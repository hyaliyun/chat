import{_,o as s,c as n,a as t,m,t as d,C as h,M as g,U as b,f as l,F as x,p as y,e as v,q as w}from"./chunks/framework.B1z0IdBH.js";const q={name:"PoemCard",props:{poem:{type:Object,required:!0}}},k={class:"poem-container"},T={class:"review"},L={class:"review-title"},N={class:"review-content"};function A(r,e,u,c,i,a){return s(),n("div",k,[t("div",T,[t("div",L,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),m(d(u.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",N,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),m(d(u.poem.solution),1)])])])}const R=_(q,[["render",A],["__scopeId","data-v-bd98e645"]]),S=JSON.parse(`[{"question":"def submatrix_sum(matrix, upper_left, lower_right): Returns the sum of all elements in the specified submatrix. Parameters: - matrix: list of lists of integers representing the n x m matrix. - upper_left: tuple of integers representing the upper-left corner of submatrix (row, column). - lower_right: tuple of integers representing the lower-right corner of submatrix (row, column). Returns: - Sum of all elements in the specified submatrix. pass # Unit Tests def test_submatrix_sum_example1(): matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] upper_left = (1, 1) lower_right = (2, 2) assert submatrix_sum(matrix, upper_left, lower_right) == 34 def test_submatrix_sum_example2(): matrix = [ [5, 3, 8], [1, 6, 7], [4, 2, 9] ] upper_left = (0, 0) lower_right = (2, 1) assert submatrix_sum(matrix, upper_left, lower_right) == 21 def test_submatrix_sum_single_element(): matrix = [ [5, 3, 8], [1, 6, 7], [4, 2, 9] ] upper_left = (1, 1) lower_right = (1, 1) assert submatrix_sum(matrix, upper_left, lower_right) == 6 def test_submatrix_sum_entire_matrix(): matrix = [ [1, 2], [3, 4] ] upper_left = (0, 0) lower_right = (1, 1) assert submatrix_sum(matrix, upper_left, lower_right) == 10 def test_submatrix_sum_top_left_corner(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] upper_left = (0, 0) lower_right = (1, 1) assert submatrix_sum(matrix, upper_left, lower_right) == 12 def test_submatrix_sum_bottom_right_corner(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] upper_left = (1, 1) lower_right = (2, 2) assert submatrix_sum(matrix, upper_left, lower_right) == 28","solution":"def submatrix_sum(matrix, upper_left, lower_right): Returns the sum of all elements in the specified submatrix. Parameters: - matrix: list of lists of integers representing the n x m matrix. - upper_left: tuple of integers representing the upper-left corner of submatrix (row, column). - lower_right: tuple of integers representing the lower-right corner of submatrix (row, column). Returns: - Sum of all elements in the specified submatrix. sum_elements = 0 start_row, start_col = upper_left end_row, end_col = lower_right for i in range(start_row, end_row + 1): for j in range(start_col, end_col + 1): sum_elements += matrix[i][j] return sum_elements"},{"question":"def can_schedule_games(N, M, restricted_pairs): Determines whether it is possible to create a valid schedule given the limitations. Parameters: N (int): The number of players. M (int): The number of restricted pairs. restricted_pairs (list of tuples): List of pairs which indicate restricted matches. Returns: str: \\"YES\\" if a valid schedule can be created, otherwise \\"NO\\". def test_can_schedule_games_example1(): N = 4 M = 2 restricted_pairs = [(1, 2), (3, 4)] assert can_schedule_games(N, M, restricted_pairs) == \\"YES\\" def test_can_schedule_games_example2(): N = 4 M = 3 restricted_pairs = [(1, 2), (2, 3), (3, 1)] assert can_schedule_games(N, M, restricted_pairs) == \\"NO\\" def test_no_restrictions(): N = 5 M = 0 restricted_pairs = [] assert can_schedule_games(N, M, restricted_pairs) == \\"YES\\" def test_all_pairs_restricted(): N = 3 M = 3 restricted_pairs = [(1, 2), (2, 3), (3, 1)] assert can_schedule_games(N, M, restricted_pairs) == \\"NO\\" def test_large_input(): N = 1000 M = 1 restricted_pairs = [(1, 2)] assert can_schedule_games(N, M, restricted_pairs) == \\"YES\\" def test_unconnected_graph(): N = 6 M = 4 restricted_pairs = [(1, 2), (3, 4), (5, 6), (2, 3)] assert can_schedule_games(N, M, restricted_pairs) == \\"YES\\"","solution":"def can_schedule_games(N, M, restricted_pairs): Determines whether it is possible to create a valid schedule given the limitations. Parameters: N (int): The number of players. M (int): The number of restricted pairs. restricted_pairs (list of tuples): List of pairs which indicate restricted matches. Returns: str: \\"YES\\" if a valid schedule can be created, otherwise \\"NO\\". from collections import defaultdict, deque # Create a graph adjacency list graph = defaultdict(list) for u, v in restricted_pairs: graph[u].append(v) graph[v].append(u) # Use coloring to determine if the graph is bipartite. color = {} def bfs(start): queue = deque([start]) color[start] = 0 while queue: node = queue.popleft() current_color = color[node] for neighbor in graph[node]: if neighbor not in color: color[neighbor] = 1 - current_color queue.append(neighbor) elif color[neighbor] == current_color: return False return True # Check for each component in the graph for player in range(1, N + 1): if player not in color: if not bfs(player): return \\"NO\\" return \\"YES\\""},{"question":"def minimum_remaining_element(arr): Returns the minimum possible value of the remaining element after performing n-1 operations. >>> minimum_remaining_element([1, 2, 3, 4]) 10 >>> minimum_remaining_element([5, 8, 6]) 19 >>> minimum_remaining_element([100, 200]) 300","solution":"def minimum_remaining_element(arr): Returns the minimum possible value of the remaining element after performing n-1 operations. return sum(arr)"},{"question":"from typing import List def process_commands(commands: List[str]) -> List[str]: Processes a list of commands on a grid and returns the state of light bulbs for each query command. Parameters: commands (List[str]): List of command strings in the format 'L x y', 'T x y', 'Q x y' Returns: List[str]: List of results for each query in the order they appeared, each one being \\"ON\\" or \\"OFF\\" Examples: >>> process_commands([\\"L 1 2\\", \\"Q 1 2\\", \\"T 1 2\\", \\"Q 1 2\\", \\"L 3 4\\", \\"Q 3 4\\"]) [\\"ON\\", \\"OFF\\", \\"ON\\"] >>> process_commands([\\"L 0 0\\", \\"T 0 0\\", \\"Q 0 0\\", \\"T 0 0\\", \\"Q 0 0\\"]) [\\"OFF\\", \\"ON\\"] pass def test_basic_commands(): commands = [ \\"L 1 2\\", \\"Q 1 2\\", \\"T 1 2\\", \\"Q 1 2\\", \\"L 3 4\\", \\"Q 3 4\\" ] assert process_commands(commands) == [\\"ON\\", \\"OFF\\", \\"ON\\"] def test_toggle_same_position(): commands = [ \\"L 0 0\\", \\"T 0 0\\", \\"Q 0 0\\", \\"T 0 0\\", \\"Q 0 0\\" ] assert process_commands(commands) == [\\"OFF\\", \\"ON\\"] def test_query_without_light(): commands = [ \\"Q 5 5\\", \\"L 5 5\\", \\"Q 5 5\\", \\"T 5 5\\", \\"Q 5 5\\" ] assert process_commands(commands) == [\\"OFF\\", \\"ON\\", \\"OFF\\"] def test_multiple_toggles(): commands = [ \\"L 1 1\\", \\"T 1 1\\", \\"T 1 1\\", \\"Q 1 1\\", \\"T 1 1\\", \\"Q 1 1\\" ] assert process_commands(commands) == [\\"ON\\", \\"OFF\\"]","solution":"def process_commands(commands): Processes a list of commands on a grid and returns the state of light bulbs for each query command. Parameters: commands (List[str]): List of command strings in the format 'L x y', 'T x y', 'Q x y' Returns: List[str]: List of results for each query in the order they appeared, each one being \\"ON\\" or \\"OFF\\" grid = {} results = [] for command in commands: parts = command.split() cmd = parts[0] x, y = int(parts[1]), int(parts[2]) key = (x, y) if cmd == 'L': grid[key] = True elif cmd == 'T': if key in grid and grid[key] == True: grid[key] = False else: grid[key] = True elif cmd == 'Q': if key in grid and grid[key] == True: results.append(\\"ON\\") else: results.append(\\"OFF\\") return results"},{"question":"def find_two_sum_indices(numbers: List[int], target: int) -> Tuple[int, int]: Find two indices of numbers in the list such that their sum is equal to the target value. Assumes exactly one solution exists and each element is used only once. Args: numbers (list of int): The list of numbers. target (int): The target sum value. Returns: tuple of int: A tuple containing indices of the two numbers. pass def test_example_1(): assert find_two_sum_indices([2, 7, 11, 15, 1], 9) == (0, 1) def test_example_2(): assert find_two_sum_indices([3, 2, 4], 6) == (1, 2) def test_negative_numbers(): assert find_two_sum_indices([-1, -2, -3, -4], -5) == (1, 2) def test_large_numbers(): assert find_two_sum_indices([1000000000, 2000000000, 1500000000], 3500000000) == (1, 2) def test_mix_sign_numbers(): assert find_two_sum_indices([-10, 20, 10], 0) == (0, 2) def test_first_last_pair(): assert find_two_sum_indices([1, 4, 5, 6], 7) == (0, 3)","solution":"def find_two_sum_indices(numbers, target): Find two indices of numbers in the list such that their sum is equal to the target value. Assumes exactly one solution exists and each element is used only once. Args: numbers (list of int): The list of numbers. target (int): The target sum value. Returns: tuple of int: A tuple containing indices of the two numbers. number_to_index = {} for i, num in enumerate(numbers): complement = target - num if complement in number_to_index: return (number_to_index[complement], i) number_to_index[num] = i return None # Should not reach here as per problem statement"},{"question":"from typing import List def longest_contiguous_subarray(arr: List[int]) -> int: Given a list of integers, find the length of the longest subarray that forms a contiguous block of integers (i.e., the elements can be rearranged to form a consecutive sequence of integers). >>> longest_contiguous_subarray([1, 2, 3, 5, 6]) 3 >>> longest_contiguous_subarray([4, 2, 1, 6, 5]) 3 >>> longest_contiguous_subarray([8, 6, 9, 7, 10, 12]) 5 >>> longest_contiguous_subarray([1, 1, 1, 1]) 1 >>> longest_contiguous_subarray([10, 11, 14, 15, 12, 13, 16]) 7 >>> longest_contiguous_subarray([]) 0 >>> longest_contiguous_subarray([10]) 1 >>> longest_contiguous_subarray([-1, -2, -3, -5, -4]) 5 >>> longest_contiguous_subarray([10, 12, 11, 0, -1]) 3 >>> longest_contiguous_subarray([1, 3, 2, 6, 4, 5]) 6","solution":"def longest_contiguous_subarray(arr): if not arr: return 0 arr.sort() max_length = 1 current_length = 1 for i in range(1, len(arr)): if arr[i] == arr[i - 1] + 1: current_length += 1 elif arr[i] != arr[i - 1]: current_length = 1 max_length = max(max_length, current_length) return max_length"},{"question":"def total_elevation_gain(n: int, heights: List[int]) -> int: Calculate the total elevation gain from a list of segment heights. Arguments: n -- integer, number of segments heights -- list of integers, heights of each segment Returns: integer, total elevation gain >>> total_elevation_gain(5, [1, 5, 3, 6, 4]) 7 >>> total_elevation_gain(3, [4, 4, 4]) 0 >>> total_elevation_gain(4, [2, 4, 6, 8]) 6 from solution import total_elevation_gain def test_total_elevation_gain(): # Test with provided example cases assert total_elevation_gain(5, [1, 5, 3, 6, 4]) == 7 assert total_elevation_gain(3, [4, 4, 4]) == 0 assert total_elevation_gain(4, [2, 4, 6, 8]) == 6 # Additional tests assert total_elevation_gain(2, [1, 2]) == 1 # Minimum size case assert total_elevation_gain(6, [6, 5, 6, 5, 6, 5]) == 2 # Alternating heights assert total_elevation_gain(5, [5, 4, 3, 2, 1]) == 0 # All decreasing assert total_elevation_gain(5, [1000000000, 999999999, 1000000000, 1, 1000000000]) == (1 + 999999999) # High values def test_total_elevation_gain_edge_cases(): # Edge case with all heights the same assert total_elevation_gain(6, [7, 7, 7, 7, 7, 7]) == 0 # Edge case with all heights increasing by 1 assert total_elevation_gain(5, [1, 2, 3, 4, 5]) == 4 # Edge case with random heights assert total_elevation_gain(7, [10, 15, 12, 20, 25, 18, 30]) == (5 + 8 + 5 + 12)","solution":"def total_elevation_gain(n, heights): Calculate the total elevation gain from a list of segment heights. Arguments: n -- integer, number of segments heights -- list of integers, heights of each segment Returns: integer, total elevation gain elevation_gain = 0 for i in range(1, n): if heights[i] > heights[i - 1]: elevation_gain += heights[i] - heights[i - 1] return elevation_gain"},{"question":"def longest_consecutive_subsequence(sequence: List[int]) -> int: Returns the length of the longest subsequence of consecutive numbers in the list. >>> longest_consecutive_subsequence([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive_subsequence([1, 2, 3, 4]) 4 >>> longest_consecutive_subsequence([10, 5, 15, 20, 25]) 1","solution":"def longest_consecutive_subsequence(sequence): Returns the length of the longest subsequence of consecutive numbers in the list. if not sequence: return 0 num_set = set(sequence) longest = 0 for num in num_set: if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest = max(longest, current_streak) return longest"},{"question":"def can_all_characters_carry_items(n: int, weight_limits: List[int], m: int, item_weights: List[int]) -> str: Determine if all characters can carry the items assigned to them in the specified order without exceeding their limits. Args: n (int): The number of characters. weight_limits (List[int]): The maximum weight limit each character can carry. m (int): The number of items. item_weights (List[int]): The weights of the items in the specified order. Returns: str: \\"YES\\" if all characters can carry their items without exceeding their limits, otherwise \\"NO\\". Examples: >>> can_all_characters_carry_items(2, [5, 10], 4, [2, 2, 4, 3]) \\"YES\\" >>> can_all_characters_carry_items(3, [3, 5, 2], 5, [2, 2, 2, 2, 2]) \\"NO\\" >>> can_all_characters_carry_items(1, [10], 3, [3, 2, 6]) \\"NO\\"","solution":"def can_all_characters_carry_items(n, weight_limits, m, item_weights): current_character = 0 current_weight = 0 for item_weight in item_weights: if current_weight + item_weight <= weight_limits[current_character]: current_weight += item_weight else: current_character += 1 if current_character >= n: return \\"NO\\" current_weight = item_weight if current_weight > weight_limits[current_character]: return \\"NO\\" return \\"YES\\""},{"question":"from typing import List def generate_series(n: int) -> List[int]: Generate a list of integers following the pattern: 0, -1, 2, -3, 4, -5, 6, -7, 8, -9, ... Args: n (int): number of terms to generate Returns: List[int]: list of n integers following the series pattern. >>> generate_series(5) [0, -1, 2, -3, 4] >>> generate_series(10) [0, -1, 2, -3, 4, -5, 6, -7, 8, -9] >>> generate_series(1) [0]","solution":"from typing import List def generate_series(n: int) -> List[int]: Generate a list of integers following the pattern: 0, -1, 2, -3, 4, -5, 6, -7, 8, -9, ... Args: n (int): number of terms to generate Returns: List[int]: list of n integers following the series pattern. return [(i if i % 2 == 0 else -i) for i in range(n)]"},{"question":"def get_monster_removal_order(n: int, healths: List[int]) -> List[int]: Returns the order in which monsters are removed from the line. >>> get_monster_removal_order(3, [3, 1, 2]) [2, 3, 1] >>> get_monster_removal_order(4, [4, 2, 3, 1]) [4, 2, 3, 1]","solution":"def get_monster_removal_order(n, healths): Returns the order in which monsters are removed from the line. order_of_removal = [] index = 0 # Convert healths to list of tuples (index, health) healths_with_index = [(i+1, health) for i, health in enumerate(healths)] while healths_with_index: # Decrease the health of the current monster monster_index, monster_health = healths_with_index[index] monster_health -= 1 if monster_health <= 0: # If the monster's health is 0 or less, remove it and add its index to the removal order order_of_removal.append(monster_index) healths_with_index.pop(index) # Update index as the current monster is removed index = index % len(healths_with_index) if healths_with_index else 0 else: # If the monster is not removed, update its health and move to the next monster healths_with_index[index] = (monster_index, monster_health) index = (index + 1) % len(healths_with_index) return order_of_removal # Example: n = 3 healths = [3, 1, 2] print(get_monster_removal_order(n, healths)) # Output: [2, 3, 1]"},{"question":"def min_warehouses(test_cases): Determine the minimum number of warehouses needed such that every city either has a warehouse or is directly connected to a city with a warehouse. Args: test_cases (List[Tuple[int, int, List[Tuple[int, int]]]]): List of test cases, where each test case is represented as a tuple (N, M, edges). Returns: List[int]: List of integers representing the minimum number of warehouses needed for each test case. Example: >>> test_cases = [(3, 3, [(1, 2), (2, 3), (3, 1)]), (4, 3, [(1, 2), (2, 3), (3, 4)])] >>> min_warehouses(test_cases) [1, 2] from typing import List, Tuple # Example of how to use the function for given inputs def test_min_warehouses(): test_cases = [ (3, 3, [(1, 2), (2, 3), (3, 1)]), (4, 3, [(1, 2), (2, 3), (3, 4)]) ] assert min_warehouses(test_cases) == [1, 2] test_cases = [ (2, 1, [(1, 2)]), (3, 2, [(1, 2), (2, 3)]), (4, 2, [(1, 2), (3, 4)]) ] assert min_warehouses(test_cases) == [1, 1, 2]","solution":"def min_warehouses(test_cases): def greedy_vertex_cover(n, edges): # Adjacency list representation adjacency_list = [[] for _ in range(n)] for u, v in edges: adjacency_list[u-1].append(v-1) adjacency_list[v-1].append(u-1) visited = [False] * n warehouses = 0 for u in range(n): if not visited[u]: for v in adjacency_list[u]: if not visited[v]: visited[v] = True visited[u] = True warehouses += 1 break return warehouses results = [] for (N, M, edges) in test_cases: results.append(greedy_vertex_cover(N, edges)) return results # Example of how to use the function for given inputs test_cases = [ (3, 3, [(1, 2), (2, 3), (3, 1)]), (4, 3, [(1, 2), (2, 3), (3, 4)]) ] print(min_warehouses(test_cases)) # Output: [1, 2] # Function to read multiple test cases def read_test_cases(input_str): input_data = input_str.strip().split('n') T = int(input_data[0]) test_cases = [] index = 1 for _ in range(T): N, M = map(int, input_data[index].split()) edges = [tuple(map(int, input_data[index + i + 1].split())) for i in range(M)] test_cases.append((N, M, edges)) index += M + 1 return test_cases"},{"question":"def merge_intervals(intervals): Merges overlapping intervals in a list of intervals. Args: intervals (list of tuples): A list where each tuple represents an interval as (start, end) Returns: list of tuples: A list of merged intervals sorted by the start time. pass from solution import merge_intervals def test_no_intervals(): assert merge_intervals([]) == [] def test_no_overlap(): assert merge_intervals([(1, 2), (3, 4), (5, 6)]) == [(1, 2), (3, 4), (5, 6)] def test_complete_overlap(): assert merge_intervals([(1, 3), (2, 6), (8, 10), (15, 18)]) == [(1, 6), (8, 10), (15, 18)] def test_touching_intervals(): assert merge_intervals([(1, 4), (4, 5)]) == [(1, 5)] def test_complex_merge(): assert merge_intervals([(1, 4), (2, 6), (8, 10), (7, 9), (15, 18), (16, 17)]) == [(1, 6), (7, 10), (15, 18)] def test_unordered_intervals(): assert merge_intervals([(8, 10), (1, 3), (2, 6), (15, 18)]) == [(1, 6), (8, 10), (15, 18)] def test_single_interval(): assert merge_intervals([(1, 5)]) == [(1, 5)]","solution":"def merge_intervals(intervals): Merges overlapping intervals in a list of intervals. Args: intervals (list of tuples): A list where each tuple represents an interval as (start, end) Returns: list of tuples: A list of merged intervals sorted by the start time. if not intervals: return [] intervals.sort(key=lambda x: x[0]) merged = [intervals[0]] for current in intervals[1:]: last_merged = merged[-1] if current[0] <= last_merged[1]: merged[-1] = (last_merged[0], max(last_merged[1], current[1])) else: merged.append(current) return merged"},{"question":"def max_golden_fruits(n: int, fruits: List[int], untraversable: List[bool]) -> int: Determine the maximum number of golden fruits Algorithmus can collect on a valid path from west to east. Arguments: n: An integer, the number of trees in the orchard. fruits: An array of integers, where the i-th integer represents the number of golden fruits on the i-th tree. untraversable: An array of boolean values, where the i-th value is true if the i-th tree is untraversable, and false otherwise. Returns: An integer, the maximum number of golden fruits collected. >>> max_golden_fruits(5, [2, 3, 1, 5, 4], [False, False, True, False, False]) 14 >>> max_golden_fruits(5, [2, 3, 1, 5, 4], [False, False, False, False, False]) 15 >>> max_golden_fruits(5, [2, 3, 1, 5, 4], [True, True, True, True, True]) 0 >>> max_golden_fruits(4, [1, 2, 3, 4], [True, False, False, False]) 0","solution":"def max_golden_fruits(n, fruits, untraversable): if untraversable[0]: return 0 dp = [0] * n dp[0] = fruits[0] for i in range(1, n): if not untraversable[i]: if untraversable[i - 1]: dp[i] = dp[i - 2] + fruits[i] if i - 2 >= 0 else fruits[i] else: dp[i] = dp[i - 1] + fruits[i] return max(dp) # Example usage: # n = 5 # fruits = [2, 3, 1, 5, 4] # untraversable = [False, False, True, False, False] # print(max_golden_fruits(n, fruits, untraversable)) # Output: 14"},{"question":"def min_replacements_to_palindrome(s: str) -> int: Calculate the minimum number of character replacements needed to make the string a palindrome. Parameters: s (str): The input string. Returns: int: Minimum number of replacements needed. >>> min_replacements_to_palindrome('a') 0 >>> min_replacements_to_palindrome('aa') 0 >>> min_replacements_to_palindrome('ab') 1 >>> min_replacements_to_palindrome('abba') 0 >>> min_replacements_to_palindrome('abca') 1 >>> min_replacements_to_palindrome('racecar') 0 >>> min_replacements_to_palindrome('racefar') 1 >>> min_replacements_to_palindrome('a' * 50000 + 'b' * 50000) 50000 >>> min_replacements_to_palindrome('abcdcba') 0 >>> min_replacements_to_palindrome('abcde') 2","solution":"def min_replacements_to_palindrome(s): Calculate the minimum number of character replacements needed to make the string a palindrome. Parameters: s (str): The input string. Returns: int: Minimum number of replacements needed. left, right = 0, len(s) - 1 replacements = 0 while left < right: if s[left] != s[right]: replacements += 1 left += 1 right -= 1 return replacements"},{"question":"def has_zero_sum_subsequence(n: int, seq: List[int]) -> str: Determine if there is a non-empty contiguous subsequence that sums to 0. :param n: Number of elements in the sequence :param seq: List of integers in the sequence :return: \\"YES\\" if such a subsequence exists, otherwise \\"NO\\" >>> has_zero_sum_subsequence(5, [4, -1, 2, -3, 1]) == \\"YES\\" >>> has_zero_sum_subsequence(5, [1, 2, 3, 4, 5]) == \\"NO\\" >>> has_zero_sum_subsequence(1, [0]) == \\"YES\\" >>> has_zero_sum_subsequence(1, [7]) == \\"NO\\" >>> has_zero_sum_subsequence(4, [10**9, -10**9, 10**9, -10**9]) == \\"YES\\" >>> has_zero_sum_subsequence(5, [-1, -2, -3, -4, 10]) == \\"YES\\" >>> has_zero_sum_subsequence(3, [1, 2, 3]) == \\"NO\\" >>> has_zero_sum_subsequence(6, [1, 2, -3, 1, 2, -3]) == \\"YES\\" pass","solution":"def has_zero_sum_subsequence(n, seq): Determine if there is a non-empty contiguous subsequence that sums to 0. :param n: Number of elements in the sequence :param seq: List of integers in the sequence :return: \\"YES\\" if such a subsequence exists, otherwise \\"NO\\" prefix_sums = set() current_sum = 0 for num in seq: current_sum += num if current_sum == 0 or current_sum in prefix_sums: return \\"YES\\" prefix_sums.add(current_sum) return \\"NO\\""},{"question":"def lexicographically_smallest_c(n: int, a: List[int], b: List[int]) -> List[int]: Find the lexicographically smallest array c of length n such that: c_i is the maximum of any one element from array a and any one element from array b. Parameters: n (int): the size of the arrays a (List[int]): the elements of the array a b (List[int]): the elements of the array b Returns: List[int]: the lexicographically smallest array c Examples: >>> lexicographically_smallest_c(3, [1, 2, 3], [3, 2, 1]) [3, 2, 3] >>> lexicographically_smallest_c(4, [5, 1, 4, 7], [3, 4, 5, 2]) [5, 4, 5, 7]","solution":"def lexicographically_smallest_c(n, a, b): Returns the lexicographically smallest array c of length n such that: c_i = max(a[x], b[y]), where x and y can be different indices for each i. c = [] for i in range(n): c.append(max(a[i], b[i])) return c # Main function for debugging with input if __name__ == \\"__main__\\": n = int(input().strip()) a = list(map(int, input().strip().split())) b = list(map(int, input().strip().split())) result = lexicographically_smallest_c(n, a, b) print(\\" \\".join(map(str, result)))"},{"question":"def max_subarray_sum_with_one_removal(arr): Calculate the maximum possible sum of a contiguous subarray with the constraint that at most one element can be removed. >>> max_subarray_sum_with_one_removal([1, -2, 0, 3, 2]) 6 >>> max_subarray_sum_with_one_removal([-1, -1, -1]) -1 >>> max_subarray_sum_with_one_removal([1, 2, 3, 4, 5]) 15 >>> max_subarray_sum_with_one_removal([-1, 2, 3, 4, -5]) 9 >>> max_subarray_sum_with_one_removal([0, -1, 3, -2, 4, -1]) 7 >>> max_subarray_sum_with_one_removal([1, -1, 1]) 2 >>> max_subarray_sum_with_one_removal([-2, -3, 4, -1, -2, 1, 5, -3]) 9 pass","solution":"def max_subarray_sum_with_one_removal(arr): n = len(arr) if n == 0: return 0 if n == 1: return arr[0] max_ending_here = [0] * n max_starting_here = [0] * n # Calculate maximum subarray sum ending at every index max_ending_here[0] = arr[0] for i in range(1, n): max_ending_here[i] = max(arr[i], max_ending_here[i - 1] + arr[i]) # Calculate maximum subarray sum starting at every index max_starting_here[-1] = arr[-1] for i in range(n - 2, -1, -1): max_starting_here[i] = max(arr[i], max_starting_here[i + 1] + arr[i]) # Now, calculate the max possible sum without removing any element max_sum = max(max_ending_here) # Calculate max possible sum with removing one element for i in range(1, n - 1): max_sum = max(max_sum, max_ending_here[i - 1] + max_starting_here[i + 1]) return max_sum"},{"question":"def find_missing_numbers(arr): Write a function that receives an array of positive integers and returns the missing number(s) from the sequence. The function should find all the missing numbers and return them as an array sorted in ascending order. Parameters: arr (list): A list of positive integers. Returns: list: A list of missing integer numbers, sorted in ascending order. >>> find_missing_numbers([1, 2, 4, 6]) [3, 5] >>> find_missing_numbers([3, 7, 1, 2, 8, 4, 5]) [6] >>> find_missing_numbers([10, 12, 11, 14]) [13] >>> find_missing_numbers([1, 2, 3, 4, 5]) [] from solution import find_missing_numbers def test_find_missing_numbers_case1(): assert find_missing_numbers([1, 2, 4, 6]) == [3, 5] def test_find_missing_numbers_case2(): assert find_missing_numbers([3, 7, 1, 2, 8, 4, 5]) == [6] def test_find_missing_numbers_case3(): assert find_missing_numbers([10, 12, 11, 14]) == [13] def test_find_missing_numbers_case4(): assert find_missing_numbers([1, 2, 3, 4, 5]) == [] def test_find_missing_numbers_empty_array(): assert find_missing_numbers([]) == [] def test_find_missing_numbers_single_element(): assert find_missing_numbers([5]) == []","solution":"def find_missing_numbers(arr): This function takes a list of positive integers and returns a list of missing numbers in the sequence, sorted in ascending order. Parameters: arr (list): A list of positive integers. Returns: list: A list of missing integer numbers, sorted in ascending order. if not arr: return [] min_num = min(arr) max_num = max(arr) full_set = set(range(min_num, max_num + 1)) arr_set = set(arr) missing_numbers = sorted(list(full_set - arr_set)) return missing_numbers"},{"question":"from typing import List def findSmallestMissingPositive(nums: List[int]) -> int: Given an array of integers, find the smallest missing positive integer. Args: nums (List[int]): Array of integers. Returns: int: The smallest missing positive integer. Examples: >>> findSmallestMissingPositive([1, 2, 0]) 3 >>> findSmallestMissingPositive([3, 4, -1, 1]) 2 >>> findSmallestMissingPositive([7, 8, 9, 11, 12]) 1 pass","solution":"from typing import List def findSmallestMissingPositive(nums: List[int]) -> int: n = len(nums) # Helper function to place numbers in their respective positions def place_numbers(): for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] place_numbers() # Finding the smallest missing positive number for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"def min_buses_required(t: int, departments: List[Tuple[int, int]]) -> List[int]: This function calculates the minimum number of buses required for each department. :param t: The number of departments :param departments: A list of tuples where each tuple contains two integers, the number of employees in the department and the maximum capacity of each bus. :return: A list of integers where each integer represents the minimum number of buses required >>> min_buses_required(3, [(10, 4), (15, 5), (7, 2)]) [3, 3, 4] >>> min_buses_required(1, [(1000, 1000)]) [1] pass from typing import List, Tuple def test_min_buses_required(): assert min_buses_required(3, [(10, 4), (15, 5), (7, 2)]) == [3, 3, 4] assert min_buses_required(1, [(1000, 1000)]) == [1] assert min_buses_required(2, [(20, 3), (50, 10)]) == [7, 5] assert min_buses_required(5, [(1, 1), (100, 10), (10, 1), (99, 33), (500, 100)]) == [1, 10, 10, 3, 5] def test_min_buses_required_edge_cases(): assert min_buses_required(3, [(1, 1), (1, 2), (1, 3)]) == [1, 1, 1] assert min_buses_required(3, [(2, 1), (2, 2), (2, 3)]) == [2, 1, 1] assert min_buses_required(3, [(1000, 1), (1000, 1000), (1000, 500)]) == [1000, 1, 2] def test_min_buses_required_large_input(): assert min_buses_required(100, [(1000, 999)] * 100) == [2] * 100 assert min_buses_required(100, [(999, 1000)] * 100) == [1] * 100","solution":"def min_buses_required(t, departments): This function calculates the minimum number of buses required for each department. :param t: The number of departments :param departments: A list of tuples where each tuple contains two integers, the number of employees in the department and the maximum capacity of each bus. :return: A list of integers where each integer represents the minimum number of buses required results = [] for n, k in departments: # Calculate the minimum number of buses required buses = (n + k - 1) // k results.append(buses) return results"},{"question":"from typing import List, Tuple def min_steps_each_robot(N: int, M: int, grid: List[str], robots: List[Tuple[int, int, int, int]]) -> List[int]: Determine the minimum steps required for each robot to reach its end position from its start position, or -1 if it is impossible. Args: N (int): The number of rows in the grid. M (int): The number of columns in the grid. grid (List[str]): The NxM grid where each cell can be passable ('.') or blocked ('#'). robots (List[Tuple[int, int, int, int]]): List of tuples specifying the start and end positions of each robot. Returns: List[int]: List of minimum steps required for each robot to reach its end position, or -1 if it's impossible. Examples: >>> N, M = 5, 5 >>> grid = [\\".....\\", \\".#.\\", \\".#.#.\\", \\".#.\\", \\".....\\"] >>> robots = [(0, 0, 4, 4), (2, 2, 0, 0)] >>> min_steps_each_robot(N, M, grid, robots) [8, -1] >>> N, M = 3, 3 >>> grid = [\\"...\\", \\".#.\\", \\"...\\"] >>> robots = [(0, 0, 1, 1)] >>> min_steps_each_robot(N, M, grid, robots) [-1] >>> N, M = 10, 10 >>> grid = [\\"..........\\" for _ in range(10)] >>> robots = [(0, 0, 9, 9)] >>> min_steps_each_robot(N, M, grid, robots) [18] >>> N, M = 5, 5 >>> grid = [\\".....\\", \\".#.\\", \\".#.#.\\", \\".#.\\", \\".....\\"] >>> robots = [(1, 1, 4, 4), (0, 0, 2, 2)] >>> min_steps_each_robot(N, M, grid, robots) [-1, -1]","solution":"from collections import deque def bfs(grid, start, end, N, M): sx, sy = start ex, ey = end if grid[sx][sy] == '#' or grid[ex][ey] == '#': return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] visited = [[False] * M for _ in range(N)] queue = deque([(sx, sy, 0)]) # (row, col, steps) visited[sx][sy] = True while queue: x, y, steps = queue.popleft() if (x, y) == (ex, ey): return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and not visited[nx][ny] and grid[nx][ny] == '.': visited[nx][ny] = True queue.append((nx, ny, steps + 1)) return -1 def min_steps_each_robot(N, M, grid, robots): results = [] for (sx, sy, ex, ey) in robots: steps = bfs(grid, (sx, sy), (ex, ey), N, M) results.append(steps) return results"},{"question":"from typing import List, Tuple def get_post_with_max_unique_likes(events: List[Tuple[int, int, int]], queries: List[Tuple[int, int]]) -> List[int]: Determine the post with the highest number of unique users who liked it within a given time interval. Parameters: events (List[Tuple[int, int, int]]): A list of tuples, each containing user_id, post_id, and timestamp for each like event. queries (List[Tuple[int, int]]): A list of tuples, each containing the start_time and end_time for each query. Returns: List[int]: A list of post_ids with the highest number of unique users who liked it within the given time intervals, for each query. >>> events = [(1, 100, 10), (2, 100, 15), (3, 101, 20), (1, 101, 22), (2, 102, 25), (3, 102, 30), (4, 103, 35)] >>> queries = [(10, 25), (15, 35)] >>> get_post_with_max_unique_likes(events, queries) [100, 101]","solution":"def get_post_with_max_unique_likes(events, queries): from collections import defaultdict import heapq posts_likes = defaultdict(lambda: defaultdict(set)) for user_id, post_id, timestamp in events: posts_likes[post_id][timestamp].add(user_id) results = [] for start, end in queries: post_unique_users = defaultdict(set) for post_id in posts_likes: for timestamp in posts_likes[post_id]: if start <= timestamp <= end: post_unique_users[post_id].update(posts_likes[post_id][timestamp]) max_unique = -1 post_with_max_unique = None for post_id in post_unique_users: unique_count = len(post_unique_users[post_id]) if unique_count > max_unique or (unique_count == max_unique and (post_with_max_unique is None or post_id < post_with_max_unique)): max_unique = unique_count post_with_max_unique = post_id results.append(post_with_max_unique) return results"},{"question":"from typing import List, Tuple def preprocess_grid(grid: List[List[int]]) -> List[List[int]]: Preprocess the grid to create a prefix sum matrix. pass def query_sum(prefix_sum: List[List[int]], x1: int, y1: int, x2: int, y2: int) -> int: Query the sum of the sub-grid defined by (x1, y1) to (x2, y2). pass def handle_queries(grid: List[List[int]], queries: List[Tuple[int, int, int, int]]) -> List[int]: Handle multiple queries on the grid. pass def test_preprocess_grid(): grid = [ [1, 2, 4], [8, 16, 32], [64, 128, 256] ] expected_prefix_sum = [ [0, 0, 0, 0], [0, 1, 3, 7], [0, 9, 27, 63], [0, 73, 219, 511] ] assert preprocess_grid(grid) == expected_prefix_sum def test_query_sum(): prefix_sum = [ [0, 0, 0, 0], [0, 1, 3, 7], [0, 9, 27, 63], [0, 73, 219, 511] ] assert query_sum(prefix_sum, 1, 1, 2, 2) == 27 assert query_sum(prefix_sum, 2, 2, 3, 3) == 432 def test_handle_queries(): grid = [ [1, 2, 4], [8, 16, 32], [64, 128, 256] ] queries = [ (1, 1, 2, 2), (2, 2, 3, 3) ] assert handle_queries(grid, queries) == [27, 432]","solution":"def preprocess_grid(grid): Preprocess the grid to create a prefix sum matrix. n = len(grid) m = len(grid[0]) prefix_sum = [[0] * (m + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, m + 1): prefix_sum[i][j] = (grid[i-1][j-1] + prefix_sum[i-1][j] + prefix_sum[i][j-1] - prefix_sum[i-1][j-1]) return prefix_sum def query_sum(prefix_sum, x1, y1, x2, y2): Query the sum of the sub-grid defined by (x1, y1) to (x2, y2). Adjust indices to 1-based. x1, y1, x2, y2 = x1 - 1, y1 - 1, x2, y2 return (prefix_sum[x2][y2] - prefix_sum[x1][y2] - prefix_sum[x2][y1] + prefix_sum[x1][y1]) def handle_queries(grid, queries): Handle multiple queries on the grid. prefix_sum = preprocess_grid(grid) result = [] for x1, y1, x2, y2 in queries: result.append(query_sum(prefix_sum, x1, y1, x2, y2)) return result"},{"question":"def min_distance(s1: str, s2: str) -> int: Determines the minimum number of operations required to transform string s1 into string s2. The operations allowed are: - Insert a character - Delete a character - Replace a character Args: s1 (str): The source string. s2 (str): The target string. Returns: int: The minimum number of operations. >>> min_distance(\\"horse\\", \\"ros\\") 3 >>> min_distance(\\"intention\\", \\"execution\\") 5","solution":"def min_distance(s1, s2): Determines the minimum number of operations required to transform string s1 into string s2. Args: s1 (str): The source string. s2 (str): The target string. Returns: int: The minimum number of operations. m, n = len(s1), len(s2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): dp[i][0] = i for j in range(1, n + 1): dp[0][j] = j for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) return dp[m][n]"},{"question":"def first_unique_char(s: str) -> str: Returns the first unique character in the string. A unique character is a character that appears only once in the string. If there are no unique characters, return an empty string. >>> first_unique_char(\\"hello\\") \\"h\\" >>> first_unique_char(\\"swiss\\") \\"w\\" >>> first_unique_char(\\"aabbcc\\") \\"\\"","solution":"def first_unique_char(s): Returns the first unique character in the string s. A unique character is one that appears only once in the string. If there are no unique characters, returns an empty string. char_count = {} # Count the occurrences of each character in the string for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find the first character with a count of 1 for char in s: if char_count[char] == 1: return char # If no unique character is found, return an empty string return \\"\\""},{"question":"def is_path_possible(grid: List[str]) -> str: Determine if there is a path from the top-left corner to the bottom-right corner of the grid. >>> is_path_possible([ >>> \\"OXO\\", >>> \\"OOX\\", >>> \\"OOO\\", >>> ]) \\"YES\\" >>> is_path_possible([ >>> \\"OXO\\", >>> \\"XXO\\", >>> \\"OOO\\", >>> ]) \\"NO\\"","solution":"def is_path_possible(grid): Determine if there is a path from the top-left corner to the bottom-right corner of the grid. n = len(grid) m = len(grid[0]) # Directions for movement - up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Helper function for Depth First Search def dfs(x, y, visited): # If we reach the bottom-right corner if x == n-1 and y == m-1: return True # Mark this cell as visited visited.add((x, y)) # Explore all possible directions for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == 'O' and (nx, ny) not in visited: if dfs(nx, ny, visited): return True return False # Initialize visited set and start DFS from the top-left corner visited = set() result = dfs(0, 0, visited) return \\"YES\\" if result else \\"NO\\""},{"question":"def minimum_steps_to_collect_all(N, M, garden): Find the minimum number of steps required to collect all the flowers and return to the initial position. If it is not possible to collect all the flowers or return to the starting cell, return -1. Args: N (int): Number of rows in the garden. M (int): Number of columns in the garden. garden (List[str]): Representation of the garden where '*' represents a flower, '#' represents a tree, and '.' represents empty space. Returns: int: Minimum number of steps to collect all flowers and return to the starting position, or -1 if not possible. Examples: >>> minimum_steps_to_collect_all(3, 3, [\\"*.#\\", \\".#.\\", \\"..*\\"]) 8 >>> minimum_steps_to_collect_all(3, 3, [\\"...\\", \\"...\\", \\"...\\"]) 0 >>> minimum_steps_to_collect_all(3, 3, [\\"*#.\\", \\"#\\", \\"..*\\"]) -1 def test_minimum_steps_sample(): N = 3 M = 3 garden = [\\"*.#\\", \\".#.\\", \\"..*\\"] assert minimum_steps_to_collect_all(N, M, garden) == 8 def test_minimum_steps_no_flowers(): N = 3 M = 3 garden = [\\"...\\", \\"...\\", \\"...\\"] assert minimum_steps_to_collect_all(N, M, garden) == 0 def test_minimum_steps_blocked_path(): N = 3 M = 3 garden = [\\"*#.\\", \\"#\\", \\"..*\\"] assert minimum_steps_to_collect_all(N, M, garden) == -1 def test_minimum_steps_single_flower(): N = 3 M = 3 garden = [\\"*..\\", \\"...\\", \\"...\\"] assert minimum_steps_to_collect_all(N, M, garden) == 0 # Not collecting since start cell has flower def test_minimum_steps_disconnected_areas(): N = 4 M = 4 garden = [\\"*..*\\", \\"\\", \\"*..*\\", \\"\\"] assert minimum_steps_to_collect_all(N, M, garden) == -1 def test_minimum_steps_small_grid(): N = 1 M = 1 garden = [\\".\\"] # Minimal grid without any flower assert minimum_steps_to_collect_all(N, M, garden) == 0 N = 1 M = 1 garden = [\\"*\\"] # Minimal grid with a flower assert minimum_steps_to_collect_all(N, M, garden) == 0 # Start cell has a flower import pytest pytest.main(args=[\\"-v\\"])","solution":"from collections import deque def minimum_steps_to_collect_all(N, M, garden): def within_bounds(x, y): return 0 <= x < N and 0 <= y < M def neighbors(x, y): for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if within_bounds(nx, ny) and garden[nx][ny] != '#': yield nx, ny flowers = sum(row.count('*') for row in garden) if flowers == 0: return 0 start = (0, 0) if garden[0][0] == '#': return -1 def bfs(start): queue = deque([(start, 0)]) visited = set([start]) distances = {} while queue: (x, y), dist = queue.popleft() if garden[x][y] == '*': distances[(x, y)] = dist for nx, ny in neighbors(x, y): if (nx, ny) not in visited: visited.add((nx, ny)) queue.append(((nx, ny), dist + 1)) return distances distances_from_start = bfs(start) if len(distances_from_start) != flowers: return -1 total_steps = 0 for (fx, fy), dist in distances_from_start.items(): total_steps += 2 * dist return total_steps # Example usage N = 3 M = 3 garden = [\\"*.#\\", \\".#.\\", \\"..*\\"] print(minimum_steps_to_collect_all(N, M, garden)) # Output: 8"},{"question":"def process_operations_and_queries(N: int, Q: int, K: int, A: List[int], operations: List[Tuple[int, ...]]) -> List[int]: Processes update and sum operations on an array A. Parameters: - N: The number of elements in the array A. - Q: The number of operations/queries. - K: The constant value added to each element in A. - A: The list of integers representing the array. - operations: List of tuples representing the operations/queries where each tuple can be: - (1, l, r, x) for update operation. - (2, l, r) for sum query. Returns: - A list of integers, where each integer is the result of a sum query. import pytest def test_example_case(): N = 5 Q = 5 K = 2 A = [1, 2, 3, 4, 5] operations = [ (2, 1, 3), (1, 2, 4, 1), (2, 1, 3), (1, 3, 5, -2), (2, 3, 5) ] assert process_operations_and_queries(N, Q, K, A, operations) == [12, 14, 14] def test_large_update_operation(): N = 10 Q = 2 K = 0 A = [1] * 10 operations = [ (1, 1, 10, 1), (2, 1, 10) ] assert process_operations_and_queries(N, Q, K, A, operations) == [20] def test_no_operations(): N = 5 Q = 0 K = 5 A = [0, 0, 0, 0, 0] operations = [] assert process_operations_and_queries(N, Q, K, A, operations) == [] def test_negative_updates(): N = 5 Q = 3 K = 0 A = [5, 5, 5, 5, 5] operations = [ (1, 1, 3, -5), (2, 1, 3), (2, 4, 5) ] assert process_operations_and_queries(N, Q, K, A, operations) == [0, 10] def test_sum_entire_array(): N = 5 Q = 1 K = 1 A = [1, 2, 3, 4, 5] operations = [ (2, 1, 5) ] assert process_operations_and_queries(N, Q, K, A, operations) == [20] if __name__ == \\"__main__\\": pytest.main()","solution":"def process_operations_and_queries(N, Q, K, A, operations): Processes update and sum operations on an array A. Parameters: - N: The number of elements in the array A. - Q: The number of operations/queries. - K: The constant value added to each element in A. - A: The list of integers representing the array. - operations: List of tuples representing the operations/queries where each tuple can be: - (1, l, r, x) for update operation. - (2, l, r) for sum query. Returns: - A list of integers, where each integer is the result of a sum query. A = [a + K for a in A] results = [] for op in operations: if op[0] == 1: # Update operation l, r, x = op[1] - 1, op[2] - 1, op[3] for i in range(l, r + 1): A[i] += x elif op[0] == 2: # Sum query l, r = op[1] - 1, op[2] - 1 results.append(sum(A[l:r + 1])) return results # Example usage: N = 5 Q = 5 K = 2 A = [1, 2, 3, 4, 5] operations = [ (2, 1, 3), (1, 2, 4, 1), (2, 1, 3), (1, 3, 5, -2), (2, 3, 5) ] print(process_operations_and_queries(N, Q, K, A, operations)) # Output: [12, 14, 14]"},{"question":"import datetime def checkDay(date_str: str) -> str: Determines if a given date (in the format 'YYYY-MM-DD') is a weekend or a weekday. Parameters: - date_str: A string representing the date. Returns: - \\"Weekend\\" if the date is Saturday or Sunday. - \\"Weekday\\" if the date is between Monday and Friday. - \\"Invalid date\\" if the input is not a valid date or not in the 'YYYY-MM-DD' format. >>> checkDay('2023-10-14') 'Weekend' >>> checkDay('2023-10-11') 'Weekday' >>> checkDay('2023-02-30') 'Invalid date' >>> checkDay('not-a-date') 'Invalid date'","solution":"import datetime def checkDay(date_str): Determines if a given date (in the format 'YYYY-MM-DD') is a weekend or a weekday. Parameters: - date_str: A string representing the date. Returns: - \\"Weekend\\" if the date is Saturday or Sunday. - \\"Weekday\\" if the date is between Monday and Friday. - \\"Invalid date\\" if the input is not a valid date or not in the 'YYYY-MM-DD' format. try: date_obj = datetime.datetime.strptime(date_str, '%Y-%m-%d').date() except ValueError: return \\"Invalid date\\" if date_obj.weekday() in [5, 6]: # 5: Saturday, 6: Sunday return \\"Weekend\\" else: return \\"Weekday\\""},{"question":"def calculate_duration(start: str, end: str) -> int: Given start and end times in \\"HH:MM\\" format, calculates the duration in minutes. >>> calculate_duration(\\"12:30\\", \\"14:00\\") 90 >>> calculate_duration(\\"23:45\\", \\"01:15\\") 90 >>> calculate_duration(\\"09:10\\", \\"09:15\\") 5 >>> calculate_duration(\\"00:00\\", \\"23:59\\") 1439 pass def movie_durations(times: List[Tuple[str, str]]) -> List[int]: Given a list of start and end times, returns a list of durations in minutes. >>> movie_durations([(\\"12:30\\", \\"14:00\\"), (\\"23:45\\", \\"01:15\\"), (\\"09:10\\", \\"09:15\\"), (\\"00:00\\", \\"23:59\\"), (\\"23:00\\", \\"00:30\\")]) [90, 90, 5, 1439, 90] pass def test_same_day_duration(): assert calculate_duration(\\"12:30\\", \\"14:00\\") == 90 assert calculate_duration(\\"09:10\\", \\"09:15\\") == 5 assert calculate_duration(\\"00:00\\", \\"23:59\\") == 1439 def test_next_day_duration(): assert calculate_duration(\\"23:45\\", \\"01:15\\") == 90 assert calculate_duration(\\"23:00\\", \\"00:30\\") == 90 assert calculate_duration(\\"22:00\\", \\"02:00\\") == 240 def test_movie_durations(): times = [ (\\"12:30\\", \\"14:00\\"), (\\"23:45\\", \\"01:15\\"), (\\"09:10\\", \\"09:15\\"), (\\"00:00\\", \\"23:59\\"), (\\"23:00\\", \\"00:30\\") ] expected_durations = [90, 90, 5, 1439, 90] assert movie_durations(times) == expected_durations","solution":"def calculate_duration(start, end): Given start and end times in \\"HH:MM\\" format, calculates the duration in minutes. def to_minutes(time): hours, minutes = map(int, time.split(':')) return hours * 60 + minutes start_minutes = to_minutes(start) end_minutes = to_minutes(end) if end_minutes >= start_minutes: return end_minutes - start_minutes else: # If end time is on the next day return (24 * 60 - start_minutes) + end_minutes def movie_durations(times): Given a list of start and end times, returns a list of durations in minutes. durations = [] for start, end in times: durations.append(calculate_duration(start, end)) return durations"},{"question":"def k_system_to_decimal(k: int, k_system_number: List[int]) -> int: Converts a number from a K-system to its decimal (base 10) equivalent. Parameters: k (int): The base of the K-system (2 ≤ k ≤ 10). k_system_number (list): A list of integers representing the digits in the K-system. >>> k_system_to_decimal(3, [1, 2, 1]) 16 >>> k_system_to_decimal(5, [4, 0, 3]) 103 pass def process_test_cases(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Processes multiple test cases of converting K-system numbers to decimal equivalents. Parameters: test_cases (list): A list of tuples where each tuple contains (k, k_system_number) >>> process_test_cases([(3, [1, 2, 1]), (5, [4, 0, 3])]) [16, 103] >>> process_test_cases([(2, [1, 0, 1, 1])]) [11] pass # Unit Tests def test_k_system_to_decimal_base_3(): assert k_system_to_decimal(3, [1, 2, 1]) == 16 def test_k_system_to_decimal_base_5(): assert k_system_to_decimal(5, [4, 0, 3]) == 103 def test_k_system_to_decimal_single_digit(): assert k_system_to_decimal(4, [3]) == 3 def test_k_system_to_decimal_base_2(): assert k_system_to_decimal(2, [1, 0, 1, 1]) == 11 def test_process_test_cases_multiple(): test_cases = [ (3, [1, 2, 1]), (5, [4, 0, 3]) ] assert process_test_cases(test_cases) == [16, 103] def test_process_test_cases_single_case(): assert process_test_cases([(2, [1, 0, 1, 1])]) == [11]","solution":"def k_system_to_decimal(k, k_system_number): Converts a number from a K-system to its decimal (base 10) equivalent. Parameters: k (int): The base of the K-system (2 ≤ k ≤ 10). k_system_number (list): A list of integers representing the digits in the K-system. Returns: int: The decimal equivalent of the K-system number. decimal_value = 0 k_system_number = k_system_number[::-1] for i, digit in enumerate(k_system_number): decimal_value += digit * (k ** i) return decimal_value def process_test_cases(test_cases): Processes multiple test cases of converting K-system numbers to decimal. Parameters: test_cases (list): A list of tuples where each tuple contains (k, k_system_number) Returns: list: A list of integers representing the decimal equivalents for each test case. results = [] for k, k_system_number in test_cases: results.append(k_system_to_decimal(k, k_system_number)) return results # Example usage: # test_cases = [ # (3, [1, 2, 1]), # (5, [4, 0, 3]) # ] # print(process_test_cases(test_cases)) # Output: [16, 103]"},{"question":"def solve(test_cases): Given a list of test cases, determine the maximum length of a contiguous substring containing the same character after performing at most K operations. Each test case is a tuple of the form (N, K, S). Args: test_cases (List[Tuple[int, int, str]]): List of test cases where each test case consists of: N (int): Length of the string S. K (int): Maximum number of operations allowed. S (str): The string consisting of 'A' and 'B'. Returns: List[int]: List of results for each test case, indicating the maximum length of the contiguous substring of the same character after performing at most K operations. Test cases: >>> solve([(5, 1, 'AABAB'), (4, 2, 'BBAB'), (6, 0, 'ABABAB')]) [4, 4, 1] >>> solve([(5, 2, 'AAAAA'), (5, 2, 'BBBBB')]) [5, 5] >>> solve([(6, 3, 'AAABBB'), (5, 1, 'BBBBB')]) [6, 5] >>> solve([(6, 0, 'ABABAB'), (4, 0, 'ABBA')]) [1, 2] >>> solve([(100000, 50000, 'A' * 50000 + 'B' * 50000)]) [100000]","solution":"def max_length_substring(n, k, s): def max_length_with_replacements(char): left = 0 max_length = 0 count_replacements = 0 for right in range(n): if s[right] != char: count_replacements += 1 while count_replacements > k: if s[left] != char: count_replacements -= 1 left += 1 max_length = max(max_length, right - left + 1) return max_length return max(max_length_with_replacements('A'), max_length_with_replacements('B')) def solve(test_cases): results = [] for n, k, s in test_cases: results.append(max_length_substring(n, k, s)) return results"},{"question":"def next_available_ticket_id(reserved_tickets: List[int]) -> int: Returns the smallest available ticket ID for a new reservation. Parameters: reserved_tickets (list of int): The list of currently reserved ticket IDs. Returns: int: The smallest available ticket ID. >>> next_available_ticket_id([]) == 1 >>> next_available_ticket_id([1, 2, 3, 4]) == 5 >>> next_available_ticket_id([3, 5, 1, 2]) == 4 >>> next_available_ticket_id([6, 4, 2, 1]) == 3 >>> next_available_ticket_id([1, 1000000]) == 2 >>> next_available_ticket_id([2, 3, 4, 5]) == 1","solution":"def next_available_ticket_id(reserved_tickets): Returns the smallest available ticket ID for a new reservation. Parameters: reserved_tickets (list of int): The list of currently reserved ticket IDs. Returns: int: The smallest available ticket ID. if not reserved_tickets: return 1 reserved_set = set(reserved_tickets) i = 1 while i in reserved_set: i += 1 return i"},{"question":"from typing import List, Tuple def min_cost_path(matrix: List[List[int]]) -> int: Find the minimum cost path in a matrix from top-left to bottom-right. >>> min_cost_path([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) == 7 >>> min_cost_path([ ... [1, 2], ... [4, 1] ... ]) == 4 def process_test_cases(test_cases: List[Tuple[int, int, List[List[int]]]]) -> List[int]: Process a list of test cases and return the minimum costs for each. >>> test_cases = [ ... (3, 3, [ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]), ... (2, 2, [ ... [1, 2], ... [4, 1] ... ]) ... ] >>> process_test_cases(test_cases) == [7, 4] def main(input: str) -> None: Parse input string, process test cases, and print the results. Example usage: >>> input_data = ''' ... 2 ... 3 3 ... 1 3 1 ... 1 5 1 ... 4 2 1 ... 2 2 ... 1 2 ... 4 1 ... ''' >>> main(input_data) 7 4","solution":"def min_cost_path(matrix): M = len(matrix) N = len(matrix[0]) # Create a 2D dp array to store the minimum cost path dp = [[0]*N for _ in range(M)] dp[0][0] = matrix[0][0] # Initialize the first row for j in range(1, N): dp[0][j] = dp[0][j-1] + matrix[0][j] # Initialize the first column for i in range(1, M): dp[i][0] = dp[i-1][0] + matrix[i][0] # Fill the dp array for i in range(1, M): for j in range(1, N): dp[i][j] = matrix[i][j] + min(dp[i-1][j], dp[i][j-1]) return dp[M-1][N-1] def process_test_cases(test_cases): results = [] for M, N, matrix in test_cases: results.append(min_cost_path(matrix)) return results def main(input): lines = input.strip().split('n') T = int(lines[0]) test_cases = [] idx = 1 for _ in range(T): M, N = map(int, lines[idx].split()) matrix = [] for i in range(M): matrix.append(list(map(int, lines[idx + 1 + i].split()))) test_cases.append((M, N, matrix)) idx += M + 1 results = process_test_cases(test_cases) for result in results: print(result)"},{"question":"def find_max_sum_array(arrays): Returns the array with the maximum sum of its elements. If there are multiple arrays with the same maximum sum, return the first one. Params: arrays (List[List[int]]): A list of integer arrays. Returns: List[int]: The array with the maximum sum. # Example usage def main(): T = int(input()) arrays = [] for _ in range(T): arrays.append(list(map(int, input().split()))) result = find_max_sum_array(arrays) print(' '.join(map(str, result))) if __name__ == \\"__main__\\": main()","solution":"def find_max_sum_array(arrays): Returns the array with the maximum sum of its elements. If there are multiple arrays with the same maximum sum, return the first one. Params: arrays (List[List[int]]): A list of integer arrays. Returns: List[int]: The array with the maximum sum. max_sum = float('-inf') max_array = [] for array in arrays: current_sum = sum(array) if current_sum > max_sum: max_sum = current_sum max_array = array return max_array # Example usage def main(): T = int(input()) arrays = [] for _ in range(T): arrays.append(list(map(int, input().split()))) result = find_max_sum_array(arrays) print(' '.join(map(str, result))) if __name__ == \\"__main__\\": main()"},{"question":"def find_word_in_grid(r: int, c: int, grid: List[str], word: str) -> str: Determine if the given word can be found in the grid according to the specified movement rules. >>> find_word_in_grid(5, 5, [\\"HELLO\\", \\"WORLD\\", \\"ABCDE\\", \\"FGHIJ\\", \\"KLMNO\\"], \\"HELLO\\") \\"YES\\" >>> find_word_in_grid(3, 3, [\\"ABC\\", \\"DEF\\", \\"GHI\\"], \\"FEG\\") \\"NO\\" >>> find_word_in_grid(4, 4, [\\"AXXX\\", \\"BXXX\\", \\"CXXX\\", \\"DXXX\\"], \\"ABCD\\") \\"YES\\" >>> find_word_in_grid(2, 4, [\\"DCBA\\", \\"XXXX\\"], \\"ABCD\\") \\"YES\\" >>> find_word_in_grid(2, 2, [\\"AA\\", \\"BB\\"], \\"ABA\\") \\"NO\\" >>> find_word_in_grid(2, 2, [\\"AA\\", \\"BB\\"], \\"A\\") \\"YES\\" >>> find_word_in_grid(2, 2, [\\"AB\\", \\"CD\\"], \\"ABCD\\") \\"NO\\"","solution":"def find_word_in_grid(r, c, grid, word): def search(x, y, dx, dy): for i in range(len(word)): nx, ny = x + i * dx, y + i * dy if not (0 <= nx < r and 0 <= ny < c and grid[nx][ny] == word[i]): return False return True for row in range(r): for col in range(c): if grid[row][col] == word[0]: if search(row, col, 1, 0): return \\"YES\\" # Vertical down if search(row, col, -1, 0): return \\"YES\\" # Vertical up if search(row, col, 0, 1): return \\"YES\\" # Horizontal right if search(row, col, 0, -1): return \\"YES\\" # Horizontal left return \\"NO\\""},{"question":"def is_pseudo_palindrome(s: str) -> str: Check if the string can be a pseudo-palindrome by removing at most one character. Parameters: s (str): The input string consisting of lowercase English letters (1 ≤ |s| ≤ 1,000,000). Returns: str: \\"YES\\" if it's a pseudo-palindrome, otherwise \\"NO\\". >>> is_pseudo_palindrome(\\"abca\\") \\"YES\\" >>> is_pseudo_palindrome(\\"abc\\") \\"NO\\"","solution":"def is_pseudo_palindrome(s): Check if the string can be a pseudo-palindrome by removing at most one character. Parameters: s (str): The input string. Returns: str: \\"YES\\" if it's a pseudo-palindrome, otherwise \\"NO\\". def is_palindrome(sub): return sub == sub[::-1] left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: if is_palindrome(s[left:right]) or is_palindrome(s[left+1:right+1]): return \\"YES\\" else: return \\"NO\\" left += 1 right -= 1 return \\"YES\\" # Example usage: # s = \\"abca\\" # print(is_pseudo_palindrome(s)) # Output: \\"YES\\""},{"question":"from typing import List def numUniquePaths(M: int, N: int, grid: List[List[int]]) -> int: Returns the number of unique paths from the top-left to the bottom-right in a grid with obstacles. >>> numUniquePaths(3, 3, [[0, 0, 0], [0, 1, 0], [0, 0, 0]]) 2 >>> numUniquePaths(3, 3, [[0, 1, 0], [0, 1, 0], [0, 0, 0]]) 1","solution":"def numUniquePaths(M, N, grid): Returns the number of unique paths from the top-left to the bottom-right in a grid with obstacles. if grid[0][0] == 1 or grid[M-1][N-1] == 1: return 0 dp = [[0] * N for _ in range(M)] dp[0][0] = 1 for i in range(M): for j in range(N): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[M-1][N-1]"},{"question":"def max_sum_of_consecutive_elements(test_cases): Returns the maximum sum of k consecutive elements for each test case. Parameters: test_cases (list of tuples): A list of tuples where each tuple contains an integer k and a list of integers. Returns: list of int: The maximum sums for each test case. pass # Here are some test cases to validate the correctness of the function def test_example_cases(): cases = [ (3, [1, 2, 3, 4, 5]), (2, [1, 3, 4]), (4, [1, 2, 3]) ] expected = [12, 7, 0] assert max_sum_of_consecutive_elements(cases) == expected def test_empty_list(): cases = [ (1, []), (5, []) ] expected = [0, 0] assert max_sum_of_consecutive_elements(cases) == expected def test_single_element_list(): cases = [ (1, [10]), (2, [10]) ] expected = [10, 0] assert max_sum_of_consecutive_elements(cases) == expected def test_all_same_elements(): cases = [ (3, [5, 5, 5, 5, 5]), (2, [7, 7, 7]), ] expected = [15, 14] assert max_sum_of_consecutive_elements(cases) == expected def test_large_k(): cases = [ (3, [1, 5, 1]), (4, [2, 3, 9, 8, 3, 4]) ] expected = [7, 24] assert max_sum_of_consecutive_elements(cases) == expected","solution":"def max_sum_of_consecutive_elements(test_cases): Returns the maximum sum of k consecutive elements for each test case. Parameters: test_cases (list of tuples): A list of tuples where each tuple contains an integer k and a list of integers. Returns: list of int: The maximum sums for each test case. result = [] for k, arr in test_cases: if len(arr) < k: result.append(0) else: max_sum = sum(arr[:k]) current_sum = max_sum for i in range(k, len(arr)): current_sum += arr[i] - arr[i - k] if current_sum > max_sum: max_sum = current_sum result.append(max_sum) return result"},{"question":"def correct_categories(T, test_cases): Assigns misplaced items to their correct categories based on weight ranges. Each test case consists of: - An integer N, the number of items - A list of N recorded weights and their categories, represented as tuples (weight, category) - An integer M, the number of correct categories - A list of M correct weight ranges for each category, represented as tuples (category, min_weight, max_weight) This function returns a list of corrected items for each test case, where each item is represented as a tuple: (weight, correct_category). >>> T = 1 >>> test_cases = [ ... ( ... 5, ... [(5, 'A'), (10, 'B'), (20, 'A'), (35, 'C'), (50, 'B')], ... 3, ... [('A', 1, 20), ('B', 21, 45), ('C', 46, 60)] ... ) ... ] >>> correct_categories(T, test_cases) [[(5, 'A'), (10, 'A'), (20, 'A'), (35, 'B'), (50, 'C')]]","solution":"def correct_categories(T, test_cases): results = [] for test_case in test_cases: N, recorded_weights, M, correct_categories_ranges = test_case category_ranges = {} for category, min_w, max_w in correct_categories_ranges: category_ranges[category] = (min_w, max_w) corrected_weights = [] for weight, _ in recorded_weights: correct_category = None for category, (min_w, max_w) in category_ranges.items(): if min_w <= weight <= max_w: correct_category = category break corrected_weights.append((weight, correct_category)) results.append(corrected_weights) return results"},{"question":"from typing import List def longest_subsequence(n: int, k: int, arr: List[int]) -> int: Returns the length of the longest subsequence where the difference between consecutive elements is exactly equal to a given integer k. >>> longest_subsequence(7, 2, [1, 3, 5, 7, 9, 11, 13]) 7 >>> longest_subsequence(5, 1, [4, 4, 4, 4, 4]) 1 >>> longest_subsequence(8, 3, [1, 4, 1, 7, 4, 4, 16, 13]) 2 >>> longest_subsequence(6, 0, [3, 3, 3, 3, 3, 3]) 6","solution":"def longest_subsequence(n, k, arr): Returns the length of the longest subsequence where the difference between consecutive elements is exactly equal to a given integer k. if n == 0: return 0 longest_len = 1 current_len = 1 for i in range(1, n): if arr[i] - arr[i-1] == k: current_len += 1 else: current_len = 1 longest_len = max(longest_len, current_len) return longest_len"},{"question":"def checkSubarraySum(arr, K): Given an array of positive integers and a number K, checks if there is any continuous subarray whose elements sum up to K. Parameters: arr (List[int]): The list of positive integers. K (int): The target sum for a continuous subarray. Returns: int: 1 if there is a subarray with sum equal to K, otherwise 0. >>> checkSubarraySum([1, 3, 5, 23, 2], 8) 1 >>> checkSubarraySum([1, 3, 5, 23, 2], 7) 0 >>> checkSubarraySum([1, 3, 5, 23, 2], 34) 1 >>> checkSubarraySum([5, 2, 3], 10) 1 >>> checkSubarraySum([10], 10) 1 >>> checkSubarraySum([5], 10) 0 >>> checkSubarraySum([1, 2, 3, 4, 5], 15) 1 >>> checkSubarraySum([2, 4, 6, 8, 10], 6) 1 >>> checkSubarraySum([2, 4, 6, 8, 10], 14) 1 >>> checkSubarraySum([1, 2, 3, 4, 5], 9) 1 >>> checkSubarraySum([1, 2, 3, 1, 1], 10) 0","solution":"def checkSubarraySum(arr, K): Checks if there is any continuous subarray whose elements sum up to K. cum_sum = 0 cum_sum_set = set() for num in arr: cum_sum += num if cum_sum == K: return 1 if (cum_sum - K) in cum_sum_set: return 1 cum_sum_set.add(cum_sum) return 0"},{"question":"def min_operations_to_equal_elements(n: int, arr: List[int]) -> int: Determine the minimum number of operations required to make all elements in an array equal. In one operation, a single element of the array can be incremented or decremented by 1. Args: n (int): The number of elements in the array. arr (List[int]): List of integers representing the array elements. Returns: int: The minimum number of operations required to make all elements equal. Examples: >>> min_operations_to_equal_elements(5, [1, 2, 3, 4, 5]) 6 >>> min_operations_to_equal_elements(3, [5, 5, 5]) 0 >>> min_operations_to_equal_elements(4, [1, -1, 1, -1]) 4 pass from solution import min_operations_to_equal_elements def test_example_1(): assert min_operations_to_equal_elements(5, [1, 2, 3, 4, 5]) == 6 def test_example_2(): assert min_operations_to_equal_elements(3, [5, 5, 5]) == 0 def test_example_3(): assert min_operations_to_equal_elements(4, [1, -1, 1, -1]) == 4 def test_single_element(): assert min_operations_to_equal_elements(1, [100]) == 0 def test_all_elements_same(): assert min_operations_to_equal_elements(5, [1, 1, 1, 1, 1]) == 0 def test_large_numbers(): assert min_operations_to_equal_elements(3, [-1000000, 0, 1000000]) == 2000000 def test_already_sorted_array(): assert min_operations_to_equal_elements(5, [10, 20, 30, 40, 50]) == 60 def test_reverse_sorted_array(): assert min_operations_to_equal_elements(5, [50, 40, 30, 20, 10]) == 60 def test_even_length_array(): assert min_operations_to_equal_elements(4, [1, 2, 3, 4]) == 4 def test_large_input_size(): large_array = list(range(100000)) assert min_operations_to_equal_elements(100000, large_array) == 2500000000","solution":"def min_operations_to_equal_elements(n, arr): arr.sort() median = arr[n // 2] return sum(abs(x - median) for x in arr) # Input reading and function call for actual implementation. if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() n = int(data[0]) arr = list(map(int, data[1:n+1])) result = min_operations_to_equal_elements(n, arr) print(result)"},{"question":"def find3Numbers(arr, N, target): Determines if there are three integers in the array that sum to the target value. Parameters: arr (list): List of integers N (int): Size of the array target (int): The target sum Returns: bool: True if there exist three numbers whose sum equals the target, False otherwise pass def test_find3Numbers(): assert find3Numbers([12, 3, 4, 1, 6, 9], 6, 24) == True assert find3Numbers([1, 2, 3, 4, 5], 5, 9) == True assert find3Numbers([1, 2, 3, 4, 5], 5, 15) == False assert find3Numbers([1, -2, 1, 0, 5], 5, 4) == True assert find3Numbers([-1, -2, -3, -4, -5], 5, -6) == True assert find3Numbers([-1, -2, -3, -4, -5], 5, 0) == False assert find3Numbers([0, 0, 0, 0, 0], 5, 0) == True assert find3Numbers([0, 1, 2], 3, 3) == True assert find3Numbers([1, 1, 1], 3, 3) == True assert find3Numbers([1, 1, 1, 1], 4, 3) == True if __name__ == \\"__main__\\": test_find3Numbers() print(\\"All tests passed!\\")","solution":"def find3Numbers(arr, N, target): Determines if there are three integers in the array that sum to the target value. Parameters: arr (list): List of integers N (int): Size of the array target (int): The target sum Returns: bool: True if there exist three numbers whose sum equals the target, False otherwise arr.sort() for i in range(N - 2): left = i + 1 right = N - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"def longest_subarray_within_limit(scores: List[int], k: int) -> int: Returns the length of the longest contiguous subarray where the difference between the maximum and minimum scores is less than or equal to k. >>> longest_subarray_within_limit([1, 3, 6, 7, 9, 2, 10], 3) 3 >>> longest_subarray_within_limit([1, 1, 1, 1, 1], 0) 5 >>> longest_subarray_within_limit([], 1) 0 >>> longest_subarray_within_limit([5], 0) 1 >>> longest_subarray_within_limit([10, 1, 10, 1, 10], 2) 1 >>> longest_subarray_within_limit([5, 5, 5, 5, 5, 5, 5], 0) 7 >>> longest_subarray_within_limit([1, 5, 9, 13], 100) 4 >>> longest_subarray_within_limit([1, 3, 1, 3, 1, 3, 1], 2) 7","solution":"def longest_subarray_within_limit(scores, k): Returns the length of the longest contiguous subarray where the difference between the maximum and minimum scores is less than or equal to k. from collections import deque min_deque = deque() max_deque = deque() left = 0 max_length = 0 for right in range(len(scores)): while min_deque and scores[min_deque[-1]] > scores[right]: min_deque.pop() while max_deque and scores[max_deque[-1]] < scores[right]: max_deque.pop() min_deque.append(right) max_deque.append(right) while scores[max_deque[0]] - scores[min_deque[0]] > k: left += 1 if left > min_deque[0]: min_deque.popleft() if left > max_deque[0]: max_deque.popleft() max_length = max(max_length, right - left + 1) return max_length"},{"question":"from typing import List, Tuple def is_valid(x: int, y: int, n: int = 8) -> bool: Check if the given position (x, y) is within the bounds of the chessboard. pass def knight_moves(start_x: int, start_y: int, target_x: int, target_y: int) -> int: Find the minimum number of moves a knight needs to reach the target position from the starting position on an 8x8 chessboard. >>> knight_moves(1, 1, 8, 8) 6 >>> knight_moves(1, 1, 2, 2) 4 pass def solve_knight_moves(test_cases: List[Tuple[int, int, int, int]]) -> List[int]: Solve multiple knight moves problems. >>> solve_knight_moves([(1, 1, 8, 8), (1, 1, 2, 2), (3, 3, 4, 3)]) [6, 4, 3] pass def main(): input_data = '''3 1 1 8 8 1 1 2 2 3 3 4 3''' lines = input_data.strip().split('n') T = int(lines[0]) test_cases = [tuple(map(int, line.split())) for line in lines[1:T+1]] results = solve_knight_moves(test_cases) for result in results: print(result) if __name__ == \\"__main__\\": main()","solution":"from collections import deque def is_valid(x, y, n=8): return 1 <= x <= n and 1 <= y <= n def knight_moves(start_x, start_y, target_x, target_y): if (start_x, start_y) == (target_x, target_y): return 0 directions = [ (2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2) ] queue = deque([(start_x, start_y, 0)]) visited = set((start_x, start_y)) while queue: x, y, moves = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if (nx, ny) == (target_x, target_y): return moves + 1 if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, moves + 1)) return -1 def solve_knight_moves(test_cases): results = [] for x1, y1, x2, y2 in test_cases: results.append(knight_moves(x1, y1, x2, y2)) return results # Example input processing def main(): input_data = '''3 1 1 8 8 1 1 2 2 3 3 4 3''' lines = input_data.strip().split('n') T = int(lines[0]) test_cases = [tuple(map(int, line.split())) for line in lines[1:T+1]] results = solve_knight_moves(test_cases) for result in results: print(result) if __name__ == \\"__main__\\": main()"},{"question":"def find_and_replace_pattern(words, pattern): Returns a list of the strings in words that match the pattern. A string matches the pattern if there exists a permutation of letters such that \`words[i]\` matches \`pattern\`, where a permutation of letters is a bijective mapping from a letter to another letter. Args: words (List[str]): List of words. pattern (str): The pattern to match. Returns: List[str]: List of words that match the given pattern. Examples: >>> find_and_replace_pattern([\\"abc\\",\\"deq\\",\\"mee\\",\\"aqq\\",\\"dkd\\",\\"ccc\\"], \\"abb\\") [\\"mee\\",\\"aqq\\"] >>> find_and_replace_pattern([\\"a\\",\\"b\\",\\"c\\"], \\"a\\") [\\"a\\",\\"b\\",\\"c\\"]","solution":"def find_and_replace_pattern(words, pattern): Returns a list of the strings in words that match the pattern. def matches(word, pattern): if len(word) != len(pattern): return False char_map_w_p = {} char_map_p_w = {} for w_char, p_char in zip(word, pattern): if w_char not in char_map_w_p: char_map_w_p[w_char] = p_char if p_char not in char_map_p_w: char_map_p_w[p_char] = w_char if char_map_w_p[w_char] != p_char or char_map_p_w[p_char] != w_char: return False return True return [word for word in words if matches(word, pattern)]"},{"question":"def two_sum(nums, target): Returns the indices of the two numbers in nums that add up to the target. Examples: >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([1, 2, 3, 4, 5], 9) [3, 4] >>> two_sum([-3, 4, 3, 90], 0) [0, 2] >>> two_sum([-1, -2, -3, -4, -5], -8) [2, 4] >>> two_sum([1000000000, 1000000000, 3, 7], 2000000000) [0, 1]","solution":"def two_sum(nums, target): Returns the indices of the two numbers in nums that add up to the target. num_dict = {} for i, num in enumerate(nums): complement = target - num if complement in num_dict: return [num_dict[complement], i] num_dict[num] = i"},{"question":"def canPartition(nums): Determines whether the array nums can be partitioned into two subsets with an equal sum. Parameters: nums (List[int]): The list of integers Returns: bool: True if the array can be partitioned into two subsets with equal sum, False otherwise >>> canPartition([1, 5, 11, 5]) True >>> canPartition([1, 2, 3, 5]) False >>> canPartition([1]) False >>> canPartition([3, 3, 3, 3]) True >>> canPartition([1, 2, 3, 4, 5, 6, 7]) True >>> canPartition([1, 2, 5, 10, 7, 8, 12]) False >>> canPartition([0, 0, 0, 0]) True >>> canPartition([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) True","solution":"def canPartition(nums): Determines whether the array nums can be partitioned into two subsets with an equal sum. Parameters: nums (List[int]): The list of integers Returns: bool: True if the array can be partitioned into two subsets with equal sum, False otherwise total_sum = sum(nums) # If total_sum is odd, it can't be split into two equal subsets if total_sum % 2 != 0: return False target = total_sum // 2 n = len(nums) dp = [False] * (target + 1) dp[0] = True for num in nums: for j in range(target, num - 1, -1): dp[j] = dp[j] or dp[j - num] return dp[target]"},{"question":"class InventoryManagement: def __init__(self): self.inventory = {} def add(self, product_code, quantity): Adds quantity of item with product code to inventory. pass def remove(self, product_code, quantity): Removes quantity of item with product code from inventory. pass def report(self, product_code): Returns the quantity of item with product code in the inventory. pass def stock(self): Returns the total number of distinct items in the inventory. pass def allstock(self): Returns a list of tuples with product code and quantity of all items in inventory. pass def process_commands(commands): inventory = InventoryManagement() results = [] for command in commands: parts = command.split() command_type = parts[0] if command_type == \\"ADD\\": product_code = int(parts[1]) quantity = int(parts[2]) inventory.add(product_code, quantity) elif command_type == \\"REMOVE\\": product_code = int(parts[1]) quantity = int(parts[2]) inventory.remove(product_code, quantity) elif command_type == \\"REPORT\\": product_code = int(parts[1]) results.append(str(inventory.report(product_code))) elif command_type == \\"STOCK\\": results.append(str(inventory.stock())) elif command_type == \\"ALLSTOCK\\": all_stock = inventory.allstock() results.extend([f\\"{code} {quantity}\\" for code, quantity in all_stock]) return results # Unit tests def test_add_and_report(): commands = [ \\"ADD 101 50\\", \\"ADD 102 30\\", \\"REPORT 101\\", \\"REPORT 102\\", ] output = process_commands(commands) assert output == [\\"50\\", \\"30\\"] def test_remove_and_report(): commands = [ \\"ADD 101 50\\", \\"REMOVE 101 20\\", \\"REPORT 101\\", \\"REMOVE 101 40\\", \\"REPORT 101\\", ] output = process_commands(commands) assert output == [\\"30\\", \\"30\\"] def test_stock(): commands = [ \\"ADD 101 50\\", \\"ADD 102 30\\", \\"STOCK\\", \\"REMOVE 101 50\\", \\"STOCK\\", ] output = process_commands(commands) assert output == [\\"2\\", \\"1\\"] def test_allstock(): commands = [ \\"ADD 101 50\\", \\"ADD 102 30\\", \\"ALLSTOCK\\", ] output = process_commands(commands) assert output == [\\"101 50\\", \\"102 30\\"] def test_all_cases(): commands = [ \\"ADD 101 50\\", \\"ADD 102 30\\", \\"REPORT 101\\", \\"REPORT 102\\", \\"REMOVE 101 20\\", \\"REPORT 101\\", \\"STOCK\\", \\"ALLSTOCK\\", \\"REMOVE 102 40\\", \\"REPORT 102\\", ] output = process_commands(commands) expected_output = [\\"50\\", \\"30\\", \\"30\\", \\"2\\", \\"101 30\\", \\"102 30\\", \\"30\\"] assert output == expected_output","solution":"class InventoryManagement: def __init__(self): self.inventory = {} def add(self, product_code, quantity): if product_code in self.inventory: self.inventory[product_code] += quantity else: self.inventory[product_code] = quantity def remove(self, product_code, quantity): if product_code in self.inventory and self.inventory[product_code] >= quantity: self.inventory[product_code] -= quantity if self.inventory[product_code] == 0: del self.inventory[product_code] def report(self, product_code): return self.inventory.get(product_code, 0) def stock(self): return len(self.inventory) def allstock(self): return sorted(self.inventory.items()) def process_commands(commands): inventory = InventoryManagement() results = [] for command in commands: parts = command.split() command_type = parts[0] if command_type == \\"ADD\\": product_code = int(parts[1]) quantity = int(parts[2]) inventory.add(product_code, quantity) elif command_type == \\"REMOVE\\": product_code = int(parts[1]) quantity = int(parts[2]) inventory.remove(product_code, quantity) elif command_type == \\"REPORT\\": product_code = int(parts[1]) results.append(str(inventory.report(product_code))) elif command_type == \\"STOCK\\": results.append(str(inventory.stock())) elif command_type == \\"ALLSTOCK\\": all_stock = inventory.allstock() results.extend([f\\"{code} {quantity}\\" for code, quantity in all_stock]) return results # Sample input commands = [ \\"ADD 101 50\\", \\"ADD 102 30\\", \\"REPORT 101\\", \\"REPORT 102\\", \\"REMOVE 101 20\\", \\"REPORT 101\\", \\"STOCK\\", \\"ALLSTOCK\\", \\"REMOVE 102 40\\", \\"REPORT 102\\", ] # Process commands output = process_commands(commands) # Print results for line in output: print(line)"},{"question":"def partitionArray(arr, N): Partition the array into two subarrays such that the difference in their sums is minimized. >>> partitionArray([1, 6, 11, 5], 4) 1 >>> partitionArray([7], 1) 7 >>> partitionArray([3, 3, 3, 3], 4) 0 >>> partitionArray([1, 2, 3, 99], 4) 93 >>> partitionArray([10, 1, 9, 1, 8, 1, 7], 7) 1 >>> partitionArray([2, 2, 2, 2], 4) 0","solution":"def partitionArray(arr, N): Returns the minimum difference between sums of two subarrays. total_sum = sum(arr) target = total_sum // 2 # Initialize a DP array dp = [False] * (target + 1) dp[0] = True for num in arr: for j in range(target, num - 1, -1): dp[j] = dp[j] or dp[j - num] for i in range(target, -1, -1): if dp[i]: return total_sum - 2 * i return total_sum # Example usage: # print(partitionArray([1, 6, 11, 5], 4)) # Output: 1"},{"question":"def find(parent, i): if parent[i] == -1: return i else: return find(parent, parent[i]) def union(parent, x, y): # Perform union of two subsets x and y x_set = find(parent, x) y_set = find(parent, y) if x_set != y_set: parent[x_set] = y_set def is_fully_connected(num_cities: int, roads: List[Tuple[int, int]]) -> str: Check if the network of cities is fully connected. >>> is_fully_connected(3, [(1, 2), (2, 3), (3, 1)]) \\"Fully Connected\\" >>> is_fully_connected(4, [(1, 2), (3, 4)]) \\"Not Fully Connected\\" def check_fully_connected(test_cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[str]: Determine if each network of cities in the test cases is fully connected. >>> test_cases = [(3, 3, [(1, 2), (2, 3), (3, 1)]), (4, 2, [(1, 2), (3, 4)])] >>> check_fully_connected(test_cases) [\\"Fully Connected\\", \\"Not Fully Connected\\"] def test_check_fully_connected(): test_cases = [ (3, 3, [(1, 2), (2, 3), (3, 1)]), (4, 2, [(1, 2), (3, 4)]), (5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]), (5, 3, [(1, 2), (2, 3), (3, 4)]), (6, 6, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1)]), (1, 0, []), ] expected_results = [ \\"Fully Connected\\", \\"Not Fully Connected\\", \\"Fully Connected\\", \\"Not Fully Connected\\", \\"Fully Connected\\", \\"Fully Connected\\", ] assert check_fully_connected(test_cases) == expected_results","solution":"def find(parent, i): if parent[i] == -1: return i else: return find(parent, parent[i]) def union(parent, x, y): x_set = find(parent, x) y_set = find(parent, y) if x_set != y_set: parent[x_set] = y_set def is_fully_connected(num_cities, roads): parent = [-1] * num_cities for road in roads: city1, city2 = road[0] - 1, road[1] - 1 # Convert to zero-based index union(parent, city1, city2) first_city_set = find(parent, 0) # Use the first city as the reference for city in range(1, num_cities): if find(parent, city) != first_city_set: return \\"Not Fully Connected\\" return \\"Fully Connected\\" def check_fully_connected(test_cases): results = [] for num_cities, num_roads, roads in test_cases: result = is_fully_connected(num_cities, roads) results.append(result) return results"},{"question":"def count_characters(input_string: str) -> dict: Returns a dictionary with the count of each character in the input string. Parameters: input_string (str): The string for which character count is to be computed. Returns: dict: A dictionary with characters as keys and their counts as values. Examples: >>> count_characters('abracadabra') {'a': 5, 'b': 2, 'r': 2, 'c': 1, 'd': 1} >>> count_characters('hello_world123') {'h': 1, 'e': 1, 'l': 3, 'o': 2, '_': 1, 'w': 1, 'r': 1, 'd': 1, '1': 1, '2': 1, '3': 1}","solution":"def count_characters(input_string): Returns a dictionary with the count of each character in the input string. Parameters: input_string (str): The string for which character count is to be computed. Returns: dict: A dictionary with characters as keys and their counts as values. char_count = {} for char in input_string: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 return char_count"},{"question":"from typing import List, Tuple def reorder_array(arr: List[int]) -> List[int]: Reorders arr such that the product of each element and its index follows a non-decreasing sequence. If multiple reorderings exist, the lexicographically smallest one is returned. >>> reorder_array([3, 1, 2, 5, 4]) [1, 2, 3, 4, 5] >>> reorder_array([8, 4, 6, 2]) [2, 4, 6, 8] pass def process_test_cases(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[List[int]]: Processes multiple test cases and returns the reordered arrays for each case. >>> process_test_cases(2, [(5, [3, 1, 2, 5, 4]), (4, [8, 4, 6, 2])]) [[1, 2, 3, 4, 5], [2, 4, 6, 8]] pass","solution":"def reorder_array(arr): Reorders arr such that the product of each element and its index follows a non-decreasing sequence. If multiple reorderings exist, the lexicographically smallest one is returned. arr_sorted = sorted(arr) return arr_sorted def process_test_cases(T, test_cases): results = [] for i in range(T): N, arr = test_cases[i] result = reorder_array(arr) results.append(result) return results"},{"question":"class QueryProcessor: def __init__(self, initial_list): self.list = initial_list self.n = len(initial_list) self.prefix_sum = [0] * (self.n + 1) self.build_prefix_sum() def build_prefix_sum(self): Builds the prefix sum array from the initial list of elements. for i in range(1, self.n + 1): self.prefix_sum[i] = self.prefix_sum[i - 1] + self.list[i - 1] def update(self, i, x): Updates the element at index i to x and adjusts the prefix sum array accordingly. diff = x - self.list[i - 1] self.list[i - 1] = x for j in range(i, self.n + 1): self.prefix_sum[j] += diff def query(self, L, R): Queries the sum of elements from index L to R. return self.prefix_sum[R] - self.prefix_sum[L - 1] def process_operations(n, initial_list, operations): Processes a series of update and query operations on an initial list of integers. Args: n: The number of elements in the initial list. initial_list: The list of integers. operations: The list of operations to perform, where each operation is represented as a list. Returns: A list of integers, where each integer is the result of a query operation. >>> n = 5 >>> initial_list = [1, -2, 3, 4, 5] >>> operations = [ ... [2, 1, 3], ... [1, 2, 10], ... [2, 1, 3], ... [2, 2, 5] ... ] >>> process_operations(n, initial_list, operations) [2, 14, 22] query_processor = QueryProcessor(initial_list) results = [] for operation in operations: op_type = operation[0] if op_type == 1: _, i, x = operation query_processor.update(i, x) elif op_type == 2: _, L, R = operation result = query_processor.query(L, R) results.append(result) return results def test_process_operations(): n = 5 initial_list = [1, -2, 3, 4, 5] operations = [ [2, 1, 3], [1, 2, 10], [2, 1, 3], [2, 2, 5] ] expected_results = [2, 14, 22] assert process_operations(n, initial_list, operations) == expected_results def test_process_operations_more_updates(): n = 5 initial_list = [1, 2, 3, 4, 5] operations = [ [2, 1, 5], [1, 1, 10], [2, 1, 5], [1, 5, 20], [2, 4, 5] ] expected_results = [15, 24, 24] assert process_operations(n, initial_list, operations) == expected_results def test_process_operations_all_query_operations(): n = 4 initial_list = [1, 2, 3, 4] operations = [ [2, 1, 2], [2, 2, 4], [2, 1, 4] ] expected_results = [3, 9, 10] assert process_operations(n, initial_list, operations) == expected_results def test_process_operations_update_first_last_elements(): n = 3 initial_list = [5, -5, 10] operations = [ [1, 1, 1], [1, 3, 3], [2, 1, 3], [2, 2, 3] ] expected_results = [-1, -2] assert process_operations(n, initial_list, operations) == expected_results def test_process_operations_no_operations(): n = 3 initial_list = [5, -5, 10] operations = [] expected_results = [] assert process_operations(n, initial_list, operations) == expected_results","solution":"class QueryProcessor: def __init__(self, initial_list): self.list = initial_list self.n = len(initial_list) self.prefix_sum = [0] * (self.n + 1) self.build_prefix_sum() def build_prefix_sum(self): for i in range(1, self.n + 1): self.prefix_sum[i] = self.prefix_sum[i - 1] + self.list[i - 1] def update(self, i, x): diff = x - self.list[i - 1] self.list[i - 1] = x for j in range(i, self.n + 1): self.prefix_sum[j] += diff def query(self, L, R): return self.prefix_sum[R] - self.prefix_sum[L - 1] def process_operations(n, initial_list, operations): query_processor = QueryProcessor(initial_list) results = [] for operation in operations: op_type = operation[0] if op_type == 1: _, i, x = operation query_processor.update(i, x) elif op_type == 2: _, L, R = operation result = query_processor.query(L, R) results.append(result) return results"},{"question":"def sort_reservations_by_checkin_date(reservations): Sorts a list of reservation objects by their check-in date in ascending order. :param reservations: List[dict] - List of reservation objects. :return: List[dict] - Sorted list of reservation objects. For example: reservations = [ { 'reservationId': 1, 'guestName': \\"Alice\\", 'checkInDate': \\"2023-10-01\\" }, { 'reservationId': 2, 'guestName': \\"Bob\\", 'checkInDate': \\"2023-09-27\\" }, { 'reservationId': 3, 'guestName': \\"Charlie\\", 'checkInDate': \\"2023-10-05\\" } ] The output should be: [ { 'reservationId': 2, 'guestName': \\"Bob\\", 'checkInDate': \\"2023-09-27\\" }, { 'reservationId': 1, 'guestName': \\"Alice\\", 'checkInDate': \\"2023-10-01\\" }, { 'reservationId': 3, 'guestName': \\"Charlie\\", 'checkInDate': \\"2023-10-05\\" } ] pass","solution":"def sort_reservations_by_checkin_date(reservations): Sorts a list of reservation objects by their check-in date in ascending order. :param reservations: List[dict] - List of reservation objects. :return: List[dict] - Sorted list of reservation objects. return sorted(reservations, key=lambda x: x['checkInDate'])"},{"question":"def max_distinct_types(n, m, seed_counts): Determine the highest number of distinct types of vegetables Sarah can grow simultaneously. Args: - n (int): Number of different types of seeds. - m (int): Number of available garden plots. - seed_counts (list of int): List of integers where each integer represents the number of seeds of a particular type Sarah has. Returns: - int: Maximum number of distinct types of vegetables Sarah can grow simultaneously. >>> max_distinct_types(5, 3, [1, 2, 3, 4, 5]) 3 >>> max_distinct_types(6, 10, [2, 2, 2, 2, 2, 2]) 6","solution":"def max_distinct_types(n, m, seed_counts): Determine the highest number of distinct types of vegetables Sarah can grow simultaneously. Args: - n (int): Number of different types of seeds. - m (int): Number of available garden plots. - seed_counts (list of int): List of integers where each integer represents the number of seeds of a particular type Sarah has. Returns: - int: Maximum number of distinct types of vegetables Sarah can grow simultaneously. return min(n, m)"},{"question":"def findPairWithDifference(arr, k): Determines if there exists a pair of elements in the sorted array \`arr\` with a specific difference \`k\`. Args: arr (list of int): The sorted array of distinct integers. k (int): The specific difference to find. Returns: bool: True if such a pair exists, otherwise False. Examples: >>> findPairWithDifference([1, 5, 9, 14], 4) True >>> findPairWithDifference([10, 20, 30, 40, 50], 35) False >>> findPairWithDifference([-5, -3, 0, 7, 12], 7) True >>> findPairWithDifference([1, 2, 3, 4, 5], 0) False >>> findPairWithDifference([1, 2, 3, 1000000000], 999999997) True >>> findPairWithDifference([1], 1) False >>> findPairWithDifference([1, 4, 7, 9], 100) False","solution":"def findPairWithDifference(arr, k): Determines if there exists a pair of elements in the sorted array \`arr\` with a specific difference \`k\`. Args: arr (list of int): The sorted array of distinct integers. k (int): The specific difference to find. Returns: bool: True if such a pair exists, otherwise False. left, right = 0, 1 while right < len(arr): if left == right: right += 1 continue diff = arr[right] - arr[left] if diff == k: return True elif diff < k: right += 1 else: left += 1 return False"},{"question":"def categorize_students(scores): Categorize students based on their average scores in Mathematics, Physics, and Chemistry. :param scores: List of tuples where each tuple contains three integers representing the scores in Mathematics, Physics, and Chemistry respectively. :return: List of strings representing the category of each student. >>> categorize_students([(95, 91, 92), (100, 99, 98)]) [\\"Excellent\\", \\"Excellent\\"] >>> categorize_students([(75, 70, 80), (80, 85, 79)]) [\\"Good\\", \\"Good\\"] >>> categorize_students([(55, 60, 50), (50, 65, 60)]) [\\"Average\\", \\"Average\\"] >>> categorize_students([(45, 40, 50), (30, 35, 40)]) [\\"Poor\\", \\"Poor\\"] >>> categorize_students([(95, 90, 92), (70, 75, 80), (45, 50, 40), (85, 80, 82), (60, 65, 58)]) [\\"Excellent\\", \\"Good\\", \\"Poor\\", \\"Good\\", \\"Average\\"]","solution":"def categorize_students(scores): Categorize students based on their average scores in Mathematics, Physics, and Chemistry. :param scores: List of tuples where each tuple contains three integers representing the scores in Mathematics, Physics, and Chemistry respectively. :return: List of strings representing the category of each student. categories = [] for math, phys, chem in scores: avg_score = (math + phys + chem) / 3 if avg_score >= 90: categories.append(\\"Excellent\\") elif avg_score >= 70: categories.append(\\"Good\\") elif avg_score >= 50: categories.append(\\"Average\\") else: categories.append(\\"Poor\\") return categories"},{"question":"def is_beautiful_string(s): Determines if the given string is a beautiful string. A string is considered beautiful if: 1. All characters are distinct. 2. For any two alphabetic characters, the absolute difference in their ASCII values is exactly one. Args: s (str): A string consisting of lowercase alphabetic characters and/or digits. Returns: str: \\"YES\\" if the string is beautiful, \\"NO\\" otherwise. >>> is_beautiful_string(\\"abc\\") 'YES' >>> is_beautiful_string(\\"abd\\") 'NO' >>> is_beautiful_string(\\"a1b\\") 'NO' >>> is_beautiful_string(\\"a\\") 'YES' >>> is_beautiful_string(\\"1a\\") 'YES'","solution":"def is_beautiful_string(s): Determines if the given string is a beautiful string. Args: s (str): A string consisting of lowercase alphabetic characters and/or digits. Returns: str: \\"YES\\" if the string is beautiful, \\"NO\\" otherwise. # Filter out digits characters = [c for c in s if c.isalpha()] # Checking for distinct characters if len(characters) != len(set(characters)): return \\"NO\\" # Sorting characters characters.sort() # Checking consecutive ASCII values for i in range(1, len(characters)): if abs(ord(characters[i]) - ord(characters[i-1])) != 1: return \\"NO\\" return \\"YES\\""},{"question":"def min_energy_path(T: int, test_cases: List[Tuple[int, int, List[List[int]]]]) -> List[int]: Determine the minimum energy path through the matrix from any cell in the leftmost column to any cell in the rightmost column. Each test case provides a matrix of energy emissions. You can move from any cell to the next column's top, bottom, or middle adjacent cell. Arguments: T : int : Number of test cases. test_cases : List[Tuple[int, int, List[List[int]]]] A list of tuples, each containing: - M (int): Number of rows in the matrix. - N (int): Number of columns in the matrix. - matrix (List[List[int]]): M x N matrix of energy values. Returns: List[int] : The minimum energy required for each test case. Example: >>> min_energy_path(1, [(3, 4, [[2, 8, 4, 1], [6, 3, 7, 2], [5, 9, 4, 8]])]) [10] >>> min_energy_path(1, [(1, 5, [[1, 2, 3, 4, 5]])]) [15] >>> min_energy_path(1, [(5, 1, [[1], [2], [3], [4], [5]])]) [1] >>> min_energy_path(1, [(2, 2, [[1000, -1000], [-1000, 1000]])]) [-2000] >>> min_energy_path(1, [(3, 3, [[0, 0, 0], [0, 0, 0], [0, 0, 0]])]) [0]","solution":"def min_energy_path(T, test_cases): results = [] for t in range(T): M, N, matrix = test_cases[t] dp = [[float('inf')] * N for _ in range(M)] # Initialize the first column with the respective cell values for i in range(M): dp[i][0] = matrix[i][0] # Fill the dp table by considering possible transitions for j in range(1, N): for i in range(M): # From the same row dp[i][j] = min(dp[i][j], dp[i][j-1] + matrix[i][j]) # From the upper row if i > 0: dp[i][j] = min(dp[i][j], dp[i-1][j-1] + matrix[i][j]) # From the lower row if i < M - 1: dp[i][j] = min(dp[i][j], dp[i+1][j-1] + matrix[i][j]) # The result is the minimum value in the last column min_energy = float('inf') for i in range(M): min_energy = min(min_energy, dp[i][N-1]) results.append(min_energy) return results"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_two_sorted_lists(list1, list2): Merge two sorted linked lists and return it as a new sorted list. Args: list1 (ListNode): The head of the first sorted linked list. list2 (ListNode): The head of the second sorted linked list. Returns: ListNode: The head of the merged sorted linked list. >>> # Test cases >>> def list_to_linked_list(elements): ... dummy = ListNode(0) ... current = dummy ... for el in elements: ... current.next = ListNode(el) ... current = current.next ... return dummy.next >>> def linked_list_to_list(node): ... elements = [] ... while node: ... elements.append(node.val) ... node = node.next ... return elements >>> list1 = list_to_linked_list([1, 2, 4]) >>> list2 = list_to_linked_list([1, 3, 4]) >>> linked_list_to_list(merge_two_sorted_lists(list1, list2)) == [1, 1, 2, 3, 4, 4] True >>> >>> list1 = list_to_linked_list([]) >>> list2 = list_to_linked_list([]) >>> linked_list_to_list(merge_two_sorted_lists(list1, list2)) == [] True >>> >>> list1 = list_to_linked_list([1, 2, 4]) >>> list2 = list_to_linked_list([]) >>> linked_list_to_list(merge_two_sorted_lists(list1, list2)) == [1, 2, 4] True >>> >>> list1 = list_to_linked_list([]) >>> list2 = list_to_linked_list([1, 3, 4]) >>> linked_list_to_list(merge_two_sorted_lists(list1, list2)) == [1, 3, 4] True >>> >>> list1 = list_to_linked_list([1, 3, 5]) >>> list2 = list_to_linked_list([2, 4, 6]) >>> linked_list_to_list(merge_two_sorted_lists(list1, list2)) == [1, 2, 3, 4, 5, 6] True","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_two_sorted_lists(list1, list2): Merge two sorted linked lists and return it as a new sorted list. dummy = ListNode(0) current = dummy while list1 and list2: if list1.val <= list2.val: current.next = list1 list1 = list1.next else: current.next = list2 list2 = list2.next current = current.next if list1: current.next = list1 elif list2: current.next = list2 return dummy.next"},{"question":"def minimum_moves(start, end): Calculate the minimum number of moves required to travel from start to end. Parameters: start (list): The starting coordinates [x1, y1] end (list): The ending coordinates [x2, y2] Returns: int: The minimum number of moves Examples: >>> minimum_moves([0, 0], [0, 0]) == 0 >>> minimum_moves([2, 3], [5, 3]) == 3 >>> minimum_moves([2, 3], [2, 7]) == 4 >>> minimum_moves([2, -3], [-3, 2]) == 10 pass","solution":"def minimum_moves(start, end): Calculate the minimum number of moves required to travel from start to end. Parameters: start (list): The starting coordinates [x1, y1] end (list): The ending coordinates [x2, y2] Returns: int: The minimum number of moves x1, y1 = start x2, y2 = end # Calculate the Manhattan distance return abs(x2 - x1) + abs(y2 - y1)"},{"question":"def word_search(words, grid): Simulates a simplified version of a word search puzzle. Given a dictionary of words and a grid of characters, return all the words from the dictionary that can be formed by tracing along a path in the grid. The path can move horizontally, vertically, or diagonally, and each cell can only be used once per word. >>> words = [\\"CAT\\", \\"DOG\\", \\"COW\\"] >>> grid = [ ... ['C', 'A', 'T'], ... ['D', 'O', 'G'], ... ['C', 'A', 'T'] ... ] >>> word_search(words, grid) ['CAT', 'DOG'] pass from solution import word_search def test_example_case(): words = [\\"CAT\\", \\"DOG\\", \\"COW\\"] grid = [ ['C', 'A', 'T'], ['D', 'O', 'G'], ['C', 'A', 'T'] ] assert set(word_search(words, grid)) == {\\"CAT\\", \\"DOG\\"} def test_no_words_found(): words = [\\"FISH\\", \\"BIRD\\"] grid = [ ['C', 'A', 'T'], ['D', 'O', 'G'], ['C', 'A', 'T'] ] assert word_search(words, grid) == [] def test_all_words_found(): words = [\\"CAT\\", \\"DOG\\", \\"COW\\", \\"GOD\\"] grid = [ ['C', 'A', 'T'], ['D', 'O', 'G'], ['C', 'A', 'T'] ] assert set(word_search(words, grid)) == {\\"CAT\\", \\"DOG\\", \\"GOD\\"} def test_grid_with_repeated_words(): words = [\\"CAT\\", \\"DOG\\"] grid = [ ['C', 'A', 'T', 'C'], ['D', 'O', 'G', 'A'], ['T', 'A', 'T', 'D'], ['C', 'A', 'T', 'O'] ] assert set(word_search(words, grid)) == {\\"CAT\\", \\"DOG\\"} def test_different_directions(): words = [\\"CAT\\", \\"ACT\\"] grid = [ ['A', 'C', 'T'], ['C', 'A', 'T'], ['A', 'T', 'A'] ] assert set(word_search(words, grid)) == {\\"CAT\\", \\"ACT\\"}","solution":"def word_search(words, grid): Returns all the words from the given dictionary that can be formed in the grid. def is_valid(x, y): return 0 <= x < len(grid) and 0 <= y < len(grid[0]) def search_word(word, index, x, y, visited): if index == len(word): return True if not is_valid(x, y) or (x, y) in visited or grid[x][y] != word[index]: return False visited.add((x, y)) for dx, dy in [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]: if search_word(word, index + 1, x + dx, y + dy, visited): return True visited.remove((x, y)) return False found_words = set() for word in words: for i in range(len(grid)): for j in range(len(grid[0])): if search_word(word, 0, i, j, set()): found_words.add(word) return list(found_words)"},{"question":"def max_value_from_vertex_one(test_cases): Find the maximum value of any vertex that can be reached starting from vertex 1. Args: test_cases (list): List consisting of tuples representing each test case. Each tuple contains (N, M, vertex_values, edges) N (int) - number of vertices M (int) - number of edges vertex_values (list) - Initial values of the vertices edges (list) - List of tuples representing edges (u_i, v_i) Returns: list: List of integers representing maximum vertex value reachable from vertex 1 for each test case. Examples: >>> max_value_from_vertex_one([(5, 4, [1, 5, 3, 2, 6], [(1, 2), (2, 3), (3, 4), (4, 5)]), (3, 2, [10, 20, 30], [(1, 2), (2, 3)])]) [6, 30] >>> max_value_from_vertex_one([(4, 3, [12, 7, 9, 14], [(1, 2), (2, 3), (3, 4)])]) [14] >>> max_value_from_vertex_one([(3, 0, [5, 8, 9], [])]) [5] >>> max_value_from_vertex_one([(1, 0, [99], [])]) [99]","solution":"def max_value_from_vertex_one(test_cases): Find the maximum value of any vertex that can be reached starting from vertex 1. Args: test_cases (list): List consisting of tuples representing each test case. Each tuple contains (N, M, vertex_values, edges) N (int) - number of vertices M (int) - number of edges vertex_values (list) - Initial values of the vertices edges (list) - List of tuples representing edges (u_i, v_i) Returns: list: List of integers representing maximum vertex value reachable from vertex 1 for each test case. def bfs_max_value(vertex_values, neighbors, start_vertex): from collections import deque visited = set() queue = deque([start_vertex]) max_value = vertex_values[start_vertex - 1] while queue: vertex = queue.popleft() if vertex not in visited: visited.add(vertex) max_value = max(max_value, vertex_values[vertex - 1]) for neighbor in neighbors[vertex]: if neighbor not in visited: queue.append(neighbor) return max_value results = [] for N, M, vertex_values, edges in test_cases: neighbors = {i: [] for i in range(1, N + 1)} for u, v in edges: neighbors[u].append(v) neighbors[v].append(u) result = bfs_max_value(vertex_values, neighbors, 1) results.append(result) return results"},{"question":"def smallest_sum_of_differences(t: int, test_cases: List[Tuple[int, int]]) -> List[int]: Determine the smallest possible sum of the maximum and minimum group size difference across all groups. Parameters: t (int): The number of test cases test_cases (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers n and k. Returns: List[int]: A list of integers representing the smallest possible sum of the maximum and minimum group size difference for each test case. >>> smallest_sum_of_differences(3, [(7, 3), (10, 4), (15, 6)]) [1, 1, 1] >>> smallest_sum_of_differences(1, [(1, 1)]) [0]","solution":"def smallest_sum_of_differences(t, test_cases): results = [] for i in range(t): n, k = test_cases[i] # Total number of participants to distribute full_groups = n // k remainder = n % k if remainder == 0: results.append(0) # If evenly distributed, max - min difference will be 0 else: results.append(1) # If there is a remainder, max - min difference will be 1 return results # Input parsing function to handle raw input for testing def parse_inputs(input_list): t = int(input_list[0]) test_cases = [tuple(map(int, line.split())) for line in input_list[1:t+1]] return t, test_cases"},{"question":"def max_alice_score(n: int, candies: List[int]) -> int: Return the maximum score Alice can achieve if both Alice and Bob play optimally. >>> max_alice_score(6, [1, 2, 9, 4, 4, 6]) 16 >>> max_alice_score(1, [5]) 5 >>> max_alice_score(2, [3, 9]) 9 >>> max_alice_score(4, [1, 100, 1, 100]) 200 >>> max_alice_score(5, [4, 4, 4, 4, 4]) 12 >>> max_alice_score(1000, list(range(1, 1001))) 250500","solution":"def max_alice_score(n, candies): Returns the maximum score Alice can achieve if both Alice and Bob play optimally. memo = [[None for _ in range(n)] for _ in range(n)] def dfs(left, right): if left > right: return 0 if memo[left][right] is not None: return memo[left][right] pick_left = candies[left] + min(dfs(left + 2, right), dfs(left + 1, right - 1)) pick_right = candies[right] + min(dfs(left + 1, right - 1), dfs(left, right - 2)) memo[left][right] = max(pick_left, pick_right) return memo[left][right] return dfs(0, n - 1)"},{"question":"def wiggleSort(nums: List[int]) -> None: Rearranges the array so that it becomes wiggle sorted. nums[0] <= nums[1] >= nums[2] <= nums[3] >= nums[4]... pass from typing import List def is_wiggle_sorted(nums): Utility function to check if the array is wiggle sorted. for i in range(len(nums) - 1): if i % 2 == 0 and nums[i] > nums[i + 1]: return False if i % 2 != 0 and nums[i] < nums[i + 1]: return False return True def test_wiggle_sort_example_1(): nums = [3, 5, 2, 1, 6, 4] wiggleSort(nums) assert is_wiggle_sorted(nums) def test_wiggle_sort_example_2(): nums = [6, 4, 2, 1, 5, 3] wiggleSort(nums) assert is_wiggle_sorted(nums) def test_wiggle_sort_single_element(): nums = [1] wiggleSort(nums) assert is_wiggle_sorted(nums) def test_wiggle_sort_two_elements(): nums = [2, 1] wiggleSort(nums) assert is_wiggle_sorted(nums) def test_wiggle_sort_already_sorted(): nums = [1, 6, 2, 5, 3, 4] wiggleSort(nums) assert is_wiggle_sorted(nums) def test_wiggle_sort_all_equal_elements(): nums = [1, 1, 1, 1, 1] wiggleSort(nums) assert is_wiggle_sorted(nums) def test_wiggle_sort_large_random(): import random nums = [random.randint(-10**9, 10**9) for _ in range(10**5)] wiggleSort(nums) assert is_wiggle_sorted(nums)","solution":"def wiggleSort(nums): Rearranges the array so that it becomes wiggle sorted. nums[0] <= nums[1] >= nums[2] <= nums[3] >= nums[4]... for i in range(len(nums) - 1): if (i % 2 == 0 and nums[i] > nums[i + 1]) or (i % 2 != 0 and nums[i] < nums[i + 1]): nums[i], nums[i + 1] = nums[i + 1], nums[i] # Test with an example nums = [3, 5, 2, 1, 6, 4] wiggleSort(nums) print(nums) # Output could be [3, 5, 1, 6, 2, 4]"},{"question":"from typing import List, Union def summarize_plant_collection(plant_inputs: List[str]) -> Union[List[Union[str, int]], List[str]]: Summarize and normalize plant collection data, converting plant names to a standard three-letter code and aggregating counts. If any plant named 'Cactus' appears in the input list, return [\\"Invalid data\\"]. Args: plant_inputs (List[str]): An array of strings where each string contains a plant type and count separated by spaces. Returns: Union[List[Union[str, int]], List[str]]: Sorted list of three-letter codes and their summed counts, or [\\"Invalid data\\"] if 'Cactus' is found. Examples: >>> summarize_plant_collection([\\"Rose 5\\", \\"Tulip 3\\", \\"Sunflower 7\\", \\"Rose 2\\", \\"Tulip 9\\", \\"Orchid 4\\"]) [\\"ORC\\", 4, \\"ROS\\", 7, \\"SUN\\", 7, \\"TUL\\", 12] >>> summarize_plant_collection([\\"Rose 5\\", \\"Cactus 3\\", \\"Sunflower 7\\"]) [\\"Invalid data\\"] pass","solution":"def summarize_plant_collection(plant_inputs): def normalize_plant_name(name): words = name.split() if len(words) == 1: return (words[0][:3]).upper() elif len(words) == 2: return (words[0][0] + words[1][:2]).upper() elif len(words) >= 3: return (words[0][0] + words[1][0] + words[2][0]).upper() plant_dict = {} for entry in plant_inputs: name, count = entry.rsplit(maxsplit=1) if name.lower() == \\"cactus\\": return [\\"Invalid data\\"] code = normalize_plant_name(name) count = int(count) if code in plant_dict: plant_dict[code] += count else: plant_dict[code] = count sorted_plants = sorted(plant_dict.items()) result = [] for code, count in sorted_plants: result.append(code) result.append(count) return result"},{"question":"def count_substrings_with_same_start_and_end(s: str) -> int: Returns the number of substrings of s that start and end with the same character. >>> count_substrings_with_same_start_and_end(\\"abc\\") 3 >>> count_substrings_with_same_start_and_end(\\"aaa\\") 6 def solve(test_cases: List[str]) -> List[int]: Returns the list of results for each test case. >>> solve([\\"abc\\", \\"aaa\\"]) [3, 6] >>> solve([\\"abcd\\", \\"ababa\\"]) [4, 9]","solution":"def count_substrings_with_same_start_and_end(s): Returns the number of substrings of s that start and end with the same character. char_count = [0] * 26 for char in s: char_count[ord(char) - ord('a')] += 1 count = 0 for i in range(26): if char_count[i] > 0: count += (char_count[i] * (char_count[i] + 1)) // 2 return count def solve(test_cases): results = [] for s in test_cases: results.append(count_substrings_with_same_start_and_end(s)) return results"},{"question":"def can_arrange_baskets(datasets): Determine whether it is possible to arrange the bamboo strips into baskets such that no two adjacent baskets contain the same predominant color strip. Args: datasets (List[List[int]]): A list of datasets. Each dataset is a list of integers where the first integer is \`n\` (the number of different color groups) and the next \`n\` integers are the count of strips in each group. The end of input is indicated by a single dataset starting with \`0\`. Returns: List[str]: A list of results, \\"Yes\\" or \\"No\\" for each dataset. >>> can_arrange_baskets([[3, 3, 3, 3], [4, 7, 3, 5, 2], [2, 1, 100], [0]]) ['Yes', 'Yes', 'No'] >>> can_arrange_baskets([[2, 5, 5], [0]]) ['Yes'] >>> can_arrange_baskets([[3, 2, 2, 10], [0]]) ['No'] >>> can_arrange_baskets([[3, 100, 150, 100], [4, 250, 250, 245, 255], [0]]) ['Yes', 'Yes'] >>> can_arrange_baskets([[5, 2, 3, 4, 2, 4], [0]]) ['Yes'] def process_input(input_data): Process the raw input data into a structured format. Args: input_data (str): A raw input string containing multiple datasets. Each dataset starts with an integer \`n\` followed by \`n\` integers and is separated by newlines. The end of input is indicated by a single dataset starting with \`0\`. Returns: List[List[int]]: A list of datasets, where each dataset is a list of integers as described above. >>> process_input(\\"3 3 3 3n4 7 3 5 2n2 1 100n0n\\") [[3, 3, 3, 3], [4, 7, 3, 5, 2], [2, 1, 100], [0]]","solution":"def can_arrange_baskets(datasets): results = [] for data in datasets: n = data[0] if n == 0: break strips = data[1:] total = sum(strips) max_count = max(strips) if max_count <= (total + 1) // 2: results.append(\\"Yes\\") else: results.append(\\"No\\") return results def process_input(input_data): lines = input_data.strip().split('n') datasets = [] for line in lines: datasets.append(list(map(int, line.split()))) return datasets"},{"question":"import math from typing import List, Tuple def pascals_triangle_element(n: int, k: int) -> int: Returns the value at the k-th position in the n-th row of Pascal's Triangle. def process_test_cases(test_cases: List[Tuple[int, int]]) -> List[int]: Takes a list of tuples containing test cases and returns a list of results. Each test case is a tuple (n, k). def test_pascals_triangle_element(): assert pascals_triangle_element(4, 2) == 6 assert pascals_triangle_element(5, 3) == 10 assert pascals_triangle_element(7, 0) == 1 assert pascals_triangle_element(0, 0) == 1 assert pascals_triangle_element(1, 0) == 1 assert pascals_triangle_element(1, 1) == 1 assert pascals_triangle_element(10, 5) == 252 def test_process_test_cases(): test_cases = [(4, 2), (5, 3), (7, 0), (0, 0), (1, 0), (1, 1), (10, 5)] expected_results = [6, 10, 1, 1, 1, 1, 252] assert process_test_cases(test_cases) == expected_results","solution":"import math def pascals_triangle_element(n, k): Returns the value at the k-th position in the n-th row of Pascal's Triangle. return math.comb(n, k) def process_test_cases(test_cases): Takes a list of tuples containing test cases and returns a list of results. Each test case is a tuple (n, k). results = [] for n, k in test_cases: results.append(pascals_triangle_element(n, k)) return results"},{"question":"def min_time_to_arrange_balloons(n, colors, k): Write a function to calculate the minimum time required for John to achieve his desired arrangement. The function should take three parameters: - n: an integer representing the number of balloons (1 ≤ n ≤ 10^5) - colors: a list of n integers where each integer represents the color of a balloon (1 ≤ a_i ≤ 10^9) - k: an integer representing the maximum number of operations (0 ≤ k ≤ 10^5) The function should return a single integer, the minimum time required for John to achieve his desired arrangement. Example: >>> min_time_to_arrange_balloons(6, [1, 2, 2, 3, 3, 3], 4) 3 Constraints: - Each balloon can be merged or separated at most k times. - The arrangement involves achieving the minimum possible group size for each color. def test_min_time_to_arrange_balloons(): # Test cases based on the provided examples and additional edge cases assert min_time_to_arrange_balloons(6, [1, 2, 2, 3, 3, 3], 4) == 3 # All balloons with different colors, no operations needed assert min_time_to_arrange_balloons(5, [1, 2, 3, 4, 5], 2) == 0 # All balloons same color, maximum operations less than required assert min_time_to_arrange_balloons(5, [1, 1, 1, 1, 1], 2) == 2 # All balloons with different colors, k is very high assert min_time_to_arrange_balloons(5, [1, 2, 3, 4, 5], 10) == 0 # Large number of same color balloons, with sufficient operations to sort them assert min_time_to_arrange_balloons(7, [4, 4, 4, 4, 4, 4, 4], 4) == 4 # Large number of same color balloons, but not sufficient operations to fully separate them assert min_time_to_arrange_balloons(10, [3, 3, 3, 3, 3, 3, 3, 3, 3, 3], 5) == 5 # Single balloon case assert min_time_to_arrange_balloons(1, [1], 0) == 0","solution":"def min_time_to_arrange_balloons(n, colors, k): Returns the minimum time required to arrange the balloons such that all balloons in a group have the same color, and the size of any group is the minimum possible. from collections import Counter color_count = Counter(colors) color_freqs = list(color_count.values()) color_freqs.sort(reverse=True) total_operations = 0 while k > 0 and color_freqs: max_freq = color_freqs[0] if max_freq == 1: # No need to perform any more operations since all groups are minimized break else: color_freqs[0] -= 1 k -= 1 total_operations += 1 color_freqs.sort(reverse=True) return total_operations"},{"question":"def smallest_prime_factor(N: int) -> int: Returns the smallest prime factor that appears more frequently than any other prime factor in N's prime factor decomposition. If no such prime factor exists, return -1. Examples: >>> smallest_prime_factor(20) 2 >>> smallest_prime_factor(45) 3 >>> smallest_prime_factor(49) 7 >>> smallest_prime_factor(18) -1 >>> smallest_prime_factor(2) 2 >>> smallest_prime_factor(15) -1 >>> smallest_prime_factor(60) 2 >>> smallest_prime_factor(81) 3 >>> smallest_prime_factor(600851475143) -1","solution":"def smallest_prime_factor(N): Returns the smallest prime factor that appears more frequently than any other prime factor in N's prime factor decomposition. If no such prime factor exists, return -1. def prime_factors(n): Return a dictionary of prime factors and their counts for a given integer n. factors = {} # Count the number of 2s that divide n while n % 2 == 0: if 2 in factors: factors[2] += 1 else: factors[2] = 1 n //= 2 # n must be odd at this point, so a skip of 2 (i.e., 3, 5, 7, 9) is used for i in range(3, int(n**0.5) + 1, 2): # While i divides n, count i and divide n while n % i == 0: if i in factors: factors[i] += 1 else: factors[i] = 1 n //= i # If n is a prime number greater than 2 if n > 2: factors[n] = 1 return factors # Find the prime factors of N factors = prime_factors(N) if len(factors) == 0: return -1 # Sort factors by key sorted_factors = sorted(factors.items()) # Find the smallest prime factor that appears more frequently than the second one if len(sorted_factors) == 1: return sorted_factors[0][0] if sorted_factors[0][1] > sorted_factors[1][1]: return sorted_factors[0][0] else: return -1"},{"question":"def can_capture_optimal_photo(n: int, m: int, settings: List[int], required_counts: List[int]) -> str: Determines if there exists a contiguous subarray of the settings that meets the requirement of exact counts of each type. Args: n: int - the number of settings m: int - the number of possible types of settings settings: List[int] - the settings values required_counts: List[int] - the required exact counts of each setting type Returns: str - \\"YES\\" if there exists such a subarray, \\"NO\\" otherwise >>> can_capture_optimal_photo(6, 3, [1, 2, 2, 1, 3, 2], [1, 2, 1]) 'YES' >>> can_capture_optimal_photo(3, 2, [1, 1, 1], [1, 2]) 'NO' >>> can_capture_optimal_photo(4, 2, [1, 2, 1, 2], [2, 2]) 'YES' >>> can_capture_optimal_photo(5, 3, [1, 3, 2, 1, 2], [1, 1, 1]) 'YES' >>> can_capture_optimal_photo(7, 3, [1, 2, 2, 3, 1, 2, 3], [1, 1, 1]) 'YES'","solution":"def can_capture_optimal_photo(n, m, settings, required_counts): Determines if there exists a contiguous subarray of the settings that meets the requirement of exact counts of each type. Args: n: int - the number of settings m: int - the number of possible types of settings settings: list[int] - the settings values required_counts: list[int] - the required exact counts of each setting type Returns: str - \\"YES\\" if there exists such a subarray, \\"NO\\" otherwise from collections import Counter desired_count = Counter() for i in range(m): desired_count[i + 1] = required_counts[i] for start in range(n): current_count = Counter() for end in range(start, n): current_count[settings[end]] += 1 if current_count == desired_count: return \\"YES\\" return \\"NO\\""},{"question":"def find_overlapping_employees(n: int, tasks: List[Tuple[int, int, int]]) -> List[int]: Identify all employees who have overlapping tasks and return their IDs in ascending order. Args: n: An integer, number of tasks recorded. tasks: A list of tuples, where each tuple contains (employee_id, start_time, end_time). Returns: A list of employee IDs who have at least one overlapping task, in ascending order. If no such employee exists, return an empty list. Example: >>> find_overlapping_employees(5, [(1, 0900, 1100), (2, 1000, 1200), (1, 1030, 1130), (2, 1230, 1400), (3, 1500, 1700)]) [1, 2] >>> find_overlapping_employees(4, [(1, 0900, 1000), (2, 1000, 1100), (3, 1100, 1200), (4, 1300, 1400)]) [] pass def parse_input(input_string: str) -> Tuple[int, List[Tuple[int, int, int]]]: Helper function to parse input string. Args: input_string: A string representing the input. Returns: A tuple containing: - An integer n, the number of tasks. - A list of tuples where each tuple contains task details (employee_id, start_time, end_time). Example: >>> parse_input(\\"5n1 0900 1100n2 1000 1200n1 1030 1130n2 1230 1400n3 1500 1700\\") (5, [(1, 0900, 1100), (2, 1000, 1200), (1, 1030, 1130), (2, 1230, 1400), (3, 1500, 1700)]) pass","solution":"def find_overlapping_employees(n, tasks): from collections import defaultdict overlaps = defaultdict(list) for task in tasks: employee_id, start_time, end_time = task if not overlaps[employee_id]: overlaps[employee_id].append((start_time, end_time)) else: for s_time, e_time in overlaps[employee_id]: if not (end_time <= s_time or start_time >= e_time): return sorted([employee for employee in overlaps.keys()]) overlaps[employee_id].append((start_time, end_time)) return [] # Helper function to parse inputs def parse_input(input_string): lines = input_string.strip().split('n') n = int(lines[0]) tasks = [tuple(map(int, line.split())) for line in lines[1:n+1]] return n, tasks"},{"question":"def update_department(employees: dict, updates: dict) -> None: Updates the department of employees based on the updates provided. Parameters: employees (dict): Dictionary of employee information. updates (dict): Dictionary with employee IDs as keys and new department names as values. Returns: None: The employees dictionary is updated in place. >>> employees = { ... \\"E123\\": {\\"name\\": \\"John Doe\\", \\"age\\": 28, \\"department\\": \\"Sales\\"}, ... \\"E124\\": {\\"name\\": \\"Jane Smith\\", \\"age\\": 34, \\"department\\": \\"Engineering\\"}, ... \\"E125\\": {\\"name\\": \\"Sam Black\\", \\"age\\": 22, \\"department\\": \\"HR\\"} ... } >>> updates = { ... \\"E123\\": \\"Marketing\\", ... \\"E126\\": \\"Finance\\", ... \\"E124\\": \\"Product\\" ... } >>> update_department(employees, updates) >>> employees {'E123': {'name': 'John Doe', 'age': 28, 'department': 'Marketing'}, 'E124': {'name': 'Jane Smith', 'age': 34, 'department': 'Product'}, 'E125': {'name': 'Sam Black', 'age': 22, 'department': 'HR'}}","solution":"def update_department(employees, updates): Updates the department of employees based on the updates provided. Parameters: employees (dict): Dictionary of employee information. updates (dict): Dictionary with employee IDs as keys and new department names as values. Returns: None: The employees dictionary is updated in place. for emp_id, new_department in updates.items(): if emp_id in employees: employees[emp_id]['department'] = new_department"},{"question":"from typing import List def find_repeated_sequences(n: int, k: int, sequences: List[str]) -> List[str]: Find sequences that repeat exactly k times in the list, and return them in lexicographical order. >>> find_repeated_sequences(5, 2, [\\"ATCG\\", \\"GCTA\\", \\"ATCG\\", \\"CGTA\\", \\"GCTA\\"]) [\\"ATCG\\", \\"GCTA\\"] >>> find_repeated_sequences(4, 3, [\\"AGT\\", \\"AGT\\", \\"AGT\\", \\"GAT\\"]) [\\"AGT\\"] >>> find_repeated_sequences(6, 1, [\\"TTT\\", \\"AAC\\", \\"GCC\\", \\"TTT\\", \\"AAC\\", \\"GGA\\"]) [\\"GCC\\", \\"GGA\\"] >>> find_repeated_sequences(5, 3, [\\"TTT\\", \\"AAC\\", \\"GCC\\", \\"TTT\\", \\"AAC\\"]) [] >>> find_repeated_sequences(4, 1, [\\"AAA\\", \\"BBB\\", \\"CCC\\", \\"DDD\\"]) [\\"AAA\\", \\"BBB\\", \\"CCC\\", \\"DDD\\"] >>> find_repeated_sequences(4, 4, [\\"AAA\\", \\"AAA\\", \\"AAA\\", \\"AAA\\"]) [\\"AAA\\"]","solution":"def find_repeated_sequences(n, k, sequences): from collections import Counter counter = Counter(sequences) result = [seq for seq, count in counter.items() if count == k] return sorted(result)"},{"question":"def filter_multiples(lst, X): Returns a list containing only the elements of the original list that are multiples of X. Parameters: lst (list of int): The list of positive integers. X (int): The integer used to filter multiples. Returns: list of int: A new list with elements that are multiples of X. Examples: >>> filter_multiples([5, 10, 15, 20, 25, 30, 35, 40], 5) [5, 10, 15, 20, 25, 30, 35, 40] >>> filter_multiples([3, 7, 11, 14, 18, 21, 24], 7) [7, 14, 21] >>> filter_multiples([1, 3, 4, 6, 8, 9], 5) []","solution":"def filter_multiples(lst, X): Returns a list containing only the elements of the original list that are multiples of X. Parameters: lst (list of int): The list of positive integers. X (int): The integer used to filter multiples. Returns: list of int: A new list with elements that are multiples of X. return [num for num in lst if num % X == 0]"},{"question":"def transfer_order(cases): Determines the order in which chemicals will be transferred from labs to central storage. Args: cases (List[Dict]): A list of test cases, each containing lab information. Each lab information includes the lab name as a string, the number of chemicals as an integer, and the weight capacity of each chemical as an integer. Returns: List[List[str]]: A list of lists. Each inner list contains the order of lab names as chemicals are transferred. Example: >>> transfer_order([{'labs': [{'name': 'LABA', 'count': 3, 'weight': 10}, {'name': 'LABB', 'count': 2, 'weight': 20}, {'name': 'LABC', 'count': 4, 'weight': 5}]}]) [['LABB', 'LABB', 'LABA', 'LABA', 'LABA', 'LABC', 'LABC', 'LABC', 'LABC']] >>> transfer_order([{'labs': [{'name': 'LABX', 'count': 1, 'weight': 100}, {'name': 'LABY', 'count': 2, 'weight': 50}]}]) [['LABX', 'LABY', 'LABY']] >>> transfer_order([{'labs': [{'name': 'LABA', 'count': 1, 'weight': 10}, {'name': 'LABC', 'count': 1, 'weight': 10}, {'name': 'LABB', 'count': 1, 'weight': 10}]}]) [['LABA', 'LABB', 'LABC']]","solution":"def transfer_order(cases): result = [] for case in cases: labs = case['labs'] lab_queue = [] for lab in labs: name, count, weight = lab['name'], lab['count'], lab['weight'] for _ in range(count): lab_queue.append((weight, name)) lab_queue.sort(key=lambda x: (-x[0], x[1])) case_result = [lab[1] for lab in lab_queue] result.append(case_result) return result"},{"question":"from typing import List def find_longest_unique_subsequence(arr: List[int]) -> List[int]: Returns the longest subsequence of elements that appear exactly once in the array. >>> find_longest_unique_subsequence([4, 3, 4, 3, 7, 4, 3, 7, 3, 6]) [6] >>> find_longest_unique_subsequence([1, 2, 2, 3, 1]) [3] >>> find_longest_unique_subsequence([5, 5, 5, 5, 5]) [] # Your code here def solve(t: int, test_cases: List[List[int]]) -> List[str]: Given multiple test cases, returns the longest subsequence of elements that appear exactly once in the array for each case. >>> solve(3, [[4, 3, 4, 3, 7, 4, 3, 7, 3, 6], [1, 2, 2, 3, 1], [5, 5, 5, 5, 5]]) [\\"6\\", \\"3\\", \\"\\"] >>> solve(1, [[10, 20, 30, 40, 50]]) [\\"10 20 30 40 50\\"] # Your code here","solution":"def find_longest_unique_subsequence(arr): Returns the longest subsequence of elements that appear exactly once in the array. from collections import Counter element_count = Counter(arr) unique_elements = [x for x in arr if element_count[x] == 1] return unique_elements def solve(t, test_cases): results = [] for case in test_cases: arr = case result = find_longest_unique_subsequence(arr) results.append(' '.join(map(str, result))) return results"},{"question":"from typing import List def findShortestContainingWord(words: List[str], n: int, characters: str) -> str: Given an array of strings words[] of length n, determine the shortest word in the list that contains all the characters of the given string characters. >>> findShortestContainingWord([\\"step\\", \\"steps\\", \\"stripe\\", \\"stepple\\", \\"stepladder\\"], 5, \\"ppe\\") == \\"stepple\\" >>> findShortestContainingWord([\\"apple\\", \\"banana\\", \\"application\\", \\"apply\\"], 4, \\"apl\\") == \\"apple\\" >>> findShortestContainingWord([\\"car\\", \\"bike\\", \\"plane\\"], 3, \\"xyz\\") is None >>> findShortestContainingWord([\\"orange\\", \\"grape\\", \\"apple\\"], 3, \\"app\\") == \\"apple\\" >>> findShortestContainingWord([\\"king\\", \\"knight\\", \\"kite\\"], 3, \\"kit\\") == \\"kite\\" >>> findShortestContainingWord([\\"abcd\\", \\"abcde\\", \\"abcdef\\"], 3, \\"abc\\") == \\"abcd\\" >>> findShortestContainingWord([\\"abcd\\", \\"abcde\\", \\"abcdef\\"], 3, \\"\\") == \\"abcd\\"","solution":"def findShortestContainingWord(words, n, characters): from collections import Counter def contains_all_chars(word, chars_counter): word_counter = Counter(word) for char, count in chars_counter.items(): if word_counter[char] < count: return False return True characters_counter = Counter(characters) shortest_word = None for word in words: if contains_all_chars(word, characters_counter): if shortest_word is None or len(word) < len(shortest_word): shortest_word = word return shortest_word"},{"question":"from typing import List def phone_combinations(digits: str) -> List[str]: Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent based on the standard phone number to letter mapping. >>> phone_combinations(\\"23\\") == [\\"ad\\",\\"ae\\",\\"af\\",\\"bd\\",\\"be\\",\\"bf\\",\\"cd\\",\\"ce\\",\\"cf\\"] >>> phone_combinations(\\"7\\") == [\\"p\\",\\"q\\",\\"r\\",\\"s\\"] >>> phone_combinations(\\"234\\") == [\\"adg\\", \\"adh\\", \\"adi\\", \\"aeg\\", \\"aeh\\", \\"aei\\", \\"afg\\", \\"afh\\", \\"afi\\", \\"bdg\\", \\"bdh\\", \\"bdi\\", \\"beg\\", \\"beh\\", \\"bei\\", \\"bfg\\", \\"bfh\\", \\"bfi\\", \\"cdg\\", \\"cdh\\", \\"cdi\\", \\"ceg\\", \\"ceh\\", \\"cei\\", \\"cfg\\", \\"cfh\\", \\"cfi\\"] >>> phone_combinations(\\"92\\") == [\\"wa\\",\\"wb\\",\\"wc\\",\\"xa\\",\\"xb\\",\\"xc\\",\\"ya\\",\\"yb\\",\\"yc\\",\\"za\\",\\"zb\\",\\"zc\\"] >>> phone_combinations(\\"4\\") == [\\"g\\",\\"h\\",\\"i\\"]","solution":"from typing import List def phone_combinations(digits: str) -> List[str]: Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. if not digits: return [] # mapping of digit to letters digit_to_letters = { \\"2\\": \\"abc\\", \\"3\\": \\"def\\", \\"4\\": \\"ghi\\", \\"5\\": \\"jkl\\", \\"6\\": \\"mno\\", \\"7\\": \\"pqrs\\", \\"8\\": \\"tuv\\", \\"9\\": \\"wxyz\\" } def backtrack(index: int, path: str): if index == len(digits): combinations.append(path) return possible_letters = digit_to_letters[digits[index]] for letter in possible_letters: backtrack(index + 1, path + letter) combinations = [] backtrack(0, \\"\\") return combinations"},{"question":"def transform_string(s: str) -> str: Transforms each character in the string to the next character in the alphabet. The alphabet is considered cyclic, so 'z' becomes 'a'. >>> transform_string(\\"abc\\") \\"bcd\\" >>> transform_string(\\"xyz\\") \\"yza\\" >>> transform_string(\\"hello\\") \\"ifmmp\\" >>> transform_string(\\"z\\") \\"a\\" >>> transform_string(\\"az\\") \\"ba\\" def transform_input(input_lines: List[str]) -> List[str]: Takes a list of input lines and transforms each line according to the transform_string function. Stops processing when a line containing an asterisk '*' is encountered. >>> transform_input([\\"abc\\", \\"xyz\\", \\"hello\\", \\"*\\"]) [\\"bcd\\", \\"yza\\", \\"ifmmp\\"] >>> transform_input([\\"abcd\\", \\"zzz\\", \\"mnop\\", \\"*\\", \\"after\\"]) [\\"bcde\\", \\"aaa\\", \\"nopq\\"] >>> transform_input([\\"aaaa\\", \\"zzzz\\", \\"*\\", \\"beef\\"]) [\\"bbbb\\", \\"aaaa\\"]","solution":"def transform_string(s): Transforms each character in the string to the next character in the alphabet. The alphabet is considered cyclic, so 'z' becomes 'a'. transformed = [] for char in s: if char == 'z': transformed.append('a') else: transformed.append(chr(ord(char) + 1)) return ''.join(transformed) def transform_input(input_lines): Takes a list of input lines and transforms each line according to the transform_string function. Stops processing when a line containing an asterisk '*' is encountered. results = [] for line in input_lines: if line.strip() == '*': break results.append(transform_string(line.strip())) return results"},{"question":"def max_non_overlapping_tasks(tasks): Given a list of tasks represented as tuples of (start_time, end_time), find the maximum number of non-overlapping tasks that can be completed starting from each k = 1, 2, ..., N. >>> max_non_overlapping_tasks([(1, 3), (2, 5), (4, 6), (7, 9), (8, 10)]) [3, 2, 2, 1, 1] >>> max_non_overlapping_tasks([(3, 4), (1, 2), (2, 3), (5, 6)]) [2, 3, 2, 1] >>> max_non_overlapping_tasks([(1, 10), (2, 9), (3, 8), (4, 7), (5, 6)]) [1, 1, 1, 1, 1] >>> max_non_overlapping_tasks([(1, 3), (3, 4), (4, 5)]) [3, 2, 1] >>> max_non_overlapping_tasks([(1, 2), (1, 2), (1, 2)]) [1,1,1] >>> max_non_overlapping_tasks([(1, 2)]) [1]","solution":"def max_non_overlapping_tasks(tasks): Given a list of tasks represented as tuples of (start_time, end_time), find the maximum number of non-overlapping tasks that can be completed starting from each k = 1, 2, ..., N. Parameters: tasks (List[Tuple[int, int]]): List of tasks where each task is represented as (start_time, end_time) Returns: List[int]: List of maximum number of non-overlapping tasks that can be completed starting from each k def find_max_tasks(start_index): selected_tasks = 0 current_end_time = -1 for idx in range(start_index, len(tasks)): start, end = tasks[idx] if start >= current_end_time: selected_tasks += 1 current_end_time = end return selected_tasks result = [] for i in range(len(tasks)): result.append(find_max_tasks(i)) return result # To match the expected input/output format def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) tasks = [(int(data[2*i + 1]), int(data[2*i + 2])) for i in range(N)] result = max_non_overlapping_tasks(tasks) for r in result: print(r)"},{"question":"def compressString(S: str, N: int) -> str: Compress the string such that consecutive characters that appear N or more times in a row are replaced by the character followed by the count of its occurrences. >>> compressString(\\"aaabccccd\\", 3) 'a3bc4d' >>> compressString(\\"aabbcc\\", 2) 'a2b2c2' >>> compressString(\\"abc\\", 3) 'abc' from solution import compressString def test_example_1(): assert compressString(\\"aaabccccd\\", 3) == \\"a3bc4d\\" def test_example_2(): assert compressString(\\"aabbcc\\", 2) == \\"a2b2c2\\" def test_example_3(): assert compressString(\\"abc\\", 3) == \\"abc\\" def test_single_character_repeated_below_N(): assert compressString(\\"aaaaa\\", 10) == \\"aaaaa\\" def test_single_character_repeated_above_N(): assert compressString(\\"aaaaa\\", 2) == \\"a5\\" def test_mixed_characters_with_varied_repeats(): assert compressString(\\"aabbbccccddeee\\", 3) == \\"aab3c4dde3\\" def test_no_repeats_at_all(): assert compressString(\\"abcdefgh\\", 2) == \\"abcdefgh\\" def test_all_repeats_below_N(): assert compressString(\\"aabbcc\\", 3) == \\"aabbcc\\" def test_all_repeats_exactly_N(): assert compressString(\\"aabbcc\\", 2) == \\"a2b2c2\\"","solution":"def compressString(S, N): compressed = [] i = 0 length = len(S) while i < length: count = 1 while i + 1 < length and S[i] == S[i + 1]: count += 1 i += 1 if count >= N: compressed.append(f\\"{S[i]}{count}\\") else: compressed.append(S[i] * count) i += 1 return ''.join(compressed)"},{"question":"def longestConsecutiveSubarray(nums): Returns the length of the longest subarray that can be rearranged to form a consecutive sequence. >>> longestConsecutiveSubarray([1, 2, 2, 3, 4, 5]) 5 >>> longestConsecutiveSubarray([10, 1, 3, 5, 2, 6, 4]) 6 pass def test_longestConsecutiveSubarray_1(): nums = [1, 2, 2, 3, 4, 5] assert longestConsecutiveSubarray(nums) == 5 def test_longestConsecutiveSubarray_2(): nums = [10, 1, 3, 5, 2, 6, 4] assert longestConsecutiveSubarray(nums) == 6 def test_longestConsecutiveSubarray_empty(): nums = [] assert longestConsecutiveSubarray(nums) == 0 def test_longestConsecutiveSubarray_single_element(): nums = [100] assert longestConsecutiveSubarray(nums) == 1 def test_longestConsecutiveSubarray_with_negative_numbers(): nums = [8, 7, -1, -2, 20, 21, 6] assert longestConsecutiveSubarray(nums) == 3 def test_longestConsecutiveSubarray_with_large_nums(): nums = [10**5, 10**5-1, 10**5-2, 1, 2, 3, 4, 5, 0] assert longestConsecutiveSubarray(nums) == 6 def test_longestConsecutiveSubarray_all_duplicates(): nums = [1, 1, 1, 1] assert longestConsecutiveSubarray(nums) == 1 def test_longestConsecutiveSubarray_mixed_positive_negative(): nums = [0, -1, 1, 2, -2] assert longestConsecutiveSubarray(nums) == 5","solution":"def longestConsecutiveSubarray(nums): Returns the length of the longest subarray that can be rearranged to form a consecutive sequence. if not nums: return 0 nums_set = set(nums) # Create a set of numbers to improve search time longest_streak = 0 for num in nums_set: if (num - 1) not in nums_set: # num is the start of a new sequence current_num = num current_streak = 1 while (current_num + 1) in nums_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def count_ways_ada_wins(l: int, s: str) -> int: Determine the number of possible ways for Ada to always win the game. Input: l (int): Length of the string \`s\` s (str): A string consisting of \`l\` lowercase alphabetical characters. Output: int: Number of ways Ada will always win. Examples: >>> count_ways_ada_wins(5, 'ababa') 6 >>> count_ways_ada_wins(2, 'ab') 1","solution":"def count_ways_ada_wins(l, s): def is_winning_position(length): return length % 2 == 1 return sum(1 for i in range(1, l + 1) if is_winning_position(i))"},{"question":"def maxConsecutiveOnes(s: str, k: int) -> int: Return the maximum number of consecutive 1s achievable by flipping at most k 0s. >>> maxConsecutiveOnes(\\"110100110\\", 3) 8 >>> maxConsecutiveOnes(\\"1100111\\", 2) 7 >>> maxConsecutiveOnes(\\"00001000\\", 1) 2 >>> maxConsecutiveOnes(\\"111\\", 0) 3 >>> maxConsecutiveOnes(\\"0\\", 2) 1","solution":"def maxConsecutiveOnes(s: str, k: int) -> int: Return the maximum number of consecutive 1s achievable by flipping at most k 0s. left, max_1s = 0, 0 num_zeros = 0 for right in range(len(s)): if s[right] == '0': num_zeros += 1 while num_zeros > k: if s[left] == '0': num_zeros -= 1 left += 1 max_1s = max(max_1s, right - left + 1) return max_1s"},{"question":"from collections import deque from typing import List, Tuple def shortestPath(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int: Find the shortest path in a 2D grid maze from start position to end position, moving only up, down, left, or right. >>> grid = [ ... [0, 0, 1, 0, 0], ... [0, 1, 0, 0, 1], ... [0, 1, 0, 1, 0], ... [0, 0, 0, 0, 0], ... [1, 1, 0, 1, 0] ... ] >>> start = (0, 0) >>> end = (3, 4) >>> shortestPath(grid, start, end) 7 def test_shortest_path_exists(): grid = [ [0, 0, 1, 0, 0], [0, 1, 0, 0, 1], [0, 1, 0, 1, 0], [0, 0, 0, 0, 0], [1, 1, 0, 1, 0] ] start = (0, 0) end = (3, 4) assert shortestPath(grid, start, end) == 7 def test_no_path_exists(): grid = [ [0, 1, 1, 0], [1, 1, 0, 0], [0, 0, 1, 1], [1, 0, 0, 0] ] start = (0, 0) end = (3, 3) assert shortestPath(grid, start, end) == -1 def test_start_is_end(): grid = [ [0, 0], [0, 1] ] start = (0, 0) end = (0, 0) assert shortestPath(grid, start, end) == 0 def test_single_path(): grid = [ [0, 0], [1, 0] ] start = (0, 0) end = (1, 1) assert shortestPath(grid, start, end) == 2 def test_longer_maze(): grid = [ [0, 1, 0, 0, 0, 0], [0, 1, 0, 1, 1, 0], [0, 0, 0, 1, 0, 0], [0, 1, 1, 1, 0, 1], [0, 0, 0, 0, 0, 0] ] start = (0, 0) end = (4, 5) assert shortestPath(grid, start, end) == 9 def test_no_way_to_exit(): grid = [ [0, 1], [1, 1] ] start = (0, 0) end = (1, 1) assert shortestPath(grid, start, end) == -1","solution":"from collections import deque def shortestPath(grid, start, end): rows, cols = len(grid), len(grid[0]) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] def is_valid(x, y): return 0 <= x < rows and 0 <= y < cols and grid[x][y] == 0 queue = deque([(start[0], start[1], 0)]) # (x, y, distance) visited = set() visited.add(start) while queue: x, y, dist = queue.popleft() if (x, y) == end: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"def game_winner(n: int, k: int, sequence: List[int]) -> str: Determines which player wins if they play optimally. Parameters: n (int): Length of the sequence. k (int): The threshold for the absolute difference. sequence (list): The list of distinct integers. Returns: str: \\"First\\" if the first player wins, \\"Second\\" otherwise. >>> game_winner(5, 10, [15, 5, 1, 8, 14]) \\"Second\\" >>> game_winner(3, 15, [20, 10, 25]) \\"First\\" >>> game_winner(1, 5, [100]) \\"First\\" >>> game_winner(4, 1, [1, 2, 3, 5]) \\"Second\\" >>> game_winner(6, 20, [11, 9, 10, 2, 25, 5]) \\"Second\\" >>> game_winner(2, 30, [-20, 5]) \\"First\\"","solution":"def game_winner(n, k, sequence): Determines which player wins if they play optimally. Parameters: n (int): Length of the sequence. k (int): The threshold for the absolute difference. sequence (list): The list of distinct integers. Returns: str: \\"First\\" if the first player wins, \\"Second\\" otherwise. sequence.sort() if sequence[-1] - sequence[0] > k: return \\"Second\\" else: return \\"First\\""},{"question":"def format_list(list_of_integers): Formats a list of integers into a string separated by colons. Parameters: list_of_integers (list): A list of integers. Returns: str: A colon-separated string of integers. >>> format_list([34, -2, 78, 14]) '34:-2:78:14' >>> format_list([1, 2, 3, 4, 5]) '1:2:3:4:5' >>> format_list([-1, -2, -3, -4, -5]) '-1:-2:-3:-4:-5' >>> format_list([0, 0, 0]) '0:0:0' >>> format_list([-1000, 1000, 0]) '-1000:1000:0' >>> format_list(list(range(1, 101))) '1:2:3:4:5:6:7:8:9:10:11:12:13:14:15:16:17:18:19:20:21:22:23:24:25:26:27:28:29:30:31:32:33:34:35:36:37:38:39:40:41:42:43:44:45:46:47:48:49:50:51:52:53:54:55:56:57:58:59:60:61:62:63:64:65:66:67:68:69:70:71:72:73:74:75:76:77:78:79:80:81:82:83:84:85:86:87:88:89:90:91:92:93:94:95:96:97:98:99:100'","solution":"def format_list(list_of_integers): Formats a list of integers into a string separated by colons. Parameters: list_of_integers (list): A list of integers. Returns: str: A colon-separated string of integers. return ':'.join(map(str, list_of_integers))"},{"question":"def count_single_and_pair_combinations(n: int) -> (int, int): Returns the number of single task assignments and unique pair combinations of different tasks. >>> count_single_and_pair_combinations(3) (3, 3) >>> count_single_and_pair_combinations(4) (4, 6) >>> count_single_and_pair_combinations(5) (5, 10)","solution":"def count_single_and_pair_combinations(n): Returns the number of single task assignments and unique pair combinations of different tasks. :param n: The number of tasks :return: A tuple (number of single task assignments, number of unique pair combinations) single_task_assignments = n pair_combinations = (n * (n - 1)) // 2 return (single_task_assignments, pair_combinations)"},{"question":"from typing import List def maxProductOfThree(nums: List[int]) -> int: Given an integer array, find the maximum possible product of three numbers in the array. >>> maxProductOfThree([1, 2, 3, 4]) 24 >>> maxProductOfThree([-10, -10, 5, 2]) 500","solution":"def maxProductOfThree(nums): Returns the maximum product of three numbers from the array. nums.sort() # The maximum product can be either the product of the three largest numbers # or the product of the two smallest numbers (which could be negative) and the largest number. return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])"},{"question":"def rearrange_string(s: str) -> str: Returns the string with all letters before digits while maintaining the relative order of letters and digits. >>> rearrange_string(\\"a1b2c3\\") 'abc123' >>> rearrange_string(\\"123abc\\") 'abc123' >>> rearrange_string(\\"abc\\") 'abc' >>> rearrange_string(\\"123\\") '123' >>> rearrange_string(\\"a1b2c3d4\\") 'abcd1234' >>> rearrange_string(\\"1a2b3c\\") 'abc123' def process_test_cases(t: int, test_cases: List[str]) -> List[str]: Processes a list of test cases and returns the rearranged strings. >>> process_test_cases(2, [\\"a1b2c3\\", \\"123abc\\"]) ['abc123', 'abc123'] >>> process_test_cases(1, [\\"a1b2c3d4\\"]) ['abcd1234'] >>> process_test_cases(3, [\\"abc123\\", \\"1a2b3c\\", \\"1234\\"]) ['abc123', 'abc123', '1234'] >>> process_test_cases(2, [\\"abcd\\", \\"1234\\"]) ['abcd', '1234']","solution":"def rearrange_string(s): Returns the string with all letters before digits while maintaining the relative order of letters and digits. letters = [] digits = [] for char in s: if char.isdigit(): digits.append(char) else: letters.append(char) return ''.join(letters + digits) def process_test_cases(t, test_cases): results = [] for s in test_cases: results.append(rearrange_string(s)) return results"},{"question":"from typing import List, Tuple def minimal_additional_routes(n: int, m: int, s: int, edges: List[Tuple[int, int]]) -> int: Determine the minimal number of additional routes needed to ensure all warehouses are reachable from the start warehouse. Parameters: n (int): The number of warehouses (nodes). m (int): The number of existing routes (directed edges). s (int): The designated start warehouse. edges (List[Tuple[int, int]]): The list of directed edges representing the existing routes. Returns: int: The minimal number of additional routes needed. Examples: >>> minimal_additional_routes(5, 4, 1, [(1, 2), (2, 3), (4, 5), (5, 1)]) 2 >>> minimal_additional_routes(3, 2, 2, [(2, 3), (3, 1)]) 0 def test_minimal_additional_routes(): assert minimal_additional_routes(5, 4, 1, [(1, 2), (2, 3), (4, 5), (5, 1)]) == 2 assert minimal_additional_routes(3, 2, 2, [(2, 3), (3, 1)]) == 0 assert minimal_additional_routes(4, 1, 1, [(1, 2)]) == 2 assert minimal_additional_routes(4, 4, 1, [(1, 2), (2, 3), (3, 4), (4, 1)]) == 0 assert minimal_additional_routes(6, 3, 1, [(1, 2), (2, 3), (3, 4)]) == 2 if __name__ == '__main__': test_minimal_additional_routes()","solution":"from collections import defaultdict, deque def minimal_additional_routes(n, m, s, edges): def bfs(start, graph): visited = [False] * (n + 1) queue = deque([start]) visited[start] = True while queue: node = queue.popleft() for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return visited # Create graph from edges graph = defaultdict(list) for u, v in edges: graph[u].append(v) # Find all reachable nodes from start reachable_from_start = bfs(s, graph) # Detect all nodes all_nodes = set(range(1, n + 1)) # Find unreachable nodes from start unreachable_nodes = [i for i in all_nodes if not reachable_from_start[i]] # Reverse graph reverse_graph = defaultdict(list) for u, v in edges: reverse_graph[v].append(u) reverse_reachable_from_unreachable = set() for node in unreachable_nodes: visited = bfs(node, reverse_graph) reverse_reachable_from_unreachable.update(node for node, v in enumerate(visited) if v) # Find set difference need_links = reverse_reachable_from_unreachable - set(node for node in all_nodes if reachable_from_start[node]) return len(need_links)"},{"question":"def min_edit_distance(source: str, target: str) -> int: Determine the minimum number of operations required to transform source into target using insert, delete, replace operations. >>> min_edit_distance(\\"cat\\", \\"cut\\") 1 >>> min_edit_distance(\\"abc\\", \\"yabd\\") 2 >>> min_edit_distance(\\"intention\\", \\"execution\\") 5","solution":"def min_edit_distance(source, target): m, n = len(source), len(target) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # Insert all characters of target elif j == 0: dp[i][j] = i # Delete all characters of source elif source[i - 1] == target[j - 1]: dp[i][j] = dp[i - 1][j - 1] # No change needed else: dp[i][j] = 1 + min(dp[i - 1][j], # Delete dp[i][j - 1], # Insert dp[i - 1][j - 1])# Replace return dp[m][n]"},{"question":"class PetGame: def __init__(self): Initialize the game manager. pass def init(self, player_name: str, pet_name: str): Register a new pet with initial level 1 and XP 0 for the specified player. Each player can have only one pet with the same name. If the pet_name is already registered under that player, ignore this operation. pass def gain_xp(self, player_name: str, pet_name: str, xp: int): Increase the XP of the specified pet belonging to the specified player by xp points (1 ≤ xp ≤ 1000). The pet levels up for every 100 XP gained. If the pet levels up, its XP is reset to the remainder after dividing by 100. pass def lose_xp(self, player_name: str, pet_name: str, xp: int): Decrease the XP of the specified pet belonging to the specified player by xp points (1 ≤ xp ≤ 1000). If the xp to be lost exceeds current XP, the pet levels down (if possible) and the remaining xp is subtracted from a full XP bar of 100 points from the new level. A pet cannot have negative levels or XP. pass def query(self, player_name: str, pet_name: str): Output the current level and XP of the specified pet belonging to the specified player. Output \\"Pet not found\\" if the pet is not registered. pass def undo_d(self, player_name: str, d: int): Undo all changes made to the pets of the specified player in the last d days (not including the current day). Restored states must be applied up to that point in time. pass # Unit Tests def test_pet_game(): game = PetGame() # Test initial registration game.init(\\"alice\\", \\"fluffy\\") game.query(\\"alice\\", \\"fluffy\\") # Expected output: 1 0 # Gain XP and check level up game.gain_xp(\\"alice\\", \\"fluffy\\", 50) game.query(\\"alice\\", \\"fluffy\\") # Expected output: 1 50 game.gain_xp(\\"alice\\", \\"fluffy\\", 60) game.query(\\"alice\\", \\"fluffy\\") # Expected output: 2 10 # Lose XP and check level down game.lose_xp(\\"alice\\", \\"fluffy\\", 30) game.query(\\"alice\\", \\"fluffy\\") # Expected output: 1 80 # Register new pet game.init(\\"bob\\", \\"rex\\") game.query(\\"bob\\", \\"rex\\") # Expected output: 1 0 game.query(\\"alice\\", \\"notfound\\") # Expected output: Pet not found # Undo XP changes game.undo_d(\\"alice\\", 2) game.query(\\"alice\\", \\"fluffy\\") # Expected output: 2 70","solution":"class PetGame: def __init__(self): self.players = {} self.history = {} def init(self, player_name, pet_name): if player_name not in self.players: self.players[player_name] = {} if pet_name not in self.players[player_name]: self.players[player_name][pet_name] = {'level': 1, 'xp': 0} if player_name not in self.history: self.history[player_name] = [] def gain_xp(self, player_name, pet_name, xp): pet = self.players.get(player_name, {}).get(pet_name, None) if not pet: return self.history[player_name].append({'action': 'gain_xp', 'pet': pet_name, 'change': xp}) xp_to_add = xp while xp_to_add > 0: if pet['xp'] + xp_to_add < 100: pet['xp'] += xp_to_add xp_to_add = 0 else: xp_to_add -= (100 - pet['xp']) pet['xp'] = 0 pet['level'] += 1 def lose_xp(self, player_name, pet_name, xp): pet = self.players.get(player_name, {}).get(pet_name, None) if not pet: return self.history[player_name].append({'action': 'lose_xp', 'pet': pet_name, 'change': xp}) xp_to_deduct = xp while xp_to_deduct > 0: if pet['xp'] > xp_to_deduct: pet['xp'] -= xp_to_deduct xp_to_deduct = 0 elif pet['level'] > 0: xp_to_deduct -= (pet['xp'] + 1) pet['level'] -= 1 pet['xp'] = 99 else: pet['xp'] = max(0, pet['xp'] - xp_to_deduct) xp_to_deduct = 0 def query(self, player_name, pet_name): pet = self.players.get(player_name, {}).get(pet_name, None) if pet: print(f\\"{pet['level']} {pet['xp']}\\") else: print(\\"Pet not found\\") def undo_d(self, player_name, d): if player_name not in self.history: return snapshots = self.history[player_name] for action in reversed(snapshots): if action['action'] == 'gain_xp': self.lose_xp(player_name, action['pet'], action['change']) elif action['action'] == 'lose_xp': self.gain_xp(player_name, action['pet'], action['change']) self.history[player_name] = [] import sys input = sys.stdin.read def main(): game = PetGame() data = input().split(\\"n\\") q = int(data[0]) for i in range(1, q+1): operation = data[i].split() command = operation[0] if command == 'init': player_name, pet_name = operation[1], operation[2] game.init(player_name, pet_name) elif command == 'gain_xp': player_name, pet_name, xp = operation[1], operation[2], int(operation[3]) game.gain_xp(player_name, pet_name, xp) elif command == 'lose_xp': player_name, pet_name, xp = operation[1], operation[2], int(operation[3]) game.lose_xp(player_name, pet_name, xp) elif command == 'query': player_name, pet_name = operation[1], operation[2] game.query(player_name, pet_name) elif command == 'undo_d': player_name, d = operation[1], int(operation[2]) game.undo_d(player_name, d) if __name__ == \\"__main__\\": main()"},{"question":"def maxMovies(lengths, minutes): Returns the maximum number of complete movies the user can watch within the given number of minutes. Parameters: lengths (list): List of integers representing the lengths of movies in minutes. minutes (int): Total number of available minutes. Returns: int: Maximum number of movies watched fully. pass def test_maxMovies_example1(): assert maxMovies([120, 90, 150, 80], 300) == 3 def test_maxMovies_example2(): assert maxMovies([200, 150, 100], 330) == 2 def test_maxMovies_not_enough_time(): assert maxMovies([150, 200, 300], 100) == 0 def test_maxMovies_exact_fit(): assert maxMovies([100, 200, 150], 450) == 3 def test_maxMovies_all_same_length(): assert maxMovies([100, 100, 100, 100], 250) == 2 def test_maxMovies_minimal_case(): assert maxMovies([1], 1) == 1 def test_maxMovies_single_long_movie(): assert maxMovies([10000], 10000) == 1 assert maxMovies([10000], 9999) == 0","solution":"def maxMovies(lengths, minutes): Returns the maximum number of complete movies the user can watch within the given number of minutes. Parameters: lengths (list): List of integers representing the lengths of movies in minutes. minutes (int): Total number of available minutes. Returns: int: Maximum number of movies watched fully. # Sort movie lengths in ascending order lengths.sort() movie_count = 0 total_time = 0 for length in lengths: if total_time + length <= minutes: total_time += length movie_count += 1 else: break return movie_count"},{"question":"def smallestSubsequence(S: str) -> str: Given a string S consisting of lowercase English alphabets, return the smallest subsequence such that each character appears exactly once. >>> smallestSubsequence(\\"bcabc\\") 'abc' >>> smallestSubsequence(\\"cbacdcbc\\") 'acdb'","solution":"def smallestSubsequence(S): Returns the smallest subsequence such that each character appears exactly once. stack = [] seen = set() last_occurrence = {c: i for i, c in enumerate(S)} for i, c in enumerate(S): if c not in seen: while stack and c < stack[-1] and i < last_occurrence[stack[-1]]: seen.discard(stack.pop()) stack.append(c) seen.add(c) return ''.join(stack)"},{"question":"from typing import List def largest_number(nums: List[int]) -> str: Write a function that takes a list of non-negative integers and returns the largest possible number that can be made by concatenating them together. >>> largest_number([10, 2]) '210' >>> largest_number([3, 30, 34, 5, 9]) '9534330'","solution":"from functools import cmp_to_key def largest_number(nums): Given a list of non-negative integers, arrange them such that they form the largest number. :param nums: List[int]: List of non-negative integers :return: str: Largest possible concatenated number in string form def custom_compare(x, y): # Compare based on concatenation in both possible orders if x + y > y + x: return -1 # x should come before y if x + y < y + x: return 1 # y should come before x return 0 # x and y are equal in terms of concatenation result # Convert numbers to strings because we need to concatenate them nums_str = [str(num) for num in nums] # Sort using the custom comparator nums_str.sort(key=cmp_to_key(custom_compare)) # Join the sorted numbers into the largest number string largest_num = ''.join(nums_str) # Edge case: if the largest number is \\"0\\" (when all numbers are zero) if largest_num[0] == '0': return '0' return largest_num"},{"question":"def can_redistribute_evenly(n: int, array: List[int]) -> str: Determines if it is possible to redistribute the books such that all shelves have the same number of books. Args: n (int): number of shelves array (List[int]): list of integers, number of books on each shelf Returns: str: 'YES' if redistribution is possible, 'NO' otherwise >>> can_redistribute_evenly(4, [3, 3, 3, 3]) 'YES' >>> can_redistribute_evenly(5, [5, 8, 6, 7, 4]) 'YES' >>> can_redistribute_evenly(4, [3, 3, 3, 4]) 'NO'","solution":"def can_redistribute_evenly(n, array): Determines if it is possible to redistribute the books such that all shelves have the same number of books. :param n: integer, number of shelves :param array: list of integers, number of books on each shelf :return: 'YES' if redistribution is possible, 'NO' otherwise total_books = sum(array) if total_books % n == 0: return \\"YES\\" else: return \\"NO\\""},{"question":"def unique_side_lengths(arr, queries): This function takes in an array of integers representing side lengths of square papers and an array of queries. Each query specifies two indices and the function returns the number of unique side lengths in the specified intervals for each query. >>> unique_side_lengths([4, 5, 6, 4, 7], [(1, 3), (2, 5), (1, 5)]) [3, 4, 4] >>> unique_side_lengths([2, 2, 2, 2], [(1, 3), (1, 4)]) [1, 1] from solution import unique_side_lengths def test_single_query(): arr = [4, 5, 6, 4, 7] queries = [(1, 3)] assert unique_side_lengths(arr, queries) == [3] def test_multiple_queries(): arr = [4, 5, 6, 4, 7] queries = [(1, 3), (2, 5), (1, 5)] assert unique_side_lengths(arr, queries) == [3, 4, 4] def test_all_elements_same(): arr = [2, 2, 2, 2] queries = [(1, 3), (1, 4)] assert unique_side_lengths(arr, queries) == [1, 1] def test_disjoint_queries(): arr = [1, 2, 3, 4, 5] queries = [(1, 2), (3, 4), (5, 5)] assert unique_side_lengths(arr, queries) == [2, 2, 1] def test_single_element_array(): arr = [7] queries = [(1, 1)] assert unique_side_lengths(arr, queries) == [1] def test_larger_range(): arr = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55] queries = [(1, 10), (4, 9)] assert unique_side_lengths(arr, queries) == [9, 6]","solution":"def unique_side_lengths(arr, queries): This function takes in an array of integers and an array of queries, and returns the number of unique integers in the specified intervals for each query. results = [] for l, r in queries: unique_lengths = set(arr[l-1:r]) # l-1 and r because input is 1-based index but Python list is 0-based results.append(len(unique_lengths)) return results"},{"question":"import re from typing import List def validate_passwords(passwords: List[str]) -> List[str]: Validate a list of passwords based on specific rules: - At least 8 characters long - At least one uppercase letter - At least one lowercase letter - At least one digit - At least one special character (!@#%^&*()-+) Args: - passwords (list of str): List of passwords to be validated. Returns: - List of str: \\"VALID\\" or \\"INVALID\\" for each password. >>> validate_passwords([\\"ValidPass1!\\", \\"Another1@\\", \\"StrongPass2\\"]) [\\"VALID\\", \\"VALID\\", \\"VALID\\"] >>> validate_passwords([\\"short!\\", \\"NoNumbers!\\", \\"nouppercase1!\\", \\"NOLOWERCASE1@\\", \\"NoSpecialChar1\\"]) [\\"INVALID\\", \\"INVALID\\", \\"INVALID\\", \\"INVALID\\", \\"INVALID\\"] >>> validate_passwords([\\"Valid1!\\", \\"Invalid\\", \\"ValidPass2#\\", \\"noSpecial2\\", \\"YESU1!\\"]) [\\"VALID\\", \\"INVALID\\", \\"VALID\\", \\"INVALID\\", \\"INVALID\\"] >>> validate_passwords([\\"A1a!2345\\"]) [\\"VALID\\"] >>> validate_passwords([\\"Password1\\"]) [\\"INVALID\\"] >>> validate_passwords([\\"P@ssw0rd\\"]) [\\"VALID\\"]","solution":"import re def validate_passwords(passwords): Validate a list of passwords based on specific rules: - At least 8 characters long - At least one uppercase letter - At least one lowercase letter - At least one digit - At least one special character (!@#%^&*()-+) Args: - passwords (list of str): List of passwords to be validated. Returns: - List of str: \\"VALID\\" or \\"INVALID\\" for each password. results = [] special_characters = re.compile(r'[!@#%^&*()-+]') for password in passwords: if (len(password) >= 8 and any(c.isupper() for c in password) and any(c.islower() for c in password) and any(c.isdigit() for c in password) and special_characters.search(password)): results.append(\\"VALID\\") else: results.append(\\"INVALID\\") return results"},{"question":"def isPalindrome(S: str) -> str: Returns \\"YES\\" if the string S is a palindrome, \\"NO\\" otherwise. >>> isPalindrome(\\"madam\\") \\"YES\\" >>> isPalindrome(\\"hello\\") \\"NO\\" >>> isPalindrome(\\"racecar\\") \\"YES\\"","solution":"def isPalindrome(S): Returns \\"YES\\" if the string S is a palindrome, \\"NO\\" otherwise. return \\"YES\\" if S == S[::-1] else \\"NO\\""},{"question":"def last_fighter_strength(strengths): Determines the strength of the last remaining fighter based on given rules. Parameters: strengths (list of int): List of strengths of fighters. Returns: int: Strength of the last remaining fighter, or 0 if none remain. >>> last_fighter_strength([2, 7, 4, 1, 8, 1]) 1 >>> last_fighter_strength([5]) 5 >>> last_fighter_strength([5, 5, 5, 5, 5, 5]) 0 >>> last_fighter_strength([8, 3]) 5 >>> last_fighter_strength([]) 0 >>> last_fighter_strength([1000, 999, 998, 997, 1000, 999]) 1","solution":"def last_fighter_strength(strengths): Determines the strength of the last remaining fighter based on given rules. Parameters: strengths (list of int): List of strengths of fighters. Returns: int: Strength of the last remaining fighter, or 0 if none remain. while len(strengths) > 1: strengths.sort(reverse=True) # Sort fighters in descending order first = strengths.pop(0) # Pick the strongest fighter second = strengths.pop(0) # Pick the second strongest fighter if first != second: strengths.append(abs(first - second)) # Append the difference return strengths[0] if strengths else 0"},{"question":"def is_possible_permutation(n: int, m: int, grid: List[List[int]]) -> str: Check if it is possible to permute the entries of the grid such that no two adjacent cells have the same type of crop. >>> is_possible_permutation(3, 3, [[1, 2, 3], [2, 3, 1], [3, 1, 2]]) 'YES' >>> is_possible_permutation(2, 2, [[1, 1], [2, 2]]) 'NO'","solution":"def is_possible_permutation(n, m, grid): Returns \\"YES\\" if it is possible to permute the entries of the grid such that no two adjacent cells have the same type of crop. Otherwise, returns \\"NO\\". from collections import defaultdict import itertools # Initialize dictionaries to count occurrences of each crop type in each row and column row_counts = [defaultdict(int) for _ in range(n)] col_counts = [defaultdict(int) for _ in range(m)] # Fill counts for i in range(n): for j in range(m): row_counts[i][grid[i][j]] += 1 col_counts[j][grid[i][j]] += 1 # Check if the maximum count of any crop type is more than half of the row length or column length for i in range(n): for count in row_counts[i].values(): if count > (m + 1) // 2: return \\"NO\\" for j in range(m): for count in col_counts[j].values(): if count > (n + 1) // 2: return \\"NO\\" return \\"YES\\""},{"question":"def check_features(input_data): Processes the input data to check if any version contains all the requested features. :param input_data: List of strings, where each string represents a line of the input. :return: List of strings, each being \\"YES\\" or \\"NO\\" based on whether the features exist in any version. Example: >>> check_features([\\"3\\",\\"1 3 2 3 4\\",\\"2 2 1 3\\",\\"3 4 2 3 4 5\\",\\"2\\",\\"1 3\\",\\"2 3 4\\",\\"0\\"]) [\\"YES\\", \\"YES\\"] >>> check_features([\\"2\\",\\"1 2 1 2\\",\\"2 2 3 4\\",\\"1\\",\\"5\\",\\"0\\"]) [\\"NO\\"] pass import pytest def test_single_version_single_request(): input_data = [\\"1\\", \\"1 3 2 3 4\\", \\"1\\", \\"2 3\\", \\"0\\"] expected_output = [\\"YES\\"] assert check_features(input_data) == expected_output def test_single_version_multiple_requests(): input_data = [\\"1\\", \\"1 4 2 3 4 5\\", \\"2\\", \\"2 3\\", \\"2 4\\", \\"0\\"] expected_output = [\\"YES\\", \\"YES\\"] assert check_features(input_data) == expected_output def test_multiple_versions_request_fulfilled_by_some(): input_data = [\\"3\\", \\"1 3 2 3 4\\", \\"2 2 1 3\\", \\"3 4 2 3 4 5\\", \\"2\\", \\"1 3\\", \\"2 3 4\\", \\"0\\"] expected_output = [\\"YES\\", \\"YES\\"] assert check_features(input_data) == expected_output def test_multiple_versions_request_not_fulfilled(): input_data = [\\"2\\", \\"1 2 1 2\\", \\"2 2 3 4\\", \\"1\\", \\"5\\", \\"0\\"] expected_output = [\\"NO\\"] assert check_features(input_data) == expected_output def test_request_with_zero_versions(): input_data = [\\"0\\"] expected_output = [] assert check_features(input_data) == expected_output def test_multiple_requests_some_no_some_yes(): input_data = [\\"3\\", \\"1 3 1 2 3\\", \\"2 3 3 4 5\\", \\"3 2 6 7\\", \\"3\\", \\"1 2\\", \\"3 4 5\\", \\"6 7\\", \\"0\\"] expected_output = [\\"YES\\", \\"YES\\", \\"YES\\"] assert check_features(input_data) == expected_output","solution":"def check_features(input_data): Processes the input data to check if any version contains all the requested features. :param input_data: List of strings, where each string represents a line of the input. :return: List of strings, each being \\"YES\\" or \\"NO\\" based on whether the features exist in any version. results = [] idx = 0 while idx < len(input_data): num_versions = int(input_data[idx]) if num_versions == 0: break idx += 1 versions = [] for _ in range(num_versions): version_data = list(map(int, input_data[idx].split())) version_id = version_data[0] features = set(version_data[2:]) versions.append((version_id, features)) idx += 1 num_requests = int(input_data[idx]) idx += 1 for _ in range(num_requests): request_features = set(map(int, input_data[idx].split())) idx += 1 found = any(request_features.issubset(version[1]) for version in versions) if found: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def feedback(secret, guess): Function to provide feedback on the guess based on the secret code. Returns a tuple (correct_position, correct_value). >>> feedback(\\"1234\\", \\"1234\\") (4, 0) >>> feedback(\\"1234\\", \\"5678\\") (0, 0) >>> feedback(\\"1234\\", \\"1243\\") (2, 2) >>> feedback(\\"1234\\", \\"2341\\") (0, 4) >>> feedback(\\"5678\\", \\"5612\\") (2, 0) pass def mastermind_game(L, K, C, guesses): Simulates the mastermind game with the given secret code C of length L and maximum attempts K. guesses is a list of the guesses made by the guesser. Outputs the result or feedback after each guess. Example: >>> mastermind_game(4, 10, \\"1234\\", [\\"5678\\", \\"1235\\", \\"1243\\", \\"1234\\"]) 0 0 3 0 2 2 4 0 Congrats! You've broken the code in 4 attempts. >>> mastermind_game(3, 5, \\"987\\", [\\"123\\", \\"987\\"]) 0 0 3 0 Congrats! You've broken the code in 2 attempts. >>> mastermind_game(3, 3, \\"567\\", [\\"123\\", \\"456\\", \\"789\\"]) 0 0 1 1 0 1 Sorry! You've used all attempts. pass","solution":"def feedback(secret, guess): Function to provide feedback on the guess based on the secret code. Returns a tuple (correct_position, correct_value). correct_position = 0 correct_value = 0 secret_used = [False] * len(secret) guess_used = [False] * len(guess) # First pass: count correct positions for i in range(len(secret)): if secret[i] == guess[i]: correct_position += 1 secret_used[i] = True guess_used[i] = True # Second pass: count correct values in wrong positions for i in range(len(guess)): if not guess_used[i]: for j in range(len(secret)): if not secret_used[j] and guess[i] == secret[j]: correct_value += 1 secret_used[j] = True break return correct_position, correct_value def mastermind_game(L, K, C, guesses): Simulates the mastermind game with the given secret code C of length L and maximum attempts K. guesses is a list of the guesses made by the guesser. Outputs the result or feedback after each guess. attempts = 0 for G in guesses: attempts += 1 correct_position, correct_value = feedback(C, G) print(f\\"{correct_position} {correct_value}\\") if correct_position == L: print(f\\"Congrats! You've broken the code in {attempts} attempts.\\") return if attempts == K: print(\\"Sorry! You've used all attempts.\\") # Example Usage: # mastermind_game(4, 10, \\"1234\\", [\\"5678\\", \\"1235\\", \\"1243\\", \\"1234\\"])"},{"question":"def firstNonRepeatingChar(s: str) -> str: Returns the first non-repeating character in the string s. If all characters are repeating, returns None. Only considers alphabetical characters (a-z and A-Z), and treats uppercase and lowercase characters as distinct. >>> firstNonRepeatingChar(\\"swiss\\") 'w' >>> firstNonRepeatingChar(\\"teeter\\") 'r' >>> firstNonRepeatingChar(\\"aabbcc\\") None","solution":"def firstNonRepeatingChar(s): Returns the first non-repeating character in the string s. If all characters are repeating, return None. # Dictionary to hold the counts of each character count_dict = {} # First pass to count the occurrences of each character for char in s: if char.isalpha(): # Only consider alphabetical characters if char in count_dict: count_dict[char] += 1 else: count_dict[char] = 1 # Second pass to find the first non-repeating character for char in s: if char.isalpha() and count_dict[char] == 1: return char return None"},{"question":"def maxDistinctValues(grid): Compute the maximum number of distinct values that can be collected along the top-left to bottom-right path of the grid using only moves to the right or downward. Args: grid (List[List[int]]): A 2D list of integers representing the grid. Returns: int: Maximum number of distinct values that can be collected. pass # Unit tests def test_max_distinct_values_example1(): grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert maxDistinctValues(grid) == 9 def test_max_distinct_values_example2(): grid = [ [1, 2, 2], [3, 3, 4], [4, 4, 5] ] assert maxDistinctValues(grid) == 5 def test_max_distinct_values_1x1(): grid = [ [1] ] assert maxDistinctValues(grid) == 1 def test_max_distinct_values_2x2(): grid = [ [1, 2], [3, 4] ] assert maxDistinctValues(grid) == 4 def test_max_distinct_values_with_repeats(): grid = [ [1, 1, 1], [1, 1, 1], [1, 1, 1] ] assert maxDistinctValues(grid) == 1","solution":"def maxDistinctValues(grid): Compute the maximum number of distinct values that can be collected along the top-left to bottom-right path of the grid using only moves to the right or downward. Args: grid (List[List[int]]): A 2D list of integers representing the grid. Returns: int: Maximum number of distinct values that can be collected. N = len(grid) M = len(grid[0]) # Use a DP table where dp[i][j] holds a set of distinct values collected up to cell (i, j) dp = [[set() for _ in range(M)] for _ in range(N)] dp[0][0].add(grid[0][0]) # Initialize the first row for j in range(1, M): dp[0][j] = dp[0][j-1].copy() dp[0][j].add(grid[0][j]) # Initialize the first column for i in range(1, N): dp[i][0] = dp[i-1][0].copy() dp[i][0].add(grid[i][0]) # Fill the dp table for i in range(1, N): for j in range(1, M): dp[i][j] = (dp[i-1][j] | dp[i][j-1]).copy() dp[i][j].add(grid[i][j]) # The result will be the number of distinct values in the bottom-right cell return len(dp[N-1][M-1])"},{"question":"from typing import List, Tuple def task_order(tasks: List[str], dependencies: List[Tuple[str, str]]) -> List[str]: Returns an order in which all tasks can be completed, respecting dependencies. If no such order exists, returns an empty list. >>> task_order([\\"a\\", \\"b\\", \\"c\\", \\"d\\"], [(\\"a\\", \\"b\\"), (\\"c\\", \\"b\\"), (\\"b\\", \\"d\\")]) ['d', 'b', 'a', 'c'] or ['d', 'b', 'c', 'a'] >>> task_order([\\"a\\", \\"b\\", \\"c\\", \\"d\\"], [(\\"a\\", \\"b\\"), (\\"b\\", \\"c\\"), (\\"c\\", \\"a\\")]) [] >>> task_order([\\"a\\"], []) ['a'] pass from solution import task_order def test_no_dependency(): assert task_order([\\"a\\"], []) == [\\"a\\"] def test_simple_dependency(): tasks = [\\"a\\", \\"b\\", \\"c\\", \\"d\\"] dependencies = [(\\"a\\", \\"b\\"), (\\"c\\", \\"b\\"), (\\"b\\", \\"d\\")] result = task_order(tasks, dependencies) assert result == ['d', 'b', 'a', 'c'] or result == ['d', 'b', 'c', 'a'] def test_circular_dependency(): tasks = [\\"a\\", \\"b\\", \\"c\\", \\"d\\"] dependencies = [(\\"a\\", \\"b\\"), (\\"b\\", \\"c\\"), (\\"c\\", \\"a\\")] assert task_order(tasks, dependencies) == [] def test_multiple_tasks_no_dependency(): tasks = [\\"a\\", \\"b\\", \\"c\\", \\"d\\"] assert task_order(tasks, []) == [\\"a\\", \\"b\\", \\"c\\", \\"d\\"] or task_order(tasks, []) == [\\"a\\", \\"b\\", \\"d\\", \\"c\\"] or task_order(tasks, []) == [\\"a\\", \\"c\\", \\"b\\", \\"d\\"] or task_order(tasks, []) == [\\"c\\", \\"d\\", \\"a\\", \\"b\\"] def test_multiple_levels_of_dependency(): tasks = [\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\"] dependencies = [(\\"a\\", \\"b\\"), (\\"b\\", \\"c\\"), (\\"c\\", \\"d\\"), (\\"d\\", \\"e\\")] assert task_order(tasks, dependencies) == [\\"e\\", \\"d\\", \\"c\\", \\"b\\", \\"a\\"] def test_self_dependency(): tasks = [\\"a\\", \\"b\\"] dependencies = [(\\"a\\", \\"a\\"), (\\"b\\", \\"a\\")] assert task_order(tasks, dependencies) == []","solution":"from collections import defaultdict, deque def task_order(tasks, dependencies): Returns an order in which all tasks can be completed, respecting dependencies. If no such order exists, returns an empty list. # Build the graph and a map to count incoming edges (indegree) graph = defaultdict(list) indegree = {task: 0 for task in tasks} for task, dep in dependencies: graph[dep].append(task) indegree[task] += 1 # Initialize deque for tasks with no dependencies queue = deque([task for task in tasks if indegree[task] == 0]) result = [] while queue: task = queue.popleft() result.append(task) for neighbor in graph[task]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) # If result has fewer tasks than the input list, return as not possible if len(result) == len(tasks): return result else: return []"},{"question":"def process_test_cases(test_cases: List[Tuple[str, int]]) -> List[str]: Determines if a string can be transformed into a palindrome using exactly K reversals. Parameters: test_cases (List[Tuple[str, int]]): A list of tuples where each tuple contains a string S and an integer K. Returns: List[str]: A list of \\"Yes\\" or \\"No\\" indicating for each test case if the transformation is possible. >>> process_test_cases([(\\"abcba\\", 2), (\\"abccba\\", 1)]) ['Yes', 'No'] >>> process_test_cases([(\\"racecar\\", 2), (\\"madam\\", 4)]) ['Yes', 'Yes'] pass # Test Cases from solution import process_test_cases def test_sample_cases(): test_cases = [ (\\"abcba\\", 2), (\\"abccba\\", 1) ] expected = [\\"Yes\\", \\"No\\"] assert process_test_cases([test_cases[0]])[0] == expected[0] assert process_test_cases([test_cases[1]])[0] == expected[1] def test_already_palindrome_even_k(): test_cases = [ (\\"racecar\\", 2), (\\"madam\\", 4) ] expected = [\\"Yes\\", \\"Yes\\"] assert process_test_cases(test_cases) == expected def test_already_palindrome_odd_k(): test_cases = [ (\\"racecar\\", 1), (\\"madam\\", 3) ] expected = [\\"No\\", \\"No\\"] assert process_test_cases(test_cases) == expected def test_not_palindrome_zero_k(): test_cases = [ (\\"abcdefg\\", 0), (\\"aaaaaab\\", 0) ] expected = [\\"No\\", \\"No\\"] assert process_test_cases(test_cases) == expected def test_k_greater_than_length(): test_cases = [ (\\"abc\\", 5), (\\"abcd\\", 10) ] expected = [\\"Yes\\", \\"Yes\\"] assert process_test_cases(test_cases) == expected def test_k_exactly_length(): test_cases = [ (\\"abc\\", 3), (\\"abcd\\", 4) ] expected = [\\"Yes\\", \\"Yes\\"] assert process_test_cases(test_cases) == expected","solution":"def can_be_palindrome(S, K): Determines if a string S can be transformed into a palindrome using exactly K reversals. n = len(S) # Function to check if a string is a palindrome def is_palindrome(s): return s == s[::-1] # If already a palindrome if is_palindrome(S): # If K is even, we can perform operations and still be palindrome. If K is odd, we cannot. return K % 2 == 0 # If not already a palindrome # If K == 0, no changes can be made and we need to check if it's already a palindrome. if K == 0: return is_palindrome(S) # General case # We need to check if it's possible to make S a palindrome with exactly K operations # If K >= n (length of the string), we should always be able to make it a palindrome by fully reversing substrings. return K >= n def process_test_cases(test_cases): results = [] for S, K in test_cases: if can_be_palindrome(S, K): results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"def min_operations_to_make_increasing(n: int, arr: List[int]) -> int: Returns the minimum number of operations to make the array monotonically increasing. >>> min_operations_to_make_increasing(4, [1, 2, 3, 4]) 0 >>> min_operations_to_make_increasing(3, [5, 5, 5]) 0 >>> min_operations_to_make_increasing(5, [3, 1, 5, 3, 7]) 4","solution":"def min_operations_to_make_increasing(n, arr): Returns the minimum number of operations to make the array strictly increasing. operations = 0 for i in range(1, n): if arr[i] < arr[i - 1]: operations += (arr[i - 1] - arr[i]) arr[i] = arr[i - 1] return operations"},{"question":"from typing import List def can_fulfill_requests(inventory: List[int], checkout_requests: List[List[int]]) -> List[str]: Determine whether the required number of copies of each book are available for checkout. >>> inventory = [4, 3, 2] >>> checkout_requests = [ >>> [2, 1, 1], >>> [3, 2, 2], >>> [5, 1, 0] >>> ] >>> can_fulfill_requests(inventory, checkout_requests) ['Yes', 'Yes', 'No']","solution":"from typing import List def can_fulfill_requests(inventory: List[int], checkout_requests: List[List[int]]) -> List[str]: results = [] for request in checkout_requests: can_fulfill = True for i in range(len(inventory)): if request[i] > inventory[i]: can_fulfill = False break if can_fulfill: results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"def stock_performance(test_cases): Determine whether the stock's performance is 'good' on each given day based on the opening and closing prices provided. >>> stock_performance([(100, 104), (200, 207), (1500, 1561), (8000, 8320), (5000, 5000)]) ['GOOD', 'BAD', 'GOOD', 'GOOD', 'BAD'] >>> stock_performance([(1, 1), (1, 1.04), (1, 1.05)]) ['BAD', 'GOOD', 'GOOD']","solution":"def stock_performance(test_cases): results = [] for O, C in test_cases: if C >= O * 1.04: results.append(\\"GOOD\\") else: results.append(\\"BAD\\") return results"},{"question":"def smallest_subsequence_length(s: str, k: int) -> int: Determines the length of the smallest subsequence in S that contains exactly K distinct characters. If no such subsequence exists, returns -1. >>> smallest_subsequence_length(\\"abcaa\\", 2) 2 >>> smallest_subsequence_length(\\"aaa\\", 1) 1 >>> smallest_subsequence_length(\\"abcde\\", 6) -1","solution":"def smallest_subsequence_length(s, k): Returns the length of the smallest subsequence in s that contains exactly k distinct characters. If no such subsequence exists, return -1. n = len(s) if len(set(s)) < k: return -1 # Initialize the window char_count = {} left, distinct_count = 0, 0 min_length = float('inf') for right in range(n): char = s[right] if char not in char_count or char_count[char] == 0: distinct_count += 1 char_count[char] = char_count.get(char, 0) + 1 # Shrink the window from the left to find the smallest valid subsequence while distinct_count >= k: min_length = min(min_length, right - left + 1) char_count[s[left]] -= 1 if char_count[s[left]] == 0: distinct_count -= 1 left += 1 return min_length if min_length != float('inf') else -1"},{"question":"def max_growth_rate(M, R, B, queries): Given the array B of M crop growth rates and range queries, returns the maximum growth rate within each range. Parameters: M (int): Number of elements in array B. R (int): Number of queries. B (list of int): List of crop growth rates. queries (list of tuple): Each tuple contains two integers L and R (1-based indices). Returns: list: Maximum growth rate for each query range. pass # Test cases def test_max_growth_rate(): M = 6 R = 3 B = [3, 1, 4, 1, 5, 9] queries = [(2, 4), (1, 6), (5, 6)] expected = [4, 9, 9] result = max_growth_rate(M, R, B, queries) assert result == expected def test_single_element_range(): M = 5 R = 2 B = [1, 2, 3, 4, 5] queries = [(1, 1), (5, 5)] expected = [1, 5] result = max_growth_rate(M, R, B, queries) assert result == expected def test_entire_array(): M = 7 R = 1 B = [10, 20, 30, 40, 50, 60, 70] queries = [(1, 7)] expected = [70] result = max_growth_rate(M, R, B, queries) assert result == expected def test_disjoint_queries(): M = 8 R = 2 B = [8, 1, 6, 3, 5, 4, 7, 2] queries = [(1, 4), (5, 8)] expected = [8, 7] result = max_growth_rate(M, R, B, queries) assert result == expected def test_identical_max_values(): M = 5 R = 3 B = [5, 5, 5, 5, 5] queries = [(1, 3), (2, 4), (3, 5)] expected = [5, 5, 5] result = max_growth_rate(M, R, B, queries) assert result == expected","solution":"def max_growth_rate(M, R, B, queries): Given the array B of M crop growth rates and range queries, returns the maximum growth rate within each range. Parameters: M (int): Number of elements in array B. R (int): Number of queries. B (list of int): List of crop growth rates. queries (list of tuple): Each tuple contains two integers L and R (1-based indices). Returns: list: Maximum growth rate for each query range. results = [] for L, R in queries: results.append(max(B[L-1:R])) return results"},{"question":"def handle_requests(n: int, m: int, requests: List[str]) -> List[str]: Process a series of requests to start and stop monitoring in different zones. Args: n : int : The number of zones. m : int : The number of requests. requests : List[str] : A list of requests in the form \\"monitor i\\" or \\"stop i\\". Returns: List[str] : A list of responses for each request. >>> handle_requests(5, 7, [\\"monitor 3\\", \\"monitor 2\\", \\"stop 3\\", \\"stop 2\\", \\"monitor 5\\", \\"stop 1\\", \\"monitor 3\\"]) [\\"Monitoring started in zone 3\\", \\"Monitoring started in zone 2\\", \\"Monitoring stopped in zone 3\\", \\"Monitoring stopped in zone 2\\", \\"Monitoring started in zone 5\\", \\"Zone 1 is not monitored\\", \\"Monitoring started in zone 3\\"] >>> handle_requests(2, 4, [\\"monitor 1\\", \\"monitor 1\\", \\"stop 1\\", \\"stop 1\\"]) [\\"Monitoring started in zone 1\\", \\"Zone 1 is already monitored\\", \\"Monitoring stopped in zone 1\\", \\"Zone 1 is not monitored\\"] >>> handle_requests(3, 3, [\\"stop 1\\", \\"monitor 1\\", \\"stop 1\\"]) [\\"Zone 1 is not monitored\\", \\"Monitoring started in zone 1\\", \\"Monitoring stopped in zone 1\\"] >>> handle_requests(4, 6, [\\"monitor 1\\", \\"monitor 2\\", \\"monitor 3\\", \\"stop 2\\", \\"stop 1\\", \\"monitor 4\\"]) [\\"Monitoring started in zone 1\\", \\"Monitoring started in zone 2\\", \\"Monitoring started in zone 3\\", \\"Monitoring stopped in zone 2\\", \\"Monitoring stopped in zone 1\\", \\"Monitoring started in zone 4\\"] # Your code here","solution":"def handle_requests(n, m, requests): is_monitored = [False] * (n + 1) results = [] for request in requests: action, zone = request.split() zone = int(zone) if action == \\"monitor\\": if is_monitored[zone]: results.append(f\\"Zone {zone} is already monitored\\") else: is_monitored[zone] = True results.append(f\\"Monitoring started in zone {zone}\\") elif action == \\"stop\\": if is_monitored[zone]: is_monitored[zone] = False results.append(f\\"Monitoring stopped in zone {zone}\\") else: results.append(f\\"Zone {zone} is not monitored\\") return results"},{"question":"def min_difference_subarray(arr, K): Given an array \`arr\` and an integer \`K\`, find the minimum absolute difference between the maximum and minimum elements of a contiguous subarray of length \`K\`. Parameters: arr (List[int]): List of integers. K (int): Length of the subarray. Returns: int: Minimum difference. Example: >>> min_difference_subarray([1, 3, 6, 4, 1, 2], 3) 2 >>> min_difference_subarray([1, 1, 1, 1, 1, 1], 3) 0","solution":"def min_difference_subarray(arr, K): Given an array \`arr\` and an integer \`K\`, find the minimum absolute difference between the maximum and minimum elements of a contiguous subarray of length \`K\`. # Sort the initial array arr.sort() # Initialize the minimum difference to a large number min_diff = float('inf') # Traverse the sorted array to find the subarray of length K with the minimum difference for i in range(len(arr) - K + 1): current_diff = arr[i + K - 1] - arr[i] min_diff = min(min_diff, current_diff) return min_diff"},{"question":"def max_children(N: int, chocolates: List[int]) -> int: Calculate the maximum number of children that can receive chocolates such that no two children receive the same kind of chocolate. >>> max_children(4, [4, 3, 2, 1]) 4 >>> max_children(5, [1, 1, 1, 1, 1]) 1","solution":"def max_children(N, chocolates): Returns the maximum number of children that can receive chocolates such that no two children receive the same kind of chocolate. return len(set(chocolates))"},{"question":"def longest_consecutive_subsequence(arr): Finds the length of the longest consecutive subsequence in the list. Parameters: arr (list): The list of integers. Returns: int: The length of the longest consecutive subsequence. >>> longest_consecutive_subsequence([100, 4, 200, 1, 3, 2, 102, 103, 104]) 4 >>> longest_consecutive_subsequence([10, 12, 11, 10, 8, 7, 6]) 4 pass from solution import longest_consecutive_subsequence def test_longest_consecutive_subsequence_single_element(): assert longest_consecutive_subsequence([100]) == 1 def test_longest_consecutive_subsequence_no_consecutive(): assert longest_consecutive_subsequence([100, 300, 200, 500, 600]) == 1 def test_longest_consecutive_subsequence_all_consecutive(): assert longest_consecutive_subsequence([1, 2, 3, 4, 5]) == 5 def test_longest_consecutive_subsequence_mixed_numbers(): assert longest_consecutive_subsequence([100, 4, 200, 1, 3, 2, 102, 103, 104]) == 4 def test_longest_consecutive_subsequence_mixed_negative_numbers(): assert longest_consecutive_subsequence([-1, -2, -3, -5, -4, -6]) == 6 def test_longest_consecutive_subsequence_duplicates(): assert longest_consecutive_subsequence([1, 2, 2, 3]) == 3 def test_longest_consecutive_subsequence_empty_list(): assert longest_consecutive_subsequence([]) == 0","solution":"def longest_consecutive_subsequence(arr): Finds the length of the longest consecutive subsequence in the list. Parameters: arr (list): The list of integers. Returns: int: The length of the longest consecutive subsequence. if not arr: return 0 num_set = set(arr) longest_streak = 0 for num in num_set: if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def char_frequency(s: str) -> dict: Returns a dictionary with the frequency of each character in the string s. The dictionary is sorted by the characters in alphabetical order. >>> char_frequency(\\"apple\\") {'a': 1, 'e': 1, 'l': 1, 'p': 2} >>> char_frequency(\\"banana\\") {'a': 3, 'b': 1, 'n': 2}","solution":"def char_frequency(s): Returns a dictionary with the frequency of each character in the string s. The dictionary is sorted by the characters in alphabetical order. freq_dict = {} for char in s: if char in freq_dict: freq_dict[char] += 1 else: freq_dict[char] = 1 return dict(sorted(freq_dict.items()))"},{"question":"def longest_subarray_with_sum_at_most_s(arr, n, S): Determine the length of the longest subarray where the sum of elements is less than or equal to a given value S. Args: arr (List[int]): the input array of integers. n (int): the length of the array. S (int): the given value. Returns: int: the length of the longest subarray where the sum is ≤ S >>> longest_subarray_with_sum_at_most_s([1, 2, 3, 4, 5], 5, 10) == 4 >>> longest_subarray_with_sum_at_most_s([4, 2, 2, 2], 4, 8) == 3 >>> longest_subarray_with_sum_at_most_s([10], 1, 5) == 0 def process_test_cases(test_cases): Process multiple test cases to determine the length of the longest subarray where the sum of elements is less than or equal to a given value S for each test case. Args: test_cases (List[dict]): a list of test cases, where each test case is a dictionary containing the array and parameters. Returns: List[int]: a list of results for each test case >>> test_cases = [{'params': (5, 10), 'array': [1, 2, 3, 4, 5]}, {'params': (4, 8), 'array': [4, 2, 2, 2]}] >>> process_test_cases(test_cases) == [4, 3] import pytest from solution import longest_subarray_with_sum_at_most_s, process_test_cases def test_longest_subarray_with_sum_at_most_s_case1(): assert longest_subarray_with_sum_at_most_s([1, 2, 3, 4, 5], 5, 10) == 4 def test_longest_subarray_with_sum_at_most_s_case2(): assert longest_subarray_with_sum_at_most_s([4, 2, 2, 2], 4, 8) == 3 def test_longest_subarray_with_sum_at_most_s_single_element(): assert longest_subarray_with_sum_at_most_s([1], 1, 1) == 1 assert longest_subarray_with_sum_at_most_s([10], 1, 10) == 1 assert longest_subarray_with_sum_at_most_s([10], 1, 5) == 0 def test_longest_subarray_with_sum_at_most_s_no_valid_subarray(): assert longest_subarray_with_sum_at_most_s([10, 20, 30], 3, 5) == 0 def test_process_test_cases(): test_cases = [ {'params': (5, 10), 'array': [1, 2, 3, 4, 5]}, {'params': (4, 8), 'array': [4, 2, 2, 2]} ] assert process_test_cases(test_cases) == [4, 3] def test_process_test_cases_mixed(): test_cases = [ {'params': (3, 5), 'array': [2, 2, 1]}, {'params': (3, 3), 'array': [1, 2, 3]}, {'params': (1, 1), 'array': [1]} ] assert process_test_cases(test_cases) == [3, 2, 1]","solution":"def longest_subarray_with_sum_at_most_s(arr, n, S): max_len = 0 current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum > S: current_sum -= arr[start] start += 1 max_len = max(max_len, end - start + 1) return max_len def process_test_cases(test_cases): results = [] for case in test_cases: n, S = case['params'] arr = case['array'] results.append(longest_subarray_with_sum_at_most_s(arr, n, S)) return results"},{"question":"def is_binary_palindrome(n: int) -> bool: Check if the binary representation of the given non-negative integer is a palindrome. >>> is_binary_palindrome(9) True >>> is_binary_palindrome(10) False >>> is_binary_palindrome(0) True >>> is_binary_palindrome(1) True >>> is_binary_palindrome(3) True >>> is_binary_palindrome(4) False >>> is_binary_palindrome(5) True >>> is_binary_palindrome(6) False >>> is_binary_palindrome(7) True >>> is_binary_palindrome(8) False >>> is_binary_palindrome(15) True # Your code here pass","solution":"def is_binary_palindrome(n): Check if the binary representation of the given non-negative integer is a palindrome. :param n: Non-negative integer to check :return: True if the binary representation is a palindrome, False otherwise binary_representation = bin(n)[2:] return binary_representation == binary_representation[::-1]"},{"question":"from typing import List, Tuple def max_satisfaction(N: int, T: int, dishes: List[Tuple[int, int]]) -> int: Find the maximum total satisfaction value that can be achieved without exceeding the total preparation time. Args: N : int : number of dishes T : int : total units of available time dishes : List[Tuple[int, int]] : list of tuples where each tuple contains two integers S_i and P_i Returns: int: maximum satisfaction value Example: >>> max_satisfaction(4, 5, [(10, 2), (20, 2), (30, 3), (40, 4)]) 50 >>> max_satisfaction(1, 5, [(100, 5)]) 100 def read_input(input_str: str) -> Tuple[int, int, List[Tuple[int, int]]]: Parse the input string into number of dishes, total time, and list of dishes. Args: input_str : str : the input string containing N, T and list of dishes with their satisfy values and preparation times. Returns: Tuple[int, int, List[Tuple[int, int]]]: parsed N, T and list of dishes Example: >>> read_input(\\"4 5n10 2n20 2n30 3n40 4\\") (4, 5, [(10, 2), (20, 2), (30, 3), (40, 4)]) from solution import max_satisfaction, read_input def test_sample_input(): N, T, dishes = read_input(\\"4 5n10 2n20 2n30 3n40 4\\") assert max_satisfaction(N, T, dishes) == 50 def test_single_dish(): N, T, dishes = read_input(\\"1 5n100 5\\") assert max_satisfaction(N, T, dishes) == 100 def test_no_time(): N, T, dishes = read_input(\\"3 0n10 1n20 2n30 3\\") assert max_satisfaction(N, T, dishes) == 0 def test_all_dishes_take_more_time_than_available(): N, T, dishes = read_input(\\"3 2n10 5n20 10n30 15\\") assert max_satisfaction(N, T, dishes) == 0 def test_max_satisfaction(): N, T, dishes = read_input(\\"3 10n60 2n100 2n120 3\\") assert max_satisfaction(N, T, dishes) == 280 def test_multiple_dishes_with_same_time(): N, T, dishes = read_input(\\"3 6n10 2n20 2n30 2\\") assert max_satisfaction(N, T, dishes) == 60","solution":"def max_satisfaction(N, T, dishes): dp = [0] * (T + 1) for i in range(N): satisfaction, time = dishes[i] for t in range(T, time - 1, -1): dp[t] = max(dp[t], dp[t - time] + satisfaction) return dp[T] # Input reading function for simplicity def read_input(input_str): lines = input_str.strip().split('n') N, T = map(int, lines[0].split()) dishes = [tuple(map(int, line.split())) for line in lines[1:]] return N, T, dishes # To handle the actual input in contests # def main(): # import sys # input = sys.stdin.read # N, T, dishes = read_input(input()) # print(max_satisfaction(N, T, dishes)) # if __name__ == \\"__main__\\": # main()"},{"question":"def can_rearrange(arr: List[int]) -> str: Determines if the array can be rearranged to form a strictly increasing sequence where each element is either the same as or exactly one greater than any of its neighbors. >>> can_rearrange([1, 2, 2, 3, 4]) 'YES' >>> can_rearrange([4, 1, 2, 3]) 'YES' >>> can_rearrange([1, 3, 3, 4, 5, 7]) 'NO'","solution":"def can_rearrange(arr): Determines if the array can be rearranged to form a strictly increasing sequence where each element is either the same as or exactly one greater than any of its neighbors. from collections import Counter # Get the frequency of each element element_count = Counter(arr) # Get the unique elements sorted unique_elements = sorted(element_count.keys()) # Iterate through the sorted unique elements and check the condition for i in range(1, len(unique_elements)): if unique_elements[i] - unique_elements[i-1] > 1: return \\"NO\\" return \\"YES\\" # Function for command line parsing def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) arr = list(map(int, data[1:n+1])) print(can_rearrange(arr))"},{"question":"def unique_paths(m: int, n: int, grid: List[str]) -> int: Determine the number of unique paths an adventurer can take to reach the bottom-right corner from the top-left corner of a grid. Each cell in the grid may either be passable ('0') or an obstacle ('1'). The adventurer can only move either down or right at each step. Parameters: m (int): Number of rows in the grid. n (int): Number of columns in the grid. grid (List[str]): The grid represented as a list of strings where '0' is a passable cell and '1' is an obstacle. Returns: int: The number of unique paths from the top-left corner to the bottom-right corner. Examples: >>> unique_paths(3, 3, [\\"000\\", \\"010\\", \\"000\\"]) 2 >>> unique_paths(3, 3, [\\"010\\", \\"010\\", \\"000\\"]) 1 >>> unique_paths(3, 3, [\\"100\\", \\"010\\", \\"000\\"]) 0 >>> unique_paths(3, 3, [\\"000\\", \\"010\\", \\"001\\"]) 0 >>> unique_paths(1, 1, [\\"0\\"]) 1 >>> unique_paths(4, 4, [\\"0000\\", \\"0000\\", \\"0000\\", \\"0000\\"]) 20 >>> unique_paths(4, 4, [\\"0000\\", \\"0100\\", \\"0001\\", \\"0000\\"]) 4","solution":"def unique_paths(m, n, grid): # Edge case: if start or end is blocked, return 0 if grid[0][0] == '1' or grid[m-1][n-1] == '1': return 0 # Create a 2D dp array to store the number of ways to reach each cell dp = [[0] * n for _ in range(m)] dp[0][0] = 1 # Starting position for i in range(m): for j in range(n): if grid[i][j] == '1': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1]"},{"question":"def evaluate_expression(expression: str) -> int: Evaluate a string containing a mathematical expression with only positive integers, '+', '-', '*', and '/' operators and return the calculated result. Do not use eval function. >>> evaluate_expression(\\"3+ 5 / 2\\") 5 >>> evaluate_expression(\\"2* 3 + 4\\") 10 >>> evaluate_expression(\\"10 - 3 / 3\\") 9","solution":"def evaluate_expression(expression): def helper(s, index): stack = [] num = 0 sign = '+' length = len(s) while index < length: char = s[index] if char.isdigit(): num = num * 10 + int(char) if char in \\"+-*/\\" or index == length - 1: if sign == '+': stack.append(num) elif sign == '-': stack.append(-num) elif sign == '*': stack.append(stack.pop() * num) elif sign == '/': stack.append(int(stack.pop() / num)) sign = char num = 0 index += 1 return sum(stack), index expression = expression.replace(' ', '') result, _ = helper(expression, 0) return result"},{"question":"from typing import List def longest_possible_length(S: str) -> int: Returns the length of the longest possible string after performing the removal operations on S. >>> longest_possible_length(\\"abacaba\\") 7 >>> longest_possible_length(\\"aabbcc\\") 6 def process_test_cases(T: int, test_cases: List[str]) -> List[int]: Process multiple test cases and returns a list of results. >>> process_test_cases(2, [\\"abacaba\\", \\"aabbcc\\"]) [7, 6] >>> process_test_cases(3, [\\"abc\\", \\"abcd\\", \\"abcde\\"]) [3, 4, 5]","solution":"def longest_possible_length(S): Returns the length of the longest possible string after performing the removal operations on S. # Each character is a potential palindrome center, so the original length is always the longest return len(S) def process_test_cases(T, test_cases): results = [] for i in range(T): S = test_cases[i] results.append(longest_possible_length(S)) return results"},{"question":"from typing import List, Tuple def max_rectangular_plots(test_cases: List[List[int]]) -> List[int]: Determine the maximum number of rectangular plots that can be created using the given wooden poles. Args: test_cases (List[List[int]]): A list of test cases, each containing a list of integers representing the lengths of the wooden poles. Returns: List[int]: A list of integers representing the maximum number of rectangular plots for each test case. Example: >>> max_rectangular_plots([[1, 2, 2, 1, 2, 2, 1, 1], [4, 4, 4, 4, 4, 5, 5]]) [2, 1] pass def parse_input(input_str: str) -> Tuple[int, List[List[int]]]: Parse the input string into a suitable format for processing. Args: input_str (str): The input data as a single string. Returns: Tuple[int, List[List[int]]]: The number of test cases and a list of test cases. Example: >>> parse_input(\\"2n8n1 2 2 1 2 2 1 1n7n4 4 4 4 4 5 5n\\") (2, [[1, 2, 2, 1, 2, 2, 1, 1], [4, 4, 4, 4, 4, 5, 5]]) pass def format_output(results: List[int]) -> str: Format the results into a string suitable for output. Args: results (List[int]): The list of results to be formatted. Returns: str: The formatted output string. Example: >>> format_output([2, 1]) '2n1' pass def test_max_rectangular_plots(): input_str = \\"2n8n1 2 2 1 2 2 1 1n7n4 4 4 4 4 5 5n\\" T, test_cases = parse_input(input_str) results = max_rectangular_plots(test_cases) output_str = format_output(results) expected_output_str = \\"2n1\\" assert output_str == expected_output_str def test_max_rectangular_plots_case1(): input_str = \\"1n5n1 2 3 4 5n\\" T, test_cases = parse_input(input_str) results = max_rectangular_plots(test_cases) output_str = format_output(results) expected_output_str = \\"0\\" assert output_str == expected_output_str def test_max_rectangular_plots_case2(): input_str = \\"1n6n2 3 4 2 5 3n\\" T, test_cases = parse_input(input_str) results = max_rectangular_plots(test_cases) output_str = format_output(results) expected_output_str = \\"1\\" assert output_str == expected_output_str","solution":"from collections import Counter def max_rectangular_plots(test_cases): results = [] for poles in test_cases: counter = Counter(poles) pairs = 0 for length, count in counter.items(): pairs += count // 2 results.append(pairs // 2) return results def parse_input(input_str): lines = input_str.strip().split('n') T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): N = int(lines[index]) poles = list(map(int, lines[index + 1].split())) test_cases.append(poles) index += 2 return T, test_cases def format_output(results): return 'n'.join(map(str, results))"},{"question":"def max_flowers(N, M): Given dimensions N and M of a rectangular garden, compute the maximum number of flowers that can be planted such that no two flowers are adjacent. pass def solve(test_cases): Given a list of test cases where each test case is a tuple (N, M), return a list of results where each result is the maximum number of flowers that can be planted in the corresponding garden. >>> solve([(3, 3), (4, 5)]) [5, 10] >>> solve([(1, 1)]) [1] pass","solution":"def max_flowers(N, M): Given dimensions N and M of a rectangular garden, compute the maximum number of flowers that can be planted such that no two flowers are adjacent. def flowers_in_cell(i, j): return (i + j) % 2 == 0 count = 0 for i in range(N): for j in range(M): if flowers_in_cell(i, j): count += 1 return count def solve(test_cases): results = [] for N, M in test_cases: results.append(max_flowers(N, M)) return results # Example usage: # T = 2 # test_cases = [(3, 3), (4, 5)] # print(solve(test_cases)) # Output: [5, 10]"},{"question":"def is_path_exists(N: int, M: int, grid: List[str]) -> str: Determine if there exists a simple path from the top-left cell to the bottom-right cell while visiting every free space cell exactly once. >>> is_path_exists(3, 3, [\\"..#\\", \\".#.\\", \\"..#\\"]) == \\"NO\\" >>> is_path_exists(2, 2, [\\"..\\", \\"..\\"]) == \\"YES\\" >>> is_path_exists(2, 2, [\\"\\", \\"..\\"]) == \\"NO\\" >>> is_path_exists(4, 4, [\\"....\\", \\"....\\", \\"....\\", \\"....\\"]) == \\"YES\\" >>> is_path_exists(3, 3, [\\".#.\\", \\"#.#\\", \\".#.\\"]) == \\"NO\\" >>> is_path_exists(3, 3, [\\"...\\", \\"#.#\\", \\"...\\"]) == \\"YES\\"","solution":"def is_path_exists(N, M, grid): from collections import deque # Helper function to check if we can move to a given cell def is_free(x, y): return 0 <= x < N and 0 <= y < M and grid[x][y] == '.' # BFS to count total free cells and verify path def bfs(start_x, start_y): queue = deque([(start_x, start_y)]) visited = [[False] * M for _ in range(N)] visited[start_x][start_y] = True free_count = 1 free_cells = sum(row.count('.') for row in grid) while queue: x, y = queue.popleft() for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if is_free(nx, ny) and not visited[nx][ny]: visited[nx][ny] = True free_count += 1 queue.append((nx, ny)) # Check if the bottom right corner is reached and all free cells are visited exactly once return free_count == free_cells and visited[N - 1][M - 1] # Start the search from the top-left cell return \\"YES\\" if bfs(0, 0) else \\"NO\\" # Example Usage: N = 3 M = 3 grid = [ \\"..#\\", \\".#.\\", \\"..#\\" ] print(is_path_exists(N, M, grid)) # Expected Output: \\"NO\\""},{"question":"def max_lantern_value(T, test_cases): Determine the maximum possible total value of the lantern by choosing a contiguous subsequence of the attachments to add to the base value. Args: T (int): The number of test cases. test_cases (list): A list of dictionaries, each containing: - 'B' (int): The base value of the lantern. - 'N' (int): The number of attachments. - 'attachments' (list): A list of N integers representing the values of the attachments. Returns: list: A list of integers where each integer is the maximum possible total value of the lantern for each test case. >>> T = 2 >>> test_cases = [ >>> {'B': 5, 'N': 4, 'attachments': [1, 2, 3, 4]}, >>> {'B': -5, 'N': 3, 'attachments': [-1, -2, 3]} >>> ] >>> max_lantern_value(T, test_cases) [15, -2]","solution":"def max_lantern_value(T, test_cases): results = [] for i in range(T): B, N = test_cases[i]['B'], test_cases[i]['N'] attachments = test_cases[i]['attachments'] # Using Kadane's Algorithm to find the maximum subarray sum current_max = 0 max_attachment_sum = -float('inf') for value in attachments: current_max = max(value, current_max + value) max_attachment_sum = max(max_attachment_sum, current_max) max_total_value = B + max_attachment_sum results.append(max_total_value) return results"},{"question":"def max_complete_albums(n: int, m: int, coin_types: List[int], album_capacities: List[int]) -> int: Determine the maximum number of complete albums Polycarp can have. Parameters: n (int): The number of different coin types. m (int): The number of albums. coin_types (List[int]): List of integers representing the types of coins. album_capacities (List[int]): List of integers representing the capacities of each album. Returns: int: Maximum number of complete albums. Examples: >>> max_complete_albums(5, 3, [1, 2, 3, 4, 5], [5, 4, 3]) 3 >>> max_complete_albums(4, 4, [1, 1, 2, 2], [1, 2, 3, 4]) 2 >>> max_complete_albums(6, 2, [1, 2, 2, 3, 3, 3], [5, 6]) 1","solution":"def max_complete_albums(n, m, coin_types, album_capacities): # We can fill an album if the sum of any subset of coins equals the album's capacity # Therefore, the answer is the number of albums m, since by constraints we know we have enough coins max_albums = min(m, len(album_capacities)) return max_albums"},{"question":"def generate_schedule(N: int, M: int, preferences: List[Tuple[int, int]]) -> Union[List[Tuple[int, int]], int]: Generate the schedule of matches for the players based on the given preferences. Ensures that no player plays against the same opponent more than once, and every player gets a fair number of rounds. Args: N: int - Number of players. M: int - Number of preferences. preferences: List[Tuple[int, int]] - List of tuples representing the preferences where each tuple contains two integers u and v indicating that player u should play against player v. Returns: List[Tuple[int, int]] if a valid schedule exists, -1 otherwise. Example: >>> generate_schedule(4, 3, [(1, 2), (2, 3), (3, 4)]) [(1, 2), (2, 3), (3, 4)] or any valid permutation >>> generate_schedule(3, 4, [(1, 2), (2, 3), (3, 1), (1, 3)]) -1","solution":"def generate_schedule(N, M, preferences): adjacency_list = {i: set() for i in range(1, N+1)} for u, v in preferences: adjacency_list[u].add(v) adjacency_list[v].add(u) schedule = [] # Using a set to keep track of matched pairs to avoid duplicates matched_pairs = set() for u in range(1, N+1): for v in adjacency_list[u]: if (u, v) not in matched_pairs and (v, u) not in matched_pairs: schedule.append((u, v)) matched_pairs.add((u, v)) if len(schedule) < M: return -1 return schedule"},{"question":"from typing import List def heapsort(N: int, A: List[int]) -> List[int]: Sorts the array A in non-decreasing order using heapsort algorithm. Parameters: - N (int): Number of elements in the array A. - A (list): List of integers to be sorted. Returns: - list: Sorted list of integers in non-decreasing order. >>> heapsort(5, [4, 1, 3, 9, 7]) [1, 3, 4, 7, 9] >>> heapsort(6, [10, 9, 8, 7, 6, 5]) [5, 6, 7, 8, 9, 10]","solution":"def heapsort(N, A): Sorts the array A in non-decreasing order using heapsort algorithm. Parameters: - N (int): Number of elements in the array A. - A (list): List of integers to be sorted. Returns: - list: Sorted list of integers in non-decreasing order. def heapify(arr, n, i): Helper function to maintain the heap property. largest = i # Initialize largest as root left = 2 * i + 1 # left = 2*i + 1 right = 2 * i + 2 # right = 2*i + 2 # If left child is larger than root if left < n and arr[i] < arr[left]: largest = left # If right child is larger than largest so far if right < n and arr[largest] < arr[right]: largest = right # If largest is not root if largest != i: arr[i], arr[largest] = arr[largest], arr[i] # swap # Recursively heapify the affected sub-tree heapify(arr, n, largest) # Build a maxheap. for i in range(N // 2 - 1, -1, -1): heapify(A, N, i) # One by one extract elements for i in range(N-1, 0, -1): A[i], A[0] = A[0], A[i] # swap heapify(A, i, 0) return A"},{"question":"def longest_unique_subarray(nums: List[int]) -> int: Create a function that takes a list of integers and returns the length of the longest contiguous subarray that contains only unique elements. >>> longest_unique_subarray([1, 2, 3, 1, 2, 3, 4, 5]) 5 >>> longest_unique_subarray([1, 2, 3, 4, 5]) 5 >>> longest_unique_subarray([1, 1, 1, 1, 1]) 1 >>> longest_unique_subarray([]) 0 >>> longest_unique_subarray([1, 2, 3, 4, 5, 1, 2, 3]) 5","solution":"def longest_unique_subarray(nums): Returns the length of the longest contiguous subarray that contains only unique elements. num_set = set() left = 0 max_length = 0 for right in range(len(nums)): while nums[right] in num_set: num_set.remove(nums[left]) left += 1 num_set.add(nums[right]) max_length = max(max_length, right - left + 1) return max_length"},{"question":"def check_nested_palindromes(T, test_cases): Determine if each string in the test cases is a nested palindrome. Args: T (int): The number of test cases. test_cases (List[str]): List of strings to be checked. Returns: List[str]: List of \\"YES\\" or \\"NO\\" for each test case. >>> check_nested_palindromes(3, [\\"abba\\", \\"abcba\\", \\"xyz\\"]) == [\\"YES\\", \\"YES\\", \\"NO\\"] >>> check_nested_palindromes(2, [\\"aaa\\", \\"abc\\"]) == [\\"YES\\", \\"NO\\"] >>> check_nested_palindromes(1, [\\"a\\"]) == [\\"YES\\"] >>> check_nested_palindromes(1, [\\"\\"]) == [\\"YES\\"]","solution":"def is_palindrome(s): Check if a string s is a palindrome. return s == s[::-1] def is_nested_palindrome(s): Check if a string s is a nested palindrome. if not is_palindrome(s): return False n = len(s) # Base case for single character or empty string. if n <= 1: return True for i in range(1, n + 1): if is_palindrome(s[:i]): if is_nested_palindrome(s[i:]): return True return False def check_nested_palindromes(T, test_cases): results = [] for s in test_cases: if is_nested_palindrome(s): results.append(\\"YES\\") else: results.append(\\"NO\\") return results # The main block to interact with input and output can be commented or adjusted as required. # if __name__ == \\"__main__\\": # import sys # input = sys.stdin.read # data = input().split() # T = int(data[0]) # test_cases = data[1:] # results = check_nested_palindromes(T, test_cases) # for result in results: # print(result)"},{"question":"def roman_to_int(s: str) -> int: Convert a Roman numeral string to an integer. >>> roman_to_int('III') 3 >>> roman_to_int('IV') 4 >>> roman_to_int('IX') 9 >>> roman_to_int('LVIII') 58 >>> roman_to_int('MCMXCIV') 1994","solution":"def roman_to_int(s): Convert a Roman numeral string to an integer. roman_to_int_map = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 } total = 0 prev_value = 0 for char in reversed(s): current_value = roman_to_int_map[char] if current_value < prev_value: total -= current_value else: total += current_value prev_value = current_value return total"},{"question":"from typing import List def lexicographically_greater_permutations(s: str) -> List[str]: Generate all permutations of the input string that are lexicographically greater than the original string and return them sorted in ascending order. :param s: string of lowercase alphabets :return: list of lexicographically greater permutations sorted in ascending order >>> lexicographically_greater_permutations(\\"abc\\") ['acb', 'bac', 'bca', 'cab', 'cba'] >>> lexicographically_greater_permutations(\\"aac\\") ['aca', 'caa'] >>> lexicographically_greater_permutations(\\"bb\\") [] pass # Your code here from solution import lexicographically_greater_permutations def test_lexicographically_greater_permutations_example1(): assert lexicographically_greater_permutations(\\"abc\\") == ['acb', 'bac', 'bca', 'cab', 'cba'] def test_lexicographically_greater_permutations_example2(): assert lexicographically_greater_permutations(\\"aac\\") == ['aca', 'caa'] def test_lexicographically_greater_permutations_example3(): assert lexicographically_greater_permutations(\\"bb\\") == [] def test_lexicographically_greater_permutations_single_character(): assert lexicographically_greater_permutations(\\"a\\") == [] def test_lexicographically_greater_permutations_same_characters(): assert lexicographically_greater_permutations(\\"aaaa\\") == [] def test_lexicographically_greater_permutations_all_permutations(): assert lexicographically_greater_permutations(\\"ab\\") == [\\"ba\\"] def test_lexicographically_greater_permutations_longer_string(): assert lexicographically_greater_permutations(\\"abcd\\") == [ 'abdc', 'acbd', 'acdb', 'adbc', 'adcb', 'bacd', 'badc', 'bcad', 'bcda', 'bdac', 'bdca', 'cabd', 'cadb', 'cbad', 'cbda', 'cdab', 'cdba', 'dabc', 'dacb', 'dbac', 'dbca', 'dcab', 'dcba'] def test_lexicographically_greater_permutations_duplicate_characters(): assert lexicographically_greater_permutations(\\"aabb\\") == [ 'abab', 'abba', 'baab', 'baba', 'bbaa']","solution":"from itertools import permutations def lexicographically_greater_permutations(s): This function returns a list of all the lexicographically greater permutations than the given string. :param s: input string :return: list of lexicographically greater permutations sorted in ascending order # Generate all unique permutations perms = {''.join(p) for p in permutations(s)} # Filter and sort permutations greater than the original string greater_perms = sorted(p for p in perms if p > s) return greater_perms"},{"question":"def is_triangular_number(x: int) -> int: Determines if a given integer x is a Triangular number. Returns the value of n such that the number is the nth Triangular number if it exists, otherwise -1. >>> is_triangular_number(3) 2 >>> is_triangular_number(10) 4 >>> is_triangular_number(8) -1 >>> is_triangular_number(1) 1 >>> is_triangular_number(500500) 1000 >>> is_triangular_number(500501) -1 >>> is_triangular_number(-10) -1","solution":"import math def is_triangular_number(x): Determines if a given integer x is a Triangular number. Returns the value of n such that the number is the nth Triangular number if it exists, otherwise -1. if x < 1: return -1 # Equation to find triangular number: Tn = n * (n + 1) // 2 # Solving for n: n * (n + 1) = 2 * x -> n^2 + n - 2 * x = 0 # Calculate the discriminant of the quadratic equation n^2 + n - 2x = 0 discriminant = 1 + 8 * x # 1^2 + 4*1*(-2*x) if discriminant < 0: return -1 # Calculate the positive root of the quadratic equation n = (-1 + math.isqrt(discriminant)) / 2 # Verify if n is an integer and if Tn equals x if n.is_integer(): n = int(n) if n * (n + 1) // 2 == x: return n return -1"},{"question":"def calculate_average_times(N: int, task_times: List[Tuple[int, float]]) -> Dict[int, float]: Calculate the average time taken by each participant given the recorded times of the tasks. Args: N (int): number of participants task_times (List[Tuple[int, float]]): List of tuples containing participant_id and time taken to complete tasks Returns: Dict[int, float]: Dictionary with participant IDs as keys and average times as values Example: >>> calculate_average_times(3, [(1, 5.0), (2, 6.1), (1, 4.2), (3, 7.0), (2, 5.4), (3, 6.3)]) {1: 4.6, 2: 5.75, 3: 6.65}","solution":"def calculate_average_times(N, task_times): Calculate the average time taken by each participant. Args: N : int : number of participants task_times : list of tuple : (participant_id, time) Returns: dict: a dictionary where keys are participant IDs and values are the average times. from collections import defaultdict # Create dictionaries to store the cumulative time and count of tasks for each participant. total_times = defaultdict(float) task_counts = defaultdict(int) # Accumulate the times and task counts for each participant. for participant_id, time in task_times: total_times[participant_id] += time task_counts[participant_id] += 1 # Calculate the average times for each participant. average_times = {participant_id: total_times[participant_id] / task_counts[participant_id] for participant_id in total_times} return average_times"},{"question":"def encode_string(s: str) -> str: Encode a string using a simple variant of the run-length encoding (RLE) algorithm. The encoding rule is to replace consecutive characters with the character followed by the number of times it appears consecutively. If a character appears only once consecutively, it should be directly included in the output without any number following it. >>> encode_string(\\"aabbc\\") \\"a2b2c\\" >>> encode_string(\\"abcd\\") \\"abcd\\" >>> encode_string(\\"aaabbaa\\") \\"a3b2a2\\"","solution":"def encode_string(s: str) -> str: if not s: return \\"\\" encoded_str = [] current_char = s[0] count = 1 for char in s[1:]: if char == current_char: count += 1 else: if count > 1: encoded_str.append(f\\"{current_char}{count}\\") else: encoded_str.append(current_char) current_char = char count = 1 if count > 1: encoded_str.append(f\\"{current_char}{count}\\") else: encoded_str.append(current_char) return ''.join(encoded_str)"},{"question":"def is_permutation_possible(N: int, target: List[int], M: int) -> str: Determines if it's possible to achieve the target permutation with the given number of commands. Parameters: - N (int): The number of animals - target (list of int): The target permutation of the animals' positions - M (int): The number of commands available Returns: - str: \\"YES\\" if the target permutation can be achieved, otherwise \\"NO\\" Examples: >>> is_permutation_possible(4, [2, 1, 4, 3], 3) 'YES' >>> is_permutation_possible(5, [5, 1, 2, 3, 4], 1) 'NO' pass","solution":"def is_permutation_possible(N, target, M): Determines if it's possible to achieve the target permutation with the given number of commands. Parameters: - N (int): The number of animals - target (list of int): The target permutation of the animals' positions - M (int): The number of commands available Returns: - str: \\"YES\\" if the target permutation can be achieved, otherwise \\"NO\\" # We can always achieve the target permutation if M is greater than or equal to N-1. # This is because in the worst case, we'd need N-1 swaps to sort the animals into any permutation. if M >= N - 1: return \\"YES\\" # Check if the target permutation is already sorted if target == sorted(target): return \\"YES\\" return \\"NO\\""},{"question":"def num_identical_pairs(nums): Returns the number of good pairs in the list. A pair (i, j) is called good if nums[i] == nums[j] and i < j. Parameters: nums (list): List of integers Returns: int: Number of good pairs Examples: >>> num_identical_pairs([1, 2, 3, 1, 1, 3]) 4 >>> num_identical_pairs([1, 1, 1, 1]) 6 >>> num_identical_pairs([1, 2, 3]) 0","solution":"def num_identical_pairs(nums): Returns the number of good pairs in the list. A pair (i, j) is called good if nums[i] == nums[j] and i < j. Parameters: nums (list): List of integers Returns: int: Number of good pairs good_pairs = 0 frequency = {} for num in nums: if num in frequency: good_pairs += frequency[num] frequency[num] += 1 else: frequency[num] = 1 return good_pairs"},{"question":"from typing import List, Tuple def can_travel_to_last_node(n: int, m: int, edges: List[Tuple[int, int]]) -> str: Determine if there is a way to travel from node 1 to node n using the edges provided in a directed graph. Args: n (int): Number of nodes in the graph. m (int): Number of edges in the graph. edges (List[Tuple[int, int]]): List of tuples where each tuple represents a directed edge from node u to node v. Returns: str: \\"YES\\" if there is a path from node 1 to node n, otherwise \\"NO\\". >>> can_travel_to_last_node(5, 6, [(1, 2), (2, 3), (3, 4), (4, 5), (1, 3), (2, 5)]) 'YES' >>> can_travel_to_last_node(4, 2, [(1, 2), (3, 4)]) 'NO'","solution":"def can_travel_to_last_node(n, m, edges): from collections import deque, defaultdict # Define an adjacency list to represent the graph graph = defaultdict(list) # Add the edges to the graph for u, v in edges: graph[u].append(v) # BFS to check if there's a path from node 1 to node n queue = deque([1]) visited = set() while queue: current = queue.popleft() if current in visited: continue visited.add(current) if current == n: return \\"YES\\" for neighbor in graph[current]: if neighbor not in visited: queue.append(neighbor) return \\"NO\\""},{"question":"def min_operations_to_equal_energy(n: int, energy_counters: List[int]) -> int: Returns the minimum number of operations required to make all energy counters identical. If it's impossible, returns -1. Parameters: n (int): The number of doors. energy_counters (List[int]): The initial energy counters of the doors. Returns: int: The minimum number of operations or -1 if it's impossible. Examples: >>> min_operations_to_equal_energy(4, [3, 7, 5, 13]) 6 >>> min_operations_to_equal_energy(3, [2, 4, 7]) -1 >>> min_operations_to_equal_energy(3, [5, 5, 5]) 0 >>> min_operations_to_equal_energy(4, [1, 3, 5, 7]) 4 >>> min_operations_to_equal_energy(4, [1, 2, 3, 4]) -1","solution":"def min_operations_to_equal_energy(n, energy_counters): Returns the minimum number of operations required to make all energy counters identical. If it's impossible, returns -1. total_energy = sum(energy_counters) # Condition to check if it's possible to make all counters equal if total_energy % n != 0: return -1 target_energy = total_energy // n operations = 0 for energy in energy_counters: if energy > target_energy: operations += energy - target_energy return operations"},{"question":"def cyclic_shift(L: List[int], k: int) -> List[int]: Cyclically shifts list L to the right by k positions. If k is negative, shifts to the left by |k| positions. >>> cyclic_shift([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> cyclic_shift([1, 2, 3, 4, 5], -1) [2, 3, 4, 5, 1] >>> cyclic_shift([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5] >>> cyclic_shift([1, 2, 3, 4, 5], 0) [1, 2, 3, 4, 5] >>> cyclic_shift([], 2) []","solution":"def cyclic_shift(L, k): Cyclically shifts list L to the right by k positions. If k is negative, shifts to the left by |k| positions. if not L: return [] n = len(L) k = k % n # Effective shifts needed if k > n return L[-k:] + L[:-k]"},{"question":"def can_rearrange_promotional_code(s: str) -> str: Determine whether it is possible to rearrange the characters of the promotional code such that no two adjacent characters are the same. >>> can_rearrange_promotional_code(\\"aabb\\") \\"YES\\" >>> can_rearrange_promotional_code(\\"aaab\\") \\"NO\\" >>> can_rearrange_promotional_code(\\"a\\") \\"YES\\" >>> can_rearrange_promotional_code(\\"abcdefg\\") \\"YES\\" >>> can_rearrange_promotional_code(\\"aaaaaa\\") \\"NO\\" >>> can_rearrange_promotional_code(\\"aab\\") \\"YES\\" >>> can_rearrange_promotional_code(\\"ababab\\") \\"YES\\" >>> can_rearrange_promotional_code(\\"a\\"*50000 + \\"b\\"*50000) \\"YES\\" >>> can_rearrange_promotional_code(\\"a\\"*50001 + \\"b\\"*49999) \\"NO\\"","solution":"def can_rearrange_promotional_code(s): from collections import Counter n = len(s) char_count = Counter(s) # Find the frequency of the most common character max_freq = max(char_count.values()) # Check if we can rearrange such that no two adjacent characters are the same if max_freq <= (n + 1) // 2: return \\"YES\\" else: return \\"NO\\""},{"question":"def find_connected_components(N, M, edges): Returns the number of connected components in the undirected graph. Parameters: N (int): Number of nodes. M (int): Number of edges. edges (list of tuples): List of edges where each edge is a tuple (U, V). Returns: int: The number of connected components in the graph. Examples: >>> find_connected_components(5, 3, [(1, 2), (2, 3), (4, 5)]) 2 >>> find_connected_components(6, 2, [(1, 2), (3, 4)]) 4 >>> find_connected_components(4, 1, [(1, 2)]) 3","solution":"def find_connected_components(N, M, edges): Returns the number of connected components in the undirected graph. Parameters: N (int): Number of nodes. M (int): Number of edges. edges (list of tuples): List of edges where each edge is a tuple (U, V). def dfs(node): Depth First Search (DFS) to visit all nodes in the current component. Parameters: node (int): The starting node for DFS. visited[node] = True for neighbor in adjacency_list[node]: if not visited[neighbor]: dfs(neighbor) # Initialize the adjacency list adjacency_list = [[] for _ in range(N + 1)] # Build the graph for U, V in edges: adjacency_list[U].append(V) adjacency_list[V].append(U) visited = [False] * (N + 1) connected_components = 0 # Traverse all nodes. If a node is not visited, it starts a new component. for node in range(1, N + 1): if not visited[node]: dfs(node) connected_components += 1 return connected_components # Example usage: # N = 5 # M = 3 # edges = [(1, 2), (2, 3), (4, 5)] # print(find_connected_components(N, M, edges)) # Output should be 2"},{"question":"def honey_production(W, P, D, H): Determines if the beehive will have a net gain, net loss, or balanced honey production. Args: W (int): Number of worker bees. P (int): Honey production rate per worker bee per day. D (int): Number of drone bees. H (int): Honey consumption rate per drone bee per day. Returns: str: \\"Net Gain\\", \\"Net Loss\\", or \\"Balanced\\". def test_net_gain(): assert honey_production(10, 5, 4, 10) == \\"Net Gain\\" def test_net_loss(): assert honey_production(5, 10, 10, 10) == \\"Net Loss\\" def test_balanced(): assert honey_production(10, 5, 10, 5) == \\"Balanced\\" def test_minimum_values(): assert honey_production(1, 1, 1, 1) == \\"Balanced\\" def test_maximum_values_balanced(): assert honey_production(100, 100, 100, 100) == \\"Balanced\\" def test_maximum_values_net_gain(): assert honey_production(100, 100, 50, 100) == \\"Net Gain\\" def test_maximum_values_net_loss(): assert honey_production(50, 100, 100, 100) == \\"Net Loss\\"","solution":"def honey_production(W, P, D, H): Determines if the beehive will have a net gain, net loss, or balanced honey production. Args: W (int): Number of worker bees. P (int): Honey production rate per worker bee per day. D (int): Number of drone bees. H (int): Honey consumption rate per drone bee per day. Returns: str: \\"Net Gain\\", \\"Net Loss\\", or \\"Balanced\\". production = W * P consumption = D * H if production > consumption: return \\"Net Gain\\" elif production < consumption: return \\"Net Loss\\" else: return \\"Balanced\\""},{"question":"def max_diverse_dishes(n: int, ingredients: List[int]) -> int: Determines the maximum number of diverse dishes Alice can prepare using the given quantities of ingredients. A dish is considered diverse if it uses all unique ingredients and no ingredient is repeated within a dish. Args: n: Integer - The number of different ingredients. ingredients: List of integers - The quantities of each ingredient. Returns: Integer - The maximum number of diverse dishes Alice can prepare. >>> max_diverse_dishes(5, [3, 2, 3, 1, 4]) 4 >>> max_diverse_dishes(3, [1, 1, 1]) 1","solution":"def max_diverse_dishes(n, ingredients): Determines the maximum number of diverse dishes Alice can prepare using the given quantities of ingredients. A dish is considered diverse if it uses all unique ingredients and no ingredient is repeated within a dish. Args: n: Integer - The number of different ingredients. ingredients: List of integers - The quantities of each ingredient. Returns: Integer - The maximum number of diverse dishes Alice can prepare. ingredients.sort() # Sort the list of ingredients max_dishes = 0 for i in range(n): if ingredients[i] > max_dishes: max_dishes += 1 return max_dishes"},{"question":"from typing import List, Tuple def max_sublist_sum(nums: List[int]) -> Tuple[int, int, int]: Given a list of integers, find the sublist (contiguous elements) which has the largest sum and return that sum. Also return the start and end indices (1-based) of this sublist. If there are multiple sublists with the same largest sum, return the one which has the smallest start index. If the list is empty, return 0 as the sum with both indices as 0. Args: nums (List[int]): List of integers Returns: Tuple[int, int, int]: A tuple containing the largest sum and the start and end indices (1-based) of the sublist. Examples: >>> max_sublist_sum([-2,1,-3,4,-1,2,1,-5,4]) (6, 4, 7) >>> max_sublist_sum([1]) (1, 1, 1) >>> max_sublist_sum([5,4,-1,7,8]) (23, 1, 5) >>> max_sublist_sum([]) (0, 0, 0) pass","solution":"from typing import List, Tuple def max_sublist_sum(nums: List[int]) -> Tuple[int, int, int]: if not nums: return (0, 0, 0) max_sum = current_sum = nums[0] start = end = 0 temp_start = 0 for i in range(1, len(nums)): if current_sum < 0: current_sum = nums[i] temp_start = i else: current_sum += nums[i] if current_sum > max_sum: max_sum = current_sum start = temp_start end = i return (max_sum, start + 1, end + 1)"},{"question":"def is_palindrome(s: str) -> bool: Check if the string s is a palindrome. return s == s[::-1] def min_palindromic_partitions(s: str) -> int: Returns the minimum number of palindromic substrings the string 's' can be partitioned into. >>> min_palindromic_partitions(\\"aab\\") 1 >>> min_palindromic_partitions(\\"racecar\\") 0 >>> min_palindromic_partitions(\\"abc\\") 2 >>> min_palindromic_partitions(\\"abac\\") 1 >>> min_palindromic_partitions(\\"civic\\") 0","solution":"def is_palindrome(s): Check if the string s is a palindrome. return s == s[::-1] def min_palindromic_partitions(s): Returns the minimum number of palindromic substrings the string 's' can be partitioned into. n = len(s) dp = [0] * (n+1) for i in range(n-1, -1, -1): min_cuts = float('inf') for j in range(i, n): if is_palindrome(s[i:j+1]): min_cuts = min(min_cuts, 1 + dp[j+1]) dp[i] = min_cuts return dp[0] - 1"},{"question":"def max_cookies(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: You are given an array of N integers, each representing the amount of cookies of a certain type. Your task is to merge all the cookie types into one type by performing a series of operations. In each operation, you can merge two different types of cookies into one, consuming all the cookies of those two types, and gaining a certain number of new cookies. The number of new cookies gained is equal to the product of the two types being merged. Determine the maximum number of cookies you can have after merging all types of cookies. Args: T (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of tuples where each tuple contains an integer N (the number of types of cookies) and a list of integers representing the amount of cookies of each type. Returns: List[int]: A list of integers where each integer is the maximum number of cookies possible after merging all types for each test case. Example: >>> max_cookies(2, [(3, [2, 3, 4]), (4, [1, 1, 1, 1])]) [24, 1]","solution":"def max_cookies(T, test_cases): def compute_max_cookies(N, cookies): max_cookies = 1 for cookie in cookies: max_cookies *= cookie return max_cookies results = [] for t in range(T): N = test_cases[t][0] cookies = test_cases[t][1] result = compute_max_cookies(N, cookies) results.append(result) return results"},{"question":"def find_longest_increasing_subsequence(arr): Return the length of the longest increasing subsequence and the sum of this subsequence for a given list. >>> find_longest_increasing_subsequence([5, 2, 7, 4, 3]) == (2, 12) >>> find_longest_increasing_subsequence([1, 3, 2, 4, 5, 6]) == (5, 19) >>> find_longest_increasing_subsequence([10, 20, 30, 40]) == (4, 100) pass def process_cases(n, cases): Process multiple cases and return the results for each as a list of tuples. >>> process_cases(3, [(5, [5, 2, 7, 4, 3]), (6, [1, 3, 2, 4, 5, 6]), (4, [10, 20, 30, 40])]) == [(2, 12), (5, 19), (4, 100)] pass","solution":"def find_longest_increasing_subsequence(arr): Return the length of the longest increasing subsequence and the sum of this subsequence for a given list. n = len(arr) if n == 0: return 0, 0 # Dynamic programming array to store the length of LIS ending at each index dp_length = [1] * n # Dynamic programming array to store the sum of LIS ending at each index dp_sum = arr[:] for i in range(1, n): for j in range(i): if arr[i] > arr[j]: if dp_length[j] + 1 > dp_length[i]: dp_length[i] = dp_length[j] + 1 dp_sum[i] = dp_sum[j] + arr[i] elif dp_length[j] + 1 == dp_length[i]: dp_sum[i] = max(dp_sum[i], dp_sum[j] + arr[i]) max_length = max(dp_length) max_sum = max(dp_sum[i] for i in range(n) if dp_length[i] == max_length) return max_length, max_sum def process_cases(n, cases): results = [] for case in cases: k, array = case[0], case[1] length, highest_sum = find_longest_increasing_subsequence(array) results.append((length, highest_sum)) return results"},{"question":"def max_occurrences(s: str) -> str: Returns the character that appears the most frequently in the string. If there is a tie, returns the character that appears first in the string. >>> max_occurrences('this is a sample string') == 's' >>> max_occurrences('example') == 'e' >>> max_occurrences('aabbbcccddee') == 'b'","solution":"def max_occurrences(s): Returns the character that appears the most frequently in the string. If there is a tie, returns the character that appears first in the string. from collections import Counter count = Counter(s) max_count = max(count.values()) for char in s: if count[char] == max_count: return char"},{"question":"def compress_string(s: str) -> str: Compress the string using the smallest possible k[x] format where x is the smallest repeating substring. If no such substring can compress the string, return the string itself. :param s: A string to be compressed. :return: The compressed string. >>> compress_string(\\"ababc\\") 'ababc' >>> compress_string(\\"ababab\\") '3[ab]' >>> compress_string(\\"aabbaabbaabb\\") '3[aabb]' >>> compress_string(\\"a\\") 'a' >>> compress_string(\\"abcdef\\") 'abcdef' def process_test_cases(T: int, test_cases: List[str]) -> List[str]: Process multiple test cases of strings to return their compressed forms. :param T: Number of test cases. :param test_cases: List of test case strings. :return: List of compressed strings corresponding to each input string. >>> process_test_cases(3, [\\"ababc\\", \\"ababab\\", \\"aabbaabbaabb\\"]) ['ababc', '3[ab]', '3[aabb]']","solution":"def compress_string(s): Compress the string using the smallest possible k[x] format where x is the smallest repeating substring. If no such substring can compress the string, return the string itself. n = len(s) def get_repeated_pattern(s): for i in range(1, n//2 + 1): if n % i == 0: if s[:i] * (n // i) == s: return (s[:i], n // i) return (s, 1) # Return the original string and count 1 if no pattern found pattern, count = get_repeated_pattern(s) if count > 1: return f\\"{count}[{pattern}]\\" return s def process_test_cases(T, test_cases): results = [] for s in test_cases: results.append(compress_string(s)) return results"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.children = [] def longest_increasing_path(root: TreeNode) -> int: Determine the length of the longest strictly increasing path from the root to any leaf in an n-ary tree. Args: root (TreeNode): The root of the n-ary tree. Returns: int: The length of the longest strictly increasing path. Example: >>> root = TreeNode(10) >>> child1 = TreeNode(5) >>> child2 = TreeNode(20) >>> child3 = TreeNode(3) >>> child4 = TreeNode(7) >>> child5 = TreeNode(15) >>> child6 = TreeNode(25) >>> root.children = [child1, child2] >>> child1.children = [child3, child4, child5] >>> child2.children = [child6] >>> longest_increasing_path(root) 3 def test_longest_increasing_path_empty(): assert longest_increasing_path(None) == 0 def test_longest_increasing_path_single_node(): root = TreeNode(10) assert longest_increasing_path(root) == 1 def test_longest_increasing_path_example(): # Constructing the example tree root = TreeNode(10) child1 = TreeNode(5) child2 = TreeNode(20) child3 = TreeNode(3) child4 = TreeNode(7) child5 = TreeNode(15) child6 = TreeNode(25) root.children = [child1, child2] child1.children = [child3, child4, child5] child2.children = [child6] assert longest_increasing_path(root) == 3 def test_longest_increasing_path_multiple_increasing(): # Constructing a tree where there are multiple increasing paths root = TreeNode(10) child1 = TreeNode(11) child2 = TreeNode(12) child3 = TreeNode(13) child1_1 = TreeNode(14) child1_2 = TreeNode(15) child1_2_1 = TreeNode(16) root.children = [child1, child2] child1.children = [child1_1, child1_2] child1_2.children = [child1_2_1] child2.children = [child3] assert longest_increasing_path(root) == 4 def test_longest_increasing_path_no_increasing(): # Constructing a tree where there is no strictly increasing path root = TreeNode(10) child1 = TreeNode(9) child2 = TreeNode(8) child3 = TreeNode(7) root.children = [child1, child2, child3] assert longest_increasing_path(root) == 1","solution":"class TreeNode: def __init__(self, x): self.val = x self.children = [] def longest_increasing_path(root: TreeNode) -> int: def dfs(node, parent_val): if not node: return 0 max_length = 0 for child in node.children: if child.val > node.val: max_length = max(max_length, dfs(child, node.val)) return 1 + max_length if not root: return 0 return dfs(root, float('-inf'))"},{"question":"def complete_grid(matrix: List[List[int]]) -> Union[List[List[int]], int]: Given a partially filled 3x3 grid, complete it to form a magic square if possible, otherwise return -1. >>> complete_grid([ ... [8, 1, 6], ... [3, 0, 0], ... [0, 0, 0] ... ]) [[8, 1, 6], [3, 5, 7], [4, 9, 2]] >>> complete_grid([ ... [0, 0, 0], ... [0, 5, 0], ... [0, 0, 0] ... ]) [[2, 7, 6], [9, 5, 1], [4, 3, 8]] >>> complete_grid([ ... [8, 1, 6], ... [3, 0, 0], ... [0, 0, 1] ... ]) -1 >>> complete_grid([ ... [2, 7, 6], ... [9, 5, 1], ... [4, 3, 8] ... ]) [[2, 7, 6], [9, 5, 1], [4, 3, 8]] pass","solution":"def is_magic_square(matrix): Check whether a 3x3 matrix is a magic square. s = sum(matrix[0]) for i in range(3): if sum(matrix[i]) != s or sum(matrix[j][i] for j in range(3)) != s: return False if sum(matrix[i][i] for i in range(3)) != s or sum(matrix[i][2-i] for i in range(3)) != s: return False return True def fill_grid(matrix): Try to complete the 3x3 grid to form a magic square. existing_numbers = [num for row in matrix for num in row if num != 0] missing_numbers = [num for num in range(1, 10) if num not in existing_numbers] def backtrack(grid, empty_positions, index): if index == len(empty_positions): return is_magic_square(grid) i, j = empty_positions[index] for num in missing_numbers: if num in grid[i] or num in [grid[k][j] for k in range(3)]: continue grid[i][j] = num if backtrack(grid, empty_positions, index + 1): return True grid[i][j] = 0 return False empty_positions = [(i, j) for i in range(3) for j in range(3) if matrix[i][j] == 0] if backtrack(matrix, empty_positions, 0): return matrix else: return -1 def complete_grid(matrix): matrix_filled = fill_grid(matrix) if matrix_filled == -1: return -1 else: return matrix_filled"},{"question":"from collections import deque def shortestPath(grid, M, N, start, end): Finds the shortest path in a grid from start to end, avoiding obstacles. Parameters: grid (List[List[int]]): The MxN grid M (int): The number of rows N (int): The number of columns start (Tuple[int, int]): The starting position (row, col) end (Tuple[int, int]): The ending position (row, col) Returns: int: The length of the shortest path, or -1 if no such path exists >>> M = 3 >>> N = 3 >>> grid = [ ... [0, 0, 0], ... [1, 1, 0], ... [0, 0, 0] ... ] >>> start = (0, 0) >>> end = (2, 2) >>> shortestPath(grid, M, N, start, end) 4 >>> M = 3 >>> N = 3 >>> grid = [ ... [0, 1, 0], ... [1, 0, 0], ... [0, 1, 0] ... ] >>> start = (0, 0) >>> end = (2, 2) >>> shortestPath(grid, M, N, start, end) -1 >>> M = 3 >>> N = 3 >>> grid = [ ... [0, 0, 0], ... [1, 1, 0], ... [0, 0, 0] ... ] >>> start = (0, 0) >>> end = (0, 0) >>> shortestPath(grid, M, N, start, end) 0 >>> M = 5 >>> N = 5 >>> grid = [ ... [0, 0, 1, 0, 0], ... [0, 1, 0, 0, 1], ... [0, 0, 0, 1, 0], ... [1, 0, 1, 0, 1], ... [0, 0, 0, 0, 0] ... ] >>> start = (0, 0) >>> end = (4, 4) >>> shortestPath(grid, M, N, start, end) 8","solution":"from collections import deque def shortestPath(grid, M, N, start, end): Finds the shortest path in a grid from start to end, avoiding obstacles. Parameters: grid (List[List[int]]): The MxN grid M (int): The number of rows N (int): The number of columns start (Tuple[int, int]): The starting position (row, col) end (Tuple[int, int]): The ending position (row, col) Returns: int: The length of the shortest path, or -1 if no such path exists if start == end: return 0 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(start[0], start[1], 0)]) # (row, col, distance) visited = set() visited.add(start) while queue: x, y, dist = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < M and 0 <= ny < N and (nx, ny) not in visited and grid[nx][ny] == 0: if (nx, ny) == end: return dist + 1 queue.append((nx, ny, dist + 1)) visited.add((nx, ny)) return -1"},{"question":"def find_free_time(intervals, start_time, end_time): Given a list of intervals representing busy times on someone's calendar, find the time slots when the person is free. Each interval is represented by a start time and an end time, and all times are integers. The busy intervals may overlap and are not necessarily sorted. The function should return the list of free time intervals within the given start and end times. >>> find_free_time([(1, 3), (5, 6), (12, 14)], 0, 15) [(0, 1), (3, 5), (6, 12), (14, 15)] >>> find_free_time([(1, 5), (2, 6), (7, 10)], 0, 12) [(0, 1), (6, 7), (10, 12)] >>> find_free_time([(8, 10), (12, 14)], 6, 16) [(6, 8), (10, 12), (14, 16)]","solution":"def find_free_time(intervals, start_time, end_time): if not intervals: return [(start_time, end_time)] # Sort intervals by start time intervals.sort(key=lambda x: x[0]) # Merge overlapping intervals merged_intervals = [] current_start, current_end = intervals[0] for start, end in intervals[1:]: if start <= current_end: current_end = max(current_end, end) else: merged_intervals.append((current_start, current_end)) current_start, current_end = start, end merged_intervals.append((current_start, current_end)) # Find free time slots free_time = [] # From start_time to the start of the first merged interval if start_time < merged_intervals[0][0]: free_time.append((start_time, merged_intervals[0][0])) # In between merged intervals for i in range(1, len(merged_intervals)): free_time.append((merged_intervals[i-1][1], merged_intervals[i][0])) # From the end of the last merged interval to end_time if merged_intervals[-1][1] < end_time: free_time.append((merged_intervals[-1][1], end_time)) return free_time"},{"question":"def number_of_trees_hit(N: int, positions: List[Tuple[int, int]]) -> List[int]: Determine the number of trees that will be hit if each tree is pushed one by one. Args: N (int): Number of trees. positions (list of tuple): List containing the positions of trees as (X_i, Y_i). Returns: list of int: List containing the number of trees hit for each tree. >>> number_of_trees_hit(5, [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)]) [0, 0, 0, 0, 0] >>> number_of_trees_hit(4, [(1, 1), (2, 1), (3, 1), (4, 1)]) [3, 2, 1, 0] >>> number_of_trees_hit(3, [(1, 1), (4, 4), (2, 3)]) [0, 0, 0]","solution":"def number_of_trees_hit(N, positions): Determine the number of trees that will be hit if each tree is pushed one by one. Args: N (int): Number of trees. positions (list of tuple): List containing the positions of trees as (X_i, Y_i). Returns: list of int: List containing the number of trees hit for each tree. # Sort the positions by X coordinate for easier processing positions_sorted = sorted(positions) # Create a list to store the result for each tree result = [0] * N # Create a dictionary to map from tree index to the number of trees hit to the right tree_to_hits = {} # Iterate over each tree from right to left to calculate the number of hits for i in range(N - 1, -1, -1): x, y = positions_sorted[i] # Initialize hit count to 0 hits = 0 # Check if there are trees to the right with the same y coordinate for j in range(i + 1, N): if positions_sorted[j][1] == y: hits += 1 + (tree_to_hits[j] if j in tree_to_hits else 0) break # Save the result for this tree result[i] = hits tree_to_hits[i] = hits # Generate result in the original order of input position_to_hits_map = {pos: result[i] for i, pos in enumerate(positions_sorted)} original_order_result = [position_to_hits_map[pos] for pos in positions] return original_order_result"},{"question":"def min_years_to_equal_heights(n: int, heights: List[int]) -> int: Determines the minimum number of years required to make all the trees in the list have the same height. Parameters: n (int): Number of trees in the forest. heights (list of int): List of heights of the trees. Returns: int: Minimum number of years required. >>> min_years_to_equal_heights(3, [4, 7, 5]) 2 >>> min_years_to_equal_heights(4, [1, 1, 1, 1]) 0 >>> min_years_to_equal_heights(5, [10, 10, 10, 10, 10]) 0","solution":"def min_years_to_equal_heights(n, heights): Determines the minimum number of years required to make all the trees in the list have the same height. Parameters: n (int): Number of trees in the forest. heights (list of int): List of heights of the trees. Returns: int: Minimum number of years required. if n <= 1: return 0 min_height = min(heights) max_height = max(heights) return max_height - min_height"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def findKDistanceNodes(root, target, K): Given a binary tree, find all the nodes at a distance K from a given target node. >>> root = TreeNode(3) >>> root.left = TreeNode(5) >>> root.right = TreeNode(1) >>> root.left.left = TreeNode(6) >>> root.left.right = TreeNode(2) >>> root.left.right.left = TreeNode(7) >>> root.left.right.right = TreeNode(4) >>> root.right.right = TreeNode(9) >>> set(findKDistanceNodes(root, root.left, 2)) {7, 4, 1} >>> root = TreeNode(3) >>> root.left = TreeNode(5) >>> root.right = TreeNode(1) >>> root.left.left = TreeNode(6) >>> set(findKDistanceNodes(root, root.left, 1)) {6, 3} >>> root = TreeNode(3) >>> findKDistanceNodes(root, root, 0) [3] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.left.left.left = TreeNode(8) >>> root.left.right.left = TreeNode(7) >>> set(findKDistanceNodes(root, root.left, 2)) {8, 7} >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> root.left.left.left = TreeNode(8) >>> root.left.right.right = TreeNode(9) >>> set(findKDistanceNodes(root, root, 3)) {8, 9}","solution":"from collections import deque, defaultdict class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def findKDistanceNodes(root, target, K): if not root: return [] # Build the graph from the tree graph = defaultdict(list) def build_graph(node, parent): if node: if parent: graph[node].append(parent) graph[parent].append(node) if node.left: build_graph(node.left, node) if node.right: build_graph(node.right, node) # Convert the tree into undirected graph build_graph(root, None) # BFS from the target node queue = deque([(target, 0)]) visited = {target} result = [] while queue: node, dist = queue.popleft() if dist == K: result.append(node.val) for neighbor in graph[node]: if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, dist + 1)) return result"},{"question":"def solve(nums, target): Determines if there are two distinct indices i and j in the input list such that the difference between nums[i] and nums[j] is exactly the target integer. Args: nums : List[int] - A list of integers. target : int - The target difference. Returns: bool - True if such a pair exists, False otherwise. Examples: >>> solve([1, 5, 9, 13], 4) True >>> solve([1, 5, 9, 13], 3) False >>> solve([1, 3, 5, 7], 2) True >>> solve([1, 5, 5, 13], 0) True >>> solve([1], 1) False","solution":"def solve(nums, target): Determines if there are two distinct indices i and j in the input list such that the difference between nums[i] and nums[j] is exactly the target integer. Args: nums : List[int] - A list of integers. target : int - The target difference. Returns: bool - True if such a pair exists, False otherwise. num_set = set(nums) if target == 0: # Special case to check pairs with zero difference from collections import Counter count = Counter(nums) for val in count.values(): if val > 1: return True else: for num in nums: if (num + target in num_set) or (num - target in num_set): return True return False"},{"question":"def longest_non_consecutive_subsequence_length(S: str) -> int: Determines the length of the longest subsequence of S that can be formed such that no two consecutive elements in the subsequence are the same. >>> longest_non_consecutive_subsequence_length('1101001') == 5 >>> longest_non_consecutive_subsequence_length('11111') == 1 >>> longest_non_consecutive_subsequence_length('10101010') == 8 >>> longest_non_consecutive_subsequence_length('0000') == 1 >>> longest_non_consecutive_subsequence_length('101') == 3 >>> longest_non_consecutive_subsequence_length('') == 0","solution":"def longest_non_consecutive_subsequence_length(S): Determines the length of the longest subsequence of S that can be formed such that no two consecutive elements in the subsequence are the same. if not S: return 0 # The initial subsequence length is 1 because the first character is always included. max_length = 1 # Traverse the string from the second character to the end. for i in range(1, len(S)): # If the current character is different from the previous one, increase the subsquence length. if S[i] != S[i - 1]: max_length += 1 return max_length"},{"question":"def lexicographically_smallest_rotation(s: str) -> str: Determine the lexicographically smallest rotated string for a given string. >>> lexicographically_smallest_rotation(\\"cabbage\\") 'abbagec' >>> lexicographically_smallest_rotation(\\"a\\") 'a' >>> lexicographically_smallest_rotation(\\"ba\\") 'ab' >>> lexicographically_smallest_rotation(\\"aaaaa\\") 'aaaaa' >>> lexicographically_smallest_rotation(\\"dbcabc\\") 'abcdbc' >>> lexicographically_smallest_rotation(\\"abc\\") 'abc' >>> lexicographically_smallest_rotation(\\"racecar\\") 'acecarr' >>> lexicographically_smallest_rotation(\\"xxxxxxxxxx\\") 'xxxxxxxxxx'","solution":"def lexicographically_smallest_rotation(s): Returns the lexicographically smallest rotation of the string s. n = len(s) doubled_s = s + s smallest_rotation = s for i in range(1, n): rotation = doubled_s[i:i+n] if rotation < smallest_rotation: smallest_rotation = rotation return smallest_rotation"},{"question":"def is_almost_prime(k: int) -> str: Determine if a given number k is almost prime. A number is almost prime if it has exactly three distinct divisors. >>> is_almost_prime(4) \\"YES\\" >>> is_almost_prime(8) \\"NO\\" >>> is_almost_prime(10) \\"NO\\" >>> is_almost_prime(9) \\"YES\\" >>> is_almost_prime(6) \\"NO\\" >>> is_almost_prime(16) \\"NO\\" >>> is_almost_prime(25) \\"YES\\" >>> is_almost_prime(50) \\"NO\\"","solution":"def is_almost_prime(k): Determine if a number k is almost prime. A number is almost prime if it has exactly three distinct divisors. divisors = set() for i in range(1, k + 1): if k % i == 0: divisors.add(i) if len(divisors) > 3: return \\"NO\\" return \\"YES\\" if len(divisors) == 3 else \\"NO\\""},{"question":"import heapq from typing import List, Tuple def shortestTravelTime(N: int, roads: List[Tuple[int, int, int]]) -> List[int]: Determines the shortest travel time from the central warehouse (node 0) to all other destinations in the city. Parameters: - N: the number of nodes - roads: a list of tuples representing the roads, each tuple (u, v, w) where u and v are nodes and w is travel time Returns: A list of integers representing the shortest travel time from node 0 to each node. Examples: >>> shortestTravelTime(5, [(0, 1, 10), (0, 2, 3), (1, 2, 1), (1, 3, 2), (2, 3, 8), (2, 4, 2), (3, 4, 7)]) [0, 4, 3, 6, 5] >>> shortestTravelTime(4, [(0, 1, 2), (0, 3, 9), (1, 2, 4), (2, 3, 1)]) [0, 2, 6, 7] >>> shortestTravelTime(1, []) [0] >>> shortestTravelTime(3, [(0, 1, 1)]) [0, 1, float('inf')] >>> shortestTravelTime(4, [(0, 1, 1), (0, 2, 2), (0, 3, 3)]) [0, 1, 2, 3]","solution":"import heapq def shortestTravelTime(N, roads): Determines the shortest travel time from the central warehouse (node 0) to all other destinations in the city. Parameters: - N: the number of nodes - roads: a list of tuples representing the roads, each tuple (u, v, w) where u and v are nodes and w is travel time Returns: A list of integers representing the shortest travel time from node 0 to each node. graph = {i: [] for i in range(N)} for u, v, w in roads: graph[u].append((v, w)) graph[v].append((u, w)) # Priority queue: (distance, node) pq = [(0, 0)] distances = {i: float('inf') for i in range(N)} distances[0] = 0 while pq: current_distance, u = heapq.heappop(pq) if current_distance > distances[u]: continue for v, w in graph[u]: distance = current_distance + w if distance < distances[v]: distances[v] = distance heapq.heappush(pq, (distance, v)) return [distances[i] for i in range(N)]"},{"question":"def ratingSystem(input_string): Analyzes the sentiment of each review in the input string. Parameters: input_string (str): Paragraph of product reviews separated by periods. Returns: dict: Dictionary with counts of 'positive', 'negative', and 'neutral' reviews. Examples: >>> ratingSystem(\\"This product is good. It is excellent. Absolutely fantastic!\\") {\\"positive\\": 3, \\"negative\\": 0, \\"neutral\\": 0} >>> ratingSystem(\\"The product is okay. It is acceptable.\\") {\\"positive\\": 0, \\"negative\\": 0, \\"neutral\\": 2} positive_keywords = [\\"good\\", \\"excellent\\", \\"awesome\\", \\"fantastic\\", \\"lovely\\"] negative_keywords = [\\"bad\\", \\"terrible\\", \\"awful\\", \\"horrible\\", \\"poor\\"] # initialize counters sentiment_counts = { \\"positive\\": 0, \\"negative\\": 0, \\"neutral\\": 0 }","solution":"def ratingSystem(input_string): Analyzes the sentiment of each review in the input string. Parameters: input_string (str): Paragraph of product reviews separated by periods. Returns: dict: Dictionary with counts of 'positive', 'negative', and 'neutral' reviews. positive_keywords = [\\"good\\", \\"excellent\\", \\"awesome\\", \\"fantastic\\", \\"lovely\\"] negative_keywords = [\\"bad\\", \\"terrible\\", \\"awful\\", \\"horrible\\", \\"poor\\"] # Initialize counters sentiment_counts = { \\"positive\\": 0, \\"negative\\": 0, \\"neutral\\": 0 } # Split the input into individual reviews reviews = input_string.lower().split('.') for review in reviews: review = review.strip() if not review: continue review_sentiment = \\"neutral\\" for p_word in positive_keywords: if p_word in review: review_sentiment = \\"positive\\" break if review_sentiment == \\"neutral\\": for n_word in negative_keywords: if n_word in review: review_sentiment = \\"negative\\" break sentiment_counts[review_sentiment] += 1 return sentiment_counts"},{"question":"from typing import List, Tuple, Dict def max_task_overlap(employee_tasks: Dict[int, List[Tuple[int, int]]]) -> Dict[int, int]: Determines the maximum number of overlapping tasks for each employee. Args: employee_tasks (dict): A dictionary where keys are employee IDs and values are lists of tasks represented as tuples of (start, end) times. Returns: dict: A dictionary where each key is the employee ID and value is the maximum number of overlapping tasks for that employee. Example: >>> employee_tasks = {1: [(1, 4), (2, 6), (5, 8), (7, 10)], 2: [(2, 4), (3, 5), (7, 9), (10, 12)], 3: [(5, 7), (6, 8), (8, 10)]} >>> max_task_overlap(employee_tasks) {1: 2, 2: 2, 3: 2}","solution":"def max_task_overlap(employee_tasks): Determines the maximum number of overlapping tasks for each employee. Args: employee_tasks (dict): A dictionary where keys are employee IDs and values are lists of tasks represented as tuples of (start, end) times. Returns: dict: A dictionary where each key is the employee ID and value is the maximum number of overlapping tasks for that employee. from collections import defaultdict def max_overlap(tasks): events = [] for start, end in tasks: events.append((start, 'start')) events.append((end, 'end')) events.sort() max_overlap = 0 current_overlap = 0 for time, event in events: if event == 'start': current_overlap += 1 max_overlap = max(max_overlap, current_overlap) else: current_overlap -= 1 return max_overlap result = {} for employee, tasks in employee_tasks.items(): result[employee] = max_overlap(tasks) return result"},{"question":"def min_diff(n: int, preferences: List[List[int]]) -> int: Divide the participants into two groups where each group can be moved to different activity zones such that the difference in the number of game preferences between the two groups is minimized. Args: n (int): Number of participants. preferences (List[List[int]]): Game preferences of each participant. Returns: int: The minimal difference in the total number of game preferences between the two groups. If it is not possible to achieve an exactly equal number of participants in each group, return 'Unbalanced'. Examples: >>> min_diff(4, [[1, 2, 3], [2, 3, 4], [1, 3, 5], [2, 4, 6]]) 0 >>> min_diff(5, [[1, 2, 3], [2, 3, 4], [1, 3, 5], [2, 4, 6], [7, 8, 9]]) 'Unbalanced' from solution import min_diff def test_case_1(): n = 4 preferences = [ [1, 2, 3], [2, 3, 4], [1, 3, 5], [2, 4, 6] ] assert min_diff(n, preferences) == 0 def test_case_2(): n = 5 preferences = [ [1, 2, 3], [2, 3, 4], [1, 3, 5], [2, 4, 6], [7, 8, 9] ] assert min_diff(n, preferences) == 'Unbalanced' def test_case_3(): n = 6 preferences = [ [1, 2, 3], [2, 3, 4], [1, 3, 5], [2, 4, 6], [7, 8, 9], [5, 10, 11] ] assert min_diff(n, preferences) == 0 def test_case_4(): n = 4 preferences = [ [1, 1, 1], [2, 2, 2], [3, 3, 3], [4, 4, 4] ] assert min_diff(n, preferences) == 0 def test_case_5(): n = 6 preferences = [ [1, 2, 3], [1, 2, 4], [1, 2, 5], [3, 4, 5], [3, 4, 6], [3, 4, 7] ] assert min_diff(n, preferences) == 0","solution":"def min_diff(n, preferences): from itertools import combinations if n % 2 != 0: return 'Unbalanced' all_preferences = [0] * 51 total_preferences = [0, 0] for pref in preferences: for game in pref: all_preferences[game] += 1 total_preferences[0] += 1 group1_preferences = all_preferences.copy() min_difference = float('inf') for comb in combinations(range(n), n//2): temp_preferences = [0] * 51 temp_total = 0 for idx in comb: for game in preferences[idx]: temp_preferences[game] += 1 temp_total += 1 group2_preferences = [all_preferences[i] - temp_preferences[i] for i in range(51)] total_group2 = total_preferences[0] - temp_total difference = abs(temp_total - total_group2) min_difference = min(min_difference, difference) return min_difference"},{"question":"def find_two_sum(nums, target): Returns the indices of the two numbers in the list that add up to the target. Args: nums (list of int): A list of integers. target (int): The target sum. Returns: list of int: A list containing the indices of the two numbers that add up to the target. Example: >>> find_two_sum([2, 11, 7, 15], 9) [0, 2] >>> find_two_sum([-1, 2, 3, -4], -5) [0, 3] >>> find_two_sum([1, 3, 2, 4], 6) [2, 3] >>> find_two_sum([3, 3], 6) [0, 1] >>> find_two_sum([1, 2, 3, 4, 5], 10) []","solution":"def find_two_sum(nums, target): Returns the indices of the two numbers in the list that add up to the target. Args: nums (list of int): A list of integers. target (int): The target sum. Returns: list of int: A list containing the indices of the two numbers that add up to the target. num_map = {} for i, num in enumerate(nums): difference = target - num if difference in num_map: return [num_map[difference], i] num_map[num] = i return []"},{"question":"def largest_product_of_three(nums): Returns the largest product that can be made by multiplying any three integers in the list. >>> largest_product_of_three([1, 2, 3, 4, 5]) 60 >>> largest_product_of_three([-10, -10, 5, 2, 1, -5]) 500 >>> largest_product_of_three([0, -1, 3, 100]) 0 pass def process_test_cases(t, test_cases): Processes the test cases and returns the results for each. >>> process_test_cases(3, [(5, [1, 2, 3, 4, 5]), (6, [-10, -10, 5, 2, 1, -5]), (4, [0, -1, 3, 100])]) [60, 500, 0] >>> process_test_cases(2, [(5, [1, 2, 3, -4, -5]), (5, [0, 2, 3, 4, -1])]) [60, 24] >>> process_test_cases(1, [(3, [1, 2, 3])]) [6] pass","solution":"def largest_product_of_three(nums): Returns the largest product that can be made by multiplying any three integers in the list. nums.sort() return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1]) def process_test_cases(t, test_cases): results = [] for i in range(t): n, nums = test_cases[i] results.append(largest_product_of_three(nums)) return results"},{"question":"def countPairs(nums: List[int], k: int) -> int: Find the number of unique pairs of integers (a, b) in the array such that a + b is equal to k. >>> countPairs([1, 2, 3, 4, 3], 6) 2 >>> countPairs([1, 5, 1, 5], 6) 1","solution":"def countPairs(nums, k): Returns the number of unique pairs (a, b) such that a + b == k. seen = set() pairs = set() for num in nums: complement = k - num if complement in seen: pairs.add(tuple(sorted((num, complement)))) seen.add(num) return len(pairs)"},{"question":"def findUnsortedSubarray(arr): Returns the start and end indices of the smallest subarray that needs to be sorted in place so that the entire array becomes sorted. If the array is already sorted, returns (-1, -1). Examples: >>> findUnsortedSubarray([1, 2, 4, 5, 3, 5, 6]) (2, 4) >>> findUnsortedSubarray([1, 3, 2, 4, 5, 6]) (1, 2) >>> findUnsortedSubarray([1, 2, 3, 4]) (-1, -1) >>> findUnsortedSubarray([1, 2, 3, 6, 5, 4, 7, 8]) (3, 5) >>> findUnsortedSubarray([1]) (-1, -1) >>> findUnsortedSubarray([2, 1]) (0, 1) >>> findUnsortedSubarray([1, 2, 3, 4, 5, 7, 6, 8, 9, 10]) (5, 6) >>> findUnsortedSubarray([3, 3, 3, 3, 3]) (-1, -1)","solution":"def findUnsortedSubarray(arr): Returns the start and end indices of the smallest subarray that needs to be sorted in place so that the entire array becomes sorted. If the array is already sorted, returns (-1, -1). n = len(arr) if n <= 1: return -1, -1 left, right = 0, n - 1 # Find the first element that is out of order from the left while left < n - 1 and arr[left] <= arr[left + 1]: left += 1 # If the entire array is already sorted if left == n - 1: return -1, -1 # Find the first element that is out of order from the right while right > 0 and arr[right] >= arr[right - 1]: right -= 1 # Find max and min in the identified subarray subarray_max = max(arr[left:right + 1]) subarray_min = min(arr[left:right + 1]) # Extend the left boundary to include any numbers greater than subarray_min while left > 0 and arr[left - 1] > subarray_min: left -= 1 # Extend the right boundary to include any numbers less than subarray_max while right < n - 1 and arr[right + 1] < subarray_max: right += 1 return left, right"},{"question":"from typing import List def longest_palindromic_substring(s: str) -> str: Mary is fascinated with palindromes and loves to play with strings. A palindrome is a string that reads the same backward as forward. She wants to determine the longest palindromic substring in a given string. Can you help Mary find it? >>> longest_palindromic_substring(\\"babad\\") \\"bab\\" >>> longest_palindromic_substring(\\"cbbd\\") \\"bb\\" def solve_cases(test_cases: List[str]) -> List[str]: Given multiple test cases, determine the longest palindromic substring for each. >>> solve_cases([\\"babad\\", \\"cbbd\\"]) [\\"bab\\", \\"bb\\"]","solution":"def longest_palindromic_substring(s): Returns the longest palindromic substring in the input string s. n = len(s) if n == 0: return \\"\\" start = 0 max_length = 1 for i in range(1, n): odd_palindrome = s[i-max_length-1:i+1] even_palindrome = s[i-max_length:i+1] if i - max_length - 1 >= 0 and odd_palindrome == odd_palindrome[::-1]: start = i - max_length - 1 max_length += 2 elif even_palindrome == even_palindrome[::-1]: start = i - max_length max_length += 1 return s[start:start + max_length] def solve_cases(test_cases): results = [] for s in test_cases: results.append(longest_palindromic_substring(s)) return results"},{"question":"def largest_rectangle_area(heights: List[int]) -> int: Calculate the maximum area of a rectangle that can be formed from a list of building heights. >>> largest_rectangle_area([2, 1, 5, 6, 2, 3]) 10 >>> largest_rectangle_area([4, 2, 0, 3, 2]) 4 def solve(buildings_data: List[int]) -> List[int]: For each test case, calculate the maximum area of a rectangle that can be formed from the buildings. >>> solve([2, 6, 2, 1, 5, 6, 2, 3, 5, 4, 2, 0, 3, 2]) [10, 4] >>> solve([1, 1, 5]) [5] >>> solve([1, 2, 1, 2]) [2] >>> solve([1, 2, 2, 1]) [2] >>> solve([1, 4, 3, 3, 3, 3]) [12] >>> solve([1, 4, 0, 0, 0, 0]) [0]","solution":"def largest_rectangle_area(heights): stack = [] max_area = 0 heights.append(0) # Add a sentinel value for final calculation for i, h in enumerate(heights): while stack and heights[stack[-1]] > h: height = heights[stack.pop()] width = i if not stack else i - stack[-1] - 1 max_area = max(max_area, height * width) stack.append(i) return max_area def solve(buildings_data): t = buildings_data[0] index = 1 results = [] for _ in range(t): n = buildings_data[index] heights = buildings_data[index + 1: index + 1 + n] index += n + 1 results.append(largest_rectangle_area(heights)) return results"},{"question":"def has_pair_with_sum(n, array, target): Determines if there are two distinct indices i and j in the array such that the sum of the integers at those indices is equal to the target value. Parameters: n (int): the size of the array. array (list of int): the elements of the array. target (int): the target value for the sum. Returns: str: \\"YES\\" if such a pair exists, otherwise \\"NO\\". >>> has_pair_with_sum(5, [2, 7, 11, 15, 4], 9) 'YES' >>> has_pair_with_sum(4, [1, 2, 3, 4], 8) 'NO' >>> has_pair_with_sum(6, [5, 3, 6, 1, 12, 7], 13) 'YES'","solution":"def has_pair_with_sum(n, array, target): Determines if there are two distinct indices i and j in the array such that the sum of the integers at those indices is equal to the target value. Parameters: n (int): the size of the array. array (list of int): the elements of the array. target (int): the target value for the sum. Returns: str: \\"YES\\" if such a pair exists, otherwise \\"NO\\". seen = set() for num in array: if target - num in seen: return \\"YES\\" seen.add(num) return \\"NO\\""},{"question":"def find_min_vertex_cover(n: int, m: int, edges: List[Tuple[int, int]]) -> int: Given a graph with \`n\` nodes and \`m\` edges, determine the minimum number of nodes required to cover all edges (i.e., find the minimum vertex cover of the graph). >>> find_min_vertex_cover(5, 6, [(1, 2), (1, 3), (2, 3), (2, 4), (3, 4), (4, 5)]) == 3 >>> find_min_vertex_cover(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) == 2","solution":"def find_min_vertex_cover(n, m, edges): from itertools import combinations # Convert edges to an adjacency list for easy coverage checking. adj_list = {i: set() for i in range(1, n + 1)} for u, v in edges: adj_list[u].add(v) adj_list[v].add(u) def is_vertex_cover(subset): Check if subset of nodes is a vertex cover. covered_edges = set() for u in subset: for v in adj_list[u]: covered_edges.add(frozenset([u, v])) return len(covered_edges) == m # Try all subsets in increasing size to find the minimum vertex cover for size in range(n + 1): for subset in combinations(range(1, n + 1), size): if is_vertex_cover(subset): return size return n # In worst case, all nodes form a cover # Reading the input and calling the function def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) m = int(data[1]) edges = [] for i in range(m): u = int(data[2 + 2 * i]) v = int(data[3 + 2 * i]) edges.append((u, v)) result = find_min_vertex_cover(n, m, edges) print(result) if __name__ == \\"__main__\\": main()"},{"question":"def sum_of_subarrays(arr): Calculates the sum of all subarrays of the given list of integers. Parameters: arr (list of int): The input list of integers. Returns: int: The cumulative sum of all subarray sums. >>> sum_of_subarrays([1]) 1 >>> sum_of_subarrays([1, 2]) 6 >>> sum_of_subarrays([1, 2, 3]) 20 >>> sum_of_subarrays([1, -1, 1, -1]) 0 >>> sum_of_subarrays([1, 2, 3, 4]) 50","solution":"def sum_of_subarrays(arr): Calculates the sum of all subarrays of the given list of integers. Parameters: arr (list of int): The input list of integers. Returns: int: The cumulative sum of all subarray sums. n = len(arr) total_sum = 0 for i in range(n): current_sum = 0 for j in range(i, n): current_sum += arr[j] total_sum += current_sum return total_sum"},{"question":"def total_playback_length(playlist): Calculate the total playback length of a playlist, excluding advertisement segments. Args: playlist (list of tuples): Each tuple contains the duration of the segment (int) and a boolean value (True if advertisement, False otherwise) Returns: int: Total playback length in seconds excluding advertisements. >>> total_playback_length([(300, False), (450, False), (180, False)]) 930 >>> total_playback_length([(300, True), (450, True), (180, True)]) 0 >>> total_playback_length([(300, False), (450, True), (180, False), (240, True)]) 480 >>> total_playback_length([(300, False)]) 300 >>> total_playback_length([(300, True)]) 0 >>> total_playback_length([(1, False), (3600, True), (1800, False), (3600, False), (1, True)]) 5401","solution":"def total_playback_length(playlist): calculates the total playback length of a playlist, excluding advertisement segments. Args: playlist (list of tuples): Each tuple contains the duration of the segment (int) and a boolean value (True if advertisement, False otherwise) Returns: int: Total playback length in seconds excluding advertisements. total_length = 0 for duration, is_ad in playlist: if not is_ad: total_length += duration return total_length"},{"question":"def max_contiguous_ones(binary_strings: List[str]) -> List[int]: Given a list of binary strings, return a list of integers where each integer represents the maximum length of the longest contiguous sequence of '1's after flipping exactly one '0' to '1' to maximize that length. Args: binary_strings (List[str]): List of binary strings. Returns: List[int]: List of maximum lengths of the longest contiguous sequence of '1's for each binary string. >>> max_contiguous_ones([\\"1101011\\"]) == [4] >>> max_contiguous_ones([\\"000100\\"]) == [2] >>> max_contiguous_ones([\\"1111\\"]) == [4] >>> max_contiguous_ones([\\"0000\\"]) == [1] >>> max_contiguous_ones([\\"000\\", \\"111\\", \\"101\\", \\"1101\\"]) == [1, 3, 3, 4]","solution":"def max_contiguous_ones(binary_strings): results = [] for s in binary_strings: if '0' not in s: results.append(len(s)) continue max_len = 0 current_ones = 0 prev_ones = 0 for char in s: if char == '1': current_ones += 1 else: max_len = max(max_len, prev_ones + current_ones + 1) prev_ones = current_ones current_ones = 0 max_len = max(max_len, prev_ones + current_ones + 1) results.append(min(max_len, len(s))) return results"},{"question":"def longest_subsequence_length(n: int, k: int, a: List[int]) -> int: Find the length of the longest subsequence of array \`a\` whose sum of elements is less than or equal to \`k\`. Args: n (int): Length of the array \`a\`. k (int): Maximum allowed sum. a (List[int]): List of integers representing the elements of the array. Returns: int: Length of the longest subsequence with sum less than or equal to \`k\`. Examples: >>> longest_subsequence_length(5, 10, [1, 2, 3, 4, 5]) 4 >>> longest_subsequence_length(5, 3, [1, 2, 3, 4, 5]) 2 >>> longest_subsequence_length(6, 20, [5, 3, 4, 8, 7, 10]) 4 >>> longest_subsequence_length(3, 15, [9, 10, 13]) 1 pass","solution":"def longest_subsequence_length(n, k, a): Given an array \`a\` of length \`n\` and a maximum allowed sum \`k\`, this function returns the length of the longest subsequence whose sum of elements is less than or equal to \`k\`. a.sort() current_sum = 0 length = 0 for i in range(n): if current_sum + a[i] <= k: current_sum += a[i] length += 1 else: break return length"},{"question":"def top_three_runners(N, runners): Returns the IDs of the top 3 fastest runners based on their completion times. Parameters: N (int): The number of students runners (list): A list of tuples, each containing the student's ID and their completion time in the format hh:mm:ss. Returns: list: IDs of the top 3 fastest runners sorted by their times. >>> top_three_runners(4, [(202, \\"02:15:30\\"), (101, \\"01:45:22\\"), (303, \\"02:10:15\\"), (404, \\"01:44:20\\")]) [404, 101, 303] >>> top_three_runners(2, [(202, \\"02:15:30\\"), (101, \\"01:45:22\\")]) [101, 202] >>> top_three_runners(3, [(202, \\"02:15:30\\"), (101, \\"01:45:22\\"), (303, \\"02:10:15\\")]) [101, 303, 202] >>> top_three_runners(4, [(202, \\"02:15:30\\"), (101, \\"02:15:30\\"), (303, \\"02:15:30\\"), (404, \\"01:44:20\\")]) [404, 202, 101] >>> top_three_runners(5, [(505, \\"03:01:10\\"), (202, \\"02:15:30\\"), (101, \\"01:45:22\\"), (303, \\"02:10:15\\"), (404, \\"01:44:20\\")]) [404, 101, 303]","solution":"def top_three_runners(N, runners): Returns the IDs of the top 3 fastest runners based on their completion times. Parameters: N (int): The number of students runners (list): A list of tuples, each containing the student's ID and their completion time in the format hh:mm:ss. Returns: list: IDs of the top 3 fastest runners sorted by their times. # Parse the runners list and convert times to seconds runners_with_time_in_seconds = [] for runner in runners: id, time_str = runner h, m, s = map(int, time_str.split(':')) total_seconds = h * 3600 + m * 60 + s runners_with_time_in_seconds.append((id, total_seconds)) # Sort the runners by their completion time sorted_runners = sorted(runners_with_time_in_seconds, key=lambda x: x[1]) # Fetch the top 3 runners' IDs top_runners_ids = [runner[0] for runner in sorted_runners[:3]] return top_runners_ids"},{"question":"def can_find_subarrays(nums: List[int], target: int) -> str: Determine if there exist two non-overlapping subarrays of nums such that the sum of the two subarrays is equal to target. >>> can_find_subarrays([1, 2, 3, 4, 5], 7) == \\"YES\\" >>> can_find_subarrays([3, 2, 7], 10) == \\"NO\\" >>> can_find_subarrays([1, 9, 5, 6, 8, 10, 2], 20) == \\"YES\\"","solution":"def can_find_subarrays(nums, target): n = len(nums) prefix_sums = {0: [-1]} # prefix_sums maps sum to list of indices where this sum occurs current_sum = 0 for i in range(n): current_sum += nums[i] if current_sum - target in prefix_sums: for start_index in prefix_sums[current_sum - target]: if start_index < i: # non-overlapping condition return \\"YES\\" if current_sum not in prefix_sums: prefix_sums[current_sum] = [] prefix_sums[current_sum].append(i) return \\"NO\\""},{"question":"def largest_square_subgrid(n: int, m: int, garden: List[str]) -> int: Returns the side length of the largest square subgrid containing only flowers in the given garden grid. >>> largest_square_subgrid(5, 6, ['FFFEEF', 'FFFFFF', 'EEFFFF', 'FFFFFF', 'FFFFEF']) == 3 >>> largest_square_subgrid(4, 4, ['EEEE', 'EEEE', 'EEEE', 'EEEE']) == 0 >>> largest_square_subgrid(3, 3, ['FFF', 'FFE', 'FFF']) == 2 >>> largest_square_subgrid(2, 2, ['FF', 'FF']) == 2 >>> largest_square_subgrid(1, 1, ['F']) == 1","solution":"def largest_square_subgrid(n, m, garden): Returns the side length of the largest square subgrid containing only flowers in the given garden grid. # Initialize memoization matrix dp = [[0] * m for _ in range(n)] max_side_length = 0 for i in range(n): for j in range(m): if garden[i][j] == 'F': if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side_length = max(max_side_length, dp[i][j]) return max_side_length"},{"question":"def generate_magic_square(n): Generates a magic square for any given odd integer n. A magic square for an odd integer n is an n x n matrix filled with distinct integers from 1 to n^2 such that each row, each column, and both main diagonals sum up to the same value. Args: n (int): The size of the magic square (must be an odd integer). Returns: List[List[int]]: The generated n x n magic square. Raises: ValueError: If n is not an odd integer. Example: >>> generate_magic_square(3) [[8, 1, 6], [3, 5, 7], [4, 9, 2]]","solution":"def generate_magic_square(n): if n % 2 == 0: raise ValueError(\\"n must be an odd number\\") magic_square = [[0] * n for _ in range(n)] num = 1 i, j = 0, n // 2 while num <= n * n: magic_square[i][j] = num num += 1 new_i, new_j = (i - 1) % n, (j + 1) % n if magic_square[new_i][new_j]: # cell is already filled i += 1 else: i, j = new_i, new_j return magic_square # Example usage: n = 3 magic_square = generate_magic_square(n) for row in magic_square: print(\\" \\".join(map(str, row)))"},{"question":"def maxProductOfThree(arr: List[int], n: int) -> int: Given an array of N integers, find the maximum product of any three numbers in the array. >>> maxProductOfThree([1, 4, 3, -6, -7, 0], 6) 168 >>> maxProductOfThree([1, 2, 3], 3) 6","solution":"def maxProductOfThree(arr, n): arr.sort() return max(arr[0] * arr[1] * arr[n-1], arr[n-1] * arr[n-2] * arr[n-3]) # Example usage: # arr = [1, 4, 3, -6, -7, 0] # n = len(arr) # print(maxProductOfThree(arr, n)) # Output: 168"},{"question":"def max_wheat(M: int, N: int, grid: List[List[int]]) -> int: Calculate the maximum units of wheat the farmer can collect in a MxN grid of wheat units by only moving right or down. Args: M: Number of rows in the grid. N: Number of columns in the grid. grid: 2D list where grid[i][j] represents the wheat units at cell (i+1, j+1). Returns: The maximum units of wheat that can be collected from the top-left corner to the bottom-right corner. Example: >>> M = 3 >>> N = 3 >>> grid = [ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ] >>> max_wheat(M, N, grid) 12 >>> M = 1 >>> N = 1 >>> grid = [ ... [7] ... ] >>> max_wheat(M, N, grid) 7","solution":"def max_wheat(M, N, grid): # Assume grid is a MxN list of lists where grid[i][j] represents the wheat units at cell (i+1, j+1) dp = [[0]*N for _ in range(M)] # Initialize the starting point dp[0][0] = grid[0][0] # Fill the first row for j in range(1, N): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column for i in range(1, M): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, M): for j in range(1, N): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The bottom-right corner will have the result return dp[M-1][N-1]"},{"question":"def max_sessions(N: int, sessions: List[List[int]]) -> int: You are given N sessions of a conference, each with a start time and an end time. Your task is to find the maximum number of sessions you can attend if you can only attend one session at a time. Note that if a session ends at the same time another one starts, you can attend both sessions consecutively. Args: N (int): the number of sessions sessions (List[List[int]]): a list of lists where each list contains two integers representing the start and end times of each session Returns: int: the maximum number of sessions you can attend Examples: >>> max_sessions(4, [[1, 3], [2, 4], [3, 5], [5, 6]]) 3 >>> max_sessions(3, [[5, 7], [1, 3], [3, 6]]) 2 >>> max_sessions(0, []) 0 >>> max_sessions(1, [[1, 2]]) 1 >>> max_sessions(3, [[1, 4], [2, 5], [3, 6]]) 1 >>> max_sessions(5, [[1, 2], [2, 3], [3, 4], [4, 5], [5, 6]]) 5 >>> max_sessions(4, [[5, 6], [1, 2], [3, 4], [2, 3]]) 4 # The function implementation will go here","solution":"def max_sessions(N, sessions): if N == 0: return 0 # Sort sessions by their end time sessions.sort(key=lambda x: x[1]) max_count = 1 last_end_time = sessions[0][1] for i in range(1, N): if sessions[i][0] >= last_end_time: max_count += 1 last_end_time = sessions[i][1] return max_count"},{"question":"def majorityElementCount(nums: List[int]) -> int: Given an integer array nums, find the number of occurrences of the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times, where n is the length of the array. Args: nums (List[int]): array of integers Returns: int: number of occurrences of the majority element Examples: >>> majorityElementCount([3, 2, 3]) 2 >>> majorityElementCount([2, 2, 1, 1, 1, 2, 2]) 4","solution":"def majorityElementCount(nums): def majorityElement(nums): count = 0 candidate = None for num in nums: if count == 0: candidate = num count += (1 if num == candidate else -1) return candidate majority_element = majorityElement(nums) return nums.count(majority_element)"},{"question":"def check_palindromes(n: int, strings: List[str]) -> List[str]: Check if each string in the list is a palindrome. >>> check_palindromes(5, [\\"racecar\\", \\"hello\\", \\"A man a plan a canal Panama\\", \\"Was it a car or a cat I saw\\", \\"Not a palindrome\\"]) [\\"Palindrome\\", \\"Not Palindrome\\", \\"Palindrome\\", \\"Palindrome\\", \\"Not Palindrome\\"] >>> check_palindromes(1, [\\"\\"]) [\\"Palindrome\\"] >>> check_palindromes(3, [\\"a\\", \\"b\\", \\"c\\"]) [\\"Palindrome\\", \\"Palindrome\\", \\"Palindrome\\"] >>> check_palindromes(2, [\\"Madam, I'm Adam.\\", \\"No 'x' in Nixon\\"]) [\\"Palindrome\\", \\"Palindrome\\"] >>> check_palindromes(1, [\\"Able was I saw Elba\\"]) [\\"Palindrome\\"] >>> check_palindromes(100, [\\"a\\" * 100] * 100) [\\"Palindrome\\"] * 100 >>> check_palindromes(100, [\\"a\\" * 50 + \\"b\\" + \\"a\\" * 49] * 100) [\\"Not Palindrome\\"] * 100","solution":"def check_palindromes(n, strings): def is_palindrome(s): s = ''.join(c for c in s if c.isalnum()).lower() return s == s[::-1] results = [] for string in strings: if is_palindrome(string): results.append(\\"Palindrome\\") else: results.append(\\"Not Palindrome\\") return results # Example of how to use the function n = 5 strings = [ \\"racecar\\", \\"hello\\", \\"A man a plan a canal Panama\\", \\"Was it a car or a cat I saw\\", \\"Not a palindrome\\" ] print(check_palindromes(n, strings))"},{"question":"def final_scores(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determines the final scores of each post after processing all the events. Args: t (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of tuples, each containing n (int): The number of events followed by a list of events. Returns: List[str]: A list of strings with the final scores of each post in the order they were created. Examples: >>> final_scores(3, [(5, [1, 2, 2, 3, 1]), (4, [2, 1, 3, 2]), (2, [1, 1])]) [\\"1 0\\", \\"0\\", \\"0 0\\"] >>> final_scores(1, [(3, [2, 3, 2])]) [\\"\\"] from typing import List, Tuple","solution":"def final_scores(t, test_cases): results = [] for test_case in test_cases: n, events = test_case post_scores = [] current_post = -1 for event in events: if event == 1: post_scores.append(0) current_post += 1 elif event == 2 and current_post >= 0: post_scores[current_post] += 1 elif event == 3 and current_post >= 0: post_scores[current_post] -= 1 results.append(' '.join(map(str, post_scores))) return results"},{"question":"def filter_by_threshold(lst: List[int], k: int) -> List[int]: Returns a new list containing elements from the input list that are greater than or equal to k. Parameters: lst (list): The input list of integers. k (int): The threshold integer. Returns: list: A new list with elements greater than or equal to k. >>> filter_by_threshold([3, 10, 5, 8, 4, 2, 7], 5) [10, 5, 8, 7] >>> filter_by_threshold([20, 15, 8, 30, 12], 15) [20, 15, 30] >>> filter_by_threshold([], 10) [] >>> filter_by_threshold([1, 2, 3, 4], 5) []","solution":"def filter_by_threshold(lst, k): Returns a new list containing elements from the input list that are greater than or equal to k. Parameters: lst (list): The input list of integers. k (int): The threshold integer. Returns: list: A new list with elements greater than or equal to k. return [x for x in lst if x >= k]"},{"question":"def sort_cards(n: int, card_numbers: List[int]) -> List[int]: Splits the cards into two parts, sorts each part, then merges them alternately. Args: n (int): The number of cards. card_numbers (List[int]): A list of integers representing the numbers on the cards. Returns: List[int]: A list of integers representing the final sequence of card numbers. Examples: >>> sort_cards(4, [13, 7, 5, 1]) [7, 1, 13, 5] >>> sort_cards(5, [8, 3, 10, 6, 2]) [3, 2, 8, 6, 10]","solution":"def sort_cards(n, card_numbers): Splits the cards into two parts, sorts each part, then merges them alternately. :param n: An integer representing the number of cards :param card_numbers: A list of integers representing the numbers on the cards :return: A list of integers representing the final sequence of card numbers first_half_length = n // 2 first_half = sorted(card_numbers[:first_half_length]) second_half = sorted(card_numbers[first_half_length:]) merged_result = [] i, j = 0, 0 while i < len(first_half) and j < len(second_half): merged_result.append(first_half[i]) i += 1 if j < len(second_half): merged_result.append(second_half[j]) j += 1 while i < len(first_half): merged_result.append(first_half[i]) i += 1 while j < len(second_half): merged_result.append(second_half[j]) j += 1 return merged_result"},{"question":"def find_peak_popularity(n: int, P: List[int]) -> Tuple[int, int, int]: Finds the peak day and total number of customers. :param n: Number of days (integer) :param P: List of integers representing customers each day :return: Tuple with peak day (1-indexed), maximum number of customers, and total customers >>> find_peak_popularity(5, [10, 30, 20, 50, 40]) (4, 50, 150) >>> find_peak_popularity(1, [100]) (1, 100, 100) from typing import List, Tuple def test_sample_input(): n = 5 P = [10, 30, 20, 50, 40] assert find_peak_popularity(n, P) == (4, 50, 150) def test_single_day(): n = 1 P = [100] assert find_peak_popularity(n, P) == (1, 100, 100) def test_increasing_customers(): n = 4 P = [10, 20, 30, 40] assert find_peak_popularity(n, P) == (4, 40, 100) def test_decreasing_customers(): n = 4 P = [40, 30, 20, 10] assert find_peak_popularity(n, P) == (1, 40, 100) def test_random_customers(): n = 3 P = [25, 50, 25] assert find_peak_popularity(n, P) == (2, 50, 100) def test_same_number_customers(): n = 5 P = [20, 20, 20, 20, 20] assert find_peak_popularity(n, P) == (1, 20, 100)","solution":"def find_peak_popularity(n, P): Finds the peak day and total number of customers. :param n: Number of days (integer) :param P: List of integers representing customers each day :return: Tuple with peak day (1-indexed), maximum number of customers, and total customers max_pop = 0 peak_day = 0 sum_population = 0 for i in range(n): sum_population += P[i] if P[i] > max_pop: max_pop = P[i] peak_day = i + 1 # 1-indexed return peak_day, max_pop, sum_population"},{"question":"from typing import List def max_nesting_depth(arr: List[int]) -> int: Determine the maximum level of nesting for each element in the list. Args: arr (list of int): The input list of integers. Returns: int: The maximum level of nesting required. Examples: >>> max_nesting_depth([4, 2, 3, 1]) 2 >>> max_nesting_depth([5, 6, 7, 8]) 1 >>> max_nesting_depth([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 1 pass","solution":"def max_nesting_depth(arr): Determine the maximum level of nesting for each element in the list. Args: arr (list of int): The input list of integers. Returns: int: The maximum level of nesting required. # Since the input is a single line of space-separated integers, # for the purpose of this function, we assume the argument # is a list of integers directly. if len(arr) <= 1: return 1 current_depth = 1 max_depth = 1 for i in range(1, len(arr)): if arr[i] < arr[i-1]: current_depth += 1 max_depth = max(max_depth, current_depth) else: current_depth = 1 return max_depth"},{"question":"from collections import defaultdict, deque from typing import List, Tuple def find_longest_path(n: int, m: int, edges: List[Tuple[int, int]]) -> int: Finds the length of the longest path in a given directed acyclic graph (DAG) where no intersection is visited more than once. Args: n (int): Number of intersections (nodes). m (int): Number of one-way roads (edges). edges (List[Tuple[int, int]]): List of one-way roads represented as pairs of integers (u, v). Returns: int: Length of the longest path. >>> find_longest_path(5, 6, [(0, 1), (1, 2), (2, 3), (1, 3), (3, 4), (2, 4)]) 4 >>> find_longest_path(1, 0, []) 0 >>> find_longest_path(3, 0, []) 0 >>> find_longest_path(4, 3, [(0, 1), (1, 2), (2, 3)]) 3 >>> find_longest_path(4, 5, [(0, 1), (0, 2), (1, 3), (2, 3), (0, 3)]) 2","solution":"from collections import defaultdict, deque def find_longest_path(n, m, edges): # Construct the graph graph = defaultdict(list) in_degrees = [0] * n for u, v in edges: graph[u].append(v) in_degrees[v] += 1 # Implementing Kahn's algorithm for topological sorting topo_order = [] queue = deque([node for node in range(n) if in_degrees[node] == 0]) while queue: node = queue.popleft() topo_order.append(node) for neighbor in graph[node]: in_degrees[neighbor] -= 1 if in_degrees[neighbor] == 0: queue.append(neighbor) # Finding the longest path dp = [-1] * n for node in topo_order: if dp[node] == -1: dp[node] = 0 for neighbor in graph[node]: if dp[neighbor] < dp[node] + 1: dp[neighbor] = dp[node] + 1 return max(dp) # Input example for illustration purposes if __name__ == \\"__main__\\": n = 5 m = 6 edges = [(0, 1), (1, 2), (2, 3), (1, 3), (3, 4), (2, 4)] print(find_longest_path(n, m, edges))"},{"question":"def minimize_disorderliness(N, books): Minimizes the disorderliness by returning the books sorted in ascending order. :param N: int, number of books :param books: list of int, initial arrangement of books :return: list of int, arrangement with minimum disorderliness >>> minimize_disorderliness(3, [3, 1, 2]) [1, 2, 3] >>> minimize_disorderliness(5, [5, 3, 2, 4, 1]) [1, 2, 3, 4, 5] >>> minimize_disorderliness(4, [4, 3, 1, 2]) [1, 2, 3, 4]","solution":"def minimize_disorderliness(N, books): Minimizes the disorderliness by returning the books sorted in ascending order. :param N: int, number of books :param books: list of int, initial arrangement of books :return: list of int, arrangement with minimum disorderliness return sorted(books)"},{"question":"from typing import List def find_minimum_swaps(arr: List[int]) -> int: Find the minimum number of swaps required to arrange the stones in a non-decreasing order of their power values. >>> find_minimum_swaps([4, 3, 1, 2, 5]) 3 >>> find_minimum_swaps([1, 2, 3, 4, 5]) 0 >>> find_minimum_swaps([2, 4, 1, 3, 5]) 3 >>> find_minimum_swaps([5, 4, 3, 2, 1]) 2 >>> find_minimum_swaps([1]) 0 >>> find_minimum_swaps([1, 3, 5, 2, 4, 6]) 3","solution":"def find_minimum_swaps(arr): n = len(arr) # Create a sorted version of the array to get target positions sorted_arr = sorted(arr) # To record the visited status of elements visited = [False] * n # Element to correct index mapping index_dict = {value: index for index, value in enumerate(arr)} swaps = 0 for i in range(n): # If the element is already in the correct position or visited if visited[i] or arr[i] == sorted_arr[i]: continue # Initialize cycle cycle_size = 0 x = i while not visited[x]: visited[x] = True x = index_dict[sorted_arr[x]] cycle_size += 1 if cycle_size > 0: swaps += (cycle_size - 1) return swaps"},{"question":"def min_insertions_to_make_valid(s: str) -> int: Returns the minimum number of insertion operations required to make the string valid with balanced parentheses. :param s: String consisting of only '(' and ')' :return: Integer indicating the number of insertions required >>> min_insertions_to_make_valid(\\"()\\") 0 >>> min_insertions_to_make_valid(\\"(())\\") 0 >>> min_insertions_to_make_valid(\\"()()\\") 0 >>> min_insertions_to_make_valid(\\"(()\\") 1 >>> min_insertions_to_make_valid(\\"())\\") 1 >>> min_insertions_to_make_valid(\\"))(\\") 3 >>> min_insertions_to_make_valid(\\"()))((\\") 4 >>> min_insertions_to_make_valid(\\"(((((\\") 5 >>> min_insertions_to_make_valid(\\")))))\\") 5 >>> min_insertions_to_make_valid(\\")()(\\") 2 >>> min_insertions_to_make_valid(\\"(()))\\") 1 >>> min_insertions_to_make_valid(\\")(\\") 2 >>> min_insertions_to_make_valid(\\"(()()())())\\") 1","solution":"def min_insertions_to_make_valid(s): Returns the minimum number of insertion operations required to make the string valid with balanced parentheses. :param s: String consisting of only '(' and ')' :return: Integer indicating the number of insertions required open_needed = 0 # To keep track of opening parentheses needed close_needed = 0 # To keep track of closing parentheses needed for char in s: if char == '(': close_needed += 1 # Each '(' needs one ')' else: if close_needed > 0: close_needed -= 1 else: open_needed += 1 # If no closer found for this ')', need to insert '(' return open_needed + close_needed"},{"question":"def edit_distance(s1: str, s2: str) -> int: Calculate the edit distance between two strings. >>> edit_distance(\\"kitten\\", \\"sitting\\") 3 >>> edit_distance(\\"flaw\\", \\"lawn\\") 2 >>> edit_distance(\\"\\", \\"\\") 0 >>> edit_distance(\\"abc\\", \\"\\") 3 >>> edit_distance(\\"intention\\", \\"execution\\") 5","solution":"def edit_distance(s1: str, s2: str) -> int: Calculate the edit distance between two strings. Args: s1 (str): first string s2 (str): second string Returns: int: minimum number of operations required to convert s1 to s2 m, n = len(s1), len(s2) # Create a 2D array to store distances dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the table for i in range(m + 1): dp[i][0] = i for j in range(n + 1): dp[0][j] = j # Fill the table for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], # Deletion dp[i][j - 1], # Insertion dp[i - 1][j - 1]) # Substitution return dp[m][n]"},{"question":"def calculate_final_savings(n: int, s: int, transactions: List[int]) -> int: Calculates Joe's final savings after a series of daily transactions. :param n: Number of daily transactions (integer) :param s: Initial savings (integer) :param transactions: List of daily transactions (list of integers) :return: Final savings (integer) >>> calculate_final_savings(5, 1000, [200, -100, 50, -300, 100]) == 950 >>> calculate_final_savings(3, 500, [100, 200, 150]) == 950 >>> calculate_final_savings(4, 800, [-100, -200, -50, -300]) == 150 >>> calculate_final_savings(6, 1000, [300, -200, 100, -50, -150, 250]) == 1250 >>> calculate_final_savings(3, 0, [100, -50, 75]) == 125 >>> calculate_final_savings(3, 1000000, [100000, -50000, 200000]) == 1250000 >>> calculate_final_savings(0, 500, []) == 500","solution":"def calculate_final_savings(n, s, transactions): Calculates Joe's final savings after a series of daily transactions. :param n: Number of daily transactions (integer) :param s: Initial savings (integer) :param transactions: List of daily transactions (list of integers) :return: Final savings (integer) final_savings = s for transaction in transactions: final_savings += transaction return final_savings"},{"question":"def maxNonNegativeSum(arr, n): Returns the maximum sum of any contiguous subarray of non-negative integers. If no such subarray exists, return 0. >>> maxNonNegativeSum([-1, 2, 3, -5, 4, 6], 6) 10 >>> maxNonNegativeSum([-5, -2, -3, -8], 4) 0","solution":"def maxNonNegativeSum(arr, n): Returns the maximum sum of any contiguous subarray of non-negative integers. If no such subarray exists, return 0. max_sum = 0 current_sum = 0 for i in range(n): if arr[i] >= 0: current_sum += arr[i] else: max_sum = max(max_sum, current_sum) current_sum = 0 # Final check in case the array ends with a positive subarray max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def sum_array(arr): Returns the sum of elements in the array arr. >>> sum_array([3, 9, 1, 14, 8]) 35 >>> sum_array([0, 0, 0, 0, 0]) 0 >>> sum_array([-3, -9, -1, -14, -8]) -35 >>> sum_array([-3, 9, -1, 14, -8]) 11 >>> sum_array([5]) 5 >>> sum_array([]) 0 pass","solution":"def sum_array(arr): Returns the sum of elements in the array arr. return sum(arr)"},{"question":"def can_type_sentence(sentence: str, malfunctioning_keys: str) -> str: Determines if the sentence can be typed accurately given the malfunctioning keys. Parameters: sentence (str): the original sentence to be typed. malfunctioning_keys (str): comma-separated string of malfunctioning keys. Returns: str: \\"YES\\" if the sentence can be typed accurately, otherwise \\"NO\\". >>> can_type_sentence(\\"hello world\\", \\"h,e,l\\") \\"NO\\" >>> can_type_sentence(\\"good morning\\", \\"z,q,x\\") \\"YES\\"","solution":"def can_type_sentence(sentence, malfunctioning_keys): Determines if the sentence can be typed accurately given the malfunctioning keys. Parameters: sentence (str): the original sentence to be typed. malfunctioning_keys (str): comma-separated string of malfunctioning keys. Returns: str: \\"YES\\" if the sentence can be typed accurately, otherwise \\"NO\\". malfunctioning_keys_set = set(malfunctioning_keys.split(',')) for char in sentence: if char in malfunctioning_keys_set: return \\"NO\\" return \\"YES\\""},{"question":"def can_form_increasing_sequence(n: int, heights: List[int]) -> str: Determines if it is possible to obtain a strictly increasing sequence of the heights after removing at most one block. >>> can_form_increasing_sequence(6, [1, 2, 10, 5, 7, 8]) 'YES' >>> can_form_increasing_sequence(5, [1, 2, 3, 4, 5]) 'YES' >>> can_form_increasing_sequence(3, [5, 4, 3]) 'NO'","solution":"def can_form_increasing_sequence(n, heights): def is_strictly_increasing(arr): return all(arr[i] < arr[i + 1] for i in range(len(arr) - 1)) if is_strictly_increasing(heights): return \\"YES\\" for i in range(n): new_heights = heights[:i] + heights[i+1:] if is_strictly_increasing(new_heights): return \\"YES\\" return \\"NO\\" # Read input if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() n = int(data[0]) heights = list(map(int, data[1:])) print(can_form_increasing_sequence(n, heights))"},{"question":"def maximum_difference(nums: List[int]) -> int: Returns the maximum difference between consecutive elements after sorting the list. If the list has only one element or is empty, returns 0. >>> maximum_difference([3, 6, 9, 1]) 3 >>> maximum_difference([10]) 0 >>> maximum_difference([]) 0 >>> maximum_difference([1, 2, 3, 4, 5]) 1 >>> maximum_difference([1, 3, 7, 9, 13]) 4 >>> maximum_difference([10, 20, 30, 40, 50]) 10 >>> maximum_difference([5, 5, 5, 5, 5]) 0 >>> maximum_difference([1, 9, 4, 7]) 3","solution":"def maximum_difference(nums): Returns the maximum difference between consecutive elements after sorting the list. If the list has only one element or is empty, returns 0. if len(nums) <= 1: return 0 nums.sort() max_diff = 0 for i in range(1, len(nums)): max_diff = max(max_diff, nums[i] - nums[i - 1]) return max_diff"},{"question":"def final_position(moves: str) -> (int, int): Returns the final coordinates of the robot after following the sequence of moves. >>> final_position(\\"UDLR\\") 0, 0 >>> final_position(\\"UUDDLRLR\\") 0, 0 >>> final_position(\\"UUUU\\") 0, 4 >>> final_position(\\"DDDD\\") 0, -4 >>> final_position(\\"LLLL\\") -4, 0 >>> final_position(\\"RRRR\\") 4, 0 >>> final_position(\\"UURRDDLL\\") 0, 0 >>> final_position(\\"UDLRUDLR\\") 0, 0","solution":"def final_position(moves): Returns the final coordinates of the robot after following the sequence of moves. x, y = 0, 0 for move in moves: if move == 'U': y += 1 elif move == 'D': y -= 1 elif move == 'L': x -= 1 elif move == 'R': x += 1 return x, y"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def create_tree(node_tuples): if not node_tuples: return None nodes = {} for val, left, right in node_tuples: if val not in nodes: nodes[val] = TreeNode(val) if left is not None: if left not in nodes: nodes[left] = TreeNode(left) nodes[val].left = nodes[left] if right is not None: if right not in nodes: nodes[right] = TreeNode(right) nodes[val].right = nodes[right] return nodes[node_tuples[0][0]] if node_tuples else None def is_bst(node, left=float('-inf'), right=float('inf')): if not node: return True if not (left < node.val < right): return False return is_bst(node.left, left, node.val) and is_bst(node.right, node.val, right) def check_if_bst(node_tuples): Check if a given binary tree is a binary search tree (BST). >>> check_if_bst([(8, 3, 10), (3, 1, 6), (1, None, None), (6, 4, 7), (4, None, None), (7, None, None), (10, None, 14), (14, 13, None), (13, None, None)]) 'YES' >>> check_if_bst([(5, 1, 4), (1, None, None), (4, 3, 6), (3, None, None), (6, None, None)]) 'NO'","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def create_tree(node_tuples): if not node_tuples: return None nodes = {} for val, left, right in node_tuples: if val not in nodes: nodes[val] = TreeNode(val) if left is not None: if left not in nodes: nodes[left] = TreeNode(left) nodes[val].left = nodes[left] if right is not None: if right not in nodes: nodes[right] = TreeNode(right) nodes[val].right = nodes[right] return nodes[node_tuples[0][0]] if node_tuples else None def is_bst(node, left=float('-inf'), right=float('inf')): if not node: return True if not (left < node.val < right): return False return is_bst(node.left, left, node.val) and is_bst(node.right, node.val, right) def check_if_bst(node_tuples): root = create_tree(node_tuples) return \\"YES\\" if is_bst(root) else \\"NO\\""},{"question":"def process_shipments(data): Process the shipment data and return the updated stock quantities. Parameters: data (list): A list of strings where each string is a line of input ending with \\"END\\". Returns: list: A list of strings representing the updated stock quantities in the format \\"S: X\\". >>> process_shipments([ ... \\"2\\", ... \\"apple 150 100\\", ... \\"orange 200 150\\", ... \\"END\\" ... ]) [\\"apple: 250\\", \\"orange: 350\\"] >>> process_shipments([ ... \\"2\\", ... \\"apple 150 100\\", ... \\"orange 200 150\\", ... \\"3\\", ... \\"banana 100 50\\", ... \\"apple 200 200\\", ... \\"banana 50 50\\", ... \\"END\\" ... ]) [\\"apple: 250\\", \\"orange: 350\\", \\"banana: 150\\", \\"apple: 400\\", \\"banana: 100\\"] >>> process_shipments([ ... \\"1\\", ... \\"watermelon 300 200\\", ... \\"END\\" ... ]) [\\"watermelon: 500\\"] >>> process_shipments([ ... \\"2\\", ... \\"peach 0 100\\", ... \\"plum 100 0\\", ... \\"END\\" ... ]) [\\"peach: 100\\", \\"plum: 100\\"] >>> process_shipments([ ... \\"2\\", ... \\"kiwi 0 0\\", ... \\"papaya 0 0\\", ... \\"END\\" ... ]) [\\"kiwi: 0\\", \\"papaya: 0\\"]","solution":"def process_shipments(data): Process the shipment data and return the updated stock quantities. Parameters: data (list): A list of strings where each string is a line of input. Returns: list: A list of strings representing the updated stock quantities in the format \\"S: X\\". results = [] index = 0 while index < len(data): if data[index] == \\"END\\": break T = int(data[index]) index += 1 for _ in range(T): line = data[index].split() item = line[0] initial_stock = int(line[1]) received_stock = int(line[2]) updated_stock = initial_stock + received_stock results.append(f\\"{item}: {updated_stock}\\") index += 1 return results"},{"question":"def maxNonOverlappingRequests(requests): Function to find the maximum number of non-overlapping requests. Parameters: requests (list): List of requests where each request is a list [si, ei]. Returns: int: Maximum number of non-overlapping requests. from solution import maxNonOverlappingRequests def test_example_1(): requests = [[0, 3], [2, 5], [4, 7], [6, 9], [8, 10]] assert maxNonOverlappingRequests(requests) == 3 def test_example_2(): requests = [[1, 3], [2, 4], [3, 5]] assert maxNonOverlappingRequests(requests) == 2 def test_no_requests(): requests = [] assert maxNonOverlappingRequests(requests) == 0 def test_all_overlap(): requests = [[0, 5], [1, 6], [2, 7], [3, 8]] assert maxNonOverlappingRequests(requests) == 1 def test_non_overlapping_consecutive(): requests = [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5]] assert maxNonOverlappingRequests(requests) == 5 def test_mixed(): requests = [[0, 3], [1, 2], [3, 4], [2, 8], [4, 7]] assert maxNonOverlappingRequests(requests) == 3","solution":"def maxNonOverlappingRequests(requests): Function to find the maximum number of non-overlapping requests. Parameters: requests (list): List of requests where each request is a list [si, ei]. Returns: int: Maximum number of non-overlapping requests. # Sort requests by their end time requests.sort(key=lambda x: x[1]) # Initialize the variables count = 0 last_end = -1 # Iterate through each request for si, ei in requests: # If the start time of the current request is greater than last end time, # then it is a non-overlapping request if si >= last_end: count += 1 last_end = ei return count"},{"question":"def minimal_packages(m): Returns the minimal number of packages required to achieve exactly M stones. If it's impossible to collect exactly M stones, returns -1. def process_test_cases(test_cases): Processes multiple test cases of the minimal_packages function. Parameters: test_cases (list): List of integers representing the test cases. Returns: list: A list of results for each test case. from solution import minimal_packages, process_test_cases def test_minimal_packages(): assert minimal_packages(29) == 5 assert minimal_packages(15) == 3 assert minimal_packages(8) == 2 assert minimal_packages(13) == -1 assert minimal_packages(4) == 1 assert minimal_packages(7) == 1 assert minimal_packages(11) == 2 def test_process_test_cases(): assert process_test_cases([29, 15, 8]) == [5, 3, 2] assert process_test_cases([13, 4, 7]) == [-1, 1, 1] assert process_test_cases([11, 20, 25]) == [2, 5, 4] # Running the tests test_minimal_packages() test_process_test_cases()","solution":"def minimal_packages(m): Returns the minimal number of packages required to achieve exactly M stones. If it's impossible to collect exactly M stones, returns -1. for num_sevens in range(m // 7, -1, -1): remaining_stones = m - num_sevens * 7 if remaining_stones % 4 == 0: num_fours = remaining_stones // 4 return num_sevens + num_fours return -1 def process_test_cases(test_cases): Processes multiple test cases of the minimal_packages function. Parameters: test_cases (list): List of integers representing the test cases. Returns: list: A list of results for each test case. results = [] for m in test_cases: results.append(minimal_packages(m)) return results"},{"question":"from typing import List def process_commands(commands: List[str]) -> List[str]: Processes a list of restock and purchase commands and returns the result of each purchase request. Args: commands (list of str): The list of commands to process. Returns: list of str: The results of the purchase commands (either \\"SUCCESS\\" or \\"FAILURE\\"). pass # Unit tests def test_restock_command(): commands = [ \\"restock 1 100\\", \\"restock 2 200\\" ] # No purchase commands, hence no result to check. result = process_commands(commands) assert result == [] def test_successful_purchase(): commands = [ \\"restock 1 100\\", \\"purchase 1 50\\" ] result = process_commands(commands) assert result == [\\"SUCCESS\\"] def test_unsuccessful_purchase(): commands = [ \\"restock 1 100\\", \\"purchase 1 150\\" ] result = process_commands(commands) assert result == [\\"FAILURE\\"] def test_mixed_purchases(): commands = [ \\"restock 1 100\\", \\"purchase 1 50\\", \\"purchase 1 60\\" ] result = process_commands(commands) assert result == [\\"SUCCESS\\", \\"FAILURE\\"] def test_multiple_products(): commands = [ \\"restock 1 100\\", \\"restock 2 200\\", \\"purchase 1 50\\", \\"purchase 2 300\\", \\"purchase 2 150\\" ] result = process_commands(commands) assert result == [\\"SUCCESS\\", \\"FAILURE\\", \\"SUCCESS\\"]","solution":"def process_commands(commands): Processes a list of restock and purchase commands and returns the result of each purchase request. Args: commands (list of str): The list of commands to process. Returns: list of str: The results of the purchase commands (either \\"SUCCESS\\" or \\"FAILURE\\"). inventory = {} results = [] for command in commands: parts = command.split() cmd_type = parts[0] product_id = int(parts[1]) quantity = int(parts[2]) if cmd_type == \\"restock\\": if product_id in inventory: inventory[product_id] += quantity else: inventory[product_id] = quantity elif cmd_type == \\"purchase\\": if product_id in inventory and inventory[product_id] >= quantity: inventory[product_id] -= quantity results.append(\\"SUCCESS\\") else: results.append(\\"FAILURE\\") return results"},{"question":"def max_teams(scores_ids): Returns the maximum number of teams with distinct scores. Parameters: scores_ids (List[Tuple[int, int]]): List of tuples containing score and ID. Returns: int: Maximum number of teams that can receive prizes. Examples: >>> max_teams([(95, 1), (92, 2), (93, 3), (94, 4), (95, 5), (96, 6)]) 5 >>> max_teams([(91, 1), (92, 2), (91, 3), (92, 4), (93, 5)]) 3 >>> max_teams([(88, 1), (89, 2), (90, 3), (91, 4)]) 4 >>> max_teams([(100, 1), (100, 2), (100, 3), (100, 4), (100, 5)]) 1 >>> max_teams([]) 0 >>> max_teams([(i, i) for i in range(-100, 101)]) 201","solution":"def max_teams(scores_ids): Returns the maximum number of teams with distinct scores. Parameters: scores_ids (List[Tuple[int, int]]): List of tuples containing score and ID. Returns: int: Maximum number of teams that can receive prizes. scores_set = set() for score, _ in scores_ids: scores_set.add(score) return len(scores_set)"},{"question":"def max_abs_difference(arr): Returns the maximum absolute difference between any two adjacent elements in the array after performing exactly one valid operation. A valid operation is defined as setting any element of the array to zero. >>> max_abs_difference([2, 4, 8, 6, 10]) 10 >>> max_abs_difference([1, 3, 7, 5]) 7","solution":"def max_abs_difference(arr): Returns the maximum absolute difference between any two adjacent elements in the array after performing exactly one valid operation. A valid operation is defined as setting any element of the array to zero. max_difference = 0 for i in range(1, len(arr)): max_difference = max(max_difference, abs(arr[i] - arr[i-1])) possible_max_diff = max(abs(arr[0]), abs(arr[-1])) for i in range(1, len(arr) - 1): possible_max_diff = max(possible_max_diff, abs(arr[i+1] - 0), abs(arr[i-1] - 0)) return max(max_difference, possible_max_diff)"},{"question":"def can_reach_target_sum(arr: List[int], target: int) -> str: Determine if there exists a non-empty subsequence of the array whose sum equals the given target sum. >>> can_reach_target_sum([1, 2, 3, 4, 5], 9) \\"YES\\" >>> can_reach_target_sum([1, 2, 3], 7) \\"NO\\"","solution":"def can_reach_target_sum(arr, target): n = len(arr) dp = [False] * (target + 1) dp[0] = True for num in arr: for j in range(target, num - 1, -1): if dp[j - num]: dp[j] = True return \\"YES\\" if dp[target] else \\"NO\\""},{"question":"def min_cost_path(t, test_cases): Calculate the minimum cost required to move from the top-left to the bottom-right corner of the grid. :param t: Number of test cases :param test_cases: List of tuples where each tuple contains n, m, and the grid (list of lists) :return: List of minimum costs for each test case def test_min_cost_path_single_case(): t = 1 test_cases = [ (3, 3, [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ]) ] assert min_cost_path(t, test_cases) == [7] def test_min_cost_path_multiple_cases(): t = 2 test_cases = [ (3, 3, [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ]), (2, 2, [ [4, 7], [2, 8] ]) ] assert min_cost_path(t, test_cases) == [7, 14] def test_min_cost_path_case_with_minimum_values(): t = 1 test_cases = [ (1, 1, [ [100] ]) ] assert min_cost_path(t, test_cases) == [100] def test_min_cost_path_case_with_maximum_values(): t = 1 test_cases = [ (2, 2, [ [1, 100], [100, 1] ]) ] assert min_cost_path(t, test_cases) == [102] def test_min_cost_path_large_grid(): t = 1 grid = [[1 for _ in range(100)] for _ in range(100)] test_cases = [ (100, 100, grid) ] assert min_cost_path(t, test_cases) == [199] # 100 (down) + 99 (right) steps all having cost 1","solution":"def min_cost_path(t, test_cases): Calculate the minimum cost required to move from the top-left to the bottom-right corner of the grid. :param t: Number of test cases :param test_cases: List of tuples where each tuple contains n, m, and the grid (list of lists) :return: List of minimum costs for each test case results = [] for case in test_cases: n, m, grid = case # dp array to store the minimum cost to reach each cell dp = [[0] * m for _ in range(n)] # Initialize the top-left cell with the starting point cost dp[0][0] = grid[0][0] # Fill the first row for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp array for i in range(1, n): for j in range(1, m): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The minimum cost to reach the bottom-right cell results.append(dp[n-1][m-1]) return results"},{"question":"def pacific_atlantic(m: int, n: int, heights: List[List[int]]) -> List[List[int]]: Given a grid with m rows and n columns, where each cell in the grid contains a positive integer height representing the elevation at that point, find all the cells where water can both flow to the Pacific Ocean (left and top edges of the grid) and the Atlantic Ocean (right and bottom edges of the grid). >>> pacific_atlantic(5, 5, [[1, 2, 2, 3, 5], [3, 2, 3, 4, 4], [2, 4, 5, 3, 1], [6, 7, 1, 4, 5], [5, 1, 1, 2, 4]]) == [[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] [[0, 0]] >>> pacific_atlantic(1, 1, [[1]]) == [[0, 0]]","solution":"def pacific_atlantic(m, n, heights): def dfs(ocean, visited, x, y): if (x, y) in visited: return visited.add((x, y)) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and heights[nx][ny] >= heights[x][y]: dfs(ocean, visited, nx, ny) # All four possible directions of movement directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Sets to keep track of cells reachable from each ocean pacific = set() atlantic = set() # Initiate DFS from the pacific ocean border cells for i in range(m): dfs('pacific', pacific, i, 0) dfs('atlantic', atlantic, i, n-1) for j in range(n): dfs('pacific', pacific, 0, j) dfs('atlantic', atlantic, m-1, j) # Intersection of cells reachable from both oceans result = list(map(list, pacific & atlantic)) return result"},{"question":"from typing import List def most_frequent_excluded_word(s: str, words: List[str]) -> str: Finds the most frequent word in s that is not included in the list of words. If there is a tie, returns the lexicographically smallest word. >>> most_frequent_excluded_word(\\"the quick brown fox jumps over the lazy dog quick the fox\\", [\\"the\\", \\"fox\\"]) 'quick' >>> most_frequent_excluded_word(\\"cat bat cat rat bat cat\\", [\\"bat\\"]) 'cat' >>> most_frequent_excluded_word(\\"apple orange banana apple orange\\", [\\"apple\\", \\"banana\\"]) 'orange' pass","solution":"from collections import Counter def most_frequent_excluded_word(s, words): Finds the most frequent word in s that is not included in the list of words. If there is a tie, returns the lexicographically smallest word. # Split the string into words and count their frequencies word_list = s.split() word_counts = Counter(word_list) # Remove the banned words from the count dictionary for word in words: if word in word_counts: del word_counts[word] # Find the most frequent word not in the banned list max_count = -1 most_frequent_word = \\"\\" for word, count in word_counts.items(): if count > max_count or (count == max_count and word < most_frequent_word): max_count = count most_frequent_word = word return most_frequent_word"},{"question":"def modify_revenue_sequence(n, revenues): Modify the sequence of revenues according to the company's policy. >>> modify_revenue_sequence(5, [10, 20, 30, 40, 50]) [10, 20, 30, 40, 50] >>> modify_revenue_sequence(5, [10, 5, 20, 15, 25]) [10, 0, 20, 15, 25] >>> modify_revenue_sequence(4, [1, 2, 1, 3]) [1, 2, 0, 3] >>> modify_revenue_sequence(1, [100]) [100] >>> modify_revenue_sequence(4, [5, 5, 5, 5]) [5, 5, 5, 5] >>> modify_revenue_sequence(3, [7, 14, 7]) [7, 14, 0] >>> modify_revenue_sequence(3, [0, 0, 0]) [0, 0, 0] >>> modify_revenue_sequence(4, [5, 0, 10, 0]) [5, 0, 10, 0]","solution":"def modify_revenue_sequence(n, revenues): modified_revenues = [] total = 0 for i in range(n): total += revenues[i] average = total / (i + 1) if revenues[i] < average: modified_revenues.append(0) total -= revenues[i] else: modified_revenues.append(revenues[i]) return modified_revenues def parse_input(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) revenues = list(map(int, data[1:])) result = modify_revenue_sequence(n, revenues) print(\\" \\".join(map(str, result)))"},{"question":"def findMedianSortedArrays(nums1, nums2): Given two sorted arrays nums1 and nums2 of size m and n respectively, this function returns the median of the two sorted arrays. The overall run-time complexity should be O(log(min(m, n))). Args: nums1: List[int] - A sorted list of integers. nums2: List[int] - Another sorted list of integers. Returns: float - The median value as a float. Examples: >>> findMedianSortedArrays([1, 3, 8, 9], [2, 4, 7, 10]) 5.500000000000000 >>> findMedianSortedArrays([1, 2, 3], [4, 5, 6, 7]) 4.000000000000000 pass","solution":"def findMedianSortedArrays(nums1, nums2): Given two sorted arrays nums1 and nums2 of size m and n respectively, this function returns the median of the two sorted arrays. # Ensure nums1 is the smaller array to minimize the binary search range if len(nums1) > len(nums2): nums1, nums2 = nums2, nums1 m, n = len(nums1), len(nums2) imin, imax, half_len = 0, m, (m + n + 1) // 2 while imin <= imax: i = (imin + imax) // 2 j = half_len - i if i < m and nums1[i] < nums2[j - 1]: imin = i + 1 elif i > 0 and nums1[i - 1] > nums2[j]: imax = i - 1 else: if i == 0: max_of_left = nums2[j - 1] elif j == 0: max_of_left = nums1[i - 1] else: max_of_left = max(nums1[i - 1], nums2[j - 1]) if (m + n) % 2 == 1: return max_of_left if i == m: min_of_right = nums2[j] elif j == n: min_of_right = nums1[i] else: min_of_right = min(nums1[i], nums2[j]) return (max_of_left + min_of_right) / 2.0"},{"question":"from typing import List, Tuple def track_user_visits(n: int, user_visits: List[int]) -> List[Tuple[int, int]]: Given a list of user visits, calculates the number of visits per user and returns the result in ascending order of user IDs. :param n: int, the number of visits :param user_visits: list of int, the list of user IDs representing visits :return: list of tuples, each tuple contains (user ID, number of visits) >>> track_user_visits(5, [2, 1, 2, 1, 2]) [(1, 2), (2, 3)] >>> track_user_visits(4, [1000000, 999999, 1000000, 999999]) [(999999, 2), (1000000, 2)] >>> track_user_visits(3, [1, 1, 1]) [(1, 3)] >>> track_user_visits(6, [3, 5, 3, 5, 3, 2]) [(2, 1), (3, 3), (5, 2)] >>> track_user_visits(0, []) []","solution":"def track_user_visits(n, user_visits): Given a list of user visits, calculates the number of visits per user and returns the result in ascending order of user IDs. :param n: int, the number of visits :param user_visits: list of int, the list of user IDs representing visits :return: list of tuples, each tuple contains (user ID, number of visits) from collections import defaultdict visit_count = defaultdict(int) for user_id in user_visits: visit_count[user_id] += 1 result = sorted(visit_count.items()) return result # Example usage: # n = 5 # user_visits = [2, 1, 2, 1, 2] # print(track_user_visits(n, user_visits)) # Output should be [(1, 2), (2, 3)]"},{"question":"def check_valid_sequence(s: str) -> str: Checks if the given sequence is valid. A sequence is valid if no two 'B's are adjacent. Parameters: s (str): The input sequence consisting of characters 'A' and 'B'. Returns: str: \\"VALID\\" if the sequence is valid, otherwise \\"INVALID\\". >>> check_valid_sequence(\\"AABAB\\") 'VALID' >>> check_valid_sequence(\\"AABB\\") 'INVALID' >>> check_valid_sequence(\\"B\\") 'VALID' >>> check_valid_sequence(\\"BB\\") 'INVALID' >>> check_valid_sequence(\\"ABABA\\") 'VALID' >>> check_valid_sequence(\\"AAA\\") 'VALID'","solution":"def check_valid_sequence(s): Checks if the given sequence is valid. A sequence is valid if no two 'B's are adjacent. Parameters: s (str): The input sequence consisting of characters 'A' and 'B'. Returns: str: \\"VALID\\" if the sequence is valid, otherwise \\"INVALID\\". # Check if sequence contains 'BB' if 'BB' in s: return \\"INVALID\\" return \\"VALID\\""},{"question":"def longest_distinct_subsequence_length(n: int, runes: List[int]) -> int: Find the length of the longest continuous subsequence of distinct integers in a list of runes. >>> longest_distinct_subsequence_length(7, [1, 2, 3, 2, 4, 5, 6]) 5 >>> longest_distinct_subsequence_length(8, [10, 20, 10, 30, 40, 50, 20, 30]) 5 >>> longest_distinct_subsequence_length(5, [1, 2, 3, 4, 5]) 5 >>> longest_distinct_subsequence_length(5, [1, 1, 1, 1, 1]) 1 >>> longest_distinct_subsequence_length(15, [1, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 1]) 8 >>> longest_distinct_subsequence_length(1, [1]) 1","solution":"def longest_distinct_subsequence_length(n, runes): rune_set = set() left = 0 result = 0 for right in range(n): while runes[right] in rune_set: rune_set.remove(runes[left]) left += 1 rune_set.add(runes[right]) result = max(result, right - left + 1) return result"},{"question":"class TextEditor: Simulate a text editor with undo functionality. The initial text is an empty string. The editor supports the following commands: - Append: Append a given string to the current text. - Delete: Remove the last \`k\` characters from the current text. - Print: Print the k-th character of the current text. - Undo: Undo the most recent command that modified the text (either Append or Delete). >>> editor = TextEditor() >>> commands = [ ... \\"append hello\\", ... \\"append world\\", ... \\"delete 5\\", ... \\"print 5\\", ... \\"undo\\", ... \\"print 10\\", ... \\"exit\\" ... ] >>> editor.process_commands(commands) o d def __init__(self): self.text = \\"\\" self.history = [] def append(self, s): Append string s to the current text. pass def delete(self, k): Remove the last k characters from the current text. pass def print_char(self, k): Print the k-th (1-indexed) character of the current text. pass def undo(self): Undo the most recent command that modified the text. pass def process_commands(self, commands): Process a list of commands in sequence. pass def test_text_editor_operations(): editor = TextEditor() commands = [ \\"append hello\\", \\"append world\\", \\"delete 5\\", \\"print 5\\", \\"undo\\", \\"print 10\\", \\"exit\\" ] expected_output = [\\"o\\", \\"d\\"] import sys from io import StringIO # Capturing the print outputs captured_output = StringIO() sys.stdout = captured_output # Process commands editor.process_commands(commands) # Restore stdout so further prints go to the console sys.stdout = sys.__stdout__ output = captured_output.getvalue().split() assert output == expected_output def test_append(): editor = TextEditor() editor.append(\\"abc\\") assert editor.text == \\"abc\\" editor.append(\\"def\\") assert editor.text == \\"abcdef\\" def test_delete(): editor = TextEditor() editor.append(\\"abcdef\\") editor.delete(2) assert editor.text == \\"abcd\\" editor.delete(4) assert editor.text == \\"\\" def test_print_char(): editor = TextEditor() editor.append(\\"abcdef\\") import sys from io import StringIO captured_output = StringIO() sys.stdout = captured_output editor.print_char(1) editor.print_char(6) sys.stdout = sys.__stdout__ output = captured_output.getvalue().split() assert output == [\\"a\\", \\"f\\"] def test_undo(): editor = TextEditor() editor.append(\\"abc\\") editor.append(\\"def\\") assert editor.text == \\"abcdef\\" editor.undo() assert editor.text == \\"abc\\" editor.undo() assert editor.text == \\"\\" # Undo more times than operations editor.undo() assert editor.text == \\"\\"","solution":"class TextEditor: def __init__(self): self.text = \\"\\" self.history = [] def append(self, s): self.history.append(self.text) # Save current state to history self.text += s def delete(self, k): self.history.append(self.text) # Save current state to history self.text = self.text[:-k] def print_char(self, k): print(self.text[k - 1]) def undo(self): if self.history: self.text = self.history.pop() def process_commands(self, commands): for command in commands: cmd = command.split() if cmd[0] == 'append': self.append(cmd[1]) elif cmd[0] == 'delete': self.delete(int(cmd[1])) elif cmd[0] == 'print': self.print_char(int(cmd[1])) elif cmd[0] == 'undo': self.undo() elif cmd[0] == 'exit': break"},{"question":"def count_alarm_minutes(hour: str) -> int: Counts how many minutes in the given hour the alarm will sound. The alarm sounds when the displayed minute contains exactly two consecutive digits that are the same. Args: hour (str): The hour in two-digit format (00 to 23). Returns: int: Number of minutes the alarm will sound in the given hour. >>> count_alarm_minutes('12') 14 >>> count_alarm_minutes('03') 11","solution":"def count_alarm_minutes(hour): Counts how many minutes in the given hour the alarm will sound. The alarm sounds when the displayed minute contains exactly two consecutive digits that are the same. Args: hour (str): The hour in two-digit format (00 to 23). Returns: int: Number of minutes the alarm will sound in the given hour. count = 0 for minute in range(60): minute_str = f\\"{minute:02}\\" if minute_str[0] == minute_str[1]: count += 1 return count"},{"question":"from typing import List def unique_rearrangements(s: str) -> int: Calculate the number of unique rearrangements of the string \`s\` that result in a different sequence of letters. Args: s (str): A string of lowercase English letters. Returns: int: The number of unique rearrangements. Example: >>> unique_rearrangements(\\"abc\\") 6 >>> unique_rearrangements(\\"aabb\\") 6 >>> unique_rearrangements(\\"apple\\") 60","solution":"from math import factorial from collections import Counter def unique_rearrangements(s): Returns the number of unique rearrangements of the string s. n = len(s) char_count = Counter(s) numerator = factorial(n) denominator = 1 for count in char_count.values(): denominator *= factorial(count) return numerator // denominator"},{"question":"def shift_characters(s: str) -> str: Returns a new string where each character in the original string is replaced by the character 2 positions ahead in the alphabet. Non-alphabetic characters remain unchanged. The operation is case-sensitive. >>> shift_characters(\\"abcXYZ\\") 'cdeZAB' >>> shift_characters(\\"helloWorld123\\") 'jgnnqYqtnf123' >>> shift_characters(\\"\\") '' >>> shift_characters(\\"wxyz\\") 'yzab' >>> shift_characters(\\"!@#123\\") '!@#123'","solution":"def shift_characters(s): Returns a new string where each character in the original string is replaced by the character 2 positions ahead in the alphabet. Non-alphabetic characters remain unchanged. The operation is case-sensitive. def shift_char(c): if 'a' <= c <= 'z': return chr(((ord(c) - ord('a') + 2) % 26) + ord('a')) elif 'A' <= c <= 'Z': return chr(((ord(c) - ord('A') + 2) % 26) + ord('A')) else: return c return ''.join(shift_char(c) for c in s)"},{"question":"def diagonal_sum(n: int, grid: List[List[int]]) -> int: Returns the sum of the elements in the main diagonal and the anti-diagonal of an n x n grid. If n is odd, the center element is counted only once. >>> diagonal_sum(3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 25 >>> diagonal_sum(4, [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]) 68 >>> diagonal_sum(1, [[5]]) 5 >>> diagonal_sum(2, [[1, 2], [3, 4]]) 10 >>> diagonal_sum(5, [[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25]]) 117","solution":"def diagonal_sum(n, grid): Returns the sum of the elements in the main diagonal and the anti-diagonal of an n x n grid. If n is odd, the center element is counted only once. diag_sum = 0 for i in range(n): diag_sum += grid[i][i] # main diagonal diag_sum += grid[i][n - 1 - i] # anti-diagonal # If n is odd, subtract the center element once as it was added twice if n % 2 == 1: center = n // 2 diag_sum -= grid[center][center] return diag_sum"},{"question":"def min_balance(n: int) -> int: Returns the minimum possible balance of a binary string of length n. The balance is defined as the absolute difference between the number of 0's and 1's. >>> min_balance(4) 0 >>> min_balance(5) 1","solution":"def min_balance(n): Returns the minimum possible balance of a binary string of length n. The balance is defined as the absolute difference between the number of 0's and 1's. # If n is even, we can have an equal number of 0's and 1's, hence balance is 0 # If n is odd, we will always have an imbalance of 1 if n % 2 == 0: return 0 else: return 1"},{"question":"def process_requests(requests): Processes multiple book requests and returns the order of issuing based on the book ID. >>> process_requests([13, 4, 26, 8, 19, 0]) == [4, 8, 13, 19, 26] >>> process_requests([13, 4, 26, 8, 19, 0, 0, 0]) == [4, 8, 13, 19, 26] >>> process_requests([0, 13, 4, 26, 8, 19]) == [4, 8, 13, 19, 26] >>> process_requests([5, 3, 1, 7, 9]) == [1, 3, 5, 7, 9] >>> process_requests([0]) == [] >>> process_requests([]) == [] >>> process_requests([15, 0]) == [15] >>> process_requests([15, 0, 8, 8, 15, 4, 4, 0]) == [4, 4, 8, 8, 15, 15]","solution":"def process_requests(requests): Returns the sorted book IDs from the requests list, excluding any 0s. # Filter out the termination signal (i.e., 0) from the list filtered_requests = [request for request in requests if request != 0] # Sort the remaining book IDs sorted_requests = sorted(filtered_requests) return sorted_requests"},{"question":"def max_robbery(n: int, houses: List[int]) -> int: Determine the maximum amount of money you can rob tonight without alerting the police. >>> max_robbery(6, [2, 7, 9, 3, 1, 4]) 15 >>> max_robbery(1, [5]) 5 >>> max_robbery(2, [1, 100]) 100 >>> max_robbery(4, [10, 10, 10, 10]) 20 >>> max_robbery(100, [i for i in range(1, 101)]) 2550 >>> max_robbery(5, [0, 0, 10, 0, 20]) 30 >>> max_robbery(5, [2, 1, 3, 1, 5]) 10","solution":"def max_robbery(n, houses): if n == 0: return 0 if n == 1: return houses[0] dp = [0] * n dp[0] = houses[0] dp[1] = max(houses[0], houses[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + houses[i]) return dp[n-1] # Demonstrating the function with an example n = 6 houses = [2, 7, 9, 3, 1, 4] print(max_robbery(n, houses)) # Output: 15"},{"question":"def decimal_to_binary(T, numbers): Converts each decimal number in the list \`numbers\` to its binary equivalent. Parameters: T (int): The number of test cases. numbers (list of int): List containing T decimal numbers. Returns: list of str: A list of binary strings representing each decimal number. >>> decimal_to_binary(1, [4]) ['100'] >>> decimal_to_binary(3, [4, 15, 7]) ['100', '1111', '111'] >>> decimal_to_binary(2, [0, 1000]) ['0', '1111101000'] >>> decimal_to_binary(1, [0]) ['0'] >>> decimal_to_binary(5, [1, 2, 3, 8, 31]) ['1', '10', '11', '1000', '11111']","solution":"def decimal_to_binary(T, numbers): Converts each decimal number in the list \`numbers\` to its binary equivalent. Parameters: T (int): The number of test cases. numbers (list of int): List containing T decimal numbers. Returns: list of str: A list of binary strings representing each decimal number. return [bin(n)[2:] for n in numbers]"},{"question":"def min_total_watering(n: int, water_requirements: List[int], capacities: List[int], pipes: List[Tuple[int, int]]) -> int: Determine the minimum total watering needed to ensure the plants' requirements are met. :param n: The number of plants. :param water_requirements: A list of integers representing the water requirement for each plant. :param capacities: A list of integers representing the water capacity for each plant. :param pipes: A list of tuples, each tuple is a pair of integers representing the pipe connections between plants. :return: An integer representing the minimum total watering needed. >>> min_total_watering(5, [10, 20, 30, 40, 50], [15, 25, 35, 45, 55], [(1, 2), (1, 3), (2, 4), (2, 5)]) 150 >>> min_total_watering(4, [5, 10, 15, 20], [10, 20, 30, 40], [(1, 2), (2, 3), (3, 4)]) 50 >>> min_total_watering(6, [5, 5, 5, 5, 5, 5], [5, 5, 5, 5, 5, 5], [(1, 2), (2, 3), (2, 4), (4, 5), (4, 6)]) 30","solution":"def min_total_watering(n, water_requirements, capacities, pipes): Function to determine the minimum total watering needed to ensure the plants' requirements are met. :param n: int, number of plants :param water_requirements: list, the water requirement for each plant :param capacities: list, the water capacity for each plant :param pipes: list of tuples, each tuple is a pair of integers representing the pipe connections between plants :return: int, the minimum total watering needed # Initialize the graph from the pipe connections from collections import defaultdict graph = defaultdict(list) for u, v in pipes: graph[u].append(v) graph[v].append(u) visited = [False] * (n + 1) min_total_watering_result = 0 def dfs(node): # Using DFS to explore the graph and gather water requirements and capacities stack = [node] group_water_requirements = 0 group_capacities = 0 while stack: current_node = stack.pop() if not visited[current_node]: visited[current_node] = True group_water_requirements += water_requirements[current_node - 1] group_capacities += capacities[current_node - 1] for adjacent in graph[current_node]: if not visited[adjacent]: stack.append(adjacent) return min(group_water_requirements, group_capacities) for node in range(1, n + 1): if not visited[node]: min_total_watering_result += dfs(node) return min_total_watering_result"},{"question":"def min_cliques(N, edges): Determine the minimum number of cliques required such that each game is in exactly one clique. Args: N (int): The number of games (nodes). edges (List[Tuple[int, int]]): The list of paths (edges) between the games. Returns: int: The minimum number of cliques needed. Examples: >>> min_cliques(4, [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]) 1 >>> min_cliques(5, [(1, 2), (2, 3), (3, 4), (4, 5)]) 3","solution":"def min_cliques(N, edges): from collections import defaultdict # Create adjacency list adj_list = defaultdict(set) for u, v in edges: adj_list[u].add(v) adj_list[v].add(u) cliques = [] unvisited = set(range(1, N + 1)) while unvisited: node = unvisited.pop() clique = {node} neighbors = adj_list[node].intersection(unvisited) for neighbor in neighbors: if all(neighbor in adj_list[other] for other in clique): clique.add(neighbor) cliques.append(clique) unvisited -= clique return len(cliques)"},{"question":"class Node: def __init__(self, value=0, left=None, middle=None, right=None): self.value = value self.left = left self.middle = middle self.right = right self.next = None self.prev = None def convertToCircularDLL(root): Convert a binary tree with at most three children nodes (left, middle, right) to a Circular Doubly Linked List (DLL) using level order traversal. Args: root (Node): Root of the binary tree Returns: Node: Head of the Circular Doubly Linked List Example: >>> tree = Node(1, Node(2), None, Node(3, Node(4))) >>> head = convertToCircularDLL(tree) >>> circular_dll_to_list(head) [1, 2, 3, 4] pass def circular_dll_to_list(head): if not head: return [] result = [] current = head while True: result.append(current.value) current = current.next if current == head: break return result def tree_from_level_order(values): if not values: return None from collections import deque root = Node(values[0]) queue = deque([root]) i = 1 while queue: current = queue.popleft() if i < len(values) and values[i] is not None: current.left = Node(values[i]) queue.append(current.left) i += 1 if i < len(values) and values[i] is not None: current.middle = Node(values[i]) queue.append(current.middle) i += 1 if i < len(values) and values[i] is not None: current.right = Node(values[i]) queue.append(current.right) i += 1 return root # Test cases def test_convert_example1(): values = [10, 12, 15, 20, 25, 30, 36, None, None, None, 40] tree = tree_from_level_order(values) head = convertToCircularDLL(tree) expected = [10, 12, 15, 20, 25, 30, 36, 40] result = circular_dll_to_list(head) assert result == expected def test_convert_example2(): values = [1, 2, 3, 4] tree = tree_from_level_order(values) head = convertToCircularDLL(tree) expected = [1, 2, 3, 4] result = circular_dll_to_list(head) assert result == expected def test_convert_empty_tree(): tree = None head = convertToCircularDLL(tree) assert head == None def test_convert_single_node(): values = [1] tree = tree_from_level_order(values) head = convertToCircularDLL(tree) expected = [1] result = circular_dll_to_list(head) assert result == expected def test_convert_large_tree(): values = list(range(1, 21)) # [1, 2, 3, ..., 20] tree = tree_from_level_order(values) head = convertToCircularDLL(tree) expected = list(range(1, 21)) result = circular_dll_to_list(head) assert result == expected","solution":"class Node: def __init__(self, value=0, left=None, middle=None, right=None): self.value = value self.left = left self.middle = middle self.right = right self.next = None self.prev = None def convertToCircularDLL(root): if not root: return None from collections import deque queue = deque([root]) head = None tail = None while queue: current = queue.popleft() dll_node = Node(current.value) if not head: head = dll_node tail = dll_node head.next = head head.prev = head else: tail.next = dll_node dll_node.prev = tail dll_node.next = head head.prev = dll_node tail = dll_node if current.left: queue.append(current.left) if current.middle: queue.append(current.middle) if current.right: queue.append(current.right) return head"},{"question":"def lis(lst): Finds the longest increasing subsequence (LIS) in a given list of integers. An increasing subsequence is a sequence derived from another sequence by deleting some or no elements without changing the order of the remaining elements. The longest increasing subsequence is the subsequence of maximum length. Input range: 500 tests 1 <= len(lst) <= 10,000 -100,000 <= lst[i] <= 100,000 Example: >>> lis([10, 22, 9, 33, 21, 50, 41, 60, 80]) # Output should be [10, 22, 33, 50, 60, 80] or equivalent >>> lis([3, 4, -1, 0, 6, 2, 3]) # Output should be [-1, 0, 2, 3] pass def test_lis_example1(): result = lis([10, 22, 9, 33, 21, 50, 41, 60, 80]) assert result == [10, 22, 33, 50, 60, 80] or result == [10, 22, 33, 41, 60, 80] def test_lis_example2(): result = lis([3, 4, -1, 0, 6, 2, 3]) assert result == [-1, 0, 2, 3] def test_lis_single_element(): result = lis([10]) assert result == [10] def test_lis_increasing_order(): result = lis([1, 2, 3, 4, 5]) assert result == [1, 2, 3, 4, 5] def test_lis_decreasing_order(): result = lis([5, 4, 3, 2, 1]) assert result == [5] or result == [4] or result == [3] or result == [2] or result == [1] def test_lis_all_same_elements(): result = lis([2, 2, 2, 2, 2]) assert result == [2] def test_lis_empty_list(): result = lis([]) assert result == [] def test_lis_large_input(): lst = list(range(10000)) result = lis(lst) assert result == lst","solution":"def lis(lst): Finds the longest increasing subsequence in a given list of integers. if not lst: return [] # Array to store our subsequence lis = [lst[0]] # Dictionary to track the actual sequences sequences = {lst[0]: [lst[0]]} for num in lst[1:]: if num > lis[-1]: lis.append(num) sequences[num] = sequences[lis[-2]] + [num] else: for i in range(len(lis)): if num <= lis[i]: lis[i] = num sequences[num] = sequences[lis[i-1]] + [num] if i > 0 else [num] break # Returning the longest increasing subsequence based on tracked sequences return sequences[lis[-1]]"},{"question":"def is_valid_parentheses(s: str) -> bool: Given a string of parentheses, determine if the order of the parentheses is valid. A string of parentheses is valid if all opening parentheses have a corresponding closing parenthesis, and the pairs of parentheses are properly nested. Args: s (str): The input string containing parentheses Returns: bool: True if the string contains valid parentheses, False otherwise. >>> is_valid_parentheses(\\"()\\") True >>> is_valid_parentheses(\\"()[]{}\\") True >>> is_valid_parentheses(\\"{[]}\\") True >>> is_valid_parentheses(\\"(]\\") False >>> is_valid_parentheses(\\"([)]\\") False","solution":"def is_valid_parentheses(s): Returns True if the string of parentheses is valid, otherwise returns False. stack = [] mapping = {')': '(', '}': '{', ']': '['} for char in s: if char in mapping: top_element = stack.pop() if stack else '#' if mapping[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"def max_path_sum(n, m, grid): Returns the maximum path sum from any cell in the first row to any cell in the last row. pass def solve_max_path_sum(T, test_cases): Solves multiple test cases for the max path sum problem. pass # Unit tests import pytest def test_sample_input_1(): T = 1 test_cases = [ (3, 3, [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) ] expected = [18] assert solve_max_path_sum(T, test_cases) == expected def test_single_cell(): T = 1 test_cases = [ (1, 1, [ [5] ]) ] expected = [5] assert solve_max_path_sum(T, test_cases) == expected def test_long_path(): T = 1 test_cases = [ (4, 2, [ [1, 2], [3, 4], [5, 6], [7, 8] ]) ] expected = [20] assert solve_max_path_sum(T, test_cases) == expected def test_multiple_paths_with_same_sum(): T = 1 test_cases = [ (3, 3, [ [2, 2, 2], [2, 2, 2], [2, 2, 2] ]) ] expected = [6] assert solve_max_path_sum(T, test_cases) == expected def test_max_in_corner_case(): T = 1 test_cases = [ (3, 3, [ [2, 2, 1000], [2, 2, 2], [2, 2, 2] ]) ] expected = [1004] assert solve_max_path_sum(T, test_cases) == expected pytest.main()","solution":"def max_path_sum(n, m, grid): Returns the maximum path sum from any cell in the first row to any cell in the last row. # Create a dp table initialized with the values of the grid dp = [[0] * m for _ in range(n)] # Initialize the first row of dp table for j in range(m): dp[0][j] = grid[0][j] # Build the dp table for i in range(1, n): for j in range(m): max_val = dp[i-1][j] # Coming straight from above if j > 0: max_val = max(max_val, dp[i-1][j-1]) # Coming from the top-left if j < m-1: max_val = max(max_val, dp[i-1][j+1]) # Coming from the top-right dp[i][j] = grid[i][j] + max_val # The result will be the maximum value in the last row return max(dp[n-1]) def solve_max_path_sum(T, test_cases): Solves multiple test cases for the max path sum problem. results = [] for n, m, grid in test_cases: results.append(max_path_sum(n, m, grid)) return results"},{"question":"def romanToInt(s: str) -> int: Convert a Roman numeral to an integer. :param s: str : Roman numeral string :return: int : Equivalent integer value Examples: >>> romanToInt(\\"III\\") 3 >>> romanToInt(\\"IX\\") 9 >>> romanToInt(\\"MCMXCIV\\") 1994","solution":"def romanToInt(s): Convert Roman numeral to integer. :param s: str : Roman numeral string :return: int : Equivalent integer value roman_to_int = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 } total = 0 prev_value = 0 for char in s[::-1]: current_value = roman_to_int[char] if current_value >= prev_value: total += current_value else: total -= current_value prev_value = current_value return total"},{"question":"def max_tasks(tasks, k): Returns the maximum number of tasks that can be completed in k consecutive days. tasks: List[int] - list of integers representing tasks to be finished on specific days k: int - number of consecutive days available to finish tasks return: int - maximum number of tasks that can be completed in k days Example: >>> max_tasks([1, 2, 3, 4, 5], 3) 3 >>> max_tasks([1, 2, 2, 3, 4, 5], 5) 5 >>> max_tasks([1, 2, 2, 3, 4, 5], 6) 6 Note: The function should handle edge cases such as an empty list or tasks with all the same day values. def test_max_tasks(): assert max_tasks([1, 2, 3, 4, 5], 3) == 3 assert max_tasks([1, 2, 2, 3, 4, 5], 5) == 5 assert max_tasks([1, 2, 2, 3, 4, 5], 6) == 6 assert max_tasks([1, 2], 1) == 1 assert max_tasks([1], 1) == 1 assert max_tasks([], 3) == 0 assert max_tasks([2, 2, 2, 2, 2], 3) == 3 assert max_tasks([5, 4, 3, 2, 1], 3) == 3 test_max_tasks()","solution":"def max_tasks(tasks, k): Returns the maximum number of tasks that can be completed in k consecutive days. tasks: List[int] - list of integers representing tasks to be finished on specific days k: int - number of consecutive days available to finish tasks return: int - maximum number of tasks that can be completed in k days n = len(tasks) max_tasks = 0 # Sort tasks to prioritize earlier days tasks.sort() # Use sliding window of size k to find the maximum number of tasks that can be done in k days for i in range(n): completed = 0 for j in range(i, min(n, i + k)): completed += 1 max_tasks = max(max_tasks, completed) return max_tasks"},{"question":"def evaluate_expression(expression: str) -> int: Evaluate a mathematical expression containing integers and operators (+, -, *, /) and return the result as an integer. >>> evaluate_expression(\\"3+2*2\\") 7 >>> evaluate_expression(\\"10-3*4+2\\") 0 >>> evaluate_expression(\\"0*5+2\\") 2 >>> evaluate_expression(\\"6/3+2*2\\") 6 >>> evaluate_expression(\\"2-4*2\\") -6 >>> evaluate_expression(\\"1000*1000+500-999999\\") 501 >>> evaluate_expression(\\"14+2*3-6/2\\") 17 def test_evaluate_expression_basic(): assert evaluate_expression(\\"3+2*2\\") == 7 def test_evaluate_expression_with_subtraction(): assert evaluate_expression(\\"10-3*4+2\\") == 0 def test_evaluate_expression_with_zero(): assert evaluate_expression(\\"0*5+2\\") == 2 def test_evaluate_expression_with_division(): assert evaluate_expression(\\"6/3+2*2\\") == 6 def test_evaluate_expression_negative_result(): assert evaluate_expression(\\"2-4*2\\") == -6 def test_evaluate_expression_large_numbers(): assert evaluate_expression(\\"1000*1000+500-999999\\") == 501 def test_evaluate_expression_complex(): assert evaluate_expression(\\"14+2*3-6/2\\") == 17 def test_evaluate_expression_long(): assert evaluate_expression(\\"1*1*1*1*1*1*1*1*1+2\\") == 3 def test_evaluate_expression_large_expr(): assert evaluate_expression(\\"1*1*1*1*1*1*1*1*1+2\\") == 3","solution":"def evaluate_expression(expression): Evaluate a mathematical expression containing integers and operators (+, -, *, /). Args: expression (str): The mathematical expression to evaluate. Returns: int: The result of the evaluation. stack = [] num = 0 sign = \\"+\\" expression += \\"+\\" # To force the last number to be processed for char in expression: if char.isdigit(): num = num * 10 + int(char) elif char in \\"+-*/\\": if sign == \\"+\\": stack.append(num) elif sign == \\"-\\": stack.append(-num) elif sign == \\"*\\": stack[-1] *= num elif sign == \\"/\\": # Integer division truncates toward zero if stack[-1] < 0: stack[-1] = -(-stack[-1] // num) else: stack[-1] //= num sign = char num = 0 return sum(stack)"},{"question":"import os import joblib def train_model(training_path: str): Train sentiment analysis model using data at the specified training path. Args: training_path (str): The path containing training directories ('positive', 'negative', 'neutral') Returns: None Notes: Saves the trained model as 'sentiment_model.pkl' # Load training data from specified path texts, labels = [], [] for sentiment in ['positive', 'negative', 'neutral']: dir_path = os.path.join(training_path, sentiment) for filename in os.listdir(dir_path): file_path = os.path.join(dir_path, filename) with open(file_path, 'r', encoding='utf-8') as file: texts.append(file.read()) labels.append(sentiment) # Train the model from sklearn.feature_extraction.text import TfidfVectorizer from sklearn.naive_bayes import MultinomialNB from sklearn.pipeline import make_pipeline model = make_pipeline(TfidfVectorizer(), MultinomialNB()) model.fit(texts, labels) # Save the model joblib.dump(model, 'sentiment_model.pkl') def load_model(): Load the previously trained sentiment analysis model. Returns: model: The loaded sentiment analysis model. return joblib.load('sentiment_model.pkl') def predict_sentiment(review_text: str, model) -> str: Predict the sentiment of a given review. Args: review_text (str): The text of the review. model: The trained sentiment analysis model. Returns: str: The predicted sentiment ('positive', 'negative', or 'neutral') of the review. Examples: >>> model = load_model() >>> predict_sentiment(\\"I love the new features of this product, amazing experience!\\", model) 'positive' >>> predict_sentiment(\\"This product broke down after a week of use, very disappointing.\\", model) 'negative' >>> predict_sentiment(\\"The product is fine but nothing spectacular.\\", model) 'neutral' return model.predict([review_text])[0] if __name__ == \\"__main__\\": training_path = 'train_sent' # The path of the training dataset # Uncomment the following line to train the model. # train_model(training_path) # Load the previously trained model model = load_model() import sys input = sys.stdin.read data = input().strip().split('n') # Get the review text from the input review_text = \\" \\".join(data[2:]) # Predict the sentiment of the review sentiment = predict_sentiment(review_text, model) print(sentiment)","solution":"import os import string from sklearn.feature_extraction.text import TfidfVectorizer from sklearn.naive_bayes import MultinomialNB from sklearn.pipeline import make_pipeline import joblib def load_training_data(training_path): texts, labels = [], [] for sentiment in ['positive', 'negative', 'neutral']: dir_path = os.path.join(training_path, sentiment) for filename in os.listdir(dir_path): file_path = os.path.join(dir_path, filename) with open(file_path, 'r', encoding='utf-8') as file: texts.append(file.read()) labels.append(sentiment) return texts, labels def train_model(training_path): texts, labels = load_training_data(training_path) model = make_pipeline(TfidfVectorizer(), MultinomialNB()) model.fit(texts, labels) joblib.dump(model, 'sentiment_model.pkl') return model def load_model(): return joblib.load('sentiment_model.pkl') def predict_sentiment(review_text, model): return model.predict([review_text])[0] def main(): training_path = 'train_sent' # The path of the training dataset # Uncomment the following line to train the model. # train_model(training_path) # Load the previously trained model model = load_model() import sys input = sys.stdin.read data = input().strip().split('n') # Get the review text from the input review_text = \\" \\".join(data[2:]) # Predict the sentiment of the review sentiment = predict_sentiment(review_text, model) print(sentiment) if __name__ == \\"__main__\\": main()"},{"question":"def max_apples(n, m, grid): Determine the maximum number of apples Alice can collect from the start to the end of her journey in an n x m orchard grid. Args: n: int - number of rows in the orchard grid. m: int - number of columns in the orchard grid. grid: List[List[int]] - a list of lists containing the number of apples in each cell. Returns: int - the maximum number of apples Alice can collect. >>> max_apples(3, 3, [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 29 >>> max_apples(2, 2, [ ... [1, 0], ... [0, 1] ... ]) 2 >>> max_apples(1, 5, [ ... [1, 1, 1, 1, 1] ... ]) 5","solution":"def max_apples(n, m, grid): dp = [[0] * m for _ in range(n)] dp[0][0] = grid[0][0] for i in range(n): for j in range(m): if i > 0: dp[i][j] = max(dp[i][j], dp[i - 1][j] + grid[i][j]) if j > 0: dp[i][j] = max(dp[i][j], dp[i][j - 1] + grid[i][j]) return dp[n - 1][m - 1]"},{"question":"from typing import List def is_unique(grid: List[List[int]], top: int, left: int, size: int) -> bool: Check if sub-square of given size starting at (top, left) is unique pass def largest_unique_subsquare(grid: List[List[int]], n: int) -> int: Return the size of the largest unique sub-square. pass def test_is_unique(): grid = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] assert is_unique(grid, 0, 0, 4) == True assert is_unique(grid, 0, 0, 2) == True assert is_unique(grid, 1, 1, 2) == True grid_with_duplicates = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 12] ] assert is_unique(grid_with_duplicates, 0, 0, 4) == False assert is_unique(grid_with_duplicates, 2, 2, 2) == False def test_largest_unique_subsquare(): grid1 = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] assert largest_unique_subsquare(grid1, 4) == 4 grid2 = [ [1, 2, 3], [1, 2, 3], [1, 2, 3] ] assert largest_unique_subsquare(grid2, 3) == 1 grid3 = [ [7, 8, 9], [12, 8, 9], [15, 16, 14] ] assert largest_unique_subsquare(grid3, 3) == 2 grid4 = [ [1] ] assert largest_unique_subsquare(grid4, 1) == 1","solution":"def is_unique(grid, top, left, size): Check if sub-square starting at (top, left) of given size is unique seen = set() for i in range(top, top + size): for j in range(left, left + size): if grid[i][j] in seen: return False seen.add(grid[i][j]) return True def largest_unique_subsquare(grid, n): Return the size of the largest unique sub-square for size in range(n, 0, -1): for top in range(n - size + 1): for left in range(n - size + 1): if is_unique(grid, top, left, size): return size return 0 # Example usage: if __name__ == \\"__main__\\": n = int(input()) grid = [list(map(int, input().split())) for _ in range(n)] print(largest_unique_subsquare(grid, n))"},{"question":"def sum_of_unique_elements(lst: List[int]) -> int: Given a list of integers, return the sum of all unique elements in the list. >>> sum_of_unique_elements([1, 2, 2, 3, 4, 5, 5]) 8 >>> sum_of_unique_elements([1, 2, 3, 4, 5]) 15 >>> sum_of_unique_elements([1, 1, 1, 1]) 0 >>> sum_of_unique_elements([1, 1, 2, 3, 3, 4]) 6 >>> sum_of_unique_elements([]) 0 >>> sum_of_unique_elements([-1, -2, -2, -3, -3, -4]) -5 >>> sum_of_unique_elements(list(range(-1000, 1001))) 0 >>> sum_of_unique_elements([10, 20, 30, 10, 30, 40]) 60","solution":"def sum_of_unique_elements(lst): Returns the sum of all unique elements in the list. from collections import Counter # Count frequencies of each element in the list element_counts = Counter(lst) # Sum up elements that appear exactly once in the list unique_sum = sum(element for element, count in element_counts.items() if count == 1) return unique_sum"},{"question":"def min_serving_cost(n, servings, m, dishes): Determine the minimum cost required to serve guests for all dinners. Parameters: n (int): The number of dinners Boris has to host. servings (List[int]): A list of servings required for each dinner. m (int): The number of different types of serving dishes available. dishes (List[Tuple[int, int]]): A list of tuples where the first element is the capacity (number of servings it can hold) and the second element is the cost of the serving dish. Returns: int: The minimum total cost to serve the guests for all dinners. Examples: >>> min_serving_cost(2, [10, 20], 3, [(5, 50), (10, 80), (20, 150)]) 230 >>> min_serving_cost(1, [15], 3, [(5, 50), (10, 80), (20, 150)]) 150 pass from typing import List, Tuple def test_min_serving_cost_example_1(): assert min_serving_cost(2, [10, 20], 3, [(5, 50), (10, 80), (20, 150)]) == 230 def test_min_serving_cost_single_dinner(): assert min_serving_cost(1, [15], 3, [(5, 50), (10, 80), (20, 150)]) == 150 def test_min_serving_cost_multiple_dishes_for_single_dinner(): assert min_serving_cost(1, [25], 3, [(10, 80), (15, 100), (30, 200)]) == 200 def test_min_serving_cost_multiple_dinners(): assert min_serving_cost(3, [10, 15, 30], 3, [(10, 50), (20, 100), (30, 200)]) == 350 def test_min_serving_cost_cheaper_dishes_are_sufficient(): assert min_serving_cost(2, [10, 20], 2, [(10, 50), (20, 90)]) == 140","solution":"def min_serving_cost(n, servings, m, dishes): # Sort the dishes by capacity first, then by cost dishes.sort(key=lambda x: (x[0], x[1])) # Initialize the total cost total_cost = 0 # Iterate through each dinner's servings requirement for required_servings in servings: # Find the minimum cost dish that can satisfy the required servings for capacity, cost in dishes: if capacity >= required_servings: total_cost += cost break return total_cost"},{"question":"from typing import Tuple def find_longest_unique_substring(s: str) -> Tuple[int, str]: Find the longest substring that consists of only distinct characters. >>> find_longest_unique_substring(\\"abcabcbb\\") (3, 'abc') >>> find_longest_unique_substring(\\"bbbbb\\") (1, 'b') >>> find_longest_unique_substring(\\"pwwkew\\") (3, 'wke')","solution":"from typing import Tuple def find_longest_unique_substring(s: str) -> Tuple[int, str]: if not s: return 0, '' n = len(s) start, max_len, max_substr = 0, 0, \\"\\" char_index_map = {} for end in range(n): if s[end] in char_index_map: start = max(start, char_index_map[s[end]] + 1) char_index_map[s[end]] = end current_len = end - start + 1 if current_len > max_len: max_len = current_len max_substr = s[start:end+1] return max_len, max_substr"},{"question":"def has_pair_with_sum(arr: List[int], target: int) -> str: Determines if there are two distinct integers in the array whose sum is exactly equal to the target sum. >>> has_pair_with_sum([1, 2, 3, 4, 5], 9) \\"YES\\" >>> has_pair_with_sum([1, 2, 3, 4], 8) \\"NO\\" >>> has_pair_with_sum([1], 2) \\"NO\\" >>> has_pair_with_sum([-1000000000, 2000000000, 0, 1000000000], 1000000000) \\"YES\\" >>> has_pair_with_sum([-1, -2, -3, -4, -5], -8) \\"YES\\" >>> has_pair_with_sum([1, 1, 1, 1], 2) \\"YES\\" >>> has_pair_with_sum([1, 1, 1, 1], 3) \\"NO\\" >>> has_pair_with_sum([], 1) \\"NO\\"","solution":"def has_pair_with_sum(arr, target): Determines if there are two distinct integers in the array whose sum is exactly equal to the target sum. seen = set() for number in arr: if target - number in seen: return \\"YES\\" seen.add(number) return \\"NO\\""},{"question":"def findLongestSubarray(arr: List[int]) -> int: Determine the length of the longest subarray with continuous elements. Args: arr (List[int]): The array of integers. Returns: int: The length of the longest subarray with continuous elements. Examples: >>> findLongestSubarray([10, 12, 11]) 3 >>> findLongestSubarray([14, 12, 11, 20]) 2","solution":"def findLongestSubarray(arr): n = len(arr) if n == 0: return 0 longest = 1 for i in range(n - 1): min_val = max_val = arr[i] for j in range(i + 1, n): min_val = min(min_val, arr[j]) max_val = max(max_val, arr[j]) if (max_val - min_val) == (j - i): longest = max(longest, j - i + 1) return longest"},{"question":"from typing import List, Tuple def find_submatrix(M: List[List[int]], P: List[List[int]]) -> Tuple[int, int]: Determine if a given matrix \`P\` is a submatrix of \`M\`. Returns the top-left coordinate of the submatrix if found, otherwise (-1, -1). >>> find_submatrix( ... [ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16] ... ], ... [ ... [6, 7], ... [10, 11] ... ] ... ) (1, 1) >>> find_submatrix( ... [ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12] ... ], ... [ ... [6, 7, 8], ... [10, 11, 12] ... ] ... ) (1, 1) >>> find_submatrix( ... [ ... [1, 2], ... [3, 4] ... ], ... [ ... [5] ... ] ... ) (-1, -1) pass","solution":"from typing import List, Tuple def find_submatrix(M: List[List[int]], P: List[List[int]]) -> Tuple[int, int]: n, m = len(M), len(M[0]) k, l = len(P), len(P[0]) for i in range(n - k + 1): for j in range(m - l + 1): match = True for x in range(k): for y in range(l): if M[i + x][j + y] != P[x][y]: match = False break if not match: break if match: return (i, j) return (-1, -1)"},{"question":"def max_efficiency_points(m, t, efficiency_points): Returns the maximum efficiency points Sophia can achieve by attending up to t sessions. :param m: Number of study sessions (int) :param t: Maximum sessions Sophia can attend in a day (int) :param efficiency_points: List of efficiency points for each session (list of ints) :return: Maximum efficiency points (int) pass # Unit Tests def test_max_efficiency_points_example_1(): assert max_efficiency_points(5, 3, [1, 2, 3, 4, 5]) == 12 def test_max_efficiency_points_example_2(): assert max_efficiency_points(6, 2, [7, 1, 5, 3, 9, 2]) == 16 def test_max_efficiency_points_example_3(): assert max_efficiency_points(4, 4, [10, 20, 30, 40]) == 100 def test_max_efficiency_points_max_sessions(): assert max_efficiency_points(3, 3, [1, 1, 1]) == 3 def test_max_efficiency_points_single_session(): assert max_efficiency_points(5, 1, [20, 3, 15, 8, 7]) == 20 def test_max_efficiency_points_all_same_points(): assert max_efficiency_points(5, 3, [5, 5, 5, 5, 5]) == 15 def test_max_efficiency_points_even_sessions(): assert max_efficiency_points(6, 3, [4, 6, 8, 2, 9, 1]) == 23","solution":"def max_efficiency_points(m, t, efficiency_points): Returns the maximum efficiency points Sophia can achieve by attending up to t sessions. :param m: Number of study sessions (int) :param t: Maximum sessions Sophia can attend in a day (int) :param efficiency_points: List of efficiency points for each session (list of ints) :return: Maximum efficiency points (int) sorted_points = sorted(efficiency_points, reverse=True) return sum(sorted_points[:t])"},{"question":"from typing import List, Tuple def optimize_route(points: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Returns the optimal path for visiting all points exactly once and returning to the starting point, employing a naive approach algorithm. >>> optimize_route([(0, 0), (1, 1), (1, 0), (0, 1)]) == [(0, 0), (1, 0), (1, 1), (0, 1), (0, 0)] >>> optimize_route([(0, 0), (1, 1)]) == [(0, 0), (1, 1), (0, 0)] >>> optimize_route([(0, 0), (2, 0), (1, 1)]) == [(0, 0), (2, 0), (1, 1), (0, 0)]","solution":"from typing import List, Tuple from itertools import permutations def euclidean_distance(point1: Tuple[int, int], point2: Tuple[int, int]) -> float: Returns the Euclidean distance between two points in 2D plane. return ((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2) ** 0.5 def total_route_distance(route: List[Tuple[int, int]]) -> float: Returns the total distance of the given route, including returning to the start point. distance = 0.0 for i in range(len(route) - 1): distance += euclidean_distance(route[i], route[i + 1]) distance += euclidean_distance(route[-1], route[0]) # Returning to start point return distance def optimize_route(points: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Returns the optimal path for visiting all points exactly once and returning to the starting point. best_route = None min_distance = float('inf') # Generate all possible permutations of points (excluding the first point as start) start_point = points[0] remaining_points = points[1:] for perm in permutations(remaining_points): current_route = [start_point] + list(perm) current_distance = total_route_distance(current_route) if current_distance < min_distance: min_distance = current_distance best_route = current_route # Add the starting point at the end to complete the loop best_route.append(start_point) return best_route"},{"question":"def magic_sequence(n: int) -> list: Generates the magic sequence for a given number n. >>> magic_sequence(5) [5] >>> magic_sequence(29) [29, 11, 2] >>> magic_sequence(9875) [9875, 29, 11, 2] >>> magic_sequence(10**18) [10**18, 1] >>> magic_sequence(10) [10, 1]","solution":"def magic_sequence(n): Generates the magic sequence for a given number n. sequence = [n] while n >= 10: n = sum(int(digit) for digit in str(n)) sequence.append(n) return sequence"},{"question":"def count_unfavorable_pairs(n: int, permutation: List[int]) -> int: Count the number of unfavorable pairs in a permutation of the first n positive integers. >>> count_unfavorable_pairs(5, [2, 3, 1, 5, 4]) 3 >>> count_unfavorable_pairs(4, [4, 3, 2, 1]) 6","solution":"def count_unfavorable_pairs(n, permutation): unfavorable_pairs = 0 # Iterate through each element in the permutation for i in range(n): # Check pairs with elements before the current element for j in range(i): if permutation[j] > permutation[i]: unfavorable_pairs += 1 return unfavorable_pairs"},{"question":"def max_groups(n: int, k: int, d: int, skill_levels: List[int]) -> int: Finds the maximum number of groups that can be formed such that each group has exactly k players and the difference in skill levels between the highest and lowest player in a group does not exceed d. Parameters: n (int): number of players k (int): number of players in each group d (int): maximum allowed difference in skill levels within a group skill_levels (list[int]): list of skill levels of the players Returns: int: the maximum number of valid groups that can be formed >>> max_groups(8, 3, 2, [4, 8, 5, 6, 7, 9, 5, 3]) 2 >>> max_groups(5, 3, 1, [10, 20, 30, 40, 50]) 0 from solution import max_groups def test_example(): assert max_groups(8, 3, 2, [4, 8, 5, 6, 7, 9, 5, 3]) == 2 def test_no_groups_possible(): assert max_groups(5, 3, 1, [10, 20, 30, 40, 50]) == 0 def test_exactly_one_group_possible(): assert max_groups(3, 3, 5, [1, 3, 5]) == 1 def test_multiple_groups_possible(): assert max_groups(6, 2, 2, [1, 2, 3, 4, 5, 6]) == 3 def test_large_difference(): assert max_groups(6, 3, 100, [1, 50, 100, 150, 200, 250]) == 2 def test_minimum_possible_values(): assert max_groups(1, 1, 0, [1]) == 1 def test_skills_within_tolerance(): assert max_groups(10, 2, 2, [1, 2, 2, 3, 3, 4, 4, 5, 5, 6]) == 5","solution":"def max_groups(n, k, d, skill_levels): Finds the maximum number of groups that can be formed such that each group has exactly k players and the difference in skill levels between the highest and lowest player in a group does not exceed d. Parameters: n (int): number of players k (int): number of players in each group d (int): maximum allowed difference in skill levels within a group skill_levels (list[int]): list of skill levels of the players Returns: int: the maximum number of valid groups that can be formed skill_levels.sort() count = 0 i = 0 while i <= n - k: if skill_levels[i + k - 1] - skill_levels[i] <= d: count += 1 i += k else: i += 1 return count"},{"question":"from typing import List def is_path_exists(n: int, grid: List[str], start_x: int, start_y: int, end_x: int, end_y: int) -> str: Determine if there exists a path from the starting point to the endpoint without passing through any obstacles, using only horizontal and vertical movements. Args: n (int): The size of the grid. grid (List[str]): The grid containing '.' and '#'. start_x (int): The x-coordinate of the starting point. start_y (int): The y-coordinate of the starting point. end_x (int): The x-coordinate of the endpoint. end_y (int): The y-coordinate of the endpoint. Returns: str: \\"YES\\" if there is a path, \\"NO\\" otherwise. Examples: >>> is_path_exists(5, [\\".....\\", \\"..#..\\", \\".....\\", \\"..#..\\", \\".....\\"], 0, 0, 4, 4) 'YES' >>> is_path_exists(5, [\\"#\\", \\"#\\", \\"#\\", \\"#\\", \\"#\\"], 0, 0, 4, 4) 'NO'","solution":"from collections import deque def is_path_exists(n, grid, start_x, start_y, end_x, end_y): def is_valid(x, y): return 0 <= x < n and 0 <= y < n and grid[x][y] == '.' directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] visited = [[False]*n for _ in range(n)] queue = deque([(start_x, start_y)]) visited[start_x][start_y] = True while queue: x, y = queue.popleft() if (x, y) == (end_x, end_y): return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and not visited[nx][ny]: visited[nx][ny] = True queue.append((nx, ny)) return \\"NO\\""},{"question":"def min_moves_to_reach_destination(n: int, s_x: int, s_y: int, e_x: int, e_y: int, intersections: List[Tuple[int, int]]) -> int: Calculate the minimum number of moves required to reach the destination. Args: n: The number of intersections in the grid. s_x: The x-coordinate of the starting point. s_y: The y-coordinate of the starting point. e_x: The x-coordinate of the ending point. e_y: The y-coordinate of the ending point. intersections: A list of tuples representing the coordinates of the intersections. Returns: The minimum number of moves required to reach the destination, or -1 if there is no possible path. Examples: >>> min_moves_to_reach_destination(5, 0, 0, 2, 2, [(0, 1), (1, 1), (1, 2), (2, 1), (2, 2)]) 3 >>> min_moves_to_reach_destination(3, 0, 0, 1, 1, [(0, 1), (1, 0), (1, 1)]) 2 >>> min_moves_to_reach_destination(4, 0, 0, 3, 3, [(0, 1), (1, 0), (1, 1), (2, 2)]) -1","solution":"from collections import deque def min_moves_to_reach_destination(n, s_x, s_y, e_x, e_y, intersections): if (s_x, s_y) == (e_x, e_y): return 0 queue = deque([(s_x, s_y, 0)]) # (x, y, distance) visited = set() visited.add((s_x, s_y)) while queue: x, y, dist = queue.popleft() for i in range(n): i_x, i_y = intersections[i] if ((x == i_x and y != i_y) or (y == i_y and x != i_x)): if (i_x, i_y) == (e_x, e_y): return dist + 1 if (i_x, i_y) not in visited: visited.add((i_x, i_y)) queue.append((i_x, i_y, dist + 1)) return -1"},{"question":"def most_frequent_char(s): Write a function that takes a string as input and returns the most frequently occurring character. If there are multiple characters with the same highest frequency, return the alphabetically smallest character. The function should also handle cases where the input is not a string or is an empty string. >>> most_frequent_char('test') == 't' >>> most_frequent_char('aabbcc') == 'a' >>> most_frequent_char('abca') == 'a' >>> most_frequent_char([1, 2, 3]) == '' >>> most_frequent_char('') == ''","solution":"def most_frequent_char(s): Returns the most frequently occurring character in the string. If there are multiple characters with the same highest frequency, returns the alphabetically smallest character. Returns an empty string if the input is not a string or is an empty string. if not isinstance(s, str) or not s: return \\"\\" char_count = {} for char in s: char_count[char] = char_count.get(char, 0) + 1 # Find the character with the highest frequency and smallest alphabetically in case of a tie max_char = '' max_count = 0 for char, count in char_count.items(): if count > max_count or (count == max_count and char < max_char): max_char = char max_count = count return max_char"},{"question":"def has_pair_with_sum(arr: List[int], target_sum: int) -> bool: Determines if any two numbers within the array sum up to the target sum. Args: arr: List of integers. target_sum: Integer representing the target sum value. Returns: True if two such numbers exist, False otherwise. >>> has_pair_with_sum([10, 15, 3, 7], 17) True >>> has_pair_with_sum([1, 2, 3, 9], 8) False >>> has_pair_with_sum([-1, 11, 5, -6], 4) True >>> has_pair_with_sum([3, 4, 5, 3], 6) True","solution":"def has_pair_with_sum(arr, target_sum): Determines if any two numbers within the array sum up to the target sum. Args: arr: List of integers. target_sum: Integer representing the target sum value. Returns: True if two such numbers exist, False otherwise. seen = set() for number in arr: if target_sum - number in seen: return True seen.add(number) return False"},{"question":"def min_subrectangle_sum(grid: List[List[int]]) -> int: Given a grid of non-negative integers, returns the smallest sum of any subrectangle within the grid. >>> min_subrectangle_sum([[1, 2, 3], [4, -5, 6], [7, 8, 9]]) -5 >>> min_subrectangle_sum([[10, 20, 30], [40, 50, -1000], [60, 70, 80]]) -1000","solution":"def min_subrectangle_sum(grid): Given a grid of non-negative integers, returns the smallest sum of any subrectangle within the grid. if not grid or not grid[0]: return 0 n = len(grid) m = len(grid[0]) min_sum = float('inf') for left in range(m): temp = [0] * n for right in range(left, m): # Sum up columns for all rows between \`left\` and \`right\` for i in range(n): temp[i] += grid[i][right] # Use Kadane's algorithm to find the smallest sum subarray in temp current_min = float('inf') current_sum = 0 for sum_val in temp: current_sum += sum_val current_min = min(current_min, current_sum) if current_sum > 0: current_sum = 0 min_sum = min(min_sum, current_min) return min_sum"},{"question":"def sum_of_prime_divisors(seq): Create a new sequence where each element is the sum of all distinct prime numbers that divide the corresponding element in the input sequence. >>> sum_of_prime_divisors([10, 12, 15, 17, 18]) == [7, 5, 8, 17, 5] >>> sum_of_prime_divisors([1, 2, 3, 4, 5]) == [0, 2, 3, 2, 5] >>> sum_of_prime_divisors([100000]) == [7] >>> sum_of_prime_divisors([99991]) == [99991] >>> sum_of_prime_divisors([100000, 99991, 99989]) == [7, 99991, 99989] >>> sum_of_prime_divisors([4, 8, 9, 12, 25]) == [2, 2, 3, 5, 5] >>> sum_of_prime_divisors([30, 70, 77, 49, 91]) == [10, 14, 18, 7, 20]","solution":"def sum_of_prime_divisors(seq): def is_prime(num): if num <= 1: return False if num == 2: return True if num % 2 == 0: return False p = 3 while p * p <= num: if num % p == 0: return False p += 2 return True def prime_factors(num): factors = set() if num % 2 == 0: factors.add(2) while num % 2 == 0: num //= 2 p = 3 while p * p <= num: if is_prime(p) and num % p == 0: factors.add(p) while num % p == 0: num //= p p += 2 if num > 2: factors.add(num) return sum(factors) return [prime_factors(x) for x in seq]"},{"question":"def four_sum(arr, target): Returns all unique quadruplets [arr[a], arr[b], arr[c], arr[d]] such that 0 <= a, b, c, d < len(arr), and a, b, c, d are distinct indices, and arr[a] + arr[b] + arr[c] + arr[d] == target >>> four_sum([1, 0, -1, 0, -2, 2], 0) [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]] >>> four_sum([2, 2, 2, 2], 8) [[2, 2, 2, 2]] >>> four_sum([1, 2, 3, 4], 50) [] >>> four_sum([1, 1, -2, 0, -1, -2], -4) [[-2, -2, -1, 1]] >>> four_sum([1000000000, 1000000000, 1000000000, 1000000000], 4000000000) [[1000000000, 1000000000, 1000000000, 1000000000]]","solution":"def four_sum(arr, target): Returns all unique quadruplets [arr[a], arr[b], arr[c], arr[d]] such that 0 <= a, b, c, d < len(arr), and a, b, c, d are distinct indices, and arr[a] + arr[b] + arr[c] + arr[d] == target arr.sort() n = len(arr) quadruplets = [] for i in range(n-3): if i > 0 and arr[i] == arr[i-1]: continue for j in range(i+1, n-2): if j > i+1 and arr[j] == arr[j-1]: continue left, right = j+1, n-1 while left < right: total = arr[i] + arr[j] + arr[left] + arr[right] if total == target: quadruplets.append([arr[i], arr[j], arr[left], arr[right]]) while left < right and arr[left] == arr[left+1]: left += 1 while left < right and arr[right] == arr[right-1]: right -= 1 left += 1 right -= 1 elif total < target: left += 1 else: right -= 1 return quadruplets"},{"question":"def min_operations_to_all_ones(n: int, s: str) -> int: Given a binary string s of length n, return the minimum number of operations required to turn all characters to '1' by flipping non-empty substrings. >>> min_operations_to_all_ones(5, \\"11001\\") 1 >>> min_operations_to_all_ones(6, \\"001100\\") 2 >>> min_operations_to_all_ones(5, \\"11111\\") 0 >>> min_operations_to_all_ones(5, \\"00000\\") 1 >>> min_operations_to_all_ones(4, \\"0101\\") 2 >>> min_operations_to_all_ones(1, \\"1\\") 0 >>> min_operations_to_all_ones(1, \\"0\\") 1","solution":"def min_operations_to_all_ones(n, s): Given a binary string s of length n, return the minimum number of operations required to turn all characters to '1' by flipping non-empty substrings. # We need to count groups of consecutive 0s. count_zeros_groups = 0 in_zero_group = False for char in s: if char == '0': if not in_zero_group: count_zeros_groups += 1 in_zero_group = True else: in_zero_group = False return count_zeros_groups"},{"question":"def max_apples(n, apples): Returns the maximum number of apples the squirrel can collect from 3 consecutive trees. :param n: int — Number of trees :param apples: list — List of integers representing the number of apples on each tree :return: int — Maximum number of apples from 3 consecutive trees >>> max_apples(5, [3, 4, 5, 1, 2]) 12 >>> max_apples(7, [2, 7, 3, 6, 8, 4, 5]) 18 >>> max_apples(3, [10, 20, 30]) 60 >>> max_apples(6, [3, 1, 4, 1, 5, 9]) 15 # Your code here","solution":"def max_apples(n, apples): Returns the maximum number of apples the squirrel can collect from 3 consecutive trees. :param n: int — Number of trees :param apples: list — List of integers representing the number of apples on each tree :return: int — Maximum number of apples from 3 consecutive trees max_apples_sum = 0 # Loop through the list, getting the sum of each triplet of consecutive trees for i in range(n - 2): current_sum = apples[i] + apples[i + 1] + apples[i + 2] if current_sum > max_apples_sum: max_apples_sum = current_sum return max_apples_sum"},{"question":"def findMissingPositive(nums): Given a list of integers, return the smallest positive integer that is missing from the list. The list may contain both positive and negative integers, and it may not be sorted. The function should only consider positive integers and ignore the negative ones. Examples: >>> findMissingPositive([3, 4, -1, 1]) # returns 2 >>> findMissingPositive([1, 2, 0]) # returns 3 >>> findMissingPositive([7, 8, 9, 11, 12]) # returns 1","solution":"def findMissingPositive(nums): Returns the smallest positive integer that is missing from the list. num_set = set(num for num in nums if num > 0) smallest_missing = 1 while smallest_missing in num_set: smallest_missing += 1 return smallest_missing"},{"question":"def romanToInt(s: str) -> int: Converts a given Roman numeral string to an integer. The string will be a valid Roman numeral in the range from 1 to 3999. Examples: >>> romanToInt(\\"III\\") == 3 >>> romanToInt(\\"IX\\") == 9 >>> romanToInt(\\"MCMXCIV\\") == 1994","solution":"def romanToInt(s): Converts a given Roman numeral string to an integer. Parameters: s (str): A valid Roman numeral string in the range from 1 to 3999. Returns: int: The integer representation of the Roman numeral. roman_to_int = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 } total = 0 prev_value = 0 for char in reversed(s): value = roman_to_int[char] if value < prev_value: total -= value else: total += value prev_value = value return total"},{"question":"def rearrange_string(S: str) -> str: Rearranges the string such that no two adjacent characters are the same if possible, otherwise returns \\"-1\\". Args: S (str): Input string consisting of lowercase English letters. Returns: str: A rearranged string or \\"-1\\" if rearrangement is not possible. Examples: >>> rearrange_string(\\"aab\\") 'aba' >>> rearrange_string(\\"aaab\\") '-1'","solution":"from collections import Counter import heapq def rearrange_string(S): # Frequency count of characters counter = Counter(S) max_heap = [] # Create a max heap based on character frequencies for char, freq in counter.items(): heapq.heappush(max_heap, (-freq, char)) prev_char = None prev_freq = 0 result = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) prev_char = char prev_freq = freq + 1 rearranged_string = ''.join(result) if len(rearranged_string) == len(S): return rearranged_string else: return \\"-1\\""},{"question":"from collections import deque from typing import List, Tuple def longest_contiguous_subarray(N: int, D: int, ratings: List[int]) -> int: Returns the length of the longest contiguous subarray where the absolute difference between the maximum and minimum ratings is <= D. pass def solve_performance_analysis(test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Processes multiple test cases and returns the result for each. pass def test_example_case(): assert longest_contiguous_subarray(6, 3, [1, 3, 6, 7, 9, 4]) == 3 def test_all_equal_elements(): assert longest_contiguous_subarray(5, 0, [7, 7, 7, 7, 7]) == 5 def test_all_different_elements_with_large_d(): assert longest_contiguous_subarray(4, 10, [1, 3, 6, 10]) == 4 def test_single_value(): assert longest_contiguous_subarray(1, 0, [1]) == 1 def test_large_d(): assert longest_contiguous_subarray(5, 100, [10, 20, 30, 40, 50]) == 5 def test_large_ratings(): assert longest_contiguous_subarray(3, 3, [1000000, 999997, 1000000]) == 3 def test_solve_performance_analysis(): test_cases = [(6, 3, [1, 3, 6, 7, 9, 4]), (5, 0, [7, 7, 7, 7, 7])] results = solve_performance_analysis(test_cases) assert results == [3, 5]","solution":"from collections import deque def longest_contiguous_subarray(N, D, ratings): Returns the length of the longest contiguous subarray where the absolute difference between the maximum and minimum ratings is <= D. left = 0 max_deque = deque() # stores indices of ratings in decreasing order min_deque = deque() # stores indices of ratings in increasing order max_length = 0 for right in range(N): while max_deque and ratings[max_deque[-1]] <= ratings[right]: max_deque.pop() while min_deque and ratings[min_deque[-1]] >= ratings[right]: min_deque.pop() max_deque.append(right) min_deque.append(right) while ratings[max_deque[0]] - ratings[min_deque[0]] > D: left += 1 if max_deque[0] < left: max_deque.popleft() if min_deque[0] < left: min_deque.popleft() max_length = max(max_length, right - left + 1) return max_length def solve_performance_analysis(test_cases): Processes multiple test cases and returns the result for each. results = [] for N, D, ratings in test_cases: result = longest_contiguous_subarray(N, D, ratings) results.append(result) return results"},{"question":"def max_ingredients(t: int, test_cases: List[Tuple[List[int], List[int]]]) -> List[int]: Determine the maximum number of different ingredients Anna can buy given the budget constraints and the special offer. Args: t (int): The number of test cases. test_cases (List[Tuple[List[int], List[int]]]): List containing t test cases. Each test case is a tuple with a list of integers for first line inputs and a list of integers for prices of ingredients. Returns: List[int]: List of integers where each integer represents the maximum number of ingredients Anna can buy for the corresponding test case. Examples: >>> max_ingredients(3, [([5, 20, 3], [1, 2, 3, 4, 5]), ([4, 15, 2], [3, 4, 5, 8]), ([3, 30, 3], [10, 10, 10])]) [5, 4, 3] >>> max_ingredients(3, [([6, 50, 3], [10, 20, 30, 40, 50, 60]), ([4, 100, 4], [25, 25, 25, 25]), ([5, 55, 2], [30, 10, 20, 20, 5])]) [3, 4, 4] >>> max_ingredients(1, [([7, 70, 5], [5, 6, 12, 13, 14, 15, 16])]) [6]","solution":"def max_ingredients(t, test_cases): results = [] for i in range(t): n, b, m = test_cases[i][0] prices = sorted(test_cases[i][1]) total_cost = 0 count = 0 while len(prices) > 0 and total_cost + prices[0] <= b: if len(prices) >= m: # Take m ingredients including the cheapest one being free total_cost += sum(prices[:m]) - min(prices[:m]) if total_cost <= b: count += m prices = prices[m:] else: break else: # Take the remaining ingredients for price in prices: if total_cost + price <= b: total_cost += price count += 1 else: break break results.append(count) return results"},{"question":"def get_prefix_sum_matrix(matrix, n, m): Helper function to compute prefix sum matrix for efficient submatrix sum queries prefix_sum = [[0] * (m + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, m + 1): prefix_sum[i][j] = matrix[i-1][j-1] + prefix_sum[i-1][j] + prefix_sum[i][j-1] - prefix_sum[i-1][j-1] return prefix_sum def submatrix_sum(n, m, q, matrix, queries): Given a grid of integers and multiple submatrix sum queries, find the sum of elements in the specified submatrix. Args: n : int : number of rows in the grid m : int : number of columns in the grid q : int : number of queries matrix : List[List[int]] : the grid of integers queries : List[Tuple[int, int, int, int]] : list of queries, each defined by four integers representing the top-left and bottom-right corners of the submatrix Returns: List[int] : list of sums for each query Example: >>> submatrix_sum(3, 3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]], [(1, 1, 2, 2), (2, 2, 3, 3), (1, 1, 3, 3)]) [12, 28, 45]","solution":"def get_prefix_sum_matrix(matrix, n, m): Helper function to compute prefix sum matrix for efficient submatrix sum queries prefix_sum = [[0] * (m + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, m + 1): prefix_sum[i][j] = matrix[i-1][j-1] + prefix_sum[i-1][j] + prefix_sum[i][j-1] - prefix_sum[i-1][j-1] return prefix_sum def submatrix_sum(n, m, q, matrix, queries): Main function to handle multiple submatrix sum queries prefix_sum = get_prefix_sum_matrix(matrix, n, m) results = [] for r1, c1, r2, c2 in queries: sum_value = ( prefix_sum[r2][c2] - prefix_sum[r1-1][c2] - prefix_sum[r2][c1-1] + prefix_sum[r1-1][c1-1] ) results.append(sum_value) return results"},{"question":"import heapq from typing import List, Tuple def shortest_paths_from_capital(n: int, m: int, roads: List[Tuple[int, int, int]]) -> List[int]: In a fictional country, there are n cities connected by m one-way roads. Each road has a specified length. The country needs to ensure that there is a way to travel from the capital city to every other city with the shortest possible total road length. n: Number of cities m: Number of roads roads: List of tuples, where each tuple contains three integers u, v, and w meaning there is a one-way road from city u to city v with length w. Returns: List of shortest distances from the capital city to all other cities. >>> shortest_paths_from_capital(5, 7, [(1, 2, 2), (1, 3, 4), (2, 3, 1), (2, 4, 7), (3, 5, 3), (4, 5, 1), (3, 4, 2)]) [2, 3, 5, 6] >>> shortest_paths_from_capital(3, 1, [(1, 2, 2)]) [2, -1] >>> shortest_paths_from_capital(4, 3, [(1, 2, 1), (1, 3, 2), (1, 4, 3)]) [1, 2, 3] >>> shortest_paths_from_capital(1, 0, []) [] >>> shortest_paths_from_capital(6, 9, [(1, 2, 10), (1, 3, 30), (1, 4, 50), (1, 5, 10), (2, 3, 40), (3, 4, 20), (4, 5, 10), (5, 6, 60), (3, 6, 70)]) [10, 30, 50, 10, 70]","solution":"import heapq def shortest_paths_from_capital(n, m, roads): def dijkstra(capital, n, graph): distances = [float('inf')] * n distances[capital] = 0 priority_queue = [(0, capital)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances graph = [[] for _ in range(n)] for u, v, w in roads: graph[u-1].append((v-1, w)) distances = dijkstra(0, n, graph) results = [] for i in range(1, n): if distances[i] == float('inf'): results.append(-1) else: results.append(distances[i]) return results"},{"question":"def rob(nums: List[int]) -> int: Determine the maximum amount of money you can rob tonight without alerting the police. You cannot rob two adjacent houses. >>> rob([1,2,3,1]) == 4 >>> rob([2,7,9,3,1]) == 12 >>> rob([]) == 0 >>> rob([5]) == 5 >>> rob([10]) == 10 >>> rob([5, 10]) == 10 >>> rob([10, 5]) == 10 >>> rob([2,1,1,2]) == 4 >>> rob([100, 200, 300, 400, 500, 600, 700]) == 1600 >>> rob([500, 1, 1, 500, 1, 1, 500]) == 1500","solution":"def rob(nums): Function to determine the maximum amount of money that can be robbed without robbing two adjacent houses. if not nums: return 0 n = len(nums) if n == 1: return nums[0] dp = [0] * n dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, n): dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]) return dp[n - 1]"},{"question":"def max_score(cards: List[int]) -> int: Determine the maximum score you can achieve from the given deck of cards. Each card has a positive integer value, and you must skip the next card after picking one. Args: cards (List[int]): A list of integers representing the values of the cards. Returns: int: The maximum score achievable. Examples: >>> max_score([4]) 4 >>> max_score([4, 1]) 4 >>> max_score([4, 1, 2]) 6 >>> max_score([4, 1, 2, 9, 8, 5, 10]) 24","solution":"def max_score(cards): N = len(cards) if N == 0: return 0 if N == 1: return cards[0] dp = [0] * N dp[0] = cards[0] if N > 1: dp[1] = max(cards[0], cards[1]) for i in range(2, N): dp[i] = max(dp[i-1], dp[i-2] + cards[i]) return dp[-1] def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) cards = list(map(int, data[1:])) print(max_score(cards)) if __name__ == \\"__main__\\": main()"},{"question":"def compress(input_string: str) -> str: Performs basic string compression using the counts of repeated characters. If the compressed string is not smaller than the original string, it returns the original string. >>> compress(\\"aabcccccaaa\\") 'a2b1c5a3' >>> compress(\\"abcdef\\") 'abcdef' >>> compress(\\"aaa\\") 'a3' >>> compress(\\"aabb\\") 'aabb'","solution":"def compress(input_string): Performs basic string compression using the counts of repeated characters. If the compressed string is not smaller than the original string, it returns the original string. if not input_string: return input_string compressed = [] count = 1 for i in range(1, len(input_string)): if input_string[i] == input_string[i - 1]: count += 1 else: compressed.append(input_string[i - 1] + str(count)) count = 1 compressed.append(input_string[-1] + str(count)) compressed_string = ''.join(compressed) return compressed_string if len(compressed_string) < len(input_string) else input_string"},{"question":"def custom_sort(arr): Sorts an array of integers in ascending order without using any built-in sorting methods. Parameters: arr (list): List of integers to be sorted. Returns: list: Sorted list of integers. >>> custom_sort([34, 7, 23, 32, 5, 62]) [5, 7, 23, 32, 34, 62] >>> custom_sort([3, -1, 2, -3, 0]) [-3, -1, 0, 2, 3] >>> custom_sort([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> custom_sort([5, 4, 3, 2, 1]) [1, 2, 3, 4, 5] >>> custom_sort([1]) [1] >>> custom_sort([]) []","solution":"def custom_sort(arr): Sorts an array of integers in ascending order using the bubble sort algorithm. Parameters: arr (list): List of integers to be sorted. Returns: list: Sorted list of integers. n = len(arr) for i in range(n): for j in range(0, n-i-1): if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] return arr"},{"question":"def min_rest_stops(L: int, M: int, rest_points: List[int]) -> int: Determine the minimum number of rest stops needed to complete the hike. >>> min_rest_stops(10, 3, [4, 1, 2, 6, 8, 9]) 4 >>> min_rest_stops(12, 4, [3, 2, 6, 10]) 3 >>> min_rest_stops(10, 5, []) -1 >>> min_rest_stops(10, 10, []) 0 >>> min_rest_stops(10, 2, [3, 5, 7]) -1 >>> min_rest_stops(9, 3, [3, 6]) 2","solution":"def min_rest_stops(L, M, rest_points): Determine the minimum number of rest stops needed to complete the hike. rest_points = [0] + sorted(rest_points) + [L] # Add start and end points n = len(rest_points) current_pos = 0 stops = 0 while current_pos < n - 1: next_pos = current_pos while (next_pos + 1 < n) and (rest_points[next_pos + 1] - rest_points[current_pos] <= M): next_pos += 1 if next_pos == current_pos: return -1 if next_pos < n - 1: stops += 1 current_pos = next_pos if rest_points[-1] - rest_points[current_pos] > M: return -1 return stops"},{"question":"from typing import List, Tuple def shortest_path_in_grid(T: int, test_cases: List[Tuple[int, int, List[str]]]) -> List[int]: Determines the length of the shortest path from the top-left corner to the bottom-right corner in a grid, avoiding buildings. >>> shortest_path_in_grid(1, [(3, 3, ['...', '.#.', '...'])]) [4] >>> shortest_path_in_grid(1, [(4, 4, ['..#.', '.#..', '....', '.#..'])]) [6] >>> shortest_path_in_grid(1, [(3, 3, ['.#.', '#', '.#.'])]) [-1] >>> shortest_path_in_grid(2, [ ... (2, 2, ['#.', '..']), ... (2, 2, ['..', '.#']) ... ]) [-1, -1] >>> N, M = 1000, 1000 >>> grid = [['.' for _ in range(M)] for _ in range(N)] >>> shortest_path_in_grid(1, [(N, M, grid)]) [1998] >>> shortest_path_in_grid(1, [(1, 1, ['.'])]) [0]","solution":"from collections import deque def shortest_path_in_grid(T, test_cases): results = [] directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] for case in test_cases: N, M, grid = case if grid[0][0] == '#' or grid[N-1][M-1] == '#': results.append(-1) continue visited = [[False] * M for _ in range(N)] queue = deque([(0, 0, 0)]) # (row, col, distance) visited[0][0] = True found = False while queue: x, y, dist = queue.popleft() if x == N-1 and y == M-1: results.append(dist) found = True break for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and not visited[nx][ny] and grid[nx][ny] == '.': visited[nx][ny] = True queue.append((nx, ny, dist + 1)) if not found: results.append(-1) return results"},{"question":"def calculate_worked_hours(n: int, logs: List[Tuple[str, str, int]]) -> List[Tuple[str, int]]: Compute the total number of minutes worked for each employee and return the results ordered by \`employee_id\`. >>> calculate_worked_hours(6, [ ... (\\"emp1\\", \\"clock_in\\", 480), ... (\\"emp2\\", \\"clock_in\\", 540), ... (\\"emp1\\", \\"clock_out\\", 780), ... (\\"emp2\\", \\"clock_out\\", 600), ... (\\"emp1\\", \\"clock_in\\", 800), ... (\\"emp1\\", \\"clock_out\\", 960), ... ]) [(\\"emp1\\", 460), (\\"emp2\\", 60)] >>> calculate_worked_hours(2, [(\\"emp1\\", \\"clock_in\\", 480), (\\"emp1\\", \\"clock_out\\", 780)]) [(\\"emp1\\", 300)] >>> calculate_worked_hours(0, []) [] >>> calculate_worked_hours(2, [(\\"emp1\\", \\"clock_in\\", 480), (\\"emp1\\", \\"clock_out\\", 480)]) [(\\"emp1\\", 0)]","solution":"def calculate_worked_hours(n, logs): from collections import defaultdict work_times = defaultdict(int) in_time = {} for log in logs: employee_id, event_type, timestamp = log if event_type == \\"clock_in\\": in_time[employee_id] = timestamp elif event_type == \\"clock_out\\": work_times[employee_id] += timestamp - in_time.pop(employee_id, 0) sorted_work_times = sorted(work_times.items()) return sorted_work_times"},{"question":"def isMountainArray(arr: List[int]) -> bool: Determine if an array is a mountain array. A mountain array is defined as an array that has exactly one peak element, where the peak element is larger than its neighbors and it is strictly increasing before the peak and strictly decreasing after the peak. >>> isMountainArray([1, 3, 5, 4, 2]) True >>> isMountainArray([2, 1, 4, 7, 3, 2]) False >>> isMountainArray([3, 5, 5]) False","solution":"def isMountainArray(arr): n = len(arr) if n < 3: return False i = 1 # walk up while i < n and arr[i] > arr[i - 1]: i += 1 # peak can't be first or last if i == 1 or i == n: return False # walk down while i < n and arr[i] < arr[i - 1]: i += 1 return i == n"},{"question":"def longest_increasing_contiguous_subsequence(arr: List[int]) -> int: Given an array of integers, find the length of the longest subsequence such that all elements of the subsequence are in strictly increasing order. The subsequence must be a contiguous block of the original array. >>> longest_increasing_contiguous_subsequence([1, 3, 2, 3, 4, 5]) 4 >>> longest_increasing_contiguous_subsequence([10]) 1 >>> longest_increasing_contiguous_subsequence([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 10 >>> longest_increasing_contiguous_subsequence([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) 1 >>> longest_increasing_contiguous_subsequence([1, 2, 3, 1, 2, 3, 4, 5, 1, 2]) 5 >>> longest_increasing_contiguous_subsequence([1, 2, 1, 2, 1, 2]) 2 >>> longest_increasing_contiguous_subsequence([5, 5, 5, 5, 5]) 1","solution":"def longest_increasing_contiguous_subsequence(arr): n = len(arr) if n == 0: return 0 longest_length = 1 current_length = 1 for i in range(1, n): if arr[i] > arr[i - 1]: current_length += 1 longest_length = max(longest_length, current_length) else: current_length = 1 return longest_length # Example usage: arr = [1, 3, 2, 3, 4, 5] print(longest_increasing_contiguous_subsequence(arr)) # Output: 4"},{"question":"def is_rotated_version(s1: str, s2: str) -> str: Determines if s2 is a rotated version of s1. >>> is_rotated_version(\\"hello\\", \\"lohel\\") \\"YES\\" >>> is_rotated_version(\\"world\\", \\"dlrow\\") \\"NO\\"","solution":"def is_rotated_version(s1, s2): Determines if s2 is a rotated version of s1. if len(s1) != len(s2): return \\"NO\\" doubled_s1 = s1 + s1 return \\"YES\\" if s2 in doubled_s1 else \\"NO\\""},{"question":"def find_first_not_smaller(nums: List[int], k: int) -> int: Returns the index of the first element in the array that is not smaller than k. If no such element exists, returns -1. >>> find_first_not_smaller([1, 3, 5, 7, 9], 5) 2 >>> find_first_not_smaller([-5, -3, -1, 1], 0) 3 >>> find_first_not_smaller([-2, -3, -5], -1) -1 pass # Test cases assert find_first_not_smaller([1, 3, 5, 7, 9], 5) == 2 assert find_first_not_smaller([-5, -3, -1, 1], 0) == 3 assert find_first_not_smaller([-2, -3, -5], -1) == -1 assert find_first_not_smaller([1, 2, 3], 4) == -1 assert find_first_not_smaller([4, 2, 3], 2) == 0 assert find_first_not_smaller([1, 1, 1, 1, 5], 5) == 4 assert find_first_not_smaller([-4, -3, -2, -1], -2) == 2","solution":"def find_first_not_smaller(nums, k): Returns the index of the first element in the array that is not smaller than k. If no such element exists, returns -1. for idx, num in enumerate(nums): if num >= k: return idx return -1"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def findLCA(root, p, q): Find the least common ancestor (LCA) of the nodes with values p and q in a BST. Parameters: root (TreeNode): The root of the binary search tree. p (int): The value of the first node. q (int): The value of the second node. Returns: int: The value of the LCA node. pass # Unit Tests def test_findLCA_example1(): root = TreeNode(val=6) root.left = TreeNode(val=2) root.right = TreeNode(val=8) root.left.left = TreeNode(val=0) root.left.right = TreeNode(val=4) root.right.left = TreeNode(val=7) root.right.right = TreeNode(val=9) root.left.right.left = TreeNode(val=3) root.left.right.right = TreeNode(val=5) assert findLCA(root, 2, 8) == 6 def test_findLCA_example2(): root = TreeNode(val=6) root.left = TreeNode(val=2) root.right = TreeNode(val=8) root.left.left = TreeNode(val=0) root.left.right = TreeNode(val=4) root.right.left = TreeNode(val=7) root.right.right = TreeNode(val=9) root.left.right.left = TreeNode(val=3) root.left.right.right = TreeNode(val=5) assert findLCA(root, 2, 4) == 2 def test_findLCA_with_root_as_LCA(): root = TreeNode(val=6) root.left = TreeNode(val=2) root.right = TreeNode(val=8) root.left.left = TreeNode(val=0) root.left.right = TreeNode(val=4) root.right.left = TreeNode(val=7) root.right.right = TreeNode(val=9) root.left.right.left = TreeNode(val=3) root.left.right.right = TreeNode(val=5) assert findLCA(root, 5, 8) == 6 def test_findLCA_for_same_node(): root = TreeNode(val=6) root.left = TreeNode(val=2) root.right = TreeNode(val=8) root.left.left = TreeNode(val=0) root.left.right = TreeNode(val=4) root.right.left = TreeNode(val=7) root.right.right = TreeNode(val=9) root.left.right.left = TreeNode(val=3) root.left.right.right = TreeNode(val=5) assert findLCA(root, 4, 4) == 4 def test_findLCA_for_leaf_nodes(): root = TreeNode(val=6) root.left = TreeNode(val=2) root.right = TreeNode(val=8) root.left.left = TreeNode(val=0) root.left.right = TreeNode(val=4) root.right.left = TreeNode(val=7) root.right.right = TreeNode(val=9) root.left.right.left = TreeNode(val=3) root.left.right.right = TreeNode(val=5) assert findLCA(root, 0, 5) == 2","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def findLCA(root, p, q): Find the least common ancestor (LCA) of the nodes with values p and q in a BST. Parameters: root (TreeNode): The root of the binary search tree. p (int): The value of the first node. q (int): The value of the second node. Returns: int: The value of the LCA node. current = root while current: if p < current.val and q < current.val: current = current.left elif p > current.val and q > current.val: current = current.right else: return current.val # Example usage: # Creating an example BST: # 6 # / # 2 8 # / / # 0 4 7 9 # / # 3 5 root = TreeNode(val=6) root.left = TreeNode(val=2) root.right = TreeNode(val=8) root.left.left = TreeNode(val=0) root.left.right = TreeNode(val=4) root.right.left = TreeNode(val=7) root.right.right = TreeNode(val=9) root.left.right.left = TreeNode(val=3) root.left.right.right = TreeNode(val=5) print(findLCA(root, 2, 8)) # Should return 6 print(findLCA(root, 2, 4)) # Should return 2"},{"question":"def translate_commands(sequence: str) -> List[str]: Translates a sequence of characters into respective commands. Each character corresponds to a specific command. Sequences within parentheses are repeated twice. Commands: 'A' -> 'Move Forward' 'B' -> 'Turn Left' 'C' -> 'Turn Right' Args: sequence (str): The sequence of commands Returns: list: List of commands as translated strings. >>> translate_commands('A') ['Move Forward'] >>> translate_commands('A(B)') ['Move Forward', 'Turn Left', 'Turn Left'] >>> translate_commands('BC(C)A') ['Turn Left', 'Turn Right', 'Turn Right', 'Turn Right', 'Move Forward'] >>> translate_commands('A(CAB)BA') ['Move Forward', 'Turn Right', 'Move Forward', 'Turn Left', 'Turn Right', 'Move Forward', 'Turn Left', 'Turn Left', 'Move Forward'] >>> translate_commands('ABC') ['Move Forward', 'Turn Left', 'Turn Right'] >>> translate_commands('') [] pass","solution":"def translate_commands(sequence): Translates a sequence of characters into respective commands. Each character corresponds to a specific command. Sequences within parentheses are repeated twice. Commands: 'A' -> 'Move Forward' 'B' -> 'Turn Left' 'C' -> 'Turn Right' Args: sequence (str): The sequence of commands Returns: list: List of commands as translated strings. command_mapping = { 'A': 'Move Forward', 'B': 'Turn Left', 'C': 'Turn Right' } result = [] i = 0 while i < len(sequence): if sequence[i] in command_mapping: result.append(command_mapping[sequence[i]]) elif sequence[i] == '(': end_idx = sequence.find(')', i) sub_sequence = sequence[i+1:end_idx] * 2 for char in sub_sequence: result.append(command_mapping[char]) i = end_idx i += 1 return result"},{"question":"from typing import List def max_occupancy(N: int, arr: List[int]) -> int: Determine the maximum number of people present in the room at any given time. Parameters: N (int): The number of hours. arr (List[int]): A list of integers where each integer represents the net number of people entering or leaving the room in a given hour. Returns: int: The maximum occupancy of the room. >>> max_occupancy(5, [10, -3, 5, -2, 8]) 18 >>> max_occupancy(5, [5, 5, 5, 5, 5]) 25 >>> max_occupancy(5, [-5, -5, -5, -5, -5]) 0 >>> max_occupancy(6, [5, -5, 10, -10, 15, -15]) 15 >>> max_occupancy(8, [3, -1, 2, -2, 1, -1, 4, -3]) 6 >>> max_occupancy(1, [10]) 10 >>> max_occupancy(1, [-10]) 0 >>> max_occupancy(1000, [1]*1000) 1000 >>> max_occupancy(5, [1000, -1000, 1000, -1000, 1000]) 1000","solution":"from typing import List def max_occupancy(N: int, arr: List[int]) -> int: Determine the maximum number of people present in the room at any given time. Parameters: N (int): The number of hours. arr (List[int]): A list of integers where each integer represents the net number of people entering or leaving the room in a given hour. Returns: int: The maximum occupancy of the room. current_occupancy = 0 max_occupancy = 0 for net_change in arr: current_occupancy += net_change if current_occupancy > max_occupancy: max_occupancy = current_occupancy return max_occupancy"},{"question":"def lexicographicRank(S: str) -> int: Calculate the lexicographic rank of string S among all its permutations sorted in alphabetical order. >>> lexicographicRank(\\"abc\\") 1 >>> lexicographicRank(\\"cba\\") 6","solution":"def factorial(n): Returns the factorial of n. return 1 if n == 0 or n == 1 else n * factorial(n - 1) def lexicographicRank(S): Returns the lexicographic rank of string S. n = len(S) rank = 1 mul = factorial(n) for i in range(n): mul //= (n - i) count = sum(1 for j in range(i + 1, n) if S[j] < S[i]) rank += count * mul return rank"},{"question":"from typing import List def rearrange_string(s: str) -> str: You are given a string s consisting of lowercase English letters. You want to rearrange the characters of the string such that no two adjacent characters are the same. If it's possible to rearrange the string, return the rearranged string. Otherwise, return an empty string. Args: s (str): The input string consisting of lowercase English letters. Returns: str: The rearranged string or an empty string if it is not possible to rearrange. Examples: >>> rearrange_string(\\"aab\\") 'aba' >>> rearrange_string(\\"aaab\\") '' pass def test_rearrange_string_basic(): assert rearrange_string(\\"aab\\") == \\"aba\\" assert rearrange_string(\\"aaab\\") == \\"\\" def test_rearrange_string_all_unique_chars(): assert rearrange_string(\\"abcd\\") == \\"abcd\\" def test_rearrange_string_two_chars(): result = rearrange_string(\\"abab\\") assert result == \\"abab\\" def test_rearrange_string_multiple_same_chars(): result = rearrange_string(\\"aaabb\\") assert result in (\\"ababa\\", \\"abbaa\\", \\"baaba\\") # Multiple valid rearrangements def test_rearrange_string_impossible_case(): assert rearrange_string(\\"aaaa\\") == \\"\\" def test_rearrange_string_large_input(): input_str = \\"a\\" * 5000 + \\"b\\" * 5000 result = rearrange_string(input_str) assert len(result) == 10000 for i in range(1, len(result)): assert result[i] != result[i - 1] # Ensure no two adjacent characters are the same","solution":"from collections import Counter import heapq def rearrange_string(s: str) -> str: # Get the frequency of each character freq = Counter(s) # Using a max-heap to store the negative frequencies (to simulate a max-heap using Python's min-heap) max_heap = [(-count, char) for char, count in freq.items()] heapq.heapify(max_heap) prev_count, prev_char = 0, '' result = [] while max_heap: count, char = heapq.heappop(max_heap) # Append current character to result and update its count result.append(char) if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) # Update prev_count as count + 1 to indicate we have used one occurrence of char prev_count, prev_char = count + 1, char result_str = ''.join(result) # If we couldn't produce a valid result, it will be shorter than the input if len(result_str) != len(s): return \\"\\" return result_str"},{"question":"def find_kth_element(A, B, k): Peter loves to play with sequences of numbers. He finds an interesting sequence game where he needs to find the k-th smallest element in the merged list of two sorted lists without actually merging them. Given two sorted lists A and B, and an integer k, find the k-th smallest element in the combined sequence of both lists. >>> find_kth_element([2, 3, 6, 7], [1, 5, 8], 5) 6 >>> find_kth_element([1, 3, 7], [2, 4, 6, 8], 3) 3 >>> find_kth_element([], [1, 2, 3, 4, 5, 6, 7], 4) 4 >>> find_kth_element([1, 2, 3, 4, 5, 6, 7], [], 4) 4 >>> find_kth_element([1, 5, 9], [2, 3, 4, 7, 8, 10], 7) 8","solution":"def find_kth_element(A, B, k): This function finds the k-th smallest element in the combined sorted list created from A and B. def kth_smallest(a, b, k): len_a, len_b = len(a), len(b) if len_a > len_b: return kth_smallest(b, a, k) if len_a == 0: return b[k-1] if k == 1: return min(a[0], b[0]) # Set pointers in a and b i = min(len_a, k // 2) j = min(len_b, k // 2) if a[i-1] > b[j-1]: return kth_smallest(a, b[j:], k-j) else: return kth_smallest(a[i:], b, k-i) return kth_smallest(A, B, k)"},{"question":"def max_books_to_read(test_cases): Determines the maximum number of books that can be read without overlaps for each test case. pass def main(input_data): Parses the input and returns the output for each test case. pass import pytest def test_sample_input(): input_data = \\"2n3n1 4n2 5n6 8n4n1 3n4 6n6 9n10 12\\" expected_output = [2, 4] assert main(input_data) == expected_output def test_no_overlap(): # All books have non-overlapping times input_data = \\"1n3n1 2n3 4n5 6\\" expected_output = [3] assert main(input_data) == expected_output def test_all_overlap(): # All books overlap at some point input_data = \\"1n3n1 10n2 11n3 12\\" expected_output = [1] assert main(input_data) == expected_output def test_partial_overlap(): # Some books overlap and some don't input_data = \\"1n4n1 3n3 5n4 6n6 8\\" expected_output = [3] assert main(input_data) == expected_output def test_single_book(): # Only one book available to read input_data = \\"1n1n1 5\\" expected_output = [1] assert main(input_data) == expected_output def test_multiple_test_cases(): input_data = \\"2n2n1 2n2 3n2n5 10n11 12\\" expected_output = [2, 2] assert main(input_data) == expected_output","solution":"def max_books_to_read(test_cases): Determines the maximum number of books that can be read without overlaps for each test case. results = [] for books in test_cases: # Sort books by their end times books.sort(key=lambda x: x[1]) # Initialize the count and the end time of the last book read max_count = 0 last_end_time = 0 for start, end in books: if start >= last_end_time: max_count += 1 last_end_time = end results.append(max_count) return results def main(input_data): Parses the input and returns the output for each test case. input_lines = input_data.strip().split('n') T = int(input_lines[0]) index = 1 test_cases = [] for _ in range(T): N = int(input_lines[index]) books = [] for j in range(index + 1, index + 1 + N): start, end = map(int, input_lines[j].split()) books.append((start, end)) test_cases.append(books) index += 1 + N return max_books_to_read(test_cases)"},{"question":"def count_distinct_substrings(t: int, test_cases: List[Tuple[str, int]]) -> List[int]: Given a number of test cases, each containing a string S and an integer k, finds out how many distinct substrings of length k can be generated from the string S. Args: t (int): The number of test cases. test_cases (List[Tuple[str, int]]): A list of tuples where each tuple contains a string S and an integer k. Returns: List[int]: The number of distinct substrings of length k for each test case. >>> count_distinct_substrings(2, [(\\"abcabc\\", 3), (\\"abcd\\", 2)]) == [3, 3] >>> count_distinct_substrings(1, [(\\"a\\", 1)]) == [1] >>> count_distinct_substrings(1, [(\\"aaaaa\\", 2)]) == [1]","solution":"def count_distinct_substrings(t, test_cases): results = [] for i in range(t): s, k = test_cases[i] substrings = set() for j in range(len(s) - k + 1): substr = s[j:j + k] substrings.add(substr) results.append(len(substrings)) return results"},{"question":"def min_palindrome_substrings(s: str) -> int: Returns the minimum number of contiguous substrings from the given string such that each substring is a palindrome. >>> min_palindrome_substrings(\\"1221\\") 1 >>> min_palindrome_substrings(\\"12321\\") 1 >>> min_palindrome_substrings(\\"12345\\") 5 >>> min_palindrome_substrings(\\"\\") 0 >>> min_palindrome_substrings(\\"1\\") 1 >>> min_palindrome_substrings(\\"ab\\") 2 >>> min_palindrome_substrings(\\"abc\\") 3 >>> min_palindrome_substrings(\\"aabbcbbaa\\") 1 >>> min_palindrome_substrings(\\"aabbccdd\\") 8","solution":"def min_palindrome_substrings(s: str) -> int: Returns the minimum number of contiguous substrings from the given string such that each substring is a palindrome. if not s: return 0 if s == s[::-1]: return 1 return len(s)"},{"question":"def max_sum_and_diff(test_cases): Given multiple test cases, each consisting of an array of integers, find the maximum possible sum and the maximum possible absolute value of the difference between the maximum and minimum element of the array after rearrangement. Parameters: test_cases: List of tuples, where each tuple contains an integer n (size of the array) and a list of n integers. Returns: A list of tuples with two integers each: the maximum sum and the maximum absolute difference. Example: >>> max_sum_and_diff([(3, [-1, 2, 3]), (4, [1, -2, 0, 3]), (2, [-5, -5])]) [(4, 4), (2, 5), (-10, 0)] pass def process_input(input_text): Convert input text into a suitable format for further processing. Parameters: input_text: A string containing the input data. Returns: A list of tuples, where each tuple contains an integer n (size of the array) and a list of n integers. Example: >>> process_input(\\"1n3n-1 2 3\\") [(3, [-1, 2, 3])] pass","solution":"def max_sum_and_diff(test_cases): results = [] for case in test_cases: n, array = case max_sum = sum(array) max_diff = max(array) - min(array) results.append((max_sum, max_diff)) return results def process_input(input_text): lines = input_text.strip().split('n') t = int(lines[0]) test_cases = [] index = 1 for _ in range(t): n = int(lines[index]) array = list(map(int, lines[index + 1].split())) test_cases.append((n, array)) index += 2 return test_cases"},{"question":"def strictly_increasing_subsequence(n: int, flower_beds: List[int], k: int) -> str: Determine if there exists a strictly increasing subsequence of length k in the array of flower beds. >>> strictly_increasing_subsequence(6, [1, 2, 1, 2, 3, 4], 3) \\"yes\\" >>> strictly_increasing_subsequence(5, [5, 4, 3, 2, 1], 2) \\"no\\" >>> strictly_increasing_subsequence(1, [1], 1) \\"yes\\" >>> strictly_increasing_subsequence(5, [1, 2, 3, 4, 5], 5) \\"yes\\" >>> strictly_increasing_subsequence(4, [2, 2, 2, 2], 2) \\"no\\" >>> strictly_increasing_subsequence(5, [1, 2, 3, 4, 5], 6) \\"no\\" >>> strictly_increasing_subsequence(3, [3, 1, 2], 1) \\"yes\\"","solution":"def strictly_increasing_subsequence(n, flower_beds, k): Returns \\"yes\\" if there exists a strictly increasing subsequence of length k, otherwise \\"no\\". Parameters: n (int): The number of flower beds. flower_beds (list of int): The number of flowers in each bed. k (int): The desired length of the strictly increasing subsequence. Returns: str: \\"yes\\" or \\"no\\" depending on whether the condition is met. if k > n: return \\"no\\" # Use dynamic programming to find the length of the longest increasing subsequence dp = [1] * n for i in range(1, n): for j in range(i): if flower_beds[i] > flower_beds[j]: dp[i] = max(dp[i], dp[j] + 1) max_length = max(dp) if max_length >= k: return \\"yes\\" else: return \\"no\\""},{"question":"def compute_minimum_rope_length(input_string: str) -> str: Compute the minimum total rope length required to connect all the lanterns. >>> input_data = '3n0 2 3n2 0 1n3 1 0n0n' >>> compute_minimum_rope_length(input_data) '3' >>> input_data = '4n0 5 9 4n5 0 1 3n9 1 0 2n4 3 2 0n0n' >>> compute_minimum_rope_length(input_data) '7' # Helper function to parse the input def parse_input(input_string): lines = input_string.strip().split('n') idx = 0 test_cases = [] while idx < len(lines): n = int(lines[idx]) if n == 0: break idx += 1 dist_matrix = [] for _ in range(n): dist_matrix.append(list(map(int, lines[idx].split()))) idx += 1 test_cases.append((n, dist_matrix)) return test_cases # Helper function to format the output def format_output(results): return 'n'.join(map(str, results)) # Function to compute the minimal rope length using Prim's algorithm def prim_mst(n, dist_matrix): import sys import heapq min_cost = [sys.maxsize] * n min_cost[0] = 0 visited = [False] * n pq = [(0, 0)] # (cost, vertex) total_cost = 0 while pq: cost, u = heapq.heappop(pq) if visited[u]: continue visited[u] = True total_cost += cost for v in range(n): if not visited[v] and dist_matrix[u][v] < min_cost[v]: min_cost[v] = dist_matrix[u][v] heapq.heappush(pq, (dist_matrix[u][v], v)) return total_cost # Function to compute the minimal rope length for all test cases def minimal_rope_length(test_cases): results = [] for case in test_cases: n = case[0] dist_matrix = case[1] results.append(prim_mst(n, dist_matrix)) return results test_cases = parse_input(input_string) result = minimal_rope_length(test_cases) return format_output(result)","solution":"import sys import heapq def prim_mst(n, dist_matrix): min_cost = [sys.maxsize] * n min_cost[0] = 0 visited = [False] * n pq = [(0, 0)] # (cost, vertex) total_cost = 0 while pq: cost, u = heapq.heappop(pq) if visited[u]: continue visited[u] = True total_cost += cost for v in range(n): if not visited[v] and dist_matrix[u][v] < min_cost[v]: min_cost[v] = dist_matrix[u][v] heapq.heappush(pq, (dist_matrix[u][v], v)) return total_cost def minimal_rope_length(test_cases): results = [] for case in test_cases: n = case[0] dist_matrix = case[1] results.append(prim_mst(n, dist_matrix)) return results # Input processing def parse_input(input_string): lines = input_string.strip().split('n') idx = 0 test_cases = [] while idx < len(lines): n = int(lines[idx]) if n == 0: break idx += 1 dist_matrix = [] for _ in range(n): dist_matrix.append(list(map(int, lines[idx].split()))) idx += 1 test_cases.append((n, dist_matrix)) return test_cases def format_output(results): return 'n'.join(map(str, results)) # Integration function def compute_minimum_rope_length(input_string): test_cases = parse_input(input_string) result = minimal_rope_length(test_cases) return format_output(result)"},{"question":"def checkPrime(N: int) -> str: Returns \\"Prime\\" if N is a prime number, otherwise returns \\"Not Prime\\". >>> checkPrime(7) 'Prime' >>> checkPrime(10) 'Not Prime'","solution":"def checkPrime(N): Returns \\"Prime\\" if N is a prime number, otherwise returns \\"Not Prime\\". if N <= 1: return \\"Not Prime\\" if N <= 3: return \\"Prime\\" if N % 2 == 0 or N % 3 == 0: return \\"Not Prime\\" i = 5 while i * i <= N: if N % i == 0 or N % (i + 2) == 0: return \\"Not Prime\\" i += 6 return \\"Prime\\""},{"question":"def shortest_nice_segment(T, test_cases): Determine the length of the shortest \\"nice\\" segment in an array, where a \\"nice\\" segment is defined as a contiguous subarray that contains at least one occurrence of every integer from 1 to M (where M can be up to 10). Parameters: - T (int): The number of test cases. - test_cases (List[Tuple[Tuple[int, int], List[int]]]): A list of tuples representing the test cases, where each tuple contains: - A tuple (N, M), where N is the length of the array and M is the maximum integer to be included in the \\"nice\\" segment. - A list of N integers, representing the elements of the array. Returns: - List[int]: A list of integers representing the length of the shortest \\"nice\\" segment for each test case, or -1 if no such segment exists. Examples: >>> T = 3 >>> test_cases = [ >>> [(5, 2), [1, 2, 1, 2, 1]], >>> [(8, 3), [3, 1, 2, 1, 3, 2, 2, 1]], >>> [(4, 2), [1, 1, 1, 1]] >>> ] >>> shortest_nice_segment(T, test_cases) [2, 3, -1]","solution":"def shortest_nice_segment(T, test_cases): results = [] for i in range(T): N, M = test_cases[i][0] arr = test_cases[i][1] def has_all_elements(seg, M): return len(set(seg)) >= M min_length = float('inf') found = False for start in range(N): for end in range(start + M - 1, N): # Minimum length required is M if has_all_elements(arr[start:end + 1], M): min_length = min(min_length, end - start + 1) found = True break # No need to expand further for this starting index if found: results.append(min_length) else: results.append(-1) return results # Example usage: # T = 3 # test_cases = [ # [(5, 2), [1, 2, 1, 2, 1]], # [(8, 3), [3, 1, 2, 1, 3, 2, 2, 1]], # [(4, 2), [1, 1, 1, 1]] # ] # print(shortest_nice_segment(T, test_cases)) # Output: [2, 3, -1]"},{"question":"def left_inversion(n: int, a: List[int]) -> List[int]: Transforms the array 'a' using the Left-Inversion procedure and returns the modified array 'b'. >>> left_inversion(5, [1, 2, 3, 4, 5]) [5, 3, 1, 2, 4] >>> left_inversion(4, [10, 20, 30, 40]) [30, 10, 20, 40] >>> left_inversion(1, [50]) [50] b = [] for i in range(n): if i % 2 == 0: b.insert(0, a[i]) else: b.append(a[i]) return b # Unit Test from solution import left_inversion def test_left_inversion_example1(): assert left_inversion(5, [1, 2, 3, 4, 5]) == [5, 3, 1, 2, 4] def test_left_inversion_example2(): assert left_inversion(4, [10, 20, 30, 40]) == [30, 10, 20, 40] def test_left_inversion_example3(): assert left_inversion(1, [50]) == [50] def test_left_inversion_even_length(): assert left_inversion(6, [1, 2, 3, 4, 5, 6]) == [5, 3, 1, 2, 4, 6] def test_left_inversion_odd_length(): assert left_inversion(7, [1, 2, 3, 4, 5, 6, 7]) == [7, 5, 3, 1, 2, 4, 6] def test_left_inversion_small_elements(): assert left_inversion(3, [100, 1, 10]) == [10, 100, 1]","solution":"def left_inversion(n, a): Transforms the array 'a' using the Left-Inversion procedure and returns the modified array 'b'. Parameters: n (int): Length of array 'a'. a (list of int): Original array. Returns: list of int: The transformed array using Left-Inversion. b = [] for i in range(n): if i % 2 == 0: b.insert(0, a[i]) else: b.append(a[i]) return b"},{"question":"def count_rectangles(n: int, m: int) -> int: Returns the number of rectangles that can be formed in an n by m grid. >>> count_rectangles(2, 2) 9 >>> count_rectangles(1, 3) 6","solution":"def count_rectangles(n, m): Returns the number of rectangles that can be formed in an n by m grid. return (n * (n + 1) * m * (m + 1)) // 4"},{"question":"def count_pairs_with_sum(N, A, B, X): Returns the number of pairs (i, j) such that A[i] + B[j] = X. Parameters: N (int): The size of arrays A and B. A (list of int): The first array. B (list of int): The second array. X (int): The target sum. Returns: int: The number of pairs that sum to X. >>> count_pairs_with_sum(4, [1, 2, 3, 4], [5, 2, 2, 1], 6) 3 >>> count_pairs_with_sum(3, [2, 4, 6], [4, 2, 0], 6) 3 >>> count_pairs_with_sum(3, [1, 1, 1], [4, 4, 4], 10) 0 >>> count_pairs_with_sum(5, [1, 2, 3, 4, 5], [10, 9, 8, 7, 6], 7) 1 >>> count_pairs_with_sum(1, [3], [3], 6) 1 >>> count_pairs_with_sum(3, [3, 3, 3], [3, 3, 3], 6) 9","solution":"def count_pairs_with_sum(N, A, B, X): Returns the number of pairs (i, j) such that A[i] + B[j] = X. Parameters: N (int): The size of arrays A and B. A (list of int): The first array. B (list of int): The second array. X (int): The target sum. Returns: int: The number of pairs that sum to X. count = 0 for i in range(N): for j in range(N): if A[i] + B[j] == X: count += 1 return count"},{"question":"def is_prime(n): Helper function to check if a number is a prime. pass def twisted_primes(L, R): Returns a list of all 'Twisted Primes' in the range [L, R]. A number is 'Twisted Prime' if reversing its digits also results in a prime number. The reversed number must be different from the original number. >>> twisted_primes(10, 100) [13, 17, 31, 37, 71, 73, 79, 97] >>> twisted_primes(200, 300) [-1] pass from solution import twisted_primes def test_twisted_primes_range_10_to_100(): assert twisted_primes(10, 100) == [13, 17, 31, 37, 71, 73, 79, 97] def test_twisted_primes_range_200_to_300(): assert twisted_primes(200, 300) == [-1] def test_twisted_primes_range_prime_reversal(): assert twisted_primes(90, 100) == [97] def test_twisted_primes_range_inclusive(): assert twisted_primes(11, 11) == [-1] def test_twisted_primes_large_range(): result = twisted_primes(1, 1000) assert 13 in result assert 103 not in result assert 929 not in result def test_twisted_primes_edge_cases(): assert twisted_primes(1, 2) == [-1]","solution":"def is_prime(n): Helper function to check if a number is a prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def twisted_primes(L, R): Returns a list of all 'Twisted Primes' in the range [L, R]. twisted_primes_list = [] for number in range(L, R + 1): if is_prime(number): reversed_number = int(str(number)[::-1]) if reversed_number != number and is_prime(reversed_number): twisted_primes_list.append(number) return twisted_primes_list if twisted_primes_list else [-1]"},{"question":"def fizz_buzz(n: int) -> List[str]: Generates a list of strings based on the FizzBuzz pattern for numbers from 1 to n. Args: n (int): The upper limit of the range starting from 1. Returns: List[str]: A list of strings based on the specified FizzBuzz rules. >>> fizz_buzz(15) ['1', '2', 'Fizz', '4', 'Buzz', 'Fizz', '7', '8', 'Fizz', 'Buzz', '11', 'Fizz', '13', '14', 'FizzBuzz'] >>> fizz_buzz(5) ['1', '2', 'Fizz', '4', 'Buzz'] >>> fizz_buzz(3) ['1', '2', 'Fizz'] >>> fizz_buzz(1) ['1'] >>> fizz_buzz(6)[-1] 'Fizz' >>> fizz_buzz(10)[-1] 'Buzz' >>> fizz_buzz(30)[-1] 'FizzBuzz' >>> fizz_buzz(7)[-1] '7'","solution":"def fizz_buzz(n): Generates a list of strings based on the FizzBuzz pattern for numbers from 1 to n. Args: n (int): The upper limit of the range starting from 1. Returns: List[str]: A list of strings based on the specified FizzBuzz rules. result = [] for i in range(1, n + 1): if i % 3 == 0 and i % 5 == 0: result.append(\\"FizzBuzz\\") elif i % 3 == 0: result.append(\\"Fizz\\") elif i % 5 == 0: result.append(\\"Buzz\\") else: result.append(str(i)) return result"},{"question":"def rearrange_array(arr): Rearranges an integer array such that all odd numbers precede all even numbers. Maintains the relative order among odd numbers and even numbers. Args: arr : list of int The input array with n distinct integers. Returns: list of int The rearranged array. >>> rearrange_array([4, 3, 2, 7, 8, 1]) [3, 7, 1, 4, 2, 8] >>> rearrange_array([1, 2, 3, 4, 5]) [1, 3, 5, 2, 4] >>> rearrange_array([1, 3, 5, 7, 9]) [1, 3, 5, 7, 9] >>> rearrange_array([2, 4, 6, 8, 10]) [2, 4, 6, 8, 10] >>> rearrange_array([11, 18, 21, 42, 33]) [11, 21, 33, 18, 42] >>> rearrange_array([7]) [7] >>> rearrange_array([4]) [4]","solution":"def rearrange_array(arr): Rearranges an integer array such that all odd numbers precede all even numbers. Maintains the relative order among odd numbers and even numbers. Args: arr : list of int The input array with n distinct integers. Returns: list of int The rearranged array. odds = [x for x in arr if x % 2 != 0] evens = [x for x in arr if x % 2 == 0] return odds + evens"},{"question":"def can_make_equal_by_one_substitution(t: int, test_cases: List[Tuple[str, str]]) -> List[str]: Determine if it is possible to make the strings equal by rearranging and performing at most one substitution. >>> can_make_equal_by_one_substitution(4, [(\\"abc\\", \\"bca\\"), (\\"aabb\\", \\"abac\\"), (\\"abc\\", \\"def\\"), (\\"abcd\\", \\"abce\\")]) ['YES', 'YES', 'NO', 'YES']","solution":"def can_make_equal_by_one_substitution(t, test_cases): results = [] for s1, s2 in test_cases: if sorted(s1) == sorted(s2): results.append(\\"YES\\") elif can_be_equal_with_one_substitution(s1, s2): results.append(\\"YES\\") else: results.append(\\"NO\\") return results def can_be_equal_with_one_substitution(s1, s2): if len(s1) != len(s2): return False counter = dict() for char in s1: if char in counter: counter[char] += 1 else: counter[char] = 1 mismatch_pairs = 0 for char in s2: if char in counter and counter[char] > 0: counter[char] -= 1 else: mismatch_pairs += 1 # Check if it's one mismatch pair a single substitution can fix return mismatch_pairs == 1 # Example usage t = 4 test_cases = [ (\\"abc\\", \\"bca\\"), (\\"aabb\\", \\"abac\\"), (\\"abc\\", \\"def\\"), (\\"abcd\\", \\"abce\\"), ] results = can_make_equal_by_one_substitution(t, test_cases) for result in results: print(result)"},{"question":"def character_frequency(s: str) -> list: Returns the frequency of each character in the given string s, excluding spaces, and preserving the order of their first occurrence. >>> character_frequency(\\"hello world\\") [('h', 1), ('e', 1), ('l', 3), ('o', 2), ('w', 1), ('r', 1), ('d', 1)] >>> character_frequency(\\"abracadabra\\") [('a', 5), ('b', 2), ('r', 2), ('c', 1), ('d', 1)] >>> character_frequency(\\"\\") [] >>> character_frequency(\\"a a a a a\\") [('a', 5)] >>> character_frequency(\\"singleCharacter\\") [('s', 1), ('i', 1), ('n', 1), ('g', 1), ('l', 1), ('e', 1), ('C', 1), ('h', 1), ('a', 2), ('r', 2), ('t', 1)] >>> character_frequency(\\"spaces in between\\") [('s', 2), ('p', 1), ('a', 1), ('c', 1), ('e', 4), ('i', 2), ('n', 3), ('b', 1), ('t', 1), ('w', 1)]","solution":"def character_frequency(s): Returns the frequency of each character in the given string s, excluding spaces, and preserving the order of their first occurrence. frequency = {} for char in s: if char != ' ': if char in frequency: frequency[char] += 1 else: frequency[char] = 1 result = [] for char in s: if char != ' ' and char in frequency: result.append((char, frequency[char])) del frequency[char] return result"},{"question":"def min_servers(T: int, test_cases: List[Tuple[int, List[int]]], K: int) -> List[int]: Determine the minimum number of servers required to ensure that all customers are served. Args: T (int): Number of test cases. test_cases (List[Tuple[int, List[int]]]): List containing tuples of (N, arrival_times) where N is the number of customers and arrival_times is the list of customer arrival times. K (int): Maximum number of customers that can be served during one hour. Returns: List[int]: List containing the minimum number of servers required for each test case. Example: >>> min_servers(2, [(5, [0, 1, 2, 3, 4]), (3, [0, 1800, 3599])], 3) [2, 1] >>> min_servers(1, [(5, [0, 1, 2, 3, 4])], 5) [1]","solution":"def min_servers(T, test_cases, K): results = [] for i in range(T): N = test_cases[i][0] arrival_times = test_cases[i][1] if N == 0: results.append(0) continue hours = {} for time in arrival_times: hour = time // 3600 if hour in hours: hours[hour] += 1 else: hours[hour] = 1 max_customers_in_hour = max(hours.values()) servers_needed = (max_customers_in_hour + K - 1) // K # Equivalent to ceiling division results.append(servers_needed) return results"},{"question":"from typing import List def combination_sum2(arr: List[int], target: int) -> List[List[int]]: Given an integer array and a target integer, find all unique combinations of numbers in the array that sum up to the target integer. Each number in the array may only be used once in the combination. Args: arr (List[int]): The list of integers. target (int): The target sum. Returns: List[List[int]]: A list of unique combinations that add up to the target sum. pass # Test Cases def test_combination_sum2_example(): arr, target = [10, 1, 2, 7, 6, 1, 5], 8 expected_output = [ [1, 1, 6], [1, 2, 5], [1, 7], [2, 6] ] result = combination_sum2(arr, target) assert sorted(result) == sorted(expected_output) def test_combination_sum2_single_element(): arr, target = [1], 1 expected_output = [[1]] assert combination_sum2(arr, target) == expected_output def test_combination_sum2_no_combinations(): arr, target = [3, 5, 7, 9], 2 expected_output = [] assert combination_sum2(arr, target) == expected_output def test_combination_sum2_multiple_combinations(): arr, target = [2, 5, 2, 1, 2], 5 expected_output = [ [1, 2, 2], [5] ] result = combination_sum2(arr, target) assert sorted(result) == sorted(expected_output) def test_combination_sum2_duplicates(): arr, target = [1, 1, 1, 1, 1, 1, 1], 3 expected_output = [ [1, 1, 1] ] assert combination_sum2(arr, target) == expected_output","solution":"def combination_sum2(arr, target): Finds unique combinations in arr that sum up to the target. arr.sort() results = [] combination = [] def backtrack(start, target): if target == 0: results.append(combination[:]) return for i in range(start, len(arr)): # Skip duplicates if i > start and arr[i] == arr[i - 1]: continue if arr[i] > target: break combination.append(arr[i]) backtrack(i + 1, target - arr[i]) combination.pop() backtrack(0, target) return results"},{"question":"from typing import List, Tuple def modify_list(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[List[int]]: You are given a list of integers. Your task is to create a new list where each element is equal to the sum of the current element and the maximum of all remaining elements in the original list. If the list is empty, return an empty list. >>> modify_list(1, [(3, [4, 5, 2])]) [[9, 10, 7]] >>> modify_list(3, [(3, [4, 5, 2]), (4, [1, 2, 3, 4]), (5, [10, 20, 30, 40, 50])]) [[9, 10, 7], [5, 6, 7, 8], [60, 70, 80, 90, 100]] >>> modify_list(1, [(0, [])]) [[]] >>> modify_list(2, [(0, []), (0, [])]) [[], []] >>> modify_list(1, [(1, [10])]) [[20]] >>> modify_list(1, [(3, [7, 7, 7])]) [[14, 14, 14]]","solution":"def modify_list(t, test_cases): result = [] for case in test_cases: n, arr = case if n == 0: result.append([]) continue max_ = max(arr) # Find the maximum of the entire list new_list = [x + max_ for x in arr] # Add the maximum to each element result.append(new_list) return result"},{"question":"def isPowerOfTwo(binary_str: str) -> bool: Given a string representation of a binary number, determine if it is a power of two. Return \`True\` if the binary representation indicates a power of two, and \`False\` otherwise. A number is a power of two if it has exactly one '1' bit in its binary representation. Examples: >>> isPowerOfTwo('10') True >>> isPowerOfTwo('1000') False >>> isPowerOfTwo('111') False >>> isPowerOfTwo('10000') True","solution":"def isPowerOfTwo(binary_str): Check if the binary representation indicates a power of two. A number is a power of two if it has exactly one '1' bit in its binary representation. return binary_str.count('1') == 1"},{"question":"from typing import List def min_hamming_distance(b: str) -> int: Calculate the minimum Hamming distance required to transform the binary string \`b\` into a new string \`c\` that only consists of alternating '0's and '1's starting with either '0' or '1'. >>> min_hamming_distance(\\"0110\\") 2 >>> min_hamming_distance(\\"101010\\") 0 >>> min_hamming_distance(\\"101100\\") 2","solution":"def min_hamming_distance(b): n = len(b) # Generate the two possible alternating patterns pattern1 = ''.join('0' if i % 2 == 0 else '1' for i in range(n)) pattern2 = ''.join('1' if i % 2 == 0 else '0' for i in range(n)) # Calculate Hamming distances dist1 = sum(b[i] != pattern1[i] for i in range(n)) dist2 = sum(b[i] != pattern2[i] for i in range(n)) return min(dist1, dist2)"},{"question":"def min_max_power(M, P): Returns the minimum possible maximum power of keys. Args: M (int): The number of keys. P (int): The sum of the powers of the keys. Returns: int: The minimum possible maximum power of keys. Examples: >>> min_max_power(2, 17) 9 >>> min_max_power(3, 20) 7 >>> min_max_power(5, 100) 20 >>> min_max_power(1, 25) 25 >>> min_max_power(10, 50) 5 >>> min_max_power(4, 99) 25 def process_test_cases(test_cases): Processes multiple test cases and returns the results. Args: test_cases (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers M and P representing the number of keys and the sum of the powers of the keys. Returns: List[int]: A list of integers representing the minimum possible value of the maximum power of the keys for each test case. Examples: >>> process_test_cases([(2, 17), (3, 20), (5, 100)]) [9, 7, 20] >>> process_test_cases([(1, 25), (10, 50), (4, 99)]) [25, 5, 25]","solution":"def min_max_power(M, P): Returns the minimum possible maximum power of keys. # Calculate the base power for each key base_power = P // M # Calculate the remainder remainder = P % M # If there is no remainder, all keys will have the same power if remainder == 0: return base_power else: # If there is a remainder, some keys will have power \`base_power + 1\` # The number of such keys is equal to the remainder return base_power + 1 def process_test_cases(test_cases): results = [] for M, P in test_cases: results.append(min_max_power(M, P)) return results"},{"question":"def longest_common_prefix(a: str, b: str) -> str: Returns the longest common prefix of two strings a and b. >>> longest_common_prefix(\\"flower\\", \\"flow\\") \\"flow\\" >>> longest_common_prefix(\\"dog\\", \\"racecar\\") \\"\\" >>> longest_common_prefix(\\"test\\", \\"testers\\") \\"test\\" >>> longest_common_prefix(\\"abcd\\", \\"ab\\") \\"ab\\" >>> longest_common_prefix(\\"same\\", \\"same\\") \\"same\\" >>> longest_common_prefix(\\"a\\", \\"ab\\") \\"a\\" >>> longest_common_prefix(\\"\\", \\"nonempty\\") \\"\\" >>> longest_common_prefix(\\"\\", \\"\\") \\"\\" >>> longest_common_prefix(\\"abcdefghijklm\\", \\"abcdefgxyz\\") \\"abcdefg\\" >>> longest_common_prefix(\\"AbcDEF\\", \\"abcDEF\\") \\"\\"","solution":"def longest_common_prefix(a, b): Returns the longest common prefix of two strings a and b. min_length = min(len(a), len(b)) for i in range(min_length): if a[i] != b[i]: return a[:i] return a[:min_length]"},{"question":"def findMaxInRange(nums, X, Y): Returns the maximum integer in the array that is less than or equal to X but greater than or equal to Y. If no such number exists, returns -1. >>> findMaxInRange([1, 3, 7, 8, 10], 9, 2) 8 >>> findMaxInRange([5, 12, 14, 20], 15, 10) 14 >>> findMaxInRange([2, 4, 6, 8], 5, 6) -1 def test_example_1(): assert findMaxInRange([1, 3, 7, 8, 10], 9, 2) == 8 def test_example_2(): assert findMaxInRange([5, 12, 14, 20], 15, 10) == 14 def test_example_3(): assert findMaxInRange([2, 4, 6, 8], 5, 6) == -1 def test_no_numbers_in_range(): assert findMaxInRange([1, 2, 3, 4], 0, 0) == -1 def test_all_numbers_in_range(): assert findMaxInRange([1, 2, 3, 4, 5], 10, 1) == 5 def test_empty_list(): assert findMaxInRange([], 5, 0) == -1 def test_single_element_in_range(): assert findMaxInRange([7], 10, 5) == 7 def test_single_element_out_of_range(): assert findMaxInRange([7], 5, 7) == -1","solution":"def findMaxInRange(nums, X, Y): Returns the maximum integer in the array that is less than or equal to X but greater than or equal to Y. If no such number exists, returns -1. max_num = -1 for num in nums: if Y <= num <= X: if num > max_num: max_num = num return max_num"},{"question":"def sort_custom_alphabet(custom_alphabet: str, words: List[str]) -> List[str]: Sort a list of words based on a custom alphabet order. :param custom_alphabet: A string containing exactly 26 unique lowercase letters. :param words: A list of strings to be sorted. :return: A list of strings sorted based on custom alphabet order. pass # Unit tests def test_sort_custom_alphabet(): custom_alphabet = \\"zyxwvutsrqponmlkjihgfedcba\\" words = [\\"apple\\", \\"banana\\", \\"cherry\\"] assert sort_custom_alphabet(custom_alphabet, words) == ['cherry', 'banana', 'apple'] def test_sort_custom_alphabet_standard_order(): custom_alphabet = \\"abcdefghijklmnopqrstuvwxyz\\" words = [\\"apple\\", \\"banana\\", \\"cherry\\"] assert sort_custom_alphabet(custom_alphabet, words) == ['apple', 'banana', 'cherry'] def test_sort_custom_alphabet_mixed_order(): custom_alphabet = \\"bacdefghijklmnopqrstuvwxy\\" words = [\\"apple\\", \\"banana\\", \\"cherry\\"] assert sort_custom_alphabet(custom_alphabet, words) == ['banana', 'apple', 'cherry'] def test_sort_custom_alphabet_single_letter(): custom_alphabet = \\"zyxwvutsrqponmlkjihgfedcba\\" words = [\\"a\\", \\"b\\", \\"c\\"] assert sort_custom_alphabet(custom_alphabet, words) == ['c', 'b', 'a'] def test_sort_custom_alphabet_longer_words(): custom_alphabet = \\"zyxwvutsrqponmlkjihgfedcba\\" words = [\\"aaaaa\\", \\"aaaab\\", \\"aaaac\\", \\"aaaad\\"] assert sort_custom_alphabet(custom_alphabet, words) == ['aaaad', 'aaaac', 'aaaab', 'aaaaa'] def test_sort_custom_alphabet_empty_words(): custom_alphabet = \\"zyxwvutsrqponmlkjihgfedcba\\" words = [] assert sort_custom_alphabet(custom_alphabet, words) == [] def test_sort_custom_alphabet_single_element(): custom_alphabet = \\"zyxwvutsrqponmlkjihgfedcba\\" words = [\\"apple\\"] assert sort_custom_alphabet(custom_alphabet, words) == [\\"apple\\"] def test_sort_custom_alphabet_duplicates(): custom_alphabet = \\"abcdefghijklmnopqrstuvwxyz\\" words = [\\"apple\\", \\"apple\\", \\"banana\\"] assert sort_custom_alphabet(custom_alphabet, words) == [\\"apple\\", \\"apple\\", \\"banana\\"]","solution":"def sort_custom_alphabet(custom_alphabet, words): Sort a list of words based on a custom alphabet order. :param custom_alphabet: A string containing exactly 26 unique lowercase letters. :param words: A list of strings to be sorted. :return: A list of strings sorted based on custom alphabet order. # Create a dictionary to map each character to its index in the custom alphabet custom_order = {char: index for index, char in enumerate(custom_alphabet)} # Function to convert each word to a tuple representing its order based on custom alphabet def convert_to_custom_order(word): return [custom_order[char] for char in word] # Sort words based on their custom order return sorted(words, key=convert_to_custom_order)"},{"question":"def can_transform(s1: str, s2: str) -> bool: Determine if s1 can be transformed into s2 by performing at most one modification. A modification is defined as an insertion, deletion, or substitution of a single character in s1. >>> can_transform(\\"pale\\", \\"ple\\") True >>> can_transform(\\"pales\\", \\"pale\\") True >>> can_transform(\\"pale\\", \\"bale\\") True >>> can_transform(\\"pale\\", \\"bake\\") False def handle_test_cases(test_cases: List[Tuple[str, str]]) -> List[str]: Handle multiple test cases for the can_transform function. >>> handle_test_cases([(\\"pale\\", \\"ple\\"), (\\"pales\\", \\"pale\\"), (\\"pale\\", \\"bale\\"), (\\"pale\\", \\"bake\\")]) [\\"Yes\\", \\"Yes\\", \\"Yes\\", \\"No\\"] from solution import can_transform, handle_test_cases def test_can_transform_insertion(): assert can_transform(\\"pale\\", \\"ple\\") == True def test_can_transform_deletion(): assert can_transform(\\"pales\\", \\"pale\\") == True def test_can_transform_substitution(): assert can_transform(\\"pale\\", \\"bale\\") == True def test_cannot_transform_multiple_changes(): assert can_transform(\\"pale\\", \\"bake\\") == False def test_transform_no_change(): assert can_transform(\\"pale\\", \\"pale\\") == True def test_transform_length_difference_more_than_1(): assert can_transform(\\"pale\\", \\"palesss\\") == False def test_handle_test_cases(): test_cases = [(\\"pale\\", \\"ple\\"), (\\"pales\\", \\"pale\\"), (\\"pale\\", \\"bale\\"), (\\"pale\\", \\"bake\\")] expected = [\\"Yes\\", \\"Yes\\", \\"Yes\\", \\"No\\"] assert handle_test_cases(test_cases) == expected","solution":"def can_transform(s1, s2): Determines if s1 can be transformed into s2 with at most one modification. len1, len2 = len(s1), len(s2) # If the length difference is more than 1, return False directly if abs(len1 - len2) > 1: return False # Now handle the edit distance of 0 or 1 modification if len1 > len2: s1, s2 = s2, s1 # Make sure s1 is always the shorter one len1, len2 = len(s1), len(s2) i, j = 0, 0 found_difference = False while i < len1 and j < len2: if s1[i] != s2[j]: if found_difference: return False found_difference = True if len1 == len2: i += 1 # If lengths are the same, move both pointers else: i += 1 j += 1 # Always move pointer for longer string return True def handle_test_cases(test_cases): results = [] for s1, s2 in test_cases: if can_transform(s1, s2): results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"def rearrange_plants(n: int, heights: List[int]) -> Union[List[int], str]: Find if it's possible to rearrange the plant heights such that no two adjacent plants have the same height. If possible, return the rearranged list of heights, otherwise return \\"Not possible\\". >>> rearrange_plants(5, [3, 1, 3, 2, 2]) [3, 1, 2, 3, 2] >>> rearrange_plants(4, [4, 4, 4, 4]) \\"Not possible\\" >>> rearrange_plants(6, [1, 2, 2, 3, 3, 4]) [2, 1, 3, 2, 3, 4]","solution":"from collections import Counter import heapq def rearrange_plants(n, heights): if n == 0: return [] # Count the frequency of each height height_counts = Counter(heights) # Max-heap for the heights based on their frequency (-frequency for max-heap) max_heap = [(-freq, height) for height, freq in height_counts.items()] heapq.heapify(max_heap) # Previous plant (initially set to None) prev_freq, prev_height = 0, None result = [] while max_heap: freq, height = heapq.heappop(max_heap) # Add the current plant to the result result.append(height) # If prev plant exists, add it back if -prev_freq > 0: heapq.heappush(max_heap, (prev_freq, prev_height)) # Update the previous plant to the current one with decreased frequency prev_freq, prev_height = freq + 1, height # If the length of the result isn't equal to n, it means we failed to rearrange if len(result) != n: return \\"Not possible\\" return result"},{"question":"import string def is_palindrome(s): Check if the given string is a palindrome, ignoring spaces, punctuation, and capitalization. Parameters: s (str): The input string to check. Returns: str: \\"Yes\\" if the string is a palindrome, otherwise \\"No\\". >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") \\"Yes\\" >>> is_palindrome(\\"This is not a palindrome\\") \\"No\\"","solution":"import string def is_palindrome(s): Check if the given string is a palindrome, ignoring spaces, punctuation, and capitalization. Parameters: s (str): The input string to check. Returns: str: \\"Yes\\" if the string is a palindrome, otherwise \\"No\\". # Remove punctuation, spaces, and convert to lowercase translator = str.maketrans('', '', string.punctuation) cleaned_str = s.translate(translator).replace(\\" \\", \\"\\").lower() # Check if the cleaned string is a palindrome return \\"Yes\\" if cleaned_str == cleaned_str[::-1] else \\"No\\""},{"question":"def prime_ranges(n): Generates a list of tuples representing ranges of consecutive prime numbers less than or equal to n. A range (tuple) is defined as the largest contiguous sequence of prime numbers where each prime number in the range is separated from the next prime number by exactly 2. Args: n (int): The upper limit integer. Returns: List[Tuple[int]]: A list of tuples containing ranges of consecutive primes. Examples: >>> prime_ranges(13) [(3, 5, 7), (11, 13)] >>> prime_ranges(20) [(3, 5, 7), (11, 13), (17, 19)] >>> prime_ranges(30) [(3, 5, 7), (11, 13), (17, 19), (29,)] from typing import List, Tuple def is_prime(n: int) -> bool: Check if a number is a prime number. pass def prime_ranges(n: int) -> List[Tuple[int]]: Returns a list of tuples representing ranges of consecutive primes less than or equal to n, where each prime number in the range is separated from the next by exactly 2. pass def test_prime_ranges_basic(): assert prime_ranges(13) == [(3, 5, 7), (11, 13)] def test_prime_ranges_up_to_20(): assert prime_ranges(20) == [(3, 5, 7), (11, 13), (17, 19)] def test_prime_ranges_up_to_30(): assert prime_ranges(30) == [(3, 5, 7), (11, 13), (17, 19), (29,)] def test_prime_ranges_no_primes(): assert prime_ranges(2) == [] def test_prime_ranges_single_prime(): assert prime_ranges(3) == [(3,)] def test_prime_ranges_no_consecutive_prime_pattern(): assert prime_ranges(10) == [(3, 5, 7)] assert prime_ranges(15) == [(3, 5, 7), (11, 13)]","solution":"def is_prime(n): Check if a number is a prime number. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def prime_ranges(n): Returns a list of tuples representing ranges of consecutive primes less than or equal to n, where each prime number in the range is separated from the next by exactly 2. primes = [p for p in range(3, n+1) if is_prime(p)] ranges = [] temp_range = [] for i in range(len(primes)): if not temp_range: temp_range.append(primes[i]) elif primes[i] - temp_range[-1] == 2: temp_range.append(primes[i]) else: if len(temp_range) > 1: ranges.append(tuple(temp_range)) temp_range = [primes[i]] if len(temp_range) > 1: ranges.append(tuple(temp_range)) elif len(temp_range) == 1: ranges.append(tuple(temp_range)) return ranges"},{"question":"from typing import List def is_score_present(teamScores: List[int], targetScore: int) -> bool: Determines if a given score is present in the list of scores for the teams. Parameters: teamScores (List[int]): List of scores of the teams. targetScore (int): The score to search in the list of team scores. Returns: bool: True if targetScore is present in teamScores, False otherwise. >>> is_score_present([23, 45, 67, 89, 12, 34], 67) True >>> is_score_present([23, 45, 67, 89, 12, 34], 50) False","solution":"from typing import List def is_score_present(teamScores: List[int], targetScore: int) -> bool: Determines if a given score is present in the list of scores for the teams. Parameters: teamScores (List[int]): List of scores of the teams. targetScore (int): The score to search in the list of team scores. Returns: bool: True if targetScore is present in teamScores, False otherwise. return targetScore in teamScores"},{"question":"from typing import List, Tuple def minimized_max_difference(heights: List[int]) -> int: Given a list of heights of students, rearranges such that the absolute difference in height between any two consecutive students is minimized. >>> minimized_max_difference([4, 2, 5]) 1 >>> minimized_max_difference([10, 1, 14, 9, 2]) 1 def process_test_cases(k: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Process multiple test cases. >>> process_test_cases(2, [(3, [4, 2, 5]), (5, [10, 1, 14, 9, 2])]) [1, 1]","solution":"def minimized_max_difference(heights): Given a list of heights of students, rearranges such that the absolute difference in height between any two consecutive students is minimized. heights.sort() max_diff = float('inf') for i in range(1, len(heights)): max_diff = min(max_diff, heights[i] - heights[i - 1]) return max_diff def process_test_cases(k, test_cases): Process multiple test cases. results = [] for i in range(k): n, heights = test_cases[i] result = minimized_max_difference(heights) results.append(result) return results"},{"question":"from typing import List def is_prime(n: int) -> bool: Returns True if n is a prime number, otherwise returns False. pass def check_primes(numbers: List[int]) -> List[str]: For each number in 'numbers' list, determine if it is prime, and return a list of strings \\"Prime\\" or \\"Not Prime\\". >>> check_primes([2, 4, 5, 9, 13]) [\\"Prime\\", \\"Not Prime\\", \\"Prime\\", \\"Not Prime\\", \\"Prime\\"] >>> check_primes([101, 102, 103, 104, 105]) [\\"Prime\\", \\"Not Prime\\", \\"Prime\\", \\"Not Prime\\", \\"Not Prime\\"] >>> check_primes([2, 3, 5, 7, 11]) [\\"Prime\\", \\"Prime\\", \\"Prime\\", \\"Prime\\", \\"Prime\\"] >>> check_primes([1, 4, 6, 8, 10]) [\\"Not Prime\\", \\"Not Prime\\", \\"Not Prime\\", \\"Not Prime\\", \\"Not Prime\\"] pass","solution":"def is_prime(n): Returns True if n is a prime number, otherwise returns False. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False sq_root = int(n**0.5) + 1 for i in range(3, sq_root, 2): if n % i == 0: return False return True def check_primes(numbers): For each number in 'numbers' list, determine if it is prime, and return a list of strings \\"Prime\\" or \\"Not Prime\\". results = [] for number in numbers: if is_prime(number): results.append(\\"Prime\\") else: results.append(\\"Not Prime\\") return results"},{"question":"def longest_non_decreasing_segment(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determines the length of the longest continuous segment of the hike where the altitude is non-decreasing. >>> longest_non_decreasing_segment(3, [(5, [1, 2, 2, 1, 2]), (3, [3, 3, 3]), (4, [4, 3, 2, 3])]) [3, 3, 2] >>> longest_non_decreasing_segment(1, [(6, [1, 2, 2, 3, 4, 5])]) [6] >>> longest_non_decreasing_segment(2, [(3, [1, 2, 1]), (5, [5, 4, 3, 2, 1])]) [2, 1] >>> longest_non_decreasing_segment(1, [(1, [42])]) [1] >>> longest_non_decreasing_segment(1, [(3, [10, -1, -2])]) [1]","solution":"def longest_non_decreasing_segment(t, test_cases): results = [] for _ in range(t): n = test_cases[_][0] altitudes = test_cases[_][1] if n == 0: results.append(0) continue max_length = 1 current_length = 1 for i in range(1, n): if altitudes[i] >= altitudes[i-1]: current_length += 1 else: if current_length > max_length: max_length = current_length current_length = 1 if current_length > max_length: max_length = current_length results.append(max_length) return results"},{"question":"def longest_contiguous_subarray(A): Returns the length of the longest contiguous subarray with the same element. Parameters: A (list): A list of integers. Returns: int: The length of the longest contiguous subarray. Examples: >>> longest_contiguous_subarray([2, 2, 2, 3, 3]) 3 >>> longest_contiguous_subarray([5]) 1 >>> longest_contiguous_subarray([4, 4, 4, 4]) 4 >>> longest_contiguous_subarray([1, 2, 3, 4, 5]) 1 # Your code here # Unit Tests def test_example_case(): assert longest_contiguous_subarray([2, 2, 2, 3, 3]) == 3 def test_single_element(): assert longest_contiguous_subarray([5]) == 1 def test_all_same_elements(): assert longest_contiguous_subarray([4, 4, 4, 4]) == 4 def test_no_repeats(): assert longest_contiguous_subarray([1, 2, 3, 4, 5]) == 1 def test_multiple_equal_length_subarrays(): assert longest_contiguous_subarray([1, 1, 2, 2, 3, 3]) == 2 def test_long_array(): assert longest_contiguous_subarray([1] * 500 + [2] * 500) == 500 def test_empty_array(): assert longest_contiguous_subarray([]) == 0 def test_subarray_at_end(): assert longest_contiguous_subarray([1, 2, 2, 2]) == 3","solution":"def longest_contiguous_subarray(A): Returns the length of the longest contiguous subarray with the same element. if not A: return 0 max_length = 1 current_length = 1 for i in range(1, len(A)): if A[i] == A[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length # Example usage # N = 5 # A = [2, 2, 2, 3, 3] # print(longest_contiguous_subarray(A)) # Output: 3"},{"question":"def encrypt_message(k: int, s: str) -> str: Encrypts the message s by shifting each letter k positions in the alphabet. Args: k (int): The fixed number of positions each letter is shifted (1 ≤ k ≤ 25). s (str): The plaintext message consisting of uppercase letters 'A'-'Z'. Returns: str: The encrypted message. Examples: >>> encrypt_message(3, \\"HELLO\\") \\"KHOOR\\" >>> encrypt_message(1, \\"ZEBRA\\") \\"AFCSB\\"","solution":"def encrypt_message(k, s): Encrypts the message s by shifting each letter k positions in the alphabet. result = [] for char in s: # Calculate the new character by shifting k positions new_char = chr((ord(char) - ord('A') + k) % 26 + ord('A')) result.append(new_char) return ''.join(result)"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest contiguous substring of \`s\` without repeating characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"\\") 0 >>> length_of_longest_substring(\\"a\\") 1 >>> length_of_longest_substring(\\"abcd\\") 4 >>> length_of_longest_substring(\\"aabca\\") 3","solution":"def length_of_longest_substring(s): Returns the length of the longest substring of \`s\` without repeating characters. char_index = {} longest = 0 start = 0 for i, char in enumerate(s): if char in char_index and char_index[char] >= start: start = char_index[char] + 1 char_index[char] = i longest = max(longest, i - start + 1) return longest"},{"question":"def two_sum(nums, target): Returns the indices of the two numbers in the list that add up to the target. If no such pair exists, return an empty list. If there are multiple pairs, return the pair with the smallest indices. Examples: >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([3, 2, 4], 6) [1, 2] >>> two_sum([3, 3], 6) [0, 1] >>> two_sum([1, 2, 3], 7) [] pass","solution":"def two_sum(nums, target): Returns the indices of the two numbers in the list that add up to the target. If no such pair exists, return an empty list. If there are multiple pairs, return the pair with the smallest indices. num_to_index = {} for index, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], index] num_to_index[num] = index return []"},{"question":"def find_and_replace(text: str, target: str, replacement: str) -> str: Replaces all standalone occurrences of the target word in text with the replacement word. >>> find_and_replace(\\"The cat sat on the catwalk\\", \\"cat\\", \\"dog\\") \\"The dog sat on the catwalk\\" >>> find_and_replace(\\"The quick brown fox jumps over the lazy dog\\", \\"jumps\\", \\"leaps\\") \\"The quick brown fox leaps over the lazy dog\\" >>> find_and_replace(\\"concatenate category cat\\", \\"cat\\", \\"pet\\") \\"concatenate category pet\\"","solution":"def find_and_replace(text: str, target: str, replacement: str) -> str: Replaces all standalone occurrences of the target word in text with the replacement word. words = text.split() for i in range(len(words)): if words[i] == target: words[i] = replacement return ' '.join(words)"},{"question":"def removeConsecutiveDuplicates(S: str) -> str: Removes consecutive duplicate characters from the string S and returns the new string. >>> removeConsecutiveDuplicates(\\"aaabbaaccd\\") \\"abacd\\" >>> removeConsecutiveDuplicates(\\"aabbcc\\") \\"abc\\" >>> removeConsecutiveDuplicates(\\"a\\") \\"a\\" >>> removeConsecutiveDuplicates(\\"abcdef\\") \\"abcdef\\" >>> removeConsecutiveDuplicates(\\"aaaaaa\\") \\"a\\" >>> removeConsecutiveDuplicates(\\"\\") \\"\\" >>> removeConsecutiveDuplicates(\\"ababababab\\") \\"ababababab\\"","solution":"def removeConsecutiveDuplicates(S): Removes consecutive duplicate characters from the string S and returns the new string. if not S: return S result = [S[0]] for char in S[1:]: if char != result[-1]: result.append(char) return ''.join(result)"},{"question":"def max_gadgets_per_minute(N: int, speeds: List[int]) -> int: Returns the maximum number of gadgets that can be produced in one minute given the constraints. Parameters: N (int): The number of machines. speeds (List[int]): List of machines' speeds. Returns: int: Maximum number of gadgets that can be produced in one minute. >>> max_gadgets_per_minute(5, [3, 1, 5, 7, 4]) 20 >>> max_gadgets_per_minute(6, [6, 3, 8, 2, 9, 5]) 33","solution":"def max_gadgets_per_minute(N, speeds): Returns the maximum number of gadgets that can be produced in one minute given the constraints. Parameters: N (int): The number of machines. speeds (List[int]): List of machines' speeds. Returns: int: Maximum number of gadgets that can be produced in one minute. # Sort the speeds in descending order so we can easily pick the k smallest values speeds.sort(reverse=True) # Find the sum of all speeds since each speed represents gadgets produced per minute total_gadgets = sum(speeds) return total_gadgets # Example usage # N = int(input()) # speeds = list(map(int, input().split())) # print(max_gadgets_per_minute(N, speeds))"},{"question":"def evalRPN(tokens: List[str]) -> int: Evaluate a given RPN (Reverse Polish Notation) expression and return the result. >>> evalRPN([\\"2\\", \\"1\\", \\"+\\", \\"3\\", \\"*\\"]) 9 >>> evalRPN([\\"4\\", \\"13\\", \\"5\\", \\"/\\", \\"+\\"]) 6 >>> evalRPN([\\"10\\", \\"6\\", \\"9\\", \\"3\\", \\"+\\", \\"-11\\", \\"*\\", \\"/\\", \\"*\\", \\"17\\", \\"+\\", \\"5\\", \\"+\\"]) 22 >>> evalRPN([\\"42\\"]) 42 >>> evalRPN([\\"3\\", \\"4\\", \\"+\\", \\"2\\", \\"*\\", \\"7\\", \\"/\\"]) 2 >>> evalRPN([\\"3\\", \\"4\\", \\"-\\"]) -1 >>> evalRPN([\\"5\\", \\"1\\", \\"2\\", \\"+\\", \\"4\\", \\"*\\", \\"+\\", \\"3\\", \\"-\\"]) 14 >>> evalRPN([\\"10\\", \\"3\\", \\"/\\"]) 3 >>> evalRPN([\\"10\\", \\"-3\\", \\"/\\"]) -3 >>> evalRPN([\\"-10\\", \\"3\\", \\"/\\"]) -3 >>> evalRPN([\\"-10\\", \\"-3\\", \\"/\\"]) 3","solution":"def evalRPN(tokens): Evaluates a given RPN (Reverse Polish Notation) expression and returns the result. :param tokens: List of strings representing the RPN expression :return: Integer result of the RPN expression stack = [] for token in tokens: if token in \\"+-*/\\": b = stack.pop() a = stack.pop() if token == '+': result = a + b elif token == '-': result = a - b elif token == '*': result = a * b elif token == '/': # Ensure integer division truncates towards zero (Python 3's // operator with int cast) result = int(a / b) stack.append(result) else: stack.append(int(token)) return stack[0] # Example usage: # print(evalRPN([\\"2\\", \\"1\\", \\"+\\", \\"3\\", \\"*\\"])) # Output should be 9"},{"question":"def longest_substring_no_star(s: str) -> int: Given a string s, this function returns the length of the longest substring which contains no '*' characters. >>> longest_substring_no_star('abc*defg*h') 4 >>> longest_substring_no_star('hello*world') 5 >>> longest_substring_no_star('****') 0 >>> longest_substring_no_star('abcdef') 6 >>> longest_substring_no_star('*a*b*c*') 1 >>> longest_substring_no_star('a') 1 >>> longest_substring_no_star('a*b*c*d*') 1 >>> longest_substring_no_star('a***b*****c******') 1 def process_test_cases(test_cases: List[str]) -> List[int]: Given a list of test cases, this function processes each test case and returns a list of results for the length of the longest substring which contains no '*' >>> process_test_cases([\\"abc*defg*h\\", \\"hello*world\\"]) [4, 5] >>> process_test_cases([\\"****\\", \\"abcdef\\", \\"*a*b*c*\\"]) [0, 6, 1] >>> process_test_cases([\\"a\\", \\"a*b*c*d*\\"]) [1, 1] >>> process_test_cases([\\"a***b*****c******\\"]) [1]","solution":"def longest_substring_no_star(s): Given a string s, this function returns the length of the longest substring which contains no '*' characters. max_length = 0 current_length = 0 for char in s: if char == '*': if current_length > max_length: max_length = current_length current_length = 0 else: current_length += 1 # Final check in case the longest substring is at the end of the string return max(max_length, current_length) def process_test_cases(test_cases): results = [] for s in test_cases: results.append(longest_substring_no_star(s)) return results"},{"question":"def count_unique_rock_types(N: int, initial_rocks: List[int], Q: int, queries: List[Tuple[int, int]]) -> List[int]: Given an array of N integers representing the initial types of rocks and Q queries, each query contains an integer X representing the unique type of the newly inserted rock and an integer P representing the position (1-indexed) where the new rock will be inserted. This function returns a list of integers representing the number of unique types of rocks in the collection after each insertion. Parameters: N (int): Number of initial rocks. initial_rocks (List[int]): Types of the initial rocks. Q (int): Number of queries. queries (List[Tuple[int, int]]): Each query contains two integers X and P. Returns: List[int]: Number of unique rock types after each query. >>> count_unique_rock_types(5, [1, 2, 3, 4, 5], 3, [(6, 3), (2, 1), (7, 6)]) [6, 5, 6] >>> count_unique_rock_types(4, [1, 2, 3, 4], 2, [(3, 3), (4, 1)]) [4, 4]","solution":"def count_unique_rock_types(N, initial_rocks, Q, queries): results = [] for x, p in queries: current_collection = initial_rocks[:p-1] + [x] + initial_rocks[p-1:] unique_rock_types = len(set(current_collection)) results.append(unique_rock_types) return results"},{"question":"def rotate_grid_90_degrees_clockwise(grid): Rotates the given n x n grid 90 degrees clockwise. :param grid: List of lists of integers representing the grid. :return: Rotated grid as a list of lists of integers. Examples: >>> rotate_grid_90_degrees_clockwise([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] >>> rotate_grid_90_degrees_clockwise([ ... [1, 2], ... [3, 4] ... ]) [ [3, 1], [4, 2] ] >>> rotate_grid_90_degrees_clockwise([[1]]) [[1]] >>> rotate_grid_90_degrees_clockwise([ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16] ... ]) [ [13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4] ]","solution":"def rotate_grid_90_degrees_clockwise(grid): Rotates the given n x n grid 90 degrees clockwise. :param grid: List of lists of integers representing the grid. :return: Rotated grid as a list of lists of integers. n = len(grid) # Create a new grid with the same dimensions but rotated rotated_grid = [[0 for _ in range(n)] for _ in range(n)] for i in range(n): for j in range(n): rotated_grid[j][n-1-i] = grid[i][j] return rotated_grid"},{"question":"def can_form_alliances(N, D, villages): Determine if it is possible to form alliances so that all villages meet their target contributions. >>> can_form_alliances(4, 10, [(5, 7), (10, 12), (3, 2), (8, 6)]) \\"YES\\" >>> can_form_alliances(3, 5, [(4, 2), (10, 3), (6, 1)]) \\"NO\\" from solution import can_form_alliances def test_example1(): assert can_form_alliances(4, 10, [(5, 7), (10, 12), (3, 2), (8, 6)]) == \\"YES\\" def test_example2(): assert can_form_alliances(3, 5, [(4, 2), (10, 3), (6, 1)]) == \\"NO\\" def test_no_alliance_case(): assert can_form_alliances(3, 1, [(5, 5), (8, 8), (1, 1)]) == \\"NO\\" def test_optimal_alliance_case(): assert can_form_alliances(4, 5, [(6, 5), (5, 6), (2, 1), (1, 2)]) == \\"YES\\" def test_edge_case(): assert can_form_alliances(2, 1, [(1, 1), (2, 2)]) == \\"YES\\" def test_large_resource_case(): assert can_form_alliances(2, 1000000000, [(1000000000, 999999999), (999999999, 1000000000)]) == \\"YES\\" def test_insufficient_resource_case(): assert can_form_alliances(2, 5, [(10, 2), (10, 2)]) == \\"NO\\"","solution":"def can_form_alliances(N, D, villages): villages.sort(key=lambda x: x[1]) # Sort by resources i = 0 while i < N: # Find the pair with the smallest resource sufficient paired = False for j in range(i + 1, N): if abs(villages[i][1] - villages[j][1]) <= D: if villages[i][1] + villages[j][1] >= villages[i][0] + villages[j][0]: paired = True break if not paired: return \\"NO\\" i += 2 # Move to the next pair return \\"YES\\""},{"question":"def max_friends_attend_concert(n: int, m: int, arr: List[int], prices: List[int]) -> int: Finds the maximum number of friends that can attend the concert by purchasing tickets they can afford. n: int - Number of friends m: int - Number of different ticket prices arr: list of int - The amount of money each friend has prices: list of int - The different ticket prices available return: int - The maximum number of friends that can attend the concert >>> max_friends_attend_concert(5, 3, [20, 15, 30, 10, 50], [10, 25, 50]) 3 >>> max_friends_attend_concert(3, 2, [5, 10, 15], [10, 20]) 1 >>> max_friends_attend_concert(3, 3, [1, 1, 1], [1, 2, 3]) 1 >>> max_friends_attend_concert(4, 5, [10, 20, 30, 40], [5, 10, 20, 30, 40]) 4 >>> max_friends_attend_concert(2, 2, [100, 200], [150, 50]) 2 >>> max_friends_attend_concert(5, 5, [10, 20, 30, 40, 50], [5, 15, 25, 35, 45]) 5 >>> max_friends_attend_concert(4, 3, [5, 5, 5, 5], [5, 10, 15]) 1 pass # Your implementation here","solution":"def max_friends_attend_concert(n, m, arr, prices): Finds the maximum number of friends that can attend the concert by purchasing tickets they can afford. n: int - Number of friends m: int - Number of different ticket prices arr: list of int - The amount of money each friend has prices: list of int - The different ticket prices available return: int - The maximum number of friends that can attend the concert arr.sort() prices.sort() i, j, count = 0, 0, 0 while i < n and j < m: if arr[i] >= prices[j]: count += 1 j += 1 i += 1 return count"},{"question":"from typing import List, Dict def evaluate_department_performance(reviews: List[Dict[str, int]]) -> str: Calculate the overall performance score for a department based on weighted review scores. Each department provides an array of review objects that include 'work_quality', 'teamwork', and 'deadline_adherence', each rated out of 10. The composite score is computed as a weighted average: - 'work_quality' contributes 50% of the total score. - 'teamwork' contributes 30% of the total score. - 'deadline_adherence' contributes 20% of the total score. The function should return a message based on the overall performance score: - If the score is 8 or above, return \\"Outstanding Performance\\". - If the score is between 6 and 8 (excluding 8), return \\"Meeting Expectations\\". - If the score is below 6, return \\"Needs Improvement\\". Examples: >>> reviews = [ ... {'work_quality': 7, 'teamwork': 6, 'deadline_adherence': 5}, ... {'work_quality': 9, 'teamwork': 8, 'deadline_adherence': 7}, ... {'work_quality': 6, 'teamwork': 7, 'deadline_adherence': 6}, ... ] >>> evaluate_department_performance(reviews) \\"Meeting Expectations\\" >>> reviews = [ ... {'work_quality': 5, 'teamwork': 5, 'deadline_adherence': 5}, ... {'work_quality': 4, 'teamwork': 5, 'deadline_adherence': 3}, ... {'work_quality': 6, 'teamwork': 6, 'deadline_adherence': 7}, ... ] >>> evaluate_department_performance(reviews) \\"Needs Improvement\\" >>> reviews = [ ... {'work_quality': 9, 'teamwork': 8, 'deadline_adherence': 9}, ... {'work_quality': 8, 'teamwork': 8, 'deadline_adherence': 7}, ... {'work_quality': 10, 'teamwork': 9, 'deadline_adherence': 8}, ... ] >>> evaluate_department_performance(reviews) \\"Outstanding Performance\\"","solution":"from typing import List, Dict def evaluate_department_performance(reviews: List[Dict[str, int]]) -> str: total_work_quality = total_teamwork = total_deadline_adherence = 0 for review in reviews: total_work_quality += review['work_quality'] total_teamwork += review['teamwork'] total_deadline_adherence += review['deadline_adherence'] num_reviews = len(reviews) avg_work_quality = total_work_quality / num_reviews avg_teamwork = total_teamwork / num_reviews avg_deadline_adherence = total_deadline_adherence / num_reviews composite_score = (avg_work_quality * 0.5) + (avg_teamwork * 0.3) + (avg_deadline_adherence * 0.2) if composite_score >= 8: return \\"Outstanding Performance\\" elif 6 <= composite_score < 8: return \\"Meeting Expectations\\" else: return \\"Needs Improvement\\""},{"question":"def rotate_list(array: List[int], k: int) -> List[int]: Rotates the list of integers to the right by k steps. >>> rotate_list([1, 2, 3, 4, 5, 6, 7], 3) [5, 6, 7, 1, 2, 3, 4] >>> rotate_list([-1, -100, 3, 99], 2) [3, 99, -1, -100] >>> rotate_list([1, 2, 3, 4, 5], 0) [1, 2, 3, 4, 5] >>> rotate_list([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5] >>> rotate_list([1, 2, 3, 4, 5], 7) [4, 5, 1, 2, 3] >>> rotate_list([1], 3) [1]","solution":"def rotate_list(array, k): Rotates the list to the right by k steps. Parameters: array (list): The list of integers to be rotated. k (int): The number of steps to rotate the list by. Returns: list: The rotated list. n = len(array) k = k % n # To handle cases where k > n return array[-k:] + array[:-k]"},{"question":"def longest_like_streak(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the longest sequence of consecutive likes for each test case. The function takes the number of test cases and the test case data as input, and returns a list of results. Each result represents the maximum number of consecutive likes (1s) in the respective test case. :param T: Number of test cases. :param test_cases: A list of tuples, where each tuple contains an integer N (number of actions) and a list of integers (user actions). :return: A list of integers representing the maximum number of consecutive likes for each test case. Example: >>> longest_like_streak(3, [(8, [1, 1, -1, 1, 1, 1, -1, 1]), (5, [1, 1, -1, -1, 1]), (6, [-1, 1, 1, -1, 1, 1])]) [3, 2, 2]","solution":"def longest_like_streak(T, test_cases): results = [] for case in test_cases: N, actions = case max_streak = current_streak = 0 for action in actions: if action == 1: current_streak += 1 max_streak = max(max_streak, current_streak) else: current_streak = 0 results.append(max_streak) return results"},{"question":"def is_balanced(s: str) -> bool: Write a function that verifies if a given string contains balanced parentheses, curly braces, and square brackets. The string may contain other characters, which should be ignored. The function should return a boolean value — True if the input string is balanced and False otherwise. >>> is_balanced(\\"()\\") True >>> is_balanced(\\"(}\\") False >>> is_balanced(\\"[()]{}\\") True >>> is_balanced(\\"[({)]\\") False >>> is_balanced(\\"Hello, [this is (a {sample})]\\") True >>> is_balanced(\\"Unbalanced, [ this (will] not [work) properly\\") False","solution":"def is_balanced(s): Returns True if the string contains balanced parentheses (), curly braces {}, and square brackets []. Otherwise, returns False. stack = [] matching_brackets = {')': '(', '}': '{', ']': '['} for char in s: if char in matching_brackets.values(): stack.append(char) elif char in matching_brackets.keys(): if stack == [] or matching_brackets[char] != stack.pop(): return False return stack == []"},{"question":"def total_hours_worked(log_entries: List[str]) -> int: Calculate the total number of hours worked in the month from the log entries. >>> total_hours_worked([\\"2023-09-01 09:00-17:00\\", \\"2023-09-01 18:00-20:00\\", \\"2023-09-02 10:00-12:00\\", \\"2023-09-03 13:00-15:00\\", \\"2023-09-03 16:00-18:00\\"]) 12 >>> total_hours_worked([\\"2023-10-15 14:00-16:00\\", \\"2023-10-15 09:00-12:00\\", \\"2023-10-15 18:00-22:00\\"]) 9 >>> total_hours_worked([\\"2023-09-01 09:00-09:00\\", \\"2023-09-01 10:00-10:00\\"]) 0 >>> total_hours_worked([]) 0 >>> total_hours_worked([\\"2023-09-30 22:00-23:00\\", \\"2023-10-01 01:00-02:00\\"]) 2","solution":"def total_hours_worked(log_entries): from datetime import datetime total_hours = 0 for entry in log_entries: date, times = entry.split() start_time, end_time = times.split('-') start_dt = datetime.strptime(f\\"{date} {start_time}\\", \\"%Y-%m-%d %H:%M\\") end_dt = datetime.strptime(f\\"{date} {end_time}\\", \\"%Y-%m-%d %H:%M\\") duration = end_dt - start_dt hours = duration.seconds // 3600 total_hours += hours return total_hours"},{"question":"def min_travel_cost(T: int, test_cases: List[Tuple[int, List[List[int]]]]) -> List[int]: Determine the minimum travel cost to visit all cities starting and ending at city 1. Args: T: Number of test cases. test_cases: A list containing T elements, each being a tuple where the first element is N (number of cities) and the second element is the cost matrix (2D list) of size N x N representing travel costs between cities. Returns: A list of integers where each integer is the minimum travel cost for the corresponding test case. Example: >>> min_travel_cost(1, [ ... (4, [ ... [0, 10, 15, 20], ... [10, 0, 35, 25], ... [15, 35, 0, 30], ... [20, 25, 30, 0] ... ]) ... ]) [80] >>> min_travel_cost(2, [ ... (4, [ ... [0, 10, 15, 20], ... [10, 0, 35, 25], ... [15, 35, 0, 30], ... [20, 25, 30, 0] ... ]), ... (3, [ ... [0, 1, 15], ... [1, 0, 6], ... [15, 6, 0] ... ]) ... ]) [80, 22] pass","solution":"def tsp(cost): Solve the TSP problem using dynamic programming with bit masking. import itertools N = len(cost) # Number of cities dp = [[float('inf')] * N for _ in range(1 << N)] dp[1][0] = 0 # Starting at city 1 with only city 1 visited for visited in range(1 << N): for last in range(N): if visited & (1 << last): for next in range(N): if not visited & (1 << next): dp[visited | (1 << next)][next] = min(dp[visited | (1 << next)][next], dp[visited][last] + cost[last][next]) return min(dp[(1 << N) - 1][i] + cost[i][0] for i in range(1, N)) def min_travel_cost(T, test_cases): results = [] for test in test_cases: N = test[0] cost = test[1] results.append(tsp(cost)) return results"},{"question":"from typing import List from collections import Counter def find_shuffled_substrings(s: str, t: str) -> List[int]: Finds the starting indices of all substrings in \`s\` that are valid shuffled substrings of \`t\`. :param s: input string where to search for the substrings :param t: the reference string whose characters must be present in the substrings :return: list of starting indices of valid shuffled substrings, or [-1] if none are found >>> find_shuffled_substrings(\\"cbabcacab\\", \\"abc\\") [0, 2, 3, 6] >>> find_shuffled_substrings(\\"abcdef\\", \\"ghij\\") [-1]","solution":"from collections import Counter def find_shuffled_substrings(s, t): Finds the starting indices of all substrings in \`s\` that are valid shuffled substrings of \`t\`. :param s: input string where to search for the substrings :param t: the reference string whose characters must be present in the substrings :return: list of starting indices of valid shuffled substrings, or [-1] if none are found len_s = len(s) len_t = len(t) if len_t > len_s: return [-1] # Create a counter for the characters in t t_counter = Counter(t) window_counter = Counter(s[:len_t]) result = [] for i in range(len_s - len_t + 1): if i > 0: # Slide the window start_char = s[i - 1] end_char = s[i + len_t - 1] window_counter[start_char] -= 1 if window_counter[start_char] == 0: del window_counter[start_char] window_counter[end_char] += 1 # If window matches t's character counts, record the start index if window_counter == t_counter: result.append(i) if not result: return [-1] return result"},{"question":"def min_removals_to_palindrome(s: str) -> int: Returns the minimum number of characters to remove to make the given string a palindrome. >>> min_removals_to_palindrome(\\"abb\\") == 1 >>> min_removals_to_palindrome(\\"abc\\") == 2 pass def process_input(input_data: str) -> str: Processes the input, executes the min_removals_to_palindrome function for each test case, and returns the results as a formatted string. >>> process_input(\\"2nabbnabc\\") == \\"1n2\\" >>> process_input(\\"3nanabnabba\\") == \\"0n1n0\\" pass","solution":"def min_removals_to_palindrome(s): Returns the minimum number of characters to remove to make the given string a palindrome. n = len(s) dp = [[0] * n for _ in range(n)] for gap in range(1, n): for l in range(n - gap): r = l + gap if s[l] == s[r]: dp[l][r] = dp[l + 1][r - 1] else: dp[l][r] = 1 + min(dp[l + 1][r], dp[l][r - 1]) return dp[0][n - 1] def process_input(input_data): input_lines = input_data.split(\\"n\\") T = int(input_lines[0]) results = [] for i in range(1, T + 1): results.append(str(min_removals_to_palindrome(input_lines[i]))) return \\"n\\".join(results)"},{"question":"def isPalindrome(num: int) -> bool: Checks whether a given integer is a palindrome without converting it to a string. >>> isPalindrome(12321) # should return True >>> isPalindrome(12345) # should return False pass from isPalindrome import isPalindrome def test_single_digit_palindrome(): assert isPalindrome(0) == True assert isPalindrome(1) == True assert isPalindrome(9) == True def test_double_digit_palindrome(): assert isPalindrome(11) == True assert isPalindrome(22) == True assert isPalindrome(99) == True def test_double_digit_non_palindrome(): assert isPalindrome(10) == False assert isPalindrome(21) == False assert isPalindrome(98) == False def test_multiple_digit_palindrome(): assert isPalindrome(101) == True assert isPalindrome(1221) == True assert isPalindrome(12321) == True def test_multiple_digit_non_palindrome(): assert isPalindrome(123) == False assert isPalindrome(1234) == False assert isPalindrome(12345) == False def test_large_palindrome(): assert isPalindrome(123454321) == True def test_large_non_palindrome(): assert isPalindrome(987654321) == False","solution":"def isPalindrome(num): Returns True if the input integer is a palindrome, otherwise False. # Attempt to early exit for simple cases if num < 0: return False if num == 0: return True # Compute the reversed number and compare with the original original = num reversed_num = 0 while num > 0: remainder = num % 10 reversed_num = reversed_num * 10 + remainder num = num // 10 return original == reversed_num"},{"question":"def min_coins(coins: List[int], amount: int) -> int: Determine the minimum number of coins needed to make up the given amount with the given denominations. If it is not possible, return -1. >>> min_coins([1, 2, 5, 11], 3) 2 >>> min_coins([2, 4, 5], 11) 3 >>> min_coins([2, 3, 7], 13) 3","solution":"def min_coins(coins, amount): Determine the minimum number of coins needed to make up the given amount with the given denominations. If it is not possible, return -1. # Initialize DP table with infinity values signifying amount cannot be reached dp = [float('inf')] * (amount + 1) dp[0] = 0 # Zero coins are needed to make amount zero for coin in coins: for x in range(coin, amount + 1): dp[x] = min(dp[x], dp[x - coin] + 1) return dp[amount] if dp[amount] != float('inf') else -1"},{"question":"def find_single_number(nums): Returns the number that appears only once in the array. >>> find_single_number([2, 2, 1]) 1 >>> find_single_number([4, 1, 2, 1, 2]) 4 def solve_single_number_problem(test_cases): Given a list of test cases, each containing an array of integers where every element appears twice except for one, this function returns a list of integers, each representing the number that appears only once in the corresponding test case. >>> solve_single_number_problem([[2, 2, 1], [4, 1, 2, 1, 2]]) [1, 4] >>> solve_single_number_problem([[1, 1, 2, 2, 3], [10, 10, 20, 30, 30]]) [3, 20]","solution":"def find_single_number(nums): Returns the number that appears only once in the array. xor_sum = 0 for num in nums: xor_sum ^= num return xor_sum def solve_single_number_problem(test_cases): results = [] for nums in test_cases: results.append(find_single_number(nums)) return results"},{"question":"def redistribute_items(t: int, test_cases: List[Tuple[int, List[str]]]) -> List[Union[List[str], str]]: Write a function to determine if it's possible to redistribute the items such that no friend receives one of their own initial items. If the redistribution is possible, return one possible way of doing the exchange. Otherwise, return an empty string. Parameters: t (int): Number of test cases. test_cases (list of tuples): Each tuple contains an integer n and a list of n strings, each string representing the items a friend brought. Returns: list: A list of lists where each sublist represents a possible redistribution of items for the respective test case. # Example usage t = 2 test_cases = [ (3, ['abc', 'def', 'ghi']), (3, ['a', 'b', 'c']) ]","solution":"def redistribute_items(t, test_cases): Function to redistribute items such that no friend receives an item they initially brought. Parameters: t (int): Number of test cases. test_cases (list of tuples): Each tuple contains an integer n and a list of n strings, each string representing the items a friend brought. Returns: list: A list of lists where each sublist represents a possible redistribution of items for the respective test case. from random import shuffle results = [] for n, friends in test_cases: friends_items = [set(friend) for friend in friends] all_items = set() for items in friends: all_items.update(items) if len(all_items) < n: results.append(\\"\\") continue all_items = list(all_items) # Attempt to find a valid redistribution for _ in range(100): # Trying multiple times to shuffle and find a valid distribution shuffle(all_items) valid_distribution = True distribution = [] for i in range(n): if all_items[i] in friends_items[i]: valid_distribution = False break distribution.append(all_items[i]) if valid_distribution: results.append(distribution) break else: results.append(\\"\\") return results # Example usage t = 2 test_cases = [ (3, ['abc', 'def', 'ghi']), (3, ['a', 'b', 'c']) ] print(redistribute_items(t, test_cases))"},{"question":"def has_pair_with_sum(arr, target): Determines if there is a pair of numbers in the list \`arr\` that sum up to \`target\`. Parameters: arr (list of int): The list of integers to check. target (int): The target sum to find in the list. Returns: bool: True if there is a pair it numbers that sum up to target, otherwise False. Examples: >>> has_pair_with_sum([1, 2, 3, 9], 8) False >>> has_pair_with_sum([1, 2, 4, 4], 8) True","solution":"def has_pair_with_sum(arr, target): Determines if there is a pair of numbers in the list \`arr\` that sum up to \`target\`. Parameters: arr (list of int): The list of integers to check. target (int): The target sum to find in the list. Returns: bool: True if there is a pair of numbers that sum up to target, otherwise False. seen = set() for num in arr: complement = target - num if complement in seen: return True seen.add(num) return False"},{"question":"def minimum_absolute_difference(n: int, items: List[int]) -> int: Find the minimum possible absolute difference between the sums of two groups of items. Given a number of items and their values, partition them into two groups such that the absolute difference between the sums of the two groups is minimized. Args: n: int - the number of items items: List[int] - values of the items Returns: int - the minimum possible absolute difference between the sums of the two groups Examples: >>> minimum_absolute_difference(4, [1, 6, 11, 5]) 1 >>> minimum_absolute_difference(3, [1, 2, 3]) 0 def solve(test_cases: List[Tuple[int, List[int]]]) -> List[int]: For each test case, finds the minimum possible absolute difference between the sums of two groups of items. Args: test_cases: List[Tuple[int, List[int]]] - list of test cases with number of items and their values Returns: List[int] - list of results for each test case Examples: >>> solve([(4, [1, 6, 11, 5]), (3, [1, 2, 3]), (5, [10, 20, 30, 40, 50])]) [1, 0, 10]","solution":"def minimum_absolute_difference(n, items): total_sum = sum(items) target = total_sum // 2 dp = [[False] * (target + 1) for _ in range(n + 1)] dp[0][0] = True for i in range(1, n+1): for j in range(target + 1): dp[i][j] = dp[i-1][j] if j >= items[i-1]: dp[i][j] = dp[i][j] or dp[i-1][j - items[i-1]] for j in range(target, -1, -1): if dp[n][j]: return abs(total_sum - 2 * j) def solve(test_cases): results = [] for n, items in test_cases: results.append(minimum_absolute_difference(n, items)) return results"},{"question":"def largest_rectangle_area(hist_list): Calculate the largest rectangular area in a histogram. >>> largest_rectangle_area([6, 2, 5, 4, 5, 1, 6]) 12 >>> largest_rectangle_area([2, 4, 6, 8]) 12 pass def largest_rectangle_in_histogram(test_cases): Calculate the largest rectangular area for multiple test cases. >>> largest_rectangle_in_histogram([[6, 2, 5, 4, 5, 1, 6], [2, 4, 6, 8]]) [12, 12] >>> largest_rectangle_in_histogram([[1, 2, 3, 4, 5], [5, 4, 3, 2, 1]]) [9, 9] pass","solution":"def largest_rectangle_area(hist): stack = [] max_area = 0 index = 0 while index < len(hist): if not stack or hist[index] >= hist[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (hist[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (hist[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area def largest_rectangle_in_histogram(test_cases): results = [] for buildings in test_cases: results.append(largest_rectangle_area(buildings)) return results"},{"question":"class Stack: A class used to represent a Stack Methods ------- push(element): Adds an element to the top of the stack. pop(): Removes the top element from the stack and returns it. If the stack is empty, returns \\"Stack is empty\\". peek(): Returns the top element of the stack without removing it. If the stack is empty, returns \\"Stack is empty\\". is_empty(): Returns True if the stack is empty, otherwise returns False. size(): Returns the number of elements in the stack. def __init__(self): Initializes an empty stack. pass def push(self, element): Adds an element to the top of the stack. pass def pop(self): Removes the top element from the stack and returns it. If the stack is empty, returns \\"Stack is empty\\". pass def peek(self): Returns the top element of the stack without removing it. If the stack is empty, returns \\"Stack is empty\\". pass def is_empty(self): Returns True if the stack is empty, otherwise returns False. pass def size(self): Returns the number of elements in the stack. pass","solution":"class Stack: def __init__(self): Initializes an empty stack. self.stack = [] def push(self, element): Adds an element to the top of the stack. self.stack.append(element) def pop(self): Removes the top element from the stack and returns it. If the stack is empty, returns \\"Stack is empty\\". if self.is_empty(): return \\"Stack is empty\\" return self.stack.pop() def peek(self): Returns the top element of the stack without removing it. If the stack is empty, returns \\"Stack is empty\\". if self.is_empty(): return \\"Stack is empty\\" return self.stack[-1] def is_empty(self): Returns True if the stack is empty, otherwise returns False. return len(self.stack) == 0 def size(self): Returns the number of elements in the stack. return len(self.stack)"},{"question":"def min_number_of_lamps_needed(T: int, test_cases: List[Tuple[int, int]]) -> List[int]: Determine the minimum number of lamps required to illuminate every cell in all test cases. Parameters: T (int): Number of test cases test_cases (list of tuples): Each tuple contains two integers, N and M, the dimensions of the matrix Returns: list of int: List containing the minimum number of lamps required for each test case >>> min_number_of_lamps_needed(1, [(3, 3)]) == [3] >>> min_number_of_lamps_needed(2, [(5, 7), (1, 6)]) == [7, 6] >>> min_number_of_lamps_needed(3, [(1, 1), (2, 2), (4, 9)]) == [1, 2, 9] >>> min_number_of_lamps_needed(1, [(50, 50)]) == [50] >>> min_number_of_lamps_needed(1, [(3, 1)]) == [3] >>> min_number_of_lamps_needed(4, [(50, 1), (1, 50), (10, 20), (25, 30)]) == [50, 50, 20, 30]","solution":"def min_number_of_lamps_needed(T, test_cases): Determine the minimum number of lamps required to illuminate every cell in all test cases. Parameters: T (int): Number of test cases test_cases (list of tuples): Each tuple contains two integers, N and M, the dimensions of the matrix Returns: list of int: List containing the minimum number of lamps required for each test case results = [] for n, m in test_cases: # The minimum number of lamps needed is equal to the maximum of the two dimensions results.append(max(n, m)) return results"},{"question":"def minimal_steps(N: int) -> int: Determine the minimal number of steps required for the robot to visit all points in the grid [0, N] x [0, N] starting from (0, 0). Args: N (int): The size of the grid (2 ≤ N ≤ 50). Returns: int: The minimal number of steps required. >>> minimal_steps(2) 2 >>> minimal_steps(5) 5 >>> minimal_steps(10) 10 >>> minimal_steps(0) 0 >>> minimal_steps(1) 1 >>> minimal_steps(50) 50","solution":"def minimal_steps(N): if N <= 0: return 0 # The minimal steps formula is derived from the fact that # to move from (0, 0) to (N, N), we need N steps. In the process, # the robot can reach all the points in the grid [0, N]x[0, N] return N # Note: The above function works directly in a single return statement # based on the problem constraints and the logic deduced."},{"question":"def min_changes_to_palindrome(s: str) -> int: Returns the minimum number of character changes required to make the string s a palindrome. >>> min_changes_to_palindrome(\\"ab\\") 1 >>> min_changes_to_palindrome(\\"abcd\\") 2 def process_test_cases(T: int, test_cases: List[str]) -> List[int]: Given the number of test cases T and the test cases as a list of strings, returns a list of results for each test case. >>> process_test_cases(4, [\\"ab\\", \\"abcd\\", \\"racecar\\", \\"abcba\\"]) [1, 2, 0, 0] # Example Unit Tests def test_single_change_needed(): assert min_changes_to_palindrome(\\"ab\\") == 1 def test_multiple_changes_needed(): assert min_changes_to_palindrome(\\"abcd\\") == 2 def test_no_changes_needed_racecar(): assert min_changes_to_palindrome(\\"racecar\\") == 0 def test_no_changes_needed_abcba(): assert min_changes_to_palindrome(\\"abcba\\") == 0 def test_process_multiple_test_cases(): assert process_test_cases(4, [\\"ab\\", \\"abcd\\", \\"racecar\\", \\"abcba\\"]) == [1, 2, 0, 0] def test_all_same_characters(): assert min_changes_to_palindrome(\\"aaaaaaa\\") == 0 def test_longer_string(): assert min_changes_to_palindrome(\\"abcdefghijjihgfedcba\\") == 0 def test_mixed_case_single_change(): assert min_changes_to_palindrome(\\"abca\\") == 1","solution":"def min_changes_to_palindrome(s): Returns the minimum number of character changes required to make the string s a palindrome. changes = 0 n = len(s) for i in range(n // 2): if s[i] != s[n - i - 1]: changes += 1 return changes def process_test_cases(T, test_cases): Given the number of test cases T and the test cases as a list of strings, returns a list of results for each test case. results = [] for test_case in test_cases: results.append(min_changes_to_palindrome(test_case)) return results"},{"question":"def max_parenthesis_depth(expression: str) -> int: Calculates the maximum depth of nested parentheses in a mathematical expression. Parameters: - expression (str): The mathematical expression containing digits, '+', '-', '*', '/', and parentheses. Returns: - int: The maximum depth of nesting of parentheses in the expression. Example: >>> max_parenthesis_depth(\\"((1+2)*3)+((4/2)+(5+(6-7)))\\") 3 >>> max_parenthesis_depth(\\"1+2-3*4/5\\") 0","solution":"def max_parenthesis_depth(expression: str) -> int: Calculates the maximum depth of nested parentheses in a mathematical expression. Parameters: - expression (str): The mathematical expression containing digits, '+', '-', '*', '/', and parentheses. Returns: - int: The maximum depth of nesting of parentheses in the expression. max_depth = 0 current_depth = 0 for char in expression: if char == '(': current_depth += 1 if current_depth > max_depth: max_depth = current_depth elif char == ')': current_depth -= 1 return max_depth"},{"question":"def final_position(M: int, N: int, X: int, Y: int, moves: str) -> tuple: Determine the final position in a MxN grid after executing a series of moves from the starting position (X, Y). Args: M (int): Number of rows in the grid. N (int): Number of columns in the grid. X (int): Starting row coordinate. Y (int): Starting column coordinate. moves (str): A string of moves consisting of 'L', 'R', 'U', and 'D'. Returns: tuple: The final coordinates as a tuple (final_X, final_Y). Example: >>> final_position(5, 5, 1, 2, \\"LRRUDD\\") (2, 3) >>> final_position(5, 5, 1, 1, \\"\\") (1, 1) >>> final_position(2, 2, 0, 0, \\"ULLDDR\\") (1, 1) >>> final_position(10, 10, 0, 0, \\"UUUU\\") (0, 0) >>> final_position(10, 10, 9, 9, \\"DDDD\\") (9, 9) >>> final_position(4, 4, 2, 2, \\"LUURRDDLL\\") (2, 1)","solution":"def final_position(m, n, x, y, moves): for move in moves: if move == 'L' and y > 0: y -= 1 elif move == 'R' and y < n - 1: y += 1 elif move == 'U' and x > 0: x -= 1 elif move == 'D' and x < m - 1: x += 1 return x, y"},{"question":"def unique_squares(nums): Takes a list of integers and returns a new list with each integer squared, without duplicating any of the squared values. The order of the output list is the same as the order of the first occurrence of their squares in the input list. >>> unique_squares([2, -2, 3, 2, -3, 4]) [4, 9, 16] >>> unique_squares([1, 1, 2, 3, 4, 5]) [1, 4, 9, 16, 25] >>> unique_squares([-1, -1, -2, -3, -4, -5]) [1, 4, 9, 16, 25] >>> unique_squares([0, 0, 0]) [0] >>> unique_squares([]) [] >>> unique_squares([-1, 1, -2, 2, -3, 3]) [1, 4, 9] >>> unique_squares([4, 5, 6, 4, 2, 3]) [16, 25, 36, 4, 9]","solution":"def unique_squares(nums): Takes a list of integers and returns a new list with each integer squared, without duplicating any of the squared values. The order of the output list is the same as the order of the first occurrence of their squares in the input list. seen = set() result = [] for num in nums: square = num ** 2 if square not in seen: seen.add(square) result.append(square) return result"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_max_path_sum(tree_str: str) -> int: Find the maximum path sum in a binary tree represented by a serialized string of nodes in level order traversal. >>> find_max_path_sum(\\"1 2 3\\") 6 >>> find_max_path_sum(\\"-10 9 20 null null 15 7\\") 42 >>> find_max_path_sum(\\"5\\") 5 >>> find_max_path_sum(\\"-3\\") -3 >>> find_max_path_sum(\\"2 -1 -2 -4 null null 3 4 null null 5\\") 8 >>> find_max_path_sum(\\"1 null 2 null 3 null 4 null 5\\") 15","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxPathSum(root): def helper(node): nonlocal max_sum if not node: return 0 # Calculate the maximum path sum with respect to current subtree left_gain = max(helper(node.left), 0) right_gain = max(helper(node.right), 0) # Update the overall maximum path sum with a split at the current node current_sum = node.val + left_gain + right_gain max_sum = max(max_sum, current_sum) # Return the maximum gain when continuing the traversal from the current node return node.val + max(left_gain, right_gain) max_sum = float('-inf') helper(root) return max_sum def deserialize(data): if not data: return None nodes = data.split() root = TreeNode(int(nodes[0])) queue = [root] i = 1 while queue and i < len(nodes): node = queue.pop(0) if nodes[i] != 'null': node.left = TreeNode(int(nodes[i])) queue.append(node.left) i += 1 if i < len(nodes) and nodes[i] != 'null': node.right = TreeNode(int(nodes[i])) queue.append(node.right) i += 1 return root def find_max_path_sum(tree_str): root = deserialize(tree_str) return maxPathSum(root)"},{"question":"def merge_sorted_lists(t: int, cases: List[Tuple[Tuple[int, int], List[int], List[int]]]) -> List[List[int]]: Merge and sort two sorted lists of timestamps for multiple test cases. >>> merge_sorted_lists(2, [([3, 4], [1, 3, 5], [2, 4, 6, 8]), ([5, 3], [10, 12, 13, 14, 18], [7, 9, 15])]) [[1, 2, 3, 4, 5, 6, 8], [7, 9, 10, 12, 13, 14, 15, 18]] >>> merge_sorted_lists(1, [([0, 0], [], [])]) [[]] >>> merge_sorted_lists(1, [([0, 3], [], [2, 3, 4])]) [[2, 3, 4]] >>> merge_sorted_lists(1, [([3, 0], [1, 2, 3], [])]) [[1, 2, 3]] >>> merge_sorted_lists(1, [([2, 2], [1000000000, 1000000001], [999999999, 1000000002])]) [[999999999, 1000000000, 1000000001, 1000000002]]","solution":"def merge_sorted_lists(t, cases): results = [] for case in cases: n, m = case[0] list1 = case[1] list2 = case[2] merged_list = [] i, j = 0, 0 # Merge the two lists while maintaining the sorted order while i < n and j < m: if list1[i] <= list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 # If there are remaining elements in list1 while i < n: merged_list.append(list1[i]) i += 1 # If there are remaining elements in list2 while j < m: merged_list.append(list2[j]) j += 1 results.append(merged_list) return results"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rearrangeOddEven(head): Rearranges a singly linked list such that all odd-indexed nodes are grouped together followed by the even-indexed nodes. The indices refer to the zero-based index of the nodes in the linked list. Args: head: ListNode, the head of the singly linked list. Returns: ListNode: the head of the modified linked list after rearranging. Examples: >>> head = list_to_nodes([1, 2, 3, 4, 5]) >>> nodes_to_list(rearrangeOddEven(head)) == [1, 3, 5, 2, 4] True >>> head = list_to_nodes([2, 1, 3, 5, 6, 4, 7]) >>> nodes_to_list(rearrangeOddEven(head)) == [2, 3, 6, 7, 1, 5, 4] True pass def list_to_nodes(lst): dummy = ListNode(0) current = dummy for value in lst: current.next = ListNode(value) current = current.next return dummy.next def nodes_to_list(node): result = [] current = node while current: result.append(current.val) current = current.next return result def test_rearrangeOddEven(): head = list_to_nodes([1, 2, 3, 4, 5]) expected = [1, 3, 5, 2, 4] result = rearrangeOddEven(head) assert nodes_to_list(result) == expected def test_rearrangeOddEven_mixed(): head = list_to_nodes([2, 1, 3, 5, 6, 4, 7]) expected = [2, 3, 6, 7, 1, 5, 4] result = rearrangeOddEven(head) assert nodes_to_list(result) == expected def test_rearrangeOddEven_single_node(): head = list_to_nodes([1]) expected = [1] result = rearrangeOddEven(head) assert nodes_to_list(result) == expected def test_rearrangeOddEven_two_nodes(): head = list_to_nodes([1, 2]) expected = [1, 2] result = rearrangeOddEven(head) assert nodes_to_list(result) == expected def test_rearrangeOddEven_empty(): head = list_to_nodes([]) expected = [] result = rearrangeOddEven(head) assert nodes_to_list(result) == expected","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rearrangeOddEven(head): if not head or not head.next: return head odd_dummy = ListNode(0) even_dummy = ListNode(0) odd_tail = odd_dummy even_tail = even_dummy is_odd = True current = head while current: if is_odd: odd_tail.next = current odd_tail = odd_tail.next else: even_tail.next = current even_tail = even_tail.next is_odd = not is_odd current = current.next even_tail.next = None odd_tail.next = even_dummy.next return odd_dummy.next"},{"question":"def k_consecutive_increasing_subsequence_exists(n: int, k: int, sequence: List[int]) -> str: Determine if there exists a subsequence of at least k consecutive increasing numbers in the sequence. Args: n (int): Number of elements in the sequence k (int): Minimum length of the increasing subsequence sequence (List[int]): The sequence of integers Returns: str: \\"YES\\" if there exists a subsequence of at least k consecutive increasing numbers, otherwise \\"NO\\" Examples: >>> k_consecutive_increasing_subsequence_exists(10, 3, [1, 2, 2, 3, 4, 5, 1, 1, 1, 6]) \\"YES\\" >>> k_consecutive_increasing_subsequence_exists(5, 4, [5, 2, 4, 6, 1]) \\"NO\\" # Unit tests for the function from typing import List def test_example_1(): assert k_consecutive_increasing_subsequence_exists(10, 3, [1, 2, 2, 3, 4, 5, 1, 1, 1, 6]) == \\"YES\\" def test_example_2(): assert k_consecutive_increasing_subsequence_exists(5, 4, [5, 2, 4, 6, 1]) == \\"NO\\" def test_k_is_1(): assert k_consecutive_increasing_subsequence_exists(5, 1, [5, 2, 4, 6, 1]) == \\"YES\\" def test_all_equal_elements(): assert k_consecutive_increasing_subsequence_exists(5, 2, [1, 1, 1, 1, 1]) == \\"NO\\" def test_k_equal_to_n(): assert k_consecutive_increasing_subsequence_exists(5, 5, [1, 2, 3, 4, 5]) == \\"YES\\" def test_decreasing_sequence(): assert k_consecutive_increasing_subsequence_exists(5, 2, [5, 4, 3, 2, 1]) == \\"NO\\" def test_increasing_and_decreasing(): assert k_consecutive_increasing_subsequence_exists(6, 3, [1, 2, 3, 2, 3, 4]) == \\"YES\\"","solution":"def has_k_consecutive_increasing(nums, k): if k == 1: return \\"YES\\" if len(nums) > 0 else \\"NO\\" n = len(nums) count = 1 for i in range(1, n): if nums[i] > nums[i - 1]: count += 1 if count >= k: return \\"YES\\" else: count = 1 return \\"NO\\" def k_consecutive_increasing_subsequence_exists(n, k, sequence): return has_k_consecutive_increasing(sequence, k)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isSymmetric(root): Check if a binary tree is symmetric around its center. def isMirror(t1, t2): if not t1 and not t2: return True if not t1 or not t2: return False return (t1.val == t2.val) and isMirror(t1.right, t2.left) and isMirror(t1.left, t2.right) def buildTree(level_order): Build a binary tree from the given level-order traversal. if not level_order or level_order[0] == 'N': return None iter_values = iter(level_order) root = TreeNode(int(next(iter_values))) queue = [root] while queue: current = queue.pop(0) try: left_val = next(iter_values) if left_val != 'N': current.left = TreeNode(int(left_val)) queue.append(current.left) right_val = next(iter_values) if right_val != 'N': current.right = TreeNode(int(right_val)) queue.append(current.right) except StopIteration: break return root def check_symmetry_of_trees(test_cases): Check the symmetry for a list of binary tree level-order traversals. results = [] for level_order in test_cases: level_order = level_order.split() level_order = ['N' if val == 'N' else val for val in level_order] root = buildTree(level_order) if isSymmetric(root): results.append(\\"Yes\\") else: results.append(\\"No\\") return results # Unit Tests def test_symmetric_trees(): assert check_symmetry_of_trees([\\"1 2 2 3 4 4 3\\"]) == [\\"Yes\\"] def test_asymmetric_trees(): assert check_symmetry_of_trees([\\"1 2 2 N 3 N 3\\"]) == [\\"No\\"] def test_multiple_cases(): test_cases = [\\"1 2 2 3 4 4 3\\", \\"1 2 2 N 3 N 3\\", \\"1 2 2\\", \\"1 N N\\"] expected_results = [\\"Yes\\", \\"No\\", \\"Yes\\", \\"Yes\\"] assert check_symmetry_of_trees(test_cases) == expected_results def test_empty_tree(): assert check_symmetry_of_trees([\\"\\"]) == [\\"Yes\\"] def test_single_node_tree(): assert check_symmetry_of_trees([\\"1\\"]) == [\\"Yes\\"]","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isSymmetric(root): def isMirror(t1, t2): if not t1 and not t2: return True if not t1 or not t2: return False return (t1.val == t2.val) and isMirror(t1.right, t2.left) and isMirror(t1.left, t2.right) return isMirror(root, root) def buildTree(level_order): if not level_order or level_order[0] == 'N': return None iter_values = iter(level_order) root = TreeNode(int(next(iter_values))) queue = [root] while queue: current = queue.pop(0) try: left_val = next(iter_values) if left_val != 'N': current.left = TreeNode(int(left_val)) queue.append(current.left) right_val = next(iter_values) if right_val != 'N': current.right = TreeNode(int(right_val)) queue.append(current.right) except StopIteration: break return root def check_symmetry_of_trees(test_cases): results = [] for level_order in test_cases: level_order = level_order.split() level_order = ['N' if val == 'N' else val for val in level_order] root = buildTree(level_order) if isSymmetric(root): results.append(\\"Yes\\") else: results.append(\\"No\\") return results # Example usage: # test_cases = [\\"1 2 2 3 4 4 3\\", \\"1 2 2 N 3 N 3\\"] # print(check_symmetry_of_trees(test_cases))"},{"question":"def can_form(S: str, T: str) -> bool: Determines if T can be formed by deleting some characters from S without reordering the remaining characters. it = iter(S) return all(char in it for char in T) def solve(test_cases: List[Tuple[str, str]]) -> List[str]: Solves the problem for a list of test cases. Args: test_cases: List of tuples where each tuple contains two strings (S, T). Returns: List of strings \\"YES\\" or \\"NO\\" for each test case. Example: >>> solve([(\\"abcde\\", \\"ace\\"), (\\"abcde\\", \\"aec\\"), (\\"a\\", \\"a\\"), (\\"abcde\\", \\"abcde\\")]) [\\"YES\\", \\"NO\\", \\"YES\\", \\"YES\\"] from typing import List, Tuple def test_can_form_basic(): assert can_form(\\"abcde\\", \\"ace\\") == True assert can_form(\\"abcde\\", \\"aec\\") == False assert can_form(\\"a\\", \\"a\\") == True assert can_form(\\"abcde\\", \\"abcde\\") == True def test_can_form_edge_cases(): assert can_form(\\"a\\"*100000 + \\"b\\"*100000, \\"a\\"*50000 + \\"b\\"*50000) == True assert can_form(\\"abcdefghijklmnopqrstuvwxyz\\"*1000, \\"zyxwvutsrqponmlkjihgfedcba\\"*1000) == False def test_solve(): test_cases = [ (\\"abcde\\", \\"ace\\"), (\\"abcde\\", \\"aec\\"), (\\"a\\", \\"a\\"), (\\"abcde\\", \\"abcde\\") ] expected_output = [\\"YES\\", \\"NO\\", \\"YES\\", \\"YES\\"] assert solve(test_cases) == expected_output test_cases = [ (\\"xyz\\", \\"xyz\\"), (\\"xyz\\", \\"xy\\"), (\\"abc\\", \\"cab\\") ] expected_output = [\\"YES\\", \\"YES\\", \\"NO\\"] assert solve(test_cases) == expected_output","solution":"def can_form(S, T): Determines if T can be formed by deleting some characters from S without reordering the remaining characters. it = iter(S) return all(char in it for char in T) def solve(test_cases): results = [] for S, T in test_cases: if can_form(S, T): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def process_surgery_data(input_lines): Returns a list of minimum number of operating rooms required for each test case. >>> process_surgery_data([\\"5\\", \\"1 4\\", \\"2 5\\", \\"6 7\\", \\"3 8\\", \\"8 9\\", \\"3\\", \\"2 3\\", \\"4 5\\", \\"6 7\\", \\"0\\"]) [3, 1] >>> process_surgery_data([\\"1\\", \\"0 1000000\\", \\"0\\"]) [1]","solution":"def min_operating_rooms(test_cases): Returns a list of minimum number of operating rooms required for each test case. results = [] for surgeries in test_cases: events = [] for s, t in surgeries: events.append((s, 'start')) events.append((t, 'end')) events.sort() max_rooms = 0 current_rooms = 0 for time, event in events: if event == 'start': current_rooms += 1 max_rooms = max(max_rooms, current_rooms) else: current_rooms -= 1 results.append(max_rooms) return results def parse_input(input_lines): test_cases = [] current_case = [] iterator = iter(input_lines) num_surgeries = int(next(iterator)) while num_surgeries != 0: for _ in range(num_surgeries): start, end = map(int, next(iterator).split()) current_case.append((start, end)) test_cases.append(current_case) current_case = [] num_surgeries = int(next(iterator)) return test_cases def process_surgery_data(input_lines): test_cases = parse_input(input_lines) results = min_operating_rooms(test_cases) return results"},{"question":"def min_remove_to_make_valid_parentheses(s: str) -> int: Determines the minimum number of parentheses to remove to make the sequence valid. Parameters: s (str): The input string containing only '(' and ')'. Returns: int: The minimum number of parentheses to remove. >>> min_remove_to_make_valid_parentheses(\\"()))((\\") 2 >>> min_remove_to_make_valid_parentheses(\\"((())())\\") 0 import pytest def test_valid_sequences(): assert min_remove_to_make_valid_parentheses(\\"((())())\\") == 0 assert min_remove_to_make_valid_parentheses(\\"()()()\\") == 0 def test_invalid_sequences(): assert min_remove_to_make_valid_parentheses(\\"())(()\\") == 2 assert min_remove_to_make_valid_parentheses(\\"()(())))\\") == 2 assert min_remove_to_make_valid_parentheses(\\"((())\\") == 1 assert min_remove_to_make_valid_parentheses(\\"))(((\\") == 5 def test_single_parentheses(): assert min_remove_to_make_valid_parentheses(\\"(\\") == 1 assert min_remove_to_make_valid_parentheses(\\")\\") == 1 def test_mixed_sequences(): assert min_remove_to_make_valid_parentheses(\\")()(\\") == 2 assert min_remove_to_make_valid_parentheses(\\"(())())\\") == 1 if __name__ == \\"__main__\\": pytest.main()","solution":"def min_remove_to_make_valid_parentheses(s: str) -> int: Determines the minimum number of parentheses to remove to make the sequence valid. Parameters: s (str): The input string containing only '(' and ')'. Returns: int: The minimum number of parentheses to remove. open_count = 0 remove_count = 0 # First pass to count extra closing parentheses for char in s: if char == '(': open_count += 1 elif char == ')': if open_count > 0: open_count -= 1 else: remove_count += 1 # open_count will be the remaining unmatched opening parentheses remove_count += open_count return remove_count"},{"question":"def find_three_numbers_sum(arr: List[int], target: int) -> List[int]: Given an array of integers, determine if there are three entries that add up to a specified target sum. Return such three numbers if they exist, otherwise return an empty array. >>> find_three_numbers_sum([1, 2, 3, 4, 5, 6], 10) in ([1, 3, 6], [2, 3, 5], [1, 4, 5]) True >>> find_three_numbers_sum([1, 2, 4, 5, 6], 20) [] >>> find_three_numbers_sum([-1, 0, 1, 2, -1, -4], 0) in ([-1, 0, 1], [-1, -1, 2]) True >>> find_three_numbers_sum([5, 7, 1, 2], 100) [] >>> find_three_numbers_sum([-3, -2, -1, 1, 2, 3], 0) in ([-3, 1, 2], [-2, -1, 3]) True >>> find_three_numbers_sum([0, -1, 2, -3, 1], -2) [-3, -1, 2]","solution":"def find_three_numbers_sum(arr, target): Given an array of integers, determine if there are three entries that add up to a specified target sum. Return such three numbers if they exist, otherwise return an empty array. arr.sort() n = len(arr) for i in range(n - 2): if i > 0 and arr[i] == arr[i - 1]: continue left, right = i + 1, n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == target: return [arr[i], arr[left], arr[right]] elif current_sum < target: left += 1 else: right -= 1 return []"},{"question":"def minimum_swaps(n, arr): Implement a function that calculates the minimum number of swaps required to sort an array containing unique integers. A swap involves exchanging the positions of two elements in the array. The goal is to sort the array such that the integer at index i equals i+1. Parameters: - n (int): The length of the array. - arr (List[int]): The array of n unique integers. Returns: - int: The minimum number of swaps required to sort the array. Example: >>> minimum_swaps(5, [4, 3, 1, 2, 5]) 3 >>> minimum_swaps(5, [1, 2, 3, 4, 5]) 0","solution":"def minimum_swaps(n, arr): Returns the minimum number of swaps required to sort the array such that the integer at index i equals i+1. Parameters: - n: int, the length of the array. - arr: List[int], the array of n unique integers. Returns: - int, the minimum number of swaps. # Create a dictionary to map value to its index value_index_map = {v: i for i, v in enumerate(arr)} swaps = 0 # Iterate over the array and place each element to its correct position for i in range(n): # Check if the current element is in its correct position while arr[i] != i + 1: # Get the correct index of the current element correct_index = value_index_map[i + 1] # Swap the current element with the element at its correct index arr[i], arr[correct_index] = arr[correct_index], arr[i] # Update the value_index_map after the swap value_index_map[arr[correct_index]] = correct_index value_index_map[arr[i]] = i # Increment the swaps counter swaps += 1 return swaps"},{"question":"def construct_array(n: int, a: List[int]) -> Union[List[int], str]: Construct array B such that for any element b_i in B, the number of elements in the input array that are less than or equal to b_i is exactly i (1-based index). If it is not possible, return 'Impossible'. >>> construct_array(5, [3, 1, 4, 1, 5]) == [1, 1, 3, 4, 5] >>> construct_array(4, [4, 3, 2, 1]) == [1, 2, 3, 4] >>> construct_array(1, [1]) == [1] >>> construct_array(3, [999999999, 500000000, 1000000000]) == [500000000, 999999999, 1000000000]","solution":"def construct_array(n, a): Construct array B such that for any element b_i in B, the number of elements in the input array that are less than or equal to b_i is exactly i (1-based index). If it is not possible, return 'Impossible'. a_sorted = sorted(a) b = [a_sorted[i] for i in range(n)] return b"},{"question":"from typing import List, Tuple def shortest_route(points: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Determine the shortest possible round trip route that visits each point exactly once and returns to the starting point. >>> shortest_route([(0, 0), (2, 2), (2, 0), (0, 2)]) [(0, 0), (2, 0), (2, 2), (0, 2), (0, 0)] >>> shortest_route([(0, 0), (1, 1)]) [(0, 0), (1, 1), (0, 0)] >>> shortest_route([(0, 0), (1, 1), (1, 0)]) [(0, 0), (1, 0), (1, 1), (0, 0)] >>> shortest_route([(0, 0), (1, 1), (1, 0), (0, 1)]) [(0, 0), (1, 0), (1, 1), (0, 1), (0, 0)]","solution":"from itertools import permutations import math from typing import List, Tuple def euclidean_distance(p1: Tuple[int, int], p2: Tuple[int, int]) -> float: return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) def calculate_route_length(route: List[Tuple[int, int]]) -> float: length = 0.0 for i in range(len(route) - 1): length += euclidean_distance(route[i], route[i+1]) length += euclidean_distance(route[-1], route[0]) return length def shortest_route(points: List[Tuple[int, int]]) -> List[Tuple[int, int]]: min_route = [] min_length = float('inf') for perm in permutations(points[1:]): current_route = [points[0]] + list(perm) + [points[0]] current_length = calculate_route_length(current_route) if current_length < min_length: min_length = current_length min_route = current_route return min_route"},{"question":"def is_lucky_sequence_possible(N, D): Returns \\"YES\\" if it's possible to form a lucky number sequence with N cards and minimum difference D, otherwise \\"NO\\". >>> is_lucky_sequence_possible(5, 1) \\"YES\\" >>> is_lucky_sequence_possible(5, 2) \\"YES\\" >>> is_lucky_sequence_possible(5, 6) \\"NO\\" def process_test_cases(T, test_cases): Processes multiple test cases to determine if a lucky number sequence is possible for each case. >>> process_test_cases(3, [(5, 1), (5, 2), (5, 6)]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> process_test_cases(2, [(10, 3), (10, 11)]) [\\"YES\\", \\"NO\\"]","solution":"def is_lucky_sequence_possible(N, D): Returns \\"YES\\" if it's possible to form a lucky number sequence with N cards and minimum difference D, otherwise \\"NO\\". current = 1 while current <= N: current += D return \\"YES\\" if current - D >= N else \\"NO\\" def process_test_cases(T, test_cases): results = [] for i in range(T): N, D = test_cases[i] result = is_lucky_sequence_possible(N, D) results.append(result) return results"},{"question":"def is_path_exists(maze: List[str]) -> str: Determines if there is a path from the start to the end of the maze. If such a path exists, return \\"YES\\"; if not, return \\"NO\\". >>> is_path_exists([ ... \\".....\\", ... \\".#.\\", ... \\".....\\", ... \\".#.\\", ... \\".....\\" ... ]) == \\"YES\\" >>> is_path_exists([ ... \\"..#.\\", ... \\"#.\\", ... \\"..#.\\" ... ]) == \\"NO\\"","solution":"def is_path_exists(maze): from collections import deque N, M = len(maze), len(maze[0]) if maze[0][0] == '#' or maze[N-1][M-1] == '#': return \\"NO\\" directions = [(-1,0), (1,0), (0,-1), (0,1)] queue = deque([(0, 0)]) visited = set() visited.add((0, 0)) while queue: x, y = queue.popleft() if x == N-1 and y == M-1: return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and (nx, ny) not in visited and maze[nx][ny] == '.': queue.append((nx, ny)) visited.add((nx, ny)) return \\"NO\\""},{"question":"def max_subarray_sum(arr): Finds the largest sum of contiguous subarray within the given array. Args: arr (list): A list of integers. Returns: int: The largest sum of contiguous subarray. Examples: >>> max_subarray_sum([-2,1,-3,4,-1,2,1,-5,4]) 6 >>> max_subarray_sum([1,2,3,4,-10]) 10","solution":"def max_subarray_sum(arr): Finds the largest sum of contiguous subarray within the given array. Args: arr (list): A list of integers. Returns: int: The largest sum of contiguous subarray. max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"def can_form_palindrome(T: str) -> str: Determines if the string T can be rearranged to form a palindrome. Arguments: T -- input string consisting of lowercase alphabets Returns: 'Yes' if T can be rearranged into a palindrome, 'No' otherwise Test Cases: >>> can_form_palindrome(\\"radar\\") 'Yes' >>> can_form_palindrome(\\"aaaaaa\\") 'Yes' >>> can_form_palindrome(\\"aabb\\") 'Yes' >>> can_form_palindrome(\\"aab\\") 'Yes' >>> can_form_palindrome(\\"abcde\\") 'No' >>> can_form_palindrome(\\"\\") 'Yes' >>> can_form_palindrome(\\"a\\") 'Yes' >>> can_form_palindrome(\\"ab\\") 'No' >>> can_form_palindrome(\\"aa\\") 'Yes'","solution":"def can_form_palindrome(T): Determines if the string T can be rearranged to form a palindrome. Arguments: T -- input string consisting of lowercase alphabets Returns: 'Yes' if T can be rearranged into a palindrome, 'No' otherwise from collections import Counter # Count the frequency of each character char_count = Counter(T) # Count how many characters have odd frequencies odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A palindrome can have at most one character with an odd frequency return \\"Yes\\" if odd_count <= 1 else \\"No\\""},{"question":"from typing import List def modifyArray(nums: List[int]) -> List[int]: Modifies the input array by removing all elements that appear more than twice and then reversing the order of the remaining elements. Parameters: nums (List[int]): The input array. Returns: List[int]: The modified array. If the resulting array is empty, return [-1]. pass # Example test cases def test_modifyArray_example(): nums = [1, 2, 3, 2, 3, 3, 4] assert modifyArray(nums) == [4, 2, 2, 1] def test_modifyArray_no_elements_removed(): nums = [1, 2, 2, 3, 3, 4, 5] assert modifyArray(nums) == [5, 4, 3, 3, 2, 2, 1] def test_modifyArray_all_elements_removed(): nums = [1, 1, 1, 2, 2, 2] assert modifyArray(nums) == [-1] def test_modifyArray_some_elements_removed(): nums = [1, 1, 2, 2, 3, 3, 3, 4] assert modifyArray(nums) == [4, 2, 2, 1, 1] def test_modifyArray_empty_input(): nums = [] assert modifyArray(nums) == [-1]","solution":"from collections import Counter def modifyArray(nums): Modifies the input array by removing all elements that appear more than twice and then reversing the order of the remaining elements. Parameters: nums (list of int): The input array. Returns: list of int: The modified array. # Count the frequency of each element count = Counter(nums) # Create a new array with elements that appear at most twice modified = [num for num in nums if count[num] <= 2] # Reverse the modified array modified.reverse() # If the resulting array is empty, return [-1] return modified if modified else [-1]"},{"question":"def firstNFibonacci(n: int) -> List[int]: Returns a list containing the first n elements of the Fibonacci sequence. >>> firstNFibonacci(5) == [0, 1, 1, 2, 3] >>> firstNFibonacci(10) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] pass # Your implementation goes here # Unit tests def test_zero_elements(): assert firstNFibonacci(0) == [] def test_one_element(): assert firstNFibonacci(1) == [0] def test_two_elements(): assert firstNFibonacci(2) == [0, 1] def test_five_elements(): assert firstNFibonacci(5) == [0, 1, 1, 2, 3] def test_ten_elements(): assert firstNFibonacci(10) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] def test_negative_input(): assert firstNFibonacci(-5) == [] def test_large_input(): result = firstNFibonacci(20) expected = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181] assert result == expected","solution":"def firstNFibonacci(n): Returns a list containing the first n elements of the Fibonacci sequence. if n <= 0: return [] elif n == 1: return [0] fib_sequence = [0, 1] for i in range(2, n): fib_sequence.append(fib_sequence[-1] + fib_sequence[-2]) return fib_sequence"},{"question":"def longest_increasing_sequence(n: int, events: List[Tuple[int, int, int]]) -> int: Given the number of events and a list of events, find the longest sequence of consecutive increasing readings for any sensor. Parameters: n (int): The number of events. events (List[Tuple[int, int, int]]): A list of events where each event is represented as a tuple (t, s, v). Returns: int: The length of the longest sequence of consecutive increasing readings for any sensor. >>> longest_increasing_sequence(7, [(1, 1, 10), (2, 1, 12), (3, 1, 15), (4, 2, 5), (5, 1, 9), (6, 1, 11), (7, 1, 13)]) 3 >>> longest_increasing_sequence(3, [(1, 2, 7), (2, 2, 8), (3, 2, 9)]) 3","solution":"def longest_increasing_sequence(n, events): sensor_data = {} longest_sequence = 0 for t, s, v in events: if s not in sensor_data: sensor_data[s] = (v, 1) # (prev_value, current_sequence_length) else: prev_value, current_length = sensor_data[s] if v > prev_value: current_length += 1 else: current_length = 1 sensor_data[s] = (v, current_length) longest_sequence = max(longest_sequence, sensor_data[s][1]) return longest_sequence"},{"question":"def findLCA(n: int, edges: List[Tuple[int, int]], u: int, v: int) -> int: Find the lowest common ancestor (LCA) of two given computers in a network based on the parent-child relationships. Parameters: n (int): The number of computers in the network. edges (List[Tuple[int, int]]): A list of tuples representing the parent-child relationships. u (int): The ID of the first computer. v (int): The ID of the second computer. Returns: int: The ID of the lowest common ancestor of computers u and v. Examples: >>> findLCA(7, [(1,2), (1,3), (3,4), (3,5), (4,6), (4,7)], 6, 7) 4 >>> findLCA(5, [(1,2), (1,3), (2,4), (2,5)], 4, 5) 2","solution":"def findLCA(n, edges, u, v): from collections import defaultdict, deque # Build tree and parent structure tree = defaultdict(list) parent = {i: None for i in range(1, n + 1)} for p, c in edges: tree[p].append(c) parent[c] = p def findAncestors(node): ancestors = set() while node is not None: ancestors.add(node) node = parent[node] return ancestors u_ancestors = findAncestors(u) v_ancestors = findAncestors(v) # Find the lowest common ancestor lca = None while u is not None: if u in v_ancestors: lca = u break u = parent[u] return lca"},{"question":"class RankingSystem: def __init__(self, n): Initialize the ranking system for n players. pass def add_points(self, player_id, points): Add points to a player's existing score. Args: player_id (int): ID of the player. points (int): Points to be added to the player. pass def query_rank(self, player_id): Query the current rank of a player. Args: player_id (int): ID of the player to query. Returns: int: The current rank of the player. pass Unit tests for the Ranking System def test_ranking_system(): # Initial Setup rs = RankingSystem(5) # Adding Points rs.add_points(1, 10) rs.add_points(2, 20) rs.add_points(3, 15) # Query Ranks assert rs.query_rank(1) == 3 assert rs.query_rank(2) == 1 assert rs.query_rank(3) == 2 # Adding More Points rs.add_points(1, 15) # Query Ranks Again assert rs.query_rank(1) == 1 assert rs.query_rank(2) == 2 assert rs.query_rank(3) == 3 def test_ranking_equal_points(): # Initial Setup rs = RankingSystem(3) # Adding Points rs.add_points(1, 10) rs.add_points(2, 10) rs.add_points(3, 10) # Query Ranks assert rs.query_rank(1) == 1 assert rs.query_rank(2) == 2 assert rs.query_rank(3) == 3 # Adding More Points rs.add_points(3, 5) # Query Ranks Again assert rs.query_rank(1) == 2 assert rs.query_rank(2) == 3 assert rs.query_rank(3) == 1","solution":"class RankingSystem: def __init__(self, n): self.n = n self.players_points = [0] * (n + 1) self.history = [] def add_points(self, player_id, points): self.players_points[player_id] += points self.history.append((player_id, self.players_points[player_id])) def query_rank(self, player_id): player_points = self.players_points[player_id] rank = 1 for i in range(1, self.n + 1): if i == player_id: continue if self.players_points[i] > player_points: rank += 1 elif self.players_points[i] == player_points: for p_id, p_points in self.history: if p_points == player_points and p_id == i: rank += 1 break if p_points == player_points and p_id == player_id: break return rank"},{"question":"def ladderLength(start: str, end: str, wordList: list[str]) -> int: Given a string and a dictionary of words, find the shortest transformation sequence from the string to a target word in the dictionary, such that only one letter can be changed at a time and each transformed word must exist in the dictionary. Return the length of the shortest transformation sequence or 0 if no such transformation sequence exists. >>> ladderLength(\\"hit\\", \\"cog\\", [\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\",\\"cog\\"]) 5 >>> ladderLength(\\"hit\\", \\"cog\\", [\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\"]) 0 >>> ladderLength(\\"a\\", \\"c\\", [\\"a\\",\\"b\\",\\"c\\"]) 2","solution":"from collections import deque def ladderLength(start: str, end: str, wordList: list[str]) -> int: def get_neighbors(word): neighbors = [] for i in range(len(word)): for char in 'abcdefghijklmnopqrstuvwxyz': if char != word[i]: new_word = word[:i] + char + word[i+1:] neighbors.append(new_word) return neighbors wordSet = set(wordList) if end not in wordSet: return 0 queue = deque([(start, 1)]) visited = set() visited.add(start) while queue: current_word, steps = queue.popleft() if current_word == end: return steps for neighbor in get_neighbors(current_word): if neighbor in wordSet and neighbor not in visited: queue.append((neighbor, steps + 1)) visited.add(neighbor) return 0"},{"question":"from typing import List def find_modes(n: int, nums: List[int]) -> List[int]: Determines the mode(s) of a list of integers. Args: n : int - number of integers in the list. nums : list of int - list of integers. Returns: list of int - list of mode(s) in ascending order. from collections import Counter def test_single_mode(): assert find_modes(10, [1, 2, 2, 3, 3, 4, 4, 4, 5, 6]) == [4] def test_multiple_modes(): assert find_modes(6, [1, 2, 2, 3, 3, 4]) == [2, 3] def test_all_unique(): assert find_modes(5, [1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] def test_single_value(): assert find_modes(1, [5]) == [5] def test_same_frequency_different_numbers(): assert find_modes(4, [1, 2, 3, 4]) == [1, 2, 3, 4]","solution":"from collections import Counter def find_modes(n, nums): Determines the mode(s) of a list of integers. Args: n : int - number of integers in the list. nums : list of int - list of integers. Returns: list of int - list of mode(s) in ascending order. counter = Counter(nums) max_frequency = max(counter.values()) modes = [num for num, freq in counter.items() if freq == max_frequency] return sorted(modes)"},{"question":"def find_largest_plateau(n: int, heights: List[int]) -> Union[Tuple[int, int], int]: Finds the largest flat top plateau in terms of number of blocks. Parameters: n (int): Number of blocks heights (list of int): Heights of the blocks Returns: tuple: Starting index (1-based) and length of the largest plateau. If no plateau is found, returns 0. >>> find_largest_plateau(7, [2, 2, 3, 3, 3, 4, 4]) (3, 3) >>> find_largest_plateau(5, [1, 2, 3, 4, 5]) 0 >>> find_largest_plateau(8, [5, 5, 5, 2, 2, 2, 2, 3]) (4, 4)","solution":"def find_largest_plateau(n, heights): Finds the largest flat top plateau in terms of number of blocks. Parameters: n (int): Number of blocks heights (list of int): Heights of the blocks Returns: tuple: Starting index (1-based) and length of the largest plateau. If no plateau is found, returns 0. max_length = 0 max_start_index = -1 current_length = 1 for i in range(1, n): if heights[i] == heights[i-1]: current_length += 1 else: if current_length > max_length: max_length = current_length max_start_index = i - current_length current_length = 1 if current_length > max_length: max_length = current_length max_start_index = n - current_length if max_length >= 2: return (max_start_index + 1, max_length) else: return 0"},{"question":"def sortPersons(A, B): Sort persons by their height in descending order and for persons with the same height, sort them by the number of chocolates in ascending order. Parameters: A (list): List of heights. B (list): List of chocolates. Returns: list: Sorted list of tuples (height, chocolates). Example: A = [170, 180, 160, 170] B = [2, 7, 10, 3] >>> sortPersons(A, B) [(180, 7), (170, 2), (170, 3), (160, 10)] A = [150, 150, 150, 140] B = [3, 1, 2, 5] >>> sortPersons(A, B) [(150, 1), (150, 2), (150, 3), (140, 5)] pass from solution import sortPersons def test_example_case_1(): A = [170, 180, 160, 170] B = [2, 7, 10, 3] expected = [(180, 7), (170, 2), (170, 3), (160, 10)] assert sortPersons(A, B) == expected def test_example_case_2(): A = [150, 150, 150, 140] B = [3, 1, 2, 5] expected = [(150, 1), (150, 2), (150, 3), (140, 5)] assert sortPersons(A, B) == expected def test_all_same_height(): A = [160, 160, 160, 160] B = [4, 3, 2, 1] expected = [(160, 1), (160, 2), (160, 3), (160, 4)] assert sortPersons(A, B) == expected def test_all_same_chocolates(): A = [170, 180, 160, 170] B = [5, 5, 5, 5] expected = [(180, 5), (170, 5), (170, 5), (160, 5)] assert sortPersons(A, B) == expected def test_random_case(): A = [200, 180, 200, 190] B = [3, 2, 1, 5] expected = [(200, 1), (200, 3), (190, 5), (180, 2)] assert sortPersons(A, B) == expected def test_single_element(): A = [170] B = [2] expected = [(170, 2)] assert sortPersons(A, B) == expected","solution":"def sortPersons(A, B): Sort persons by their height in descending order and for persons with the same height, sort them by the number of chocolates in ascending order. Parameters: A (list): List of heights. B (list): List of chocolates. Returns: list: Sorted list of tuples (height, chocolates). persons = list(zip(A, B)) sorted_persons = sorted(persons, key=lambda x: (-x[0], x[1])) return sorted_persons"},{"question":"class Valley: In a secluded valley, there exists a group of trees. Each tree has a unique height. The forest guard receives three types of operations as requests: - \`add h\` — Add a tree of height \`h\` to the valley. It’s guaranteed that there’s no tree with the same height already existing in the valley at the time of the request. - \`remove h\` — Remove the tree of height \`h\` from the valley. It’s guaranteed that there is a tree with height \`h\` in the valley at the time of the request. - \`tallest_in_range l r\` — Determine the tallest tree in the range from \`l\` to \`r\` (both inclusive). If there are trees in the range, output the height of the tallest tree. Otherwise, output \`-1\`. The forest guard needs help maintaining the forest efficiently when the number of requests becomes significantly large. Implement the following methods: - add(h: int) - remove(h: int) - tallest_in_range(l: int, r: int) -> int Example: >>> valley = Valley() >>> valley.add(5) >>> valley.add(10) >>> valley.add(15) >>> valley.tallest_in_range(1, 10) 10 >>> valley.remove(10) >>> valley.tallest_in_range(1, 10) 5 def test_add_and_tallest_in_range(): valley = Valley() valley.add(5) valley.add(10) valley.add(15) assert valley.tallest_in_range(1, 10) == 10 def test_remove_and_tallest_in_range(): valley = Valley() valley.add(5) valley.add(10) valley.add(15) valley.remove(10) assert valley.tallest_in_range(1, 10) == 5 def test_add_remove_and_tallest_in_range(): valley = Valley() valley.add(5) valley.add(10) valley.add(15) assert valley.tallest_in_range(1, 10) == 10 valley.remove(10) assert valley.tallest_in_range(1, 10) == 5 valley.add(7) valley.add(13) assert valley.tallest_in_range(1, 20) == 15 valley.remove(5) assert valley.tallest_in_range(1, 10) == 7 def test_no_trees_in_range(): valley = Valley() valley.add(5) valley.add(10) valley.add(15) assert valley.tallest_in_range(20, 30) == -1 def test_single_tree(): valley = Valley() valley.add(7) assert valley.tallest_in_range(1, 10) == 7 assert valley.tallest_in_range(7, 7) == 7 def test_edge_cases(): valley = Valley() valley.add(1) valley.add(1000000000) assert valley.tallest_in_range(1, 1) == 1 assert valley.tallest_in_range(1000000000, 1000000000) == 1000000000 assert valley.tallest_in_range(1, 1000000000) == 1000000000","solution":"class Valley: def __init__(self): self.trees = set() def add(self, h): self.trees.add(h) def remove(self, h): if h in self.trees: self.trees.remove(h) def tallest_in_range(self, l, r): tallest = -1 for height in self.trees: if l <= height <= r: if height > tallest: tallest = height return tallest"},{"question":"import heapq from typing import List, Tuple def find_min_time(N: int, M: int, paths: List[Tuple[int, int, int]]) -> int: Calculate the minimum time required to get from Attraction 1 to Attraction N. If it is not possible to reach Attraction N from Attraction 1, output \`-1\`. >>> find_min_time(4, 4, [(1, 2, 4), (2, 4, 6), (1, 3, 2), (3, 4, 8)]) == 10 >>> find_min_time(5, 5, [(1, 2, 2), (2, 3, 3), (3, 4, 4), (4, 5, 5), (1, 5, 10)]) == 10 >>> find_min_time(3, 1, [(1, 2, 5)]) == -1","solution":"import heapq def find_min_time(N, M, paths): from collections import defaultdict graph = defaultdict(list) for a, b, t in paths: graph[a].append((b, t)) graph[b].append((a, t)) pq = [(0, 1)] # (time, attraction) dist = {i: float('inf') for i in range(1, N + 1)} dist[1] = 0 while pq: current_time, u = heapq.heappop(pq) if u == N: return current_time if current_time > dist[u]: continue for v, time in graph[u]: if current_time + time < dist[v]: dist[v] = current_time + time heapq.heappush(pq, (dist[v], v)) return -1 if dist[N] == float('inf') else dist[N]"},{"question":"from typing import List, Tuple def has_overlap(intervals: List[Tuple[int, int]], target: Tuple[int, int]) -> str: Determine if any interval in the list overlaps with the target interval. Args: intervals (List[Tuple[int, int]]): A list of tuples where each tuple represents an interval. target (Tuple[int, int]): A tuple representing the target interval. Returns: str: \\"Yes\\" if any interval overlaps with the target interval, otherwise \\"No\\". Examples: >>> has_overlap([(1, 5), (10, 14), (3, 7), (9, 11), (12, 16)], (8, 13)) \\"Yes\\" >>> has_overlap([(1, 2), (4, 5), (7, 8)], (9, 10)) \\"No\\" >>> has_overlap([(1, 5), (6, 8)], (5, 6)) \\"Yes\\" def test_example(): intervals = [(1, 5), (10, 14), (3, 7), (9, 11), (12, 16)] target = (8, 13) assert has_overlap(intervals, target) == \\"Yes\\" def test_no_overlap(): intervals = [(1, 2), (4, 5), (7, 8)] target = (9, 10) assert has_overlap(intervals, target) == \\"No\\" def test_overlap_at_edge(): intervals = [(1, 5), (6, 8)] target = (5, 6) assert has_overlap(intervals, target) == \\"Yes\\" def test_complete_overlap(): intervals = [(1, 10)] target = (2, 9) assert has_overlap(intervals, target) == \\"Yes\\" def test_target_inside_interval(): intervals = [(1, 5), (6, 10)] target = (7, 8) assert has_overlap(intervals, target) == \\"Yes\\" def test_interval_inside_target(): intervals = [(7, 8)] target = (1, 10) assert has_overlap(intervals, target) == \\"Yes\\" def test_single_interval_no_overlap(): intervals = [(1, 5)] target = (6, 10) assert has_overlap(intervals, target) == \\"No\\"","solution":"def has_overlap(intervals, target): Determine if any interval in the list overlaps with the target interval. Args: intervals (List[Tuple[int, int]]): A list of tuples where each tuple represents an interval. target (Tuple[int, int]): A tuple representing the target interval. Returns: str: \\"Yes\\" if any interval overlaps with the target interval, otherwise \\"No\\". target_start, target_end = target for start, end in intervals: if start <= target_end and target_start <= end: return \\"Yes\\" return \\"No\\""},{"question":"def lexicographically_smallest_array_after_gcd_operations(N: int, M: int, array: List[int]) -> List[int]: Given an array of N elements and M operations, this function returns the lexicographically smallest possible array after performing exactly M operations. >>> lexicographically_smallest_array_after_gcd_operations(5, 1, [12, 15, 9, 18, 24]) [3, 3, 3, 3, 3] >>> lexicographically_smallest_array_after_gcd_operations(4, 3, [6, 10, 15, 20]) [1, 1, 1, 1] import pytest def test_example_1(): N = 5 M = 1 array = [12, 15, 9, 18, 24] expected_output = [3, 3, 3, 3, 3] assert lexicographically_smallest_array_after_gcd_operations(N, M, array) == expected_output def test_example_2(): N = 4 M = 3 array = [6, 10, 15, 20] expected_output = [1, 1, 1, 1] assert lexicographically_smallest_array_after_gcd_operations(N, M, array) == expected_output def test_single_element_array(): N = 1 M = 1 array = [7] expected_output = [7] assert lexicographically_smallest_array_after_gcd_operations(N, M, array) == expected_output def test_all_elements_same(): N = 4 M = 100 array = [8, 8, 8, 8] expected_output = [8, 8, 8, 8] assert lexicographically_smallest_array_after_gcd_operations(N, M, array) == expected_output def test_large_M(): N = 4 M = 10**9 array = [2, 6, 8, 14] expected_output = [2, 2, 2, 2] assert lexicographically_smallest_array_after_gcd_operations(N, M, array) == expected_output def test_prime_numbers(): N = 5 M = 5 array = [2, 3, 5, 7, 11] expected_output = [1, 1, 1, 1, 1] assert lexicographically_smallest_array_after_gcd_operations(N, M, array) == expected_output if __name__ == \\"__main__\\": pytest.main()","solution":"from math import gcd from functools import reduce def calculate_gcd_of_array(arr): This function calculates the GCD of all elements in the array. return reduce(gcd, arr) def lexicographically_smallest_array_after_gcd_operations(N, M, array): Given an array of N elements and M operations, this function returns the lexicographically smallest possible array after performing exactly M operations. overall_gcd = calculate_gcd_of_array(array) return sorted([overall_gcd] * N)"},{"question":"def convex_hull(points): Computes the vertices of the convex hull of a set of 2D points. The convex hull is the smallest convex polygon that can enclose all the given points. :param points: List of points [(x1, y1), (x2, y2), ..., (xn, yn)] :return: List of vertices on the convex hull in clockwise order. >>> convex_hull([(0, 3), (1, 1), (2, 2), (4, 4), (0, 0), (1, 2), (3, 1), (3, 3)]) [(0, 0), (3, 1), (4, 4), (0, 3)] >>> convex_hull([(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)]) [(0, 0), (4, 4)] >>> convex_hull([(0, 0), (0, 1), (1, 0), (1, 1)]) [(0, 0), (1, 0), (1, 1), (0, 1)] >>> convex_hull([(0, 0), (1, 1), (2, 2), (1, 1), (0, 2), (2, 0), (2, 2)]) [(0, 0), (2, 0), (2, 2), (0, 2)] >>> convex_hull([(2,2), (1,1), (2,3), (0,2), (1,3), (1,0)]) [(0,2), (1,0), (2,2), (2,3), (1,3)]","solution":"def convex_hull(points): Computes the vertices of the convex hull of a set of 2D points. :param points: List of points [(x1, y1), (x2, y2), ..., (xn, yn)] :return: List of vertices on the convex hull in clockwise order. # Remove duplicate points points = list(set(points)) # Sort points by x, then by y points.sort() def cross(o, a, b): return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]) # Build the lower hull lower = [] for p in points: while len(lower) >= 2 and cross(lower[-2], lower[-1], p) <= 0: lower.pop() lower.append(p) # Build the upper hull upper = [] for p in reversed(points): while len(upper) >= 2 and cross(upper[-2], upper[-1], p) <= 0: upper.pop() upper.append(p) # Concatenate lower and upper hull to get the full convex hull # The last point of each half is omitted because it's repeated at the beginning of the other half convex_hull = lower[:-1] + upper[:-1] return convex_hull"},{"question":"def minutes_to_time(N: int) -> str: Given the number of minutes N since midnight (0 ≤ N < 1440), return the current time in 12-hour format. >>> minutes_to_time(0) == \\"12:00 AM\\" >>> minutes_to_time(720) == \\"12:00 PM\\" >>> minutes_to_time(780) == \\"01:00 PM\\" >>> minutes_to_time(1020) == \\"05:00 PM\\" >>> minutes_to_time(1380) == \\"11:00 PM\\" >>> minutes_to_time(75) == \\"01:15 AM\\" >>> minutes_to_time(1439) == \\"11:59 PM\\"","solution":"def minutes_to_time(N): Given the number of minutes N since midnight, return the current time in 12-hour format. hours = N // 60 minutes = N % 60 period = \\"AM\\" if hours < 12 else \\"PM\\" hours = hours % 12 hours = 12 if hours == 0 else hours return f\\"{hours:02}:{minutes:02} {period}\\""},{"question":"def search_books(library, criteria): Returns a list of book titles that match the given search criteria. Parameters: - library (list): A list of dictionaries with book details. - criteria (dictionary): A dictionary containing search parameters. Returns: - list: List of titles that match the search criteria. >>> library = [ >>> {\\"title\\": \\"To Kill a Mockingbird\\", \\"author\\": \\"Harper Lee\\", \\"genre\\": \\"Fiction\\", \\"year\\": 1960}, >>> {\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"genre\\": \\"Dystopian\\", \\"year\\": 1949}, >>> {\\"title\\": \\"Moby Dick\\", \\"author\\": \\"Herman Melville\\", \\"genre\\": \\"Adventure\\", \\"year\\": 1851}, >>> {\\"title\\": \\"The Great Gatsby\\", \\"author\\": \\"F. Scott Fitzgerald\\", \\"genre\\": \\"Fiction\\", \\"year\\": 1925} >>> ] >>> criteria = {\\"author\\": \\"George Orwell\\"} >>> search_books(library, criteria) [\\"1984\\"] >>> criteria = {\\"genre\\": \\"Fiction\\", \\"year\\": 1960} >>> search_books(library, criteria) [\\"To Kill a Mockingbird\\"] >>> criteria = {\\"title\\": \\"the great gatsby\\"} >>> search_books(library, criteria) [\\"The Great Gatsby\\"]","solution":"def search_books(library, criteria): Returns a list of book titles that match the given search criteria. Parameters: - library (list): A list of dictionaries with book details. - criteria (dictionary): A dictionary containing search parameters. Returns: - list: List of titles that match the search criteria. def matches_criteria(book, criteria): for key, value in criteria.items(): if key in book: if isinstance(book[key], str) and not book[key].lower() == value.lower(): return False elif isinstance(book[key], int) and not book[key] == value: return False return True result = [] for book in library: if matches_criteria(book, criteria): result.append(book['title']) return result"},{"question":"def unpaired_element(arr): Write a function that takes a list of integers as input and returns the element that appears an odd number of times. You can assume there's exactly one such element in the list. >>> unpaired_element([2, 3, 2, 4, 4, 5, 3]) == 5 >>> unpaired_element([10, 15, 10, 30, 30]) == 15 >>> unpaired_element([20, 1, 1, 20, 1, 50, 50]) == 1 from solution import unpaired_element def test_unpaired_element_single_occurrence(): assert unpaired_element([5]) == 5 def test_unpaired_element_example_1(): assert unpaired_element([2, 3, 2, 4, 4, 5, 3]) == 5 def test_unpaired_element_example_2(): assert unpaired_element([10, 15, 10, 30, 30]) == 15 def test_unpaired_element_example_3(): assert unpaired_element([20, 1, 1, 20, 1, 50, 50]) == 1 def test_unpaired_element_large_list(): long_list = [x for x in range(1000000)] * 2 + [999999] # All numbers paired except one assert unpaired_element(long_list) == 999999","solution":"def unpaired_element(arr): Returns the element that appears an odd number of times in the list. Assumes exactly one such element exists. xor_result = 0 for num in arr: xor_result ^= num return xor_result"},{"question":"def longest_palindrome(n: int, chars: List[str]) -> str: Finds the longest palindrome that can be formed from the given set of characters. Parameters: n (int): Number of characters in the set. chars (List[str]): A list of n lowercase characters. Returns: str: The longest palindrome string. Examples: >>> longest_palindrome(5, ['a', 'b', 'c', 'b', 'a']) 'abcba' >>> longest_palindrome(4, ['a', 'b', 'c', 'd']) 'a' >>> longest_palindrome(6, ['a', 'a', 'b', 'b', 'c', 'c']) 'abccba' def test_longest_palindrome_case_1(): assert longest_palindrome(5, ['a', 'b', 'c', 'b', 'a']) == \\"abcba\\" def test_longest_palindrome_case_2(): assert longest_palindrome(4, ['a', 'b', 'c', 'd']) in [\\"a\\", \\"b\\", \\"c\\", \\"d\\"] def test_longest_palindrome_case_3(): assert longest_palindrome(6, ['a', 'a', 'b', 'b', 'c', 'c']) == \\"abccba\\" def test_longest_palindrome_single_character(): assert longest_palindrome(1, ['z']) == \\"z\\" def test_longest_palindrome_multiple_identical_character(): assert longest_palindrome(5, ['a', 'a', 'a', 'a', 'a']) == \\"aaaaa\\" assert longest_palindrome(5, ['b', 'b', 'b', 'b', 'b']) == \\"bbbbb\\" def test_longest_palindrome_empty_input(): assert longest_palindrome(0, []) == \\"\\" def test_longest_palindrome_all_unique_characters(): assert longest_palindrome(5, ['a', 'b', 'c', 'd', 'e']) in ['a', 'b', 'c', 'd', 'e']","solution":"from collections import Counter def longest_palindrome(n, chars): Finds the longest palindrome that can be formed from the given characters. Parameters: n (int): Number of characters in the set. chars (list): A list of n lowercase characters. Returns: str: The longest palindrome string. counter = Counter(chars) left_part = [] middle_part = '' for char, count in counter.items(): if count % 2 == 0: left_part.extend([char] * (count // 2)) else: left_part.extend([char] * (count // 2)) if middle_part == '': middle_part = char # Only one odd-character will be in center left_part = ''.join(left_part) right_part = left_part[::-1] return left_part + middle_part + right_part # Example usage: # print(longest_palindrome(5, ['a', 'b', 'c', 'b', 'a'])) # Output: \\"abcba\\""},{"question":"def smallest_concatenation(n: int) -> int: Returns the smallest concatenation of the numbers from 1 to n as a single integer. If it's not possible, returns -1. >>> smallest_concatenation(3) 123 >>> smallest_concatenation(10) 12345678910 >>> smallest_concatenation(0) -1 pass def solve(t: int, cases: List[int]) -> List[int]: Solves the problem for multiple test cases. >>> solve(3, [3, 5, 10]) [123, 12345, 12345678910] >>> solve(2, [1, 2]) [1, 12] >>> solve(4, [1, 2, 3, 4]) [1, 12, 123, 1234] pass","solution":"def smallest_concatenation(n): Returns the smallest concatenation of the numbers from 1 to n as a single integer. If it's not possible, returns -1. if n < 1: return -1 return int(\\"\\".join(str(i) for i in range(1, n + 1))) def solve(t, cases): results = [] for n in cases: results.append(smallest_concatenation(n)) return results"},{"question":"def almost_palindrome(s: str) -> bool: Checks if a given string is almost a palindrome. A string is considered almost a palindrome if it can be made into a palindrome by removing exactly one character. Args: s (str): Input string Returns: bool: True if the input string is almost a palindrome, False otherwise. Examples: >>> almost_palindrome(\\"radkar\\") True >>> almost_palindrome(\\"raceecar\\") True >>> almost_palindrome(\\"abc\\") False","solution":"def is_palindrome(s): Helper function to check if a given string is a palindrome. return s == s[::-1] def almost_palindrome(s): Returns True if the given string is an almost palindrome. A string is considered an almost palindrome if it can be made into a palindrome by removing exactly one character. # Clean the string by removing non-alphanumeric characters and converting to lowercase cleaned = ''.join(c.lower() for c in s if c.isalnum()) # Check if already a palindrome if is_palindrome(cleaned): return True n = len(cleaned) for i in range(n): # Create a new string by skipping the i-th character new_string = cleaned[:i] + cleaned[i+1:] # Check if the new string is a palindrome if is_palindrome(new_string): return True return False"},{"question":"def max_non_overlapping_projects(test_cases): Find the maximum number of non-overlapping projects for each test case. >>> max_non_overlapping_projects([[(1, 3), (2, 5), (4, 6)]]) [2] >>> max_non_overlapping_projects([[(1, 2), (2, 4), (3, 5), (5, 6)]]) [3] def solve_input(T, data): Parse the input data and determine the maximum number of non-overlapping projects for each test case. >>> T = 2 >>> data = [3, (1, 3), (2, 5), (4, 6), 4, (1, 2), (2, 4), (3, 5), (5, 6)] >>> solve_input(T, data) [2, 3] from solution import solve_input def test_max_non_overlapping_projects_sample1(): T = 2 data = [ 3, (1, 3), (2, 5), (4, 6), 4, (1, 2), (2, 4), (3, 5), (5, 6) ] assert solve_input(T, data) == [2, 3] def test_max_non_overlapping_projects_multiple_cases(): T = 3 data = [ 2, (1, 2), (2, 3), 2, (1, 4), (2, 3), 3, (3, 4), (1, 4), (2, 4) ] assert solve_input(T, data) == [2, 1, 1] def test_max_non_overlapping_projects_large_intervals(): T = 1 data = [ 3, (1, 100000000), (2, 100000001), (100000000 - 1, 1000000000) ] assert solve_input(T, data) == [1] def test_max_non_overlapping_projects_edge_cases(): T = 1 data = [ 1, (1, 2) ] assert solve_input(T, data) == [1] T = 1 data = [ 2, (1, 2), (3, 4) ] assert solve_input(T, data) == [2] def test_max_non_overlapping_projects_no_overlap(): T = 1 data = [ 3, (1, 2), (2, 3), (3, 4) ] assert solve_input(T, data) == [3]","solution":"def max_non_overlapping_projects(test_cases): results = [] for projects in test_cases: projects.sort(key=lambda x: x[1]) # Sort by end time max_count = 0 previous_end_time = -1 for project in projects: start, end = project if start >= previous_end_time: max_count += 1 previous_end_time = end results.append(max_count) return results def solve_input(T, data): test_cases = [] index = 0 for _ in range(T): N = data[index] projects = [] index += 1 for _ in range(N): S, E = data[index] projects.append((S, E)) index += 1 test_cases.append(projects) return max_non_overlapping_projects(test_cases)"},{"question":"from datetime import datetime from typing import List, Tuple def effective_discount(campaigns: List[Tuple[str, str, int]], date: str) -> int: Determines the effective discount percentage on a given date, taking into account overlapping campaigns. Parameters: campaigns (list of tuples): A list where each tuple contains start date (YYYY-MM-DD), end date (YYYY-MM-DD), and discount percentage. date (str): The date (YYYY-MM-DD) for which to determine the effective discount. Returns: int: The effective discount percentage on the given date. If no campaigns are active on that date, returns 0. >>> campaigns = [(\\"2023-01-01\\", \\"2023-01-10\\", 15), (\\"2023-01-05\\", \\"2023-01-12\\", 20), (\\"2023-01-11\\", \\"2023-01-20\\", 10)] >>> date = \\"2023-01-06\\" >>> effective_discount(campaigns, date) 20 >>> campaigns = [(\\"2022-10-01\\", \\"2022-10-10\\", 25), (\\"2022-10-15\\", \\"2022-10-25\\", 30)] >>> date = \\"2022-10-05\\" >>> effective_discount(campaigns, date) 25 >>> campaigns = [] >>> date = \\"2023-01-01\\" >>> effective_discount(campaigns, date) 0 >>> campaigns = [(\\"2022-10-01\\", \\"2022-10-05\\", 10), (\\"2022-10-15\\", \\"2022-10-20\\", 20)] >>> date = \\"2022-10-10\\" >>> effective_discount(campaigns, date) 0 pass def parse_input(input_string: str) -> Tuple[List[Tuple[str, str, int]], str]: Parses the input string and returns campaigns and date. Parameters: input_string (str): The input string containing campaigns and date. Returns: tuple: A tuple containing a list of campaigns and the date to query. >>> input_string = \\"3n2023-01-01 2023-01-10 15n2023-01-05 2023-01-12 20n2023-01-11 2023-01-20 10n2023-01-06\\" >>> campaigns, date = parse_input(input_string) >>> expected_campaigns = [(\\"2023-01-01\\", \\"2023-01-10\\", 15), (\\"2023-01-05\\", \\"2023-01-12\\", 20), (\\"2023-01-11\\", \\"2023-01-20\\", 10)] >>> campaigns == expected_campaigns True >>> date '2023-01-06' pass","solution":"from datetime import datetime def effective_discount(campaigns, date): Determines the effective discount percentage on a given date, taking into account overlapping campaigns. Parameters: campaigns (list of tuples): A list where each tuple contains start date (YYYY-MM-DD), end date (YYYY-MM-DD), and discount percentage. date (str): The date (YYYY-MM-DD) for which to determine the effective discount. Returns: int: The effective discount percentage on the given date. If no campaigns are active on that date, returns 0. max_discount = 0 query_date = datetime.strptime(date, \\"%Y-%m-%d\\") for start_date, end_date, discount in campaigns: start_date = datetime.strptime(start_date, \\"%Y-%m-%d\\") end_date = datetime.strptime(end_date, \\"%Y-%m-%d\\") if start_date <= query_date <= end_date: max_discount = max(max_discount, discount) return max_discount def parse_input(input_string): Parses the input string and returns campaigns and date. Parameters: input_string (str): The input string containing campaigns and date. Returns: tuple: A tuple containing a list of campaigns and the date to query. lines = input_string.strip().split('n') n = int(lines[0]) campaigns = [] for i in range(1, 1 + n): start_date, end_date, discount = lines[i].split() discount = int(discount) campaigns.append((start_date, end_date, discount)) query_date = lines[-1] return campaigns, query_date"},{"question":"def max_gold(t, cases): Compute the maximal amount of gold you can collect following the given rules. Arguments: t -- the number of test cases cases -- a list of tuples, where each tuple contains an integer n (the number of piles) and a list of integers representing the amount of gold in each pile Returns: A list of integers representing the maximal amount of gold that can be collected for each test case Example: >>> max_gold(1, [(4, [1, 2, 3, 4])]) [9] >>> max_gold(1, [(5, [1, 5, 3, 2, 4])]) [10] >>> max_gold(1, [(3, [10, 20, 30])]) [60]","solution":"def max_gold(t, cases): results = [] for case in cases: n, gold_piles = case max_gold_collected = 0 for i in range(0, n-2): # Taking 3 piles at a time for maximum sum of 3 max_gold_collected = max(max_gold_collected, gold_piles[i] + gold_piles[i+1] + gold_piles[i+2]) results.append(max_gold_collected) return results"},{"question":"def num_distinct_integers(n: int) -> int: Returns the number of distinct integers that can be represented using exactly n symbols among A, B, C, and D. >>> num_distinct_integers(1) 4 >>> num_distinct_integers(2) 10 >>> num_distinct_integers(3) 20","solution":"from itertools import combinations_with_replacement def num_distinct_integers(n): Returns the number of distinct integers that can be represented using exactly n symbols among A, B, C, and D. # Mapping for symbols to their respective numbers mapper = {'A': 2, 'B': 3, 'C': 5, 'D': 7} # Get the list of values values = list(mapper.values()) if n == 1: return len(values) # To store products distinct_products = set() # Generate all possible combinations with replacement for comb in combinations_with_replacement(values, n): product = 1 for num in comb: product *= num distinct_products.add(product) return len(distinct_products)"},{"question":"def check_password(password: str) -> str: Check if the password is valid based on the criteria: - The password must be at least 6 characters long. - The password must contain at least one uppercase letter and one digit. - The password must be a valid palindrome. Returns \\"VALID\\" if the password meets all criteria, otherwise \\"INVALID\\". >>> check_password(\\"A1B2B1A\\") \\"VALID\\" >>> check_password(\\"AB1BA\\") \\"INVALID\\" >>> check_password(\\"ABCDE\\") \\"INVALID\\"","solution":"def check_password(password): Check if the password is valid based on the given criteria. :param password: Password string to check. :return: \\"VALID\\" if the password meets all criteria, otherwise \\"INVALID\\". # Check if the password is at least 6 characters long if len(password) < 6: return \\"INVALID\\" # Check if the password contains at least one uppercase letter and one digit has_upper = any(char.isupper() for char in password) has_digit = any(char.isdigit() for char in password) if not (has_upper and has_digit): return \\"INVALID\\" # Check if the password is a palindrome if password != password[::-1]: return \\"INVALID\\" return \\"VALID\\""},{"question":"def longest_uniform_subarray(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[Tuple[int, int]]: Find the length and value of the longest subarray where all elements are the same for multiple test cases. Args: t (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): Each test case is a tuple with an integer N and a list of N integers. Returns: List[Tuple[int, int]]: A list of tuples where each tuple contains the length of the longest subarray and the value of the elements in this subarray for each test case. >>> longest_uniform_subarray(3, [(7, [4, 4, 4, 4, 5, 5, 5]), (8, [6, 6, 6, 6, 6, 1, 1, 1]), (5, [3, 3, 2, 2, 2])]) [(4, 4), (5, 6), (3, 2)] >>> longest_uniform_subarray(1, [(5, [1, 2, 3, 4, 5])]) [(1, 1)]","solution":"def longest_uniform_subarray(t, test_cases): result = [] for case in test_cases: n, arr = case max_length = 1 current_length = 1 value = arr[0] current_value = arr[0] for i in range(1, n): if arr[i] == current_value: current_length += 1 else: if current_length > max_length: max_length = current_length value = current_value current_value = arr[i] current_length = 1 # Check last subarray if current_length > max_length: max_length = current_length value = current_value result.append((max_length, value)) return result"},{"question":"def maximumGap(nums): Given an integer array nums, return the maximum difference between two successive elements in its sorted form. If the array contains less than two elements, return 0. You must solve it in linear time and using linear extra space. >>> maximumGap([3, 6, 9, 1]) 3 >>> maximumGap([10]) 0 from typing import List import unittest class TestMaximumGap(unittest.TestCase): def test_maximum_gap_example1(self): self.assertEqual(maximumGap([3, 6, 9, 1]), 3) def test_maximum_gap_example2(self): self.assertEqual(maximumGap([10]), 0) def test_maximum_gap_empty(self): self.assertEqual(maximumGap([]), 0) def test_maximum_gap_identical_elements(self): self.assertEqual(maximumGap([5, 5, 5, 5, 5]), 0) def test_maximum_gap_sorted_order(self): self.assertEqual(maximumGap([1, 2, 3, 4, 5]), 1) def test_maximum_gap_unsorted_order(self): self.assertEqual(maximumGap([10, 20, 0, 30, 25, 15]), 10) def test_maximum_gap_minimum_size_array(self): self.assertEqual(maximumGap([1, 1000000000]), 999999999) def test_maximum_gap_large_numbers(self): self.assertEqual(maximumGap([1000000000, 999999999, 1000000001]), 1) if __name__ == \\"__main__\\": unittest.main()","solution":"def maximumGap(nums): Returns the maximum difference between two successive elements in the sorted form of nums. if len(nums) < 2: return 0 nums.sort() max_gap = 0 for i in range(1, len(nums)): max_gap = max(max_gap, nums[i] - nums[i - 1]) return max_gap"},{"question":"from typing import List def longest_palindromic_subsequence(s: str) -> int: Returns the length of the longest palindromic subsequence in the given string s. >>> longest_palindromic_subsequence(\\"ABBDCACB\\") 5 >>> longest_palindromic_subsequence(\\"AAAA\\") 4 >>> longest_palindromic_subsequence(\\"ABCDE\\") 1 pass def process_test_cases(test_cases: List[str]) -> List[int]: Process multiple test cases to determine the length of the longest palindromic subsequence for each. >>> process_test_cases([\\"ABBDCACB\\", \\"AAAA\\", \\"ABCDE\\"]) [5, 4, 1] >>> process_test_cases([\\"A\\", \\"AA\\", \\"ABCBA\\", \\"ABCCBA\\"]) [1, 2, 5, 6] pass","solution":"def longest_palindromic_subsequence(s): Returns the length of the longest palindromic subsequence in the given string s. n = len(s) dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = 1 for cl in range(2, n + 1): for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j] and cl == 2: dp[i][j] = 2 elif s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) return dp[0][n - 1] def process_test_cases(test_cases): results = [] for s in test_cases: results.append(longest_palindromic_subsequence(s)) return results"},{"question":"def hasCycle(n: int, adjacencyList: List[List[int]]) -> bool: Determine if the undirected graph contains a cycle. >>> hasCycle(4, [[1, 2], [0, 2], [0, 1, 3], [2]]) True >>> hasCycle(3, [[1], [0, 2], [1]]) False","solution":"def hasCycle(n, adjacencyList): def dfs(node, parent, visited): visited[node] = True for neighbor in adjacencyList[node]: if not visited[neighbor]: if dfs(neighbor, node, visited): return True elif neighbor != parent: return True return False visited = [False] * n for i in range(n): if not visited[i]: if dfs(i, -1, visited): return True return False"},{"question":"class SegmentTree: def __init__(self, data): self.n = len(data) self.tree = [0] * (2 * self.n) self.lazy = [0] * (2 * self.n) # Store the data in the leaves of the tree for i in range(self.n): self.tree[self.n + i] = data[i] # Build the tree by calculating the maximum of children for i in range(self.n - 1, 0, -1): self.tree[i] = max(self.tree[i * 2], self.tree[i * 2 + 1]) def update_range(self, l, r, value): l += self.n r += self.n # Adding value to all nodes in the range [l, r) while l < r: if l & 1: self.lazy_update(l, value) l += 1 if r & 1: r -= 1 self.lazy_update(r, value) l >>= 1 r >>= 1 self.push_up() def lazy_update(self, pos, value): self.tree[pos] += value if pos < self.n: self.lazy[pos] += value def push_up(self): for i in range(1, self.n): pos = (self.n - 1 + i) >> 1 self.tree[pos] = max(self.tree[2 * pos], self.tree[2 * pos + 1]) + self.lazy[pos] def query_range(self, l, r): l += self.n r += self.n self.push_down(l) self.push_down(r - 1) maximum = -float('inf') while l < r: if l & 1: maximum = max(maximum, self.tree[l]) l += 1 if r & 1: r -= 1 maximum = max(maximum, self.tree[r]) l >>= 1 r >>= 1 return maximum def push_down(self, pos): depth = 0 while (pos >> depth) > 0: depth += 1 for d in range(depth, 0, -1): parent = pos >> d if self.lazy[parent] != 0: self.lazy_update(parent * 2, self.lazy[parent]) self.lazy_update(parent * 2 + 1, self.lazy[parent]) self.lazy[parent] = 0 def process_tasks(n, tasks, data): Process a series of update and query tasks on a list of integers using a Segment Tree. Args: n : int : The number of integers in the list. tasks : List[tuple] : A list of tasks where each task is represented as a tuple. data : List[int] : The initial state of the list of integers. Returns: List[int] : The results of all query operations. >>> process_tasks(5, [(2, 1, 5), (1, 2, 4, 3), (2, 2, 4)], [1, 3, 5, 7, 9]) [9, 10] >>> process_tasks(1, [(2, 1, 1)], [8]) [8] >>> process_tasks(5, [(1, 1, 5, 5), (2, 1, 5)], [2, 4, 6, 8, 10]) [15] >>> process_tasks(100000, [(1, 1, 100000, 1), (2, 1, 100000)], [1] * 100000) [2] seg_tree = SegmentTree(data) results = [] for task in tasks: if task[0] == 1: # Update operation _, i, j, v = task seg_tree.update_range(i - 1, j, v) elif task[0] == 2: # Query operation _, i, j = task results.append(seg_tree.query_range(i - 1, j)) return results","solution":"class SegmentTree: def __init__(self, data): self.n = len(data) self.tree = [0] * (2 * self.n) self.lazy = [0] * (2 * self.n) # Store the data in the leaves of the tree for i in range(self.n): self.tree[self.n + i] = data[i] # Build the tree by calculating the maximum of children for i in range(self.n - 1, 0, -1): self.tree[i] = max(self.tree[i * 2], self.tree[i * 2 + 1]) def update_range(self, l, r, value): l += self.n r += self.n # Adding value to all nodes in the range [l, r) while l < r: if l & 1: self.lazy_update(l, value) l += 1 if r & 1: r -= 1 self.lazy_update(r, value) l >>= 1 r >>= 1 self.push_up() def lazy_update(self, pos, value): self.tree[pos] += value if pos < self.n: self.lazy[pos] += value def push_up(self): for i in range(1, self.n): pos = (self.n - 1 + i) >> 1 self.tree[pos] = max(self.tree[2 * pos], self.tree[2 * pos + 1]) + self.lazy[pos] def query_range(self, l, r): l += self.n r += self.n self.push_down(l) self.push_down(r - 1) maximum = -float('inf') while l < r: if l & 1: maximum = max(maximum, self.tree[l]) l += 1 if r & 1: r -= 1 maximum = max(maximum, self.tree[r]) l >>= 1 r >>= 1 return maximum def push_down(self, pos): depth = 0 while (pos >> depth) > 0: depth += 1 for d in range(depth, 0, -1): parent = pos >> d if self.lazy[parent] != 0: self.lazy_update(parent * 2, self.lazy[parent]) self.lazy_update(parent * 2 + 1, self.lazy[parent]) self.lazy[parent] = 0 def process_tasks(n, tasks, data): seg_tree = SegmentTree(data) results = [] for task in tasks: if task[0] == 1: # Update operation _, i, j, v = task seg_tree.update_range(i - 1, j, v) elif task[0] == 2: # Query operation _, i, j = task results.append(seg_tree.query_range(i - 1, j)) return results"},{"question":"from collections import defaultdict from typing import List, Tuple def largest_gcd_subset_size(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the size of the largest subset where the GCD of all numbers is greater than 1. >>> largest_gcd_subset_size([(5, [10, 15, 20, 25, 30]), (4, [3, 6, 9, 12])]) [5, 4] def process_input(input_data: str) -> List[Tuple[int, List[int]]]: Process the input data to extract the test cases. >>> process_input(\\"2n5n10 15 20 25 30n4n3 6 9 12\\") [(5, [10, 15, 20, 25, 30]), (4, [3, 6, 9, 12])] def process_output(results: List[int]) -> str: Convert the results list to a formatted string output. >>> process_output([5, 4]) \\"5n4\\" from solution import largest_gcd_subset_size, process_input, process_output def test_largest_gcd_subset_size_example_cases(): input_data = \\"2n5n10 15 20 25 30n4n3 6 9 12\\" expected_output = \\"5n4\\" test_cases = process_input(input_data) results = largest_gcd_subset_size(test_cases) output = process_output(results) assert output == expected_output def test_largest_gcd_subset_size_single_element(): input_data = \\"1n1n10\\" expected_output = \\"1\\" test_cases = process_input(input_data) results = largest_gcd_subset_size(test_cases) output = process_output(results) assert output == expected_output def test_largest_gcd_subset_size_multiple_primes(): input_data = \\"1n5n2 3 5 7 11\\" expected_output = \\"1\\" test_cases = process_input(input_data) results = largest_gcd_subset_size(test_cases) output = process_output(results) assert output == expected_output def test_largest_gcd_subset_size_common_gcd(): input_data = \\"1n4n6 9 12 18\\" expected_output = \\"4\\" test_cases = process_input(input_data) results = largest_gcd_subset_size(test_cases) output = process_output(results) assert output == expected_output","solution":"from collections import defaultdict from math import gcd def largest_gcd_subset_size(test_cases): def sieve(n): is_prime = [True] * (n + 1) is_prime[0] = is_prime[1] = False for i in range(2, int(n**0.5) + 1): if is_prime[i]: for j in range(i * i, n + 1, i): is_prime[j] = False return [x for x in range(2, n + 1) if is_prime[x]] def get_prime_factors(n): factors = [] for prime in primes: if prime * prime > n: break if n % prime == 0: while n % prime == 0: n //= prime factors.append(prime) if n > 1: factors.append(n) return factors results = [] primes = sieve(100000) for n, arr in test_cases: frequency = defaultdict(int) for number in arr: factors = get_prime_factors(number) for factor in factors: frequency[factor] += 1 largest_size = max(frequency.values(), default=1) results.append(largest_size) return results def process_input(input_data): lines = input_data.strip().split('n') t = int(lines[0]) test_cases = [] index = 1 for _ in range(t): n = int(lines[index]) arr = list(map(int, lines[index + 1].split())) test_cases.append((n, arr)) index += 2 return test_cases def process_output(results): return \\"n\\".join(map(str, results))"},{"question":"def maxMoney(money): Given an array of integers representing the amount of money in each house, calculate the maximum amount of money that can be robbed without alerting the police. >>> maxMoney([2, 7, 9, 3, 1]) 12 >>> maxMoney([1, 2, 3, 1]) 4 >>> maxMoney([]) 0 >>> maxMoney([10]) 10 >>> maxMoney([5, 10]) 10 >>> maxMoney([2, 1, 1, 2]) 4 >>> maxMoney([1, 100, 1, 100, 1, 100]) 300 >>> maxMoney([5, 5, 5, 5, 5]) 15 >>> maxMoney([i for i in range(1000)]) 250000","solution":"def maxMoney(money): Given an array of integers representing the amount of money in each house, calculate the maximum amount of money that can be robbed without alerting the police. if not money: return 0 if len(money) == 1: return money[0] N = len(money) dp = [0] * N dp[0] = money[0] dp[1] = max(money[0], money[1]) for i in range(2, N): dp[i] = max(dp[i-1], dp[i-2] + money[i]) return dp[-1]"},{"question":"def longest_magical_subsequence(n: int, sequence: List[int]) -> int: Calculates the length of the longest magical subsequence from the original sequence. A subsequence is magical if the sum of its elements is positive and all elements are distinct. >>> longest_magical_subsequence(5, [4, -1, 2, -3, 5]) == 3 >>> longest_magical_subsequence(4, [-1, -2, -3, -4]) == 0 >>> longest_magical_subsequence(7, [1, 2, 3, -1, -2, 4, 5]) == 5","solution":"def longest_magical_subsequence(n, sequence): Calculates the length of the longest magical subsequence from the original sequence. A subsequence is magical if the sum of its elements is positive and all elements are distinct. if n == 0: return 0 # Filter positive unique elements unique_positive_elements = [x for x in set(sequence) if x > 0] # Check if there are no positive distinct elements if not unique_positive_elements: return 0 return len(unique_positive_elements)"},{"question":"def trailing_zeros_in_factorial(n: int) -> int: Given an integer n, returns the number of trailing zeros in the factorial of n. >>> trailing_zeros_in_factorial(1) == 0 >>> trailing_zeros_in_factorial(5) == 1 >>> trailing_zeros_in_factorial(25) == 6 >>> trailing_zeros_in_factorial(50) == 12 >>> trailing_zeros_in_factorial(100) == 24 >>> trailing_zeros_in_factorial(1000) == 249 >>> trailing_zeros_in_factorial(10000) == 2499 >>> trailing_zeros_in_factorial(0) == 0 >>> trailing_zeros_in_factorial(1000000000) == 249999998","solution":"def trailing_zeros_in_factorial(n): Given an integer n, returns the number of trailing zeros in the factorial of n. count_zeros = 0 power_of_five = 5 while n >= power_of_five: count_zeros += n // power_of_five power_of_five *= 5 return count_zeros"},{"question":"from typing import List def longest_subarray(arr: List[int], k: int) -> int: Given an integer array \`arr\`, find the length of the longest subarray where the difference between any two elements is at most \`k\`. >>> longest_subarray([1, 5, 3, 2, 4, 6], 2) 3 >>> longest_subarray([8, 8, 8, 8], 0) 4 >>> longest_subarray([10, 1, 2, 3, 4, 7, 6], 3) 4 def test_example_1(): assert longest_subarray([1, 5, 3, 2, 4, 6], 2) == 3 def test_example_2(): assert longest_subarray([8, 8, 8, 8], 0) == 4 def test_example_3(): assert longest_subarray([10, 1, 2, 3, 4, 7, 6], 3) == 4 def test_with_no_elements(): assert longest_subarray([], 5) == 0 def test_with_single_element(): assert longest_subarray([5], 5) == 1 def test_with_all_elements_same(): assert longest_subarray([2, 2, 2, 2, 2], 0) == 5 def test_with_large_numbers(): assert longest_subarray([1000000, 1000001, 1000002], 2) == 3 def test_with_zero_k(): assert longest_subarray([1, 2, 3, 4, 5], 0) == 1 def test_with_large_k(): assert longest_subarray([5, 1, 2, 7, 3, 10], 1000000) == 6","solution":"from typing import List def longest_subarray(arr: List[int], k: int) -> int: if not arr: return 0 left, right = 0, 0 max_len = 0 min_val, max_val = arr[0], arr[0] while right < len(arr): min_val = min(min_val, arr[right]) max_val = max(max_val, arr[right]) if max_val - min_val <= k: max_len = max(max_len, right - left + 1) right += 1 else: left += 1 min_val = min(arr[left:right+1]) max_val = max(arr[left:right+1]) right += 1 return max_len"},{"question":"def splat_paint(W: int, H: int, K: int, splat_coords: List[Tuple[int, int]]) -> int: Determine how many cells are painted after the paint has spread infinitely. Args: W : int : width of the grid. H : int : height of the grid. K : int : number of initially splatted cells. splat_coords : List[Tuple[int, int]] : list of coordinates of initially splatted cells. Returns: int : the number of cells that are painted after infinite spreading. >>> splat_paint(5, 4, 2, [(1, 2), (3, 3)]) 20 >>> splat_paint(3, 3, 1, [(2, 2)]) 9 >>> splat_paint(5, 5, 0, []) 0","solution":"def splat_paint(W, H, K, splat_coords): if K == 0: return 0 painted = set() # Adding initial splatted cells for x, y in splat_coords: painted.add((x, y)) # BFS to spread the paint queue = list(painted) while queue: x, y = queue.pop(0) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 1 <= nx <= W and 1 <= ny <= H and (nx, ny) not in painted: painted.add((nx, ny)) queue.append((nx, ny)) return len(painted)"},{"question":"def find_pair(arr, target): Determines if there are two distinct indices i and j in the array such that the absolute difference between the integers at these indices is equal to the target. :param arr: List of integers :param target: Integer target :return: True if such a pair exist, otherwise False >>> find_pair([1, 5, 3, 4, 2], 2) True >>> find_pair([1, 2, 3, 4, 5], 6) False >>> find_pair([8, 12, 16, 4, 0, 20], 8) True >>> find_pair([10, 15, 3, 7], 5) True","solution":"def find_pair(arr, target): Determines if there are two distinct indices i and j in the array such that the absolute difference between the integers at these indices is equal to the target. :param arr: List of integers :param target: Integer target :return: True if such a pair exist, otherwise False num_set = set(arr) for num in arr: if (num + target in num_set) or (num - target in num_set): return True return False"},{"question":"from typing import List, Tuple def is_homogeneous(grid: List[str], a: int, b: int, c: int, d: int) -> str: Check if the subgrid defined by (a, b) to (c, d) is homogeneous. pass def homogeneous_queries(n: int, m: int, q: int, grid: List[str], queries: List[Tuple[int, int, int, int]]) -> List[str]: Determine if each specified subgrid in the list of queries is homogeneous. >>> homogeneous_queries(3, 4, 2, [\\"aaaa\\", \\"bbbb\\", \\"cccc\\"], [(1, 1, 1, 4), (2, 1, 3, 4)]) [\\"YES\\", \\"NO\\"] >>> homogeneous_queries(4, 5, 3, [\\"abcde\\", \\"fghij\\", \\"klmno\\", \\"pqrst\\"], [(1, 1, 2, 2), (2, 3, 3, 5), (1, 1, 4, 5)]) [\\"NO\\", \\"NO\\", \\"NO\\"] pass","solution":"def is_homogeneous(grid, a, b, c, d): first_letter = grid[a][b] for i in range(a, c + 1): for j in range(b, d + 1): if grid[i][j] != first_letter: return \\"NO\\" return \\"YES\\" def homogeneous_queries(n, m, q, grid, queries): results = [] for query in queries: a, b, c, d = query # Convert to 0-based indexing for internal grid representation a -= 1 b -= 1 c -= 1 d -= 1 result = is_homogeneous(grid, a, b, c, d) results.append(result) return results"},{"question":"def is_valid_identifier(s: str) -> bool: Determine if a given string is a valid identifier. A string is considered to be a valid identifier if it meets the following criteria: 1. It starts with a letter (either uppercase or lowercase) or an underscore ('_'). 2. The remaining characters can be any combination of letters, digits, or underscores. >>> is_valid_identifier(\\"variable_name_1\\") True >>> is_valid_identifier(\\"_startWithUnderscore\\") True >>> is_valid_identifier(\\"a\\") True >>> is_valid_identifier(\\"\\") False >>> is_valid_identifier(\\"1_startWithNumber\\") False >>> is_valid_identifier(\\"variable-name\\") False >>> is_valid_identifier(\\"variable name\\") False >>> is_valid_identifier(\\"variable@name\\") False >>> is_valid_identifier(\\"Var1able_2Name\\") True >>> is_valid_identifier(\\"_123abc\\") True >>> is_valid_identifier(\\"3name\\") False","solution":"def is_valid_identifier(s): Determine if the given string is a valid identifier. :param s: String to be checked. :return: True if the string is a valid identifier, False otherwise. if not s: return False if not (s[0].isalpha() or s[0] == '_'): return False for char in s: if not (char.isalnum() or char == '_'): return False return True"},{"question":"def longest_even_sum_subsequence_length(n: int, arr: List[int]) -> int: Find the length of the longest subsequence with an even sum. Args: n: An integer representing the length of the array. arr: A list of integers, representing the array elements. Returns: The length of the longest subsequence with an even sum. Examples: >>> longest_even_sum_subsequence_length(5, [1, 3, 5, 7, 9]) 4 >>> longest_even_sum_subsequence_length(3, [2, 4, 6]) 3 >>> longest_even_sum_subsequence_length(6, [5, 7, 10, 12, 15, 20]) 5 >>> longest_even_sum_subsequence_length(1, [2]) 1 >>> longest_even_sum_subsequence_length(1, [1]) 0 >>> longest_even_sum_subsequence_length(6, [3, 5, 7, 2, 4, 6]) 5","solution":"def longest_even_sum_subsequence_length(n, arr): sum_arr = sum(arr) if sum_arr % 2 == 0: return n min_odd = float('inf') for num in arr: if num % 2 != 0: min_odd = min(min_odd, num) return n - 1 # Excluding smallest odd number"},{"question":"def process_operations(n, q, array, operations): Processes a series of operations on an array. Each operation can be one of three types: 1. Reverse a subarray from index \`l\` to \`r\`. 2. Increment each element in a subarray from index \`l\` to \`r\` by 1. 3. Return the sum of elements in a subarray from index \`l\` to \`r\`. Args: n (int): The size of the array. q (int): The number of operations. array (List[int]): The array on which operations are performed. operations (List[Tuple[int, int, int]]): The series of operations. Returns: List[int]: The results of the sum operations. >>> n, q = 5, 4 >>> array = [1, 2, 3, 4, 5] >>> operations = [ ... (2, 1, 3), ... (3, 0, 4), ... (1, 0, 2), ... (3, 0, 2) ... ] >>> process_operations(n, q, array, operations) [18, 8] >>> n, q = 6, 3 >>> array = [5, 6, 7, 8, 9, 10] >>> operations = [ ... (1, 1, 4), ... (2, 2, 5), ... (3, 0, 3) ... ] >>> process_operations(n, q, array, operations) [31] >>> n, q = 3, 3 >>> array = [1, 2, 3] >>> operations = [ ... (3, 0, 2), ... (1, 0, 1), ... (3, 0, 1) ... ] >>> process_operations(n, q, array, operations) [6, 3]","solution":"def process_operations(n, q, array, operations): result = [] for operation in operations: op_type, l, r = operation if op_type == 1: # Reverse subarray from l to r array[l:r+1] = array[l:r+1][::-1] elif op_type == 2: # Increment subarray from l to r by 1 for i in range(l, r+1): array[i] += 1 elif op_type == 3: # Sum subarray from l to r result.append(sum(array[l:r+1])) return result"},{"question":"def min_operations_to_transform(s: str, t: str) -> int: Returns the minimum number of operations required to transform string s into string t. >>> min_operations_to_transform(\\"kitten\\", \\"sitting\\") == 3 >>> min_operations_to_transform(\\"\\", \\"\\") == 0 >>> min_operations_to_transform(\\"\\", \\"abc\\") == 3 >>> min_operations_to_transform(\\"abc\\", \\"\\") == 3 >>> min_operations_to_transform(\\"abc\\", \\"abc\\") == 0 >>> min_operations_to_transform(\\"a\\", \\"ab\\") == 1 >>> min_operations_to_transform(\\"ab\\", \\"a\\") == 1 >>> min_operations_to_transform(\\"abc\\", \\"axc\\") == 1","solution":"def min_operations_to_transform(s, t): Returns the minimum number of operations required to transform string s into string t. m, n = len(s), len(t) # Create a (m+1)x(n+1) DP table dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize base cases for transformation for i in range(m + 1): dp[i][0] = i for j in range(n + 1): dp[0][j] = j # Fill the DP table for i in range(1, m + 1): for j in range(1, n + 1): if s[i - 1] == t[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], # Delete dp[i][j - 1], # Insert dp[i - 1][j - 1] # Replace ) return dp[m][n]"},{"question":"def uniquePaths(n, m, matrix): Given a matrix of dimensions n x m, determine the number of unique paths from the top-left corner to the bottom-right corner. You can only move either down or right at any point in time. Some cells contain obstacles (denoted by 1) which you cannot traverse. Args: n (int): number of rows in the matrix. m (int): number of columns in the matrix. matrix (List[List[int]]): the grid where each cell is either 0 (no obstacle) or 1 (obstacle). Returns: int: the number of unique paths from the top-left to the bottom-right corner, modulo 10**9 + 7. >>> uniquePaths(3, 3, [ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) 2 >>> uniquePaths(3, 3, [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) 6 >>> uniquePaths(3, 3, [ ... [1, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) 0 >>> uniquePaths(1, 1, [ ... [0] ... ]) 1 >>> uniquePaths(1, 1, [ ... [1] ... ]) 0","solution":"def uniquePaths(n, m, matrix): MOD = 10**9 + 7 if matrix[0][0] == 1 or matrix[n-1][m-1] == 1: return 0 dp = [[0] * m for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(m): if matrix[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] dp[i][j] %= MOD return dp[n-1][m-1]"},{"question":"def move_robot(instructions: str) -> tuple: Returns the final coordinates of the robot after executing the instruction sequence. >>> move_robot(\\"URR\\") (2, 1) >>> move_robot(\\"UUDDRR\\") (2, 0) def process_test_cases(test_cases: List[str]) -> List[tuple]: Processes multiple test cases and returns the final coordinates for each instruction set. >>> process_test_cases([\\"URR\\", \\"UUDDRR\\"]) [(2, 1), (2, 0)]","solution":"def move_robot(instructions): Returns the final coordinates of the robot after executing the instruction sequence. x, y = 0, 0 for instruction in instructions: if instruction == \\"U\\": y += 1 elif instruction == \\"D\\": y -= 1 elif instruction == \\"R\\": x += 1 return x, y def process_test_cases(test_cases): results = [] for instructions in test_cases: final_position = move_robot(instructions) results.append(final_position) return results"},{"question":"def can_form_consecutive_with_single_swap(n: int, arr: List[int]) -> str: Determine if the given array can form a consecutive sequence after a single swap between any two elements. Args: n (int): The length of the array. arr (List[int]): The array of integers. Returns: str: \\"YES\\" if it is possible to have a consecutive sequence after one swap, otherwise \\"NO\\". >>> can_form_consecutive_with_single_swap(3, [1, 3, 2]) \\"YES\\" >>> can_form_consecutive_with_single_swap(3, [2, 4, 3]) \\"YES\\" >>> can_form_consecutive_with_single_swap(3, [1, 4, 3]) \\"NO\\" pass def process_test_cases(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Process multiple test cases for checking consecutive sequence formation after a single swap. Args: T (int): Number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of tuples where each tuple contains the number of elements and the array. Returns: List[str]: List of results for each test case. >>> process_test_cases(3, [(3, [1, 3, 2]), (3, [2, 4, 3]), (3, [1, 4, 3])]) [\\"YES\\", \\"YES\\", \\"NO\\"] pass","solution":"def can_form_consecutive_with_single_swap(n, arr): # Check if the array is already a consecutive sequence sorted_arr = sorted(arr) if all(sorted_arr[i] == sorted_arr[0] + i for i in range(n)): return \\"YES\\" # Try to swap every pair of elements and check if it forms a consecutive sequence for i in range(n): for j in range(i + 1, n): arr[i], arr[j] = arr[j], arr[i] sorted_arr = sorted(arr) arr[i], arr[j] = arr[j], arr[i] # Swap back to original if all(sorted_arr[k] == sorted_arr[0] + k for k in range(n)): return \\"YES\\" return \\"NO\\" def process_test_cases(T, test_cases): results = [] for case in test_cases: n, arr = case results.append(can_form_consecutive_with_single_swap(n, arr)) return results"},{"question":"def min_runways(flights) -> int: Determines the minimum number of runways required so that no two flights overlap. Flights is a list of tuples where each tuple consists of start and end times of a flight. >>> min_runways([(1, 5), (2, 6), (8, 12), (5, 9)]) 2 >>> min_runways([(1, 2), (3, 4), (5, 6)]) 1 >>> min_runways([(1, 5), (2, 6), (4, 8)]) 3 >>> min_runways([(1, 4), (2, 5), (5, 9), (8, 12)]) 2 >>> min_runways([(1, 2), (2, 3), (3, 4)]) 1 >>> min_runways([]) 0 pass","solution":"def min_runways(flights): Determines the minimum number of runways required so that no two flights overlap. Flights is a list of tuples where each tuple consists of start and end times of a flight. if not flights: return 0 # Separate out all the start and end times starts = sorted([flight[0] for flight in flights]) ends = sorted([flight[1] for flight in flights]) s = e = 0 num_flights = len(flights) max_runways = current_runways = 0 # Iterate over times to find the maximum number of overlapping flights while s < num_flights: if starts[s] < ends[e]: current_runways += 1 max_runways = max(max_runways, current_runways) s += 1 else: current_runways -= 1 e += 1 return max_runways # Function to parse input and return the flights as a list of tuples def parse_input(): import sys flights = [] for line in sys.stdin: start, end = map(int, line.split()) if start == -1 and end == -1: break flights.append((start, end)) return flights # Main code block if __name__ == \\"__main__\\": flights = parse_input() print(min_runways(flights))"},{"question":"class AccountManager: def __init__(self): self.accounts = {} def add(self, account_id, name, age, balance): Add a new account to the account manager. Parameters: account_id (int): The unique ID of the account. name (str): The name of the account holder. age (int): The age of the account holder. balance (int): The initial balance of the account. pass def update(self, account_id, balance): Update the balance of an existing account. Parameters: account_id (int): The unique ID of the account. balance (int): The new balance to set. pass def balance(self, account_id): Retrieve the balance of an existing account. Parameters: account_id (int): The unique ID of the account. Returns: int: The balance of the account. pass def delete(self, account_id): Delete an existing account from the account manager. Parameters: account_id (int): The unique ID of the account. pass def process_commands(commands): Process a list of commands for the account manager and return results. Parameters: commands (List[str]): A list of commands to execute. Returns: List[int]: A list of results for 'balance' commands. pass def test_account_manager(): commands = [ \\"add 1 Alice 30 1000\\", \\"add 2 Bob 27 1500\\", \\"balance 1\\", \\"update 2 2000\\", \\"balance 2\\", \\"delete 1\\", \\"balance 2\\" ] expected_results = [1000, 2000, 2000] results = process_commands(commands) assert results == expected_results, f\\"Expected {expected_results}, but got {results}\\" def test_empty_manager(): commands = [] expected_results = [] results = process_commands(commands) assert results == expected_results, f\\"Expected {expected_results}, but got {results}\\" def test_multiple_updates(): commands = [ \\"add 1 Alice 30 1000\\", \\"update 1 1500\\", \\"balance 1\\", \\"update 1 2000\\", \\"balance 1\\" ] expected_results = [1500, 2000] results = process_commands(commands) assert results == expected_results, f\\"Expected {expected_results}, but got {results}\\" def test_delete_and_add_same_id(): commands = [ \\"add 1 Alice 30 1000\\", \\"delete 1\\", \\"add 1 Bob 25 2000\\", \\"balance 1\\" ] expected_results = [2000] results = process_commands(commands) assert results == expected_results, f\\"Expected {expected_results}, but got {results}\\" def test_non_existent_balance(): # Assuming all IDs given in the commands are valid and exist at the time of their respective command commands = [ \\"add 1 Alice 30 1000\\", \\"balance 1\\", \\"delete 1\\" ] expected_results = [1000] results = process_commands(commands) assert results == expected_results, f\\"Expected {expected_results}, but got {results}\\" def test_single_account_operations(): commands = [ \\"add 1 Alice 30 1000\\", \\"balance 1\\", \\"update 1 5000\\", \\"balance 1\\", \\"delete 1\\" ] expected_results = [1000, 5000] results = process_commands(commands) assert results == expected_results, f\\"Expected {expected_results}, but got {results}\\"","solution":"class AccountManager: def __init__(self): self.accounts = {} def add(self, account_id, name, age, balance): self.accounts[account_id] = { \\"name\\": name, \\"age\\": age, \\"balance\\": balance } def update(self, account_id, balance): if account_id in self.accounts: self.accounts[account_id]['balance'] = balance def balance(self, account_id): if account_id in self.accounts: return self.accounts[account_id]['balance'] def delete(self, account_id): if account_id in self.accounts: del self.accounts[account_id] def process_commands(commands): account_manager = AccountManager() results = [] for command in commands: parts = command.split() action = parts[0] if action == \\"add\\": account_id = int(parts[1]) name = parts[2] age = int(parts[3]) balance = int(parts[4]) account_manager.add(account_id, name, age, balance) elif action == \\"update\\": account_id = int(parts[1]) balance = int(parts[2]) account_manager.update(account_id, balance) elif action == \\"balance\\": account_id = int(parts[1]) results.append(account_manager.balance(account_id)) elif action == \\"delete\\": account_id = int(parts[1]) account_manager.delete(account_id) return results"},{"question":"def min_steps_to_reach_destination(grid, start, end): Determines the minimum number of steps required to go from the starting position to the ending position in a grid. Return -1 if it is not possible to reach the destination. :param grid: List[List[str]] - The grid representing open spaces ('0') and obstacles ('1') :param start: Tuple[int, int] - The starting position (r1, c1) :param end: Tuple[int, int] - The ending position (r2, c2) :return: int - The minimum number of steps required to reach from the starting position to the ending position, or -1 if not possible >>> grid1 = [ ... ['0', '0', '0', '0', '0'], ... ['0', '0', '1', '0', '0'], ... ['0', '0', '0', '0', '0'], ... ['0', '1', '0', '1', '0'], ... ['0', '0', '0', '0', '0'] ... ] >>> start1 = (0, 0) >>> end1 = (4, 4) >>> min_steps_to_reach_destination(grid1, start1, end1) 8 >>> grid2 = [ ... ['0', '1', '0'], ... ['0', '1', '0'], ... ['0', '1', '0'] ... ] >>> start2 = (0, 0) >>> end2 = (2, 2) >>> min_steps_to_reach_destination(grid2, start2, end2) -1","solution":"from collections import deque def min_steps_to_reach_destination(grid, start, end): m, n = len(grid), len(grid[0]) r1, c1 = start r2, c2 = end if grid[r1][c1] == '1' or grid[r2][c2] == '1': return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] visited = [[False for _ in range(n)] for _ in range(m)] queue = deque([(r1, c1, 0)]) visited[r1][c1] = True while queue: x, y, dist = queue.popleft() if (x, y) == (r2, c2): return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] == '0': visited[nx][ny] = True queue.append((nx, ny, dist + 1)) return -1"},{"question":"from typing import List def sumOfPrimes(numbers: List[int]) -> int: Calculate the sum of all prime numbers in the list. >>> sumOfPrimes([1, 2, 3, 4, 5]) 10 >>> sumOfPrimes([10, 11, 12, 13, 14]) 24 >>> sumOfPrimes([4, 6, 8, 10]) 0","solution":"def is_prime(n): Returns True if n is a prime number, else False. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def sumOfPrimes(numbers): Returns the sum of all prime numbers in the list numbers. return sum(n for n in numbers if is_prime(n))"},{"question":"from typing import List def compress(s: str) -> str: Compresses the given string using the described algorithm. >>> compress(\\"aaabbcdddd\\") \\"a3b2c1d4\\" >>> compress(\\"abc\\") \\"a1b1c1\\" pass def decompress(s: str) -> str: Decompresses the given compressed string back to its original form. >>> decompress(\\"a3b2c1d4\\") \\"aaabbcdddd\\" >>> decompress(\\"a1b1c1\\") \\"abc\\" pass if __name__ == \\"__main__\\": T = int(input()) results = [] for _ in range(T): type_ = input().strip() s = input().strip() if type_ == \\"compress\\": results.append(compress(s)) elif type_ == \\"decompress\\": results.append(decompress(s)) for result in results: print(result)","solution":"def compress(s): Compresses the given string using the described algorithm. if not s: return \\"\\" compressed = [] count = 1 prev_char = s[0] for char in s[1:]: if char == prev_char: count += 1 else: compressed.append(prev_char) compressed.append(str(count)) prev_char = char count = 1 compressed.append(prev_char) compressed.append(str(count)) return \\"\\".join(compressed) def decompress(s): Decompresses the given compressed string back to its original form. decompressed = [] i = 0 while i < len(s): char = s[i] count = int(s[i + 1]) decompressed.append(char * count) i += 2 return \\"\\".join(decompressed)"},{"question":"def max_final_coin_value(n: int, coins: List[int]) -> int: Returns the maximum possible value of the final coin after performing operations. >>> max_final_coin_value(3, [1, 2, 3]) 6 >>> max_final_coin_value(4, [2, 2, 1, 5]) 10","solution":"def max_final_coin_value(n, coins): Returns the maximum possible value of the final coin after performing operations. total_value = sum(coins) return total_value # Example usage: # n = 4 # coins = [2, 2, 1, 5] # print(max_final_coin_value(n, coins)) # Output: 10"},{"question":"def find_duplicates(nums: List[int]) -> List[int]: Returns a list of elements that appear twice in the array nums. >>> find_duplicates([4,3,2,7,8,2,3,1]) == [2, 3] >>> find_duplicates([1,1,2]) == [1] >>> find_duplicates([1]) == [] >>> find_duplicates([]) == [] >>> find_duplicates([2, 2, 3, 3, 3, 4, 4]) == [2, 3, 4] >>> find_duplicates(list(range(10000)) + list(range(10000))) == list(range(10000))","solution":"def find_duplicates(nums): Returns a list of elements that appear twice in the array nums. # Use a set to track the elements we have seen and a list to collect duplicates seen = set() duplicates = [] for num in nums: if num in seen: # If the num is already in seen, it's a duplicate if num not in duplicates: # To ensure we do not add it more than once duplicates.append(num) else: # Otherwise, add it to the seen set seen.add(num) return duplicates"},{"question":"def max_non_overlapping_time_slots(M: int, time_slots: List[Tuple[int, int]]) -> int: Determine the maximum number of non-overlapping time slots. Args: M (int): The number of employees. time_slots (List[Tuple[int, int]]): A list of tuples where each tuple contains the start and end time of an employee's preferred time slot. Returns: int: The maximum number of non-overlapping time slots. >>> max_non_overlapping_time_slots(5, [(1, 4), (3, 5), (0, 6), (5, 7), (8, 9)]) 3 >>> max_non_overlapping_time_slots(3, [(1, 2), (3, 4), (5, 6)]) 3 >>> max_non_overlapping_time_slots(3, [(1, 10), (2, 9), (3, 8)]) 1 >>> max_non_overlapping_time_slots(5, [(1, 4), (2, 3), (3, 5), (6, 8), (7, 9)]) 3 >>> max_non_overlapping_time_slots(4, [(1, 2), (2, 3), (3, 4), (4, 5)]) 4 >>> max_non_overlapping_time_slots(1, [(0, 1)]) 1","solution":"def max_non_overlapping_time_slots(M, time_slots): # Sort time slots by their end time time_slots.sort(key=lambda x: x[1]) # Initialize count of non-overlapping slots and end time of last added slot count = 0 last_end_time = -1 for start, end in time_slots: if start >= last_end_time: count += 1 last_end_time = end return count"},{"question":"def find_pairs_with_sum(arr: List[int], target: int) -> Union[Set[Tuple[int, int]], str]: Finds and returns unique pairs (a, b) from the list such that a + b equals the target and a < b to ensure unique pairs. >>> find_pairs_with_sum([1, 5, 7, -1, 5, 3], 6) {(1, 5), (-1, 7)} >>> find_pairs_with_sum([2, 4, 3, 5, 7], 9) {(2, 7), (4, 5)} >>> find_pairs_with_sum([1, 2, 3, 4], 8) \\"No pairs found\\"","solution":"def find_pairs_with_sum(arr, target): Finds and returns unique pairs (a, b) from the list such that a + b equals the target and a < b to ensure unique pairs. seen = set() pairs = set() for num in arr: complement = target - num if complement in seen: a, b = sorted((num, complement)) pairs.add((a, b)) seen.add(num) return pairs if pairs else \\"No pairs found\\" def get_input_output(): Handles input and output for the solution. n = int(input()) arr = list(map(int, input().split())) target = int(input()) result = find_pairs_with_sum(arr, target) if result == \\"No pairs found\\": print(result) else: for pair in result: print(pair)"},{"question":"def reverse_each_word(sentence: str) -> str: Given a string, reverse each word in the string. >>> reverse_each_word(\\"Hello World\\") 'olleH dlroW' >>> reverse_each_word(\\"Python is fun\\") 'nohtyP si nuf' >>> reverse_each_word(\\"A quick brown fox\\") 'A kciuq nworb xof' def process_test_cases(test_cases: List[str]) -> List[str]: Given multiple test cases, process each sentence and reverse each word. >>> process_test_cases([\\"Hello World\\", \\"Python is fun\\"]) ['olleH dlroW', 'nohtyP si nuf'] >>> process_test_cases([\\"A quick brown fox\\"]) ['A kciuq nworb xof']","solution":"def reverse_each_word(sentence): Given a string, reverse each word in the string. return ' '.join(word[::-1] for word in sentence.split()) def process_test_cases(test_cases): Given multiple test cases, process each sentence and reverse each word. return [reverse_each_word(test_case) for test_case in test_cases]"},{"question":"from typing import List def gcd_of_list(numbers: List[int]) -> int: Returns the greatest common divisor (GCD) of the list of numbers. >>> gcd_of_list([12, 15, 21]) 3 >>> gcd_of_list([36, 48, 18, 24]) 6 def process_datasets(datasets: List[List[int]]) -> List[int]: Processes a list of datasets and returns the GCD for each dataset. >>> process_datasets([[3, 12, 15, 21], [4, 36, 48, 18, 24]]) [3, 6] >>> process_datasets([[1, 1], [2, 1000000, 999999], [3, 17, 34, 51], [4, 7, 14, 28, 35]]) [1, 1, 17, 7]","solution":"from math import gcd from functools import reduce def gcd_of_list(numbers): Returns the greatest common divisor (GCD) of the list of numbers. return reduce(gcd, numbers) def process_datasets(datasets): Processes a list of datasets and returns the GCD for each dataset. results = [] for dataset in datasets: n, *numbers = dataset results.append(gcd_of_list(numbers)) return results"},{"question":"def can_complete_trip(s: int, a: int, b: int, d: int) -> str: Determines if a delivery person can complete a delivery round trip from the company's base to a customer's house and back without needing to recharge the scooter. :param s: Maximum speed of scooter in km/h (1 ≤ s ≤ 1000) :param a: Acceleration rate in km/h² (1 ≤ a ≤ 1000) :param b: Battery range in km (1 ≤ b ≤ 10000) :param d: Distance from base to customer's house in km (1 ≤ d ≤ 10000) :return: \\"YES\\" if the scooter can complete the round trip without recharging, \\"NO\\" otherwise >>> can_complete_trip(20, 5, 50, 15) 'YES' >>> can_complete_trip(15, 3, 30, 20) 'NO' from solution import can_complete_trip def test_exact_battery_range(): assert can_complete_trip(20, 5, 50, 25) == \\"YES\\" assert can_complete_trip(30, 10, 30, 15) == \\"YES\\" def test_more_than_battery_range(): assert can_complete_trip(20, 5, 50, 30) == \\"NO\\" assert can_complete_trip(25, 7, 50, 26) == \\"NO\\" def test_less_than_battery_range(): assert can_complete_trip(20, 5, 50, 15) == \\"YES\\" assert can_complete_trip(20, 5, 50, 20) == \\"YES\\" def test_edge_cases(): assert can_complete_trip(1, 1, 1, 1) == \\"NO\\" assert can_complete_trip(1, 1, 2, 1) == \\"YES\\" assert can_complete_trip(1000, 1000, 10000, 5000) == \\"YES\\" assert can_complete_trip(1000, 1000, 10000, 5001) == \\"NO\\"","solution":"def can_complete_trip(s, a, b, d): Determines if the scooter can complete the trip from base to customer's house and back. :param s: Maximum speed of scooter in km/h :param a: Acceleration rate in km/h² :param b: Battery range in km :param d: Distance from base to customer's house in km :return: \\"YES\\" if the scooter can complete the round trip, \\"NO\\" otherwise round_trip_distance = 2 * d if round_trip_distance <= b: return \\"YES\\" else: return \\"NO\\""},{"question":"def process_input(input_data: str) -> List[str]: Analyze the viewing patterns of users and find the viewer who watched the most unique sessions and the viewer with the longest total viewing time. >>> process_input(\\"3 4n1 101 1000 102 1500 103 2000 104 2500n2 102 2000 103 1500 101 2500 104 3000n3 101 3000 102 4000 103 5000 104 6000nn2 3n4 201 5000 202 6000 203 7000n5 202 7000 203 6000 201 5000nn0 0n\\") ['1', '3', '4', '4'] >>> process_input(\\"1 1n1 101 3600nn0 0n\\") ['1', '1'] >>> process_input(\\"0 0n\\") []","solution":"def analyze_viewing_patterns(data): result = [] datasets = data.strip().split(\\"nn\\") for dataset in datasets: lines = dataset.strip().split(\\"n\\") m, n = map(int, lines[0].split()) if m == 0 and n == 0: continue viewers = {} for i in range(1, m + 1): parts = lines[i].split() viewer_id = parts[0] sessions = parts[1:] unique_sessions = set() total_time = 0 for j in range(0, len(sessions), 2): session_id = sessions[j] view_time = int(sessions[j + 1]) unique_sessions.add(session_id) total_time += view_time viewers[viewer_id] = (len(unique_sessions), total_time) max_unique_sessions = -1 max_unique_id = None max_view_time = -1 max_view_time_id = None for viewer_id, (num_unique_sessions, total_time) in viewers.items(): if num_unique_sessions > max_unique_sessions: max_unique_sessions = num_unique_sessions max_unique_id = viewer_id elif num_unique_sessions == max_unique_sessions and max_unique_id == None: max_unique_id = viewer_id if total_time > max_view_time: max_view_time = total_time max_view_time_id = viewer_id elif total_time == max_view_time and max_view_time_id == None: max_view_time_id = viewer_id result.append(max_unique_id) result.append(max_view_time_id) return result def process_input(input_data): input_data = input_data.strip() if input_data == \\"\\": return [] datasets = input_data.split(\\"nn\\") result = [] for dataset in datasets: if '0 0' in dataset: break res = analyze_viewing_patterns(dataset) result.extend(res) return result"},{"question":"from typing import List, Tuple def process_queries(n: int, q: int, values: List[int], edges: List[Tuple[int, int]], queries: List[str]) -> List[int]: Given a tree with n nodes and a series of queries, process the queries and return the results for type 1 queries. :param n: Number of nodes in the tree :param q: Number of queries :param values: List of values associated with each node (1-based index) :param edges: List of tuples representing the edges in the tree :param queries: List of queries (type 1 or 2) :return: List of results for type 1 queries Example: >>> process_queries(5, 3, [1, 2, 3, 4, 5], [(1, 2), (1, 3), (2, 4), (2, 5)], [\\"1 3\\", \\"2 2 10\\", \\"1 2\\"]) [3, 19]","solution":"from collections import defaultdict class Tree: def __init__(self, n, values): self.n = n self.values = values self.adj_list = defaultdict(list) self.subtree_sum = [0] * (n + 1) self.visited = [False] * (n + 1) def add_edge(self, u, v): self.adj_list[u].append(v) self.adj_list[v].append(u) def dfs(self, node): self.visited[node] = True subtree_total = self.values[node - 1] for neighbor in self.adj_list[node]: if not self.visited[neighbor]: subtree_total += self.dfs(neighbor) self.subtree_sum[node] = subtree_total return subtree_total def update_value(self, node, value): self.values[node - 1] = value self.visited = [False] * (self.n + 1) self.dfs(1) def sum_subtree(self, node): return self.subtree_sum[node] def process_queries(n, q, values, edges, queries): tree = Tree(n, values) for u, v in edges: tree.add_edge(u, v) # Precompute the subtree sums with dfs from root node, assuming node 1 as root tree.dfs(1) result = [] for query in queries: parts = query.split() if parts[0] == '1': _, x = parts x = int(x) result.append(tree.sum_subtree(x)) elif parts[0] == '2': _, x, y = parts x, y = int(x), int(y) tree.update_value(x, y) return result"},{"question":"def can_partition_into_equal_subarrays(nums: List[int]) -> str: Determines if the array can be divided into two subarrays such that the sum of the elements in both subarrays is equal. Each element in the array can only belong to one subarray. Returns \\"YES\\" if the array can be divided into two such subarrays, otherwise returns \\"NO\\". >>> can_partition_into_equal_subarrays([1, 5, 11, 5]) \\"YES\\" >>> can_partition_into_equal_subarrays([1, 2, 3, 5]) \\"NO\\"","solution":"def can_partition_into_equal_subarrays(nums): Determines if the array can be divided into two subarrays such that the sum of the elements in both subarrays is equal. total_sum = sum(nums) # If the total sum is not even, we cannot partition it into two equal parts if total_sum % 2 != 0: return \\"NO\\" target_sum = total_sum // 2 n = len(nums) # dp[i] will be True if there is a subsequence with sum i dp = [False] * (target_sum + 1) dp[0] = True for num in nums: for i in range(target_sum, num - 1, -1): if dp[i - num]: dp[i] = True return \\"YES\\" if dp[target_sum] else \\"NO\\""},{"question":"def generate_triangle(base_length): Generate a triangle pattern of numbers with the specified base length. Args: base_length (int): The base length and the height of the triangle. Returns: List[str]: A list of strings representing each row of the triangle. pass def generate_patterns(n, base_lengths): Generate triangle patterns for multiple stones. Args: n (int): Number of stones. base_lengths (List[int]): List of base lengths for each stone. Returns: List[List[str]]: A list containing the triangle patterns for each stone. pass # Test cases from solution import generate_triangle, generate_patterns def test_generate_triangle_base_2(): expected_output = [\\"12\\", \\"23\\"] assert generate_triangle(2) == expected_output def test_generate_triangle_base_3(): expected_output = [\\"123\\", \\"234\\", \\"345\\"] assert generate_triangle(3) == expected_output def test_generate_triangle_base_4(): expected_output = [\\"1234\\", \\"2345\\", \\"3456\\", \\"4567\\"] assert generate_triangle(4) == expected_output def test_generate_patterns(): n = 3 base_lengths = [2, 3, 4] expected_output = [ [\\"12\\", \\"23\\"], [\\"123\\", \\"234\\", \\"345\\"], [\\"1234\\", \\"2345\\", \\"3456\\", \\"4567\\"] ] assert generate_patterns(n, base_lengths) == expected_output def test_generate_patterns_single_stone(): n = 1 base_lengths = [4] expected_output = [[\\"1234\\", \\"2345\\", \\"3456\\", \\"4567\\"]] assert generate_patterns(n, base_lengths) == expected_output def test_generate_patterns_multiple_identical_stones(): n = 2 base_lengths = [3, 3] expected_output = [ [\\"123\\", \\"234\\", \\"345\\"], [\\"123\\", \\"234\\", \\"345\\"] ] assert generate_patterns(n, base_lengths) == expected_output","solution":"def generate_triangle(base_length): Generate a triangle pattern of numbers with the specified base length. Args: base_length (int): The base length and the height of the triangle. Returns: List[str]: A list of strings representing each row of the triangle. triangle = [] for i in range(1, base_length + 1): row = ''.join(str((i + j) % 10) for j in range(base_length)) triangle.append(row) return triangle def generate_patterns(n, base_lengths): Generate triangle patterns for multiple stones. Args: n (int): Number of stones. base_lengths (List[int]): List of base lengths for each stone. Returns: List[List[str]]: A list containing the triangle patterns for each stone. patterns = [] for base_length in base_lengths: patterns.append(generate_triangle(base_length)) return patterns # Example usage: # n = 3 # base_lengths = [2, 3, 4] # patterns = generate_patterns(n, base_lengths) # for pattern in patterns: # for row in pattern: # print(row) # print()"},{"question":"def findKthSmallest(nums1: List[int], nums2: List[int], k: int) -> int: Find the k-th smallest number among the combined sorted arrays nums1 and nums2. Args: nums1 (List[int]): The first sorted array. nums2 (List[int]): The second sorted array. k (int): The k-th position to find the smallest number. Returns: int: The k-th smallest number. Example: >>> findKthSmallest([1, 3, 5], [2, 4, 6], 4) 4 >>> findKthSmallest([2, 3, 8], [1, 7], 3) 3","solution":"def findKthSmallest(nums1, nums2, k): Find the k-th smallest number in the merged sorted arrays nums1 and nums2. def kth(nums1, nums2, k): if not nums1: return nums2[k-1] if not nums2: return nums1[k-1] index1, index2 = len(nums1) // 2, len(nums2) // 2 median1, median2 = nums1[index1], nums2[index2] if index1 + index2 < k - 1: if median1 > median2: return kth(nums1, nums2[index2 + 1:], k - index2 - 1) else: return kth(nums1[index1 + 1:], nums2, k - index1 - 1) else: if median1 > median2: return kth(nums1[:index1], nums2, k) else: return kth(nums1, nums2[:index2], k) return kth(nums1, nums2, k)"},{"question":"def isSquareWord(word: str) -> bool: Determine if a given string is a \\"square word\\". A word is considered a \\"square word\\" if the indices of each letter can form a perfect square when summed together. Indices of letters start from 1 (1-indexed). >>> isSquareWord(\\"abc\\") == False >>> isSquareWord(\\"abbc\\") == True >>> isSquareWord(\\"zzz\\") == True >>> isSquareWord(\\"dd\\") == False >>> isSquareWord(\\"a\\") == True","solution":"import math def isSquareWord(word): Determine if the sum of the squares of the indices of each letter in the word is a perfect square. index_square_sum = sum((i + 1) ** 2 for i in range(len(word))) square_root = math.isqrt(index_square_sum) return square_root * square_root == index_square_sum"},{"question":"def max_guests(N, intervals): Determine the maximum number of guests that can be present at the party at the same time. Args: N (int): The number of guests. intervals (List[Tuple[int, int]]): A list of tuples where each tuple contains the start and end times for a guest's availability. >>> max_guests(5, [(1, 4), (2, 6), (4, 7), (5, 8), (3, 5)]) 3 >>> max_guests(3, [(1, 2), (3, 4), (5, 6)]) 1 >>> max_guests(3, [(1, 10), (2, 9), (3, 8)]) 3 >>> max_guests(4, [(1, 5), (2, 6), (5, 8), (7, 10)]) 2 import sys import io def test_max_guests_sample_input(): input_str = \\"5n1 4n2 6n4 7n5 8n3 5n\\" expected_output = \\"3n\\" sys.stdin = io.StringIO(input_str) sys.stdout = io.StringIO() N = int(input().strip()) intervals = [] for _ in range(N): start, end = map(int, input().strip().split()) intervals.append((start, end)) max_guests(N, intervals) output = sys.stdout.getvalue() assert output == expected_output def test_max_guests_no_overlap(): input_str = \\"3n1 2n3 4n5 6n\\" expected_output = \\"1n\\" sys.stdin = io.StringIO(input_str) sys.stdout = io.StringIO() N = int(input().strip()) intervals = [] for _ in range(N): start, end = map(int, input().strip().split()) intervals.append((start, end)) max_guests(N, intervals) output = sys.stdout.getvalue() assert output == expected_output def test_max_guests_all_overlap(): input_str = \\"3n1 10n2 9n3 8n\\" expected_output = \\"3n\\" sys.stdin = io.StringIO(input_str) sys.stdout = io.StringIO() N = int(input().strip()) intervals = [] for _ in range(N): start, end = map(int, input().strip().split()) intervals.append((start, end)) max_guests(N, intervals) output = sys.stdout.getvalue() assert output == expected_output def test_max_guests_partial_overlap(): input_str = \\"4n1 5n2 6n5 8n7 10n\\" expected_output = \\"2n\\" sys.stdin = io.StringIO(input_str) sys.stdout = io.StringIO() N = int(input().strip()) intervals = [] for _ in range(N): start, end = map(int, input().strip().split()) intervals.append((start, end)) max_guests(N, intervals) output = sys.stdout.getvalue() assert output == expected_output","solution":"def max_guests(N, intervals): events = [] for interval in intervals: start, end = interval events.append((start, 'start')) events.append((end, 'end')) events.sort() current_guests = 0 max_guests = 0 for event in events: if event[1] == 'start': current_guests += 1 max_guests = max(max_guests, current_guests) else: current_guests -= 1 print(max_guests)"},{"question":"def min_operations_to_equalize(sequence): Determine the minimum number of operations required to make all elements of the sequence the same integer. >>> min_operations_to_equalize([3, 3, 1, 1, 1]) 2 >>> min_operations_to_equalize([1, 1, 1, 1, 1]) 0 >>> min_operations_to_equalize([1, 2, 3, 4, 5]) 4 >>> min_operations_to_equalize([2, 2, 2, 3, 3]) 2 >>> min_operations_to_equalize([10, 10, 10, -10, -10, 10, 10, 10]) 2 >>> min_operations_to_equalize([1, 2, 3, 4, 5, 6]) 5 >>> min_operations_to_equalize([1, 2, 2, 3, 4, 5]) 4","solution":"def min_operations_to_equalize(sequence): from collections import Counter N = len(sequence) counter = Counter(sequence) max_freq = max(counter.values()) # The least number of operations to make all elements the same return N - max_freq # Example usage: # N = 5 # sequence = [3, 3, 1, 1, 1] # print(min_operations_to_equalize(sequence)) # Output: 2"},{"question":"def process_queries(A: List[int], queries: List[Tuple[int, int]]) -> List[int]: Perform Q queries on array A to find the maximum element in subarray A[L...R] for each query. Args: A : List[int] - The array of integers. queries : List[Tuple[int, int]] - List of tuples where each tuple contains two integers L and R Returns: List[int] - List of maximum elements for each query. Example: >>> process_queries([1, 3, -2, 8, 5], [(0, 2), (1, 3), (2, 4)]) [3, 8, 8] >>> process_queries([-1, -3, -2, -8, -5], [(0, 2), (1, 4)]) [-1, -2] >>> process_queries([1, 3, -2, 8, 5], [(2, 2), (4, 4)]) [-2, 5] >>> process_queries(list(range(1, 100001)), [(0, 99999)]) [100000]","solution":"import sys import math class SegmentTree: def __init__(self, data): self.n = len(data) self.tree = [0] * (2 * self.n) self.build(data) def build(self, data): for i in range(self.n): self.tree[self.n + i] = data[i] for i in range(self.n - 1, 0, -1): self.tree[i] = max(self.tree[i * 2], self.tree[i * 2 + 1]) def query(self, left, right): left += self.n right += self.n + 1 maximum = -sys.maxsize while left < right: if left % 2 == 1: maximum = max(maximum, self.tree[left]) left += 1 if right % 2 == 1: right -= 1 maximum = max(maximum, self.tree[right]) left //= 2 right //= 2 return maximum def process_queries(A, queries): seg_tree = SegmentTree(A) results = [] for L, R in queries: results.append(seg_tree.query(L, R)) return results # Example usage: N = 5 A = [1, 3, -2, 8, 5] Q = 3 queries = [(0, 2), (1, 3), (2, 4)] results = process_queries(A, queries) for result in results: print(result)"},{"question":"def min_meeting_rooms(meetings: List[Tuple[int, int]]) -> int: Calculate the minimum number of meeting rooms required to accommodate all the meetings. >>> min_meeting_rooms([(0, 30), (5, 10), (15, 20)]) 2 >>> min_meeting_rooms([(7, 10), (2, 4), (3, 8), (5, 7)]) 2 >>> min_meeting_rooms([(0, 5), (5, 10), (10, 15)]) 1 >>> min_meeting_rooms([]) 0 >>> min_meeting_rooms([(1, 5), (2, 6), (3, 8), (4, 7)]) 4 >>> min_meeting_rooms([(1, 8), (2, 5), (6, 8)]) 2 >>> min_meeting_rooms([(1, 10), (10, 20), (20, 30)]) 1 >>> min_meeting_rooms([(1, 5), (5, 10)]) 1 >>> min_meeting_rooms([(1, 10), (2, 3), (4, 8)]) 2 >>> min_meeting_rooms([(1, 4), (2, 5), (4, 6), (7, 9), (8, 10)]) 2","solution":"def min_meeting_rooms(meetings): if not meetings: return 0 # Separate start and end times, and sort them start_times = sorted([meeting[0] for meeting in meetings]) end_times = sorted([meeting[1] for meeting in meetings]) start_pointer, end_pointer = 0, 0 used_rooms = 0 max_rooms = 0 # Iterate over all the meetings while start_pointer < len(meetings): # If there's a meeting that has started before the last ended, we need a new room if start_times[start_pointer] < end_times[end_pointer]: used_rooms += 1 start_pointer += 1 else: # Else we can reuse the room used_rooms -= 1 end_pointer += 1 # Track the maximum number of rooms in use at any time max_rooms = max(max_rooms, used_rooms) return max_rooms"},{"question":"def can_traffic_reach_endpoint(n: int, m: int, grid: List[str], sx: int, sy: int, endpoints: List[Tuple[int, int]]) -> str: Develop a function that simulates a simplified version of a traffic system in a grid-like city. Given a grid of size n x m representing the city, where each cell can either be a road ('R') or a building ('B'), and a starting point (sx, sy) and one or more ending points, determine if vehicular traffic can reach any of the given end points from the starting point. Example: >>> can_traffic_reach_endpoint(5, 5, [\\"RRRRR\\", \\"RBBBR\\", \\"RRRRR\\", \\"RBBBB\\", \\"RRRRR\\"], 0, 0, [(4, 4), (2, 2)]) \\"YES\\" >>> can_traffic_reach_endpoint(5, 5, [\\"RRRRR\\", \\"RBBBR\\", \\"RRRRR\\", \\"RBBBB\\", \\"RRRRR\\"], 0, 0, [(1, 1)]) \\"NO\\" from typing import List, Tuple def test_case_1(): n, m = 5, 5 grid = [ \\"RRRRR\\", \\"RBBBR\\", \\"RRRRR\\", \\"RBBBB\\", \\"RRRRR\\" ] sx, sy = 0, 0 endpoints = [(4, 4), (2, 2)] assert can_traffic_reach_endpoint(n, m, grid, sx, sy, endpoints) == \\"YES\\" def test_case_2(): n, m = 5, 5 grid = [ \\"RRRRR\\", \\"RBBBR\\", \\"RRRRR\\", \\"RBBBB\\", \\"RRRRR\\" ] sx, sy = 0, 0 endpoints = [(4, 4)] assert can_traffic_reach_endpoint(n, m, grid, sx, sy, endpoints) == \\"YES\\" def test_case_3(): n, m = 5, 5 grid = [ \\"RRRRR\\", \\"RBBBR\\", \\"RRRRR\\", \\"RBBBB\\", \\"RRRRR\\" ] sx, sy = 0, 0 endpoints = [(1, 1)] assert can_traffic_reach_endpoint(n, m, grid, sx, sy, endpoints) == \\"NO\\" def test_case_4(): n, m = 3, 3 grid = [ \\"RRB\\", \\"RRB\\", \\"BBB\\" ] sx, sy = 0, 0 endpoints = [(1, 1)] assert can_traffic_reach_endpoint(n, m, grid, sx, sy, endpoints) == \\"YES\\" def test_case_5(): n, m = 3, 3 grid = [ \\"RRR\\", \\"BBB\\", \\"RRR\\" ] sx, sy = 0, 0 endpoints = [(2, 2)] assert can_traffic_reach_endpoint(n, m, grid, sx, sy, endpoints) == \\"NO\\"","solution":"def can_traffic_reach_endpoint(n, m, grid, sx, sy, endpoints): from collections import deque directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] visited = [[False for _ in range(m)] for _ in range(n)] queue = deque([(sx, sy)]) visited[sx][sy] = True while queue: x, y = queue.popleft() if (x, y) in endpoints: return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and grid[nx][ny] == 'R': visited[nx][ny] = True queue.append((nx, ny)) return \\"NO\\""},{"question":"def can_schedule_all_workshops(n: int, workshops: [(int, int)]) -> str: Determines if it is possible to schedule all workshops without any overlap. Parameters: n (int): The number of workshops. workshops (list of tuples): A list of tuples where each tuple contains two integers representing the start and end times of a workshop. Returns: str: \\"YES\\" if it is possible to schedule all workshops without any overlap, otherwise \\"NO\\". Example: >>> can_schedule_all_workshops(3, [(1, 3), (2, 4), (3, 5)]) NO >>> can_schedule_all_workshops(2, [(5, 10), (1, 5)]) YES >>> can_schedule_all_workshops(4, [(1, 2), (3, 4), (5, 6), (7, 8)]) YES","solution":"def can_schedule_all_workshops(n, workshops): Determines if it is possible to schedule all workshops without any overlap. Parameters: n (int): The number of workshops. workshops (list of tuples): A list of tuples where each tuple contains two integers representing the start and end times of a workshop. Returns: str: \\"YES\\" if it is possible to schedule all workshops without any overlap, otherwise \\"NO\\". # Sort workshops by their start times (and by end times if start times are equal) workshops.sort() # Compare the end time of the previous workshop with the start time of the current for i in range(1, n): if workshops[i-1][1] > workshops[i][0]: return \\"NO\\" return \\"YES\\""},{"question":"def min_steps_to_one(n: int) -> int: Returns the minimum number of steps required to reduce the number n to 1. In one step, you can either: - Subtract 1 from the number, - If the number is even, divide it by 2, - If the number is divisible by 3, divide it by 3. Examples: >>> min_steps_to_one(10) 3 >>> min_steps_to_one(15) 4 >>> min_steps_to_one(7) 3","solution":"def min_steps_to_one(n): Returns the minimum number of steps required to reduce the number n to 1. In one step, you can either: - Subtract 1 from the number, - If the number is even, divide it by 2, - If the number is divisible by 3, divide it by 3. dp = [float('inf')] * (n + 1) dp[1] = 0 for i in range(2, n + 1): dp[i] = dp[i - 1] + 1 if i % 2 == 0: dp[i] = min(dp[i], dp[i // 2] + 1) if i % 3 == 0: dp[i] = min(dp[i], dp[i // 3] + 1) return dp[n]"},{"question":"def is_subsequence(S: str, T: str) -> str: This function checks if string S is a subsequence of string T. :param S: The string to be checked as subsequence :param T: The string in which to check for subsequence :return: 'Yes' if S is a subsequence of T, otherwise 'No' >>> is_subsequence(\\"abc\\", \\"ahbgdc\\") == \\"Yes\\" >>> is_subsequence(\\"axc\\", \\"ahbgdc\\") == \\"No\\" >>> is_subsequence(\\"\\", \\"ahbgdc\\") == \\"Yes\\" >>> is_subsequence(\\"a\\", \\"\\") == \\"No\\" >>> is_subsequence(\\"abc\\", \\"abc\\") == \\"Yes\\" >>> is_subsequence(\\"abc\\", \\"acb\\") == \\"No\\" >>> is_subsequence(\\"aaaa\\", \\"aaaaaaaa\\") == \\"Yes\\"","solution":"def is_subsequence(S, T): This function checks if string S is a subsequence of string T. :param S: The string to be checked as subsequence :param T: The string in which to check for subsequence :return: 'Yes' if S is a subsequence of T, otherwise 'No' s_index, t_index = 0, 0 while s_index < len(S) and t_index < len(T): if S[s_index] == T[t_index]: s_index += 1 t_index += 1 return 'Yes' if s_index == len(S) else 'No'"},{"question":"def mini_sudoku_solver(grid: List[List[int]]) -> str: Determine if the given Mini Sudoku puzzle has at least one valid solution. >>> mini_sudoku_solver([ ... [0, 0, 3, 4], ... [3, 4, 0, 0], ... [0, 3, 4, 0], ... [4, 0, 0, 3] ... ]) \\"YES\\" >>> mini_sudoku_solver([ ... [1, 1, 2, 3], ... [3, 4, 1, 0], ... [2, 3, 4, 1], ... [4, 2, 0, 0] ... ]) \\"NO\\" ...","solution":"def is_valid(grid, row, col, num): # Check if num is not in the given row if num in grid[row]: return False # Check if num is not in the given column if num in [grid[r][col] for r in range(4)]: return False # Check if num is not in the 2x2 sub-grid start_row, start_col = 2 * (row // 2), 2 * (col // 2) for i in range(start_row, start_row + 2): for j in range(start_col, start_col + 2): if grid[i][j] == num: return False return True def solve(grid): for row in range(4): for col in range(4): if grid[row][col] == 0: for num in range(1, 5): if is_valid(grid, row, col, num): grid[row][col] = num if solve(grid): return True grid[row][col] = 0 return False return True def mini_sudoku_solver(grid): if solve(grid): return \\"YES\\" else: return \\"NO\\""},{"question":"def sum_between_kth_elements(arr, test_cases): Returns a list of sums of elements between the k1-th and k2-th smallest elements for each test case. Parameters: arr (list): The list of distinct integers. test_cases (list of tuples): Each tuple contains (k1, k2). Returns: list: List of sums for each test case. Example: >>> sum_between_kth_elements([3, 1, 5, 2, 4, 6], [(2, 5), (1, 3)]) [14, 6]","solution":"def sum_between_kth_elements(arr, test_cases): Returns a list of sums of elements between the k1-th and k2-th smallest elements for each test case. Parameters: arr (list): The list of distinct integers. test_cases (list of tuples): Each tuple contains (k1, k2). Returns: list: List of sums for each test case. # Sort the array to determine k-th smallest elements sorted_arr = sorted(arr) results = [] for k1, k2 in test_cases: # Calculate the sum from the k1-th to the k2-th smallest elements (1-based) sum_between = sum(sorted_arr[k1-1:k2]) results.append(sum_between) return results"},{"question":"def sort_students(students): Returns a new list of dictionaries sorted by the students' scores in descending order. If two students have the same score, they are sorted by their names alphabetically. :param students: List of dictionaries with each dictionary containing 'name' and 'score' keys. :return: Sorted list of dictionaries.","solution":"def sort_students(students): Returns a new list of dictionaries sorted by the students' scores in descending order. If two students have the same score, they are sorted by their names alphabetically. :param students: List of dictionaries with each dictionary containing 'name' and 'score' keys. :return: Sorted list of dictionaries. return sorted(students, key=lambda x: (-x['score'], x['name']))"},{"question":"def max_lexicographical_array(arr: List[int]) -> List[int]: Returns the maximum possible lexicographically array. >>> max_lexicographical_array([1, 0, 2, 1, 0, 2]) [2, 2, 1, 1, 0, 0] >>> max_lexicographical_array([2, 0, 2, 2, 1, 1, 0, 0]) [2, 2, 2, 1, 1, 0, 0, 0] >>> max_lexicographical_array([1, 2, 0]) [2, 1, 0] >>> max_lexicographical_array([0, 1, 2]) [2, 1, 0] >>> max_lexicographical_array([2, 2, 2]) [2, 2, 2] >>> max_lexicographical_array([0, 0, 0]) [0, 0, 0] >>> max_lexicographical_array([1, 1, 1]) [1, 1, 1] >>> max_lexicographical_array([2, 1, 0, 2, 1, 0]) [2, 2, 1, 1, 0, 0]","solution":"def max_lexicographical_array(arr): Returns the maximum possible lexicographically array. # Sort the array in descending order return sorted(arr, reverse=True) if __name__ == \\"__main__\\": n = int(input().strip()) arr = list(map(int, input().strip().split())) result = max_lexicographical_array(arr) print(\\" \\".join(map(str, result)))"},{"question":"def count_even_sum_pairs(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given an array of n integers, determine the number of unordered pairs of elements (x, y) where x and y are distinct and x + y is an even number. Parameters: test_cases (List[Tuple[int, List[int]]]): A list of tuples where each tuple contains an integer n and a list of n integers. Returns: List[int]: A list of integers where each integer represents the number of valid pairs for the corresponding test case. Example: >>> test_cases = [(3, [1, 2, 3]), (4, [4, 6, 8, 10]), (5, [1, 3, 5, 7, 9])] >>> count_even_sum_pairs(test_cases) [1, 6, 10] def process_input(input_data: str) -> List[Tuple[int, List[int]]]: Process the input string and convert it to a list of test cases. Parameters: input_data (str): A string containing the input data. Returns: List[Tuple[int, List[int]]]: A list of tuples where each tuple contains an integer n and a list of n integers. Example: >>> input_data = \\"3n3n1 2 3n4n4 6 8 10n5n1 3 5 7 9\\" >>> process_input(input_data) [(3, [1, 2, 3]), (4, [4, 6, 8, 10]), (5, [1, 3, 5, 7, 9])] from solution import count_even_sum_pairs, process_input def test_single_case(): input_data = \\"1n5n1 2 3 4 5\\" test_cases = process_input(input_data) results = count_even_sum_pairs(test_cases) assert results == [4], f\\"Expected [4], but got {results}\\" def test_multiple_cases(): input_data = \\"3n3n1 2 3n4n4 6 8 10n5n1 3 5 7 9\\" test_cases = process_input(input_data) results = count_even_sum_pairs(test_cases) assert results == [1, 6, 10], f\\"Expected [1, 6, 10], but got {results}\\" def test_all_even(): input_data = \\"1n4n2 4 6 8\\" test_cases = process_input(input_data) results = count_even_sum_pairs(test_cases) assert results == [6], f\\"Expected [6], but got {results}\\" def test_all_odd(): input_data = \\"1n3n1 3 5\\" test_cases = process_input(input_data) results = count_even_sum_pairs(test_cases) assert results == [3], f\\"Expected [3], but got {results}\\" def test_large_input(): input_data = \\"1n6n-999999999 0 1 2 3 4\\" test_cases = process_input(input_data) results = count_even_sum_pairs(test_cases) assert results == [6], f\\"Expected [6], but got {results}\\"","solution":"def count_even_sum_pairs(test_cases): results = [] for n, array in test_cases: odd_count = sum(1 for x in array if x % 2 != 0) even_count = n - odd_count # Pairs of (odd, odd) and (even, even) both give even sums. odd_pairs = (odd_count * (odd_count - 1)) // 2 even_pairs = (even_count * (even_count - 1)) // 2 results.append(odd_pairs + even_pairs) return results def process_input(input_data): lines = input_data.strip().split('n') t = int(lines[0]) test_cases = [] index = 1 for _ in range(t): n = int(lines[index]) array = list(map(int, lines[index + 1].split())) test_cases.append((n, array)) index += 2 return test_cases"},{"question":"def compute_supported_weights(columns: List[List[int]]) -> List[List[int]]: Computes the weights supported by each product in each column. :param columns: List of columns, where each column is a list of weights from bottom to top. :return: A list of lists, where each inner list represents the supported weights from bottom to top in each column. >>> compute_supported_weights([[10, 20, 30]]) [[60, 50, 30]] >>> compute_supported_weights([[15, 25]]) [[40, 25]] def process_input(c: int, column_data: List[str]) -> List[List[int]]: Processes the input data and computes the supported weights. :param c: Number of columns. :param column_data: List of strings representing the columns. :return: List of lists of supported weights. >>> process_input(2, [\\"3 10 20 30\\", \\"2 15 25\\"]) [[60, 50, 30], [40, 25]] >>> process_input(1, [\\"3 10 10 10\\"]) [[30, 20, 10]]","solution":"def compute_supported_weights(columns): Computes the weights supported by each product in each column. :param columns: List of columns, where each column is a list of weights from bottom to top. :return: A list of lists, where each inner list represents the supported weights from bottom to top in each column. result = [] for column in columns: column_result = [] total_weight = sum(column) for weight in column: column_result.append(total_weight) total_weight -= weight result.append(column_result) return result def process_input(c, column_data): Processes the input data and computes the supported weights. :param c: Number of columns. :param column_data: List of strings representing the columns. :return: List of lists of supported weights. columns = [] for data in column_data: data_list = list(map(int, data.split())) h = data_list[0] column = data_list[1:h+1] columns.append(column) return compute_supported_weights(columns)"},{"question":"def rotate_array(A, N, X): Rotates the array A to the right by X positions. Parameters: A (list): List of integers to rotate. N (int): Size of the array. X (int): Number of positions to rotate. Returns: list: The rotated array. pass def sum_even_indices(A, N): Finds the sum of the elements present at even indices in the array A. Parameters: A (list): List of integers to sum. N (int): Size of the array. Returns: int: Sum of elements at even indices. pass def delete_value(A, N, Y): Deletes any occurrences of the value Y from the array A. Parameters: A (list): List of integers. N (int): Size of the array. Y (int): Value to delete. Returns: list: The resulting array after deletions. pass # Test cases from solution import rotate_array, sum_even_indices, delete_value def test_rotate_array(): assert rotate_array([1, 2, 3, 4, 5, 6], 6, 2) == [5, 6, 1, 2, 3, 4] assert rotate_array([1, 2, 3, 4], 4, 1) == [4, 1, 2, 3] assert rotate_array([1, 2, 3, 4], 4, 4) == [1, 2, 3, 4] assert rotate_array([1, 2, 3, 4], 4, 5) == [4, 1, 2, 3] # 5 % 4 == 1 def test_sum_even_indices(): assert sum_even_indices([1, 2, 3, 4, 5, 6], 6) == 1 + 3 + 5 assert sum_even_indices([1], 1) == 1 assert sum_even_indices([2, 4, 6, 8], 4) == 2 + 6 assert sum_even_indices([], 0) == 0 def test_delete_value(): assert delete_value([1, 2, 3, 4, 2, 5, 2], 7, 2) == [1, 3, 4, 5] assert delete_value([1, 1, 1], 3, 1) == [] assert delete_value([1, 2, 3], 3, 4) == [1, 2, 3] assert delete_value([1, 2, 3, 4, 4], 5, 4) == [1, 2, 3]","solution":"def rotate_array(A, N, X): Rotates the array A to the right by X positions. Parameters: A (list): List of integers to rotate. N (int): Size of the array. X (int): Number of positions to rotate. Returns: list: The rotated array. X = X % N # Handle cases where X > N return A[-X:] + A[:-X] def sum_even_indices(A, N): Finds the sum of the elements present at even indices in the array A. Parameters: A (list): List of integers to sum. N (int): Size of the array. Returns: int: Sum of elements at even indices. return sum(A[i] for i in range(N) if i % 2 == 0) def delete_value(A, N, Y): Deletes any occurrences of the value Y from the array A. Parameters: A (list): List of integers. N (int): Size of the array. Y (int): Value to delete. Returns: list: The resulting array after deletions. return [a for a in A if a != Y]"},{"question":"from typing import List, Tuple def is_subsequence(treasure: str, clue: str) -> bool: Determines if 'clue' is a subsequence of 'treasure'. Args: treasure (str): The treasure string. clue (str): The clue string. Returns: bool: True if clue is a subsequence of treasure, False otherwise. # (Implementation here) def count_subsequences(T: int, test_cases: List[Tuple[int, str, int, List[str]]]) -> List[int]: Counts the number of clues that are subsequences of the treasure strings for each test case. Args: T (int): The number of test cases. test_cases (List[Tuple[int, str, int, List[str]]]): A list of tuples representing each test case. Returns: List[int]: A list of counts of clues that are subsequences for each test case. # (Implementation here) def parse_input(input_string: str) -> Tuple[int, List[Tuple[int, str, int, List[str]]]]: Parses the input string and prepares the test cases. Args: input_string (str): The input string containing test cases information. Returns: Tuple[int, List[Tuple[int, str, int, List[str]]]]: The number of test cases and the list of test cases. # (Implementation here) def test_is_subsequence(): assert is_subsequence(\\"TREASURE\\", \\"TRE\\") == True assert is_subsequence(\\"TREASURE\\", \\"SURE\\") == True assert is_subsequence(\\"TREASURE\\", \\"ASTR\\") == False assert is_subsequence(\\"GDVANC\\", \\"GAC\\") == True assert is_subsequence(\\"GDVANC\\", \\"DAN\\") == True assert is_subsequence(\\"GDVANC\\", \\"DVN\\") == True assert is_subsequence(\\"GDVANC\\", \\"GDN\\") == True def test_count_subsequences(): T = 2 test_cases = [ (7, \\"TREASURE\\", 3, [\\"TRE\\", \\"SURE\\", \\"ASTR\\"]), (6, \\"GDVANC\\", 4, [\\"GAC\\", \\"DAN\\", \\"DVN\\", \\"GDN\\"]) ] assert count_subsequences(T, test_cases) == [2, 4] def test_parse_input(): input_string = 2 7 TREASURE 3 TRE SURE ASTR 6 GDVANC 4 GAC DAN DVN GDN T, test_cases = parse_input(input_string) expected_T = 2 expected_test_cases = [ (7, \\"TREASURE\\", 3, [\\"TRE\\", \\"SURE\\", \\"ASTR\\"]), (6, \\"GDVANC\\", 4, [\\"GAC\\", \\"DAN\\", \\"DVN\\", \\"GDN\\"]) ] assert T == expected_T assert test_cases == expected_test_cases","solution":"def is_subsequence(treasure, clue): Determines if 'clue' is a subsequence of 'treasure'. it = iter(treasure) return all(char in it for char in clue) def count_subsequences(T, test_cases): Counts the number of clues that are subsequences of the treasure strings for each test case. results = [] for case in test_cases: N, treasure, K, clues = case count = sum(is_subsequence(treasure, clue) for clue in clues) results.append(count) return results # Parsing input and preparing test cases def parse_input(input_string): lines = input_string.strip().split('n') T = int(lines[0].strip()) idx = 1 test_cases = [] for _ in range(T): N = int(lines[idx].strip()) treasure = lines[idx+1].strip() K = int(lines[idx+2].strip()) clues = [lines[idx+3+i].strip() for i in range(K)] test_cases.append((N, treasure, K, clues)) idx += 3 + K return T, test_cases # Example usage if __name__ == \\"__main__\\": input_string = 2 7 TREASURE 3 TRE SURE ASTR 6 GDVANC 4 GAC DAN DVN GDN T, test_cases = parse_input(input_string) results = count_subsequences(T, test_cases) for result in results: print(result)"},{"question":"from collections import Counter import re class HashtagCounter: A class to maintain and retrieve the top N most frequently used hashtags. Methods: add_post(post): Accepts a string \`post\`, which is a sentence containing one or more words, and extracts hashtags (words starting with \`#\`). It updates the internal count of each hashtag. top_n_hashtags(n): Returns a list of the \`n\` most frequently occurring hashtags, in descending order of their frequency. If there are multiple hashtags with the same frequency, their order is arbitrary. Example usage: >>> counter = HashtagCounter() >>> counter.add_post(\\"This is a #fun post with #coding and #fun\\") >>> counter.add_post(\\"Another #fun post with #learning and #coding\\") >>> print(counter.top_n_hashtags(2)) ['#fun', '#coding'] >>> print(counter.top_n_hashtags(3)) ['#fun', '#coding', '#learning'] def __init__(self): self.hashtag_count = Counter() def add_post(self, post): Extracts hashtags from the post and updates their counts. Args: post (str): The post from which to extract hashtags. def top_n_hashtags(self, n): Returns a list of the top \`n\` most frequently occurring hashtags. Args: n (int): The number of top hashtags to return. Returns: list: The top \`n\` hashtags in descending order of frequency.","solution":"from collections import defaultdict, Counter import re class HashtagCounter: def __init__(self): self.hashtag_count = Counter() def add_post(self, post): Extracts hashtags from the post and updates their counts. Args: post (str): The post from which to extract hashtags. hashtags = re.findall(r'#w{1,50}', post) for hashtag in hashtags: self.hashtag_count[hashtag] += 1 def top_n_hashtags(self, n): Returns a list of the top \`n\` most frequently occurring hashtags. Args: n (int): The number of top hashtags to return. Returns: list: The top \`n\` hashtags in descending order of frequency. most_common = self.hashtag_count.most_common(n) return [hashtag for hashtag, count in most_common]"},{"question":"def find_three_points(L: int, W: int, harvesters: List[Tuple[int, int, int]]) -> List[Tuple[int, int]]: This function selects three distinct points which will generate the largest circumscribed circle such that the expected number of harvesters captured in the photo is maximized. Args: L (int): length of the field W (int): width of the field harvesters (list of tuples): list of tuples, where each tuple contains (xi, yi, vi) representing the initial location and speed of each harvester. Returns: list of tuples: Three points (x, y) that form the vertices of the circumscribed circle. Unit Test: from solution import find_three_points def test_high_density(): L, W = 10, 10 harvesters = [ (2, 2, 1), (8, 8, 2), (5, 5, 1), ] result = find_three_points(L, W, harvesters) assert len(result) == 3 assert all(isinstance(pt, tuple) and len(pt) == 2 for pt in result) def test_edge_case_minimum_size(): L, W = 1, 1 harvesters = [ (0, 0, 1), (1, 1, 1), (0, 1, 1), (1, 0, 1), ] result = find_three_points(L, W, harvesters) assert len(result) == 3 assert all(isinstance(pt, tuple) and len(pt) == 2 for pt in result) def test_collinear_points(): L, W = 10, 10 harvesters = [ (0, 0, 1), (2, 2, 1), (4, 4, 1), (8, 8, 1), (10, 10, 1), ] result = find_three_points(L, W, harvesters) assert len(result) == 3 assert all(isinstance(pt, tuple) and len(pt) == 2 for pt in result) def test_large_field(): L, W = 1000, 1000 harvesters = [ (100, 100, 10), (900, 900, 10), (500, 500, 10), (200, 800, 20), (700, 300, 15), ] result = find_three_points(L, W, harvesters) assert len(result) == 3 assert all(isinstance(pt, tuple) and len(pt) == 2 for pt in result) def test_random_positions(): L, W = 20, 20 harvesters = [ (1, 1, 2), (10, 10, 3), (5, 5, 4), (4, 16, 1), (18, 2, 2), ] result = find_three_points(L, W, harvesters) assert len(result) == 3 assert all(isinstance(pt, tuple) and len(pt) == 2 for pt in result)","solution":"def find_three_points(L, W, harvesters): This function selects three distinct points which will generate the largest circumscribed circle such that the expected number of harvesters captured in the photo is maximized. Args: L (int): length of the field W (int): width of the field harvesters (list of tuples): list of tuples, where each tuple contains (xi, yi, vi) representing the initial location and speed of each harvester Returns: list of tuples: Three points (x, y) that form the vertices of the circumscribed circle. # Step 1: Collect the possible positions of each harvester after one second possible_positions = set() for (xi, yi, vi) in harvesters: for dx in range(-vi, vi + 1): for dy in range(max(-vi - abs(dx), -vi), min(vi + 1 - abs(dx), vi + 1)): new_x = xi + dx new_y = yi + dy if 0 <= new_x <= L and 0 <= new_y <= W: possible_positions.add((new_x, new_y)) # Step 2: Find three points that are not collinear to make a valid triangle def are_not_collinear(a, b, c): Check if three points are not collinear. Points (x1, y1), (x2, y2), (x3, y3) are collinear if and only if the area of the triangle they form is zero. The area can be calculated using the determinant: Area = 0.5 * | x1(y2 - y3) + x2(y3 - y1) + x3(y1 - y2) | If Area == 0, then points are collinear. x1, y1 = a x2, y2 = b x3, y3 = c area = abs(x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) return area != 0 possible_positions = list(possible_positions) n = len(possible_positions) for i in range(n): for j in range(i + 1, n): for k in range(j + 1, n): if are_not_collinear(possible_positions[i], possible_positions[j], possible_positions[k]): return [possible_positions[i], possible_positions[j], possible_positions[k]] return [] # Example usage L = 10 W = 10 harvesters = [(2, 2, 1), (8, 8, 2), (5, 5, 1)] result = find_three_points(L, W, harvesters) for point in result: print(point)"},{"question":"def apply_operations(data: str) -> int: Given a string \`data\` representing a sequence of numerical operations, return the final result of applying those operations starting from 0. Parameters: data (str): A string of operations Returns: int: The final result after all operations >>> apply_operations(\\"+3+2-4*5\\") 5 >>> apply_operations(\\"+10-2/4\\") 2 >>> apply_operations(\\"-5*6-8\\") -38 from solution import apply_operations def test_apply_operations_example_1(): assert apply_operations(\\"+3+2-4*5\\") == 5 def test_apply_operations_example_2(): assert apply_operations(\\"+10-2/4\\") == 2 def test_apply_operations_example_3(): assert apply_operations(\\"-5*6-8\\") == -38 def test_apply_operations_addition(): assert apply_operations(\\"+1+2+3\\") == 6 def test_apply_operations_multiplication(): assert apply_operations(\\"*3*2\\") == 0 # 0 * 3 * 2 = 0 def test_apply_operations_division(): assert apply_operations(\\"+12/4\\") == 3 # 0 + 12 = 12; 12 // 4 = 3 def test_apply_operations_combined_operations(): assert apply_operations(\\"+10*2/2-4\\") == 6 # (0 + 10) * 2 = 20; 20 // 2 = 10; 10 - 4 = 6","solution":"def apply_operations(data:str) -> int: Given a string \`data\` representing a sequence of numerical operations, return the final result of applying those operations starting from 0. Parameters: data (str): A string of operations Returns: int: The final result after all operations result = 0 i = 0 while i < len(data): op = data[i] num_str = '' i += 1 while i < len(data) and data[i].isdigit(): num_str += data[i] i += 1 num = int(num_str) if op == '+': result += num elif op == '-': result -= num elif op == '*': result *= num elif op == '/': result //= num return result"},{"question":"def distinct_triangles(S: int) -> int: Determine the number of distinct integers T such that the total side lengths of squares used in triangles is exactly S. Parameters: S (int): The total side lengths of squares Returns: int: Distinct number of triangles >>> distinct_triangles(10) 10 >>> distinct_triangles(1) 1","solution":"def distinct_triangles(S): Determine the number of distinct integers T such that the total side lengths of squares used in triangles is exactly S. Parameters: S (int): The total side lengths of squares Returns: int: Distinct number of triangles return S"},{"question":"from typing import List def is_valid_sudoku(board: List[str]) -> bool: Check if a given Sudoku puzzle is valid. >>> is_valid_sudoku([ \\"53..7....\\", \\"6..195...\\", \\".98....6.\\", \\"8...6...3\\", \\"4..8.3..1\\", \\"7...2...6\\", \\".6....28.\\", \\"...419..5\\", \\"....8..79\\" ]) == True >>> is_valid_sudoku([ \\"63..7....\\", \\"6..895...\\", \\".98....6.\\", \\"8...6...3\\", \\"4..8.3..1\\", \\"7...2...6\\", \\".6....28.\\", \\"...619..5\\", \\"....8..7.\\" ]) == False pass def validate_sudoku_puzzles(puzzles: List[List[str]]) -> List[str]: Validate a list of Sudoku puzzles. >>> validate_sudoku_puzzles([ [ \\"53..7....\\", \\"6..195...\\", \\".98....6.\\", \\"8...6...3\\", \\"4..8.3..1\\", \\"7...2...6\\", \\".6....28.\\", \\"...419..5\\", \\"....8..79\\" ], [ \\"63..7....\\", \\"6..895...\\", \\".98....6.\\", \\"8...6...3\\", \\"4..8.3..1\\", \\"7...2...6\\", \\".6....28.\\", \\"...619..5\\", \\"....8..7.\\" ] ]) == [\\"Valid\\", \\"Invalid\\"] pass","solution":"def is_valid_sudoku(board): def is_valid_unit(unit): elements = [num for num in unit if num != '.'] return len(elements) == len(set(elements)) def get_subgrid(board, start_row, start_col): return [board[row][col] for row in range(start_row, start_row + 3) for col in range(start_col, start_col + 3)] # Check rows and columns for i in range(9): if not is_valid_unit(board[i]) or not is_valid_unit([board[row][i] for row in range(9)]): return False # Check 3x3 sub-grids for row in range(0, 9, 3): for col in range(0, 9, 3): if not is_valid_unit(get_subgrid(board, row, col)): return False return True def validate_sudoku_puzzles(puzzles): results = [] for board in puzzles: if is_valid_sudoku(board): results.append(\\"Valid\\") else: results.append(\\"Invalid\\") return results"},{"question":"def max_crates(L: int, W: int) -> int: Determines the maximum number of crates that can be placed in a LxW warehouse such that no two crates are adjacent or on the same row, column, or diagonal. Parameters: L (int): The length of the grid. W (int): The width of the grid. Returns: int: Maximum number of crates that can be placed. >>> max_crates(3, 3) 5 >>> max_crates(5, 5) 13 >>> max_crates(6, 7) 21 def solve(input_data: str) -> str: Solve the problem given the input as a single string. Parameters: input_data (str): Input data as a single string, containing multiple test cases. Returns: str: Output results, one per line for each test case. >>> solve(\\"3n3 3n5 5n6 7\\") \\"5n13n21\\" >>> solve(\\"2n1 1n2 2\\") \\"1n2\\"","solution":"def max_crates(L, W): Determines the maximum number of crates that can be placed in a LxW warehouse such that no two crates are adjacent or on the same row, column, or diagonal. This can be achieved by calculating the maximum independent set on a board where each cell alternates like a chessboard. Parameters: L (int): The length of the grid. W (int): The width of the grid. Returns: int: Maximum number of crates that can be placed. return (L * W + 1) // 2 def solve(input_data): input_lines = input_data.strip().split('n') T = int(input_lines[0]) results = [] for i in range(1, T + 1): L, W = map(int, input_lines[i].split()) results.append(max_crates(L, W)) return 'n'.join(map(str, results))"},{"question":"def larger_than_mean(lst: List[int]) -> List[int]: Write a function that takes a list of integers and returns a new list containing the elements that are larger than the arithmetic mean of the original list. Args: lst (List[int]): A list of integers Returns: List[int]: A list containing elements greater than the arithmetic mean of the input list >>> larger_than_mean([1, 2, 3, 4, 5]) [4, 5] >>> larger_than_mean([10, 20, 30, 40, 50]) [40, 50] >>> larger_than_mean([4, 4, 4, 4]) [] >>> larger_than_mean([]) [] >>> larger_than_mean([-10, 0, 10, 20]) [10, 20] >>> larger_than_mean([-5, -4, -3, -2, -1]) [-2, -1]","solution":"def larger_than_mean(lst): Returns a list of elements from the original list that are larger than the arithmetic mean of the original list. if not lst: return [] mean_value = sum(lst) / len(lst) return [x for x in lst if x > mean_value]"},{"question":"def evaluate_expression(expression: str) -> int: Evaluate a mathematical expression consisting of non-negative integers and '+' and '-' operators Operations are evaluated from left to right without precedence of operators. >>> evaluate_expression(\\"10+5-27+6\\") -6 >>> evaluate_expression(\\"2+3+4-5\\") 4 >>> evaluate_expression(\\"50-20+10\\") 40","solution":"def evaluate_expression(expression): Evaluates a simple mathematical expression with non-negative integers and +, - operators. Operations are evaluated from left to right without precedence. num = 0 # to store the current number result = 0 sign = 1 # to store sign of current number i = 0 while i < len(expression): char = expression[i] if char.isdigit(): num = num * 10 + int(char) elif char in '+-': result += sign * num num = 0 sign = 1 if char == '+' else -1 i += 1 result += sign * num # add the last number return result"},{"question":"import json from typing import List, Dict def manage_inventory(operations: List[Dict]): Manage the bookstore inventory by reading a list of operations and executing them. Supported operations: - Add a new book to the inventory. - Update the details of an existing book. - Remove a book from the inventory. - List all the books with their details. Args: operations (List[Dict]): A list of operations, where each operation is a dictionary detailing the action to be performed on the inventory. Example: >>> manage_inventory([ ... {\\"operation\\": \\"add_book\\", \\"id\\": \\"1\\", \\"title\\": \\"The Catcher in the Rye\\", \\"author\\": \\"J.D. Salinger\\", \\"price\\": 9.99, \\"quantity\\": 5}, ... {\\"operation\\": \\"add_book\\", \\"id\\": \\"2\\", \\"title\\": \\"To Kill a Mockingbird\\", \\"author\\": \\"Harper Lee\\", \\"price\\": 12.99, \\"quantity\\": 3}, ... {\\"operation\\": \\"list_books\\"}, ... {\\"operation\\": \\"update_book\\", \\"id\\": \\"1\\", \\"title\\": \\"The Catcher in the Rye\\", \\"author\\": \\"J.D. Salinger\\", \\"price\\": 7.99, \\"quantity\\": 10}, ... {\\"operation\\": \\"remove_book\\", \\"id\\": \\"2\\"}, ... {\\"operation\\": \\"list_books\\"} ... ]) id: 1, Title: The Catcher in the Rye, Author: J.D. Salinger, Price: 9.99, Quantity: 5 id: 2, Title: To Kill a Mockingbird, Author: Harper Lee, Price: 12.99, Quantity: 3 id: 1, Title: The Catcher in the Rye, Author: J.D. Salinger, Price: 7.99, Quantity: 10 # Write your solution here def test_manage_inventory(capsys): operations = [ {\\"operation\\": \\"add_book\\", \\"id\\": \\"1\\", \\"title\\": \\"The Catcher in the Rye\\", \\"author\\": \\"J.D. Salinger\\", \\"price\\": 9.99, \\"quantity\\": 5}, {\\"operation\\": \\"add_book\\", \\"id\\": \\"2\\", \\"title\\": \\"To Kill a Mockingbird\\", \\"author\\": \\"Harper Lee\\", \\"price\\": 12.99, \\"quantity\\": 3}, {\\"operation\\": \\"list_books\\"}, {\\"operation\\": \\"update_book\\", \\"id\\": \\"1\\", \\"title\\": \\"The Catcher in the Rye\\", \\"author\\": \\"J.D. Salinger\\", \\"price\\": 7.99, \\"quantity\\": 10}, {\\"operation\\": \\"remove_book\\", \\"id\\": \\"2\\"}, {\\"operation\\": \\"list_books\\"} ] manage_inventory(operations) captured = capsys.readouterr() assert captured.out == ( \\"id: 1, Title: The Catcher in the Rye, Author: J.D. Salinger, Price: 9.99, Quantity: 5n\\" \\"id: 2, Title: To Kill a Mockingbird, Author: Harper Lee, Price: 12.99, Quantity: 3n\\" \\"id: 1, Title: The Catcher in the Rye, Author: J.D. Salinger, Price: 7.99, Quantity: 10n\\" ) def test_list_books_empty_inventory(capsys): operations = [ {\\"operation\\": \\"list_books\\"} ] manage_inventory(operations) captured = capsys.readouterr() assert captured.out == \\"No books availablen\\" def test_add_duplicate_book(capsys): operations = [ {\\"operation\\": \\"add_book\\", \\"id\\": \\"1\\", \\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"price\\": 8.99, \\"quantity\\": 4}, {\\"operation\\": \\"add_book\\", \\"id\\": \\"1\\", \\"title\\": \\"Brave New World\\", \\"author\\": \\"Aldous Huxley\\", \\"price\\": 9.99, \\"quantity\\": 2}, {\\"operation\\": \\"list_books\\"} ] manage_inventory(operations) captured = capsys.readouterr() assert captured.out == ( \\"id: 1, Title: 1984, Author: George Orwell, Price: 8.99, Quantity: 4n\\" ) def test_update_nonexistent_book(capsys): operations = [ {\\"operation\\": \\"update_book\\", \\"id\\": \\"1\\", \\"title\\": \\"The Great Gatsby\\", \\"author\\": \\"F. Scott Fitzgerald\\", \\"price\\": 10.99, \\"quantity\\": 7}, {\\"operation\\": \\"list_books\\"} ] manage_inventory(operations) captured = capsys.readouterr() assert captured.out == \\"No books availablen\\" def test_remove_nonexistent_book(capsys): operations = [ {\\"operation\\": \\"remove_book\\", \\"id\\": \\"1\\"}, {\\"operation\\": \\"add_book\\", \\"id\\": \\"2\\", \\"title\\": \\"Moby-Dick\\", \\"author\\": \\"Herman Melville\\", \\"price\\": 11.99, \\"quantity\\": 5}, {\\"operation\\": \\"list_books\\"} ] manage_inventory(operations) captured = capsys.readouterr() assert captured.out == ( \\"id: 2, Title: Moby-Dick, Author: Herman Melville, Price: 11.99, Quantity: 5n\\" )","solution":"import json def manage_inventory(operations): inventory = {} def add_book(book): if book[\\"id\\"] not in inventory: inventory[book[\\"id\\"]] = book def update_book(book): if book[\\"id\\"] in inventory: inventory[book[\\"id\\"]] = book def remove_book(book_id): if book_id in inventory: del inventory[book_id] def list_books(): if not inventory: print(\\"No books available\\") else: for book in inventory.values(): print(f'id: {book[\\"id\\"]}, Title: {book[\\"title\\"]}, Author: {book[\\"author\\"]}, Price: {book[\\"price\\"]}, Quantity: {book[\\"quantity\\"]}') for operation in operations: if operation[\\"operation\\"] == \\"add_book\\": add_book(operation) elif operation[\\"operation\\"] == \\"update_book\\": update_book(operation) elif operation[\\"operation\\"] == \\"remove_book\\": remove_book(operation[\\"id\\"]) elif operation[\\"operation\\"] == \\"list_books\\": list_books()"},{"question":"def unique_paths(m: int, n: int, k: int, restricted_cells: List[Tuple[int, int]]) -> int: Calculate the number of unique paths the robot can take to reach the bottom-right corner of the grid. while avoiding restricted cells. >>> unique_paths(3, 3, 1, [(2, 2)]) == 2 >>> unique_paths(3, 3, 0, []) == 6 >>> unique_paths(2, 2, 1, [(1, 2)]) == 1 >>> unique_paths(5, 5, 0, []) == 70 >>> unique_paths(3, 3, 2, [(2, 1), (1, 2)]) == 0 >>> unique_paths(1, 1, 0, []) == 1 >>> unique_paths(3, 3, 1, [(1, 1)]) == 0 >>> unique_paths(3, 3, 1, [(3, 3)]) == 0","solution":"def unique_paths(m, n, k, restricted_cells): MOD = 10**9 + 7 # create a grid to store the number of paths dp = [[0] * n for _ in range(m)] # mark the restricted cells in the grid for cell in restricted_cells: dp[cell[0] - 1][cell[1] - 1] = -1 # initialize the starting point if dp[0][0] != -1: dp[0][0] = 1 # populate the number of paths for each cell in the grid for i in range(m): for j in range(n): if dp[i][j] == -1: continue if i > 0 and dp[i - 1][j] != -1: dp[i][j] = (dp[i][j] + dp[i - 1][j]) % MOD if j > 0 and dp[i][j - 1] != -1: dp[i][j] = (dp[i][j] + dp[i][j - 1]) % MOD return dp[m-1][n-1] if dp[m-1][n-1] != -1 else 0 # Parse input (for testing locally) if __name__ == \\"__main__\\": m, n = map(int, input().split()) k = int(input()) restricted_cells = [tuple(map(int, input().split())) for _ in range(k)] print(unique_paths(m, n, k, restricted_cells))"},{"question":"def max_total_sweetness(n: int, k: int, sweetness_values: List[int]) -> int: Returns the maximum possible total sweetness if Monkey Kong eats up to k bananas. Args: n: int : the number of bananas k: int : the maximum number of bananas Monkey Kong can eat sweetness_values: List[int] : the sweetness values of the bananas Returns: int : the maximum possible total sweetness pass # Unit Tests def test_case1(): assert max_total_sweetness(5, 3, [2, -5, 6, -3, 8]) == 16 def test_case2(): assert max_total_sweetness(6, 2, [4, 4, 4, -10, -10, 3]) == 8 def test_case3(): assert max_total_sweetness(4, 2, [1, 2, 3, 4]) == 7 def test_case4(): assert max_total_sweetness(5, 5, [-1, -2, -3, -4, -5]) == -15 def test_case5(): assert max_total_sweetness(7, 3, [7, 7, 7, 7, 7, 7, 7]) == 21 def test_case6(): assert max_total_sweetness(3, 2, [-10, -20, 30]) == 20 def test_case7(): assert max_total_sweetness(10, 4, [10, -1, -2, -3, -4, -5, 6, 7, 8, 9]) == 34","solution":"def max_total_sweetness(n, k, sweetness_values): Returns the maximum possible total sweetness if Monkey Kong eats up to k bananas. Args: n: int : the number of bananas k: int : the maximum number of bananas Monkey Kong can eat sweetness_values: List[int] : the sweetness values of the bananas Returns: int : the maximum possible total sweetness # Sort the sweetness values in descending order sweetness_values.sort(reverse=True) # Take the sum of the first k elements for maximum sweetness max_sweetness = sum(sweetness_values[:k]) return max_sweetness"},{"question":"def two_sum_indices(arr, target): Returns indices of the two numbers from the array that add up to the target. >>> two_sum_indices([2, 7, 11, 15], 9) (0, 1) >>> two_sum_indices([3, 2, 4], 6) (1, 2) >>> two_sum_indices([-3, 4, 3, 90], 0) (0, 2) >>> two_sum_indices([1000000000, -1000000000], 0) (0, 1) def process_input(Q, test_cases): Processes multiple test cases. >>> process_input(2, [(4, [2, 7, 11, 15], 9), (3, [3, 2, 4], 6)]) [(0, 1), (1, 2)]","solution":"def two_sum_indices(arr, target): Returns indices of the two numbers from the array that add up to the target. num_to_index = {} for i, num in enumerate(arr): complement = target - num if complement in num_to_index: return num_to_index[complement], i num_to_index[num] = i def process_input(Q, test_cases): results = [] for i in range(Q): n, arr, target = test_cases[i] result = two_sum_indices(arr, target) results.append(result) return results"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_and_remove_duplicates(l1: ListNode, l2: ListNode) -> ListNode: Merge two sorted linked lists and removes duplicates so that each element appears only once. Args: l1 (ListNode): The head of the first sorted linked list. l2 (ListNode): The head of the second sorted linked list. Returns: ListNode: The head of the merged and deduplicated linked list. >>> create_linked_list([1, 2, 4]) >>> create_linked_list([1, 3, 4, 5]) >>> merged = merge_and_remove_duplicates(l1, l2) >>> linked_list_to_list(merged) [1, 2, 3, 4, 5]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_and_remove_duplicates(l1: ListNode, l2: ListNode) -> ListNode: dummy = ListNode() current = dummy s = set() # Merge two sorted linked lists along with removing duplicates while l1 and l2: if l1.val == l2.val: if l1.val not in s: current.next = ListNode(l1.val) current = current.next s.add(l1.val) l1 = l1.next l2 = l2.next elif l1.val < l2.val: if l1.val not in s: current.next = ListNode(l1.val) current = current.next s.add(l1.val) l1 = l1.next else: if l2.val not in s: current.next = ListNode(l2.val) current = current.next s.add(l2.val) l2 = l2.next # Process remaining nodes in l1 while l1: if l1.val not in s: current.next = ListNode(l1.val) current = current.next s.add(l1.val) l1 = l1.next # Process remaining nodes in l2 while l2: if l2.val not in s: current.next = ListNode(l2.val) current = current.next s.add(l2.val) l2 = l2.next return dummy.next"},{"question":"def remove_adjacent_duplicates(lst: List[int]) -> List[int]: Given a list of integers, return another list which contains only the elements that remain after removing all adjacent duplicate elements. >>> remove_adjacent_duplicates([1, 2, 2, 3, 4, 4, 4, 5, 1, 1]) [1, 2, 3, 4, 5, 1] >>> remove_adjacent_duplicates([1, 1, 1, 1, 1]) [1] >>> remove_adjacent_duplicates([]) [] >>> remove_adjacent_duplicates([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> remove_adjacent_duplicates([1, 2, 1, 2, 1, 2]) [1, 2, 1, 2, 1, 2] >>> remove_adjacent_duplicates([1, 1, 2, 3, 3, 3, 4, 5, 5, 1, 1, 2, 2, 3]) [1, 2, 3, 4, 5, 1, 2, 3]","solution":"def remove_adjacent_duplicates(lst): Returns a list with adjacent duplicate elements removed. if not lst: return [] result = [lst[0]] for elem in lst[1:]: if elem != result[-1]: result.append(elem) return result"},{"question":"def find_symmetric_difference(list1, list2): Write a function find_symmetric_difference that takes in two lists and returns a list that contains the symmetric difference of the two input lists. The symmetric difference is the set of elements which are in either of the sets, but not in their intersection. The order of the elements in the output list does not matter. Example cases: >>> sorted(find_symmetric_difference([1, 2, 3], [3, 4, 5])) [1, 2, 4, 5] >>> sorted(find_symmetric_difference([10, 20, 30], [20, 40, 50])) [10, 30, 40, 50] >>> find_symmetric_difference([10], [10]) [] >>> sorted(find_symmetric_difference([1, 2, 3, 3], [3, 4, 4, 5])) [1, 2, 4, 5]","solution":"def find_symmetric_difference(list1, list2): Returns the symmetric difference between two lists. Args: list1: A list of integers. list2: A list of integers. Returns: A list containing the symmetric difference between list1 and list2. set1 = set(list1) set2 = set(list2) symmetric_diff = set1.symmetric_difference(set2) return list(symmetric_diff)"},{"question":"def find_first_non_repeating_char(s: str) -> str: Returns the first non-repeating character in the given string \`s\`. If there is no non-repeating character, returns an empty string ''. >>> find_first_non_repeating_char('swiss') 'w' >>> find_first_non_repeating_char('redivider') 'v' >>> find_first_non_repeating_char('abcabc') ''","solution":"def find_first_non_repeating_char(s): Returns the first non-repeating character in the given string \`s\`. If there is no non-repeating character, returns an empty string ''. char_count = {} # First pass: Count occurrences of each character for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Second pass: Find the first non-repeating character for char in s: if char_count[char] == 1: return char return ''"},{"question":"def get_permutation(n: int, k: int) -> str: Returns the kth permutation sequence of numbers from 1 to n in lexicographical order. >>> get_permutation(3, 3) == \\"213\\" >>> get_permutation(4, 9) == \\"2314\\" >>> get_permutation(3, 1) == \\"123\\"","solution":"import math def get_permutation(n: int, k: int) -> str: Returns the kth permutation sequence of numbers from 1 to n in lexicographical order. numbers = list(range(1, n + 1)) k -= 1 # convert k to zero-based index permutation = [] # Compute factorial values factorial = math.factorial(n) for i in range(n, 0, -1): factorial //= i index = k // factorial permutation.append(str(numbers.pop(index))) k %= factorial return ''.join(permutation)"},{"question":"def max_sum_path(matrix): Given a matrix, find the maximum possible sum of elements from the matrix, starting from the top-left corner to the bottom-right corner, moving only to the right or downward. Parameters: matrix (list of list of int): The input matrix Returns: int: The maximum possible sum >>> max_sum_path([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 29 >>> max_sum_path([ ... [1], ... [2], ... [3], ... [4], ... [5] ... ]) 15 >>> max_sum_path([ ... [1, -2, 3], ... [-4, 5, 6], ... [7, -8, 9] ... ]) 19 pass","solution":"def max_sum_path(matrix): Given a matrix, find the maximum possible sum of elements from the matrix, starting from the top-left corner to the bottom-right corner, moving only to the right or downward. Parameters: matrix (list of list of int): The input matrix Returns: int: The maximum possible sum if not matrix or not matrix[0]: return 0 N = len(matrix) M = len(matrix[0]) # Initialize a DP table with the same dimensions as the matrix dp = [[0] * M for _ in range(N)] # Set the value of the starting point dp[0][0] = matrix[0][0] # Fill in the top row (only moves right) for j in range(1, M): dp[0][j] = dp[0][j-1] + matrix[0][j] # Fill in the leftmost column (only moves down) for i in range(1, N): dp[i][0] = dp[i-1][0] + matrix[i][0] # Fill in the rest of the dp table for i in range(1, N): for j in range(1, M): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j] # The answer is in the bottom-right corner of the dp table return dp[N-1][M-1] # Example usage if __name__ == \\"__main__\\": matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] print(max_sum_path(matrix)) # Output: 29"},{"question":"import heapq from collections import defaultdict from typing import List, Tuple, Dict def find_top_k_products(T: int, test_cases: List[Dict[str, any]]) -> List[List[int]]: Find the top K most frequently sold products within a given time range for several test cases. Args: T (int): number of test cases test_cases (list): List of dictionaries containing details for each test case with keys - 'details' (tuple): (N, S, E) number of sales, start timestamp, and end timestamp - 'sales' (list): list of tuples, each containing (timestamp, product identifier) - 'K' (int): number of top products to find Returns: list: list of lists, where each sublist contains K product identifiers Example: >>> find_top_k_products(2, [ { \\"details\\": (5, 1, 10), \\"sales\\": [ (1, 3), (2, 3), (5, 4), (7, 2), (10, 4) ], \\"K\\": 3 }, { \\"details\\": (7, 5, 15), \\"sales\\": [ (8, 2), (9, 2), (10, 3), (11, 4), (13, 4), (14, 5), (15, 5) ], \\"K\\": 3 } ]) == [ [3, 4, 2], [2, 4, 5] ]","solution":"import heapq from collections import defaultdict, Counter def find_top_k_products(T, test_cases): results = [] for case in test_cases: N, S, E = case['details'] sales = case['sales'] K = case['K'] product_count = defaultdict(int) for timestamp, product in sales: if S <= timestamp <= E: product_count[product] += 1 # Use a min-heap to keep track of top K elements heap = [] for product, count in product_count.items(): heapq.heappush(heap, (-count, product)) top_k_products = [] for _ in range(K): top_k_products.append(heapq.heappop(heap)[1]) results.append(top_k_products) return results # Sample inputs for testing def main(): sample_input = [ { \\"details\\": (5, 1, 10), \\"sales\\": [ (1, 3), (2, 3), (5, 4), (7, 2), (10, 4) ], \\"K\\": 3 }, { \\"details\\": (7, 5, 15), \\"sales\\": [ (8, 2), (9, 2), (10, 3), (11, 4), (13, 4), (14, 5), (15, 5) ], \\"K\\": 3 } ] results = find_top_k_products(2, sample_input) for result in results: for product in result: print(product) print() if __name__ == \\"__main__\\": main()"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isSymmetric(root: TreeNode) -> bool: Given a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center). >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(2) >>> root.left.left = TreeNode(3) >>> root.left.right = TreeNode(4) >>> root.right.left = TreeNode(4) >>> root.right.right = TreeNode(3) >>> isSymmetric(root) True >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(2) >>> root.left.right = TreeNode(3) >>> root.right.right = TreeNode(3) >>> isSymmetric(root) False","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isSymmetric(root: TreeNode) -> bool: def isMirror(t1: TreeNode, t2: TreeNode) -> bool: if not t1 and not t2: return True if not t1 or not t2: return False return (t1.val == t2.val) and isMirror(t1.right, t2.left) and isMirror(t1.left, t2.right) return isMirror(root, root)"},{"question":"def find_blank_subgrids(n: int, m: int) -> List[Tuple[int, int, int, int]]: This function returns a list of all possible coordinates for the subgrid that can be left blank such that all planted crops form a single connected component. Each coordinate pair is in the format [(r1, c1), (r2, c2)]. Args: n: int - the number of rows in the grid. m: int - the number of columns in the grid. Returns: List[Tuple[int, int, int, int]] - a list of tuples, where each tuple contains the coordinates (r1, c1, r2, c2) of a rectangular subgrid. >>> find_blank_subgrids(3, 3) [(0, 0, 0, 0), (0, 0, 0, 1), (0, 0, 0, 2), (0, 0, 1, 0), (0, 0, 1, 1), (0, 0, 1, 2), (0, 0, 2, 0), (0, 0, 2, 1), (0, 0, 2, 2), (0, 1, 0, 1), (0, 1, 0, 2), (0, 1, 1, 1), (0, 1, 1, 2), (0, 1, 2, 1), (0, 1, 2, 2), (0, 2, 0, 2), (0, 2, 1, 2), (0, 2, 2, 2), (1, 0, 1, 0), (1, 0, 1, 1), (1, 0, 1, 2), (1, 0, 2, 0), (1, 0, 2, 1), (1, 0, 2, 2), (1, 1, 1, 1), (1, 1, 1, 2), (1, 1, 2, 1), (1, 1, 2, 2), (1, 2, 1, 2), (1, 2, 2, 2), (2, 0, 2, 0), (2, 0, 2, 1), (2, 0, 2, 2), (2, 1, 2, 1), (2, 1, 2, 2), (2, 2, 2, 2)]","solution":"def find_blank_subgrids(n, m): This function returns a list of all possible coordinates for the subgrid that can be left blank such that all planted crops form a single connected component. Each coordinate pair is in the format [(r1, c1), (r2, c2)]. possible_coordinates = [] for r1 in range(n): for c1 in range(m): for r2 in range(r1, n): for c2 in range(c1, m): possible_coordinates.append((r1, c1, r2, c2)) return possible_coordinates # Example usage n, m = 3, 3 results = find_blank_subgrids(n, m) for res in results: print(f\\"({res[0]}, {res[1]}) ({res[2]}, {res[3]})\\")"},{"question":"def max_stackable_goods(n: int, H: int, heights: List[int]) -> int: Determine the maximum number of different types of goods that can be stacked without exceeding the given height limit. :param n: int, number of different types of goods :param H: int, maximum height allowed for the stack :param heights: list of int, heights of different types of goods :return: int, maximum number of different types of goods that can be stacked >>> max_stackable_goods(5, 15, [3, 7, 5, 6, 9]) 3 >>> max_stackable_goods(3, 10, [2, 3, 4]) 3 >>> max_stackable_goods(5, 5, [10, 20, 30, 40, 5]) 1 >>> max_stackable_goods(3, 5, [6, 7, 8]) 0 >>> max_stackable_goods(4, 10, [1, 2, 3, 4]) 4 >>> max_stackable_goods(4, 10, [3, 3, 2, 2]) 4","solution":"def max_stackable_goods(n, H, heights): Determine the maximum number of different types of goods that can be stacked without exceeding the given height limit. :param n: int, number of different types of goods :param H: int, maximum height allowed for the stack :param heights: list of int, heights of different types of goods :return: int, maximum number of different types of goods that can be stacked heights.sort() current_height = 0 count = 0 for height in heights: if current_height + height <= H: current_height += height count += 1 else: break return count"},{"question":"import itertools from typing import List def calculate_min_tour_distance(n: int, distances: List[List[int]]) -> int: Calculates the minimum distance required to visit all cities exactly once and return to the starting city. Args: n (int): The number of cities. distances (List[List[int]]): A matrix where the j-th integer in the i-th list represents the distance between city i and city j. Returns: int: The minimum distance of the tour. pass # Unit Tests def test_calculate_min_tour_distance_example1(): n = 4 distances = [ [0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0] ] assert calculate_min_tour_distance(n, distances) == 80 def test_calculate_min_tour_distance_example2(): n = 3 distances = [ [0, 1, 10], [1, 0, 12], [10, 12, 0] ] assert calculate_min_tour_distance(n, distances) == 23 def test_calculate_min_tour_distance_two_cities(): n = 2 distances = [ [0, 5], [5, 0] ] assert calculate_min_tour_distance(n, distances) == 10 def test_calculate_min_tour_distance_large_distance(): n = 4 distances = [ [0, 1000, 1000, 1000], [1000, 0, 1000, 1000], [1000, 1000, 0, 1000], [1000, 1000, 1000, 0] ] assert calculate_min_tour_distance(n, distances) == 4000 def test_calculate_min_tour_distance_same_distances(): n = 3 distances = [ [0, 2, 2], [2, 0, 2], [2, 2, 0] ] assert calculate_min_tour_distance(n, distances) == 6","solution":"import itertools def calculate_min_tour_distance(n, distances): Calculates the minimum distance required to visit all cities exactly once and return to the starting city. Args: n (int): The number of cities. distances (list of list of int): A matrix where the j-th integer in the i-th list represents the distance between city i and city j. Returns: int: The minimum distance of the tour. # Generate all permutations of cities except the first one to calculate the minimal tour route cities = list(range(n)) min_tour_distance = float('inf') for perm in itertools.permutations(cities[1:]): current_distance = 0 current_path = [0] + list(perm) + [0] for i in range(len(current_path) - 1): current_distance += distances[current_path[i]][current_path[i + 1]] min_tour_distance = min(min_tour_distance, current_distance) return min_tour_distance # Example usage # n = 4 # distances = [[0, 10, 15, 20], # [10, 0, 35, 25], # [15, 35, 0, 30], # [20, 25, 30, 0]] # print(calculate_min_tour_distance(n, distances)) # Output: 80"},{"question":"def findLargestSquare(N: int, M: List[List[int]]) -> int: Return the size of the largest square sub-matrix which contains all identical elements. >>> findLargestSquare(4, [ ... [1, 1, 1, 0], ... [1, 1, 1, 0], ... [1, 1, 1, 0], ... [0, 0, 0, 0] ... ]) == 3 >>> findLargestSquare(5, [ ... [2, 2, 2, 2, 2], ... [2, 2, 2, 2, 2], ... [2, 2, 2, 2, 2], ... [2, 2, 2, 2, 2], ... [2, 2, 2, 2, 2] ... ]) == 5","solution":"def findLargestSquare(N, M): if N == 0: return 0 max_side = 0 dp = [[0] * N for _ in range(N)] for i in range(N): for j in range(N): if i == 0 or j == 0: dp[i][j] = 1 else: if M[i][j] == M[i-1][j] == M[i][j-1] == M[i-1][j-1]: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 else: dp[i][j] = 1 max_side = max(max_side, dp[i][j]) return max_side"},{"question":"def remove_element(nums, val): Removes all occurrences of val in nums in-place and returns the new length. >>> nums1 = [3, 2, 2, 3] >>> val1 = 3 >>> remove_element(nums1, val1) 2 >>> nums1[:2] [2, 2] >>> nums2 = [0, 1, 2, 2, 3, 0, 4, 2] >>> val2 = 2 >>> remove_element(nums2, val2) 5 >>> nums2[:5] [0, 1, 3, 0, 4] >>> nums3 = [1, 2, 3, 4, 5] >>> val3 = 6 >>> remove_element(nums3, val3) 5 >>> nums3[:5] [1, 2, 3, 4, 5] >>> nums4 = [1, 1, 1, 1] >>> val4 = 1 >>> remove_element(nums4, val4) 0 >>> nums4[:0] [] >>> nums5 = [4, 5, 4, 4, 6, 7, 4] >>> val5 = 4 >>> remove_element(nums5, val5) 3 >>> nums5[:3] [5, 6, 7]","solution":"def remove_element(nums, val): Removes all occurrences of val in nums in-place and returns the new length. k = 0 # Counter for non-val elements for i in range(len(nums)): if nums[i] != val: nums[k] = nums[i] k += 1 return k"},{"question":"def reverseParentheses(s: str) -> str: Given a string s which consists of lowercase English letters and brackets, reverse the strings inside each pair of parentheses. The strings inside parentheses can be nested within other parentheses. Return the resulting string after all the reversals are completed. >>> reverseParentheses(\\"(abcd)\\") 'dcba' >>> reverseParentheses(\\"(u(love)i)\\") 'iloveu' >>> reverseParentheses(\\"(ed(et(oc))el)\\") 'leetcode'","solution":"def reverseParentheses(s: str) -> str: stack = [] for char in s: if char == ')': substr = [] while stack and stack[-1] != '(': substr.append(stack.pop()) stack.pop() # popping the '(' stack.extend(substr) else: stack.append(char) return ''.join(stack)"},{"question":"def max_battery_consumption_diff(T, test_cases): Determine the maximum battery consumption rate difference between any two scenarios. :param T: Number of test cases :param test_cases: List of tuples, each tuple contains: - N (number of scenarios) - List of N battery consumption rates :return: List of integers representing the maximum battery consumption rate difference for each test case >>> max_battery_consumption_diff(1, [(5, [20, 40, 60, 80, 100])]) [80] >>> max_battery_consumption_diff(2, [(5, [20, 40, 60, 80, 100]), (4, [10, 15, 25, 35])]) [80, 25] >>> max_battery_consumption_diff(1, [(2, [1, 1000])]) [999] >>> max_battery_consumption_diff(1, [(5, [10, 10, 10, 10, 10])]) [0] >>> max_battery_consumption_diff(1, [(3, [1000, 200, 300])]) [800]","solution":"def max_battery_consumption_diff(T, test_cases): Determine the maximum battery consumption rate difference between any two scenarios. :param T: Number of test cases :param test_cases: List of tuples, each tuple contains: - N (number of scenarios) - List of N battery consumption rates :return: List of integers representing the maximum battery consumption rate difference for each test case result = [] for i in range(T): N, consumption_rates = test_cases[i] max_rate = max(consumption_rates) min_rate = min(consumption_rates) max_diff = max_rate - min_rate result.append(max_diff) return result"},{"question":"def are_anagrams(str1: str, str2: str) -> bool: Checks whether two strings are anagrams of each other. >>> are_anagrams(\\"listen\\", \\"silent\\") True >>> are_anagrams(\\"hello\\", \\"bellow\\") False >>> are_anagrams(\\"Listen\\", \\"Silent\\") True >>> are_anagrams(\\"meat\\", \\"teamwork\\") False >>> are_anagrams(\\"identity\\", \\"identity\\") True >>> are_anagrams(\\"\\", \\"\\") True >>> are_anagrams(\\"a\\", \\"a\\") True >>> are_anagrams(\\"a\\", \\"b\\") False >>> are_anagrams(\\"cinema\\", \\"iceman\\") True >>> are_anagrams(\\"aabbcc\\", \\"abcabc\\") True >>> are_anagrams(\\"aabbcc\\", \\"aabbc\\") False","solution":"def are_anagrams(str1, str2): Checks whether two strings are anagrams of each other. Arguments: str1 -- first string str2 -- second string Returns: True if str1 and str2 are anagrams, otherwise False # Normalize the strings by converting them to lowercase str1, str2 = str1.lower(), str2.lower() # Sort the characters of both the strings return sorted(str1) == sorted(str2)"},{"question":"import json def calculate_total_salary_expenditure(json_string: str) -> (int, int): Calculate the total monthly salary expenditure and the count of employees. Args: json_string (str): A JSON string representing employee records. Returns: (int, int): The total salary expenditure, and the count of employees. >>> json_input = ''' ... { ... \\"John Doe\\": {\\"designation\\": \\"Software Engineer\\", \\"monthly_salary\\": 5000}, ... \\"Jane Smith\\": {\\"designation\\": \\"Project Manager\\", \\"monthly_salary\\": 7000}, ... \\"Emily Johnson\\": {\\"designation\\": \\"Data Scientist\\", \\"monthly_salary\\": 6000} ... } ... ''' >>> total_salary_expenditure, total_employees = calculate_total_salary_expenditure(json_input) >>> total_salary_expenditure 18000 >>> total_employees 3 >>> json_input = '{}' >>> total_salary_expenditure, total_employees = calculate_total_salary_expenditure(json_input) >>> total_salary_expenditure 0 >>> total_employees 0","solution":"import json def calculate_total_salary_expenditure(json_string): Calculate the total monthly salary expenditure and the count of employees. Args: json_string (str): A JSON string representing employee records. Returns: (int, int): The total salary expenditure, and the count of employees. employees = json.loads(json_string) total_salary_expenditure = sum(employee['monthly_salary'] for employee in employees.values()) total_employees = len(employees) return total_salary_expenditure, total_employees"},{"question":"def unique_paths_with_obstacles(grid: List[List[int]]) -> int: Returns the number of unique paths from the top-left corner to the bottom-right corner of the grid considering obstacles. >>> unique_paths_with_obstacles([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) 2 >>> unique_paths_with_obstacles([ ... [0, 1], ... [0, 0] ... ]) 1 >>> unique_paths_with_obstacles([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) 6 >>> unique_paths_with_obstacles([ ... [0, 1, 1], ... [1, 1, 1], ... [1, 1, 0] ... ]) 0 >>> unique_paths_with_obstacles([[0]]) 1 >>> unique_paths_with_obstacles([ ... [0, 0, 0, 0, 0] ... ]) 1 >>> unique_paths_with_obstacles([ ... [0], ... [0], ... [0], ... [0], ... [0] ... ]) 1","solution":"def unique_paths_with_obstacles(grid): Returns the number of unique paths from the top-left corner to the bottom-right corner of the grid considering obstacles. :param grid: List[List[int]] :return: int if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return 0 m, n = len(grid), len(grid[0]) # Create a 2D dp array dp = [[0] * n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[-1][-1]"},{"question":"def find_hidden_message(t: int, test_cases: List[List[int]]) -> List[int]: Find the hidden message by applying the given pattern to the list of integers. >>> find_hidden_message(3, [[10, 20, 30, 40, 50], [5, 15, 25, 35, 45, 55], [71]]) [30, 60, 71] >>> find_hidden_message(2, [[100], [200]]) [100, 200] >>> find_hidden_message(2, [[1, 2, 3, 4, 5], [11, 22, 33, 44, 55, 66, 77]]) [3, 44] >>> find_hidden_message(2, [[1, 2, 3, 4], [10, 20, 30, 40, 50, 60]]) [5, 70] >>> find_hidden_message(2, [[7, 8, 9, 10, 11, 12], [15, 25, 35, 45, 55, 65, 75]]) [19, 45]","solution":"def find_hidden_message(t, test_cases): results = [] for case in test_cases: n = len(case) if n % 2 == 1: # odd number of integers middle_index = n // 2 results.append(case[middle_index]) else: # even number of integers middle_index1 = n // 2 - 1 middle_index2 = n // 2 results.append(case[middle_index1] + case[middle_index2]) return results"},{"question":"from typing import List from collections import defaultdict MOD = 10**9 + 7 def count_subsets_with_sum(nums: List[int], target: int) -> int: Returns the number of distinct subsets of the sequence nums whose sum equals target, modulo 10^9 + 7. >>> count_subsets_with_sum([1, 2, 3, -1, 5], 3) 3 >>> count_subsets_with_sum([-1, 1, -1, 1], 0) 6","solution":"MOD = 10**9 + 7 def count_subsets_with_sum(nums, target): Returns the number of distinct subsets of the sequence nums whose sum equals target, modulo 10^9 + 7. # Initialize the hash table to store the counts of sums. from collections import defaultdict sum_counts = defaultdict(int) sum_counts[0] = 1 for num in nums: current_counts = list(sum_counts.items()) for current_sum, count in current_counts: new_sum = current_sum + num sum_counts[new_sum] = (sum_counts[new_sum] + count) % MOD return sum_counts[target] # Read input from stdin def main(): import sys input = sys.stdin.read data = input().strip().split() N = int(data[0]) T = int(data[1]) nums = list(map(int, data[2:N+2])) result = count_subsets_with_sum(nums, T) print(result) if __name__ == \\"__main__\\": main()"},{"question":"def has_pair_with_sum(N: int, K: int, A: List[int]) -> str: Determines if there exist two integers in the array A whose sum is exactly K. :param N: int - number of integers in the array :param K: int - target sum :param A: list of int - the array of integers :return: str - \\"YES\\" if such a pair exists, otherwise \\"NO\\" >>> has_pair_with_sum(5, 9, [2, 7, 11, 15, 3]) 'YES' >>> has_pair_with_sum(4, 10, [1, 2, 3, 4]) 'NO'","solution":"def has_pair_with_sum(N, K, A): Determines if there exist two integers in the array A whose sum is exactly K. :param N: int - number of integers in the array :param K: int - target sum :param A: list of int - the array of integers :return: str - \\"YES\\" if such a pair exists, otherwise \\"NO\\" seen = set() for num in A: if K - num in seen: return \\"YES\\" seen.add(num) return \\"NO\\""},{"question":"def count_unique_and_non_unique_elements(numbers): Count the number of unique and non-unique elements in a list. Args: numbers (list): A list of integers where the end is marked by -1. Returns: tuple: A tuple with the number of unique elements and non-unique elements. >>> count_unique_and_non_unique_elements([1, 2, 3, -1]) (3, 0) >>> count_unique_and_non_unique_elements([1, 1, 1, -1]) (0, 1) >>> count_unique_and_non_unique_elements([1, 2, 2, 3, -1]) (2, 1) >>> count_unique_and_non_unique_elements([1, 2, 3, 3, 2, -1]) (1, 2) >>> count_unique_and_non_unique_elements([-1]) (0, 0) >>> count_unique_and_non_unique_elements([1, -1]) (1, 0)","solution":"def count_unique_and_non_unique_elements(numbers): Count the number of unique and non-unique elements in a list. Args: numbers (list): A list of integers where the end is marked by -1. Returns: tuple: A tuple with the number of unique elements and non-unique elements. num_count = {} for num in numbers: if num == -1: break if num in num_count: num_count[num] += 1 else: num_count[num] = 1 unique_count = sum(1 for count in num_count.values() if count == 1) non_unique_count = sum(1 for count in num_count.values() if count > 1) return unique_count, non_unique_count"},{"question":"def combinationSum(nums: List[int], target: int) -> List[List[int]]: Write a function that takes a list of integers and returns a list containing all the unique combinations of numbers from the input list that sum up to a target value. >>> combinationSum([10, 1, 2, 7, 6, 1, 5], 8) [ [1, 1, 6], [1, 2, 5], [1, 7], [2, 6] ] >>> combinationSum([1], 1) [ [1] ] >>> combinationSum([2, 4, 6], 3) [] >>> combinationSum([2, 3, 5], 8) [ [3, 5] ] >>> combinationSum([1, 1, 1, 1, 1, 1, 1], 4) [ [1, 1, 1, 1] ] >>> combinationSum([2, 2, 2], 4) [ [2, 2] ]","solution":"def combinationSum(nums, target): def backtrack(start, path, target): if target == 0: result.append(path) return if target < 0: return for i in range(start, len(nums)): if i > start and nums[i] == nums[i - 1]: continue backtrack(i + 1, path + [nums[i]], target - nums[i]) nums.sort() result = [] backtrack(0, [], target) return result"},{"question":"def nth_prime(n: int) -> int: Given an integer n, return the nth prime number. >>> nth_prime(1) == 2 >>> nth_prime(5) == 11 >>> nth_prime(10) == 29","solution":"def nth_prime(n): Returns the nth prime number. if n <= 0: return None primes = [] candidate = 2 while len(primes) < n: is_prime = True for prime in primes: if prime * prime > candidate: break if candidate % prime == 0: is_prime = False break if is_prime: primes.append(candidate) candidate += 1 return primes[-1]"},{"question":"def trailing_zeros(n): Calculate the number of trailing zeros in n! Args: n (int): The number for which the factorial is to be computed. Returns: int: The number of trailing zeros in n!. count = 0 while n >= 5: n //= 5 count += n return count def test_trailing_zeros_0(): assert trailing_zeros(0) == 0 def test_trailing_zeros_5(): assert trailing_zeros(5) == 1 def test_trailing_zeros_10(): assert trailing_zeros(10) == 2 def test_trailing_zeros_25(): assert trailing_zeros(25) == 6 def test_trailing_zeros_100(): assert trailing_zeros(100) == 24 def test_trailing_zeros_1000(): assert trailing_zeros(1000) == 249 def test_trailing_zeros_10000(): assert trailing_zeros(10000) == 2499","solution":"def trailing_zeros(n): Calculate the number of trailing zeros in n! Args: n (int): The number for which the factorial is to be computed. Returns: int: The number of trailing zeros in n!. count = 0 while n >= 5: n //= 5 count += n return count"},{"question":"def longest_substring_with_k_replacements(k: int, s: str) -> int: Returns the length of the longest substring that can be made by replacing at most \`k\` characters with any other character in the given string \`s\`. >>> longest_substring_with_k_replacements(2, \\"ABAB\\") 4 >>> longest_substring_with_k_replacements(1, \\"AABABBA\\") 4 >>> longest_substring_with_k_replacements(0, \\"ABCDE\\") 1","solution":"def longest_substring_with_k_replacements(k, s): Returns the length of the longest substring that can be made by replacing at most \`k\` characters with any other character in the given string \`s\`. l = 0 max_freq = 0 char_counts = {} max_len = 0 for r in range(len(s)): char_counts[s[r]] = char_counts.get(s[r], 0) + 1 max_freq = max(max_freq, char_counts[s[r]]) if (r - l + 1) - max_freq > k: char_counts[s[l]] -= 1 l += 1 max_len = max(max_len, r - l + 1) return max_len"},{"question":"def findContradictoryWidgets(T, cases): Returns a list of widget IDs for each test case that have contradictory inspection results. Args: T: An integer representing the number of test cases. cases: A list of test cases, each consisting of a list of inspections. Each inspection is represented as a two-element list where the first element is an integer (widget ID) and the second element is a boolean (inspection result). Returns: A list of lists where each sub-list contains widget IDs with contradictory results for each test case. Example: >>> findContradictoryWidgets(1, [[[1, True], [2, True], [1, False], [3, True]]]) [[1]] >>> findContradictoryWidgets(2, [[[1, True], [2, True], [1, False], [3, True]], [[1, True], [2, False], [3, True], [2, True], [3, False]]]) [[1], [2, 3]]","solution":"def findContradictoryWidgets(T, cases): Returns a list of widget IDs for each test case that have contradictory inspection results. results = [] for i in range(T): inspections = cases[i] inspection_dict = {} for inspection in inspections: widget_id, result = inspection if widget_id not in inspection_dict: inspection_dict[widget_id] = set() inspection_dict[widget_id].add(result) contradictory_widgets = [wid for wid, res in inspection_dict.items() if len(res) > 1] contradictory_widgets.sort() # sort the list of widget IDs for consistency in output results.append(contradictory_widgets) return results"},{"question":"def remove_character_from_string(input_list): Given a list where the first element is an integer M and the following elements are pairs of strings and characters, removes all instances of each character from each corresponding string and returns a list of modified strings. Parameters: input_list (list): List containing an integer M followed by M pairs of strings and characters. Returns: list: List of modified strings with characters removed. Examples: >>> remove_character_from_string([3, 'hello', 'l', 'banana', 'n', 'test', 't']) ['heo', 'baaa', 'es'] >>> remove_character_from_string([2, 'hello', 'z', 'world', 'x']) ['hello', 'world'] >>> remove_character_from_string([1, 'aaaa', 'a']) [''] >>> remove_character_from_string([1, '', 'a']) [''] >>> remove_character_from_string([1, 'hello world', ' ']) ['helloworld']","solution":"def remove_character_from_string(input_list): Given a list where the first element is an integer M and the following elements are pairs of strings and characters, this function removes all instances of each character from each corresponding string and returns a list of modified strings. M = input_list[0] results = [] for i in range(1, M + 1): string, char = input_list[2 * i - 1], input_list[2 * i] modified_string = string.replace(char, '') results.append(modified_string) return results"},{"question":"def generate_magic_square(n): Generates an n x n magic square. n must be an odd number. >>> generate_magic_square(3) [[8, 1, 6], [3, 5, 7], [4, 9, 2]] >>> generate_magic_square(5) [[17, 24, 1, 8, 15], [23, 5, 7, 14, 16], [4, 6, 13, 20, 22], [10, 12, 19, 21, 3], [11, 18, 25, 2, 9]] >>> generate_magic_square(1) [[1]] >>> generate_magic_square(2) Traceback (most recent call last): ... ValueError: n must be an odd integer between 1 and 9 inclusive. >>> generate_magic_square(10) Traceback (most recent call last): ... ValueError: n must be an odd integer between 1 and 9 inclusive. >>> generate_magic_square(0) Traceback (most recent call last): ... ValueError: n must be an odd integer between 1 and 9 inclusive.","solution":"def generate_magic_square(n): Generates an n x n magic square. n must be an odd number. if n < 1 or n > 9 or n % 2 == 0: raise ValueError(\\"n must be an odd integer between 1 and 9 inclusive.\\") magic_square = [[0] * n for _ in range(n)] num = 1 i, j = 0, n // 2 while num <= n * n: magic_square[i][j] = num num += 1 newi, newj = (i - 1) % n, (j + 1) % n if magic_square[newi][newj]: i += 1 else: i, j = newi, newj return magic_square def print_magic_square(square): Print the magic square with appropriate spacing. n = len(square) width = len(str(n * n)) for row in square: print(\\" \\".join(f\\"{num:>{width}}\\" for num in row)) def main(): import sys input = sys.stdin.read n = int(input().strip()) square = generate_magic_square(n) print_magic_square(square) if __name__ == \\"__main__\\": main()"},{"question":"def is_special_number(m: int, y: int, numbers: List[int]) -> int: Determines if y is a special number (divisible by at least one of the numbers in the list). :param m: Number of elements in the list :param y: The number to check :param numbers: List of integers :return: 1 if y is a special number, otherwise 0 >>> is_special_number(3, 15, [3, 5, 7]) 1 >>> is_special_number(4, 14, [2, 3, 6, 9]) 1 >>> is_special_number(3, 17, [3, 5, 7]) 0 >>> is_special_number(4, 23, [2, 3, 6, 9]) 0 >>> is_special_number(1, 1, [1]) 1 >>> is_special_number(1, 1, [2]) 0 >>> is_special_number(5, 1000, [10, 20, 25, 50, 200]) 1 >>> is_special_number(5, 1001, [10, 20, 25, 50, 200]) 0 >>> is_special_number(5, 1, [1, 2, 3, 4, 5]) 1 >>> is_special_number(5, 1, [2, 3, 4, 5, 6]) 0","solution":"def is_special_number(m, y, numbers): Determines if y is a special number (divisible by at least one of the numbers in the list). :param m: Number of elements in the list :param y: The number to check :param numbers: List of integers :return: 1 if y is a special number, otherwise 0 for num in numbers: if y % num == 0: return 1 return 0 # Example usage: # m = 4 # y = 14 # numbers = [2, 3, 6, 9] # Output: 1 (because 14 is divisible by 2)"},{"question":"def maxElement(N, A): Returns the maximum possible value of the remaining element after performing specified operations on the array A. Example: >>> maxElement(3, [1, 2, 3]) 6 >>> maxElement(4, [1, 2, 3, 4]) 10 >>> maxElement(1, [5]) 5 >>> maxElement(5, [5, 5, 5, 5, 5]) 25 >>> maxElement(5, [1, 2, 3, 4, 5]) 15 >>> maxElement(3, [1000000000, 1000000000, 1000000000]) 3000000000 >>> maxElement(6, [1, 1, 1, 1, 1, 6]) 11 >>> maxElement(2, [1, 1000000000]) 1000000001","solution":"def maxElement(N, A): Returns the maximum possible value of the remaining element after performing specified operations on the array A. # The maximum possible value after the operations would be the sum of all elements. return sum(A)"},{"question":"import math from typing import List def count_portals(N: int, addresses: List[int]) -> int: Determines the number of portals that can be established between consecutive streets based on the given addresses. >>> count_portals(5, [3, 5, 7, 10, 14]) 3 >>> count_portals(4, [6, 10, 15, 25]) 0","solution":"import math def count_portals(N, addresses): Returns the number of portals that can be established between consecutive streets based on the given addresses. # Initialize the portal count to 0 portal_count = 0 # Iterate through the street addresses to check consecutive pairs for i in range(N - 1): if math.gcd(addresses[i], addresses[i + 1]) == 1: portal_count += 1 return portal_count"},{"question":"def maxCommitsInInterval(commits, n, m): Function to determine the maximum number of commits made in any continuous interval of M minutes. Args: commits: List[int] : List of integers representing commit times n: int : Number of commits m: int : Interval in minutes Returns: int : Maximum number of commits in any continuous interval of M minutes Examples: >>> maxCommitsInInterval([10, 20, 30, 100, 110], 5, 60) 3 >>> maxCommitsInInterval([1, 2, 3, 14, 15, 30, 31], 7, 15) 5 >>> maxCommitsInInterval([], 0, 60) 0 >>> maxCommitsInInterval([15], 1, 60) 1 >>> maxCommitsInInterval([1, 100, 200], 3, 10) 1 >>> maxCommitsInInterval([0, 1, 5, 10, 14], 5, 15) 5 >>> maxCommitsInInterval([1, 100, 200], 3, 50) 1 >>> maxCommitsInInterval([10, 20, 30, 40, 50, 60, 70], 7, 100) 7","solution":"def maxCommitsInInterval(commits, n, m): Function to determine the maximum number of commits made in any continuous interval of M minutes. # Edge case: If there are no commits if n == 0: return 0 # Sort the commits to ensure they are in ascending order commits.sort() max_commits = 0 start = 0 # Start of the sliding window for end in range(n): # Slide the window to include the current end commit # and exclude commits that are out of the interval while commits[end] - commits[start] > m: start += 1 # Update max_commits with the current window size max_commits = max(max_commits, end - start + 1) return max_commits"},{"question":"from collections import deque, defaultdict def find_performance_order(n: int, m: int, dependencies: List[Tuple[int, int]]) -> Union[List[int], str]: Determine a valid order of performances respecting the given dependencies. Args: n (int): The number of performances. m (int): The number of dependencies. dependencies (List[Tuple[int, int]]): List of dependencies where each tuple (a, b) means performance \`a\` must be completed before \`b\`. Returns: Union[List[int], str]: A valid order of performances or \\"IMPOSSIBLE\\" if no such order exists. Examples: >>> find_performance_order(5, 4, [(1, 2), (1, 3), (3, 4), (4, 5)]) [1, 3, 4, 5, 2] >>> find_performance_order(3, 3, [(1, 2), (2, 3), (3, 1)]) \\"IMPOSSIBLE\\" import pytest def test_find_performance_order(): assert find_performance_order(5, 4, [(1, 2), (1, 3), (3, 4), (4, 5)]) != \\"IMPOSSIBLE\\" assert find_performance_order(3, 3, [(1, 2), (2, 3), (3, 1)]) == \\"IMPOSSIBLE\\" assert find_performance_order(4, 0, []) != \\"IMPOSSIBLE\\" assert find_performance_order(1, 0, []) == [1] assert find_performance_order(3, 2, [(1, 2), (2, 3)]) == [1, 2, 3] assert find_performance_order(2, 1, [(1, 2)]) == [1, 2] assert find_performance_order(3, 2, [(1, 3), (2, 3)]) != \\"IMPOSSIBLE\\"","solution":"from collections import deque, defaultdict def find_performance_order(n, m, dependencies): indegree = [0] * (n + 1) graph = defaultdict(list) # Build the graph and count indegrees for a, b in dependencies: graph[a].append(b) indegree[b] += 1 # Initialize queue with nodes having 0 indegree queue = deque([i for i in range(1, n + 1) if indegree[i] == 0]) order = [] while queue: node = queue.popleft() order.append(node) for neighbor in graph[node]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) # Check if we have included all the performances if len(order) == n: return order else: return \\"IMPOSSIBLE\\" # Example Usage n = 5 m = 4 dependencies = [ (1, 2), (1, 3), (3, 4), (4, 5) ] print(find_performance_order(n, m, dependencies)) # Example output"},{"question":"def can_follow_route(grid_size, route): Determines whether a Jumpicorn can follow the given route on an n x n grid. Args: grid_size (int): Size of the n x n grid. route (List[Tuple[int, int]]): List of coordinates representing the route. Returns: bool: True if the Jumpicorn can follow the route, False otherwise. Examples: >>> can_follow_route(5, [(0, 0), (0, 1), (1, 1)]) True >>> can_follow_route(5, [(0, 0), (2, 0)]) False","solution":"def can_follow_route(grid_size, route): Determines whether a Jumpicorn can follow the given route on an n x n grid. Args: grid_size (int): Size of the n x n grid. route (List[Tuple[int, int]]): List of coordinates representing the route. Returns: bool: True if the Jumpicorn can follow the route, False otherwise. for i in range(1, len(route)): x1, y1 = route[i-1] x2, y2 = route[i] # Calculate the differences in x and y coordinates dx = abs(x2 - x1) dy = abs(y2 - y1) # Check if the move is more than one unit away if dx > 1 or dy > 1: return False return True"},{"question":"def encode_message(message: str) -> str: Encodes the input message based on the described encoding process. Parameters: message (str): The original message to be encoded. Returns: str: The encoded message. >>> encode_message(\\"HELLO WORLD\\") 'HFNOSXZISUI' >>> encode_message(\\"ABC\\") 'BCD' # Your implementation here def decode_message(encoded_message: str) -> str: Decodes the encoded message back to its original form. Parameters: encoded_message (str): The encoded message to be decoded. Returns: str: The decoded message. >>> decode_message(\\"HFNOSXZISUI\\") 'HELLO WORLD' >>> decode_message(\\"BCD\\") 'ABC' # Your implementation here import pytest def test_encode_decode_simple(): message = \\"HELLO WORLD\\" encoded = encode_message(message) assert encoded != message, \\"Encoded message should differ from the original\\" assert decode_message(encoded) == message, \\"Decoded message should match the original\\" def test_single_character(): assert encode_message(\\"A\\") == \\"B\\" assert encode_message(\\" \\") == \\"A\\" assert decode_message(\\"B\\") == \\"A\\" assert decode_message(\\"A\\") == \\" \\" def test_all_letters(): original_message = \\"ABCDEFGHIJKLMNOPQRSTUVWXYZ \\" encoded_message = encode_message(original_message) decoded_message = decode_message(encoded_message) assert decoded_message == original_message def test_edge_cases(): assert encode_message(\\"\\") == \\"\\", \\"Encoding an empty string should return an empty string\\" assert decode_message(\\"\\") == \\"\\", \\"Decoding an empty string should return an empty string\\" assert encode_message(\\" \\") == \\"A\\", \\"Single space encoding\\" assert decode_message(\\"A\\") == \\" \\", \\"Single A decoding\\" def test_large_input(): long_message = \\"HELLO WORLD\\" * 10000 encoded = encode_message(long_message) assert decode_message(encoded) == long_message pytest.main()","solution":"def encode_message(message: str) -> str: Encodes the input message based on the described encoding process. encoded = [] for i, char in enumerate(message): # Calculate the 0-based alphabetical/index position if char == ' ': pos = 26 else: pos = ord(char) - ord('A') # Increment by position (1-based) and modulo 27 new_pos = (pos + (i + 1)) % 27 # Convert back to character if new_pos == 26: encoded_char = ' ' else: encoded_char = chr(ord('A') + new_pos) encoded.append(encoded_char) return ''.join(encoded) def decode_message(encoded_message: str) -> str: Decodes the encoded message back to its original form. decoded = [] for i, char in enumerate(encoded_message): # Calculate the 0-based position if char == ' ': pos = 26 else: pos = ord(char) - ord('A') # Subtract the position (1-based) and modulo 27 orig_pos = (pos - (i + 1)) % 27 # Convert back to original character if orig_pos == 26: decoded_char = ' ' else: decoded_char = chr(ord('A') + orig_pos) decoded.append(decoded_char) return ''.join(decoded)"},{"question":"def can_form_palindrome(s: str) -> str: Determines if the given string can be rearranged to form a palindrome. >>> can_form_palindrome(\\"civic\\") \\"YES\\" >>> can_form_palindrome(\\"ivicc\\") \\"YES\\" >>> can_form_palindrome(\\"hello\\") \\"NO\\" >>> can_form_palindrome(\\"aabb\\") \\"YES\\" >>> can_form_palindrome(\\"aaabb\\") \\"YES\\" def palindrome_test_cases(T: int, cases: List[str]) -> List[str]: Processes multiple test cases and determines if each string can be rearranged to form a palindrome. >>> palindrome_test_cases(3, [\\"civic\\", \\"ivicc\\", \\"hello\\"]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> palindrome_test_cases(2, [\\"aabb\\", \\"aaabb\\"]) [\\"YES\\", \\"YES\\"] >>> palindrome_test_cases(1, [\\"abc\\"]) [\\"NO\\"] >>> palindrome_test_cases(4, [\\"aa\\", \\"bb\\", \\"cc\\", \\"dd\\"]) [\\"YES\\", \\"YES\\", \\"YES\\", \\"YES\\"]","solution":"def can_form_palindrome(s): Determines if the given string can be rearranged to form a palindrome. :param s: A string consisting of lowercase letters :return: \\"YES\\" if the string can be rearranged to form a palindrome, otherwise \\"NO\\" from collections import Counter char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can be rearranged into a palindrome if it has at most one character with an odd count return \\"YES\\" if odd_count <= 1 else \\"NO\\" # Function to process multiple test cases def palindrome_test_cases(T, cases): results = [] for i in range(T): results.append(can_form_palindrome(cases[i])) return results"},{"question":"def track_word_frequencies(reviews, words_to_track): Returns the frequency of specific words in product reviews. Parameters: reviews (dict): Dictionary where keys are product IDs and values are lists of review strings. words_to_track (list): List of words to track frequencies for. Returns: dict: Dictionary with product IDs as keys and dictionaries of word frequencies as values. Example: >>> track_word_frequencies( >>> { >>> \\"P123\\": [\\"Excellent quality, will buy again\\", \\"Not worth the price\\", \\"Quality is great but expensive\\"], >>> \\"P456\\": [\\"Very comfortable\\", \\"Comfortable and affordable\\", \\"Not comfortable at all\\", \\"Highly recommend for comfort\\"], >>> \\"P789\\": [\\"Poor quality\\", \\"Quality is a big issue\\", \\"Will not recommend\\"] >>> }, >>> [\\"quality\\", \\"comfortable\\", \\"expensive\\", \\"recommend\\"] >>> ) { \\"P123\\": {\\"quality\\": 2, \\"comfortable\\": 0, \\"expensive\\": 1, \\"recommend\\": 0}, \\"P456\\": {\\"quality\\": 0, \\"comfortable\\": 3, \\"expensive\\": 0, \\"recommend\\": 1}, \\"P789\\": {\\"quality\\": 2, \\"comfortable\\": 0, \\"expensive\\": 0, \\"recommend\\": 1} }","solution":"def track_word_frequencies(reviews, words_to_track): Returns the frequency of specific words in product reviews. Parameters: reviews (dict): Dictionary where keys are product IDs and values are lists of review strings. words_to_track (list): List of words to track frequencies for. Returns: dict: Dictionary with product IDs as keys and dictionaries of word frequencies as values. def count_words(review_list, words_set): word_count = {word: 0 for word in words_set} for review in review_list: review_lower = review.lower() for word in words_set: word_count[word] += review_lower.count(word) return word_count words_set = set([word.lower() for word in words_to_track]) result = {} for product_id, review_list in reviews.items(): if any(\\"fraud\\" in review.lower() for review in review_list): continue result[product_id] = count_words(review_list, words_set) return result"},{"question":"def handle_operations(N, Q, roles, operations): Manage a list of employees with abilities to add, update roles and query roles. :param N: Initial number of employees :param Q: Number of operations to be performed :param roles: List of initial roles of the employees :param operations: List of operations to be executed on employees :return: List of results for each query operation Operations: 1. Add an employee with a unique ID and a role to the list. 2. Update the role of an existing employee. 3. Query to find out how many employees have a specific role in the listed subset. >>> handle_operations(5, 4, [1, 2, 3, 4, 5], [(1, 6, 1), (2, 2, 3), (3, 1, 5, 1), (3, 2, 4, 3)]) [1, 2] >>> handle_operations(1, 1, [1], [(3, 1, 1, 1)]) [1] from solution import handle_operations def test_handle_operations(): N, Q = 5, 4 roles = [1, 2, 3, 4, 5] operations = [ (1, 6, 1), # Add employee with unique ID 6 and role 1 (2, 2, 3), # Update role of employee with ID 2 to 3 (3, 1, 5, 1), # Query number of employees with role 1 from index 1 to 5 (3, 2, 4, 3) # Query number of employees with role 3 from index 2 to 4 ] expected = [1, 2] assert handle_operations(N, Q, roles, operations) == expected def test_single_employee(): N, Q = 1, 1 roles = [1] operations = [ (3, 1, 1, 1), # Query number of employees with role 1 from index 1 to 1 ] expected = [1] assert handle_operations(N, Q, roles, operations) == expected def test_add_and_update(): N, Q = 3, 3 roles = [2, 3, 4] operations = [ (1, 4, 5), # Add employee with unique ID 4 and role 5 (2, 1, 5), # Update role of employee with ID 1 to 5 (3, 1, 4, 5), # Query number of employees with role 5 from index 1 to 4 ] expected = [2] assert handle_operations(N, Q, roles, operations) == expected def test_multiple_updates(): N, Q = 5, 3 roles = [2, 2, 2, 3, 4] operations = [ (2, 1, 3), # Update role of employee with ID 1 to 3 (2, 4, 2), # Update role of employee with ID 4 to 2 (3, 1, 5, 2), # Query number of employees with role 2 from index 1 to 5 ] expected = [3] assert handle_operations(N, Q, roles, operations) == expected","solution":"class EmployeeManager: def __init__(self, roles): self.employees = roles self.id_map = {i+1: i for i in range(len(roles))} def add_employee(self, role): self.employees.append(role) self.id_map[len(self.employees)] = len(self.employees) - 1 def update_role(self, id, new_role): index = self.id_map[id] self.employees[index] = new_role def query_role_count(self, L, R, role): return sum(1 for i in range(L-1, R) if self.employees[i] == role) # Function to handle the operations def handle_operations(N, Q, roles, operations): manager = EmployeeManager(roles) results = [] for op in operations: if op[0] == 1: manager.add_employee(op[2]) elif op[0] == 2: manager.update_role(op[1], op[2]) elif op[0] == 3: results.append(manager.query_role_count(op[1], op[2], op[3])) return results"},{"question":"from typing import List def k_most_frequent(nums: List[int], k: int) -> List[int]: Given an array \`nums\` consisting of \`n\` integers and an integer \`k\`, returns the \`k\` most frequent elements in the array. If there are multiple answers, return any of them. >>> k_most_frequent([1, 1, 1, 2, 2, 3], 2) [1, 2] >>> k_most_frequent([4, 4, 4, 6, 6, 2, 2, 2], 3) [2, 4, 6] >>> k_most_frequent([1], 1) [1] >>> k_most_frequent([5, 5, 5, 5], 1) [5] >>> k_most_frequent([i for i in range(100)] * 10, 5) [0, 1, 2, 3, 4]","solution":"from collections import Counter def k_most_frequent(nums, k): Returns the k most frequent elements in the array nums. count = Counter(nums) return [item for item, _ in count.most_common(k)]"},{"question":"def max_difficulty_in_k_steps(N, K, terrains): Returns the maximum difficulty faced during any exactly K consecutive steps. :param N: int: The number of terrains :param K: int: The number of consecutive steps :param terrains: List[int]: The difficulty levels of the terrains :return: int: The maximum difficulty faced during any exactly K consecutive steps >>> max_difficulty_in_k_steps(10, 3, [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]) 100 >>> max_difficulty_in_k_steps(5, 2, [5, 1, 2, 6, 7]) 7 >>> max_difficulty_in_k_steps(1, 1, [10]) 10 >>> max_difficulty_in_k_steps(5, 3, [4, 4, 4, 4, 4]) 4 >>> max_difficulty_in_k_steps(6, 2, [10, 9, 4, 3, 2, 1]) 10 >>> max_difficulty_in_k_steps(6, 3, [1, 2, 3, 4, 5, 6]) 6","solution":"def max_difficulty_in_k_steps(N, K, terrains): Returns the maximum difficulty faced during any exactly K consecutive steps. :param N: int: The number of terrains :param K: int: The number of consecutive steps :param terrains: List[int]: The difficulty levels of the terrains :return: int: The maximum difficulty faced during any exactly K consecutive steps max_difficulty = 0 for i in range(N - K + 1): max_difficulty = max(max_difficulty, max(terrains[i:i+K])) return max_difficulty"},{"question":"def can_form_palindromic_permutation(s: str) -> bool: Determine if a permutation of the input string can form a palindrome. >>> can_form_palindromic_permutation(\\"civic\\") True >>> can_form_palindromic_permutation(\\"ivicc\\") True >>> can_form_palindromic_permutation(\\"hello\\") False def process_test_cases(t: int, cases: List[str]) -> List[str]: Process multiple test cases to determine if each string can be rearranged to form a palindrome. >>> process_test_cases(3, [\\"civic\\", \\"ivicc\\", \\"hello\\"]) [\\"YES\\", \\"YES\\", \\"NO\\"]","solution":"def can_form_palindromic_permutation(s): from collections import Counter counts = Counter(s) # A string can be rearranged to form a palindrome if at most one character has an odd count. odd_count = sum(1 for count in counts.values() if count % 2 != 0) return odd_count <= 1 def process_test_cases(t, cases): results = [] for case in cases: result = \\"YES\\" if can_form_palindromic_permutation(case) else \\"NO\\" results.append(result) return results"},{"question":"def maxUnguardedExhibits(n: int, m: int, intervals: List[List[int]]) -> int: Determine the maximum number of exhibits that can be left unguarded simultaneously during any interval. >>> maxUnguardedExhibits(5, 4, [[1, 1, 5], [2, 2, 6], [3, 3, 7], [4, 4, 8]]) 4 >>> maxUnguardedExhibits(3, 3, [[1, 1, 3], [2, 4, 6], [3, 2, 5]]) 2 pass # Test cases def test_example1(): n = 5 m = 4 intervals = [ [1, 1, 5], [2, 2, 6], [3, 3, 7], [4, 4, 8] ] assert maxUnguardedExhibits(n, m, intervals) == 4 def test_example2(): n = 3 m = 3 intervals = [ [1, 1, 3], [2, 4, 6], [3, 2, 5] ] assert maxUnguardedExhibits(n, m, intervals) == 2 def test_no_overlap(): n = 3 m = 3 intervals = [ [1, 1, 2], [2, 3, 4], [3, 5, 6] ] assert maxUnguardedExhibits(n, m, intervals) == 1 def test_full_overlap(): n = 5 m = 5 intervals = [ [1, 1, 5], [2, 1, 5], [3, 1, 5], [4, 1, 5], [5, 1, 5] ] assert maxUnguardedExhibits(n, m, intervals) == 5 def test_partial_overlap(): n = 4 m = 4 intervals = [ [1, 1, 4], [2, 2, 5], [3, 3, 6], [4, 7, 8] ] assert maxUnguardedExhibits(n, m, intervals) == 3 def test_single_interval(): n = 2 m = 1 intervals = [ [1, 5, 10] ] assert maxUnguardedExhibits(n, m, intervals) == 1","solution":"from typing import List def maxUnguardedExhibits(n: int, m: int, intervals: List[List[int]]) -> int: from collections import defaultdict import heapq events = [] for interval in intervals: guard, start, end = interval events.append((start, 1, guard)) events.append((end+1, -1, guard)) events.sort() max_unguarded = 0 current_unguarded = 0 active_guards = set() guard_times = {} for time, event_type, guard in events: if event_type == 1: active_guards.add(guard) current_unguarded += 1 guard_times[guard] = time max_unguarded = max(max_unguarded, current_unguarded) else: if guard in active_guards: active_guards.remove(guard) current_unguarded -= 1 return max_unguarded"},{"question":"def min_difficulty(n: int, m: int, grid: List[List[int]]) -> int: Determine the minimal total difficulty to cover the entire grid using one robot. >>> min_difficulty(2, 2, [[1, 2], [3, 4]]) 10 >>> min_difficulty(3, 3, [[1, 1, 1], [1, 2, 1], [1, 1, 1]]) 10","solution":"def min_difficulty(n, m, grid): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def is_valid(x, y, visited): return 0 <= x < n and 0 <= y < m and not visited[x][y] def dfs(x, y, visited, current_sum, remain_cells): if remain_cells == 1: return current_sum + grid[x][y] visited[x][y] = True min_sum = float('inf') for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny, visited): min_sum = min(min_sum, dfs(nx, ny, visited, current_sum + grid[x][y], remain_cells - 1)) visited[x][y] = False return min_sum minimal_difficulty = float('inf') for i in range(n): for j in range(m): visited = [[False] * m for _ in range(n)] minimal_difficulty = min(minimal_difficulty, dfs(i, j, visited, 0, n * m)) return minimal_difficulty # Example usage n, m = 2, 2 grid = [[1, 2], [3, 4]] print(min_difficulty(n, m, grid)) # Output: 10 n, m = 3, 3 grid = [[1, 1, 1], [1, 2, 1], [1, 1, 1]] print(min_difficulty(n, m, grid)) # Output: 10"},{"question":"def distributeCandies(n, r): Write a program to calculate the number of ways to distribute \`n\` distinct candies into \`r\` identical jars such that no jar is empty. >>> distributeCandies(4, 2) 3 >>> distributeCandies(5, 3) 6 from solution import distributeCandies def test_example_1(): assert distributeCandies(4, 2) == 3 def test_example_2(): assert distributeCandies(5, 3) == 6 def test_corner_case_not_enough_candies(): assert distributeCandies(3, 4) == 0 def test_exact_distribution(): assert distributeCandies(5, 1) == 1 def test_equal_candies_and_jars(): assert distributeCandies(7, 7) == 1 def test_minimal_case(): assert distributeCandies(1, 1) == 1 def test_non_trivial_case(): assert distributeCandies(10, 4) == 84","solution":"def distributeCandies(n, r): Returns the number of ways to distribute n distinct candies into r identical jars such that no jar is empty. Uses dynamic programming to calculate the possible distributions. # Base case: Not enough candies to go around if n < r if n < r: return 0 # Initialize a DP table dp = [[0 for _ in range(n+1)] for _ in range(r+1)] # Base case: 1 way to fill 0 jars —> doing nothing dp[0][0] = 1 # Fill the DP table for i in range(1, r+1): for j in range(1, n+1): if j >= i: dp[i][j] = dp[i-1][j-1] + dp[i][j-1] else: dp[i][j] = dp[i-1][j-1] return dp[r][n]"},{"question":"def move_zeros_to_end(arr): Moves all zeros in the array to the end while maintaining the relative order of non-zero elements. :param arr: List of integers :return: List of integers with zeros moved to the end Examples: >>> move_zeros_to_end([0, 1, 0, 3, 12, 0, 2]) [1, 3, 12, 2, 0, 0, 0] >>> move_zeros_to_end([0, 0, 0, 2, 5]) [2, 5, 0, 0, 0] >>> move_zeros_to_end([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> move_zeros_to_end([1, 2, 3, 0, 0, 0]) [1, 2, 3, 0, 0, 0] >>> move_zeros_to_end([0, 0, 0, 0, 0]) [0, 0, 0, 0, 0] >>> move_zeros_to_end([0]) [0] >>> move_zeros_to_end([1]) [1]","solution":"def move_zeros_to_end(arr): Moves all zeros in the array to the end while maintaining the relative order of non-zero elements. :param arr: List of integers :return: List of integers with zeros moved to the end # Initialize a list for non-zero elements non_zero_elements = [num for num in arr if num != 0] # Count the number of zeros in the array zero_count = arr.count(0) # Concatenate non-zero elements with the required number of zeros at the end result = non_zero_elements + [0] * zero_count return result"},{"question":"from typing import List def uniqueCombinations(n: int, s: str) -> List[str]: Find all possible unique combinations of the characters in the given string. The combinations may vary in length from 1 to the length of the string itself. Parameters: n (int): The length of the input string. s (str): The input string. Returns: List[str]: A sorted list of unique combinations. Examples: >>> uniqueCombinations(3, \\"aab\\") ['a', 'aa', 'aab', 'ab', 'b'] >>> uniqueCombinations(4, \\"abcd\\") ['a', 'ab', 'abc', 'abcd', 'abd', 'ac', 'acd', 'ad', 'b', 'bc', 'bcd', 'bd', 'c', 'cd', 'd'] pass # your code here # Unit tests def test_example1(): n = 3 s = \\"aab\\" expected_output = ['a', 'aa', 'aab', 'ab', 'b'] assert uniqueCombinations(n, s) == expected_output def test_example2(): n = 4 s = \\"abcd\\" expected_output = ['a', 'ab', 'abc', 'abcd', 'abd', 'ac', 'acd', 'ad', 'b', 'bc', 'bcd', 'bd', 'c', 'cd', 'd'] assert uniqueCombinations(n, s) == expected_output def test_single_char(): n = 1 s = \\"x\\" expected_output = ['x'] assert uniqueCombinations(n, s) == expected_output def test_all_duplicate_chars(): n = 3 s = \\"ccc\\" expected_output = ['c', 'cc', 'ccc'] assert uniqueCombinations(n, s) == expected_output def test_no_duplicates(): n = 3 s = \\"xyz\\" expected_output = ['x', 'xy', 'xyz', 'xz', 'y', 'yz', 'z'] assert uniqueCombinations(n, s) == expected_output def test_empty_string(): n = 0 s = \\"\\" expected_output = [] assert uniqueCombinations(n, s) == expected_output","solution":"from itertools import combinations def uniqueCombinations(n, s): Returns all possible unique combinations of the characters in the given string. Parameters: n (int): The length of the input string. s (str): The input string. Returns: list: A sorted list of unique combinations. # Generate all combinations unique_combos = set() for i in range(1, n + 1): for combo in combinations(s, i): unique_combos.add(''.join(combo)) # Sort and return the list of unique combinations return sorted(unique_combos)"},{"question":"def traffic_light_states(timesteps: int) -> dict: Simulates the transitions of the traffic lights at a four-way intersection over a number of timesteps. Parameters: timesteps (int): Number of timesteps to simulate. Returns: dict: A dictionary representing the state of each direction's traffic light after the given number of timesteps. Example: >>> traffic_light_states(0) {\\"North\\": \\"Green\\", \\"East\\": \\"Red\\", \\"South\\": \\"Green\\", \\"West\\": \\"Red\\"} >>> traffic_light_states(5) {\\"North\\": \\"Yellow\\", \\"East\\": \\"Red\\", \\"South\\": \\"Yellow\\", \\"West\\": \\"Red\\"} >>> traffic_light_states(10) {\\"North\\": \\"Red\\", \\"East\\": \\"Green\\", \\"South\\": \\"Red\\", \\"West\\": \\"Green\\"} >>> traffic_light_states(15) {\\"North\\": \\"Red\\", \\"East\\": \\"Yellow\\", \\"South\\": \\"Red\\", \\"West\\": \\"Yellow\\"} >>> traffic_light_states(20) {\\"North\\": \\"Green\\", \\"East\\": \\"Red\\", \\"South\\": \\"Green\\", \\"West\\": \\"Red\\"}","solution":"def traffic_light_states(timesteps): Returns the state of each traffic light direction after the given number of timesteps. # Time cycle point in the sequence cycle_point = timesteps % 20 if cycle_point < 5: return {\\"North\\": \\"Green\\", \\"East\\": \\"Red\\", \\"South\\": \\"Green\\", \\"West\\": \\"Red\\"} elif cycle_point < 10: return {\\"North\\": \\"Yellow\\", \\"East\\": \\"Red\\", \\"South\\": \\"Yellow\\", \\"West\\": \\"Red\\"} elif cycle_point < 15: return {\\"North\\": \\"Red\\", \\"East\\": \\"Green\\", \\"South\\": \\"Red\\", \\"West\\": \\"Green\\"} else: return {\\"North\\": \\"Red\\", \\"East\\": \\"Yellow\\", \\"South\\": \\"Red\\", \\"West\\": \\"Yellow\\"}"},{"question":"from typing import List def get_top_scorer(student_records: List[str]) -> List[str]: You are given a list of strings, where each string represents a student record in the format 'Name:Score'. Implement a function that processes the list and returns the name of the student with the highest score. If there is a tie, return all names with the highest score, sorted alphabetically. >>> get_top_scorer([\\"Alice:88\\"]) == [\\"Alice\\"] >>> get_top_scorer([\\"Alice:88\\", \\"Bob:70\\", \\"Charlie:65\\", \\"David:90\\"]) == [\\"David\\"] >>> get_top_scorer([\\"Alice:88\\", \\"Bob:95\\", \\"Charlie:95\\", \\"David:90\\"]) == [\\"Bob\\", \\"Charlie\\"] >>> get_top_scorer([\\"Alice:77\\", \\"Bob:77\\", \\"Charlie:77\\", \\"David:77\\"]) == [\\"Alice\\", \\"Bob\\", \\"Charlie\\", \\"David\\"] >>> get_top_scorer([\\"Alice:88\\", \\"Bob:99\\", \\"Charlie:95\\", \\"David:99\\", \\"Eve:80\\"]) == [\\"Bob\\", \\"David\\"] >>> get_top_scorer([\\"Alice:0\\", \\"Bob:0\\"]) == [\\"Alice\\", \\"Bob\\"] >>> get_top_scorer([\\"Alice:100\\", \\"Bob:100\\"]) == [\\"Alice\\", \\"Bob\\"]","solution":"from typing import List def get_top_scorer(student_records: List[str]) -> List[str]: top_scorers = [] highest_score = -1 for record in student_records: name, score = record.split(':') score = int(score) if score > highest_score: top_scorers = [name] highest_score = score elif score == highest_score: top_scorers.append(name) return sorted(top_scorers)"},{"question":"def summarize_campaign(T: int, interactions: List[Tuple[str, str]]) -> List[str]: Process email interactions and output the summary of each interaction type for each email address. Args: T (int): Number of interactions interactions (List[Tuple[str, str]]): List of interactions where each interaction is a tuple of (email, interaction_type) Returns: List[str]: List of summaries for each unique email address in the order they first appeared >>> summarize_campaign(7, [(\\"user1@example.com\\", \\"click\\"), ... (\\"user2@example.com\\", \\"open\\"), ... (\\"user1@example.com\\", \\"open\\"), ... (\\"user2@example.com\\", \\"unsubscribe\\"), ... (\\"user3@example.com\\", \\"open\\"), ... (\\"user3@example.com\\", \\"click\\"), ... (\\"user1@example.com\\", \\"unsubscribe\\")]) [\\"user1@example.com: 1 1 1\\", \\"user2@example.com: 1 0 1\\", \\"user3@example.com: 1 1 0\\"] >>> summarize_campaign(1, [(\\"user1@example.com\\", \\"click\\")]) [\\"user1@example.com: 0 1 0\\"] >>> summarize_campaign(3, [(\\"user1@example.com\\", \\"click\\"), ... (\\"user2@example.com\\", \\"click\\"), ... (\\"user3@example.com\\", \\"click\\")]) [\\"user1@example.com: 0 1 0\\", \\"user2@example.com: 0 1 0\\", \\"user3@example.com: 0 1 0\\"] >>> summarize_campaign(0, []) [] >>> summarize_campaign(5, [(\\"user1@example.com\\", \\"open\\"), ... (\\"user1@example.com\\", \\"open\\"), ... (\\"user1@example.com\\", \\"click\\"), ... (\\"user1@example.com\\", \\"unsubscribe\\"), ... (\\"user1@example.com\\", \\"unsubscribe\\")]) [\\"user1@example.com: 2 1 2\\"]","solution":"def summarize_campaign(T, interactions): summary = {} order = [] for email, interaction in interactions: if email not in summary: summary[email] = {'open': 0, 'click': 0, 'unsubscribe': 0} order.append(email) summary[email][interaction] += 1 result = [] for email in order: result.append(f\\"{email}: {summary[email]['open']} {summary[email]['click']} {summary[email]['unsubscribe']}\\") return result"},{"question":"from typing import List def can_form_unique_palindrome(s: str) -> str: Determine if the input string can be rearranged to form exactly one unique palindrome. If possible, return \\"YES\\" followed by the palindrome. If not, return \\"NO\\". >>> can_form_unique_palindrome(\\"aabb\\") 'YESnabba' >>> can_form_unique_palindrome(\\"abcba\\") 'YESnabcba' >>> can_form_unique_palindrome(\\"abccba\\") 'YESnabccba' >>> can_form_unique_palindrome(\\"abcd\\") 'NO' >>> can_form_unique_palindrome(\\"aaabccc\\") 'NO' def process_test_cases(test_cases: List[str]) -> List[str]: Process multiple test cases to determine if each string can be rearranged to form exactly one unique palindrome. >>> test_cases = [\\"aabb\\", \\"abcba\\", \\"abccba\\", \\"abcd\\"] >>> process_test_cases(test_cases) ['YESnabba', 'YESnabcba', 'YESnabccba', 'NO'] def test_can_form_unique_palindrome(): assert can_form_unique_palindrome(\\"aabb\\") == \\"YESnabba\\" assert can_form_unique_palindrome(\\"abcba\\") == \\"YESnabcba\\" assert can_form_unique_palindrome(\\"abccba\\") == \\"YESnabccba\\" assert can_form_unique_palindrome(\\"abcd\\") == \\"NO\\" assert can_form_unique_palindrome(\\"aaabccc\\") == \\"NO\\" assert can_form_unique_palindrome(\\"a\\") == \\"YESna\\" assert can_form_unique_palindrome(\\"aa\\") == \\"YESnaa\\" assert can_form_unique_palindrome(\\"aaa\\") == \\"YESnaaa\\" def test_process_test_cases(): test_cases = [\\"aabb\\", \\"abcba\\", \\"abccba\\", \\"abcd\\"] results = process_test_cases(test_cases) assert results == [ \\"YESnabba\\", \\"YESnabcba\\", \\"YESnabccba\\", \\"NO\\" ]","solution":"def can_form_unique_palindrome(s): from collections import Counter char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) if odd_count > 1: return \\"NO\\" first_half = [] middle = [] for char, count in char_count.items(): if count % 2 == 0: first_half.append(char * (count // 2)) else: first_half.append(char * (count // 2)) middle.append(char) palindrome = ''.join(first_half) + ''.join(middle) + ''.join(first_half[::-1]) return f\\"YESn{palindrome}\\" def process_test_cases(test_cases): results = [] for s in test_cases: results.append(can_form_unique_palindrome(s)) return results"},{"question":"def elementWiseSum(L1, L2): Returns a new list containing the element-wise sum of the integers in L1 and L2. Args: L1: List[int] - The first list of integers. L2: List[int] - The second list of integers. Returns: List[int] - A new list containing the element-wise sum of L1 and L2. Examples: >>> elementWiseSum([1, 2, 3], [4, 5, 6]) [5, 7, 9] >>> elementWiseSum([10, 20, 30], [1, 2, 3]) [11, 22, 33]","solution":"def elementWiseSum(L1, L2): Returns a new list containing the element-wise sum of the integers in L1 and L2. return [a + b for a, b in zip(L1, L2)]"},{"question":"def findSubarrayWithTargetSum(nums, target): Find the first continuous subarray that sums up to a given target sum. If such a subarray doesn't exist, return an empty array. Parameters: nums (List[int]): A list of integers. target (int): The target sum. Returns: List[int]: A continuous subarray that sums up to the target sum. Examples: >>> findSubarrayWithTargetSum([1, 2, 3, 7, 5], 12) [2, 3, 7] >>> findSubarrayWithTargetSum([1, 2, 3, 4, 5], 9) [2, 3, 4] >>> findSubarrayWithTargetSum([1, 2, 3, 4, 5], 20) [] pass # Implementation goes here","solution":"def findSubarrayWithTargetSum(nums, target): Find the first continuous subarray that sums up to a given target sum. If such a subarray doesn't exist, return an empty array. curr_sum = 0 start = 0 sum_map = {} for i in range(len(nums)): curr_sum += nums[i] if curr_sum == target: return nums[start:i + 1] if (curr_sum - target) in sum_map: return nums[sum_map[curr_sum - target] + 1:i + 1] sum_map[curr_sum] = i return []"},{"question":"def count_pairs_with_difference(arr, k): Returns the number of pairs with an absolute difference of k. Args: arr: list of integers k: integer, the absolute difference Returns: int: the number of pairs with absolute difference k >>> count_pairs_with_difference([1, 5, 3, 4, 2], 2) 3 >>> count_pairs_with_difference([1, 2, 3, 4, 5], 1) 4 >>> count_pairs_with_difference([1, 2, 3, 4, 5], 10) 0 >>> count_pairs_with_difference([3, 3, 3, 3], 0) 6 >>> count_pairs_with_difference([1, 5, 3, 4, 2], 10) 0","solution":"def count_pairs_with_difference(arr, k): Returns the number of pairs with an absolute difference of k. Args: arr: list of integers k: integer, the absolute difference Returns: int: the number of pairs with absolute difference k count = 0 n = len(arr) for i in range(n): for j in range(i + 1, n): if abs(arr[i] - arr[j]) == k: count += 1 return count"},{"question":"def minimum_groups(N: int, G: int, M: int, sizes: List[int]) -> int: Returns the minimum number of groups needed to distribute all candies according to the given rules. Args: N: int : number of candies G: int : number of candies each group should have M: int : maximum allowed size difference within a group sizes: List[int] : list of candy sizes Returns: int : minimum number of groups needed >>> minimum_groups(7, 3, 2, [4, 1, 5, 3, 2, 8, 6]) 3 >>> minimum_groups(6, 3, 0, [1, 1, 1, 2, 2, 2]) 2 >>> minimum_groups(4, 2, 0, [1, 2, 3, 4]) 4 >>> minimum_groups(5, 2, 1000, [1, 1000, 2000, 3000, 4000]) 3 >>> minimum_groups(1, 1, 0, [1]) 1 >>> minimum_groups(5, 5, 5, [1, 3, 2, 4, 6]) 1 >>> minimum_groups(6, 5, 10, [1, 2, 3, 4, 5, 15]) 2","solution":"def minimum_groups(N, G, M, sizes): Returns the minimum number of groups needed to distribute all candies according to the given rules. # Sorting the candy sizes to facilitate grouping sizes.sort() groups = 0 i = 0 # Traverse through the list of sorted candy sizes while i < N: j = i # Find the end index for the group starting at index i while j < N and (sizes[j] - sizes[i] <= M) and (j - i < G): j += 1 # Increment the number of groups needed groups += 1 # Move to the next group starting point i = j return groups"},{"question":"from typing import List, Tuple def parse_orders(input_data: str) -> List[List[Tuple[str, int, float]]]: Parses the input data and returns a list where each element is a list of tuples representing an order. >>> input_data = \\"2n3nburger 2 5.00nfries 1 2.50ncola 1 1.25n2npizza 1 10.00nwater 2 1.00\\" >>> parse_orders(input_data) [[('burger', 2, 5.00), ('fries', 1, 2.50), ('cola', 1, 1.25)], [('pizza', 1, 10.00), ('water', 2, 1.00)]] pass def compute_order_cost(order: List[Tuple[str, int, float]]) -> float: Takes an order and returns the total cost of the order. >>> order = [(\\"burger\\", 2, 5.00), (\\"fries\\", 1, 2.50), (\\"cola\\", 1, 1.25)] >>> compute_order_cost(order) 13.75 >>> order = [(\\"pizza\\", 1, 10.00), (\\"water\\", 2, 1.00)] >>> compute_order_cost(order) 12.00 pass def compute_total_cost(orders: List[List[Tuple[str, int, float]]]) -> float: Takes a list of orders and returns the total cost of all orders. >>> orders = [[(\\"burger\\", 2, 5.00), (\\"fries\\", 1, 2.50), (\\"cola\\", 1, 1.25)], [(\\"pizza\\", 1, 10.00), (\\"water\\", 2, 1.00)]] >>> compute_total_cost(orders) 25.75 >>> orders = [[(\\"pasta\\", 3, 7.50), (\\"salad\\", 1, 5.00)]] >>> compute_total_cost(orders) 27.50 pass","solution":"from typing import List, Tuple def parse_orders(input_data: str) -> List[List[Tuple[str, int, float]]]: Parses the input data and returns a list where each element is a list of tuples representing an order. lines = input_data.strip().split('n') n = int(lines[0]) index = 1 orders = [] for _ in range(n): m = int(lines[index]) index += 1 order = [] for _ in range(m): item_data = lines[index].split() item_name = item_data[0] item_quantity = int(item_data[1]) item_price = float(item_data[2]) order.append((item_name, item_quantity, item_price)) index += 1 orders.append(order) return orders def compute_order_cost(order: List[Tuple[str, int, float]]) -> float: Takes an order and returns the total cost of the order. total_cost = sum(quantity * price_per_unit for _, quantity, price_per_unit in order) return total_cost def compute_total_cost(orders: List[List[Tuple[str, int, float]]]) -> float: Takes a list of orders and returns the total cost of all orders. total_cost = sum(compute_order_cost(order) for order in orders) return round(total_cost, 2) # Example usage: # input_data = \\"2n3nburger 2 5.00nfries 1 2.50ncola 1 1.25n2npizza 1 10.00nwater 2 1.00\\" # orders = parse_orders(input_data) # total_cost = compute_total_cost(orders) # print(total_cost)"},{"question":"def subarray_sums(n: int, q: int, array: List[int], queries: List[Tuple[int, int]]) -> List[int]: Calculate the sum of elements in a subarray for multiple queries. Args: n (int): Number of elements in the array. q (int): Number of queries. array (List[int]): The array of integers. queries (List[Tuple[int, int]]): List of queries with (start, end) indices as tuples. Returns: List[int]: Sum of elements for each query. >>> subarray_sums(5, 3, [1, 2, 3, 4, 5], [(1, 3), (2, 4), (1, 5)]) [6, 9, 15] >>> subarray_sums(4, 2, [-1, 2, -3, 4], [(1, 2), (2, 4)]) [1, 3] # Implement the function here","solution":"def subarray_sums(n, q, array, queries): prefix_sums = [0] * (n + 1) for i in range(1, n + 1): prefix_sums[i] = prefix_sums[i - 1] + array[i - 1] results = [] for l, r in queries: results.append(prefix_sums[r] - prefix_sums[l - 1]) return results"},{"question":"def paint_enclosure(m, n, operations): Returns an m x n grid showing the final colors of each cell after all painting operations. Parameters: m (int): Number of rows in the grid. n (int): Number of columns in the grid. operations (list of tuples): Each tuple contains (r1, c1, r2, c2, color) where (r1, c1) is the top-left and (r2, c2) is the bottom-right of the section to paint and color is the color to paint that section. Returns: list of lists: m x n grid where each cell contains the final color. from solution import paint_enclosure def test_paint_single_operation(): result = paint_enclosure(2, 2, [(0, 0, 1, 1, 'blue')]) expected = [['blue', 'blue'], ['blue', 'blue']] assert result == expected def test_paint_multiple_operations(): result = paint_enclosure(4, 4, [(0, 0, 1, 1, 'red'), (1, 1, 2, 2, 'blue'), (0, 2, 3, 3, 'green')]) expected = [['red', 'red', 'green', 'green'], ['red', 'blue', 'green', 'green'], ['white', 'blue', 'green', 'green'], ['white', 'white', 'green', 'green']] assert result == expected def test_paint_overlapping_operations(): result = paint_enclosure(3, 3, [(0, 0, 2, 2, 'red'), (1, 1, 2, 2, 'blue')]) expected = [['red', 'red', 'red'], ['red', 'blue', 'blue'], ['red', 'blue', 'blue']] assert result == expected def test_paint_non_overlapping_operations(): result = paint_enclosure(3, 3, [(0, 0, 1, 1, 'red'), (1, 1, 2, 2, 'blue')]) expected = [['red', 'red', 'white'], ['red', 'blue', 'blue'], ['white', 'blue', 'blue']] assert result == expected def test_empty_operations(): result = paint_enclosure(2, 2, []) expected = [['white', 'white'], ['white', 'white']] assert result == expected","solution":"def paint_enclosure(m, n, operations): Returns an m x n grid showing the final colors of each cell after all painting operations. Parameters: m (int): Number of rows in the grid. n (int): Number of columns in the grid. operations (list of tuples): Each tuple contains (r1, c1, r2, c2, color) where (r1, c1) is the top-left and (r2, c2) is the bottom-right of the section to paint and color is the color to paint that section. Returns: list of lists: m x n grid where each cell contains the final color. # Initialize the grid with 'white' grid = [['white' for _ in range(n)] for _ in range(m)] # Apply each painting operation in order for r1, c1, r2, c2, color in operations: for row in range(r1, r2 + 1): for col in range(c1, c2 + 1): grid[row][col] = color return grid"},{"question":"def can_arrange_performers(N, skill_levels): Determine if it is possible to arrange the performers such that no two performers with the same skill level march next to each other. >>> can_arrange_performers(5, [1, 2, 3, 2, 1]) \\"YES\\" >>> can_arrange_performers(4, [1, 1, 1, 1]) \\"NO\\" def process_test_cases(T, test_cases): Process multiple test cases to determine if the parade arrangement is possible for each case. >>> process_test_cases(3, [(5, [1, 2, 3, 2, 1]), (4, [1, 1, 1, 1]), (6, [1, 2, 3, 4, 5, 6])]) [\\"YES\\", \\"NO\\", \\"YES\\"] # Define test cases for the completion task from completion import process_test_cases, can_arrange_performers def test_single_test_case_possible(): assert can_arrange_performers(5, [1, 2, 3, 2, 1]) == \\"YES\\" def test_single_test_case_impossible(): assert can_arrange_performers(4, [1, 1, 1, 1]) == \\"NO\\" def test_single_test_case_trivial_possible(): assert can_arrange_performers(6, [1, 2, 3, 4, 5, 6]) == \\"YES\\" def test_multiple_test_cases(): test_cases = [ (5, [1, 2, 3, 2, 1]), (4, [1, 1, 1, 1]), (6, [1, 2, 3, 4, 5, 6]) ] expected = [\\"YES\\", \\"NO\\", \\"YES\\"] assert process_test_cases(3, test_cases) == expected def test_edge_case_one_performer(): assert can_arrange_performers(1, [1]) == \\"YES\\" def test_edge_case_two_different_performers(): assert can_arrange_performers(2, [1, 2]) == \\"YES\\" def test_edge_case_two_same_performers(): assert can_arrange_performers(2, [1, 1]) == \\"NO\\" def test_large_input(): N = 100000 skill_levels = [1] * (N // 2) + [2] * (N // 2) assert can_arrange_performers(N, skill_levels) == \\"YES\\"","solution":"from collections import Counter import heapq def can_arrange_performers(N, skill_levels): if N == 1: return \\"YES\\" # Count frequency of each skill level freq = Counter(skill_levels) # Place all counts in a max heap as negative values to simulate max-heap using min-heap max_heap = [-count for count in freq.values()] heapq.heapify(max_heap) # Get the maximum frequency max_freq = -max_heap[0] # Check if the maximum frequency is more than half the length of performers (rounded up) if max_freq > (N + 1) // 2: return \\"NO\\" return \\"YES\\" def process_test_cases(T, test_cases): results = [] for N, skill_levels in test_cases: results.append(can_arrange_performers(N, skill_levels)) return results def main(): import sys input = sys.stdin.read data = input().split() T = int(data[0]) idx = 1 test_cases = [] for _ in range(T): N = int(data[idx]) skill_levels = list(map(int, data[idx+1:idx+1+N])) test_cases.append((N, skill_levels)) idx += (N + 1) results = process_test_cases(T, test_cases) for result in results: print(result)"},{"question":"def sort_teams(input_data): Parses the input data, sorts the teams based on their points in descending order, and returns a list of sorted team names. :param input_data: List of strings in the format \\"teamname points\\" :return: List of sorted team names in descending order of points pass from solution import sort_teams def test_sort_teams_example(): input_data = [ \\"Alpha 370\\", \\"Bravo 415\\", \\"Charlie 520\\", \\"Delta 415\\", \\"Echo 520\\" ] expected_output = [\\"Charlie\\", \\"Echo\\", \\"Bravo\\", \\"Delta\\", \\"Alpha\\"] assert sort_teams(input_data) == expected_output def test_sort_teams_all_equal(): input_data = [ \\"Alpha 500\\", \\"Bravo 500\\", \\"Charlie 500\\", \\"Delta 500\\", \\"Echo 500\\" ] expected_output = [\\"Alpha\\", \\"Bravo\\", \\"Charlie\\", \\"Delta\\", \\"Echo\\"] assert sort_teams(input_data) == expected_output def test_sort_teams_no_ties(): input_data = [ \\"Alpha 100\\", \\"Bravo 200\\", \\"Charlie 300\\", \\"Delta 400\\", \\"Echo 500\\" ] expected_output = [\\"Echo\\", \\"Delta\\", \\"Charlie\\", \\"Bravo\\", \\"Alpha\\"] assert sort_teams(input_data) == expected_output def test_sort_teams_with_ties(): input_data = [ \\"Alpha 300\\", \\"Bravo 200\\", \\"Charlie 300\\", \\"Delta 100\\", \\"Echo 200\\" ] expected_output = [\\"Alpha\\", \\"Charlie\\", \\"Bravo\\", \\"Echo\\", \\"Delta\\"] assert sort_teams(input_data) == expected_output def test_sort_teams_with_zero_points(): input_data = [ \\"Alpha 0\\", \\"Bravo 300\\", \\"Charlie 200\\", \\"Delta 0\\", \\"Echo 100\\" ] expected_output = [\\"Bravo\\", \\"Charlie\\", \\"Echo\\", \\"Alpha\\", \\"Delta\\"] assert sort_teams(input_data) == expected_output","solution":"def sort_teams(input_data): Parses the input data, sorts the teams based on their points in descending order, and returns a list of sorted team names. :param input_data: List of strings in the format \\"teamname points\\" :return: List of sorted team names in descending order of points teams = [] # Parse input data for data in input_data: name, points = data.split() teams.append((name, int(points))) # Sort teams by points in descending order. Stable sort is used to maintain input order in case of ties. sorted_teams = sorted(teams, key=lambda x: x[1], reverse=True) # Extract team names from sorted teams sorted_team_names = [team[0] for team in sorted_teams] return sorted_team_names"},{"question":"def most_popular_product(T: int, test_cases: List[Tuple[int, List[str]]]) -> List[str]: Determine the most popular product among customers for each test case. Args: T (int): The number of test cases. test_cases (List[Tuple[int, List[str]]]): A list of tuples, each containing the number of customers and a list of favorite products. Returns: List[str]: A list of the most popular products for each test case. >>> most_popular_product(2, [(7, [\\"cake\\", \\"muffin\\", \\"cake\\", \\"pie\\", \\"cake\\", \\"muffin\\", \\"pie\\"]), (3, [\\"bread\\", \\"bread\\", \\"pie\\"])]) [\\"cake\\", \\"bread\\"] >>> most_popular_product(1, [(4, [\\"donut\\", \\"donut\\", \\"donut\\", \\"donut\\"])]) [\\"donut\\"] >>> most_popular_product(1, [(5, [\\"apple\\", \\"banana\\", \\"apple\\", \\"cherry\\", \\"banana\\"])]) [\\"apple\\"] >>> most_popular_product(1, [(6, [\\"pie\\", \\"pie\\", \\"cake\\", \\"cake\\", \\"pie\\", \\"pie\\"])]) [\\"pie\\"] >>> most_popular_product(1, [(3, [\\"abcd\\", \\"bcda\\", \\"dabc\\"])]) [\\"abcd\\"]","solution":"def most_popular_product(T, test_cases): from collections import Counter results = [] for test_case in test_cases: N, products = test_case product_count = Counter(products) most_popular = sorted(product_count.items(), key=lambda x: (-x[1], x[0]))[0][0] results.append(most_popular) return results # Input processing for the function will not be written here as it is not needed for the solution and unit tests."},{"question":"def partition_farm(N: int, M: int, K: int, crops: List[List[int]]) -> List[List[int]]: Partition the farm into K contiguous subgrids such that the difference between the subgrid with the maximum total crops and the subgrid with the minimum total crops is minimized. :param N: int, number of rows in the grid :param M: int, number of columns in the grid :param K: int, number of subgrids :param crops: List[List[int]], amount of crops in each grid cell :return: List[List[int]], partitioned grid with subgrid numbers >>> partition_farm(4, 4, 1, [[1, 3, 2, 6], [5, 9, 8, 4], [4, 7, 1, 2], [3, 5, 6, 9]]) [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]] >>> partition_farm(4, 4, 2, [[1, 3, 2, 6], [5, 9, 8, 4], [4, 7, 1, 2], [3, 5, 6, 9]]) [[1, 1, 1, 1], [1, 1, 1, 1], [2, 2, 2, 2], [2, 2, 2, 2]] >>> partition_farm(6, 6, 3, [[1, 3, 2, 6, 1, 1], [5, 9, 8, 4, 5, 5], [4, 7, 1, 2, 4, 4], [3, 5, 6, 9, 3, 3], [2, 3, 4, 1, 2, 2], [1, 1, 1, 1, 1, 1]]) [[1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2], [3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3]] # Example unit tests def test_partition_farm_single_subgrid(): N, M, K = 4, 4, 1 crops = [ [1, 3, 2, 6], [5, 9, 8, 4], [4, 7, 1, 2], [3, 5, 6, 9] ] expected_output = [ [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1] ] assert partition_farm(N, M, K, crops) == expected_output def test_partition_farm_two_subgrids(): N, M, K = 4, 4, 2 crops = [ [1, 3, 2, 6], [5, 9, 8, 4], [4, 7, 1, 2], [3, 5, 6, 9] ] expected_output = [ [1, 1, 1, 1], [1, 1, 1, 1], [2, 2, 2, 2], [2, 2, 2, 2] ] assert partition_farm(N, M, K, crops) == expected_output def test_partition_farm_three_subgrids(): N, M, K = 6, 6, 3 crops = [ [1, 3, 2, 6, 1, 1], [5, 9, 8, 4, 5, 5], [4, 7, 1, 2, 4, 4], [3, 5, 6, 9, 3, 3], [2, 3, 4, 1, 2, 2], [1, 1, 1, 1, 1, 1] ] expected_output = [ [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2], [3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3] ] assert partition_farm(N, M, K, crops) == expected_output","solution":"def partition_farm(N, M, K, crops): Partition the farm into K contiguous subgrids such that the difference between the subgrid with the maximum total crops and the subgrid with the minimum total crops is minimized. :param N: int, number of rows in the grid :param M: int, number of columns in the grid :param K: int, number of subgrids :param crops: List[List[int]], amount of crops in each grid cell :return: List[List[int]], partitioned grid with subgrid numbers # Initialize the partition grid with 1s initially partition_grid = [[1] * M for _ in range(N)] if K == 1: return partition_grid # Start with simple row-wise partition (this can be changed to a more optimal approach) rows_per_subgrid = N // K extra_rows = N % K subgrid_number = 1 for row in range(N): if (subgrid_number <= extra_rows and (row - subgrid_number * (rows_per_subgrid + 1)) >= 0) or (subgrid_number > extra_rows and (row - extra_rows * (rows_per_subgrid + 1) - ((subgrid_number - extra_rows) * rows_per_subgrid)) >= 0): subgrid_number += 1 for col in range(M): partition_grid[row][col] = subgrid_number return partition_grid"},{"question":"def count_right_angle_isosceles_triangles(points: List[Tuple[int, int]]) -> int: Returns the number of distinct right-angled isosceles triangles with the right angle at the origin (0, 0). Args: points (list): List of tuple containing the x and y coordinates of the points Returns: int: The count of distinct triangles >>> count_right_angle_isosceles_triangles([(2, 0), (0, 2), (2, 2), (3, 0), (0, 3)]) 2 >>> count_right_angle_isosceles_triangles([(1, 1), (2, 0), (0, 2)]) 1 >>> count_right_angle_isosceles_triangles([(1, 1), (2, 2), (3, 3), (0, 0)]) 1 >>> count_right_angle_isosceles_triangles([(1, 2), (2, 1), (3, 3)]) 0 >>> count_right_angle_isosceles_triangles([(0, 1)]) 0 >>> count_right_angle_isosceles_triangles([(0, 1), (0, 2), (0, 3), (1, 0), (2, 0)]) 2","solution":"def count_right_angle_isosceles_triangles(points): Returns the number of distinct right-angled isosceles triangles with the right angle at the origin (0, 0). Args: points (list): List of tuple containing the x and y coordinates of the points Returns: int: The count of distinct triangles x_coords = set() y_coords = set() for x, y in points: if x == 0: y_coords.add(y) if y == 0: x_coords.add(x) return min(len(x_coords), len(y_coords))"},{"question":"def trapWater(height: List[int]) -> int: Calculate the amount of water that can be trapped. :param height: List of integers representing the heights of buildings :return: Integer representing the total water trapped >>> trapWater([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trapWater([4, 2, 0, 3, 2, 5]) 9 >>> trapWater([]) 0 >>> trapWater([5]) 0 >>> trapWater([4, 5]) 0 >>> trapWater([5, 4, 3, 2, 1]) 0 >>> trapWater([1, 2, 3, 4, 5]) 0 >>> trapWater([5, 1, 5]) 4","solution":"def trapWater(height): Calculate the amount of water that can be trapped. :param height: List of integers representing the heights of buildings :return: Integer representing the total water trapped if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - height[i] return trapped_water"},{"question":"def min_paint_capacity(n: int, heights: List[int], antennas: List[int]) -> int: Calculate the minimum capacity of paint required to paint all the buildings with antennas. Arguments: n -- Number of buildings heights -- List of building heights antennas -- List of indices (1-based) of buildings with antennas Returns: Minimum capacity of paint required. Example: >>> min_paint_capacity(5, [2, 5, 4, 3, 1], [2, 4]) 8 >>> min_paint_capacity(6, [3, 1, 4, 1, 5, 9], [1, 6]) 12 pass def test_case_1(): n = 5 heights = [2, 5, 4, 3, 1] antennas = [2, 4] assert min_paint_capacity(n, heights, antennas) == 8 def test_case_2(): n = 6 heights = [3, 1, 4, 1, 5, 9] antennas = [1, 6] assert min_paint_capacity(n, heights, antennas) == 12 def test_case_3(): n = 4 heights = [1, 2, 3, 4] antennas = [1, 2, 3, 4] assert min_paint_capacity(n, heights, antennas) == 10 def test_case_4(): n = 3 heights = [5, 5, 5] antennas = [1, 3] assert min_paint_capacity(n, heights, antennas) == 10 def test_case_5(): n = 1 heights = [4] antennas = [1] assert min_paint_capacity(n, heights, antennas) == 4 def test_case_6(): n = 3 heights = [1, 2, 2] antennas = [1, 3] assert min_paint_capacity(n, heights, antennas) == 3","solution":"def can_paint_in_line_of_sight(heights, start, end): Helper function to check if all buildings between \`start\` and \`end\` are in line of sight, i.e., no building taller than heights[start] or heights[end] in between. Arguments: heights -- List of building heights start -- Starting building index (0-based) end -- Ending building index (0-based) Returns: True if all the buildings between start and end are in line of sight, False otherwise. max_height = max(heights[start], heights[end]) for i in range(start + 1, end): if heights[i] > max_height: return False return True def min_paint_capacity(n, heights, antennas): Calculate the minimum capacity of paint required to paint all the buildings with antennas. Arguments: n -- Number of buildings heights -- List of building heights antennas -- List of indices (1-based) of buildings with antennas Returns: Minimum capacity of paint required. total_paint = 0 # Convert 1-based indices to 0-based indices antennas = [idx - 1 for idx in antennas] size = len(antennas) for i in range(size): current_building = antennas[i] total_paint += heights[current_building] return total_paint"},{"question":"import math from typing import Tuple def perfect_squares(L: int, R: int) -> Tuple[int, int]: Returns the number of perfect squares in the interval [L, R], and the largest perfect square within this interval, or -1 if no perfect square exists. >>> perfect_squares(1, 100) (10, 100) >>> perfect_squares(50, 75) (1, 64) >>> perfect_squares(50, 63) (0, -1) >>> perfect_squares(64, 64) (1, 64) >>> perfect_squares(1, 999999999999999999) (999999999, 999999999000000000)","solution":"import math def perfect_squares(L, R): Returns the number of perfect squares in the interval [L, R], and the largest perfect square within this interval, or -1 if no perfect square exists. # Count the number of perfect squares in the interval [L, R] start = math.ceil(math.sqrt(L)) end = math.floor(math.sqrt(R)) count = max(0, end - start + 1) # Find the largest perfect square within this interval largest_perfect_square = end ** 2 if count > 0 else -1 return count, largest_perfect_square"},{"question":"def rotateMatrix(matrix): Rotates the given n x n 2D matrix by 90 degrees clockwise in-place. Args: matrix (list of list of int): The matrix to rotate. Returns: None: The matrix is rotated in-place. pass # Unit tests def test_rotate_3x3_matrix(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] expected = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] rotateMatrix(matrix) assert matrix == expected def test_rotate_4x4_matrix(): matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] expected = [ [13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4] ] rotateMatrix(matrix) assert matrix == expected def test_rotate_2x2_matrix(): matrix = [ [1, 2], [3, 4] ] expected = [ [3, 1], [4, 2] ] rotateMatrix(matrix) assert matrix == expected def test_rotate_1x1_matrix(): matrix = [ [1] ] expected = [ [1] ] rotateMatrix(matrix) assert matrix == expected def test_rotate_with_negative_numbers(): matrix = [ [0, -1], [-2, -3] ] expected = [ [-2, 0], [-3, -1] ] rotateMatrix(matrix) assert matrix == expected","solution":"def rotateMatrix(matrix): Rotates the given n x n 2D matrix by 90 degrees clockwise in-place. Args: matrix (list of list of int): The matrix to rotate. Returns: None: The matrix is rotated in-place. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"def maximize_profit(T, cake_cases): Determine the optimal quantity of each type of cake to bake to maximize profit. Each test case contains: - The number of cake types - The maximum quantities for each cake type - The profit per unit for each cake type - The number of customers - Each customer’s favorite cake type and maximum units to buy Input: - T: int, number of test cases - cake_cases: list of dictionaries containing: - C: int, number of cake types - Q: list of int, maximum quantities for each cake type - P: list of int, profit per unit for each cake type - N: int, number of customers - customers: list of tuples (F_j, D_j) for each customer Returns: - list of lists, each containing the number of units of each type of cake to bake to maximize profit Example: >>> maximize_profit(1, [{'C': 2, 'Q': [100, 50], 'P': [10, 20], 'N': 3, 'customers': [(1, 30), (2, 10), (1, 20)]}]) [[50, 10]] >>> maximize_profit(1, [{'C': 1, 'Q': [50], 'P': [20], 'N': 5, 'customers': [(1, 10), (1, 20), (1, 10), (1, 15), (1, 5)]}]) [[50]] def parse_input(data): Helper function to parse input data into the needed format. Input: - data: str, the string representation of the input data Returns: - T: int, number of test cases - cake_cases: list of dictionaries representing the cake data for each test case Example: >>> parse_input('''1 2 100 50 10 20 3 1 30 2 10 1 20''') (1, [{'C': 2, 'Q': [100, 50], 'P': [10, 20], 'N': 3, 'customers': [(1, 30), (2, 10), (1, 20)]}]) # Example test cases def test_example_case(): data = 1 2 100 50 10 20 3 1 30 2 10 1 20 expected_output = [[50, 10]] T, cake_cases = parse_input(data) solution = maximize_profit(T, cake_cases) assert solution == expected_output def test_case_all_demand_met(): data = 1 3 80 50 70 15 25 20 4 1 20 2 10 3 30 2 30 expected_output = [[20, 40, 30]] T, cake_cases = parse_input(data) solution = maximize_profit(T, cake_cases) assert solution == expected_output def test_case_some_demand_exceeds(): data = 1 2 30 40 25 30 3 1 25 2 35 1 10 expected_output = [[30, 35]] T, cake_cases = parse_input(data) solution = maximize_profit(T, cake_cases) assert solution == expected_output def test_case_multiple_customers_one_cake(): data = 1 1 50 20 5 1 10 1 20 1 10 1 15 1 5 expected_output = [[50]] T, cake_cases = parse_input(data) solution = maximize_profit(T, cake_cases) assert solution == expected_output def test_case_no_customers(): data = 1 2 50 100 20 15 0 expected_output = [[0, 0]] T, cake_cases = parse_input(data) solution = maximize_profit(T, cake_cases) assert solution == expected_output","solution":"def maximize_profit(T, cake_cases): results = [] for case in cake_cases: C = case['C'] quantities = case['Q'] profits = case['P'] N = case['N'] customers = case['customers'] # Sort the cakes based on profit per unit cakes = sorted([(profits[i], quantities[i], i) for i in range(C)], reverse=True) # Initialize the number of cakes to bake bake = [0] * C # Demand tracking demand = [0] * C for fj, dj in customers: fj -= 1 demand[fj] += dj for profit, quantity, i in cakes: if demand[i] <= quantity: bake[i] = demand[i] else: bake[i] = quantity results.append(bake) return results # Helper function to parse input data into the needed format def parse_input(data): lines = data.split('n') T = int(lines[0].strip()) index = 1 cake_cases = [] for _ in range(T): C = int(lines[index].strip()) index += 1 Q = list(map(int, lines[index].strip().split())) index += 1 P = list(map(int, lines[index].strip().split())) index += 1 N = int(lines[index].strip()) index += 1 customers = [] for _ in range(N): F_j, D_j = map(int, lines[index].strip().split()) customers.append((F_j, D_j)) index += 1 cake_cases.append({ 'C': C, 'Q': Q, 'P': P, 'N': N, 'customers': customers }) return T, cake_cases # Given example input data = 1 2 100 50 10 20 3 1 30 2 10 1 20 T, cake_cases = parse_input(data) solution = maximize_profit(T, cake_cases) for result in solution: print(\\" \\".join(map(str, result)))"},{"question":"def largest_contiguous_area(grid: List[List[str]]) -> int: Given a grid of tiles represented by their colors in uppercase English letters, find the area of the largest rectangular subgrid where all tiles have the same color. >>> largest_contiguous_area([\\"AAA\\", \\"AAA\\", \\"AAA\\"]) 9 >>> largest_contiguous_area([\\"ABAA\\", \\"ABBB\\", \\"ABBB\\", \\"AAAA\\", \\"BBBB\\"]) 6 >>> largest_contiguous_area([\\"A\\"]) 1 >>> largest_contiguous_area([\\"A\\", \\"A\\", \\"A\\"]) 3 >>> largest_contiguous_area([\\"AAA\\"]) 3 >>> largest_contiguous_area([\\"ABC\\", \\"DEF\\", \\"GHI\\"]) 1 def check_uniform(grid: List[List[str]], row_start: int, col_start: int, row_end: int, col_end: int, color: str) -> bool: Check if a subgrid from (row_start, col_start) to (row_end, col_end) is uniform, meaning all tiles have the same color. def parse_input(input_string: str) -> List[List[List[str]]]: Parse the input string into a list of grids. >>> parse_input(\\"3 3nAAAnAAAnAAAn0 0n\\") [[\\"AAA\\", \\"AAA\\", \\"AAA\\"]] def solve(input_string: str) -> List[int]: Solve the problem using the input string and return a list of results for each dataset. >>> solve(\\"3 3nAAAnAAAnAAAn5 4nABAAnABBBnABBBnAAAAnBBBBn0 0n\\") [9, 6]","solution":"def largest_contiguous_area(grid): R = len(grid) C = len(grid[0]) if R > 0 else 0 max_area = 0 for row_start in range(R): for col_start in range(C): color = grid[row_start][col_start] for row_end in range(row_start, R): for col_end in range(col_start, C): if check_uniform(grid, row_start, col_start, row_end, col_end, color): area = (row_end - row_start + 1) * (col_end - col_start + 1) max_area = max(max_area, area) return max_area def check_uniform(grid, row_start, col_start, row_end, col_end, color): for i in range(row_start, row_end + 1): for j in range(col_start, col_end + 1): if grid[i][j] != color: return False return True def parse_input(input_string): datasets = [] lines = input_string.strip().split('n') i = 0 while i < len(lines): R, C = map(int, lines[i].split()) if R == 0 and C == 0: break grid = [lines[i + 1 + j] for j in range(R)] datasets.append(grid) i += R + 1 return datasets def solve(input_string): datasets = parse_input(input_string) results = [] for grid in datasets: results.append(largest_contiguous_area(grid)) return results if __name__ == \\"__main__\\": import sys input_string = sys.stdin.read() results = solve(input_string) for result in results: print(result)"},{"question":"def max_meetings(n: int, meetings: List[Tuple[int, int]]) -> int: Calculate the maximum number of non-overlapping meetings. Args: n (int): The number of meetings. meetings (list of tuples): List of (start, end) times for each meeting. Returns: int: The maximum number of non-overlapping meetings. >>> max_meetings(5, [(1, 4), (2, 5), (9, 12), (5, 9), (5, 5)]) 4 >>> max_meetings(3, [(1, 3), (3, 4), (2, 6)]) 2 pass def test_example_1(): assert max_meetings(5, [(1, 4), (2, 5), (9, 12), (5, 9), (5, 5)]) == 4 def test_example_2(): assert max_meetings(3, [(1, 3), (3, 4), (2, 6)]) == 2 def test_single_meeting(): assert max_meetings(1, [(1, 2)]) == 1 def test_no_meetings(): assert max_meetings(0, []) == 0 def test_all_meetings_overlapping(): assert max_meetings(3, [(1, 5), (2, 6), (3, 7)]) == 1 def test_non_overlapping_meetings(): assert max_meetings(4, [(1, 2), (2, 3), (3, 4), (4, 5)]) == 4 def test_meetings_end_at_same_time(): assert max_meetings(4, [(1, 4), (2, 4), (3, 4), (4, 4)]) == 2 # including meeting exactly at the end of another def test_large_input(): meetings = [(i, i+1) for i in range(100000)] assert max_meetings(100000, meetings) == 100000","solution":"def max_meetings(n, meetings): Calculate the maximum number of non-overlapping meetings. Args: n (int): The number of meetings. meetings (list of tuples): List of (start, end) times for each meeting. Returns: int: The maximum number of non-overlapping meetings. # Sort meetings based on the end time meetings.sort(key=lambda x: x[1]) # Initialize the count of non-overlapping meetings count = 0 last_end_time = 0 for start, end in meetings: if start >= last_end_time: # If the meeting starts after or exactly when the last meeting finished count += 1 last_end_time = end return count"},{"question":"from typing import List def max_contiguous_subarray_sum(arr: List[int]) -> int: Given an array of integers, return the maximum sum of any contiguous subarray of the given array. >>> max_contiguous_subarray_sum([1, -2, 3, 4, -1, 2, 1, -5, 4]) 9 >>> max_contiguous_subarray_sum([-2, -3, -1, -4]) -1 >>> max_contiguous_subarray_sum([5, 4, -1, 7, 8]) 23 >>> max_contiguous_subarray_sum([3]) 3 >>> max_contiguous_subarray_sum([-3]) -3 >>> max_contiguous_subarray_sum([1] * 10**5) 10**5 >>> max_contiguous_subarray_sum([-1] * 10**5) -1 >>> max_contiguous_subarray_sum([0, -3, 1, 2, -1, 0, 3, -2]) 5","solution":"from typing import List def max_contiguous_subarray_sum(arr: List[int]) -> int: max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"from typing import List, Tuple def min_total_time(datasets: List[List[Tuple[str, int, int]]]) -> List[int]: Compute the minimum total time required for completing all tasks in each dataset. Args: datasets: A list of datasets, where each dataset is a list of tuples with the task ID, priority, and duration. Returns: A list of integers representing the minimum total time required for completing all tasks for each dataset. def parse_input(data: str) -> List[List[Tuple[str, int, int]]]: Parse the input string to extract datasets of tasks. Args: data: A multi-line string where each line represents a task with its ID, priority, and duration. Returns: A list of datasets, where each dataset is a list of tuples with the task ID, priority, and duration. # Unit Test def test_min_total_time(): data = [ [(\\"T1\\", 2, 30), (\\"T2\\", 1, 20), (\\"T3\\", 3, 10)], [(\\"T1\\", 1, 40), (\\"T2\\", 2, 20)] ] assert min_total_time(data) == [60, 60] def test_single_task(): data = [ [(\\"T1\\", 1, 10)] ] assert min_total_time(data) == [10] def test_multiple_same_priority(): data = [ [(\\"T1\\", 1, 10), (\\"T2\\", 1, 20)] ] assert min_total_time(data) == [30] def test_priority_ordering(): data = [ [(\\"T1\\", 3, 30), (\\"T2\\", 1, 20), (\\"T3\\", 2, 10)] ] assert min_total_time(data) == [60] def test_parse_input(): input_data = 3 T1 2 30 T2 1 20 T3 3 10 2 T1 1 40 T2 2 20 0 expected_output = [ [(\\"T1\\", 2, 30), (\\"T2\\", 1, 20), (\\"T3\\", 3, 10)], [(\\"T1\\", 1, 40), (\\"T2\\", 2, 20)] ] assert parse_input(input_data) == expected_output","solution":"def min_total_time(datasets): results = [] for tasks in datasets: # Sort tasks by priority (first element of tuple) tasks_sorted = sorted(tasks, key=lambda x: x[1]) # Calculate total time total_time = sum(task[2] for task in tasks_sorted) results.append(total_time) return results def parse_input(data): datasets = [] current_dataset = [] for line in data.strip().split('n'): if line == '0': if current_dataset: datasets.append(current_dataset) break elif line.isdigit(): if current_dataset: datasets.append(current_dataset) current_dataset = [] else: task_id, priority, duration = line.split() current_dataset.append((task_id, int(priority), int(duration))) return datasets # Example input processing input_data = 3 T1 2 30 T2 1 20 T3 3 10 2 T1 1 40 T2 2 20 0 datasets = parse_input(input_data) output = min_total_time(datasets) for result in output: print(result)"},{"question":"def longest_uniform_subarray_length(N, array, queries): Function to find the length of the longest sub-array with all equal elements for each query with the given range in the list. :param N: integer, number of elements in array :param array: list of integers :param queries: list of tuples, each containing start and end index of the range (1-based) :return: list of integers, longest lengths for each query >>> longest_uniform_subarray_length(5, [1, 2, 2, 3, 3], [(1, 3), (2, 4), (3, 5)]) [2, 2, 2] >>> longest_uniform_subarray_length(5, [1, 2, 2, 3, 3], [(1, 1), (5, 5)]) [1, 1] >>> longest_uniform_subarray_length(5, [1, 1, 1, 1, 1], [(1, 5)]) [5] >>> longest_uniform_subarray_length(5, [1, 2, 3, 4, 5], [(1, 5), (2, 4)]) [1, 1] >>> longest_uniform_subarray_length(8, [4, 4, 4, 4, 1, 1, 1, 1], [(1, 8), (1, 4), (5, 8), (1, 5)]) [4, 4, 4, 4] >>> longest_uniform_subarray_length(1, [1], [(1, 1)]) [1] >>> longest_uniform_subarray_length(3, [2, 2, 2], [(1, 1), (1, 2), (1, 3), (2, 2), (2, 3), (3, 3)]) [1, 2, 3, 1, 2, 1]","solution":"def longest_uniform_subarray_length(N, array, queries): Function to find the length of the longest sub-array with all equal elements for each query with the given range in the list. :param N: integer, number of elements in array :param array: list of integers :param queries: list of tuples, each containing start and end index of the range (1-based) :return: list of integers, longest lengths for each query results = [] for L, R in queries: start = L - 1 end = R max_length = 1 current_length = 1 for i in range(start + 1, end): if array[i] == array[i - 1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 max_length = max(max_length, current_length) results.append(max_length) return results"},{"question":"from collections import deque from typing import List def shortest_path_in_grid(M: int, N: int, Sx: int, Sy: int, Dx: int, Dy: int, grid: List[str]) -> int: Computes the minimum number of steps required to move from the starting cell to the destination cell in a grid. Parameters: M (int): Number of rows in the grid. N (int): Number of columns in the grid. Sx (int): Row index of the starting cell (1-indexed). Sy (int): Column index of the starting cell (1-indexed). Dx (int): Row index of the destination cell (1-indexed). Dy (int): Column index of the destination cell (1-indexed). grid (List[str]): The grid itself, where '.' represents an empty cell and '#' represents a blocked cell. Returns: int: The minimum number of steps to reach the destination cell, or -1 if it is impossible. Examples: >>> shortest_path_in_grid(5, 5, 1, 1, 5, 5, [ \\".....\\", \\"..#..\\", \\"..#..\\", \\"..#..\\", \\".....\\" ]) 8 >>> shortest_path_in_grid(3, 3, 1, 1, 3, 3, [ \\".#.\\", \\".#.\\", \\".#.\\" ]) -1 pass # Unit tests def test_shortest_path_in_grid(): M = 5 N = 5 Sx = 1 Sy = 1 Dx = 5 Dy = 5 grid = [ \\".....\\", \\"..#..\\", \\"..#..\\", \\"..#..\\", \\".....\\" ] assert shortest_path_in_grid(M, N, Sx, Sy, Dx, Dy, grid) == 8 M = 3 N = 3 Sx = 1 Sy = 1 Dx = 3 Dy = 3 grid = [ \\".#.\\", \\".#.\\", \\".#.\\" ] assert shortest_path_in_grid(M, N, Sx, Sy, Dx, Dy, grid) == -1 M = 3 N = 3 Sx = 1 Sy = 1 Dx = 3 Dy = 3 grid = [ \\"...\\", \\"...\\", \\"...\\" ] assert shortest_path_in_grid(M, N, Sx, Sy, Dx, Dy, grid) == 4 M = 3 N = 3 Sx = 1 Sy = 1 Dx = 1 Dy = 1 grid = [ \\"...\\", \\"...\\", \\"...\\" ] assert shortest_path_in_grid(M, N, Sx, Sy, Dx, Dy, grid) == 0 M = 5 N = 5 Sx = 1 Sy = 1 Dx = 5 Dy = 5 grid = [ \\".....\\", \\".#.\\", \\".....\\", \\".#.\\", \\".....\\" ] assert shortest_path_in_grid(M, N, Sx, Sy, Dx, Dy, grid) == 8 def test_impossible_path(): M = 4 N = 4 Sx = 1 Sy = 1 Dx = 4 Dy = 4 grid = [ \\"#...\\", \\"\\", \\"....\\", \\"...#\\" ] assert shortest_path_in_grid(M, N, Sx, Sy, Dx, Dy, grid) == -1 if __name__ == \\"__main__\\": test_shortest_path_in_grid() test_impossible_path() print(\\"All tests passed!\\")","solution":"from collections import deque def shortest_path_in_grid(M, N, Sx, Sy, Dx, Dy, grid): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] Sx -= 1 Sy -= 1 Dx -= 1 Dy -= 1 queue = deque([(Sx, Sy, 0)]) visited = set() visited.add((Sx, Sy)) while queue: x, y, steps = queue.popleft() if x == Dx and y == Dy: return steps for direction in directions: nx, ny = x + direction[0], y + direction[1] if 0 <= nx < M and 0 <= ny < N and (nx, ny) not in visited and grid[nx][ny] == '.': visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return -1 # To execute the function based on input def read_input_and_compute(): import sys input = sys.stdin.read data = input().split() M = int(data[0]) N = int(data[1]) Sx = int(data[2]) Sy = int(data[3]) Dx = int(data[4]) Dy = int(data[5]) grid = data[6:] print(shortest_path_in_grid(M, N, Sx, Sy, Dx, Dy, grid)) if __name__ == \\"__main__\\": read_input_and_compute()"},{"question":"def can_make_wish(n: int, k: int, heights: List[int]) -> str: Function to check if there are two distinct trees with a height difference of exactly k. :param n: Number of trees in the forest :param k: The desired height difference :param heights: List of integers representing the heights of the trees :return: 'Yes' if such a pair exists, otherwise 'No' >>> can_make_wish(5, 3, [1, 5, 3, 8, 6]) 'Yes' >>> can_make_wish(4, 10, [1, 2, 3, 4]) 'No'","solution":"def can_make_wish(n, k, heights): Function to check if there are two distinct trees with a height difference of exactly k. :param n: Number of trees in the forest :param k: The desired height difference :param heights: List of integers representing the heights of the trees :return: 'Yes' if such a pair exists, otherwise 'No' height_set = set(heights) for height in heights: if (height + k) in height_set or (height - k) in height_set: return \\"Yes\\" return \\"No\\""},{"question":"def createPatternList(a: int, b: int) -> list: Generates a list of numbers from a to b with 'Fizz', 'Buzz', and 'FizzBuzz' replacements. Parameters: a (int): The starting number of the list. b (int): The ending number of the list. Returns: list: The generated list with specified replacements.","solution":"def createPatternList(a, b): Generates a list of numbers from a to b with 'Fizz', 'Buzz', and 'FizzBuzz' replacements. Parameters: a (int): The starting number of the list. b (int): The ending number of the list. Returns: list: The generated list with specified replacements. result = [] for num in range(a, b + 1): if num % 3 == 0 and num % 5 == 0: result.append(\\"FizzBuzz\\") elif num % 3 == 0: result.append(\\"Fizz\\") elif num % 5 == 0: result.append(\\"Buzz\\") else: result.append(num) return result"},{"question":"def can_obtain_n_distinct(s: str, k: int, n: int) -> str: Determines if it is possible to remove exactly k characters from the given string such that the resulting string contains exactly n distinct characters. >>> can_obtain_n_distinct(\\"abcabcabc\\", 2, 2) \\"YES\\" >>> can_obtain_n_distinct(\\"aabbcc\\", 4, 3) \\"NO\\"","solution":"def can_obtain_n_distinct(s, k, n): Determines if it's possible to remove exactly k characters from the string s such that the resulting string contains exactly n distinct characters. from collections import Counter # Calculate the number of distinct characters in the original string distinct_char_count = len(set(s)) # If we need more distinct characters than are originally present, it's not possible if n > distinct_char_count: return \\"NO\\" # If removing k characters would remove all characters or result in more than n distinct characters if len(s) - k < n: return \\"NO\\" return \\"YES\\""},{"question":"def pages_per_day_and_remainder(p: int, d: int) -> (int, int): Given the total number of pages \`p\` and the number of days \`d\`, this function returns a tuple containing the number of pages each student will read each day and the number of pages that need to be read on the final day. Parameters: p (int): total number of pages d (int): number of days Returns: (int, int): number of pages per day and remaining pages >>> pages_per_day_and_remainder(50, 7) (7, 1) >>> pages_per_day_and_remainder(20, 5) (4, 0) >>> pages_per_day_and_remainder(13, 4) (3, 1) def test_pages_per_day_and_remainder(): assert pages_per_day_and_remainder(50, 7) == (7, 1) assert pages_per_day_and_remainder(20, 5) == (4, 0) assert pages_per_day_and_remainder(13, 4) == (3, 1) assert pages_per_day_and_remainder(100, 25) == (4, 0) assert pages_per_day_and_remainder(1000000, 3) == (333333, 1)","solution":"def pages_per_day_and_remainder(p, d): Given the total number of pages \`p\` and the number of days \`d\`, this function returns a tuple containing the number of pages each student will read each day and the number of pages that need to be read on the final day. Parameters: p (int): total number of pages d (int): number of days Returns: (int, int): number of pages per day and remaining pages pages_per_day = p // d remainder = p % d return pages_per_day, remainder"},{"question":"from typing import List def min_buildings_encountered(N: int, M: int, S_x: int, S_y: int, T_x: int, T_y: int, grid: List[str]) -> int: Determine the minimum number of building cells the drone must encounter to get from the start to the target cell in a grid-based city. >>> N = 5 >>> M = 5 >>> S_x, S_y, T_x, T_y = 0, 0, 4, 4 >>> grid = [ ... \\".....\\", ... \\".#.#.\\", ... \\".#.#.\\", ... \\".#.#.\\", ... \\".....\\" ... ] >>> min_buildings_encountered(N, M, S_x, S_y, T_x, T_y, grid) == 0 >>> N = 5 >>> M = 5 >>> S_x, S_y, T_x, T_y = 0, 0, 4, 4 >>> grid = [ ... \\".....\\", ... \\"#\\", ... \\"#\\", ... \\".#.\\", ... \\".....\\" ... ] >>> min_buildings_encountered(N, M, S_x, S_y, T_x, T_y, grid) == -1 >>> N = 3 >>> M = 3 >>> S_x, S_y, T_x, T_y = 0, 0, 2, 2 >>> grid = [ ... \\"...\\", ... \\".#.\\", ... \\"...\\" ... ] >>> min_buildings_encountered(N, M, S_x, S_y, T_x, T_y, grid) == 0 >>> N = 3 >>> M = 3 >>> S_x, S_y, T_x, T_y = 0, 1, 2, 1 >>> grid = [ ... \\".#.\\", ... \\"#\\", ... \\".#.\\" ... ] >>> min_buildings_encountered(N, M, S_x, S_y, T_x, T_y, grid) == -1 >>> N = 3 >>> M = 3 >>> S_x, S_y, T_x, T_y = 0, 0, 2, 2 >>> grid = [ ... \\"...\\", ... \\"...\\", ... \\"...\\" ... ] >>> min_buildings_encountered(N, M, S_x, S_y, T_x, T_y, grid) == 0","solution":"from collections import deque def min_buildings_encountered(N, M, S_x, S_y, T_x, T_y, grid): directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] def is_valid(x, y): return 0 <= x < N and 0 <= y < M and grid[x][y] != '#' queue = deque([(S_x, S_y, 0, 0)]) # (x, y, buildings_count, steps) visited = set((S_x, S_y)) while queue: x, y, buildings_count, steps = queue.popleft() if (x, y) == (T_x, T_y): return buildings_count for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, buildings_count, steps + 1)) return -1"},{"question":"def isColorful(n): Determines if a positive integer n is a colorful number. >>> isColorful(3245) True >>> isColorful(326) False >>> isColorful(263) True >>> isColorful(23) True >>> isColorful(22) False >>> isColorful(9) True >>> isColorful(987) True","solution":"def isColorful(n): Determines if a positive integer n is a colorful number. num_str = str(n) products = set() # Iterate over all possible contiguous subsequences for i in range(len(num_str)): for j in range(i, len(num_str)): subseq = num_str[i:j+1] product = 1 for digit in subseq: product *= int(digit) if product in products: return False products.add(product) return True"},{"question":"from typing import List def canReachDestination(grid: List[List[str]], threshold: int) -> str: Determine if the robot can reach the destination within the given threshold. Args: grid (List[List[str]]): 2-D grid of n * m cells, where '.' represents an empty cell and '#' represents a blocked cell. threshold (int): maximum allowed path length. Returns: str: \\"Yes\\" if the robot can reach the destination within the given threshold, otherwise \\"No\\". Example: >>> grid = [ >>> ['.','.','#','.'], >>> ['#','.','#','.'], >>> ['.','.','.','#'], >>> ['#','#','.','.'] >>> ] >>> threshold = 6 >>> canReachDestination(grid, threshold) 'Yes' >>> grid = [ >>> ['.','.','#','.'], >>> ['#','.','#','.'], >>> ['.','.','.','#'], >>> ['#','#','.','.'] >>> ] >>> threshold = 5 >>> canReachDestination(grid, threshold) 'No'","solution":"from collections import deque def canReachDestination(grid, threshold): if not grid or not grid[0]: # empty grid case return \\"No\\" n, m = len(grid), len(grid[0]) directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] if grid[0][0] == '#' or grid[n-1][m-1] == '#': return \\"No\\" q = deque([(0, 0, 0)]) # (row, col, distance) visited = set((0, 0)) while q: r, c, dist = q.popleft() if (r, c) == (n-1, m-1): return \\"Yes\\" if dist <= threshold else \\"No\\" for dr, dc in directions: nr, nc, ndist = r + dr, c + dc, dist + 1 if 0 <= nr < n and 0 <= nc < m and (nr, nc) not in visited and grid[nr][nc] == '.': visited.add((nr, nc)) q.append((nr, nc, ndist)) return \\"No\\""},{"question":"def is_connected(n: int, m: int, connections: List[Tuple[int, int]]) -> str: Determines if a network of stations is connected. Parameters: - n: int, number of stations - m: int, number of direct connections - connections: list of tuples, each representing a direct connection (u, v) Returns: - str: \\"YES\\" if the network is connected, otherwise \\"NO\\" >>> is_connected(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) \\"YES\\" >>> is_connected(5, 3, [(1, 2), (2, 3), (4, 5)]) \\"NO\\" from typing import List, Tuple def test_network_fully_connected(): assert is_connected(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) == \\"YES\\" def test_network_not_fully_connected(): assert is_connected(5, 3, [(1, 2), (2, 3), (4, 5)]) == \\"NO\\" def test_single_station_no_connections(): assert is_connected(1, 0, []) == \\"YES\\" def test_two_stations_no_connection(): assert is_connected(2, 0, []) == \\"NO\\" def test_two_stations_with_connection(): assert is_connected(2, 1, [(1, 2)]) == \\"YES\\" def test_network_with_cycle(): assert is_connected(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) == \\"YES\\" def test_network_disjoint_parts(): assert is_connected(6, 4, [(1, 2), (2, 3), (4, 5), (5, 6)]) == \\"NO\\"","solution":"def is_connected(n, m, connections): Determines if a network of stations is connected. Parameters: - n: int, number of stations - m: int, number of direct connections - connections: list of tuples, each representing a direct connection (u, v) Returns: - str: \\"YES\\" if the network is connected, otherwise \\"NO\\" # Create adjacency list for the stations from collections import defaultdict, deque graph = defaultdict(list) for u, v in connections: graph[u].append(v) graph[v].append(u) # Since the network is undirected # To perform BFS/DFS to check connectivity def bfs(start): visited = set() queue = deque([start]) while queue: node = queue.popleft() if node not in visited: visited.add(node) queue.extend(graph[node]) return visited # Check connectivity by starting from station 1 all_stations = set(range(1, n + 1)) if n == 1: return \\"YES\\" # Only one station means it is connected if m == 0: return \\"NO\\" # No connections means stations can't communicate visited_stations = bfs(1) if visited_stations == all_stations: return \\"YES\\" else: return \\"NO\\""},{"question":"from typing import List, Tuple def min_purchases(n: int, k: int) -> int: Returns the minimum number of purchases required to get at least n chocolates, where chocolates can be bought in single units or bundles of k units. >>> min_purchases(5, 2) 3 >>> min_purchases(10, 3) 4 >>> min_purchases(12, 5) 3 pass def process_input(test_cases: List[Tuple[int, int]]) -> List[int]: Processes multiple test cases to find the minimum purchases required for each. test_cases: A list of tuples, where each tuple contains (n, k) Returns: A list of results for each test case >>> process_input([(5, 2), (10, 3), (12, 5)]) [3, 4, 3] pass","solution":"def min_purchases(n, k): Returns the minimum number of purchases required to get at least n chocolates, where chocolates can be bought in single units or bundles of k units. # Calculate number of full bundles needed full_bundles = n // k # If there is a remainder, it means we need an additional purchase for the remaining remainder = n % k # Total purchases will be full bundles + any remainder total_purchases = full_bundles + (1 if remainder > 0 else 0) return total_purchases def process_input(test_cases): Processes multiple test cases to find the minimum purchases required for each. test_cases: A list of tuples, where each tuple contains (n, k) Returns: A list of results for each test case results = [] for n, k in test_cases: results.append(min_purchases(n, k)) return results"},{"question":"def partitionString(S: str) -> int: Returns the minimum number of parts the string can be split into where each part contains unique characters. >>> partitionString(\\"abac\\") # should return 2; one possible split is {\\"ab\\", \\"ac\\"} >>> partitionString(\\"world\\") # should return 1; as each character is already unique >>> partitionString(\\"aab\\") # should return 2; one possible split is {\\"a\\", \\"ab\\"} >>> partitionString(\\"abcabc\\") # should return 2; one possible split is {\\"abc\\", \\"abc\\"}","solution":"def partitionString(S: str) -> int: Returns the minimum number of parts the string can be split into where each part contains unique characters. seen = set() part_count = 0 for char in S: if char in seen: part_count += 1 seen.clear() seen.add(char) # Count the last part if there are remaining characters in the set if seen: part_count += 1 return part_count"},{"question":"import math from typing import List def longestPerfectSquareSubsequence(arr: List[int]) -> List[int]: Given a list of integers, find the longest subsequence such that all elements of the subsequence are perfect squares. A perfect square is an integer that is the square of an integer (e.g., 1, 4, 9, 16, ...). Args: arr (List[int]): The list of integers. Returns: List[int]: The longest subsequence of perfect square numbers in non-decreasing order. Example: >>> longestPerfectSquareSubsequence([3, 4, 16, 2, 1, 9, 25]) [1, 4, 9, 16, 25] >>> longestPerfectSquareSubsequence([7, 11, 13, 17]) [] Constraints: * The length of the input list will not exceed 10^5. * Each integer in the list will be in the range 0 to 10^9. def test_example_1(): assert longestPerfectSquareSubsequence([3, 4, 16, 2, 1, 9, 25]) == [1, 4, 9, 16, 25] def test_example_2(): assert longestPerfectSquareSubsequence([7, 11, 13, 17]) == [] def test_empty_list(): assert longestPerfectSquareSubsequence([]) == [] def test_all_perfect_squares(): assert longestPerfectSquareSubsequence([1, 4, 9, 16, 25, 36]) == [1, 4, 9, 16, 25, 36] def test_mixed_numbers(): assert longestPerfectSquareSubsequence([20, 1, 9, 5, 4, 18, 25, 2, 100]) == [1, 4, 9, 25, 100] def test_large_non_perfect_square(): assert longestPerfectSquareSubsequence([10**9 + 1]) == [] def test_large_input_size(): large_input = [i for i in range(100000)] # Expected output would be the list of perfect squares up to 99999 perfect_squares = [i**2 for i in range(317)] assert longestPerfectSquareSubsequence(large_input) == perfect_squares","solution":"import math def longestPerfectSquareSubsequence(arr): def is_perfect_square(x): if x < 0: return False s = int(math.sqrt(x)) return s * s == x perfect_squares = [x for x in arr if is_perfect_square(x)] return sorted(perfect_squares)"},{"question":"from typing import List, Tuple def path_exists(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> bool: Return whether a path exists from start to end in the given grid. :param grid: 2D list of integers where 0 is an open cell and 1 is a wall. :param start: A tuple (r, c) representing the starting coordinates. :param end: A tuple (r, c) representing the ending coordinates. :return: Boolean indicating whether a path exists from start to end. >>> path_exists([[0, 1, 0, 0], [0, 0, 1, 0], [1, 0, 1, 0], [0, 0, 0, 0]], (0, 0), (3, 3)) True >>> path_exists([[0, 1, 0, 1], [1, 0, 1, 1], [1, 0, 1, 1], [0, 0, 0, 1]], (0, 0), (3, 3)) False # Implement the function here","solution":"from typing import List, Tuple from collections import deque def path_exists(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> bool: Return whether a path exists from start to end in the given grid. :param grid: 2D list of integers where 0 is an open cell and 1 is a wall. :param start: A tuple (r, c) representing the starting coordinates. :param end: A tuple (r, c) representing the ending coordinates. :return: Boolean indicating whether a path exists from start to end. if not grid or not grid[0] or grid[start[0]][start[1]] == 1 or grid[end[0]][end[1]] == 1: return False rows, cols = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, Down, Left, Right queue = deque([start]) visited = set() visited.add(start) while queue: current = queue.popleft() if current == end: return True for dir in directions: new_row, new_col = current[0] + dir[0], current[1] + dir[1] if 0 <= new_row < rows and 0 <= new_col < cols and (new_row, new_col) not in visited and grid[new_row][new_col] == 0: queue.append((new_row, new_col)) visited.add((new_row, new_col)) return False"},{"question":"def check_palindromes(words: List[str]) -> List[str]: Determines whether each word in the list is a palindrome or not. Parameters: words (list): A list of words to check. Returns: list: A list containing \\"Yes\\" or \\"No\\" for each word. >>> check_palindromes([\\"level\\", \\"racecar\\", \\"hello\\"]) [\\"Yes\\", \\"Yes\\", \\"No\\"] >>> check_palindromes([\\"abc\\", \\"deed\\"]) [\\"No\\", \\"Yes\\"]","solution":"def check_palindromes(words): Determines whether each word in the list is a palindrome or not. Parameters: words (list): A list of words to check. Returns: list: A list containing \\"Yes\\" or \\"No\\" for each word. results = [] for word in words: if word == word[::-1]: results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"def min_difference(test_cases: List[List[int]]) -> List[int]: Help Alex and Bob find the minimum possible absolute difference between the total weights of the two groups of candies. Parameters: test_cases (List[List[int]]): A list of test cases, where each test case is a list of integers representing the weights of the candies. Returns: List[int]: A list of integers representing the minimum possible absolute difference for each test case. Example: >>> min_difference([[2, 4, 6], [1, 5, 11, 5], [1, 2]]) [0, 0, 1]","solution":"def min_difference(test_cases): def find_min_difference(weights): total_sum = sum(weights) n = len(weights) possible_sums = [False] * (total_sum + 1) possible_sums[0] = True for weight in weights: for j in range(total_sum, weight - 1, -1): if possible_sums[j - weight]: possible_sums[j] = True half_sum = total_sum // 2 for i in range(half_sum, -1, -1): if possible_sums[i]: return total_sum - 2 * i results = [] for case in test_cases: results.append(find_min_difference(case)) return results # Example usage: # test_cases = [ # [2, 4, 6], # [1, 5, 11, 5], # [1, 2] # ] # print(min_difference(test_cases)) # Output: [0, 0, 1]"},{"question":"def check_bonus(levels: List[int]) -> str: Determines if a player receives a bonus based on the number of levels completed each day over 25 days. Parameters: levels (list of int): A list of integers where each integer represents the number of levels completed each day over 25 days. Returns: str: \\"Bonus\\" if the player completed at least 20 levels, \\"No Bonus\\" otherwise. >>> check_bonus([3, 1, 4, 2, 4, 1, 3, 2, 0, 1, 5, 2, 1, 4, 3, 2, 0, 1, 3, 2, 1, 4, 1, 2, 0]) \\"Bonus\\" >>> check_bonus([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) \\"No Bonus\\" >>> check_bonus([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) \\"Bonus\\" >>> check_bonus([5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 25, 5]) \\"Bonus\\" >>> check_bonus([2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]) \\"Bonus\\" >>> check_bonus([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) \\"No Bonus\\"","solution":"def check_bonus(levels): Determines if a player receives a bonus based on the number of levels completed each day over 25 days. Parameters: levels (list of int): A list of integers where each integer represents the number of levels completed each day over 25 days. Returns: str: \\"Bonus\\" if the player completed at least 20 levels, \\"No Bonus\\" otherwise. total_levels_completed = sum(levels) if total_levels_completed >= 20: return \\"Bonus\\" else: return \\"No Bonus\\""},{"question":"def shortest_journey(n, stops, s, t): Returns the minimum number of stops required to travel from stop s to stop t. :param n: Number of stops along the route :param stops: List of stop identifiers in order they appear along the route :param s: The start stop index (1-based) :param t: The destination stop index (1-based) :return: Minimum number of stops required to travel from s to t >>> shortest_journey(5, [3, 5, 2, 7, 4], 2, 4) 2 >>> shortest_journey(4, [1, 2, 3, 4], 4, 1) 1 >>> shortest_journey(3, [3, 2, 1], 1, 3) 1 >>> shortest_journey(6, [1, 2, 3, 4, 5, 6], 3, 6) 3 >>> shortest_journey(7, [7, 6, 5, 4, 3, 2, 1], 7, 4) 3 >>> shortest_journey(5, [3, 1, 2, 4, 2], 1, 5) 1 >>> shortest_journey(2, [1, 2], 1, 2) 1","solution":"def shortest_journey(n, stops, s, t): Returns the minimum number of stops required to travel from stop s to stop t. :param n: Number of stops along the route :param stops: List of stop identifiers in order they appear along the route :param s: The start stop index (1-based) :param t: The destination stop index (1-based) :return: Minimum number of stops required to travel from s to t # Convert to 0-based index for easier manipulation s -= 1 t -= 1 # Case 1: Moving from s to t in a clockwise direction if t >= s: clockwise_distance = t - s else: clockwise_distance = n - s + t # Case 2: Moving from s to t in a counter-clockwise direction if s >= t: counter_clockwise_distance = s - t else: counter_clockwise_distance = s + n - t # Return the minimum of the two distances return min(clockwise_distance, counter_clockwise_distance)"},{"question":"def leftover_candies(T, test_cases): Determines the number of leftover candies after distributing equally among children. Parameters: T (int): Number of test cases test_cases (list of tuples): Each tuple contains two integers, N (number of candies) and M (number of children) Returns: list: A list of integers representing the number of leftover candies for each test case >>> leftover_candies(3, [(10, 3), (20, 4), (8, 5)]) [1, 0, 3] >>> leftover_candies(2, [(25, 4), (7, 3)]) [1, 1] >>> leftover_candies(1, [(15, 5)]) [0] >>> leftover_candies(4, [(100, 3), (500, 7), (123, 12), (1, 1)]) [1, 3, 3, 0] >>> leftover_candies(5, [(10000, 10000), (9999, 9999), (5000, 5), (250, 7), (14, 3)]) [0, 0, 0, 5, 2]","solution":"def leftover_candies(T, test_cases): Determines the number of leftover candies after distributing equally among children. Parameters: T (int): Number of test cases test_cases (list of tuples): Each tuple contains two integers, N (number of candies) and M (number of children) Returns: list: A list of integers representing the number of leftover candies for each test case leftovers = [] for N, M in test_cases: leftovers.append(N % M) return leftovers"},{"question":"def max_products(shelves: int, shelf_spaces: List[int], products: int, product_spaces: List[int]) -> int: Determines the maximum number of products that can be stored in the warehouse without exceeding the capacity of any shelf. :param shelves: int - number of shelves :param shelf_spaces: list of int - available space on each shelf :param products: int - number of products :param product_spaces: list of int - space required by each product :return: int - maximum number of products that can be stored >>> max_products(4, [10, 20, 30, 40], 6, [5, 10, 15, 20, 25, 35]) 4 >>> max_products(3, [5, 5, 5], 4, [6, 6, 6, 6]) 0 >>> max_products(3, [5, 10, 15], 3, [5, 10, 15]) 3","solution":"def max_products(shelves, shelf_spaces, products, product_spaces): Determines the maximum number of products that can be stored in the warehouse without exceeding the capacity of any shelf. :param shelves: int - number of shelves :param shelf_spaces: list of int - available space on each shelf :param products: int - number of products :param product_spaces: list of int - space required by each product :return: int - maximum number of products that can be stored # Sort shelf spaces and product spaces to facilitate optimal fitting shelf_spaces.sort() product_spaces.sort() # Initialize counters max_products = 0 shelf_index = 0 # Try to fit each product to the smallest possible shelf for product in product_spaces: while shelf_index < shelves and shelf_spaces[shelf_index] < product: shelf_index += 1 if shelf_index < shelves: max_products += 1 shelf_index += 1 return max_products"},{"question":"def decompress_string(compressed_str: str) -> List[int]: This function takes a compressed string and decompresses it into an array of integers. Args: compressed_str (str): A compressed string where elements may be represented as \`element*count\` or just \`element\`. Returns: list: A list of integers representing the decompressed array. >>> decompress_string(\\"3*2 1 4*3 2\\") [3, 3, 1, 4, 4, 4, 2] >>> decompress_string(\\"7*4 5 5 8*2\\") [7, 7, 7, 7, 5, 5, 8, 8]","solution":"def decompress_string(compressed_str): This function takes a compressed string and decompresses it into an array of integers. Args: compressed_str (str): A compressed string where elements may be represented as \`element*count\` or just \`element\`. Returns: list: A list of integers representing the decompressed array. decompressed_list = [] elements = compressed_str.split() for element in elements: if '*' in element: value, count = element.split('*') decompressed_list.extend([int(value)] * int(count)) else: decompressed_list.append(int(element)) return decompressed_list"},{"question":"def sort_odds_before_evens(lst: List[int]) -> List[int]: Given a list of integers, sorts the list such that all odd numbers come before all even numbers. Within the odd numbers, they should be sorted in ascending order, and within the even numbers, they should be sorted in ascending order. >>> sort_odds_before_evens([10, 21, 3, 14, 5, 8, 7]) [3, 5, 7, 21, 8, 10, 14] >>> sort_odds_before_evens([1, 2, 3, 4, 5]) [1, 3, 5, 2, 4] >>> sort_odds_before_evens([-9, -2, -3, 0, 1, 4, -5, 6]) [-9, -5, -3, 1, -2, 0, 4, 6] >>> sort_odds_before_evens([7, 5, 3, 1]) [1, 3, 5, 7] >>> sort_odds_before_evens([2, 4, 6, 8]) [2, 4, 6, 8] >>> sort_odds_before_evens([10, -3, -6, 7, -1, 0]) [-3, -1, 7, -6, 0, 10] >>> sort_odds_before_evens([1]) [1] >>> sort_odds_before_evens([2]) [2] >>> sort_odds_before_evens([]) []","solution":"def sort_odds_before_evens(lst): This function sorts the list such that all odd numbers come before the evens, with both groups of numbers sorted in ascending order. odds = sorted([num for num in lst if num % 2 != 0]) evens = sorted([num for num in lst if num % 2 == 0]) return odds + evens"},{"question":"def thue_morse_length(n: int) -> int: Given an integer n (1 ≤ n ≤ 10^5), determine the length of the shortest Thue-Morse string that can be formed of length n. >>> thue_morse_length(1) == 1 >>> thue_morse_length(2) == 2 >>> thue_morse_length(5) == 8 >>> thue_morse_length(10) == 16 >>> thue_morse_length(20) == 32","solution":"def thue_morse_length(n): Returns the length of the shortest Thue-Morse string of at least length n. # Generate the Thue-Morse sequence until it is long enough thue_morse = '0' while len(thue_morse) < n: thue_morse += ''.join('1' if c == '0' else '0' for c in thue_morse) return len(thue_morse)"},{"question":"def is_palindrome(s: str) -> bool: Checks if the given string is a palindrome considering only alphabetic characters. >>> is_palindrome(\\"a.b,a\\") True >>> is_palindrome(\\"race car\\") True >>> is_palindrome(\\"hello\\") False pass def check_palindromes(test_cases: List[str]) -> List[str]: For each test case, check if the string is a palindrome and return \\"YES\\" or \\"NO\\". >>> check_palindromes([\\"a.b,a\\", \\"race car\\", \\"hello\\"]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> check_palindromes([\\"No 'x' in Nixon\\", \\"123hello321\\"]) [\\"YES\\", \\"NO\\"] pass","solution":"def is_palindrome(s): Checks if the given string is a palindrome considering only alphabetic characters. # Filter only alphabetic characters and convert them to lowercase filtered_s = ''.join(filter(str.isalpha, s)).lower() # Check if the filtered string is the same when reversed return filtered_s == filtered_s[::-1] def check_palindromes(test_cases): For each test case, check if the string is a palindrome and return \\"YES\\" or \\"NO\\". results = [] for s in test_cases: if is_palindrome(s): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"class Library: A class to manage the book catalog for a library. def __init__(self): Initialize an empty catalog. self.catalog = {} def add_update_book(self, book_id: int, title: str, author: str, year: int): Add or update a book record in the catalog. Args: book_id (int): The unique ID of the book. title (str): The title of the book. author (str): The author of the book. year (int): The year of publication. pass def get_book_info(self, book_id: int) -> str: Retrieve the information of a book given its unique book ID. Args: book_id (int): The unique ID of the book. Returns: str: A string containing the book's title, author, and year separated by spaces, or \\"NOT FOUND\\" if the book does not exist. pass def handle_queries(queries: list) -> list: Handle a list of queries for managing the book catalog. Args: queries (list): A list of query strings. Returns: list: A list of responses for \\"GET\\" queries. pass from library import Library def test_add_and_get_book(): queries = [ \\"ADD 1 MobyDick Melville 1851\\", \\"ADD 2 Hamlet Shakespeare 1603\\", \\"GET 1\\", \\"GET 3\\", \\"ADD 1 MobyDick Melville 1852\\", \\"GET 1\\" ] expected_results = [ \\"MobyDick Melville 1851\\", \\"NOT FOUND\\", \\"MobyDick Melville 1852\\" ] assert handle_queries(queries) == expected_results def test_get_nonexistent_book(): queries = [ \\"GET 999\\", ] expected_results = [ \\"NOT FOUND\\", ] assert handle_queries(queries) == expected_results def test_update_book(): queries = [ \\"ADD 5 WarAndPeace Tolstoy 1869\\", \\"GET 5\\", \\"ADD 5 WarAndPeace Tolstoy 1873\\", \\"GET 5\\" ] expected_results = [ \\"WarAndPeace Tolstoy 1869\\", \\"WarAndPeace Tolstoy 1873\\" ] assert handle_queries(queries) == expected_results def test_large_number_of_queries(): queries = [\\"ADD {} Title{} Author{} 2000\\".format(i, i, i) for i in range(1, 10001)] queries += [\\"GET 9999\\"] expected_results = [\\"Title9999 Author9999 2000\\"] assert handle_queries(queries) == expected_results def test_varied_sequence_of_operations(): queries = [ \\"ADD 10 BookA AuthorA 2000\\", \\"ADD 20 BookB AuthorB 2001\\", \\"ADD 30 BookC AuthorC 2002\\", \\"GET 10\\", \\"GET 20\\", \\"ADD 10 BookAX AuthorAX 2010\\", \\"GET 10\\", \\"GET 30\\" ] expected_results = [ \\"BookA AuthorA 2000\\", \\"BookB AuthorB 2001\\", \\"BookAX AuthorAX 2010\\", \\"BookC AuthorC 2002\\" ] assert handle_queries(queries) == expected_results","solution":"class Library: def __init__(self): self.catalog = {} def add_update_book(self, book_id, title, author, year): self.catalog[book_id] = (title, author, year) def get_book_info(self, book_id): if book_id in self.catalog: return f\\"{self.catalog[book_id][0]} {self.catalog[book_id][1]} {self.catalog[book_id][2]}\\" else: return \\"NOT FOUND\\" def handle_queries(queries): library = Library() results = [] for query in queries: parts = query.split() cmd = parts[0] if cmd == \\"ADD\\": book_id = int(parts[1]) title = parts[2] author = parts[3] year = parts[4] library.add_update_book(book_id, title, author, year) elif cmd == \\"GET\\": book_id = int(parts[1]) results.append(library.get_book_info(book_id)) return results"},{"question":"def canFormPalindrome(s: str) -> bool: Write a function canFormPalindrome(s) that takes a string s as input and returns true if any permutation of s could form a palindrome, otherwise returns false. A string can form a palindrome if at most one character appears an odd number of times. >>> canFormPalindrome(\\"aabb\\") == True >>> canFormPalindrome(\\"racecar\\") == True >>> canFormPalindrome(\\"hello\\") == False >>> canFormPalindrome(\\"\\") == True >>> canFormPalindrome(\\"a\\") == True >>> canFormPalindrome(\\"abc\\") == False >>> canFormPalindrome(\\"aabbccd\\") == True","solution":"def canFormPalindrome(s): Returns True if any permutation of the string s can form a palindrome, otherwise returns False. from collections import Counter char_count = Counter(s) odd_counts = sum(1 for count in char_count.values() if count % 2 != 0) return odd_counts <= 1"},{"question":"from typing import List, Tuple def string_operations(m: int, operations: List[Tuple[int, str]]) -> List[str]: Perform a series of string operations and return the result of each operation. Args: m (int): The number of operations to perform. operations (List[Tuple[int, str]]): A list of operations, where each operation is represented by a tuple. - If the first element is 1, append the string (second element) to the current string. - If the first element is 2, remove the last 'l_i' characters from the current string. - If the first element is 3, check if the substring (second element) exists in the current string. Returns: List[str]: The results of the operations, where each result corresponds to an operation. >>> string_operations(6, [(1, 'abc'), (1, 'def'), (3, 'cd'), (2, 3), (3, 'def'), (3, 'ab')]) ['APPENDED', 'APPENDED', 'YES', 'REMOVED', 'NO', 'YES']","solution":"def string_operations(m, operations): current_string = \\"\\" results = [] for operation in operations: op = operation[0] if op == 1: s_i = operation[1] current_string += s_i results.append(\\"APPENDED\\") elif op == 2: l_i = operation[1] current_string = current_string[:-l_i] results.append(\\"REMOVED\\") elif op == 3: t_i = operation[1] if t_i in current_string: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def decode_morse(morse_code: str) -> str: Decode a string representing a sequence in Morse code and return the decoded English sentence. Consider the following Morse code rules: - A space ' ' separates letters within a word. - Three spaces ' ' separate words. Here's a sample Morse code dictionary to use: MORSE_CODE_DICT = { 'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', 'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..', 'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.', 'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', 'Y': '-.--', 'Z': '--..', '1': '.----', '2': '..---', '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...', '8': '---..', '9': '----.', '0': '-----', ',': '--..--','.': '.-.-.-','?': '..--..','/': '-..-.', '-': '-....-', '(': '-.--.', ')': '-.--.-','&': '.-...' } Example: >>> decode_morse(\\".... . -.-- .--- ..- -.. .\\") \\"HEY JUDE\\" >>> decode_morse(\\"--. --- --- -.. -- --- .-. -. .. -. --.\\") \\"GOOD MORNING\\"","solution":"def decode_morse(morse_code): MORSE_CODE_DICT = { '.-': 'A', '-...': 'B', '-.-.': 'C', '-..': 'D', '.': 'E', '..-.': 'F', '--.': 'G', '....': 'H', '..': 'I', '.---': 'J', '-.-': 'K', '.-..': 'L', '--': 'M', '-.': 'N', '---': 'O', '.--.': 'P', '--.-': 'Q', '.-.': 'R', '...': 'S', '-': 'T', '..-': 'U', '...-': 'V', '.--': 'W', '-..-': 'X', '-.--': 'Y', '--..': 'Z', '-----': '0', '.----': '1', '..---': '2', '...--': '3', '....-': '4', '.....': '5', '-....': '6', '--...': '7', '---..': '8', '----.': '9', '--..--': ',', '.-.-.-': '.', '..--..': '?', '-..-.': '/', '-....-': '-', '-.--.': '(', '-.--.-': ')', '.-...': '&' } # Splitting the morse code by three spaces to separate words words = morse_code.split(' ') decoded_message = [] for word in words: # Splitting the word by single space to separate each letter letters = word.split(' ') decoded_word = ''.join(MORSE_CODE_DICT[letter] for letter in letters) decoded_message.append(decoded_word) return ' '.join(decoded_message)"},{"question":"def evaluateExpression(S: str) -> int: Evaluates a well-formed arithmetic expression containing integers, addition, subtraction, multiplication, and division operators. Division is treated as integer division. Args: S (str): The arithmetic expression string to evaluate Returns: int: The result of the arithmetic expression evaluation Examples: >>> evaluateExpression(\\"3+2*2\\") 7 >>> evaluateExpression(\\" 3/2 \\") 1 >>> evaluateExpression(\\" 3+5 / 2 \\") 5","solution":"def evaluateExpression(S): Evaluates a well-formed arithmetic expression containing integers, addition, subtraction, multiplication, and division operators. Division is treated as integer division. Args: S (str): The arithmetic expression string to evaluate Returns: int: The result of the arithmetic expression evaluation num = 0 stack = [] sign = \\"+\\" S = S.replace(\\" \\", \\"\\") # Remove spaces for i, char in enumerate(S): if char.isdigit(): # Build the current number num = num * 10 + int(char) if char in \\"+-*/\\" or i == len(S) - 1: if sign == \\"+\\": stack.append(num) elif sign == \\"-\\": stack.append(-num) elif sign == \\"*\\": stack.append(stack.pop() * num) elif sign == \\"/\\": stack.append(int(stack.pop() / num)) # Integer division sign = char num = 0 return sum(stack)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def findLCA(root, p, q): This function finds the least common ancestor (LCA) of two nodes in a binary search tree. :param root: TreeNode, the root of the binary search tree :param p: TreeNode, one of the two nodes :param q: TreeNode, the other node :return: TreeNode, the least common ancestor of p and q pass # Example usages >>> root = TreeNode(6) >>> root.left = TreeNode(2) >>> root.right = TreeNode(8) >>> root.left.left = TreeNode(0) >>> root.left.right = TreeNode(4) >>> root.right.left = TreeNode(7) >>> root.right.right = TreeNode(9) >>> root.left.right.left = TreeNode(3) >>> root.left.right.right = TreeNode(5) >>> p = root.left # Node with value 2 >>> q = root.right # Node with value 8 >>> findLCA(root, p, q).val 6 >>> p = root.left # Node with value 2 >>> q = root.left.right # Node with value 4 >>> findLCA(root, p, q).val 2","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def findLCA(root, p, q): This function finds the least common ancestor (LCA) of two nodes in a binary search tree. :param root: TreeNode, the root of the binary search tree :param p: TreeNode, one of the two nodes :param q: TreeNode, the other node :return: TreeNode, the least common ancestor of p and q if not root: # If the root is None, there is no LCA return None # If both p and q are greater than root, LCA lies in right subtree if p.val > root.val and q.val > root.val: return findLCA(root.right, p, q) # If both p and q are less than root, LCA lies in left subtree if p.val < root.val and q.val < root.val: return findLCA(root.left, p, q) # If split happens, root is the LCA return root"},{"question":"from datetime import datetime, timedelta from typing import List def longest_streak(n: int, dates: List[str]) -> int: Finds the length of the longest streak of consecutive days with at least one task completed. Parameters: n (int): Number of tasks completed by the user. dates (List[str]): List of dates in 'YYYY-MM-DD' format representing the completion date of a task. Returns: int: Length of the longest streak of consecutive days with task completion. pass # Unit Tests def test_example_1(): assert longest_streak(5, [ \\"2023-01-01\\", \\"2023-01-02\\", \\"2023-01-03\\", \\"2023-01-01\\", \\"2023-01-05\\" ]) == 3 def test_example_2(): assert longest_streak(4, [ \\"2023-01-01\\", \\"2023-01-03\\", \\"2023-01-04\\", \\"2023-01-05\\" ]) == 3 def test_example_3(): assert longest_streak(3, [ \\"2023-01-01\\", \\"2023-01-10\\", \\"2023-01-20\\" ]) == 1 def test_all_dates_same(): assert longest_streak(3, [ \\"2023-01-01\\", \\"2023-01-01\\", \\"2023-01-01\\" ]) == 1 def test_no_dates(): assert longest_streak(0, []) == 0 def test_single_date(): assert longest_streak(1, [\\"2023-01-01\\"]) == 1 def test_non_consecutive_dates(): assert longest_streak(5, [ \\"2023-01-01\\", \\"2023-01-10\\", \\"2023-01-20\\", \\"2023-01-30\\", \\"2023-02-01\\" ]) == 1 def test_mixed_dates(): assert longest_streak(7, [ \\"2023-01-01\\", \\"2023-01-05\\", \\"2023-01-06\\", \\"2023-01-07\\", \\"2023-01-08\\", \\"2023-01-10\\", \\"2023-01-11\\" ]) == 4 def test_consecutive_with_duplicates(): assert longest_streak(6, [ \\"2023-01-01\\", \\"2023-01-01\\", \\"2023-01-02\\", \\"2023-01-03\\", \\"2023-01-03\\", \\"2023-01-03\\" ]) == 3","solution":"from datetime import datetime, timedelta def longest_streak(n, dates): Finds the length of the longest streak of consecutive days with at least one task completed. Parameters: n (int): Number of tasks completed by the user. dates (List[str]): List of dates in 'YYYY-MM-DD' format representing the completion date of a task. Returns: int: Length of the longest streak of consecutive days with task completion. if n <= 0: return 0 # Convert list of dates to a set of datetime objects to remove duplicates and for O(1) lookups completion_dates = set(datetime.strptime(date, '%Y-%m-%d') for date in dates) max_streak = 0 current_streak = 0 for date in sorted(completion_dates): if current_streak == 0: # Start of a new streak current_streak = 1 else: if (previous_date + timedelta(days=1)) == date: # Consecutive day current_streak += 1 else: # Streak breaks max_streak = max(max_streak, current_streak) current_streak = 1 # Update previous_date to current date for next iteration previous_date = date # Final check in case the longest streak is the last streak found max_streak = max(max_streak, current_streak) return max_streak"},{"question":"def reorder_string(s: str) -> str: Reorders the string such that all digit characters come before all letter characters while preserving the relative order of digits among themselves and letters among themselves. :param s: Input string containing digits and lowercase letters :return: Reordered string with digits first and letters following >>> reorder_string(\\"a1b2c3d4\\") == \\"1234abcd\\" >>> reorder_string(\\"4d3c2b1a\\") == \\"4321dcba\\" >>> reorder_string(\\"abc123\\") == \\"123abc\\" >>> reorder_string(\\"123abc\\") == \\"123abc\\" >>> reorder_string(\\"a1a1b1\\") == \\"111aab\\" >>> reorder_string(\\"1a2b3c4d\\") == \\"1234abcd\\" >>> reorder_string(\\"z4y3x2w1\\") == \\"4321zyxw\\"","solution":"def reorder_string(s): Reorders the string such that all digit characters come before all letter characters while preserving the relative order of digits among themselves and letters among themselves. :param s: Input string containing digits and lowercase letters :return: Reordered string with digits first and letters following digits = [] letters = [] for char in s: if char.isdigit(): digits.append(char) else: letters.append(char) return ''.join(digits) + ''.join(letters)"},{"question":"from typing import List def rearrangeArray(n: int, arr: List[int]) -> List[int]: Given an array of integers arr of size n, determine if it is possible to rearrange the elements of the array such that no two adjacent elements have the same value. If possible, return one such rearrangement, otherwise return an empty array. Example 1: >>> rearrangeArray(6, [1, 1, 2, 2, 3, 3]) [1, 2, 1, 3, 2, 3] Example 2: >>> rearrangeArray(3, [1, 1, 1]) [] Constraints: 1 <= n <= 10^5 1 <= arr[i] <= 10^9 import pytest from solution import rearrangeArray def test_example1(): assert rearrangeArray(6, [1, 1, 2, 2, 3, 3]) == [1, 2, 1, 3, 2, 3] def test_example2(): assert rearrangeArray(3, [1, 1, 1]) == [] def test_small_array(): assert rearrangeArray(1, [1]) == [1] assert rearrangeArray(2, [1, 2]) == [1, 2] assert rearrangeArray(2, [2, 2]) == [] def test_large_array_possible(): assert rearrangeArray(5, [1, 1, 2, 2, 3]) != [] assert rearrangeArray(7, [1, 1, 1, 2, 2, 3, 3]) != [] def test_large_array_not_possible(): assert rearrangeArray(5, [1, 1, 1, 1, 2]) == [] assert rearrangeArray(5, [1, 1, 1, 1, 1]) == []","solution":"from collections import Counter import heapq def rearrangeArray(n, arr): if n == 1: return arr # Count frequency of each element counter = Counter(arr) max_freq = max(counter.values()) # If the highest frequency element is more than (n+1)//2, return empty list if max_freq > (n + 1) // 2: return [] # Create a max heap based on the frequency counts max_heap = [] for num, freq in counter.items(): heapq.heappush(max_heap, (-freq, num)) result = [0] * n # Fill the elements in the result array in a zigzag manner index = 0 while max_heap: freq, num = heapq.heappop(max_heap) freq = -freq # convert back to positive frequency for _ in range(freq): if index >= n: index = 1 # move to the next available odd position result[index] = num index += 2 return result"},{"question":"def solve(n, q, scores, edges, queries): A software company implements a system for monitoring user activities on its platform. The platform has a tree structure representing a hierarchy of different modules, where each module is connected to its parent module. Each module has an associated activity score which represents the user engagement on that module. An activity score is a positive integer. You are given the hierarchy of the modules in terms of n nodes (modules) numbered from 1 to n, connected by n-1 bidirectional roads. You are also given q queries, each query asking for the maximum activity score on the path between two given modules. For each query, return the maximum activity score on the path between module u and module v. :param n: int, the number of modules :param q: int, the number of queries :param scores: List[int], the list of activity scores for each module :param edges: List[Tuple[int, int]], the list of edges representing the hierarchy of modules :param queries: List[Tuple[int, int]], the list of queries :return: List[int], the list of maximum scores for each query >>> solve(5, 3, [1, 5, 3, 2, 4], [(1, 2), (1, 3), (2, 4), (2, 5)], [(1, 4), (4, 5), (3, 4)]) [5, 5, 5] >>> solve(4, 2, [8, 6, 7, 5], [(1, 2), (1, 3), (1, 4)], [(2, 3), (2, 4)]) [8, 8]","solution":"class TreeNode: def __init__(self, index, score): self.index = index self.score = score self.children = [] self.parent = None def build_tree(n, scores, edges): nodes = [TreeNode(i, scores[i-1]) for i in range(1, n+1)] for u, v in edges: nodes[u-1].children.append(nodes[v-1]) nodes[v-1].children.append(nodes[u-1]) return nodes def preprocess_lca(n, nodes): depth = [0] * n lca_parent = [[-1] * n for _ in range(n)] max_scores = [[float('-inf')] * n for _ in range(n)] root = nodes[0] # Take an arbitrary root def dfs(node, par): for child in node.children: if child.index != par: depth[child.index - 1] = depth[node.index - 1] + 1 lca_parent[child.index - 1][0] = node.index - 1 max_scores[child.index - 1][0] = max(node.score, child.score) dfs(child, node.index) dfs(root, -1) for j in range(1, n): for i in range(n): if lca_parent[i][j-1] != -1: lca_parent[i][j] = lca_parent[lca_parent[i][j-1]][j-1] max_scores[i][j] = max(max_scores[i][j-1], max_scores[lca_parent[i][j-1]][j-1]) return depth, lca_parent, max_scores def query_max_score(u, v, depth, lca_parent, max_scores): if depth[u] < depth[v]: u, v = v, u max_score = float('-inf') log = 1 while (1 << log) <= depth[u]: log += 1 log -= 1 for i in range(log, -1, -1): if depth[u] - (1 << i) >= depth[v]: max_score = max(max_score, max_scores[u][i]) u = lca_parent[u][i] if u == v: return max_score for i in range(log, -1, -1): if lca_parent[u][i] != -1 and lca_parent[u][i] != lca_parent[v][i]: max_score = max(max_score, max_scores[u][i], max_scores[v][i]) u = lca_parent[u][i] v = lca_parent[v][i] max_score = max(max_score, max_scores[u][0], max_scores[v][0]) return max_score def solve(n, q, scores, edges, queries): nodes = build_tree(n, scores, edges) depth, lca_parent, max_scores = preprocess_lca(n, nodes) result = [] for u, v in queries: result.append(query_max_score(u-1, v-1, depth, lca_parent, max_scores)) return result"},{"question":"def warrior_qualification(N: int, test_cases: List[Tuple[int, int, int, int, int, int, int]]) -> List[str]: Determine if warriors meet the ranking criteria. >>> warrior_qualification(5, [(2, 2, 2, 10, 3, 3, 3), (2, 2, 2, 10, 1, 4, 5), (5, 5, 6, 20, 5, 5, 5), (1, 2, 2, 6, 1, 3, 2), (10, 10, 10, 30, 10, 10, 10)]) [\\"DISQUALIFIED\\", \\"DISQUALIFIED\\", \\"DISQUALIFIED\\", \\"QUALIFIED\\", \\"QUALIFIED\\"] >>> warrior_qualification(1, [(2, 2, 2, 6, 2, 2, 2)]) [\\"QUALIFIED\\"] >>> warrior_qualification(1, [(2, 2, 2, 6, 1, 2, 2)]) [\\"DISQUALIFIED\\"] results = [] for case in test_cases: S_min, P_min, I_min, R_min, S, P, I = case if S >= S_min and P >= P_min and I >= I_min and (S + P + I) >= R_min: results.append(\\"QUALIFIED\\") else: results.append(\\"DISQUALIFIED\\") return results","solution":"def warrior_qualification(N, test_cases): results = [] for case in test_cases: S_min, P_min, I_min, R_min, S, P, I = case if S >= S_min and P >= P_min and I >= I_min and (S + P + I) >= R_min: results.append(\\"QUALIFIED\\") else: results.append(\\"DISQUALIFIED\\") return results"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a given mathematical expression string containing integers, +, -, and *. >>> evaluate_expression(\\"3+5*2-6\\") 7 >>> evaluate_expression(\\"42\\") 42 >>> evaluate_expression(\\"1+2+3\\") 6 >>> evaluate_expression(\\"10-5-2\\") 3 >>> evaluate_expression(\\"2*3*4\\") 24 >>> evaluate_expression(\\"2+3*4-1\\") 13 >>> evaluate_expression(\\"1000*1000+1000-1\\") 1000999 >>> evaluate_expression(\\"1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1\\") 36","solution":"def evaluate_expression(expression): Evaluates a given mathematical expression string containing integers, +, -, and *. def precedence(op): if op == '+' or op == '-': return 1 if op == '*': return 2 return 0 def apply_op(a, b, op): if op == '+': return a + b if op == '-': return a - b if op == '*': return a * b # Stack to store integers values = [] # Stack to store operators ops = [] i = 0 while i < len(expression): # If current character is a digit if expression[i].isdigit(): val = 0 while i < len(expression) and expression[i].isdigit(): val = (val * 10) + int(expression[i]) i += 1 values.append(val) i -= 1 # If current character is an operator else: while len(ops) != 0 and precedence(ops[-1]) >= precedence(expression[i]): val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) ops.append(expression[i]) i += 1 while len(ops) != 0: val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) return values[0]"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_unival_tree(root): Determines if a binary tree is a uni-value tree. def deserialize(data): Deserializes a space-separated string input into a binary tree. def is_unival_tree_from_str(data): Checks if a binary tree, read as a space-separated string, is a uni-value binary tree. root = deserialize(data) return is_unival_tree(root) # Test cases def test_unival_tree(): assert is_unival_tree_from_str(\\"1 1 1 1 1 null null\\") == True assert is_unival_tree_from_str(\\"2 2 2 null null 5 2\\") == False assert is_unival_tree_from_str(\\"1 1 1 1 1 1 1\\") == True assert is_unival_tree_from_str(\\"1\\") == True assert is_unival_tree_from_str(\\"0 0 null 0 0\\") == True assert is_unival_tree_from_str(\\"3 3 3 3 2 3 3\\") == False assert is_unival_tree_from_str(\\"null\\") == True assert is_unival_tree_from_str(\\"4 4 4 4 null null 4\\") == True assert is_unival_tree_from_str(\\"5 5 5 null 5 null 5\\") == True assert is_unival_tree_from_str(\\"1 1 1 null null null 2\\") == False","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_unival_tree(root): Determines if a binary tree is a uni-value tree. if not root: return True val = root.val def dfs(node): if not node: return True if node.val != val: return False return dfs(node.left) and dfs(node.right) return dfs(root) def deserialize(data): Deserializes a space-separated string input into a binary tree. if not data: return None nodes = data.split() if nodes[0] == \\"null\\": return None root = TreeNode(int(nodes[0])) queue = [root] i = 1 while queue and i < len(nodes): current = queue.pop(0) if nodes[i] != \\"null\\": current.left = TreeNode(int(nodes[i])) queue.append(current.left) i += 1 if i < len(nodes) and nodes[i] != \\"null\\": current.right = TreeNode(int(nodes[i])) queue.append(current.right) i += 1 return root def is_unival_tree_from_str(data): root = deserialize(data) return is_unival_tree(root)"},{"question":"def generate_fizz_list(n, m): Generate a list of integers from 1 to n such that integers divisible by m are replaced with \\"Fizz\\". :param n: int, upper limit of the range (must be >= 1) :param m: int, the divisor for \\"Fizz\\" (must be >= 1) :return: list, the generated list with replacements","solution":"def generate_fizz_list(n, m): Generate a list of integers from 1 to n with all multiples of m replaced with \\"Fizz\\". :param n: int, upper limit of the range :param m: int, the divisor for \\"Fizz\\" :return: list, the generated list with replacements if n < 1 or m < 1: return [] result = [] for i in range(1, n+1): if i % m == 0: result.append(\\"Fizz\\") else: result.append(i) return result"},{"question":"def min_abs_differences(test_cases: List[List[int]]) -> List[int]: Determine the minimum possible absolute difference between the sums of two parts by splitting the list into exactly two non-empty parts. Args: test_cases (List[List[int]]): A list of test cases, each containing a list of integers. Returns: List[int]: A list of minimum possible absolute differences for each test case. >>> min_abs_differences([[1, 2, 3, 4, 5]]) [1] >>> min_abs_differences([[2, -1, 2, -3, 4, 1]]) [1] >>> min_abs_differences([[1, 1, 1, 1, 1, 1]]) [0] >>> min_abs_differences([[3, 1, 4, 2, 2]]) [0] >>> min_abs_differences([[1, 2, 3, 4, 5], [2, -1, 2, -3, 4, 1], [3, 3, 3, 3], [-1, -1, 1, 1]]) [1, 1, 0, 0]","solution":"def min_abs_difference(nums): total_sum = sum(nums) n = len(nums) dp = [False] * (total_sum // 2 + 1) dp[0] = True for num in nums: for s in range(total_sum // 2, num - 1, -1): dp[s] = dp[s] or dp[s - num] for s in range(total_sum // 2, -1, -1): if dp[s]: first_part_sum = s break second_part_sum = total_sum - first_part_sum return abs(first_part_sum - second_part_sum) def min_abs_differences(test_cases): results = [] for nums in test_cases: results.append(min_abs_difference(nums)) return results"},{"question":"def rearrange_to_palindrome(s: str) -> str: Rearranges the string s to form a palindrome if possible. Returns the rearranged palindromic string or \\"-1\\" if it is not possible. Input: s: str - the input string consisting of lowercase English letters Output: str - the rearranged palindromic string if possible, otherwise \\"-1\\" Example: >>> rearrange_to_palindrome(\\"aabb\\") \\"abba\\" >>> rearrange_to_palindrome(\\"abc\\") \\"-1\\" >>> rearrange_to_palindrome(\\"civic\\") \\"civic\\"","solution":"def rearrange_to_palindrome(s): Rearranges the string s to form a palindrome if possible. Returns the rearranged palindromic string or \\"-1\\" if it is not possible. from collections import Counter counter = Counter(s) middle_char = None half_palindrome = [] # Check the count of characters and build the half_palindrome for char, count in counter.items(): if count % 2 != 0: if middle_char is not None: # More than one character has an odd count return \\"-1\\" middle_char = char half_palindrome.append(char * (count // 2)) # Build the palindromic string half_palindrome_str = \\"\\".join(half_palindrome) if middle_char: return half_palindrome_str + middle_char + half_palindrome_str[::-1] else: return half_palindrome_str + half_palindrome_str[::-1]"},{"question":"def minimum_partitions(n: int, a: List[int]) -> int: You are given an array a of length n. The array has n integers which are either 1, 2 or 3. Your task is to partition the array into the minimum number of contiguous subarrays such that each subarray contains exactly one occurrence of 1, 2, and 3. Args: n (int) : length of the array a (List[int]) : the array Returns: int : the minimum number of contiguous subarrays Examples: >>> minimum_partitions(7, [1, 3, 2, 3, 1, 2, 1]) 2 >>> minimum_partitions(6, [1, 2, 3, 1, 2, 3]) 2 >>> minimum_partitions(5, [3, 2, 1, 3, 2]) 1","solution":"def minimum_partitions(n, a): from collections import deque positions = {1: deque(), 2: deque(), 3: deque()} for i in range(n): positions[a[i]].append(i) partitions = 0 while all(positions[val] for val in positions): max_pos = max(positions[1][0], positions[2][0], positions[3][0]) partitions += 1 for val in positions: while positions[val] and positions[val][0] <= max_pos: positions[val].popleft() return partitions"},{"question":"def is_valid_parenthesis_sequence(s: str) -> bool: Determines if the input string is a valid parenthesis sequence. Args: s (str): Input string consisting of characters '(', ')', '{', '}', '[' and ']'. Returns: bool: True if the input string is a valid parenthesis sequence, False otherwise. >>> is_valid_parenthesis_sequence(\\"()\\") True >>> is_valid_parenthesis_sequence(\\"()[]{}\\") True >>> is_valid_parenthesis_sequence(\\"(]\\") False >>> is_valid_parenthesis_sequence(\\"([{}])\\") True >>> is_valid_parenthesis_sequence(\\"{[()]\\") False from solution import is_valid_parenthesis_sequence def test_valid_trivial_case(): assert is_valid_parenthesis_sequence(\\"()\\") == True def test_valid_mixed_brackets(): assert is_valid_parenthesis_sequence(\\"()[]{}\\") == True def test_invalid_single_mismatch(): assert is_valid_parenthesis_sequence(\\"(]\\") == False def test_valid_nested(): assert is_valid_parenthesis_sequence(\\"([{}])\\") == True def test_invalid_unclosed(): assert is_valid_parenthesis_sequence(\\"{[()]\\") == False def test_empty_string(): assert is_valid_parenthesis_sequence(\\"\\") == True def test_single_open(): assert is_valid_parenthesis_sequence(\\"(\\") == False def test_single_close(): assert is_valid_parenthesis_sequence(\\")\\") == False def test_long_valid_sequence(): assert is_valid_parenthesis_sequence(\\"{[()()]}[{}]\\") == True def test_long_invalid_sequence(): assert is_valid_parenthesis_sequence(\\"{[()()]}}\\") == False","solution":"def is_valid_parenthesis_sequence(s): Determines if the input string is a valid parenthesis sequence. Args: s (str): Input string consisting of characters '(', ')', '{', '}', '[' and ']'. Returns: bool: True if the input string is a valid parenthesis sequence, False otherwise. stack = [] mapping = {')': '(', '}': '{', ']': '['} for char in s: if char in mapping: top_element = stack.pop() if stack else '#' if mapping[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"def isPalindrome(s): Determines if a string is a palindrome, ignoring spaces, punctuation, and capitalization. >>> isPalindrome(\\"A man, a plan, a canal, Panama\\") == True >>> isPalindrome(\\"race a car\\") == False >>> isPalindrome(\\"No lemon, no melon\\") == True >>> isPalindrome(\\"\\") == True >>> isPalindrome(\\"a\\") == True >>> isPalindrome(\\"12321\\") == True >>> isPalindrome(\\"This is not a palindrome\\") == False >>> isPalindrome(\\"Able,, was I ere I saw... elbA!\\") == True","solution":"def isPalindrome(s): Determines if a string is a palindrome, ignoring spaces, punctuation, and capitalization. # Remove all non-alphanumeric characters and convert to lowercase filtered_s = ''.join(char.lower() for char in s if char.isalnum()) # Check if the string reads the same backward as forward return filtered_s == filtered_s[::-1]"},{"question":"def filter_auction_items(N, items): Filters out invalid starting bids and increments based on the given rules. Parameters: N (int): Number of items. items (list of tuples): List of tuples where each tuple contains two integers pi and ii. Returns: list of tuples: Filtered valid starting bids and increments. >>> filter_auction_items(4, [(2, 4), (6, 2), (3, 6), (8, 8)]) [(2, 4), (6, 2), (8, 8)] >>> filter_auction_items(3, [(12, 5), (10, 8), (14, 6)]) [(14, 6)]","solution":"def filter_auction_items(N, items): Filters out invalid starting bids and increments based on the given rules. Parameters: N (int): Number of items. items (list of tuples): List of tuples where each tuple contains two integers pi and ii. Returns: list of tuples: Filtered valid starting bids and increments. valid_items = [] for i in range(N): pi, ii = items[i] if (pi % 2 == 0 and ii % 2 == 0 and (i == 0 or pi > items[i - 1][0])): valid_items.append((pi, ii)) return valid_items # Example usage if __name__ == \\"__main__\\": N = 4 items = [(2, 4), (6, 2), (3, 6), (8, 8)] print(filter_auction_items(N, items)) # Output should be [(2, 4), (6, 2), (8, 8)]"},{"question":"def find_single_element(array): Returns the single element that does not appear twice in the array. >>> find_single_element([4, 1, 2, 1, 2, 4, 5]) == 5 >>> find_single_element([2, 2, 3, 3, 1, 1, 4]) == 4 >>> find_single_element([4]) == 4 >>> find_single_element([-1, -1, -2, -2, -3]) == -3 >>> find_single_element([0, 0, 5]) == 5 def parse_input(input_str): Parses the input string and returns the array of integers. >>> parse_input(\\"7 4 1 2 1 2 4 5\\") == [4, 1, 2, 1, 2, 4, 5] >>> parse_input(\\"3 1 1 3\\") == [1, 1, 3] >>> parse_input(\\"1 5\\") == [5]","solution":"def find_single_element(array): Returns the single element that does not appear twice in the array. xor_result = 0 for num in array: xor_result ^= num return xor_result def parse_input(input_str): Parses the input string and returns the array of integers. parts = input_str.split() n = int(parts[0]) array = list(map(int, parts[1:n + 1])) return array"},{"question":"def can_organize_event(N: int, M: int, capacities: List[int], interests: List[int]) -> str: Determines if the event can be organized such that no activity exceeds its capacity. :param N: Number of employees :param M: Number of activities :param capacities: List of capacities of each activity :param interests: List of interests of each employee :returns: \\"Possible\\" if event can be organized, else \\"Impossible\\" >>> can_organize_event(5, 3, [2, 1, 3], [1, 1, 2, 3, 3]) \\"Possible\\" >>> can_organize_event(5, 3, [1, 1, 3], [1, 1, 2, 3, 3]) \\"Impossible\\" >>> can_organize_event(3, 3, [1, 1, 1], [1, 2, 3]) \\"Possible\\" >>> can_organize_event(0, 3, [1, 1, 1], []) \\"Possible\\" >>> can_organize_event(1, 1, [1], [1]) \\"Possible\\" >>> can_organize_event(3, 1, [2], [1, 1, 1]) \\"Impossible\\" pass","solution":"def can_organize_event(N, M, capacities, interests): Determines if the event can be organized such that no activity exceeds its capacity. :param N: Number of employees :param M: Number of activities :param capacities: List of capacities of each activity :param interests: List of interests of each employee :returns: \\"Possible\\" if event can be organized, else \\"Impossible\\" # Create a list to track the number of employees interested in each activity current_interests = [0] * M # Count the number of employees interested in each activity for interest in interests: current_interests[interest - 1] += 1 # Check if any activity exceeds its capacity for i in range(M): if current_interests[i] > capacities[i]: return \\"Impossible\\" return \\"Possible\\""},{"question":"def find_intersection_and_union(n: int, a: List[int], m: int, b: List[int]) -> Tuple[List[int], List[int]]: Given two sorted lists of integers, find their intersection and union. Parameters: n (int): Number of elements in the first list \`a\`. a (list): The first list of integers. m (int): Number of elements in the second list \`b\`. b (list): The second list of integers. Returns: tuple: A tuple where the first element is a list of intersection and the second element is a list of union. >>> find_intersection_and_union(6, [1, 2, 2, 3, 4, 5], 5, [2, 2, 3, 4, 6]) ([2, 3, 4], [1, 2, 3, 4, 5, 6]) >>> find_intersection_and_union(3, [1, 3, 5], 3, [2, 4, 6]) ([], [1, 2, 3, 4, 5, 6]) >>> find_intersection_and_union(4, [1, 2, 3, 4], 4, [1, 2, 3, 4]) ([1, 2, 3, 4], [1, 2, 3, 4]) >>> find_intersection_and_union(6, [1, 2, 3, 4, 5, 6], 6, [2, 4, 6, 8, 10, 12]) ([2, 4, 6], [1, 2, 3, 4, 5, 6, 8, 10, 12])","solution":"def find_intersection_and_union(n, a, m, b): Given two sorted lists of integers, find their intersection and union. Parameters: n (int): Number of elements in the first list \`a\`. a (list): The first list of integers. m (int): Number of elements in the second list \`b\`. b (list): The second list of integers. Returns: tuple: A tuple where the first element is a list of intersection and the second element is a list of union. set_a = set(a) set_b = set(b) intersection = sorted(list(set_a & set_b)) union = sorted(list(set_a | set_b)) return intersection, union"},{"question":"def pass_the_book(t: int, test_cases: List[Tuple[int, int]]) -> List[List[int]]: Determine the order in which students receive the book. Args: t: the number of test cases. test_cases: a list of tuples, each containing the number of students (n) and the number of passes (k). Returns: A list of lists containing the sequence of student labels in the order they receive the book. >>> pass_the_book(3, [(5, 2), (4, 1), (6, 3)]) [[1, 3, 5, 2, 4], [1, 2, 3, 4], [1, 4, 1, 4, 1, 4]] >>> pass_the_book(1, [(5, 1)]) [[1, 2, 3, 4, 5]] >>> pass_the_book(2, [(3, 3), (6, 5)]) [[1, 1, 1], [1, 6, 5, 4, 3, 2]] >>> pass_the_book(2, [(7, 3), (8, 4)]) [[1, 4, 7, 3, 6, 2, 5], [1, 5, 1, 5, 1, 5, 1, 5]] >>> pass_the_book(1, [(10, 2)]) [[1, 3, 5, 7, 9, 1, 3, 5, 7, 9]]","solution":"def pass_the_book(t, test_cases): results = [] for test in test_cases: n, k = test order = [] current_student = 1 for _ in range(n): order.append(current_student) current_student = (current_student + k - 1) % n + 1 results.append(order) return results"},{"question":"def calculate_final_hay_amount(test_cases): Computes the final amount of hay after processing given instructions for each test case. Arguments: test_cases -- a list of test cases, where each test case is represented as a tuple containing: (number_of_instructions, initial_hay_amount, instructions) \`instructions\` is a list of strings Returns: A list of final hay amounts for each test case. from solution import calculate_final_hay_amount def test_single_test_case(): test_cases = [ (3, 10, [\\"ADD 5\\", \\"MUL 2\\", \\"ADD 3\\"]) ] assert calculate_final_hay_amount(test_cases) == [33] def test_multiple_test_cases(): test_cases = [ (3, 10, [\\"ADD 5\\", \\"MUL 2\\", \\"ADD 3\\"]), (2, 7, [\\"MUL 3\\", \\"ADD 4\\"]) ] assert calculate_final_hay_amount(test_cases) == [33, 25] def test_with_zero_addition(): test_cases = [ (2, 5, [\\"ADD 0\\", \\"MUL 3\\"]) ] assert calculate_final_hay_amount(test_cases) == [15] def test_with_zero_multiplication(): test_cases = [ (2, 5, [\\"MUL 0\\", \\"ADD 4\\"]) ] assert calculate_final_hay_amount(test_cases) == [4] def test_large_numbers(): test_cases = [ (2, 10**6, [\\"MUL 1000\\", \\"ADD 999\\"]) ] expected_result = 10**9 + 999 assert calculate_final_hay_amount(test_cases) == [expected_result]","solution":"def calculate_final_hay_amount(test_cases): Computes the final amount of hay after processing given instructions for each test case. Arguments: test_cases -- a list of test cases, where each test case is represented as a tuple containing: (number_of_instructions, initial_hay_amount, instructions) \`instructions\` is a list of strings Returns: A list of final hay amounts for each test case. results = [] for m, h0, instructions in test_cases: hay_amount = h0 for instruction in instructions: command, x = instruction.split() x = int(x) if command == \\"ADD\\": hay_amount += x elif command == \\"MUL\\": hay_amount *= x results.append(hay_amount) return results"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def buildTree(levelOrder): if not levelOrder or levelOrder[0] == -1: return None root = TreeNode(levelOrder[0]) queue = [root] i = 1 while queue and i < len(levelOrder): current = queue.pop(0) if levelOrder[i] != -1: current.left = TreeNode(levelOrder[i]) queue.append(current.left) i += 1 if i < len(levelOrder) and levelOrder[i] != -1: current.right = TreeNode(levelOrder[i]) queue.append(current.right) i += 1 return root def findTreeHeight(root): Find the height of a given binary tree. Args: root (TreeNode): The root of the binary tree. Returns: int: The height of the binary tree. >>> root = buildTree([3, 9, 20, -1, -1, 15, 7]) >>> findTreeHeight(root) 3 >>> root = buildTree([1, -1, 2, -1, -1]) >>> findTreeHeight(root) 2 def evaluateTestCases(testCases): results = [] for tc in testCases: root = buildTree(tc) height = findTreeHeight(root) results.append(height) return results","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def buildTree(levelOrder): if not levelOrder or levelOrder[0] == -1: return None root = TreeNode(levelOrder[0]) queue = [root] i = 1 while queue and i < len(levelOrder): current = queue.pop(0) if levelOrder[i] != -1: current.left = TreeNode(levelOrder[i]) queue.append(current.left) i += 1 if i < len(levelOrder) and levelOrder[i] != -1: current.right = TreeNode(levelOrder[i]) queue.append(current.right) i += 1 return root def findTreeHeight(root): if not root: return 0 left_height = findTreeHeight(root.left) right_height = findTreeHeight(root.right) return max(left_height, right_height) + 1 def evaluateTestCases(testCases): results = [] for tc in testCases: root = buildTree(tc) height = findTreeHeight(root) results.append(height) return results"},{"question":"def organism_size(D): Calculate the size of the organism at the end of day D. >>> organism_size(0) 1 >>> organism_size(3) 27 >>> organism_size(6) 243 >>> organism_size(7) 1215 def process_test_cases(test_cases): Process multiple test cases. >>> process_test_cases([0, 3, 6, 7]) [1, 27, 243, 1215]","solution":"def organism_size(D): Calculate the size of the organism at the end of day D. if D == 0: return 1 elif 1 <= D <= 5: return 3 ** D else: initial_size = 3 ** 5 # size at the end of day 5 growth_days = (D - 5) // 2 size = initial_size * (5 ** growth_days) return size def process_test_cases(test_cases): Process multiple test cases. results = [] for D in test_cases: results.append(organism_size(D)) return results"},{"question":"def findSubsets(integers: List[int], T: int) -> List[List[int]]: Given a set of N distinct positive integers, find all subsets that sum up to a target integer T. Output all such subsets in any order. Each subset should be represented as a list of integers, and output should be a list of lists. If no such subset exists, return an empty list. >>> findSubsets([1, 2, 3, 4], 5) [[1, 4], [2, 3]] >>> findSubsets([1, 2, 5], 4) [] >>> findSubsets([5], 5) [[5]] >>> findSubsets([4], 5) [] >>> findSubsets([1, 2, 2, 3], 4) [[1, 3], [2, 2]] >>> findSubsets([], 5) [] >>> findSubsets([1000, 2000, 3000], 5000) [[2000, 3000]] >>> findSubsets([1, 2, 3], 6) [[1, 2, 3]] >>> findSubsets([1, 3, 5, 7], 2) []","solution":"def findSubsets(integers, T): Given a set of distinct positive integers, find all subsets that sum up to T. result = [] def backtrack(start, path, target): if target == 0: result.append(path) return elif target < 0: return for i in range(start, len(integers)): backtrack(i + 1, path + [integers[i]], target - integers[i]) backtrack(0, [], T) return result"},{"question":"def exist(grid: List[List[str]], word: str) -> str: Determine if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are horizontally or vertically neighboring. The same letter cell may not be used more than once. >>> grid = [['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']] >>> exist(grid, \\"ABCCED\\") \\"YES\\" >>> grid = [['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']] >>> exist(grid, \\"SEE\\") \\"YES\\" >>> grid = [['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']] >>> exist(grid, \\"ABCB\\") \\"NO\\"","solution":"def exist(grid, word): m, n = len(grid), len(grid[0]) def dfs(x, y, word_index): if word_index == len(word): return True if x < 0 or x >= m or y < 0 or y >= n or grid[x][y] != word[word_index]: return False temp, grid[x][y] = grid[x][y], '#' found = (dfs(x + 1, y, word_index + 1) or dfs(x - 1, y, word_index + 1) or dfs(x, y + 1, word_index + 1) or dfs(x, y - 1, word_index + 1)) grid[x][y] = temp return found for i in range(m): for j in range(n): if dfs(i, j, 0): return \\"YES\\" return \\"NO\\""},{"question":"def findUnique(nums: List[int]) -> int: Returns the element that appears exactly once in the array where each other element appears exactly three times. :param nums: List[int], array of integers where each element appears exactly three times except for one :return: int, the single element that appears only once >>> findUnique([2, 2, 3, 2, 4, 4, 4]) 3 >>> findUnique([0, 1, 0, 1, 0, 1, 50, 77, 77, 77]) 50","solution":"def findUnique(nums): Returns the element that appears exactly once in the array where each other element appears exactly three times. :param nums: List[int], array of integers where each element appears exactly three times except for one :return: int, the single element that appears only once ones, twos = 0, 0 for num in nums: # \`ones & num\` will be the bits that are there in both \`ones\` and current \`num\` twos |= ones & num # XOR the new bits with \`ones\` ones ^= num # \`common_bit_mask\` will be the mask where both \`ones\` and \`twos\` has bits set common_bit_mask = ~(ones & twos) # Remove these bits from \`ones\` ones &= common_bit_mask # Remove these bits from \`twos\` twos &= common_bit_mask return ones"},{"question":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> None: Rotates an n x n matrix by 90 degrees clockwise in place. >>> matrix1 = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate_matrix(matrix1) >>> matrix1 [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> matrix2 = [ ... [ 5, 1, 9, 11], ... [ 2, 4, 8, 10], ... [13, 3, 6, 7], ... [15, 14, 12, 16] ... ] >>> rotate_matrix(matrix2) >>> matrix2 [[15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11]] pass","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> None: Rotates an n x n matrix by 90 degrees clockwise in place. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"def findPair(nums, target): Finds two numbers in the list \`nums\` that add up to \`target\`. If such a pair is found, it returns the pair as a list. If no such pair exists, it returns an empty list. >>> findPair([2, 7, 11, 15], 9) [2, 7] >>> findPair([3, 2, 4], 6) [2, 4] >>> findPair([3, 3], 6) [3, 3] >>> findPair([1, 2, 3], 7) [] >>> findPair([-1, -2, -3, -4, -5], -8) [-3, -5]","solution":"def findPair(nums, target): Finds two numbers in the list \`nums\` that add up to \`target\`. If such a pair is found, it returns the pair as a list. If no such pair exists, it returns an empty list. num_map = {} for num in nums: complement = target - num if complement in num_map: return [complement, num] num_map[num] = True return []"},{"question":"def process_operations(n: int, operations: List[str]) -> List[Union[int, str]]: Process a sequence of list operations and return the results of \\"MAX\\" operations. :param n: Integer, number of operations to be performed. :param operations: List of strings, each representing an operation. :return: List of results for each \\"MAX\\" operation. >>> process_operations(8, [\\"ADD 3\\", \\"ADD 1\\", \\"MAX\\", \\"REMOVE 3\\", \\"MAX\\", \\"ADD 2\\", \\"REMOVE 4\\", \\"MAX\\"]) [3, 1, 2] >>> process_operations(7, [\\"MAX\\", \\"ADD 5\\", \\"ADD 7\\", \\"MAX\\", \\"REMOVE 7\\", \\"REMOVE 5\\", \\"MAX\\"]) [\\"EMPTY\\", 7, \\"EMPTY\\"]","solution":"def process_operations(n, operations): Process a sequence of list operations and return the results of \\"MAX\\" operations. :param n: Integer, number of operations to be performed. :param operations: List of strings, each representing an operation. :return: List of results for each \\"MAX\\" operation. lst = [] results = [] for op in operations: if op.startswith(\\"ADD\\"): x = int(op.split()[1]) lst.append(x) elif op.startswith(\\"REMOVE\\"): x = int(op.split()[1]) if x in lst: lst.remove(x) elif op == \\"MAX\\": if lst: results.append(max(lst)) else: results.append(\\"EMPTY\\") return results"},{"question":"from collections import defaultdict from typing import List, Tuple def find_max_weight_path(t: int, test_cases: List[Tuple[int, List[Tuple[int, int, int]]]]) -> List[int]: Find the maximum weight path that starts at the root (node 1) and ends at any leaf node. Each path visits each node exactly once. >>> find_max_weight_path(1, [(5, [(1, 2, 1), (1, 3, 2), (3, 4, 1), (3, 5, 3)])]) == [5] >>> find_max_weight_path(2, [(5, [(1, 2, 1), (1, 3, 2), (3, 4, 1), (3, 5, 3)]), (3, [(1, 2, 3), (1, 3, 1)])]) == [5, 3]","solution":"from collections import defaultdict, deque def find_max_weight_path(t, test_cases): def dfs(node, parent): max_weight = 0 for neighbor, weight in tree[node]: if neighbor != parent: max_weight = max(max_weight, dfs(neighbor, node) + weight) return max_weight results = [] for n, edges in test_cases: tree = defaultdict(list) for u, v, w in edges: tree[u].append((v, w)) tree[v].append((u, w)) max_path_weight = dfs(1, -1) results.append(max_path_weight) return results # Example usage to fit the problem statement def main(): t = int(input().strip()) test_cases = [] for _ in range(t): n = int(input().strip()) edges = [] for __ in range(n-1): u, v, w = map(int, input().strip().split()) edges.append((u, v, w)) test_cases.append((n, edges)) results = find_max_weight_path(t, test_cases) for result in results: print(result) # Uncomment to run in local # if __name__ == \\"__main__\\": # main()"},{"question":"def reorder_entries(n, positions): Reorders the sequence of numbers from 1 to n based on the provided positions. Parameters: n (int): Number of entries. positions (list): List of integers representing the original positions of the entries. Returns: list: Re-ordered sequence of entries. pass # Examples # reorder_entries(5, [4, 1, 3, 2, 5]) -> [2, 4, 3, 1, 5] # reorder_entries(4, [2, 3, 4, 1]) -> [4, 1, 2, 3] from solution import reorder_entries def test_reorder_entries_example1(): assert reorder_entries(5, [4, 1, 3, 2, 5]) == [2, 4, 3, 1, 5] def test_reorder_entries_example2(): assert reorder_entries(4, [2, 3, 4, 1]) == [4, 1, 2, 3] def test_reorder_entries_single_entry(): assert reorder_entries(1, [1]) == [1] def test_reorder_entries_sorted_order(): assert reorder_entries(3, [1, 2, 3]) == [1, 2, 3] def test_reorder_entries_reverse_order(): assert reorder_entries(4, [4, 3, 2, 1]) == [4, 3, 2, 1]","solution":"def reorder_entries(n, positions): Reorders the sequence of numbers from 1 to n based on the provided positions. Parameters: n (int): Number of entries. positions (list): List of integers representing the original positions of the entries. Returns: list: Re-ordered sequence of entries. ordered_sequence = [0] * n for index, pos in enumerate(positions): ordered_sequence[pos-1] = index + 1 return ordered_sequence"},{"question":"def can_prepare_dish(calories, ingredients): Determine if it's possible to combine a subset of ingredients such that their total calorie count matches the required amount. Args: calories (int): The required total calorie count. ingredients (List[int]): A list of integers representing the calorie counts of available ingredients. Returns: bool: True if it's possible to achieve the exact calorie count, otherwise False. Examples: >>> can_prepare_dish(8, [3, 34, 4, 12, 5, 2]) True >>> can_prepare_dish(30, [3, 34, 4, 12, 5, 2]) False","solution":"def can_prepare_dish(calories, ingredients): Determines if it's possible to combine a subset of ingredients such that their total calorie count matches the required amount. Args: calories (int): The required total calorie count. ingredients (List[int]): A list of integers representing the calorie counts of available ingredients. Returns: bool: True if it's possible to achieve the exact calorie count, otherwise False. n = len(ingredients) # Initialize a list to store whether a specific calorie count can be achieved dp = [False] * (calories + 1) dp[0] = True # 0 calories can always be achieved with an empty subset # Populate the dp array for i in range(n): for j in range(calories, ingredients[i] - 1, -1): if dp[j - ingredients[i]]: dp[j] = True return dp[calories]"},{"question":"def first_non_repeating_character(s: str) -> str: Given an input string consisting of lowercase alphabets and spaces, return the first non-repeating character in the string. If every character in the string repeats, return a single space. Ignore spaces in the string when checking for non-repeating characters. >>> first_non_repeating_character('this is a test string') 'h' >>> first_non_repeating_character('aabbcc') ' '","solution":"def first_non_repeating_character(s): Returns the first non-repeating character in the string s, or a single space if all characters repeat. Spaces in the string are ignored. from collections import OrderedDict char_count = OrderedDict() # Count occurrences of each character ignoring spaces for char in s: if char != ' ': if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find the first non-repeating character for char, count in char_count.items(): if count == 1: return char return ' '"},{"question":"def totalWaterTrapped(A: List[int]) -> int: Returns the total amount of rainwater that can be trapped. Examples: >>> totalWaterTrapped([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> totalWaterTrapped([2, 0, 2]) 2 >>> totalWaterTrapped([0, 3, 0, 5, 0, 3, 0]) 6 >>> totalWaterTrapped([3, 0, 2, 0, 4]) 7 >>> totalWaterTrapped([2, 2, 2, 2, 2]) 0 >>> totalWaterTrapped([0, 1, 2, 3, 4]) 0 >>> totalWaterTrapped([4, 3, 2, 1, 0]) 0","solution":"def totalWaterTrapped(A): Returns the total amount of rainwater that can be trapped. n = len(A) if n <= 2: return 0 left = 0 right = n - 1 left_max = A[left] right_max = A[right] trapped_water = 0 while left < right: if A[left] < A[right]: left += 1 left_max = max(left_max, A[left]) trapped_water += max(0, left_max - A[left]) else: right -= 1 right_max = max(right_max, A[right]) trapped_water += max(0, right_max - A[right]) return trapped_water"},{"question":"def form_balanced_pairs(total_participants: int, skill_levels: List[int]) -> List[Tuple[int, int]]: Forms pairs of participants such that the sum of their skill levels is as balanced as possible. Parameters: total_participants (int): The total number of participants. skill_levels (list of int): The skill levels of the participants. Returns: list of tuple: A list of tuples where each tuple represents a pair of participants. >>> form_balanced_pairs(4, [1, 4, 3, 2]) [(1, 4), (2, 3)] >>> form_balanced_pairs(6, [1, 6, 3, 4, 2, 5]) [(1, 6), (2, 5), (3, 4)]","solution":"def form_balanced_pairs(total_participants, skill_levels): Forms pairs of participants such that the sum of their skill levels is as balanced as possible. Parameters: total_participants (int): The total number of participants. skill_levels (list of int): The skill levels of the participants. Returns: list of tuple: A list of tuples where each tuple represents a pair of participants. sorted_levels = sorted(skill_levels) pairs = [] for i in range(total_participants // 2): pairs.append((sorted_levels[i], sorted_levels[total_participants - 1 - i])) return pairs # Example usage # total_participants = 4 # skill_levels = [1, 4, 3, 2] # output_pairs = form_balanced_pairs(total_participants, skill_levels) # for pair in output_pairs: # print(pair)"},{"question":"def count_vowels(sentences): Returns the number of vowels in each sentence from the given list of sentences. Test cases: >>> count_vowels([\\"Hello world\\"]) [\\"3 vowels\\"] >>> count_vowels([\\"Hello world\\", \\"This is a test\\", \\"Python is fun\\"]) [\\"3 vowels\\", \\"4 vowels\\", \\"3 vowels\\"] >>> count_vowels([\\"\\"]) [\\"0 vowels\\"] >>> count_vowels([\\"bcdfg\\"]) [\\"0 vowels\\"] >>> count_vowels([\\"aeiouAEIOU\\"]) [\\"10 vowels\\"] >>> count_vowels([\\"HeLlO WoRlD\\"]) [\\"3 vowels\\"]","solution":"def count_vowels(sentences): Returns the number of vowels in each sentence from the given list of sentences. vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'} result = [] for sentence in sentences: count = sum(1 for char in sentence if char in vowels) result.append(f\\"{count} vowels\\") return result"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a given arithmetic expression with binary operators + and - without parentheses and returns the result as an integer. Args: expression (str): A string representing the arithmetic expression. Returns: int: The result of evaluating the arithmetic expression. Examples: >>> evaluate_expression(\\"3+5-2\\") 6 >>> evaluate_expression(\\"10-2+4\\") 12 >>> evaluate_expression(\\"100\\") 100","solution":"def evaluate_expression(expression: str) -> int: Evaluates a given arithmetic expression with binary operators + and - without parentheses and returns the result as an integer. # Initiate a variable to store running total total = 0 # Temp string to hold current number being processed num_str = \\"\\" # Last operator we encountered, default to + last_op = '+' # Iterate through the characters in the expression for char in expression: if char.isdigit(): num_str += char # Build the number string else: # Process the number we have collected so far if num_str: num = int(num_str) if last_op == '+': total += num elif last_op == '-': total -= num num_str = \\"\\" # Reset number string for next number # Update last_op to current operator last_op = char # Process the last collected number if num_str: num = int(num_str) if last_op == '+': total += num elif last_op == '-': total -= num return total"},{"question":"def find_and_replace(n: int, text: str, operations: List[Tuple[str, str]]) -> str: Replaces words in the text based on the operations provided. Parameters: n (int): Number of replacement operations. text (str): Original text. operations (list of tuple): List of replacement operations where each is a tuple (target, replacement). Returns: str: Text after performing all replacement operations. >>> find_and_replace(1, \\"hello world\\", [(\\"world\\", \\"planet\\")]) 'hello planet' >>> find_and_replace(2, \\"this is a test. this example, is simple!\\", [(\\"is\\", \\"was\\"), (\\"this\\", \\"that\\")]) 'that was a test. that example, was simple!' >>> find_and_replace(1, \\"no match here\\", [(\\"absent\\", \\"present\\")]) 'no match here' >>> find_and_replace(1, \\"an example: he is here!\\", [(\\"he\\", \\"she\\")]) 'an example: she is here!' >>> find_and_replace(1, \\"standing and understanding\\", [(\\"stand\\", \\"sit\\")]) 'standing and understanding' >>> find_and_replace(2, \\"overlap overlap\\", [(\\"over\\", \\"under\\"), (\\"overlap\\", \\"nod\\")]) 'nod nod' >>> find_and_replace(1, \\"a\\" * 10000, [(\\"a\\" * 9, \\"b\\")]) 'a' * 10000","solution":"import re def find_and_replace(n, text, operations): Replaces words in the text based on the operations provided. Parameters: n (int): Number of replacement operations. text (str): Original text. operations (list of tuple): List of replacement operations where each is a tuple (target, replacement). Returns: str: Text after performing all replacement operations. for target, replacement in operations: pattern = rf\\"b{re.escape(target)}b\\" text = re.sub(pattern, replacement, text) return text"},{"question":"def has_pair_with_sum(arr: List[int], k: int) -> str: Determines if there exists a pair of distinct indices \`i\` and \`j\` such that arr[i] + arr[j] == k. Parameters: arr (list): List of integers. k (int): Target sum. Returns: str: \\"yes\\" if such a pair exists, otherwise \\"no\\". >>> has_pair_with_sum([2, 7, 11, 15, 1], 9) \\"yes\\" >>> has_pair_with_sum([1, 2, 3, 4, 5], 10) \\"no\\" >>> has_pair_with_sum([-1, -2, -3, -4, 8], 5) \\"yes\\" >>> has_pair_with_sum([1, -2, 3, 10, -3, 5], 7) \\"yes\\" >>> has_pair_with_sum(list(range(1, 10001)), 19999) \\"yes\\" >>> has_pair_with_sum(list(range(1, 10001)), 20001) \\"no\\" >>> has_pair_with_sum([4, 4, 1, -1], 0) \\"yes\\" # Implementation here","solution":"def has_pair_with_sum(arr, k): Determines if there exists a pair of distinct indices \`i\` and \`j\` such that arr[i] + arr[j] == k. Parameters: arr (list): List of integers. k (int): Target sum. Returns: str: \\"yes\\" if such a pair exists, otherwise \\"no\\". seen = set() for number in arr: if k - number in seen: return \\"yes\\" seen.add(number) return \\"no\\""},{"question":"from typing import List, Tuple class SegmentTree: def __init__(self, data: List[int]): pass def build(self, data: List[int]): pass def update(self, pos: int, value: int): pass def query(self, left: int, right: int) -> int: pass def process_queries(n: int, q: int, array: List[int], queries: List[Tuple[int, int, int]]) -> List[int]: Perform a series of update and sum queries on an array. Args: n (int): Number of elements in the array. q (int): Number of queries. array (List[int]): The initial array of integers. queries (List[Tuple[int, int, int]]): A list of queries. Returns: List[int]: The results of sum queries. >>> process_queries(5, 5, [1, 2, 3, 4, 5], [(2, 1, 3), (1, 3, 10), (2, 2, 4), (1, 5, -1), (2, 4, 5)]) [6, 16, 3] >>> process_queries(4, 2, [1, 2, 3, 4], [(1, 3, 8), (2, 1, 4)]) [15] >>> process_queries(3, 1, [1, 2, 3], [(2, 1, 3)]) [6] >>> process_queries(3, 0, [1, 2, 3], []) [] >>> process_queries(5, 4, [1, 3, 5, 7, 9], [(1, 1, 2), (1, 5, 10), (2, 1, 5), (2, 1, 3)]) [27, 10]","solution":"class SegmentTree: def __init__(self, data): n = len(data) self.n = n self.tree = [0] * (2 * n) self.build(data) def build(self, data): for i in range(self.n): self.tree[self.n + i] = data[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1] def update(self, pos, value): pos += self.n self.tree[pos] = value while pos > 1: pos //= 2 self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1] def query(self, left, right): result = 0 left += self.n right += self.n while left < right: if left % 2: result += self.tree[left] left += 1 if right % 2: right -= 1 result += self.tree[right] left //= 2 right //= 2 return result def process_queries(n, q, array, queries): segment_tree = SegmentTree(array) results = [] for query in queries: if query[0] == 1: _, i, x = query segment_tree.update(i - 1, x) elif query[0] == 2: _, l, r = query result = segment_tree.query(l - 1, r) results.append(result) return results"},{"question":"def will_birds_migrate(test_cases): Determine if birds will migrate based on weather patterns. Args: test_cases: List of tuples, where each tuple contains: N: Length of binary string (int) L: Length of the subsequence (int) binary_string: String of binary digits Returns: List of strings: \\"YES\\" if birds will migrate, otherwise \\"NO\\" >>> will_birds_migrate([(7, 3, '1011010'), (5, 2, '01101'), (6, 4, '000011')]) [\\"YES\\", \\"YES\\", \\"NO\\"] pass def parse_input(input_data): Parse input data into structured test cases. Args: input_data: String representing the raw input data Returns: List of tuples containing parsed test case information >>> parse_input(\\"3n7 3n1011010n5 2n01101n6 4n000011n\\") [(7, 3, '1011010'), (5, 2, '01101'), (6, 4, '000011')] pass def solution(input_data): Solve the problem using the parsed input data. Args: input_data: String representing the raw input data Returns: String: \\"YES\\" or \\"NO\\" for each test case, separated by newline >>> solution(\\"3n7 3n1011010n5 2n01101n6 4n000011n\\") \\"YESnYESnNO\\" pass","solution":"def will_birds_migrate(test_cases): results = [] for case in test_cases: N, L, binary_string = case found = False for i in range(N - L + 1): substring = binary_string[i:i + L] if substring.count('1') > substring.count('0'): found = True break results.append(\\"YES\\" if found else \\"NO\\") return results def parse_input(input_data): lines = input_data.strip().split('n') T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): N, L = map(int, lines[index].split()) binary_string = lines[index + 1] test_cases.append((N, L, binary_string)) index += 2 return test_cases def solution(input_data): test_cases = parse_input(input_data) results = will_birds_migrate(test_cases) return \\"n\\".join(results)"},{"question":"from typing import List def can_reach_target(target: int, initial_fuel: int, fuel_per_station: int, fuel_stations: List[int], obstacles: List[int]) -> bool: Determine if it's possible to reach the target position without hitting obstacles or running out of fuel. >>> can_reach_target(20, 10, 10, [5, 15, 25], [10, 30]) == True >>> can_reach_target(30, 10, 10, [5, 15, 25], [10, 20]) == False :param target: The target position you want to reach. :param initial_fuel: The initial amount of fuel. :param fuel_per_station: The amount of fuel acquired at each fuel station. :param fuel_stations: The positions of the fuel stations. :param obstacles: The positions of the obstacles. :return: True if it's possible to reach the target position without hitting obstacles or running out of fuel, otherwise False. def test_can_reach_target_success_no_obstacles(): assert can_reach_target(20, 10, 10, [5, 15, 25], []) == True def test_can_reach_target_hit_obstacle(): assert can_reach_target(20, 10, 10, [5, 15, 25], [10, 20]) == False def test_can_reach_target_run_out_of_fuel(): assert can_reach_target(30, 10, 10, [5, 15, 25], [10, 20]) == False def test_can_reach_target_negative_target_no_obstacles(): assert can_reach_target(-20, 10, 10, [-5, -15, -25], []) == True def test_can_reach_target_negative_target_with_obstacles(): assert can_reach_target(-20, 10, 10, [-5, -15, -25], [-10, -20]) == False def test_can_reach_target_no_fuel_stations(): assert can_reach_target(5, 5, 10, [], []) == True def test_can_reach_target_large_distance_with_fuel_stations(): assert can_reach_target(100, 10, 10, list(range(10, 100, 10)), []) == True def test_can_reach_target_large_distance_with_obstacles(): assert can_reach_target(100, 10, 10, list(range(10, 100, 10)), [50]) == False","solution":"from typing import List def can_reach_target(target: int, initial_fuel: int, fuel_per_station: int, fuel_stations: List[int], obstacles: List[int]) -> bool: fuel_stations_set = set(fuel_stations) obstacles_set = set(obstacles) current_position = 0 current_fuel = initial_fuel step = 1 if target > 0 else -1 while current_position != target: # Move one step towards the target current_position += step current_fuel -= 1 # Check if we've hit an obstacle if current_position in obstacles_set: return False # Check if we run out of fuel if current_fuel < 0: return False # Refuel at fuel stations if current_position in fuel_stations_set: current_fuel += fuel_per_station return True"},{"question":"def find_min_max(arr, N): Finds the minimum and maximum number in an array. Parameters: arr (list): List of integers. N (int): Number of elements in the list. Returns: list: A list containing the minimum and maximum number. Example: >>> find_min_max([1, 3, 5, 7, 9], 5) [1, 9] >>> find_min_max([2, 4, 6, 8, 10, 12], 6) [2, 12]","solution":"def find_min_max(arr, N): Finds the minimum and maximum number in an array. Parameters: arr (list): List of integers. N (int): Number of elements in the list. Returns: list: A list containing the minimum and maximum number. if not arr or N <= 0: return [None, None] min_num = float('inf') max_num = float('-inf') for num in arr: if num < min_num: min_num = num if num > max_num: max_num = num return [min_num, max_num]"},{"question":"from typing import List from collections import Counter def can_rearrange(S: str) -> str: Determine if it is possible to rearrange the characters of S in such a way that every adjacent pair of characters are different. >>> can_rearrange(\\"aabb\\") \\"YES\\" >>> can_rearrange(\\"aaab\\") \\"NO\\" >>> can_rearrange(\\"a\\") \\"YES\\" >>> can_rearrange(\\"abcdefgh\\") \\"YES\\"","solution":"from collections import Counter def can_rearrange(S: str) -> str: Determine if it is possible to rearrange the characters of S so that no two adjacent characters are the same. count = Counter(S) max_count = max(count.values()) if max_count > (len(S) + 1) // 2: return \\"NO\\" return \\"YES\\""},{"question":"def adjust_brightness(cases: List[Tuple[int, int, int, int]]) -> List[Tuple[int, int, int]]: Adjust the brightness of each pixel's color in the image. Each RGB color value is represented by three integers ranging from 0 to 255, inclusive, representing the Red, Green, and Blue components of the color. Brightness adjustment is done by adding the same integer value to each of the R, G, and B components. Args: cases (List[Tuple[int, int, int, int]]): A list of tuples where each tuple contains four integers. The first three integers represent the RGB values of a color, and the fourth integer represents the brightness adjustment. Returns: List[Tuple[int, int, int]]: A list of tuples where each tuple contains the adjusted RGB values. >>> adjust_brightness([(50, 100, 150, 10), (255, 250, 245, -10), (0, 0, 0, 50)]) [(60, 110, 160), (245, 240, 235), (50, 50, 50)] # Test cases def test_adjust_brightness(): cases = [(50, 100, 150, 10), (255, 250, 245, -10), (0, 0, 0, 50)] results = adjust_brightness(cases) assert results == [(60, 110, 160), (245, 240, 235), (50, 50, 50)] def test_brighten_to_max(): cases = [(250, 250, 250, 10), (245, 245, 245, 20)] results = adjust_brightness(cases) assert results == [(255, 255, 255), (255, 255, 255)] def test_darken_to_min(): cases = [(10, 10, 10, -20), (5, 5, 5, -10)] results = adjust_brightness(cases) assert results == [(0, 0, 0), (0, 0, 0)] def test_no_adjustment(): cases = [(120, 130, 140, 0), (255, 0, 0, 0)] results = adjust_brightness(cases) assert results == [(120, 130, 140), (255, 0, 0)]","solution":"def adjust_brightness(cases): def clamp(value): if value < 0: return 0 elif value > 255: return 255 return value results = [] for case in cases: R, G, B, adjustment = case new_R = clamp(R + adjustment) new_G = clamp(G + adjustment) new_B = clamp(B + adjustment) results.append((new_R, new_G, new_B)) return results"},{"question":"def minimum_cost(M: int, C: int, D: int) -> int: Returns the minimum cost to buy M cakes using either of the two discount plans. Plan 1: Every third cake is free. You pay for 2 out of every 3 cakes. Plan 2: You get a discount of C yen on each cake's original price D yen. >>> minimum_cost(9, 5, 20) 120 >>> minimum_cost(1, 1, 2) 1 >>> minimum_cost(2, 3, 10) 14 >>> minimum_cost(6, 2, 10) 40 >>> minimum_cost(10, 3, 7) 40 >>> minimum_cost(3, 1, 3) 6 >>> minimum_cost(20, 10, 20) 200","solution":"def minimum_cost(M, C, D): Returns the minimum cost to buy M cakes using either of the two discount plans. Plan 1: Every third cake is free. You pay for 2 out of every 3 cakes. Plan 2: You get a discount of C yen on each cake's original price D yen. # Plan 1: Calculate the cost when every third cake is free. full_price_cakes = (M // 3) * 2 + (M % 3) cost_plan1 = full_price_cakes * D # Plan 2: Calculate the cost with a discount of C yen per cake. cost_plan2 = M * (D - C) # Return the minimum cost of the two plans. return min(cost_plan1, cost_plan2)"},{"question":"from typing import List, Tuple def min_moves_to_interest(n: int, m: int, grid: List[str], sx: int, sy: int) -> int: Calculate the minimal number of moves to the nearest point of interest from starting position on grid. Arguments: n -- the number of rows in the grid m -- the number of columns in the grid grid -- a list of strings representing the grid sx -- the starting x-coordinate sy -- the starting y-coordinate Returns: int -- the minimal number of moves to the nearest point of interest, or -1 if unreachable >>> min_moves_to_interest(3, 3, [\\"..*\\", \\".#.\\", \\".*.\\"], 0, 0) 2 >>> min_moves_to_interest(3, 3, [\\"..#\\", \\".#.\\", \\".#.\\"], 0, 0) -1 pass def process_test_cases(t: int, test_cases: List[Tuple[int, int, List[str], int, int]]) -> List[int]: Process multiple test cases for minimal move calculation to the nearest point of interest. Arguments: t -- the number of test cases test_cases -- a list of tuples, each containing: - n (int): number of rows in the grid - m (int): number of columns in the grid - grid (List[str]): the grid representation - sx (int): starting x-coordinate - sy (int): starting y-coordinate Returns: List[int] -- a list of results for each test case >>> process_test_cases(2, [(3, 3, [\\"..*\\", \\".#.\\", \\".*.\\"], 0, 0), (3, 3, [\\"..#\\", \\".#.\\", \\".#.\\"], 0, 0)]) [2, -1] pass # Unit Tests def test_min_moves_to_interest(): n, m = 3, 3 grid = [\\"..*\\", \\".#.\\", \\".*.\\"] sx, sy = 0, 0 assert min_moves_to_interest(n, m, grid, sx, sy) == 2 n, m = 3, 3 grid = [\\"..#\\", \\".#.\\", \\".#.\\"] sx, sy = 0, 0 assert min_moves_to_interest(n, m, grid, sx, sy) == -1 n, m = 1, 1 grid = [\\"*\\"] sx, sy = 0, 0 assert min_moves_to_interest(n, m, grid, sx, sy) == 0 def test_process_test_cases(): t = 2 test_cases = [ (3, 3, [\\"..*\\", \\".#.\\", \\".*.\\"], 0, 0), (3, 3, [\\"..#\\", \\".#.\\", \\".#.\\"], 0, 0) ] results = process_test_cases(t, test_cases) assert results == [2, -1] t = 1 test_cases = [ (1, 1, [\\"*\\"], 0, 0) ] results = process_test_cases(t, test_cases) assert results == [0] def test_edge_cases(): n, m = 1, 1 grid = [\\"*\\"] sx, sy = 0, 0 assert min_moves_to_interest(n, m, grid, sx, sy) == 0 n, m = 1, 1 grid = [\\".\\"] sx, sy = 0, 0 assert min_moves_to_interest(n, m, grid, sx, sy) == -1","solution":"from collections import deque def min_moves_to_interest(n, m, grid, sx, sy): # Directions for right, left, down, up directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] # Check if the starting point is the point of interest if grid[sx][sy] == '*': return 0 queue = deque([(sx, sy, 0)]) # (x, y, distance) visited = set() visited.add((sx, sy)) while queue: x, y, dist = queue.popleft() # Explore in all four directions for dx, dy in directions: nx, ny = x + dx, y + dy # Check if new position is within bounds and not an obstacle if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] != '#': if grid[nx][ny] == '*': return dist + 1 queue.append((nx, ny, dist + 1)) visited.add((nx, ny)) return -1 def process_test_cases(t, test_cases): results = [] for case in test_cases: n, m, grid, sx, sy = case results.append(min_moves_to_interest(n, m, grid, sx, sy)) return results"},{"question":"def find_median(lst): Returns the median value of a list of integers. If the list is empty, returns None. If the list has an even number of elements, returns the average of the two middle numbers. Examples: >>> find_median([1, 2, 3, 4, 5]) 3 >>> find_median([10, 20, 30, 40]) 25.0 >>> find_median([]) None pass import pytest def test_find_median_odd(): assert find_median([1, 2, 3, 4, 5]) == 3 def test_find_median_even(): assert find_median([10, 20, 30, 40]) == 25.0 def test_find_median_empty(): assert find_median([]) == None def test_find_median_single_element(): assert find_median([10]) == 10 def test_find_median_two_elements(): assert find_median([10, 20]) == 15.0 def test_find_median_unsorted(): assert find_median([40, 10, 30, 20]) == 25.0 def test_find_median_with_negative_numbers(): assert find_median([3, -2, 1, 4, -1]) == 1","solution":"def find_median(lst): Returns the median value of a list of integers. If the list is empty, returns None. If the list has an even number of elements, returns the average of the two middle values. if not lst: return None lst.sort() n = len(lst) mid = n // 2 if n % 2 == 0: # If even number of elements return (lst[mid - 1] + lst[mid]) / 2.0 else: # If odd number of elements return lst[mid]"},{"question":"def roman_to_int(roman: str) -> int: Convert a Roman numeral to an integer. :param roman: str, string representation of a Roman numeral :return: int, the integer representation of the Roman numeral Example: >>> roman_to_int('MMXVIII') 2018 >>> roman_to_int('IV') 4 >>> roman_to_int('CDXLIV') 444","solution":"def roman_to_int(roman): Convert a Roman numeral to an integer. :param roman: str, string representation of a Roman numeral :return: int, the integer representation of the Roman numeral roman_to_value = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 } total = 0 prev_value = 0 for char in reversed(roman): value = roman_to_value[char] if value >= prev_value: total += value else: total -= value prev_value = value return total"},{"question":"def can_sort_by_subarray_reversal(t: int, cases: List[Tuple[int, List[int]]]) -> List[str]: Determine if it's possible to sort the array in non-decreasing order using the allowed subarray reversal operation. >>> can_sort_by_subarray_reversal(1, [(3, [3, 1, 2])]) [\\"YES\\"] >>> can_sort_by_subarray_reversal(1, [(5, [4, 3, 2, 1, 5])]) [\\"NO\\"] >>> can_sort_by_subarray_reversal(1, [(4, [1, 3, 2, 4])]) [\\"YES\\"]","solution":"def can_sort_by_subarray_reversal(t, cases): results = [] for i in range(t): n, a = cases[i] sorted_a = sorted(a) # We need to see if we can transform \`a\` to \`sorted_a\` possible = False for j in range(n - 2): if sorted_a[j:j+3] == sorted(a[j:j+3]): possible = True break if possible or a == sorted_a: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def max_magic_power(n: int, a: List[int]) -> int: Returns the maximum sum of a segment of consecutive houses. >>> max_magic_power(5, [-3, 2, -1, 4, -5]) 5 >>> max_magic_power(8, [1, -2, 3, 5, -1, 2, -1, 4]) 12","solution":"def max_magic_power(n, a): Returns the maximum sum of a segment of consecutive houses. max_sum = current_sum = a[0] for i in range(1, n): current_sum = max(a[i], current_sum + a[i]) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def additional_employees_needed(n: int, log: str) -> int: Determine the minimum number of additional employees needed to ensure that future events can be properly hosted. Parameters: n (int): The number of employees. log (str): A string representing employees participation in past events ('H' for hosts and 'G' for guests). Returns: int: The minimum number of additional employees needed. Examples: >>> additional_employees_needed(5, 'HHHHH') 1 >>> additional_employees_needed(4, 'GGGG') 1 >>> additional_employees_needed(3, 'HGH') 0","solution":"def additional_employees_needed(n, log): Determine the minimum number of additional employees needed to ensure that future events can be properly hosted. Parameters: n (int): The number of employees. log (str): A string representing employees participation in past events ('H' for hosts and 'G' for guests). Returns: int: The minimum number of additional employees needed. has_host = 'H' in log has_guest = 'G' in log if has_host and has_guest: return 0 elif has_host: return 1 elif has_guest: return 1 else: return 2"},{"question":"def process_queries(E, M, T, projects, Q, queries): Determine the bonus eligibility of employees based on their project completion records. Args: E (int): Number of employees. M (int): Number of months. T (int): Bonus threshold. projects (List[List[int]]): Project completion record for each employee. Q (int): Number of queries. queries (List[str]): List of queries. Returns: List[str]: List of results for each query of type 1, either \\"ELIGIBLE\\" or \\"NOT ELIGIBLE\\". Examples: >>> process_queries(3, 5, 3, [ [1, 0, 1, 1, 0], [0, 1, 1, 0, 0], [1, 1, 0, 1, 1]], 4, [\\"1 1 4\\", \\"2 2 1\\", \\"1 2 3\\", \\"1 3 5\\"]) [\\"ELIGIBLE\\", \\"NOT ELIGIBLE\\", \\"ELIGIBLE\\"] >>> process_queries(1, 1, 1, [[1]], 1, [\\"1 1 1\\"]) [\\"ELIGIBLE\\"] >>> process_queries(2, 2, 1, [ [0, 1], [1, 0]], 3, [\\"1 1 2\\", \\"2 1 1\\", \\"1 1 2\\"]) [\\"ELIGIBLE\\", \\"ELIGIBLE\\"]","solution":"def process_queries(E, M, T, projects, Q, queries): results = [] for query in queries: operation = query.split() type_k = int(operation[0]) if type_k == 1: employee = int(operation[1]) till_month = int(operation[2]) project_sum = sum(projects[employee - 1][:till_month]) if project_sum >= T: results.append(\\"ELIGIBLE\\") else: results.append(\\"NOT ELIGIBLE\\") elif type_k == 2: employee = int(operation[1]) project_status = int(operation[2]) projects[employee - 1][-1] = project_status return results"},{"question":"def most_visited_book(browsing_history: list) -> int: Returns the ID of the book that has been visited the most. If there is a tie (i.e., multiple books have been visited the same maximum number of times), returns the smallest book ID. >>> most_visited_book([1, 2, 1, 2, 3, 1, 3, 1, 2, 2]) == 1 >>> most_visited_book([4, 5, 4, 5, 6]) == 4 >>> most_visited_book([1, 2, 3, 1, 1, 2]) == 1","solution":"def most_visited_book(browsing_history: list) -> int: Returns the ID of the most visited book. If multiple books have been visited the same maximum number of times, returns the smallest book ID. from collections import Counter # Count the occurrences of each book ID book_count = Counter(browsing_history) # Find the maximum visit count max_visits = max(book_count.values()) # Filter the book IDs that have the maximum visit count most_visited_books = [book_id for book_id, count in book_count.items() if count == max_visits] # Return the smallest book ID among those return min(most_visited_books)"},{"question":"def is_happy_number(num: int) -> bool: Determines whether the sequence starting with the given number results in it being a happy number. A happy number is defined as a number that eventually reaches 1 when replaced by the sum of the square of each digit. A sad number enters a repeating cycle that does not include 1. Args: - num: positive integer to check for happiness Returns: - bool: True if num is a happy number, False otherwise >>> is_happy_number(19) # True because the sequence is 19 -> 82 -> 68 -> 100 -> 1 >>> is_happy_number(7) # True because the sequence is 7 -> 49 -> 97 -> 130 -> 10 -> 1 >>> is_happy_number(4) # False because the sequence is 4 -> 16 -> 37 -> 58 -> 89 -> 145 -> 42 -> 20 -> 4 (cycle)","solution":"def is_happy_number(num): Determines whether the sequence starting with the given number results in it being a happy number. A happy number is defined as a number that eventually reaches 1 when replaced by the sum of the square of each digit. A sad number enters a repeating cycle that does not include 1. Args: - num: positive integer to check for happiness Returns: - bool: True if num is a happy number, False otherwise def sum_of_squares(n): return sum(int(digit)**2 for digit in str(n)) seen = set() while num != 1 and num not in seen: seen.add(num) num = sum_of_squares(num) return num == 1"},{"question":"def process_operations(n: int, arr: List[int], q: int, operations: List[str]) -> List[int]: Processes a list of operations on an array. The operations include updating elements and querying sums of subarrays. Parameters: n (int): Size of the array. arr (list of int): Initial array of integers. q (int): Number of operations. operations (list of str): List of operations in the format \\"U x y\\" or \\"S l r\\". Returns: list of int: The results of the sum queries. >>> n = 5 >>> arr = [1, 2, 3, 4, 5] >>> q = 3 >>> operations = ['U 3 10', 'S 2 4', 'S 1 5'] >>> process_operations(n, arr, q, operations) [16, 22] from solution import process_operations def test_process_operations(): # Test case 1 n = 5 arr = [1, 2, 3, 4, 5] q = 3 operations = ['U 3 10', 'S 2 4', 'S 1 5'] assert process_operations(n, arr, q, operations) == [16, 22] # Test case 2 - no operation n = 3 arr = [1, 1, 1] q = 0 operations = [] assert process_operations(n, arr, q, operations) == [] # Test case 3 - multiple updates and single query n = 4 arr = [4, 6, 7, 3] q = 5 operations = ['U 1 1', 'U 4 2', 'U 2 5', 'U 3 8', 'S 1 4'] assert process_operations(n, arr, q, operations) == [16] # Test case 4 - Single element array n = 1 arr = [99] q = 2 operations = ['S 1 1', 'U 1 1', 'S 1 1'] assert process_operations(n, arr, q, operations) == [99, 1] # Test case 5 - Continuous updates n = 2 arr = [5, 10] q = 6 operations = ['S 1 2', 'U 2 20', 'S 1 2', 'U 1 0', 'S 1 2', 'S 1 1'] assert process_operations(n, arr, q, operations) == [15, 25, 20, 0] def test_process_operations_edge_cases(): # Edge case with maximal values n = 10**5 arr = [10**9] * n q = 10 operations = ['S 1 100000'] + ['U 1 999999999'] * (q - 1) assert process_operations(n, arr, q, operations) == [10**9 * 10**5] def test_process_operations_minimal_values(): n = 1 arr = [1] q = 1 operations = ['S 1 1'] assert process_operations(n, arr, q, operations) == [1] def test_process_operations_large_range(): n = 100 arr = list(range(1, 101)) # [1, 2, ..., 100] q = 2 operations = ['S 1 50', 'S 51 100'] assert process_operations(n, arr, q, operations) == [1275, 3775]","solution":"def process_operations(n, arr, q, operations): Processes a list of operations on an array. The operations include updating elements and querying sums of subarrays. Parameters: n (int): Size of the array. arr (list of int): Initial array of integers. q (int): Number of operations. operations (list of str): List of operations in the format \\"U x y\\" or \\"S l r\\". Returns: list of int: The results of the sum queries. results = [] for op in operations: parts = op.split() if parts[0] == 'U': x, y = int(parts[1]), int(parts[2]) arr[x-1] = y elif parts[0] == 'S': l, r = int(parts[1]), int(parts[2]) results.append(sum(arr[l-1:r])) return results"},{"question":"def flatten_dictionary(d, delimiter='.'): Flatten a nested dictionary. The keys in the nested dictionary can be concatenated into a single key with each level separated by a delimiter. Args: d (dict): The dictionary to flatten. delimiter (str): The delimiter to use for concatenating keys. Returns: dict: A flattened dictionary with concatenated keys. >>> flatten_dictionary({ \\"a\\": 1, \\"b\\": { \\"c\\": 2, \\"d\\": { \\"e\\": 3 } } }) == { \\"a\\": 1, \\"b.c\\": 2, \\"b.d.e\\": 3 } >>> flatten_dictionary({ \\"a\\": 1, \\"b\\": { \\"c\\": 2, \\"d\\": { \\"e\\": 3 } } }, delimiter='-') == { \\"a\\": 1, \\"b-c\\": 2, \\"b-d-e\\": 3 } def test_flatten_simple(): assert flatten_dictionary({\\"a\\": 1, \\"b\\": 2}) == {\\"a\\": 1, \\"b\\": 2} def test_flatten_nested(): assert flatten_dictionary({ \\"a\\": 1, \\"b\\": { \\"c\\": 2, \\"d\\": { \\"e\\": 3 } } }) == { \\"a\\": 1, \\"b.c\\": 2, \\"b.d.e\\": 3 } def test_flatten_with_different_delimiter(): assert flatten_dictionary({ \\"a\\": 1, \\"b\\": { \\"c\\": 2, \\"d\\": { \\"e\\": 3 } } }, delimiter='-') == { \\"a\\": 1, \\"b-c\\": 2, \\"b-d-e\\": 3 } def test_flatten_empty_dict(): assert flatten_dictionary({}) == {} def test_flatten_single_nested(): assert flatten_dictionary({ \\"a\\": { \\"b\\": 1 } }) == { \\"a.b\\": 1 } def test_flatten_multiple_nested(): assert flatten_dictionary({ \\"a\\": { \\"b\\": { \\"c\\": 2 }, \\"d\\": 1 }, \\"e\\": { \\"f\\": 3 } }) == { \\"a.b.c\\": 2, \\"a.d\\": 1, \\"e.f\\": 3 }","solution":"def flatten_dictionary(d, delimiter='.'): def flatten(current_item, parent_key=''): items = [] for k, v in current_item.items(): new_key = f\\"{parent_key}{delimiter}{k}\\" if parent_key else k if isinstance(v, dict): items.extend(flatten(v, new_key).items()) else: items.append((new_key, v)) return dict(items) return flatten(d)"},{"question":"def total_cost_for_cows(T, test_cases): Calculate the total cost for each test case. Parameters: T (int): number of test cases. test_cases (list of tuples): Each tuple contains three integers N, P, Q. Returns: list: total costs for each test case. pass def test_total_cost_for_cows(): T = 3 test_cases = [ (2, 300, 50), (3, 400, 70), (1, 500, 100) ] expected = [700, 1410, 600] result = total_cost_for_cows(T, test_cases) assert result == expected def test_total_cost_for_cows_single_test_case(): T = 1 test_cases = [ (5, 200, 20) ] expected = [1100] result = total_cost_for_cows(T, test_cases) assert result == expected def test_total_cost_for_cows_with_zeroes(): T = 2 test_cases = [ (0, 300, 50), # N is 0, so total cost is 0 (4, 0, 50) # P is 0, so total cost is 4 * 50 = 200 ] expected = [0, 200] result = total_cost_for_cows(T, test_cases) assert result == expected def test_total_cost_for_cows_large_numbers(): T = 2 test_cases = [ (100, 1000, 1000), (100, 500, 500) ] expected = [200000, 100000] result = total_cost_for_cows(T, test_cases) assert result == expected","solution":"def total_cost_for_cows(T, test_cases): Calculate the total cost for each test case. Parameters: T (int): number of test cases. test_cases (list of tuples): Each tuple contains three integers N, P, Q. Returns: list: total costs for each test case. total_costs = [] for i in range(T): N, P, Q = test_cases[i] total_cost = N * (P + Q) total_costs.append(total_cost) return total_costs"},{"question":"def check_assignments(T: str) -> str: Determines if there is at least one pair of students that will be assigned a project together. :param T: A string of length 3 representing the enrollment status of three students. :return: \\"Yes\\" if there is at least one pair of students that will be assigned a project together, otherwise \\"No\\". >>> check_assignments(\\"MSA\\") == \\"Yes\\" >>> check_assignments(\\"SAM\\") == \\"Yes\\" >>> check_assignments(\\"ASM\\") == \\"Yes\\" >>> check_assignments(\\"MMS\\") == \\"Yes\\" >>> check_assignments(\\"SSA\\") == \\"Yes\\" >>> check_assignments(\\"AAM\\") == \\"Yes\\" >>> check_assignments(\\"MMM\\") == \\"No\\" >>> check_assignments(\\"SSS\\") == \\"No\\" >>> check_assignments(\\"AAA\\") == \\"No\\" >>> check_assignments(\\"MMA\\") == \\"Yes\\" >>> check_assignments(\\"MSS\\") == \\"Yes\\"","solution":"def check_assignments(T): Determines if there is at least one pair of students that will be assigned a project together. :param T: A string of length 3 representing the enrollment status of three students. :return: \\"Yes\\" if there is at least one pair of students that will be assigned a project together, otherwise \\"No\\". if len(set(T)) > 1: return \\"Yes\\" return \\"No\\""},{"question":"def balance_batteries(n, batteries): Returns the minimum possible difference between the most and the least charged battery after redistributing the power units. >>> balance_batteries(3, [1, 6, 3]) 1 >>> balance_batteries(4, [10, 10, 10, 10]) 0 >>> balance_batteries(5, [3, 1, 4, 1, 5]) 1","solution":"def balance_batteries(n, batteries): Returns the minimum possible difference between the most and the least charged battery after redistributing the power units. total_power = sum(batteries) avg_power = total_power // n remainder = total_power % n # In case of exact divisibility, all batteries can have avg_power units, so difference is 0. if remainder == 0: return 0 # Distribute the power optimally more_power_batteries = n - remainder less_power_batteries = remainder return 1 # The difference will be just 1 unit in the worst balanced scenario # Example usage: print(balance_batteries(3, [1, 6, 3])) # Output: 1 print(balance_batteries(4, [10, 10, 10, 10])) # Output: 0 print(balance_batteries(5, [3, 1, 4, 1, 5])) # Output: 1"},{"question":"def evaluate_arithmetic_expression(expression: str) -> float: Evaluates an arithmetic expression in infix notation and returns the result as a float. >>> evaluate_arithmetic_expression(\\"3 + 5\\") 8.0 >>> evaluate_arithmetic_expression(\\"10 + 2 * 6\\") 22.0 >>> evaluate_arithmetic_expression(\\"100 * 2 + 12\\") 212.0 >>> evaluate_arithmetic_expression(\\"100 * (2 + 12)\\") 1400.0 >>> evaluate_arithmetic_expression(\\"100 * (2 + 12) / 14\\") 100.0","solution":"def evaluate_arithmetic_expression(expression): Evaluates an arithmetic expression in infix notation and returns the result as a float. def precedence(op): if op in ('+', '-'): return 1 if op in ('*', '/'): return 2 return 0 def apply_op(a, b, op): if op == '+': return a + b if op == '-': return a - b if op == '*': return a * b if op == '/': return a / b def calculate(tokens): values = [] ops = [] i = 0 while i < len(tokens): if tokens[i] == ' ': i += 1 continue if tokens[i] == '(': ops.append(tokens[i]) elif tokens[i].isdigit(): val = 0 while (i < len(tokens) and tokens[i].isdigit()): val = (val * 10) + int(tokens[i]) i += 1 values.append(val) i -= 1 elif tokens[i] == ')': while len(ops) != 0 and ops[-1] != '(': val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) ops.pop() else: while (len(ops) != 0 and precedence(ops[-1]) >= precedence(tokens[i])): val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) ops.append(tokens[i]) i += 1 while len(ops) != 0: val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) return values[-1] return float(calculate(expression))"},{"question":"def minimum_total_time(n: int) -> int: Determine the minimum total time needed to complete all tasks for n teams and n tasks. The time taken by team i to complete task j is given by |i - j| + 1. Args: n (int): The number of teams and tasks. Returns: int: The minimum total time needed to complete all tasks. Examples: >>> minimum_total_time(3) 6 >>> minimum_total_time(5) 15","solution":"def minimum_total_time(n): Returns the minimum total time needed to complete all tasks for n teams and n tasks. return n * (n + 1) // 2"},{"question":"def is_palindromic(number): Returns True if the number is palindromic, False otherwise. >>> is_palindromic(1) True >>> is_palindromic(9) True >>> is_palindromic(11) True >>> is_palindromic(22) True >>> is_palindromic(121) True >>> is_palindromic(123) False def count_palindromic_numbers(a, b): Returns the count of palindromic numbers in the range [a, b] inclusive. >>> count_palindromic_numbers(1, 10) 9 >>> count_palindromic_numbers(10, 20) 1 >>> count_palindromic_numbers(5, 15) 6 >>> count_palindromic_numbers(100, 110) 1 >>> count_palindromic_numbers(1, 100) 18 >>> count_palindromic_numbers(500, 510) 1 >>> count_palindromic_numbers(999, 1000) 1","solution":"def is_palindromic(number): Returns True if the number is palindromic, False otherwise. return str(number) == str(number)[::-1] def count_palindromic_numbers(a, b): Returns the count of palindromic numbers in the range [a, b] inclusive. count = 0 for number in range(a, b + 1): if is_palindromic(number): count += 1 return count"},{"question":"def game_of_life(initial_state: List[List[int]], T: int) -> List[List[int]]: Determine the state of the rectangular grid after a certain number of time steps. >>> game_of_life([[0, 1, 0],[0, 0, 1],[1, 1, 1]], 1) [[0, 0, 0], [1, 0, 1], [0, 1, 1]] >>> game_of_life([[1, 1, 0],[1, 0, 1],[0, 1, 1]], 1) [[1, 1, 0], [1, 0, 1], [0, 1, 1]] >>> game_of_life([[1, 0],[0, 1]], 1) [[0, 0], [0, 0]] >>> game_of_life([[1, 1, 1],[1, 1, 1],[1, 1, 1]], 1) [[1, 0, 1], [0, 0, 0], [1, 0, 1]] >>> game_of_life([[0, 0, 0],[0, 0, 0],[0, 0, 0]], 1) [[0, 0, 0], [0, 0, 0], [0, 0, 0]] >>> game_of_life([[0, 0, 0],[0, 1, 0],[0, 0, 0]], 0) [[0, 0, 0], [0, 1, 0], [0, 0, 0]] pass","solution":"def get_next_state(grid): m, n = len(grid), len(grid[0]) next_grid = [[0] * n for _ in range(m)] def count_live_neighbors(x, y): directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] count = 0 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 1: count += 1 return count for i in range(m): for j in range(n): live_neighbors = count_live_neighbors(i, j) if grid[i][j] == 1: if live_neighbors < 2 or live_neighbors > 3: next_grid[i][j] = 0 else: next_grid[i][j] = 1 else: if live_neighbors == 3: next_grid[i][j] = 1 else: next_grid[i][j] = 0 return next_grid def game_of_life(initial_state, T): grid = initial_state for _ in range(T): grid = get_next_state(grid) return grid"},{"question":"def minUniqueSplit(s: str) -> int: Determine the minimum number of substrings in which all characters are unique. Example: >>> minUniqueSplit(\\"abac\\") 2 >>> minUniqueSplit(\\"world\\") 1 >>> minUniqueSplit(\\"abcdef\\") 1 >>> minUniqueSplit(\\"aaaa\\") 4 >>> minUniqueSplit(\\"\\") 1 >>> minUniqueSplit(\\"a\\") 1 >>> minUniqueSplit(\\"abab\\") 2","solution":"def minUniqueSplit(s): Determine the minimum number of substrings in which all characters are unique. last_seen = {} count = 1 for idx, char in enumerate(s): if char in last_seen: count += 1 last_seen = {} last_seen[char] = idx return count"},{"question":"def valid_palindrome(s: str) -> bool: Check if a given string is a valid palindrome after removing at most one character. Examples: >>> valid_palindrome(\\"abca\\") True >>> valid_palindrome(\\"racecar\\") True >>> valid_palindrome(\\"deified\\") True >>> valid_palindrome(\\"stone\\") False def test_valid_palindrome(): assert valid_palindrome(\\"abca\\") == True assert valid_palindrome(\\"racecar\\") == True assert valid_palindrome(\\"deified\\") == True assert valid_palindrome(\\"stone\\") == False assert valid_palindrome(\\"a\\") == True assert valid_palindrome(\\"ab\\") == True assert valid_palindrome(\\"abcba\\") == True assert valid_palindrome(\\"abccba\\") == True assert valid_palindrome(\\"abcdda\\") == False assert valid_palindrome(\\"abcdedcba\\") == True assert valid_palindrome(\\"abcdefggfedcba\\") == True assert valid_palindrome(\\"abcdefghijjihgfedcba\\") == True assert valid_palindrome(\\"\\") == True # Empty string case assert valid_palindrome(\\"aaabaaa\\") == True # Remove one 'b' assert valid_palindrome(\\"aaa\\") == True # No need to remove any character if __name__ == \\"__main__\\": test_valid_palindrome() print(\\"All tests passed!\\")","solution":"def valid_palindrome(s: str) -> bool: Returns True if the string can be a palindrome by removing at most one character, otherwise returns False. def is_palindrome_range(i, j): Helper function to check if the substring s[i:j+1] is a palindrome. return all(s[k] == s[j - k + i] for k in range(i, j)) left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: # Check by removing the character at left or at right return is_palindrome_range(left + 1, right) or is_palindrome_range(left, right - 1) left += 1 right -= 1 return True"},{"question":"def total_travel_time(test_cases): Calculates the total travel time from city 1 to city n for each test case. Args: test_cases (list of dict): Each dict contains: - n: Number of cities - expected_travel_times: List of expected travel times between consecutive cities - expected_delays: List of expected delays between consecutive cities Returns: list of int: Total travel time for each test case. pass # Test cases def test_single_case(): test_cases = [ { 'n': 4, 'expected_travel_times': [3, 5, 2], 'expected_delays': [1, 3, 4] } ] assert total_travel_time(test_cases) == [18] def test_multiple_cases(): test_cases = [ { 'n': 4, 'expected_travel_times': [3, 5, 2], 'expected_delays': [1, 3, 4], }, { 'n': 3, 'expected_travel_times': [6, 4], 'expected_delays': [2, 1], } ] assert total_travel_time(test_cases) == [18, 13] def test_minimum_values(): test_cases = [ { 'n': 2, 'expected_travel_times': [1], 'expected_delays': [1], } ] assert total_travel_time(test_cases) == [2] def test_maximum_values(): test_cases = [ { 'n': 100, 'expected_travel_times': [1000000] * 99, 'expected_delays': [1000000] * 99, } ] assert total_travel_time(test_cases) == [198000000]","solution":"def total_travel_time(test_cases): Calculates the total travel time from city 1 to city n for each test case. Args: test_cases (list of dict): Each dict contains: - n: Number of cities - expected_travel_times: List of expected travel times between consecutive cities - expected_delays: List of expected delays between consecutive cities Returns: list of int: Total travel time for each test case. total_times = [] for case in test_cases: n = case['n'] expected_travel_times = case['expected_travel_times'] expected_delays = case['expected_delays'] total_time = sum(expected_travel_times) + sum(expected_delays) total_times.append(total_time) return total_times"},{"question":"def highest_likes_index(N, like_counts): Returns the index of the song with the highest like count. If there are multiple songs with the highest like count, selects the one that appears first in the list. Parameters: N (int): The number of songs in the playlist. like_counts (list of int): A list of integers where each integer represents the like count of a song. Returns: int: The index of the song with the highest like count. Examples: >>> highest_likes_index(5, [10, 20, 20, 10, 30]) 4 >>> highest_likes_index(6, [5, 5, 5, 5, 5, 5]) 0 >>> highest_likes_index(4, [15, 10, 10, 5]) 0 >>> highest_likes_index(4, [10, 10, 10, 20]) 3 >>> highest_likes_index(4, [10, 20, 30, 20]) 2 >>> highest_likes_index(3, [15, 20, 20]) 1","solution":"def highest_likes_index(N, like_counts): Returns the index of the song with the highest like count. If there are multiple songs with the highest like count, selects the one that appears first in the list. Parameters: N (int): The number of songs in the playlist. like_counts (list of int): A list of integers where each integer represents the like count of a song. Returns: int: The index of the song with the highest like count. max_likes = -1 max_index = -1 for i in range(N): if like_counts[i] > max_likes: max_likes = like_counts[i] max_index = i return max_index"},{"question":"def find_common_elements(T: int, test_cases: List[Tuple[int, List[List[int]]]]) -> List[str]: The function takes the number of test cases T and a list of test cases. Each test case contains an integer K and K sorted arrays. It returns a list of strings where each string represents the unique common elements in lexicographical order found in all arrays for that test case. If there are no such integers, it returns \\"No common elements!\\". Example usage: >>> find_common_elements(2, [ ... [3, [ ... [1, 2, 3, 4, 5], ... [2, 4, 6, 8], ... [0, 2, 4, 6] ... ]], ... [2, [ ... [1, 4, 5, 6], ... [6, 7, 8, 9] ... ]] ... ]) == [\\"2 4\\", \\"6\\"] # Your code here from solution import find_common_elements def test_single_case_with_common_elements(): test_cases = [ [3, [ [1, 2, 3, 4, 5], [2, 4, 6, 8], [0, 2, 4, 6] ]] ] assert find_common_elements(1, test_cases) == [\\"2 4\\"] def test_single_case_no_common_elements(): test_cases = [ [2, [ [1, 4, 5, 6], [6, 7, 8, 9] ]] ] assert find_common_elements(1, test_cases) == [\\"6\\"] def test_multiple_cases(): test_cases = [ [3, [ [1, 2, 3, 4, 5], [2, 4, 6, 8], [0, 2, 4, 6] ]], [2, [ [1, 4, 5, 6], [6, 7, 8, 9] ]] ] assert find_common_elements(2, test_cases) == [\\"2 4\\", \\"6\\"] def test_no_common_elements_at_all(): test_cases = [ [3, [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]] ] assert find_common_elements(1, test_cases) == [\\"No common elements!\\"]","solution":"def find_common_elements(T, test_cases): result = [] for case in test_cases: K, arrays = case common_elements = set(arrays[0]) for array in arrays[1:]: common_elements &= set(array) if common_elements: result.append(\\" \\".join(map(str, sorted(common_elements)))) else: result.append(\\"No common elements!\\") return result"},{"question":"def distribute_prizes(test_cases): Calculate the prize for each of the top K competitors. Args: test_cases (list): A list of dictionaries where each dictionary contains: - N: The number of participants - K: The top K competitors - total_prize_pool: The total amount of prize pool - scores: A list of scores for all participants Returns: list: A list of lists where each inner list contains the prizes for the top K competitors formatted to two decimal places. >>> test_cases = [ {\\"N\\": 5, \\"K\\": 3, \\"total_prize_pool\\": 1500, \\"scores\\": [100, 200, 300, 400, 500]}, {\\"N\\": 4, \\"K\\": 2, \\"total_prize_pool\\": 1000, \\"scores\\": [0, 0, 100, 200]} ] >>> distribute_prizes(test_cases) [['625.00', '500.00', '375.00'], ['666.67', '333.33']] pass def parse_input(input_string): Parse the input string into a structured format. Args: input_string (str): The input string containing multiple test cases. Returns: list: A list of dictionaries where each dictionary contains: - N: The number of participants - K: The top K competitors - total_prize_pool: The total amount of prize pool - scores: A list of scores for all participants >>> input_string = \\"2n5 3 1500n100 200 300 400 500n4 2 1000n0 0 100 200\\" >>> parse_input(input_string) [{'N': 5, 'K': 3, 'total_prize_pool': 1500, 'scores': [100, 200, 300, 400, 500]}, {'N': 4, 'K': 2, 'total_prize_pool': 1000, 'scores': [0, 0, 100, 200]}] pass def format_output(results): Format the output results into the required output string. Args: results (list): A list of lists where each inner list contains the prizes for the top K competitors. Returns: str: A formatted string representing the results. >>> results = [['625.00', '500.00', '375.00'], ['666.67', '333.33']] >>> format_output(results) '625.00 500.00 375.00n666.67 333.33' pass def main(input_string): Main function to handle input and output. Args: input_string (str): The input string containing multiple test cases. Returns: str: The formatted output string. >>> input_string = \\"2n5 3 1500n100 200 300 400 500n4 2 1000n0 0 100 200\\" >>> main(input_string) '625.00 500.00 375.00n666.67 333.33' pass","solution":"def distribute_prizes(test_cases): results = [] for case in test_cases: N, K, total_prize_pool = case[\\"N\\"], case[\\"K\\"], case[\\"total_prize_pool\\"] scores = case[\\"scores\\"] # Get top K scores in descending order top_k_scores = sorted(scores, reverse=True)[:K] total_top_k_score = sum(top_k_scores) # Calculate the prize for each of the top K competitors prizes = [(score / total_top_k_score) * total_prize_pool for score in top_k_scores] # Format prizes to two decimal places and add to results formatted_prizes = [f\\"{prize:.2f}\\" for prize in prizes] results.append(formatted_prizes) return results # Function to convert the input format to a structured format def parse_input(input_string): lines = input_string.strip().split('n') T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): N, K, total_prize_pool = map(int, lines[index].split()) index += 1 scores = list(map(int, lines[index].split())) index += 1 test_cases.append({\\"N\\": N, \\"K\\": K, \\"total_prize_pool\\": total_prize_pool, \\"scores\\": scores}) return test_cases # Function to convert the output format def format_output(results): return \\"n\\".join([\\" \\".join(result) for result in results]) # Main function to handle input and output def main(input_string): test_cases = parse_input(input_string) results = distribute_prizes(test_cases) return format_output(results)"},{"question":"def can_form_palindrome(S: str) -> str: Checks if characters can be removed from the string S to form a palindrome. >>> can_form_palindrome(\\"abccba\\") \\"YES\\" >>> can_form_palindrome(\\"abcde\\") \\"NO\\"","solution":"def can_form_palindrome(S): Checks if characters can be removed from the string S to form a palindrome. from collections import Counter char_count = Counter(S) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can form a palindrome if it has at most one character with an odd count. if odd_count <= 1: return \\"YES\\" else: return \\"NO\\" def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) S = data[1] print(can_form_palindrome(S))"},{"question":"def min_subset_difference(n, arr): Partition the list of integers into two subsets such that the absolute difference between the sums of elements in the two subsets is minimized. Args: n (int): Number of integers in the list. arr (list): List of n integers. Returns: int: The minimum absolute difference between the sums of the two subsets. Examples: >>> min_subset_difference(4, [1, 2, 3, 9]) 3 >>> min_subset_difference(3, [4, 1, 7]) 2 >>> min_subset_difference(3, [2, 8, 4]) 2 pass def solve(t, test_cases): Solve multiple test cases for the minimum subset difference problem. Args: t (int): Number of test cases. test_cases (list): List of tuples containing the number of integers and the list itself. Returns: list: List of results for each test case. Examples: >>> solve(1, [(4, [1, 2, 3, 9])]) [3] >>> solve(2, [ ... (4, [1, 6, 11, 5]), ... (3, [3, 1, 4]) ... ]) [1, 0] pass","solution":"def min_subset_difference(n, arr): total_sum = sum(arr) half_sum = total_sum // 2 dp = [0] * (half_sum + 1) for num in arr: for j in range(half_sum, num - 1, -1): dp[j] = max(dp[j], dp[j - num] + num) subset1_sum = dp[half_sum] subset2_sum = total_sum - subset1_sum return abs(subset2_sum - subset1_sum) def solve(t, test_cases): results = [] for n, arr in test_cases: result = min_subset_difference(n, arr) results.append(result) return results"},{"question":"def find_min_difference(n: int, skill_levels: List[int]) -> int: This function takes the number of employees (n) and a list of their skill levels (skill_levels), and returns the minimum possible difference between the total skill levels of the two teams. >>> find_min_difference(4, [1, 6, 11, 5]) 1 >>> find_min_difference(1, [5]) 5 >>> find_min_difference(2, [10, 10]) 0 >>> find_min_difference(4, [5, 5, 5, 5]) 0 >>> find_min_difference(3, [1, 2, 3]) 0 >>> find_min_difference(5, [2, 2, 2, 2, 2]) 2 >>> find_min_difference(5, [10, 20, 30, 40, 50]) 10","solution":"def find_min_difference(n, skill_levels): This function takes the number of employees (n) and a list of their skill levels (skill_levels), and returns the minimum possible difference between the total skill levels of the two teams. total_sum = sum(skill_levels) dp = [[False] * (total_sum + 1) for _ in range(n + 1)] dp[0][0] = True for i in range(1, n + 1): for j in range(total_sum + 1): if dp[i - 1][j]: dp[i][j] = True dp[i][j + skill_levels[i - 1]] = True min_diff = float('inf') for j in range(total_sum // 2 + 1): if dp[n][j]: min_diff = min(min_diff, total_sum - 2 * j) return min_diff"},{"question":"def can_reorder_no_adjacent_same_points(t: int, cases: List[Tuple[int, List[int]]]) -> List[str]: Determine if you can reorder the teams such that no two adjacent teams in the new order have the same number of points, or report if it is impossible. Args: t (int): number of test cases. cases (List[Tuple[int, List[int]]]): list of test cases, where each test case contains an integer n (the number of teams) and a list of integers (points scored by each team). Returns: List[str]: list of results for each test case - \\"YES\\" if reordering is possible, \\"NO\\" otherwise. Example: >>> can_reorder_no_adjacent_same_points(3, [(5, [4, 3, 3, 4, 2]), (4, [1, 1, 1, 1]), (3, [7, 6, 6])]) [\\"YES\\", \\"NO\\", \\"YES\\"]","solution":"def can_reorder_no_adjacent_same_points(t, cases): results = [] for case in cases: n, points = case freq = {} for p in points: if p in freq: freq[p] += 1 else: freq[p] = 1 max_freq = max(freq.values()) if max_freq > (n + 1) // 2: results.append(\\"NO\\") else: results.append(\\"YES\\") return results"},{"question":"def right_aligned_pyramid(n: int): Prints a right-aligned pyramid of asterisks with n rows. >>> right_aligned_pyramid(5) * ** *** **** ***** >>> right_aligned_pyramid(3) * ** *** >>> right_aligned_pyramid(6) * ** *** **** ***** ******","solution":"def right_aligned_pyramid(n): Prints a right-aligned pyramid of asterisks with n rows. for i in range(1, n + 1): leading_spaces = ' ' * (n - i) stars = '*' * i print(leading_spaces + stars)"},{"question":"def max_pyramid_height(n: int) -> int: Determine the height of the tallest pyramid that can be built with n pots. Args: n: int - The number of pots available for building the pyramid. Returns: int - The height of the tallest pyramid that can be built. Examples: >>> max_pyramid_height(14) 4 >>> max_pyramid_height(20) 5","solution":"def max_pyramid_height(n): This function calculates the height of the tallest pyramid that can be built with n pots. height = 0 total_pots = 0 while total_pots + (height + 1) <= n: height += 1 total_pots += height return height"},{"question":"def is_path_exists(grid): Determine whether there exists a path from the top-left to the bottom-right corner of a grid without crossing obstacles. :param grid: List of strings representing the grid :return: \\"YES\\" if there is a path, otherwise \\"NO\\" >>> is_path_exists([ ... \\"..#\\", ... \\".#.\\", ... \\"...\\" ... ]) == \\"YES\\" >>> is_path_exists([ ... \\"#..\\", ... \\".#.\\", ... \\"..#\\" ... ]) == \\"NO\\" >>> is_path_exists([ ... \\".\\" ... ]) == \\"YES\\" >>> is_path_exists([ ... \\"#\\" ... ]) == \\"NO\\" >>> is_path_exists([ ... \\".....\\", ... \\".....\\", ... \\".....\\", ... \\".....\\", ... ]) == \\"YES\\" >>> is_path_exists([ ... \\"#\\", ... \\"#\\", ... \\"#\\", ... \\"#\\", ... ]) == \\"NO\\"","solution":"def is_path_exists(grid): n = len(grid) m = len(grid[0]) if grid[0][0] == '#' or grid[n-1][m-1] == '#': return \\"NO\\" def dfs(x, y, visited): if x == n - 1 and y == m - 1: return True if x < 0 or x >= n or y < 0 or y >= m or grid[x][y] == '#' or visited[x][y]: return False visited[x][y] = True down = dfs(x + 1, y, visited) right = dfs(x, y + 1, visited) return down or right visited = [[False for _ in range(m)] for _ in range(n)] return \\"YES\\" if dfs(0, 0, visited) else \\"NO\\""},{"question":"def find_hierarchy_depth(N: int, relations: List[Tuple[int, int]]) -> int: Determines the depth of the hierarchy tree in a company. >>> find_hierarchy_depth(4, [(1, -1), (2, 1), (3, 1), (4, 3)]) 3 >>> find_hierarchy_depth(4, [(1, -1), (2, 1), (3, 1), (4, 1)]) 2 pass # Implementation to be provided by the user from typing import List, Tuple def test_sample_input_1(): N = 4 relations = [(1, -1), (2, 1), (3, 1), (4, 3)] assert find_hierarchy_depth(N, relations) == 3 def test_sample_input_2(): N = 4 relations = [(1, -1), (2, 1), (3, 1), (4, 1)] assert find_hierarchy_depth(N, relations) == 2 def test_all_report_to_ceo(): N = 3 relations = [(1, -1), (2, 1), (3, 1)] assert find_hierarchy_depth(N, relations) == 2 def test_linear_chain_of_command(): N = 4 relations = [(1, -1), (2, 1), (3, 2), (4, 3)] assert find_hierarchy_depth(N, relations) == 4 def test_single_employee(): N = 1 relations = [(1, -1)] assert find_hierarchy_depth(N, relations) == 1","solution":"def find_hierarchy_depth(N, relations): from collections import defaultdict, deque # Building the adjacency list for the hierarchy tree tree = defaultdict(list) for emp, mgr in relations: if mgr != -1: tree[mgr].append(emp) else: ceo = emp # BFS to find the depth of the tree queue = deque([(ceo, 1)]) # (current node, current depth) max_depth = 0 while queue: node, depth = queue.popleft() max_depth = max(max_depth, depth) for subordinate in tree[node]: queue.append((subordinate, depth + 1)) return max_depth"},{"question":"def can_win_game(n, m, k, your_dice, opponent_dice): Determines if it is possible for you to rearrange your dice to achieve at least k round wins against your opponent. :param n: Number of your dice :param m: Number of opponent's dice :param k: Number of round wins required to win the game :param your_dice: List of integers representing the number of sides on each of your dice :param opponent_dice: List of integers representing the number of sides on each of opponent's dice :return: \\"possible\\" if you can win at least k rounds, otherwise \\"impossible\\" pass # Test cases def test_can_win_game_example1(): n, m, k = 3, 3, 2 your_dice = [6, 8, 10] opponent_dice = [5, 7, 9] assert can_win_game(n, m, k, your_dice, opponent_dice) == \\"possible\\" def test_can_win_game_example2(): n, m, k = 3, 3, 4 your_dice = [6, 8, 10] opponent_dice = [5, 7, 9] assert can_win_game(n, m, k, your_dice, opponent_dice) == \\"impossible\\" def test_can_win_game_edge_case1(): n, m, k = 1, 1, 1 your_dice = [10] opponent_dice = [1] assert can_win_game(n, m, k, your_dice, opponent_dice) == \\"possible\\" def test_can_win_game_edge_case2(): n, m, k = 1, 1, 2 your_dice = [10] opponent_dice = [1] assert can_win_game(n, m, k, your_dice, opponent_dice) == \\"impossible\\" def test_can_win_game_more_your_dice(): n, m, k = 4, 3, 3 your_dice = [6, 8, 10, 12] opponent_dice = [5, 7, 9] assert can_win_game(n, m, k, your_dice, opponent_dice) == \\"possible\\" def test_can_win_game_more_opponent_dice(): n, m, k = 3, 4, 3 your_dice = [6, 8, 10] opponent_dice = [5, 7, 9, 11] assert can_win_game(n, m, k, your_dice, opponent_dice) == \\"impossible\\"","solution":"def can_win_game(n, m, k, your_dice, opponent_dice): Determines if it is possible for you to rearrange your dice to achieve at least k round wins against your opponent. :param n: Number of your dice :param m: Number of opponent's dice :param k: Number of round wins required to win the game :param your_dice: List of integers representing the number of sides on each of your dice :param opponent_dice: List of integers representing the number of sides on each of opponent's dice :return: \\"possible\\" if you can win at least k rounds, otherwise \\"impossible\\" # Sort both dice collections in descending order your_dice.sort(reverse=True) opponent_dice.sort(reverse=True) # Calculate wins required wins = 0 for i in range(len(your_dice)): if i >= len(opponent_dice) or your_dice[i] > opponent_dice[i]: wins += 1 if wins >= k: return \\"possible\\" return \\"impossible\\""},{"question":"from typing import List, Tuple def count_good_pairs(nums: List[int]) -> int: Takes a list of integers nums and returns the number of \\"good pairs\\". >>> count_good_pairs([2, 4, 6, 3, 5]) 4 >>> count_good_pairs([1, 1, 1, 1]) 6 >>> count_good_pairs([2, 1, 3]) 1 pass def solve(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Takes a list of tuples representing test cases. Each tuple consists of an integer n and a list of integers nums. Returns a list of integers where each integer is the number of good pairs for the respective test case. >>> solve([(5, [2, 4, 6, 3, 5]), (4, [1, 1, 1, 1]), (3, [2, 1, 3])]) [4, 6, 1] pass","solution":"def count_good_pairs(nums): This function takes a list of integers nums and returns the number of \\"good pairs\\". A pair (i, j) is called \\"good\\" if nums[i] + nums[j] is even and i < j. n = len(nums) evens = odds = 0 for num in nums: if num % 2 == 0: evens += 1 else: odds += 1 # Number of ways to pick two evens + Number of ways to pick two odds good_pairs = (evens * (evens - 1)) // 2 + (odds * (odds - 1)) // 2 return good_pairs def solve(test_cases): This function takes a list of tuples representing test cases. Each tuple consists of an integer n and a list of integers nums. It returns a list of integers where each integer is the number of good pairs for the respective test case. results = [] for n, nums in test_cases: results.append(count_good_pairs(nums)) return results"},{"question":"def assign_loyalty_points(spendings): Assigns loyalty points based on the total amount spent by each customer. Parameters: spendings (List[int]): A list containing the total spending amounts for each customer. Returns: List[int]: A list containing the loyalty points assigned to each customer. >>> assign_loyalty_points([1500, 750, 400, 1001, 500]) [50, 30, 0, 50, 30] >>> assign_loyalty_points([1001, 2000, 3000]) [50, 50, 50] >>> assign_loyalty_points([500, 750, 999]) [30, 30, 30] >>> assign_loyalty_points([0, 250, 499]) [0, 0, 0] >>> assign_loyalty_points([0, 600, 1500, 1000, 999, 1001, 499]) [0, 30, 50, 30, 30, 50, 0] >>> assign_loyalty_points([500, 1000, 1001]) [30, 30, 50]","solution":"def assign_loyalty_points(spendings): Returns a list of loyalty points assigned based on each customer's total spending. points = [] for spending in spendings: if spending > 1000: points.append(50) elif 500 <= spending <= 1000: points.append(30) else: points.append(0) return points"},{"question":"def min_total_bonus(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the minimum total bonus the company must give to the employees while satisfying the conditions. Args: T: int, the number of test cases. test_cases: List of Tuples, each containing an integer N (number of employees) and a list of integers representing employee performance scores. Returns: List[int]: A list containing the minimum total bonus for each test case. >>> min_total_bonus(2, [(3, [1, 2, 2]), (4, [1, 2, 2, 3])]) [4, 6] >>> min_total_bonus(1, [(5, [5, 4, 3, 2, 1])]) [15] # implementation","solution":"def min_total_bonus(T, test_cases): results = [] for case in test_cases: N, scores = case if N == 0: results.append(0) continue bonuses = [1] * N # Left to right pass for i in range(1, N): if scores[i] > scores[i-1]: bonuses[i] = bonuses[i-1] + 1 # Right to left pass for i in range(N-2, -1, -1): if scores[i] > scores[i+1]: bonuses[i] = max(bonuses[i], bonuses[i+1] + 1) results.append(sum(bonuses)) return results"},{"question":"from typing import List def is_path_possible(grid: List[List[int]], t: int) -> bool: Determines if there is a path from the top-left cell to the bottom-right cell driving the given height difference condition. Parameters: grid (List[List[int]]): A 2D list representing the grid of cells with heights. t (int): The maximum allowed height difference between adjacent cells. Returns: bool: True if there is such a path, otherwise False. Examples: >>> is_path_possible([[1, 3, 5], [4, 2, 3], [7, 1, 2]], 3) True >>> is_path_possible([[1, 6, 1], [6, 4, 6], [1, 6, 1]], 2) False >>> is_path_possible([[5, 5, 5], [5, 0, 5], [5, 5, 5]], 5) True def test_path_possible(): assert is_path_possible([[1, 3, 5], [4, 2, 3], [7, 1, 2]], 3) == True def test_no_path(): assert is_path_possible([[1, 6, 1], [6, 4, 6], [1, 6, 1]], 2) == False def test_path_possible_with_max_t(): assert is_path_possible([[5, 5, 5], [5, 0, 5], [5, 5, 5]], 5) == True def test_single_cell_grid(): assert is_path_possible([[0]], 0) == True def test_two_by_two_grid(): assert is_path_possible([[1, 4], [7, 10]], 3) == False assert is_path_possible([[1, 3], [4, 0]], 3) == True","solution":"def is_path_possible(grid, t): Determines if there is a path from the top-left cell to the bottom-right cell satisfying the given height difference condition. from collections import deque m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] visited = set() queue = deque([(0, 0)]) visited.add((0, 0)) while queue: x, y = queue.popleft() if x == m - 1 and y == n - 1: return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited: if abs(grid[nx][ny] - grid[x][y]) <= t: queue.append((nx, ny)) visited.add((nx, ny)) return False"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def zigzagLevelOrder(root: TreeNode) -> List[List[int]]: Perform zigzag level order traversal on a binary tree. >>> root = TreeNode(3) >>> root.left = TreeNode(9) >>> root.right = TreeNode(20, TreeNode(15), TreeNode(7)) >>> zigzagLevelOrder(root) [[3], [20, 9], [15, 7]] >>> zigzagLevelOrder(None) [] >>> root = TreeNode(1) >>> zigzagLevelOrder(root) [[1]]","solution":"from typing import List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def zigzagLevelOrder(root: TreeNode) -> List[List[int]]: if not root: return [] result = [] current_level = [root] left_to_right = True while current_level: level_vals = [] next_level = [] for node in current_level: level_vals.append(node.val) if node.left: next_level.append(node.left) if node.right: next_level.append(node.right) if not left_to_right: level_vals.reverse() result.append(level_vals) current_level = next_level left_to_right = not left_to_right return result"},{"question":"def is_rotation(X: str, Y: str) -> str: Determine if X is a rotation of Y. >>> is_rotation(\\"erbottlewat\\", \\"waterbottle\\") \\"YES\\" >>> is_rotation(\\"hello\\", \\"ohell\\") \\"YES\\" >>> is_rotation(\\"abc\\", \\"bac\\") \\"NO\\"","solution":"def is_rotation(X, Y): Returns \\"YES\\" if X is a rotation of Y, otherwise returns \\"NO\\". if len(X) != len(Y): return \\"NO\\" return \\"YES\\" if Y in X + X else \\"NO\\""},{"question":"from typing import List, Tuple, Union def perform_operations(n: int, q: int, array: List[int], queries: List[Tuple[str, Union[int]]]) -> List[int]: Perform a series of operations on an array and return the results of 'get' operations. Parameters: n: int - The initial size of the array. q: int - The number of queries. array: List[int] - The initial array of integers. queries: List[Tuple[str, Union[int]]] - A list of queries where each query is a tuple indicating the operation type ('add', 'mult', 'get') and the corresponding value. Returns: List[int] - A list of results from the 'get' operations. Example: >>> perform_operations(5, 4, [1, 2, 3, 4, 5], [(\\"add\\", 2), (\\"mult\\", 3), (\\"get\\", 2), (\\"get\\", 4)]) [15, 21] >>> perform_operations(5, 2, [1, 1, 1, 1, 1], [(\\"add\\", 10), (\\"get\\", 3)]) [11]","solution":"def perform_operations(n, q, array, queries): add_sum = 0 mult_product = 1 results = [] for query in queries: command = query[0] if command == \\"add\\": d = int(query[1]) add_sum += d elif command == \\"mult\\": m = int(query[1]) add_sum *= m mult_product *= m elif command == \\"get\\": index = int(query[1]) value = array[index] * mult_product + add_sum results.append(value) return results"},{"question":"def countA(s: str) -> int: Returns the frequency of the character 'a' in the string s. >>> countA(\\"apple\\") == 1 >>> countA(\\"banana\\") == 3 >>> countA(\\"hello\\") == 0 >>> countA(\\"aaaaa\\") == 5 >>> countA(\\"abracadabra\\") == 5 >>> countA(\\"\\") == 0 >>> countA(\\"bcdefg\\") == 0","solution":"def countA(s): Returns the frequency of the character 'a' in the string s. return s.count('a')"},{"question":"def max_sum_subarray(n, m, arr): Given an array of n integers, find the maximum sum subarray of size m. Parameters: n (int): The length of the array. m (int): The size of the subarray. arr (List[int]): The input array of integers. Returns: int: The maximum sum of a subarray of size m. Examples: >>> max_sum_subarray(10, 3, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 27 >>> max_sum_subarray(5, 2, [-1, -2, -3, -4, -5]) -3 >>> max_sum_subarray(6, 4, [1, 1, 1, 1, 1, 1]) 4","solution":"def max_sum_subarray(n, m, arr): Returns the maximum sum of a subarray of size m from the given array arr. n: Length of the array m: Size of the subarray arr: Input integer array # Initialize the sum of first m elements current_sum = sum(arr[:m]) max_sum = current_sum # Use sliding window to calculate the rest of the sums for i in range(m, n): current_sum += arr[i] - arr[i - m] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def calculate_final_balances(n: int, accounts: List[List[int]]) -> List[str]: Simulate final balances of each account given a list of transactions and identify accounts with potential overdrafts. >>> calculate_final_balances(3, [[5, 100, -50, 20, 30, -10], [2, -10, -20], [4, 50, 50, -60, -40]]) [\\"90 OK\\", \\"-30 Overdraft\\", \\"0 OK\\"] >>> calculate_final_balances(1, [[3, -10, -20, -30]]) [\\"-60 Overdraft\\"]","solution":"def calculate_final_balances(n, accounts): results = [] for account in accounts: num_transactions = account[0] transactions = account[1:num_transactions + 1] balance = sum(transactions) if balance < 0: results.append(f\\"{balance} Overdraft\\") else: results.append(f\\"{balance} OK\\") return results"},{"question":"def can_schedule_tasks(k: int, task_durations: List[int], max_time_per_slot: int) -> str: Determines if the tasks can be scheduled within the given time slots without exceeding the time limit. Args: k: int, number of time slots. task_durations: list of int, durations of the tasks. max_time_per_slot: int, maximum time limit per time slot. Returns: str: 'YES' if tasks can be scheduled within the time slots without exceeding the limit, otherwise 'NO'. >>> can_schedule_tasks(3, [4, 2, 3], 5) 'YES' >>> can_schedule_tasks(2, [6, 3], 4) 'NO' >>> can_schedule_tasks(4, [1, 1, 1, 1], 2) 'YES'","solution":"def can_schedule_tasks(k, task_durations, max_time_per_slot): Determines if the tasks can be scheduled within the given time slots without exceeding the time limit. Args: k: int, number of time slots. task_durations: list of int, durations of the tasks. max_time_per_slot: int, maximum time limit per time slot. Returns: str: 'YES' if tasks can be scheduled within the time slots without exceeding the limit, otherwise 'NO'. # Check if any single task exceeds max_time_per_slot for task in task_durations: if task > max_time_per_slot: return 'NO' current_sum = 0 time_slots_needed = 1 for duration in task_durations: if current_sum + duration <= max_time_per_slot: current_sum += duration else: time_slots_needed += 1 current_sum = duration if time_slots_needed > k: return 'NO' return 'YES'"},{"question":"def prioritize_tickets(T, test_cases): Determines the order in which tickets should be processed based on priority. Args: T: int - the number of test cases test_cases: List - list of test cases, each containing the number of customers and a list of tuples with customer IDs and their priority levels Returns: List[List[str]] - a list of lists, where each inner list contains the customer IDs sorted by their priority levels in ascending order. Example: >>> T = 1 >>> test_cases = [ ... (5, [ ... (\\"customer1\\", 10), ... (\\"customer2\\", 5), ... (\\"customer3\\", 12), ... (\\"customer4\\", 8), ... (\\"customer5\\", 1) ... ]) ... ] >>> prioritize_tickets(T, test_cases) [['customer5', 'customer2', 'customer4', 'customer1', 'customer3']]","solution":"def prioritize_tickets(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] customers = test_cases[i][1] customers.sort(key=lambda x: x[1]) # Sort by priority level result = [customer[0] for customer in customers] results.append(result) return results"},{"question":"def longest_repeating_substring(s: str) -> str: Returns the longest substring that appears at least twice in the given string. >>> longest_repeating_substring(\\"banana\\") 'ana' >>> longest_repeating_substring(\\"abcd\\") '' >>> longest_repeating_substring(\\"aaabaaa\\") 'aaa'","solution":"def longest_repeating_substring(s): Returns the longest substring that appears at least twice in the given string. If no such substring exists, returns an empty string. n = len(s) longest_subs = \\"\\" # Function to check if there exists a substring of length 'length' that appears at least twice def has_repeating_substring(length): seen = set() for i in range(n - length + 1): substr = s[i:i + length] if substr in seen: return substr seen.add(substr) return \\"\\" left, right = 1, n while left <= right: mid = (left + right) // 2 substr = has_repeating_substring(mid) if substr: longest_subs = substr left = mid + 1 else: right = mid - 1 return longest_subs"},{"question":"def assign_tasks(d1: int, d2: int, d3: int) -> tuple: Assigns tasks' durations to workers based on their experience levels. The longest duration task goes to the most experienced worker (1), the second longest to the second most experienced (2), and the shortest to the least experienced (3). Returns: tuple: experience level assignments for each task in the order they were given. >>> assign_tasks(20, 15, 25) == (2, 3, 1) >>> assign_tasks(45, 20, 35) in [(1, 3, 2), (1, 2, 3)]","solution":"def assign_tasks(d1, d2, d3): Assigns tasks' durations to workers based on their experience levels. The longest duration task goes to the most experienced worker (1), the second longest to the second most experienced (2), and the shortest to the least experienced (3). Returns: tuple: experience level assignments for each task in the order they were given. durations = [(d1, 1), (d2, 2), (d3, 3)] # Sort tasks by their durations in descending order sorted_durations = sorted(durations, key=lambda x: x[0], reverse=True) # Mapping of durations after sorting them into their experience levels experience_assignment = [0] * 3 for i, (_, original_index) in enumerate(sorted_durations): # Assign experience level (1-based) to original task position experience_assignment[original_index - 1] = i + 1 return tuple(experience_assignment)"},{"question":"def generate_magic_square(n): Generates a n x n magic square if possible; otherwise returns None. >>> generate_magic_square(3) [[8, 1, 6], [3, 5, 7], [4, 9, 2]] >>> generate_magic_square(4) [[1, 15, 14, 4], [12, 6, 7, 9], [8, 10, 11, 5], [13, 3, 2, 16]] >>> generate_magic_square(2) None >>> generate_magic_square(8) is not None True from solution import generate_magic_square def is_magic_square(square): Checks if a given 2D list is a magic square. n = len(square) if n == 0: return False expected_sum = sum(square[0]) # Check rows sum for row in square: if sum(row) != expected_sum: return False # Check columns sum for col in range(n): if sum(square[row][col] for row in range(n)) != expected_sum: return False # Check diagonals sum if sum(square[i][i] for i in range(n)) != expected_sum: return False if sum(square[i][n-1-i] for i in range(n)) != expected_sum: return False # Check all numbers from 1 to n^2 are used all_nums = sorted([num for row in square for num in row]) if all_nums != list(range(1, n**2 + 1)): return False return True def test_odd_magic_square(): ms_3 = generate_magic_square(3) ms_5 = generate_magic_square(5) assert ms_3 is not None and is_magic_square(ms_3) assert ms_5 is not None and is_magic_square(ms_5) def test_singly_even_magic_square(): ms_4 = generate_magic_square(4) assert ms_4 is not None and is_magic_square(ms_4) def test_doubly_even_magic_square(): ms_8 = generate_magic_square(8) assert ms_8 is not None and is_magic_square(ms_8) def test_invalid_magic_square(): assert generate_magic_square(2) is None assert generate_magic_square(6) is None assert generate_magic_square(0) is None assert generate_magic_square(16) is None","solution":"def generate_magic_square(n): Generates a n x n magic square if possible; otherwise returns None. if n < 1 or n > 15 or (n % 2 == 0 and n != 4 and (n % 4 != 0)): return None if n % 2 == 1: # odd order magic square magic_square = [[0]*n for _ in range(n)] num = 1 i, j = 0, n // 2 while num <= n**2: magic_square[i][j] = num num += 1 newi, newj = (i-1) % n, (j+1) % n if magic_square[newi][newj]: i += 1 else: i, j = newi, newj return magic_square elif n == 4: # singly even order magic squares (n mod 4 == 0) magic_square = [[(n*y)+x+1 for x in range(n)] for y in range(n)] # Swap necessary blocks s = n // 4 for i in range(n): for j in range(n): if (i < s or i >= n - s) and (j < s or j >= n - s): continue elif (i >= s and i < n - s) and (j >= s and j < n - s): continue magic_square[i][j] = n*n + 1 - magic_square[i][j] return magic_square elif n % 4 == 0: # doubly even order magic squares (n multiple of 4) magic_square = [[n*y + x + 1 for x in range(n)] for y in range(n)] s = n // 4 for i in range(n): for j in range(n): if (i < s or i >= n - s) and (j < s or j >= n - s): magic_square[i][j] = n*n + 1 - magic_square[i][j] elif (i >= s and i < n - s) and (j >= s and j < n - s): magic_square[i][j] = n*n + 1 - magic_square[i][j] return magic_square return None"},{"question":"class DSU: def __init__(self, n): self.parent = list(range(n)) self.rank = [1] * n self.size = [1] * n def find(self, x): if self.parent[x] != x: self.parent[x] = self.find(self.parent[x]) return self.parent[x] def union(self, x, y): rootX = self.find(x) rootY = self.find(y) if rootX != rootY: if self.rank[rootX] > self.rank[rootY]: self.parent[rootY] = rootX self.size[rootX] += self.size[rootY] elif self.rank[rootX] < self.rank[rootY]: self.parent[rootX] = rootY self.size[rootY] += self.size[rootX] else: self.parent[rootY] = rootX self.size[rootX] += self.size[rootY] self.rank[rootX] += 1 return False return True def count_loops(n: int, m: int, paths: List[Tuple[int, int]]) -> List[int]: Determine the number of ways to form loop sets after the completion of each path. Args: n : int : The number of locations. m : int : The number of paths. paths : List[Tuple[int, int]] : The paths, each represented by a tuple of two integers (ai, bi). Returns: List[int] : A list where the i-th element represents the number of ways to form loop sets after the completion of path number i. pass # Example usage if __name__ == \\"__main__\\": n, m = 4, 4 paths = [(1, 2), (2, 3), (3, 4), (4, 2)] print(count_loops(n, m, paths)) # Expected output: [0, 0, 0, 1] # Tests def test_example_case(): n, m = 4, 4 paths = [(1, 2), (2, 3), (3, 4), (4, 2)] assert count_loops(n, m, paths) == [0, 0, 0, 1] def test_no_loops(): n, m = 3, 2 paths = [(1, 2), (2, 3)] assert count_loops(n, m, paths) == [0, 0] def test_single_loop(): n, m = 3, 3 paths = [(1, 2), (2, 3), (3, 1)] assert count_loops(n, m, paths) == [0, 0, 1] def test_multiple_paths_between_nodes_with_one_loop(): n, m = 3, 4 paths = [(1, 2), (2, 3), (3, 1), (2, 3)] assert count_loops(n, m, paths) == [0, 0, 1, 2] def test_longer_cycle_with_intersecting_subtrees(): n, m = 6, 6 paths = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 3)] assert count_loops(n, m, paths) == [0, 0, 0, 0, 0, 1]","solution":"MOD = 1000000007 class DSU: def __init__(self, n): self.parent = list(range(n)) self.rank = [1] * n self.size = [1] * n def find(self, x): if self.parent[x] != x: self.parent[x] = self.find(self.parent[x]) return self.parent[x] def union(self, x, y): rootX = self.find(x) rootY = self.find(y) if rootX != rootY: if self.rank[rootX] > self.rank[rootY]: self.parent[rootY] = rootX self.size[rootX] += self.size[rootY] elif self.rank[rootX] < self.rank[rootY]: self.parent[rootX] = rootY self.size[rootY] += self.size[rootX] else: self.parent[rootY] = rootX self.size[rootX] += self.size[rootY] self.rank[rootX] += 1 return False return True def count_loops(n, m, paths): dsu = DSU(n) loops = 0 results = [] for a, b in paths: a -= 1 b -= 1 if dsu.union(a, b): loops += 1 results.append(loops) return [x % MOD for x in results] # Example usage n, m = 4, 4 paths = [(1, 2), (2, 3), (3, 4), (4, 2)] print(count_loops(n, m, paths)) # Output: [0, 0, 0, 1]"},{"question":"def reverse_number(n: int) -> int: Reverse the digits of a positive integer number except for leading zeros. >>> reverse_number(1234) 4321 >>> reverse_number(1200) 21 >>> reverse_number(1) 1 >>> reverse_number(10) 1 >>> reverse_number(1000) 1 >>> reverse_number(1001) 1001 >>> reverse_number(987654321) 123456789 >>> reverse_number(1000000000) 1","solution":"def reverse_number(n: int) -> int: reversed_num = 0 while n > 0: reversed_num = reversed_num * 10 + n % 10 n = n // 10 return reversed_num"},{"question":"def reverseWords(sentence: str) -> str: Reverses each word in the sentence while maintaining the order of the words. :param sentence: A string consisting of single words separated by spaces. :return: A string with each word reversed, maintaining word order. >>> reverseWords(\\"Hello World\\") 'olleH dlroW' >>> reverseWords(\\"Reverse each word\\") 'esreveR hcae drow' >>> reverseWords(\\"Python\\") 'nohtyP' >>> reverseWords(\\"\\") '' >>> reverseWords(\\" Hello World \\") ' olleH dlroW ' >>> reverseWords(\\"a b c d e\\") 'a b c d e' >>> reverseWords(\\"madam racecar\\") 'madam racecar'","solution":"def reverseWords(sentence): Reverses each word in the sentence while maintaining the order of the words. :param sentence: A string consisting of single words separated by spaces. :return: A string with each word reversed, maintaining word order. return ' '.join(word[::-1] for word in sentence.split(' '))"},{"question":"def delete_one_digit_max(strings): Given a string containing digits from 0 to 9, find the maximum number you can obtain by deleting exactly one digit from the string. >>> delete_one_digit_max([\\"123\\"]) [23] >>> delete_one_digit_max([\\"51423\\"]) [5423] >>> delete_one_digit_max([\\"9876\\"]) [987] >>> delete_one_digit_max([\\"210945\\"]) [21945] >>> delete_one_digit_max([\\"111\\"]) [11]","solution":"def delete_one_digit_max(strings): results = [] for s in strings: max_num = 0 for i in range(len(s)): num = int(s[:i] + s[i+1:]) max_num = max(max_num, num) results.append(max_num) return results"},{"question":"from typing import List def largest_integer(numbers: List[int]) -> str: Write a function, \`largest_integer\`, that takes a list of non-negative integers and returns the largest integer that can be formed by concatenating the integers together. >>> largest_integer([10, 2]) '210' >>> largest_integer([3, 30, 34, 5, 9]) '9534330'","solution":"from typing import List from functools import cmp_to_key def compare(x, y): if x + y > y + x: return -1 elif x + y < y + x: return 1 else: return 0 def largest_integer(numbers: List[int]) -> str: # Convert all the integers to strings str_numbers = list(map(str, numbers)) # Sort the numbers based on their possible concatenation results str_numbers.sort(key=cmp_to_key(compare)) # Join all sorted numbers in a single string largest_num = ''.join(str_numbers) # Handle case where resulting number is all zeros if largest_num.lstrip('0') == '': return '0' return largest_num"},{"question":"def calculate_working_hours(n: int, times: List[Tuple[int, int, int, int]]) -> List[Tuple[int, int]]: Calculate the total hours and minutes worked by each employee in a given day. For each employee, given their check-in hour and minute, and check-out hour and minute, calculate the total working hours and minutes. Args: n (int): The number of employees. times (List[Tuple[int, int, int, int]]): A list of tuples, each containing: - (H_in, M_in, H_out, M_out): where H_in and M_in are the check-in hour and minute, and H_out and M_out are the check-out hour and minute. Returns: List[Tuple[int, int]]: A list of tuples, each containing the total hours and minutes worked by an employee. Examples: >>> calculate_working_hours(2, [(9, 30, 17, 45), (10, 0, 18, 0)]) [(8, 15), (8, 0)] >>> calculate_working_hours(1, [(0, 0, 23, 59)]) [(23, 59)]","solution":"def calculate_working_hours(n, times): results = [] for time in times: Hin, Min, Hout, Mout = time total_minutes_in = Hin * 60 + Min total_minutes_out = Hout * 60 + Mout total_work_minutes = total_minutes_out - total_minutes_in hours_worked = total_work_minutes // 60 minutes_worked = total_work_minutes % 60 results.append((hours_worked, minutes_worked)) return results"},{"question":"def max_subsequence_length(n: int, d: int, sequence: List[int]) -> int: Returns the maximal possible length of a subsequence where the absolute difference between any two consecutive elements is at least d. Parameters: n (int): Length of the input sequence. d (int): Minimum allowed absolute difference. sequence (list of int): List of integers representing the sequence. Returns: int: Maximal length of the subsequence. >>> max_subsequence_length(5, 3, [1, 5, 3, 9, 7]) 3 >>> max_subsequence_length(6, 2, [4, 2, 6, 8, 3, 1]) 4 >>> max_subsequence_length(4, 5, [10, 1, 6, 2]) 2","solution":"def max_subsequence_length(n, d, sequence): Returns the maximal possible length of a subsequence where the absolute difference between any two consecutive elements is at least d. Parameters: n (int): Length of the input sequence. d (int): Minimum allowed absolute difference. sequence (list of int): List of integers representing the sequence. Returns: int: Maximal length of the subsequence. if not sequence: return 0 sequence.sort() count = 1 last_element = sequence[0] for i in range(1, n): if abs(sequence[i] - last_element) >= d: count += 1 last_element = sequence[i] return count # Example usage: # length = max_subsequence_length(5, 3, [1, 5, 3, 9, 7]) # print(length) # Output: 3"},{"question":"def waveSort(arr: List[int]) -> List[int]: Given an array of integers, sorts the array into a wave like array. :param arr: List[int] :return: List[int] Example: >>> waveSort([3, 6, 5, 10, 7, 20]) [3, 6, 5, 10, 7, 20] >>> waveSort([2, 4, 7, 8, 9, 10]) [2, 4, 7, 8, 9, 10]","solution":"def waveSort(arr): Given an array of integers, sorts the array into a wave like array. :param arr: List[int] :return: List[int] arr.sort() for i in range(0, len(arr)-1, 2): arr[i], arr[i+1] = arr[i+1], arr[i] return arr"},{"question":"def max_profit(prices): Find the maximum profit obtainable from at most two transactions. A transaction is defined as buying and then selling one unit of stock. :param prices: List[int] - A list of integer prices :return: int - The maximum profit >>> max_profit([3, 3, 5, 0, 0, 3, 1, 4]) 6 >>> max_profit([1, 2, 3, 4, 5]) 4 >>> max_profit([7, 6, 4, 3, 1]) 0 >>> max_profit([1]) 0 def test_max_profit_no_transaction(): assert max_profit([7, 6, 4, 3, 1]) == 0 def test_max_profit_single_transaction(): assert max_profit([1, 2, 3, 4, 5]) == 4 def test_max_profit_multi_transaction(): assert max_profit([3, 3, 5, 0, 0, 3, 1, 4]) == 6 def test_max_profit_single_price(): assert max_profit([1]) == 0 def test_max_profit_empty_list(): assert max_profit([]) == 0 def test_max_profit_alternating_prices(): assert max_profit([7, 1, 5, 3, 6, 4]) == 7 def test_max_profit_all_increasing(): assert max_profit([1, 2, 4, 6, 8, 10, 12]) == 11 def test_max_profit_all_decreasing(): assert max_profit([12, 10, 8, 6, 4, 2, 1]) == 0","solution":"def max_profit(prices): if not prices or len(prices) < 2: return 0 n = len(prices) max_profit_one_txn = [0] * n max_profit_two_txn = [0] * n min_price_so_far = prices[0] for i in range(1, n): min_price_so_far = min(min_price_so_far, prices[i]) max_profit_one_txn[i] = max(max_profit_one_txn[i-1], prices[i] - min_price_so_far) max_price_so_far = prices[-1] for i in range(n-2, -1, -1): max_price_so_far = max(max_price_so_far, prices[i]) max_profit_two_txn[i] = max(max_profit_two_txn[i+1], max_price_so_far - prices[i] + max_profit_one_txn[i]) return max(max_profit_two_txn)"},{"question":"import math from typing import List, Tuple def minimum_trips(T: int, test_cases: List[Tuple[int, int]]) -> List[int]: Given the number of test cases and for each test case: the total number of packages on the route and the maximum number of packages a delivery person can carry in one trip, determine the minimum number of trips needed to complete all deliveries on their assigned route. >>> minimum_trips(3, [(10, 3), (15, 5), (20, 4)]) [4, 3, 5] >>> minimum_trips(2, [(5, 5), (12, 6)]) [1, 2] >>> minimum_trips(1, [(7, 2)]) [4] >>> minimum_trips(4, [(99, 10), (100, 10), (1, 1), (100000, 100000)]) [10, 10, 1, 1] >>> minimum_trips(3, [(1, 2), (2, 2), (3, 2)]) [1, 1, 2]","solution":"import math def minimum_trips(T, test_cases): result = [] for i in range(T): N, K = test_cases[i] trips = math.ceil(N / K) result.append(trips) return result"},{"question":"def unique_paths_with_obstacles(grid: List[List[int]]) -> int: Calculate the number of unique paths from the top-left to the bottom-right corner of a grid, avoiding obstacles. >>> unique_paths_with_obstacles([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) 2 >>> unique_paths_with_obstacles([ ... [0, 0, 0, 1], ... [0, 1, 0, 0], ... [0, 0, 1, 0], ... [0, 0, 0, 0] ... ]) 3 >>> unique_paths_with_obstacles([ ... [0, 1], ... [1, 0] ... ]) 0 pass","solution":"def unique_paths_with_obstacles(grid): M = len(grid) N = len(grid[0]) if grid[0][0] == 1 or grid[M-1][N-1] == 1: return 0 dp = [[0]*N for _ in range(M)] dp[0][0] = 1 for i in range(M): for j in range(N): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[M-1][N-1]"},{"question":"def calculate_total_items(n, x): Calculate the total number of items a customer can get with 'buy n get x free' offer. >>> calculate_total_items(2, 3) 8 >>> calculate_total_items(5, 10) 55 >>> calculate_total_items(7, 2) 21 pass def process_input(input_data): Process multiple datasets and return the results of total items calculation. >>> process_input([\\"2 3\\", \\"5 10\\", \\"7 2\\", \\"0 0\\"]) [8, 55, 21] >>> process_input([\\"1 100\\", \\"10 0\\", \\"0 0\\"]) [101, 10] pass","solution":"def calculate_total_items(n, x): Calculate the total number of items a customer can get with 'buy n get x free' offer. if n == 0 and x == 0: return None return n + n * x def process_input(input_data): results = [] for line in input_data: n, x = map(int, line.split()) if n == 0 and x == 0: break result = calculate_total_items(n, x) if result is not None: results.append(result) return results"},{"question":"import math from typing import List def restore_array(b: List[int]) -> List[int]: Given an array b where b[i] = a[i] * a[i], restore and return the original array a. >>> restore_array([1, 4, 9, 16]) [1, 2, 3, 4] >>> restore_array([81]) [9] >>> restore_array([25, 25, 1]) [5, 5, 1] def test_restore_array_example1(): assert restore_array([1, 4, 9, 16]) == [1, 2, 3, 4] def test_restore_array_example2(): assert restore_array([81]) == [9] def test_restore_array_example3(): assert restore_array([25, 25, 1]) == [5, 5, 1] def test_restore_array_single_element(): assert restore_array([100]) == [10] def test_restore_array_large_numbers(): assert restore_array([1000000, 4000000, 9000000]) == [1000, 2000, 3000] def test_restore_array_mixed_numbers(): assert restore_array([1, 4, 100, 25]) == [1, 2, 10, 5] def test_restore_array_distinct_numbers(): assert restore_array([9, 49, 144, 225]) == [3, 7, 12, 15]","solution":"import math def restore_array(b): Given an array b where b[i] = a[i] * a[i], restore and return the original array a. return [int(math.sqrt(b_i)) for b_i in b] # Example usage: # b = [1, 4, 9, 16] # print(restore_array(b)) # Output will be [1, 2, 3, 4]"},{"question":"def max_sum_weights(input_string: str) -> List[int]: Determine the maximum possible sum of weights of two books that Bob can achieve for each test case. >>> max_sum_weights(\\"3n3n1 2 4n4n5 1 2 9n5n7 5 12 8 10n\\") [6, 14, 22] >>> max_sum_weights(\\"1n2n1 2n\\") [3] >>> max_sum_weights(\\"1n5n3 3 3 3 3n\\") [6] >>> max_sum_weights(\\"1n3n999999999 1000000000 999999998n\\") [1999999999] >>> max_sum_weights(\\"1n4n10 8 6 4n\\") [18] >>> max_sum_weights(\\"1n5n1 2 3 4 5n\\") [9]","solution":"def max_sum_of_two_books(test_cases): results = [] for books in test_cases: # Sort the books weights weights = sorted(books) # The maximum sum of two books will be the sum of the two heaviest books results.append(weights[-1] + weights[-2]) return results # Helper function to parse input into format required by max_sum_of_two_books function def parse_input(input_string): data = input_string.strip().split('n') idx = 0 t = int(data[idx]) idx += 1 test_cases = [] for _ in range(t): n = int(data[idx]) idx += 1 weights = list(map(int, data[idx].split())) idx += 1 test_cases.append(weights) return test_cases def max_sum_weights(input_string): test_cases = parse_input(input_string) return max_sum_of_two_books(test_cases)"},{"question":"class QueueUsingStacks: Implement a Queue using two stacks stack1 and stack2. Methods: enqueue(x: int) -> None: Enqueue an element 'x' into the queue. dequeue() -> int: Dequeue an element from the queue, returning -1 if the queue is empty. def __init__(self): self.stack1 = [] self.stack2 = [] def enqueue(self, x: int) -> None: Enqueue an element 'x' into the queue. # Your code here def dequeue(self) -> int: Dequeue an element from the queue, returning -1 if the queue is empty. # Your code here # Unit Tests def test_enqueue_dequeue(): queue = QueueUsingStacks() queue.enqueue(2) queue.enqueue(3) assert queue.dequeue() == 2 queue.enqueue(4) assert queue.dequeue() == 3 assert queue.dequeue() == 4 def test_only_enqueue(): queue = QueueUsingStacks() queue.enqueue(1) queue.enqueue(2) queue.enqueue(3) assert queue.dequeue() == 1 assert queue.dequeue() == 2 assert queue.dequeue() == 3 def test_empty_dequeue(): queue = QueueUsingStacks() assert queue.dequeue() == -1 def test_mixed_operations(): queue = QueueUsingStacks() queue.enqueue(10) queue.enqueue(20) assert queue.dequeue() == 10 queue.enqueue(30) queue.enqueue(40) assert queue.dequeue() == 20 queue.enqueue(50) assert queue.dequeue() == 30 assert queue.dequeue() == 40 assert queue.dequeue() == 50 assert queue.dequeue() == -1","solution":"class QueueUsingStacks: def __init__(self): self.stack1 = [] self.stack2 = [] def enqueue(self, x): self.stack1.append(x) def dequeue(self): if not self.stack2: while self.stack1: self.stack2.append(self.stack1.pop()) if not self.stack2: return -1 return self.stack2.pop()"},{"question":"def can_partition(nums: List[int]) -> bool: Determine if the list can be partitioned into two subsets with equal sum. Args: nums (List[int]): A list of non-negative integers Returns: bool: True if it can be partitioned into two subsets with equal sum, False otherwise Examples: >>> can_partition([1, 5, 11, 5]) True >>> can_partition([1, 2, 3, 5]) False","solution":"def can_partition(nums): Determine if the list can be partitioned into two subsets with equal sum. total_sum = sum(nums) # If total sum is odd, we cannot partition it into two equal subsets if total_sum % 2 != 0: return False target = total_sum // 2 dp = [False] * (target + 1) dp[0] = True for num in nums: for i in range(target, num - 1, -1): dp[i] = dp[i] | dp[i - num] return dp[target]"},{"question":"def word_break(s: str, word_dict: set) -> bool: Given a string and a dictionary of words, determine if the string can be segmented into a space-separated sequence of one or more dictionary words. :param s: A string to be segmented. :param word_dict: A set of strings representing the dictionary of words. :return: True if the string can be segmented using the dictionary words, False otherwise. >>> word_break(\\"applepie\\", {\\"apple\\", \\"pie\\"}) True >>> word_break(\\"applepie\\", {\\"apple\\", \\"pea\\"}) False >>> word_break(\\"\\", {\\"apple\\", \\"pie\\"}) True >>> word_break(\\"apple\\", {\\"apple\\"}) True >>> word_break(\\"applepie\\", {\\"apple\\"}) False >>> word_break(\\"appleapple\\", {\\"apple\\"}) True >>> word_break(\\"leetcode\\", {\\"leet\\", \\"code\\"}) True >>> word_break(\\"catsandog\\", {\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"}) False >>> word_break(\\"pineapplepenapple\\", {\\"apple\\", \\"pen\\", \\"applepen\\", \\"pine\\", \\"pineapple\\"}) True","solution":"def word_break(s: str, word_dict: set) -> bool: Given a string and a dictionary of words, determine if the string can be segmented into a space-separated sequence of one or more dictionary words. :param s: A string to be segmented. :param word_dict: A set of strings representing the dictionary of words. :return: True if the string can be segmented using the dictionary words, False otherwise. n = len(s) dp = [False] * (n + 1) dp[0] = True for i in range(1, n + 1): for j in range(i): if dp[j] and s[j:i] in word_dict: dp[i] = True break return dp[n]"},{"question":"def are_anagrams(str1: str, str2: str) -> bool: Returns True if str1 and str2 are anagrams of each other, False otherwise. Non-alphabet characters are disregarded and case is ignored. >>> are_anagrams(\\"Listen\\", \\"Silent\\") == True >>> are_anagrams(\\"A gentleman!\\", \\"Elegant man.\\") == True >>> are_anagrams(\\"Clint Eastwood\\", \\"Old West action\\") == True >>> are_anagrams(\\"Programming\\", \\"Gram ring mop!\\") == True >>> are_anagrams(\\"Apple\\", \\"Peach\\") == False","solution":"def are_anagrams(str1: str, str2: str) -> bool: Returns True if str1 and str2 are anagrams of each other, False otherwise. Non-alphabet characters are disregarded and case is ignored. from collections import Counter import re # Function to clean and prepare the string for comparison def clean_string(s: str) -> str: # Remove non-alphabetic characters and convert to lowercase return re.sub(r'[^a-z]', '', s.lower()) clean_str1 = clean_string(str1) clean_str2 = clean_string(str2) # Compare the character counts of both strings return Counter(clean_str1) == Counter(clean_str2)"},{"question":"def max_bundles(K: int, piles: List[int]) -> int: Determine the maximum number of bundles Petya can form given the piles of coins and the bundle size K. >>> max_bundles(6, [3, 5, 2, 7, 1, 8]) 2 >>> max_bundles(4, [4, 8, 12, 16]) 10 >>> max_bundles(5, [5, 10, 15, 20]) 10 >>> max_bundles(10, [10, 20, 30, 40, 50]) 15 >>> max_bundles(1, [1, 1, 1, 1]) 4 >>> max_bundles(100, [10, 20, 30, 40]) 0 >>> max_bundles(10, [0, 0, 0, 0]) 0","solution":"def max_bundles(K, piles): bundles_count = 0 for pile in piles: bundles_count += pile // K return bundles_count if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() K = int(data[0]) piles = list(map(int, data[1:])) print(max_bundles(K, piles))"},{"question":"def competition_results(test_cases): Determine for each participant if they pass or fail based on ingredient usage. Args: test_cases: A list of tuples, each containing: - N (int): The number of participants. - K (int): The total number of ingredients available (not used in logic). - R (int): The threshold of different ingredients required to pass. - participants (List[int]): A list of integers representing the number of different ingredients used by each participant. Returns: List[List[int]]: A list of lists containing binary integers (0 or 1) indicating if participants pass (1) or fail (0). pass def parse_input(input_data): Parse the input data to extract the test cases. Args: input_data (str): The input data as a multiline string. Returns: List[Tuple[int, int, int, List[int]]]: A list of tuples, each containing test case data. pass def format_output(results): Format the output data to the required string format. Args: results (List[List[int]]): A list of lists containing binary integers indicating results of each test case. Returns: str: A formatted string with results for all test cases. pass # Here are some test cases to validate the correctness of your implementation def test_competition_results_case_1(): assert competition_results([(3, 5, 3, [2, 4, 5])]) == [[0, 1, 1]] def test_competition_results_case_2(): assert competition_results([(4, 8, 6, [5, 6, 8, 7])]) == [[0, 1, 1, 1]] def test_parse_input(): input_data = \\"2n3 5 3n2 4 5n4 8 6n5 6 8 7n\\" expected_output = [ (3, 5, 3, [2, 4, 5]), (4, 8, 6, [5, 6, 8, 7]) ] assert parse_input(input_data) == expected_output def test_format_output(): results = [ [0, 1, 1], [0, 1, 1, 1] ] expected_output = \\"0 1 1n0 1 1 1\\" assert format_output(results) == expected_output def test_integration(): input_data = \\"2n3 5 3n2 4 5n4 8 6n5 6 8 7n\\" test_cases = parse_input(input_data) results = competition_results(test_cases) output_result = format_output(results) expected_output = \\"0 1 1n0 1 1 1\\" assert output_result == expected_output","solution":"def competition_results(test_cases): results = [] for case in test_cases: N, K, R, participants = case result = [] for p in participants: if p >= R: result.append(1) else: result.append(0) results.append(result) return results # Function to parse the input and generate the appropriate data structure def parse_input(input_data): lines = input_data.strip().split('n') T = int(lines[0]) test_cases = [] idx = 1 for _ in range(T): N, K, R = map(int, lines[idx].split()) participants = list(map(int, lines[idx + 1].split())) test_cases.append((N, K, R, participants)) idx += 2 return test_cases # Function to convert the output to the required format def format_output(results): formatted_results = [] for result in results: formatted_results.append(' '.join(map(str, result))) return 'n'.join(formatted_results)"},{"question":"def max_robbery(houses): Returns the maximum amount of money that can be robbed without triggering the alarm. :param houses: List of non-negative integers representing the amount of money in each house. :return: Maximum amount of money that can be robbed. >>> max_robbery([]) 0 >>> max_robbery([5]) 5 >>> max_robbery([1, 2, 3, 1]) 4 >>> max_robbery([2, 7, 9, 3, 1]) 12 >>> max_robbery([5, 3, 4, 11, 2]) 16 >>> max_robbery([0, 0, 0, 0]) 0 >>> max_robbery([1, 1, 1, 1, 1]) 3","solution":"def max_robbery(houses): Returns the maximum amount of money that can be robbed without triggering the alarm. :param houses: List of non-negative integers representing the amount of money in each house. :return: Maximum amount of money that can be robbed. n = len(houses) if n == 0: return 0 if n == 1: return houses[0] dp = [0] * n dp[0] = houses[0] dp[1] = max(houses[0], houses[1]) for i in range(2, n): dp[i] = max(houses[i] + dp[i - 2], dp[i - 1]) return dp[-1]"},{"question":"def can_form_palindrome(s: str) -> str: Determines if the input string can be rearranged to form a palindrome. Args: s (str): The input string consisting of lowercase English letters. Returns: str: 'Yes' if the string can be rearranged to form a palindrome, otherwise 'No'. >>> can_form_palindrome(\\"aabb\\") 'Yes' >>> can_form_palindrome(\\"aaabb\\") 'Yes' >>> can_form_palindrome(\\"abc\\") 'No' >>> can_form_palindrome(\\"racecar\\") 'Yes' >>> can_form_palindrome(\\"xxyyyzzz\\") 'No'","solution":"def can_form_palindrome(s): Determines if the input string can be rearranged to form a palindrome. Args: s (str): The input string consisting of lowercase English letters. Returns: str: 'Yes' if the string can be rearranged to form a palindrome, otherwise 'No'. from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # Count how many characters have an odd frequency odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # The string can be rearranged to form a palindrome if at most one character has an odd count if odd_count <= 1: return 'Yes' else: return 'No'"},{"question":"def is_anagram(str1, str2): Determines if two given strings are anagrams of each other by ignoring spaces, punctuation, and considering uppercase and lowercase letters as the same. Parameters: str1 (string): the first string to compare str2 (string): the second string to compare Returns: string: 'anagram' or 'not anagram' >>> is_anagram(\\"listen\\", \\"silent\\") 'anagram' >>> is_anagram(\\"modern\\", \\"normed kayak\\") 'not anagram' >>> is_anagram(\\"A gentleman\\", \\"Elegant man!\\") 'anagram' >>> is_anagram(\\"hello\\", \\"world\\") 'not anagram'","solution":"def is_anagram(str1, str2): Determines if two given strings are anagrams of each other by ignoring spaces, punctuation, and considering uppercase and lowercase letters as the same. Parameters: str1 (string): the first string to compare str2 (string): the second string to compare Returns: string: 'anagram' or 'not anagram' import re # Remove all non-alphabetical characters and convert to lowercase cleaned_str1 = re.sub(r'[^a-zA-Z]', '', str1).lower() cleaned_str2 = re.sub(r'[^a-zA-Z]', '', str2).lower() # Compare sorted versions of the cleaned strings if sorted(cleaned_str1) == sorted(cleaned_str2): return 'anagram' else: return 'not anagram'"},{"question":"def count_bubble_sort_swaps(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given an array of integers, this function counts the number of swaps needed for the bubble sort algorithm to sort the array in ascending order. :param T: Number of test cases. :param test_cases: A list of tuples, where each tuple contains: - an integer representing the size of the array - a list of integers representing the array :return: A list of integers where each integer represents the number of swaps needed for the corresponding test case >>> count_bubble_sort_swaps(3, [(5, [1, 3, 2, 5, 4]), (5, [5, 4, 3, 2, 1]), (3, [3, 2, 1])]) [2, 10, 3]","solution":"def count_bubble_sort_swaps(T, test_cases): This function implements the bubble sort algorithm and counts the number of swaps required to sort the array in ascending order for multiple test cases. :param T: Number of test cases :param test_cases: A list of tuples, where each tuple contains: - the size of the array - the array itself :return: A list of integers where each integer represents the number of swaps needed for the corresponding test case result = [] for n, a in test_cases: swaps = 0 for i in range(n): for j in range(0, n - i - 1): if a[j] > a[j + 1]: a[j], a[j + 1] = a[j + 1], a[j] swaps += 1 result.append(swaps) return result"},{"question":"def right_angled_triangle_area(base: int, height: int) -> int: Calculates the area of a right-angled triangle given its base and height. >>> right_angled_triangle_area(5, 3) 7 >>> right_angled_triangle_area(1, 1) 0 >>> right_angled_triangle_area(10, 10) 50 >>> right_angled_triangle_area(7, 4) 14 >>> right_angled_triangle_area(99, 1) 49 >>> right_angled_triangle_area(100, 100) 5000 >>> right_angled_triangle_area(2, 50) 50 >>> right_angled_triangle_area(6, 6) 18","solution":"def right_angled_triangle_area(base, height): Calculates the area of a right-angled triangle given its base and height. return (base * height) // 2"},{"question":"def find_most_similar_user(users): Finds the most similar user based on the number of common interests. Parameters: users (List[Tuple[str, List[str]]]): A list of tuples where each tuple contains a user identifier and their interests. Returns: Tuple[str, str]: The pair of most similar users. >>> users = [(\\"Alice\\", [\\"reading\\", \\"cycling\\"]), (\\"Bob\\", [\\"reading\\", \\"gaming\\"]), (\\"Charlie\\", [\\"cycling\\", \\"baking\\"]), (\\"Dana\\", [\\"reading\\", \\"cooking\\"])] >>> find_most_similar_user(users) ('Alice', 'Bob')","solution":"def find_most_similar_user(users): Finds the most similar user based on the number of common interests. Parameters: users (List[Tuple[str, List[str]]]): A list of tuples where each tuple contains a user identifier and their interests. Returns: Tuple[str, str]: The pair of most similar users. def common_interests_count(interests1, interests2): return len(set(interests1) & set(interests2)) max_common_interests = -1 most_similar_pair = (\\"\\", \\"\\") for i in range(len(users)): for j in range(i+1, len(users)): user1, interests1 = users[i] user2, interests2 = users[j] common_count = common_interests_count(interests1, interests2) if common_count > max_common_interests: max_common_interests = common_count most_similar_pair = (user1, user2) return most_similar_pair"},{"question":"def remove_kth_from_end(head, k): Removes the k-th node from the end of the linked list. If k is greater than the length of the list, the list is returned unchanged. >>> head = create_linked_list([1, 2, 3, 4, 5]) >>> k = 2 >>> new_head = remove_kth_from_end(head, k) >>> linked_list_to_list(new_head) [1, 2, 3, 5] >>> head = create_linked_list([1, 2, 3, 4, 5]) >>> k = 6 >>> new_head = remove_kth_from_end(head, k) >>> linked_list_to_list(new_head) [1, 2, 3, 4, 5] # Helper function to create linked list from list def create_linked_list(elements): head = ListNode(elements[0]) current = head for element in elements[1:]: current.next = ListNode(element) current = current.next return head # Helper function to convert linked list to list def linked_list_to_list(head): elements = [] while head: elements.append(head.val) head = head.next return elements class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_kth_from_end(head, k): Removes the k-th node from the end of the linked list. If k is greater than the length of the list, the list is returned unchanged. dummy = ListNode(0) dummy.next = head first = second = dummy # Move first k+1 steps ahead for _ in range(k + 1): if not first: return head first = first.next # Move first to the end, maintaining the gap while first: first = first.next second = second.next # Remove the k-th node second.next = second.next.next return dummy.next # Helper function to create linked list from list def create_linked_list(elements): head = ListNode(elements[0]) current = head for element in elements[1:]: current.next = ListNode(element) current = current.next return head # Helper function to convert linked list to list def linked_list_to_list(head): elements = [] while head: elements.append(head.val) head = head.next return elements"},{"question":"from typing import List def find_pair_with_sum(arr: List[int], target: int) -> List[int]: Determines if there are two distinct elements in the array that add up to the target sum. Returns a list of their indices or an empty list if no such pair exists. >>> find_pair_with_sum([1, 2, 3, 4, 5], 6) [1, 3] >>> find_pair_with_sum([0, -1, 1], 0) [1, 2] >>> find_pair_with_sum([1, 2, 3, 4], 10) []","solution":"from typing import List def find_pair_with_sum(arr: List[int], target: int) -> List[int]: Returns the indices of the two distinct elements that add up to the target sum. If no such pair exists, returns an empty list. num_to_index = {} for i, num in enumerate(arr): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i return []"},{"question":"from typing import List def twist_sort(arr: List[int]) -> List[int]: Sorts the array using the Twist Sort algorithm. The Twist Sort algorithm sorts pairs of adjacent elements and iteratively merges these pairs. Args: arr (List[int]): A list of n integers to be sorted. Returns: List[int]: A sorted list of n integers. Examples: >>> twist_sort([4, 3, 2, 8, 1, 5]) [1, 2, 3, 4, 5, 8] >>> twist_sort([10, 7, 5, 2, 9]) [2, 5, 7, 9, 10] pass def test_twist_sort_basic(): assert twist_sort([4, 3, 2, 8, 1, 5]) == [1, 2, 3, 4, 5, 8] def test_twist_sort_with_odd_elements(): assert twist_sort([10, 7, 5, 2, 9]) == [2, 5, 7, 9, 10] def test_twist_sort_single_element(): assert twist_sort([1]) == [1] def test_twist_sort_two_elements(): assert twist_sort([2, 1]) == [1, 2] def test_twist_sort_sorted(): assert twist_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] def test_twist_sort_reverse_sorted(): assert twist_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] def test_twist_sort_mixed_numbers(): assert twist_sort([0, -1, 3, -2, 2, 1]) == [-2, -1, 0, 1, 2, 3] def test_twist_sort_large_input(): import random arr = [random.randint(-10**6, 10**6) for _ in range(100000)] assert twist_sort(arr) == sorted(arr)","solution":"def twist_sort(arr): Sorts the array using the Twist Sort algorithm. n = len(arr) if n < 2: return arr[:] # Step 1: Sort adjacent pairs sorted_pairs = [] for i in range(0, n - 1, 2): if arr[i] > arr[i + 1]: sorted_pairs.append((arr[i + 1], arr[i])) else: sorted_pairs.append((arr[i], arr[i + 1])) if n % 2 == 1: sorted_pairs.append((arr[-1],)) # Step 2: Iteratively merge the pairs while len(sorted_pairs) > 1: new_pairs = [] i = 0 while i < len(sorted_pairs) - 1: new_pairs.append(_merge(sorted_pairs[i], sorted_pairs[i + 1])) i += 2 if len(sorted_pairs) % 2 == 1: new_pairs.append(sorted_pairs[-1]) sorted_pairs = new_pairs return list(sorted_pairs[0]) def _merge(pair1, pair2): Merges two sorted pairs into one. merged = [] i, j = 0, 0 while i < len(pair1) and j < len(pair2): if pair1[i] <= pair2[j]: merged.append(pair1[i]) i += 1 else: merged.append(pair2[j]) j += 1 while i < len(pair1): merged.append(pair1[i]) i += 1 while j < len(pair2): merged.append(pair2[j]) j += 1 return tuple(merged)"},{"question":"from typing import List def minimum_moves_to_deliver_package(grid: List[str], n: int, m: int) -> int: Determine the minimum number of moves required for the drone to reach the destination, or return -1 if it's impossible. Arguments: grid: List of strings representing the warehouse layout. n: Number of rows in the grid. m: Number of columns in the grid. Returns: int: Minimum number of moves to reach the destination or -1 if impossible. >>> minimum_moves_to_deliver_package([\\".....\\", \\".***.\\", \\".....\\", \\".***.\\", \\".....\\"], 5, 5) 8 >>> minimum_moves_to_deliver_package([\\".***\\", \\"*...\\", \\"....\\"], 3, 4) -1 def execute_minimum_moves(n: int, m: int, layout: List[str]) -> int: Execute the minimum_moves_to_deliver_package function with provided inputs. Args: n: int, number of rows in the grid. m: int, number of columns in the grid. layout: List of strings representing the grid. Returns: int: minimum number of moves or -1 if unreachable.","solution":"from collections import deque def minimum_moves_to_deliver_package(grid, n, m): Determine the minimum number of moves required for the drone to reach the destination, or return -1 if it's impossible. Arguments: grid: List of strings representing the warehouse layout. n: Number of rows in the grid. m: Number of columns in the grid. Returns: int: Minimum number of moves to reach the destination or -1 if impossible. if grid[0][0] == '*' or grid[n-1][m-1] == '*': return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0)]) # Start from (0, 0) moves = [[-1 for _ in range(m)] for _ in range(n)] moves[0][0] = 0 # Starting point while queue: x, y = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == '.' and moves[nx][ny] == -1: moves[nx][ny] = moves[x][y] + 1 queue.append((nx, ny)) return moves[n-1][m-1] def execute_minimum_moves(n, m, layout): Execute the minimum_moves_to_deliver_package function with provided inputs. Args: n: int, number of rows in the grid. m: int, number of columns in the grid. layout: List of strings representing the grid. Returns: int: minimum number of moves or -1 if unreachable. return minimum_moves_to_deliver_package(layout, n, m)"},{"question":"def unique_paths(n: int, m: int) -> int: Given an n x m grid, find the number of unique paths from the top-left corner to the bottom-right corner of the grid, such that no cell is visited more than once and movement is restricted to either right or down. The result should be returned as the number of unique paths modulo 1000000007. >>> unique_paths(2, 2) 2 >>> unique_paths(3, 3) 6 >>> unique_paths(1, 100) 1","solution":"def unique_paths(n, m): MOD = 1000000007 # initialize a 2D list with zeroes dp = [[0] * m for _ in range(n)] # set the number of ways to reach each cell in the first row and first column to 1 for i in range(n): dp[i][0] = 1 for j in range(m): dp[0][j] = 1 # fill the dp table for i in range(1, n): for j in range(1, m): dp[i][j] = (dp[i-1][j] + dp[i][j-1]) % MOD return dp[n-1][m-1] # Read input if __name__ == \\"__main__\\": import sys input = sys.stdin.read n, m = map(int, input().split()) print(unique_paths(n, m))"},{"question":"def factorial(n): Returns the factorial of the given non-negative integer n. >>> factorial(5) 120 >>> factorial(0) 1","solution":"def factorial(n): Returns the factorial of the given non-negative integer n. if n == 0: return 1 result = 1 for i in range(1, n + 1): result *= i return result"},{"question":"def max_energy_sum(N, energy_values): In a magical forest, there are N trees arranged in a straight line. Each tree has a unique magical value associated with it, called the energy value Ei of tree i. The magical value can be positive, zero, or negative. A magician wants to find the maximum sum of the energy values of any contiguous subarray of trees. However, the magician can also choose not to pick any subarray if the maximum sum of all possible subarrays is negative, in which case the result would be 0. The goal is to find the maximum sum of the energy values of any contiguous subarray of trees, or 0 if none of the sums is positive. Args: N (int): The number of trees. energy_values (List[int]): Energy values for each tree. Returns: int: The maximum sum of any contiguous subarray, or 0 if no positive sum exists. Examples: >>> max_energy_sum(4, [-2, 1, -3, 4]) 4 >>> max_energy_sum(5, [-1, -2, -3, -4, -5]) 0 >>> max_energy_sum(3, [1, -2, 3]) 3 from solution import max_energy_sum def test_all_positive(): assert max_energy_sum(4, [1, 2, 3, 4]) == 10 def test_all_negative(): assert max_energy_sum(5, [-1, -2, -3, -4, -5]) == 0 def test_mixed_signs(): assert max_energy_sum(4, [-2, 1, -3, 4]) == 4 def test_single_positive(): assert max_energy_sum(1, [5]) == 5 def test_single_negative(): assert max_energy_sum(1, [-5]) == 0 def test_multiple_contiguous_max_sum(): assert max_energy_sum(6, [-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 # (4 + (-1) + 2 + 1) def test_zeros_and_negatives(): assert max_energy_sum(5, [0, -1, 0, -2, -3]) == 0 def test_zeros_and_positives(): assert max_energy_sum(5, [0, 2, 0, 3, 0]) == 5 def test_large_input(): assert max_energy_sum(5, [1000000000, -1, -1, 1000000000, -1]) == 1999999998","solution":"def max_energy_sum(N, energy_values): Returns the maximum sum of contiguous subarray of trees or 0 if all sums are negative. # Initialize current and max sums max_sum = current_sum = 0 has_positive = any(e > 0 for e in energy_values) # To check if there's any positive number if not has_positive: return 0 # If no positive numbers are present, return 0 for value in energy_values: current_sum = max(0, current_sum + value) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def countIslands(grid) -> int: Returns the number of distinct islands in the given 2D binary grid. >>> countIslands([ ... [1, 1, 0, 0, 0], ... [1, 1, 0, 0, 0], ... [0, 0, 1, 0, 0], ... [0, 0, 0, 1, 1] ... ]) == 3 >>> countIslands([ ... [1, 0], ... [0, 0] ... ]) == 1 >>> countIslands([ ... [0, 0], ... [0, 0] ... ]) == 0 >>> countIslands([ ... [1, 0, 1, 0], ... [0, 1, 0, 1], ... [1, 0, 1, 0], ... [0, 1, 0, 1] ... ]) == 8 >>> countIslands([ ... [1] * 100 for _ in range(100) ... ]) == 1","solution":"def countIslands(grid): Returns the number of distinct islands in the given 2D binary grid. def dfs(grid, visited, i, j): stack = [(i, j)] while stack: x, y = stack.pop() for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and not visited[nx][ny] and grid[nx][ny] == 1: visited[nx][ny] = True stack.append((nx, ny)) if not grid: return 0 m, n = len(grid), len(grid[0]) visited = [[False for _ in range(n)] for _ in range(m)] islands_count = 0 for i in range(m): for j in range(n): if grid[i][j] == 1 and not visited[i][j]: dfs(grid, visited, i, j) islands_count += 1 return islands_count"},{"question":"def minimum_magical_operations(N: int, ingredients: List[Tuple[int, int]]) -> int: Determines the minimum number of magical operations required to collect exactly k units of each of the N ingredients. >>> minimum_magical_operations(3, [(10, 3), (15, 4), (20, 5)]) 12 >>> minimum_magical_operations(1, [(10, 2)]) 5 >>> minimum_magical_operations(2, [(1, 1), (10, 10)]) 2 >>> minimum_magical_operations(2, [(10**9, 1), (1, 10**9)]) 1000000001 >>> minimum_magical_operations(1, [(1, 1)]) 1","solution":"def minimum_magical_operations(N, ingredients): total_operations = 0 for k, m in ingredients: total_operations += (k + m - 1) // m return total_operations # Example usage: # N = 3 # ingredients = [(10, 3), (15, 4), (20, 5)] # print(minimum_magical_operations(N, ingredients)) # Output: 12"},{"question":"def is_valid_parentheses(sequence: str) -> str: Determine if the given sequence of parentheses is valid. :param sequence: A string containing '(', ')', '{', '}', '[' and ']'. :return: \\"YES\\" if the sequence is valid, otherwise \\"NO\\". >>> is_valid_parentheses(\\"()\\") == \\"YES\\" >>> is_valid_parentheses(\\"([])()\\") == \\"YES\\" >>> is_valid_parentheses(\\"{[()()]}\\") == \\"YES\\" >>> is_valid_parentheses(\\"\\") == \\"YES\\" >>> is_valid_parentheses(\\"(\\") == \\"NO\\" >>> is_valid_parentheses(\\"([)]\\") == \\"NO\\" >>> is_valid_parentheses(\\"([{})\\") == \\"NO\\" >>> is_valid_parentheses(\\")\\") == \\"NO\\" >>> is_valid_parentheses(\\"((()))[\\") == \\"NO\\" >>> is_valid_parentheses(\\"{[()]}(){}\\") == \\"YES\\" >>> is_valid_parentheses(\\"{[()]}}\\") == \\"NO\\" >>> is_valid_parentheses(\\"{[(])}\\") == \\"NO\\" >>> is_valid_parentheses(\\"{{[[(())]]}}\\") == \\"YES\\" >>> is_valid_parentheses(\\"{[(])\\") == \\"NO\\"","solution":"def is_valid_parentheses(sequence): Determine if the given sequence of parentheses is valid. :param sequence: A string containing '(', ')', '{', '}', '[' and ']'. :return: \\"YES\\" if the sequence is valid, otherwise \\"NO\\". stack = [] matching_bracket = {')': '(', '}': '{', ']': '['} for char in sequence: if char in matching_bracket.values(): stack.append(char) elif char in matching_bracket.keys(): if stack == [] or stack.pop() != matching_bracket[char]: return \\"NO\\" else: return \\"NO\\" # Invalid character, though it should not be possible with the given input constraints if stack: return \\"NO\\" else: return \\"YES\\" # Example usage: # print(is_valid_parentheses(\\"([])()\\")) # Output: YES # print(is_valid_parentheses(\\"([)]\\")) # Output: NO"},{"question":"def min_max_temperature(n, records, q, queries): Computes the minimum and maximum temperatures over a specific range of time for multiple queries. Parameters: n (int): number of temperature records records (list of tuples): each tuple contains (time, temperature) q (int): number of queries queries (list of tuples): each tuple contains (start_time, end_time) Returns: list of tuples: each tuple contains (min_temperature, max_temperature) for the respective query >>> min_max_temperature(6, [(1, 30), (2, 35), (3, 25), (4, 40), (5, 32), (6, 28)], 3, [(1, 3), (2, 5), (4, 6)]) [(25, 35), (25, 40), (28, 40)] >>> min_max_temperature(3, [(1, 30), (3, 25), (5, 32)], 2, [(2, 2), (4, 4)]) []","solution":"def min_max_temperature(n, records, q, queries): Computes the minimum and maximum temperatures over a specific range of time for multiple queries. Parameters: n (int): number of temperature records records (list of tuples): each tuple contains (time, temperature) q (int): number of queries queries (list of tuples): each tuple contains (start_time, end_time) Returns: list of tuples: each tuple contains (min_temperature, max_temperature) for the respective query results = [] # Convert records into a dictionary for quick access temp_dict = {time: temp for time, temp in records} for start, end in queries: temps = [temp_dict[time] for time in range(start, end + 1) if time in temp_dict] if temps: min_temp = min(temps) max_temp = max(temps) results.append((min_temp, max_temp)) return results"},{"question":"def lexicographically_smallest_array(n, arr): Return the lexicographically smallest array possible by swapping elements. >>> lexicographically_smallest_array(3, [3, 2, 1]) [1, 2, 3] >>> lexicographically_smallest_array(5, [5, 3, 2, 4, 1]) [1, 2, 3, 4, 5] def process_test_cases(T, test_cases): Process the given test cases and return the results. >>> T = 2 >>> test_cases = [(3, [3, 2, 1]), (5, [5, 3, 2, 4, 1])] >>> process_test_cases(T, test_cases) ['1 2 3', '1 2 3 4 5']","solution":"def lexicographically_smallest_array(n, arr): Return the lexicographically smallest array possible by swapping elements. return sorted(arr) def process_test_cases(T, test_cases): Process the given test cases and return the results. results = [] for i in range(T): n, arr = test_cases[i] smallest_array = lexicographically_smallest_array(n, arr) results.append(\\" \\".join(map(str, smallest_array))) return results"},{"question":"def max_ones_after_flip(t: int, test_cases: List[Tuple[int, str]]) -> List[int]: Determine the maximum number of 1s obtainable by flipping a contiguous substring of a binary string exactly once. >>> max_ones_after_flip(1, [(5, '11111')]) [4] >>> max_ones_after_flip(1, [(8, '00000000')]) [8] >>> max_ones_after_flip(1, [(6, '110100')]) [5] >>> max_ones_after_flip(3, [(5, '11111'), (8, '00000000'), (6, '110100')]) [4, 8, 5] >>> max_ones_after_flip(2, [(1, '0'), (1, '1')]) [1, 0]","solution":"def max_ones_after_flip(t, test_cases): results = [] for i in range(t): n, s = test_cases[i] # Initial number of 1s in the string initial_ones = s.count('1') # Kadane's algorithm to find the subarray (substring) that we should flip max_diff = 0 current_diff = 0 for char in s: value = 1 if char == '0' else -1 current_diff = max(current_diff + value, value) max_diff = max(max_diff, current_diff) # If initial_ones is already n, flip any substring will only decrease the number of 1s if initial_ones == n: results.append(n - 1) else: results.append(initial_ones + max_diff) return results"},{"question":"def max_books_stack(f: int, nf: int) -> int: Calculate the maximum number of books that can be in the stack such that no two fiction books are adjacent. :param f: number of fiction books :param nf: number of non-fiction books :return: the maximum number of books in the stack that follows the rule >>> max_books_stack(3, 5) 8 >>> max_books_stack(4, 2) 0","solution":"def max_books_stack(f, nf): Calculate the maximum number of books that can be in the stack such that no two fiction books are adjacent. :param f: number of fiction books :param nf: number of non-fiction books :return: the maximum number of books in the stack that follows the rule if f > nf + 1: return 0 return f + nf"},{"question":"def longest_contiguous_subarray(N: int, X: int, A: List[int]) -> int: Finds the length of the longest contiguous subarray where the difference between the maximum and minimum element in the subarray is at most X. Args: N : int : The number of elements in array A. X : int : The maximum allowed difference between the maximum and minimum element in any contiguous subarray. A : List[int] : The list of integers. Returns: int : The length of the longest contiguous subarray where the difference between the maximum and minimum element is at most X. >>> longest_contiguous_subarray(6, 3, [10, 1, 2, 3, 10, 4]) 3 >>> longest_contiguous_subarray(5, 10, [1, 2, 5, 6, 7]) 5 >>> longest_contiguous_subarray(5, 1, [1, 2, 2, 3, 9]) 3 # TODO: Implement this function","solution":"def longest_contiguous_subarray(N, X, A): Finds the length of the longest contiguous subarray where the difference between the maximum and minimum element in the subarray is at most X. max_length = 0 for i in range(N): min_val = A[i] max_val = A[i] for j in range(i, N): min_val = min(min_val, A[j]) max_val = max(max_val, A[j]) if max_val - min_val <= X: max_length = max(max_length, j - i + 1) else: break return max_length"},{"question":"def spiralTraversal(matrix): Write a function called \`spiralTraversal\` that takes a 2D matrix (a list of lists) as an argument and returns a list of its elements in spiral order. The spiral order starts at the top-left element and proceeds to the right, then down, then left, and finally up, repeating this pattern until all elements have been added to the output list. :param matrix: List[List[int]] - The 2D list of integers :return: List[int] - The elements of the matrix in spiral order >>> spiralTraversal([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) [1, 2, 3, 6, 9, 8, 7, 4, 5] >>> spiralTraversal([[1]]) [1] >>> spiralTraversal([ [1, 2], [3, 4], [5, 6] ]) [1, 2, 4, 6, 5, 3] >>> spiralTraversal([ [1, 2, 3, 4] ]) [1, 2, 3, 4] >>> spiralTraversal([ [1], [2], [3], [4] ]) [1, 2, 3, 4]","solution":"def spiralTraversal(matrix): Returns the elements of the matrix in spiral order. :param matrix: List[List[int]] - The 2D list of integers :return: List[int] - The elements of the matrix in spiral order if not matrix or not matrix[0]: return [] top, bottom = 0, len(matrix) - 1 left, right = 0, len(matrix[0]) - 1 result = [] while top <= bottom and left <= right: # Traverse from left to right for i in range(left, right + 1): result.append(matrix[top][i]) top += 1 # Traverse from top to bottom for i in range(top, bottom + 1): result.append(matrix[i][right]) right -= 1 if top <= bottom: # Traverse from right to left for i in range(right, left - 1, -1): result.append(matrix[bottom][i]) bottom -= 1 if left <= right: # Traverse from bottom to top for i in range(bottom, top - 1, -1): result.append(matrix[i][left]) left += 1 return result"},{"question":"def is_isomorphic(string1: str, string2: str) -> bool: Checks whether two strings are isomorphic. Two strings are isomorphic if the characters in one string can be replaced to get the other string. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself. If the two strings are empty or of different lengths, return False. >>> is_isomorphic(\\"paper\\", \\"title\\") True >>> is_isomorphic(\\"foo\\", \\"bar\\") False","solution":"def is_isomorphic(string1, string2): Checks if two strings are isomorphic. Parameters: string1 (str): The first string to check. string2 (str): The second string to check. Returns: bool: True if both strings are isomorphic, False otherwise. if len(string1) != len(string2): return False mapping_s1_to_s2 = {} mapping_s2_to_s1 = {} for char1, char2 in zip(string1, string2): if char1 in mapping_s1_to_s2: if mapping_s1_to_s2[char1] != char2: return False else: mapping_s1_to_s2[char1] = char2 if char2 in mapping_s2_to_s1: if mapping_s2_to_s1[char2] != char1: return False else: mapping_s2_to_s1[char2] = char1 return True"},{"question":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next class MyLinkedList: def __init__(self): Initialize your data structure here. pass def addAtHead(self, val): Add a node of value val to the head of the list. :param val: int pass def addAtTail(self, val): Append a node of value val to the tail of the list. :param val: int pass def addAtIndex(self, index, val): Add a node of value val before the index-th node in the list. If index equals to the length of list, the node will be appended to the end of list. If index is greater than the length, the node will not be inserted. :param index: int :param val: int pass def deleteAtIndex(self, index): Delete the index-th node in the list, if the index is valid. :param index: int pass def get(self, index): Get the value of the index-th node in the linked list. If the index is invalid, return -1. :param index: int :return: int pass # Unit Tests def test_addAtHead(): ll = MyLinkedList() ll.addAtHead(1) ll.addAtHead(2) assert ll.get(0) == 2 assert ll.get(1) == 1 def test_addAtTail(): ll = MyLinkedList() ll.addAtTail(1) ll.addAtTail(2) assert ll.get(0) == 1 assert ll.get(1) == 2 def test_addAtIndex(): ll = MyLinkedList() ll.addAtTail(1) ll.addAtTail(3) ll.addAtIndex(1, 2) assert ll.get(0) == 1 assert ll.get(1) == 2 assert ll.get(2) == 3 ll.addAtIndex(0, 0) assert ll.get(0) == 0 assert ll.get(1) == 1 def test_deleteAtIndex(): ll = MyLinkedList() ll.addAtTail(1) ll.addAtTail(2) ll.addAtTail(3) ll.deleteAtIndex(1) assert ll.get(0) == 1 assert ll.get(1) == 3 ll.deleteAtIndex(0) assert ll.get(0) == 3 def test_get(): ll = MyLinkedList() ll.addAtTail(1) ll.addAtTail(2) ll.addAtTail(3) assert ll.get(0) == 1 assert ll.get(1) == 2 assert ll.get(2) == 3 assert ll.get(3) == -1","solution":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next class MyLinkedList: def __init__(self): self.head = None self.size = 0 def addAtHead(self, val): new_node = Node(val, self.head) self.head = new_node self.size += 1 def addAtTail(self, val): new_node = Node(val) if not self.head: self.head = new_node; else: tail = self.head while tail.next: tail = tail.next tail.next = new_node self.size += 1 def addAtIndex(self, index, val): if index > self.size: return if index <= 0: self.addAtHead(val) else: new_node = Node(val) prev = None current = self.head for _ in range(index): prev = current current = current.next new_node.next = current if prev: prev.next = new_node self.size += 1 def deleteAtIndex(self, index): if index < 0 or index >= self.size: return if index == 0: self.head = self.head.next else: prev = None current = self.head for _ in range(index): prev = current current = current.next if prev and current: prev.next = current.next self.size -= 1 def get(self, index): if index < 0 or index >= self.size: return -1 current = self.head for _ in range(index): current = current.next return current.val if current else -1"},{"question":"def max_valid_participations(T: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]: Determine the maximum number of valid user participations in a social media event where a user should not participate on consecutive days. >>> max_valid_participations(2, >>> [(5, [(1, 1), (2, 2), (1, 3), (3, 4), (2, 5)]), >>> (4, [(1, 1), (2, 1), (3, 2), (1, 2)])]) == [5, 3] :param T: an integer, number of test cases. :param test_cases: a list where each element is a tuple containing an integer N and a list of N tuples, each representing user activities with userID and the day they participated. :return: a list of integers where each integer represents the maximum number of valid participations for a test case.","solution":"def max_valid_participations(T, test_cases): results = [] for i in range(T): N, activities = test_cases[i] user_days = {} for user_id, day in activities: if user_id not in user_days: user_days[user_id] = [] user_days[user_id].append(day) valid_count = 0 for user_id in user_days: days = sorted(user_days[user_id]) valid_count += 1 # First day is always valid for j in range(1, len(days)): if days[j] != days[j-1] + 1: valid_count += 1 results.append(valid_count) return results"},{"question":"def max_sum_path(grid: List[List[int]]) -> int: Find the maximum sum starting at any cell in the first row and reaching the last row according to the given movement rules. >>> max_sum_path([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]) == 24 >>> max_sum_path([[1, 2, 3], [4, 5, 6]]) == 9 >>> max_sum_path([[10, 20, 30]]) == 30 >>> max_sum_path([[1], [2], [3]]) == 6 >>> max_sum_path([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) == 0 >>> max_sum_path([[100, 100], [100, 100], [100, 100]]) == 300","solution":"def max_sum_path(grid): n = len(grid) m = len(grid[0]) # Create a DP table initialized with 0 dp = [[0] * m for _ in range(n)] # Initialize the first row of dp table for j in range(m): dp[0][j] = grid[0][j] # Fill the dp table for i in range(1, n): for j in range(m): dp[i][j] = grid[i][j] + max( dp[i-1][j] if j >= 0 and j < m else 0, dp[i-1][j-1] if j > 0 else 0, dp[i-1][j+1] if j < m-1 else 0, ) # The result will be the maximum value in the last row of dp table return max(dp[n-1]) # Example usage: n, m = 3, 4 grid = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12] ] print(max_sum_path(grid)) # Output: 24"},{"question":"def is_super_palindrome(word: str) -> str: Checks if the given word is a Super Palindrome. :param word: The word to check. :return: \\"YES\\" if the word is a Super Palindrome, otherwise \\"NO\\". >>> is_super_palindrome('aabbcc') 'YES' >>> is_super_palindrome('racecar') 'YES' >>> is_super_palindrome('abc') 'NO' >>> is_super_palindrome('aaaaaa') 'YES' def process_input(words: List[str]) -> List[str]: Processes a list of words and returns if they are Super Palindromes. :param words: List of words to process. :return: List of results (\\"YES\\" or \\"NO\\") for each word. >>> process_input(['aabbcc', 'racecar', 'abc', 'aaaaaa', 'END']) ['YES', 'YES', 'NO', 'YES'] >>> process_input(['a', 'aa', 'bb', 'ccc', 'abcd', 'END']) ['YES', 'YES', 'YES', 'YES', 'NO']","solution":"def is_super_palindrome(word): Checks if the given word is a Super Palindrome. :param word: The word to check. :return: \\"YES\\" if the word is a Super Palindrome, otherwise \\"NO\\". from collections import Counter # Count the occurrences of each character char_count = Counter(word) # Count how many characters have an odd number of occurrences odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # If more than one character has an odd number of occurrences, it can't be rearranged to form a palindrome return \\"YES\\" if odd_count <= 1 else \\"NO\\" def process_input(words): Processes a list of words and returns if they are Super Palindromes :param words: List of words to process :return: List of results (\\"YES\\" or \\"NO\\") for each word results = [] for word in words: if word == \\"END\\": break results.append(is_super_palindrome(word)) return results"},{"question":"def rotate_matrix_90_degrees(matrix): Rotates a given matrix 90 degrees clockwise. :param matrix: A list of lists representing the matrix. :return: A list of lists representing the rotated matrix. pass def transform_input(input_str): Transforms the input string into the required dimensions and matrix. :param input_str: A string representing the input. :return: Dimensions of the matrix and the matrix itself. pass def matrix_rotation(input_str): Main function to get input string, process it, rotate matrix and produce output string. :param input_str: A string representing the input. :return: A string representing the rotated matrix output. pass # Example usage: input_str = \\"3 4n1 2 3 4n5 6 7 8n9 10 11 12\\" Expected Output: 9 5 1 10 6 2 11 7 3 12 8 4 output_str = matrix_rotation(input_str) print(output_str)","solution":"def rotate_matrix_90_degrees(matrix): Rotates a given matrix 90 degrees clockwise. :param matrix: A list of lists representing the matrix. :return: A list of lists representing the rotated matrix. if not matrix: return [] n, m = len(matrix), len(matrix[0]) rotated_matrix = [[0] * n for _ in range(m)] for i in range(n): for j in range(m): rotated_matrix[j][n-1-i] = matrix[i][j] return rotated_matrix def transform_input(input_str): Transforms the input string into the required dimensions and matrix. :param input_str: A string representing the input. :return: Dimensions of the matrix and the matrix itself. lines = input_str.strip().split('n') n, m = map(int, lines[0].split()) matrix = [] for line in lines[1:]: matrix.append(list(map(int, line.split()))) return n, m, matrix def matrix_rotation(input_str): Main function to get input string, process it, rotate matrix and produce output string. :param input_str: A string representing the input. :return: A string representing the rotated matrix output. n, m, matrix = transform_input(input_str) rotated_matrix = rotate_matrix_90_degrees(matrix) return 'n'.join(' '.join(map(str, row)) for row in rotated_matrix)"},{"question":"def can_knight_reach(N: int, r1: int, c1: int, r2: int, c2: int, K: int) -> str: Determine if a knight can reach the target position (r2, c2) from (r1, c1) in exactly K moves. Args: N (int): Size of the chessboard (N x N) r1 (int): Starting row position of the knight (1-based indexing) c1 (int): Starting column position of the knight (1-based indexing) r2 (int): Target row position of the knight (1-based indexing) c2 (int): Target column position of the knight (1-based indexing) K (int): Exact number of moves Returns: str: \\"YES\\" if the knight can reach the target position in exactly K moves, otherwise \\"NO\\" >>> can_knight_reach(8, 1, 1, 8, 8, 6) \\"YES\\" >>> can_knight_reach(8, 1, 1, 8, 8, 5) \\"NO\\" >>> can_knight_reach(5, 3, 3, 4, 3, 1) \\"NO\\"","solution":"from collections import deque def can_knight_reach(N, r1, c1, r2, c2, K): # Define all possible knight moves knight_moves = [ (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2), (-1, 2), (-2, 1) ] # Use BFS to find the exact number of moves queue = deque([(r1-1, c1-1, 0)]) # Start from (r1, c1) with 0 moves visited = set((r1-1, c1-1)) # Keep track of visited squares while queue: x, y, moves = queue.popleft() if moves == K: if (x+1, y+1) == (r2, c2): return \\"YES\\" continue if moves < K: for dx, dy in knight_moves: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < N and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, moves + 1)) return \\"NO\\""},{"question":"def highest_min_energy(T, test_cases): Divide participants into teams to maximize the minimum energy level of the weakest team. Args: T (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of tuples, each containing the number of participants N and a list of their energy levels. Returns: List[int]: A list of the highest possible minimum energy levels for the weakest team for each test case. >>> T, test_cases = parse_input(\\"2n4n1 3 6 2n5n4 2 7 1 3n\\") >>> results = highest_min_energy(T, test_cases) >>> format_output(results) '2n3' pass def parse_input(input_str): Parse the input string into the number of test cases and the test cases. Args: input_str (str): Input string containing the number of test cases and the energy levels of participants. Returns: Tuple[int, List[Tuple[int, List[int]]]]: The number of test cases and a list of tuples, each containing the number of participants and their energy levels. >>> parse_input(\\"2n4n1 3 6 2n5n4 2 7 1 3n\\") (2, [(4, [1, 3, 6, 2]), (5, [4, 2, 7, 1, 3])]) pass def format_output(results): Format the output list into the required string format. Args: results (List[int]): A list of results for each test case. Returns: str: Formatted string of results. >>> format_output([2, 3]) \\"2n3\\" pass","solution":"def highest_min_energy(T, test_cases): results = [] for _ in range(T): N = test_cases[_][0] energies = test_cases[_][1] energies.sort() max_min_energy = 0 for i in range(N): max_min_energy = max(max_min_energy, min(energies[i], N - i)) results.append(max_min_energy) return results def parse_input(input_str): lines = input_str.strip().split('n') T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): N = int(lines[index]) energies = list(map(int, lines[index + 1].split())) test_cases.append((N, energies)) index += 2 return T, test_cases def format_output(results): return 'n'.join(map(str, results)) # Example usage input_str = \\"2n4n1 3 6 2n5n4 2 7 1 3n\\" T, test_cases = parse_input(input_str) results = highest_min_energy(T, test_cases) output_str = format_output(results) print(output_str)"},{"question":"def sum_of_differences(n: int, arr: List[int]) -> int: Calculate the sum of the difference between the maximum and minimum elements of all possible subarrays of the given array. Parameters: n (int): Number of elements in the array. arr (list[int]): List of integers representing the array. Returns: int: The sum of the differences. >>> sum_of_differences(3, [1, 2, 3]) 4 >>> sum_of_differences(1, [5]) 0 >>> sum_of_differences(2, [1, 3]) 2 >>> sum_of_differences(4, [2, 2, 2, 2]) 0 >>> sum_of_differences(5, [1, 2, 3, 4, 5]) 20 >>> sum_of_differences(4, [4, 3, 2, 1]) 10","solution":"def sum_of_differences(n, arr): Calculate the sum of the difference between the maximum and minimum elements of all possible subarrays of the given array. Parameters: n (int): Number of elements in the array. arr (list[int]): List of integers representing the array. Returns: int: The sum of the differences. total_diff_sum = 0 for i in range(n): current_max = arr[i] current_min = arr[i] for j in range(i, n): current_max = max(current_max, arr[j]) current_min = min(current_min, arr[j]) total_diff_sum += current_max - current_min return total_diff_sum"},{"question":"def min_additions_to_increasing(arr): Determine the minimum number of buildings to add to make the skyline strictly increasing. >>> min_additions_to_increasing([1, 2, 2, 3, 4]) 1 >>> min_additions_to_increasing([4, 3, 2, 1]) 3 >>> min_additions_to_increasing([1, 3, 3, 5, 4, 6]) 2 ... def process_test_cases(test_cases): Process multiple test cases to determine the number of additions for each one. >>> test_cases = [ ... (5, [1, 2, 2, 3, 4]), ... (4, [4, 3, 2, 1]), ... (6, [1, 3, 3, 5, 4, 6]) ... ] >>> process_test_cases(test_cases) [1, 3, 2] ...","solution":"def min_additions_to_increasing(arr): Determine the minimum number of buildings to add to make the skyline strictly increasing. n = len(arr) additions = 0 current_max = arr[0] for i in range(1, n): if arr[i] <= current_max: additions += 1 else: current_max = arr[i] return additions def process_test_cases(test_cases): Process multiple test cases to determine the number of additions for each one. results = [] for n, arr in test_cases: results.append(min_additions_to_increasing(arr)) return results"},{"question":"from typing import List, Tuple, Union def minimum_cost_to_connect_all_districts(n: int, m: int, edges: List[Tuple[int, int, int]]) -> Union[int, str]: Determines the minimum cost to connect all districts under given constraints, or determine if it’s impossible. Args: n : int : The number of districts. m : int : The maximum number of roads a district can have. edges : List[Tuple[int, int, int]] : List of possible roads represented as tuples (u, v, c). Returns: Union[int, str] : The minimum cost required to connect all districts, or \\"impossible\\" if it can't be done. Example: >>> minimum_cost_to_connect_all_districts(4, 2, [(0, 1, 10), (0, 2, 6), (0, 3, 5), (1, 2, 15), (2, 3, 4)]) 19 >>> minimum_cost_to_connect_all_districts(4, 1, [(0, 1, 10), (0, 2, 6), (0, 3, 5), (1, 2, 15)]) \\"impossible\\" pass","solution":"def find(parent, i): while parent[i] != i: i = parent[i] return i def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x else: parent[root_y] = root_x rank[root_x] += 1 def minimum_cost_to_connect_all_districts(n, m, edges): edges = sorted(edges, key=lambda item: item[2]) parent = [] rank = [] degree = [0] * n for node in range(n): parent.append(node) rank.append(0) result = [] for u, v, weight in edges: if degree[u] < m and degree[v] < m: x = find(parent, u) y = find(parent, v) if x != y: result.append((u, v, weight)) union(parent, rank, x, y) degree[u] += 1 degree[v] += 1 if len(result) != n - 1: return \\"impossible\\" minimum_cost = sum([weight for u, v, weight in result]) return minimum_cost # Example usage: # n = 4, m = 2, e = 5 # edges = [(0, 1, 10), (0, 2, 6), (0, 3, 5), (1, 2, 15), (2, 3, 4)] # print(minimum_cost_to_connect_all_districts(n, m, edges)) # Output: 19"},{"question":"from typing import List, Tuple def is_perfect_circle(flight_points: List[Tuple[int, int]]) -> str: Determine if the given points form a perfect circle centered at the origin. Args: flight_points: A list of tuples containing the coordinates of the flight points. Returns: str: \\"YES\\" if the points form a perfect circle, \\"NO\\" otherwise. pass def check_circular_paths(test_cases: List[List[Tuple[int, int]]]) -> List[str]: Check multiple test cases to determine if points form a perfect circle. Args: test_cases: A list of test cases, each containing a list of coordinate tuples. Returns: List[str]: A list of results for each test case (\\"YES\\" or \\"NO\\"). pass def parse_input(input_str: str) -> List[List[Tuple[int, int]]]: Parse the input string to extract test cases. Args: input_str: A string containing the input data. Returns: List[List[Tuple[int, int]]]: A list of test cases extracted from the input string. pass def main(input_str: str) -> str: Main function to process input and generate output. Args: input_str: A string containing the input data. Returns: str: The output results as a string. pass","solution":"import math def is_perfect_circle(flight_points): distances = [math.sqrt(x**2 + y**2) for x, y in flight_points] return all(abs(d - distances[0]) < 1e-6 for d in distances) def check_circular_paths(test_cases): results = [] for points in test_cases: if is_perfect_circle(points): results.append(\\"YES\\") else: results.append(\\"NO\\") return results def parse_input(input_str): lines = input_str.strip().split(\\"n\\") T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): N = int(lines[index]) index += 1 points = [] for _ in range(N): x, y = map(int, lines[index].split()) index += 1 points.append((x, y)) test_cases.append(points) return test_cases def main(input_str): test_cases = parse_input(input_str) results = check_circular_paths(test_cases) return \\"n\\".join(results)"},{"question":"from typing import List def minDiffSubarray(Arr: List[int], N: int, K: int) -> int: Finds the minimum difference between the maximum and minimum values in any subarray of length K. >>> minDiffSubarray([10, 1, 5, 9, 3, 8, 12], 7, 3) 2 >>> minDiffSubarray([4, 7, 9, 2, 5], 5, 2) 1 >>> minDiffSubarray([5, 10, 15, 20], 4, 1) 0 >>> minDiffSubarray([7, 7, 7, 7, 7], 5, 3) 0 >>> minDiffSubarray([1, 2, 3, 1000000000], 4, 2) 1 >>> minDiffSubarray(list(range(1, 100001)), 100000, 1000) 999 >>> minDiffSubarray([1000000000, 1], 2, 2) 999999999","solution":"def minDiffSubarray(Arr, N, K): Finds the minimum difference between the maximum and minimum values in any subarray of length K. # Sort the array Arr.sort() # Initialize the minimum difference to a very large number min_diff = float('inf') # Slide the window of length K and find the minimum difference for i in range(N - K + 1): current_diff = Arr[i + K - 1] - Arr[i] if current_diff < min_diff: min_diff = current_diff return min_diff"},{"question":"def can_create_groups(n, k, participants): Determines if it is possible to create exactly k groups from n participants. Args: n (int): Number of participants. k (int): Number of groups to create. participants (list of str): List of participant names. Returns: str: \\"YES\\" if k groups can be created, otherwise \\"NO\\". Example: >>> can_create_groups(6, 3, [\\"alice\\", \\"bob\\", \\"charlie\\", \\"dave\\", \\"eve\\", \\"frank\\"]) 'YES' >>> can_create_groups(4, 5, [\\"john\\", \\"doe\\", \\"jennifer\\", \\"smith\\"]) 'NO'","solution":"def can_create_groups(n, k, participants): Determines if it is possible to create exactly k groups from n participants. Args: n (int): Number of participants. k (int): Number of groups to create. participants (list of str): List of participant names. Returns: str: \\"YES\\" if k groups can be created, otherwise \\"NO\\". if k > n: return \\"NO\\" return \\"YES\\""},{"question":"def longest_increasing_subsequence(heights: List[int]) -> int: Determine the maximum number of students that can be arranged such that each student is shorter than the next one in the sequence. >>> longest_increasing_subsequence([1, 3, 5, 2, 6, 4]) 4 >>> longest_increasing_subsequence([5, 4, 3, 2, 1]) 1","solution":"def longest_increasing_subsequence(heights): Returns the length of the longest increasing subsequence. if not heights: return 0 # Create an array to store longest increasing subsequence length for each element lis = [1] * len(heights) # Calculate the LIS values in a bottom up manner for i in range(1, len(heights)): for j in range(0, i): if heights[i] > heights[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 # The maximum value in lis[] is the length of the longest increasing subsequence return max(lis) # Example usage: # n = int(input()) # heights = list(map(int, input().split())) # print(longest_increasing_subsequence(heights))"},{"question":"def simulate_bot(commands: str) -> tuple: Simulates the movement of a bot according to given commands. Parameters: - commands (str): a string consisting of the characters 'L', 'R', and 'G' Returns: - tuple: the final position (x, y) and direction of the bot as (x, y, direction) >>> simulate_bot(\\"GGLLGG\\") (0, 0, 'S') >>> simulate_bot(\\"GLG\\") (-1, 1, 'W') >>> simulate_bot(\\"GRGR\\") (0, 0, 'S')","solution":"def simulate_bot(commands): Simulates the movement of a bot according to given commands. Parameters: - commands (str): a string consisting of the characters 'L', 'R', and 'G' Returns: - tuple: the final position (x, y) and direction of the bot as (x, y, direction) # Initial position and direction x, y = 0, 0 direction = 'N' # Define movement changes for directions directions = ['N', 'E', 'S', 'W'] # Movement vector for each direction (N, E, S, W) move_vector = { 'N': (0, 1), 'E': (1, 0), 'S': (0, -1), 'W': (-1, 0), } for command in commands: if command == 'L': # Turn left direction = directions[(directions.index(direction) - 1) % 4] elif command == 'R': # Turn right direction = directions[(directions.index(direction) + 1) % 4] elif command == 'G': # Move forward in the current direction dx, dy = move_vector[direction] x += dx y += dy return (x, y, direction)"},{"question":"def maxWaterTrapped(heights: List[int]) -> int: Returns the maximum amount of water that can be trapped between the bars after raining. Example: >>> maxWaterTrapped([1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> maxWaterTrapped([4, 2, 0, 3, 2, 5]) 9 >>> maxWaterTrapped([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> maxWaterTrapped([7, 1, 4, 0, 1, 2]) 6 >>> maxWaterTrapped([1, 2, 3, 4, 5]) 0 >>> maxWaterTrapped([5, 4, 3, 2, 1]) 0 >>> maxWaterTrapped([]) 0 >>> maxWaterTrapped([1]) 0 >>> maxWaterTrapped([1, 2]) 0","solution":"def maxWaterTrapped(heights): Returns the maximum amount of water that can be trapped between the bars. if not heights or len(heights) < 3: return 0 left, right = 0, len(heights) - 1 left_max, right_max = heights[left], heights[right] water_trapped = 0 while left < right: if heights[left] < heights[right]: left += 1 left_max = max(left_max, heights[left]) water_trapped += left_max - heights[left] else: right -= 1 right_max = max(right_max, heights[right]) water_trapped += right_max - heights[right] return water_trapped"},{"question":"def optimal_drc_location(W: int, H: int, disaster_zones: List[Tuple[int, int]]) -> Tuple[int, int]: Determine the optimal location to place a Disaster Relief Center (DRC) that minimizes the maximum distance from the DRC to any disaster zone (DZ) in a grid of size W x H. The optimal location is the grid coordinates (X, Y) such that the greatest Manhattan distance from this point to any DZ in the grid is minimized. Parameters: W (int): The width of the grid. H (int): The height of the grid. disaster_zones (List[Tuple[int, int]]): A list of tuples representing the coordinates of the disaster zones. Returns: Tuple[int, int]: The coordinates (X, Y) of the optimal location for the DRC. >>> optimal_drc_location(5, 5, [(0, 0), (4, 0), (2, 4)]) (2, 2) >>> optimal_drc_location(6, 6, [(5, 1), (0, 3), (3, 5), (2, 2)]) (2, 3)","solution":"def optimal_drc_location(W, H, disaster_zones): max_x = max(dz[0] for dz in disaster_zones) min_x = min(dz[0] for dz in disaster_zones) max_y = max(dz[1] for dz in disaster_zones) min_y = min(dz[1] for dz in disaster_zones) optimal_x = (min_x + max_x) // 2 optimal_y = (min_y + max_y) // 2 return optimal_x, optimal_y # Example usage W = 5 H = 5 disaster_zones = [(0, 0), (4, 0), (2, 4)] print(optimal_drc_location(W, H, disaster_zones)) # Output: 2, 2"},{"question":"def min_shelves(n: int, difficulty_levels: List[int]) -> int: Calculates the minimum number of shelves required to accommodate all the books. Parameters: - n: Integer, number of books. - difficulty_levels: List of integers, difficulty levels of books. Returns: - Integer, minimum number of shelves required. >>> min_shelves(6, [4, 3, 2, 4, 1, 3]) 2 >>> min_shelves(5, [1, 1, 1, 1, 1]) 5 >>> min_shelves(5, [1, 2, 3, 4, 5]) 1","solution":"def min_shelves(n, difficulty_levels): Calculates the minimum number of shelves required to accommodate all the books. Parameters: - n: Integer, number of books. - difficulty_levels: List of integers, difficulty levels of books. Returns: - Integer, minimum number of shelves required. from collections import Counter # Count the frequency of each difficulty level difficulty_count = Counter(difficulty_levels) # The minimum number of shelves required is the maximum frequency of any difficulty level return max(difficulty_count.values())"},{"question":"def max_profit(prices): Given a list of prices, computes the maximum profit that could have been made by buying one day and selling on a later day. If no profit can be made, it returns 0. >>> max_profit([7, 1, 5, 3, 6, 4]) == 5 >>> max_profit([7, 6, 4, 3, 1]) == 0 >>> max_profit([3, 3, 5, 0, 0, 3, 1, 4]) == 4 >>> max_profit([5, 4, 3, 2, 1, 10]) == 9 >>> max_profit([2, 4, 1]) == 2 >>> max_profit([1, 1, 1, 1]) == 0 >>> max_profit([1]) == 0 >>> max_profit([]) == 0 >>> max_profit([9, 1, 3, 10]) == 9 >>> max_profit([12, 11, 15, 3, 10]) == 7","solution":"def max_profit(prices): Given a list of prices, computes the maximum profit that could have been made by buying one day and selling on a later day. If no profit can be made, it returns 0. if not prices or len(prices) < 2: return 0 min_price = prices[0] max_profit = 0 for price in prices[1:]: profit = price - min_price if profit > max_profit: max_profit = profit if price < min_price: min_price = price return max_profit"},{"question":"def product_of_list(int_list): Returns the product of all elements in the list. >>> product_of_list([1, 2, 3, 4]) 24 >>> product_of_list([2, 5, 7]) 70 >>> product_of_list([0, 2, 3]) 0 >>> product_of_list([2, 0, 2]) 0 >>> product_of_list([-1, 2, 3]) -6 >>> product_of_list([-1, -2, -3]) -6 >>> product_of_list([]) 1 >>> product_of_list([5]) 5 >>> product_of_list([-5]) -5","solution":"def product_of_list(int_list): Returns the product of all elements in the list. product = 1 for num in int_list: product *= num return product"},{"question":"def count_stall_types(n, stall_types): Counts the number of each type of food stall. Parameters: n (int): The number of food stalls. stall_types (list of str): A list of strings where each string is one of \\"Vegetarian\\", \\"Non-Vegetarian\\", or \\"Mixed\\". Returns: tuple: A tuple of three integers representing the counts of \\"Vegetarian\\", \\"Non-Vegetarian\\", and \\"Mixed\\" stalls respectively. >>> count_stall_types(5, [\\"Vegetarian\\", \\"Non-Vegetarian\\", \\"Mixed\\", \\"Vegetarian\\", \\"Mixed\\"]) (2, 1, 2) >>> count_stall_types(4, [\\"Mixed\\", \\"Mixed\\", \\"Vegetarian\\", \\"Non-Vegetarian\\"]) (1, 1, 2) >>> count_stall_types(3, [\\"Vegetarian\\", \\"Vegetarian\\", \\"Vegetarian\\"]) (3, 0, 0) >>> count_stall_types(3, [\\"Non-Vegetarian\\", \\"Non-Vegetarian\\", \\"Non-Vegetarian\\"]) (0, 3, 0) >>> count_stall_types(3, [\\"Mixed\\", \\"Mixed\\", \\"Mixed\\"]) (0, 0, 3) >>> count_stall_types(0, []) (0, 0, 0) >>> count_stall_types(6, [\\"Vegetarian\\", \\"Non-Vegetarian\\", \\"Mixed\\", \\"Non-Vegetarian\\", \\"Mixed\\", \\"Vegetarian\\"]) (2, 2, 2)","solution":"def count_stall_types(n, stall_types): Counts the number of each type of food stall. Parameters: n (int): The number of food stalls. stall_types (list of str): A list of strings where each string is one of \\"Vegetarian\\", \\"Non-Vegetarian\\", or \\"Mixed\\". Returns: tuple: A tuple of three integers representing the counts of \\"Vegetarian\\", \\"Non-Vegetarian\\", and \\"Mixed\\" stalls respectively. vegetarian_count = 0 non_vegetarian_count = 0 mixed_count = 0 for stall in stall_types: if stall == \\"Vegetarian\\": vegetarian_count += 1 elif stall == \\"Non-Vegetarian\\": non_vegetarian_count += 1 elif stall == \\"Mixed\\": mixed_count += 1 return vegetarian_count, non_vegetarian_count, mixed_count"},{"question":"def count_pairs_with_sum(N: int, K: int, A: List[int]) -> int: Determines the number of pairs (i, j) such that A[i] + A[j] equals a given value K. Args: N: The number of elements in the array. K: The target sum. A: The list of integers. Returns: The number of valid pairs. Examples: >>> count_pairs_with_sum(5, 7, [1, 2, 3, 4, 5]) 2 >>> count_pairs_with_sum(4, 5, [1, 1, 1, 1]) 0 >>> count_pairs_with_sum(3, 5, [2, 3, 2]) 2 >>> count_pairs_with_sum(5, 1000000000, [500000000, 500000000, 3, 4, 5]) 1 >>> count_pairs_with_sum(6, 0, [-1, 1, -2, 2, -3, 3]) 3 >>> count_pairs_with_sum(5, 6, [3, 3, 3, 3, 3]) 10","solution":"def count_pairs_with_sum(N, K, A): Returns the number of pairs (i, j) such that A[i] + A[j] = K and i < j. count = 0 # Iterate through the array to find all pairs (i, j) such that i < j and A[i] + A[j] = K for i in range(N): for j in range(i + 1, N): if A[i] + A[j] == K: count += 1 return count"},{"question":"from typing import List, Tuple def max_tourists(tourist_times: List[Tuple[int, int]]) -> int: Given a list of tuples representing the arrival and departure times of tourists, returns the maximum number of tourists present in the forest at the same time. >>> max_tourists([(1, 5), (2, 8), (4, 6)]) 3 >>> max_tourists([(1, 7), (3, 6), (5, 8), (2, 4), (6, 9)]) 4 def test_max_tourists_example1(): tourist_times = [(1, 5), (2, 8), (4, 6)] assert max_tourists(tourist_times) == 3 def test_max_tourists_example2(): tourist_times = [(1, 7), (3, 6), (5, 8), (2, 4), (6, 9)] assert max_tourists(tourist_times) == 4 def test_max_tourists_example3(): tourist_times = [(1, 3), (4, 6), (2, 5), (7, 8)] assert max_tourists(tourist_times) == 2 def test_tourists_no_overlap(): tourist_times = [(1, 2), (3, 4)] assert max_tourists(tourist_times) == 1 def test_tourists_all_arriving_simultaneously(): tourist_times = [(1, 5), (1, 6), (1, 7)] assert max_tourists(tourist_times) == 3 def test_tourists_all_leaving_simultaneously(): tourist_times = [(1, 5), (2, 5), (3, 5)] assert max_tourists(tourist_times) == 3 def test_tourists_covering_entire_period(): tourist_times = [(1, 10), (2, 9), (3, 8)] assert max_tourists(tourist_times) == 3 def test_single_tourist(): tourist_times = [(0, 10)] assert max_tourists(tourist_times) == 1","solution":"def max_tourists(tourist_times): Given a list of tuples representing the arrival and departure times of tourists, returns the maximum number of tourists present in the forest at the same time. events = [] # create events for all tourist arrivals and departures for arrival, departure in tourist_times: events.append((arrival, 'arrival')) events.append((departure, 'departure')) # sort events first by time, then by type (arrival before departure in case of tie) events.sort(key=lambda x: (x[0], x[1] == 'departure')) max_tourists_present = 0 current_tourists = 0 for event in events: if event[1] == 'arrival': current_tourists += 1 else: current_tourists -= 1 max_tourists_present = max(max_tourists_present, current_tourists) return max_tourists_present"},{"question":"import math from typing import List, Tuple def solve_gcd_sequence(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the minimum possible integer that can be left in the sequence after performing the given operations. Args: t (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of test cases, each containing an integer n and a list of n integers. Returns: List[int]: The minimum possible integers left in the sequence for each test case. >>> solve_gcd_sequence(2, [(3, [6, 9, 15]), (4, [8, 4, 12, 16])]) [3, 4] >>> solve_gcd_sequence(1, [(2, [10, 15])]) [5] >>> solve_gcd_sequence(1, [(3, [4, 8, 16])]) [4] >>> solve_gcd_sequence(1, [(2, [7, 14])]) [7] >>> solve_gcd_sequence(1, [(5, [20, 30, 40, 50, 60])]) [10] >>> solve_gcd_sequence(1, [(5, [1, 1, 1, 1, 1])]) [1]","solution":"import math from functools import reduce def solve_gcd_sequence(t, test_cases): results = [] for n, arr in test_cases: min_gcd = reduce(math.gcd, arr) results.append(min_gcd) return results"},{"question":"def countSubstrings(s: str, c: str) -> int: Returns the number of substrings in s that start and end with the character c. Parameters: s (str): The input string. c (char): The character to look for. Returns: int: The number of substrings that start and end with the character c. pass def test_example_1(): assert countSubstrings(\\"abcabc\\", 'a') == 3 def test_example_2(): assert countSubstrings(\\"aaaa\\", 'a') == 10 def test_example_3(): assert countSubstrings(\\"abcd\\", 'z') == 0 def test_no_occurrences(): assert countSubstrings(\\"bbbb\\", 'a') == 0 def test_single_occurrence(): assert countSubstrings(\\"babab\\", 'a') == 3 def test_all_same_character(): assert countSubstrings(\\"ccccc\\", 'c') == 15","solution":"def countSubstrings(s, c): Returns the number of substrings in s that start and end with the character c. Parameters: s (str): The input string. c (char): The character to look for. Returns: int: The number of substrings that start and end with the character c. count = 0 occurrences = 0 for char in s: if char == c: occurrences += 1 count += occurrences return count"},{"question":"def encode_message(shift: int, plaintext: str) -> str: Encodes the plaintext using the provided shift value. Shift each letter in the plaintext by the given shift amount. Characters other than letters remain unchanged. :param shift: Integer value representing the shift amount. :param plaintext: String representing the plaintext to be encoded. :return: String representing the encoded text. >>> encode_message(1, \\"abc XYZ\\") 'bcd YZA' >>> encode_message(-1, \\"bcd YZA\\") 'abc XYZ' >>> encode_message(0, \\"abc XYZ\\") 'abc XYZ' >>> encode_message(1, \\"xyz XYZ\\") 'yza YZA' >>> encode_message(-1, \\"abc ABC\\") 'zab ZAB' >>> encode_message(1, \\"Hello, World!\\") 'Ifmmp, Xpsme!' >>> encode_message(26, \\"abc XYZ\\") 'abc XYZ' >>> encode_message(-26, \\"abc XYZ\\") 'abc XYZ' >>> encode_message(52, \\"abc XYZ\\") 'abc XYZ' >>> encode_message(-52, \\"abc XYZ\\") 'abc XYZ' >>> encode_message(-27, \\"abc XYZ\\") 'zab WXY'","solution":"def encode_message(shift, plaintext): Encodes the plaintext using the provided shift value. :param shift: Integer value representing the shift amount. :param plaintext: String representing the plaintext to be encoded. :return: String representing the encoded text. encoded_text = [] for char in plaintext: if 'a' <= char <= 'z': # lowercase letters new_char = chr((ord(char) - ord('a') + shift) % 26 + ord('a')) elif 'A' <= char <= 'Z': # uppercase letters new_char = chr((ord(char) - ord('A') + shift) % 26 + ord('A')) else: new_char = char # non-alphabet characters remain unchanged encoded_text.append(new_char) return ''.join(encoded_text)"},{"question":"def coin_change(coins, M): Write a function \`coin_change\` that takes in an array \`coins\` containing the values of the N coins, and an integer \`M\` representing the desired amount of money. Your function should return the number of distinct ways to make the amount M using the given coins. Args: coins (list of int): An array of integers where each integer represents the value of a coin. M (int): An integer representing the amount of money to be made. Returns: int: The number of distinct ways to make the amount M using any number of coins from the collection. Examples: >>> coin_change([1, 2, 5], 5) 4 >>> coin_change([3], 9) 1 >>> coin_change([2, 3, 5], 10) 4 >>> coin_change([3, 5], 7) 0 >>> coin_change([1, 2, 3], 100) 884 >>> coin_change([10, 20, 50], 100) 10","solution":"def coin_change(coins, M): Function to calculate the number of ways to make amount M using any number of given coins. # Create an array to store the number of ways we can make each amount from 0 to M dp = [0] * (M + 1) # There is one way to make zero amount, which is to use no coins dp[0] = 1 # Iterate over each coin and update the dp array for coin in coins: for amount in range(coin, M + 1): dp[amount] += dp[amount - coin] # The value at dp[M] will be the number of ways to make amount M return dp[M]"},{"question":"def format_invitations(participants): Returns a formatted multi-line string of participant names. Each name is in the format \\"Last name, First name\\". >>> participants = [ ... {\\"first_name\\": \\"John\\", \\"last_name\\": \\"Doe\\"}, ... {\\"first_name\\": \\"Jane\\", \\"last_name\\": \\"Smith\\"}, ... {\\"first_name\\": \\"Alice\\", \\"last_name\\": \\"Johnson\\"} ... ] >>> format_invitations(participants) 'Doe, JohnnSmith, JanenJohnson, Alice' >>> participants = [] >>> format_invitations(participants) '' >>> participants = [{\\"first_name\\": \\"John\\", \\"last_name\\": \\"Doe\\"}] >>> format_invitations(participants) 'Doe, John' >>> participants = [ ... {\\"first_name\\": \\"Emily\\", \\"last_name\\": \\"Clark\\"}, ... {\\"first_name\\": \\"Anna\\", \\"last_name\\": \\"Bell\\"}, ... {\\"first_name\\": \\"Tom\\", \\"last_name\\": \\"Holland\\"} ... ] >>> format_invitations(participants) 'Clark, EmilynBell, AnnanHolland, Tom'","solution":"def format_invitations(participants): Returns a formatted multi-line string of participant names. Each name is in the format \\"Last name, First name\\". if not participants: return \\"\\" return \\"n\\".join(f\\"{participant['last_name']}, {participant['first_name']}\\" for participant in participants)"},{"question":"def max_friendships(n: int, m: int, friendships: List[Tuple[int, int]]) -> Tuple[int, List[int]]: Determine the maximum number of friendships that can be satisfied and provide a possible seating arrangement of guests achieving this maximum. >>> max_friendships(2, 1, [(1, 2)]) (1, [1, 2]) >>> max_friendships(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) (4, [1, 2, 3, 4, 5])","solution":"def max_friendships(n, m, friendships): from collections import defaultdict def find_root(guest): if parent[guest] != guest: parent[guest] = find_root(parent[guest]) return parent[guest] def union_sets(guest1, guest2): root1 = find_root(guest1) root2 = find_root(guest2) if root1 != root2: if rank[root1] > rank[root2]: parent[root2] = root1 elif rank[root1] < rank[root2]: parent[root1] = root2 else: parent[root2] = root1 rank[root1] += 1 parent = {i: i for i in range(1, n+1)} rank = {i: 0 for i in range(1, n+1)} for u, v in friendships: union_sets(u, v) satisfied_friendships = 0 components = defaultdict(list) for guest in range(1, n+1): components[find_root(guest)].append(guest) seating = [] for nodes in components.values(): seating.extend(nodes) satisfied_friendships += len(nodes) - 1 return satisfied_friendships, seating # Sample test scenario n = 5 m = 4 friendships = [(1, 2), (2, 3), (3, 4), (4, 5)] satisfied_friendships, seating = max_friendships(n, m, friendships) print(satisfied_friendships) print(' '.join(map(str, seating)))"},{"question":"def min_trips(test_cases): Determine the minimum number of trips required to transport all the guests. Args: test_cases (List[Tuple[int, List[int]]]): Each test case contains the number of guests and their arrival times. Returns: List[int]: A list containing the minimum number of trips required for each test case. pass def parse_input(input_str): Parse the input string into test cases. Args: input_str (str): The input string containing the number of test cases, number of guests and their arrival times. Returns: List[Tuple[int, List[int]]]: The parsed test cases. pass from solution import min_trips, parse_input def test_min_trips_case_1(): input_str = \\"2n5n1 3 3 9 10n4n0 0 0 0\\" test_cases = parse_input(input_str) result = min_trips(test_cases) assert result == [4, 1] def test_min_trips_single_guest(): input_str = \\"1n1n5\\" test_cases = parse_input(input_str) result = min_trips(test_cases) assert result == [1] def test_min_trips_all_at_once(): input_str = \\"1n3n0 0 0\\" test_cases = parse_input(input_str) result = min_trips(test_cases) assert result == [1] def test_min_trips_sequential(): input_str = \\"1n5n1 2 3 4 5\\" test_cases = parse_input(input_str) result = min_trips(test_cases) assert result == [5] def test_min_trips_reverse_order(): input_str = \\"1n5n5 4 3 2 1\\" test_cases = parse_input(input_str) result = min_trips(test_cases) assert result == [5]","solution":"def min_trips(test_cases): results = [] for case in test_cases: N, arrival_times = case arrival_times.sort() trips = 0 current_time = -1 for time in arrival_times: if time > current_time: trips += 1 current_time = time results.append(trips) return results # Helper function for parsing input def parse_input(input_str): data = input_str.strip().split('n') T = int(data[0]) test_cases = [] index = 1 for _ in range(T): N = int(data[index]) arrival_times = list(map(int, data[index + 1].split())) test_cases.append((N, arrival_times)) index += 2 return test_cases"},{"question":"def longest_even_palindrome_subsequence(s: str) -> int: Given a string s consisting of lowercase letters, determine the length of the longest subsequence such that the subsequence is a valid palindrome and the frequency of each character in the subsequence is even. >>> longest_even_palindrome_subsequence(\\"abccccdd\\") 6 >>> longest_even_palindrome_subsequence(\\"aabbcc\\") 6 >>> longest_even_palindrome_subsequence(\\"abcdef\\") 0 from solution import longest_even_palindrome_subsequence def test_sample_cases(): assert longest_even_palindrome_subsequence(\\"abccccdd\\") == 6 assert longest_even_palindrome_subsequence(\\"aabbcc\\") == 6 assert longest_even_palindrome_subsequence(\\"abcdef\\") == 0 def test_single_letter(): assert longest_even_palindrome_subsequence(\\"a\\") == 0 assert longest_even_palindrome_subsequence(\\"z\\") == 0 def test_all_same_letters(): assert longest_even_palindrome_subsequence(\\"bbbb\\") == 4 assert longest_even_palindrome_subsequence(\\"ssssss\\") == 6 def test_mixed_letters_with_even_counts(): assert longest_even_palindrome_subsequence(\\"aabbccdd\\") == 8 assert longest_even_palindrome_subsequence(\\"xxyyzz\\") == 6 def test_mixed_letters_with_odds_and_evens(): assert longest_even_palindrome_subsequence(\\"aabbbcccddee\\") == 10 assert longest_even_palindrome_subsequence(\\"abcabcabc\\") == 6 def test_long_string(): assert longest_even_palindrome_subsequence(\\"a\\" * 500 + \\"b\\" * 500) == 1000 assert longest_even_palindrome_subsequence(\\"a\\" * 501 + \\"b\\" * 499) == 998","solution":"def longest_even_palindrome_subsequence(s): Given a string s, returns the length of the longest subsequence that is a palindrome and all characters have even frequencies. from collections import Counter char_count = Counter(s) length = 0 for count in char_count.values(): if count % 2 == 0: length += count else: length += count - 1 return length"},{"question":"def can_split_into_equal_halves(n: int, arr: List[int]) -> str: Determines if the array can be rearranged to have equal sums in its two halves. >>> can_split_into_equal_halves(4, [1, 1, 2, 2]) == \\"YES\\" >>> can_split_into_equal_halves(5, [1, 2, 3, 4, 5]) == \\"NO\\" >>> can_split_into_equal_halves(6, [3, 3, 3, 3, 6, 6]) == \\"YES\\" def process_input(t: int, cases: List[Tuple[int, List[int]]]) -> List[str]: Processes the input and returns the results for each test case. >>> process_input(3, [(4, [1, 1, 2, 2]), (5, [1, 2, 3, 4, 5]), (6, [3, 3, 3, 3, 6, 6])]) == [\\"YES\\", \\"NO\\", \\"YES\\"] >>> process_input(2, [(4, [1, 1, 1, 2]), (6, [1, 1, 1, 1, 4, 4])]) == [\\"NO\\", \\"YES\\"]","solution":"from itertools import combinations def can_split_into_equal_halves(n, arr): Determines if the array can be rearranged to have equal sums in its two halves. if n % 2 != 0: return \\"NO\\" half = n // 2 total_sum = sum(arr) if total_sum % 2 != 0: return \\"NO\\" half_sum = total_sum // 2 possible = sum_possible(half_sum, arr) return \\"YES\\" if possible else \\"NO\\" def sum_possible(target, nums): Determines if any subset of nums sums up to target. This is a variation of the subset-sum problem. dp = [False] * (target + 1) dp[0] = True for num in nums: for i in range(target, num - 1, -1): if dp[i - num]: dp[i] = True return dp[target] def process_input(t, cases): results = [] for i in range(t): n, arr = cases[i] result = can_split_into_equal_halves(n, arr) results.append(result) return results"},{"question":"def encode_string(s: str, shift: int) -> str: Encode the string \`s\` by shifting each letter by \`shift\` positions in the alphabet. Non-letter characters are not affected. >>> encode_string(\\"hello\\", 1) \\"ifmmp\\" >>> encode_string(\\"Zebra!\\", 3) \\"Cheud!\\" >>> encode_string(\\"hello\\", 0) \\"hello\\" >>> encode_string(\\"abcdefghijklmnopqrstuvwxyz\\", 1) \\"bcdefghijklmnopqrstuvwxyza\\" >>> encode_string(\\"xyz\\", 3) \\"abc\\" >>> encode_string(\\"XYZ\\", 3) \\"ABC\\" >>> encode_string(\\"Hello, World!\\", 5) \\"Mjqqt, Btwqi!\\" >>> encode_string(\\"a\\", 25) \\"z\\" >>> encode_string(\\"A\\", 25) \\"Z\\"","solution":"def encode_string(s, shift): Encode the string \`s\` by shifting each letter by \`shift\` positions in the alphabet. Non-letter characters are not affected. encoded_chars = [] for char in s: if 'a' <= char <= 'z': encoded_chars.append(chr((ord(char) - ord('a') + shift) % 26 + ord('a'))) elif 'A' <= char <= 'Z': encoded_chars.append(chr((ord(char) - ord('A') + shift) % 26 + ord('A'))) else: encoded_chars.append(char) return ''.join(encoded_chars) def main(): import sys input = sys.stdin.read data = input().strip().split('n') T = int(data[0]) results = [] for i in range(1, T + 1): parts = data[i].rsplit(' ', 1) s = parts[0] shift = int(parts[1]) results.append(encode_string(s, shift)) for result in results: print(result) if __name__ == \\"__main__\\": main()"},{"question":"def maxPowerOutput(n: int, d: List[int], s: List[int], w: List[int]) -> int: Determine the maximum power output you can achieve such that the total power output matches exactly the city's demand for each time slot. >>> maxPowerOutput(4, [8, 7, 4, 5], [5, 3, 5, 6], [4, 5, 3, 2]) == 24 >>> maxPowerOutput(3, [7, 6, 9], [3, 3, 3], [4, 4, 4]) == -1","solution":"def maxPowerOutput(n, d, s, w): total_power_output = 0 for i in range(n): if d[i] == s[i]: total_power_output += s[i] elif d[i] == w[i]: total_power_output += w[i] else: return -1 return total_power_output"},{"question":"def can_create_potion(n: int, available: List[int], needed: List[int]) -> str: Determine if a potion can be created given the available quantities of the ingredients. :param n: number of types of ingredients :param available: list of integers representing quantities of available ingredients :param needed: list of integers representing quantities of ingredients needed for one potion :return: \\"YES\\" if one potion can be created, otherwise \\"NO\\" >>> can_create_potion(5, [3, 6, 2, 5, 8], [2, 5, 1, 1, 3]) \\"YES\\" >>> can_create_potion(4, [2, 1, 0, 4], [1, 2, 1, 2]) \\"NO\\"","solution":"def can_create_potion(n, available, needed): Determine if a potion can be created given the available quantities of the ingredients. :param n: number of types of ingredients :param available: list of integers representing quantities of available ingredients :param needed: list of integers representing quantities of ingredients needed for one potion :return: \\"YES\\" if one potion can be created, otherwise \\"NO\\" for i in range(n): if available[i] < needed[i]: return \\"NO\\" return \\"YES\\""},{"question":"def paint_hex_grid(n: int, m: int, edges: List[Tuple[int, int]]) -> str: Determines whether it is possible to paint a hexagonal grid such that no two adjacent hexagons have the same color. If it is possible, returns \\"Possible\\" followed by a configuration string of length n where each character is either 'R' (Red) or 'B' (Blue). Otherwise, returns \\"Impossible\\". >>> paint_hex_grid(6, 7, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 5), (4, 6), (5, 6)]) \\"PossiblenRBRBRB\\" >>> paint_hex_grid(4, 5, [(1, 2), (2, 3), (3, 1), (1, 4), (3, 4)]) \\"Impossible\\" pass from typing import List, Tuple def test_example_1(): n = 6 m = 7 edges = [(1, 2), (1, 3), (2, 4), (2, 5), (3, 5), (4, 6), (5, 6)] result = paint_hex_grid(n, m, edges) assert result.startswith(\\"Possible\\") def test_example_2(): n = 4 m = 5 edges = [(1, 2), (2, 3), (3, 1), (1, 4), (3, 4)] result = paint_hex_grid(n, m, edges) assert result == \\"Impossible\\" def test_single_vertex(): n = 1 m = 0 edges = [] result = paint_hex_grid(n, m, edges) assert result == \\"PossiblenR\\" def test_two_connected_vertices(): n = 2 m = 1 edges = [(1, 2)] result = paint_hex_grid(n, m, edges) assert result == \\"PossiblenRB\\" or result == \\"PossiblenBR\\" def test_complex_graph(): n = 8 m = 9 edges = [(1, 2), (1, 3), (2, 4), (3, 4), (4, 5), (5, 6), (5, 7), (6, 8), (7, 8)] result = paint_hex_grid(n, m, edges) assert result.startswith(\\"Possible\\")","solution":"def is_bipartite(graph, n): color = [-1] * n def bfs(source): queue = [source] color[source] = 0 while queue: node = queue.pop(0) for neighbor in graph[node]: if color[neighbor] == -1: color[neighbor] = 1 - color[node] queue.append(neighbor) elif color[neighbor] == color[node]: return False return True for src in range(n): if color[src] == -1: if not bfs(src): return \\"Impossible\\" result = ''.join(['R' if c == 0 else 'B' for c in color]) return f\\"Possiblen{result}\\" def paint_hex_grid(n, m, edges): graph = [[] for _ in range(n)] for u, v in edges: graph[u - 1].append(v - 1) graph[v - 1].append(u - 1) return is_bipartite(graph, n) # Example usage: # n = 6 # m = 7 # edges = [(1, 2), (1, 3), (2, 4), (2, 5), (3, 5), (4, 6), (5, 6)] # print(paint_hex_grid(n, m, edges))"},{"question":"def smallest_concatenated_number(N, K): Constructs the smallest possible number by concatenating exactly K integers chosen from the interval [1, N]. Args: N : int : The upper limit of the selection range (inclusive). K : int : The number of integers to concatenate. Returns: str : The smallest possible concatenated number. Examples: >>> smallest_concatenated_number(5, 3) '111' >>> smallest_concatenated_number(10, 4) '1111' pass # implement the function here from solution import smallest_concatenated_number def test_smallest_concatenated_number_small_input(): assert smallest_concatenated_number(5, 3) == '111' assert smallest_concatenated_number(10, 4) == '1111' def test_smallest_concatenated_number_large_k(): assert smallest_concatenated_number(100, 10) == '1111111111' def test_smallest_concatenated_number_edge_case_n1_k1(): assert smallest_concatenated_number(1, 1) == '1' def test_smallest_concatenated_number_edge_case_n1000_k10(): assert smallest_concatenated_number(1000, 10) == '1111111111' def test_smallest_concatenated_number_edge_case_n1000_k1(): assert smallest_concatenated_number(1000, 1) == '1' def test_smallest_concatenated_number_various_cases(): assert smallest_concatenated_number(7, 2) == '11' assert smallest_concatenated_number(50, 5) == '11111'","solution":"def smallest_concatenated_number(N, K): Constructs the smallest possible number by concatenating exactly K integers chosen from the interval [1, N]. Args: N : int : The upper limit of the selection range (inclusive). K : int : The number of integers to concatenate. Returns: str : The smallest possible concatenated number. return '1' * K"},{"question":"def longestUniquePath(N, M, grid): Determine the length of the longest path in a grid where the path does not revisit any character and all characters in the path are adjacent either horizontally or vertically. >>> N = 3 >>> M = 4 >>> grid = [ ... ['a', 'b', 'c', 'd'], ... ['e', 'f', 'g', 'h'], ... ['i', 'j', 'k', 'l'] ... ] >>> longestUniquePath(N, M, grid) 12 >>> N = 2 >>> M = 2 >>> grid = [ ... ['a', 'b'], ... ['c', 'a'] ... ] >>> longestUniquePath(N, M, grid) 3 Args: N (int): Number of rows in the grid. M (int): Number of columns in the grid. grid (List[List[str]]): The grid represented as a list of lists of characters. Returns: int: The length of the longest path with unique characters.","solution":"def longestUniquePath(N, M, grid): def dfs(x, y, visited): max_length = 0 for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and grid[nx][ny] not in visited: max_length = max(max_length, dfs(nx, ny, visited | {grid[nx][ny]})) return 1 + max_length longest_path = 0 for i in range(N): for j in range(M): longest_path = max(longest_path, dfs(i, j, {grid[i][j]})) return longest_path"},{"question":"def max_unique_cocktails(n, m, combinations): Calculate the maximum number of unique cocktails Robin can make. Parameters: n (int): Number of spirits. m (int): Number of valid combinations. combinations (list of list of int): Each inner list represents a combination of spirit ids. Returns: int: Maximum number of unique cocktails. >>> max_unique_cocktails(3, 4, [[1, 2], [2, 3], [1, 2, 3], [3]]) 4 >>> max_unique_cocktails(5, 3, [[1, 2], [3, 4], [2, 3, 5]]) 3 >>> max_unique_cocktails(3, 3, [[1, 2], [1, 2], [2, 3]]) 2 >>> max_unique_cocktails(4, 5, [[1, 2], [3, 4], [2], [1, 3, 4], [2, 3]]) 5 >>> max_unique_cocktails(0, 0, []) 0 >>> max_unique_cocktails(1, 1, [[1]]) 1 # Placeholder for implementation pass","solution":"def max_unique_cocktails(n, m, combinations): Calculate the maximum number of unique cocktails Robin can make. Parameters: n (int): Number of spirits. m (int): Number of valid combinations. combinations (list of list of int): Each inner list represents a combination of spirit ids. Returns: int: Maximum number of unique cocktails. unique_combinations = set() for combo in combinations: # Convert the list to a frozenset to ensure it is hashable and can be added to the set unique_combinations.add(frozenset(combo)) return len(unique_combinations)"},{"question":"def min_trip_cost(n, m, B, p, q): Returns the minimum possible total cost of the trip, given the budget constraint. If no valid combination of flights satisfies the budget constraint, returns -1. Args: n (int): The number of flights from city A to city B. m (int): The number of flights from city B to city C. B (int): The maximum budget for any single flight. p (List[int]): List of costs for flights from city A to city B. q (List[int]): List of costs for flights from city B to city C. Returns: int: The minimum possible total cost of the trip, or -1 if no valid combination exists. Examples: >>> min_trip_cost(3, 4, 100, [80, 40, 60], [20, 10, 50, 90]) 50 >>> min_trip_cost(2, 3, 30, [25, 35], [10, 30, 40]) 35 >>> min_trip_cost(3, 3, 15, [20, 25, 30], [10, 15, 20]) -1 # Write your implementation here def parse_input_and_min_trip_cost(input_string): Parses the input string and returns the minimum trip cost. Args: input_string (str): Input string in the specified format. Returns: int: The minimum possible total cost of the trip, or -1 if no valid combination exists. Examples: >>> parse_input_and_min_trip_cost(\\"3 4 100n80 40 60n20 10 50 90\\") 50 >>> parse_input_and_min_trip_cost(\\"2 3 30n25 35n10 30 40\\") 35 >>> parse_input_and_min_trip_cost(\\"3 3 15n20 25 30n10 15 20\\") -1 lines = input_string.strip().split('n') n, m, B = map(int, lines[0].split()) p = list(map(int, lines[1].split())) q = list(map(int, lines[2].split())) return min_trip_cost(n, m, B, p, q)","solution":"def min_trip_cost(n, m, B, p, q): Returns the minimum possible total cost of the trip, given the budget constraint. If no valid combination of flights satisfies the budget constraint, returns -1. # Filter the flights within budget constraint B p = [cost for cost in p if cost <= B] q = [cost for cost in q if cost <= B] # If there are no valid flights left in either list, return -1 if not p or not q: return -1 # Find the minimum possible total cost min_total_cost = min(p) + min(q) return min_total_cost # Provided implementation following input as described in the prompt def parse_input_and_min_trip_cost(input_string): lines = input_string.strip().split('n') n, m, B = map(int, lines[0].split()) p = list(map(int, lines[1].split())) q = list(map(int, lines[2].split())) return min_trip_cost(n, m, B, p, q)"},{"question":"def filter_numbers(numbers, threshold): Returns a list of numbers from the input list that are greater than the given threshold. :param numbers: List[int] - A list of integers. :param threshold: int - A single integer threshold. :return: List[int] - A list of integers from the input list that are greater than the threshold. >>> filter_numbers([1, 2, 3, 4, 5], 3) [4, 5] >>> filter_numbers([10, 20, 30], 25) [30] >>> filter_numbers([5, 7, 2, 9], 9) [] >>> filter_numbers([], 1) [] >>> filter_numbers([-1, -2, -3, 0], -2) [-1, 0] >>> filter_numbers([5, 10, 15], 5) [10, 15] >>> filter_numbers([1, 1, 1, 1], 1) [] >>> filter_numbers([0, 0, 0, 0], -1) [0, 0, 0, 0]","solution":"def filter_numbers(numbers, threshold): Returns a list of numbers from the input list that are greater than the given threshold. :param numbers: List[int] - A list of integers. :param threshold: int - A single integer threshold. :return: List[int] - A list of integers from the input list that are greater than the threshold. return [num for num in numbers if num > threshold]"},{"question":"def longest_alternating_subsequence(n: int, heights: List[int]) -> int: Determine the longest subsequence of days where the plant's height strictly alternates between growing and shrinking. >>> longest_alternating_subsequence(5, [1, 3, 2, 4, 3]) 5 >>> longest_alternating_subsequence(4, [2, 2, 2, 2]) 1 >>> longest_alternating_subsequence(6, [3, 2, 1, 2, 1, 3]) 5 def process_test_cases(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Process multiple test cases to determine the length of the longest strictly alternating subsequence for each case. >>> process_test_cases(3, [(5, [1, 3, 2, 4, 3]), (4, [2, 2, 2, 2]), (6, [3, 2, 1, 2, 1, 3])]) [5, 1, 5] def test_longest_alternating_subsequence(): # Sample input 1 assert longest_alternating_subsequence(5, [1, 3, 2, 4, 3]) == 5 assert longest_alternating_subsequence(4, [2, 2, 2, 2]) == 1 assert longest_alternating_subsequence(6, [3, 2, 1, 2, 1, 3]) == 5 # Additional tests assert longest_alternating_subsequence(0, []) == 0 assert longest_alternating_subsequence(1, [1]) == 1 assert longest_alternating_subsequence(2, [1, 2]) == 2 assert longest_alternating_subsequence(2, [2, 1]) == 2 assert longest_alternating_subsequence(3, [1, 2, 1]) == 3 assert longest_alternating_subsequence(3, [2, 1, 2]) == 3 assert longest_alternating_subsequence(3, [1, 3, 2]) == 3 assert longest_alternating_subsequence(5, [1, 2, 3, 4, 5]) == 2 def test_process_test_cases(): input_cases = [ (5, [1, 3, 2, 4, 3]), (4, [2, 2, 2, 2]), (6, [3, 2, 1, 2, 1, 3]) ] output_results = [5, 1, 5] assert process_test_cases(3, input_cases) == output_results","solution":"def longest_alternating_subsequence(n, heights): if n == 0: return 0 # Initialization longest_length = 1 current_trend = 0 # 0 means no trend, 1 means increasing, -1 means decreasing for i in range(1, n): if heights[i] > heights[i - 1] and current_trend != 1: longest_length += 1 current_trend = 1 elif heights[i] < heights[i - 1] and current_trend != -1: longest_length += 1 current_trend = -1 return longest_length def process_test_cases(T, test_cases): results = [] for i in range(T): n, heights = test_cases[i] results.append(longest_alternating_subsequence(n, heights)) return results"},{"question":"def is_sum_divisible_by_3(s: str) -> bool: Checks if the sum of ASCII values of the characters in the string \`s\` is divisible by 3. >>> is_sum_divisible_by_3(\\"Watson\\") True >>> is_sum_divisible_by_3(\\"Sherlock\\") False def who_is_at_the_door(test_cases: List[str]) -> List[str]: Given a list of test cases with strings, returns a list of \\"YES\\" or \\"NO\\" based on whether the sum of ASCII values of the characters in each string is divisible by 3. >>> who_is_at_the_door([\\"Sherlock\\", \\"Watson\\"]) [\\"NO\\", \\"YES\\"] >>> who_is_at_the_door([\\"abc\\", \\"def\\"]) [\\"YES\\", \\"YES\\"]","solution":"def is_sum_divisible_by_3(s): Checks if the sum of ASCII values of the characters in the string \`s\` is divisible by 3. ascii_sum = sum(ord(char) for char in s) return ascii_sum % 3 == 0 def who_is_at_the_door(test_cases): Given a list of test cases with strings, returns a list of \\"YES\\" or \\"NO\\" based on whether the sum of ASCII values of the characters in each string is divisible by 3. result = [] for s in test_cases: if is_sum_divisible_by_3(s): result.append(\\"YES\\") else: result.append(\\"NO\\") return result"},{"question":"def top_scores(n: int, p: int, scores: List[int]) -> List[int]: Determines the top p scores, including ties. >>> top_scores(5, 3, [50, 80, 80, 70, 90]) [90, 80, 80] >>> top_scores(6, 4, [100, 100, 90, 80, 75, 70]) [100, 100, 90, 80] >>> top_scores(4, 2, [60, 85, 85, 75]) [85, 85] >>> top_scores(5, 3, [100, 100, 100, 100, 100]) [100, 100, 100, 100, 100] >>> top_scores(7, 5, [56, 75, 65, 85, 75, 56, 95]) [95, 85, 75, 75, 65] >>> top_scores(1, 1, [42]) [42] >>> top_scores(7, 4, [70, 85, 85, 85, 60, 50, 40]) [85, 85, 85, 70]","solution":"def top_scores(n, p, scores): Determines the top p scores, including ties. Parameters: n (int): The number of scores p (int): The number of top scores to return scores (List[int]): The list of scores Returns: List[int]: The list of top p scores, sorted in non-increasing order. # Sort scores in non-increasing order sorted_scores = sorted(scores, reverse=True) # Collect the top p scores including ties top_p_scores = sorted_scores[:p] cutoff_score = top_p_scores[-1] # Include all scores that are tied with the last score in top_p_scores result = [score for score in sorted_scores if score >= cutoff_score] return result"},{"question":"from collections import defaultdict, deque def find_task_order(N, M, prerequisites): Find the order in which to complete tasks to satisfy all the prerequisites, if possible. If there are multiple valid orderings, output any one of them. If it's not possible to complete all the tasks due to a cycle, output \\"Impossible\\". Args: N (int): The number of tasks. M (int): The number of prerequisites. prerequisites (List[Tuple[int, int]]): A list of prerequisites as (A_i, B_i) pairs. Returns: str: A space-separated string representing the task order or \\"Impossible\\" if not possible. def main(input_str): input_lines = input_str.strip().split(\\"n\\") N, M = map(int, input_lines[0].split()) prerequisites = [tuple(map(int, line.split())) for line in input_lines[1:]] return find_task_order(N, M, prerequisites) # Unit tests def test_find_task_order_possible(): input_str = \\"4 3n1 2n3 2n4 3n\\" assert main(input_str) in [\\"1 4 3 2\\", \\"4 1 3 2\\"] def test_find_task_order_impossible(): input_str = \\"2 2n1 2n2 1n\\" assert main(input_str) == \\"Impossible\\" def test_find_task_order_single_task(): input_str = \\"1 0n\\" assert main(input_str) == \\"1\\" def test_find_task_order_multiple_orders(): input_str = \\"3 2n1 2n1 3n\\" assert main(input_str) in [\\"1 2 3\\", \\"1 3 2\\"] def test_find_task_order_no_prerequisites(): input_str = \\"3 0n\\" assert main(input_str) in [\\"1 2 3\\", \\"1 3 2\\", \\"2 1 3\\", \\"2 3 1\\", \\"3 1 2\\", \\"3 2 1\\"] def test_find_task_order_complex(): input_str = \\"6 6n1 2n1 3n3 4n2 4n4 5n5 6n\\" assert main(input_str) == \\"1 2 3 4 5 6\\" # or any other valid topological sort","solution":"from collections import defaultdict, deque def find_task_order(N, M, prerequisites): # Create an adjacency list and indegree array adj_list = defaultdict(list) indegree = [0] * (N + 1) # Populate the adjacency list and indegree array for A, B in prerequisites: adj_list[A].append(B) indegree[B] += 1 # Initialize a queue with all tasks having 0 indegree queue = deque([i for i in range(1, N + 1) if indegree[i] == 0]) order = [] # Process the queue while queue: current = queue.popleft() order.append(current) # Decrease the indegree of neighbors and add to queue if they become 0 for neighbor in adj_list[current]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) # If the order contains all tasks, return the order, else return Impossible if len(order) == N: return \\" \\".join(map(str, order)) else: return \\"Impossible\\" def main(input_str): input_lines = input_str.strip().split(\\"n\\") N, M = map(int, input_lines[0].split()) prerequisites = [tuple(map(int, line.split())) for line in input_lines[1:]] return find_task_order(N, M, prerequisites)"},{"question":"def max_consecutive_days(N: int, W: int, water_requirements: List[int]) -> int: Returns the maximum number of continuous days Alice can keep all crops healthy. :param N: Number of crops :param W: Daily water supply :param water_requirements: List of daily water requirements for each crop :return: Maximum number of continuous days >>> max_consecutive_days(5, 100, [15, 20, 10, 30, 25]) 1 >>> max_consecutive_days(4, 50, [10, 20, 30, 40]) 0 >>> max_consecutive_days(3, 300, [100, 100, 100]) 1 def process_test_cases(test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Process all test cases and returns the results for each test case. :param test_cases: List of tuples where each tuple contains N, W, and water requirements :return: List of results for each test case >>> test_cases = [ ... (5, 100, [15, 20, 10, 30, 25]), ... (4, 50, [10, 20, 30, 40]), ... (3, 300, [100, 100, 100]) ... ] >>> process_test_cases(test_cases) [1, 0, 1]","solution":"def max_consecutive_days(N, W, water_requirements): Returns the maximum number of continuous days Alice can keep all crops healthy. :param N: Number of crops :param W: Daily water supply :param water_requirements: List of daily water requirements for each crop :return: Maximum number of continuous days # Calculate the total daily water requirement for all crops total_daily_water_requirement = sum(water_requirements) # Determine the number of days Alice can keep the crops healthy if total_daily_water_requirement > W: return 0 # Alice cannot water all crops at all from the very start else: return W // total_daily_water_requirement # Determine the maximum days def process_test_cases(test_cases): Process all test cases and returns the results for each test case. :param test_cases: List of tuples where each tuple contains N, W, and water requirements :return: List of results for each test case results = [] for N, W, water_requirements in test_cases: result = max_consecutive_days(N, W, water_requirements) results.append(result) return results"},{"question":"def parse_input(data: str): Parses the input data and returns it in a structured format. >>> parse_input(\\"3 2n1 500n2 1000n3 300n5 1 100n3 2 250n0 0\\") [ ([(1, 500), (2, 1000), (3, 300)], [(5, 1, 100), (3, 2, 250)]) ] def compute_planks(inventory: List[Tuple[int, int]], orders: List[Tuple[int, int, int]]) -> List[int]: Calculates the number of wood planks required for each order. >>> compute_planks([(1, 500), (2, 1000), (3, 300)], [(5, 1, 100), (3, 2, 250)]) [1, 1, 0] def get_wood_planks(data: str) -> List[List[int]]: Processes the entire input data and computes the required planks. >>> get_wood_planks(\\"3 2n1 500n2 1000n3 300n5 1 100n3 2 250n0 0\\") [[1, 1, 0]] def format_output(results: List[List[int]]) -> str: Formats the output results into a string format. >>> format_output([[1, 1, 0]]) \\"1 1 0\\"","solution":"def parse_input(data): lines = data.strip().split('n') index = 0 result = [] while index < len(lines): I, J = map(int, lines[index].split()) if I == 0 and J == 0: break index += 1 inventory = [] for i in range(I): wi, li = map(int, lines[index].split()) inventory.append((wi, li)) index += 1 orders = [] for j in range(J): nj, kj, tj = lines[index].split() orders.append((int(nj), int(kj), int(tj))) index += 1 result.append((inventory, orders)) return result def compute_planks(inventory, orders): requirements = {wood_type: 0 for wood_type, _ in inventory} for pieces, wood_type, required_length in orders: requirements[wood_type] += pieces * required_length planks_needed = [] for wood_type, inventory_length in inventory: if requirements[wood_type] > 0: planks_needed.append(-(-requirements[wood_type] // inventory_length)) # Ceiling division else: planks_needed.append(0) return planks_needed def get_wood_planks(data): datasets = parse_input(data) results = [] for inventory, orders in datasets: result = compute_planks(inventory, orders) results.append(result) return results def format_output(results): result_lines = [] for result in results: result_lines.append(\\" \\".join(map(str, result))) return \\"n\\".join(result_lines)"},{"question":"def bubble_sort(arr): Sorts a list of integers in non-decreasing order using the bubble sort algorithm. pass def process_test_cases(test_cases): Processes multiple test cases. Each test case is a tuple (N, array). Returns a list of results where each result is the sorted array for a test case. pass import pytest def test_bubble_sort(): assert bubble_sort([64, 25, 12, 22, 11]) == [11, 12, 22, 25, 64] assert bubble_sort([-1, -3, 0, 99]) == [-3, -1, 0, 99] assert bubble_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert bubble_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] assert bubble_sort([0]) == [0] assert bubble_sort([]) == [] def test_process_test_cases(): assert process_test_cases([(5, [64, 25, 12, 22, 11])]) == [[11, 12, 22, 25, 64]] assert process_test_cases([(4, [-1, -3, 0, 99]), (5, [64, 25, 12, 22, 11])]) == [[-3, -1, 0, 99], [11, 12, 22, 25, 64]] assert process_test_cases([(1, [1]), (3, [3, 2, 1])]) == [[1], [1, 2, 3]] assert process_test_cases([(3, [100, -100, 0]), (2, [-1, 1])]) == [[-100, 0, 100], [-1, 1]] if __name__ == \\"__main__\\": pytest.main()","solution":"def bubble_sort(arr): Sorts a list of integers in non-decreasing order using the bubble sort algorithm. n = len(arr) for i in range(n): for j in range(0, n-i-1): # Swap if the element found is greater than the next element if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] return arr def process_test_cases(test_cases): Processes multiple test cases. Each test case is a tuple (N, array). Returns a list of results where each result is the sorted array for a test case. results = [] for case in test_cases: N, array = case sorted_array = bubble_sort(array) results.append(sorted_array) return results"},{"question":"def checkDupWithinK(arr: List[int], k: int) -> bool: Determines if the array contains any duplicate elements within k distance from each other. >>> checkDupWithinK([1, 2, 3, 1], 3) True >>> checkDupWithinK([1, 0, 1, 1], 1) True >>> checkDupWithinK([1, 2, 3, 4, 5], 2) False","solution":"def checkDupWithinK(arr, k): Determines if the array contains any duplicate elements within k distance from each other. Parameters: arr (List[int]): The array to check for duplicates. k (int): The maximum allowed distance between duplicate elements. Returns: bool: True if there are duplicate elements within k distance, False otherwise. seen_elements = {} for i, value in enumerate(arr): if value in seen_elements and i - seen_elements[value] <= k: return True seen_elements[value] = i return False"},{"question":"from typing import List, Tuple def isBypassExists(n: int, m: int, edges: List[Tuple[int, int]], K: int, A: int, B: int) -> bool: Determine if there exists a bypass from intersection A to intersection B with at most K intermediate intersections. :param n: Number of intersections :param m: Number of streets :param edges: List of tuples representing directed edges :param K: Maximum number of intermediate intersections :param A: Starting intersection :param B: Destination intersection :return: Boolean value indicating whether a bypass exists >>> isBypassExists(5, 6, [(1, 2), (2, 3), (3, 4), (4, 5), (1, 3), (1, 4)], 2, 1, 5) True >>> isBypassExists(5, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (1, 3)], 1, 1, 5) False >>> isBypassExists(3, 3, [(1, 2), (2, 3), (1, 3)], 0, 1, 3) True >>> isBypassExists(3, 3, [(1, 1), (1, 2), (2, 3)], 2, 1, 3) True >>> isBypassExists(3, 2, [(1, 2), (2, 1)], 2, 1, 3) False >>> isBypassExists(4, 4, [(1, 2), (2, 3), (3, 4), (1, 3)], 2, 1, 4) True","solution":"from collections import deque, defaultdict def isBypassExists(n, m, edges, K, A, B): Determine if there exists a bypass from intersection A to intersection B with at most K intermediate intersections. :param n: Number of intersections :param m: Number of streets :param edges: List of tuples representing directed edges :param K: Maximum number of intermediate intersections :param A: Starting intersection :param B: Destination intersection :return: Boolean value indicating whether a bypass exists # Create the graph representation graph = defaultdict(list) for u, v in edges: graph[u].append(v) # BFS to find the shortest path from A to B with at most K intermediate nodes queue = deque([(A, 0)]) # (current node, current depth) visited = set((A, 0)) while queue: node, depth = queue.popleft() if node == B: return True if depth < K + 1: for neighbor in graph[node]: if (neighbor, depth + 1) not in visited: visited.add((neighbor, depth + 1)) queue.append((neighbor, depth + 1)) return False"},{"question":"def find_lexicographically_smallest_array(N: int, K: int, A: List[int]) -> List[int]: Performs exactly one reverse operation on any K consecutive elements to make the array lexicographically smallest. Parameters: N (int): The size of the array. K (int): The number of consecutive elements to reverse. A (List[int]): The array of integers. Returns: List[int]: The lexicographically smallest array possible after one reverse operation. Examples: >>> find_lexicographically_smallest_array(5, 3, [4, 3, 2, 1, 5]) [2, 3, 4, 1, 5] >>> find_lexicographically_smallest_array(4, 4, [7, 6, 5, 1]) [1, 5, 6, 7] from typing import List # Unit Test def test_example_case(): N, K = 5, 3 A = [4, 3, 2, 1, 5] assert find_lexicographically_smallest_array(N, K, A) == [2, 3, 4, 1, 5] def test_all_elements_ascending(): N, K = 7, 4 A = [1, 2, 3, 4, 5, 6, 7] assert find_lexicographically_smallest_array(N, K, A) == [1, 2, 3, 4, 5, 6, 7] def test_reverse_entire_array(): N, K = 4, 4 A = [7, 6, 5, 1] assert find_lexicographically_smallest_array(N, K, A) == [1, 5, 6, 7] def test_multiple_same_values(): N, K = 5, 3 A = [1, 2, 2, 2, 1] assert find_lexicographically_smallest_array(N, K, A) == [1, 2, 1, 2, 2] def test_already_sorted(): N, K = 3, 2 A = [1, 2, 3] assert find_lexicographically_smallest_array(N, K, A) == [1, 2, 3]","solution":"def find_lexicographically_smallest_array(N, K, A): Performs exactly one reverse operation on any K consecutive elements to make the array lexicographically smallest. smallest_array = A[:] for i in range(N - K + 1): current_array = A[:i] + A[i:i+K][::-1] + A[i+K:] if current_array < smallest_array: smallest_array = current_array return smallest_array # Example input N = 5 K = 3 A = [4, 3, 2, 1, 5] # Example usage result = find_lexicographically_smallest_array(N, K, A) print(result) # Output should be [2, 3, 4, 1, 5]"},{"question":"def find_pairs_with_sum(N, T, numbers): Finds all pairs of integers in the list whose sum equals the target value. Arguments: N -- the number of integers in the list T -- the target sum numbers -- the list of N integers Returns: A list of tuples, each containing a pair of integers whose sum equals T return [] from find_pairs_with_sum import find_pairs_with_sum def test_find_pairs_with_sum_example_1(): assert find_pairs_with_sum(5, 10, [2, 8, 3, 7, 1]) == [(2, 8), (3, 7)] def test_find_pairs_with_sum_example_2(): assert find_pairs_with_sum(4, 0, [-1, 0, 1, 2]) == [(-1, 1)] def test_find_pairs_with_sum_no_pairs(): assert find_pairs_with_sum(5, 100, [1, 2, 3, 4, 5]) == [] def test_find_pairs_with_sum_multiple_pairs(): assert find_pairs_with_sum(6, 5, [1, 4, 2, 3, 0, 5]) == [(0, 5), (1, 4), (2, 3)] def test_find_pairs_with_sum_negative_target(): assert find_pairs_with_sum(4, -3, [2, -5, 4, -1, ]) == [(-5, 2)] def test_find_pairs_with_sum_duplicates(): # This case also tests that each pair of integers appears at most once in the output assert find_pairs_with_sum(7, 10, [5, 5, 5, 5, 0, 10, 10]) == [(0, 10), (5, 5)]","solution":"def find_pairs_with_sum(N, T, numbers): Finds all pairs of integers in the list whose sum equals the target value. Arguments: N -- the number of integers in the list T -- the target sum numbers -- the list of N integers Returns: A list of tuples, each containing a pair of integers whose sum equals T seen = set() pairs = set() for num in numbers: complement = T - num if complement in seen: pairs.add((min(num, complement), max(num, complement))) seen.add(num) return sorted(list(pairs)) # Example usage: if __name__ == \\"__main__\\": # Read input N, T = map(int, input().split()) numbers = list(map(int, input().split())) # Find and print pairs result = find_pairs_with_sum(N, T, numbers) for pair in result: print(pair[0], pair[1])"},{"question":"def has_diverse_shortest_path(n: int, m: int, colors: List[int], edges: List[Tuple[int, int]]) -> str: Given an undirected graph with n vertices and m edges, each vertex having a color represented by an integer, determine if there exists two vertices such that the shortest path between them involves vertices with at least two distinct colors. Args: n (int): Number of vertices. m (int): Number of edges. colors (List[int]): List of colors for each vertex. edges (List[Tuple[int, int]]): List of edges where each edge is a tuple containing two vertices. Returns: str: \\"YES\\" if there exists such a path, otherwise \\"NO\\". Examples: >>> has_diverse_shortest_path(5, 4, [1, 2, 1, 2, 3], [(1, 2), (2, 3), (3, 4), (4, 5)]) \\"YES\\" >>> has_diverse_shortest_path(4, 3, [1, 1, 1, 2], [(1, 2), (2, 3), (3, 4)]) \\"YES\\" >>> has_diverse_shortest_path(4, 4, [1, 1, 1, 1], [(1, 2), (2, 3), (3, 4), (4, 1)]) \\"NO\\"","solution":"from collections import deque def has_diverse_shortest_path(n, m, colors, edges): if len(set(colors)) == 1: return \\"NO\\" graph = [[] for _ in range(n + 1)] for u, v in edges: graph[u].append(v) graph[v].append(u) visited = [False] * (n + 1) for start in range(1, n + 1): queue = deque([(start, 0)]) visited = [False] * (n + 1) visited[start] = True start_color = colors[start - 1] while queue: node, dist = queue.popleft() for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True if colors[neighbor - 1] != start_color: return \\"YES\\" queue.append((neighbor, dist + 1)) return \\"NO\\""},{"question":"def almost_increasing(sequence) -> str: Checks if a sequence is almost increasing. Args: sequence (list of int): The list of integers representing the sequence. Returns: str: \\"YES\\" if the sequence is almost increasing, \\"NO\\" otherwise. >>> almost_increasing([1, 3, 2, 1, 4]) \\"NO\\" >>> almost_increasing([1, 2, 10, 5]) \\"YES\\" >>> almost_increasing([1, 2, 3, 4, 5, 6]) \\"YES\\"","solution":"def almost_increasing(sequence): Checks if a sequence is almost increasing. Args: sequence (list of int): The list of integers representing the sequence. Returns: bool: True if the sequence is almost increasing, False otherwise. def is_strictly_increasing(seq): return all(x < y for x, y in zip(seq, seq[1:])) # Check if the original sequence is already strictly increasing if is_strictly_increasing(sequence): return \\"YES\\" # Check by removing each element once for i in range(len(sequence)): if is_strictly_increasing(sequence[:i] + sequence[i+1:]): return \\"YES\\" return \\"NO\\""},{"question":"import heapq from typing import List, Tuple def shortest_path(n: int, m: int, a: int, b: int, edges: List[Tuple[int, int, int]]) -> List[int]: Find the shortest path in an undirected graph from node a to node b. Each edge is given as a tuple (u, v, w) where u and v are nodes and w is the weight. >>> shortest_path(5, 6, 1, 5, [(1, 2, 2), (1, 3, 4), (2, 3, 1), (2, 4, 7), (3, 5, 3), (4, 5, 1)]) [1, 2, 3, 5] >>> shortest_path(4, 4, 1, 4, [(1, 2, 2), (1, 3, 1), (2, 4, 3), (3, 4, 1)]) [1, 3, 4] pass # Your implementation here # Example test cases def test_shortest_path_case_1(): n = 5 m = 6 a = 1 b = 5 edges = [(1, 2, 2), (1, 3, 4), (2, 3, 1), (2, 4, 7), (3, 5, 3), (4, 5, 1)] result = shortest_path(n, m, a, b, edges) assert result == [1, 2, 3, 5] or result == [1, 3, 5] # Multiple correct paths def test_shortest_path_case_2(): n = 4 m = 4 a = 1 b = 4 edges = [(1, 2, 2), (1, 3, 1), (2, 4, 3), (3, 4, 1)] result = shortest_path(n, m, a, b, edges) assert result == [1, 3, 4] def test_shortest_path_case_3(): n = 3 m = 3 a = 1 b = 3 edges = [(1, 2, 2), (2, 3, 2), (1, 3, 5)] result = shortest_path(n, m, a, b, edges) assert result == [1, 2, 3] def test_shortest_path_case_4(): n = 6 m = 7 a = 1 b = 6 edges = [(1, 2, 2), (1, 3, 4), (2, 3, 1), (2, 4, 7), (3, 5, 3), (4, 5, 1), (5, 6, 2)] result = shortest_path(n, m, a, b, edges) assert result == [1, 2, 3, 5, 6] or result == [1, 2, 3, 5, 6] def test_shortest_path_case_5(): n = 4 m = 5 a = 1 b = 4 edges = [(1, 2, 1), (2, 3, 2), (3, 4, 1), (1, 3, 2), (2, 4, 4)] result = shortest_path(n, m, a, b, edges) assert result == [1, 3, 4]","solution":"import heapq def shortest_path(n, m, a, b, edges): graph = [[] for _ in range(n+1)] for u, v, w in edges: graph[u].append((w, v)) graph[v].append((w, u)) dist = [float('inf')] * (n+1) dist[a] = 0 prev = [None] * (n+1) pq = [(0, a)] while pq: d, node = heapq.heappop(pq) if d > dist[node]: continue for weight, neighbor in graph[node]: new_dist = d + weight if new_dist < dist[neighbor]: dist[neighbor] = new_dist prev[neighbor] = node heapq.heappush(pq, (new_dist, neighbor)) path = [] current = b while current: path.append(current) current = prev[current] return path[::-1] # Example usage: n = 5 m = 6 a = 1 b = 5 edges = [(1, 2, 2), (1, 3, 4), (2, 3, 1), (2, 4, 7), (3, 5, 3), (4, 5, 1)] print(shortest_path(n, m, a, b, edges)) # Output: [1, 2, 3, 5]"},{"question":"def read_employees_data(): Reads employees' data from user input and returns a list of dictionaries containing employee information. pass def search_employees_by_last_name(employees, last_name): Searches for employees by their last name and returns a list of matching employee information. pass # Unit Tests def test_sample_input_1(monkeypatch): input_data = \\"3nJohn Doe 30 ManagernAlice Smith 28 DevelopernBob Doe 25 DesignernDoen\\" monkeypatch.setattr('sys.stdin.read', lambda: input_data) employees, last_name = read_employees_data() result = search_employees_by_last_name(employees, last_name) expected_result = [\\"John Doe 30 Manager\\", \\"Bob Doe 25 Designer\\"] assert result == expected_result def test_sample_input_2(monkeypatch): input_data = \\"2nJane Austen 40 HRnMark Twain 35 EngineernTenantn\\" monkeypatch.setattr('sys.stdin.read', lambda: input_data) employees, last_name = read_employees_data() result = search_employees_by_last_name(employees, last_name) expected_result = \\"No employees with that last name found.\\" assert result == expected_result def test_no_employees(): employees = [] result = search_employees_by_last_name(employees, \\"AnyLastName\\") expected_result = \\"No employees with that last name found.\\" assert result == expected_result def test_one_employee_found(): employees = [{\\"first_name\\": \\"John\\", \\"last_name\\": \\"Doe\\", \\"age\\": \\"30\\", \\"position\\": \\"Manager\\"}] result = search_employees_by_last_name(employees, \\"Doe\\") expected_result = [\\"John Doe 30 Manager\\"] assert result == expected_result def test_no_employees_found(): employees = [{\\"first_name\\": \\"Jane\\", \\"last_name\\": \\"Austen\\", \\"age\\": \\"40\\", \\"position\\": \\"HR\\"}] result = search_employees_by_last_name(employees, \\"Twain\\") expected_result = \\"No employees with that last name found.\\" assert result == expected_result","solution":"def read_employees_data(): Reads employees' data from user input and returns a list of dictionaries containing employee information. import sys input = sys.stdin.read data = input().strip().split(\\"n\\") n = int(data[0]) employees = [] for i in range(1, n+1): first_name, last_name, age, position = data[i].split() employees.append({ \\"first_name\\": first_name, \\"last_name\\": last_name, \\"age\\": age, \\"position\\": position }) search_last_name = data[n+1] return employees, search_last_name def search_employees_by_last_name(employees, last_name): Searches for employees by their last name and returns a list of matching employee information. matching_employees = [e for e in employees if e['last_name'] == last_name] if not matching_employees: return \\"No employees with that last name found.\\" result = [] for e in matching_employees: result.append(f\\"{e['first_name']} {e['last_name']} {e['age']} {e['position']}\\") return result"},{"question":"from typing import List, Tuple def find_employees_on_date(P: int, W: int, projects: List[Tuple[str, str, str]], work_periods: List[Tuple[str, str, str, str]], Q: int, queries: List[str]) -> List[List[str]]: Given projects and work periods, find the employee IDs working on projects on specific dates. Parameters: P (int): number of projects W (int): number of work periods projects (List[Tuple[str, str, str]]): each tuple contains project ID, start date, and end date work_periods (List[Tuple[str, str, str, str]]): each tuple contains employee ID, project ID, first date, and last date Q (int): number of queries queries (List[str]): list of dates to check for employee participation Returns: List[List[str]]: list of lists containing unique employee IDs for each query date Examples: >>> find_employees_on_date( ... 2, 4, ... [[\\"P1\\", \\"2023-01-01\\", \\"2023-12-31\\"], [\\"P2\\", \\"2024-01-01\\", \\"2024-12-31\\"]], ... [[\\"E1\\", \\"P1\\", \\"2023-01-10\\", \\"2023-01-20\\"], [\\"E2\\", \\"P1\\", \\"2023-01-15\\", \\"2023-02-10\\"], [\\"E3\\", \\"P2\\", \\"2024-03-01\\", \\"2024-03-20\\"], [\\"E1\\", \\"P2\\", \\"2024-01-05\\", \\"2024-01-15\\"]], ... 3, ... [\\"2023-01-15\\", \\"2023-01-25\\", \\"2024-01-10\\"] ... ) [['E1', 'E2'], ['E2'], ['E1']]","solution":"import datetime from collections import defaultdict def parse_date(date_str): return datetime.datetime.strptime(date_str, '%Y-%m-%d').date() def find_employees_on_date(P, W, projects, work_periods, Q, queries): project_periods = {} for project in projects: project_id, start_str, end_str = project project_periods[project_id] = (parse_date(start_str), parse_date(end_str)) employee_work_periods = defaultdict(list) for work_period in work_periods: emp_id, project_id, first_str, last_str = work_period start_date, end_date = project_periods[project_id] emp_start_date = max(parse_date(first_str), start_date) emp_end_date = min(parse_date(last_str), end_date) if emp_start_date <= emp_end_date: employee_work_periods[emp_id].append((emp_start_date, emp_end_date)) results = [] for query_date_str in queries: query_date = parse_date(query_date_str) employees_working = set() for emp_id, periods in employee_work_periods.items(): for start_date, end_date in periods: if start_date <= query_date <= end_date: employees_working.add(emp_id) break results.append(sorted(employees_working)) return results"},{"question":"def marble_collection(n: int) -> (int, int): Calculate the total number of marbles in each jar after n days. Jar A: On i-th day, i marbles are added. Jar B: On i-th day, i^2 marbles are added. Parameters: n (int): The number of days. Returns: (int, int): Total marbles in jar A and B after n days. >>> marble_collection(3) (6, 14) >>> marble_collection(5) (15, 55)","solution":"def marble_collection(n: int) -> (int, int): Calculate the total number of marbles in each jar after n days. Jar A: On i-th day, i marbles are added. Jar B: On i-th day, i^2 marbles are added. Parameters: n (int): The number of days. Returns: (int, int): Total marbles in jar A and B after n days. total_A = sum(i for i in range(1, n+1)) total_B = sum(i**2 for i in range(1, n+1)) return total_A, total_B"},{"question":"from typing import List def longest_increasing_subsequence(arr: List[int]) -> int: Returns the length of the longest strictly increasing subsequence in the given array. >>> longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) == 4 >>> longest_increasing_subsequence([1, 2, 3, 4, 5]) == 5 >>> longest_increasing_subsequence([5, 4, 3, 2, 1]) == 1","solution":"from typing import List def longest_increasing_subsequence(arr: List[int]) -> int: Returns the length of the longest strictly increasing subsequence in the given array. if not arr: return 0 n = len(arr) dp = [1] * n for i in range(1, n): for j in range(i): if arr[i] > arr[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def longest_palindrome(s: str) -> str: Returns the longest palindrome that can be formed by rearranging the characters of the input string. If no palindrome can be formed, returns an empty string. >>> longest_palindrome(\\"abba\\") 'abba' >>> longest_palindrome(\\"abc\\") in ['a', 'b', 'c'] >>> longest_palindrome(\\"abbccc\\") in ['bcccb', 'ccc'] >>> longest_palindrome(\\"a\\") 'a' >>> longest_palindrome(\\"\\") '' >>> longest_palindrome(\\"a\\" * 500 + \\"b\\" * 500) 'aaaa...bbb...aaaa'","solution":"from collections import Counter def longest_palindrome(s): Returns the longest palindrome that can be formed by rearranging the characters of the input string. If no palindrome can be formed, returns an empty string. count = Counter(s) odd_char = \\"\\" half_palindrome = [] for char, freq in count.items(): if freq % 2 == 1: if not odd_char or freq > count[odd_char]: odd_char = char half_palindrome.append(char * (freq // 2)) half_palindrome = ''.join(sorted(half_palindrome)) return half_palindrome + odd_char + half_palindrome[::-1]"},{"question":"def max_min_abs_difference(n: int, toxicity_levels: List[int]) -> int: Find the maximum possible minimum absolute difference in the toxicity levels for any unique pair of solutions. >>> max_min_abs_difference(4, [1, 9, 5, 11]) 2 >>> max_min_abs_difference(3, [4, 4, 4]) 0","solution":"def max_min_abs_difference(n, toxicity_levels): # Sort the array to make finding differences easier toxicity_levels.sort() # Initialize min_diff with a large number min_diff = float('inf') # Iterate through the sorted array and find the minimum difference for i in range(1, n): min_diff = min(min_diff, abs(toxicity_levels[i] - toxicity_levels[i - 1])) return min_diff"},{"question":"def longest_unique_substring(s: str) -> str: Returns the longest substring of s without repeating characters. If there are multiple substrings of the same length, the first one encountered is returned. >>> longest_unique_substring(\\"abcabcbb\\") == \\"abc\\" >>> longest_unique_substring(\\"bbbbb\\") == \\"b\\" >>> longest_unique_substring(\\"pwwkew\\") == \\"wke\\" >>> longest_unique_substring(\\"aab\\") == \\"ab\\" >>> longest_unique_substring(\\"\\") == \\"\\" >>> longest_unique_substring(\\"dvdf\\") == \\"vdf\\" >>> longest_unique_substring(\\"anviaj\\") == \\"nviaj\\" >>> longest_unique_substring(\\"aAaA\\") == \\"aA\\" >>> longest_unique_substring(\\"abcdef\\") == \\"abcdef\\" >>> longest_unique_substring(\\"AaBbCc\\") == \\"AaBbCc\\" >>> longest_unique_substring(\\"1234567890\\") == \\"1234567890\\"","solution":"def longest_unique_substring(s: str) -> str: Returns the longest substring of s without repeating characters. If there are multiple substrings of the same length, the first one encountered is returned. n = len(s) longest_substr = \\"\\" char_map = {} start = 0 for end in range(n): if s[end] in char_map: start = max(start, char_map[s[end]] + 1) char_map[s[end]] = end if end - start + 1 > len(longest_substr): longest_substr = s[start:end + 1] return longest_substr"},{"question":"def schedule_tournament(n: int): Schedules a sports tournament with n players where no pair plays more than once. Each player plays in every round. Args: n: int - Number of players (2 ≤ n ≤ 100) Returns: - If possible, return \\"YES\\" followed by the tournament schedule with n/2 lines. Each line contains n/2 pairs of integers. - If not possible, return \\"NO\\". >>> schedule_tournament(4) \\"YESn1 4 2 3n1 3 4 2n1 2 3 4\\" >>> schedule_tournament(6) \\"YESn1 6 2 5 3 4n1 5 6 4 2 3n1 4 5 3 6 2n1 3 4 2 5 6n1 2 3 6 4 5\\" >>> schedule_tournament(3) \\"NO\\" >>> schedule_tournament(2) \\"YESn1 2\\" def format_schedule_tournament(n: int): Formats the output of the schedule_tournament function to match the required output format. Args: n: int - Number of players (2 ≤ n ≤ 100) Returns: - Formatted string of the tournament schedule","solution":"def schedule_tournament(n): if n % 2 != 0 or n < 2 or n > 100: return (\\"NO\\",) rounds = [] players = list(range(1, n + 1)) for i in range(n - 1): round_matches = [] for j in range(n // 2): player1 = players[j] player2 = players[n - 1 - j] round_matches.append((player1, player2)) rounds.append(round_matches) # Rotate the array for the next round, fixing the first element players = [players[0]] + [players[-1]] + players[1:-1] return (\\"YES\\", rounds) # Formatting the output def format_schedule_tournament(n): result = schedule_tournament(n) if result[0] == \\"NO\\": return \\"NO\\" else: output = [\\"YES\\"] for round_matches in result[1]: round_representation = \\" \\".join(f\\"{p1} {p2}\\" for p1, p2 in round_matches) output.append(round_representation) return \\"n\\".join(output)"},{"question":"def can_reorder_playlist(n: int, genres: List[int]) -> str: Determine if it's possible to reorder the playlist such that no two consecutive songs have the same genre. Parameters: n (int): The number of songs in the list. genres (List[int]): The genre of each song. Returns: str: \\"YES\\" if it's possible to reorder the playlist, otherwise \\"NO\\". >>> can_reorder_playlist(5, [1, 1, 2, 2, 3]) 'YES' >>> can_reorder_playlist(4, [1, 1, 1, 1]) 'NO'","solution":"def can_reorder_playlist(n, genres): Returns \\"YES\\" if it's possible to reorder the playlist such that no two consecutive songs have the same genre, otherwise returns \\"NO\\". from collections import Counter # Count frequencies of each genre freq = Counter(genres) # Find the maximum frequency max_freq = max(freq.values()) # If the most frequent element appears more than (n + 1) // 2 times, it's not possible if max_freq > (n + 1) // 2: return \\"NO\\" else: return \\"YES\\" # Example usage: # print(can_reorder_playlist(5, [1, 1, 2, 2, 3])) # Output: \\"YES\\" # print(can_reorder_playlist(4, [1, 1, 1, 1])) # Output: \\"NO\\""},{"question":"def smallest_non_zero_element(arr): Returns the least possible non-zero element left after performing the operations optimally. >>> smallest_non_zero_element([10, 7, 9, 5]) 1 >>> smallest_non_zero_element([4, 4, 4, 4]) 4 >>> smallest_non_zero_element([2, 2, 3, 7, 11]) 1 >>> smallest_non_zero_element([1000000, 500000, 250000, 125000]) 125000 >>> smallest_non_zero_element([8, 12]) 4 >>> smallest_non_zero_element([6, 9, 15, 25]) 1","solution":"def smallest_non_zero_element(arr): Returns the least possible non-zero element left after performing the operations optimally. from math import gcd from functools import reduce def gcd_of_list(lst): return reduce(gcd, lst) # Calculate the gcd of the entire array min_non_zero = gcd_of_list(arr) return min_non_zero"},{"question":"def trap_rain_water(heights): Calculate the amount of trapped rainwater between the buildings. Args: heights (list of int): Heights of the buildings. Returns: int: The total amount of trapped water. Examples: >>> trap_rain_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap_rain_water([4, 2, 0, 3, 2, 5]) 9 >>> trap_rain_water([2, 0, 2]) 2","solution":"def trap_rain_water(heights): Calculate the amount of trapped rainwater between the buildings. Args: heights (list of int): Heights of the buildings. Returns: int: The total amount of trapped water. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n water_trapped = 0 left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"import heapq from typing import List, Tuple def dijkstra(num_cities: int, roads: List[Tuple[int, int, int]], start: int, end: int) -> int: Calculate the shortest distance between two cities using Dijkstra's algorithm. Args: num_cities (int): Number of cities. roads (List[Tuple[int, int, int]]): List of roads, each represented as a tuple (a, b, length). start (int): Starting city. end (int): Ending city. Returns: int: The shortest distance between the start and end cities. If no path exists, return -1. Examples: >>> dijkstra(4, [(1, 2, 4), (1, 3, 2), (2, 3, 3), (3, 4, 1)], 1, 4) 3 >>> dijkstra(4, [(1, 2, 4), (1, 3, 2), (2, 3, 3)], 1, 4) -1","solution":"import heapq def dijkstra(num_cities, roads, start, end): graph = {i: [] for i in range(1, num_cities + 1)} for a, b, length in roads: graph[a].append((b, length)) graph[b].append((a, length)) pq = [(0, start)] distances = {i: float('inf') for i in range(1, num_cities + 1)} distances[start] = 0 while pq: current_distance, current_city = heapq.heappop(pq) if current_distance > distances[current_city]: continue for neighbor, length in graph[current_city]: distance = current_distance + length if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return distances[end] if distances[end] != float('inf') else -1"},{"question":"def is_balanced(s: str) -> bool: Determines if a string of brackets is balanced. >>> is_balanced(\\"([{}])\\") True >>> is_balanced(\\"([)]\\") False >>> is_balanced(\\"\\") True >>> is_balanced(\\"({[<>]})\\") True >>> is_balanced(\\"({[<>]\\") False >>> is_balanced(\\"{[}]\\") False >>> is_balanced(\\"(\\") False >>> is_balanced(\\")\\") False >>> is_balanced(\\"{[({[({[]})]})]}\\") True","solution":"def is_balanced(s): Determines if a string of brackets is balanced. stack = [] matching_bracket = {')': '(', ']': '[', '}': '{', '>': '<'} for char in s: if char in '([{<': stack.append(char) elif char in ')]}>': if not stack or stack.pop() != matching_bracket[char]: return False return not stack"},{"question":"def max_non_overlapping_meetings(meetings): Returns the maximum number of non-overlapping meetings that can be scheduled. :param meetings: List of tuples where each tuple contains start time and end time of a meeting. :return: Maximum count of non-overlapping meetings def from_input_string(input_string): lines = input_string.strip().split(\\"n\\") N = int(lines[0]) meetings = [tuple(map(int, line.split())) for line in lines[1:]] return meetings def from_output_string(output_string): return int(output_string.strip()) def to_input_string(inputs): meetings = inputs input_str = f\\"{len(meetings)}n\\" + \\"n\\".join(f\\"{start} {end}\\" for start, end in meetings) return input_str def to_output_string(output): return str(output) import pytest from solution import max_non_overlapping_meetings, from_input_string, from_output_string, to_input_string, to_output_string def test_sample_case(): input_str = \\"6n1 4n2 3n3 5n7 8n5 6n4 7n\\" expected_output_str = \\"4\\" inputs = from_input_string(input_str) expected_output = from_output_string(expected_output_str) assert max_non_overlapping_meetings(inputs) == expected_output def test_min_case(): assert max_non_overlapping_meetings([(0, 1)]) == 1 def test_non_overlapping_meetings(): assert max_non_overlapping_meetings([(1, 2), (3, 4), (5, 6)]) == 3 def test_overlapping_meetings(): assert max_non_overlapping_meetings([(1, 3), (2, 4), (3, 5)]) == 2 def test_single_overlap_meetings(): assert max_non_overlapping_meetings([(1, 3), (3, 4)]) == 2 assert max_non_overlapping_meetings([(1, 2), (2, 4), (4, 6)]) == 3 def test_complex_case(): input_str = \\"3n2 4n1 3n3 5n\\" expected_output_str = \\"2\\" inputs = from_input_string(input_str) expected_output = from_output_string(expected_output_str) assert max_non_overlapping_meetings(inputs) == expected_output","solution":"def max_non_overlapping_meetings(meetings): Returns the maximum number of non-overlapping meetings that can be scheduled. :param meetings: List of tuples where each tuple contains start time and end time of a meeting. :return: Maximum count of non-overlapping meetings # Sort meetings based on end time sorted_meetings = sorted(meetings, key=lambda x: x[1]) count = 0 last_end_time = 0 for start, end in sorted_meetings: if start >= last_end_time: count += 1 last_end_time = end return count def from_input_string(input_string): lines = input_string.strip().split(\\"n\\") N = int(lines[0]) meetings = [tuple(map(int, line.split())) for line in lines[1:]] return meetings def from_output_string(output_string): return int(output_string.strip()) def to_input_string(inputs): meetings = inputs input_str = f\\"{len(meetings)}n\\" + \\"n\\".join(f\\"{start} {end}\\" for start, end in meetings) return input_str def to_output_string(output): return str(output)"},{"question":"def maxProfit(prices): Returns the maximum profit that can be achieved by making a single buy and sell transaction. >>> maxProfit([7, 1, 5, 3, 6, 4]) 5 >>> maxProfit([1, 2, 3, 4, 5]) 4 >>> maxProfit([5, 4, 3, 2, 1]) 0 >>> maxProfit([1]) 0 >>> maxProfit([]) 0 >>> maxProfit([3, 3, 3, 3]) 0 >>> maxProfit([2, 2, 2, 3, 3, 3, 4, 4, 4]) 2","solution":"def maxProfit(prices): Returns the maximum profit that can be achieved by making a single buy and sell transaction. if not prices or len(prices) < 2: return 0 min_price = prices[0] max_profit = 0 for price in prices[1:]: profit = price - min_price if profit > max_profit: max_profit = profit if price < min_price: min_price = price return max_profit"},{"question":"def minSwapsToFront(words: List[str], target: str) -> int: Finds the minimum number of adjacent swaps needed to move \`target\` to the beginning of the list \`words\`. Returns -1 if \`target\` is not found. >>> minSwapsToFront(['apple', 'banana', 'cherry', 'date', 'fig', 'grape'], 'date') 3 >>> minSwapsToFront(['lemon', 'orange', 'pear', 'watermelon'], 'grapefruit') -1","solution":"def minSwapsToFront(words, target): Finds the minimum number of adjacent swaps needed to move \`target\` to the beginning of the list \`words\`. Returns -1 if \`target\` is not found. try: # Find the index of the target in the list target_index = words.index(target) except ValueError: # If target is not found, return -1 return -1 # The number of swaps needed to move the target to the front return target_index"},{"question":"def has_contiguous_subarray_with_sum(arr: List[int], target: int) -> bool: Determine if there is a contiguous subarray within the given array that sums up to the target integer. >>> has_contiguous_subarray_with_sum([1, 2, 3, 7, 5], 12) True >>> has_contiguous_subarray_with_sum([-1, 4, 2, -2, 5], 7) False","solution":"def has_contiguous_subarray_with_sum(arr, target): Determine if there is a contiguous subarray within the given array that sums up to the target integer. if not arr: return False current_sum = 0 sum_set = {0} for num in arr: current_sum += num if current_sum - target in sum_set: return True sum_set.add(current_sum) return False"},{"question":"def max_nested_depth(s: str) -> int: Determines the deepest level of nested parentheses in the input string. Parameters: s (str): The input string containing parentheses. Returns: int: The maximum depth of nested parentheses if properly nested, otherwise -1. Examples: >>> max_nested_depth(\\"(())\\") 2 >>> max_nested_depth(\\"(()(()))\\") 3 >>> max_nested_depth(\\")(\\") -1 >>> max_nested_depth(\\"(()\\") -1 >>> max_nested_depth(\\"()\\") 1 >>> max_nested_depth(\\"\\") 0","solution":"def max_nested_depth(s): Determines the deepest level of nested parentheses in the input string. Parameters: s (str): The input string containing parentheses. Returns: int: The maximum depth of nested parentheses if properly nested, otherwise -1. max_depth = 0 current_depth = 0 for char in s: if char == \\"(\\": current_depth += 1 if current_depth > max_depth: max_depth = current_depth elif char == \\")\\": if current_depth == 0: return -1 # Unmatched closing parenthesis current_depth -= 1 if current_depth != 0: return -1 # Unmatched opening parenthesis return max_depth"},{"question":"from typing import List, Tuple def max_non_overlapping_items(items: List[Tuple[int, int]]) -> int: Determine the maximum number of items that can be scheduled for the exhibit without any overlap in their display periods. Args: items (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers representing the start and end date of an item. Returns: int: The maximum number of non-overlapping items. Examples: >>> max_non_overlapping_items([(1, 4), (2, 3), (3, 5)]) 2 >>> max_non_overlapping_items([(0, 2), (3, 4), (5, 6), (7, 8)]) 4","solution":"def max_non_overlapping_items(items): # Sort the items by their end date items.sort(key=lambda x: x[1]) max_items = 0 current_end = -1 for start, end in items: if start >= current_end: max_items += 1 current_end = end return max_items"},{"question":"def frequency_sort(S: str) -> str: Returns the characters of the string S sorted by frequency and then alphabetically within the same frequency. >>> frequency_sort(\\"bbaa\\") == \\"ab\\" >>> frequency_sort(\\"abcabc\\") == \\"abc\\" >>> frequency_sort(\\"zzyyxx\\") == \\"xyz\\" >>> frequency_sort(\\"zzzbbbccc\\") == \\"bcz\\" pass def process_test_cases(T: int, test_cases: List[str]) -> List[str]: Process and return results for multiple test cases. >>> process_test_cases(2, [\\"bbaa\\", \\"abcabc\\"]) == [\\"ab\\", \\"abc\\"] >>> process_test_cases(2, [\\"zzyyxx\\", \\"zzzbbbccc\\"]) == [\\"xyz\\", \\"bcz\\"] >>> process_test_cases(5, [\\"a\\", \\"bb\\", \\"ccc\\", \\"ddddd\\", \\"eeeee\\"]) == [\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\"] pass","solution":"def frequency_sort(S): Returns the characters of the string S sorted by frequency and then alphabetically within the same frequency. from collections import Counter # Count frequencies of each character in S freq_counter = Counter(S) # Generate a sorted list of characters based on frequency and alphabetically within the same frequency sorted_chars = sorted(freq_counter.keys(), key=lambda x: (-freq_counter[x], x)) return ''.join(sorted_chars) def process_test_cases(T, test_cases): Process and return results for multiple test cases. results = [] for S in test_cases: results.append(frequency_sort(S)) return results"},{"question":"def find_missing_code(codes): Returns the smallest missing code greater than 0 from the list of codes. >>> find_missing_code([3, 4, 7, 1]) 2 >>> find_missing_code([1, 2, 3, 5]) 4 >>> find_missing_code([5, 6, 7, 8]) 1 >>> find_missing_code([]) 1 >>> find_missing_code([1]) 2 >>> find_missing_code([10]) 1 >>> find_missing_code([100, 200, 300]) 1 >>> find_missing_code([-1, -2, -3, 1, 3]) 2 >>> find_missing_code([1, 2, 2, 3, 5, 3]) 4 >>> find_missing_code([10, 20, 30, 50]) 1","solution":"def find_missing_code(codes): Returns the smallest missing code greater than 0 from the list of codes. sorted_codes = sorted(set(codes)) expected_code = 1 for code in sorted_codes: if code == expected_code: expected_code += 1 elif code > expected_code: break return expected_code"},{"question":"def count_odd_sum_subarrays(T, test_cases): Count the number of subarrays with an odd sum for each test case. :param T: Integer, number of test cases :param test_cases: List of tuples, where each tuple contains a positive integer N (number of elements in the array) and a list of N integers (the elements of the array) :return: List of integers, where each integer is the count of subarrays with an odd sum for a corresponding test case >>> count_odd_sum_subarrays(2, [(3, [1, 2, 3]), (4, [1, 2, 3, 4])]) [4, 6] >>> count_odd_sum_subarrays(1, [(2, [2, 4])]) [0]","solution":"def count_odd_sum_subarrays(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] array = test_cases[i][1] odd = 0 even = 1 # to account for the prefix sum of 0 which is even prefix_sum = 0 count = 0 for num in array: prefix_sum += num if prefix_sum % 2 == 0: count += odd even += 1 else: count += even odd += 1 results.append(count) return results"},{"question":"def minCostToPalindrome(S: str) -> int: Returns the minimum cost to make the string S a palindrome. You are given a string \`S\` consisting only of lowercase alphabets. Your task is to determine the minimum cost to make the string a valid palindrome. A string is said to be a valid palindrome if it reads the same backward as forward. You are allowed to perform two types of operations: 1. Insert any character at any position in the string with a cost of 1. 2. Remove any character from the string with a cost of 1. >>> minCostToPalindrome(\\"abca\\") 1 >>> minCostToPalindrome(\\"race\\") 3","solution":"def minCostToPalindrome(S): Returns the minimum cost to make the string S a palindrome. n = len(S) if n == 0: return 0 # Create a 2D DP array dp = [[0] * n for _ in range(n)] # Fill the DP array for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 if S[i] == S[j]: dp[i][j] = dp[i + 1][j - 1] else: dp[i][j] = 1 + min(dp[i + 1][j], dp[i][j - 1]) return dp[0][n - 1]"},{"question":"def find_largest_sum(grid): Finds the greatest sum of any contiguous subgrid within the given grid. Uses dynamic programming approach similar to Kadane's algorithm for 2D arrays. >>> grid = [ ... [1, 2, -1, -4, -20], ... [-8, -3, 4, 2, 1], ... [3, 8, 10, 1, 3], ... [-4, -1, 1, 7, -6] ... ] >>> find_largest_sum(grid) 29 def test_find_largest_sum_basic(): grid = [ [1, 2, -1, -4, -20], [-8, -3, 4, 2, 1], [3, 8, 10, 1, 3], [-4, -1, 1, 7, -6] ] assert find_largest_sum(grid) == 29 def test_find_largest_sum_single_element(): grid = [ [1] ] assert find_largest_sum(grid) == 1 def test_find_largest_sum_all_negative(): grid = [ [-1, -2], [-3, -4] ] assert find_largest_sum(grid) == -1 def test_find_largest_sum_mixed(): grid = [ [0, -2, -7, 0], [9, 2, -6, 2], [-4, 1, -4, 1], [-1, 8, 0, -2] ] assert find_largest_sum(grid) == 15 def test_find_largest_sum_large(): grid = [ [1, -3, 4, 5], [-2, 3, 6, -4], [2, -1, 5, -6], [-3, 2, -1, 4] ] assert find_largest_sum(grid) == 15","solution":"def find_largest_sum(grid): Finds the greatest sum of any contiguous subgrid within the given grid. Uses dynamic programming approach similar to Kadane's algorithm for 2D arrays. if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) max_sum = float('-inf') for left in range(cols): temp = [0] * rows for right in range(left, cols): for i in range(rows): temp[i] += grid[i][right] current_sum = kadane(temp) max_sum = max(max_sum, current_sum) return max_sum def kadane(array): Helper function to perform Kadane's algorithm on a 1D array. Finds the maximum sum of any contiguous subarray within the array. max_sum = current_subarray_sum = array[0] for num in array[1:]: current_subarray_sum = max(num, current_subarray_sum + num) max_sum = max(max_sum, current_subarray_sum) return max_sum"},{"question":"def max_submatrix_sum(matrix: List[List[int]]) -> int: Returns the maximum sum of any submatrix within the given matrix. A submatrix is defined as any contiguous rectangular part of the given matrix. >>> matrix = [ ... [1, 2, -1, -4, -20], ... [-8, -3, 4, 2, 1], ... [3, 8, 10, 1, 3], ... [-4, -1, 1, 7, -6] ... ] >>> max_submatrix_sum(matrix) 29 >>> max_submatrix_sum([[5]]) 5 >>> matrix = [ ... [-1, -2], ... [-3, -4] ... ] >>> max_submatrix_sum(matrix) -1","solution":"def max_submatrix_sum(matrix): Returns the maximum sum of any submatrix within the given matrix. Uses an extension of Kadane's algorithm to 2D arrays. n = len(matrix) m = len(matrix[0]) max_sum = float('-inf') # For each pair of rows, apply Kadane's algorithm on the columns for start_row in range(n): # This will accumulate column sums between the start_row and end_row col_sums = [0] * m for end_row in range(start_row, n): # Calculate the sum of elements in each column between start_row and end_row for col in range(m): col_sums[col] += matrix[end_row][col] # Now find the maximum sum subarray in col_sums using Kadane's algorithm current_max = float('-inf') current_sum = 0 for x in col_sums: current_sum += x if current_sum > current_max: current_max = current_sum if current_sum < 0: current_sum = 0 # Update the maximum submatrix sum found so far if current_max > max_sum: max_sum = current_max return max_sum"},{"question":"def is_permutation(str1: str, str2: str) -> bool: Determines if one string is a permutation of the other. Ignores case sensitivity and non-alphabetic characters. >>> is_permutation(\\"listen\\", \\"silent\\") True >>> is_permutation(\\"triangle\\", \\"integral\\") True >>> is_permutation(\\"apple\\", \\"pale\\") False >>> is_permutation(\\"Astronomer\\", \\"Moon starer\\") True >>> is_permutation(\\" \\", \\" \\") True >>> is_permutation(\\"ABCDE\\", \\"edcba\\") True >>> is_permutation(\\"hello\\", \\"billion\\") False >>> is_permutation(\\"Dormitory\\", \\"Dirty room!\\") True","solution":"def is_permutation(str1: str, str2: str) -> bool: Determines if one string is a permutation of the other. Ignores case sensitivity and non-alphabetic characters. from collections import Counter import re # Remove non-alphabetic characters and convert to lowercase filtered_str1 = re.sub(r'[^a-z]', '', str1.lower()) filtered_str2 = re.sub(r'[^a-z]', '', str2.lower()) # Count character frequencies and compare return Counter(filtered_str1) == Counter(filtered_str2)"},{"question":"def climb_stairs(n: int) -> int: Calculate the number of possible ways to climb a staircase of n steps, given that you can only take 1, 2, or 3 steps at a time. :param n: Number of steps in the staircase :return: Total number of possible ways to reach the top of the staircase >>> climb_stairs(0) == 1 >>> climb_stairs(1) == 1 >>> climb_stairs(2) == 2 >>> climb_stairs(3) == 4 >>> climb_stairs(4) == 7 >>> climb_stairs(5) == 13 >>> climb_stairs(6) == 24 >>> climb_stairs(10) == 274","solution":"def climb_stairs(n: int) -> int: Calculate the number of possible ways to climb a staircase of n steps, given that you can only take 1, 2, or 3 steps at a time. :param n: Number of steps in the staircase :return: Total number of possible ways to reach the top of the staircase if n == 0: return 1 elif n == 1: return 1 elif n == 2: return 2 elif n == 3: return 4 ways = [0] * (n + 1) ways[0] = 1 ways[1] = 1 ways[2] = 2 ways[3] = 4 for i in range(4, n + 1): ways[i] = ways[i - 1] + ways[i - 2] + ways[i - 3] return ways[n]"},{"question":"def repeat_values(lst: List[int]) -> List[int]: Returns a new list where each integer is repeated as many times as its value. Only processes the first occurrence of each integer. >>> repeat_values([1, 3, 2, 4, 2, 3]) == [1, 3, 3, 3, 2, 2, 4, 4, 4, 4] >>> repeat_values([1, 3, 2, 3, 1, 2]) == [1, 3, 3, 3, 2, 2] >>> repeat_values([4, 5, 6]) == [4, 4, 4, 4, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6] >>> repeat_values([]) == [] >>> repeat_values([0, 1, 2, 0, 1]) == [1, 2, 2] >>> repeat_values([3]) == [3, 3, 3] >>> repeat_values([0]) == [] >>> repeat_values([-1, -2]) == []","solution":"def repeat_values(lst): Returns a new list where each integer is repeated as many times as its value. Only processes the first occurrence of each integer. seen = set() result = [] for num in lst: if num not in seen: result.extend([num] * num) seen.add(num) return result"},{"question":"def calculate_average_feedback(responses): Calculate the average feedback score and round to 2 decimal places. :param responses: List of integers representing feedback scores :return: Float representing the average score rounded to 2 decimal places >>> calculate_average_feedback([4, 5, 3, 2, 5]) 3.80 >>> calculate_average_feedback([5, 5, 5, 5, 5]) 5.00 >>> calculate_average_feedback([1, 1, 1, 1, 1]) 1.00 >>> calculate_average_feedback([2, 3, 4]) 3.00 >>> calculate_average_feedback([3]) 3.00 >>> calculate_average_feedback([1, 2, 3, 4, 5]) 3.00 >>> calculate_average_feedback([]) 0.0","solution":"def calculate_average_feedback(responses): Calculate the average feedback score and round to 2 decimal places. :param responses: List of integers representing feedback scores :return: Float representing the average score rounded to 2 decimal places if not responses: return 0.0 average_score = sum(responses) / len(responses) return round(average_score, 2)"},{"question":"def find_abs_difference(arr, queries): For each query, find the minimum and maximum values in the subarray and return their absolute difference. >>> find_abs_difference([1, 5, 2, 4, 6, 3, 7], [(1, 3), (4, 7), (2, 5)]) [4, 4, 4] >>> find_abs_difference([10, 20, 30], [(1, 1), (2, 2), (3, 3)]) [0, 0, 0] >>> find_abs_difference([3, 9, 1, 7, 2], [(1, 5)]) [8] >>> find_abs_difference([7, 2, 5], [(1, 2), (2, 3)]) [5, 3] >>> find_abs_difference([4, 4, 4, 4], [(1, 4), (2, 3)]) [0, 0]","solution":"def find_abs_difference(arr, queries): For each query, find the minimum and maximum values in the subarray and return their absolute difference. results = [] for l, r in queries: subarray = arr[l-1:r] min_val = min(subarray) max_val = max(subarray) abs_difference = abs(max_val - min_val) results.append(abs_difference) return results"},{"question":"def reverseEveryOther(sentence: str) -> str: Reverses every other word in the given sentence. :param sentence: A string of words separated by spaces. :return: A modified sentence with every other word reversed. >>> reverseEveryOther(\\"Hello world this is a test\\") \\"Hello dlrow this si a tset\\" >>> reverseEveryOther(\\"Coding is fun\\") \\"Coding si fun\\" >>> reverseEveryOther(\\"I love programming\\") \\"I evol programming\\" >>> reverseEveryOther(\\"\\") \\"\\" >>> reverseEveryOther(\\"A B C D E F\\") \\"A B C D E F\\" >>> reverseEveryOther(\\"To be or not to be\\") \\"To eb or ton to eb\\" >>> reverseEveryOther(\\"single\\") \\"single\\" >>> reverseEveryOther(\\"two words\\") \\"two sdrow\\"","solution":"def reverseEveryOther(sentence): Reverses every other word in the given sentence. :param sentence: A string of words separated by spaces. :return: A modified sentence with every other word reversed. words = sentence.split() for i in range(len(words)): if i % 2 == 1: words[i] = words[i][::-1] return ' '.join(words)"},{"question":"def are_stations_connected(T, test_cases): Given number of test cases, number of space stations, number of tunnels and tunnel connections, determines whether all stations are connected through the given tunnels. Args: T: int - Number of test cases test_cases: list - List of tuples. Each tuple contains: - N: int - Number of space stations - M: int - Number of tunnels - edges: list of tuples - Each tuple contains (u, v) representing a direct tunnel between stations u and v Returns: List of strings: \\"CONNECTED\\" if all stations are accessible from each other, otherwise \\"DISCONNECTED\\" Example: >>> are_stations_connected(2, [ ... (4, 3, [(0, 1), (1, 2), (2, 3)]), ... (5, 3, [(0, 1), (1, 2), (3, 4)]) ... ]) [\\"CONNECTED\\", \\"DISCONNECTED\\"]","solution":"def are_stations_connected(T, test_cases): def dfs(node, visited, adj_list): stack = [node] while stack: current = stack.pop() if not visited[current]: visited[current] = True for neighbor in adj_list[current]: if not visited[neighbor]: stack.append(neighbor) results = [] for case in test_cases: N, M, edges = case adj_list = [[] for _ in range(N)] for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) visited = [False] * N dfs(0, visited, adj_list) if all(visited): results.append(\\"CONNECTED\\") else: results.append(\\"DISCONNECTED\\") return results"},{"question":"def robovac_path(w, h, n, obstacles): Given the dimensions of the room, the number of obstacles and their positions, this function returns the path taken by the RoboVac. Args: w (int): Width of the room. h (int): Height of the room. n (int): Number of obstacles. obstacles (list of tuples): List containing the coordinates of the obstacles. Returns: list of tuples: A list containing the coordinates of the positions visited by RoboVac. >>> robovac_path(5, 5, 1, [(2, 2)]) [(0, 0), (5, 0), (5, 5), (2, 5), (2, 2), (0, 2), (0, 0)] >>> robovac_path(3, 3, 2, [(1, 1), (2, 1)]) [(0, 0), (3, 0), (3, 2), (2, 2), (2, 3), (0, 3), (0, 0)]","solution":"def robovac_path(w, h, n, obstacles): Given the dimensions of the room, the number of obstacles and their positions, this function returns the path taken by the RoboVac. Args: w (int): Width of the room. h (int): Height of the room. n (int): Number of obstacles. obstacles (list of tuples): List containing the coordinates of the obstacles. Returns: list of tuples: A list containing the coordinates of the positions visited by RoboVac. # Define the initial position and direction x, y = 0, 0 direction = \\"RIGHT\\" visited_positions = [(x, y)] # Set of visited positions and set of obstacle coordinates for quick lookup obstacle_set = set(obstacles) while True: if direction == \\"RIGHT\\": while x < w and (x + 1, y) not in obstacle_set: x += 1 visited_positions.append((x, y)) direction = \\"UP\\" elif direction == \\"UP\\": while y < h and (x, y + 1) not in obstacle_set: y += 1 visited_positions.append((x, y)) direction = \\"LEFT\\" elif direction == \\"LEFT\\": while x > 0 and (x - 1, y) not in obstacle_set: x -= 1 visited_positions.append((x, y)) direction = \\"DOWN\\" elif direction == \\"DOWN\\": while y > 0 and (x, y - 1) not in obstacle_set: y -= 1 visited_positions.append((x, y)) direction = \\"RIGHT\\" # If RoboVac returns to the starting position, break the loop if (x, y) == (0, 0): break return visited_positions # Support function to print the path in the required format def print_robovac_path(w, h, obstacles): steps = robovac_path(w, h, len(obstacles), obstacles) for step in steps: print(f\\"({step[0]}, {step[1]})\\")"},{"question":"from typing import List def largest_anagram_group(words: List[str]) -> List[str]: Identify the largest group of anagrams from a list of words and return it. Args: words (List[str]): A list of words to analyze. Returns: List[str]: The largest group of anagrams. Examples: >>> largest_anagram_group([\\"listen\\", \\"silent\\", \\"enlist\\", \\"google\\", \\"gooegl\\", \\"inlets\\", \\"banana\\"]) [\\"listen\\", \\"silent\\", \\"enlist\\", \\"inlets\\"] >>> largest_anagram_group([\\"cat\\", \\"dog\\", \\"tac\\", \\"god\\", \\"act\\"]) [\\"cat\\", \\"tac\\", \\"act\\"] # Your code here def test_largest_anagram_group(): words = [\\"listen\\", \\"silent\\", \\"enlist\\", \\"google\\", \\"gooegl\\", \\"inlets\\", \\"banana\\"] expected = [\\"listen\\", \\"silent\\", \\"enlist\\", \\"inlets\\"] result = largest_anagram_group(words) assert sorted(result) == sorted(expected) def test_largest_anagram_group_tie(): words = [\\"listen\\", \\"silent\\", \\"enlist\\", \\"google\\", \\"gooegl\\", \\"inlets\\", \\"banana\\", \\"angel\\", \\"glean\\", \\"angle\\"] expected_1 = [\\"listen\\", \\"silent\\", \\"enlist\\", \\"inlets\\"] expected_2 = [\\"angel\\", \\"glean\\", \\"angle\\"] result = largest_anagram_group(words) assert sorted(result) == sorted(expected_1) or sorted(result) == sorted(expected_2) def test_largest_anagram_group_single_element(): words = [\\"apple\\"] expected = [\\"apple\\"] result = largest_anagram_group(words) assert result == expected def test_largest_anagram_group_no_anagrams(): words = [\\"cat\\", \\"dog\\", \\"fish\\"] expected = [\\"cat\\"] # Any single word may be returned as there are no anagrams result = largest_anagram_group(words) assert result in [[\\"cat\\"], [\\"dog\\"], [\\"fish\\"]] def test_largest_anagram_group_empty_list(): words = [] expected = [] result = largest_anagram_group(words) assert result == expected def test_largest_anagram_group_all_same_word(): words = [\\"star\\", \\"star\\", \\"star\\"] expected = [\\"star\\", \\"star\\", \\"star\\"] result = largest_anagram_group(words) assert result == expected","solution":"from collections import defaultdict from typing import List def largest_anagram_group(words: List[str]) -> List[str]: Returns the largest group of anagram strings from the given list. anagrams = defaultdict(list) for word in words: sorted_word = ''.join(sorted(word)) anagrams[sorted_word].append(word) # Find the largest group of anagrams largest_group = [] for group in anagrams.values(): if len(group) > len(largest_group): largest_group = group return largest_group"},{"question":"def minimize_highway_cost(n: int, m: int, coordinates: List[int]) -> int: Minimize the total cost of building the highways. Args: n (int): the number of cities m (int): the number of highways coordinates (List[int]): the coordinates of the cities in non-decreasing order Returns: int: the minimum total cost of building the highways >>> minimize_highway_cost(4, 2, [1, 3, 5, 7]) 4 >>> minimize_highway_cost(5, 3, [1, 2, 3, 4, 5]) 2","solution":"def minimize_highway_cost(n, m, coordinates): # Sort the coordinates to ensure they are in non-decreasing order coordinates.sort() # Calculate the segment lengths segment_lengths = [coordinates[i+1] - coordinates[i] for i in range(n-1)] # Sort segment lengths in non-decreasing order segment_lengths.sort() # The minimum total cost is the sum of the (n-m) smallest segment lengths return sum(segment_lengths[:n-m])"},{"question":"def largest_lexicographical_string(test_cases: List[Tuple[str, int]]) -> List[str]: Determine the largest possible lexicographical string that can be obtained by removing exactly 'k' characters from the given string 'S' for each test case. >>> largest_lexicographical_string([(\\"abcdefg\\", 2)]) [\\"cdefg\\"] >>> largest_lexicographical_string([(\\"bca\\", 1)]) [\\"ca\\"] >>> largest_lexicographical_string([(\\"mnop\\", 3)]) [\\"p\\"] >>> largest_lexicographical_string([(\\"abc\\", 0)]) [\\"abc\\"] >>> largest_lexicographical_string([(\\"zyxwvutsrqponm\\", 5)]) [\\"zyxwvutsr\\"] >>> largest_lexicographical_string([ (\\"abcdefg\\", 2), (\\"bca\\", 1), (\\"mnop\\", 3) ]) [\\"cdefg\\", \\"ca\\", \\"p\\"] >>> largest_lexicographical_string([ (\\"abcde\\", 0), (\\"zxcvb\\", 0) ]) [\\"abcde\\", \\"zxcvb\\"] pass","solution":"def largest_lexicographical_string(test_cases): results = [] for case in test_cases: S, k = case stack = [] to_remove = k for char in S: while stack and to_remove > 0 and stack[-1] < char: stack.pop() to_remove -= 1 stack.append(char) results.append(''.join(stack[:-to_remove] if to_remove else stack)) return results"},{"question":"def min_operations_to_equalize(arr): Returns the minimum number of operations required to make all elements of the array equal. >>> min_operations_to_equalize([3, 7, 2, 5]) 5 >>> min_operations_to_equalize([4, 4, 4]) 0 >>> min_operations_to_equalize([1, 2, 3, 4, 5]) 4 >>> min_operations_to_equalize([42]) 0 >>> min_operations_to_equalize([2, 8]) 6 >>> min_operations_to_equalize([7, 7]) 0 >>> min_operations_to_equalize([1000000, 1000000, 1000000, 1000000]) 0 >>> min_operations_to_equalize([1, 1000000]) 999999","solution":"def min_operations_to_equalize(arr): Returns the minimum number of operations required to make all elements of the array equal. max_val = max(arr) min_val = min(arr) if max_val == min_val: return 0 return max_val - min_val"},{"question":"def has_pair_with_sum(arr: List[int], target: int) -> bool: Checks if there are two numbers in a list that add up to the target sum. If the list is empty or contains less than two elements, the function returns False. Args: arr (List[int]): The list of integers. target (int): The target sum. Returns: bool: True if there are two numbers in the list that add up to target, False otherwise. >>> has_pair_with_sum([1, 2, 3, 4], 5) True >>> has_pair_with_sum([10, 15, 3, 7], 17) True >>> has_pair_with_sum([-1, 2, 5, -3, 7], 4) True >>> has_pair_with_sum([1, 2, 3, 4], 8) False >>> has_pair_with_sum([10, 15, 3, 7], 11) False >>> has_pair_with_sum([-1, 2, 5, -3, 7], 10) False >>> has_pair_with_sum([1], 2) False >>> has_pair_with_sum([], 5) False >>> has_pair_with_sum([3, 3, 3, 3], 6) True >>> has_pair_with_sum([1000000, 500000, -1500000, 2000000], 500000) True","solution":"def has_pair_with_sum(arr, target): Checks if there are two numbers in \`arr\` that add up to \`target\`. Args: arr (list of int): The list of integers. target (int): The target sum. Returns: bool: True if there are two numbers in the list that add up to target, False otherwise. if len(arr) < 2: return False seen_numbers = set() for num in arr: complementary = target - num if complementary in seen_numbers: return True seen_numbers.add(num) return False"},{"question":"def first_missing_positive(nums: List[int]) -> int: Write a function that takes a list of integers as input and returns the smallest positive integer that is missing from the list. The solution should run in O(n) time. >>> first_missing_positive([1, 3, 6, 4, 1, 2]) 5 >>> first_missing_positive([1, 2, 3]) 4 >>> first_missing_positive([-1, -3]) 1","solution":"def first_missing_positive(nums): Returns the smallest positive integer that is missing from the list. This solution runs in O(n) time. n = len(nums) # Step 1: Replace non-positive numbers and numbers greater than n with n+1 for i in range(n): if nums[i] <= 0 or nums[i] > n: nums[i] = n + 1 # Step 2: Use the index as a hash key and mark the corresponding element negative for i in range(n): num = abs(nums[i]) if num <= n: nums[num - 1] = -abs(nums[num - 1]) # Step 3: The first index which has a positive number represents the missing number for i in range(n): if nums[i] > 0: return i + 1 return n + 1"},{"question":"def calculate_uptime(query_count: int, queries: List[Dict[str, Union[Tuple[int, int], List[Tuple[int, str]]]]]) -> List[int]: Calculate the total uptime of the service over the specified period in seconds, for each query. Parameters: - query_count (int): The number of queries. - queries (List[Dict[str, Union[Tuple[int, int], List[Tuple[int, str]]]]]): A list of queries where each query contains: - period (Tuple[int, int]): A tuple containing the start_time and end_time for the period to analyze. - logs (List[Tuple[int, str]]): A list of tuples, each containing: - timestamp (int): The time of the log in seconds since the Unix epoch. - status (str): Either \\"active\\" or \\"inactive\\". Returns: - List[int]: A list of integers representing the total uptime for each query in seconds.","solution":"def calculate_uptime(query_count, queries): results = [] for query in queries: start_time, end_time = query['period'] logs = query['logs'] uptime = 0 in_active_period = False last_active_time = None for timestamp, status in logs: if timestamp < start_time: if status == 'active': in_active_period = True continue if timestamp > end_time: if in_active_period: uptime += end_time - last_active_time break if in_active_period: if status == 'inactive': uptime += timestamp - last_active_time in_active_period = False else: if status == 'active': last_active_time = max(start_time, timestamp) in_active_period = True if in_active_period: uptime += end_time - last_active_time results.append(uptime) return results"},{"question":"def make_beautiful(s: str) -> int: This function takes a string s and returns the minimum number of replacements needed to convert the string into a \\"beautiful\\" string, where no two adjacent characters are the same. >>> make_beautiful(\\"aabb\\") 2 >>> make_beautiful(\\"aAaAaA\\") 0","solution":"def make_beautiful(s: str) -> int: This function takes a string s and returns the minimum number of replacements needed to convert the string into a \\"beautiful\\" string, where no two adjacent characters are the same. replacements = 0 for i in range(1, len(s)): if s[i] == s[i - 1]: replacements += 1 return replacements"},{"question":"def count_subarrays_with_sum(nums: List[int], k: int) -> int: Returns the number of subarrays with a sum equal to k. >>> count_subarrays_with_sum([1, 2, 3, 4, 5], 5) 2 >>> count_subarrays_with_sum([1, -1, 1, -1], 0) 4 >>> count_subarrays_with_sum([1, 1, 1], 2) 2 >>> count_subarrays_with_sum([1, 2, -1, -2, 3], 3) 3 >>> count_subarrays_with_sum([1], 1) 1 >>> count_subarrays_with_sum([1, 2, 1, 2], 3) 3 >>> count_subarrays_with_sum([-1, -1, 1], -1) 3 >>> count_subarrays_with_sum([0, 0, 0], 0) 6","solution":"def count_subarrays_with_sum(nums, k): Returns the number of subarrays with a sum equal to k. count = 0 current_sum = 0 sum_map = {0: 1} for num in nums: current_sum += num if current_sum - k in sum_map: count += sum_map[current_sum - k] if current_sum in sum_map: sum_map[current_sum] += 1 else: sum_map[current_sum] = 1 return count"},{"question":"def can_build_fence(trees: List[Tuple[int, int]]) -> str: Determine if a fence can be built between two trees without encountering any other tree on the same vertical or horizontal line. Args: trees (List[Tuple[int, int]]): A list of tuples where each tuple represents the x and y coordinates of a tree. Returns: str: \\"YES\\" if a fence can be built, otherwise \\"NO\\". >>> can_build_fence([(1, 2), (3, 4), (5, 6), (7, 8)]) \\"YES\\" >>> can_build_fence([(1, 2), (3, 4), (1, 6), (5, 8)]) \\"NO\\" >>> can_build_fence([(1, 2), (3, 2), (5, 6), (7, 8)]) \\"NO\\" >>> can_build_fence([(1, 2)]) \\"YES\\" >>> can_build_fence([(1, 2), (3, 4)]) \\"YES\\"","solution":"def can_build_fence(trees): x_coordinates = set() y_coordinates = set() for x, y in trees: if x in x_coordinates or y in y_coordinates: return \\"NO\\" x_coordinates.add(x) y_coordinates.add(y) return \\"YES\\" # Read inputs (commented for testing purposes, usually provided via standard input) # n = int(input()) # trees = [tuple(map(int, input().split())) for _ in range(n)] # For Testing: # n = 4 # trees = [(1, 2), (3, 4), (5, 6), (7, 8)] # print(can_build_fence(trees))"},{"question":"def smallest_missing_positive_integer(arr): Finds the smallest positive integer that is not present in the array. Args: arr (list of int): The input array of integers. Returns: int: The smallest positive integer not present in the array. Examples: >>> smallest_missing_positive_integer([1, 3, 6, 4, 1, 2]) 5 >>> smallest_missing_positive_integer([-1, -3, -2]) 1","solution":"def smallest_missing_positive_integer(arr): Finds the smallest positive integer that is not present in the array. Parameters: arr (list of int): The input array of integers. Returns: int: The smallest positive integer not present in the array. n = len(arr) present = [False] * (n + 1) # Mark present numbers for num in arr: if 1 <= num <= n: present[num] = True # Find the first missing number for i in range(1, n + 1): if not present[i]: return i return n + 1"},{"question":"def max_subarray_sum(arr): Returns the largest sum of a contiguous subarray. The subarray should contain at least one number. If the array is empty, return None. >>> max_subarray_sum([1, 2, 3, 4]) == 10 >>> max_subarray_sum([-1, -2, -3, -4]) == -1 >>> max_subarray_sum([-1, 2, 3, -4, 5]) == 6 >>> max_subarray_sum([0, -2, -3, 0, -4, -1]) == 0 >>> max_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]) == 7 >>> max_subarray_sum([]) == None >>> max_subarray_sum([5]) == 5 >>> max_subarray_sum([-5]) == -5","solution":"def max_subarray_sum(arr): Returns the largest sum of a contiguous subarray. The subarray should contain at least one number. If the array is empty, return None. if not arr: return None max_sum = current_sum = arr[0] for num in arr[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def update_token_levels(n: int, initial_tokens: list[int], events: list[tuple[int, int]]) -> list[int]: Updates the token levels of players based on a series of events. Parameters: n (int): Number of players. initial_tokens (list of int): Initial tokens each player has. events (list of tuples): Each tuple contains (P, L) where player P loses L tokens. Returns: list of int: Final token levels of all players. Example: >>> update_token_levels(3, [50, 60, 70], [(1, 30), (2, 50), (3, 80), (1, 10), (2, 20)]) [10, 0, 0] >>> update_token_levels(4, [100, 200, 300, 400], []) [100, 200, 300, 400]","solution":"def update_token_levels(n, initial_tokens, events): Updates the token levels of players based on a series of events. Parameters: n (int): Number of players. initial_tokens (list of int): Initial tokens each player has. events (list of tuples): Each tuple contains (P, L) where player P loses L tokens. Returns: list of int: Final token levels of all players. tokens = initial_tokens[:] for event in events: player, loss = event tokens[player - 1] = max(0, tokens[player - 1] - loss) return tokens"},{"question":"def find_min_platforms(arrivals, departures): Returns the minimum number of platforms required for the given train schedules. >>> find_min_platforms([\\"09:00\\", \\"09:20\\", \\"09:25\\", \\"09:40\\", \\"10:00\\"], [\\"09:10\\", \\"09:30\\", \\"09:35\\", \\"09:50\\", \\"10:10\\"]) 2 >>> find_min_platforms([\\"09:00\\", \\"09:05\\", \\"09:10\\"], [\\"09:20\\", \\"09:15\\", \\"09:30\\"]) 3 >>> find_min_platforms([\\"09:00\\", \\"09:10\\", \\"09:20\\", \\"09:30\\", \\"09:40\\"], [\\"09:05\\", \\"09:15\\", \\"09:25\\", \\"09:35\\", \\"09:45\\"]) 1 >>> find_min_platforms([\\"09:00\\", \\"09:05\\", \\"10:00\\"], [\\"09:10\\", \\"09:15\\", \\"10:10\\"]) 2 >>> find_min_platforms([\\"09:00\\", \\"09:05\\", \\"09:10\\", \\"09:15\\", \\"09:20\\"], [\\"09:25\\", \\"09:30\\", \\"09:35\\", \\"09:40\\", \\"09:45\\"]) 5","solution":"def find_min_platforms(arrivals, departures): Returns the minimum number of platforms required for the given train schedules. # Convert arrival and departure times to minutes past midnight def to_minutes(time_str): hours, minutes = map(int, time_str.split(':')) return hours * 60 + minutes arrival_times = sorted([to_minutes(time) for time in arrivals]) departure_times = sorted([to_minutes(time) for time in departures]) platform_count = 0 max_platforms = 0 i = 0 j = 0 while i < len(arrival_times) and j < len(departure_times): if arrival_times[i] < departure_times[j]: platform_count += 1 max_platforms = max(max_platforms, platform_count) i += 1 else: platform_count -= 1 j += 1 return max_platforms"},{"question":"def permutations(s: str) -> list[str]: Generates all unique permutations of a given string. :param s: The input string :type s: str :return: A list of unique permutations :rtype: list pass # Unit Tests def test_empty_string(): assert permutations(\\"\\") == [\\"\\"] def test_single_character(): assert permutations(\\"a\\") == [\\"a\\"] def test_two_characters(): result = permutations(\\"ab\\") expected = [\\"ab\\", \\"ba\\"] assert sorted(result) == sorted(expected) def test_duplicate_characters(): result = permutations(\\"aab\\") expected = [\\"aab\\", \\"aba\\", \\"baa\\"] assert sorted(result) == sorted(expected) def test_three_characters(): result = permutations(\\"abc\\") expected = [\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"] assert sorted(result) == sorted(expected) def test_four_characters_with_duplicates(): result = permutations(\\"aabc\\") expected = [\\"aabc\\", \\"aacb\\", \\"abac\\", \\"abca\\", \\"acab\\", \\"acba\\", \\"baac\\", \\"baca\\", \\"bcaa\\", \\"caab\\", \\"caba\\", \\"cbaa\\"] assert sorted(result) == sorted(expected)","solution":"from itertools import permutations as itertools_permutations def permutations(s): Generates all unique permutations of a given string. :param s: The input string :type s: str :return: A list of unique permutations :rtype: list # Use itertools to generate all permutations and convert them to set to remove duplicates. if s == \\"\\": return [\\"\\"] perm_set = set(itertools_permutations(s)) return [''.join(p) for p in perm_set]"},{"question":"def longest_non_decreasing_subarray(temperatures: List[int]) -> int: Returns the length of the longest subarray where the temperature does not decrease. >>> longest_non_decreasing_subarray([1, 2, 2, 3, 1, 2, 2]) 4 >>> longest_non_decreasing_subarray([1, 2, 3, 4, 5]) 5 >>> longest_non_decreasing_subarray([5, 4, 3, 2, 1]) 1 >>> longest_non_decreasing_subarray([1, 3, 2, 3, 4, 1, 2]) 3 >>> longest_non_decreasing_subarray([10]) 1 >>> longest_non_decreasing_subarray([5, 5, 5, 5, 5]) 5 >>> longest_non_decreasing_subarray([]) 0 >>> longest_non_decreasing_subarray([1] * 100000) 100000 >>> longest_non_decreasing_subarray([i for i in range(100000)]) 100000 pass","solution":"def longest_non_decreasing_subarray(temperatures): Returns the length of the longest subarray where the temperature does not decrease. if not temperatures: return 0 max_length = 1 current_length = 1 for i in range(1, len(temperatures)): if temperatures[i] >= temperatures[i-1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 return max(max_length, current_length) # Function to handle the input and output format def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) temperatures = list(map(int, data[1:])) print(longest_non_decreasing_subarray(temperatures))"},{"question":"def is_palindrome(s: str) -> bool: Checks if the given string is a palindrome. >>> is_palindrome(\\"racecar\\") == True >>> is_palindrome(\\"hello\\") == False >>> is_palindrome(\\"level\\") == True >>> is_palindrome(\\"a\\") == True >>> is_palindrome(\\"ab\\") == False def process_input(input_list: List[str]) -> List[str]: Process a list of strings and check for each if it is a palindrome. >>> process_input([\\"racecar\\", \\"hello\\", \\"level\\", \\"end\\"]) == [\\"Yes\\", \\"No\\", \\"Yes\\"] >>> process_input([\\"noon\\", \\"civic\\", \\"deified\\", \\"end\\"]) == [\\"Yes\\", \\"Yes\\", \\"Yes\\"] >>> process_input([\\"apple\\", \\"banana\\", \\"carrot\\", \\"end\\"]) == [\\"No\\", \\"No\\", \\"No\\"] >>> process_input([\\"\\", \\"a\\", \\"ab\\", \\"end\\"]) == [\\"Yes\\", \\"Yes\\", \\"No\\"]","solution":"def is_palindrome(s): Checks if the given string is a palindrome. return s == s[::-1] def process_input(input_list): Process a list of strings and check for each if it is a palindrome. results = [] for s in input_list: if s == \\"end\\": break if is_palindrome(s): results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"from typing import List, Tuple def can_runner_reach_all_checkpoints(n: int, m: int, runners: List[Tuple[int, int]]) -> List[str]: Determines if each runner can reach all checkpoints on a circular track given their energy. >>> can_runner_reach_all_checkpoints(5, 3, [(1, 4), (3, 2), (5, 1)]) [\\"NO\\", \\"NO\\", \\"NO\\"] >>> can_runner_reach_all_checkpoints(5, 3, [(1, 4), (3, 5), (5, 10)]) [\\"NO\\", \\"YES\\", \\"YES\\"] pass def solve_race_cases(test_cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[List[str]]: Solves multiple race cases to determine if runners can complete the circular track. >>> solve_race_cases([(5, 3, [(1, 4), (3, 2), (5, 1)]), (4, 2, [(2, 0), (1, 5)])]) [[\\"NO\\", \\"NO\\", \\"NO\\"], [\\"NO\\", \\"YES\\"]] pass # Sample test cases if __name__ == \\"__main__\\": test_cases = [ (5, 3, [(1, 4), (3, 2), (5, 1)]), (4, 2, [(2, 0), (1, 5)]) ] print(solve_race_cases(test_cases))","solution":"def can_runner_reach_all_checkpoints(n, m, runners): results = [] for a, e in runners: if e >= n: results.append(\\"YES\\") else: results.append(\\"NO\\") return results def solve_race_cases(test_cases): results = [] for tc in test_cases: n, m, runners = tc results.append(can_runner_reach_all_checkpoints(n, m, runners)) return results"},{"question":"def minimum_operations(arr): Given an array of integers, determine the minimum number of operations needed so that no two adjacent integers are the same. Parameters: arr (list): List of integers representing flower types Returns: int: Minimum number of operations >>> minimum_operations([1, 2, 2, 3, 3]) 2 >>> minimum_operations([4, 4, 4, 4]) 3 >>> minimum_operations([1, 1, 1]) 2 >>> minimum_operations([1]) 0 >>> minimum_operations([1, 2, 3, 4]) 0 >>> minimum_operations([]) 0 >>> minimum_operations([1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) 9 >>> minimum_operations([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 0 >>> minimum_operations([5, 3, 5, 2, 2, 4]) 1","solution":"def minimum_operations(arr): Given an array of integers, determine the minimum number of operations needed so that no two adjacent integers are the same. Parameters: arr (list): List of integers representing flower types Returns: int: Minimum number of operations N = len(arr) if N == 0: return 0 operations = 0 for i in range(1, N): if arr[i] == arr[i - 1]: operations += 1 # Change the current element to a different value # In practical scenario, we can just mark this change, as it doesn't affect further steps in this loop return operations"},{"question":"def branch_with_lowest_income(n: int, m: int, branches: List[List[int]], queries: List[List[int]]) -> List[int]: Identify the branch with the lowest taxable income based on sector incomes and expenditures. Args: n (int): Number of branches. m (int): Number of sectors. branches (List[List[int]]): Each branch's income and expenditures for m sectors. queries (List[List[int]]): A list of queries, each query containing a number x followed by x sectors to be considered. Returns: List[int]: List of branch IDs with the lowest taxable income for each query. Example: >>> n = 3 >>> m = 3 >>> branches = [ ... [500, 100, 300, 50, 200, 80], ... [400, 200, 300, 100, 200, 150], ... [600, 200, 400, 200, 100, 70] ... ] >>> queries = [ ... [2, 0, 1], ... [3, 0, 1, 2] ... ] >>> branch_with_lowest_income(n, m, branches, queries) [2, 2]","solution":"def branch_with_lowest_income(n, m, branches, queries): results = [] for query in queries: x = query[0] sectors = query[1:] min_income = float('inf') min_branch_id = -1 for i in range(n): total_income = sum(branches[i][sector*2] - branches[i][sector*2 + 1] for sector in sectors) if total_income < min_income or (total_income == min_income and i + 1 < min_branch_id): min_income = total_income min_branch_id = i + 1 results.append(min_branch_id) return results"},{"question":"from typing import List def generate_spiral_matrix(N: int) -> List[List[int]]: Generates an N x N spiral matrix. >>> generate_spiral_matrix(3) [[1, 2, 3], [8, 9, 4], [7, 6, 5]] >>> generate_spiral_matrix(4) [[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]] pass def print_spiral_matrices(test_cases: List[int]) -> List[str]: Print spiral matrices for given test cases. >>> print_spiral_matrices([3, 4]) ['1 2 3', '8 9 4', '7 6 5', '', '1 2 3 4', '12 13 14 5', '11 16 15 6', '10 9 8 7', ''] pass","solution":"def generate_spiral_matrix(N): Generates an N x N spiral matrix. matrix = [[0] * N for _ in range(N)] val = 1 left, right = 0, N - 1 top, bottom = 0, N - 1 while left <= right and top <= bottom: # Traverse from left to right across the top row for i in range(left, right + 1): matrix[top][i] = val val += 1 top += 1 # Traverse from top to bottom down the right column for i in range(top, bottom + 1): matrix[i][right] = val val += 1 right -= 1 # Traverse from right to left across the bottom row if top <= bottom: for i in range(right, left - 1, -1): matrix[bottom][i] = val val += 1 bottom -= 1 # Traverse from bottom to top up the left column if left <= right: for i in range(bottom, top - 1, -1): matrix[i][left] = val val += 1 left += 1 return matrix def print_spiral_matrices(test_cases): results = [] for case in test_cases: N = case matrix = generate_spiral_matrix(N) for row in matrix: results.append(\\" \\".join(map(str, row))) results.append(\\"\\") # Blank line separator after each matrix return results # Sample usage: # test_cases = [3, 4] # matrices = print_spiral_matrices(test_cases) # for line in matrices: # print(line)"},{"question":"def meets_target(contributions: List[int], target: int) -> bool: Returns True if the total amount of contributions meets or exceeds the target, otherwise returns False. Args: contributions (list of int): List of contributions by each team member. target (int): The funding goal. Returns: bool: True if total contributions >= target, otherwise False. >>> meets_target([50, 100, 25, 75], 200) True >>> meets_target([50, 50, 30], 150) False >>> meets_target([10, 20, 30, 40], 100) True >>> meets_target([], 50) False >>> meets_target([20, 30, 50], 0) True >>> meets_target([200], 150) True","solution":"def meets_target(contributions, target): Returns True if the total amount of contributions meets or exceeds the target, otherwise returns False. Args: contributions (list of int): List of contributions by each team member. target (int): The funding goal. Returns: bool: True if total contributions >= target, otherwise False. total_contributions = sum(contributions) return total_contributions >= target"},{"question":"import re from typing import List def extract_integers(s: str) -> List[int]: Extracts and returns a list of integers from the given string. It only considers sequences of digits as valid integers. It handles negative integers (preceded by a \`-\` sign) correctly. It returns the integers in the order they appear in the string. If there are no integers in the string, it returns an empty list. Args: s (str): The input string. Returns: List[int]: A list of integers extracted from the string. >>> extract_integers(\\"The temperatures are -3, -5, and -7 degrees.\\") [-3, -5, -7] >>> extract_integers(\\"123 Main St.\\") [123] >>> extract_integers(\\"No numbers here!\\") []","solution":"import re def extract_integers(s): Extracts and returns a list of integers from the given string. Parameters: s (str): The input string. Returns: List[int]: A list of integers extracted from the string. pattern = r'-?d+' matches = re.findall(pattern, s) return [int(match) for match in matches]"},{"question":"from typing import List, Tuple def find_max_depth_sum(n: int, edges: List[Tuple[int, int]]) -> int: Determine the sum of the values of nodes at the maximum depth of a tree. Parameters: n (int): The number of nodes in the tree. edges (List[Tuple[int, int]]): List of edges specified as tuples where (parent, child). Returns: int: Sum of the values of nodes at the maximum depth of the tree. >>> find_max_depth_sum(5, [(1, 2), (1, 3), (2, 4), (2, 5)]) 9 >>> find_max_depth_sum(1, []) 1 >>> find_max_depth_sum(5, [(1, 2), (2, 3), (3, 4), (4, 5)]) 5 >>> find_max_depth_sum(7, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)]) 22 >>> find_max_depth_sum(3, [(1, 2), (2, 3)]) 3","solution":"def find_max_depth_sum(n, edges): from collections import deque, defaultdict # Build the tree as an adjacency list tree = defaultdict(list) for parent, child in edges: tree[parent].append(child) # BFS to find farthest nodes from the root (node 1) queue = deque([(1, 0)]) # (node, depth) max_depth = 0 depth_sums = defaultdict(int) while queue: node, depth = queue.popleft() max_depth = max(max_depth, depth) depth_sums[depth] += node for child in tree[node]: queue.append((child, depth + 1)) return depth_sums[max_depth] # Example usage # N = 5 # edges = [(1, 2), (1, 3), (2, 4), (2, 5)] # print(find_max_depth_sum(N, edges)) # Output should be 9"},{"question":"def generate_sequence(initial_number: int, length: int) -> list: Generates a sequence where each term is the sum of the digits of the previous term, starting with an initial number provided by the user and with a specified length. Parameters: initial_number (int): The starting number of the sequence. length (int): The length of the sequence. Returns: list: A list containing the generated sequence. Examples: >>> generate_sequence(12345, 3) [12345, 15, 6] >>> generate_sequence(987, 4) [987, 24, 6, 6] from solution import generate_sequence def test_generate_sequence(): assert generate_sequence(12345, 3) == [12345, 15, 6] assert generate_sequence(987, 4) == [987, 24, 6, 6] assert generate_sequence(505, 2) == [505, 10] assert generate_sequence(1, 5) == [1, 1, 1, 1, 1] assert generate_sequence(11111, 3) == [11111, 5, 5] def test_generate_sequence_single_term(): assert generate_sequence(12345, 1) == [12345] assert generate_sequence(98765, 1) == [98765] def test_generate_sequence_zero_initial(): assert generate_sequence(0, 3) == [0, 0, 0] assert generate_sequence(10, 4) == [10, 1, 1, 1]","solution":"def generate_sequence(initial_number, length): Generates a sequence where each term is the sum of the digits of the previous term. Parameters: - initial_number (int): The starting number of the sequence. - length (int): The length of the sequence. Returns: - list: A list containing the generated sequence. sequence = [initial_number] current_number = initial_number for _ in range(1, length): current_number = sum(int(digit) for digit in str(current_number)) sequence.append(current_number) return sequence"},{"question":"def find_possible_k_m_pairs(n): Given an integer n, this function returns all pairs (k, m) such that k * m = n. If no such pairs exist, it returns an empty list. >>> find_possible_k_m_pairs(12) [(1, 12), (2, 6), (3, 4), (4, 3), (6, 2), (12, 1)] >>> find_possible_k_m_pairs(15) [(1, 15), (3, 5), (5, 3), (15, 1)] >>> find_possible_k_m_pairs(1) [(1, 1)] pass def solve(t, numbers): Given a number of test cases t and a list of integers numbers, where each integer is the total number of planks, this function returns a list of lists containing all possible pairs (k, m) such that k * m = n for each integer in numbers. If no such pairs exist for a test case, it returns [-1] for that test case. >>> solve(3, [12, 15, 1]) [[(1, 12), (2, 6), (3, 4), (4, 3), (6, 2), (12, 1)], [(1, 15), (3, 5), (5, 3), (15, 1)], [(1, 1)]] pass","solution":"def find_possible_k_m_pairs(n): Given an integer n, this function returns all pairs (k, m) such that k * m = n. If no such pairs exist, it returns an empty list. pairs = [] for k in range(1, int(n**0.5) + 1): if n % k == 0: pairs.append((k, n // k)) if k != n // k: pairs.append((n // k, k)) pairs.sort() return pairs def solve(t, numbers): results = [] for n in numbers: pairs = find_possible_k_m_pairs(n) if pairs: results.append(pairs) else: results.append([-1]) return results"},{"question":"def find_pair_with_difference(arr, k): Determines if there exists a pair of elements in the array whose absolute difference is exactly K. :param arr: List of integers :param k: Integer :return: \\"YES\\" if such a pair exists, otherwise \\"NO\\" >>> find_pair_with_difference([1, 5, 3, 4, 2], 3) 'YES' >>> find_pair_with_difference([1, 2, 3, 4, 6], 6) 'NO' >>> find_pair_with_difference([1, 1000000000], 999999999) 'YES' >>> find_pair_with_difference([1, 3, 3, 6], 2) 'YES' >>> find_pair_with_difference([1], 1) 'NO'","solution":"def find_pair_with_difference(arr, k): Determines if there exists a pair of elements in the array whose absolute difference is exactly K. :param arr: List of integers :param k: Integer :return: \\"YES\\" if such a pair exists, otherwise \\"NO\\" elements = set(arr) for num in arr: if (num + k) in elements or (num - k) in elements: return \\"YES\\" return \\"NO\\""},{"question":"def rearrange_array(arr: List[int]) -> List[int]: Rearranges the array such that all negative numbers come before all non-negative numbers. The relative order among negative and non-negative numbers is preserved. Args: arr (list): List of integers which contains both negative and non-negative numbers. Returns: list: Rearranged list. >>> rearrange_array([3, -4, 2, -1, 5, 0, -6]) [-4, -1, -6, 3, 2, 5, 0] >>> rearrange_array([-1, -3, -4]) [-1, -3, -4] >>> rearrange_array([3, 2, 1, 5, 0]) [3, 2, 1, 5, 0] >>> rearrange_array([5]) [5] >>> rearrange_array([-5]) [-5] >>> rearrange_array([]) [] >>> rearrange_array([0, 0, 0]) [0, 0, 0] >>> rearrange_array([4, -3, 4, -3]) [-3, -3, 4, 4]","solution":"def rearrange_array(arr): Rearranges the array such that all negative numbers come before all non-negative numbers. The relative order among negative and non-negative numbers is preserved. Args: arr (list): List of integers which contains both negative and non-negative numbers. Returns: list: Rearranged list. negatives = [] non_negatives = [] for num in arr: if num < 0: negatives.append(num) else: non_negatives.append(num) return negatives + non_negatives"},{"question":"def count_distinct_prime_factors(N: int) -> int: Given an integer N, returns the total number of distinct prime factors of all integers from 1 to N. >>> count_distinct_prime_factors(10) 4 >>> count_distinct_prime_factors(15) 6 def solve(test_cases: List[int]) -> List[int]: Given a list of test cases where each case is an integer N, returns the total number of distinct prime factors of all integers from 1 to N for each test case. >>> solve([10, 15, 1, 2]) [4, 6, 0, 1] >>> solve([20, 50]) [8, 15]","solution":"def count_distinct_prime_factors(N): Given an integer N, returns the total number of distinct prime factors of all integers from 1 to N. sieve = [True] * (N + 1) sieve[0] = sieve[1] = False # 0 and 1 are not primes for start in range(2, int(N ** 0.5) + 1): if sieve[start]: for multiple in range(start * start, N + 1, start): sieve[multiple] = False distinct_primes = [num for num, is_prime in enumerate(sieve) if is_prime] return len(distinct_primes) def solve(test_cases): results = [] for N in test_cases: results.append(count_distinct_prime_factors(N)) return results"},{"question":"def count_abc_substrings(s: str) -> int: Returns the number of ways to select and remove three contiguous characters 'ABC' from the string s. >>> count_abc_substrings(\\"ABCFBCFxABC\\") 2 >>> count_abc_substrings(\\"AAAABBBCCCC\\") 0","solution":"def count_abc_substrings(s): Returns the number of ways to select and remove three contiguous characters 'ABC' from the string s. count = 0 n = len(s) for i in range(n - 2): if s[i:i+3] == 'ABC': count += 1 return count"},{"question":"import math from typing import List def min_moves_to_restock(n: int, x: int, k: int, inventory: List[int]) -> List[int]: Calculates the minimum number of moves required for each store to ensure each store has at least \`x\` items after all operations or -1 if not possible. Parameters: n (int): Number of stores. x (int): Minimum required number of items. k (int): Maximum number of items that can be restocked in each move. inventory (list of int): Initial number of items in each store. Returns: list of int: Minimum number of moves required for each store or -1 if not possible. >>> min_moves_to_restock(3, 10, 5, [2, 8, 15]) [2, 1, 0] >>> min_moves_to_restock(2, 5, 3, [1, 6]) [2, 0]","solution":"import math def min_moves_to_restock(n, x, k, inventory): Calculates the minimum number of moves required for each store to ensure each store has at least x items after all operations or -1 if not possible. Parameters: n (int): Number of stores. x (int): Minimum required number of items. k (int): Maximum number of items that can be restocked in each move. inventory (list of int): Initial number of items in each store. Returns: list of int: Minimum number of moves required for each store or -1 if not possible. result = [] for items in inventory: if items >= x: result.append(0) else: required_items = x - items if required_items > 0 and k > 0: moves = math.ceil(required_items / k) result.append(moves) else: result.append(-1 if required_items > 0 else 0) return result"},{"question":"def max_groups(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determines the maximum number of groups Anna can create following given rules. Args: T : int : number of test cases test_cases : List[Tuple[int, List[int]]] : list of test cases, each having a tuple with two elements: - an integer representing the number of different types of coins - a list of integers representing the number of each type of coin Returns: List[int] : list of integers representing the maximum number of groups for each test case >>> max_groups(2, [(5, [10, 20, 30, 40, 50]), (3, [3, 3, 3])]) [5, 3] >>> max_groups(1, [(4, [1, 1, 1, 1])]) [4] >>> max_groups(1, [(5, [5, 3, 4, 1, 2])]) [5] >>> max_groups(1, [(4, [8, 3, 5, 3])]) [4] >>> max_groups(1, [(4, [1000000000, 1000000000, 999999999, 1000000000])]) [4] >>> max_groups(1, [(6, [2, 4, 6, 8, 10, 12])]) [6]","solution":"def max_groups(T, test_cases): Determines the maximum number of groups Anna can create following given rules. Args: T : int : number of test cases test_cases : List[Tuple[int, List[int]]] : list of test cases, each having a tuple with two elements: - an integer M representing the number of different types of coins - a list of integers representing the number of each type of coin Returns: List[int] : list of integers representing the maximum number of groups for each test case import heapq results = [] for M, counts in test_cases: counts.sort() used = set() max_groups = 0 for count in counts: if count not in used: used.add(count) max_groups += 1 else: new_count = count while new_count in used: new_count += 1 used.add(new_count) max_groups += 1 results.append(max_groups) return results"},{"question":"def is_valid_triangle(A: int, B: int, C: int) -> str: Determines if the sides A, B, and C can form a valid triangle. A triangle is valid if the sum of any two sides is greater than the third side. Parameters: A (int): Length of side A (1 ≦ A ≦ 100) B (int): Length of side B (1 ≦ B ≦ 100) C (int): Length of side C (1 ≦ C ≦ 100) Returns: str: \\"Yes\\" if the sides form a valid triangle, otherwise \\"No\\" >>> is_valid_triangle(3, 4, 5) \\"Yes\\" >>> is_valid_triangle(1, 2, 3) \\"No\\"","solution":"def is_valid_triangle(A, B, C): Determines if the sides A, B, and C can form a valid triangle. A triangle is valid if the sum of any two sides is greater than the third side. if A + B > C and A + C > B and B + C > A: return \\"Yes\\" else: return \\"No\\""},{"question":"def compute_student_averages(input_lines: List[str]) -> List[str]: Compute the average grade for each student from the given input lines. Args: input_lines (List[str]): A list of strings, where each string contains a student name and a grade. Returns: List[str]: A list of strings, each containing the student's name and their average grade formatted to two decimal places. >>> input_lines = [\\"John 80\\", \\"Jane 85\\", \\"John 90\\", \\"Jane 95\\", \\"STOP\\"] >>> compute_student_averages(input_lines) [\\"Jane 90.00\\", \\"John 85.00\\"] >>> input_lines = [\\"John 80\\", \\"Jane 200\\", \\"John 90\\", \\"Jane -5\\", \\"STOP\\"] >>> compute_student_averages(input_lines) [\\"John 85.00\\"] pass from solution import compute_student_averages def test_basic_input(): input_lines = [ \\"John 80\\", \\"Jane 85\\", \\"John 90\\", \\"Jane 95\\", \\"STOP\\" ] assert compute_student_averages(input_lines) == [\\"Jane 90.00\\", \\"John 85.00\\"] def test_invalid_entries(): input_lines = [ \\"John 80\\", \\"Jane 200\\", # Invalid grade \\"John 90\\", \\"Jane -5\\", # Invalid grade \\"STOP\\" ] assert compute_student_averages(input_lines) == [\\"John 85.00\\"] def test_single_student_multiple_valid_grades(): input_lines = [ \\"John 70\\", \\"John 80\\", \\"John 90\\", \\"STOP\\" ] assert compute_student_averages(input_lines) == [\\"John 80.00\\"] def test_multiple_students(): input_lines = [ \\"John 80\\", \\"Alex 70\\", \\"John 90\\", \\"Alex 80\\", \\"STOP\\" ] assert compute_student_averages(input_lines) == [\\"Alex 75.00\\", \\"John 85.00\\"] def test_mixed_case_student_names(): input_lines = [ \\"john 70\\", \\"John 80\\", \\"John 90\\", \\"STOP\\" ] # Assuming case-sensitive handling, hence only \\"John\\" gets considered for computation assert compute_student_averages(input_lines) == [\\"John 85.00\\", \\"john 70.00\\"] def test_empty_input(): input_lines = [\\"STOP\\"] assert compute_student_averages(input_lines) == [] def test_only_invalid_grades(): input_lines = [ \\"John -10\\", \\"Jane 101\\", \\"STOP\\" ] assert compute_student_averages(input_lines) == []","solution":"def compute_student_averages(input_lines): from collections import defaultdict # Dictionary to store grades for each student student_grades = defaultdict(list) for line in input_lines: if line == \\"STOP\\": break name, grade = line.split() grade = int(grade) if 0 <= grade <= 100: student_grades[name].append(grade) # Calculate the average for each student student_averages = {} for student, grades in student_grades.items(): if grades: avg_grade = sum(grades) / len(grades) student_averages[student] = f\\"{avg_grade:.2f}\\" # Sort the students alphabetically and generate the output sorted_students = sorted(student_averages.items()) output_lines = [f\\"{student} {avg_grade}\\" for student, avg_grade in sorted_students] return output_lines # Example input: input_lines = [ \\"John 80\\", \\"Jane 85\\", \\"John 90\\", \\"Jane 95\\", \\"InvalidEntry -1\\", \\"STOP\\" ] output = compute_student_averages(input_lines) for line in output: print(line)"},{"question":"def allocate_parcels(n, m, parcels, capacities): Allocate parcels to trucks such that no truck exceeds its delivery capacity, and every parcel is assigned to exactly one truck. Parameters: - n (int): The number of parcels. - m (int): The number of trucks. - parcels (List[int]): The delivery locations of the parcels. - capacities (List[int]): The maximum delivery capacities of the trucks. Returns: - List[List[int]]: A matrix where a 1 in row i and column j means the i-th truck will deliver the j-th parcel. A 0 means it will not. Examples: >>> allocate_parcels(5, 3, [20, 35, 50, 40, 60], [2, 1, 2]) [[1, 1, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 1, 1]] >>> allocate_parcels(4, 1, [10, 20, 30, 40], [4]) [[1, 1, 1, 1]] pass from typing import List # Unit Tests def test_example(): n = 5 m = 3 parcels = [20, 35, 50, 40, 60] capacities = [2, 1, 2] output = allocate_parcels(n, m, parcels, capacities) expected = [ [1, 1, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 1, 1] ] assert output == expected def test_single_truck_multiple_parcels(): n = 4 m = 1 parcels = [10, 20, 30, 40] capacities = [4] output = allocate_parcels(n, m, parcels, capacities) expected = [ [1, 1, 1, 1] ] assert output == expected def test_multiple_trucks_single_parcel(): n = 1 m = 3 parcels = [10] capacities = [1, 1, 1] output = allocate_parcels(n, m, parcels, capacities) expected = [ [1], [0], [0] ] assert output == expected def test_equal_parcels_trucks(): n = 3 m = 3 parcels = [10, 20, 30] capacities = [1, 1, 1] output = allocate_parcels(n, m, parcels, capacities) expected = [ [1, 0, 0], [0, 1, 0], [0, 0, 1] ] assert output == expected def test_trucks_with_insufficient_capacity(): n = 5 m = 1 parcels = [10, 20, 30, 40, 50] capacities = [3] output = allocate_parcels(n, m, parcels, capacities) expected = [ [1, 1, 1, 0, 0] ] assert output == expected def test_parcels_trucks_with_different_capacities(): n = 5 m = 3 parcels = [10, 20, 30, 40, 50] capacities = [2, 1, 2] output = allocate_parcels(n, m, parcels, capacities) expected = [ [1, 1, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 1, 1] ] assert output == expected","solution":"def allocate_parcels(n, m, parcels, capacities): allocation = [[0] * n for _ in range(m)] parcel_index = 0 for truck_index in range(m): remaining_capacity = capacities[truck_index] while remaining_capacity > 0 and parcel_index < n: allocation[truck_index][parcel_index] = 1 remaining_capacity -= 1 parcel_index += 1 return allocation"},{"question":"def lexicographically_smallest_string(S: str) -> str: Returns the lexicographically smallest string by swapping some (or none) of the characters. Each character can be swapped at most once and only with the character that is exactly one position to its right. >>> lexicographically_smallest_string('cba') 'bca'","solution":"def lexicographically_smallest_string(S): Returns the lexicographically smallest string by swapping each character at most once with the character that is exactly one position to its right. S = list(S) length = len(S) for i in range(length - 1): if S[i] > S[i + 1]: S[i], S[i + 1] = S[i + 1], S[i] break return \\"\\".join(S)"},{"question":"def longest_path_in_tree(N: int, edges: List[Tuple[int, int]]) -> int: Find the length of the longest path from Planet 1 to any other planet in a tree-like hierarchy. Args: N (int): The number of planets. edges (List[Tuple[int, int]]): A list of tuples representing the directional wormholes between planets. Returns: int: The length of the longest path from Planet 1. >>> longest_path_in_tree(1, []) 0 >>> longest_path_in_tree(2, [(1, 2)]) 1 >>> longest_path_in_tree(3, [(1, 2), (2, 3)]) 2 >>> longest_path_in_tree(3, [(1, 2), (1, 3)]) 1 >>> longest_path_in_tree(4, [(1, 2), (1, 3), (2, 4)]) 2","solution":"def longest_path_in_tree(N, edges): from collections import defaultdict, deque graph = defaultdict(list) for u, v in edges: graph[u].append(v) # Function to perform BFS and return the farthest node and its distance def bfs(start): queue = deque([(start, 0)]) visited = set([start]) farthest_node, max_distance = start, 0 while queue: current, distance = queue.popleft() for neighbor in graph[current]: if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, distance + 1)) if distance + 1 > max_distance: farthest_node, max_distance = neighbor, distance + 1 return farthest_node, max_distance # Starting from the root (planet 1) _, max_distance = bfs(1) return max_distance"},{"question":"from typing import List def largest_rectangle_area(heights: List[int]) -> int: Given a list of integers representing the heights of buildings in a skyline, returns the maximum area of a rectangular section formed using contiguous buildings. Example: >>> largest_rectangle_area([2, 1, 5, 6, 2, 3]) 10 >>> largest_rectangle_area([2, 4]) 4 >>> largest_rectangle_area([1, 1, 1, 1]) 4 pass def test_largest_rectangle_area(): assert largest_rectangle_area([2, 1, 5, 6, 2, 3]) == 10 assert largest_rectangle_area([2, 4]) == 4 assert largest_rectangle_area([2, 3, 4, 5, 6]) == 12 assert largest_rectangle_area([2, 3, 4, 2, 1, 5, 6, 2, 3]) == 10 assert largest_rectangle_area([6, 2, 5, 4, 5, 1, 6]) == 12 assert largest_rectangle_area([1]) == 1 assert largest_rectangle_area([1, 2, 3, 4, 5]) == 9 assert largest_rectangle_area([1, 1, 1, 1]) == 4","solution":"def largest_rectangle_area(heights): Given a list of integers representing the heights of buildings in a skyline, returns the maximum area of a rectangular section formed using contiguous buildings. stack = [] max_area = 0 index = 0 while index < len(heights): # Push the current building index to the stack if it's taller than the stack's top if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: # Pop the top building height top_of_stack = stack.pop() # Calculate the area with the popped height as the smallest (or minimum height) bar 'h' area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) # Update the max_area max_area = max(max_area, area) # Now pop the remaining buildings from the stack and calculate area after all buildings are processed while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def max_books(N, W, T): Determine the maximum number of books that can be stacked without exceeding the width limit W. Parameters: N (int): The number of books. W (int): The width limit of the stack. T (list): List of integers representing the thickness of each book. Returns: int: Maximum number of books that can be stacked. # Implement the function here pass def solve(test_cases): Process multiple test cases to determine the maximum number of books that can be stacked without exceeding the width limit W for each test case. Parameters: test_cases (list): List of tuples, each containing: - an integer N (number of books) - an integer W (width limit) - a list of integers T (thickness of each book) Returns: list: List of integers, each representing the maximum number of books that can be stacked for each test case. # Implement the function here pass # Test cases for testing the implementation def test_max_books(): assert max_books(5, 10, [2, 3, 4, 5, 6]) == 4 assert max_books(3, 3, [2, 2, 2]) == 2 assert max_books(4, 5, [1, 1, 1, 1]) == 4 assert max_books(4, 3, [3, 3, 3, 3]) == 1 assert max_books(6, 15, [1, 2, 3, 4, 5, 6]) == 5 def test_solve(): test_cases = [ (5, 10, [2, 3, 4, 5, 6]), (3, 3, [2, 2, 2]) ] assert solve(test_cases) == [4, 2]","solution":"def max_books(N, W, T): Determine the maximum number of books that can be stacked without exceeding the width limit W. Parameters: N (int): The number of books. W (int): The width limit of the stack. T (list): List of integers representing the thickness of each book. Returns: int: Maximum number of books that can be stacked. # Sorting the array for optimal stacking T.sort() current_width = 0 count = 0 for thickness in T: if current_width + thickness <= W: # Stack horizontally current_width += thickness count += 1 else: if current_width + 1 <= W: # Stack vertically current_width += 1 count += 1 else: break return count def solve(test_cases): results = [] for case in test_cases: N, W, T = case results.append(max_books(N, W, T)) return results"},{"question":"def longest_increasing_or_decreasing_subsequence(n: int, heights: List[int]) -> int: Returns the length of the longest subsequence of trees with heights that are either strictly increasing or strictly decreasing. >>> longest_increasing_or_decreasing_subsequence(1, [10]) 1 >>> longest_increasing_or_decreasing_subsequence(5, [1, 2, 3, 4, 5]) 5 >>> longest_increasing_or_decreasing_subsequence(5, [5, 4, 3, 2, 1]) 5 >>> longest_increasing_or_decreasing_subsequence(6, [10, 20, 10, 30, 25, 40]) 4 >>> longest_increasing_or_decreasing_subsequence(6, [10, 20, 30, 25, 15, 5]) 4 >>> longest_increasing_or_decreasing_subsequence(4, [5, 5, 5, 5]) 1 >>> longest_increasing_or_decreasing_subsequence(6, [1, 3, 2, 4, 3, 5]) 4","solution":"def longest_increasing_or_decreasing_subsequence(n, heights): Returns the length of the longest subsequence of trees with heights that are either strictly increasing or strictly decreasing. if n == 0: return 0 # Initialize arrays to store the length of longest increasing and decreasing subsequences increasing = [1] * n decreasing = [1] * n # Compute the longest increasing subsequence for i in range(1, n): for j in range(0, i): if heights[i] > heights[j] and increasing[i] < increasing[j] + 1: increasing[i] = increasing[j] + 1 # Compute the longest decreasing subsequence for i in range(1, n): for j in range(0, i): if heights[i] < heights[j] and decreasing[i] < decreasing[j] + 1: decreasing[i] = decreasing[j] + 1 # Find the maximum length among increasing and decreasing subsequences max_length = max(max(increasing), max(decreasing)) return max_length"},{"question":"from typing import List def count_smaller(nums: List[int]) -> List[int]: Given an integer array nums, return a new array counts where counts[i] is the number of smaller elements to the right of nums[i]. Parameters: nums (List[int]): List of integers. Returns: List[int]: A new list where the i-th element is the count of smaller elements to the right of nums[i]. Example: >>> count_smaller([5, 2, 6, 1]) [2, 1, 1, 0] >>> count_smaller([1, 2, 3, 4]) [0, 0, 0, 0] from solution import count_smaller def test_count_smaller_examples(): assert count_smaller([5, 2, 6, 1]) == [2, 1, 1, 0] assert count_smaller([1, 2, 3, 4]) == [0, 0, 0, 0] assert count_smaller([4, 3, 2, 1]) == [3, 2, 1, 0] assert count_smaller([3, 3, 3, 3]) == [0, 0, 0, 0] def test_count_smaller_single_element(): assert count_smaller([10]) == [0] def test_count_smaller_no_smaller_elements(): assert count_smaller([1, 3, 5, 7, 9]) == [0, 0, 0, 0, 0] def test_count_smaller_all_equal(): assert count_smaller([2, 2, 2, 2, 2]) == [0, 0, 0, 0, 0] def test_count_smaller_large_array(): import random large_array = random.sample(range(-10000, 10000), 10000) counts = count_smaller(large_array) assert len(counts) == 10000","solution":"from bisect import bisect_left def count_smaller(nums): For each element in nums, count the number of smaller elements to its right. Parameters: nums (list): List of integers. Returns: list: A new list where the i-th element is the count of smaller elements to the right of nums[i]. result = [] sorted_list = [] for num in reversed(nums): position = bisect_left(sorted_list, num) result.append(position) sorted_list.insert(position, num) return result[::-1]"},{"question":"def has_pair_with_sum(n: int, k: int, arr: List[int]) -> bool: Determines if there exists a pair of distinct integers in the list such that their sum is equal to k. Args: n (int): Number of integers in the list. k (int): Target sum. arr (list): List of integers. Returns: bool: True if such a pair exists, False otherwise. >>> has_pair_with_sum(5, 9, [1, 3, 5, 7, 8]) True >>> has_pair_with_sum(4, 10, [1, 2, 3, 4]) False >>> has_pair_with_sum(5, 1, [-1, -2, 3, 4, 5]) True >>> has_pair_with_sum(3, 0, [10**9, -(10**9), 1]) True >>> has_pair_with_sum(3, 5, [1, 1, 1]) False >>> has_pair_with_sum(4, 4, [2, 2, 2, 2]) True >>> has_pair_with_sum(4, 5, [1, 1, 1, 2]) False","solution":"def has_pair_with_sum(n, k, arr): Determines if there exists a pair of distinct integers in the list such that their sum is equal to k. Args: n (int): Number of integers in the list. k (int): Target sum. arr (list): List of integers. Returns: bool: True if such a pair exists, False otherwise. seen = set() for num in arr: if k - num in seen: return True seen.add(num) return False"},{"question":"def robot_position(instructions: str) -> (int, int): Decodes the instructions and calculates the robot's final position. Parameters: instructions (str): The encoded string with direction and steps. Returns: tuple: The final coordinates (x, y). >>> robot_position(\\"E2N1W1S3\\") (1, -2) >>> robot_position(\\"E5\\") (5, 0) >>> robot_position(\\"N7\\") (0, 7) >>> robot_position(\\"\\") (0, 0) >>> robot_position(\\"N3E3S1W1\\") (2, 2) >>> robot_position(\\"E10N5W5S3\\") (5, 2) >>> robot_position(\\"N03E5\\") (5, 3)","solution":"def robot_position(instructions): Decodes the instructions and calculates the robot's final position. Parameters: instructions (str): The encoded string with direction and steps. Returns: tuple: The final coordinates (x, y). x, y = 0, 0 i = 0 while i < len(instructions): direction = instructions[i] i += 1 steps = 0 while i < len(instructions) and instructions[i].isdigit(): steps = steps * 10 + int(instructions[i]) i += 1 if direction == 'N': y += steps elif direction == 'S': y -= steps elif direction == 'E': x += steps elif direction == 'W': x -= steps return (x, y)"},{"question":"from typing import List def findLongestWord(W: str, words: List[str]) -> str: Find the longest word in the list that can be formed by deleting some characters of W without rearranging the remaining characters of W. >>> findLongestWord(\\"abpcplea\\", [\\"ale\\", \\"apple\\", \\"monkey\\", \\"plea\\"]) \\"apple\\" >>> findLongestWord(\\"abpcplea\\", [\\"a\\", \\"b\\", \\"c\\"]) \\"a\\" >>> findLongestWord(\\"abpcplea\\", [\\"abc\\", \\"abe\\", \\"abcd\\"]) \\"abc\\" # Implement your solution here","solution":"from typing import List def findLongestWord(W: str, words: List[str]) -> str: def is_subsequence(word: str, W: str) -> bool: it = iter(W) return all(char in it for char in word) longest_word = \\"\\" for word in words: if is_subsequence(word, W): if len(word) > len(longest_word) or (len(word) == len(longest_word) and word < longest_word): longest_word = word return longest_word"},{"question":"def maximize_blooms(T: int, test_cases: List[str]) -> List[int]: Given the number of test cases T, and a list of strings representing the initial state of flowers, determine the maximum number of fully bloomed flowers that can be achieved for each test case. Parameters: T (int): the number of test cases test_cases (List[str]): a list of strings where each character is either 'F' or 'W' Returns: List[int]: a list of integers representing the maximum number of fully bloomed flowers for each test case Examples: >>> maximize_blooms(1, [\\"FFF\\"]) [3] >>> maximize_blooms(1, [\\"WW\\"]) [2] >>> maximize_blooms(1, [\\"FWFWF\\"]) [5] >>> maximize_blooms(3, [\\"FWFWF\\", \\"FFF\\", \\"WW\\"]) [5, 3, 2] >>> maximize_blooms(2, [\\"F\\", \\"W\\"]) [1, 1] results = [] for S in test_cases: results.append(len(S)) return results","solution":"def maximize_blooms(T, test_cases): Given the number of test cases T, and a list of strings representing the initial state of flowers, determine the maximum number of fully bloomed flowers that can be achieved for each test case. results = [] for S in test_cases: # Max blooming will be the length of the string as we can always flip the whole string. results.append(len(S)) return results"},{"question":"def max_flowers_increasing_heights(N: int, heights: List[int]) -> Tuple[int, int]: Determine the maximum number of flowers that can have strictly increasing heights and the minimum number of watering operations needed to achieve this. Args: N (int): The total number of flowers. heights (List[int]): The height of each flower. Returns: Tuple[int, int]: The maximum number of flowers that can have strictly increasing heights, and the minimum number of watering operations required. >>> max_flowers_increasing_heights(7, [2, 3, 5, 1, 4, 6, 7]) (5, 2) >>> max_flowers_increasing_heights(5, [2, 2, 2, 2, 2]) (1, 5) >>> max_flowers_increasing_heights(5, [1, 2, 3, 4, 5]) (5, 1) >>> max_flowers_increasing_heights(1, [1]) (1, 1) >>> max_flowers_increasing_heights(6, [5, 1, 2, 3, 7, 6]) (4, 2) pass","solution":"def max_flowers_increasing_heights(N, heights): def lis_length_and_segments(nums): if not nums: return 0, 0 tails = [] for num in nums: pos = binary_search(tails, num) if pos == len(tails): tails.append(num) else: tails[pos] = num return len(tails) def binary_search(tails, num): low, high = 0, len(tails) while low < high: mid = (low + high) // 2 if tails[mid] < num: low = mid + 1 else: high = mid return low lis_end_here = [0] * N longest_increasing_subsequence = [] for i in range(N): lis_end_here[i] = lis_length_and_segments(heights[:i+1]) longest_increasing_subsequence.append((lis_end_here[i], heights[i])) max_length = max(lis_end_here) watering_operations = 1 current_max = longest_increasing_subsequence[0][1] for i in range(1, N): if longest_increasing_subsequence[i][1] <= current_max: watering_operations += 1 current_max = longest_increasing_subsequence[i][1] return max_length, watering_operations"},{"question":"def get_clusters_count_and_sizes(grid): Returns the number of distinct clusters of products and their sizes in ascending order. Args: grid -- list of list of integers, where 0 represents empty cell and 1 represents a product Returns: Tuple containing the number of clusters and a list of cluster sizes in ascending order >>> get_clusters_count_and_sizes([ ... [1, 1, 0, 0, 0], ... [1, 1, 0, 0, 0], ... [0, 0, 1, 0, 0], ... [0, 0, 0, 1, 1], ... [0, 0, 0, 1, 1] ... ]) (3, [1, 4, 4]) >>> get_clusters_count_and_sizes([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) (0, []) >>> get_clusters_count_and_sizes([ ... [1, 1], ... [1, 1] ... ]) (1, [4]) >>> get_clusters_count_and_sizes([ ... [1, 0, 1], ... [0, 0, 0], ... [1, 0, 1] ... ]) (4, [1, 1, 1, 1]) >>> get_clusters_count_and_sizes([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) (1, [9])","solution":"def get_clusters_count_and_sizes(grid): Returns the number of clusters and their sizes in ascending order. Args: grid -- list of list of integers Returns: Tuple containing the number of clusters and a list of cluster sizes in ascending order n = len(grid) visited = [[False] * n for _ in range(n)] directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] def dfs(x, y): stack = [(x, y)] size = 0 while stack: cx, cy = stack.pop() if not visited[cx][cy]: visited[cx][cy] = True size += 1 for dx, dy in directions: nx, ny = cx + dx, cy + dy if 0 <= nx < n and 0 <= ny < n and grid[nx][ny] == 1 and not visited[nx][ny]: stack.append((nx, ny)) return size clusters_sizes = [] for i in range(n): for j in range(n): if grid[i][j] == 1 and not visited[i][j]: clusters_sizes.append(dfs(i, j)) clusters_sizes.sort() return len(clusters_sizes), clusters_sizes"},{"question":"def modify_sentence(sentence: str, commands: List[str]) -> str: Modifies the sentence based on the given commands. Each command is applied in sequence to the sentence. Parameters: sentence (str): The initial sentence to be modified. commands (list of str): The commands specifying modifications. Returns: str: The modified sentence. pass # Please implement the function here. # Test cases to validate the solution if __name__ == \\"__main__\\": # Testing Upper command assert modify_sentence(\\"hello world here I am\\", [\\"Upper 3\\"]) == \\"HELLO WORLD HERE I am\\" # Testing Lower command assert modify_sentence(\\"HELLO WORLD HERE I AM\\", [\\"Lower 2\\"]) == \\"HELLO WORLD HERE i am\\" # Testing Reverse command assert modify_sentence(\\"one two three four five\\", [\\"Reverse 3\\"]) == \\"three two one four five\\" # Testing multiple commands assert modify_sentence(\\"This is a simple sentence\\", [\\"Upper 2\\", \\"Reverse 4\\", \\"Lower 3\\"]) == \\"simple a is this sentence\\" # Testing without any commands assert modify_sentence(\\"This sentence will remain the same\\", []) == \\"This sentence will remain the same\\" # Testing Upper command on all words assert modify_sentence(\\"make everything uppercase\\", [\\"Upper 4\\"]) == \\"MAKE EVERYTHING UPPERCASE\\" # Testing Lower command on all words assert modify_sentence(\\"MAKE EVERYTHING LOWERCASE\\", [\\"Lower 4\\"]) == \\"make everything lowercase\\"","solution":"def modify_sentence(sentence, commands): Modifies the sentence based on the given commands. Each command is applied in sequence to the sentence. Parameters: sentence (str): The initial sentence to be modified. commands (list of str): The commands specifying modifications. Returns: str: The modified sentence. words = sentence.split() # Split the sentence into words. for command in commands: action, n = command.split() n = int(n) # Convert the number of words to be modified to an integer. if action == \\"Upper\\": for i in range(min(n, len(words))): words[i] = words[i].upper() elif action == \\"Lower\\": for i in range(max(0, len(words) - n), len(words)): words[i] = words[i].lower() elif action == \\"Reverse\\": words[:n] = reversed(words[:n]) return ' '.join(words) # Join the modified words back into a sentence."},{"question":"from typing import List def min_steps_in_maze(m: int, n: int, grid: List[List[int]]) -> int: Tom and Jerry lost their way in a maze described as a grid of size m × n. Each cell in the grid contains either a 0 (representing an empty space) or a 1 (representing an obstacle). Tom starts at cell (0, 0) and needs to reach cell (m-1, n-1). He can move up, down, left, or right, but cannot go through obstacles. Help Tom find the minimum number of steps required to reach (m-1, n-1). If it is not possible for Tom to reach the destination, return -1. >>> min_steps_in_maze(5, 5, [ [0, 0, 1, 0, 0], [0, 0, 1, 0, 0], [0, 0, 1, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 0, 0] ]) 8 >>> min_steps_in_maze(3, 3, [ [0, 1, 0], [0, 1, 0], [0, 0, 0] ]) 4 >>> min_steps_in_maze(3, 3, [ [0, 1, 0], [1, 1, 0], [0, 0, 0] ]) -1 >>> min_steps_in_maze(1, 1, [ [0] ]) 0 >>> min_steps_in_maze(1, 1, [ [1] ]) -1 >>> min_steps_in_maze(3, 3, [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ]) 4","solution":"from collections import deque def min_steps_in_maze(m, n, grid): if grid[0][0] == 1 or grid[m-1][n-1] == 1: return -1 directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] visited = [[False] * n for _ in range(m)] queue = deque([(0, 0, 0)]) # (x, y, steps) visited[0][0] = True while queue: x, y, steps = queue.popleft() if x == m-1 and y == n-1: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] == 0: queue.append((nx, ny, steps + 1)) visited[nx][ny] = True return -1"},{"question":"from typing import List def numberOfIslands(grid: List[List[str]]) -> int: Determine the number of distinct islands in the grid. >>> numberOfIslands([ ... [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], ... [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], ... [\\"0\\",\\"0\\",\\"1\\",\\"0\\",\\"0\\"], ... [\\"0\\",\\"0\\",\\"0\\",\\"1\\",\\"1\\"] ... ]) 3 >>> numberOfIslands([ ... [\\"1\\",\\"0\\",\\"1\\",\\"0\\"], ... [\\"0\\",\\"0\\",\\"0\\",\\"0\\"], ... [\\"0\\",\\"1\\",\\"1\\",\\"0\\"], ... [\\"0\\",\\"0\\",\\"0\\",\\"1\\"] ... ]) 4","solution":"from typing import List def numberOfIslands(grid: List[List[str]]) -> int: if not grid or not grid[0]: return 0 def dfs(grid, r, c): grid[r][c] = '0' # Mark as visited for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]: nr, nc = r + dr, c + dc if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and grid[nr][nc] == '1': dfs(grid, nr, nc) islands_count = 0 for r in range(len(grid)): for c in range(len(grid[0])): if grid[r][c] == '1': islands_count += 1 dfs(grid, r, c) return islands_count"},{"question":"def datasorted(lst): Takes a list of integers and returns a dictionary with the original list, the list sorted in ascending order, and the list sorted in descending order. Args: lst (list of int): The input list of integers. Returns: dict: A dictionary with the original list, the list sorted in ascending order, and the list sorted in descending order.","solution":"def datasorted(lst): Takes a list of integers and returns a dictionary with the original list, the list sorted in ascending order, and the list sorted in descending order. Args: lst (list of int): The input list of integers. Returns: dict: A dictionary with the original list, the list sorted in ascending order, and the list sorted in descending order. return { 'original': lst, 'ascending': sorted(lst), 'descending': sorted(lst, reverse=True) }"},{"question":"from typing import List def min_rounds_return_to_initial(N: int, K: int, positions: List[int]) -> int: Determine the smallest number of rounds required for all runners to return to their initial positions. >>> min_rounds_return_to_initial(3, 5, [1, 3, 5]) 5 >>> min_rounds_return_to_initial(4, 6, [2, 4, 6, 1]) 6 >>> min_rounds_return_to_initial(5, 7, [1, 2, 3, 4, 5]) 7 >>> min_rounds_return_to_initial(4, 12, [3, 6, 9, 12]) 12 def test_case_1(): assert min_rounds_return_to_initial(3, 5, [1, 3, 5]) == 5 def test_case_2(): assert min_rounds_return_to_initial(4, 6, [2, 4, 6, 1]) == 6 def test_case_3(): assert min_rounds_return_to_initial(5, 7, [1, 2, 3, 4, 5]) == 7 def test_case_4(): assert min_rounds_return_to_initial(4, 12, [3, 6, 9, 12]) == 12 def test_case_multiple(): assert min_rounds_return_to_initial(3, 10, [1, 5, 9]) == 10 assert min_rounds_return_to_initial(2, 14, [1, 14]) == 14 assert min_rounds_return_to_initial(2, 10**9, [1, 10**9]) == 10**9 assert min_rounds_return_to_initial(6, 15, [2, 5, 7, 10, 12, 15]) == 15","solution":"import math from functools import reduce def gcd(a, b): while b: a, b = b, a % b return a def lcm(x, y): return x * y // gcd(x, y) def min_rounds_return_to_initial(N, K, positions): def steps_to_return(pos, K): # Since it's a circle, if pos is at a[i] it should return after K steps. return K return reduce(lcm, [steps_to_return(pos, K) for pos in positions]) # Reading input def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) K = int(data[1]) positions = list(map(int, data[2:2+N])) print(min_rounds_return_to_initial(N, K, positions)) if __name__ == \\"__main__\\": main()"},{"question":"from collections import defaultdict from typing import List, Tuple def find_oldest_artifact(n: int, t: int, q: int, artifacts: List[Tuple[int, int, int]], queries: List[Tuple[int, int, int]]) -> List[int]: Find the oldest artifacts in the collection from a given type and within a specified age range. >>> artifacts = [(123, 1, 300), (124, 2, 200), (125, 1, 150), (126, 3, 400), (127, 2, 250)] >>> queries = [(1, 100, 200), (2, 200, 300)] >>> find_oldest_artifact(5, 3, 2, artifacts, queries) [125, 124] >>> artifacts = [(123, 1, 300), (124, 2, 200), (125, 1, 150), (126, 3, 400), (127, 2, 250)] >>> queries = [(1, 400, 500), (3, 200, 300)] >>> find_oldest_artifact(5, 3, 2, artifacts, queries) [-1, -1] >>> artifacts = [(123, 1, 300), (124, 2, 200), (125, 1, 150), (126, 3, 400), (127, 2, 250)] >>> queries = [(1, 150, 150), (3, 400, 400)] >>> find_oldest_artifact(5, 3, 2, artifacts, queries) [125, 126] >>> artifacts = [(123, 1, 300), (124, 2, 200), (125, 1, 150), (126, 1, 180), (127, 2, 250)] >>> queries = [(1, 150, 300)] >>> find_oldest_artifact(5, 3, 1, artifacts, queries) [125]","solution":"def find_oldest_artifact(n, t, q, artifacts, queries): from collections import defaultdict # Create a dictionary to store artifacts by their type artifacts_by_type = defaultdict(list) for identifier, artifact_type, age in artifacts: artifacts_by_type[artifact_type].append((identifier, age)) # Function to find the oldest artifact satisfying the query conditions def get_oldest_artifact(artifact_type, l, u): relevant_artifacts = [ (identifier, age) for identifier, age in artifacts_by_type[artifact_type] if l <= age <= u ] if not relevant_artifacts: return -1 # Find the oldest among the relevant artifacts return min(relevant_artifacts, key=lambda x: x[1])[0] results = [] for artifact_type, l, u in queries: result = get_oldest_artifact(artifact_type, l, u) results.append(result) return results"},{"question":"from typing import List def rotate_matrix_90(matrix: List[List[int]]) -> List[List[int]]: Rotates the given matrix 90 degrees clockwise. >>> rotate_matrix_90([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] def max_submatrix_sum(matrix: List[List[int]], n: int) -> int: Finds the maximum sum of an NxN submatrix within the given matrix. >>> max_submatrix_sum([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ], 2) 28 # Submatrix [[5, 6], [8, 9]] def sherlockAndMaxSum(matrix: List[List[int]], n: int) -> int: Finds the maximum sum of a submatrix of size NxN for all rotations of the given matrix. >>> sherlockAndMaxSum([ ... [1, 2, 3, 4, 5], ... [6, 7, 8, 9, 10], ... [11, 12, 13, 14, 15], ... [16, 17, 18, 19, 20] ... ], 2) 68 >>> sherlockAndMaxSum([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ], 2) 28","solution":"def rotate_matrix_90(matrix): Rotates the given matrix 90 degrees clockwise. return [list(reversed(col)) for col in zip(*matrix)] def max_submatrix_sum(matrix, n): Finds the maximum sum of an NxN submatrix within the given matrix. r = len(matrix) c = len(matrix[0]) max_sum = 0 for i in range(r - n + 1): for j in range(c - n + 1): curr_sum = sum(matrix[x][y] for x in range(i, i + n) for y in range(j, j + n)) max_sum = max(max_sum, curr_sum) return max_sum def sherlockAndMaxSum(matrix, n): Finds the maximum sum of a submatrix of size NxN for all rotations of the given matrix. max_sum = 0 for _ in range(4): # Rotate 0, 90, 180, and 270 degrees max_sum = max(max_sum, max_submatrix_sum(matrix, n)) matrix = rotate_matrix_90(matrix) return max_sum"},{"question":"def surging_energy_order(n, energies): Returns the surging order of energy levels and their original positions. Parameters: - n: int - number of artifacts - energies: list[int] - list of energy levels of the artifacts Returns: - surging_energies: list[int] - list of energy levels in surging order - surging_positions: list[int] - list of original positions of the energies in surging order >>> surging_energy_order(6, [3, 1, 4, 1, 5, 9]) ([9, 1, 5, 1, 4, 3], [6, 2, 5, 4, 3, 1]) >>> surging_energy_order(5, [10, 20, 30, 40, 50]) ([50, 10, 40, 20, 30], [5, 1, 4, 2, 3])","solution":"def surging_energy_order(n, energies): Returns the surging order of energy levels and their original positions. Parameters: - n: int - number of artifacts - energies: list[int] - list of energy levels of the artifacts Returns: - surging_energies: list[int] - list of energy levels in surging order - surging_positions: list[int] - list of original positions of the energies in surging order indexed_energies = list(enumerate(energies, start=1)) indexed_energies.sort(key=lambda x: x[1]) left, right = 0, n - 1 surging_energies = [] surging_positions = [] while left <= right: if right >= left: surging_energies.append(indexed_energies[right][1]) surging_positions.append(indexed_energies[right][0]) right -= 1 if left <= right: surging_energies.append(indexed_energies[left][1]) surging_positions.append(indexed_energies[left][0]) left += 1 return surging_energies, surging_positions"},{"question":"def process_operations(n: int, q: int, array: List[int], operations: List[str]) -> List[int]: Processes a list of operations on an array and returns results of queries. :param n: Number of integers in the list (1 ≤ n ≤ 10^5). :param q: Number of operations to perform (1 ≤ q ≤ 10^5). :param array: Initial list of integers (1 ≤ ai ≤ 10^9). :param operations: List of operations to perform. :return: List of results from query operations. Operations include: - \\"1 l r x\\": Add x to all integers from index l to index r (1 ≤ l ≤ r ≤ n, 1 ≤ x ≤ 10^9). - \\"2 l r x\\": Multiply all integers from index l to index r by x (1 ≤ l ≤ r ≤ n, 1 ≤ x ≤ 10^9). - \\"3 i\\": Output the integer at index i (1 ≤ i ≤ n). >>> n = 5 >>> q = 6 >>> array = [10, 20, 30, 40, 50] >>> operations = [ >>> \\"1 1 3 5\\", >>> \\"2 2 4 2\\", >>> \\"3 3\\", >>> \\"3 5\\", >>> \\"1 4 5 10\\", >>> \\"3 4\\" >>> ] >>> process_operations(n, q, array, operations) == [70, 50, 90] >>> n = 4 >>> q = 5 >>> array = [1, 2, 3, 4] >>> operations = [ >>> \\"1 2 3 100\\", >>> \\"2 1 4 10\\", >>> \\"3 1\\", >>> \\"3 2\\", >>> \\"3 4\\" >>> ] >>> process_operations(n, q, array, operations) == [10, 1020, 40]","solution":"def process_operations(n, q, array, operations): Processes a list of operations on an array and returns results of queries. :param n: Number of integers in the list. :param q: Number of operations to perform. :param array: Initial list of integers. :param operations: List of operations to perform. :return: List of results from query operations. results = [] for op in operations: # Parse the operation op = op.split() op_type = int(op[0]) if op_type == 1: # Add x to all integers from index l to index r (inclusive) l = int(op[1]) - 1 r = int(op[2]) - 1 x = int(op[3]) for i in range(l, r+1): array[i] += x elif op_type == 2: # Multiply all integers from index l to index r (inclusive) by x l = int(op[1]) - 1 r = int(op[2]) - 1 x = int(op[3]) for i in range(l, r+1): array[i] *= x elif op_type == 3: # Output the integer at index i i = int(op[1]) - 1 results.append(array[i]) return results"},{"question":"import heapq from collections import Counter def reorganize_string(s: str) -> str: Reorganizes the string such that no two adjacent characters are the same. If it is not possible, return an empty string. >>> reorganize_string(\\"aab\\") \\"aba\\" >>> reorganize_string(\\"aaab\\") \\"\\"","solution":"import heapq from collections import Counter def reorganize_string(s): Reorganizes the string such that no two adjacent characters are the same. If it is not possible, returns an empty string. count = Counter(s) max_heap = [(-value, key) for key, value in count.items()] heapq.heapify(max_heap) prev_count, prev_char = 0, '' result = [] while max_heap: current_count, current_char = heapq.heappop(max_heap) result.append(current_char) if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) prev_count, prev_char = current_count + 1, current_char result_string = ''.join(result) if len(result_string) != len(s): return \\"\\" return result_string"},{"question":"def transform_string(k: int, s: str) -> str: Transforms the string s by shifting each character k positions forward in the alphabet. Wraps around from 'z' to 'a' if necessary. Parameters: k (int): Number of positions to shift each character (1 ≤ k ≤ 25). s (str): Input string consisting of only lowercase English letters (1 ≤ length of s ≤ 1000). Returns: str: Transformed string after applying the shifts. >>> transform_string(5, \\"apple\\") 'fuuqj' >>> transform_string(3, \\"xyz\\") 'abc'","solution":"def transform_string(k, s): Transforms the string s by shifting each character k positions forward in the alphabet. Wraps around from 'z' to 'a' if necessary. Parameters: k (int): Number of positions to shift each character (1 ≤ k ≤ 25). s (str): Input string consisting of only lowercase English letters (1 ≤ length of s ≤ 1000). Returns: str: Transformed string after applying the shifts. transformed = [] for char in s: new_char = chr((ord(char) - ord('a') + k) % 26 + ord('a')) transformed.append(new_char) return ''.join(transformed)"},{"question":"from typing import List def find_missing_number(arr: List[int]) -> int: Finds the missing number in an array containing unique integers from 1 to n. >>> find_missing_number([1, 2, 4, 5]) == 3 >>> find_missing_number([2, 3, 1, 5]) == 4 >>> find_missing_number([5, 3, 2, 1]) == 4 >>> find_missing_number([1, 3]) == 2","solution":"from typing import List def find_missing_number(arr: List[int]) -> int: Finds the missing number in an array containing unique integers from 1 to n. n = len(arr) + 1 total_sum = n * (n + 1) // 2 arr_sum = sum(arr) return total_sum - arr_sum"},{"question":"def canPartition(arr: List[int]) -> bool: Determines if it's possible to partition the list into two sublists such that the sum of elements in both sublists is the same. :param arr: List of integers :return: True if such a partition is possible, otherwise False >>> canPartition([1, 5, 11, 5]) == True >>> canPartition([1, 2, 3, 5]) == False >>> canPartition([1]) == False >>> canPartition([1, 1]) == True >>> canPartition([0, 0, 0, 0]) == True >>> canPartition([3, 3, 3, 4, 5]) == True","solution":"def canPartition(arr): Determines if it's possible to partition the list into two sublists such that the sum of elements in both sublists is the same. :param arr: List of integers :return: True if such a partition is possible, otherwise False total_sum = sum(arr) # If the total sum is odd, we can't partition it into two equal subsets if total_sum % 2 != 0: return False target = total_sum // 2 n = len(arr) # DP array to store the state whether a particular sum is achievable or not dp = [False] * (target + 1) dp[0] = True for num in arr: for j in range(target, num - 1, -1): dp[j] = dp[j] or dp[j - num] return dp[target]"},{"question":"def find_earliest_chat_room(N: int, chat_room_data: List[Tuple[int, int]]) -> int: Identifies and returns the chat room with the earliest (oldest) last active timestamp. Args: N (int): Number of chat rooms the employee is part of. chat_room_data (List[Tuple[int, int]]): List of tuples where each tuple contains two integers, ci (chat room id) and ti (last active timestamp). Returns: int: The chat room id with the earliest last active timestamp. >>> find_earliest_chat_room(3, [(101, 1610000000), (102, 1610005000), (103, 1609999999)]) 103 >>> find_earliest_chat_room(1, [(101, 1610000000)]) 101 >>> find_earliest_chat_room(3, [(101, 1610000000), (102, 1610000000), (100, 1610000000)]) 100","solution":"def earliest_chat_room(chat_rooms): Returns the chat room id with the earliest last active timestamp. In case of ties, returns the smallest chat room id among the tied ones. Args: chat_rooms (list of tuples): a list where each tuple contains two integers, ci (chat room id) and ti (last active timestamp). Returns: int: the chat room id with the earliest last active timestamp. # Initialize variables to store the smallest timestamp and the corresponding chat room id smallest_timestamp = float('inf') smallest_id = float('inf') # Iterate over each chat room for chat_id, timestamp in chat_rooms: # Compare the current timestamp and chat room id with the smallest ones found so far if (timestamp < smallest_timestamp) or (timestamp == smallest_timestamp and chat_id < smallest_id): smallest_timestamp = timestamp smallest_id = chat_id return smallest_id def find_earliest_chat_room(N, chat_room_data): return earliest_chat_room(chat_room_data)"},{"question":"def unique_user_pairs_within_limit(T, test_cases): Determine the number of unique user pairs that can be formed without exceeding the maximum allowed recommendations. Args: T (int): The number of test cases. test_cases (List[Tuple[int, int]]): List of tuples where each tuple contains: - N (int): Number of users in the network. - M (int): Maximum allowed number of recommendations. Returns: List[Union[int, str]]: For each test case, if the number of unique pairs is within the allowed limit, return the number of unique pairs. Otherwise, return \\"Exceeds Limit\\". >>> unique_user_pairs_within_limit(2, [(5, 10), (10, 30)]) [10, \\"Exceeds Limit\\"] >>> unique_user_pairs_within_limit(1, [(6, 15)]) [15] >>> unique_user_pairs_within_limit(3, [(1, 0), (100000, 1000000000), (10000, 49995000)]) [0, \\"Exceeds Limit\\", 49995000] # Test cases to validate the solution def test_unique_user_pairs_within_limit(): T = 2 test_cases = [(5, 10), (10, 30)] assert unique_user_pairs_within_limit(T, test_cases) == [10, \\"Exceeds Limit\\"] T = 1 test_cases = [(6, 15)] assert unique_user_pairs_within_limit(T, test_cases) == [15] T = 3 test_cases = [(1, 0), (100000, 1000000000), (10000, 49995000)] assert unique_user_pairs_within_limit(T, test_cases) == [0, \\"Exceeds Limit\\", 49995000] T = 1 test_cases = [(10000, 49995000-1)] assert unique_user_pairs_within_limit(T, test_cases) == [\\"Exceeds Limit\\"] T = 1 test_cases = [(1, 1)] assert unique_user_pairs_within_limit(T, test_cases) == [0]","solution":"def unique_user_pairs_within_limit(T, test_cases): results = [] for case in test_cases: N, M = case # Calculate the number of unique pairs unique_pairs = (N * (N - 1)) // 2 if unique_pairs <= M: results.append(unique_pairs) else: results.append(\\"Exceeds Limit\\") return results"},{"question":"def find_discrepancies(day1_counts, day2_counts, day3_counts): Function to find discrepancy items between Day 1 and Day 2, and between Day 2 and Day 3. Parameters: day1_counts (list): Item counts recorded on Day 1. day2_counts (list): Item counts recorded on Day 2. day3_counts (list): Item counts recorded on Day 3. Returns: tuple: Discrepancies between Day 1 and 2, and between Day 2 and 3. pass from solution import find_discrepancies def test_find_discrepancies_example1(): assert find_discrepancies([11, 5, 7, 3], [5, 7, 3], [7, 3]) == (11, 5) def test_find_discrepancies_example2(): assert find_discrepancies([15, 12, 9, 13, 6], [15, 9, 13, 6], [13, 9, 6]) == (12, 15) def test_find_discrepancies_all_same(): assert find_discrepancies([1, 2, 3], [1, 2], [1]) == (3, 2) def test_find_discrepancies_large_numbers(): assert find_discrepancies([1000000000, 999999999], [999999999], []) == (1000000000, 999999999) def test_find_discrepancies_reverse_order(): assert find_discrepancies([3, 2, 1], [2, 1], [1]) == (3, 2)","solution":"def find_discrepancies(day1_counts, day2_counts, day3_counts): Function to find discrepancy items between Day 1 and Day 2, and between Day 2 and Day 3. Parameters: day1_counts (list): Item counts recorded on Day 1. day2_counts (list): Item counts recorded on Day 2. day3_counts (list): Item counts recorded on Day 3. Returns: tuple: Discrepancies between Day 1 and 2, and between Day 2 and 3. def find_missing(list1, list2): count_map = {} for item in list1: count_map[item] = count_map.get(item, 0) + 1 for item in list2: if item in count_map and count_map[item] > 0: count_map[item] -= 1 if count_map[item] == 0: del count_map[item] for missing_item in count_map: return missing_item discrepancy_1_2 = find_missing(day1_counts, day2_counts) discrepancy_2_3 = find_missing(day2_counts, day3_counts) return (discrepancy_1_2, discrepancy_2_3)"},{"question":"import heapq from typing import List, Tuple def shortest_path(n: int, m: int, edges: List[Tuple[int, int, int]], start: int, end: int) -> int: Returns the shortest path weight from start node to end node in a graph with n nodes and m edges. If no such path exists, returns -1. Args: n (int): Number of nodes m (int): Number of edges edges (List[Tuple[int, int, int]]): List of edges where each edge is represented as (u, v, w) start (int): Start node end (int): End node Returns: int: The weight of the shortest path from start to end, or -1 if no such path exists Example: >>> shortest_path(4, 4, [(0, 1, 1), (1, 2, 2), (0, 2, 4), (2, 3, 1)], 0, 3) 4 >>> shortest_path(4, 3, [(0, 1, 1), (1, 2, 2), (0, 2, 4)], 0, 3) -1 def test_shortest_path(): assert shortest_path(4, 4, [(0, 1, 1), (1, 2, 2), (0, 2, 4), (2, 3, 1)], 0, 3) == 4 assert shortest_path(4, 4, [(0, 1, 1), (1, 2, 2), (0, 2, 4), (2, 3, 1)], 0, 2) == 3 assert shortest_path(4, 4, [(0, 1, 1), (1, 2, 2), (0, 2, 4), (2, 3, 1)], 3, 0) == 4 assert shortest_path(4, 4, [(0, 1, 1), (1, 2, 2), (0, 2, 4), (2, 3, 1)], 0, 1) == 1 assert shortest_path(4, 3, [(0, 1, 1), (1, 2, 2), (0, 2, 4)], 0, 3) == -1 assert shortest_path(4, 0, [], 0, 3) == -1 assert shortest_path(1, 0, [], 0, 0) == 0","solution":"import heapq def shortest_path(n, m, edges, start, end): Returns the shortest path weight from start node to end node in a graph with n nodes and m edges. If no such path exists, returns -1. graph = [[] for _ in range(n)] for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) # Dijkstra's algorithm pq = [(0, start)] dist = {i: float('inf') for i in range(n)} dist[start] = 0 visited = set() while pq: current_dist, current_node = heapq.heappop(pq) if current_node in visited: continue visited.add(current_node) for neighbor, weight in graph[current_node]: distance = current_dist + weight if distance < dist[neighbor]: dist[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return dist[end] if dist[end] != float('inf') else -1"},{"question":"import re def isPalindrome(s: str) -> bool: Determine if a given string is a palindrome, ignoring spaces, punctuation, and capitalization. >>> isPalindrome(\\"A man, a plan, a canal, Panama\\") True >>> isPalindrome(\\"race a car\\") False >>> isPalindrome(\\"No 'x' in Nixon\\") True","solution":"import re def isPalindrome(s): Checks if the given string is a palindrome, ignoring spaces, punctuation, and capitalization. # Remove non-alphabetic characters and convert to lowercase cleaned_s = re.sub(r'[^a-zA-Z]', '', s).lower() # Compare the cleaned string with its reverse return cleaned_s == cleaned_s[::-1]"},{"question":"def game_winner(a: int, b: int) -> str: Determine the winner of the game at coordinates (a, b). >>> game_winner(1, 2) \\"ALICE\\" >>> game_winner(2, 2) \\"BOB\\" >>> game_winner(3, 1) \\"ALICE\\" >>> game_winner(0, 0) \\"BOB\\" >>> game_winner(1000000, 1000000) \\"BOB\\" >>> game_winner(1000000, 999999) \\"ALICE\\" def find_winner(T: int, coordinates: List[Tuple[int, int]]) -> List[str]: For T test cases with given coordinates, determine the winner of each game. >>> find_winner(3, [(1, 2), (2, 2), (3, 1)]) [\\"ALICE\\", \\"BOB\\", \\"ALICE\\"] >>> find_winner(2, [(0, 0), (1000000, 999999)]) [\\"BOB\\", \\"ALICE\\"]","solution":"def game_winner(a, b): Determine the winner of the game at coordinates (a, b) if a == b: return \\"BOB\\" else: return \\"ALICE\\" def find_winner(T, coordinates): results = [] for a, b in coordinates: results.append(game_winner(a, b)) return results"},{"question":"class MessagingSystem: Class for managing a messaging system within an office. def send_message(self, from_employee: str, to_employee: str, message_text: str) -> None: Sends a message from \`from_employee\` to \`to_employee\` with the content \`message_text\`. pass def query_message_history(self, employee_1: str, employee_2: str) -> List[str]: Returns a list of all messages exchanged between \`employee_1\` and \`employee_2\`. Each message is represented as a string formatted as: \\"from [sender] to [receiver]: [message_text]\\" pass # Example usage ms = MessagingSystem() ms.send_message(\\"Alice\\", \\"Bob\\", \\"Hello Bob!\\") ms.send_message(\\"Bob\\", \\"Alice\\", \\"Hi Alice!\\") ms.send_message(\\"Alice\\", \\"Bob\\", \\"How are you?\\") history = ms.query_message_history(\\"Alice\\", \\"Bob\\") print(history) # Output: [\\"from Alice to Bob: Hello Bob!\\", \\"from Bob to Alice: Hi Alice!\\", \\"from Alice to Bob: How are you?\\"]","solution":"class MessagingSystem: def __init__(self): self.messages = [] def send_message(self, from_employee, to_employee, message_text): Sends a message from \`from_employee\` to \`to_employee\` with the content \`message_text\`. self.messages.append((from_employee, to_employee, message_text)) def query_message_history(self, employee_1, employee_2): Returns a list of all messages exchanged between \`employee_1\` and \`employee_2\`. history = [] for msg in self.messages: if (msg[0] == employee_1 and msg[1] == employee_2) or (msg[0] == employee_2 and msg[1] == employee_1): history.append(f\\"from {msg[0]} to {msg[1]}: {msg[2]}\\") return history"},{"question":"from typing import List, Dict def canCommunicate(messages: List[Dict[str, int, str]], queries: List[Dict[str, int, str]]) -> List[str]: Determine if there exists a sequence of messages that starts with the first employee and ends with the second employee within the given timeframe. >>> messages = [ ... {\\"sender\\": \\"Alice\\", \\"recipient\\": \\"Bob\\", \\"timestamp\\": 1}, ... {\\"sender\\": \\"Bob\\", \\"recipient\\": \\"Charlie\\", \\"timestamp\\": 2}, ... {\\"sender\\": \\"Charlie\\", \\"recipient\\": \\"Dave\\", \\"timestamp\\": 4}, ... {\\"sender\\": \\"Alice\\", \\"recipient\\": \\"Eve\\", \\"timestamp\\": 3}, ... {\\"sender\\": \\"Eve\\", \\"recipient\\": \\"Bob\\", \\"timestamp\\": 5}, ... {\\"sender\\": \\"Bob\\", \\"recipient\\": \\"Alice\\", \\"timestamp\\": 6}, ... ] >>> queries = [ ... {\\"start\\": \\"Alice\\", \\"end\\": \\"Dave\\", \\"start_time\\": 1, \\"end_time\\": 4}, ... {\\"start\\": \\"Alice\\", \\"end\\": \\"Charlie\\", \\"start_time\\": 1, \\"end_time\\": 5}, ... {\\"start\\": \\"Eve\\", \\"end\\": \\"Charlie\\", \\"start_time\\": 2, \\"end_time\\": 6}, ... ] >>> canCommunicate(messages, queries) [\\"YES\\", \\"YES\\", \\"NO\\"] import pytest def test_sample(): messages = [ {\\"sender\\": \\"Alice\\", \\"recipient\\": \\"Bob\\", \\"timestamp\\": 1}, {\\"sender\\": \\"Bob\\", \\"recipient\\": \\"Charlie\\", \\"timestamp\\": 2}, {\\"sender\\": \\"Charlie\\", \\"recipient\\": \\"Dave\\", \\"timestamp\\": 4}, {\\"sender\\": \\"Alice\\", \\"recipient\\": \\"Eve\\", \\"timestamp\\": 3}, {\\"sender\\": \\"Eve\\", \\"recipient\\": \\"Bob\\", \\"timestamp\\": 5}, {\\"sender\\": \\"Bob\\", \\"recipient\\": \\"Alice\\", \\"timestamp\\": 6}, ] queries = [ {\\"start\\": \\"Alice\\", \\"end\\": \\"Dave\\", \\"start_time\\": 1, \\"end_time\\": 4}, {\\"start\\": \\"Alice\\", \\"end\\": \\"Charlie\\", \\"start_time\\": 1, \\"end_time\\": 5}, {\\"start\\": \\"Eve\\", \\"end\\": \\"Charlie\\", \\"start_time\\": 2, \\"end_time\\": 6}, ] assert canCommunicate(messages, queries) == [\\"YES\\", \\"YES\\", \\"NO\\"] def test_no_chain_exists(): messages = [ {\\"sender\\": \\"Alice\\", \\"recipient\\": \\"Bob\\", \\"timestamp\\": 1}, {\\"sender\\": \\"Bob\\", \\"recipient\\": \\"Charlie\\", \\"timestamp\\": 2}, ] queries = [ {\\"start\\": \\"Alice\\", \\"end\\": \\"Dave\\", \\"start_time\\": 1, \\"end_time\\": 5}, ] assert canCommunicate(messages, queries) == [\\"NO\\"] def test_single_message(): messages = [ {\\"sender\\": \\"Alice\\", \\"recipient\\": \\"Bob\\", \\"timestamp\\": 1}, ] queries = [ {\\"start\\": \\"Alice\\", \\"end\\": \\"Bob\\", \\"start_time\\": 1, \\"end_time\\": 5}, {\\"start\\": \\"Bob\\", \\"end\\": \\"Alice\\", \\"start_time\\": 1, \\"end_time\\": 5} ] assert canCommunicate(messages, queries) == [\\"YES\\", \\"NO\\"] def test_complex_chain(): messages = [ {\\"sender\\": \\"Alice\\", \\"recipient\\": \\"Bob\\", \\"timestamp\\": 1}, {\\"sender\\": \\"Bob\\", \\"recipient\\": \\"Charlie\\", \\"timestamp\\": 2}, {\\"sender\\": \\"Charlie\\", \\"recipient\\": \\"Dave\\", \\"timestamp\\": 4}, {\\"sender\\": \\"Alice\\", \\"recipient\\": \\"Eve\\", \\"timestamp\\": 3}, {\\"sender\\": \\"Eve\\", \\"recipient\\": \\"Charlie\\", \\"timestamp\\": 5}, {\\"sender\\": \\"Charlie\\", \\"recipient\\": \\"Eve\\", \\"timestamp\\": 6}, {\\"sender\\": \\"Eve\\", \\"recipient\\": \\"Alice\\", \\"timestamp\\": 7}, {\\"sender\\": \\"Alice\\", \\"recipient\\": \\"Charlie\\", \\"timestamp\\": 8}, ] queries = [ {\\"start\\": \\"Alice\\", \\"end\\": \\"Dave\\", \\"start_time\\": 1, \\"end_time\\": 4}, {\\"start\\": \\"Eve\\", \\"end\\": \\"Charlie\\", \\"start_time\\": 2, \\"end_time\\": 6}, {\\"start\\": \\"Eve\\", \\"end\\": \\"Alice\\", \\"start_time\\": 1, \\"end_time\\": 8} ] assert canCommunicate(messages, queries) == [\\"YES\\", \\"YES\\", \\"YES\\"]","solution":"from collections import defaultdict, deque def canCommunicate(messages, queries): def bfs(start, end, start_time, end_time, graph, times): queue = deque([(start, start_time)]) visited = set() while queue: current, curr_time = queue.popleft() if current in visited: continue visited.add(current) for next_node, timestamp in graph[current]: if start_time <= timestamp <= end_time and timestamp >= curr_time: if next_node == end: return \\"YES\\" queue.append((next_node, timestamp)) return \\"NO\\" # Building the graph graph = defaultdict(list) for msg in messages: if msg['timestamp'] <= 10**9: graph[msg['sender']].append((msg['recipient'], msg['timestamp'])) # Answering each query results = [] for query in queries: result = bfs(query['start'], query['end'], query['start_time'], query['end_time'], graph, messages) results.append(result) return results"},{"question":"def organize_books(T: int, test_cases: List[Tuple[int, List[str]]]) -> List[str]: Organize a list of book IDs by sorting them based on sum of digits, number of digits, and lexicographical order. >>> organize_books(2, [(3, [\\"103\\", \\"002\\", \\"21\\"]), (4, [\\"123\\", \\"234\\", \\"345\\", \\"456\\"])]) [\\"002 21 103\\", \\"123 234 345 456\\"] >>> >>> organize_books(1, [(5, [\\"321\\", \\"123\\", \\"213\\", \\"132\\", \\"231\\"])]) [\\"123 132 213 231 321\\"] >>>","solution":"def sum_of_digits(s): return sum(int(d) for d in s) def custom_sort_book_ids(book_ids): return sorted(book_ids, key=lambda x: (sum_of_digits(x), len(x), x)) def organize_books(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] book_ids = test_cases[i][1] sorted_ids = custom_sort_book_ids(book_ids) results.append(\\" \\".join(sorted_ids)) return results"},{"question":"def check_bookings(T: int, test_cases: List[Tuple[int, int, List[Tuple[int, int, int]]]]) -> List[str]: Determine if the seat bookings for each test case are valid based on the rules: 1. Each booking specifies a start station, an end station, and a seat number. 2. A seat can be booked by multiple passengers only if their journeys do not overlap. Examples: >>> check_bookings(3, [ (5, 3, [(1, 3, 2), (2, 4, 2), (3, 5, 2)]), (5, 2, [(1, 2, 1), (2, 3, 1)]), (5, 3, [(1, 3, 1), (3, 5, 1), (1, 5, 2)]) ]) ['INVALID', 'VALID', 'VALID'] >>> check_bookings(1, [(5, 2, [(1, 2, 1), (2, 3, 1)])]) ['VALID']","solution":"def check_bookings(T, test_cases): results = [] for i in range(T): N, M, bookings = test_cases[i] seat_map = {} valid = \\"VALID\\" for s, e, k in bookings: if k not in seat_map: seat_map[k] = [] # Check for overlap for st, en in seat_map[k]: if not (e <= st or s >= en): # Overlapping condition valid = \\"INVALID\\" break if valid == \\"INVALID\\": break seat_map[k].append((s, e)) results.append(valid) return results # Example Test Case T = 3 test_cases = [ (5, 3, [(1, 3, 2), (2, 4, 2), (3, 5, 2)]), (5, 2, [(1, 2, 1), (2, 3, 1)]), (5, 3, [(1, 3, 1), (3, 5, 1), (1, 5, 2)]) ] print(check_bookings(T, test_cases)) # Expected Output: ['INVALID', 'VALID', 'VALID']"},{"question":"def trap(height): Calculates the amount of water trapped between the buildings. Parameters: height (list): A list of integers representing the heights of buildings. Returns: int: Total units of water trapped. >>> trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap([4, 2, 0, 3, 2, 5]) 9 >>> trap([]) 0 >>> trap([5]) 0 >>> trap([1, 2]) 0 >>> trap([1, 1, 1, 1, 1]) 0 >>> trap([3, 0, 2]) 2 >>> trap([0, 2, 0, 1, 3, 0, 1, 2]) 6 >>> trap([3, 0, 3]) 3 >>> trap([5, 4, 3, 2, 1, 2, 3, 4, 5]) 16","solution":"def trap(height): Calculates the amount of water trapped between the buildings. Parameters: height (list): A list of integers representing the heights of buildings. Returns: int: Total units of water trapped. if len(height) < 3: return 0 left_max, right_max = [0] * len(height), [0] * len(height) left_max[0], right_max[-1] = height[0], height[-1] # Fill left_max and right_max arrays for i in range(1, len(height)): left_max[i] = max(left_max[i - 1], height[i]) for i in range(len(height) - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) # Calculate trapped water trapped = 0 for i in range(1, len(height) - 1): trapped += max(min(left_max[i], right_max[i]) - height[i], 0) return trapped"},{"question":"from typing import List, Tuple def mix_colors(base_colors: List[str], mixing_instructions: List[str]) -> List[str]: Returns the resulting set of colors after mixing the base colors according to the provided instructions. def process_input(input_lines: List[str]) -> Tuple[List[str], List[str]]: Processes the input lines to extract base colors and mixing instructions. def test_mix_colors(): base_colors, mixing_instructions = process_input([ \\"red blue yellow\\", \\"red+blue=purple\\", \\"blue+yellow=green\\", \\"red+yellow=orange\\", \\"*\\" ]) assert mix_colors(base_colors, mixing_instructions) == [\\"purple\\", \\"green\\", \\"orange\\"] base_colors, mixing_instructions = process_input([ \\"red blue yellow\\", \\"red+blue=purple\\", \\"blue+yellow=green\\", \\"red+yellow=orange\\", \\"blue+yellow=lime\\", \\"*\\" ]) assert mix_colors(base_colors, mixing_instructions) == [\\"purple\\", \\"green\\", \\"orange\\", \\"lime\\"] base_colors, mixing_instructions = process_input([ \\"red blue yellow\\", \\"red+blue=purple\\", \\"blue+yellow=green\\", \\"red+yellow=orange\\", \\"black+white=gray\\", \\"purple+green=brown\\", \\"blue+yellow=lime\\", \\"*\\" ]) assert mix_colors(base_colors, mixing_instructions) == [\\"purple\\", \\"green\\", \\"orange\\", \\"gray\\", \\"brown\\", \\"lime\\"] base_colors, mixing_instructions = process_input([ \\"red blue yellow\\", \\"*\\" ]) assert mix_colors(base_colors, mixing_instructions) == [] base_colors, mixing_instructions = process_input([ \\"\\", \\"red+blue=purple\\", \\"*\\" ]) assert mix_colors(base_colors, mixing_instructions) == [\\"purple\\"]","solution":"def mix_colors(base_colors, mixing_instructions): Returns the resulting set of colors after mixing the base colors according to the provided instructions. resulting_colors = [] seen_colors = set() for instruction in mixing_instructions: color1, rest = instruction.split('+') color2, mixedColor = rest.split('=') if mixedColor not in seen_colors: resulting_colors.append(mixedColor) seen_colors.add(mixedColor) return resulting_colors def process_input(input_lines): base_colors = input_lines[0].split() mixing_instructions = [] for line in input_lines[1:]: if line == '*': break mixing_instructions.append(line) return base_colors, mixing_instructions"},{"question":"def generate_sequence(n, a, b): Generates a sequence of length n using the specified recurrence relation. Parameters: n (int): Length of the sequence a (int): The first element of the sequence b (int): The second element of the sequence Returns: list: A list containing the generated sequence def parse_input(input_str): Parses the input string and generates output sequences for each dataset. Parameters: input_str (str): Input string containing multiple lines of datasets Returns: list: A list of output sequence strings for each dataset # Unit Tests def test_generate_sequence_example1(): assert generate_sequence(5, 3, 4) == [3, 4, 7, 11, 18] def test_generate_sequence_example2(): assert generate_sequence(7, 1, -1) == [1, -1, 0, -1, -1, -2, -3] def test_generate_sequence_example3(): assert generate_sequence(10, 0, 0) == [0, 0, 0, 0, 0, 0, 0, 0, 0, 0] def test_parse_input(): input_str = \\"5 3 4n7 1 -1n10 0 0n0 0 0n\\" expected_output = [\\"3 4 7 11 18\\", \\"1 -1 0 -1 -1 -2 -3\\", \\"0 0 0 0 0 0 0 0 0 0\\"] assert parse_input(input_str) == expected_output def test_parse_input_with_different_values(): input_str = \\"5 2 3n5 5 5n5 0 1n0 0 0n\\" expected_output = [\\"2 3 5 8 13\\", \\"5 5 10 15 25\\", \\"0 1 1 2 3\\"] assert parse_input(input_str) == expected_output","solution":"def generate_sequence(n, a, b): Generates a sequence of length n using the specified recurrence relation. Parameters: n (int): Length of the sequence a (int): The first element of the sequence b (int): The second element of the sequence Returns: list: A list containing the generated sequence sequence = [0] * n sequence[0] = a sequence[1] = b for i in range(2, n): sequence[i] = sequence[i - 1] + sequence[i - 2] return sequence def parse_input(input_str): Parses the input string and generates output sequences for each dataset. Parameters: input_str (str): Input string containing multiple lines of datasets Returns: list: A list of output sequence strings for each dataset lines = input_str.strip().split('n') result = [] for line in lines: n, a, b = map(int, line.split()) if n == 0 and a == 0 and b == 0: break sequence = generate_sequence(n, a, b) result.append(\\" \\".join(map(str, sequence))) return result"},{"question":"def min_classrooms(classes): Calculates the minimum number of classrooms needed to hold all classes without overlap. :param classes: List of tuples where each tuple contains start and end time of a class :returns: Integer representing the minimum number of classrooms needed >>> min_classrooms([(30, 75), (0, 50), (60, 150)]) 2 >>> min_classrooms([(0, 30), (5, 10), (15, 20), (20, 30)]) 2 >>> min_classrooms([(0, 50), (50, 100), (100, 150)]) 1 >>> min_classrooms([(0, 10), (10, 20), (20, 30)]) 1 >>> min_classrooms([(0, 30), (5, 20), (15, 40), (35, 50)]) 3 >>> min_classrooms([(0, 10), (5, 15), (10, 20), (15, 25)]) 2 >>> min_classrooms([]) 0","solution":"def min_classrooms(classes): Calculates the minimum number of classrooms needed to hold all classes without overlap. :param classes: List of tuples where each tuple contains start and end time of a class :returns: Integer representing the minimum number of classrooms needed if not classes: return 0 starts = sorted([start for start, end in classes]) ends = sorted([end for start, end in classes]) start_ptr, end_ptr = 0, 0 max_rooms, rooms_needed = 0, 0 while start_ptr < len(classes): if starts[start_ptr] < ends[end_ptr]: rooms_needed += 1 start_ptr += 1 max_rooms = max(max_rooms, rooms_needed) else: rooms_needed -= 1 end_ptr += 1 return max_rooms"},{"question":"def is_prime(num: int) -> bool: Helper function to check if a number is a prime. >>> is_prime(2) == True >>> is_prime(3) == True >>> is_prime(4) == False >>> is_prime(17) == True >>> is_prime(18) == False def can_be_expressed_as_sum_of_two_primes(n: int) -> str: Returns \\"YES\\" if n can be expressed as the sum of two prime numbers. Otherwise, returns \\"NO\\". >>> can_be_expressed_as_sum_of_two_primes(34) == \\"YES\\" >>> can_be_expressed_as_sum_of_two_primes(10) == \\"YES\\" >>> can_be_expressed_as_sum_of_two_primes(17) == \\"NO\\" >>> can_be_expressed_as_sum_of_two_primes(1) == \\"NO\\" >>> can_be_expressed_as_sum_of_two_primes(2) == \\"NO\\" >>> can_be_expressed_as_sum_of_two_primes(3) == \\"NO\\" >>> can_be_expressed_as_sum_of_two_primes(1000000) == \\"YES\\"","solution":"def is_prime(num): Helper function to check if a number is a prime. if num <= 1: return False if num == 2: return True if num % 2 == 0: return False for i in range(3, int(num**0.5) + 1, 2): if num % i == 0: return False return True def can_be_expressed_as_sum_of_two_primes(n): Returns \\"YES\\" if n can be expressed as the sum of two prime numbers. Otherwise, returns \\"NO\\". if n < 4: # The smallest sum of two primes is 2 + 2 = 4 return \\"NO\\" for prime in range(2, n//2 + 1): if is_prime(prime) and is_prime(n - prime): return \\"YES\\" return \\"NO\\""},{"question":"def maxSumSubarray(nums): Returns the maximum sum of any contiguous subarray within the array. >>> maxSumSubarray([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> maxSumSubarray([1, 2, 3, 4, -10]) 10 >>> maxSumSubarray([-2, -3, -1, -4]) -1 >>> maxSumSubarray([1, -3, 2, 1, -1]) 3 >>> maxSumSubarray([5]) 5 >>> maxSumSubarray([-5]) -5 >>> maxSumSubarray([]) 0","solution":"def maxSumSubarray(nums): Returns the maximum sum of any contiguous subarray within the array. if not nums: return 0 max_current = max_global = nums[0] for num in nums[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"def traffic_light_color(G, Y, R, T): Determines the color of the traffic light at time T seconds after they all turned green. Parameters: G (int): Duration of the green light in seconds. Y (int): Duration of the yellow light in seconds. R (int): Duration of the red light in seconds. T (int): The number of seconds after the lights turned green. Returns: str: The color of the traffic light (\\"green\\", \\"yellow\\", or \\"red\\"). Examples: >>> traffic_light_color(5, 3, 2, 7) \\"yellow\\" >>> traffic_light_color(10, 5, 7, 24) \\"green\\" >>> traffic_light_color(6, 4, 5, 10) \\"red\\" pass def process_queries(queries): Processes a list of traffic light queries. Parameters: queries (List[Tuple[int, int, int, int]]): List of tuples containing G, Y, R, T for each query. Returns: List[str]: List of results for each query indicating the color of the traffic light. Examples: >>> process_queries([(5, 3, 2, 7), (10, 5, 7, 24), (6, 4, 5, 10)]) [\\"yellow\\", \\"green\\", \\"red\\"] pass","solution":"def traffic_light_color(G, Y, R, T): Determines the color of the traffic light at time T seconds after they all turned green. Parameters: G (int): Duration of the green light in seconds. Y (int): Duration of the yellow light in seconds. R (int): Duration of the red light in seconds. T (int): The number of seconds after the lights turned green. Returns: str: The color of the traffic light (\\"green\\", \\"yellow\\", or \\"red\\"). cycle_duration = G + Y + R t_in_cycle = T % cycle_duration if t_in_cycle < G: return \\"green\\" elif t_in_cycle < G + Y: return \\"yellow\\" else: return \\"red\\" # Reading input from stdin and processing each query def process_queries(queries): results = [] for query in queries: G, Y, R, T = query results.append(traffic_light_color(G, Y, R, T)) return results"},{"question":"def climb_stairs(n): Returns the number of distinct ways to climb a staircase with n steps, if you can take either 1 or 2 steps at a time. >>> climb_stairs(0) 1 >>> climb_stairs(1) 1 >>> climb_stairs(2) 2 >>> climb_stairs(3) 3 >>> climb_stairs(4) 5 >>> climb_stairs(5) 8 >>> climb_stairs(10) 89","solution":"def climb_stairs(n): Returns the number of distinct ways to climb a staircase with n steps, if you can take either 1 or 2 steps at a time. # Base cases if n == 0: return 1 elif n == 1: return 1 # Use dynamic programming approach dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 for i in range(2, n + 1): dp[i] = dp[i - 1] + dp[i - 2] return dp[n]"},{"question":"def manipulate_list(nums): Manipulate a list of integers following specific rules. The task is to find the sum of all odd integers in the list and the product of all even integers. Based on these results, return a new list as follows: 1. If the sum of odd integers is greater than the product of even integers, reverse the original list. 2. If the product of even integers is greater than or equal to the sum of odd integers, double each even integer in the list and halve each odd integer. Parameters: nums (List[int]): List of integers to manipulate Returns: List[int]: The manipulated list based on the specified rules >>> manipulate_list([1, 2, 3, 4, 5]) [5, 4, 3, 2, 1] >>> manipulate_list([10, 1, 3, 5]) [20, 0.5, 1.5, 2.5] pass def process_test_cases(test_cases): Process multiple test cases to manipulate lists based on the specified rules. Parameters: test_cases (List[List[int]]): List of test cases where each test case is a list of integers Returns: List[List[int]]: A list of manipulated lists where each list corresponds to a test case >>> process_test_cases([[1, 2, 3, 4, 5], [10, 1, 3, 5]]) [[5, 4, 3, 2, 1], [20, 0.5, 1.5, 2.5]] pass def main(input_data): Main function to handle input and output for multiple test cases. Parameters: input_data (str): String containing the input data Returns: List[List[int]]: A list of manipulated lists where each list corresponds to a test case >>> input_data = \\"2n5n1 2 3 4 5n4n10 1 3 5\\" >>> main(input_data) [[5, 4, 3, 2, 1], [20, 0.5, 1.5, 2.5]] pass","solution":"def manipulate_list(nums): odd_sum = sum(num for num in nums if num % 2 != 0) even_product = 1 has_even = False for num in nums: if num % 2 == 0: even_product *= num if num != 0 else 1 has_even = True if not has_even: even_product = 0 if odd_sum > even_product: return nums[::-1] else: return [(num * 2 if num % 2 == 0 else num / 2) for num in nums] def process_test_cases(test_cases): results = [] for nums in test_cases: results.append(manipulate_list(nums)) return results def main(input_data): lines = input_data.strip().split('n') T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): N = int(lines[index]) nums = list(map(int, lines[index + 1].split())) test_cases.append(nums) index += 2 results = process_test_cases(test_cases) return results"},{"question":"def count_valid_pairs(arr): Counts the number of valid pairs (i, j) such that the bitwise AND of the elements at these positions equals zero. >>> count_valid_pairs([1, 2, 4, 8]) 6 >>> count_valid_pairs([1, 3, 7]) 0 # Write your code here def queries_number_of_valid_pairs(t, queries): For each query, returns the number of valid pairs (i, j) such that (b_i & b_j) = 0, modulo 10^9 + 7. >>> queries_number_of_valid_pairs(1, [(4, [1, 2, 4, 8])]) [6] >>> queries_number_of_valid_pairs(2, [(4, [1, 2, 4, 8]), (3, [1, 2, 3])]) [6, 1] # Write your code here def test_given_example(): t = 1 queries = [ (4, [1, 2, 4, 8]) ] assert queries_number_of_valid_pairs(t, queries) == [6] def test_no_pairs(): t = 1 queries = [ (3, [1, 3, 7]) ] assert queries_number_of_valid_pairs(t, queries) == [0] def test_large_input(): t = 1 queries = [ (4, [1, 2, 4, 7]) # Only (1&2)==0, (1&4)==0, (2&4)==0 ] assert queries_number_of_valid_pairs(t, queries) == [3] def test_large_numbers(): t = 1 queries = [ (3, [34359738368, 68719476736, 137438953472]) ] assert queries_number_of_valid_pairs(t, queries) == [3] def test_multiple_queries(): t = 2 queries = [ (4, [1, 2, 4, 8]), (3, [1, 2, 3]) ] assert queries_number_of_valid_pairs(t, queries) == [6, 1]","solution":"MOD = 10**9 + 7 def count_valid_pairs(arr): n = len(arr) count = 0 for i in range(n): for j in range(i + 1, n): if (arr[i] & arr[j]) == 0: count += 1 if count >= MOD: count -= MOD return count def queries_number_of_valid_pairs(t, queries): results = [] for i in range(t): n = queries[i][0] array = queries[i][1] results.append(count_valid_pairs(array)) return results"},{"question":"def find_top_student(test_cases): You are given a list of students with their respective marks in two subjects: Mathematics and Science. Your task is to find the student who has the maximum aggregate marks, where aggregate marks are calculated as the sum of Mathematics and Science marks. If there is a tie, the student with the highest Mathematics marks should be chosen. If there is still a tie, choose the student whose name comes first lexicographically. >>> find_top_student([[3, [[\\"Alice\\", \\"98\\", \\"99\\"], [\\"Bob\\", \\"95\\", \\"96\\"], [\\"Charlie\\", \\"99\\", \\"95\\"]]], [4, [[\\"David\\", \\"87\\", \\"92\\"], [\\"Eve\\", \\"91\\", \\"88\\"], [\\"Frank\\", \\"90\\", \\"91\\"], [\\"Gina\\", \\"92\\", \\"89\\"]]]]) [\\"Alice\\", \\"Gina\\"] >>> find_top_student([[1, [[\\"Anna\\", \\"95\\", \\"95\\"], [\\"Bob\\", \\"95\\", \\"95\\"]]]]) [\\"Anna\\"] >>> find_top_student([[1, [[\\"Zara\\", \\"95\\", \\"90\\"], [\\"Anna\\", \\"95\\", \\"90\\"], [\\"Bob\\", \\"95\\", \\"90\\"]]]]) [\\"Anna\\"] >>> find_top_student([[1, [[\\"Sam\\", \\"90\\", \\"90\\"]]]]) [\\"Sam\\"] >>> find_top_student([[1, [[\\"Charlie\\", \\"90\\", \\"90\\"], [\\"Alice\\", \\"90\\", \\"90\\"], [\\"Bob\\", \\"90\\", \\"90\\"]]]]) [\\"Alice\\"] >>> find_top_student([[1, [[\\"Alpha\\", \\"0\\", \\"0\\"], [\\"Beta\\", \\"0\\", \\"0\\"]]]]) [\\"Alpha\\"] def parse_input(input_string): Parsing input string for test cases. >>> parse_input(\\"2n3nAlice 98 99nBob 95 96nCharlie 99 95n4nDavid 87 92nEve 91 88nFrank 90 91nGina 92 89\\") [[3, [[\\"Alice\\", \\"98\\", \\"99\\"], [\\"Bob\\", \\"95\\", \\"96\\"], [\\"Charlie\\", \\"99\\", \\"95\\"]]], [4, [[\\"David\\", \\"87\\", \\"92\\"], [\\"Eve\\", \\"91\\", \\"88\\"], [\\"Frank\\", \\"90\\", \\"91\\"], [\\"Gina\\", \\"92\\", \\"89\\"]]]] def main(input_string): Main function to return the student with maximum aggregate marks for each test case. >>> main(\\"2n3nAlice 98 99nBob 95 96nCharlie 99 95n4nDavid 87 92nEve 91 88nFrank 90 91nGina 92 89\\") [\\"Alice\\", \\"Gina\\"]","solution":"def find_top_student(test_cases): results = [] for test_case in test_cases: n = test_case[0] students = test_case[1] top_student = None max_aggregate = -1 for student in students: name, math, science = student math, science = int(math), int(science) aggregate = math + science if (aggregate > max_aggregate or (aggregate == max_aggregate and (math > top_student[1] or (math == top_student[1] and name < top_student[0])))): top_student = (name, math, science, aggregate) max_aggregate = aggregate results.append(top_student[0]) return results def parse_input(input_string): lines = input_string.strip().split('n') T = int(lines[0]) test_cases = [] idx = 1 for _ in range(T): n = int(lines[idx]) students = [lines[i].split() for i in range(idx + 1, idx + n + 1)] test_cases.append((n, students)) idx += n + 1 return test_cases def main(input_string): test_cases = parse_input(input_string) return find_top_student(test_cases)"},{"question":"def longest_balanced_substring(S: str) -> int: Returns the length of the longest balanced substring of S. A string is called \\"balanced\\" if it consists of exactly the same number of characters 'A' and 'B'. >>> longest_balanced_substring(\\"AABBAA\\") 4 >>> longest_balanced_substring(\\"AAAA\\") 0 >>> longest_balanced_substring(\\"ABABAB\\") 6 >>> longest_balanced_substring(\\"AAABBB\\") 6 >>> longest_balanced_substring(\\"AABBABBA\\") 8 >>> longest_balanced_substring(\\"ABBAAABBBAAABBB\\") 14 >>> longest_balanced_substring(\\"AABAABBAABBBAAABBBABB\\") 20","solution":"def longest_balanced_substring(S): Returns the length of the longest balanced substring of S. max_length = 0 balance = 0 first_occurrence = {0: -1} for i, char in enumerate(S): if char == 'A': balance += 1 else: balance -= 1 if balance in first_occurrence: max_length = max(max_length, i - first_occurrence[balance]) else: first_occurrence[balance] = i return max_length"},{"question":"def is_happy_number(n: int) -> str: Returns YES if n is a happy number, otherwise NO. >>> is_happy_number(19) 'YES' >>> is_happy_number(20) 'NO'","solution":"def is_happy_number(n): Returns YES if n is a happy number, otherwise NO. def get_next_number(num): return sum(int(digit) ** 2 for digit in str(num)) seen_numbers = set() while n != 1 and n not in seen_numbers: seen_numbers.add(n) n = get_next_number(n) return \\"YES\\" if n == 1 else \\"NO\\""},{"question":"def minSprinklers(M: int, N: int, grid: List[str]) -> int: Determine the minimum number of sprinklers needed to water all fertile lands in a grid. >>> minSprinklers(3, 3, ['FFF', 'FBF', 'FFF']) 1 >>> minSprinklers(3, 3, ['FBF', 'BFB', 'FBF']) 5 >>> minSprinklers(2, 2, ['BB', 'BB']) 0 >>> minSprinklers(2, 2, ['FF', 'FF']) 1 >>> minSprinklers(1, 1, ['F']) 1 >>> minSprinklers(3, 3, ['FBB', 'BFB', 'BBF']) 3","solution":"def minSprinklers(M, N, grid): # Helper function to loop through and mark all connected 'F' cells def dfs(i, j): if i < 0 or i >= M or j < 0 or j >= N or grid[i][j] == 'B' or visited[i][j]: return visited[i][j] = True dfs(i + 1, j) dfs(i - 1, j) dfs(i, j + 1) dfs(i, j - 1) visited = [[False for _ in range(N)] for _ in range(M)] sprinklers = 0 # Loop through the grid to find all connected components of 'F' for i in range(M): for j in range(N): if grid[i][j] == 'F' and not visited[i][j]: # Found a new connected component, need at least 1 sprinkler sprinklers += 1 # Mark all cells in this component as visited dfs(i, j) return sprinklers"},{"question":"def tally_results(N: int, games: List[Tuple[int, int, int]]) -> List[Tuple[int, int]]: Returns the win and loss tally for each of the N teams. Parameters: N (int): Number of teams. games (list): List of tuples containing game results in the format (team_i, team_j, winner). Returns: list: A list of tuples, each tuple containing the number of wins and losses for each team from team 1 to team N. >>> tally_results(5, [(1, 2, 1), (1, 3, 1), (1, 4, 4), (1, 5, 1), (2, 3, 3), (2, 4, 2), (2, 5, 5), (3, 4, 3), (3, 5, 5), (4, 5, 5)]) [(3, 1), (1, 3), (2, 2), (1, 3), (3, 1)] >>> tally_results(2, [(1, 2, 1)]) [(1, 0), (0, 1)]","solution":"def tally_results(N, games): Returns the win and loss tally for each of the N teams. Parameters: N (int): Number of teams. games (list): List of tuples containing game results in the format (team_i, team_j, winner). Returns: list: A list of tuples, each tuple containing the number of wins and losses for each team from team 1 to team N. wins = [0] * N losses = [0] * N for game in games: team_i, team_j, winner = game if winner == team_i: wins[team_i - 1] += 1 losses[team_j - 1] += 1 elif winner == team_j: wins[team_j - 1] += 1 losses[team_i - 1] += 1 result = [(wins[i], losses[i]) for i in range(N)] return result # Example usage: N = 5 games = [ (1, 2, 1), (1, 3, 1), (1, 4, 4), (1, 5, 1), (2, 3, 3), (2, 4, 2), (2, 5, 5), (3, 4, 3), (3, 5, 5), (4, 5, 5) ] # Expected output: # [ # (3, 1), # (1, 3), # (2, 2), # (1, 3), # (3, 1) # ] print(tally_results(N, games))"},{"question":"def is_almost_sorted(n, a): Determines if the sequence 'a' is almost sorted with one element out of place. Parameters: n (int): The length of the sequence. a (list): The sequence of integers. Returns: str: \\"Yes\\" if the sequence is almost sorted, otherwise \\"No\\". Examples: >>> is_almost_sorted(6, [1, 2, 7, 4, 5, 6]) \\"Yes\\" >>> is_almost_sorted(6, [1, 2, 7, 6, 5, 4]) \\"No\\" >>> is_almost_sorted(5, [1, 2, 3, 4, 5]) \\"Yes\\" >>> is_almost_sorted(1, [0]) \\"Yes\\" >>> is_almost_sorted(2, [2, 1]) \\"Yes\\"","solution":"def is_almost_sorted(n, a): Determines if the sequence 'a' is almost sorted with one element out of place. Parameters: n (int): The length of the sequence. a (list): The sequence of integers. Returns: str: \\"Yes\\" if the sequence is almost sorted, otherwise \\"No\\". count_out_of_place = 0 out_of_place_index = -1 for i in range(1, n): if a[i] < a[i - 1]: count_out_of_place += 1 if count_out_of_place > 1: return \\"No\\" out_of_place_index = i if count_out_of_place == 0: return \\"Yes\\" if count_out_of_place == 1: # Check if removing or replacing the element at out_of_place_index fixes the list. def is_sorted_except_one_removal(index): candidate = a[:index] + a[index+1:] return all(candidate[i] <= candidate[i + 1] for i in range(len(candidate) - 1)) if is_sorted_except_one_removal(out_of_place_index) or is_sorted_except_one_removal(out_of_place_index - 1): return \\"Yes\\" return \\"No\\""},{"question":"def reverse_alphabetic_strings(strings: List[str]) -> Union[List[str], str]: This function takes a list of strings and returns a new list with the strings in reverse order. If any string contains non-alphabetic characters, the function returns an error message with the number of invalid entries. >>> reverse_alphabetic_strings(['apple', 'banana', 'cherry', 'date']) ['date', 'cherry', 'banana', 'apple'] >>> reverse_alphabetic_strings(['apple', 'banana2', 'cherry', 'd@te']) \\"There are 2 invalid entries: ['banana2', 'd@te']\\" >>> reverse_alphabetic_strings(['apple', 'b@nana', 'cherry', 'date', '1apple']) \\"There are 3 invalid entries: ['b@nana', '1apple']\\" >>> reverse_alphabetic_strings(['Apple', 'Banana', 'Cherry', 'Date']) ['Date', 'Cherry', 'Banana', 'Apple'] >>> reverse_alphabetic_strings(['apple', 'banana', 'Cherry', 'date']) ['date', 'Cherry', 'banana', 'apple'] >>> reverse_alphabetic_strings([]) \\"The list is empty.\\" >>> reverse_alphabetic_strings(['apple', 123, 'cherry', True]) \\"The list contains non-string items.\\" pass","solution":"def reverse_alphabetic_strings(strings): This function takes a list of strings and returns a new list with the strings in reverse order. If any string contains non-alphabetic characters, the function returns an error message with the number of invalid entries. if not strings: return \\"The list is empty.\\" if not all(isinstance(s, str) for s in strings): return \\"The list contains non-string items.\\" invalid_entries = [s for s in strings if not s.isalpha()] if invalid_entries: error_message = f\\"There {'are' if len(invalid_entries) > 1 else 'is'} {len(invalid_entries)} invalid entr{'ies' if len(invalid_entries) > 1 else 'y'}: {invalid_entries}\\" return error_message return strings[::-1]"},{"question":"def process_commands(commands): Process a list of commands to insert, delete, and query employees. Args: commands (list of str): The list of commands to be processed. Returns: list of str: The results of the query commands. pass # Example usage: # commands = [ # \\"INSERT 1 John 50000\\", # \\"INSERT 2 Alice 60000\\", # \\"QUERY 1\\", # \\"QUERY 3\\", # \\"INSERT 1 Michael 70000\\", # \\"QUERY 1\\", # \\"DELETE 2\\" # ] # print(process_commands(commands))","solution":"def process_commands(commands): Process a list of commands to insert, delete, and query employees. Args: commands (list of str): The list of commands to be processed. Returns: list of str: The results of the query commands. database = {} results = [] for command in commands: parts = command.split() action = parts[0] if action == \\"INSERT\\": employee_id = int(parts[1]) name = parts[2] salary = int(parts[3]) database[employee_id] = (name, salary) elif action == \\"DELETE\\": employee_id = int(parts[1]) if employee_id in database: del database[employee_id] elif action == \\"QUERY\\": employee_id = int(parts[1]) if employee_id in database: results.append(f\\"{database[employee_id][0]} {database[employee_id][1]}\\") else: results.append(\\"NOT FOUND\\") return results # Example usage: # commands = [ # \\"INSERT 1 John 50000\\", # \\"INSERT 2 Alice 60000\\", # \\"QUERY 1\\", # \\"QUERY 3\\", # \\"INSERT 1 Michael 70000\\", # \\"QUERY 1\\", # \\"DELETE 2\\" # ] # print(process_commands(commands))"},{"question":"def min_button_presses(t: int, cases: List[Tuple[str, str]]) -> List[int]: Determines the minimum number of button presses required to transform the initial sequence into the final sequence for multiple test cases. :param t: The number of test cases :param cases: List of tuples where each tuple contains two strings (initial_str, final_str) :return: List of integers representing the minimum number of button presses for each test case >>> t = 3 >>> cases = [ ... ('ab', 'abc'), ... ('abc', 'abcd'), ... ('ab', 'ac') ... ] >>> min_button_presses(t, cases) [1, 1, 1] >>> t = 2 >>> cases = [ ... ('abc', 'abc'), ... ('hello', 'hello') ... ] >>> min_button_presses(t, cases) [0, 0] >>> t = 2 >>> cases = [ ... ('a', 'b'), ... ('abc', 'xyz') ... ] >>> min_button_presses(t, cases) [1, 3] >>> t = 2 >>> cases = [ ... ('abcdef', 'abc'), ... ('abcd', 'abef') ... ] >>> min_button_presses(t, cases) [3, 2] >>> t = 2 >>> cases = [ ... ('a', 'abcd'), ... ('xy', 'xyzw') ... ] >>> min_button_presses(t, cases) [3, 2]","solution":"def min_button_presses(t, cases): Determines the minimum number of button presses required to transform the initial sequence into the final sequence for multiple test cases. :param t: The number of test cases :param cases: List of tuples where each tuple contains two strings (initial_str, final_str) :return: List of integers representing the minimum number of button presses for each test case results = [] for s, f in cases: len_s = len(s) len_f = len(f) # Find the point where the sequences differ i = 0 while i < min(len_s, len_f) and s[i] == f[i]: i += 1 if i == len_s and i == len_f: # Both sequences are already equal results.append(0) elif i == len_s: # All characters of \`s\` are part of \`f\` at the beginning results.append(len_f - len_s) else: # Replace the remaining characters of \`s\` to match \`f\` results.append(max(len_s, len_f) - i) return results"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def flatten(root): Flatten the binary tree to a linked list in-place. >>> root = TreeNode(1, TreeNode(2, TreeNode(3), TreeNode(4)), TreeNode(5, right=TreeNode(6))) >>> flatten(root) >>> tree_to_list(root) [1, 2, 3, 4, 5, 6] def tree_to_list(root): Convert the flattened binary tree to a list of values. >>> root = TreeNode(1, TreeNode(2, TreeNode(3), TreeNode(4)), TreeNode(5, right=TreeNode(6))) >>> flatten(root) >>> tree_to_list(root) [1, 2, 3, 4, 5, 6] result = [] while root: result.append(root.val) root = root.right return result","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def flatten(root): Flatten the binary tree to a linked list in-place. if not root: return None stack = [root] prev = None while stack: node = stack.pop() if prev: prev.right = node prev.left = None if node.right: stack.append(node.right) if node.left: stack.append(node.left) prev = node def tree_to_list(root): Convert the flattened binary tree to a list of values. result = [] while root: result.append(root.val) root = root.right return result"},{"question":"def generateSpiralMatrix(n): Generates an n x n spiral matrix. >>> generateSpiralMatrix(3) [ [1, 2, 3], [8, 9, 4], [7, 6, 5] ] >>> generateSpiralMatrix(4) [ [1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7] ] # Test cases def test_generateSpiralMatrix_3(): result = generateSpiralMatrix(3) expected = [ [1, 2, 3], [8, 9, 4], [7, 6, 5], ] assert result == expected def test_generateSpiralMatrix_4(): result = generateSpiralMatrix(4) expected = [ [1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7], ] assert result == expected def test_generateSpiralMatrix_1(): result = generateSpiralMatrix(1) expected = [ [1], ] assert result == expected def test_generateSpiralMatrix_0(): result = generateSpiralMatrix(0) expected = [] assert result == expected def test_generateSpiralMatrix_2(): result = generateSpiralMatrix(2) expected = [ [1, 2], [4, 3] ] assert result == expected","solution":"def generateSpiralMatrix(n): Generates an n x n spiral matrix. if n <= 0: return [] # Initialize the matrix with zeros matrix = [[0] * n for _ in range(n)] # Starting positions for the layer left, right, top, bottom = 0, n-1, 0, n-1 num = 1 while left <= right and top <= bottom: # Fill top row for i in range(left, right + 1): matrix[top][i] = num num += 1 top += 1 # Fill right column for i in range(top, bottom + 1): matrix[i][right] = num num += 1 right -= 1 # Fill bottom row if top <= bottom: for i in range(right, left - 1, -1): matrix[bottom][i] = num num += 1 bottom -= 1 # Fill left column if left <= right: for i in range(bottom, top - 1, -1): matrix[i][left] = num num += 1 left += 1 return matrix"},{"question":"from typing import List, Tuple, Dict def distinct_products_within_range(num_cases: int, cases: List[Dict]) -> List[int]: Given a list of sales transactions, each containing a product ID and a timestamp, determine the number of unique product IDs in a given time range. Arguments: num_cases : int : the number of test cases cases : List[Dict] : a list of dictionaries where each dictionary represents a test case. Each dictionary contains: - 'n' : int : the number of sales transactions - 'transactions' : List[Tuple[str, int]] : a list of tuples where each tuple contains a string (product ID) and an int (timestamp) - 'time_range': Tuple[int, int] : a tuple containing two integers, the start and end of the time range (inclusive) Returns: List[int] : a list of integers where each integer represents the number of distinct product IDs within the given time range for each test case >>> distinct_products_within_range(2, [{'n': 5, 'transactions': [('productA', 1), ('productB', 2), ('productC', 3), ('productA', 5), ('productB', 8)], 'time_range': (1, 5)}, {'n': 4, 'transactions': [('item1', 10), ('item2', 20), ('item3', 30), ('item1', 40)], 'time_range': (15, 35)}]) [3, 2] def parse_input(input_str: str) -> Tuple[int, List[Dict]]: Parses the input string and returns the number of test cases and the list of cases in the required format. Arguments: input_str : str : multiline string containing the input data in the specified format Returns: Tuple[int, List[Dict]] : a tuple containing the number of test cases and a list of dictionaries representing each case >>> parse_input(\\"2n5nproductA 1nproductB 2nproductC 3nproductA 5nproductB 8n1 5n4nitem1 10nitem2 20nitem3 30nitem1 40n15 35\\") (2, [{'n': 5, 'transactions': [('productA', 1), ('productB', 2), ('productC', 3), ('productA', 5), ('productB', 8)], 'time_range': (1, 5)}, {'n': 4, 'transactions': [('item1', 10), ('item2', 20), ('item3', 30), ('item1', 40)], 'time_range': (15, 35)}])","solution":"def distinct_products_within_range(num_cases, cases): results = [] for i in range(num_cases): n = cases[i]['n'] transactions = cases[i]['transactions'] start_time = cases[i]['time_range'][0] end_time = cases[i]['time_range'][1] unique_products = set() for product_id, timestamp in transactions: if start_time <= timestamp <= end_time: unique_products.add(product_id) results.append(len(unique_products)) return results # Sample input parser for the function def parse_input(input_str): lines = input_str.strip().split('n') idx = 0 T = int(lines[idx]) idx += 1 cases = [] for _ in range(T): N = int(lines[idx]) idx += 1 transactions = [] for _ in range(N): parts = lines[idx].split() product_id = parts[0] timestamp = int(parts[1]) transactions.append((product_id, timestamp)) idx += 1 time_range = tuple(map(int, lines[idx].split())) idx += 1 cases.append({ 'n': N, 'transactions': transactions, 'time_range': time_range }) return T, cases # Example usage: T, cases = parse_input(2 5 productA 1 productB 2 productC 3 productA 5 productB 8 1 5 4 item1 10 item2 20 item3 30 item1 40 15 35) results = distinct_products_within_range(T, cases) for result in results: print(result)"},{"question":"def longest_common_subsequence(str1: str, str2: str) -> str: Returns the longest common subsequence of two input strings. >>> longest_common_subsequence(\\"ABCBDAB\\", \\"BDCABC\\") \\"BCAB\\" >>> longest_common_subsequence(\\"ABC\\", \\"DEF\\") \\"\\" >>> longest_common_subsequence(\\"ABCDEF\\", \\"ACE\\") \\"ACE\\" >>> longest_common_subsequence(\\"ABC\\", \\"ABC\\") \\"ABC\\" >>> longest_common_subsequence(\\"\\", \\"ABC\\") \\"\\" >>> longest_common_subsequence(\\"ABC\\", \\"\\") \\"\\" >>> longest_common_subsequence(\\"\\", \\"\\") \\"\\"","solution":"def longest_common_subsequence(str1, str2): Returns the longest common subsequence of two input strings. m, n = len(str1), len(str2) dp = [[\\"\\" for _ in range(n+1)] for _ in range(m+1)] for i in range(1, m+1): for j in range(1, n+1): if str1[i-1] == str2[j-1]: dp[i][j] = dp[i-1][j-1] + str1[i-1] else: if len(dp[i-1][j]) > len(dp[i][j-1]): dp[i][j] = dp[i-1][j] else: dp[i][j] = dp[i][j-1] return dp[m][n]"},{"question":"def main(input_str: str) -> str: Given an input string that describes the number of test cases, and for each test case, the number of houses and roads, followed by the connecting roads and their lengths, determine the minimum total length of the roads that need to be decorated. Args: input_str (str): A multiline string containing the input details. Returns: str: The result for each test case as a multiline string. Example: >>> main(\\"1n4 5n1 2 3n2 3 4n3 4 5n4 1 2n1 3 7n\\") \\"9\\" >>> main(\\"3n4 5n1 2 3n2 3 4n3 4 5n4 1 2n1 3 7n5 7n1 2 1n2 3 2n3 4 3n4 5 4n1 5 5n1 3 6n2 4 7n3 3n1 2 10n2 3 15n1 3 5n\\") \\"9n10n15\\" pass # Unit tests def test_single_case(): input_str = \\"1n4 5n1 2 3n2 3 4n3 4 5n4 1 2n1 3 7n\\" output_str = \\"9\\" assert main(input_str) == output_str def test_multiple_cases(): input_str = \\"3n4 5n1 2 3n2 3 4n3 4 5n4 1 2n1 3 7n5 7n1 2 1n2 3 2n3 4 3n4 5 4n1 5 5n1 3 6n2 4 7n3 3n1 2 10n2 3 15n1 3 5n\\" output_str = \\"9n10n15\\" assert main(input_str) == output_str def test_minimal_case(): input_str = \\"1n2 1n1 2 1n\\" output_str = \\"1\\" assert main(input_str) == output_str def test_no_roads(): input_str = \\"1n1 0n\\" output_str = \\"0\\" assert main(input_str) == output_str def test_extra_case(): input_str = \\"1n3 3n1 2 10n2 3 15n1 3 5n\\" output_str = \\"15\\" assert main(input_str) == output_str","solution":"def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def kruskal_minimum_spanning_tree(n, edges): result = [] # This will store the resultant MST i = 0 # An index variable for sorted edges e = 0 # An index variable for result[] # Step 1: Sort all edges in non-decreasing order of their weight. edges = sorted(edges, key=lambda item: item[2]) parent = [] rank = [] for node in range(n): parent.append(node) rank.append(0) while e < n - 1: u, v, w = edges[i] i += 1 x = find(parent, u - 1) y = find(parent, v - 1) if x != y: e += 1 result.append([u, v, w]) union(parent, rank, x, y) minimum_cost = 0 for u, v, weight in result: minimum_cost += weight return minimum_cost def minimum_roads_to_decorate(t, test_cases): results = [] for n, m, roads in test_cases: results.append(kruskal_minimum_spanning_tree(n, roads)) return results def process_input(input_str): input_lines = input_str.strip().split(\\"n\\") current_line = 0 t = int(input_lines[current_line].strip()) current_line += 1 test_cases = [] for _ in range(t): n, m = map(int, input_lines[current_line].strip().split()) current_line += 1 roads = [] for _ in range(m): u, v, w = map(int, input_lines[current_line].strip().split()) current_line += 1 roads.append((u, v, w)) test_cases.append((n, m, roads)) return t, test_cases def main(input_str): t, test_cases = process_input(input_str) results = minimum_roads_to_decorate(t, test_cases) return \\"n\\".join(map(str, results))"},{"question":"def min_removals_to_unique_stories(n: int, stories: List[str]) -> int: Determine the minimum number of words to be removed to ensure all remaining words in the combined sequence of stories are unique. >>> min_removals_to_unique_stories(3, [\\"hello world\\", \\"hello instabook\\", \\"world wide web\\"]) 2 >>> min_removals_to_unique_stories(2, [\\"a quick brown fox\\", \\"jumps over the lazy dog\\"]) 0 >>> min_removals_to_unique_stories(4, [\\"good morning\\", \\"good night\\", \\"good evening\\", \\"hello good\\"]) 3 >>> min_removals_to_unique_stories(3, [\\"abc xyz\\", \\"def uvw\\", \\"ghij klmn\\"]) 0 >>> min_removals_to_unique_stories(2, [\\"same story\\", \\"same story\\"]) 2","solution":"def min_removals_to_unique_stories(n, stories): word_count = {} # Count how many times each word appears for story in stories: words = story.split() for word in words: if word in word_count: word_count[word] += 1 else: word_count[word] = 1 # Calculate the number of words to be removed to make all words unique removals = 0 for count in word_count.values(): if count > 1: removals += count - 1 return removals"},{"question":"def minimum_tax_after_one_cut(n: int, heights: List[int]) -> int: Returns the minimum tax (height of the tallest remaining tree) after cutting down at most one tree. Parameters: n (int): The number of trees. heights (list): A list of tree heights. Returns: int: The minimum tax after cutting down one tree. pass from solution import minimum_tax_after_one_cut def test_example_case(): assert minimum_tax_after_one_cut(5, [2, 3, 9, 7, 4]) == 7 def test_two_trees_case(): assert minimum_tax_after_one_cut(2, [5, 10]) == 5 def test_all_trees_same_height(): assert minimum_tax_after_one_cut(4, [6, 6, 6, 6]) == 6 def test_decreasing_heights(): assert minimum_tax_after_one_cut(4, [10, 9, 8, 7]) == 9 def test_increasing_heights(): assert minimum_tax_after_one_cut(4, [1, 2, 3, 4]) == 3 def test_random_heights(): assert minimum_tax_after_one_cut(6, [10, 20, 15, 25, 18, 30]) == 25 def test_single_maximum_tree(): assert minimum_tax_after_one_cut(5, [1, 2, 3, 4, 5]) == 4 assert minimum_tax_after_one_cut(5, [5, 4, 3, 2, 1]) == 4","solution":"def minimum_tax_after_one_cut(n, heights): Returns the minimum tax (height of the tallest remaining tree) after cutting down at most one tree. Parameters: n (int): The number of trees. heights (list): A list of tree heights. Returns: int: The minimum tax after cutting down one tree. if n == 2: return min(heights) # If there are only 2 trees, remove the taller one. sorted_heights = sorted(heights[:]) first_max = sorted_heights[-1] # Tallest tree second_max = sorted_heights[-2] # Second tallest tree min_tax = first_max for i in range(n): # If the current tree is the tallest, the tallest remaining becomes second_max if heights[i] == first_max: min_tax = min(min_tax, second_max) # Otherwise the tallest remaining tree is still first_max else: min_tax = min(min_tax, first_max) return min_tax"},{"question":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key def insert(root, key): if root is None: return TreeNode(key) if key < root.val: root.left = insert(root.left, key) else: root.right = insert(root.right, key) return root def sum_bst(root): if root is None: return 0 return root.val + sum_bst(root.left) + sum_bst(root.right) def calculate_sums(test_cases): Given a list of test cases where each test case consists of an integer representing the number of elements and a list of unique integers representing the sequence of elements to be inserted into a BST, return a list of sums of all values stored in the BST for each test case. Example: >>> calculate_sums([(5, [10, 20, 30, 40, 50])]) [150] >>> calculate_sums([(3, [5, 3, 8])]) [16] results = [] for n, elements in test_cases: root = None for element in elements: root = insert(root, element) results.append(sum_bst(root)) return results # Unit Tests def test_single_element(): assert calculate_sums([(1, [1])]) == [1] def test_multiple_elements_linear(): assert calculate_sums([(5, [10, 20, 30, 40, 50])]) == [150] def test_multiple_elements_bst(): assert calculate_sums([(3, [5, 3, 8])]) == [16] def test_empty(): assert calculate_sums([(0, [])]) == [0] def test_varied_input(): input_data = [ (5, [10, 20, 30, 40, 50]), (3, [5, 3, 8]), (4, [25, 15, 50, 10]) ] expected_output = [150, 16, 100] assert calculate_sums(input_data) == expected_output","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key def insert(root, key): if root is None: return TreeNode(key) if key < root.val: root.left = insert(root.left, key) else: root.right = insert(root.right, key) return root def sum_bst(root): if root is None: return 0 return root.val + sum_bst(root.left) + sum_bst(root.right) def calculate_sums(test_cases): results = [] for n, elements in test_cases: root = None for element in elements: root = insert(root, element) results.append(sum_bst(root)) return results # Example input and usage: test_cases = [ (5, [10, 20, 30, 40, 50]), (3, [5, 3, 8]) ] print(calculate_sums(test_cases)) # Output: [150, 16]"}]`),E={name:"App",components:{PoemCard:R},data(){return{searchQuery:"",visibleCount:4,poemsData:S,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},D={class:"search-container"},j={class:"card-container"},C={key:0,class:"empty-state"},P=["disabled"],z={key:0},I={key:1};function F(r,e,u,c,i,a){const p=h("PoemCard");return s(),n("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",D,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),g(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>i.searchQuery=o),placeholder:"Search..."},null,512),[[b,i.searchQuery]]),i.searchQuery?(s(),n("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>i.searchQuery="")}," ✕ ")):l("",!0)]),t("div",j,[(s(!0),n(x,null,y(a.displayedPoems,(o,f)=>(s(),v(p,{key:f,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(s(),n("div",C,' No results found for "'+d(i.searchQuery)+'". ',1)):l("",!0)]),a.hasMorePoems?(s(),n("button",{key:0,class:"load-more-button",disabled:i.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[i.isLoading?(s(),n("span",I,"Loading...")):(s(),n("span",z,"See more"))],8,P)):l("",!0)])}const M=_(E,[["render",F],["__scopeId","data-v-b986d8b7"]]),B=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"library/32.md","filePath":"library/32.md"}'),O={name:"library/32.md"},G=Object.assign(O,{setup(r){return(e,u)=>(s(),n("div",null,[w(M)]))}});export{B as __pageData,G as default};
