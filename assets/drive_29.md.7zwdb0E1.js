import{_ as h,o as n,c as i,a as t,m as c,t as d,C as g,M as _,U as y,f as u,F as b,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},I={class:"review-title"},E={class:"review-content"};function A(r,e,l,p,s,a){return n(),i("div",T,[t("div",q,[t("div",I,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),c(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",E,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),c(d(l.poem.solution),1)])])])}const C=h(k,[["render",A],["__scopeId","data-v-d66305f0"]]),N=JSON.parse('[{"question":"# Coding Assessment Question Scenario Imagine you are working on a robot automation system. One of the tasks involves guiding the robot through a path, represented as a grid of cells. Each cell in the grid has a specific energy cost associated with moving through it. The robot starts at the top-left cell and needs to reach the bottom-right cell. The robot can only move either down or right at any point in time. Your job is to determine the minimum energy cost required for the robot to reach the bottom-right cell from the top-left cell. Task Write a function `min_energy_cost` that computes the minimum energy cost for the robot to travel from the top-left cell to the bottom-right cell in a given grid. Requirements 1. If the grid is empty, raise a `ValueError` with the message \\"Grid is empty\\". 2. If any cell in the grid has an energy cost less than 0, raise a `ValueError` with the message \\"Energy cost cannot be negative\\". Function Signature ```python def min_energy_cost(grid: List[List[int]]) -> int: pass ``` Inputs - `grid` (List[List[int]]): A 2D list where each element is a non-negative integer representing the energy cost of that cell. Output - (int): The minimum energy cost to travel from the top-left cell to the bottom-right cell. Constraints - The grid will have at least 1 row and 1 column. - Each cell in the grid will contain a non-negative integer. Example ```python >>> min_energy_cost([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_energy_cost([[1, 2, 3], [4, 5, 6]]) 12 >>> min_energy_cost([]) Traceback (most recent call last): ... ValueError: Grid is empty >>> min_energy_cost([[1, -1, 3], [4, 5, 6]]) Traceback (most recent call last): ... ValueError: Energy cost cannot be negative ``` Implement this function ensuring it handles all edge cases and constraints as specified.","solution":"from typing import List def min_energy_cost(grid: List[List[int]]) -> int: if not grid or not grid[0]: raise ValueError(\\"Grid is empty\\") rows, cols = len(grid), len(grid[0]) for row in grid: if any(cell < 0 for cell in row): raise ValueError(\\"Energy cost cannot be negative\\") # Create a DP table to store the minimum energy cost at each cell dp = [[0] * cols for _ in range(rows)] dp[0][0] = grid[0][0] # Initialize the first row for j in range(1, cols): dp[0][j] = dp[0][j - 1] + grid[0][j] # Initialize the first column for i in range(1, rows): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill in the rest of the dp table for i in range(1, rows): for j in range(1, cols): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] return dp[rows - 1][cols - 1]"},{"question":"# Minimal Roman Numeral Conversion **Context**: Roman numerals are a numeric system used in ancient Rome. The basic symbols are: - `I` (1) - `V` (5) - `X` (10) - `L` (50) - `C` (100) - `D` (500) - `M` (1000) When smaller symbols appear before larger ones, they are subtracted (e.g., `IV` for 4, `IX` for 9). When they appear after, they\'re added (e.g., `VI` for 6, `XIII` for 13). **Prompt**: Create a function to convert a given integer into its smallest possible Roman numeral equivalent. Focus on understanding Roman numeral rules and how to structure the conversion algorithm efficiently. **Function Signature**: ```python def int_to_roman(num: int) -> str: Converts an integer to its Roman numeral representation. :param num: The integer to convert (1 ≤ num ≤ 3999) :return: A string representing the Roman numeral form of the given integer ``` # Requirements: 1. **Input**: A single integer `num` in the range from 1 to 3999 inclusive. 2. **Output**: A string that represents the Roman numeral of `num`. 3. Use dictionaries or lists to map integer values to their Roman numeral counterparts for efficient conversion. 4. Ensure correct handling of subtractive combinations in the numeral system (e.g., `IV`, `IX`, `XL`, etc.). # Examples: ```python >>> int_to_roman(1994) \'MCMXCIV\' >>> int_to_roman(58) \'LVIII\' >>> int_to_roman(9) \'IX\' >>> int_to_roman(14) \'XIV\' ``` # Constraints: 1. Your code should use a dictionary or list to store Roman numeral mappings. 2. Implement the logic in a clear, readable, and well-structured manner. 3. The function must follow best practices for efficiency considering the constraints.","solution":"def int_to_roman(num: int) -> str: Converts an integer to its Roman numeral representation. :param num: The integer to convert (1 ≤ num ≤ 3999) :return: A string representing the Roman numeral form of the given integer value_map = [ (1000, \'M\'), (900, \'CM\'), (500, \'D\'), (400, \'CD\'), (100, \'C\'), (90, \'XC\'), (50, \'L\'), (40, \'XL\'), (10, \'X\'), (9, \'IX\'), (5, \'V\'), (4, \'IV\'), (1, \'I\') ] roman_numeral = \'\' for value, symbol in value_map: while num >= value: roman_numeral += symbol num -= value return roman_numeral"},{"question":"# **Array Rotation and Sum Calculation** Given an array of integers, you are required to perform the following operations: 1. Rotate the array to the right by `k` places. 2. Calculate the sum of the elements of the rotated array. Implement a function `rotate_and_sum(arr: List[int], k: int) -> Tuple[List[int], int]` that performs these operations. **Task** 1. Rotate the array `arr` to the right by `k` places. 2. Calculate the sum of the elements of the rotated array. 3. Return a tuple containing the rotated array and the sum. **Function Signature** ```python from typing import List, Tuple def rotate_and_sum(arr: List[int], k: int) -> Tuple[List[int], int]: pass ``` Input - `arr`: A list of integers (1 <= len(arr) <= 10^5). - `k`: An integer representing the number of positions to rotate the array (0 <= k <= 10^5). Output - A tuple containing the rotated array and the sum of its elements. Constraints - The elements of the array are integers within the range [-10^5, 10^5]. Examples ```python >>> rotate_and_sum([1, 2, 3, 4, 5], 2) ([4, 5, 1, 2, 3], 15) >>> rotate_and_sum([0, -1, -2, -3], 1) ([-3, 0, -1, -2], -6) >>> rotate_and_sum([10, 20, 30], 3) ([10, 20, 30], 60) ``` **Note** - Ensure the rotation logic handles cases where `k` is larger than the length of the array efficiently. - Focus on both optimizing the rotation step and the summation for large input sizes. - Edge cases such as an array with a single element or an empty array should be considered.","solution":"from typing import List, Tuple def rotate_and_sum(arr: List[int], k: int) -> Tuple[List[int], int]: if not arr: # Handling empty array edge case return arr, 0 n = len(arr) k = k % n # To handle cases where k is larger than n rotated_array = arr[-k:] + arr[:-k] array_sum = sum(rotated_array) return rotated_array, array_sum"},{"question":"# Scenario You are a software engineer responsible for creating an API for a new e-commerce platform. This API needs an efficient system to handle the inventory of products using various operations. To ensure the system\'s quality, the operations will be tested extensively. # Task Implement the following inventory operations as specified: 1. `add_product(inventory, product_name, quantity)`: Adds a specified quantity of a product to the inventory. 2. `remove_product(inventory, product_name, quantity)`: Removes a specified quantity of a product from the inventory. 3. `get_product_quantity(inventory, product_name)`: Returns the current quantity of a specified product in the inventory. 4. `list_inventory(inventory)`: Returns a list of products and their quantities sorted alphabetically by product name. # Specifications - **Input**: - `add_product`, `remove_product`: A dictionary `inventory` where keys are product names and values are quantities, a string `product_name`, and an integer `quantity`. - `get_product_quantity`: A dictionary `inventory` and a string `product_name`. - `list_inventory`: A dictionary `inventory`. - **Output**: - The modified `inventory` dictionary for `add_product` and `remove_product`. - The quantity of the specified product for `get_product_quantity`. - A list of tuples `(product_name, quantity)` sorted alphabetically for `list_inventory`. # Example Implementations ```python def add_product(inventory, product_name, quantity): # Implement logic for adding product to inventory pass def remove_product(inventory, product_name, quantity): # Implement logic for removing product from inventory pass def get_product_quantity(inventory, product_name): # Implement logic for getting product quantity pass def list_inventory(inventory): # Implement logic for listing inventory pass ``` # Constraints - You should handle invalid input cases gracefully by raising appropriate exceptions, such as `ValueError` for invalid quantity (e.g., below 0) or if the `product_name` does not exist in the inventory when removing or retrieving quantities. - Ensure that your solutions are efficient and follow best practices. - Quantities for products should be non-negative integers. # Performance Requirements - The time complexity should be kept as low as practical within the constraints of typical use cases. - Your code will be tested for efficiency and should handle reasonably large inventories (e.g., 10,000 products) within acceptable time limits.","solution":"def add_product(inventory, product_name, quantity): Adds a specified quantity of a product to the inventory. Parameters: inventory (dict): The inventory dictionary. product_name (str): The name of the product to add. quantity (int): The quantity to add. Returns: dict: The updated inventory dictionary. if quantity < 0: raise ValueError(\\"Quantity cannot be negative.\\") if product_name in inventory: inventory[product_name] += quantity else: inventory[product_name] = quantity return inventory def remove_product(inventory, product_name, quantity): Removes a specified quantity of a product from the inventory. Parameters: inventory (dict): The inventory dictionary. product_name (str): The name of the product to remove. quantity (int): The quantity to remove. Returns: dict: The updated inventory dictionary. if quantity < 0: raise ValueError(\\"Quantity cannot be negative.\\") if product_name not in inventory: raise ValueError(\\"Product does not exist in inventory.\\") if inventory[product_name] < quantity: raise ValueError(\\"Not enough quantity in inventory to remove.\\") inventory[product_name] -= quantity if inventory[product_name] == 0: del inventory[product_name] return inventory def get_product_quantity(inventory, product_name): Returns the current quantity of a specified product in the inventory. Parameters: inventory (dict): The inventory dictionary. product_name (str): The name of the product to get the quantity of. Returns: int: The quantity of the product. if product_name not in inventory: raise ValueError(\\"Product does not exist in inventory.\\") return inventory[product_name] def list_inventory(inventory): Returns a list of products and their quantities sorted alphabetically by product name. Parameters: inventory (dict): The inventory dictionary. Returns: list: A list of tuples (product_name, quantity) sorted alphabetically. return sorted(inventory.items())"},{"question":"# Coding Question: Recursive Pascal\'s Triangle with Memoization Background Pascal\'s Triangle is a triangular array of the binomial coefficients. The rows of Pascal\'s Triangle correspond to the powers of 11. The value at the nth row and kth column in Pascal\'s Triangle, say `P(n, k)`, is equal to `P(n-1, k-1) + P(n-1, k)` where `P(n, 0) = 1` and `P(n, n) = 1`. Task Improve the recursive function generating Pascal\'s Triangle by implementing a memoized version. This optimized solution should cache previously computed results to reduce the time complexity for subsequent calculations. Implement a function `pascal_triangle_memoized` that leverages a dictionary to store intermediate results. Function Signature ```python def pascal_triangle_memoized(n: int, memo: dict[tuple[int, int], int] = {}) -> list[int]: Generate the nth row of Pascal\'s Triangle using memoization to optimize performance. :param n: The row index (0-based) of Pascal\'s Triangle. :param memo: A dictionary to store previously computed values of Pascal\'s Triangle. :return: A list containing the binomial coefficients in the nth row of Pascal\'s Triangle. pass ``` Constraints 1. `0 <= n <= 20` 2. The function `pascal_triangle_memoized` must use a memo to store and reuse results of precomputed values. Example ```python >>> pascal_triangle_memoized(0) [1] >>> pascal_triangle_memoized(1) [1, 1] >>> pascal_triangle_memoized(4) [1, 4, 6, 4, 1] >>> pascal_triangle_memoized(6) [1, 6, 15, 20, 15, 6, 1] ``` Write a solution that returns the nth row of Pascal\'s Triangle as a list, utilizing memoization for optimization.","solution":"def pascal_triangle_memoized(n: int, memo: dict = None) -> list[int]: if memo is None: memo = {} def get_pascal_value(row: int, col: int) -> int: if (row, col) in memo: return memo[(row, col)] if col == 0 or col == row: return 1 memo[(row, col)] = get_pascal_value(row - 1, col - 1) + get_pascal_value(row - 1, col) return memo[(row, col)] return [get_pascal_value(n, k) for k in range(n + 1)]"},{"question":"# Path Sum in Binary Tree Problem Statement You are given a binary tree where each node contains an integer value. You need to determine if the tree has a root-to-leaf path such that adding up all the values along the path equals a given sum. Given a `TreeNode` class from which nodes of the binary tree are constructed, create a function `has_path_sum(root: TreeNode, target_sum: int) -> bool` that returns `True` if such a path exists, otherwise `False`. Input Format - `root`: The root node of the binary tree. - `target_sum`: An integer representing the sum to be checked along a path from the root to any leaf. Output Format - A boolean value: - `True` if there exists a root-to-leaf path with the given sum. - `False` otherwise. Constraints - The number of nodes in the binary tree is between `1` and `10^4`. - Node values are integers between `-10^4` and `10^4`. Examples 1. For the given tree and sum: ``` 5 / 4 8 / / 11 13 4 / 7 2 1 ``` `has_path_sum(root, 22)` returns `True` because the path `5 -> 4 -> 11 -> 2` equals `22`. 2. For the given tree and sum: ``` 1 / 2 3 ``` `has_path_sum(root, 5)` returns `False`. 3. For the given tree and sum: ``` 1 / 2 3 7 ``` `has_path_sum(root, 10)` returns `True` because the path `1 -> 3 -> 7` equals `11`. Python Implementation ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def has_path_sum(root: TreeNode, target_sum: int) -> bool: if not root: return False target_sum -= root.val if not root.left and not root.right: # if it\'s a leaf return target_sum == 0 return has_path_sum(root.left, target_sum) or has_path_sum(root.right, target_sum) ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def has_path_sum(root: TreeNode, target_sum: int) -> bool: if not root: return False target_sum -= root.val if not root.left and not root.right: # if it\'s a leaf return target_sum == 0 return has_path_sum(root.left, target_sum) or has_path_sum(root.right, target_sum)"},{"question":"# Palindrome Substrings Finder You are tasked with creating a function that finds all distinct palindromic substrings in a given string. This will help solidify your understanding of string manipulations and dynamic programming concepts. Function Definition: 1. **find_palindromes(s: str) -> list[str]** This function should return all distinct palindromic substrings within the input string. - **Input**: `s` (str) – The string in which to find palindromic substrings. - **Output**: A list of distinct palindromic substrings sorted in lexicographical order. Constraints: - The length of the string `s` should be between 1 and 1000 inclusive. - The palindromic substrings should be case-sensitive, meaning \\"Aba\\" and \\"aba\\" are considered different substrings. Example Output: For `find_palindromes(\\"ababa\\")`, one possible output might look like: ```python palindromes = find_palindromes(\\"ababa\\") print(palindromes) # [\'a\', \'aba\', \'ababa\', \'b\', \'bab\'] ``` Context: This function is useful in text analysis and understanding symmetrical patterns within strings, which has applications in fields such as computational biology and cryptography. --- This new question focuses on string manipulation and dynamic programming, introducing a different but related concept within typical coding assessments. The complexity and structure align with the existing RSA question, challenging candidates to think algorithmically about substring identification and storage.","solution":"def find_palindromes(s: str) -> list[str]: def expand_around_center(left: int, right: int): while left >= 0 and right < len(s) and s[left] == s[right]: palindromes.add(s[left:right+1]) left -= 1 right += 1 palindromes = set() for i in range(len(s)): # Odd length palindromes expand_around_center(i, i) # Even length palindromes expand_around_center(i, i + 1) return sorted(palindromes)"},{"question":"# Question: Sum of Unique Elements in an Array Scenario You are given an array of integers and are tasked with developing a function that calculates the sum of all unique elements in the array. A unique element is defined as an element that appears exactly once in the array. Task Implement a function `sum_unique_elements(arr: List[int]) -> int` that returns the sum of all unique elements in the provided array. Input * `arr` (List[int]): A list of integers. Constraints: 1 ≤ len(arr) ≤ 1000, -10^4 ≤ arr[i] ≤ 10^4 Output * Returns an integer representing the sum of all unique elements in the array. Example ```python >>> sum_unique_elements([1, 2, 2, 3, 4, 4, 5]) 9 >>> sum_unique_elements([1, 1, 1, 1, 1]) 0 >>> sum_unique_elements([10, 20, 10, 30, 40, 50]) 140 ``` Constraints * Handle arrays with all unique elements. * Handle arrays where no elements are unique. Additional Notes * Consider edge cases such as an empty array or an array with only one element. * Ensure the solution is efficient and can handle the given input constraints.","solution":"from typing import List from collections import Counter def sum_unique_elements(arr: List[int]) -> int: Calculates the sum of unique elements in the array. Parameters: arr (List[int]): List of integers. Returns: int: Sum of unique elements. element_count = Counter(arr) # Count occurrences of each element unique_elements = [element for element, count in element_count.items() if count == 1] return sum(unique_elements)"},{"question":"# Coding Assessment Question Context As part of the traffic management system, you are tasked with evaluating the efficiency of different routes based on traffic data. Each route between two points is represented as a weighted directed graph where nodes represent intersections and edges represent roads with a given travel time. Your task is to find the shortest travel time from a start intersection to an end intersection using Dijkstra\'s algorithm. Task Write a function `find_shortest_path` that, given a graph representing intersection routes, the starting intersection, and the ending intersection, computes the shortest travel time from the start to the end using Dijkstra\'s algorithm. # Function Signature ```python def find_shortest_path( graph: Dict[int, List[Tuple[int, float]]], start: int, end: int ) -> float: Computes the shortest travel time from start intersection to end intersection using Dijkstra\'s algorithm. Args: graph: A dictionary where keys are integers representing intersections, and values are lists of tuples. Each tuple contains two elements: an integer representing a connected intersection, and a float representing the travel time to that intersection. start: An integer representing the starting intersection. end: An integer representing the ending intersection. Returns: float: The shortest travel time from the start intersection to the end intersection. If there is no valid path from start to end, return float(\'inf\'). ``` # Input and Output Format - **Input**: - `graph`: A dictionary where the keys are intersection identifiers and the values are lists of tuples. Each tuple contains an integer (a neighboring intersection) and a float (travel time to that neighbor). - `start`: An integer representing the starting intersection. - `end`: An integer representing the ending intersection. - **Output**: - A float value representing the shortest travel time from the `start` intersection to the `end` intersection. If there is no valid path, return `float(\'inf\')`. # Constraints - The number of intersections (`len(graph)`) will be in the range `[2, 1000]`. - The graph may contain cycles. - Travel times will be positive floats. # Example ```python graph = { 0: [(1, 10.0), (2, 5.0)], 1: [(2, 2.0), (3, 1.0)], 2: [(1, 3.0), (3, 9.0), (4, 2.0)], 3: [(4, 4.0)], 4: [(3, 6.0)] } start = 0 end = 4 shortest_time = find_shortest_path(graph, start, end) print(shortest_time) # Expected output: 7.0 (0 -> 2 -> 4) ``` # Notes - Utilize a priority queue (min-heap) to implement Dijkstra\'s algorithm efficiently. - Make sure to handle cases where there is no path from the start intersection to the end intersection. Hints 1. Use a priority queue to always expand the closest unvisited node. 2. Keep track of the shortest travel times to each node found so far and update them as needed. 3. Ensure all nodes are visited and consistently update their travel time records until you reach the end node or exhaust all possible routes.","solution":"import heapq def find_shortest_path(graph, start, end): Computes the shortest travel time from start intersection to end intersection using Dijkstra\'s algorithm. Args: graph: A dictionary where keys are integers representing intersections, and values are lists of tuples. Each tuple contains two elements: an integer representing a connected intersection, and a float representing the travel time to that intersection. start: An integer representing the starting intersection. end: An integer representing the ending intersection. Returns: float: The shortest travel time from the start intersection to the end intersection. If there is no valid path from start to end, return float(\'inf\'). # Initialize the priority queue (min-heap) and the shortest path tracker pq = [(0, start)] # (travel_time, intersection) shortest_paths = {start: 0} while pq: current_time, current_node = heapq.heappop(pq) # If we reached the end node, return the time if current_node == end: return current_time # If the time is greater than the current shortest path, continue if current_time > shortest_paths[current_node]: continue # Explore neighbors for neighbor, travel_time in graph.get(current_node, []): time = current_time + travel_time if time < shortest_paths.get(neighbor, float(\'inf\')): shortest_paths[neighbor] = time heapq.heappush(pq, (time, neighbor)) return float(\'inf\') # If we exhaust all options without finding the end"},{"question":"Depth-First Search: Graph Traversal Scenario You are required to implement Depth-First Search (DFS) for graph traversal. Given an undirected graph represented as an adjacency list, you need to implement a function that performs a DFS traversal starting from a given node and returns the list of nodes in the order they were visited. Input and Output * Input: * An integer `n` representing the number of nodes in the graph. * A list of tuples representing the edges of the graph. Each tuple `(u, v)` signifies an undirected edge between nodes `u` and `v`. * An integer `start` representing the starting node for the DFS traversal. * Output: * A list of integers representing the nodes in the order they were visited during the DFS traversal. Constraints * The graph is connected. * The graph will have at least one node and at most 100 nodes. * There will be at least 0 and at most 1000 edges. * Nodes are numbered from 0 to `n-1`. * Each edge is represented as a tuple `(u, v)` where `u` and `v` are node numbers. Implementation Details * You must implement the DFS traversal method. * Handle edge cases such as graphs with isolated nodes properly. Function Definition ```python def dfs_traversal(n: int, edges: list[tuple[int, int]], start: int) -> list[int]: Perform DFS traversal on an undirected graph. Args: n (int): Number of nodes in the graph. edges (list[tuple[int, int]]): Edges of the graph as tuples of two nodes. start (int): Starting node for the traversal. Returns: list[int]: List of nodes in the order they were visited. # Implementation goes here ``` Example ```python # Example 1: n = 5 edges = [(0, 1), (0, 2), (1, 3), (1, 4)] start = 0 print(dfs_traversal(n, edges, start)) # Output: [0, 1, 3, 4, 2] # Example 2: n = 4 edges = [(0, 1), (0, 2), (1, 2), (2, 3)] start = 1 print(dfs_traversal(n, edges, start)) # Output: [1, 0, 2, 3] # Example 3: n = 6 edges = [] start = 2 print(dfs_traversal(n, edges, start)) # Output: [2] ``` Implement the above function such that it correctly performs a DFS traversal for the given graph.","solution":"def dfs_traversal(n: int, edges: list[tuple[int, int]], start: int) -> list[int]: Perform DFS traversal on an undirected graph. Args: n (int): Number of nodes in the graph. edges (list[tuple[int, int]]): Edges of the graph as tuples of two nodes. start (int): Starting node for the traversal. Returns: list[int]: List of nodes in the order they were visited. # Create adjacency list adj_list = {i: [] for i in range(n)} for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) visited = [False] * n result = [] def dfs(node): visited[node] = True result.append(node) for neighbor in adj_list[node]: if not visited[neighbor]: dfs(neighbor) dfs(start) return result"},{"question":"# Problem Statement A logistics company needs to ensure that its delivery trucks operate efficiently by optimizing the routes they take from a warehouse to multiple delivery points. They decide to use the Genetic Algorithm (GA) approach to solve this problem. Your task is to implement a function that uses a Genetic Algorithm to find the optimal route that minimizes the total distance traveled. # Requirements 1. Implement the Genetic Algorithm including selection, crossover, mutation, and fitness evaluation functions. 2. Ensure various constraints such as population size, mutation rate, crossover rate, and generations limit are handled. 3. Provide a way to visualize the evolution of the optimization process. # Function Signature ```python import random import math class Route: def __init__(self, points: list): # constructor def total_distance(self) -> float: # returns total distance of the route def mutate(self, mutation_rate: float): # performs mutation on the route based on the given mutation rate def genetic_algorithm( initial_population: list, generations: int = 1000, mutation_rate: float = 0.01, crossover_rate: float = 0.75, population_size: int = 100, visualize: bool = False ) -> Route: # implementation ``` # Input Constraints 1. **Points**: A list of coordinates (x, y) representing delivery points. 2. **Population Size**: Positive integer indicating the number of routes in the population. 3. **Mutation Rate**: A float between 0 and 1 indicating the probability of mutation. 4. **Crossover Rate**: A float between 0 and 1 indicating the probability of crossover. 5. **Generations**: Positive integer indicating the number of generations to evolve. # Output Return the Route object that represents the shortest path found after the specified number of generations. # Example **Test the function with the following:** ```python points = [ (0, 0), # Warehouse (1, 5), (2, 2), (3, 6), (5, 3), (6, 1) ] initial_population = [Route(points) for _ in range(50)] def test_route_genetic_algorithm(): optimal_route = genetic_algorithm( initial_population=initial_population, generations=2000, mutation_rate=0.05, crossover_rate=0.8, population_size=50, visualize=True ) print(f\\"Optimal route found: {optimal_route.points}\\") print(f\\"Total distance: {optimal_route.total_distance()}\\") test_route_genetic_algorithm() ```","solution":"import random import math import matplotlib.pyplot as plt from itertools import combinations class Route: def __init__(self, points: list): self.points = points random.shuffle(self.points) def total_distance(self) -> float: distance = 0.0 for i in range(len(self.points)): x1, y1 = self.points[i] x2, y2 = self.points[(i+1) % len(self.points)] distance += math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2) return distance def mutate(self, mutation_rate: float): for i in range(len(self.points)): if random.random() < mutation_rate: j = random.randint(0, len(self.points) - 1) self.points[i], self.points[j] = self.points[j], self.points[i] def crossover(parent1: Route, parent2: Route) -> Route: start, end = sorted(random.sample(range(len(parent1.points)), 2)) child_points = [None] * len(parent1.points) child_points[start:end] = parent1.points[start:end] parent2_points = [point for point in parent2.points if point not in child_points] pointer = 0 for i in range(len(child_points)): if child_points[i] is None: child_points[i] = parent2_points[pointer] pointer += 1 return Route(child_points) def genetic_algorithm( initial_population: list, generations: int = 1000, mutation_rate: float = 0.01, crossover_rate: float = 0.75, population_size: int = 100, visualize: bool = False ) -> Route: def selection(population): return random.choices( population, weights=[1/route.total_distance() for route in population], k=2 ) population = initial_population if visualize: distances = [] for generation in range(generations): new_population = [] for _ in range(population_size): parent1, parent2 = selection(population) if random.random() < crossover_rate: child = crossover(parent1, parent2) else: child = Route(parent1.points[:]) child.mutate(mutation_rate) new_population.append(child) population = new_population if visualize: best_route = min(population, key=lambda route: route.total_distance()) distances.append(best_route.total_distance()) if visualize: plt.plot(range(generations), distances) plt.xlabel(\\"Generation\\") plt.ylabel(\\"Distance\\") plt.show() best_route = min(population, key=lambda route: route.total_distance()) return best_route"},{"question":"# Problem Description In the field of data analysis, you have been given a task to compute statistical metrics from a given dataset of numerical values. Specifically, you need to compute the mean, median, and mode of the data. These metrics are fundamental in understanding the distribution and central tendency of the data. Objective Write three functions `calculate_mean`, `calculate_median`, and `calculate_mode` that process a list of integers and return the mean, median, and mode, respectively. Function Signatures * `calculate_mean(data: List[int]) -> float` * `calculate_median(data: List[int]) -> float` * `calculate_mode(data: List[int]) -> Union[int, List[int]]` # Function Definitions 1. **calculate_mean** This function calculates the mean (average) of the given list of integers using the formula: [ text{Mean} = frac{sum text{data}}{text{number of elements in data}} ] 2. **calculate_median** This function calculates the median of the given list of integers: - If the number of elements is odd, the median is the middle element. - If the number of elements is even, the median is the average of the two middle elements. 3. **calculate_mode** This function calculates the mode(s) of the given list of integers as follows: - The mode is the number(s) that appear most frequently in the data. - If multiple numbers have the same highest frequency, return all such numbers in ascending order. # Input * `data` (List[int]): A list of integers. # Output 1. **calculate_mean** * Returns the calculated mean as a float. If the data is empty, return `0.0`. 2. **calculate_median** * Returns the calculated median as a float. If the data is empty, return `0.0`. 3. **calculate_mode** * Returns the mode as an integer if there is a single mode. If there are multiple modes, return a list of integers in ascending order. If the data is empty, return an empty list `[]`. # Examples ```python # Example for calculate_mean print(calculate_mean([1, 2, 3, 4, 5])) # Expected Output: 3.0 print(calculate_mean([5, 5, 5, 5])) # Expected Output: 5.0 print(calculate_mean([])) # Expected Output: 0.0 # Example for calculate_median print(calculate_median([1, 2, 3, 4, 5])) # Expected Output: 3.0 print(calculate_median([1, 2, 3, 4])) # Expected Output: 2.5 print(calculate_median([])) # Expected Output: 0.0 # Example for calculate_mode print(calculate_mode([1, 2, 3, 3, 4, 4, 4])) # Expected Output: 4 print(calculate_mode([1, 2, 3, 3, 4, 4])) # Expected Output: [3, 4] print(calculate_mode([])) # Expected Output: [] ``` # Instructions 1. Ensure efficient and correct handling of edge cases. 2. Raise appropriate errors for invalid inputs. 3. Make sure to test your code thoroughly using the provided examples and additional test cases if necessary. Use Python\'s built-in libraries and data structures wherever applicable for efficient implementations.","solution":"from typing import List, Union import statistics def calculate_mean(data: List[int]) -> float: if not data: return 0.0 return sum(data) / len(data) def calculate_median(data: List[int]) -> float: if not data: return 0.0 sorted_data = sorted(data) n = len(sorted_data) mid = n // 2 if n % 2 == 0: return (sorted_data[mid - 1] + sorted_data[mid]) / 2 else: return sorted_data[mid] def calculate_mode(data: List[int]) -> Union[int, List[int]]: if not data: return [] frequency = {} for num in data: if num in frequency: frequency[num] += 1 else: frequency[num] = 1 max_freq = max(frequency.values()) modes = [key for key, value in frequency.items() if value == max_freq] return modes[0] if len(modes) == 1 else sorted(modes)"},{"question":"# Coding Question **Title: Calculate the Minimum Steps to Escape a Maze** **Background**: You are trapped in a maze represented by a 2D grid. Each cell in the grid is either open or blocked. You begin at the top-left corner of the maze and must reach the bottom-right corner of the maze. You can move up, down, left, or right, but cannot pass through blocked cells. Write a Python function `min_steps_to_escape(maze: List[List[int]]) -> int` that calculates the minimum number of steps required to escape the maze. **Function Signature**: ```python def min_steps_to_escape(maze: List[List[int]]) -> int: ``` **Input**: - `maze` (List[List[int]]): A 2D grid of integers representing the maze. The values are either 0 (an open cell) or 1 (a blocked cell). `1 <= len(maze), len(maze[0]) <= 100`. **Output**: - (int): The minimum number of steps required to reach the bottom-right corner from the top-left corner, or -1 if it is not possible to escape the maze. **Constraints**: - The maze will always have at least one cell. - You can move up, down, left, or right but cannot move through walls (cells with value 1). - If the initial or final cell is blocked, it is impossible to escape the maze. **Examples**: ```python assert min_steps_to_escape([[0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [0, 1, 0, 0, 0]]) == 7 assert min_steps_to_escape([[0, 0, 0], [1, 1, 0], [0, 0, 0]]) == 4 assert min_steps_to_escape([[1, 0, 0], [0, 1, 0], [0, 0, 0]]) == -1 ``` **Implementation Guidelines**: 1. Handle edge cases where the initial or final cell is blocked. 2. Use a breadth-first search (BFS) technique to explore the shortest path. 3. Maintain a queue for positions to explore and a set to track visited positions. 4. Initialize the queue with the start position and perform BFS until you reach the target position or exhaust all possible moves. 5. Return -1 if no path exists from the start to the end position.","solution":"from collections import deque from typing import List def min_steps_to_escape(maze: List[List[int]]) -> int: rows, cols = len(maze), len(maze[0]) # Check if starting or ending point is blocked if maze[0][0] == 1 or maze[rows-1][cols-1] == 1: return -1 # Possible moves: right, down, left, up directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) # (row, col, step count) visited = set((0, 0)) while queue: r, c, steps = queue.popleft() # When we reach the bottom-right corner if r == rows - 1 and c == cols - 1: return steps for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and maze[nr][nc] == 0 and (nr, nc) not in visited: visited.add((nr, nc)) queue.append((nr, nc, steps + 1)) return -1"},{"question":"# Scenario You are working on a project that manages a company\'s inventory. Each item in the inventory has a unique code, name, and quantity. The inventory system needs to support various operations such as adding new items, removing items, updating the quantity of items, and querying current stock levels. # Task Write a class `Inventory` that manages a collection of `Item` objects. The class should support the following methods: 1. `add_item(code: str, name: str, quantity: int) -> None`: Adds a new item to the inventory. If an item with the same code already exists, raises a `ValueError`. 2. `remove_item(code: str) -> None`: Removes the item with the given code from the inventory. If no such item exists, raises a `ValueError`. 3. `update_quantity(code: str, quantity: int) -> None`: Updates the quantity of the specified item. If the item does not exist, raises a `ValueError`. 4. `get_stock(code: str) -> int`: Returns the current quantity of the specified item. If the item does not exist, raises a `ValueError`. # Input * `code` (string): Unique code for the item. * `name` (string): The name of the item. * `quantity` (integer): The quantity of the item. # Output As described, the outputs are dependent on the methods invoked: either return `None` or an integer representing the stock. # Constraints 1. The `code` is a non-empty string and unique within the inventory. 2. The `name` is a non-empty string. 3. The `quantity` is a non-negative integer. # Examples ```python # Example usage inventory = Inventory() inventory.add_item(\\"001\\", \\"Apple\\", 50) inventory.add_item(\\"002\\", \\"Banana\\", 30) inventory.update_quantity(\\"002\\", 45) print(inventory.get_stock(\\"002\\")) # Output: 45 inventory.remove_item(\\"001\\") print(inventory.get_stock(\\"001\\")) # Output: None ``` # Note Ensure to handle erroneous inputs by raising a `ValueError` for situations such as attempting to add an item with an already existing code or referencing a non-existent item in any of the methods.","solution":"class Item: def __init__(self, code: str, name: str, quantity: int): self.code = code self.name = name self.quantity = quantity class Inventory: def __init__(self): self.items = {} def add_item(self, code: str, name: str, quantity: int) -> None: if code in self.items: raise ValueError(f\\"Item with code {code} already exists.\\") self.items[code] = Item(code, name, quantity) def remove_item(self, code: str) -> None: if code not in self.items: raise ValueError(f\\"Item with code {code} does not exist.\\") del self.items[code] def update_quantity(self, code: str, quantity: int) -> None: if code not in self.items: raise ValueError(f\\"Item with code {code} does not exist.\\") self.items[code].quantity = quantity def get_stock(self, code: str) -> int: if code not in self.items: raise ValueError(f\\"Item with code {code} does not exist.\\") return self.items[code].quantity"},{"question":"# Problem Statement: You are required to implement a function that performs Breadth-First Search (BFS) on a given graph starting from a specified source vertex. The graph is represented by an adjacency list where each vertex is mapped to a list of neighboring vertices. The function should return a list of vertices in the order they are visited. # Function Signature: ```python def bfs_traversal(graph: dict, start_vertex: int) -> list: pass ``` # Input: - `graph`: A dictionary representing an undirected graph. Key is an integer vertex, and the value is a list of integers representing adjacent vertices. - `start_vertex`: An integer representing the starting vertex for BFS. # Output: - Returns a list of integers representing the vertices in the order they are visited during the BFS traversal. # Constraints: - Vertices are represented as non-negative integers. - The input graph can be empty, but not `None`. - The adjacency list does not guarantee order. - The start vertex is guaranteed to be a key in the graph if the graph is not empty. # Example: ```plaintext graph = { 0: [1, 2, 3], 1: [0, 4, 5], 2: [0], 3: [0, 6, 7], 4: [1], 5: [1], 6: [3], 7: [3] } bfs_traversal(graph, 0) # Output: [0, 1, 2, 3, 4, 5, 6, 7] ``` # Explanation: The function initializes a queue with the start vertex and a set to track visited vertices. It iterates through the queue, marking the current vertex as visited and adding its unvisited neighbors to the queue. This process continues until the queue is empty, ensuring all reachable vertices from the start vertex are visited in BFS order. # Other Considerations: - Ensure the function can handle edge cases like an empty graph or a graph with a single vertex. - The BFS algorithm should correctly handle graphs with disconnected components, although the function will only cover the component containing the start vertex.","solution":"def bfs_traversal(graph: dict, start_vertex: int) -> list: from collections import deque if not graph: return [] visited = set() traversal_order = [] queue = deque([start_vertex]) while queue: vertex = queue.popleft() if vertex not in visited: visited.add(vertex) traversal_order.append(vertex) for neighbor in graph[vertex]: if neighbor not in visited: queue.append(neighbor) return traversal_order"},{"question":"# Minimum Time to Visit All Points Problem Context You\'re given an array of points in a 2D plane, where each point is represented as an array of two integers [x, y]. To visit all points in the given order, you can move: - Horizontally or vertically 1 unit in 1 second. - Diagonally (both horizontally and vertically) 1 unit in 1 second. You need to determine the minimum time required to visit all points in the order they appear in the input array. Task Implement a function `min_time_to_visit_all_points` that takes a list of points and returns the minimum time required to visit all points in order. Input - A list of `n` points, where each point is an array [x, y] with (1 leq n leq 10^{4}). - ([-10^4 leq x, y leq 10^4)). Output - An integer representing the minimum time required to visit all the points. Example ```python def min_time_to_visit_all_points(points: List[List[int]]) -> int: # your code here print(min_time_to_visit_all_points([[1,1],[3,4],[-1,0]])) # Output: 7 print(min_time_to_visit_all_points([[3,2],[-2,2]])) # Output: 5 ``` Performance Requirements Your solution should efficiently calculate the minimum time even for the upper constraint limits. Consider iterating through the points array and calculating the time for each consecutive pair of points.","solution":"from typing import List def min_time_to_visit_all_points(points: List[List[int]]) -> int: def get_distance(p1, p2): return max(abs(p1[0] - p2[0]), abs(p1[1] - p2[1])) total_time = 0 for i in range(len(points) - 1): total_time += get_distance(points[i], points[i + 1]) return total_time"},{"question":"# Coding Assessment Question Problem Statement You are given a binary tree and an integer `target_sum`. Implement a function that counts all root-to-leaf paths in the binary tree where the sum of the node values along the path equals `target_sum`. Function Signature ```python class TreeNode: def __init__(self, value: int): self.value = value self.left = None self.right = None def count_paths_with_sum(root: TreeNode, target_sum: int) -> int: Count the root-to-leaf paths in the binary tree that sum to target_sum. :param root: Root node of the binary tree. :param target_sum: Sum to check paths against. :return: Number of paths that sum to target_sum. ``` Input Format * A binary tree where each node contains an integer value. * An integer `target_sum`. Output Format * An integer representing the number of root-to-leaf paths in the binary tree that sum to `target_sum`. Example ```python # Construct the binary tree root = TreeNode(5) root.left = TreeNode(4) root.right = TreeNode(8) root.left.left = TreeNode(11) root.left.left.left = TreeNode(7) root.left.left.right = TreeNode(2) root.right.left = TreeNode(13) root.right.right = TreeNode(4) root.right.right.left = TreeNode(5) root.right.right.right = TreeNode(1) # Example usage print(count_paths_with_sum(root, 22)) # Output: 3 # Explanation: There are three paths that sum to 22: # 1. 5 -> 4 -> 11 -> 2 # 2. 5 -> 8 -> 4 -> 5 # 3. 5 -> 8 -> 4 -> 5 -> 1 ``` Constraints * The binary tree can have up to 10^4 nodes. * Node values are integers and can be positive or negative. * The integer `target_sum` can be positive, negative, or zero. Implementation Notes * Ensure the function handles edge cases, such as when the binary tree is empty. * The function should be efficient and able to handle the largest possible input sizes. * Use depth-first search (DFS) to explore all root-to-leaf paths in the binary tree.","solution":"class TreeNode: def __init__(self, value: int): self.value = value self.left = None self.right = None def count_paths_with_sum(root: TreeNode, target_sum: int) -> int: def dfs(node: TreeNode, current_sum: int) -> int: if not node: return 0 current_sum += node.value if not node.left and not node.right: # Check if it\'s a leaf node return 1 if current_sum == target_sum else 0 # Continue DFS on left and right subtrees return dfs(node.left, current_sum) + dfs(node.right, current_sum) if not root: return 0 # Initialize DFS from the root and get the total paths return dfs(root, 0) + count_paths_with_sum(root.left, target_sum) + count_paths_with_sum(root.right, target_sum)"},{"question":"# Fibonacci Sequence You\'re preparing a lesson on the Fibonacci sequence, and you need to create a Python function that generates the sequence up to a specified number of terms. **Problem Statement**: Write a function `fibonacci_sequence(number_of_terms: int) -> list` that takes one argument: - `number_of_terms`: The number of terms of the Fibonacci sequence to generate. The function should return a list containing the first `number_of_terms` elements of the Fibonacci sequence. The Fibonacci sequence is defined as follows: - The first term is 0. - The second term is 1. - Every subsequent term is the sum of the two preceding terms (i.e., `F(n) = F(n-1) + F(n-2)` for `n >= 3`). **Input Constraints**: - `number_of_terms` is a non-negative integer. **Requirements**: 1. If `number_of_terms` is 0, the function should return an empty list. 2. Ensure that the function correctly handles small values for `number_of_terms`, including cases where it is 1 or 2. 3. The function should efficiently compute the Fibonacci sequence for typical educational purposes. **Example**: ```python >>> print(fibonacci_sequence(5)) [0, 1, 1, 2, 3] >>> print(fibonacci_sequence(10)) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] >>> print(fibonacci_sequence(2)) [0, 1] >>> print(fibonacci_sequence(0)) [] ``` **Instructions**: - Implement the function with consideration for edge cases as described. - Strive for an optimal performance where feasible, recognizing the needs of educational purposes. - Validate the function\'s output with various inputs to ensure correctness.","solution":"def fibonacci_sequence(number_of_terms: int) -> list: Generates the Fibonacci sequence up to the specified number of terms. Args: number_of_terms (int): The number of terms to generate. Returns: list: A list containing the first `number_of_terms` elements of the Fibonacci sequence. if number_of_terms == 0: return [] elif number_of_terms == 1: return [0] elif number_of_terms == 2: return [0, 1] sequence = [0, 1] for i in range(2, number_of_terms): sequence.append(sequence[-1] + sequence[-2]) return sequence"},{"question":"# Coding Challenge: Find The Smallest Missing Positive Integer **Context:** Given an unsorted array of integers, you need to find the smallest missing positive integer in the array. The array may contain negative numbers, zero, and duplicates. The goal is to identify the smallest positive integer (greater than 0) that is missing from the array. **Task:** Write a function `find_smallest_missing_positive` to find the smallest positive integer that does not appear in the array. Function Signature: ```python def find_smallest_missing_positive(arr: list[int]) -> int: ``` Input: - `arr`: A list of integers representing the unsorted array. Output: - Returns an integer representing the smallest missing positive integer. Constraints: - The length of `arr` will be at most 10^5. - Each element of `arr` will be between -10^6 and 10^6. **Examples:** ```python assert find_smallest_missing_positive([1, 2, 0]) == 3 assert find_smallest_missing_positive([3, 4, -1, 1]) == 2 assert find_smallest_missing_positive([7, 8, 9, 11, 12]) == 1 ``` **Hints:** 1. Consider using a hash set to store the elements and then check sequentially for the smallest positive integer that is not present. 2. Alternately, you can try to manipulate the original array to place each number in its corresponding index (1 at index 0, 2 at index 1, and so on) and then iterate through the array to find the first missing positive integer.","solution":"def find_smallest_missing_positive(arr): n = len(arr) # First pass to mark non-positive numbers and numbers greater than n as n + 1 for i in range(n): if arr[i] <= 0 or arr[i] > n: arr[i] = n + 1 # Use the indices of the array to mark presence of elements for i in range(n): val = abs(arr[i]) if val <= n: arr[val - 1] = -abs(arr[val - 1]) # The first index which has a positive value, its index + 1 is the answer for i in range(n): if arr[i] > 0: return i + 1 return n + 1"},{"question":"# Objective: Create a function to determine if a given integer is a prime number using an efficient algorithm, ensuring understanding of prime number properties and optimization techniques. # Question: Design a function called `is_prime(n: int) -> bool` that determines if an integer `n` is a prime number. The function should be optimized for large values of `n` to ensure efficiency. # Requirements: * **Input**: An integer `n` where 2 ≤ n ≤ 10^18. * **Output**: A boolean value indicating whether `n` is a prime number. # Constraints: * You must use an optimized algorithm for primality testing, such as the Miller-Rabin primality test or trial division up to the square root of `n` with optimizations. * Ensure your implementation is capable of handling the upper constraint of `n` within reasonable time limits. # Example: ```python def is_prime(n: int) -> bool: # Your code here # Example Usage print(is_prime(11)) # Expected: True print(is_prime(1000)) # Expected: False print(is_prime(9999999967)) # Example of a large prime number, Expected: True ``` # Function Signature: ```python def is_prime(n: int) -> bool: ``` # Notes: * The function should return `True` if `n` is a prime number. * The function should return `False` otherwise. * Consider edge cases such as even numbers and numbers that are obviously divisible by small prime factors. # Hints: * A prime number is only divisible by 1 and itself. * For optimization, consider skipping even numbers (after checking if `n` is even) and using the 6k ± 1 rule for further division checks. * Optimal solutions for large numbers typically require probabilistic algorithms like Miller-Rabin for efficiently determining primality.","solution":"def is_prime(n: int) -> bool: Determines if a given integer n is a prime number. Uses the Miller-Rabin primality test for efficiency. # Base cases if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False # Miller-Rabin Primality Test components d, r = n - 1, 0 while d % 2 == 0: d //= 2 r += 1 def is_composite(a): x = pow(a, d, n) if x == 1 or x == n - 1: return False for _ in range(r - 1): x = pow(x, 2, n) if x == n - 1: return False return True # Known small prime numbers for base-a in Miller-Rabin bases = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37] for base in bases: if base >= n: break if is_composite(base): return False return True"},{"question":"# Coding Assessment Question Context You are building a feature for a photo-sharing application that allows users to arrange their photos in specific orders. Additionally, it is essential that identical photos (marked by the same ID) maintain their relative ordering after sorting. This requirement ensures that, even after sorting, the order of photos uploaded at the same time is preserved. Problem Implement a stable sorting algorithm to sort an array of tuples where each tuple represents a photo with an integer ID and a string timestamp. Ensure that the photos are sorted in ascending order based on their IDs. The sorting algorithm should maintain the relative order of tuples with the same ID (i.e., it should be stable). Specifications * **Function Signature**: `def stable_sort_photos(photos: list[tuple[int, str]]) -> list[tuple[int, str]]:` * **Input**: A list of tuples `photos` where each tuple contains: - An integer `ID` representing the photo ID (`photos[i][0]`). - A string `timestamp` representing when the photo was uploaded (`photos[i][1]`). * **Output**: A new list containing the tuples sorted by ID in ascending order, while maintaining the stability of the sorting algorithm. * **Constraints**: * The input list `photos` can have up to (10^5) tuples. * Each photo ID is a non-negative integer. * The timestamp is a non-empty string. * **Performance Requirements**: * Achieve a time complexity of (O(n log n)). * Ensure the sorting algorithm is stable. Example ```python photos = [(10, \'2023-10-01T14:22:00\'), (1, \'2023-10-02T11:00:00\'), (10, \'2023-10-01T15:30:00\'), (3, \'2023-10-03T08:45:00\')] sorted_photos = stable_sort_photos(photos) print(sorted_photos) # Output: [(1, \'2023-10-02T11:00:00\'), (3, \'2023-10-03T08:45:00\'), (10, \'2023-10-01T14:22:00\'), (10, \'2023-10-01T15:30:00\')] photos = [(2, \'2022-01-01T10:00:00\'), (1, \'2022-01-02T12:00:00\'), (2, \'2022-01-01T11:00:00\')] sorted_photos = stable_sort_photos(photos) print(sorted_photos) # Output: [(1, \'2022-01-02T12:00:00\'), (2, \'2022-01-01T10:00:00\'), (2, \'2022-01-01T11:00:00\')] ``` Notes * This problem requires knowledge of stable sorting algorithms and their implementation. * Take special care to ensure the stability property is preserved, particularly for input with duplicate IDs.","solution":"def stable_sort_photos(photos): Returns the list of photos sorted by ID in ascending order. The sort is stable, meaning the relative order of elements with equal keys is maintained. return sorted(photos, key=lambda photo: photo[0])"},{"question":"# Question **Context**: You are working on a project that requires the ability to efficiently search for elements in large datasets. You\'ve implemented linear search before, but you are looking for a more efficient way to search sorted arrays. **Goal**: Your task is to implement **Binary Search**, which has a time complexity of O(log n), making it an efficient algorithm for searching in sorted arrays. **Function to Implement**: ```python def binary_search(arr: list[int], target: int) -> int: Searches for a target value in a sorted array using the binary search algorithm. :param arr: a sorted list of integers :param target: an integer value to search for :return: the index of the target if found, otherwise -1 ``` **Input**: - A sorted list of integers, `arr`, where 1 <= len(arr) <= 10^5 and -10^9 <= arr[i] <= 10^9. - An integer, `target`, which you need to search for in the array. **Output**: - Return the index of `target` in the array `arr`. If `target` does not exist in the array, return -1. **Constraints**: - The solution should have a time complexity of O(log n). - You should not use any inbuilt search functions, but you may use helper functions. **Example**: ```python >>> binary_search([1, 3, 5, 7, 9, 11], 5) 2 >>> binary_search([2, 4, 6, 8, 10], 7) -1 ``` **Hint**: - Use a divide-and-conquer approach to repeatedly split the array and narrow down the search space.","solution":"def binary_search(arr, target): Searches for a target value in a sorted array using the binary search algorithm. :param arr: a sorted list of integers :param target: an integer value to search for :return: the index of the target if found, otherwise -1 left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: return mid elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Context You are tasked with creating a function that calculates the distance between two points on the Earth\'s surface given their geographic coordinates (latitude and longitude). This is commonly known as the Haversine formula, which accounts for the spherical shape of the Earth to provide an accurate distance measurement. # Task Implement a function `calculate_haversine_distance` that computes the distance between two geographic coordinates in kilometers. # Requirements * **Input**: * `lat1` (float): Latitude of the first point in decimal degrees. * `lon1` (float): Longitude of the first point in decimal degrees. * `lat2` (float): Latitude of the second point in decimal degrees. * `lon2` (float): Longitude of the second point in decimal degrees. * **Output**: * A float representing the distance between the two points in kilometers. * **Constraints**: * Latitude values must be in the range of -90 to 90 degrees. * Longitude values must be in the range of -180 to 180 degrees. * If invalid latitude or longitude values are provided, raise a `ValueError` with a message indicating the valid ranges. # Example ```python def calculate_haversine_distance(lat1: float, lon1: float, lat2: float, lon2: float) -> float: Calculate the Haversine distance between two geographic points. Parameters: lat1 : float: Latitude of the first point. lon1 : float: Longitude of the first point. lat2 : float: Latitude of the second point. lon2 : float: Longitude of the second point. Returns: float: Distance between the two points in kilometers. Raises: ValueError: If `lat1`, `lon1`, `lat2`, or `lon2` are out of valid ranges. Example: >>> calculate_haversine_distance(34.052235, -118.243683, 40.712776, -74.005974) 3940.241201201967 >>> calculate_haversine_distance(0.0, 0.0, -90.0, 180.0) 10007.543398010286 >>> calculate_haversine_distance(91.0, 0.0, 0.0, 0.0) ValueError: Latitude must be in the range -90 to 90 degrees. # Your implementation here pass # Test cases print(calculate_haversine_distance(34.052235, -118.243683, 40.712776, -74.005974)) # Output: Approx 3940.24 print(calculate_haversine_distance(-33.8688, 151.2093, 51.5074, -0.1278)) # Output: Approx 16993.96 print(calculate_haversine_distance(-90.0, 0.0, 90.0, 0.0)) # Output: Approx 20015.09 ```","solution":"import math def calculate_haversine_distance(lat1: float, lon1: float, lat2: float, lon2: float) -> float: Calculate the Haversine distance between two geographic points. Parameters: lat1 : float: Latitude of the first point. lon1 : float: Longitude of the first point. lat2 : float: Latitude of the second point. lon2 : float: Longitude of the second point. Returns: float: Distance between the two points in kilometers. Raises: ValueError: If `lat1`, `lon1`, `lat2`, or `lon2` are out of valid ranges. if not (-90 <= lat1 <= 90 and -90 <= lat2 <= 90 and -180 <= lon1 <= 180 and -180 <= lon2 <= 180): raise ValueError(\\"Latitude must be in the range -90 to 90 degrees and Longitude must be in the range -180 to 180 degrees.\\") R = 6371 # Earth radius in kilometers # Convert latitude and longitude from degrees to radians lat1_rad = math.radians(lat1) lon1_rad = math.radians(lon1) lat2_rad = math.radians(lat2) lon2_rad = math.radians(lon2) # Compute the differences between the two points dlat = lat2_rad - lat1_rad dlon = lon2_rad - lon1_rad # Apply the Haversine formula a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2 c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a)) distance = R * c return distance"},{"question":"# Context: You are tasked with developing a feature that can identify the most frequent word in a given text document after excluding a set of common stop words. This feature is part of a larger text analysis tool aiming to help users determine key information from large bodies of text. # Task: Implement a function `most_frequent_word(text: str, stop_words: List[str]) -> str` that processes the input `text`, excludes the `stop_words`, and returns the most frequently occurring word in the text. If multiple words have the highest frequency, return any one of them. # Specifications: - **Input**: - `text`: A string representing the text document. The document contains words separated by spaces, and can include punctuation such as `.,!?;`. Punctuation should be excluded from the word counts. - `stop_words`: A list of strings representing the stop words to be excluded from the frequency count. - **Output**: A string representing the most frequently occurring word after excluding the stop words. - **Constraints**: - The length of `text` will not exceed (10^5) characters. - The length of `stop_words` will not exceed (10^3) words. - All words are case-insensitive during comparison. # Implementation: - **Function**: ```python def most_frequent_word(text: str, stop_words: List[str]) -> str: pass ``` - Make sure to convert words to lower case for uniform comparison. - Handle punctuation effectively, ensuring it\'s not counted as part of any word. # Example: Input: ```python text = \\"The quick brown fox jumps over the lazy dog! The fox was quick and the dog was lazy.\\" stop_words = [\\"the\\", \\"was\\", \\"and\\", \\"over\\"] ``` In this example, the word frequencies (excluding stop words) are: - \\"quick\\": 2 - \\"brown\\": 1 - \\"fox\\": 2 - \\"jumps\\": 1 - \\"lazy\\": 1 - \\"dog\\": 2 Output: ```python \\"fox\\" ``` or ```python \\"quick\\" ``` or ```python \\"dog\\" ``` Each of these words appears twice and thus any of them are valid outputs.","solution":"from typing import List from collections import Counter import string def most_frequent_word(text: str, stop_words: List[str]) -> str: Returns the most frequent word in the text after excluding the given stop words. stop_words_set = set(stop_words) translator = str.maketrans(\'\', \'\', string.punctuation) words = text.translate(translator).lower().split() filtered_words = [word for word in words if word not in stop_words_set] if not filtered_words: return \\"\\" word_counts = Counter(filtered_words) most_common_word, _ = word_counts.most_common(1)[0] return most_common_word"},{"question":"# Merge Intervals with Enhanced Features Scenario: You are tasked to enhance the given implementation of the Merge Intervals algorithm to include the following features: 1. **Non-overlapping Filter**: The algorithm should filter out intervals that do not overlap with any other intervals. 2. **Custom Overlap Detection**: Provide an option to define a custom overlap detection function. 3. **Result Preservation**: Ensure that the implementation preserves the original list of intervals and returns a new list if necessary. Task: Implement the function `enhanced_merge_intervals` with the following signature: ```python from typing import Callable, List, Tuple, Optional def enhanced_merge_intervals(intervals: List[Tuple[int, int]], overlap_detector: Optional[Callable[[Tuple[int, int], Tuple[int, int]], bool]] = None) -> List[Tuple[int, int]] ``` * **Parameters**: - `intervals`: A list of tuples where each tuple represents an interval (start, end). - `overlap_detector`: An optional custom function that takes two intervals and returns True if they overlap based on custom logic. If not provided, defaults to standard overlap detection `(a, b) and (c, d)` overlap if `a <= d` and `b >= c`. * **Returns**: - A new list of merged and filtered intervals. * **Constraints**: - The provided list can be empty or contain up to (10^4) intervals. * **Example**: ```python # Example usage: enhanced_merge_intervals([(1, 3), (2, 6), (8, 10), (15, 18)]) # Returns: [(1, 6), (8, 10), (15, 18)] enhanced_merge_intervals([(1, 4), (4, 5)]) # Returns: [(1, 5)] enhanced_merge_intervals([(1, 3), (2, 4), (5, 7), (8, 10)], overlap_detector=lambda a, b: max(a[0], b[0]) <= min(a[1], b[1]) - 1) # Returns: [(1, 4), (5, 7), (8, 10)] ``` Note: - The implementation should maintain the efficiency of the merge intervals algorithm while incorporating the requested features. - Consider edge cases and validate your implementation with various test cases, including empty lists and single-interval lists.","solution":"from typing import Callable, List, Tuple, Optional def default_overlap_detector(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> bool: Default method to check if two intervals overlap return interval1[1] >= interval2[0] and interval2[1] >= interval1[0] def enhanced_merge_intervals(intervals: List[Tuple[int, int]], overlap_detector: Optional[Callable[[Tuple[int, int], Tuple[int, int]], bool]] = None) -> List[Tuple[int, int]]: if not intervals: return [] if not overlap_detector: overlap_detector = default_overlap_detector # Sort intervals by starting point intervals = sorted(intervals, key=lambda x: x[0]) merged_intervals = [] for interval in intervals: if not merged_intervals or not overlap_detector(merged_intervals[-1], interval): merged_intervals.append(interval) else: merged_intervals[-1] = (merged_intervals[-1][0], max(merged_intervals[-1][1], interval[1])) return merged_intervals"},{"question":"# Largest Palindromic Substring Write a function that finds the largest palindromic substring within a given string and returns its length. Function Signature: ```python def largest_palindromic_substring_length(s: str) -> int: # your code here ``` Parameters: - `s` (str): The input string consisting of lowercase alphabets. Returns: - `int`: The length of the largest palindromic substring. Constraints: - The length of the input string is at most ( 10^3 ). Example: ```python # Example Input s = \\"babad\\" # Expected Output 3 # Explanation: # The largest palindromic substring in \\"babad\\" is \\"bab\\" or \\"aba\\". # Both are palindromes of length 3. ``` ```python # Example Input s = \\"cbbd\\" # Expected Output 2 # Explanation: # The largest palindromic substring in \\"cbbd\\" is \\"bb\\", which has a length of 2. ``` Notes: - A substring is defined as a contiguous sequence of characters within a string. - Ensure that your solution is efficient enough to handle the upper limit of input size. - The implementation should consider both odd and even length palindromes. - You may assume that there is always at least one palindrome substring in the input string (since any single character is a palindrome).","solution":"def largest_palindromic_substring_length(s: str) -> int: def expand_around_center(left: int, right: int) -> int: # Expand while the characters are the same while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 # Return the length of the palindrome return right - left - 1 max_length = 1 # At least every single character is a palindrome for i in range(len(s)): # Odd length palindromes len1 = expand_around_center(i, i) # Even length palindromes len2 = expand_around_center(i, i + 1) # Update the maximum length found max_length = max(max_length, len1, len2) return max_length"},{"question":"# Data Structure & Algorithms: Graph Traversal You are developing a navigation system for a city. The city is represented as a graph where intersections are nodes, and roads are edges. You need to find the shortest path from a starting intersection to a destination intersection. Task: Implement a function `shortest_path(graph: dict, start: int, end: int) -> list[int]` that calculates the shortest path in terms of the number of intersections from the `start` intersection to the `end` intersection. Requirements: 1. **Input:** * `graph` (dictionary): A dictionary where keys are integers representing intersections, and values are lists of integers representing directly connected intersections. * `start` (integer): The starting intersection. * `end` (integer): The destination intersection. 2. **Output:** A list of integers representing the intersections in the order they are visited from `start` to `end`. If no path exists, return an empty list. 3. The function should handle the following edge cases: * `start` or `end` intersection does not exist in the graph. * There is no path between `start` and `end`. 4. Optimize the algorithm to handle large graphs efficiently. Constraints: * The graph is unweighted, and each road has equal weight. * The number of intersections can be up to 10,000. * There can be multiple shortest paths with the same length. Example: ```python def main(): city_map = { 0: [1, 2], 1: [0, 3, 4], 2: [0, 4], 3: [1], 4: [1, 2, 5], 5: [4] } path = shortest_path(city_map, 0, 5) print(path) # Expected Output: [0, 1, 4, 5] if __name__ == \\"__main__\\": main() ``` This should compute the shortest path from intersection 0 to intersection 5 in the given city map. Note: Use an appropriate graph traversal algorithm (such as Breadth-First Search) to find the shortest path efficiently. Ensure the function includes error handling for non-existent intersections and unreachable destinations.","solution":"from collections import deque def shortest_path(graph, start, end): Returns the shortest path from the start intersection to the end intersection using Breadth-First Search. if start not in graph or end not in graph: return [] queue = deque([[start]]) visited = set([start]) while queue: path = queue.popleft() node = path[-1] if node == end: return path for neighbor in graph[node]: if neighbor not in visited: visited.add(neighbor) queue.append(path + [neighbor]) return []"},{"question":"# Question **Background**: You are tasked with developing a lightweight logging module to help track the performance of different sections of your code. To achieve this, you need to measure the execution time of specific functions. **Task**: Write a decorator function `execution_time_logger` that measures the execution time of the decorated function and logs it to the console. The decorator should be able to handle both functions with arguments and functions without arguments. **Function Signature**: ```python import time from functools import wraps def execution_time_logger(func): @wraps(func) def wrapper(*args, **kwargs): pass return wrapper ``` **Input**: * The input will be any callable function, possibly with any number of arguments and keyword arguments. **Output**: * The decorated function should print to the console the execution time in seconds followed by the function name in the format: `\\"Execution time for <function_name>: <time_taken> seconds\\"`. **Example**: ```python @execution_time_logger def example_function_1(): time.sleep(1) print(\\"Function 1 executed\\") @execution_time_logger def example_function_2(x, y): time.sleep(2) print(f\\"Function 2 executed with arguments: {x} and {y}\\") example_function_1() # Expected: Execution time for example_function_1: 1.0000 seconds # Expected: Function 1 executed example_function_2(5, 10) # Expected: Execution time for example_function_2: 2.0000 seconds # Expected: Function 2 executed with arguments: 5 and 10 ``` **Notes**: * Ensure the logged execution time has a precision of four decimal places. * The execution time should be accurate and measured using the `time.time()` function. * Integrate your solution smoothly with both functions that do and do not take arguments. **Constraints**: * The execution time of the functions can vary widely, from milliseconds to several seconds. * The functions to be decorated might perform various operations, such as computations or I/O.","solution":"import time from functools import wraps def execution_time_logger(func): @wraps(func) def wrapper(*args, **kwargs): start_time = time.time() result = func(*args, **kwargs) end_time = time.time() execution_time = end_time - start_time print(f\\"Execution time for {func.__name__}: {execution_time:.4f} seconds\\") return result return wrapper"},{"question":"# Coding Question: Extract Unique Words from Text Scenario For a natural language processing project, you need to develop a function that extracts unique words from a given text. This function will help clean and preprocess text data for further analysis. Problem Write a function to extract all unique words from a given string. The function should ignore punctuation and be case-insensitive. Words are defined as sequences of alphabetic characters. Function Signature ```python def extract_unique_words(text: str) -> list: ``` Input * A string `text` (1 ≤ |text| ≤ 10^5). Output * A list of unique words sorted in the order they first appear in the text. Constraints * The input string can contain punctuations and is case-insensitive. * Only alphabetic characters are considered as part of a word. Example ```python >>> extract_unique_words(\\"Hello, world! Hello.\\") [\'hello\', \'world\'] >>> extract_unique_words(\\"This is a test. This test is only a test.\\") [\'this\', \'is\', \'a\', \'test\', \'only\'] >>> extract_unique_words(\\"Unique words are fun: unique, words, fun!\\") [\'unique\', \'words\', \'are\', \'fun\'] >>> extract_unique_words(\\"Python is great! PYTHON is GREATER!!\\") [\'python\', \'is\', \'great\', \'greater\'] ``` Edge Cases * `text = \\"\\"`: Return an empty list. * `text = \\"a b c A B C\\"`: Return `[\'a\', \'b\', \'c\']` since the function is case-insensitive. Implement the function `extract_unique_words`. # Solution Here\'s how you can implement the `extract_unique_words` function: ```python import re def extract_unique_words(text: str) -> list: # Use regular expression to find all words ignoring punctuation and case words = re.findall(r\'b[a-zA-Z]+b\', text.lower()) # Initialize an ordered dictionary to preserve the order of first appearances from collections import OrderedDict unique_words = OrderedDict() for word in words: if word not in unique_words: unique_words[word] = None # The keys of the ordered dictionary are the unique words in the correct order return list(unique_words.keys()) # Test cases print(extract_unique_words(\\"Hello, world! Hello.\\")) # [\'hello\', \'world\'] print(extract_unique_words(\\"This is a test. This test is only a test.\\")) # [\'this\', \'is\', \'a\', \'test\', \'only\'] print(extract_unique_words(\\"Unique words are fun: unique, words, fun!\\")) # [\'unique\', \'words\', \'are\', \'fun\'] print(extract_unique_words(\\"Python is great! PYTHON is GREATER!!\\")) # [\'python\', \'is\', \'great\', \'greater\'] ```","solution":"import re from collections import OrderedDict def extract_unique_words(text: str) -> list: Extracts all unique words from a given string. The function ignores punctuation and is case-insensitive. Words are defined as sequences of alphabetic characters. :param text: Input text string. :return: List of unique words in the order they first appear in the text. # Use regular expression to find all words ignoring punctuation and case words = re.findall(r\'b[a-zA-Z]+b\', text.lower()) # Initialize an ordered dictionary to preserve the order of first appearances unique_words = OrderedDict() for word in words: if word not in unique_words: unique_words[word] = None # The keys of the ordered dictionary are the unique words in the correct order return list(unique_words.keys())"},{"question":"# Problem: Circular Queue Implementation Design and implement a circular queue using a fixed-size array to manage ongoing print jobs in a network printer system. This queue should allow enqueueing new print jobs at the rear and dequeuing jobs from the front with wrap-around support when the end of the array is reached. Requirements: 1. **Implement a method `enqueue(data: int) -> bool`**: - This method should add the specified data to the rear of the circular queue. - If the queue is full, return `False`. - If the queue is not full, insert the data and return `True`. 2. **Implement a method `dequeue() -> int | None`**: - This method should remove and return the data at the front of the queue. - If the queue is empty, return `None`. 3. **Implement a method `front() -> int | None`**: - This method should return the data at the front of the queue without removing it. - If the queue is empty, return `None`. 4. **Implement a method `is_empty() -> bool`**: - This method should return `True` if the queue is empty, otherwise return `False`. 5. **Implement a method `is_full() -> bool`**: - This method should return `True` if the queue is full, otherwise return `False`. Function Signatures: ```python class CircularQueue: def __init__(self, size: int) -> None: # Initialization def enqueue(self, data: int) -> bool: # Code for enqueue def dequeue(self) -> int | None: # Code for dequeue def front(self) -> int | None: # Code for front def is_empty(self) -> bool: # Code for is_empty def is_full(self) -> bool: # Code for is_full ``` Input/Output Formats: - `enqueue(data: int) -> bool` - Input: Data (integer) - Output: Insertion success (boolean) - `dequeue() -> int | None` - Input: None - Output: Removed front element\'s data (integer) or None - `front() -> int | None` - Input: None - Output: Front element\'s data (integer) or None - `is_empty() -> bool` - Input: None - Output: Queue emptiness status (boolean) - `is_full() -> bool` - Input: None - Output: Queue fullness status (boolean) Example: ```python queue = CircularQueue(3) print(queue.is_empty()) # Output: True print(queue.enqueue(1)) # Output: True print(queue.enqueue(2)) # Output: True print(queue.enqueue(3)) # Output: True print(queue.enqueue(4)) # Output: False print(queue.is_full()) # Output: True print(queue.front()) # Output: 1 print(queue.dequeue()) # Output: 1 print(queue.front()) # Output: 2 ``` Constraints: - Ensure methods handle wrap-around correctly. - `front` and `dequeue` should manage empty queue scenarios correctly. - Use a fixed-size array for the internal representation of the queue. - Data inserted into the queue will be non-negative integers.","solution":"class CircularQueue: def __init__(self, size: int) -> None: self.queue = [None] * size self.size = size self.front_index = 0 self.rear_index = 0 self.current_size = 0 def enqueue(self, data: int) -> bool: if self.is_full(): return False self.queue[self.rear_index] = data self.rear_index = (self.rear_index + 1) % self.size self.current_size += 1 return True def dequeue(self) -> int | None: if self.is_empty(): return None data = self.queue[self.front_index] self.queue[self.front_index] = None self.front_index = (self.front_index + 1) % self.size self.current_size -= 1 return data def front(self) -> int | None: if self.is_empty(): return None return self.queue[self.front_index] def is_empty(self) -> bool: return self.current_size == 0 def is_full(self) -> bool: return self.current_size == self.size"},{"question":"# Problem Scenario You are tasked with designing a system to manage the inventory of a bookstore. The system needs to keep track of the number of books available for sale, restocking events, and customer purchase transactions. Each book is identified by its unique ISBN number. # Function Implementations Implement the following functions: 1. **add_book(inventory: Dict[str, int], isbn: str, quantity: int) -> None** - Input: A dictionary representing the inventory with ISBNs as keys and their respective quantities as values, a string representing the ISBN of the book, and an integer representing the quantity to add. - Output: None. The function should update the inventory in place. 2. **remove_book(inventory: Dict[str, int], isbn: str, quantity: int) -> None** - Input: A dictionary representing the inventory with ISBNs as keys and their respective quantities as values, a string representing the ISBN of the book, and an integer representing the quantity to remove. - Output: None. The function should update the inventory in place. If there is not enough stock, set the quantity of the book to zero. 3. **get_inventory_value(inventory: Dict[str, int], prices: Dict[str, float]) -> float** - Input: A dictionary representing the inventory with ISBNs as keys and their respective quantities as values, and a dictionary representing the prices with ISBNs as keys and their respective prices as values. - Output: A float representing the total value of the current inventory. # Constraints - The number of different ISBNs (n) can range from 1 to (10^5). - Each quantity and price is a positive integer within the range of [1, (10^5)]. - The ISBNs are guaranteed to be unique strings consisting of alphanumeric characters. - The sum of all quantities in the inventory will not exceed (10^6). # Example ```python # Example Usage: inventory = {\\"978-3-16-148410-0\\": 10, \\"978-1-86197-876-9\\": 5} prices = {\\"978-3-16-148410-0\\": 12.99, \\"978-1-86197-876-9\\": 8.99} add_book(inventory, \\"978-3-16-148410-0\\", 5) remove_book(inventory, \\"978-1-86197-876-9\\", 2) total_value = get_inventory_value(inventory, prices) assert inventory == {\\"978-3-16-148410-0\\": 15, \\"978-1-86197-876-9\\": 3} assert abs(total_value - 234.72) < 1e-2 print(\\"Inventory management successful!\\") ``` # Notes - Ensure the functions handle edge cases such as trying to remove books that are not in inventory or removing more books than available. - Optimize for performance to handle the maximum constraints smoothly.","solution":"def add_book(inventory, isbn, quantity): Add books to the inventory. Parameters: inventory (dict): The current inventory with ISBNs as keys and quantities as values. isbn (str): The ISBN of the book to add. quantity (int): The quantity of books to add. Returns: None if isbn in inventory: inventory[isbn] += quantity else: inventory[isbn] = quantity def remove_book(inventory, isbn, quantity): Remove books from the inventory. Parameters: inventory (dict): The current inventory with ISBNs as keys and quantities as values. isbn (str): The ISBN of the book to remove. quantity (int): The quantity of books to remove. Returns: None if isbn in inventory: if inventory[isbn] >= quantity: inventory[isbn] -= quantity else: inventory[isbn] = 0 def get_inventory_value(inventory, prices): Calculate the total value of the current inventory. Parameters: inventory (dict): The current inventory with ISBNs as keys and quantities as values. prices (dict): The prices of books with ISBNs as keys and prices as values. Returns: float: The total value of the inventory. total_value = 0.0 for isbn, quantity in inventory.items(): if isbn in prices: total_value += quantity * prices[isbn] return total_value"},{"question":"# Question You are responsible for creating a scheduling system that assigns tasks to workers in a way that ensures each worker is assigned tasks they prefer and the overall tasks are distributed as evenly as possible. The goal is to minimize the maximum number of tasks assigned to any worker. Function Specification ```python def balanced_task_assignment(workers_pref: list[list[int]], tasks_pref: list[list[int]], num_tasks: int) -> list[list[int]]: Assigns tasks to workers ensuring an even distribution and respecting preferences as much as possible. The function accepts the preferences of workers and tasks, and returns a list where the index represents the worker and the value at the index is a list of tasks assigned to that worker. ``` # Input * `workers_pref`: A list of lists representing the preference rankings of each worker, where `workers_pref[i]` is the list containing the i-th worker\'s preferred tasks in order of priority. * `tasks_pref`: A list of lists representing the preference rankings of each task, where `tasks_pref[j]` is the list containing the j-th task\'s preferred workers in order of priority. * `num_tasks`: An integer indicating the total number of tasks that need to be assigned to workers. # Output * A list of lists where the i-th index represents the worker and the value at the index is a list of tasks assigned to that worker. # Constraints * `1 ≤ num_workers ≤ 500` - The number of workers is constrained between 1 and 500. * `1 ≤ num_tasks ≤ 500` - The number of tasks is constrained between 1 and 500. * Each worker\'s and task\'s preference list is guaranteed to be of length `num_tasks` and `num_workers` respectively, and will not contain duplicate entries. * `num_tasks` is guaranteed to be at least as large as `num_workers`, ensuring that each worker gets at least one task. # Example ```python workers_pref = [[0, 1, 2, 3], [1, 0, 3, 2], [2, 3, 0, 1], [3, 2, 1, 0]] tasks_pref = [[1, 0, 2, 3], [0, 2, 1, 3], [3, 0, 1, 2], [2, 3, 0, 1]] num_tasks = 4 print(balanced_task_assignment(workers_pref, tasks_pref, num_tasks)) # Output: [[0, 1], [2, 3], [ ], [ ]] ``` # Performance Requirements Your implementation should aim for an O(n^2) time complexity to handle the upper limit of inputs efficiently. Explanation: In the example given: 1. Worker 0 prefers task 0 the most and task 1 secondarily. 2. Worker 1 prefers task 1 the most and task 0 secondarily. 3. Worker 2 prefers task 2 the most and task 3 secondarily. 4. Worker 3 prefers task 3 the most and task 2 secondarily. The tasks\' preferences will guide which worker they prefer to be assigned. The function should ensure the final assignment is as balanced as possible, distributing the tasks evenly and respecting preferences to a reasonable extent.","solution":"def balanced_task_assignment(workers_pref, tasks_pref, num_tasks): from heapq import heappop, heappush # Initialize the tasks assignments for each worker. num_workers = len(workers_pref) workers_tasks = [[] for _ in range(num_workers)] worker_loads = [0] * num_workers # the current load of each worker task_assigned = [False] * num_tasks # track which tasks have been assigned # Create a min-heap to assign tasks based on worker\'s preferred order heap = [] # Populate the heap initially with all worker preferences for worker_id in range(num_workers): for rank, task_id in enumerate(workers_pref[worker_id]): heappush(heap, (rank, worker_id, task_id)) # Assign tasks while maintaining balanced load while heap: rank, worker_id, task_id = heappop(heap) if not task_assigned[task_id]: workers_tasks[worker_id].append(task_id) worker_loads[worker_id] += 1 task_assigned[task_id] = True # Check if all tasks are assigned if all(task_assigned): break # Check if current worker has too many tasks - balance the load for next_worker_id in range(num_workers): if worker_loads[next_worker_id] < worker_loads[worker_id]: heappush(heap, (rank + 1, next_worker_id, task_id)) return workers_tasks"},{"question":"# Dungeon Crawling: Connected Islands Problem Statement You are designing an adventure game where the player needs to navigate through a series of connected islands. Each island is represented as a node in a graph and the bridges connecting them are the edges. The player starts on a given island and must collect a set of treasures located on specific islands before reaching the goal island. Write a function that determines the shortest path (minimum number of bridges crossed) for the player to collect all the treasures and reach the goal island. Use a Breadth-First Search (BFS) algorithm to solve this problem. # Constraints 1. The graph is represented as an adjacency list. 2. The function should be able to handle graphs with up to 1000 nodes. 3. Treasures are located on a subset of islands and need to be collected in any order. 4. The input guarantees that there is at least one valid path from the start to the goal passing through all treasures. # Input Format * An integer `n` representing the number of islands (nodes). * A list of pairs `bridges` representing the bridges (edges) where each pair `(u, v)` indicates a bridge between island `u` and island `v`. * An integer `start` representing the start island. * An integer `goal` representing the goal island. * A list of integers `treasures` representing the islands containing treasures. # Output Format * A list of integers representing the sequence of islands that forms the shortest path from the start island to the goal island, collecting all treasures along the way. * If no such path exists, return an empty list. # Function Signature ```python def shortest_treasure_path(n: int, bridges: list[tuple[int, int]], start: int, goal: int, treasures: list[int]) -> list[int]: pass ``` # Example Input ```python n = 6 bridges = [(0, 1), (0, 2), (1, 3), (2, 3), (2, 4), (3, 5), (4, 5)] start = 0 goal = 5 treasures = [1, 4] ``` Output ```python [0, 1, 3, 2, 4, 5] ``` # Notes * Ensure the function efficiently handles all specified input sizes. * Use a combination of BFS and multi-source BFS to identify the shortest path visiting all designated treasures. * Note which treasures are collected to avoid redundant visits, aiming to minimize the total number of bridges crossed.","solution":"from collections import deque, defaultdict def shortest_treasure_path(n, bridges, start, goal, treasures): def bfs_multisource(sources): q = deque([(source, [source]) for source in sources]) visited = set(sources) paths = {source: [source] for source in sources} while q: current, path = q.popleft() # Collect paths for each adjacent node for neighbor in adj_list[current]: if neighbor not in visited: visited.add(neighbor) new_path = path + [neighbor] paths[neighbor] = new_path q.append((neighbor, new_path)) return paths # Build the adjacency list for the graph adj_list = defaultdict(list) for u, v in bridges: adj_list[u].append(v) adj_list[v].append(u) # Perform multi-source BFS from treasures and the start node all_sources = treasures + [start] paths_from_sources = bfs_multisource(all_sources) # Initialize distance tracking and the best path containers complete_treasure_set = set(treasures) shortest_path = None shortest_length = float(\'inf\') # Perform BFS from the start to the goal while collecting treasures q = deque([(start, [], set())]) while q: current, path, collected_treasures = q.popleft() new_path = path + [current] # If we collect a treasure, include it in the set if current in treasures: collected_treasures.add(current) # If we reached the goal and have all treasures, check path length if current == goal and collected_treasures == complete_treasure_set: if len(new_path) < shortest_length: shortest_length = len(new_path) shortest_path = new_path continue # Continue BFS to explore further nodes for neighbor in adj_list[current]: if neighbor not in path: # Avoid revisiting nodes in the current path q.append((neighbor, new_path, collected_treasures.copy())) return shortest_path if shortest_path else []"},{"question":"# Problem Description You are required to write a function that detects cycles in a directed graph. Determine if the graph contains at least one cycle and return `True` if it does, or `False` otherwise. A directed graph is represented by an adjacency list, where each node points to a list of other nodes. # Function Signature ```python def has_cycle(graph: dict) -> bool: Function to detect if a directed graph contains a cycle. Args: graph (dict): A dictionary where the keys are graph nodes and the values are lists of nodes the key node points to. Returns: bool: True if there is at least one cycle in the graph, False otherwise. Example: >>> has_cycle({\'A\': [\'B\'], \'B\': [\'C\'], \'C\': [\'A\']}) True # There\'s a cycle: A -> B -> C -> A >>> has_cycle({\'A\': [\'B\'], \'B\': [\'C\'], \'C\': []}) False # No cycle in this graph >>> has_cycle({\'1\': [\'2\', \'3\'], \'2\': [\'4\'], \'3\': [], \'4\': [\'2\']}) True # There\'s a cycle: 2 -> 4 -> 2 ``` # Constraints - Each node in the graph is a unique identifier (e.g., string or integer). - There will be no duplicate edges or self-loops in the graph. - The graph can have disconnected components. # Requirements: 1. The function should consider various graph structures, including disconnected components and simple graphs. 2. The solution should be efficient, handling varying graph sizes appropriately. # Implementation Goals - Implement an efficient cycle detection algorithm for directed graphs (e.g., Depth-First Search (DFS) with recursion stack or Kahn\'s algorithm for topological sorting). # Example Scenarios - For `{\'A\': [\'B\'], \'B\': [\'C\'], \'C\': [\'A\']}`, the result should be `True`, because there\'s a cycle: A -> B -> C -> A. - For `{\'A\': [\'B\'], \'B\': [\'C\'], \'C\': []}`, the result should be `False`, indicating no cycles. # Further Considerations - How does your implementation efficiently handle large graphs? - How do you ensure all nodes, including those in disconnected components, are appropriately checked for cycles?","solution":"def has_cycle(graph: dict) -> bool: def dfs(node, visited, rec_stack): visited.add(node) rec_stack.add(node) for neighbor in graph.get(node, []): if neighbor not in visited: if dfs(neighbor, visited, rec_stack): return True elif neighbor in rec_stack: return True rec_stack.remove(node) return False visited = set() rec_stack = set() for node in graph: if node not in visited: if dfs(node, visited, rec_stack): return True return False"},{"question":"Problem Description You are given a list of transactions that represent deposits and withdrawals in a bank account. Your task is to implement a function to calculate the final balance after processing all the transactions. # Input - A list of strings where each string represents a transaction: - A positive integer prefixed with a \'+\' indicates a deposit (e.g., \\"+500\\"). - A negative integer prefixed with a \'-\' indicates a withdrawal (e.g., \\"-200\\"). # Output - An integer representing the final account balance after all transactions have been processed. # Function Signature ```python def calculate_balance(transactions: list[str]) -> int: pass ``` # Constraints - The initial account balance is 0. - The total value of deposits and withdrawals will fit within the range of a standard integer. - All transactions in the list are valid and in the correct format. # Example ```python transactions = [ \\"+1000\\", \\"-200\\", \\"+300\\", \\"-700\\", \\"+150\\" ] print(calculate_balance(transactions)) # Output: 550 ``` # Notes - Ensure that your function handles both positive and negative transactions correctly. - Think about the efficiency of your solution, especially considering large lists of transactions. - You may assume all transactions are valid and formatted correctly.","solution":"def calculate_balance(transactions: list[str]) -> int: Calculates the final balance after processing all transactions. balance = 0 for transaction in transactions: balance += int(transaction) return balance"},{"question":"# Problem Statement You are tasked with creating a `data_clean` function that processes a given list of strings. This function aims to standardize and clean the list to prepare it for further analysis. Specifically, the function should accept a list of strings and perform the following operations: 1. Trim leading and trailing whitespace from each string. 2. Convert all characters in each string to lowercase. 3. Remove any strings that are empty after trimming whitespace. 4. Sort the resulting list in alphabetical order. Write a Python function named `data_clean()` that takes a single parameter: - `data`: A list of strings, where each string can contain alphabetic characters, numeric characters, and special characters. The function should return a new list of cleaned strings. # Input - `data`: A list of strings with length ( 0 leq len(data) leq 10^4 ). # Output - A list of strings that have been trimmed, converted to lower case, filtered for emptiness, and sorted. # Example ```python # Example usage data = [\\" Alice \\", \\"BOB\\", \\" \\", \\"CHARLIE\\", \\" Eve\\"] print(data_clean(data)) # Output: # [\'alice\', \'bob\', \'charlie\', \'eve\'] data = [\\" ZEBRA\\", \\"lion \\", \\" Tiger\\"] print(data_clean(data)) # Output: # [\'lion\', \'tiger\', \'zebra\'] ``` # Note - The function should handle cases where the input list is empty. - Ensure that the function performs efficiently even with larger input lists. - Strings containing non-alphabetic characters should be retained and treated in the same manner as other strings.","solution":"def data_clean(data): Cleans the input list of strings by trimming whitespace, converting to lowercase, removing empty strings, and sorting the list. Args: data (list of str): List of strings to be cleaned. Returns: List of str: Cleaned list of strings. cleaned_data = [s.strip().lower() for s in data if s.strip()] return sorted(cleaned_data)"},{"question":"You are tasked with creating a simplified hashing algorithm and demonstrating its application. Please follow the requirements below: # Scenario You are given the task of implementing a basic hashing function that maps strings to integer hash values. The hashing function should perform simple operations to ensure a uniform distribution of hashes. # Function Signature ```python def simple_hash(input_string: str, max_size: int) -> int: Computes a hash for the given input string. Parameters: - input_string: The string to be hashed. - max_size: The maximum size for the hash table (i.e., max hash value). Returns: - An integer which is the hash value of the input string. ``` # Constraints 1. The input string will consist of alphanumeric characters and spaces only. 2. The `max_size` will be a positive integer. 3. The hash value should be between 0 and `max_size - 1`. # Examples ```python # Hashing example hash_value1 = simple_hash(\\"hello\\", 100) print(f\\"Hash value for \'hello\': {hash_value1}\\") hash_value2 = simple_hash(\\"world\\", 100) print(f\\"Hash value for \'world\': {hash_value2}\\") hash_value3 = simple_hash(\\"hello world\\", 100) print(f\\"Hash value for \'hello world\': {hash_value3}\\") # Expected output: # The hash values should be integers within the range [0, 99] # Example: # Hash value for \'hello\': 12 # Hash value for \'world\': 34 # Hash value for \'hello world\': 56 ``` # Performance Requirements - The solution should handle typical edge cases, such as empty strings or very short strings. - Ensure that the hashing function is sufficiently fast and distributes hash values uniformly within the given `max_size`. - Optimize for simplicity and clarity, while maintaining efficiency.","solution":"def simple_hash(input_string: str, max_size: int) -> int: Computes a hash for the given input string. Parameters: - input_string: The string to be hashed. - max_size: The maximum size for the hash table (i.e., max hash value). Returns: - An integer which is the hash value of the input string. hash_value = 0 for i, char in enumerate(input_string): hash_value += (i + 1) * ord(char) return hash_value % max_size"},{"question":"# Coding Question Your task is to implement a function that simulates a simple version of the \\"Word Wrap\\" algorithm which breaks a given text into lines of given maximum width. Each line should not exceed the specified width and words in a single line should be separated by a single space. Function Signature ```python def word_wrap(text: str, max_width: int) -> str: pass ``` Input - `text` (str): The input text that needs to be wrapped. - `max_width` (int): The maximum allowed width for each line. Output - Returns a string representing the text broken into lines. Each line should end with a newline character (\'n\') except the last line. Constraints - The input `text` contains only printable ASCII characters and spaces. - `1 <= max_width <= 100` - The length of any word in `text` is less than or equal to `max_width`. Example ```python text = \\"This is an example of text that needs word wrapping.\\" max_width = 15 # Expected Output # This is an # example of text # that needs word # wrapping. print(word_wrap(text, max_width)) # Output: # \\"This is annexample of textnthat needs wordnwrapping.\\" ``` Implement the `word_wrap` function to format the input text into multiple lines such that the length of each line does not exceed the specified width. Ensure words are not split in the middle and each line ends with a newline character (\'n\') except for the last one.","solution":"def word_wrap(text: str, max_width: int) -> str: Broken down the given text into lines of given maximum width. Each line should not exceed the specified width and words in a single line should be separated by a single space. words = text.split() lines = [] current_line = [] current_length = 0 for word in words: if current_length + len(word) + len(current_line) > max_width: lines.append(\\" \\".join(current_line)) current_line = [word] current_length = len(word) else: current_line.append(word) current_length += len(word) if current_line: lines.append(\\" \\".join(current_line)) return \\"n\\".join(lines)"},{"question":"# Context In computer science, binary trees are a widely used data structure for organizing hierarchical data. They provide efficiencies in both search and modification operations. One common problem is finding the lowest common ancestor in a binary tree, which has practical applications in databases, file systems, and more. # Task Implement a class `BinaryTree` to handle a binary tree structure and find the lowest common ancestor (LCA) of two nodes. # Your Task Function Implementations **Class**: `BinaryTree` 1. **__init__(self, root: \'TreeNode\')** - **Input**: A `TreeNode` representing the root of the binary tree. - **Functionality**: Initialize the binary tree with the given root node. 2. **lowest_common_ancestor(self, p: \'TreeNode\', q: \'TreeNode\') -> \'TreeNode\'** - **Input**: Two `TreeNode` objects, `p` and `q`. - **Output**: Returns the `TreeNode` that represents their lowest common ancestor. - **Time Complexity**: O(n), where `n` is the number of nodes in the tree. Data Classes **Class**: `TreeNode` ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Constraints - Each node\'s value is unique. - `p` and `q` are different and both values exist in the binary tree. - The number of nodes in the tree will be in the range `1` to `10^4`. # Example ```python # Assuming the implementation is already done. # Construct the tree: # 3 # / # 5 1 # / / # 6 2 0 8 # / # 7 4 root = TreeNode(3) root.left = TreeNode(5) root.right = TreeNode(1) root.left.left = TreeNode(6) root.left.right = TreeNode(2) root.right.left = TreeNode(0) root.right.right = TreeNode(8) root.left.right.left = TreeNode(7) root.left.right.right = TreeNode(4) bt = BinaryTree(root) # Find LCA of nodes 5 and 1 print(bt.lowest_common_ancestor(root.left, root.right).val) # Output: 3 # Find LCA of nodes 5 and 4 print(bt.lowest_common_ancestor(root.left, root.left.right.right).val) # Output: 5 ``` Create implementations to ensure the `BinaryTree` features work correctly with optimal time complexity.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BinaryTree: def __init__(self, root: TreeNode): self.root = root def lowest_common_ancestor(self, p: TreeNode, q: TreeNode) -> TreeNode: def recurse_tree(current_node): if not current_node: return None if current_node == p or current_node == q: return current_node left = recurse_tree(current_node.left) right = recurse_tree(current_node.right) if left and right: return current_node return left if left else right return recurse_tree(self.root)"},{"question":"# Problem Statement Write a program that simulates a simple file system using a tree structure. Each node in the tree can represent either a file or a directory. The root node represents the root directory. Your task is to implement functionality to add files/directories, retrieve the list of files/directories, and generate the full path of a specific node (file/directory) in the tree. # Constraints 1. Each directory can contain up to 1,000 files or directories. 2. The depth of the tree (file system) will not exceed 20 levels. 3. Directory and file names will contain only alphanumeric characters and will be unique within the same directory. # Function Signature ```python class TreeNode: def __init__(self, name, node_type): pass def add_child(self, child_node): pass def get_children(self): pass def get_full_path(self): pass def add_node(root, path, name, node_type): pass ``` # Input * A series of operations to construct the file system. - Each operation will be one of the following formats: 1. `(\'add_dir\', \'path\', \'dir_name\')` - to add a directory at a specified path. 2. `(\'add_file\', \'path\', \'file_name\')` - to add a file at a specified path. 3. `(\'ls\', \'path\')` - to list the contents of a directory at a specified path. 4. `(\'full_path\', \'path\', \'name\')` - to get the full path of a specified node (file/directory). # Output * A list of strings representing the results of the \'ls\' and \'full_path\' operations. # Example ```python operations = [ (\'add_dir\', \'/\', \'home\'), (\'add_dir\', \'/home\', \'user\'), (\'add_file\', \'/home/user\', \'file1.txt\'), (\'add_file\', \'/home/user\', \'file2.txt\'), (\'ls\', \'/home/user\'), (\'full_path\', \'/home\', \'user\') ] #3. Expected Output [\'file1.txt\', \'file2.txt\', \'/home/user\'] ``` # Explanation 1. Implement the `TreeNode` class to represent each node (either a file or directory) in the tree. 2. Implement the `add_node` function to add directories or files to the file system tree. 3. Implement methods to list the contents of a directory and to get the full path of a specified node in the tree. 4. Provide logic to handle operations based on the provided inputs and generate respective outputs for \'ls\' and \'full_path\' operations. # Notes - Ensure your implementation is efficient and can handle the constraints mentioned. - Handle edge cases, such as adding to non-existent directories or attempting to list the contents of an empty directory. - The root path is represented by a single forward slash `\'/\'`.","solution":"class TreeNode: def __init__(self, name, node_type): self.name = name self.node_type = node_type self.children = {} def add_child(self, child_node): self.children[child_node.name] = child_node def get_children(self): return sorted(self.children.keys()) def get_full_path(self): return self._get_full_path_helper().rstrip(\'/\') def _get_full_path_helper(self): if self.name == \'/\': return \'/\' return f\\"{self.parent._get_full_path_helper()}{self.name}/\\" def add_node(root, path, name, node_type): path_nodes = path.strip(\'/\').split(\'/\') current = root for node in path_nodes: if node: current = current.children.get(node) if current is None: raise ValueError(f\\"Path \'{path}\' does not exist\\") new_node = TreeNode(name, node_type) new_node.parent = current current.add_child(new_node) return new_node def filesystem_operations(operations): root = TreeNode(\'/\', \'dir\') result = [] for operation in operations: if operation[0] == \'add_dir\': add_node(root, operation[1], operation[2], \'dir\') elif operation[0] == \'add_file\': add_node(root, operation[1], operation[2], \'file\') elif operation[0] == \'ls\': path_nodes = operation[1].strip(\'/\').split(\'/\') current = root for node in path_nodes: if node: current = current.children.get(node) if current is None: raise ValueError(f\\"Path \'{operation[1]}\' does not exist\\") result.append(current.get_children()) elif operation[0] == \'full_path\': path, name = operation[1], operation[2] path_nodes = path.strip(\'/\').split(\'/\') current = root for node in path_nodes: if node: current = current.children.get(node) if current is None: raise ValueError(f\\"Path \'{path}\' does not exist\\") if name not in current.children: raise ValueError(f\\"Node \'{name}\' does not exist in path \'{path}\'\\") result.append(current.children[name].get_full_path()) return result"},{"question":"# Matrix Transposition **Context:** You are working on a data analysis project that involves matrix manipulation. One essential operation in matrix algebra is matrix transposition. Transposing a matrix means swapping its rows and columns. **Objective:** Write a function `transpose_matrix` that takes a 2D list (matrix) as input and returns its transpose. **Function Signature:** ```python def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: ``` **Inputs:** * `matrix (List[List[int]])`: a 2D list representing the matrix to be transposed. Assume all rows are of the same length. **Outputs:** * A `List[List[int]]` representing the transposed matrix. **Constraints:** * The matrix can be of any dimension but non-empty (at least 1x1). **Example Usage:** ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] transposed_matrix = transpose_matrix(matrix) print(transposed_matrix) # Output: [[1, 4, 7], [2, 5, 8], [3, 6, 9]] ``` **Notes:** * Ensure your solution is efficient and can handle larger matrices. * Consider edge cases such as a matrix with only one row or one column.","solution":"from typing import List def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: Returns the transpose of the given matrix. Args: matrix (List[List[int]]): 2D list representing the matrix to be transposed. Returns: List[List[int]]: Transposed matrix. # Number of rows in the original matrix becomes number of columns in the transposed matrix # Number of columns in the original matrix becomes number of rows in the transposed matrix return [list(row) for row in zip(*matrix)]"},{"question":"# Context: You are working on a company\'s web scraping tool for extracting data from various e-commerce websites. As part of the data extraction process, they want to filter out products that are currently out of stock. They\'ve asked you to improve the existing implementation by adding a new method that will help identify and remove these out-of-stock products. # Task: Extend the `ProductFilter` class to support filtering out products based on their availability status. # Requirements: 1. **Function Implementation:** - Add a method `filter_out_of_stock` to the `ProductFilter` class which takes a list of `Product` objects and returns a new list containing only those that are in stock. - Ensure that the `Product` class has an attribute `is_in_stock` which indicates whether the product is available or not. 2. **Edge Case Handling:** - Ensure the method handles lists with mixed in-stock and out-of-stock products correctly. - The method should also handle an empty list input gracefully. 3. **Testing:** - Demonstrate the correctness of your implementation with several test cases. **Input and Output formats:** - **Input:** A list of `Product` objects. - **Output:** A filtered list of `Product` objects that are in stock. **Constraints:** - Assume the `Product` and `ProductFilter` classes are already defined. - The `Product` class contains at least the attributes `name` (a string) and `is_in_stock` (a boolean). # Example: ```python class Product: def __init__(self, name, is_in_stock): self.name = name self.is_in_stock = is_in_stock class ProductFilter: @staticmethod def filter_out_of_stock(products): return [product for product in products if product.is_in_stock] products = [ Product(\\"Laptop\\", True), Product(\\"Smartphone\\", False), Product(\\"Keyboard\\", True) ] in_stock_products = ProductFilter.filter_out_of_stock(products) assert len(in_stock_products) == 2 assert in_stock_products[0].name == \\"Laptop\\" assert in_stock_products[1].name == \\"Keyboard\\" ``` **Note:** Ensure that your implementation does not modify the original list of products.","solution":"class Product: def __init__(self, name, is_in_stock): self.name = name self.is_in_stock = is_in_stock class ProductFilter: @staticmethod def filter_out_of_stock(products): return [product for product in products if product.is_in_stock]"},{"question":"# Robot Grid Pathfinding with Obstacles You are given a grid representing a map of obstacles and open spaces. Your task is to determine if there exists a path for a robot from the top-left corner `(0, 0)` to the bottom-right corner `(N-1, N-1)` of this grid. The robot can move up, down, left, or right but cannot move through obstacles. # Input Format - An integer `N` representing the size of the grid (the grid is `N x N`). - A 2D list `grid` of size `N x N`, where each element is either `0` (representing an open space) or `1` (representing an obstacle). # Output Format - A boolean `True` if there exists a path from `(0, 0)` to `(N-1, N-1)`, otherwise `False`. # Constraints - 1 ≤ N ≤ 1000 - Element values are either `0` or `1` # Function Signature ```python def robot_path_exists(N: int, grid: List[List[int]]) -> bool: ``` # Example ```python # Example 1 N = 5 grid = [ [0, 0, 1, 0, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0], [1, 1, 1, 0, 1], [0, 0, 0, 0, 0] ] assert robot_path_exists(N, grid) == True # Example 2 N = 3 grid = [ [0, 1, 0], [1, 1, 0], [0, 0, 0] ] assert robot_path_exists(N, grid) == False ``` # Notes 1. You can use breadth-first search (BFS) or depth-first search (DFS) to solve the pathfinding problem. 2. Analyze edge cases where the grid size is minimum (N=1) or the start/end positions are blocked. 3. Ensure to handle large grid sizes efficiently to avoid timeouts.","solution":"from typing import List from collections import deque def robot_path_exists(N: int, grid: List[List[int]]) -> bool: Determines if a path exists from the top-left corner to the bottom-right corner of the grid. # Edge case: if start or end is blocked if grid[0][0] == 1 or grid[N-1][N-1] == 1: return False # Directions: down, up, right, left directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] # BFS initialization queue = deque([(0, 0)]) visited = set((0, 0)) while queue: x, y = queue.popleft() # If we reach the bottom-right corner if x == N-1 and y == N-1: return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < N and grid[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) return False"},{"question":"# Unique String Identifier Finder **Context**: In many applications, it\'s important to find and identify unique elements within a dataset. This can promote efficiency in data retrieval operations and is crucial in operations like removing duplicates or identifying anomalies. **Your Task**: Implement a function that finds the first non-repeating character in a given string. If there are no unique characters, return an empty string `\'\'`. Function Signature ```python def first_unique_character(s: str) -> str: ``` Input - `s`: A string consisting of lowercase English letters. Output - Returns the first non-repeating character as a string. - If every character repeats, return `\'\'`. Constraints - The string will contain at least 1 character and at most (10^5) characters. - The string will only contain lowercase English letters. Example ```python >>> first_unique_character(\\"leetcode\\") \'l\' >>> first_unique_character(\\"aabbcc\\") \'\' >>> first_unique_character(\\"swiss\\") \'w\' ``` Requirements - Your solution should be optimized to handle the upper limit of the string length efficiently. - Aim for an algorithm with linear time complexity, preferably ( O(n) ). Hints - Consider using a data structure that helps track the frequency and position of characters in one pass through the string.","solution":"def first_unique_character(s: str) -> str: Finds the first non-repeating character in a given string. :param s: The input string. :return: The first non-repeating character, or an empty string if there are no unique characters. from collections import defaultdict # Step 1: Track the frequency of each character in the string char_frequency = defaultdict(int) for char in s: char_frequency[char] += 1 # Step 2: Find the first character that has a frequency of 1 for char in s: if char_frequency[char] == 1: return char # If no unique character found, return an empty string return \'\'"},{"question":"# Context In this assessment, you are required to implement a function that focuses on merging two pre-ordered lists while maintaining the order of the elements. Your competence in handling list manipulations and understanding of the merge operation from the merge sort algorithm will be crucial in solving this problem effectively. # Problem Statement Design a function `merge_two_sorted_lists` that merges two given sorted lists into a single sorted list in non-descending order. # Function Signature ```python def merge_two_sorted_lists(list1: list[int], list2: list[int]) -> list[int]: ``` # Input * Two lists of integers `list1` and `list2`, both already sorted in non-descending order. # Output * A single sorted list containing all the elements from `list1` and `list2` in non-descending order. # Constraints * The input lists `list1` and `list2` can contain any integer values (negative, positive, or zero). * The length of each list will be between 0 and 1000. * The output list should preserve the non-descending order. # Example ```python # Example 1 list1 = [1, 3, 5] list2 = [2, 4, 6] result = merge_two_sorted_lists(list1, list2) print(result) # Output: [1, 2, 3, 4, 5, 6] # Example 2 list1 = [1, 2, 3] list2 = [] result = merge_two_sorted_lists(list1, list2) print(result) # Output: [1, 2, 3] # Example 3 list1 = [] list2 = [4, 5, 6] result = merge_two_sorted_lists(list1, list2) print(result) # Output: [4, 5, 6] # Example 4 list1 = [-3, -1, 2] list2 = [-2, 0, 1] result = merge_two_sorted_lists(list1, list2) print(result) # Output: [-3, -2, -1, 0, 1, 2] ``` # Hints * Consider using indices to iterate through both lists and compare their elements. * An efficient method involves linear iteration through both lists to construct the result list. * Handle edge cases where one or both input lists are empty.","solution":"def merge_two_sorted_lists(list1: list[int], list2: list[int]) -> list[int]: Merges two sorted lists into a single sorted list in non-descending order. merged_list = [] i, j = 0, 0 while i < len(list1) and j < len(list2): if list1[i] < list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 while i < len(list1): merged_list.append(list1[i]) i += 1 while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"# Problem Description: Write a function `convert_to_rpn` that converts an infix arithmetic expression to its equivalent Reverse Polish Notation (RPN). The input expression string will contain non-negative integers and the operators `+`, `-`, `*`, `/`, and parentheses `(`, `)`. The output should be a string representing the RPN. Reverse Polish Notation (RPN), also known as postfix notation, is a mathematical notation in which every operator follows all of its operands. In this notation, the operators appear in the order in which they need to be applied. # Requirements: - **Input Format**: ```python def convert_to_rpn(expression: str) -> str ``` - `expression`: A string containing the arithmetic expression in infix notation (e.g., `\\"3 + 4 * 2 / ( 1 - 5 )\\"`) - **Output Format**: - Return a string representing the equivalent expression in Reverse Polish Notation. # Example Usage: ```python print(convert_to_rpn(\\"3 + 4 * 2 / ( 1 - 5 )\\")) # Output: \\"3 4 2 * 1 5 - / +\\" print(convert_to_rpn(\\"( 1 + 2 ) * ( 3 / 4 )\\")) # Output: \\"1 2 + 3 4 / *\\" ``` # Notes: - Ensure to handle spaces in the input expression correctly. - Implement the Shunting-yard algorithm to perform the conversion from infix to RPN. - The output RPN should be a single string with elements separated by spaces. - Parentheses have the highest precedence, followed by `*` and `/`, and `+` and `-` have the lowest precedence. - Assume the input is always a valid arithmetic expression.","solution":"def convert_to_rpn(expression: str) -> str: Converts an infix arithmetic expression to its equivalent Reverse Polish Notation (RPN). def precedence(op): if op in (\'+\', \'-\'): return 1 if op in (\'*\', \'/\'): return 2 return 0 output = [] stack = [] tokens = expression.split() for token in tokens: if token.isdigit(): output.append(token) elif token == \'(\': stack.append(token) elif token == \')\': while stack and stack[-1] != \'(\': output.append(stack.pop()) stack.pop() else: # token is an operator while stack and precedence(stack[-1]) >= precedence(token): output.append(stack.pop()) stack.append(token) while stack: output.append(stack.pop()) return \\" \\".join(output)"},{"question":"# Problem Statement You are tasked with creating a simple file compression and decompression utility using a basic run-length encoding (RLE) algorithm. The objective is to implement two primary functions: one for compressing a text string to reduce its size, and another for decompressing the encoded string back to its original form. # Requirements: 1. **Function to Compress Text**: - Name: `compress_rle` - Input: A non-empty string `text`. - Output: A string representing the compressed form using run-length encoding. - Constraints: - Ensure the compressed string has consistent and valid formatting. - Handle edge cases such as single-character strings appropriately. - Raise appropriate exceptions for invalid inputs. 2. **Function to Decompress Text**: - Name: `decompress_rle` - Input: A non-empty string `encoded_text` representing the run-length encoded string. - Output: The original uncompressed string. - Constraints: - Ensure the decompression process reliably retrieves the original text. - Handle edge cases such as incorrectly formatted encoded strings. - Raise appropriate exceptions for invalid inputs. # Example: ```python class RLECompressor: @staticmethod def compress_rle(text: str) -> str: # Your implementation here pass @staticmethod def decompress_rle(encoded_text: str) -> str: # Your implementation here pass ``` # Notes: - In run-length encoding, consecutive elements with the same value are replaced with a single element and a count. - For example, the string \\"AAAABBBCCDAA\\" would be compressed to \\"4A3B2C1D2A\\". - Ensure thorough testing of your implementation to cover various scenarios, such as strings with no repetitions, varying character types, and extremely long strings. - Include comprehensive error handling to manage invalid input scenarios and edge cases effectively.","solution":"class RLECompressor: @staticmethod def compress_rle(text: str) -> str: if not text or not isinstance(text, str): raise ValueError(\\"Invalid input. Non-empty string expected.\\") compressed = [] count = 1 for i in range(1, len(text)): if text[i] == text[i - 1]: count += 1 else: compressed.append(f\\"{count}{text[i - 1]}\\") count = 1 compressed.append(f\\"{count}{text[-1]}\\") # Add the last group return \'\'.join(compressed) @staticmethod def decompress_rle(encoded_text: str) -> str: if not encoded_text or not isinstance(encoded_text, str): raise ValueError(\\"Invalid input. Non-empty string expected.\\") decompressed = [] count = \'\' for char in encoded_text: if char.isdigit(): count += char else: if count == \'\': raise ValueError(\\"Invalid encoding format.\\") decompressed.append(char * int(count)) count = \'\' if count != \'\': raise ValueError(\\"Invalid encoding format.\\") return \'\'.join(decompressed)"},{"question":"# Problem Statement You are developing a rate-limiter for an online service to prevent abuse and ensure fair usage. A rate-limiter controls how frequently a user can make requests in a specified time frame. Your task is to implement a class `RateLimiter` that tracks the requests per user and rejects requests if the user has exceeded the rate limit. # Class Specifications Class Signature ```python class RateLimiter: def __init__(self, limit: int, time_window: int): pass def request(self, user_id: str, timestamp: int) -> bool: pass ``` Methods - `__init__(self, limit: int, time_window: int)`: Initializes a rate limiter with a maximum of `limit` requests allowed per `time_window` seconds for each user. For example, if `limit=5` and `time_window=60`, a user can make up to 5 requests per 60 seconds. - `request(self, user_id: str, timestamp: int) -> bool`: Processes a request from `user_id` at the given `timestamp` (unix timestamp). Returns `True` if the request is allowed, otherwise `False`. # Example ```python limiter = RateLimiter(limit=3, time_window=10) print(limiter.request(\\"user1\\", 1)) # True -- First request print(limiter.request(\\"user1\\", 2)) # True -- Second request print(limiter.request(\\"user1\\", 3)) # True -- Third request print(limiter.request(\\"user1\\", 4)) # False -- Exceeds limit # After 10 seconds, user1 can make new requests print(limiter.request(\\"user1\\", 12)) # True -- Request allowed after time window ``` # Notes - Each user is tracked individually, with requests limited within a sliding window of `time_window` seconds. - Handle edge cases such as: - Large number of requests in a short period. - Requests arriving exactly at the same time. - Requests falling out of the time window. # Constraints - `limit` (1 ≤ limit ≤ 100) - `time_window` (1 ≤ time_window ≤ 10^4) in seconds - `timestamp` is a non-negative integer representing a Unix timestamp. - Requests should be processed efficiently to handle a high volume of users.","solution":"from collections import deque class RateLimiter: def __init__(self, limit: int, time_window: int): self.limit = limit self.time_window = time_window self.user_requests = {} def request(self, user_id: str, timestamp: int) -> bool: if user_id not in self.user_requests: self.user_requests[user_id] = deque() # Remove requests that are out of the time window while self.user_requests[user_id] and self.user_requests[user_id][0] <= timestamp - self.time_window: self.user_requests[user_id].popleft() if len(self.user_requests[user_id]) < self.limit: self.user_requests[user_id].append(timestamp) return True else: return False"},{"question":"# Log File Analysis and Cleaning You are asked to build a utility that processes and cleans a web server log file. The log file contains entries in the Common Log Format (CLF), and your task is to filter and clean invalid entries, count the number of requests per status code, and save the cleaned log to a new file. Implement the following two functions: 1. **filter_valid_entries**: This function should read the log file, filter out invalid entries (e.g., malformed lines that do not match the CLF format), and return a list of valid log entries. * **Input**: A string representing the file path of the log file to be processed. * **Output**: A list of strings, where each string is a valid log entry. * **Constraints**: - Ensure the function handles file reading errors appropriately. - The function must correctly identify and skip invalid log entries. - Use regular expressions to match valid log entries. 2. **count_requests_per_status**: This function should take the list of valid log entries and count the number of requests for each HTTP status code, then return a dictionary with status codes as keys and counts as values. * **Input**: A list of strings, each representing a valid log entry. * **Output**: A dictionary where the keys are status codes (as strings) and the values are the counts of requests with those status codes. * **Constraints**: - Ensure the function correctly parses the status codes from the log entries. - Handle edge cases such as logs without a status code properly. 3. **save_cleaned_log**: This function should save the list of valid log entries to a new file. * **Input**: Two strings - the original file path and the new file path to save the cleaned log. * **Output**: None (side effect of saving the file). * **Constraints**: - Ensure the function handles file writing errors appropriately. - The function must write valid log entries to the new file in the same format as the original. # Example ```python # Example usage if __name__ == \\"__main__\\": filtered_entries = filter_valid_entries(\\"webserver.log\\") status_count = count_requests_per_status(filtered_entries) save_cleaned_log(\\"webserver.log\\", \\"cleaned_webserver.log\\") print(f\\"Status code counts: {status_count}\\") ``` # Notes - Ensure robust error handling and consider edge cases such as empty log files. - For testing, you can create sample log files with a mix of valid and invalid entries. - Regular expressions should be efficient and precise in matching valid log entries. - Performance considerations: handle large log files efficiently without excessive memory use.","solution":"import re def filter_valid_entries(file_path): Reads the log file and filters out invalid entries. Returns a list of valid log entries. valid_entries = [] clf_pattern = re.compile( r\'^S+ S+ S+ [S+ S+] \\"S+ S+ S+\\" d{3} d+\' ) try: with open(file_path, \'r\') as file: for line in file: if clf_pattern.match(line): valid_entries.append(line.strip()) except IOError as e: print(f\\"Error reading file {file_path}: {e}\\") return valid_entries def count_requests_per_status(valid_entries): Takes a list of valid log entries and counts the number of requests for each HTTP status code. Returns a dictionary with status codes as keys and counts as values. status_count = {} for entry in valid_entries: status_code = re.search(r\'(?<=s)d{3}(?=sd+)\', entry) if status_code: code = status_code.group() if code in status_count: status_count[code] += 1 else: status_count[code] = 1 return status_count def save_cleaned_log(original_file_path, new_file_path): Saves the list of valid log entries to a new file. valid_entries = filter_valid_entries(original_file_path) try: with open(new_file_path, \'w\') as file: for entry in valid_entries: file.write(entry + \'n\') except IOError as e: print(f\\"Error writing to file {new_file_path}: {e}\\")"},{"question":"# Triple Duplicate Finder Write a function that checks for the existence of any element appearing three times consecutively in a given list. Your task is to enhance the given code base by incorporating this function so that it can be integrated with an existing application logic module. The function should effectively scan through the provided list and identify any sequence of the same element repeating exactly three times in a row. Requirements: 1. The function should accept a list of integers as its input. 2. It should return `True` if any element appears three times consecutively, and `False` otherwise. 3. The function should be efficient and handle edge cases such as very short lists or lists with no consecutive duplicates. Input: * A list of integers to check for triple consecutive duplicates. Output: * A boolean value indicating the presence of any element repeating three times consecutively in the list. Example: Input: ```python numbers = [4, 2, 2, 2, 1, 7, 7, 7, 3] ``` Output: ```python True ``` Example Explanation: In the given input list, the value `2` appears three times consecutively, as well as the value `7`. # Implementation Implement the following function: ```python def has_triple_consecutive(numbers: list[int]) -> bool: Check if any element appears three times consecutively in the list. Parameters: numbers (list[int]): The list of integers to check. Returns: bool: True if any element appears three times consecutively, otherwise False. for i in range(len(numbers) - 2): if numbers[i] == numbers[i + 1] == numbers[i + 2]: return True return False # Example usage numbers = [4, 2, 2, 2, 1, 7, 7, 7, 3] print(has_triple_consecutive(numbers)) # Output: True ```","solution":"def has_triple_consecutive(numbers: list[int]) -> bool: Check if any element appears three times consecutively in the list. Parameters: numbers (list[int]): The list of integers to check. Returns: bool: True if any element appears three times consecutively, otherwise False. for i in range(len(numbers) - 2): if numbers[i] == numbers[i + 1] == numbers[i + 2]: return True return False"},{"question":"# String Permutation Checker You are given two strings and you need to check if one string is a permutation of the other. A string is considered a permutation of another if it contains the same characters with the same frequencies, but in different orders. # Implementation Details Implement the function `are_permutations` that takes two strings as input and returns a boolean indicating whether the two strings are permutations of each other. Function Signature ```python def are_permutations(str1: str, str2: str) -> bool: ... ``` Inputs - `str1`: A string containing alphanumeric characters. - `str2`: A string containing alphanumeric characters. Output - Return a boolean indicating whether the two strings are permutations of each other (True) or not (False). Constraints - The strings can have a length ranging from `1` to `10000`. Example ```python str1 = \\"listen\\" str2 = \\"silent\\" print(are_permutations(str1, str2)) # Outputs: True ``` Note - You should not use any built-in sorting functions. - Consider time complexity and aim for an efficient solution using dictionaries or other suitable data structures to count character frequencies.","solution":"def are_permutations(str1: str, str2: str) -> bool: Determines if str1 is a permutation of str2. Args: str1 (str): The first string. str2 (str): The second string. Returns: bool: True if str1 is a permutation of str2, False otherwise. if len(str1) != len(str2): return False char_count = {} for char in str1: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 for char in str2: if char in char_count: char_count[char] -= 1 else: return False for count in char_count.values(): if count != 0: return False return True"},{"question":"# User Tweet Analyzer You are tasked with creating a utility that fetches tweets from a specified Twitter user using the Twitter API and processes the results to return specific fields requested by the user. This function should help in retrieving data relevant to specific needs (such as tweet texts, creation dates, or retweet counts) from the most recent tweets. # Function Signature ```python def get_user_tweets(username: str, limit: int = 1, wanted_data: list | None = None) -> dict: ... ``` # Input Descriptions - `username` (str): The Twitter handle of the user to fetch tweets from (e.g., \\"elonmusk\\"). - `limit` (int, optional): The number of tweets to fetch. Default is 1. - `wanted_data` (list, optional): A list of specific fields to fetch from each tweet. If not provided, all data for each tweet will be returned. Possible values are: * \\"created_at\\", \\"id\\", \\"text\\", \\"truncated\\", \\"entities\\", * \\"source\\", \\"in_reply_to_status_id\\", \\"in_reply_to_user_id\\", \\"in_reply_to_screen_name\\", * \\"geo\\", \\"contributors\\", \\"retweeted_status_id\\", \\"user_id\\", \\"user_screen_name\\", * \\"retweet_count\\", \\"favorite_count\\", \\"favorited\\", \\"retweeted\\", \\"lang\\". # Output Description The function should return a dictionary with the requested data fields for each tweet. The dictionary keys are the tweet indices (0 to `limit - 1`), and the values are dictionaries containing the available requested fields. # Constraints 1. If `wanted_data` contains fields not listed in the provided possible values, the function should raise a `ValueError` with an appropriate message. 2. In case of rate limiting (HTTP 429), the function should raise a `requests.HTTPError` with the response details. # Example ```python # Fetch 3 recent tweets from the user \\"elonmusk\\", requesting text, creation date, and retweet count result = get_user_tweets(\\"elonmusk\\", limit=3, wanted_data=[\\"text\\", \\"created_at\\", \\"retweet_count\\"]) print(result) ``` # Expected Result: ```python { 0: { \'text\': \'Tweet content...1\', \'created_at\': \'2023-10-01T15:04:05Z\', \'retweet_count\': 1200 }, 1: { \'text\': \'Tweet content...2\', \'created_at\': \'2023-10-01T14:03:04Z\', \'retweet_count\': 1100 }, 2: { \'text\': \'Tweet content...3\', \'created_at\': \'2023-10-01T13:02:03Z\', \'retweet_count\': 1000 } } ``` # Additional Information Ensure the function has robust error handling for scenarios such as network failures, invalid Twitter handles, and rate-limited responses. Validate the fields requested by the user against the provided list of possible values before making the API call.","solution":"import requests TWITTER_API_BASE_URL = \\"https://api.twitter.com/2/tweets\\" TWITTER_BEARER_TOKEN = \\"YOUR_TOKEN_HERE\\" # Replace with your actual bearer token POSSIBLE_FIELDS = [ \\"created_at\\", \\"id\\", \\"text\\", \\"truncated\\", \\"entities\\", \\"source\\", \\"in_reply_to_status_id\\", \\"in_reply_to_user_id\\", \\"in_reply_to_screen_name\\", \\"geo\\", \\"contributors\\", \\"retweeted_status_id\\", \\"user_id\\", \\"user_screen_name\\", \\"retweet_count\\", \\"favorite_count\\", \\"favorited\\", \\"retweeted\\", \\"lang\\" ] def get_user_tweets(username: str, limit: int = 1, wanted_data: list | None = None) -> dict: if wanted_data is None: wanted_data = POSSIBLE_FIELDS else: for field in wanted_data: if field not in POSSIBLE_FIELDS: raise ValueError(f\\"Invalid field requested: {field}\\") headers = { \\"Authorization\\": f\\"Bearer {TWITTER_BEARER_TOKEN}\\" } params = { \\"screen_name\\": username, \\"count\\": limit, \\"tweet_mode\\": \\"extended\\" # Ensures we get full text } response = requests.get(f\\"{TWITTER_API_BASE_URL}/user_timeline.json\\", headers=headers, params=params) if response.status_code == 429: # Rate limiting raise requests.HTTPError(f\\"Rate limit exceeded: {response.text}\\", response=response) response.raise_for_status() tweets = response.json() result = {} for idx, tweet in enumerate(tweets): extracted_tweet = {field: tweet.get(field) for field in wanted_data} result[idx] = extracted_tweet return result"},{"question":"# Question Scenario You are designing a system to help a library manage its collection of books. One of the functionalities that need to be implemented is the ability to merge two sorted lists of books based on their ISBN numbers. Task Write a function that merges two sorted lists of integers representing ISBN numbers into a single sorted list. You should aim for an efficient solution that takes advantage of the fact that both lists are already sorted. Function Signature ```python def merge_sorted_lists(list1: List[int], list2: List[int]) -> List[int]: ``` Input - `list1` (List[int]): A sorted list of integers representing ISBN numbers. - `list2` (List[int]): Another sorted list of integers representing ISBN numbers. Output - `List[int]`: A new sorted list containing all integers from `list1` and `list2`. Constraints - The combined size of the lists will be at most (10^6) elements. - The integers in the lists will be between (-10^9) and (10^9). Examples ```python >>> merge_sorted_lists([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_lists([10, 20, 30], [5, 25, 35]) [5, 10, 20, 25, 30, 35] >>> merge_sorted_lists([-8, -3, 0, 2], [-7, 1, 5, 9]) [-8, -7, -3, 0, 1, 2, 5, 9] ``` Additional Notes - Try to solve the problem with a time complexity of O(n + m), where n and m are the lengths of the input lists. - You may assume all inputs are valid and no input validation is required.","solution":"from typing import List def merge_sorted_lists(list1: List[int], list2: List[int]) -> List[int]: merged_list = [] i, j = 0, 0 while i < len(list1) and j < len(list2): if list1[i] <= list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 while i < len(list1): merged_list.append(list1[i]) i += 1 while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"# Coding Assessment Question **Scenario**: As a software developer for an automation company, you have been tasked to create a program that manipulates lists of numeric data for various operations performed by automated machines. Your task involves writing functions to calculate cumulative sum, find the maximum difference between consecutive elements, and compute the moving average of a list of numbers. The **Moving Average** is calculated as the mean of the last `k` numbers in the list. # Task 1. Implement a function `cumulative_sum` that computes the cumulative sum of a list. 2. Implement a function `max_consecutive_difference` that finds the maximum difference between consecutive elements in a list. 3. Implement a function `moving_average` that computes the moving average of the last `k` elements of a list. # Specifications 1. **cumulative_sum**: * **Input**: - `numbers` (list of float): The list of numbers. * **Output**: - List of cumulative sums (list of float). 2. **max_consecutive_difference**: * **Input**: - `numbers` (list of float): The list of numbers. * **Output**: - Maximum consecutive difference (float). 3. **moving_average**: * **Input**: - `numbers` (list of float): The list of numbers. - `k` (int): The number of elements to consider for the moving average. * **Output**: - Moving average (float). * **Constraints**: - Ensure `k` is greater than 0 and less than or equal to the length of `numbers`. Handle cases where the list is empty or `k` is invalid. # Implementation Write your solution in Python. Optimize where possible to ensure efficient computation for large lists. # Example Usage ```python print(cumulative_sum([1, 2, 3, 4])) # Output: [1, 3, 6, 10] print(max_consecutive_difference([1, 3, 6, 10])) # Output: 4 print(moving_average([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3)) # Output: 9.0 ``` # Example Input and Output Explained: - `cumulative_sum([1, 2, 3, 4])` returns a list where each element is the sum of all previous elements in the input list. The results here are `[1+0, 1+2, 1+2+3, 1+2+3+4]` -> `[1, 3, 6, 10]`. - `max_consecutive_difference([1, 3, 6, 10])` calculates the maximum difference between consecutive numbers in the list. Here it finds the differences `[2, 3, 4]` and returns `4`. - `moving_average([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3)` computes the average of the last 3 numbers `[8, 9, 10]` -> `(8+9+10)/3 = 9.0`.","solution":"def cumulative_sum(numbers): Returns the cumulative sum of the list \'numbers\'. cum_sum = [] current_sum = 0 for number in numbers: current_sum += number cum_sum.append(current_sum) return cum_sum def max_consecutive_difference(numbers): Returns the maximum difference between consecutive elements in the list \'numbers\'. if len(numbers) < 2: return 0 # No consecutive elements to compare max_diff = float(\'-inf\') for i in range(1, len(numbers)): diff = abs(numbers[i] - numbers[i-1]) if diff > max_diff: max_diff = diff return max_diff def moving_average(numbers, k): Returns the moving average of the last \'k\' elements of the list \'numbers\'. if not numbers or k <= 0 or k > len(numbers): return 0 # Return 0 for invalid \'k\' values or empty list return sum(numbers[-k:]) / k"},{"question":"# Context Graphs are a fundamental concept in computer science, representing relationships between objects. A graph is composed of nodes (or vertices) connected by edges. In a binary tree, a specific type of graph, each node can have at most two children: left and right. Traversal of a binary tree can be achieved through various methods, such as inorder, preorder, and postorder. A binary tree\'s inorder traversal (Left, Node, Right) visits nodes in a specific sequence. We can reconstruct a binary tree if we know its inorder and preorder (Node, Left, Right) traversals. # Task Implement a function `construct_binary_tree` that reconstructs the binary tree from its inorder and preorder traversals and returns the root of the tree. 1. **Function Signature**: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def construct_binary_tree(preorder: List[int], inorder: List[int]) -> TreeNode: pass ``` 2. **Parameters**: - `preorder` (List[int]): The list of node values representing the preorder traversal of the binary tree. - `inorder` (List[int]): The list of node values representing the inorder traversal of the binary tree. 3. **Returns**: - A `TreeNode` object representing the root of the reconstructed binary tree. # Constraints - The number of nodes in the tree is in the range [1, 1000]. - Each node value is unique. - `preorder` and `inorder` lists are valid representations of a binary tree\'s traversal. # Example ```python # Example 1: preorder = [3, 9, 20, 15, 7] inorder = [9, 3, 15, 20, 7] # The binary tree should be: # 3 # / # 9 20 # / # 15 7 root = construct_binary_tree(preorder, inorder) assert root.val == 3 assert root.left.val == 9 assert root.right.val == 20 assert root.right.left.val == 15 assert root.right.right.val == 7 # Example 2: preorder = [1, 2, 3] inorder = [3, 2, 1] # The binary tree should be: # 1 # / # 2 # # 3 root = construct_binary_tree(preorder, inorder) assert root.val == 1 assert root.left.val == 2 assert root.left.right.val == 3 ``` # Implementation Details 1. Start by identifying the root of the tree using the preorder list (the first element). 2. Locate this root in the inorder list to determine the left and right subtrees. 3. Recursively construct the left and right subtrees using the corresponding parts of preorder and inorder lists. 4. Ensure correct handling of edge cases, such as single node trees and complete balanced trees.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def construct_binary_tree(preorder, inorder): if not preorder or not inorder: return None root_val = preorder[0] root = TreeNode(root_val) mid = inorder.index(root_val) root.left = construct_binary_tree(preorder[1:mid+1], inorder[:mid]) root.right = construct_binary_tree(preorder[mid+1:], inorder[mid+1:]) return root"},{"question":"# Problem Statement Given a non-empty list of integers, write a function that finds the length of the longest subsequence which is bitonic. A subsequence is bitonic if it is first strictly increasing and then strictly decreasing. Implement the function `longestBitonicSubsequence(nums)` that computes the length of such a subsequence. # Function Signature ```python def longestBitonicSubsequence(nums: List[int]) -> int: ``` # Input - **nums**: A list of integers of size `n` where `2 ≤ n ≤ 1000`. # Output - **length**: An integer representing the length of the longest bitonic subsequence. # Constraints - All integers in `nums` are distinct. # Example ```python nums = [1, 3, 5, 7, 4, 2, 1] assert longestBitonicSubsequence(nums) == 7 ``` # Explanation In this example, the sequence `[1, 3, 5, 7, 4, 2, 1]` is a bitonic subsequence and it includes all elements of the input list. Therefore, the length of the longest bitonic subsequence is `7`. # Additional Examples ```python nums = [1, 11, 2, 10, 4, 5, 2, 1] assert longestBitonicSubsequence(nums) == 6 ``` # Explanation In this additional example, a possible bitonic subsequence is `[1, 2, 10, 4, 2, 1]` which has a length of `6`.","solution":"from typing import List def longestBitonicSubsequence(nums: List[int]) -> int: n = len(nums) if n < 2: return n inc = [1] * n dec = [1] * n # Compute lengths of increasing subsequences for i in range(1, n): for j in range(0, i): if nums[i] > nums[j]: inc[i] = max(inc[i], inc[j] + 1) # Compute lengths of decreasing subsequences starting from i for i in range(n-2, -1, -1): for j in range(n-1, i, -1): if nums[i] > nums[j]: dec[i] = max(dec[i], dec[j] + 1) # Find the maximum length of bitonic subsequence max_len = 0 for i in range(n): max_len = max(max_len, inc[i] + dec[i] - 1) return max_len"},{"question":"# Coding Assessment Question Context You are developing a tool to assist civil engineers in calculating various parameters for cylindrical tanks used in water supply systems. The tool needs to accurately compute the surface area, volume, and lateral surface area of a cylindrical tank. A cylindrical tank is defined by its radius (r) and height (h). Here are the formulas: * **Surface Area (A)**: ( A = 2 times pi times r times (r + h) ) * **Volume (V)**: ( V = pi times r^2 times h ) * **Lateral Surface Area (L)**: ( L = 2 times pi times r times h ) Task Implement functions to compute the surface area, volume, and lateral surface area of a cylindrical tank. Requirements * **Function Names**: - `cylindrical_tank_surface_area(radius: float, height: float) -> float` - `cylindrical_tank_volume(radius: float, height: float) -> float` - `cylindrical_tank_lateral_surface_area(radius: float, height: float) -> float` * **Input**: - Two floats `radius` and `height` representing the radius and height of the cylindrical tank. * **Output**: - For `cylindrical_tank_surface_area`, return the surface area as a float. - For `cylindrical_tank_volume`, return the volume as a float. - For `cylindrical_tank_lateral_surface_area`, return the lateral surface area as a float. * **Constraints**: - `radius` and `height` must be positive numbers; raise a `ValueError` if not. * **Performance**: - The implementation should be efficient, with each method operating in constant time. * **Tests**: - Include tests to validate your solution. For example: ```python >>> cylindrical_tank_surface_area(3, 5) 150.79644737231007 >>> cylindrical_tank_volume(3, 5) 141.3716694115407 >>> cylindrical_tank_lateral_surface_area(3, 5) 94.24777960769379 >>> cylindrical_tank_surface_area(-3, 5) Traceback (most recent call last): ... ValueError: Radius and height must be positive. ``` Bonus Extend your solution to include a fourth function `describe_cylindrical_tank(radius: float, height: float) -> dict`, which returns a dictionary containing the surface area, volume, and lateral surface area. --- This question integrates well with the existing set by maintaining a consistent tone, similar length, and equivalent complexity, while addressing computational geometry in the context of civil engineering applications.","solution":"import math def cylindrical_tank_surface_area(radius: float, height: float) -> float: if radius <= 0 or height <= 0: raise ValueError(\\"Radius and height must be positive.\\") return 2 * math.pi * radius * (radius + height) def cylindrical_tank_volume(radius: float, height: float) -> float: if radius <= 0 or height <= 0: raise ValueError(\\"Radius and height must be positive.\\") return math.pi * radius ** 2 * height def cylindrical_tank_lateral_surface_area(radius: float, height: float) -> float: if radius <= 0 or height <= 0: raise ValueError(\\"Radius and height must be positive.\\") return 2 * math.pi * radius * height def describe_cylindrical_tank(radius: float, height: float) -> dict: return { \\"surface_area\\": cylindrical_tank_surface_area(radius, height), \\"volume\\": cylindrical_tank_volume(radius, height), \\"lateral_surface_area\\": cylindrical_tank_lateral_surface_area(radius, height) }"},{"question":"# Problem Statement You are required to write a function that takes a list of integers and generates a new list of strings where each string describes the respective integer\'s parity (\\"even\\" or \\"odd\\"). # Function Signature ```python def describe_parity(numbers: list) -> list: ``` # Input - A single list `numbers` consisting of integers. # Output - A list of strings where each string describes whether the corresponding integer in the input list is \\"even\\" or \\"odd\\". # Constraints - `0 <= len(numbers) <= 1000` - Each integer in the list is between `-10^5` and `10^5`. # Example ```python assert describe_parity([1, 2, 3, 4, 5]) == [\'odd\', \'even\', \'odd\', \'even\', \'odd\'] assert describe_parity([10, -15, 22, 0, -3]) == [\'even\', \'odd\', \'even\', \'even\', \'odd\'] assert describe_parity([]) == [] ``` # Explanation For the list [1, 2, 3, 4, 5]: 1. 1 is odd: \'odd\' 2. 2 is even: \'even\' 3. 3 is odd: \'odd\' 4. 4 is even: \'even\' 5. 5 is odd: \'odd\' This results in the list [\'odd\', \'even\', \'odd\', \'even\', \'odd\']. # Edge Cases to Consider - The list might be empty, and the function should return an empty list. - The list can contain both positive and negative integers as well as zero. Implement the function ensuring efficiency and correctness. Avoid unnecessary computations and ensure the function handles edge cases gracefully.","solution":"def describe_parity(numbers: list) -> list: Returns a list of strings where each string describes whether the corresponding integer in the input list is \'even\' or \'odd\'. Args: numbers: A list of integers. Returns: A list of strings where the ith element is \'even\' if numbers[i] is even, and \'odd\' if numbers[i] is odd. return [\'even\' if num % 2 == 0 else \'odd\' for num in numbers]"},{"question":"# Scenario You have a string consisting of lowercase and uppercase letters. Your task is to transform the string so that each character is replaced with the *next* character in the alphabet. If the transformation results in a letter beyond \'z\' or \'Z\', it should wrap around to \'a\' or \'A\' respectively. For example, \'z\' should become \'a\' and \'Z\' should become \'A\'. # Problem Statement Write a function `shift_string` that takes a string input `s` and returns a new string where each character is shifted to the next character in the alphabet, with wrapping. # Input Format A single string `s`. # Output Format A string with each character shifted to the next character in the alphabet. # Constraints * The string contains only alphabetic characters (both lowercase and uppercase). * The string length is between 1 and 1000 characters, inclusive. # Function Signature ```python def shift_string(s: str) -> str: # implementation here ``` # Examples Example 1 **Input**: ```python \\"abcdxyz\\" ``` **Output**: ```python \\"bcdeyza\\" ``` **Explanation**: Each character is replaced by the next one in the alphabet, with \'z\' wrapping around to \'a\'. Example 2 **Input**: ```python \\"XYZ\\" ``` **Output**: ```python \\"YZA\\" ``` **Explanation**: Each character is replaced by the next one in the alphabet, with \'Z\' wrapping around to \'A\'. # Implementation Notes * Consider using ASCII values and the `ord` and `chr` functions to handle character transformations. * Be mindful of the wrap-around for both lower and uppercase letters.","solution":"def shift_string(s: str) -> str: Shifts each character in the string to the next character in the alphabet. Wraps around after \'z\' to \'a\' and after \'Z\' to \'A\'. shifted_chars = [] for char in s: if \'a\' <= char <= \'z\': if char == \'z\': shifted_chars.append(\'a\') else: shifted_chars.append(chr(ord(char) + 1)) elif \'A\' <= char <= \'Z\': if char == \'Z\': shifted_chars.append(\'A\') else: shifted_chars.append(chr(ord(char) + 1)) return \'\'.join(shifted_chars)"},{"question":"# Context The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones, usually starting with 0 and 1. There are many applications of the Fibonacci sequence in computer science, mathematics, and nature. # Task You need to implement a function to calculate the Fibonacci sequence up to the `n`-th term in Python. Specifically, you\'ll write two functions: 1. `fibonacci_recursive(n: int) -> int`: The recursive implementation. 2. `fibonacci_iterative(n: int) -> int`: The iterative implementation. # Input/Output Format * **Input**: A single integer `n` that represents the position in the Fibonacci sequence (0-based index). * **Output**: An integer which is the `n`-th term in the Fibonacci sequence. # Constraints 1. `0 <= n <= 30` for `fibonacci_recursive` 2. `0 <= n <= 1000` for `fibonacci_iterative` # Requirements 1. `fibonacci_recursive`: Implement a direct recursive approach to calculate the Fibonacci sequence. 2. `fibonacci_iterative`: Implement an iterative approach to calculate the Fibonacci sequence for larger values of `n`. # Examples ```python >>> fibonacci_recursive(0) 0 >>> fibonacci_recursive(7) 13 >>> fibonacci_iterative(0) 0 >>> fibonacci_iterative(7) 13 >>> fibonacci_iterative(30) 832040 ``` # Performance Expectations The iterative implementation should handle larger values of `n` efficiently. The recursive implementation is not suitable for very large `n` due to its exponential time complexity. Use the `timeit` module to benchmark the two functions.","solution":"def fibonacci_recursive(n): Calculate the n-th term in the Fibonacci sequence using recursion. if n <= 1: return n else: return fibonacci_recursive(n-1) + fibonacci_recursive(n-2) def fibonacci_iterative(n): Calculate the n-th term in the Fibonacci sequence using an iterative approach. if n <= 1: return n a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Log File Analyzer & Report Generator You are required to write a Python script that processes a set of log files, extracts specified data, and generates a concise report. Your task focuses on implementing the core functions for log file reading, data extraction, and report generation. Task Requirements: 1. **Function Implementation** - Implement the following functions: * `parse_log_file(file_path: str) -> list[dict]` * `extract_errors(log_data: list[dict]) -> list[dict]` * `extract_warnings(log_data: list[dict]) -> list[dict]` * `generate_summary_report(errors: list[dict], warnings: list[dict]) -> str` * Write a function to write the summary report to a file. 2. **Log File Format**: * Assume the log files are in the following format (one entry per line, JSON encoded): ``` {\\"timestamp\\": \\"2023-10-01T12:00:00\\", \\"level\\": \\"INFO\\", \\"message\\": \\"Service started\\"} {\\"timestamp\\": \\"2023-10-01T12:01:00\\", \\"level\\": \\"ERROR\\", \\"message\\": \\"Failed to connect to database\\"} {\\"timestamp\\": \\"2023-10-01T12:02:00\\", \\"level\\": \\"WARNING\\", \\"message\\": \\"High memory usage detected\\"} {\\"timestamp\\": \\"2023-10-01T12:03:00\\", \\"level\\": \\"INFO\\", \\"message\\": \\"Service running\\"} ``` 3. **Input/Output**: * Your functions will primarily read from log files and return lists of dictionaries for further processing. * The summary report should include the total number of entries, total number of errors, total number of warnings, and the first 5 messages for each category (errors and warnings). 4. **Constraints**: * Assume all log files are located in a directory named `logs/` and have a `.log` extension. * Only consider logs within the directory and ignore subdirectories. * Ensure that the output report is concise, with a clean and readable format suitable for quick review by a system administrator. 5. **Performance**: * Ensure your script can handle large log files efficiently in terms of both time and space. * Aim for clarity and simplicity in your code to allow easy maintenance and updates. Sample Usage: ```python log_data = parse_log_file(\'logs/service_20231001.log\') errors = extract_errors(log_data) warnings = extract_warnings(log_data) summary = generate_summary_report(errors, warnings) write_summary_report(\'logs/summary_report.txt\', summary) ```","solution":"import os import json def parse_log_file(file_path: str) -> list: Reads a log file and returns a list of dictionaries representing each log entry. with open(file_path, \'r\') as file: log_data = [json.loads(line.strip()) for line in file] return log_data def extract_errors(log_data: list) -> list: Returns a list of error log entries from the given log data. return [entry for entry in log_data if entry[\'level\'] == \'ERROR\'] def extract_warnings(log_data: list) -> list: Returns a list of warning log entries from the given log data. return [entry for entry in log_data if entry[\'level\'] == \'WARNING\'] def generate_summary_report(errors: list, warnings: list) -> str: Generates a summary report of errors and warnings. report = [ f\\"Total Entries: {len(errors) + len(warnings)}\\", f\\"Total Errors: {len(errors)}\\", \\"First 5 Errors:\\", *([f\\" {e[\'timestamp\']} - {e[\'message\']}\\" for e in errors[:5]]), f\\"Total Warnings: {len(warnings)}\\", \\"First 5 Warnings:\\", *([f\\" {w[\'timestamp\']} - {w[\'message\']}\\" for w in warnings[:5]]), ] return \'n\'.join(report) def write_summary_report(file_path: str, summary: str): Writes the summary report to a file. with open(file_path, \'w\') as file: file.write(summary)"},{"question":"# Merge K Sorted Arrays **Scenario**: You are tasked with creating a utility in a data processing software that will assist in merging multiple sorted lists into a single sorted array. Given multiple lists of integers, each of which is sorted in ascending order, the task is to merge these lists into one sorted list while maintaining the order. **Task**: Write a function `merge_k_sorted_arrays(arrays: list[list[int]]) -> list[int]` that merges k sorted arrays into a single sorted list. **Input**: * `arrays` - A list of `k` lists, where each list contains `n` integers in ascending order. **Output**: * Return a single list containing all integers from the input lists in ascending order. **Constraints**: * 1 <= k <= 10^3 * 0 <= n <= 10^3 * -10^6 <= element <= 10^6 Ensure that your implementation handles the merging efficiently to cater to large input sizes. **Example**: ```python >>> merge_k_sorted_arrays([[1, 4, 5], [1, 3, 4], [2, 6]]) [1, 1, 2, 3, 4, 4, 5, 6] >>> merge_k_sorted_arrays([[], [2, 3], [1, 4, 5, 6], [7, 8]]) [1, 2, 3, 4, 5, 6, 7, 8] >>> merge_k_sorted_arrays([[-1, 0, 2], [4, 6, 8], [], [-2, -1, 3]]) [-2, -1, -1, 0, 2, 3, 4, 6, 8] ``` **Note**: - Efficiently merging multiple sorted arrays is critical, so consider using a min-heap (priority queue) to achieve optimal performance. - Think about the characteristics of the input data where each list is already sorted and leverage this to minimize the computational complexity.","solution":"import heapq def merge_k_sorted_arrays(arrays): Merges k sorted arrays into a single sorted list. Parameters: arrays (list of list of int): A list of k sorted lists. Returns: list of int: A single sorted list containing all the integers from the input lists. min_heap = [] for i, array in enumerate(arrays): if array: heapq.heappush(min_heap, (array[0], i, 0)) merged_list = [] while min_heap: value, array_index, element_index = heapq.heappop(min_heap) merged_list.append(value) next_element_index = element_index + 1 if next_element_index < len(arrays[array_index]): next_value = arrays[array_index][next_element_index] heapq.heappush(min_heap, (next_value, array_index, next_element_index)) return merged_list"},{"question":"# Problem Statement You are responsible for adding a feature to an existing application that calculates the result of an arithmetic expression provided in infix notation with basic mathematical operations (+, -, *, /), parentheses for explicit grouping, and variables that will be substituted with actual numeric values. Implement a function `evaluate_expression(expression: str, variables: dict) -> float` that processes and evaluates the given infix arithmetic expression using the provided variable values. # Input: - `expression` (str): The infix arithmetic expression to be evaluated. The expression can include numbers, the basic operators (+, -, *, /), parentheses, and variables. - `variables` (dict): A dictionary where keys are variable names appearing in the expression, and values are their corresponding numeric values. # Output: - Return the calculated result as a float. # Constraints: - The expression will be a valid arithmetic expression in infix notation. - The variable names are case-insensitive. - Division by zero should raise a `ValueError` with the message \\"Division by zero is undefined\\". - All variable names present in the expression must be defined in the `variables` dictionary. If a variable is not defined, raise a `ValueError` with the message \\"Undefined variable: {variable_name}\\". # Example Usage: ```python >>> evaluate_expression(\\"a + b * (c - d) / e\\", {\'a\': 3, \'b\': 4, \'c\': 10, \'d\': 2, \'e\': 2}) 3 + 4 * (10 - 2) / 2 -> 3 + 4 * 8 / 2 -> 3 + 32 = 35 -> 35 / 2 -> 17.5 >>> evaluate_expression(\\"3 + 5 * ( 2 - 8 )\\", {}) 3 + 5 * (2 - 8) -> 3 + 5 * -6 -> 3 - 30 -> -27 >>> evaluate_expression(\\"x / (y - z)\\", {\'x\': 15, \'y\': 5, \'z\': 5}) Traceback (most recent call last): ... ValueError: Division by zero is undefined >>> evaluate_expression(\\"a + b\\", {\'a\': 5}) Traceback (most recent call last): ... ValueError: Undefined variable: b ``` # Leading Hints 1. Properly parse the expression respecting the operator precedence and parentheses. 2. Handle variable lookup and substitution carefully, ensuring all variables are defined and uppercase/lowercase insensitivity. 3. Implement appropriate error handling mechanisms for division by zero and undefined variables. Implementing this function successfully will test your understanding of parsing arithmetic expressions, handling variables and substitution, and managing errors for edge cases effectively.","solution":"def evaluate_expression(expression: str, variables: dict) -> float: Evaluates an arithmetic expression in infix notation using provided variable values and returns the result as a float. :param expression: str: The arithmetic expression in infix notation. :param variables: dict: Dictionary with variable values. :return: float: The evaluation result. import re from collections import deque import operator # Convert the input dictionary keys to lower case for case-insensitivity. variables = {key.lower(): value for key, value in variables.items()} # Replace variables in the expression with their corresponding values def replace_vars(match): var = match.group(0).lower() if var not in variables: raise ValueError(f\\"Undefined variable: {var}\\") return str(variables[var]) expression = re.sub(r\'b[a-zA-Z]+b\', replace_vars, expression) # Define operator precedence and corresponding functions operators = { \'+\': (1, operator.add), \'-\': (1, operator.sub), \'*\': (2, operator.mul), \'/\': (2, operator.truediv) } def shunting_yard(expr): stack = deque() output = [] num = re.compile(r\'d+(.d+)?\') i = 0 while i < len(expr): if expr[i].isdigit() or (expr[i] == \'.\' and i < len(expr) - 1 and expr[i+1].isdigit()): j = i while j < len(expr) and (expr[j].isdigit() or expr[j] == \'.\'): j += 1 output.append(float(expr[i:j])) i = j elif expr[i] in operators: while (stack and stack[-1] != \'(\' and operators[stack[-1]][0] >= operators[expr[i]][0]): output.append(stack.pop()) stack.append(expr[i]) i += 1 elif expr[i] == \'(\': stack.append(expr[i]) i += 1 elif expr[i] == \')\': while stack and stack[-1] != \'(\': output.append(stack.pop()) stack.pop() i += 1 else: i += 1 while stack: output.append(stack.pop()) return output def evaluate_rpn(rpn_expr): stack = deque() for token in rpn_expr: if isinstance(token, float): stack.append(token) else: b = stack.pop() a = stack.pop() if token == \'/\' and b == 0: raise ValueError(\\"Division by zero is undefined\\") stack.append(operators[token][1](a, b)) return stack[0] rpn = shunting_yard(expression) return evaluate_rpn(rpn)"},{"question":"# Question: Implement Dijkstra\'s Algorithm for Shortest Path Calculation You are tasked with implementing Dijkstra\'s algorithm to find the shortest path from a given source vertex to all other vertices in a weighted, directed graph. Problem Statement Implement a function `dijkstra(graph: List[Vertex], source: Vertex) -> Dict[int, int]` that returns a dictionary where the keys are vertex IDs and the values are the shortest path distances from the source vertex to each corresponding vertex. Input * `graph`: A list of `Vertex` objects representing the graph. * `source`: A `Vertex` object from which Dijkstra\'s algorithm should start. Each `Vertex` object has the following properties: * `id`: Unique identifier for the vertex. * `neighbors`: List of tuples where each tuple contains a neighbor vertex\'s ID and the edge weight to that neighbor. Output A dictionary where the keys are vertex IDs and the values are the shortest distance from the source vertex to that vertex. Constraints * All edge weights are non-negative integers. * The graph is directed and the vertices\' ids are 0-based integers. * The graph may not be connected. Example ```python # Assuming the definition of the Vertex class and connect function are available # Create vertices vertices = [Vertex(i) for i in range(6)] # Connect vertices with edges vertices[0].neighbors = [(1, 5), (2, 3)] vertices[1].neighbors = [(0, 5), (3, 6), (2, 2)] vertices[2].neighbors = [(0, 3), (1, 2), (3, 7)] vertices[3].neighbors = [(1, 6), (2, 7), (4, 8), (5, 4)] vertices[4].neighbors = [(3, 8), (5, 9)] vertices[5].neighbors = [(3, 4), (4, 9)] # Call Dijkstra\'s Algorithm distances = dijkstra(vertices, vertices[0]) # Expected output (one of the possible correct outputs) # {0: 0, 1: 5, 2: 3, 3: 10, 4: 18, 5: 14} print(distances) ``` Notes 1. Initialize all vertices with their distances set to infinity (`inf`) and the distance of the source vertex to `0`. 2. Use a min-heap priority queue to efficiently fetch the vertex with the smallest distance during each iteration. 3. Update the distances of the neighboring vertices and push the updated distances to the priority queue. 4. Ensure that the complexity of the solution aligns with ( O((m + n) log n) ). Implement the `dijkstra` function and test your solution with different graph configurations to ensure correctness and efficiency.","solution":"from typing import List, Tuple, Dict import heapq import sys class Vertex: def __init__(self, id: int): self.id = id self.neighbors = [] def dijkstra(graph: List[Vertex], source: Vertex) -> Dict[int, int]: dist = {vertex.id: sys.maxsize for vertex in graph} dist[source.id] = 0 priority_queue = [(0, source.id)] heapq.heapify(priority_queue) while priority_queue: current_dist, u = heapq.heappop(priority_queue) if current_dist > dist[u]: continue for neighbor_id, weight in graph[u].neighbors: distance_through_u = current_dist + weight if distance_through_u < dist[neighbor_id]: dist[neighbor_id] = distance_through_u heapq.heappush(priority_queue, (distance_through_u, neighbor_id)) return dist"},{"question":"# Question: Optimize Pathfinding with Dynamic Edge Weights in a Weighted Directed Graph Context: You are given a weighted directed graph representing a transportation network, where nodes represent locations and directed edges represent available routes with associated travel times. Each travel time (weight) can dynamically change over time due to varying traffic conditions. Your task is to optimize the pathfinding algorithm to efficiently handle these dynamic changes between two nodes in the network. Task: Implement a function `optimized_pathfinder` that computes the shortest path between two nodes, considering the dynamic nature of edge weights. Your algorithm should minimize the recomputation time by updating only the affected parts of the graph whenever an edge weight changes. Specifications: 1. **Input**: - `graph` : A dictionary representing the nodes and their respective connections with weights (`{node: [(neighbor, weight), ...], ...}`). - `start_node` : The starting node for the pathfinding. - `end_node` : The destination node for the pathfinding. - `updates` : A list of tuples representing dynamic changes to the graph in the format `[(node1, node2, new_weight), ...]`. 2. **Output**: - `shortest_path` : A list representing the shortest path from `start_node` to `end_node`, adhering to the updated edge weights. 3. **Constraints**: - The graph is connected and directed. - Edge weights are positive integers. - Updates can be frequent and only affect a small portion of the graph at a time. - The algorithm should efficiently handle typical scenarios with large, sparse graphs. Example Input: ```python graph = { \'A\': [(\'B\', 1), (\'C\', 4)], \'B\': [(\'C\', 2), (\'D\', 5)], \'C\': [(\'D\', 1)], \'D\': [] } start_node = \'A\' end_node = \'D\' updates = [(\'B\', \'C\', 3), (\'A\', \'C\', 2)] ``` Example Output: ```python [\'A\', \'C\', \'D\'] ``` This output indicates that the shortest path from node `A` to node `D` is via nodes `C`, considering the updated edge weights. Instructions: 1. **Pathfinding Algorithm**: Implement an efficient pathfinding algorithm (such as Dijkstra\'s or A*). 2. **Dynamic Update Handling**: Optimize the algorithm to handle dynamic changes in edge weights without full recomputation. 3. **Testing**: Write at least 3 test cases to verify correctness and efficiency, including cases with multiple updates. Hints: 1. Consider using a priority queue to manage the nodes for pathfinding dynamically. 2. Investigate strategies to locally update shortest path calculations after an edge weight change rather than recomputing from scratch. 3. Assess the use of data structures that allow efficient updates and deletions, like Fibonacci heaps, to maintain optimal performance.","solution":"import heapq def optimized_pathfinder(graph, start_node, end_node, updates): Computes the shortest path between start_node and end_node considering dynamic edge weight updates. def dijkstra(graph, source, target): # Priority queue to store (cost, node) pq = [(0, source)] # Distance dictionary to store shortest path to each node distances = {node: float(\'inf\') for node in graph} distances[source] = 0 # Previous nodes dictionary to reconstruct path previous = {node: None for node in graph} while pq: current_distance, current_node = heapq.heappop(pq) if current_node == target: break if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance previous[neighbor] = current_node heapq.heappush(pq, (distance, neighbor)) # Reconstruct shortest path path = [] current = target while previous[current] is not None: path.append(current) current = previous[current] if path: path.append(source) path.reverse() return path # Apply updates to the graph for node1, node2, new_weight in updates: for idx, (neighbor, weight) in enumerate(graph[node1]): if neighbor == node2: graph[node1][idx] = (neighbor, new_weight) break else: graph[node1].append((node2, new_weight)) # Return the shortest path after updates return dijkstra(graph, start_node, end_node)"},{"question":"# Problem Statement You have been tasked with developing a function that generates all possible permutations of a given string. A permutation is a rearrangement of the characters of the string into a new string. The goal is to output each unique permutation in sorted order (lexicographically), without duplicates. # Function to Implement Implement the function `string_permutations(s: str) -> List[str]`. This function should return a list of all unique permutations of the provided string, sorted in lexicographical order. # Input * `s` (str): A string of lowercase English letters, with a length of at most 8 characters. # Output * (List[str]): A list of unique permutations of the input string, sorted lexicographically. # Constraints 1. The length of the input string will not exceed 8 characters. 2. The string may contain duplicate characters. # Examples ```python assert string_permutations(\\"abc\\") == [\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"] assert string_permutations(\\"aab\\") == [\\"aab\\", \\"aba\\", \\"baa\\"] assert string_permutations(\\"a\\") == [\\"a\\"] ``` # Additional Notes * For generating permutations, consider using a recursive approach or leveraging built-in libraries. * Pay special attention to handling duplicate characters to ensure the uniqueness of permutations in the result. # Scenario You are developing a software tool for creating anagrams of words. This tool needs to generate all possible unique anagrams (permutations) of a given word, sorted in alphabetical order to help linguists study various wordforms and their occurrences in texts.","solution":"from itertools import permutations def string_permutations(s: str) -> list: Generates all unique permutations of a given string sorted in lexicographical order. Parameters: s (str): Input string Returns: list: Sorted list of unique permutations # Generate all permutations permut_list = permutations(s) # Convert each permutation tuple to string permut_strings = {\'\'.join(p) for p in permut_list} # Return a sorted list of unique permutations return sorted(list(permut_strings))"},{"question":"# Question: Implement a Custom Sorting Function You are required to implement a sorting functionality that extends Python\'s built-in sort behavior to achieve custom sorting of tuples within a list. Specifically, the sorting should be based on multiple criteria. **Function Definition**: `custom_sort(tuples: list) -> list` **Parameters**: - You are provided a list of tuples where each tuple contains two elements: an integer and a string. Example: `[(3, \'apple\'), (1, \'banana\'), (2, \'cherry\'), (5, \'date\'), (2, \'elderberry\')]`. **Sorting Criteria**: 1. The tuples should first be sorted based on the integer value in ascending order. 2. If two tuples have the same integer value, they should be sorted based on the string value in ascending lexicographical order. **Input**: - A list of tuples where each tuple contains exactly two elements: an integer and a string. - You can assume the list contains at least one tuple and at most `10^6` tuples. **Output**: - Return a list of tuples sorted based on the criteria specified. **Constraints**: - The integer values are within the range `0` to `10^9`. - The strings are non-empty and consist only of lowercase English letters (\'a\' to \'z\'). # Example ```python print(custom_sort([(3, \'apple\'), (1, \'banana\'), (2, \'cherry\'), (5, \'date\'), (2, \'elderberry\')])) # Output: [(1, \'banana\'), (2, \'cherry\'), (2, \'elderberry\'), (3, \'apple\'), (5, \'date\')] print(custom_sort([(10, \'zebra\'), (7, \'dog\'), (10, \'cat\'), (7, \'apple\')])) # Output: [(7, \'apple\'), (7, \'dog\'), (10, \'cat\'), (10, \'zebra\')] ``` # Performance Requirements: - Your implementation should handle lists efficiently for sizes up to `10^6`. Implement the `custom_sort` function ensuring that your approach is optimized, handles edge cases, and maintains the custom sort order accurately.","solution":"def custom_sort(tuples: list) -> list: Sorts a list of tuples based on the first element in ascending order, and if they are equal, sorts based on the second element in ascending lexicographical order. Parameters: - tuples (list of tuples): List of tuples to be sorted. Returns: - list of tuples: Sorted list of tuples based on the specified criteria. return sorted(tuples, key=lambda x: (x[0], x[1]))"},{"question":"# Reverse Nodes in k-Group # Objective: Implement a function to reverse nodes of a linked list in groups of k and return the modified list. # Problem Statement: Write a function `reverse_k_group` that takes the head of a linked list and an integer k, and reverses the nodes of the list k at a time. Return the modified list\'s head. If the number of nodes is not a multiple of k, the remaining nodes at the end should stay in the same order. # Function Signature: ```python class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def reverse_k_group(head: ListNode, k: int) -> ListNode: pass ``` # Input: - `head`: A ListNode object representing the head of the linked list. - `k`: An integer representing the size of the groups to reverse. # Output: - A ListNode object representing the head of the modified linked list. # Constraints: - The linked list may contain 0 to 10^5 nodes. - The value of k is a positive integer less than or equal to the number of nodes in the linked list. - The value in each node of the linked list is within the range [-10^9, 10^9]. # Performance Requirements: - Ensure the algorithm operates in O(n) time complexity, where n is the number of nodes in the linked list. - Space complexity should be O(1) for the iterative approach (excluding the input and output structures). # Example Scenario: Consider a healthcare system where patient records stored in a linked list need to be grouped and reversed in chunks. This operation could be beneficial for certain batch processing tasks. # Example: ```python # Helper function to create a linked list from a list of values def create_linked_list(values): if not values: return None head = ListNode(values[0]) current = head for value in values[1:]: current.next = ListNode(value) current = current.next return head # Helper function to convert a linked list to a list of values def linked_list_to_list(head): current = head result = [] while current: result.append(current.value) current = current.next return result # Create linked list: 1 -> 2 -> 3 -> 4 -> 5 head = create_linked_list([1, 2, 3, 4, 5]) # Reverse nodes in groups of k=2 new_head = reverse_k_group(head, 2) print(linked_list_to_list(new_head)) # [2, 1, 4, 3, 5] # Create another linked list: 1 -> 2 -> 3 -> 4 -> 5 head = create_linked_list([1, 2, 3, 4, 5]) # Reverse nodes in groups of k=3 new_head = reverse_k_group(head, 3) print(linked_list_to_list(new_head)) # [3, 2, 1, 4, 5] ``` # Constraints to Keep in Mind: - Handle edge cases such as an empty list, list with one element, and group size k = 1. - Ensure the implementation efficiently manages the pointers to reconstruct the modified linked list.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def reverse_k_group(head: ListNode, k: int) -> ListNode: if head is None or k == 1: return head def reverse_segment(start, end): new_head, p = None, start while p != end: tmp = p.next p.next = new_head new_head = p p = tmp return new_head dummy = ListNode(0) dummy.next = head prev_group_end = dummy while True: kth = prev_group_end for i in range(k): kth = kth.next if kth is None: return dummy.next group_start = prev_group_end.next next_group_start = kth.next kth.next = None prev_group_end.next = reverse_segment(group_start, kth.next) group_start.next = next_group_start prev_group_end = group_start return dummy.next"},{"question":"# Problem Statement Given an integer array of size `n` that represents heights of buildings in a skyline, determine the width of the largest rectangle that can be formed by contiguous buildings. A rectangle\'s width is determined by how many contiguous buildings it spans, and its height is determined by the height of the shortest building in the sequence. Implement the function `largest_rectangle_area(heights: List[int]) -> int` to achieve this. # Input * `heights`: A list of integers representing the heights of buildings, where 1 ≤ len(heights) ≤ 10^5 and 0 ≤ heights[i] ≤ 10^4. # Output * Return an integer representing the maximum area of the largest rectangle that can be formed. # Constraints * The algorithm should run in O(n) time. * The algorithm should use O(n) space. # Example ```python assert largest_rectangle_area([2, 1, 5, 6, 2, 3]) == 10 assert largest_rectangle_area([2, 4]) == 4 assert largest_rectangle_area([1, 1, 1, 1]) == 4 assert largest_rectangle_area([0, 0, 0, 0]) == 0 assert largest_rectangle_area([6, 2, 5, 4, 5, 1, 6]) == 12 ``` # Explanation 1. In the first example, the array `[2, 1, 5, 6, 2, 3]` can form a maximum rectangle with area of 10 (formed by buildings of height 5 and 6). 2. In the second example, the array `[2, 4]` can form a maximum rectangle with area of 4 (formed by the single building of height 4). 3. In the third example, the array `[1, 1, 1, 1]` can form a maximum rectangle with area of 4. 4. In the fourth example, the array `[0, 0, 0, 0]` cannot form any rectangle, hence the area is 0. 5. In the fifth example, the array `[6, 2, 5, 4, 5, 1, 6]` can form a maximum rectangle with area of 12 (formed by buildings of height 4 and 5).","solution":"from typing import List def largest_rectangle_area(heights: List[int]) -> int: Returns the largest rectangle area in a histogram made of heights. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"Question You are asked to implement a function that checks if a string `s` can be segmented into words from a given dictionary `wordDict`. The dictionary does not necessarily contain the concatenated words as a whole, so each word from the dictionary can appear multiple times in the final segmentation. # Function Signature ```python def word_break(s: str, wordDict: List[str]) -> bool: ``` # Input - `s` (string): The input string (length <= 200). - `wordDict` (List of strings): The list of valid words (each word length <= 100). # Output - `bool`: Return `True` if the string can be segmented into one or more words from the dictionary, otherwise return `False`. # Constraints - `1 <= len(s) <= 200` - All characters in the input string are lowercase English letters. - The dictionary is not guaranteed to be exhaustive, i.e., it might not contain every substring within `s`. # Example ```python >>> word_break(\\"leetcode\\", [\\"leet\\", \\"code\\"]) True >>> word_break(\\"applepenapple\\", [\\"apple\\", \\"pen\\"]) True >>> word_break(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) False >>> word_break(\\"cars\\", [\\"car\\", \\"ca\\", \\"rs\\"]) True >>> word_break(\\"apple\\", [\\"a\\", \\"b\\", \\"c\\"]) False ``` # Considerations - Use dynamic programming to efficiently check the segmentations. - Handle cases where `s` might have overlapping words that can be segmented differently based on the dictionary. - Take care of edge cases where the dictionary might contain single letters or substrings that are part of larger words in `s`.","solution":"from typing import List def word_break(s: str, wordDict: List[str]) -> bool: dp = [False] * (len(s) + 1) dp[0] = True # Base case: an empty string can always be segmented for i in range(1, len(s) + 1): for word in wordDict: if dp[i - len(word)] and s[i - len(word):i] == word: dp[i] = True return dp[-1]"},{"question":"# Rotate 2D Array As a coding task, you need to implement a function that rotates a given NxN 2D array by 90 degrees clockwise. Your task is to ensure the rotation is performed in-place, modifying the given array without using any extra space for another array. # Function Signature ```python def rotate_2d_array(matrix: List[List[int]]) -> None: ``` # Input: - `matrix`: A 2D list of integers representing an NxN matrix. # Output: - The function doesn\'t return anything. The input matrix should be modified in-place to represent its rotated form. # Constraints: - **The input matrix will always be non-empty and will have the same number of rows and columns (NxN).** - **N will be greater than or equal to 1 and less than or equal to 1000.** # Example Scenarios Example 1 ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_2d_array(matrix) Output: [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` Example 2 ```python matrix = [ [5, 1, 9, 11], [2, 4, 8, 10], [13, 3, 6, 7], [15, 14, 12, 16] ] rotate_2d_array(matrix) Output: [ [15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11] ] ``` Example 3 ```python matrix = [ [1] ] rotate_2d_array(matrix) Output: [ [1] ] ``` # Additional Requirements: 1. Do not use extra space for another array. 2. Modify the input matrix in place. 3. Ensure the rotation is done in the most efficient way possible. Write your implementation with thorough testing to validate correctness for diverse inputs and edge cases.","solution":"from typing import List def rotate_2d_array(matrix: List[List[int]]) -> None: Rotates a given NxN 2D array by 90 degrees clockwise in-place. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i + 1, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"# Coding Assessment Question **Problem Context**: You are developing a feature for a mathematical software that involves matrix operations. One of the required operations is to transpose a given matrix. Your task is to write a function that performs the matrix transposition and handles various edge cases appropriately. **Task**: Implement a function `transpose_matrix(matrix: List[List[int]]) -> List[List[int]]` that takes a 2D list (matrix) and returns its transposition. Ensure that your implementation can handle edge cases, including empty matrices and non-rectangular matrices. **Function Signature**: ```python def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: pass ``` **Constraints**: 1. The input matrix can have varying number of rows and columns. 2. Handle edge cases such as an empty matrix ([]). 3. If the matrix is not rectangular (i.e., rows have different lengths), raise a ValueError indicating the input is not valid. **Input Format**: - A 2D list representing the matrix. **Output Format**: - A 2D list representing the transposed matrix. **Examples**: ```python >>> transpose_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[1, 4, 7], [2, 5, 8], [3, 6, 9]] >>> transpose_matrix([[1, 2], [3, 4], [5, 6]]) [[1, 3, 5], [2, 4, 6]] >>> transpose_matrix([]) [] >>> transpose_matrix([[1], [2], [3]]) [[1, 2, 3]] >>> transpose_matrix([[1, 2, 3], [4, 5], [6, 7, 8]]) ValueError: Input is not a rectangular matrix ``` **Additional Task**: - Ensure your implementation can handle and raise an appropriate exception for non-rectangular matrices by validating the input matrix before performing the transpose operation. **Performance Requirements**: - Optimize for time complexity O(n*m), where n is the number of rows and m is the number of columns in the input matrix. - Ensure space complexity is O(n*m) for storing the result.","solution":"from typing import List def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: Transposes the given 2D list matrix. Args: matrix (List[List[int]]): A 2D list representing the matrix. Returns: List[List[int]]: The transposed matrix. Raises: ValueError: If the matrix is not a rectangular matrix. if not matrix: # handle empty matrix return [] # Check if all rows have the same length row_length = len(matrix[0]) for row in matrix: if len(row) != row_length: raise ValueError(\\"Input is not a rectangular matrix\\") # Transpose the matrix transposed = [[matrix[j][i] for j in range(len(matrix))] for i in range(row_length)] return transposed"},{"question":"# Coding Question: Calculate Total Distance with Multiple Offsets Imagine you\'re developing a part of a navigation system for an autonomous delivery robot that calculates the total distance traveled after applying multiple directional offsets. Each offset represents a movement in a 2D coordinate system. Write a function `total_distance` that takes a list of 2D coordinates `offsets` and computes the total Euclidean distance the robot travels, starting from the origin point `(0, 0)` and moving through each offset in order. # Example ```python >>> total_distance([(3, 4), (1, 2), (4, 0)]) 10.0 ``` Explanation: - Starting from (0, 0), the robot first moves to (3, 4), which is 5 units away (distance calculated using Pythagorean theorem). - Then it moves from (3, 4) to (4, 6), which is √(1^2 + 2^2) = √5 ≈ 2.236 units away. - Finally, it moves from (4, 6) to (8, 6), which is 4 units away. - Total distance = 5 + 2.236 + 4 = 11.236 units. # Constraints 1. Each offset in the list will be a tuple of two floats representing the x and y coordinates. 2. The list `offsets` will have at least one offset. 3. The offset values can be positive or negative, but the total distance must always be non-negative. # Input - `offsets`: a list of tuples, where each tuple contains two floats representing x and y coordinates. # Output - Returns a float representing the total distance traveled after moving through each offset in order. ```python def total_distance(offsets: list[tuple[float, float]]) -> float: # Your implementation here ``` You should ensure your solution accurately handles float arithmetic and computes the distance using the Euclidean distance formula.","solution":"import math def total_distance(offsets): Calculates the total Euclidean distance traveled after applying multiple directional offsets. Parameters: offsets (list of tuples): A list of (x, y) tuples representing the offsets. Returns: float: The total distance traveled. if not offsets: return 0.0 total_dist = 0.0 current_position = (0, 0) for offset in offsets: next_position = (current_position[0] + offset[0], current_position[1] + offset[1]) distance = math.sqrt((next_position[0] - current_position[0])**2 + (next_position[1] - current_position[1])**2) total_dist += distance current_position = next_position return total_dist"},{"question":"# Coding Assessment Task Context You are given a basic implementation of a priority queue using a list in Python. However, this implementation is not efficient for insertion and deletion operations. Your task is to improve the priority queue implementation using a binary heap to provide better performance. Objective Implement a new class `BinaryHeapPriorityQueue` that provides efficient insertion and extraction of elements based on their priority using a binary heap. Your implementation should handle both min-heap and max-heap scenarios. Requirements - Implement the binary heap data structure with methods to insert elements and extract the minimum or maximum element. - Ensure the priority queue supports dynamic resizing as elements are added or removed. - Implement methods to efficiently percolate up and percolate down elements to maintain the heap property. # Function Specifications `BinaryHeapPriorityQueue` * **Attributes**: - `heap`: List representing the binary heap. - `is_min_heap`: Boolean indicating if the heap is a min-heap (True) or max-heap (False). * **Methods**: - `__init__(self, is_min_heap=True)`: Initialize the binary heap as either a min-heap or max-heap. - `insert(self, element)`: Insert a new element into the heap. - `extract(self)`: Extract the root element (minimum for min-heap, maximum for max-heap) from the heap. - `_percolate_up(self, index)`: Percolate an element up to maintain heap property. - `_percolate_down(self, index)`: Percolate an element down to maintain heap property. - `_parent(self, index)`: Return the index of the parent of the given index. - `_left_child(self, index)`: Return the index of the left child of the given index. - `_right_child(self, index)`: Return the index of the right child of the given index. # Constraints - The heap should dynamically resize as elements are inserted or extracted. - Ensure all operations (`insert`, `extract`) work in O(log n) time complexity. - Input elements can be any comparable types (e.g., integers, floats). Example Usage ```python pq = BinaryHeapPriorityQueue(is_min_heap=True) pq.insert(10) pq.insert(5) pq.insert(20) min_element = pq.extract() # Should return 5 pq_max = BinaryHeapPriorityQueue(is_min_heap=False) pq_max.insert(10) pq_max.insert(5) pq_max.insert(20) max_element = pq_max.extract() # Should return 20 ``` # Hints - Use list manipulation methods to dynamically adjust the size of the heap. - Helper methods like `_parent`, `_left_child`, and `_right_child` can simplify index calculations in your `insert`, `_percolate_up`, and `_percolate_down` methods. - Consider edge cases such as extracting from an empty heap.","solution":"class BinaryHeapPriorityQueue: def __init__(self, is_min_heap=True): self.is_min_heap = is_min_heap self.heap = [] def insert(self, element): self.heap.append(element) self._percolate_up(len(self.heap) - 1) def extract(self): if not self.heap: raise IndexError(\\"extract from empty heap\\") if len(self.heap) == 1: return self.heap.pop() root = self.heap[0] self.heap[0] = self.heap.pop() self._percolate_down(0) return root def _percolate_up(self, index): parent = self._parent(index) if parent >= 0 and self._compare(self.heap[index], self.heap[parent]): self.heap[index], self.heap[parent] = self.heap[parent], self.heap[index] self._percolate_up(parent) def _percolate_down(self, index): left = self._left_child(index) right = self._right_child(index) target = index if left < len(self.heap) and self._compare(self.heap[left], self.heap[target]): target = left if right < len(self.heap) and self._compare(self.heap[right], self.heap[target]): target = right if target != index: self.heap[index], self.heap[target] = self.heap[target], self.heap[index] self._percolate_down(target) def _compare(self, child, parent): if self.is_min_heap: return child < parent return child > parent def _parent(self, index): return (index - 1) // 2 def _left_child(self, index): return 2 * index + 1 def _right_child(self, index): return 2 * index + 2"},{"question":"# Problem Statement Given two strings, your task is to implement an algorithm that detects if one string is a scrambled string of another. A scrambled string is defined recursively by partitioning the string into two non-empty substrings and swapping them. # Function Signature ```python def is_scramble(s1: str, s2: str) -> bool: Determines if string s1 is a scrambled string of s2. Args: s1 (str): The first string. s2 (str): The second string. Returns: bool: True if s1 is a scrambled string of s2, otherwise False. pass ``` # Example Usage ```python assert is_scramble(\\"great\\", \\"rgeat\\") == True # true because \\"rgeat\\" is a scrambled string of \\"great\\" by swapping \\"gr\\" and \\"eat\\" assert is_scramble(\\"abcde\\", \\"caebd\\") == False # false because there is no way to produce \\"caebd\\" from \\"abcde\\" by swapping assert is_scramble(\\"a\\", \\"a\\") == True # true because both strings are identical assert is_scramble(\\"abc\\", \\"bca\\") == True # true because \\"bca\\" can be obtained by swapping \\"a\\" and \\"bc\\" in \\"abc\\" assert is_scramble(\\"abc\\", \\"cab\\") == True # true because \\"cab\\" can be obtained by recursively swapping \\"ab\\" and \\"c\\" in \\"abc\\" ``` # Constraints * The strings s1 and s2 will have the same length (1 ≤ len(s1) = len(s2) ≤ 30). * s1 and s2 consist only of lowercase English letters. # Additional Information Consider edge cases such as: * Strings with length 1. * Strings where s1 is already equal to s2. * Recursive swaps that may not immediately form s2 from s1. Implement the function `is_scramble` to determine if s1 is a scrambled string of s2 according to the problem definition.","solution":"def is_scramble(s1: str, s2: str) -> bool: Determines if string s1 is a scrambled string of s2. Args: s1 (str): The first string. s2 (str): The second string. Returns: bool: True if s1 is a scrambled string of s2, otherwise False. # If the strings are equal, then s2 is a scrambled string of s1 if s1 == s2: return True # If the strings are not of the same length or have different character counts, they can\'t be scrambled versions if sorted(s1) != sorted(s2): return False n = len(s1) for i in range(1, n): # Check if there exists a split index `i` where one of the two conditions is true and make recursive calls if (is_scramble(s1[:i], s2[:i]) and is_scramble(s1[i:], s2[i:])) or (is_scramble(s1[:i], s2[-i:]) and is_scramble(s1[i:], s2[:-i])): return True return False"},{"question":"**Scenario**: You are managing an inventory tracking system for an online bookstore. Each book can have multiple editions, and you need to maintain an up-to-date list of all the available editions based on the incoming data. For each incoming update: - If a new edition of a book is listed, add it to the list. - If an edition number that\'s already in the inventory is listed with a higher stock or a later date, update the existing record. - Ignore any incoming data where the edition number is already in the inventory with equal or better information. # Task Write a function `update_inventory(inventory: list[dict], updates: list[dict]) -> list[dict]` that takes an inventory of books and a list of update records and returns the updated inventory. Each book record and update record is represented by a dictionary with keys `\'book_id\'`, `\'edition\'`, `\'stock\'`, and `\'update_date\'`. # Input * `inventory`: A list of dictionaries, each representing a book edition currently in inventory. * `updates`: A list of dictionaries, each representing an update record for a book edition. # Output * A list of dictionaries representing the updated inventory. # Constraints * Each dictionary in `inventory` and `updates` has the following format: * `\'book_id\'`: An integer representing the unique ID of the book. * `\'edition\'`: An integer representing the edition number of the book. * `\'stock\'`: An integer representing the stock count of the book edition. * `\'update_date\'`: A string representing the date of the update in the format YYYY-MM-DD. * Assume that the inputs are well-formed and conform to the format described. * The edition of a book is always a positive integer. * The book_id is always a positive integer. * The stock is always a non-negative integer. * The update_date is always a valid date string. # Examples ```python >>> inventory = [ {\\"book_id\\": 1, \\"edition\\": 1, \\"stock\\": 10, \\"update_date\\": \\"2023-01-01\\"}, {\\"book_id\\": 2, \\"edition\\": 2, \\"stock\\": 5, \\"update_date\\": \\"2023-01-02\\"} ] >>> updates = [ {\\"book_id\\": 1, \\"edition\\": 1, \\"stock\\": 15, \\"update_date\\": \\"2023-01-05\\"}, {\\"book_id\\": 2, \\"edition\\": 3, \\"stock\\": 7, \\"update_date\\": \\"2023-01-04\\"}, {\\"book_id\\": 1, \\"edition\\": 1, \\"stock\\": 10, \\"update_date\\": \\"2023-01-02\\"} ] >>> update_inventory(inventory, updates) [ {\\"book_id\\": 1, \\"edition\\": 1, \\"stock\\": 15, \\"update_date\\": \\"2023-01-05\\"}, {\\"book_id\\": 2, \\"edition\\": 2, \\"stock\\": 5, \\"update_date\\": \\"2023-01-02\\"}, {\\"book_id\\": 2, \\"edition\\": 3, \\"stock\\": 7, \\"update_date\\": \\"2023-01-04\\"} ] ``` # Note * In the first example, the update to book_id 1, edition 1 with a stock of 15 is accepted since it\'s a higher stock and a later date. * The second update (edition 3) for book_id 2 is added as it’s a new edition. * The third update for book_id 1, edition 1 is ignored as it has an earlier date. **Function Signature** ```python def update_inventory(inventory: list[dict], updates: list[dict]) -> list[dict]: ```","solution":"def update_inventory(inventory, updates): Updates the inventory based on the incoming updates. Parameters: - inventory: A list of dictionaries representing current inventory. - updates: A list of dictionaries representing incoming updates. Returns: - A list of dictionaries representing the updated inventory. # Create a dictionary to track the latest records for quick search and update inventory_dict = { (book[\'book_id\'], book[\'edition\']) : book for book in inventory } for update in updates: key = (update[\'book_id\'], update[\'edition\']) if key in inventory_dict: current = inventory_dict[key] if (update[\'update_date\'] > current[\'update_date\']) or (update[\'update_date\'] == current[\'update_date\'] and update[\'stock\'] > current[\'stock\']): inventory_dict[key] = update else: inventory_dict[key] = update # Convert back the dictionary to the required list of dictionaries return list(inventory_dict.values())"},{"question":"# Binary Search for the First Occurrence Problem Statement You are tasked with implementing a binary search algorithm to find the index of the first occurrence of a given target value in a sorted list. If the target is not present in the list, the function should return -1. Function to Implement Implement the function `find_first_occurrence` which takes the following parameters: 1. **arr**: A sorted list of integers where the search is to be performed. 2. **target**: An integer representing the value to search for. The function should return an integer representing the index of the first occurrence of the target value in the list. If the target is not found, return -1. Example Input ```python arr = [1, 2, 2, 2, 3, 4, 5] target = 2 ``` Example Output ```python 2 ``` Constraints - The length of the list `arr` will be between 1 and 10^5. - The integer values in `arr` and `target` will be between -10^9 and 10^9. Additional Information - You should aim to implement the binary search in O(log n) time complexity. - Ensure that your solution correctly handles edge cases, such as an empty list or a list with no occurrence of the target value. ```python def find_first_occurrence(arr, target): Find the index of the first occurrence of target in a sorted list. :param arr: Sorted list of integers :param target: Integer value to search for :return: Index of the first occurrence of target, or -1 if not found # Your implementation here pass ``` Notes - Use iterative or recursive binary search techniques to find the element. - Carefully handle cases where multiple occurrences of the target exist. - Ensure that the function performs optimally even for large input sizes.","solution":"def find_first_occurrence(arr, target): Find the index of the first occurrence of target in a sorted list. :param arr: Sorted list of integers :param target: Integer value to search for :return: Index of the first occurrence of target, or -1 if not found left, right = 0, len(arr) - 1 result = -1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: result = mid right = mid - 1 # Move left to find the first occurrence elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return result"},{"question":"**Scenario**: You\'ve been asked to implement a system that handles logging messages of varying severity levels in a software application. The log messages can be filtered based on their severity levels, allowing the user to see only the messages they\'re interested in. # Task 1. **Enum Definition**: - Define an `Enum` class `LogLevel` with the following severity levels: `DEBUG`, `INFO`, `WARNING`, `ERROR`, `CRITICAL`. 2. **Logging Class**: - Implement a `Logger` class that: - Initializes with a list to store log messages. - Has different methods for logging messages at each severity level (`log_debug`, `log_info`, `log_warning`, `log_error`, `log_critical`). Each method appends a tuple containing the severity level and the message to the log messages list. - Has a method `filter_logs` that takes a severity level and returns a list of messages at that severity level or higher. 3. **Enhanced Filtering**: - Modify the `filter_logs` method to accept a list of severity levels to filter the logs. It should return all messages that match any of the provided severity levels. - Raise a `ValueError` if an invalid severity level is passed. # Input and Output Format - **Input**: * For `Logger` methods: different severity levels (`LogLevel`), `message` (str). * For `filter_logs`: params `severities` (LogLevel or list of LogLevel). - **Output**: * For logging methods: store the message in the log list. * For `filter_logs`: return a list of tuples containing severity level and message. # Constraints - The severity levels and messages will always be valid strings. # Example ```python # Enum Definition class LogLevel(Enum): DEBUG = 1 INFO = 2 WARNING = 3 ERROR = 4 CRITICAL = 5 # Logging Class class Logger: def __init__(self): self.logs = [] def log_debug(self, message): self.logs.append((LogLevel.DEBUG, message)) def log_info(self, message): self.logs.append((LogLevel.INFO, message)) def log_warning(self, message): self.logs.append((LogLevel.WARNING, message)) def log_error(self, message): self.logs.append((LogLevel.ERROR, message)) def log_critical(self, message): self.logs.append((LogLevel.CRITICAL, message)) def filter_logs(self, severities): if not isinstance(severities, list): severities = [severities] if not all(isinstance(level, LogLevel) for level in severities): raise ValueError(\\"Invalid severity level provided.\\") return [log for log in self.logs if log[0] in severities] # Example Usage logger = Logger() logger.log_info(\\"System initialized.\\") logger.log_warning(\\"Low disk space.\\") logger.log_error(\\"File not found.\\") filtered_logs = logger.filter_logs([LogLevel.WARNING, LogLevel.ERROR]) # returns [(LogLevel.WARNING, \\"Low disk space.\\"), (LogLevel.ERROR, \\"File not found.\\")] try: logger.filter_logs([\\"INVALID\\"]) except ValueError as e: print(e) # Outputs: \\"Invalid severity level provided.\\" ```","solution":"from enum import Enum class LogLevel(Enum): DEBUG = 1 INFO = 2 WARNING = 3 ERROR = 4 CRITICAL = 5 class Logger: def __init__(self): self.logs = [] def log_debug(self, message): self.logs.append((LogLevel.DEBUG, message)) def log_info(self, message): self.logs.append((LogLevel.INFO, message)) def log_warning(self, message): self.logs.append((LogLevel.WARNING, message)) def log_error(self, message): self.logs.append((LogLevel.ERROR, message)) def log_critical(self, message): self.logs.append((LogLevel.CRITICAL, message)) def filter_logs(self, severities): if not isinstance(severities, list): severities = [severities] if not all(isinstance(level, LogLevel) for level in severities): raise ValueError(\\"Invalid severity level provided.\\") return [log for log in self.logs if log[0] in severities]"},{"question":"# Fibonacci Sequence and Even Sum Calculation Context You need to work with the Fibonacci sequence and perform operations on its even-valued terms. The Fibonacci sequence is defined as: - ( F_0 = 0, F_1 = 1 ) - ( F_n = F_{n-1} + F_{n-2} ) for ( n geq 2 ) Task 1. Implement a function, `generate_fibonacci(n: int) -> list` that generates the first `n` terms of the Fibonacci sequence. 2. Implement a function, `sum_of_even_fibonacci(n: int) -> int` that calculates the sum of the even-valued terms in the first `n` terms of the Fibonacci sequence. Specifications 1. You have two functions to implement: ```python def generate_fibonacci(n: int) -> list: Generate the first n terms of the Fibonacci sequence. Args: n: An integer representing the number of terms to generate Returns: list: A list containing the first n terms of the Fibonacci sequence Raises: ValueError: If n is not a positive integer def sum_of_even_fibonacci(n: int) -> int: Return the sum of the even-valued terms in the first n terms of the Fibonacci sequence. Args: n: An integer representing the number of terms to consider Returns: int: The sum of the even-valued terms in the first n terms of the Fibonacci sequence Raises: ValueError: If n is not a positive integer ``` Input and Output Formats * **Input**: * `n` - An integer representing the number of terms to consider. * The input for both functions should be a positive integer. * **Output**: * For `generate_fibonacci`: Return a list of the first `n` terms of the Fibonacci sequence. * For `sum_of_even_fibonacci`: Return the sum of the even-valued terms in the first `n` terms as an integer. Constraints * The input integer `n` should be a positive integer. Examples ```python assert generate_fibonacci(5) == [0, 1, 1, 2, 3] assert generate_fibonacci(10) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] assert sum_of_even_fibonacci(5) == 2 assert sum_of_even_fibonacci(10) == 44 ```","solution":"def generate_fibonacci(n: int) -> list: Generate the first n terms of the Fibonacci sequence. Args: n: An integer representing the number of terms to generate Returns: list: A list containing the first n terms of the Fibonacci sequence Raises: ValueError: If n is not a positive integer if n <= 0: raise ValueError(\\"The input must be a positive integer\\") fibonacci_seq = [0, 1] for _ in range(2, n): fibonacci_seq.append(fibonacci_seq[-1] + fibonacci_seq[-2]) return fibonacci_seq[:n] def sum_of_even_fibonacci(n: int) -> int: Return the sum of the even-valued terms in the first n terms of the Fibonacci sequence. Args: n: An integer representing the number of terms to consider Returns: int: The sum of the even-valued terms in the first n terms of the Fibonacci sequence Raises: ValueError: If n is not a positive integer if n <= 0: raise ValueError(\\"The input must be a positive integer\\") fibonacci_seq = generate_fibonacci(n) even_sum = sum(x for x in fibonacci_seq if x % 2 == 0) return even_sum"},{"question":"# Question: Develop a Robust Logistic Map Visualizer You are tasked with constructing a program that visualizes the logistic map, demonstrating how populations evolve over time with different growth rates. The logistics map is defined by the recursive sequence: [ x_{n+1} = r cdot x_n cdot (1 - x_n) ] where (0 < r leq 4) is the growth rate and (0 < x_0 < 1) is the initial population. # Requirements: 1. Implement a function `plot_logistic_map(start_population: float, growth_rate: float, generations: int)`: * **`start_population` (float)**: The starting population value ( x_0 ) between 0 and 1. * **`growth_rate` (float)**: The growth rate ( r ) between 0 and 4. * **`generations` (int)**: The number of generations to simulate and plot. 2. Utilize **matplotlib** or a similar plotting library to visualize the population over the given generations. 3. Ensure the plot is clear and well-labeled, with population on the y-axis and generation number on the x-axis. # Example: ```python plot_logistic_map(0.5, 3.7, 100) ``` This should produce a plot showing how the population evolves from an initial population of `0.5` with a growth rate of `3.7` over `100` generations. # Constraints: * 0 < `start_population` < 1 * 0 < `growth_rate` <= 4 * 1 <= `generations` <= 1000 # Performance Requirements: * The solution should efficiently compute and plot the population for a large number of generations without excessive delay or memory usage.","solution":"import matplotlib.pyplot as plt def plot_logistic_map(start_population: float, growth_rate: float, generations: int): Plots the logistic map showing population over time for the specified number of generations. :param start_population: Initial population value (0 < start_population < 1) :param growth_rate: Growth rate (0 < growth_rate <= 4) :param generations: Number of generations (1 <= generations <= 1000) :return: None if not (0 < start_population < 1): raise ValueError(\\"start_population must be between 0 and 1\\") if not (0 < growth_rate <= 4): raise ValueError(\\"growth_rate must be between 0 and 4\\") if not (1 <= generations <= 1000): raise ValueError(\\"generations must be between 1 and 1000\\") populations = [start_population] for _ in range(generations): next_population = growth_rate * populations[-1] * (1 - populations[-1]) populations.append(next_population) plt.plot(range(generations + 1), populations, marker=\'o\') plt.title(f\\"Logistic Map (r={growth_rate}, x0={start_population})\\") plt.xlabel(\\"Generation\\") plt.ylabel(\\"Population\\") plt.grid(True) plt.show()"},{"question":"# Question You are given the task of converting a given string into a format where every substring of repeated characters is replaced by the character followed by the number of times it appears consecutively. This process is known as run-length encoding. Your function should adhere to the following specifications: **Function Signature:** ```python def run_length_encoding(s: str) -> str: ``` **Input:** - `s` (string): The input string consisting of only alphanumeric characters (1 ≤ len(s) ≤ 1000). **Output:** - Return a string that represents the run-length encoded form of `s`. **Example:** ```python assert run_length_encoding(\\"aaabbcc\\") == \\"a3b2c2\\" assert run_length_encoding(\\"abcd\\") == \\"a1b1c1d1\\" assert run_length_encoding(\\"aaa\\") == \\"a3\\" assert run_length_encoding(\\"aabbcc\\") == \\"a2b2c2\\" ``` **Constraints and Notes:** - Each group of the same character in the input string should appear in order with the character followed by its count in the output string. - The input string will not contain any spaces or special characters, only alphanumeric characters. - Consider implementing an efficient approach to traverse the string and build the result. # Evaluation Criteria: - Correctness in encoding various strings. - Efficiency in processing input of maximum length. - Clarity and maintainability of the code.","solution":"def run_length_encoding(s: str) -> str: Takes a string s and returns its run-length encoded form. if len(s) == 0: return \\"\\" encoded_str = [] current_char = s[0] count = 1 for i in range(1, len(s)): if s[i] == current_char: count += 1 else: encoded_str.append(f\\"{current_char}{count}\\") current_char = s[i] count = 1 encoded_str.append(f\\"{current_char}{count}\\") # Append the last counted character return \'\'.join(encoded_str)"},{"question":"# Question You are tasked with implementing a function that performs matrix multiplication. The function will take two matrices as input and return their product if multiplication is possible. Requirements 1. The function should check if the number of columns in the first matrix matches the number of rows in the second matrix. If not, raise a ValueError. 2. Multiply the matrices and return the resulting matrix. 3. Add appropriate documentation and type hints to your function. Function Signature ```python def matrix_multiplication(matrix_a: list[list[float]], matrix_b: list[list[float]]) -> list[list[float]]: Perform matrix multiplication on two given matrices. :param matrix_a: List of lists representing the first matrix. :param matrix_b: List of lists representing the second matrix. :return: A list of lists representing the resulting matrix after multiplication. :raises ValueError: If the number of columns in matrix_a does not match the number of rows in matrix_b. pass ``` Input - `matrix_a`: A list of lists of floats, representing the first matrix of dimensions m x n (1 <= m, n <= 100). - `matrix_b`: A list of lists of floats, representing the second matrix of dimensions n x p (1 <= n, p <= 100). Output - Returns a list of lists representing the resulting matrix of dimensions m x p. Constraints - Your solution should handle matrices of sizes up to 100x100 efficiently. - Incorrect dimensions should trigger the respective error. Example ```python matrix_a = [ [1, 2], [3, 4] ] matrix_b = [ [5, 6], [7, 8] ] result_matrix = matrix_multiplication(matrix_a, matrix_b) # Output: # result_matrix = [ # [19, 22], # [43, 50] # ] # In case of mismatched dimensions matrix_a = [ [1, 2, 3], [4, 5, 6] ] matrix_b = [ [7, 8] ] # Raises ValueError ``` Hints - Ensure you iterate through rows of the first matrix and columns of the second matrix to compute each element of the resulting matrix. - Take care of edge cases where the matrix dimensions do not align for multiplication.","solution":"def matrix_multiplication(matrix_a: list[list[float]], matrix_b: list[list[float]]) -> list[list[float]]: Perform matrix multiplication on two given matrices. :param matrix_a: List of lists representing the first matrix. :param matrix_b: List of lists representing the second matrix. :return: A list of lists representing the resulting matrix after multiplication. :raises ValueError: If the number of columns in matrix_a does not match the number of rows in matrix_b. # Check if matrix dimensions are compatible for multiplication if len(matrix_a[0]) != len(matrix_b): raise ValueError(\\"Number of columns in the first matrix must equal the number of rows in the second matrix.\\") # Initialize the resulting matrix with zeros result_matrix = [[0 for _ in range(len(matrix_b[0]))] for _ in range(len(matrix_a))] # Compute the resulting matrix for i in range(len(matrix_a)): for j in range(len(matrix_b[0])): for k in range(len(matrix_b)): result_matrix[i][j] += matrix_a[i][k] * matrix_b[k][j] return result_matrix"},{"question":"# Question Scenario You are working on enhancing the performance of a web application by caching results of frequently accessed database queries. One popular algorithm for cache eviction is the Least Recently Used (LRU) algorithm, which discards the least recently accessed items first. You decide to implement an LRU cache to optimize query performance. Task Implement an LRU cache class with the following methods: - `get(key: int) -> int`: Fetch the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. - `put(key: int, value: int) -> None`: Insert a value by key into the cache. If the cache exceeds its capacity, it should invalidate the least recently used item before inserting the new item. Class Signature ```python class LRUCache: def __init__(self, capacity: int): pass def get(self, key: int) -> int: pass def put(self, key: int, value: int) -> None: pass ``` Constraints - Your implementation should follow O(1) time complexity for both `get` and `put` operations. - The cache capacity will be in the range [1, 10^5]. - The cache will be queried up to 10^6 times in total. Examples ```python cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) print(cache.get(1)) # returns 1 cache.put(3, 3) # evicts key 2 print(cache.get(2)) # returns -1 (not found) cache.put(4, 4) # evicts key 1 print(cache.get(1)) # returns -1 (not found) print(cache.get(3)) # returns 3 print(cache.get(4)) # returns 4 ``` Additional Notes - Use collections like `OrderedDict` or maintain your own doubly linked list to achieve O(1) time complexity. - Ensure your solution is both time and space efficient.","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.cache = OrderedDict() self.capacity = capacity def get(self, key: int) -> int: if key not in self.cache: return -1 else: self.cache.move_to_end(key) return self.cache[key] def put(self, key: int, value: int) -> None: if key in self.cache: self.cache.move_to_end(key) self.cache[key] = value if len(self.cache) > self.capacity: self.cache.popitem(last=False)"},{"question":"# Problem Statement You are developing a navigation system for drones. One of the essential functionalities is tracking the drone\'s position. You need to write a function that updates the drone\'s position based on a series of movements given as a list of instructions. Each instruction is a direction (`\'N\'`, `\'S\'`, `\'E\'`, `\'W\'`) and a distance. # Function Signature ```python def update_drone_position(start_x: int, start_y: int, instructions: list) -> tuple: Args: start_x: Initial x-coordinate of the drone. start_y: Initial y-coordinate of the drone. instructions: A list of instructions, where each instruction is a tuple (direction: str, distance: int). Returns: A tuple representing the new (x, y) position of the drone. ``` # Input Format * `start_x` (int): Initial x-coordinate of the drone. * `start_y` (int): Initial y-coordinate of the drone. * `instructions` (list): A list of instructions, where each instruction is a tuple (direction: str, distance: int). Each direction is one of `\'N\'`, `\'S\'`, `\'E\'`, or `\'W\'`, and distance is a positive integer. # Output Format * A tuple `(x, y)` representing the new position of the drone. # Constraints * `-1e6 <= start_x, start_y <= 1e6` (valid range for initial coordinates) * `1 <= distance <= 1e6` (realistic range for movement distance) * `1 <= len(instructions) <= 1e3` (number of instructions to follow) # Examples ```python >>> update_drone_position(0, 0, [(\'N\', 10), (\'E\', 5), (\'S\', 3), (\'W\', 4)]) (1, 7) >>> update_drone_position(3, 3, [(\'N\', 1), (\'E\', 2), (\'N\', 10)]) (5, 14) >>> update_drone_position(-5, -5, [(\'W\', 10), (\'S\', 2)]) (-15, -7) ``` # Requirement * Validate the input instructions to ensure they follow the expected format and contain valid directions and distances. * Raise appropriate exceptions for invalid inputs.","solution":"def update_drone_position(start_x: int, start_y: int, instructions: list) -> tuple: Updates the drone\'s position based on a series of movement instructions. Args: start_x: Initial x-coordinate of the drone. start_y: Initial y-coordinate of the drone. instructions: A list of instructions, where each instruction is a tuple (direction: str, distance: int). Returns: A tuple representing the new (x, y) position of the drone. # Validate input instructions valid_directions = {\'N\', \'S\', \'E\', \'W\'} for direction, distance in instructions: if direction not in valid_directions: raise ValueError(f\\"Invalid direction \'{direction}\' in instructions.\\") if not isinstance(distance, int) or distance < 1: raise ValueError(f\\"Invalid distance \'{distance}\' in instructions.\\") x, y = start_x, start_y # Process each instruction for direction, distance in instructions: if direction == \'N\': y += distance elif direction == \'S\': y -= distance elif direction == \'E\': x += distance elif direction == \'W\': x -= distance return (x, y)"},{"question":"# Coding Assessment Question Scenario: You are developing a data visualization tool that outputs graphical representations of various datasets. Your task is to implement a line chart component that enables users to plot data points and visualize trends over time. The component should handle different types of data series, allowing for customization such as line color and line thickness. Task: Implement a function that generates a line chart for a given dataset. The function should take in time-series data, plot it on a chart, and allow users to customize the appearance of the line. Function: ```python def generate_line_chart(data: List[Tuple[str, float]], title: str, x_label: str, y_label: str, line_color: str = \'blue\', line_thickness: int = 2) -> None: Creates a line chart with the given data and customization options. Args: data (List[Tuple[str, float]]): A list of tuples where each tuple contains a timestamp (str) and a data value (float). title (str): The title of the chart. x_label (str): The label for the x-axis. y_label (str): The label for the y-axis. line_color (str, optional): The color of the line. Defaults to \'blue\'. line_thickness (int, optional): The thickness of the line. Defaults to 2. Returns: None: The function displays the line chart. ``` Input: * `data` (List[Tuple[str, float]]): The time-series data to be plotted, where each tuple contains a timestamp (`str`) and a corresponding data value (`float`). * `title` (str): The title of the line chart. * `x_label` (str): The label for the x-axis. * `y_label` (str): The label for the y-axis. * `line_color` (str, optional): The color of the line on the chart. Defaults to `blue`. * `line_thickness` (int, optional): The thickness of the line on the chart. Defaults to `2`. Output: * A displayed line chart with the specified data and customization. Constraints: * The timestamps in the `data` list should be in a valid datetime format (e.g. `\'YYYY-MM-DD\'`). * The list `data` must contain at least two data points. Example: ```python # Generate a line chart with sample data data_points = [(\'2023-01-01\', 100.0), (\'2023-02-01\', 120.0), (\'2023-03-01\', 115.0), (\'2023-04-01\', 130.0)] generate_line_chart(data_points, \'Sample Data Over Time\', \'Date\', \'Value\') # Customize the line color and thickness generate_line_chart(data_points, \'Customized Line Chart\', \'Date\', \'Value\', line_color=\'red\', line_thickness=3) ``` The resulting line chart will be displayed with the data points plotted according to the provided timestamps and values. The chart appearance should match the specified customization options for the line color and thickness.","solution":"import matplotlib.pyplot as plt from typing import List, Tuple def generate_line_chart(data: List[Tuple[str, float]], title: str, x_label: str, y_label: str, line_color: str = \'blue\', line_thickness: int = 2) -> None: Creates a line chart with the given data and customization options. Args: data (List[Tuple[str, float]]): A list of tuples where each tuple contains a timestamp (str) and a data value (float). title (str): The title of the chart. x_label (str): The label for the x-axis. y_label (str): The label for the y-axis. line_color (str, optional): The color of the line. Defaults to \'blue\'. line_thickness (int, optional): The thickness of the line. Defaults to 2. Returns: None: The function displays the line chart. if len(data) < 2: raise ValueError(\\"Data list must contain at least two data points.\\") dates, values = zip(*data) plt.figure(figsize=(10, 6)) plt.plot(dates, values, color=line_color, linewidth=line_thickness) plt.title(title) plt.xlabel(x_label) plt.ylabel(y_label) plt.grid(True) plt.show()"},{"question":"Dynamic Programming - Minimum Cost Path in a Grid You need to implement a function that computes the minimum cost path in a grid from the top-left corner to the bottom-right corner. Each cell in the grid contains a value representing the cost of entering that cell. You can only move either down or right at any point in time. **Expected Input and Output Formats**: * **Input**: A 2D list of integers representing the grid. * **Output**: An integer representing the minimum cost to reach the bottom-right corner from the top-left corner. **Constraints/Limitations**: * The grid can be of size MxN, where (1 leq M, N leq 100). * All values in the grid are non-negative integers. **Performance Requirements**: * The solution should efficiently compute the minimum cost using dynamic programming principles, operating within O(M * N) time complexity. **Function Signature**: ```python def min_cost_path(grid: list[list[int]]) -> int: ... ``` # Example: ```python # Example input and validation grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] print(min_cost_path(grid)) # Should output 7 (path: 1→3→1→1→1) # Edge case: single cell grid single_cell_grid = [ [10] ] print(min_cost_path(single_cell_grid)) # Should output 10 ``` **Notes**: * Consider edge cases such as a single-row or single-column grid. * Use dynamic programming to build up the solution from the base case to the full problem.","solution":"def min_cost_path(grid: list[list[int]]) -> int: Compute the minimum cost path in a grid from top-left to bottom-right where moving is only allowed down or right. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] # Initialize the first row for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Initialize the first column for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill in the rest of the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[m-1][n-1]"},{"question":"# Find Duplicate Number in Array Background: You are given an array of integers where each integer is in the range from 1 to n (inclusive), and there is exactly one duplicate number in the array. Your task is to find the duplicate number without modifying the original array and using only constant extra space. Task: 1. **Find the Duplicate**: Implement a function that finds and returns the duplicate number in the array. Function Signature: `find_duplicate(nums: list[int]) -> int` * **Input**: * `nums` - A list of integers where each integer `num` is in the range `[1, n]` and the list contains exactly one duplicate number. * **Output**: * The duplicate number in the array. Constraints: * The array may contain n+1 integers where each integer is within the range [1, n]. * Time complexity should be O(n). * Space complexity should be O(1) (excluding the input array). Example: ```python def find_duplicate(nums): # Typically, you would implement the function using Floyd\'s Tortoise and Hare algorithm # to find the duplicate value. slow, fast = nums[0], nums[0] # Phase 1, finding the intersection point in the cycle while True: slow = nums[slow] fast = nums[nums[fast]] if slow == fast: break # Phase 2, finding the entrance to the cycle slow = nums[0] while slow != fast: slow = nums[slow] fast = nums[fast] return slow # Example array nums = [3, 1, 3, 4, 2] duplicate = find_duplicate(nums) print(duplicate) # Output: 3 ``` Notes: * The array has exactly one duplicate number. * You are required to implement the `find_duplicate` function without modifying the original array and with constant extra space complexity. * Ensure consideration of edge cases such as the minimum size array and all numbers being the same except for the duplicate.","solution":"def find_duplicate(nums): Finds and returns the duplicate number in the array without modifying the array and using only constant extra space. slow = nums[0] fast = nums[0] # Phase 1: Finding the intersection point in the cycle. while True: slow = nums[slow] fast = nums[nums[fast]] if slow == fast: break # Phase 2: Finding the entrance to the cycle. slow = nums[0] while slow != fast: slow = nums[slow] fast = nums[fast] return slow"},{"question":"# Coding Assessment Question Problem You are tasked with creating a function that sorts a list of student records based on multiple fields. Each student record contains a name, age, and GPA, and the sorting should prioritize by GPA in descending order, then by age in ascending order, and finally by name in alphabetical order in case of ties. **Objective**: * Write a function `sort_students` that takes a list of student records and returns the sorted list according to the specified rules. **Function Signature**: ```python def sort_students(students: List[Tuple[str, int, float]]) -> List[Tuple[str, int, float]]: ``` * **Input**: * `students`: A list of tuples, where each tuple contains the following: * `name` (str): The name of the student. * `age` (int): The age of the student. * `gpa` (float): The GPA of the student. * **Output**: * Returns a list of student records sorted by GPA in descending order, then by age in ascending order, and finally by name alphabetically. **Constraints**: * The input list will have at most 10^4 student records. * The names will consist of upper and lower case letters only and will have a maximum length of 100 characters. * Ages will be between 10 and 100 inclusive. * GPA will be a floating-point number between 0.0 and 4.0 inclusive. **Performance Requirements**: * Ensure that the sorting operation is optimized considering the constraints. Example ```python students = [ (\\"John\\", 21, 3.5), (\\"Jane\\", 20, 3.8), (\\"Dave\\", 21, 3.8), (\\"Doe\\", 20, 3.5) ] print(sort_students(students)) # Output: [ # (\\"Jane\\", 20, 3.8), # (\\"Dave\\", 21, 3.8), # (\\"Doe\\", 20, 3.5), # (\\"John\\", 21, 3.5) # ] ``` Additional Information: You can use Python\'s `sorted` function with a custom sorting key to achieve the required order. Remember that for multiple field-based sorting, tuples can be handy in defining the sorting precedence.","solution":"from typing import List, Tuple def sort_students(students: List[Tuple[str, int, float]]) -> List[Tuple[str, int, float]]: Sorts a list of student records based on GPA (descending), then age (ascending), then name (alphabetical). Args: students (List[Tuple[str, int, float]]): List of student records, each containing name (str), age (int), and GPA (float). Returns: List[Tuple[str, int, float]]: Sorted list of student records. return sorted(students, key=lambda x: (-x[2], x[1], x[0]))"},{"question":"# Problem Statement You are tasked with designing an algorithm to process and manipulate a sequence of stock prices to determine potential buy and sell points for maximum profit. Implement a solution that identifies the best days to buy and sell in order to achieve the highest profit. # Objectives 1. Provide a method that efficiently calculates the maximum possible profit given a list of stock prices. 2. The buy action must occur before the sell action. 3. The algorithm should manage edge cases such as steady prices or declining prices. # Function Signature ```python def max_profit(prices: List[int]) -> Tuple[int, int, int]: pass ``` # Input * `prices` (List[int]): A list of integers representing the stock prices, where each index corresponds to a day. # Output * Returns a tuple containing: * `max_profit_value` (int): The maximum profit that can be achieved. * `buy_day` (int): The 0-based index of the day to buy the stock. * `sell_day` (int): The 0-based index of the day to sell the stock. # Constraints * The input list will contain at least 2 prices and have a maximum length of (10^5). * All prices will be non-negative integers less than (10^5). # Example ```python >>> max_profit([7, 1, 5, 3, 6, 4]) (5, 1, 4) >>> max_profit([7, 6, 4, 3, 1]) (0, -1, -1) ``` # Notes * If no profit can be achieved, return a profit of 0 along with -1 for `buy_day` and `sell_day`. * Use efficient algorithms to ensure the solution works within the constraints, aiming for linear time complexity. Explain your approach and any optimizations made in the comments within your code.","solution":"from typing import List, Tuple def max_profit(prices: List[int]) -> Tuple[int, int, int]: Calculate the maximum profit from a list of stock prices. Args: prices: List[int] - A list of integers representing the stock prices. Returns: Tuple containing: - max_profit_value (int): The maximum profit that can be achieved. - buy_day (int): The 0-based index of the day to buy the stock. - sell_day (int): The 0-based index of the day to sell the stock. if not prices or len(prices) < 2: return (0, -1, -1) min_price = prices[0] min_index = 0 max_profit = 0 buy_day = -1 sell_day = -1 for i in range(1, len(prices)): if prices[i] < min_price: min_price = prices[i] min_index = i elif prices[i] - min_price > max_profit: max_profit = prices[i] - min_price buy_day = min_index sell_day = i return (max_profit, buy_day, sell_day)"},{"question":"# Problem Statement: You are given a task to determine the number of unique ways to partition a given integer number `n` into a sum of at least two positive integers, where each partition is represented as a sorted list in non-decreasing order. Construct a function `partition_count(n: int, k: int) -> int` which calculates the number of unique partitions of `n` where the number of addends in each partition is exactly `k`. # Input Format: - `n` (integer): The integer number to be partitioned (2 ≤ n ≤ 100). - `k` (integer): The exact number of addends in the partitions (2 ≤ k ≤ n). # Output Format: - Return an integer representing the number of unique ways to partition the integer `n` into exactly `k` addends. # Example: ```python >>> partition_count(5, 2) 2 # The two partitions are: [1, 4], [2, 3] >>> partition_count(5, 3) 2 # The two partitions are: [1, 1, 3], [1, 2, 2] >>> partition_count(6, 3) 3 # The three partitions are: [1, 1, 4], [1, 2, 3], [2, 2, 2] ``` # Constraints: - Ensure your solution handles the upper bounds of the input without significant performance degradation. - Consider edge cases where `n` and `k` are close in value. - Optimize the function for efficient performance in terms of both time and space. # Implementation Details: Use dynamic programming or recursive algorithms to systematically explore and count all possible partitions of `n` satisfying the given conditions. Keep track of previously computed states to avoid redundant calculations and ensure efficient execution.","solution":"def partition_count(n, k): def partitions(result, start, n, k): # Base case: if no numbers left to add and k parts left if k == 0: return 1 if n == 0 else 0 elif n <= 0: return 0 count = 0 for i in range(start, n + 1): count += partitions(result, i, n - i, k - 1) return count result = [] return partitions(result, 1, n, k)"},{"question":"Problem Description In the context of data analysis and reporting, you are to write a function that summarizes information about numerical data in a specific format. Your task is to compute specific statistics from a list of integers and format the results into a standardized report. Task 1. **Compute Basic Statistics**: * Calculate the minimum, maximum, sum, average (mean), and median of the list of integers. 2. **Format the Report**: * Present the computed statistics in the following format: ``` Minimum: <min_value> Maximum: <max_value> Sum: <sum_value> Average: <average_value> Median: <median_value> ``` * Ensure the average and median values are presented to two decimal places. 3. **Input Validation**: * Validate that the input is a non-empty list of integers. * If the input is invalid, return the string `\\"Invalid input\\"`. 4. **Edge Cases**: * Handle cases with single-element lists. * Ensure the function can manage lists with both positive and negative numbers as well as zeros. # Input and Output Formats Function: `generate_report` * **Input**: * A `data` list containing integers. * Constraints: The list will contain at least one integer. * **Output**: * A string formatted according to the specified report structure, or `\\"Invalid input\\"` if the input is invalid. * **Example**: ```python generate_report([1, 2, 3, 4, 5]) == \'Minimum: 1nMaximum: 5nSum: 15nAverage: 3.00nMedian: 3.00\' ``` * **Example with Edge Case (single element)**: ```python generate_report([10]) == \'Minimum: 10nMaximum: 10nSum: 10nAverage: 10.00nMedian: 10.00\' ``` * **Example with Negative and Positive Values**: ```python generate_report([-1, -2, 0, 1, 2]) == \'Minimum: -2nMaximum: 2nSum: 0nAverage: 0.00nMedian: 0.00\' ``` Implementation Details 1. Validate the input to ensure it is a non-empty list of integers. Return `\\"Invalid input\\"` if the validation fails. 2. Calculate the minimum, maximum, sum, average (rounded to two decimal places), and median (rounded to two decimal places) of the list. 3. Format and return the results as a string in the specified report structure.","solution":"def generate_report(data): Generates a report with basic statistics of the list `data`. Parameters: data (list): A list of integers. Returns: str: A formatted string with basic statistics or \\"Invalid input\\". if not isinstance(data, list) or len(data) == 0 or not all(isinstance(i, int) for i in data): return \\"Invalid input\\" data_sorted = sorted(data) n = len(data) minimum = data_sorted[0] maximum = data_sorted[-1] total_sum = sum(data) average = total_sum / n if n % 2 == 0: median = (data_sorted[n//2 - 1] + data_sorted[n//2]) / 2 else: median = data_sorted[n//2] report = ( f\\"Minimum: {minimum}n\\" f\\"Maximum: {maximum}n\\" f\\"Sum: {total_sum}n\\" f\\"Average: {average:.2f}n\\" f\\"Median: {median:.2f}\\" ) return report"},{"question":"# Coding Assessment Question You are developing a system to manage and query information about books in a library. Implement a `Library` class that provides functionalities to add books, search for books by title, and list all books written by a specific author. **Requirements**: 1. Implement the `Library` class constructor to initialize an empty collection of books. 2. Implement the `add_book` method to add a book\'s information to the library. 3. Implement the `search_by_title` method to find a book by its title. 4. Implement the `list_books_by_author` method to list all books written by a given author. **Function Signatures**: ```python class Library: def __init__(self) -> None: Init method to store an empty collection of books. def add_book(self, title: str, author: str, year: int) -> None: Add a book to the library with the provided title, author, and publication year. def search_by_title(self, title: str) -> dict: Search and return the details of the book with the given title. If the book is not found, return an empty dictionary. def list_books_by_author(self, author: str) -> list: Return a list of dictionaries, each representing a book written by the given author. If no books are found for that author, return an empty list. ``` **Input**: * **title**: A string representing the title of the book. * **author**: A string representing the name of the author. * **year**: An integer representing the year the book was published. **Output**: * **search_by_title**: Return a dictionary with the book\'s details (title, author, year) if found, or an empty dictionary if not found. * **list_books_by_author**: Return a list of dictionaries where each dictionary contains the details of a book (title, author, year) by the specified author, or an empty list if no books by that author are found. **Example**: ```python library = Library() library.add_book(\\"To Kill a Mockingbird\\", \\"Harper Lee\\", 1960) library.add_book(\\"1984\\", \\"George Orwell\\", 1949) library.add_book(\\"Animal Farm\\", \\"George Orwell\\", 1945) print(library.search_by_title(\\"1984\\")) # Output: {\'title\': \'1984\', \'author\': \'George Orwell\', \'year\': 1949} print(library.search_by_title(\\"The Great Gatsby\\")) # Output: {} print(library.list_books_by_author(\\"George Orwell\\")) # Output: [{\'title\': \'1984\', \'author\': \'George Orwell\', \'year\': 1949}, {\'title\': \'Animal Farm\', \'author\': \'George Orwell\', \'year\': 1945}] print(library.list_books_by_author(\\"J.K. Rowling\\")) # Output: [] ``` **Constraints**: * The number of books that can be added to the library is at most (10^4). * Book titles will be unique within the library. * Authors can have multiple books. * Titles and author names are strings with a maximum length of 100 characters. * Years are integers within a valid range (e.g., 1500 to 2023).","solution":"class Library: def __init__(self) -> None: Init method to store an empty collection of books. self.books = [] def add_book(self, title: str, author: str, year: int) -> None: Add a book to the library with the provided title, author, and publication year. self.books.append({\\"title\\": title, \\"author\\": author, \\"year\\": year}) def search_by_title(self, title: str) -> dict: Search and return the details of the book with the given title. If the book is not found, return an empty dictionary. for book in self.books: if book[\\"title\\"] == title: return book return {} def list_books_by_author(self, author: str) -> list: Return a list of dictionaries, each representing a book written by the given author. If no books are found for that author, return an empty list. return [book for book in self.books if book[\\"author\\"] == author]"},{"question":"# String Compression Algorithm Objective Implement a function to perform basic string compression using the counts of repeated characters and decompression of such compressed strings. Problem Statement Given an input string, write functions that: 1. Compress the string following the rules outlined below. 2. Decompress the string back to its original form. Input and Output * **Input Format**: - A string `text` to be compressed or decompressed. * **Output Format**: - A string representing the compressed or decompressed text. Constraints 1. The input string will only contain uppercase English letters (A-Z). 2. The length of the string will not exceed 100 characters. 3. In the compressed format, a single letter followed by a single digit (e.g., \\"A1\\") will be counted as the letter itself. Compression Rules The compression scheme is simple: For each group of repeated characters in the string, the character is followed by the count of repetitions. If the compressed string is not shorter than the original string, return the original string instead. Decompression Rules For each character followed by a digit in the compressed string, expand the character according to the digit count. Requirements * **Functions**: 1. `compress(text: str) -> str` 2. `decompress(text: str) -> str` Example ```python # Example 1 text = \'AABCCCCC\' compressed_text = compress(text) print(compressed_text) # Should output \'A2B1C5\' decompressed_text = decompress(compressed_text) print(decompressed_text) # Should output \'AABCCCCC\' # Example 2 text = \'AABB\' compressed_text = compress(text) print(compressed_text) # Should output \'AABB\' because \'A2B2\' is not shorter decompressed_text = decompress(compressed_text) print(decompressed_text) # Should output \'AABB\' ```","solution":"def compress(text): Compress the input string using the counts of repeated characters. If the compressed string is not shorter than original, return the original string. if not text: return text compressed = [] count = 1 prev_char = text[0] for char in text[1:]: if char == prev_char: count += 1 else: compressed.append(prev_char + str(count)) prev_char = char count = 1 compressed.append(prev_char + str(count)) compressed_text = \'\'.join(compressed) return compressed_text if len(compressed_text) < len(text) else text def decompress(text): Decompress the input string which was compressed using counts of repeated characters. if not text: return text decompressed = [] i = 0 while i < len(text): char = text[i] count = int(text[i + 1]) decompressed.append(char * count) i += 2 return \'\'.join(decompressed)"},{"question":"# Coding Assessment Question You are tasked with developing a small CLI-based budget tracking application. Implement a `BudgetTracker` class to manage expenses, income entries, and calculate the total balance. **Requirements**: 1. Implement the `BudgetTracker` class constructor to initialize an empty list for transactions. 2. Implement the `add_income` method to add an income entry. 3. Implement the `add_expense` method to add an expense entry. 4. Implement the `calculate_balance` method to calculate the total balance. The balance is the sum of all incomes minus the sum of all expenses. **Function Signatures**: ```python class BudgetTracker: def __init__(self) -> None: Init method to initialize the list of transactions. def add_income(self, amount: float, description: str) -> None: Add an income entry. def add_expense(self, amount: float, description: str) -> None: Add an expense entry. def calculate_balance(self) -> float: Calculate and return the balance. ``` **Input**: * **amount** (for both `add_income` and `add_expense` methods): A float representing the income or expense amount. * **description** (for both `add_income` and `add_expense` methods): A string describing the income or expense. **Output**: * **calculate_balance**: Return the total balance as a float. **Example**: ```python tracker = BudgetTracker() tracker.add_income(1000.0, \\"Salary\\") tracker.add_expense(200.0, \\"Groceries\\") tracker.add_expense(150.0, \\"Utilities\\") print(tracker.calculate_balance()) # Output: 650.0 tracker.add_income(500.0, \\"Bonus\\") tracker.add_expense(100.0, \\"Transport\\") print(tracker.calculate_balance()) # Output: 1050.0 ``` **Constraints**: * `amount` will be a positive float. * `description` will be a non-empty string. * The number of transactions will be up to (10^4).","solution":"class BudgetTracker: def __init__(self) -> None: Init method to initialize the list of transactions. self.transactions = [] def add_income(self, amount: float, description: str) -> None: Add an income entry. self.transactions.append((\'income\', amount, description)) def add_expense(self, amount: float, description: str) -> None: Add an expense entry. self.transactions.append((\'expense\', amount, description)) def calculate_balance(self) -> float: Calculate and return the balance. balance = 0.0 for transaction in self.transactions: if transaction[0] == \'income\': balance += transaction[1] elif transaction[0] == \'expense\': balance -= transaction[1] return balance"},{"question":"# Problem Statement A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. A twin prime is a pair of prime numbers that differ by exactly two (e.g., (3, 5), (11, 13)). Your task is to find all twin prime pairs within a given range `[start, end]`. **Task**: Write a Python function `find_twin_primes` that computes all twin prime pairs within the provided range. # Requirements 1. **Function Definition**: ```python def find_twin_primes(start: int, end: int) -> List[Tuple[int, int]]: pass ``` 2. **Input**: - `start`: An integer representing the start of the range (inclusive). - `end`: An integer representing the end of the range (inclusive). 3. **Output**: - Returns a list of tuples, where each tuple consists of twin prime numbers within the given range. 4. **Constraints**: - `1 <= start <= end <= 10^6` - The range may not necessarily contain any twin primes. 5. **Error Handling**: - If no twin primes are found within the range, return an empty list. # Example ```python result = find_twin_primes(1, 100) print(result) # Should print: [(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)] ``` # Performance Requirements - Ensure the solution is efficient, leveraging techniques such as the Sieve of Eratosthenes to find prime numbers up to `end`. The algorithm should be optimized to handle large ranges efficiently. Be mindful of edge cases such as range boundaries and ensure the correctness of prime number identification within the specified range.","solution":"from typing import List, Tuple def find_twin_primes(start: int, end: int) -> List[Tuple[int, int]]: Finds all twin prime pairs within the given range [start, end]. Parameters: start (int): The starting range (inclusive). end (int): The ending range (inclusive). Returns: List[Tuple[int, int]]: A list of twin prime pairs within the specified range. def sieve_of_eratosthenes(n): Returns a list of booleans representing primality of numbers from 0 to n. is_prime = [True] * (n + 1) p = 2 while (p * p <= n): if is_prime[p] == True: for i in range(p * p, n + 1, p): is_prime[i] = False p += 1 is_prime[0], is_prime[1] = False, False # 0 and 1 are not prime numbers return is_prime if start < 1 or end < 1 or start > end: return [] is_prime = sieve_of_eratosthenes(end) twin_primes = [] for num in range(start, end - 1): if is_prime[num] and is_prime[num + 2]: twin_primes.append((num, num + 2)) return twin_primes"},{"question":"Problem Overview You are tasked with implementing a binary search algorithm to find the leftmost (first occurrence) index of a given target element in a sorted array of integers. This classic problem is essential for understanding how binary search can be adapted to meet specific requirements beyond simple existence checks. Detailed Description # Function Specification You need to implement the following function: ```python def find_leftmost_index(arr: list[int], target: int) -> int: Finds the leftmost index of the target element in a sorted array using binary search. Parameters: arr (list[int]): A sorted list of integers. target (int): The target integer to find. Returns: int: The leftmost index of the target element if it exists in the array; otherwise, -1. pass ``` # Input - A sorted list of integers `arr`, where 0 ≤ len(arr) ≤ 10^5 and each integer in the array is between -10^9 and 10^9. - An integer `target`, where -10^9 ≤ target ≤ 10^9. # Output - An integer representing the leftmost index of the `target` in the array, or -1 if the target is not found. # Constraints - You must use the Binary Search algorithm. - The solution should handle edge cases efficiently, such as empty arrays or arrays without the target element. # Example: ```python >>> find_leftmost_index([1, 2, 2, 2, 3, 4, 5], 2) 1 >>> find_leftmost_index([1, 2, 3, 4, 5], 6) -1 >>> find_leftmost_index([], 3) -1 >>> find_leftmost_index([-10, -5, 0, 3, 3, 3, 8, 9], 3) 3 ``` # Implementation Notes - Use an iterative or recursive approach to implement binary search. - Keep track of the possible index of the leftmost occurrence while narrowing down the search range. - Ensure the algorithm has a time complexity of O(log n) due to the binary search. - Test edge cases like empty arrays, single-element arrays, and arrays where the target is not present or appears multiple times.","solution":"def find_leftmost_index(arr: list[int], target: int) -> int: Finds the leftmost index of the target element in a sorted array using binary search. Parameters: arr (list[int]): A sorted list of integers. target (int): The target integer to find. Returns: int: The leftmost index of the target element if it exists in the array; otherwise, -1. left, right = 0, len(arr) - 1 result = -1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: result = mid right = mid - 1 # look on the left side of mid elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return result"},{"question":"# String Pattern Matching Assessment You are tasked with implementing an efficient string pattern matching function. Design a function named `find_substrings(s: str, pattern: str) -> List[int]`. Requirements: 1. The function should return a list of starting indices where the `pattern` is found within the string `s`. 2. Optimize the method to handle larger inputs efficiently using algorithms such as **Knuth-Morris-Pratt (KMP)** or **Rabin-Karp**. 3. Handle edge cases where the pattern is not found or where the input string or pattern may be empty. Constraints: - `0 <= len(s), len(pattern) <= 10^5` Expected Input and Output: ```python >>> find_substrings(\\"abracadabra\\", \\"abra\\") [0, 7] >>> find_substrings(\\"aaaaa\\", \\"aa\\") [0, 1, 2, 3] >>> find_substrings(\\"hello world\\", \\"o\\") [4, 7] >>> find_substrings(\\"mississippi\\", \\"issi\\") [1, 4] >>> find_substrings(\\"abc\\", \\"\\") [] >>> find_substrings(\\"\\", \\"abc\\") [] >>> find_substrings(\\"aaa\\", \\"aaaa\\") [] ```","solution":"def find_substrings(s: str, pattern: str) -> list: Returns a list of starting indices where the `pattern` is found within the string `s`. # Base case: if pattern is empty, return an empty list if not pattern: return [] # Lengths of the input string and pattern n, m = len(s), len(pattern) # Base case: if pattern is longer than s, no match can exist if m > n: return [] # KMP algorithm implementation def compute_lps(pattern): lps = [0] * len(pattern) length = 0 i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps lps = compute_lps(pattern) indices = [] i = j = 0 while i < n: if pattern[j] == s[i]: i += 1 j += 1 if j == m: indices.append(i - j) j = lps[j - 1] elif i < n and pattern[j] != s[i]: if j != 0: j = lps[j - 1] else: i += 1 return indices"},{"question":"# Question You are provided with a matrix of `n x m` of integers. Your task is to find the number of unique paths to reach the bottom-right corner (cell `(n-1, m-1)`) from the top-left corner (cell `(0, 0)`) if you can only move right or down. Write a function `unique_paths` that calculates this number. # Function Signature ```python def unique_paths(n: int, m: int) -> int: pass ``` # Input - `n`: An integer representing the number of rows in the matrix. - `m`: An integer representing the number of columns in the matrix. # Output - An integer representing the number of unique paths from the top-left to the bottom-right corner. # Example ```python print(unique_paths(3, 7)) # Output: 28 print(unique_paths(3, 2)) # Output: 3 ``` # Constraints - `1 <= n, m <= 100`. # Requirements - Ensure your function is optimized for large matrices and completes within a reasonable time frame. - Handle edge cases where the matrix dimensions are minimal (e.g., 1x1). # Hints - You may use dynamic programming to build a solution starting from the top-left corner and proceeding to fill the number of paths to each cell based on the cells from which it can be reached.","solution":"def unique_paths(n: int, m: int) -> int: # Create a 2D list to store the number of paths to reach each cell dp = [[0] * m for _ in range(n)] # Initialize the first row and first column for i in range(n): dp[i][0] = 1 for j in range(m): dp[0][j] = 1 # Fill the dp table for i in range(1, n): for j in range(1, m): dp[i][j] = dp[i-1][j] + dp[i][j-1] # The bottom-right corner will have the number of unique paths return dp[n-1][m-1]"},{"question":"# Problem Statement You need to implement a simple text editor that supports a sequence of operations: inserting a character at a specific position, deleting a character from a specific position, and retrieving the current state of the text. Each operation is defined by its type and the parameters required. # Function Implementation 1. **Function 1**: `TextEditor()` - **Description**: Initialize your text editor with an empty string. 2. **Function 2**: `insert_char(self, position: int, char: str) -> None` - **Input**: An integer `position` (0-based) to insert character `char` (a single alphabetic character) at that index. - **Output**: None - **Constraints**: * The `char` is guaranteed to be a single alphabetic character. * The `position` is guaranteed to be valid (i.e., 0 ≤ position ≤ length of current string). 3. **Function 3**: `delete_char(self, position: int) -> None` - **Input**: An integer `position` (0-based) to delete the character at that index. - **Output**: None - **Constraints**: * The `position` is guaranteed to be valid (i.e., 0 ≤ position < length of current string). 4. **Function 4**: `get_text(self) -> str` - **Output**: Return the current state of the text as a string. # Requirements * Your implementation should be efficient in handling insert, delete, and get operations. * Make sure the operations correctly handle edge cases such as inserting or deleting at the boundaries of the string. # Example ```python class TextEditor: def __init__(self): Initialize your text editor with an empty string. self.text = \\"\\" def insert_char(self, position: int, char: str) -> None: Insert a character at the specified position. :param position: Index to insert the character at (0-based) :param char: Character to insert self.text = self.text[:position] + char + self.text[position:] def delete_char(self, position: int) -> None: Delete the character at the specified position. :param position: Index to delete the character from (0-based) self.text = self.text[:position] + self.text[position + 1:] def get_text(self) -> str: Get the current state of the text. :return: Current text as a string return self.text # Usage example editor = TextEditor() editor.insert_char(0, \'h\') editor.insert_char(1, \'e\') editor.insert_char(2, \'l\') editor.insert_char(3, \'l\') editor.insert_char(4, \'o\') print(editor.get_text()) # Output: \'hello\' editor.delete_char(0) print(editor.get_text()) # Output: \'ello\' ```","solution":"class TextEditor: def __init__(self): Initialize your text editor with an empty string. self.text = \\"\\" def insert_char(self, position: int, char: str) -> None: Insert a character at the specified position. :param position: Index to insert the character at (0-based) :param char: Character to insert self.text = self.text[:position] + char + self.text[position:] def delete_char(self, position: int) -> None: Delete the character at the specified position. :param position: Index to delete the character from (0-based) self.text = self.text[:position] + self.text[position + 1:] def get_text(self) -> str: Get the current state of the text. :return: Current text as a string return self.text"},{"question":"# Problem Statement You are designing a software system for an online library that manages book rentals. The system should help users calculate the total rental cost of books based on the rental duration and different pricing schemes. Your task is to implement three functions: `calculate_total_cost`, `apply_discount`, and `late_fee`. Each function should perform calculations according to the given rules and assumptions. # Input and Output Format Function 1: `calculate_total_cost(rental_rate: float, days_rented: int) -> float` * **Input**: * `rental_rate` (float): The daily rental rate of a book (dollars per day). * `days_rented` (int): The number of days the book is rented. * **Output**: * Returns the total rental cost as a float. Function 2: `apply_discount(total_cost: float, discount_rate: float, max_discount: float) -> float` * **Input**: * `total_cost` (float): The initial total rental cost (dollars). * `discount_rate` (float): The discount rate to apply (percentage). * `max_discount` (float): The maximum discount that can be applied (dollars). * **Output**: * Returns the total cost after applying the discount as a float. Function 3: `late_fee(initial_cost: float, days_late: int, late_rate: float) -> float` * **Input**: * `initial_cost` (float): The initial cost before the late fee (dollars). * `days_late` (int): The number of days the book is returned late. * `late_rate` (float): The late fee rate per day (dollars per day). * **Output**: * Returns the total cost including the late fee as a float. # Requirements 1. Each function should raise a `ValueError` with a meaningful message if any input is invalid (e.g., negative values for rates or days). 2. Apply discounts and late fees correctly based on the provided inputs. 3. Ensure that the discount applied does not exceed the specified maximum discount amount. 4. Check for edge cases such as zero rental days or zero discount rates. # Example ```python # Example usages based on provided rules # Total cost calculation assert isclose(calculate_total_cost(2.5, 10), 25.0) assert isclose(calculate_total_cost(3.0, 5), 15.0) # Applying discounts assert isclose(apply_discount(100.0, 10.0, 5.0), 95.0) assert isclose(apply_discount(50.0, 20.0, 10.0), 40.0) assert isclose(apply_discount(30.0, 50.0, 15.0), 15.0) # maximum discount # Late fee calculation assert isclose(late_fee(20.0, 3, 2.0), 26.0) assert isclose(late_fee(60.0, 5, 1.5), 67.5) # Checking for ValueErrors try: calculate_total_cost(-2.5, 5) except ValueError as e: assert str(e) == \\"Rental rate must be positive\\" try: apply_discount(100.0, 110.0, 5.0) except ValueError as e: assert str(e) == \\"Discount rate must be between 0 and 100\\" ``` # Constraints * The input values will be within valid ranges for their types. * The input values will be floating point numbers or integers, as specified in the function signatures. * Rental rate, discount rate, and late rate will be non-negative. * Number of days (rented or late) will be non-negative integers. You are expected to implement these functions in Python, ensuring correctness and efficiency.","solution":"def calculate_total_cost(rental_rate: float, days_rented: int) -> float: if rental_rate < 0: raise ValueError(\\"Rental rate must be non-negative\\") if days_rented < 0: raise ValueError(\\"Days rented must be non-negative\\") return rental_rate * days_rented def apply_discount(total_cost: float, discount_rate: float, max_discount: float) -> float: if total_cost < 0: raise ValueError(\\"Total cost must be non-negative\\") if discount_rate < 0 or discount_rate > 100: raise ValueError(\\"Discount rate must be between 0 and 100\\") if max_discount < 0: raise ValueError(\\"Max discount must be non-negative\\") discount = total_cost * (discount_rate / 100) if discount > max_discount: discount = max_discount return total_cost - discount def late_fee(initial_cost: float, days_late: int, late_rate: float) -> float: if initial_cost < 0: raise ValueError(\\"Initial cost must be non-negative\\") if days_late < 0: raise ValueError(\\"Days late must be non-negative\\") if late_rate < 0: raise ValueError(\\"Late rate must be non-negative\\") return initial_cost + (days_late * late_rate)"},{"question":"# Question: Validate and Generate International Phone Numbers You are tasked with developing a function that validates an input string representing an international phone number and another function that formats a given number into the international phone number format. Input: 1. A single string containing a potential international phone number. 2. A pair of strings: a country code and a local phone number string. Output: 1. A Boolean indicating if the input string is a valid international phone number. 2. A formatted string representing the international phone number. Constraints: - A valid international phone number must start with a plus symbol followed by a country code and a local phone number (e.g., `+1-202-555-0133`). - The country code must be digits only and can have 1-3 digits. - The local phone number must contain groups of digits separated by hyphens, spaces, or nothing (no mixed separators). - The local phone number should be at least 7 digits long. - The formatted phone number should use only hyphens for separators. Examples: ```python def validate_phone_number(phone_number: str) -> bool: Validate an international phone number. :param phone_number: str: The string to validate. :return: bool: True if valid, False otherwise. Examples: >>> validate_phone_number(\\"+1-202-555-0133\\") True >>> validate_phone_number(\\"+44 20 7946 0958\\") True >>> validate_phone_number(\\"+1-202-555-0133 ext. 456\\") False >>> validate_phone_number(\\"1-202-555-0133\\") False >>> validate_phone_number(\\"+12345678\\") True >>> validate_phone_number(\\"+99 123 1234 1234 1234\\") True >>> validate_phone_number(\\"+12345678901234567890\\") False import re pattern = re.compile(r\'^+d{1,3}([- ]?d+)+\') match = pattern.match(phone_number) if not match: return False # Removing non-digit characters and check the total length of local phone number part phone_parts = re.split(r\'[- ]\', phone_number) local_number = \'\'.join(phone_parts[1:]) # Exclude country code part return 7 <= len(local_number) <= 15 def format_phone_number(country_code: str, local_phone_number: str) -> str: Format a phone number with the given country code and local number. :param country_code: str: The country code. :param local_phone_number: str: The local phone number string. :return: str: The formatted international phone number. Examples: >>> format_phone_number(\\"1\\", \\"202-555-0133\\") \'+1-202-555-0133\' >>> format_phone_number(\\"44\\", \\"20 7946 0958\\") \'+44-20-7946-0958\' >>> format_phone_number(\\"91\\", \\"9876543210\\") \'+91-9876543210\' >>> format_phone_number(\\"123\\", \\"456 7890123\\") \'+123-456-7890123\' # Normalize local phone number to use hyphens as separators local_phone_number = re.sub(r\'[ ]\', \'-\', local_phone_number) return f\\"+{country_code}-{local_phone_number}\\" if __name__ == \\"__main__\\": from doctest import testmod testmod() ``` Your task is to implement the two functions `validate_phone_number` and `format_phone_number` according to the specifications given above.","solution":"import re def validate_phone_number(phone_number: str) -> bool: Validate an international phone number. :param phone_number: str: The string to validate. :return: bool: True if valid, False otherwise. pattern = re.compile(r\'^+d{1,3}([- ]?d+)+\') match = pattern.match(phone_number) if not match: return False # Removing non-digit characters and check the total length of local phone number part phone_parts = re.split(r\'[- ]\', phone_number) local_number = \'\'.join(phone_parts[1:]) # Exclude country code part return 7 <= len(local_number) <= 15 def format_phone_number(country_code: str, local_phone_number: str) -> str: Format a phone number with the given country code and local number. :param country_code: str: The country code. :param local_phone_number: str: The local phone number string. :return: str: The formatted international phone number. # Normalize local phone number to use hyphens as separators local_phone_number = re.sub(r\'[ ]\', \'-\', local_phone_number) return f\\"+{country_code}-{local_phone_number}\\""},{"question":"# Suffix Array Construction and Searching Design a function `suffix_array_search` that constructs a suffix array from a given string and uses it to search for a pattern within the string. Function Signature: ```python def suffix_array_search(text: str, pattern: str) -> list[int]: ``` Input: * `text`: A string representing the text to be searched, consisting of lowercase alphabetical characters. * `pattern`: A string representing the pattern to be found in the text, also consisting of lowercase alphabetical characters. Output: * A list of integers representing the starting indices where the pattern is found within the text. The list should be sorted in ascending order. Constraints: * (1 leq text{len(text)} leq 10^5) * (1 leq text{len(pattern)} leq 100) Example: ```python text = \\"banana\\" pattern = \\"ana\\" result = suffix_array_search(text, pattern) print(result) # Example output: [1, 3] ``` Explanation 1. **Building the Suffix Array**: * Create a suffix array from the given text where each entry represents the starting index of a suffix in the text. * Sort the suffix array based on the lexicographical order of the suffixes. 2. **Searching for the Pattern**: * Use binary search on the suffix array to efficiently locate the occurrences of the pattern in the text. * Return the starting indices of the matched pattern. Your implementation should handle large strings efficiently and ensure the operations on the suffix array are optimal. Document your code with appropriate comments explaining key parts of the algorithm.","solution":"def build_suffix_array(text): # Generate suffixes along with their starting indices suffixes = sorted((text[i:], i) for i in range(len(text))) # Extract and return only the starting indices sorted by the suffixes return [suffix[1] for suffix in suffixes] def binary_search(suffix_array, text, pattern): n = len(text) m = len(pattern) l = 0 r = n - 1 left_bound = -1 right_bound = -1 # Finding the left bound while l <= r: mid = (l + r) // 2 suffix = text[suffix_array[mid]:suffix_array[mid] + m] if suffix < pattern: l = mid + 1 else: r = mid - 1 left_bound = l l = 0 r = n - 1 # Finding the right bound while l <= r: mid = (l + r) // 2 suffix = text[suffix_array[mid]:suffix_array[mid] + m] if suffix <= pattern: l = mid + 1 else: r = mid - 1 right_bound = r # All occurrences of pattern are in suffixes in the range [left_bound, right_bound] if left_bound <= right_bound: return suffix_array[left_bound:right_bound + 1] else: return [] def suffix_array_search(text: str, pattern: str) -> list[int]: suffix_array = build_suffix_array(text) indices = binary_search(suffix_array, text, pattern) return sorted(indices)"},{"question":"# Robot Path Finder **Scenario**: You are designing a path-finding algorithm for a simple robot in a 2D grid. The grid contains obstacles that the robot must navigate around to reach its destination. The robot can move in 4 directions: up, down, left, and right. You are given the starting position, the destination position, and the grid configuration. Your task is to determine the minimum number of moves required for the robot to reach the destination, or return -1 if it is impossible. Task: Implement the function `minimum_moves(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int`. Given a 2D grid (a list of lists), the starting position, and the destination position, the function should return the minimum number of moves required for the robot to reach the destination, or -1 if it is impossible. Input: - `grid` (List[List[int]]): A 2D grid where `0` represents an open cell and `1` represents an obstacle. - `start` (Tuple[int, int]): A tuple representing the starting position of the robot. - `end` (Tuple[int, int]): A tuple representing the destination position of the robot. Output: - An integer representing the minimum number of moves required to reach the destination, or -1 if the destination is unreachable. Constraints: - The dimensions of the grid are m x n where 1 ≤ m, n ≤ 100. - Both `start` and `end` positions are guaranteed to be valid positions within the grid (i.e., not obstacles and within bounds). Examples: - When `grid` is `[[0, 0, 0], [1, 1, 0], [0, 0, 0]]`, `start` is `(0, 0)`, and `end` is `(2, 2)`, the function should return `4`. - When `grid` is `[[0, 1, 0], [1, 0, 1], [0, 1, 0]]`, `start` is `(0, 0)`, and `end` is `(2, 2)`, the function should return `-1`. # Performance requirements: - The function must efficiently handle grids of the maximum size with a balanced consideration for time and space complexity. - Use an appropriate algorithm like Breadth-First Search (BFS) to ensure the shortest path is found in an optimal manner. # Notes: - You may use common Python libraries for data structures (e.g., `collections.deque` for the BFS queue). - Consider edge cases like starting position being the same as the destination or the grid being entirely blocked. Example code snippet to be implemented: ```python from typing import List, Tuple from collections import deque def minimum_moves(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int: Return the minimum number of moves required for the robot to reach the destination, or -1 if the destination is unreachable. # Your implementation here ```","solution":"from typing import List, Tuple from collections import deque def minimum_moves(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int: Return the minimum number of moves required for the robot to reach the destination, or -1 if the destination is unreachable. if start == end: return 0 rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(start[0], start[1], 0)]) # The queue will store (row, col, steps) visited = set() visited.add(start) while queue: row, col, steps = queue.popleft() for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < rows and 0 <= new_col < cols and (new_row, new_col) not in visited: if grid[new_row][new_col] == 0: if (new_row, new_col) == end: return steps + 1 queue.append((new_row, new_col, steps + 1)) visited.add((new_row, new_col)) return -1"},{"question":"You are given a dictionary representing a directed graph. Each key in the dictionary is a node, and its value is a list of nodes that are directly reachable from it. Your task is to implement a function `is_cyclic(graph: dict) -> bool` that determines if the graph contains a cycle. # Function Signature ```python def is_cyclic(graph: dict) -> bool: pass ``` # Input * `graph`: A dictionary where the keys are nodes and the values are lists of nodes representing directed edges. # Output * A boolean value `True` if the graph contains a cycle, `False` otherwise. # Constraints * The graph dictionary might be empty, in which case, the function should return `False`. * The graph does not need to be connected. * The nodes are represented by integers or strings. # Example Example 1 Input: ```python graph = { 0: [1, 2], 1: [2], 2: [0, 3], 3: [3] } ``` Output: `True` Explanation: There is a cycle in the graph: 0 -> 2 -> 0 Example 2 Input: ```python graph = { 0: [1, 2], 1: [2], 2: [3], 3: [] } ``` Output: `False` Explanation: No cycle is present in the graph. Example 3 Input: ```python graph = { \\"A\\": [\\"B\\"], \\"B\\": [\\"C\\"], \\"C\\": [\\"A\\"], \\"D\\": [\\"E\\"], \\"E\\": [] } ``` Output: `True` Explanation: There is a cycle in the graph: A -> B -> C -> A # Additional Notes * Optimize your solution to avoid unnecessary repeated computations. * Utilize appropriate graph traversal algorithms like Depth-First Search (DFS) to detect cycles efficiently. * You may assume all node values in the graph are unique. # Testing Ensure your function passes the provided examples and considers edge cases such as disconnected graphs, graphs with self-loops, and empty graphs.","solution":"def is_cyclic(graph: dict) -> bool: def dfs(node, visited, rec_stack): visited.add(node) rec_stack.add(node) for neighbor in graph.get(node, []): if neighbor not in visited: if dfs(neighbor, visited, rec_stack): return True elif neighbor in rec_stack: return True rec_stack.remove(node) return False visited = set() rec_stack = set() for node in graph: if node not in visited: if dfs(node, visited, rec_stack): return True return False"},{"question":"# Scenario A programmer is developing an application that needs to sort a list of student records based on their grades. Each student record contains the student\'s name and their grade. The programmer wants to implement a custom sort function that sorts the records primarily by grade in descending order, and in case of ties, by name in ascending order. # Task Write a Python function `sort_students(records: List[Tuple[str, int]]) -> List[Tuple[str, int]]` that sorts a list of student records based on the given criteria. # Requirements - The function should sort the records by grade in descending order. - If two students have the same grade, their records should be sorted by name in ascending order. - Ensure the function is efficient and handles different edge cases appropriately. # Input and Output - **Input**: A list of tuples, where each tuple contains a student\'s name (string) and grade (integer) - **Output**: A list of tuples sorted as per the given requirements # Constraints - The list of records will have a length between 0 and 1000 - Student names will have a length between 1 and 50 characters - Grades will be integers in the range [0, 100] # Examples ```python >>> sort_students([(\'Alice\', 90), (\'Bob\', 85), (\'Charlie\', 90), (\'Dave\', 95)]) [(\'Dave\', 95), (\'Alice\', 90), (\'Charlie\', 90), (\'Bob\', 85)] >>> sort_students([(\'Bob\', 75), (\'Alice\', 75)]) [(\'Alice\', 75), (\'Bob\', 75)] >>> sort_students([(\'Eve\', 100), (\'Mallory\', 80), (\'Oscar\', 90)]) [(\'Eve\', 100), (\'Oscar\', 90), (\'Mallory\', 80)] ``` # Notes - The approach should leverage Python\'s built-in sorting functions with custom keys. - Consider edge cases such as an empty list or records with all students having the same grade. Create a Python function `sort_students` following the described specifications.","solution":"from typing import List, Tuple def sort_students(records: List[Tuple[str, int]]) -> List[Tuple[str, int]]: Sorts a list of student records primarily by grade in descending order, and by name in ascending order in case of ties. :param records: List of tuples where each tuple contains a student\'s name (str) and grade (int) :return: Sorted list of records according to the specified criteria # Sorting by grade in descending order and then by name in ascending order return sorted(records, key=lambda record: (-record[1], record[0]))"},{"question":"# Problem Statement A Demlo number is a number of the form ( n times 10^n + (n-1) times 10^{n-1} + ldots + 1 ). These are also known as rep-tend numbers or triangle numbers in decimal system. For example: - For ( n = 1 ): 1 - For ( n = 2 ): 12 - For ( n = 3 ): 123 - For ( n = 4 ): 1234 Write a function that generates the Demlo number for a given ( n ). # Requirements 1. Implement a function to generate the Demlo number for a given ( n ). # Input - An integer ( n ), specifying the number of digits in the Demlo number. # Output - A string representing the Demlo number. # Example ```python def demlo_number(n: int) -> str: Returns the Demlo number for the given n. # Example usage: print(demlo_number(1)) # Expected output: \\"1\\" print(demlo_number(2)) # Expected output: \\"12\\" print(demlo_number(3)) # Expected output: \\"123\\" ``` # Constraints - ( 1 leq n leq 500 ) You are required to handle edge cases and ensure the function is efficient for large values of ( n ). # Hints - Use string manipulation to concatenate the necessary digits. - Ensure to convert integers to strings during the concatenation process.","solution":"def demlo_number(n: int) -> str: Returns the Demlo number for the given n. # Generates a concatenated string of numbers from 1 to n. return \'\'.join(str(i) for i in range(1, n + 1))"},{"question":"# Compact Matrix Representation Write a class `CompactMatrix` that efficiently represents a sparse matrix (a matrix with many zero elements). The class should provide methods to add elements to the matrix, retrieve elements, and display the matrix. Class Signature ```python class CompactMatrix: def __init__(self, rows: int, cols: int): Initializes a sparse matrix with the given dimensions. def add_element(self, row: int, col: int, value: int) -> None: Adds or updates an element at the given row and column with the provided value. def get_element(self, row: int, col: int) -> int: Retrieves the element at the specified row and column. Returns 0 if the element is not set. def display(self) -> str: Returns a string representation of the matrix. ``` Input * For the `__init__` method: * An integer `rows` representing the number of rows. * An integer `cols` representing the number of columns. * For the `add_element` method: * An integer `row` indicating the row index where the element is to be added. * An integer `col` indicating the column index where the element is to be added. * An integer `value` representing the value to be added to the specified position in the matrix. * For the `get_element` method: * An integer `row` indicating the row index of the element to retrieve. * An integer `col` indicating the column index of the element to retrieve. Output * For the `add_element` method: * There is no return value. It updates the matrix in place. * For the `get_element` method: * Returns the value at the specified position or `0` if the position has not been set. * For the `display` method: * Returns a string representation of the matrix where rows are separated by newlines and columns by spaces. Constraints * The number of rows and columns will be between 1 and 1000. * The row and column indices provided to `add_element` and `get_element` will be within the matrix dimensions. * The value to be added can be any integer. Example ```python matrix = CompactMatrix(3, 3) matrix.add_element(0, 1, 5) matrix.add_element(2, 2, 10) assert matrix.get_element(0, 1) == 5 assert matrix.get_element(1, 1) == 0 assert matrix.get_element(2, 2) == 10 # Displaying the matrix should return a string representation expected_output = \\"0 5 0n0 0 0n0 0 10\\" assert matrix.display() == expected_output ``` **Note**: The `CompactMatrix` class should only store non-zero elements internally to save memory, and efficiently retrieve and display the matrix elements.","solution":"class CompactMatrix: def __init__(self, rows: int, cols: int): Initializes a sparse matrix with the given dimensions. self.rows = rows self.cols = cols self.matrix = {} # Use a dictionary to store non-zero elements def add_element(self, row: int, col: int, value: int) -> None: Adds or updates an element at the given row and column with the provided value. if value != 0: self.matrix[(row, col)] = value elif (row, col) in self.matrix: del self.matrix[(row, col)] def get_element(self, row: int, col: int) -> int: Retrieves the element at the specified row and column. Returns 0 if the element is not set. return self.matrix.get((row, col), 0) def display(self) -> str: Returns a string representation of the matrix. matrix_str = [] for i in range(self.rows): row_str = [] for j in range(self.cols): row_str.append(str(self.get_element(i, j))) matrix_str.append(\\" \\".join(row_str)) return \\"n\\".join(matrix_str)"},{"question":"# Scenario: You are working on a utility that needs to standardize user input for dates. Given the date in the format `day-month-year`, you need to convert it to `year-month-day` for consistency and further processing. # Task: Write a function `standardize_date_format` that takes a string representing a date in `day-month-year` format and returns a string representing the date in `year-month-day` format. # Expected Function: ```python def standardize_date_format(date: str) -> str: ``` # Input Format: * A string `date` in the format `DD-MM-YYYY` where: - `DD` is a two-digit day (`01` to `31`) - `MM` is a two-digit month (`01` to `12`) - `YYYY` is a four-digit year (`0000` to `9999`) # Output Format: * A string representing the date in `YYYY-MM-DD` format. # Constraints: * You can assume that the input dates are valid and within the format specified. * The function should handle leading zeros in day and month correctly. # Example: ```python >>> standardize_date_format(\\"25-12-2022\\") \'2022-12-25\' >>> standardize_date_format(\\"01-01-2000\\") \'2000-01-01\' >>> standardize_date_format(\\"15-05-1995\\") \'1995-05-15\' ``` # Notes: 1. Your implementation should be able to convert dates efficiently. 2. Edge cases such as leading zeros must be handled correctly to ensure the proper format.","solution":"def standardize_date_format(date: str) -> str: Converts a date from \'day-month-year\' format to \'year-month-day\' format. Parameters: date (str): A string representing the date in \'DD-MM-YYYY\' format. Returns: str: A string representing the date in \'YYYY-MM-DD\' format. day, month, year = date.split(\'-\') return f\\"{year}-{month}-{day}\\""},{"question":"# Coding Challenge: Reverse Words in a String Background Given a string `s`, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order. A word is defined as a sequence of non-space characters. Task Write a function `reverse_words(s: str) -> str` that reverses the characters in each word of the input string while preserving the word order and whitespace. Input - A single string `s` (1 <= len(s) <= 10^5) containing alphabetic characters and spaces. Output - A string with the characters in each word reversed but the word order preserved. Examples ```python assert reverse_words(\\"The quick brown fox\\") == \\"ehT kciuq nworb xof\\" assert reverse_words(\\"Hello World\\") == \\"olleH dlroW\\" assert reverse_words(\\" a b \\") == \\" a b \\" assert reverse_words(\\"Python is fun\\") == \\"nohtyP si nuf\\" ``` Constraints - The input string will always be non-empty and consist of alphabetic characters and spaces. - Your solution should maintain the original word order and whitespace. - Pay attention to space handling in the input string. --- By adhering to the given guidelines, this additional question fits well into the existing set with a comparable style, length, complexity, and scope. The question is unique in its problem statement but remains aligned with the core programming concepts being assessed.","solution":"def reverse_words(s: str) -> str: Reverse the characters in each word of the input string while preserving the word order and whitespace. Arguments: s -- input string containing words and spaces Returns: A string with the characters in each word reversed but the word order preserved return \' \'.join(word[::-1] for word in s.split(\' \'))"},{"question":"# Task: Implement a Robust XOR Function Your task is to implement a robust XOR gate function that incorporates enhanced input validation and the ability to handle both individual and list inputs. Ensure your implementation is efficient and handles edge cases gracefully. Specifically: 1. **Input Validation**: Ensure that the inputs are either 0 or 1. In case of any invalid input, raise a ValueError with the message \\"Invalid input: Input must be 0 or 1\\". 2. **List Support**: Extend the function to support lists of binary values. When the inputs are lists and have the same length, the function should return a new list where each element is the XOR result of the corresponding elements from both input lists. If the input lists are of different lengths, raise a ValueError with the message \\"List inputs must have the same length\\". # Function Signature ```python def robust_xor_gate(input_1, input_2): Calculate XOR of the input values, with enhanced features and error handling. :param input_1: int or list of int (0 or 1) :param input_2: int or list of int (0 or 1) :return: int or list of int: XOR result of input values >>> robust_xor_gate(0, 1) 1 >>> robust_xor_gate(1, 1) 0 >>> robust_xor_gate([1, 0, 0], [0, 1, 1]) [1, 1, 1] >>> robust_xor_gate([0, 1], [1, 0, 1]) Traceback (most recent call last): ... ValueError: List inputs must have the same length >>> robust_xor_gate(1, 2) Traceback (most recent call last): ... ValueError: Invalid input: Input must be 0 or 1 # Your implementation here ``` # Constraints 1. The inputs can either be integers (0 or 1) or lists of integers (only containing 0 or 1). 2. For list inputs, both lists must have the same length. 3. The function should raise appropriate ValueError for invalid inputs. # Example Usages - `robust_xor_gate(0, 1)` should return `1`. - `robust_xor_gate([1, 0, 0], [0, 1, 1])` should return `[1, 1, 1]`. - `robust_xor_gate([1], [0])` should return `[1]`. - `robust_xor_gate([1, 0], [1, 2])` should raise `ValueError: Invalid input: Input must be 0 or 1`. - `robust_xor_gate([1, 0], [1])` should raise `ValueError: List inputs must have the same length`.","solution":"def robust_xor_gate(input_1, input_2): Calculate XOR of the input values, with enhanced features and error handling. :param input_1: int or list of int (0 or 1) :param input_2: int or list of int (0 or 1) :return: int or list of int: XOR result of input values >>> robust_xor_gate(0, 1) 1 >>> robust_xor_gate(1, 1) 0 >>> robust_xor_gate([1, 0, 0], [0, 1, 1]) [1, 1, 1] >>> robust_xor_gate([0, 1], [1, 0, 1]) Traceback (most recent call last): ... ValueError: List inputs must have the same length >>> robust_xor_gate(1, 2) Traceback (most recent call last): ... ValueError: Invalid input: Input must be 0 or 1 def validate_input(val): if isinstance(val, int): if val not in (0, 1): raise ValueError(\\"Invalid input: Input must be 0 or 1\\") elif isinstance(val, list): if not all(isinstance(i, int) and i in (0, 1) for i in val): raise ValueError(\\"Invalid input: Input must be 0 or 1\\") else: raise ValueError(\\"Invalid input: Input must be 0 or 1\\") validate_input(input_1) validate_input(input_2) if isinstance(input_1, list) and isinstance(input_2, list): if len(input_1) != len(input_2): raise ValueError(\\"List inputs must have the same length\\") return [a ^ b for a, b in zip(input_1, input_2)] elif isinstance(input_1, int) and isinstance(input_2, int): return input_1 ^ input_2 else: raise ValueError(\\"Both inputs must be of same type, either int or list\\")"},{"question":"Archangel\'s Palindrome Number Finder **Objective**: Write a function that finds the next palindrome number greater than a given integer. Context A palindrome number is a number that remains the same when its digits are reversed. For example, 121 is a palindrome number, as is 12321. However, 123 is not a palindrome, as its reverse is 321. Your task is to implement an algorithm that, given an integer input, finds the smallest palindrome number that is greater than the input. Function Signature ```python def next_palindrome(n: int) -> int: Finds the next palindrome number greater than the given integer. Parameters: n (int): The input integer. Must be non-negative. Returns: int: The smallest palindrome number greater than n. Raises: ValueError: If n is negative. pass ``` Expected Input and Output 1. **Input**: - An integer `n` (non-negative). 2. **Output**: - An integer representing the smallest palindrome number greater than `n`. Constraints - ( 0 leq n leq 10^9 ) Performance Requirements - **Time Complexity**: O(d) where d is the number of digits in the number. - **Space Complexity**: O(d) Example * **Example 1**: ```python >>> next_palindrome(123) 131 ``` * **Example 2**: ```python >>> next_palindrome(999) 1001 ``` * **Example 3**: ```python >>> next_palindrome(12921) 13031 ``` * **Edge Case**: ```python >>> next_palindrome(1000000000) 1000000001 ``` **Note**: You must handle invalid inputs by raising an appropriate exception.","solution":"def next_palindrome(n: int) -> int: Finds the next palindrome number greater than the given integer. Parameters: n (int): The input integer. Must be non-negative. Returns: int: The smallest palindrome number greater than n. Raises: ValueError: If n is negative. if n < 0: raise ValueError(\\"Input must be non-negative\\") def is_palindrome(x: int) -> bool: Check if a number is a palindrome. return str(x) == str(x)[::-1] current_number = n + 1 while not is_palindrome(current_number): current_number += 1 return current_number"},{"question":"# Coding Assessment Question Problem Statement You are given the task of implementing a function to detect and return cycles in an undirected graph. A cycle is a path of edges and vertices in which the starting vertex is also the ending vertex, and it contains at least one other vertex. You need to implement the function `find_cycles` that identifies all unique cycles in the graph. The graph is represented as an adjacency list. Function Signature ```python def find_cycles(graph: dict[int, list[int]]) -> list[list[int]]: pass ``` Input - `graph (dict[int, list[int]])`: A dictionary representing the undirected graph, where keys are vertex IDs and values are lists of adjacent vertices. Output - Returns a list of lists, with each sublist representing a cycle found in the graph. Each cycle is a list of vertex IDs, and cycles must be sorted in ascending order. - The cycles themselves should also be sorted in ascending order based on the first vertex of each cycle. Constraints - The number of vertices will be at least 2 and up to 10^3. - The number of edges will be at least 1 and up to 10^4. - There are no self-loops or duplicate edges in the graph. Requirements - The solution should efficiently handle large graphs within the given constraints. - Ensure that the output does not contain duplicate cycles, even if they are found through different paths. Example ```python graph = { 1: [2, 3], 2: [1, 3, 4], 3: [1, 2, 4], 4: [2, 3, 5], 5: [4] } result = find_cycles(graph) print(result) ``` Expected Output: ``` [[1, 2, 3], [2, 3, 4]] ``` --- Notes 1. Use Depth-First Search (DFS) or other appropriate algorithms to detect cycles in the graph. 2. Make sure to consider cycles of varying lengths. 3. Handle cases where the graph has no cycles. 4. Ensure that each cycle in the output is unique and sorted as specified. ---","solution":"def find_cycles(graph): def dfs(node, visited, parent, path): visited[node] = True path.append(node) cycle_found = [] for neighbor in graph[node]: if not visited[neighbor]: result = dfs(neighbor, visited, node, path) if result: cycle_found.extend(result) elif neighbor != parent and neighbor in path: cycle = sorted(path[path.index(neighbor):]) if cycle not in cycle_found: cycle_found.append(cycle) path.pop() return cycle_found all_cycles = set() visited = {node: False for node in graph} for node in graph: if not visited[node]: cycles = dfs(node, visited, -1, []) for cycle in cycles: all_cycles.add(tuple(cycle)) all_cycles = [list(cycle) for cycle in all_cycles] all_cycles.sort() return all_cycles"},{"question":"# Question You are tasked with implementing a function that finds the smallest positive integer that is evenly divisible by all the numbers from 1 to a given limit. # Function Signature ```python def smallest_multiple(limit: int) -> int: # Your code here ``` # Input The function will have a single input: * `limit` (1 <= limit <= 40): An integer indicating the highest number in the range to check for divisibility. # Output The function should return: * An integer representing the smallest positive integer that is evenly divisible by all numbers from 1 to `limit`. # Constraints * The solution should handle all edge cases effectively. * Ensure the performance is viable for the maximum `limit` value (40). # Examples ```python assert smallest_multiple(10) == 2520 assert smallest_multiple(15) == 360360 assert smallest_multiple(20) == 232792560 assert smallest_multiple(1) == 1 assert smallest_multiple(5) == 60 assert smallest_multiple(30) == 2329089562800 ``` # Context This problem involves understanding the least common multiple (LCM) of a range of numbers, which emphasizes proficiency in number theory, understanding of prime factors, and algorithm design to efficiently compute the LCM of a range of integers. Solving this will demonstrate your ability to handle mathematical concepts effectively and write efficient code in Python. # Task Implement the required function based on the problem constraints and examples provided.","solution":"import math def lcm(a, b): return abs(a * b) // math.gcd(a, b) def smallest_multiple(limit: int) -> int: result = 1 for i in range(1, limit + 1): result = lcm(result, i) return result"},{"question":"# Student Grade Calculation and Letter Assignment Objective: Write a Python function to calculate the average grade from a list of student scores and assign a corresponding letter grade. Familiarize yourself with list processing and basic decision-making constructs in Python. Problem Description: Create a function `calculate_final_grades(grades: dict) -> dict` that accepts a dictionary where the keys are student names and the values are lists of numerical scores (integers from 0 to 100). The function should compute the average score for each student, determine their letter grade based on the average, and return a new dictionary with student names as keys and their letter grades as values. Input: - `grades`: A dictionary where each key is a student\'s name (string) and each value is a list of their numerical scores (integers). Output: - A dictionary mapping student names (strings) to their final letter grades (strings). Constraints: - Each student will have at least one score. - Scores are integer values between 0 and 100 inclusive. - Letter grades are assigned based on the following scale: - \'A\': 90 <= average <= 100 - \'B\': 80 <= average < 90 - \'C\': 70 <= average < 80 - \'D\': 60 <= average < 70 - \'F\': average < 60 Requirements: 1. Compute the average grade for each student. 2. Assign the correct letter grade according to the average. 3. Handle the input dictionary gracefully, ensuring all students are processed. Example Usage: ```python grades = { \\"John\\": [88, 92, 76, 81], \\"Jane\\": [100, 96, 94], \\"Dave\\": [59, 62, 70], \\"Anna\\": [73, 75, 77, 78] } final_grades = calculate_final_grades(grades) print(final_grades) ``` Example Output: ```python { \\"John\\": \\"B\\", \\"Jane\\": \\"A\\", \\"Dave\\": \\"D\\", \\"Anna\\": \\"C\\" } ``` Implementation Strategy: 1. For each student in the dictionary, calculate the average of their scores. 2. Use conditional statements to determine the letter grade based on the average. 3. Store the student\'s name and their letter grade in the output dictionary. 4. Return the output dictionary containing the final grades. ```python def calculate_final_grades(grades: dict) -> dict: Calculate the final letter grades for students based on their numerical scores. :param grades: Dictionary of student names and their list of scores. :return: Dictionary of student names and their corresponding letter grades. letter_grades = {} for student, scores in grades.items(): average_score = sum(scores) / len(scores) if average_score >= 90: letter_grades[student] = \'A\' elif average_score >= 80: letter_grades[student] = \'B\' elif average_score >= 70: letter_grades[student] = \'C\' elif average_score >= 60: letter_grades[student] = \'D\' else: letter_grades[student] = \'F\' return letter_grades ``` Implement the function ensuring accuracy in computation and clarity in the verification of each student\'s performance.","solution":"def calculate_final_grades(grades: dict) -> dict: Calculate the final letter grades for students based on their numerical scores. :param grades: Dictionary of student names and their list of scores. :return: Dictionary of student names and their corresponding letter grades. letter_grades = {} for student, scores in grades.items(): average_score = sum(scores) / len(scores) if average_score >= 90: letter_grades[student] = \'A\' elif average_score >= 80: letter_grades[student] = \'B\' elif average_score >= 70: letter_grades[student] = \'C\' elif average_score >= 60: letter_grades[student] = \'D\' else: letter_grades[student] = \'F\' return letter_grades"},{"question":"# Sudoku Solver Implement a Sudoku solver that fills an empty or partially filled Sudoku board. The function should use a backtracking algorithm to ensure that the board respects the Sudoku rules. Every row, column, and 3x3 subgrid must contain distinct numbers from 1 to 9. # Input and Output Input * A 9x9 2D list (or matrix) representing the Sudoku board. The empty cells are represented by zeros (`0`). Output * A boolean indicating whether the Sudoku puzzle can be solved. * The solved 9x9 2D list (if solvable) or the original board (if not solvable). # Constraints * The input is always a 9x9 matrix. * You do not need to handle invalid boards that break Sudoku rules from the start. ```python def is_valid(board, row, col, num): # Check if the number is already in the row for x in range(9): if board[row][x] == num: return False # Check if the number is already in the column for x in range(9): if board[x][col] == num: return False # Check if the number is already in the 3x3 subgrid startRow = row - row % 3 startCol = col - col % 3 for i in range(3): for j in range(3): if board[i + startRow][j + startCol] == num: return False return True def solve_sudoku(board): # Find next empty cell empty_found = False for i in range(9): for j in range(9): if board[i][j] == 0: row = i col = j empty_found = True break if empty_found: break if not empty_found: return True for num in range(1, 10): if is_valid(board, row, col, num): board[row][col] = num if solve_sudoku(board): return True board[row][col] = 0 return False def sudoku_solver(board): solvable = solve_sudoku(board) return solvable, board # Sample Input board = [ [5, 3, 0, 0, 7, 0, 0, 0, 0], [6, 0, 0, 1, 9, 5, 0, 0, 0], [0, 9, 8, 0, 0, 0, 0, 6, 0], [8, 0, 0, 0, 6, 0, 0, 0, 3], [4, 0, 0, 8, 0, 3, 0, 0, 1], [7, 0, 0, 0, 2, 0, 0, 0, 6], [0, 6, 0, 0, 0, 0, 2, 8, 0], [0, 0, 0, 4, 1, 9, 0, 0, 5], [0, 0, 0, 0, 8, 0, 0, 7, 9] ] # Call the function solvable, solved_board = sudoku_solver(board) if solvable: print(\\"Sudoku solved successfully!\\") else: print(\\"Sudoku puzzle is unsolvable.\\") ```","solution":"def is_valid(board, row, col, num): Check if placing the number at the given row and column is valid according to Sudoku rules. # Check if the number is already in the row for x in range(9): if board[row][x] == num: return False # Check if the number is already in the column for x in range(9): if board[x][col] == num: return False # Check if the number is already in the 3x3 subgrid startRow = row - row % 3 startCol = col - col % 3 for i in range(3): for j in range(3): if board[i + startRow][j + startCol] == num: return False return True def solve_sudoku(board): Solve the Sudoku puzzle using backtracking # Find next empty cell empty_found = False for i in range(9): for j in range(9): if board[i][j] == 0: row = i col = j empty_found = True break if empty_found: break if not empty_found: return True for num in range(1, 10): if is_valid(board, row, col, num): board[row][col] = num if solve_sudoku(board): return True board[row][col] = 0 return False def sudoku_solver(board): Solve the given Sudoku puzzle solvable = solve_sudoku(board) return solvable, board"},{"question":"# Inventory Management System Problem Statement You are tasked with creating a simple inventory management system for a bookstore. The store owner needs to keep track of the books available in the store by their titles, authors, and stock quantities. You need to implement a system that allows adding new books, updating stock for existing books, and checking the availability of a specific book. Task Write a class `Bookstore` with the following methods: 1. `add_book(title: str, author: str, quantity: int) -> None`: Adds a new book with the given title, author, and initial stock quantity to the inventory. If the book already exists (based on title and author), just update the quantity. 2. `update_stock(title: str, author: str, quantity: int) -> None`: Updates the stock quantity for a book with the given title and author. If the book does not exist, it should raise an error. 3. `check_stock(title: str, author: str) -> int`: Returns the current stock quantity for the book with the given title and author. If the book does not exist, it should return 0. Input - `title`: A string representing the title of the book. - `author`: A string representing the author of the book. - `quantity`: An integer representing the number of copies available or to be added. Output - Methods `add_book` and `update_stock` do not return any value. - Method `check_stock` returns an integer representing the current stock quantity of the book. Examples ```python store = Bookstore() store.add_book(\\"Harry Potter\\", \\"J.K. Rowling\\", 10) store.add_book(\\"Atomic Habits\\", \\"James Clear\\", 5) store.update_stock(\\"Harry Potter\\", \\"J.K. Rowling\\", 5) # Increases stock by 5 print(store.check_stock(\\"Harry Potter\\", \\"J.K. Rowling\\")) # Output: 15 print(store.check_stock(\\"Atomic Habits\\", \\"James Clear\\")) # Output: 5 print(store.check_stock(\\"The Alchemist\\", \\"Paulo Coelho\\")) # Output: 0 store.update_stock(\\"The Alchemist\\", \\"Paulo Coelho\\", 3) # Raises an error: Book not found ``` Constraints 1. All string inputs (`title` and `author`) will be non-empty strings of length at most 100. 2. `quantity` will be an integer between 1 and 1000. 3. The inventory can contain at most 1000 different books. 4. Book titles and authors are case-sensitive. Notes - Ensure the methods handle cases where books do not exist appropriately. - Manage the inventory efficiently to handle the maximum constraints smoothly.","solution":"class BookNotFoundError(Exception): pass class Bookstore: def __init__(self): self.inventory = {} def add_book(self, title: str, author: str, quantity: int) -> None: key = (title, author) if key in self.inventory: self.inventory[key] += quantity else: self.inventory[key] = quantity def update_stock(self, title: str, author: str, quantity: int) -> None: key = (title, author) if key in self.inventory: self.inventory[key] += quantity else: raise BookNotFoundError(f\\"Book \'{title}\' by \'{author}\' not found.\\") def check_stock(self, title: str, author: str) -> int: key = (title, author) return self.inventory.get(key, 0)"},{"question":"# Question: Reversing a Linked List You are given a singly linked list where each node contains an integer value and a pointer to the next node. The task is to reverse the linked list, such that the last node becomes the first node and now its `next` pointer points to the previous node, and so on. Implement the following Python class and methods: Node Class ```python class ListNode: def __init__(self, value: int = 0, next_node: \'ListNode\' = None): self.value = value self.next = next_node ``` Function: `reverse_linked_list` ```python def reverse_linked_list(head: \'ListNode\') -> \'ListNode\': Reverses the given linked list. Args: head (ListNode): The head node of the singly linked list. Returns: ListNode: The new head node of the reversed linked list. Examples: >>> head = ListNode(1, ListNode(2, ListNode(3, ListNode(4, None)))) >>> new_head = reverse_linked_list(head) >>> [new_head.value, new_head.next.value, new_head.next.next.value, new_head.next.next.next.value] [4, 3, 2, 1] >>> head = ListNode(1, None) >>> new_head = reverse_linked_list(head) >>> new_head.value 1 >>> new_head = reverse_linked_list(None) >>> new_head is None True pass ``` # Constraints * The input linked list may be empty (i.e., the head node can be `None`). * The linked list contains at most 1000 nodes. # Requirements * Implement the reversal in-place without using extra space for a new list. * You may use a few extra variables for pointers. # Explanation * **reverse_linked_list**: Reverses the linked list, updating the `next` pointers of each node to point to the previous node. The function returns the new head node of the reversed list. Ensure your implementation passes the provided examples and handles the constraints appropriately.","solution":"class ListNode: def __init__(self, value: int = 0, next_node: \'ListNode\' = None): self.value = value self.next = next_node def reverse_linked_list(head: \'ListNode\') -> \'ListNode\': Reverses the given linked list. Args: head (ListNode): The head node of the singly linked list. Returns: ListNode: The new head node of the reversed linked list. prev = None current = head while current: next_node = current.next current.next = prev prev = current current = next_node return prev"},{"question":"# Largest Even Number Finder Your task is to write a function that finds the largest even number in a list of integers. Function Signature ```python def largest_even_number(numbers: list) -> int: ``` Input - A single list `numbers` containing `n` integers, where 0 ≤ `n` ≤ 10^3. Each integer can have values in the range of -10^6 to 10^6. Output - An integer representing the largest even number in the list. If there are no even numbers, return `None`. Constraints - The function should be efficient with a time complexity of O(n). Examples ```python - Input: [3, 1, 4, 1, 5, 9, 2, 6, 5] Output: 6 - Input: [7, 3, 1, 9] Output: None - Input: [0, 2, 4, 8, 16, 32] Output: 32 - Input: [-5, -3, -5, -1] Output: None - Input: [-6, -2, -4, -8, -10, 1] Output: -2 ``` Additional requirements - The algorithm should be straightforward and implementable without the use of external libraries. - Ensure the function passes all given example cases, including handling lists with all odd numbers effectively and returning `None` when appropriate. Write your code to implement the function based on the described behavior and constraints.","solution":"def largest_even_number(numbers: list) -> int: Returns the largest even number from the list of numbers. If there are no even numbers, returns None. # Filter out the even numbers from the list even_numbers = [num for num in numbers if num % 2 == 0] # Return the maximum of the even numbers if the list isn\'t empty if even_numbers: return max(even_numbers) else: return None"},{"question":"# Coding Assessment Question: Background In combinatorial mathematics, a Permutation is an arrangement of all the members of a set into some sequence or order. Given a list of distinct integers, each permutation of the list is unique. Task Implement a function `next_permutation(nums)` that takes a list of integers `nums` and rearranges it into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it to the lowest possible order (i.e., sorted in ascending order). - **Input**: A list of distinct integers `nums` (1 ≤ len(nums) ≤ 1000). - **Output**: Modify the list `nums` in place to the next permutation. You do not need to return anything. - **Constraints**: The function should handle the rearrangement efficiently. - **Performance**: Optimize your implementation to handle the upper limits of the input size gracefully. Function Signature ```python def next_permutation(nums: list[int]) -> None: pass ``` Examples ```python example_list = [1, 2, 3] next_permutation(example_list) assert example_list == [1, 3, 2] example_list = [3, 2, 1] next_permutation(example_list) assert example_list == [1, 2, 3] example_list = [1, 1, 5] next_permutation(example_list) assert example_list == [1, 5, 1] ``` Additional Notes - You are required to implement the function in such a way that it modifies `nums` in place. - The list `nums` contains only distinct integers, and the size of the list will always be at least 1 and at most 1000.","solution":"def next_permutation(nums: list[int]) -> None: Rearrange numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, rearrange it to the lowest possible order. # Step 1: Find the first decreasing element from the right i = len(nums) - 2 while i >= 0 and nums[i] >= nums[i + 1]: i -= 1 # Step 2: If we found a number at i which is less than its next number, then we need to swap if i >= 0: j = len(nums) - 1 while nums[j] <= nums[i]: j -= 1 nums[i], nums[j] = nums[j], nums[i] # Step 3: Reverse the numbers after the i-th position to get the next smallest lexicographical arrangement left, right = i + 1, len(nums) - 1 while left < right: nums[left], nums[right] = nums[right], nums[left] left += 1 right -= 1"},{"question":"# Coding Assessment Question Problem Statement You are given a singly linked list and an integer `x`. Implement a function that partitions the linked list around the value `x`, such that all nodes less than `x` come before nodes greater than or equal to `x`. The relative order of the nodes in each of the two partitions should be preserved. Function Signature ```python class LinkedList: def partition(self, x: int) -> None: Partition linked list based on value x. :param x: The partitioning value. ``` Input Format * A linked list of integers. * An integer `x`. Output Format * The linked list partitioned around value `x`. Example ```python ll = LinkedList([1, 4, 3, 2, 5, 2]) ll.partition(3) print(list(ll)) # Output: [1, 2, 2, 4, 3, 5] ``` Constraints * The linked list can have up to 10^5 nodes. * The values in the linked list nodes are integers and can be positive or negative. * The input linked list will always have at least one node, and \'x\' will be an integer present in the list. Implementation Notes * Make sure to handle edge cases, such as when the list is empty or when all nodes have the same value. * Ensure the function runs efficiently even for long lists. * The linked list should be modified in place.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next class LinkedList: def __init__(self, values=None): self.head = None if values: self.head = ListNode(values[0]) current = self.head for value in values[1:]: current.next = ListNode(value) current = current.next def __iter__(self): current = self.head while current: yield current.value current = current.next def partition(self, x): left_dummy = ListNode(0) # Starting point of the less than x list right_dummy = ListNode(0) # Starting point of the greater/equal to x list left = left_dummy # Pointer to form the list of nodes less than x right = right_dummy # Pointer to form the list of nodes greater/equal to x current = self.head while current: if current.value < x: left.next = current left = left.next else: right.next = current right = right.next current = current.next right.next = None # End the list greater/equal to x left.next = right_dummy.next # Combine the two lists self.head = left_dummy.next # Head of the modified list"},{"question":"# Coding Assessment Question: Scenario: You are developing a system for generating personalized book recommendations based on the books a user has already read. To avoid suggesting redundant recommendations, the system should be able to determine the longest sequence of distinct books read by a user. Your task is to implement a function that finds the length of the longest subsequence of distinct books within a given list of books read by a user. # Function Signature: ```python def longest_distinct_books_sequence(books: List[str]) -> int: pass ``` # Input: * `books` (List[str]): A list of strings where each string represents a book that the user has read. # Output: * An integer representing the length of the longest subsequence of distinct books. # Example: ```python assert longest_distinct_books_sequence([\\"book1\\", \\"book2\\", \\"book1\\", \\"book3\\", \\"book4\\", \\"book2\\"]) == 4 assert longest_distinct_books_sequence([\\"book1\\", \\"book1\\", \\"book1\\"]) == 1 assert longest_distinct_books_sequence([]) == 0 assert longest_distinct_books_sequence([\\"book1\\", \\"book2\\", \\"book3\\", \\"book4\\", \\"book5\\"]) == 5 ``` # Constraints: * Each book title is a string of length between 1 and 100. * The length of the list `books` does not exceed 10^5. # Performance Requirements: * Ensure your solution efficiently handles lists with up to 100,000 book titles. Implementation: Write the function `longest_distinct_books_sequence` that finds the length of the longest subsequence of distinct books from the given list of books read by a user.","solution":"from typing import List def longest_distinct_books_sequence(books: List[str]) -> int: Finds the length of the longest subsequence of distinct books within a given list of books read by the user. :param books: List of strings representing books read by the user. :return: Integer representing the length of the longest subsequence of distinct books. if not books: return 0 book_set = set() left = 0 max_len = 0 for right in range(len(books)): while books[right] in book_set: book_set.remove(books[left]) left += 1 book_set.add(books[right]) max_len = max(max_len, right - left + 1) return max_len"},{"question":"# Question: Implement a Tail-Recursive List Flattener You are required to implement a tail-recursive function to flatten a nested list of integers. A nested list may contain integers or other nested lists, and the function should return a single flat list of integers. Most implementations use regular recursion, which can lead to stack overflow with deeply nested lists. Instead, you will implement the function using tail recursion to optimize performance and avoid stack overflow issues. # Requirements: 1. Implement the function `flatten_list(nested_list: list) -> list` using tail recursion: * **`nested_list` (list)**: The nested list to be flattened. 2. The function should return a new list that contains all integers from the nested list in the same order as they appear. 3. Ensure the use of tail recursion to handle deeply nested lists efficiently. # Example: ```python flatten_list([1, [2, [3, [4, 5]], 6], 7]) ``` This should return the flat list `[1, 2, 3, 4, 5, 6, 7]`. # Constraints: * The nested list can contain only integers and nested lists. * The depth of nesting can be significant, but you should be able to handle at least 100 levels efficiently. # Performance Requirements: * The tail-recursive solution should avoid stack overflow for deeply nested lists and be as performant as possible. # Helper Function: You may use a helper function to implement the tail-recursive behavior.","solution":"def flatten_list(nested_list): def _flatten_helper(nested_list, accumulator): Tail-recursive helper function to flatten the list. if not nested_list: return accumulator head, *tail = nested_list if isinstance(head, list): return _flatten_helper(head + tail, accumulator) else: return _flatten_helper(tail, accumulator + [head]) return _flatten_helper(nested_list, [])"},{"question":"# Coding Question - Implement a Min Heap using an Array Context You are required to implement a Min Heap data structure using an array. A Min Heap is a binary tree where the value of each node is greater than or equal to the value of its parent, ensuring the smallest value is always at the root. This structure is useful for efficiently finding and extracting the minimum element. Task Implement a `MinHeap` class in Python with the following methods: 1. **`__init__(self, capacity: int) -> None`**: Initializes the Min Heap with a given capacity. 2. **`is_full(self) -> bool`**: Returns `True` if the Min Heap is full, otherwise `False`. 3. **`is_empty(self) -> bool`**: Returns `True` if the Min Heap is empty, otherwise `False`. 4. **`insert(self, item: int) -> None`**: Inserts an item into the Min Heap. If the heap is full, raise an `OverflowError`. 5. **`extract_min(self) -> int`**: Removes and returns the minimum element from the Min Heap. If the heap is empty, raise an `IndexError`. 6. **`peek_min(self) -> int`**: Returns the minimum element from the Min Heap without removing it. If the heap is empty, raise an `IndexError`. 7. **`__str__(self) -> str`**: Returns a string representation of the heap, where elements are space-separated. Input and Output Formats: - The constructor initialization will have an integer parameter `capacity`. - `insert` method will have an integer item as an input. - `extract_min` and `peek_min` methods will return an integer. - `is_empty` and `is_full` will return boolean values. - `__str__` will return a string of space-separated integers representing the heap. Example: ```python mh = MinHeap(5) print(mh.is_empty()) # True mh.insert(10) mh.insert(5) mh.insert(30) print(str(mh)) # \\"5 10 30\\" print(len(mh)) # 3 print(mh.extract_min()) # 5 print(str(mh)) # \\"10 30\\" mh.insert(2) mh.insert(8) print(str(mh)) # \\"2 10 30 8\\" print(mh.peek_min()) # 2 print(mh.is_full()) # False mh.insert(1) print(mh.is_full()) # True print(mh.extract_min()) # 1 print(str(mh)) # \\"2 10 30 8\\" print(mh.is_empty()) # False ``` Constraints: - Capacity will be a positive integer (1 <= capacity <= 10^5). - Input values for insertion will be positive integers. Performance Requirements: - All operations (insert, extract_min, peek_min) must have a time complexity of O(log n).","solution":"class MinHeap: def __init__(self, capacity: int) -> None: self.capacity = capacity self.size = 0 self.heap = [0] * capacity def is_full(self) -> bool: return self.size == self.capacity def is_empty(self) -> bool: return self.size == 0 def insert(self, item: int) -> None: if self.is_full(): raise OverflowError(\\"Heap is full\\") self.heap[self.size] = item self.size += 1 self._heapify_up(self.size - 1) def extract_min(self) -> int: if self.is_empty(): raise IndexError(\\"Heap is empty\\") min_item = self.heap[0] self.heap[0] = self.heap[self.size - 1] self.size -= 1 self._heapify_down(0) return min_item def peek_min(self) -> int: if self.is_empty(): raise IndexError(\\"Heap is empty\\") return self.heap[0] def __str__(self) -> str: return \' \'.join(map(str, self.heap[:self.size])) def _heapify_up(self, index): parent_index = (index - 1) // 2 if index > 0 and self.heap[index] < self.heap[parent_index]: self.heap[index], self.heap[parent_index] = self.heap[parent_index], self.heap[index] self._heapify_up(parent_index) def _heapify_down(self, index): smallest = index left_child = 2 * index + 1 right_child = 2 * index + 2 if left_child < self.size and self.heap[left_child] < self.heap[smallest]: smallest = left_child if right_child < self.size and self.heap[right_child] < self.heap[smallest]: smallest = right_child if smallest != index: self.heap[index], self.heap[smallest] = self.heap[smallest], self.heap[index] self._heapify_down(smallest)"},{"question":"# Reverse a Singly Linked List You are working with a singly linked list, a common data structure consisting of nodes, where each node contains a value and a reference to the next node in the sequence. You need to reverse the linked list, meaning the last node should become the first, the second last node should become the second, and so on. Problem Statement Implement the function `reverse_linked_list(head: Optional[ListNode]) -> Optional[ListNode]`. This function should accept the head of a singly linked list and return the new head after reversing the list. # Input - `head` (Optional[ListNode]): The head node of a singly linked list. Each node is of type `ListNode` which holds an integer value and a reference to the next node. # Output - The new head of the reversed singly linked list. # Constraints - The number of nodes in the linked list will be in the range `[0, 5000]`. - Each node\'s value will be an integer in the range `[-10^4, 10^4]`. # Performance Requirements - The algorithm should run in O(n) time complexity, where `n` is the number of nodes in the linked list. - The algorithm should utilize O(1) additional space (i.e., it should reverse the list in-place). # Example ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next # Example 1 # Input: 1 -> 2 -> 3 -> 4 -> 5 -> None # Output: 5 -> 4 -> 3 -> 2 -> 1 -> None head = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))) new_head = reverse_linked_list(head) # The new_head node should represent the reversed linked list: 5 -> 4 -> 3 -> 2 -> 1 -> None # Example 2 # Input: None # Output: None head = None new_head = reverse_linked_list(head) # The new_head node should be None as there is no input node. ``` Your task is to implement the function `reverse_linked_list` that correctly reverses the singly linked list as per the examples and constraints provided.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_linked_list(head): Reverses a singly linked list. Args: head (Optional[ListNode]): The head of the singly linked list. Returns: Optional[ListNode]: The new head of the reversed singly linked list. prev = None current = head while current: next_node = current.next current.next = prev prev = current current = next_node return prev"},{"question":"# Scenario You are working on a project that involves manipulating lists of numbers and generating sequences based on some specific rules. One of the tasks requires creating a sequence where each element is the sum of digits of the previous element in the list, starting from a given integer. # Problem Write a function `digit_sum_sequence(start: int, length: int) -> list[int]` that takes an integer `start` and an integer `length` and returns a list containing the generated sequence. The sequence starts with `start`, and each subsequent number is the sum of the digits of the previous number. # Input * `start` (int): The starting number of the sequence. Must be a non-negative integer. * `length` (int): The number of elements in the sequence. Must be a positive integer. # Output * `list[int]`: A list containing the generated sequence. # Constraints 1. `start` must be a non-negative integer. 2. `length` must be a positive integer. 3. If `length` is not a positive integer, the function should raise a `ValueError` with the message \\"Length must be a positive integer.\\" # Examples 1. `digit_sum_sequence(123, 5)` should return `[123, 6, 6, 6, 6]`. 2. `digit_sum_sequence(9876, 4)` should return `[9876, 30, 3, 3]`. 3. `digit_sum_sequence(0, 3)` should return `[0, 0, 0]`. 4. `digit_sum_sequence(56, 0)` should raise a `ValueError`. # Implementation Implement your solution based on the analysis above: ```python def digit_sum_sequence(start: int, length: int) -> list[int]: :param start: starting number of the sequence :type start: int :param length: total number of elements in the sequence :type length: int :return: A list representing the digit sum sequence Tests: >>> digit_sum_sequence(123, 5) [123, 6, 6, 6, 6] >>> digit_sum_sequence(9876, 4) [9876, 30, 3, 3] >>> digit_sum_sequence(0, 3) [0, 0, 0] >>> digit_sum_sequence(56, 0) Traceback (most recent call last): ... ValueError: Length must be a positive integer. if length <= 0 or not isinstance(length, int): raise ValueError(\\"Length must be a positive integer.\\") if start < 0 or not isinstance(start, int): raise ValueError(\\"Start must be a non-negative integer.\\") sequence = [start] for _ in range(1, length): next_num = sum(int(digit) for digit in str(sequence[-1])) sequence.append(next_num) return sequence if __name__ == \\"__main__\\": import doctest doctest.testmod() ```","solution":"def digit_sum_sequence(start: int, length: int) -> list[int]: Generates a sequence where each element is the sum of digits of the previous element in the list. :param start: starting number of the sequence :type start: int :param length: total number of elements in the sequence, must be a positive integer :type length: int :return: A list representing the digit sum sequence :rtype: list[int] Raises: ValueError: If length is not a positive integer or if start is not a non-negative integer. if length <= 0: raise ValueError(\\"Length must be a positive integer.\\") if start < 0: raise ValueError(\\"Start must be a non-negative integer.\\") sequence = [start] for _ in range(1, length): next_num = sum(int(digit) for digit in str(sequence[-1])) sequence.append(next_num) return sequence"},{"question":"# Context: You are given a collection of letters where some pairs of letters are known to be adjacent in a sorted order represented by a directed graph. Your task is to determine the relative order of these letters. # Task: Implement a function `find_letter_order(pairs: List[Tuple[str, str]]) -> str` that determines the order of letters based on the given adjacent pairs using Topological Sort. # Specifications: - **Input**: A list of tuples `pairs`, where each tuple `(a, b)` means letter `a` is followed by letter `b` in the sorted order. - **Output**: A string representing the relative order of the letters. - **Constraints**: - The input pairs form a Directed Acyclic Graph (DAG). - All letters are lowercase English letters. - The result will be a single unique string that represents the valid order of letters. # Implementation: - **Function**: ```python def find_letter_order(pairs: List[Tuple[str, str]]) -> str: pass ``` - Ensure your solution is efficient in both time and space. - Handle edge cases such as isolated letters and multiple independent subgraphs. # Example: Input: ```python pairs = [(\'w\', \'e\'), (\'e\', \'r\'), (\'r\', \'t\')] ``` In this example, the pairs represent the following constraints: - \'w\' is followed by \'e\' - \'e\' is followed by \'r\' - \'r\' is followed by \'t\' Output: ```python \\"wert\\" ``` This is the only valid order of letters that satisfies all the given constraints.","solution":"from typing import List, Tuple from collections import defaultdict, deque def find_letter_order(pairs: List[Tuple[str, str]]) -> str: # Build the graph and indegree count graph = defaultdict(list) indegree = defaultdict(int) all_letters = set() for a, b in pairs: graph[a].append(b) indegree[b] += 1 all_letters.update([a, b]) # Initialize the queue with nodes that have 0 indegree queue = deque() for letter in all_letters: if indegree[letter] == 0: queue.append(letter) # Perform topological sort order = [] while queue: current = queue.popleft() order.append(current) for neighbor in graph[current]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) # If the order contains all the letters, return it as a string if len(order) == len(all_letters): return \'\'.join(order) else: # There was a cycle or some other issue return \\"\\""},{"question":"# Coding Assessment Question: Maximum Subarray Sum Less Than or Equal to a Given Value Problem Statement: You are given an integer array `arr` and an integer `limit`. Your task is to find the maximum possible sum of a contiguous subarray such that the sum is less than or equal to `limit`. If no such subarray exists, return 0. Implement a function that computes this value. Function Signature: ```python def max_subarray_sum_with_limit(arr: List[int], limit: int) -> int: Find the maximum subarray sum such that the sum does not exceed the given limit. ``` Constraints: 1. The `arr` array will contain at least one element and contains at most `10^5` elements. 2. Each element of the `arr` array will be in the range of `-10^4` to `10^4`. 3. `limit` is a positive integer. Example: 1. Input: `arr = [1, 2, 5, -1, 7], limit = 8` Output: `8` 2. Input: `arr = [-2, 3, -1, 5], limit = 4` Output: `4` 3. Input: `arr = [5, 6, 7, 8], limit = 4` Output: `0` Notes: - Use an efficient approach such as sliding window or prefix sums to handle large input arrays. - Consider edge cases where the array contains all negative numbers or very large/small sums. - Ensure that the function returns promptly for large input arrays by choosing appropriate algorithms. Evaluation criteria: - Correctness: The algorithm should correctly identify the maximum sum of a valid subarray. - Efficiency: The solution should efficiently handle the upper bounds of the input size. - Edge Cases: Proper handling of edge cases and ensuring valid outputs where no subarray meets the condition.","solution":"from typing import List def max_subarray_sum_with_limit(arr: List[int], limit: int) -> int: Find the maximum subarray sum such that the sum does not exceed the given limit. max_sum = 0 current_sum = 0 start = 0 for end in range(len(arr)): current_sum += arr[end] while current_sum > limit and start <= end: current_sum -= arr[start] start += 1 if current_sum <= limit: max_sum = max(max_sum, current_sum) return max_sum"},{"question":"Binary Tree Path Sum You are given the root node of a binary tree and an integer `target_sum`. Your task is to find all the paths that sum to a given value. Each path must start at the root node and end at any leaf node. # Function Definition: 1. **`binary_tree_path_sum(root: TreeNode, target_sum: int) -> list[list[int]]`** - **Input**: root: TreeNode, target_sum: int - **Output**: list of lists of integers representing all paths from root to leaf that sum up to `target_sum`. # Constraints: - The number of nodes in the binary tree is in the range [0, 1000]. - Each node has a unique integer value. # Example: Given the binary tree and target_sum: ``` 5 / 4 8 / / 11 13 4 / / 7 2 5 1 ``` - **target_sum**: 22 The paths that sum up to 22 are: 1. **Path 1**: [5, 4, 11, 2] 2. **Path 2**: [5, 8, 4, 5] # Output: [[5, 4, 11, 2], [5, 8, 4, 5]] # Function Signature: ```python def binary_tree_path_sum(root: TreeNode, target_sum: int) -> list[list[int]]: # write your code here ``` Use the provided `TreeNode` class for tree construction: ```python from __future__ import annotations from typing import Optional, List class TreeNode: def __init__(self, val: int = 0, left: Optional[TreeNode] = None, right: Optional[TreeNode] = None): self.val = val self.left = left self.right = right ``` Implement the function considering edge cases and optimizing for the constraints provided.","solution":"from typing import Optional, List class TreeNode: def __init__(self, val: int = 0, left: Optional[\'TreeNode\'] = None, right: Optional[\'TreeNode\'] = None): self.val = val self.left = left self.right = right def binary_tree_path_sum(root: Optional[TreeNode], target_sum: int) -> List[List[int]]: def find_paths(node, current_sum, path, paths): if not node: return current_sum += node.val path.append(node.val) if not node.left and not node.right and current_sum == target_sum: paths.append(list(path)) else: find_paths(node.left, current_sum, path, paths) find_paths(node.right, current_sum, path, paths) path.pop() paths = [] find_paths(root, 0, [], paths) return paths"},{"question":"# Coding Problem: Count Balanced Brackets **Problem Statement**: Given a string `s` containing only characters `(` and `)`, write a function to determine the minimum number of parenthesis insertions required to make the string valid. A string is considered valid if every opening parenthesis `(` has a corresponding closing parenthesis `)`, and every closing parenthesis `)` has a matching opening parenthesis `(`. Your function should return the number of insertions required to make the given string valid. **Input**: - A string `s` that consists of only the characters `(` and `)` and has length `n`. **Output**: - Return an integer, the number of insertions required to make the string valid. **Function Signature**: ```python def min_insertions_to_balance(s: str) -> int: pass ``` **Constraints**: - `0 <= n <= 10^6`, where `n` is the length of the string `s`. **Example**: ```python >>> min_insertions_to_balance(\\"(()\\") 1 >>> min_insertions_to_balance(\\")(()\\") 2 >>> min_insertions_to_balance(\\"())(()\\") 2 ``` **Requirements**: - Optimize for both time and space complexities. - Consider potential edge cases such as empty string or strings that are already balanced. Implement the function `min_insertions_to_balance` and ensure it adheres to the constraints and efficiently addresses the problem statement.","solution":"def min_insertions_to_balance(s: str) -> int: open_needed = 0 # To track the number of `(` needed balance_needed = 0 # To track the number of `)` needed for char in s: if char == \'(\': open_needed += 1 else: # char == \')\' if open_needed > 0: open_needed -= 1 else: # Need an extra `(` for this `)` balance_needed += 1 # Any remaining `(` needs a closing `)` return open_needed + balance_needed"},{"question":"# Scenario A social networking application needs to suggest new friends to users based on their current friend network. The suggestion algorithm should take into account mutual friends to determine the best new friend suggestions. The application stores friendship data in an adjacency list, where each user is a node and friends are edges connecting the nodes. # Task You need to implement the `suggest_friends` function that suggests the top k new friends with the most mutual friends for a given user. If there are ties, suggestions should be in ascending order of user IDs. # Specification **Function Signature**: ```python def suggest_friends(adjacency_list: dict[int, list[int]], user: int, k: int) -> list[int]: Suggests new friends for a given user based on mutual friends. Args: adjacency_list: A dictionary where the keys are user IDs and the values are lists of friend IDs. user: The user ID for whom to suggest new friends. k: The number of friend suggestions to make. Returns: list[int]: A list of the top k suggested friend IDs ordered by the number of mutual friends first, then by ascending user ID in case of ties. ``` # Input * `adjacency_list` (dict[int,list[int]]): A dictionary where keys are integers representing user IDs and values are lists of integers representing the friend IDs of each user. * `user` (int): The user ID for whom friend suggestions are being made. * `k` (int): The number of friend suggestions needed. # Output * `list[int]`: A list of integers representing the suggested friend IDs. # Performance Requirements * Ensure the function can handle adjacency lists with up to (10^4) users and (10^5) connections efficiently. # Constraints * The adjacency list may not contain the user ID if the user has no friends. * If there are less than k suggestions possible, return as many as available. * The function should prioritize suggestions based on mutual friends count primarily, then by ascending user ID. # Examples ```python adj_list = { 1: [2, 3, 4], 2: [1, 3, 5], 3: [1, 2, 6], 4: [1, 5], 5: [2, 4], 6: [3] } assert suggest_friends(adj_list, 1, 2) == [5, 6] assert suggest_friends(adj_list, 2, 3) == [4, 6] assert suggest_friends(adj_list, 3, 1) == [5] assert suggest_friends(adj_list, 4, 2) == [2, 6] ```","solution":"def suggest_friends(adjacency_list, user, k): Suggests new friends for a given user based on mutual friends. Args: adjacency_list: A dictionary where the keys are user IDs and the values are lists of friend IDs. user: The user ID for whom to suggest new friends. k: The number of friend suggestions to make. Returns: list[int]: A list of the top k suggested friend IDs ordered by the number of mutual friends first, then by ascending user ID in case of ties. if user not in adjacency_list: return [] friends = set(adjacency_list[user]) # Dictionary to count mutual friends mutual_friends_count = {} # Analyze each friend of the user\'s friends to count mutual friends for friend in friends: for potential_friend in adjacency_list.get(friend, []): if potential_friend != user and potential_friend not in friends: if potential_friend not in mutual_friends_count: mutual_friends_count[potential_friend] = 0 mutual_friends_count[potential_friend] += 1 # Convert mutual friends count to a sorted list of tuples (potential_friend, count) sorted_suggestions = sorted(mutual_friends_count.items(), key=lambda x: (-x[1], x[0])) # Extract just the user ids from the sorted list suggested_friends = [pair[0] for pair in sorted_suggestions] # Return top k suggestions return suggested_friends[:k]"},{"question":"# Sum of Digits in a String Problem Statement Given a string composed of digits, you need to find the sum of all its digits. The function should be able to handle large strings efficiently. Your task is to write a function that computes the sum of all the digits in the input string. Function Signature ```python def sum_of_digits(s: str) -> int: pass ``` Input - `s` (str): The input string composed of digits (1 ≤ len(s) ≤ 10^6). Output - Returns an integer representing the sum of all the digits in the string. Example ```python assert sum_of_digits(\\"123456789\\") == 45 assert sum_of_digits(\\"000123\\") == 6 ``` Constraints - The string consists of digits (\'0\'-\'9\') only. - Do not use in-built functions like `sum()` to aggregate the values. Performance Requirements Your solution should be efficient enough to handle strings with lengths up to 1,000,000 characters seamlessly. # Context This problem tests your ability to iterate through a string and perform a basic aggregation efficiently. Given the constraints, your implementation should be optimized to avoid excessive computation time and memory usage for very large input strings. Edge Cases - Empty string: This case will not occur as the length constraint is a minimum of 1. - Strings with leading or repeated zeros should be handled correctly.","solution":"def sum_of_digits(s: str) -> int: Returns the sum of all digits in the input string. Parameters: s (str): Input string composed of digits. Returns: int: Sum of all digits in the string. total = 0 for char in s: total += int(char) return total"},{"question":"# Question: Implement a File System with Directory and File Timestamps You are required to implement a basic file system simulation that includes directories and files. The file system should support various operations like adding directories and files, retrieving their information, and tracking the last access and modification times. **Features to Implement**: 1. **Directory Handling**: Ability to create and manage directories. 2. **File Handling**: Create, read, write, and delete files within directories. 3. **Timestamps**: Track the creation, last access, and last modification times for both files and directories. 4. **Path Navigation**: Functionality to navigate the file system using file paths. # Class Definitions: ```python import datetime class FileSystem: def __init__(self) -> None: # Initialize the file system with a root directory self.root = Directory(name=\\"/\\") self.current = self.root def create_directory(self, path: str) -> None: \'\'\' Create a directory at the specified path. Args: path (str): Path of the new directory. \'\'\' pass def create_file(self, path: str, content: str) -> None: \'\'\' Create a file at the specified path with given content. Args: path (str): Path of the new file. content (str): Content to be stored in the file. \'\'\' pass def read_file(self, path: str) -> str: \'\'\' Read the content of the file at the specified path. Args: path (str): Path of the file to read. Returns: str: Content of the file. \'\'\' pass def write_file(self, path: str, content: str) -> None: \'\'\' Write new content to the file at the specified path. Args: path (str): Path of the file to write. content (str): New content to be stored in the file. \'\'\' pass def delete_file(self, path: str) -> None: \'\'\' Delete the file at the specified path. Args: path (str): Path of the file to delete. \'\'\' pass def get_info(self, path: str) -> dict: \'\'\' Retrieve information (timestamps) of the directory or file at the specified path. Args: path (str): Path of the directory or file. Returns: dict: Information including creation, last access, and last modification times. \'\'\' pass class Directory: def __init__(self, name: str) -> None: self.name = name self.created = datetime.datetime.now() self.modified = self.created self.accessed = self.created self.contents = {} # key: name, value: Directory or File object class File: def __init__(self, name: str, content: str) -> None: self.name = name self.content = content self.created = datetime.datetime.now() self.modified = self.created self.accessed = self.created ``` Input Format: 1. For `create_directory`: `(path)` where `path` is the directory path to create. 2. For `create_file`: `(path, content)` where `path` is the file path and `content` is the data to store in the file. 3. For `read_file`: `(path)` where `path` is the file path to read. 4. For `write_file`: `(path, content)` where `path` is the file path and `content` is the new data to store in the file. 5. For `delete_file`: `(path)` where `path` is the file path to delete. 6. For `get_info`: `(path)` where `path` is the directory or file path to get info for. Output Format: 1. For `read_file`: Returns the content of the file. 2. For `get_info`: Returns a dictionary with creation, last access, and last modification times for the given path. Constraints: - Ensure thread-safe operations for accessing and modifying the file system. - Implement efficient path navigation for creating, retrieving, and modifying directories and files. - Handle edge cases such as invalid paths, non-existing directories or files, and permission issues. Example Usage: ```python # Creating an instance of FileSystem fs = FileSystem() # Creating directories fs.create_directory(\\"/home\\") fs.create_directory(\\"/home/user\\") # Creating files fs.create_file(\\"/home/user/file.txt\\", \\"Hello, World!\\") # Reading file content print(fs.read_file(\\"/home/user/file.txt\\")) # Output: \\"Hello, World!\\" # Modifying file content fs.write_file(\\"/home/user/file.txt\\", \\"Hello, Python!\\") # Retrieving file information info = fs.get_info(\\"/home/user/file.txt\\") print(info) # Output: { # \\"created\\": datetime.datetime(...), # \\"modified\\": datetime.datetime(...), # \\"accessed\\": datetime.datetime(...) # } # Deleting a file fs.delete_file(\\"/home/user/file.txt\\") ``` Your task is to implement the `FileSystem` class along with the `Directory` and `File` classes to achieve the outlined functionalities.","solution":"import datetime class FileSystem: def __init__(self) -> None: self.root = Directory(name=\\"/\\") self.current = self.root def create_directory(self, path: str) -> None: dirs = path.strip(\'/\').split(\'/\') current = self.root for directory in dirs: if directory not in current.contents: new_dir = Directory(name=directory) current.contents[directory] = new_dir current.modified = datetime.datetime.now() current = current.contents[directory] def create_file(self, path: str, content: str) -> None: parts = path.strip(\'/\').split(\'/\') filename = parts.pop() current = self.root for directory in parts: if directory in current.contents: current = current.contents[directory] else: raise FileNotFoundError(f\\"Directory {directory} not found in path\\") new_file = File(name=filename, content=content) current.contents[filename] = new_file current.modified = datetime.datetime.now() def read_file(self, path: str) -> str: parts = path.strip(\'/\').split(\'/\') filename = parts.pop() current = self.root for directory in parts: if directory in current.contents: current = current.contents[directory] else: raise FileNotFoundError(f\\"Directory {directory} not found in path\\") if filename in current.contents and isinstance(current.contents[filename], File): file = current.contents[filename] file.accessed = datetime.datetime.now() return file.content else: raise FileNotFoundError(f\\"File {filename} not found\\") def write_file(self, path: str, content: str) -> None: parts = path.strip(\'/\').split(\'/\') filename = parts.pop() current = self.root for directory in parts: if directory in current.contents: current = current.contents[directory] else: raise FileNotFoundError(f\\"Directory {directory} not found in path\\") if filename in current.contents and isinstance(current.contents[filename], File): file = current.contents[filename] file.content = content file.modified = datetime.datetime.now() current.modified = datetime.datetime.now() else: raise FileNotFoundError(f\\"File {filename} not found\\") def delete_file(self, path: str) -> None: parts = path.strip(\'/\').split(\'/\') filename = parts.pop() current = self.root for directory in parts: if directory in current.contents: current = current.contents[directory] else: raise FileNotFoundError(f\\"Directory {directory} not found in path\\") if filename in current.contents and isinstance(current.contents[filename], File): del current.contents[filename] current.modified = datetime.datetime.now() else: raise FileNotFoundError(f\\"File {filename} not found\\") def get_info(self, path: str) -> dict: parts = path.strip(\'/\').split(\'/\') current = self.root for directory in parts: if directory in current.contents: current = current.contents[directory] else: raise FileNotFoundError(f\\"Path {path} not found\\") information = { \\"created\\": current.created, \\"modified\\": current.modified, \\"accessed\\": current.accessed } return information class Directory: def __init__(self, name: str) -> None: self.name = name self.created = datetime.datetime.now() self.modified = self.created self.accessed = self.created self.contents = {} class File: def __init__(self, name: str, content: str) -> None: self.name = name self.content = content self.created = datetime.datetime.now() self.modified = self.created self.accessed = self.created"},{"question":"# Coding Assessment Question Context: A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. The Sieve of Eratosthenes is an efficient algorithm used to find all primes up to a given limit. Problem Statement: Given an integer `N`, find the sum of all prime numbers less than `N`. Function Signature: ```python def sum_of_primes(N: int) -> int: pass ``` Input: - An integer `N` (2 ≤ N ≤ 1,000,000), representing the upper bound for prime numbers considered. Output: - An integer, representing the sum of all prime numbers less than `N`. Example: 1. **Input**: `N = 10` **Output**: `17` (because the prime numbers less than 10 are 2, 3, 5, and 7, and their sum is 17) 2. **Input**: `N = 20` **Output**: `77` (because the prime numbers less than 20 are 2, 3, 5, 7, 11, 13, 17, and 19, and their sum is 77) Constraints: - The function should use the Sieve of Eratosthenes algorithm to efficiently find all prime numbers less than `N`. - Ensure the algorithm runs effectively even for large values of `N`. Note: - To implement the Sieve of Eratosthenes, create a boolean array where each index represents whether the number is prime, eliminating the multiples of each found prime. Write the Python function to solve this problem.","solution":"def sum_of_primes(N: int) -> int: Returns the sum of all prime numbers less than N using the Sieve of Eratosthenes. if N < 2: return 0 # Initialize a boolean array that will store whether each number is prime is_prime = [True] * N is_prime[0] = is_prime[1] = False # 0 and 1 are not prime numbers # Implementing Sieve of Eratosthenes p = 2 while p * p < N: if is_prime[p]: for i in range(p * p, N, p): is_prime[i] = False p += 1 # Calculate the sum of all prime numbers less than N prime_sum = sum(i for i, prime in enumerate(is_prime) if prime) return prime_sum"},{"question":"# Event Ticket Booking System You are designing an online ticket booking system for a venue that hosts various events. The system must handle reservations, ticket issuance, and user queries about available seats efficiently. Your task is to implement a class `EventBookingSystem` that includes methods to: 1. **Add Events**: Register new events with details such as event name, date, and seating capacity. 2. **Book Tickets**: Allow users to book a specified number of tickets for a particular event. 3. **Check Availability**: Query the system to check the availability of tickets for a given event. 4. **Cancel Booking**: Allow users to cancel their booking, thereby freeing up the tickets. # Requirements 1. Implement the class `EventBookingSystem` with the following methods: * **`__init__(self)`**: * Initialize the system with an empty list of events and their bookings. * **`add_event(self, event_name: str, event_date: str, capacity: int)`**: * Register a new event by storing its name, date, and seating capacity. * **`book_tickets(self, event_name: str, number_of_tickets: int) -> str`**: * Book a specified number of tickets for an event. * Ensure that the requested number of tickets does not exceed the remaining available seats for the event. * Return a confirmation message upon successful booking or an error message if the booking cannot be completed. * **`check_availability(self, event_name: str) -> int`**: * Return the number of available tickets for a specified event. * **`cancel_booking(self, event_name: str, number_of_tickets: int) -> str`**: * Cancel a specified number of tickets for an event, increasing the number of available seats accordingly. * Ensure that you cannot cancel more tickets than what has been booked. * Return a confirmation message upon successful cancellation or an error message if the cancellation cannot be completed. 2. Consider edge cases and error handling, including non-existing events, detailed status reports on failed bookings or cancellations, and proper maintenance of event data integrity. # Constraints * The event name is a unique identifier for each event. * The date format for events is \\"YYYY-MM-DD\\". * The system should handle multiple events efficiently. # Example Usage ```python ebs = EventBookingSystem() # Add events to the system ebs.add_event(\\"Concert\\", \\"2023-12-25\\", 100) ebs.add_event(\\"Conference\\", \\"2023-11-10\\", 50) # Book tickets for the events print(ebs.book_tickets(\\"Concert\\", 10)) # Output: \\"Successfully booked 10 tickets for Concert.\\" print(ebs.book_tickets(\\"Conference\\", 60)) # Output: \\"Error: Not enough available seats for Conference.\\" # Check availability of tickets print(ebs.check_availability(\\"Concert\\")) # Output: 90 print(ebs.check_availability(\\"Conference\\")) # Output: 50 # Cancel bookings for the events print(ebs.cancel_booking(\\"Concert\\", 5)) # Output: \\"Successfully cancelled 5 tickets for Concert.\\" print(ebs.cancel_booking(\\"Conference\\", 20)) # Output: \\"Error: Cannot cancel more tickets than booked.\\" ``` # Expected Input & Output * **Input**: `book_tickets(\\"Concert\\", 10)`, `check_availability(\\"Concert\\")`, `cancel_booking(\\"Concert\\", 5)`. * **Output**: Appropriate success or error messages and integer values representing available tickets. Implement the `EventBookingSystem` class as specified and ensure thorough testing for various scenarios.","solution":"class EventBookingSystem: def __init__(self): self.events = {} def add_event(self, event_name: str, event_date: str, capacity: int): if event_name not in self.events: self.events[event_name] = {\'date\': event_date, \'capacity\': capacity, \'booked\': 0} def book_tickets(self, event_name: str, number_of_tickets: int) -> str: if event_name in self.events: available_tickets = self.events[event_name][\'capacity\'] - self.events[event_name][\'booked\'] if number_of_tickets <= available_tickets: self.events[event_name][\'booked\'] += number_of_tickets return f\\"Successfully booked {number_of_tickets} tickets for {event_name}.\\" else: return f\\"Error: Not enough available seats for {event_name}.\\" else: return \\"Error: Event not found.\\" def check_availability(self, event_name: str) -> int: if event_name in self.events: return self.events[event_name][\'capacity\'] - self.events[event_name][\'booked\'] else: return -1 # Return -1 if event not found def cancel_booking(self, event_name: str, number_of_tickets: int) -> str: if event_name in self.events: if number_of_tickets <= self.events[event_name][\'booked\']: self.events[event_name][\'booked\'] -= number_of_tickets return f\\"Successfully cancelled {number_of_tickets} tickets for {event_name}.\\" else: return f\\"Error: Cannot cancel more tickets than booked for {event_name}.\\" else: return \\"Error: Event not found.\\""},{"question":"# Sum of Digits in a String **Scenario**: In a data validation process, you need to verify the integrity of alphanumeric codes by calculating the sum of all digits in the code. This sum will be used in further validation checks. **Task**: Write a function `sum_of_digits` that computes the sum of all numerical digits present in a given alphanumeric string. **Function Signature**: ```python def sum_of_digits(code: str) -> int: pass ``` **Input**: - `code`: A string containing alphanumeric characters (i.e., a mix of lowercase/uppercase letters and digits). **Output**: - Return an integer representing the sum of all numerical digits in the input string. **Constraints**: - The input string will have at least one character. - The input string will contain only ASCII characters. **Examples**: ```python assert sum_of_digits(\\"a1b2c3\\") == 6 assert sum_of_digits(\\"12345\\") == 15 assert sum_of_digits(\\"abc\\") == 0 assert sum_of_digits(\\"9lives8\\") == 17 ``` In this question, students are expected to iterate through the given string and sum up all the digits they encounter. This requires familiarity with basic string operations and type conversion in Python.","solution":"def sum_of_digits(code: str) -> int: Computes the sum of all numerical digits present in a given alphanumeric string. Parameters: code (str): An alphanumeric string containing digits and letters. Returns: int: The sum of all numerical digits in the string. return sum(int(char) for char in code if char.isdigit())"},{"question":"# Question: You are given a rectangular grid represented as a 2D list of integers and an integer `k`. Implement a function `find_max_sum_subgrid(grid: List[List[int]], k: int) -> int` that finds the maximum sum of any subgrid within the given grid that has a sum less than or equal to `k`. Input: * `grid`: a 2D list of integers representing the rectangular grid, where `grid[i][j]` is the element at row `i` and column `j`. * `k`: an integer representing the maximum allowed sum of the subgrid. Output: * An integer representing the maximum sum of any subgrid within the grid that is less than or equal to `k`. If such a subgrid does not exist, return 0. Constraints: * `1 <= len(grid) <= 20` (number of rows) * `1 <= len(grid[0]) <= 20` (number of columns) * `-10^4 <= grid[i][j] <= 10^4` * `1 <= k <= 10^8` Example: ```python grid = [ [1, 0, 1], [0, -2, 3] ] k = 2 assert find_max_sum_subgrid(grid, k) == 2 grid = [ [2, 2, -1], [-3, 4, 3], [2, 1, 6] ] k = 8 assert find_max_sum_subgrid(grid, k) == 8 ``` Notes: * The function should identify and consider all possible subgrids within the input grid. * An optimal approach would efficiently handle some precomputation for larger grids to avoid redundant calculations. * Think about utilizing techniques such as prefix sums or sliding windows to enhance the efficiency of the solution. * Consider edge cases such as subgrids that contain negative numbers and ensuring the sum is properly compared to `k`.","solution":"from typing import List import itertools def find_max_sum_subgrid(grid: List[List[int]], k: int) -> int: rows = len(grid) cols = len(grid[0]) def get_prefix_sums(matrix): prefix_sums = [[0] * (cols + 1) for _ in range(rows + 1)] for r in range(1, rows + 1): for c in range(1, cols + 1): prefix_sums[r][c] = matrix[r-1][c-1] + prefix_sums[r-1][c] + prefix_sums[r][c-1] - prefix_sums[r-1][c-1] return prefix_sums prefix_sums = get_prefix_sums(grid) max_sum = float(\'-inf\') for r1 in range(1, rows + 1): for r2 in range(r1, rows + 1): for c1 in range(1, cols + 1): for c2 in range(c1, cols + 1): current_sum = (prefix_sums[r2][c2] - prefix_sums[r1-1][c2] - prefix_sums[r2][c1-1] + prefix_sums[r1-1][c1-1]) if current_sum <= k: max_sum = max(max_sum, current_sum) return max_sum if max_sum != float(\'-inf\') else 0"},{"question":"File System Navigator Background You are implementing a simple file system navigator that simulates basic operations such as creating directories, navigating through the directory tree, and listing contents of the current directory. The file system operates in a hierarchical structure where each directory can contain files and other directories. # Problem Statement: Implement a class `FileSystem` that simulates a file system with the following methods: 1. `mkdir(path: str) -> None`: Creates a new directory at the given path. If the path already exists as a directory, do nothing. If any intermediate directories in the path do not exist, create them. 2. `cd(path: str) -> bool`: Changes the current directory to the given path. Returns `True` if the path is valid and the change is successful, otherwise returns `False`. The path can be an absolute path or a relative path based on the current directory. 3. `ls() -> list`: Lists the names of all files and directories in the current directory in lexicographical order. # Implementation Details: - Paths will use forward slashes `/` as separators. - The root directory is represented by `/`. - Directories and files share the same namespace; a directory cannot have the same name as a file. - You may assume no file system operations outside the defined methods will be performed. # Class Signature: ```python class FileSystem: def __init__(self): # Initialize the file system def mkdir(self, path: str) -> None: # Create directory def cd(self, path: str) -> bool: # Change directory def ls(self) -> list: # List contents of current directory ``` # Example Usage: ```python # After implementation fs = FileSystem() fs.mkdir(\\"/a/b/c\\") assert fs.cd(\\"/a/b/c\\") == True assert fs.ls() == [] fs.mkdir(\\"/a/b/d\\") assert fs.cd(\\"..\\") == True assert fs.ls() == [\\"c\\", \\"d\\"] assert fs.cd(\\"/\\") == True assert fs.ls() == [\\"a\\"] assert fs.cd(\\"/a/b/c\\") == True assert fs.cd(\\"/invalid/path\\") == False assert fs.cd(\\"..\\") == True assert fs.ls() == [\\"c\\", \\"d\\"] assert fs.cd(\\"/\\") == True assert fs.cd(\\"/a/b\\") == True assert fs.ls() == [\\"c\\", \\"d\\"] ``` # Constraints: * You can assume the input path is always valid and well-formed. * The lengths of paths and directories/files names do not exceed 1000 characters in total. * The number of files and directories in the file system is bounded by 10,000. This question builds on core concepts of object-oriented design, tree traversal, and string manipulation, providing an engaging challenge suitable for a coding assessment context.","solution":"class FileSystem: def __init__(self): self.fs = {\'/\': {}} # file system dictionary with root directory self.current_path = \'/\' def mkdir(self, path: str) -> None: dirs = path.split(\'/\')[1:] # split the path and ignore the first empty string curr_dir = self.fs[\'/\'] for directory in dirs: if directory not in curr_dir: curr_dir[directory] = {} curr_dir = curr_dir[directory] def cd(self, path: str) -> bool: # normalize path if path.startswith(\'/\'): full_path = path else: full_path = self.current_path + \'/\' + path full_path = \'/\' + \'/\'.join(filter(lambda x: x and x != \'.\', full_path.split(\'/\'))) # handle going up directories with \\"..\\" parts = [] for part in full_path.split(\'/\'): if part == \'..\': if parts: parts.pop() else: parts.append(part) final_path = \'/\' + \'/\'.join(filter(lambda x: x, parts)) curr_dir = self.fs[\'/\'] if final_path == \'/\': self.current_path = \'/\' return True dirs = final_path.split(\'/\')[1:] for directory in dirs: if directory not in curr_dir: return False curr_dir = curr_dir[directory] self.current_path = final_path return True def ls(self) -> list: if self.current_path == \'/\': curr_dir = self.fs[\'/\'] else: curr_dir = self.fs[\'/\'] dirs = self.current_path.split(\'/\')[1:] for directory in dirs: curr_dir = curr_dir[directory] return sorted(list(curr_dir.keys()))"},{"question":"# Software Development Assessment Question Scenario: Concurrent Prime Number Search You are developing a concurrent system that involves finding prime numbers within a specified range. Your objective is to implement an efficient solution that leverages parallel processing to speed up the execution of the prime number search. Task Implement a function `concurrent_prime_search(start, end)` that finds all prime numbers in the given range `[start, end]` using parallel processing. Utilize multiple processes to divide the workload and perform the calculations concurrently. Function Signature ```python def concurrent_prime_search(start: int, end: int) -> List[int]: Finds all prime numbers within the given range using concurrent processing. Parameters: start (int): The start of the range (inclusive). end (int): The end of the range (inclusive). Returns: List[int]: A list of prime numbers within the specified range. ``` Input - `start`: An integer representing the beginning of the range (1 <= start < end <= 10^6). - `end`: An integer representing the end of the range. Output - A list of prime numbers within the specified range `[start, end]`. Constraints - Utilize multiprocessing to achieve concurrent execution. - Properly manage synchronization to ensure thread safety when aggregating results. - Edge cases such as ranges with no prime numbers or ranges with very few elements should be taken into consideration. - Ensure the implementation efficiently handles large ranges. Example ```python from typing import List # Example function call start = 10 end = 50 primes = concurrent_prime_search(start, end) print(primes) # Output: [11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47] ``` Guidelines - Use concurrent processing libraries such as `multiprocessing` to divide the task among multiple processes. - Optimize the prime-checking function for performance since it will be called multiple times. - Handle the task distribution and result collection effectively to minimize the overhead of managing multiple processes. - Ensure your implementation is robust and can handle a range of different inputs without failing. This question aligns with the preceding sample question by maintaining the focus on parallel processing and efficient algorithm implementation, incorporating similar constraints and complexity, and presenting a different yet related problem scenario.","solution":"from typing import List import multiprocessing as mp def is_prime(n: int) -> bool: Check if a number is a prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while (i * i) <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def find_primes_in_range(start: int, end: int) -> List[int]: Find all prime numbers in the given range return [num for num in range(start, end + 1) if is_prime(num)] def concurrent_prime_search(start: int, end: int) -> List[int]: Finds all prime numbers within the given range using concurrent processing. Parameters: start (int): The start of the range (inclusive). end (int): The end of the range (inclusive). Returns: List[int]: A list of prime numbers within the specified range. if start > end: return [] num_processes = mp.cpu_count() ranges = [(start + i * (end - start) // num_processes, start + (i + 1) * (end - start) // num_processes - 1) for i in range(num_processes)] ranges[-1] = (ranges[-1][0], end) pool = mp.Pool(processes=num_processes) results = pool.starmap(find_primes_in_range, ranges) pool.close() pool.join() primes = [] for result in results: primes.extend(result) return sorted(primes)"},{"question":"# Given Context You are working on a text processing library that includes a function for analyzing word frequencies in a given text. However, the existing implementation does not handle case sensitivity properly, some common stop words are counted, and punctuation is not removed correctly. You need to improve the function by normalizing case, removing stop words, and stripping punctuation. # Task 1. Modify the `analyze_word_frequency` function to: - Convert all words to lower case. - Remove common stop words (e.g., \\"and\\", \\"the\\", \\"in\\", \\"of\\"). - Strip punctuation from the beginning and end of words. 2. Ensure the function returns a dictionary of word frequencies, with words as keys and their counts as values. # Input and Output Formats * **Function to modify**: * `analyze_word_frequency` - Currently analyzes and returns word frequencies from a given text string. * **Input**: * A string `text` consisting of multiple words separated by spaces and punctuation. * **Constraints**: * Must handle mixed case words. * Remove the following common stop words: `[\'and\', \'the\', \'in\', \'of\', \'to\', \'it\', \'is\', \'a\', \'for\']`. * Strip punctuation marks from words: `. , ! ? : ; \\" \' ( )`. * **Output**: * A dictionary where keys are words and values are their respective counts. # Example Scenario Given the text `\\"Hello, world! This is a test. Hello world!\\"`, the word frequency dictionary should not include common stop words, punctuation should be removed, and all words should be in lower case: `{\\"hello\\": 2, \\"world\\": 2, \\"this\\": 1, \\"test\\": 1}`. # Starter Code ```python import string STOP_WORDS = [\'and\', \'the\', \'in\', \'of\', \'to\', \'it\', \'is\', \'a\', \'for\'] def analyze_word_frequency(text: str) -> dict[str, int]: Analyze word frequency from the given text string. Args: text (str): A string containing the text to analyze. Returns: dict[str, int]: Dictionary of word frequencies. word_freq = {} words = text.split() for word in words: # Convert to lower case word = word.lower() # Remove punctuation from beginning and end word = word.strip(string.punctuation) # Skip stop words if word in STOP_WORDS: continue if word in word_freq: word_freq[word] += 1 else: word_freq[word] = 1 return word_freq # Test cases to validate the solution if __name__ == \\"__main__\\": print(analyze_word_frequency(\\"Hello, world! This is a test. Hello world!\\")) # Output: {\\"hello\\": 2, \\"world\\": 2, \\"this\\": 1, \\"test\\": 1} print(analyze_word_frequency(\\"Python is great. Python, python, Python!\\")) # Output: {\\"python\\": 4, \\"great\\": 1} ``` # Given Context You are developing a utility for managing tasks in a project management application. The utility should be able to group tasks based on their categories, which are provided as a part of the task description. Each task consists of a name and a category separated by a colon. You need to write a function that groups tasks by their categories and returns this information in a structured format. # Task 1. Create a function `group_tasks_by_category` that: - Takes a list of task descriptions in the format \\"task_name: category_name\\". - Groups tasks based on their categories. - Returns a dictionary where each key is a category name and the value is a list of task names belonging to that category. # Input and Output Formats * **Function to create**: * `group_tasks_by_category` - Groups tasks by their categories. * **Input**: * A list of strings `tasks` where each string is in the format \\"task_name: category_name\\". * **Output**: * A dictionary where keys are category names and values are lists of task names. # Example Scenario Given the tasks `[\\"Setup project: Development\\", \\"Write documentation: Documentation\\", \\"Fix bug: Development\\", \\"Plan sprint: Planning\\"]`, the utility should group tasks as follows: `{\\"Development\\": [\\"Setup project\\", \\"Fix bug\\"], \\"Documentation\\": [\\"Write documentation\\"], \\"Planning\\": [\\"Plan sprint\\"]}`. # Starter Code ```python def group_tasks_by_category(tasks: list[str]) -> dict[str, list[str]]: Group tasks by their categories. Args: tasks (list[str]): A list of task descriptions in the format \\"task_name: category_name\\". Returns: dict[str, list[str]]: Dictionary of categories and their respective task names. categories = {} for task in tasks: task_name, category_name = task.split(\\": \\") if category_name not in categories: categories[category_name] = [] categories[category_name].append(task_name) return categories # Test cases to validate the solution if __name__ == \\"__main__\\": print(group_tasks_by_category([\\"Setup project: Development\\", \\"Write documentation: Documentation\\", \\"Fix bug: Development\\", \\"Plan sprint: Planning\\"])) # Output: {\\"Development\\": [\\"Setup project\\", \\"Fix bug\\"], \\"Documentation\\": [\\"Write documentation\\"], \\"Planning\\": [\\"Plan sprint\\"]} ```","solution":"def group_tasks_by_category(tasks: list[str]) -> dict[str, list[str]]: Group tasks by their categories. Args: tasks (list[str]): A list of task descriptions in the format \\"task_name: category_name\\". Returns: dict[str, list[str]]: Dictionary of categories and their respective task names. categories = {} for task in tasks: task_name, category_name = task.split(\\": \\") if category_name not in categories: categories[category_name] = [] categories[category_name].append(task_name) return categories"},{"question":"# Problem Statement Implement a function to merge two sorted linked lists and return it as a new sorted list. The new list should be made by splicing together the nodes of the first two lists. # Method Signature ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_two_sorted_lists(l1: ListNode, l2: ListNode) -> ListNode: Merge two sorted linked lists into one sorted linked list. Args: - l1 (ListNode): The head of the first sorted linked list. - l2 (ListNode): The head of the second sorted linked list. Returns: - ListNode: The head of the merged sorted linked list. pass ``` # Example Usage ```python # Helper function to print the linked list def print_list(node): while node: print(node.val, end=\\" -> \\") node = node.next print(\\"None\\") # Create first linked list: 1 -> 2 -> 4 l1 = ListNode(1) l1.next = ListNode(2) l1.next.next = ListNode(4) # Create second linked list: 1 -> 3 -> 4 l2 = ListNode(1) l2.next = ListNode(3) l2.next.next = ListNode(4) # Merge lists merged_list = merge_two_sorted_lists(l1, l2) # Print merged list print_list(merged_list) # Output: 1 -> 1 -> 2 -> 3 -> 4 -> 4 -> None ``` # Constraints - The number of nodes in both lists is in the range [0, 50]. - Both `l1` and `l2` are sorted in non-decreasing order. - Keyword arguments are not used in function signature. - Assume that `ListNode` class is already defined before implementation as shown above. # Your Task Complete the function `merge_two_sorted_lists` to achieve the described behavior. Ensure that the merged linked list maintains sorted order throughout.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_two_sorted_lists(l1: ListNode, l2: ListNode) -> ListNode: Merge two sorted linked lists into one sorted linked list. Args: - l1 (ListNode): The head of the first sorted linked list. - l2 (ListNode): The head of the second sorted linked list. Returns: - ListNode: The head of the merged sorted linked list. # Create a dummy node to serve as the start of the merged list dummy = ListNode() tail = dummy # This will be the end of the merged list # Traverse both lists and link nodes in sorted order while l1 and l2: if l1.val < l2.val: tail.next = l1 l1 = l1.next else: tail.next = l2 l2 = l2.next tail = tail.next # If there are remaining nodes in either list, append them if l1: tail.next = l1 if l2: tail.next = l2 # The merged list starts from the next of the dummy node return dummy.next"},{"question":"# Coding Assessment Question Scenario You are given a rectangular grid representing an agricultural field, where each cell can either be fertile soil or an obstacle (e.g., rocks, ponds). The objective is to determine the total number of distinct regions of fertile soil in the field. Two cells are considered part of the same region if they are adjacent horizontally or vertically, but not diagonally. Task Write a function `count_fertile_regions(field: List[List[int]]) -> int` that returns the total number of distinct fertile soil regions in the given grid. Input * `field`: A 2D list of integers, where `1` represents fertile soil and `0` represents an obstacle. Output * An integer representing the total number of distinct fertile soil regions. Constraints * The dimensions of the grid (m, n) will be at least 1x1 and no more than 100x100. * The grid will contain only 0s and 1s. Example ```python def count_fertile_regions(field: List[List[int]]) -> int: # function implementation # Example Calls field1 = [ [1, 0, 0, 1, 1], [1, 0, 0, 0, 1], [0, 0, 1, 1, 0], [0, 1, 1, 0, 0] ] print(count_fertile_regions(field1)) # Output: 3 field2 = [ [1, 1, 0, 0], [1, 1, 0, 0], [0, 0, 1, 1], [0, 0, 1, 1] ] print(count_fertile_regions(field2)) # Output: 2 ``` Additional Notes * Ensure to consider edge cases such as grids with all obstacles or all fertile soil. * A Depth-First Search (DFS) or Breadth-First Search (BFS) approach is recommended to traverse the grid and identify distinct regions.","solution":"from typing import List def count_fertile_regions(field: List[List[int]]) -> int: def dfs(field, x, y): # Boundaries check if x < 0 or y < 0 or x >= len(field) or y >= len(field[0]) or field[x][y] == 0: return field[x][y] = 0 # mark as visited # Explore all four directions (up, down, left, right) dfs(field, x + 1, y) dfs(field, x - 1, y) dfs(field, x, y + 1) dfs(field, x, y - 1) count = 0 for i in range(len(field)): for j in range(len(field[0])): if field[i][j] == 1: dfs(field, i, j) count += 1 return count"},{"question":"# Number Theory: Greatest Common Divisor Using Euclidean Algorithm You are required to create a function `gcd_euclidean` that calculates the greatest common divisor (GCD) of two positive integers using the Euclidean algorithm. Additionally, create a main program that reads two integers, calls the GCD function, and prints the result. Requirements: 1. **GCD Function**: Implement a function `gcd_euclidean` that takes two positive integers and returns their GCD. 2. **Main Execution Flow**: Read two integers from the standard input, call the `gcd_euclidean` function, and print the resulting GCD. 3. **Error Handling**: Ensure the function correctly handles invalid inputs such as non-positive integers by printing an appropriate error message and terminating gracefully. Input/Output Specification: * **Input**: * `a` (Integer): The first positive integer. Constraints: (1 leq a leq 10^9) * `b` (Integer): The second positive integer. Constraints: (1 leq b leq 10^9) * **Output**: * An integer which is the greatest common divisor of the two input numbers. Example: ```python # Example 1 # Input # a = 48, b = 18 # Output # 6 # Example 2 # Input # a = 101, b = 103 # Output # 1 ``` Code: ```python def gcd_euclidean(a: int, b: int) -> int: if a <= 0 or b <= 0: raise ValueError(\\"Both numbers must be positive integers.\\") while b != 0: a, b = b, a % b return a if __name__ == \\"__main__\\": try: a = int(input(\\"Enter the first positive integer: \\")) b = int(input(\\"Enter the second positive integer: \\")) result = gcd_euclidean(a, b) print(f\\"The greatest common divisor of {a} and {b} is {result}.\\") except ValueError as e: print(e) ``` Ensure to handle cases of non-positive integers by raising an appropriate error and displaying a meaningful message to the user.","solution":"def gcd_euclidean(a: int, b: int) -> int: Calculate the greatest common divisor (GCD) using the Euclidean algorithm. if a <= 0 or b <= 0: raise ValueError(\\"Both numbers must be positive integers.\\") while b != 0: a, b = b, a % b return a if __name__ == \\"__main__\\": try: a = int(input(\\"Enter the first positive integer: \\")) b = int(input(\\"Enter the second positive integer: \\")) result = gcd_euclidean(a, b) print(f\\"The greatest common divisor of {a} and {b} is {result}.\\") except ValueError as e: print(e)"},{"question":"# Question: Evaluate Postfix Expression Given a string representing a postfix (Reverse Polish Notation) expression, implement a function `evaluate_postfix(expression: str) -> int` that evaluates the expression and returns the result. The expression will consist of integers and the operators `+`, `-`, `*`, and `/` (where division is integer division and discards the remainder). Implement an efficient algorithm to evaluate the expression correctly. # Input Format * `expression`: A string representing the postfix expression where tokens are separated by spaces. Each token is an integer or an operator. # Output Format * Return an integer, the result of evaluating the postfix expression. # Constraints * The expression will be valid. * Operands are in the range ([-10^6, 10^6]). * The length of the expression will be between 1 and (10^5). # Example ```python >>> evaluate_postfix(\\"3 4 +\\") 7 >>> evaluate_postfix(\\"5 1 2 + 4 * + 3 -\\") 14 >>> evaluate_postfix(\\"7 8 + 3 2 + /\\") 3 ``` # Additional Notes 1. Briefly explain the data structure used for evaluating the postfix expression. 2. Consider edge cases, like invalid expressions with insufficient operands for the operators.","solution":"def evaluate_postfix(expression: str) -> int: Evaluates a postfix expression and returns the result. stack = [] tokens = expression.split() for token in tokens: if token.lstrip(\'-\').isdigit(): stack.append(int(token)) else: operand2 = stack.pop() operand1 = stack.pop() if token == \'+\': stack.append(operand1 + operand2) elif token == \'-\': stack.append(operand1 - operand2) elif token == \'*\': stack.append(operand1 * operand2) elif token == \'/\': stack.append(int(operand1 / operand2)) # ensure integer division return stack.pop()"},{"question":"# File Cleaner You are tasked with developing a script that scans a directory for text files, processes their contents, and outputs a cleaned version of each file. The files may contain extraneous whitespace, special characters, and lines of non-text data. Your job is to clean these files and save the processed data. Requirements: 1. **Function `clean_text`**: - Takes a string representing the content of a file. - Removes all special characters except spaces, periods, commas, question marks, and exclamation marks. - Removes extra whitespace, ensuring a single space between words and no leading/trailing spaces. - Converts all text to lowercase. - Returns the cleaned string. 2. **Function `process_files`**: - Takes a directory path as input. - Finds all text files (`.txt` extension) within the directory. - Reads the contents of each text file, cleans the text using `clean_text`, and writes the cleaned data back to a new file with the same name but with a `_cleaned` suffix. 3. **Constraints**: - You must use the `os` and `re` libraries for directory traversal and text processing. - Ensure efficient file operations and handle potential exceptions gracefully (e.g., file not found, read/write errors). Example: Given a directory path `\\"./example_files\\"`, the script should: 1. Find all `.txt` files in the directory. 2. Clean the contents of each file. 3. Write the cleaned content to new files with the `_cleaned` suffix. ```python import os import re def clean_text(file_content: str) -> str: # Remove special characters except allowed punctuations cleaned_text = re.sub(r\\"[^a-zA-Z0-9s.,!?]\\", \\"\\", file_content) # Remove extra whitespace cleaned_text = re.sub(r\\"s+\\", \\" \\", cleaned_text).strip() # Convert to lowercase cleaned_text = cleaned_text.lower() return cleaned_text def process_files(directory_path: str) -> None: try: for filename in os.listdir(directory_path): if filename.endswith(\'.txt\'): file_path = os.path.join(directory_path, filename) with open(file_path, \'r\') as file: content = file.read() cleaned_content = clean_text(content) cleaned_file_path = os.path.join(directory_path, filename.replace(\'.txt\', \'_cleaned.txt\')) with open(cleaned_file_path, \'w\') as cleaned_file: cleaned_file.write(cleaned_content) except Exception as e: print(f\\"An error occurred: {e}\\") if __name__ == \\"__main__\\": directory = \\"./example_files\\" process_files(directory) ``` # Task: - Compose the `clean_text` and `process_files` functions according to the given requirements. - Demonstrate the script with a sample directory containing `.txt` files with mixed content. - Ensure the script handles exceptions and reports errors appropriately.","solution":"import os import re def clean_text(file_content: str) -> str: Removes all special characters except spaces, periods, commas, question marks, and exclamation marks. Removes extra whitespace, ensuring a single space between words and no leading/trailing spaces. Converts all text to lowercase. # Remove special characters except allowed punctuations cleaned_text = re.sub(r\\"[^a-zA-Z0-9s.,!?]\\", \\"\\", file_content) # Remove extra whitespace cleaned_text = re.sub(r\\"s+\\", \\" \\", cleaned_text).strip() # Convert to lowercase cleaned_text = cleaned_text.lower() return cleaned_text def process_files(directory_path: str) -> None: Finds all .txt files in the directory, reads the contents, cleans the text using `clean_text`, and writes the cleaned data back to a new file with the same name but with a `_cleaned` suffix. try: for filename in os.listdir(directory_path): if filename.endswith(\'.txt\'): file_path = os.path.join(directory_path, filename) with open(file_path, \'r\') as file: content = file.read() cleaned_content = clean_text(content) cleaned_file_path = os.path.join(directory_path, filename.replace(\'.txt\', \'_cleaned.txt\')) with open(cleaned_file_path, \'w\') as cleaned_file: cleaned_file.write(cleaned_content) except Exception as e: print(f\\"An error occurred: {e}\\") if __name__ == \\"__main__\\": directory = \\"./example_files\\" process_files(directory)"},{"question":"# Coding Assessment Question Scenario You are developing an e-commerce platform, and one of the core functionalities is to manage the product catalog efficiently. In this scenario, you need to implement a simple inventory management system that tracks the stock of various products. Each product has a unique identifier, a name, and the quantity in stock. The inventory should support adding new products, updating the quantity of existing products, and querying the current stock of a product by its identifier. Task Implement a class `Inventory` with the following methods: - `__init__`: Initializes an empty inventory. - `add_product(product_id: int, product_name: str, quantity: int) -> None`: Adds a new product to the inventory with the given product ID, name, and quantity. If the product ID already exists, update its name and quantity. - `update_quantity(product_id: int, quantity: int) -> None`: Updates the quantity of the product with the given ID. If the product does not exist, raise a `ValueError`. - `get_stock(product_id: int) -> int`: Returns the current stock of the product with the given ID. If the product does not exist, raise a `ValueError`. Requirements - Define the class `Inventory` and implement the methods as specified. - Ensure the class handles edge cases such as updating the quantity for non-existing products and querying non-existing products. - Provide sufficient test cases to validate your implementation. Constraints - `product_id`: 1 to 10^6 - `product_name`: a string of length 1 to 255 characters - `quantity`: any integer value (negative values may indicate returns or removals from stock) - Ensure each method completes within a reasonable time frame (1 second) for a maximum number of products (10^6). Performance Requirements - Time Complexity: O(1) for add_product, update_quantity, and get_stock operations. - Space Complexity: O(n), where n is the number of unique products in the inventory. Example ```python >>> inv = Inventory() >>> inv.add_product(1, \\"Laptop\\", 50) >>> inv.add_product(2, \\"Smartphone\\", 100) >>> inv.get_stock(1) 50 >>> inv.update_quantity(1, 20) >>> inv.get_stock(1) 20 >>> inv.get_stock(2) 100 >>> inv.update_quantity(3, 10) Traceback (most recent call last): ... ValueError: Product ID not found ``` Implement the `Inventory` class and its methods as outlined in the task description. Ensure your solution handles edge cases appropriately and meets the performance requirements.","solution":"class Inventory: def __init__(self): self.products = {} def add_product(self, product_id: int, product_name: str, quantity: int) -> None: self.products[product_id] = {\'name\': product_name, \'quantity\': quantity} def update_quantity(self, product_id: int, quantity: int) -> None: if product_id not in self.products: raise ValueError(\\"Product ID not found\\") self.products[product_id][\'quantity\'] = quantity def get_stock(self, product_id: int) -> int: if product_id not in self.products: raise ValueError(\\"Product ID not found\\") return self.products[product_id][\'quantity\']"},{"question":"# Coding Assessment: Dijkstra\'s Algorithm for Shortest Path in Weighted Graph Problem Statement You are provided with an implementation framework for Dijkstra\'s Algorithm to find the shortest path in a weighted graph. Your task is to complete the implementation by filling in the missing parts. Objectives 1. Implement the `dijkstra` function that computes the shortest path from a given start node to all other nodes in the graph. 2. Implement a `WeightedGraph` class with appropriate methods to support the Dijkstra\'s Algorithm. Input - **Graph**: A weighted graph represented as an adjacency list, where the keys are node identifiers and the values are lists of tuples representing neighboring nodes and the edge weights. - **Start Node**: The starting node for calculating shortest paths. Output - A dictionary where the keys are node identifiers and the values are the shortest path distances from the start node to that node. # Constraints 1. **Function Implementation**: Your `WeightedGraph` class must have the following methods: - `__init__(self, adj_list: Dict[Any, List[Tuple[Any, float]]])` - `get_neighbors(self, node: Any) -> List[Tuple[Any, float]]` 2. **Dijkstra\'s Algorithm**: Your `dijkstra` function must have the following signature: ```python def dijkstra(graph: WeightedGraph, start_node: Any) -> Dict[Any, float]: ``` 3. **Performance Requirement**: Your implementation should efficiently compute the shortest paths in graphs with up to 1000 nodes and 10000 edges within a reasonable time frame. # Example Usage ```python # Define a sample weighted graph as an adjacency list graph_adj_list = { \'A\': [(\'B\', 1), (\'C\', 4)], \'B\': [(\'A\', 1), (\'C\', 2), (\'D\', 5)], \'C\': [(\'A\', 4), (\'B\', 2), (\'D\', 1)], \'D\': [(\'B\', 5), (\'C\', 1)] } # Create graph object graph = WeightedGraph(adj_list=graph_adj_list) # Perform Dijkstra\'s algorithm shortest_paths = dijkstra(graph, start_node=\'A\') print(f\\"Shortest paths from node \'A\': {shortest_paths}\\") ``` # Code Template Here\'s a code template to get you started: ```python from typing import Dict, List, Tuple, Any import heapq class WeightedGraph: def __init__(self, adj_list: Dict[Any, List[Tuple[Any, float]]]): self.adj_list = adj_list def get_neighbors(self, node: Any) -> List[Tuple[Any, float]]: return self.adj_list.get(node, []) def dijkstra(graph: WeightedGraph, start_node: Any) -> Dict[Any, float]: # Initialize distances distances = {node: float(\'inf\') for node in graph.adj_list} distances[start_node] = 0 # Priority queue for the nodes to visit priority_queue = [(0, start_node)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph.get_neighbors(current_node): distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances # Define a sample weighted graph graph_adj_list = { \'A\': [(\'B\', 1), (\'C\', 4)], \'B\': [(\'A\', 1), (\'C\', 2), (\'D\', 5)], \'C\': [(\'A\', 4), (\'B\', 2), (\'D\', 1)], \'D\': [(\'B\', 5), (\'C\', 1)] } # Create graph object graph = WeightedGraph(adj_list=graph_adj_list) # Perform Dijkstra\'s algorithm shortest_paths = dijkstra(graph, start_node=\'A\') print(f\\"Shortest paths from node \'A\': {shortest_paths}\\") ``` Ensure that your function is well-tested with various graph structures to validate its correctness and performance.","solution":"from typing import Dict, List, Tuple, Any import heapq class WeightedGraph: def __init__(self, adj_list: Dict[Any, List[Tuple[Any, float]]]): self.adj_list = adj_list def get_neighbors(self, node: Any) -> List[Tuple[Any, float]]: return self.adj_list.get(node, []) def dijkstra(graph: WeightedGraph, start_node: Any) -> Dict[Any, float]: # Initialize distances distances = {node: float(\'inf\') for node in graph.adj_list} distances[start_node] = 0 # Priority queue for the nodes to visit priority_queue = [(0, start_node)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph.get_neighbors(current_node): distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"Coding Assessment Question You are tasked with creating a function that generates unique coupon codes for an e-commerce platform. Each coupon must be a fixed length and composed of uppercase letters and digits. Additionally, you must ensure that the generated coupon code is unique and has not been previously issued. # Function Signature ```python def generate_coupon(existing_codes: set, length: int) -> str: ``` # Objective Implement the `generate_coupon` function that: 1. Takes `existing_codes` (a set of previously generated coupon codes) and `length` (an integer specifying the desired length of the coupon code) as parameters. 2. Generates a new coupon code of the specified length that is unique (i.e., not present in the `existing_codes` set). 3. Returns the generated coupon code. # Input/Output Format * **Input**: * `existing_codes` (set): A set of strings representing the previously generated coupon codes. * `length` (int): An integer representing the desired length of the coupon code. * **Output**: * `new_coupon` (str): A string representing the newly generated, unique coupon code. # Constraints * The length of the coupon code must be a positive integer (1 <= length <= 10). * The coupon code should contain only uppercase letters (A-Z) and digits (0-9). * The function must be able to handle the generation while ensuring uniqueness even with a large number of existing coupon codes. # Context The function is part of a backend service for issuing coupons to customers. Uniqueness of coupon codes is critical to prevent fraud and ensure each discount or offer can be redeemed only once. # Performance Requirements * The function should efficiently handle cases where the number of existing codes is large. * Ensure that even with high existing counts, the generation process remains performant. # Implementation Notes * Use the `random` module from Python\'s standard library to generate random characters for the coupon. * Implement a loop to generate a new coupon code until a unique code (not in `existing_codes`) is found. Design and implement the `generate_coupon` function based on the above requirements.","solution":"import random import string def generate_coupon(existing_codes: set, length: int) -> str: Generates a unique coupon code of a given length that is not in the existing_codes set. Parameters: existing_codes (set): A set of previously generated coupon codes. length (int): Desired length of the coupon code. Returns: str: A unique coupon code. if length < 1 or length > 10: raise ValueError(\\"Length must be between 1 and 10\\") characters = string.ascii_uppercase + string.digits while True: new_coupon = \'\'.join(random.choice(characters) for _ in range(length)) if new_coupon not in existing_codes: return new_coupon"},{"question":"# Coding Assessment Question: Feature Engineering with Polynomial Features Context A data science team is working on a machine learning project and exploring the effects of feature engineering on model performance. Polynomial feature expansion is a technique where new features are generated as polynomial combinations of the existing ones. You are tasked with implementing a function that generates polynomial features up to a specified degree. Problem Specification You are given a dataset `features` in the form of a 2D Numpy array where each row represents a different feature vector. You must implement a function to generate polynomial features up to the given degree for the input data. Task 1. **Implement Polynomial Feature Expansion Function**: * Function name: `polynomial_features` * Input: * `features` (np.ndarray): A 2D array of shape ((n, m)) where (n) is the number of samples and (m) is the number of original features. * `degree` (int): The maximum degree of the polynomial features to be generated. * Output: * (np.ndarray): A 2D array of the expanded feature set including all polynomial combinations of shape ((n, new_m)). * Constraints: * `degree` must be a positive integer. * The function should generate higher-dimensional features efficiently and handle the blow-up in the number of features appropriately. Sample Inputs and Outputs ```python features = np.array([[1, 2], [3, 4], [5, 6]]) degree = 2 expanded_features = polynomial_features(features, degree) assert expanded_features.shape == (features.shape[0], (1 + 2 + (2 * (2 - 1) // 2)) * degree) features = np.array([[2, 3], [1, 4]]) degree = 3 expanded_features = polynomial_features(features, degree) assert expanded_features.shape == (features.shape[0], (1 + 2 + (2 * (2 - 1) // 2)) * degree) ``` Example Explanation For a degree of 2 and input features ([[1, 2], [3, 4], [5, 6]]): - The expanded feature set includes: 1 (bias term), x1, x2, x1^2, x2^2, and x1*x2. Performance Requirements * Your solution should be efficient and handle large datasets and high degrees appropriately. * Use appropriate numpy functions to perform feature expansion efficiently.","solution":"import numpy as np from itertools import combinations_with_replacement def polynomial_features(features, degree): Generates polynomial features up to the given degree for the input features. Parameters: - features (np.ndarray): A 2D array of shape (n, m) where n is the number of samples and m is the number of original features. - degree (int): The maximum degree of the polynomial features to be generated. Returns: - np.ndarray: A 2D array with the expanded feature set including all polynomial combinations. if degree < 1: raise ValueError(\\"Degree must be a positive integer.\\") n_samples, n_features = features.shape # Generate the polynomial features new_features = [np.ones(n_samples)] # start with the bias term (x^0 which is 1) for d in range(1, degree + 1): for combo in combinations_with_replacement(range(n_features), d): new_feature = np.prod(features[:, combo], axis=1) new_features.append(new_feature) return np.vstack(new_features).T"},{"question":"# Cylinder Filling Time Calculation Problem Statement You are tasked with calculating the time required to fill a cylindrical container with water using a constant water inflow rate. The container will fill up from the bottom until it reaches the desired volume. The volume ( V ) of the cylinder can be calculated using the formula: [ V = pi times r^2 times h ] where: - ( r ) is the radius of the cylinder’s base in meters. - ( h ) is the height of the cylinder in meters. - (pi) is a mathematical constant approximately equal to 3.14159. The time ( T ) required to fill the cylinder with a desired volume ( V ) can be calculated using: [ T = frac{V}{Q} ] where: - ( Q ) is the flow rate in cubic meters per second (m(^3)/s). Implement a function `filling_time` that adheres to the following signature: ```python def filling_time( radius: float, # radius of the cylinder in meters height: float, # height of the cylinder in meters flow_rate: float # water inflow rate in m^3/s ) -> float: ``` The function should: 1. **Raise a `ValueError`** if `radius`, `height`, or `flow_rate` are non-positive. 2. Compute the volume of the cylinder using the provided formula. 3. Compute and return the filling time rounded to two decimal places. Examples ```python >>> filling_time(1, 2, 0.5) 12.57 >>> filling_time(0.5, 1, 0.02) 39.27 >>> filling_time(3, 4, 1) 113.10 >>> filling_time(2, 5, 0.1) 628.32 >>> filling_time(-1, 2, 0.5) Traceback (most recent call last): ... ValueError: Radius must be positive. >>> filling_time(1, 0, 0.5) Traceback (most recent call last): ... ValueError: Height must be positive. >>> filling_time(1, 2, -0.5) Traceback (most recent call last): ... ValueError: Flow rate must be positive. ``` Ensure proper validation and handling edge cases, and account for typical physical constraints related to cylinder filling scenarios.","solution":"import math def filling_time(radius: float, height: float, flow_rate: float) -> float: if radius <= 0: raise ValueError(\\"Radius must be positive.\\") if height <= 0: raise ValueError(\\"Height must be positive.\\") if flow_rate <= 0: raise ValueError(\\"Flow rate must be positive.\\") volume = math.pi * radius**2 * height # Volume of the cylinder time_to_fill = volume / flow_rate # Time required to fill the cylinder return round(time_to_fill, 2)"},{"question":"# Calendar Event Notification You are tasked with implementing a function in Python that schedules an event and sends a notification at a specified time. # Objective Write a function `schedule_event` that takes an event name, a timestamp of when the event should happen, and a message to be sent as a notification at that time. The function should be able to handle scheduling in real-time effectively and simulate sending a notification. # Function Signature ```python def schedule_event(event_name: str, event_time: str, message: str) -> str: pass ``` # Input - `event_name` (str): The name of the event (e.g., \\"Meeting\\"). - `event_time` (str): The time the event is scheduled to happen in \\"YYYY-MM-DD HH:MM:SS\\" format (e.g., \\"2023-11-01 14:00:00\\"). - `message` (str): The message to be sent as a notification (e.g., \\"Reminder: Team Meeting in 10 minutes\\"). # Output - The function should return a confirmation of the event scheduling or an error message if the scheduling fails. # Constraints - The `event_time` will be a valid future date and time in the \\"YYYY-MM-DD HH:MM:SS\\" format. - The `message` must not be empty. - The function should work optimally to manage multiple event schedules. # Performance - The function needs to handle scheduling and notifications effectively, aiming for O(1) complexity for querying the next event. # Instructions 1. Use the `datetime` module for handling date and time manipulations. 2. Ensure that the function can handle at least 100 scheduling requests per minute. 3. Implement error handling for invalid time format and scheduling conflicts. # Example Scenario Given: ```python event_name = \\"Meeting\\" event_time = \\"2023-11-01 14:00:00\\" message = \\"Reminder: Team Meeting in 10 minutes\\" ``` Expected output: - If the event is scheduled successfully: \\"Event \'Meeting\' scheduled for 2023-11-01 14:00:00\\". - If there\'s an error, return a respective error message like \\"Error: Invalid time format\\". # Notes - Consider using a list or a priority queue to manage scheduled events if multiple events are involved. - Simulate the notification logic (for example, printing the message when the time arrives). ```python import datetime import time from threading import Timer def schedule_event(event_name: str, event_time: str, message: str) -> str: try: event_datetime = datetime.datetime.strptime(event_time, \\"%Y-%m-%d %H:%M:%S\\") current_time = datetime.datetime.now() delay = (event_datetime - current_time).total_seconds() if delay <= 0: return \\"Error: Event time must be in the future.\\" except ValueError: return \\"Error: Invalid time format.\\" def send_notification(): print(f\\"Notification for \'{event_name}\': {message}\\") Timer(delay, send_notification).start() return f\\"Event \'{event_name}\' scheduled for {event_time}\\" ```","solution":"import datetime import time from threading import Timer def schedule_event(event_name: str, event_time: str, message: str) -> str: # Check if the message is empty if not message.strip(): return \\"Error: Message cannot be empty.\\" try: event_datetime = datetime.datetime.strptime(event_time, \\"%Y-%m-%d %H:%M:%S\\") current_time = datetime.datetime.now() delay = (event_datetime - current_time).total_seconds() if delay <= 0: return \\"Error: Event time must be in the future.\\" except ValueError: return \\"Error: Invalid time format.\\" def send_notification(): print(f\\"Notification for \'{event_name}\': {message}\\") Timer(delay, send_notification).start() return f\\"Event \'{event_name}\' scheduled for {event_time}\\""},{"question":"# Fibonacci Sequence Determination Write a function `is_fibonacci` that determines whether a given integer is a number in the Fibonacci sequence. Input - An integer `num` that you need to check if it is a Fibonacci number. Output - A boolean value `True` if the number is in the Fibonacci sequence, otherwise `False`. Constraints - ( -10^{12} leq text{num} leq 10^{12} ) # Example ```python >>> is_fibonacci(0) True >>> is_fibonacci(1) True >>> is_fibonacci(4) False >>> is_fibonacci(8) True >>> is_fibonacci(13) True >>> is_fibonacci(14) False >>> is_fibonacci(6765) True >>> is_fibonacci(-1) False ``` # Notes - The Fibonacci sequence starts with 0 and 1, with each subsequent number being the sum of the previous two. - In solving this problem, consider both positive and negative integers, but note that standard Fibonacci sequences only deal with non-negative integers. - Ensure that your implementation is efficient and handles the large possible input range within the given constraints.","solution":"import math def is_fibonacci(num): Determines if the given integer is a number in the Fibonacci sequence. Args: num (int): The number to check. Returns: bool: True if the number is in the Fibonacci sequence, False otherwise. if num < 0: return False # Check if num is a perfect square of (5*num*num + 4) or (5*num*num - 4) def is_perfect_square(x): s = int(math.sqrt(x)) return s * s == x n1 = 5 * num * num + 4 n2 = 5 * num * num - 4 return is_perfect_square(n1) or is_perfect_square(n2)"},{"question":"# Problem Statement You are given a binary tree where each node contains a digit from 0 to 9 and each root-to-leaf path represents a number. Your task is to find the sum of all the numbers represented by root-to-leaf paths in the tree. Implement the function `sum_root_to_leaf_numbers(root: TreeNode) -> int:` that calculates the desired sum. # Input Format - A binary tree with up to 10^4 nodes. - Each node is an instance of the class `TreeNode` defined as: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None ``` # Output Format - Return an integer which is the sum of all the numbers represented by root-to-leaf paths in the binary tree. # Constraints - Each node\'s value is between 0 and 9 inclusive. - The sum of numbers generated by the paths will not exceed the maximum value of a 32-bit integer. # Example Input ```python # Given the binary tree: # 1 # / # 2 3 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) ``` Output ```python 25 ``` # Detailed Explanation - The binary tree above represents two numbers: - The path 1 -> 2 represents the number 12. - The path 1 -> 3 represents the number 13. - The sum of these numbers is 12 + 13 = 25. # Function Signature ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def sum_root_to_leaf_numbers(root: TreeNode) -> int: pass ``` # Requirements 1. You must traverse the tree efficiently to accumulate the sum. 2. Consider using Depth-First Search (DFS) to explore all root-to-leaf paths. 3. Ensure that your function handles the edge cases of empty trees and single-node trees correctly. Good luck!","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def sum_root_to_leaf_numbers(root: TreeNode) -> int: def dfs(node, current_number): if not node: return 0 current_number = current_number * 10 + node.val if not node.left and not node.right: # if the node is a leaf return current_number # Recursive sum from both subtrees return dfs(node.left, current_number) + dfs(node.right, current_number) return dfs(root, 0)"},{"question":"# Movie Theatre Seat Reservation System **Context**: You are responsible for developing a seat reservation system for a small movie theatre. The theatre has 10 rows, each containing 10 seats. Your task is to implement a system that keeps track of seat reservations and also allows users to cancel their reservations. Each seat can either be reserved or empty. Problem Statement Implement the following functions to manage the seating reservations for the movie theatre: 1. **Initialize the seating arrangement.** 2. **Reserve a seat.** 3. **Cancel a reservation.** 4. **Display the current seating arrangement.** Function Signatures ```python def initialize_seating() -> list[list[str]]: Initializes the seating arrangement for the movie theatre. Returns: list[list[str]]: A 10x10 nested list representing the seating arrangement with each seat initially marked as \'E\' for empty. pass def reserve_seat(seating: list[list[str]], row: int, col: int) -> bool: Reserves a seat at the specified row and column if it is available. Args: seating (list[list[str]]): The current seating arrangement. row (int): The row number where the seat is located (0-9). col (int): The column number where the seat is located (0-9). Returns: bool: True if the seat was successfully reserved, False if the seat was already reserved or if the specified row/col is out of range. pass def cancel_reservation(seating: list[list[str]], row: int, col: int) -> bool: Cancels the reservation of a seat at the specified row and column if it is currently reserved. Args: seating (list[list[str]]): The current seating arrangement. row (int): The row number where the seat is located (0-9). col (int): The column number where the seat is located (0-9). Returns: bool: True if the reservation was successfully cancelled, False if the seat was not reserved or if the specified row/col is out of range. pass def display_seating(seating: list[list[str]]) -> None: Displays the current seating arrangement in a readable format. Args: seating (list[list[str]]): The current seating arrangement. Returns: None pass ``` Constraints - You must initialize the seating with all seats marked as empty (\'E\'). - Reservations should mark the seat as \'R\' for reserved. - Cancellations should revert the seat back to \'E\'. - Display the seating arrangement with clear labels showing which seats are reserved and which are empty. - Ensure the row and column indices are within the valid range (0-9); otherwise, return False for any invalid operations. Example Execution ```python seating = initialize_seating() # Output: A 10x10 nested list with all elements \'E\' success = reserve_seat(seating, 3, 4) # Output: True success = reserve_seat(seating, 3, 4) # Output: False (since the seat is already reserved) success = cancel_reservation(seating, 3, 4) # Output: True success = cancel_reservation(seating, 3, 4) # Output: False (since the seat is already cancelled) display_seating(seating) # Output: Displays the 10x10 seating arrangement showing \'E\' for empty and \'R\' for reserved seats ``` Additional Notes - Incorporate error handling for invalid inputs. - Ensure the seating chart is printed in a user-friendly format.","solution":"def initialize_seating() -> list[list[str]]: Initializes the seating arrangement for the movie theatre. Returns: list[list[str]]: A 10x10 nested list representing the seating arrangement with each seat initially marked as \'E\' for empty. return [[\'E\' for _ in range(10)] for _ in range(10)] def reserve_seat(seating: list[list[str]], row: int, col: int) -> bool: Reserves a seat at the specified row and column if it is available. Args: seating (list[list[str]]): The current seating arrangement. row (int): The row number where the seat is located (0-9). col (int): The column number where the seat is located (0-9). Returns: bool: True if the seat was successfully reserved, False if the seat was already reserved or if the specified row/col is out of range. if row < 0 or row >= 10 or col < 0 or col >= 10 or seating[row][col] == \'R\': return False seating[row][col] = \'R\' return True def cancel_reservation(seating: list[list[str]], row: int, col: int) -> bool: Cancels the reservation of a seat at the specified row and column if it is currently reserved. Args: seating (list[list[str]]): The current seating arrangement. row (int): The row number where the seat is located (0-9). col (int): The column number where the seat is located (0-9). Returns: bool: True if the reservation was successfully cancelled, False if the seat was not reserved or if the specified row/col is out of range. if row < 0 or row >= 10 or col < 0 or col >= 10 or seating[row][col] == \'E\': return False seating[row][col] = \'E\' return True def display_seating(seating: list[list[str]]) -> None: Displays the current seating arrangement in a readable format. Args: seating (list[list[str]]): The current seating arrangement. Returns: None for row in seating: print(\' \'.join(row))"},{"question":"# Image Rotation Scenario You are working on a photo-editing software. One of the features you need to implement is rotating an image represented by a 2D grid of integers. The software should rotate the image 90 degrees clockwise. Task Implement a function `rotate_image(grid)` that: - Takes a 2D list of integers `grid` as input. - Modifies the grid in-place to rotate the image 90 degrees clockwise. - Returns `None`. Function Signature ```python def rotate_image(grid: list[list[int]]) -> None: pass ``` Input Constraints * 1 <= len(grid), len(grid[0]) <= 200 * Each element in the grid is a non-negative integer. Example ```python grid1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_image(grid1) assert grid1 == [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] grid2 = [ [5, 1, 9, 11], [2, 4, 8, 10], [13, 3, 6, 7], [15, 14, 12, 16] ] rotate_image(grid2) assert grid2 == [ [15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11] ] ``` Requirements 1. The grid should be rotated in place without using extra space for another grid. 2. The solution should handle grids of different sizes efficiently within the given constraints. Hint You may consider the technique of transposing the grid and then reversing each row to achieve a 90-degree clockwise rotation.","solution":"def rotate_image(grid: list[list[int]]) -> None: Rotates the image represented by the grid 90 degrees clockwise in-place. n = len(grid) # Transpose the grid for i in range(n): for j in range(i, n): grid[i][j], grid[j][i] = grid[j][i], grid[i][j] # Reverse each row for i in range(n): grid[i].reverse()"},{"question":"# Problem Description Implement a singly linked list with additional operations to reverse the list and merge two sorted lists. Your list should support the following operations: 1. `append(data)`: Adds an element \'data\' to the end of the list. 2. `reverse()`: Reverses the linked list in-place. 3. `merge_sorted(list1, list2)`: Merges two sorted linked lists list1 and list2 into a new sorted linked list. This method should be a static method and return the head of the merged list. 4. `display()`: Prints all the elements in the list. # Function Signatures You need to implement the following methods in the `LinkedList` class: ```python class Node: def __init__(self, data=None): self.data = data self.next = None class LinkedList: def __init__(self): Initializes an empty linked list. def append(self, data): Adds \'data\' to the end of the list. def reverse(self): Reverses the linked list in-place. @staticmethod def merge_sorted(list1, list2): Merges two sorted linked lists list1 and list2. Parameters: - list1: Head node of the first sorted linked list. - list2: Head node of the second sorted linked list. Returns: - Head node of the merged sorted linked list. def display(self): Prints all elements in the list. ``` # Input and Output * `append(data)`: No input returns None. * `reverse()`: No input. Reverses the list in-place. * `merge_sorted(list1, list2)`: Takes two Node instances representing the heads of two sorted linked lists. Returns a Node instance representing the head of the newly merged sorted linked list. * `display()`: No input. Prints list elements. # Constraints * Data can be of any type, but the merging operation assumes numerical data that can be compared. * Ensure efficient handling of edge cases, such as operations on empty lists or lists with one element. # Notes * Do not use any built-in data structures for the linked list operations. * Focus on maintaining the efficiency and correctness of your implementation.","solution":"class Node: def __init__(self, data=None): self.data = data self.next = None class LinkedList: def __init__(self): self.head = None def append(self, data): new_node = Node(data) if not self.head: self.head = new_node else: last = self.head while last.next: last = last.next last.next = new_node def reverse(self): prev = None current = self.head while current: next_node = current.next current.next = prev prev = current current = next_node self.head = prev @staticmethod def merge_sorted(list1, list2): dummy = Node() tail = dummy while list1 and list2: if list1.data <= list2.data: tail.next = list1 list1 = list1.next else: tail.next = list2 list2 = list2.next tail = tail.next if list1: tail.next = list1 elif list2: tail.next = list2 return dummy.next def display(self): current = self.head elements = [] while current: elements.append(current.data) current = current.next print(elements) # Helper function to create linked list from Python list (for testing) def create_linked_list(data_list): ll = LinkedList() for data in data_list: ll.append(data) return ll"},{"question":"# Coding Question: Binary Tree Path Sum You are tasked with developing a feature for a navigation system that interprets data structured as a binary tree. The system should determine if there is any root-to-leaf path in the binary tree such that the sum of the values in the path equals a given target sum. # Requirements: 1. Implement the `has_path_sum(root: Optional[TreeNode], target_sum: int) -> bool` function. 2. The function must return `True` if there is a root-to-leaf path where the sum of the node values equals `target_sum`, otherwise return `False`. 3. You must devise an efficient solution while considering the depth and breadth of the binary tree. # Input: * `root`: An optional reference to the root node of the binary tree. Each node has an integer value. * `target_sum`: An integer representing the target sum to check against root-to-leaf paths. # Output: * A Boolean value (`True` or `False`). # Constraints: * The binary tree can contain negative numbers. * The structure of the tree is arbitrary but guaranteed to be a valid binary tree. # Performance Requirements: * Aim for a time complexity of O(N), where N is the number of nodes in the binary tree. * The solution should not use excessive additional memory. # Function Signature: ```python from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def has_path_sum(root: Optional[TreeNode], target_sum: int) -> bool: pass ``` # Example: ```python # Example 1 # 5 # / # 4 8 # / / #11 13 4 #/ #7 2 1 root = TreeNode(5) root.left = TreeNode(4) root.right = TreeNode(8) root.left.left = TreeNode(11) root.left.left.left = TreeNode(7) root.left.left.right = TreeNode(2) root.right.left = TreeNode(13) root.right.right = TreeNode(4) root.right.right.right = TreeNode(1) assert has_path_sum(root, 22) == True # Expected Path Sum (5->4->11->2) # Example 2 # 1 # / # 2 3 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) assert has_path_sum(root, 5) == False # No Path Sum equals 5 ``` # Additional Notes: * Consider edge cases such as an empty tree or trees where all nodes are on one side. * Test your function thoroughly to ensure it handles various tree structures and target sums efficiently.","solution":"from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def has_path_sum(root: Optional[TreeNode], target_sum: int) -> bool: if not root: return False # If we reached a leaf node if not root.left and not root.right: return root.val == target_sum # Otherwise check both subtrees with the reduced target_sum return (has_path_sum(root.left, target_sum - root.val) or has_path_sum(root.right, target_sum - root.val))"},{"question":"# Coding Assessment Question Scenario: Circular Array Rotation You have been given a task to manipulate a list of integers by rotating its elements. The rotation is circular, meaning that after reaching the end of the list, the rotation continues from the beginning of the list. Task Implement a function `circular_array_rotation(arr, k)` that performs a circular rotation on the array `arr` by `k` positions to the right. Function Signature ```python def circular_array_rotation(arr: List[int], k: int) -> List[int]: Rotates the input array circularly by k positions to the right. Parameters: arr (List[int]): A list of integers to rotate. k (int): The number of positions to rotate the array. Returns: List[int]: The rotated list of integers. ``` Input - `arr`: A list of integers of size N (1 <= N <= 10^5) - `k`: A non-negative integer representing the number of positions to rotate the array (0 <= k <= 10^9) Output - A list of integers, rotated circularly to the right by `k` positions. Constraints - The function should be efficient and handle large values of N and k. - Consider edge cases such as arrays with a single element or when `k` is zero. Example ```python from typing import List # Example function call arr = [1, 2, 3, 4, 5] k = 2 rotated_arr = circular_array_rotation(arr, k) print(rotated_arr) # Output: [4, 5, 1, 2, 3] arr = [7, 8, 9] k = 1 rotated_arr = circular_array_rotation(arr, k) print(rotated_arr) # Output: [9, 7, 8] ``` Guidelines - Ensure that the implementation efficiently handles large inputs and constraints. - Aim for an optimal solution that minimizes redundant operations. - Consider using modular arithmetic to handle the rotations. - Write clean and readable code, and include any necessary helper functions. - Test your implementation with various test cases to ensure correctness.","solution":"from typing import List def circular_array_rotation(arr: List[int], k: int) -> List[int]: Rotates the input array circularly by k positions to the right. Parameters: arr (List[int]): A list of integers to rotate. k (int): The number of positions to rotate the array. Returns: List[int]: The rotated list of integers. if not arr: return arr n = len(arr) k = k % n # To handle cases where k is larger than the array size return arr[-k:] + arr[:-k]"},{"question":"# Problem Statement You have been given a list of integers representing the scores of students in a class. Your task is to implement a function `find_kth_highest`, which returns the k-th highest score in the list. If `k` is greater than the length of the list, the function should return `None`. # Function Signature ```python def find_kth_highest(scores: List[int], k: int) -> int: ``` # Requirements 1. Implement the `find_kth_highest` function that takes in a list of integers `scores` and an integer `k`. 2. The function should return the k-th highest score in the list. 3. If `k` is greater than the number of scores in the list, return `None`. # Input/Output Format * **Input**: - `scores`: A list of integers, representing scores. Example: `[10, 20, 20, 15, 30, 50]` - `k`: An integer representing the k-th position. Example: `3` * **Output**: - The k-th highest score as an integer, or `None` if `k` is greater than the number of scores. # Constraints - The provided list may contain duplicate values. - The list can have up to `10^5` elements. - The integer values in the list range from `-10^6` to `10^6`. - `k` is a positive integer. # Example ```python scores = [10, 20, 20, 15, 30, 50] k = 3 result = find_kth_highest(scores, k) # Output: 20 scores = [80, 70, 90, 60, 60] k = 7 result = find_kth_highest(scores, k) # Output: None scores = [5, 5, 5, 5, 5] k = 1 result = find_kth_highest(scores, k) # Output: 5 ``` # Additional Notes - Consider using efficient algorithms to handle large input sizes, such as sorting or using a heap. - Be mindful of edge cases such as an empty list, and `k` values that exceed the list length. - The function should aim for a reasonable time complexity, preferably O(n log n) or better for typical cases.","solution":"def find_kth_highest(scores, k): Returns the k-th highest score in the list of scores. If k is greater than the number of scores in the list, return None. :param scores: List of integers representing scores. :param k: The k-th highest position to find. :return: The k-th highest score, or None if k is out of bounds. if k > len(scores): return None # Sort the scores in descending order sorted_scores = sorted(scores, reverse=True) # Find the k-th highest score return sorted_scores[k-1] if k <= len(sorted_scores) else None"},{"question":"# Coding Assessment Question **Problem Statement**: Implement a function to check if a given arithmetic expression consisting of different types of parentheses `()`, `[]`, and `{}` is balanced. A balanced expression is one in which every opening parenthesis has a corresponding closing parenthesis and the pairs are properly nested. **Function Signature**: ```python def is_balanced(expression: str) -> bool: pass ``` **Description**: - Write a function `is_balanced` that takes a string `expression` as input and returns `True` if the parentheses in the expression are balanced, and `False` otherwise. **Input**: - A single string `expression` consisting of characters from `()`, `[]`, `{}`, and any lower-case letters and digits `0-9`. **Output**: - A boolean value. `True` if the expression is balanced; `False` otherwise. **Constraints**: - The length of the string `expression` will be between `1` and `1000`. **Performance Requirements**: - Ensure that the solution efficiently handles strings up to the maximum length constraint. - Aim for linear time complexity in the implementation. **Example**: ```python assert is_balanced(\\"(a+b)[c*d]{5g+h}\\") == True assert is_balanced(\\"{[a+b]*(c+d)}\\") == True assert is_balanced(\\"[a+b]*(c+d)\\") == True assert is_balanced(\\"[(a+b)]\\") == True assert is_balanced(\\"(a+b))\\") == False assert is_balanced(\\"[(a+b]\\") == False assert is_balanced(\\"{a+b)*(c+d)\\") == False assert is_balanced(\\"{a+[b*(c+2}\\") == False ``` **Explanation**: - In the expression \\"(a+b)[c*d]{5g+h}\\", every opening parenthesis has a matching closing parenthesis and they are properly nested. - In the expression \\"(a+b))\\", there is an extra closing parenthesis making it unbalanced. - In the expression \\"[(a+b]\\", the square bracket that started is not properly closed, making it unbalanced. **Edge Cases to Consider**: - Ensure that single pairs like \\"()\\", \\"[]\\", and \\"{}\\" return `True`. - Consider the function\'s behavior with an empty string input. - String with no parentheses at all should be considered balanced (return `True`). - Check deep nesting and interleaving of different types of parentheses.","solution":"def is_balanced(expression: str) -> bool: Check if the parentheses in the given expression are balanced. Args: expression (str): The string containing the expression with parentheses. Returns: bool: True if the expression is balanced, False otherwise. stack = [] matching_parenthesis = {\')\': \'(\', \']\': \'[\', \'}\': \'{\'} for char in expression: if char in matching_parenthesis.values(): stack.append(char) elif char in matching_parenthesis: if not stack or stack[-1] != matching_parenthesis[char]: return False stack.pop() return len(stack) == 0"},{"question":"# Problem Description You are working as a software developer for a company that handles text processing for various clients. Your task is to develop a function that replaces all instances of a specified word in a given string with another word, and ensures that the replacement is case-insensitive. Additionally, the function should preserve the original case of the replaced word in the text (i.e., the case of the original word should be retained in the replacement). # Task Write a function `replace_word_preserve_case` which: 1. Takes an input string, a word to replace, and the replacement word. 2. Replaces all instances of the specified word in the string with the replacement word in a case-insensitive manner. 3. Preserves the case of the original word in the text. # Function Signature ```python def replace_word_preserve_case(text: str, word_to_replace: str, replacement_word: str) -> str: # Your implementation here ``` # Input - `text`: A string representing the input text. - `word_to_replace`: A string representing the word that needs to be replaced (case-insensitive). - `replacement_word`: A string representing the word to use as the replacement. # Output - Returns the modified string with the specified word replaced and original case preserved. # Example Usage ```python # Replace word with case preservation output_text = replace_word_preserve_case(\\"This is a sample Sample text.\\", \\"sample\\", \\"example\\") print(output_text) # Output: \\"This is a example Example text.\\" ``` # Constraints 1. The input string can be of any length from 1 to 10^6 characters. 2. The words to replace and the replacement words do not contain spaces or punctuation. 3. Ensure the function handles edge cases, such as the input string being empty, or the word to replace not being found in the text. # Performance Requirements - Your implementation should be optimized for handling large text inputs, ensuring reasonable performance even with maximum constraints. # Notes - The function should handle different forms of the word to replace (e.g., \\"sample\\", \\"Sample\\", \\"SAMPLE\\") and replace them while keeping the original case format of each word.","solution":"import re def replace_word_preserve_case(text: str, word_to_replace: str, replacement_word: str) -> str: # Define a helper function to replace keeping original case def replace_with_case(match): matched_text = match.group() if matched_text.islower(): return replacement_word.lower() elif matched_text.isupper(): return replacement_word.upper() elif matched_text.istitle(): return replacement_word.capitalize() else: return replacement_word # Use re.sub with a case-insensitive pattern pattern = re.compile(re.escape(word_to_replace), re.IGNORECASE) return pattern.sub(replace_with_case, text)"},{"question":"# Maze Shortest Path Implement a function to find the shortest path in a binary maze from a given start point to a destination point. The maze is represented by a 2D list of integers, where 1 represents a walkable path, and 0 represents an obstacle. Your task is to write a function `shortest_path` that takes the 2D maze, a start point, and an end point, and returns the length of the shortest path in terms of the number of steps. If no path exists, return -1. # Function Signature: ```python def shortest_path(maze: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int: ``` # Input: - `maze`: A 2D list of integers where each element is either 1 (walkable) or 0 (obstacle). The maze dimensions are (n times m). - `start`: A tuple of two integers representing the starting coordinates (x, y). - `end`: A tuple of two integers representing the destination coordinates (x, y). # Output: - An integer representing the length of the shortest path from `start` to `end`. If no such path exists, return -1. # Example: ```python maze = [[1, 0, 0, 0, 0], [1, 1, 0, 1, 1], [0, 1, 0, 1, 0], [1, 1, 1, 1, 0], [0, 0, 0, 1, 1]] start = (0, 0) end = (4, 4) print(shortest_path(maze, start, end)) # Output: 8 ``` # Constraints: - The dimensions of the maze (n) and (m) are such that (1 leq n, m leq 1000). - The start and end points will always be within the bounds of the maze. - The start and end points will always be walkable (i.e., they will always be 1). # Notes: - You can move up, down, left, or right but not diagonally. - Consider using a shortest-path algorithm like Breadth-First Search (BFS) to solve this problem. # Hints: - Utilize a queue to keep track of the current path length and positions. - Maintain a set to keep track of visited positions to avoid cycles in the path.","solution":"from typing import List, Tuple from collections import deque def shortest_path(maze: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int: def is_valid(x, y): return 0 <= x < len(maze) and 0 <= y < len(maze[0]) and maze[x][y] == 1 if start == end: return 0 rows, cols = len(maze), len(maze[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # up, down, left, right queue = deque([(start[0], start[1], 0)]) # (x, y, distance) visited = set() while queue: x, y, dist = queue.popleft() if (x, y) in visited: continue visited.add((x, y)) if (x, y) == end: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: queue.append((nx, ny, dist + 1)) return -1 # no path found"},{"question":"# Context: You are given a string consisting of lowercase alphabets and you need to determine if it can be transformed into a valid palindrome by rearranging its characters and possibly removing one character. # Task: Implement a function `can_form_palindrome(s: str) -> bool` that checks if it is possible to rearrange the characters in the given string to form a palindrome by removing at most one character. # Specifications: - **Input**: A single string `s` containing only lowercase alphabets, with length (1 leq |s| leq 10^5). - **Output**: A boolean value `True` if it is possible to rearrange `s` into a palindrome by removing at most one character, and `False` otherwise. - **Constraints**: - The string can contain repeated characters. - The function should be optimized to run efficiently for large input sizes. # Implementation: - **Function**: ```python def can_form_palindrome(s: str) -> bool: pass ``` - Be sure to handle common edge cases such as strings of length 1 or strings that are already palindromes. - Ensure your solution handles larger inputs efficiently. # Example: Input: ```python s = \\"racecar\\" ``` Output: ```python True ``` In this example, \\"racecar\\" is already a palindrome. Input: ```python s = \\"abca\\" ``` Output: ```python True ``` In this example, by removing the character \'c\', the string \\"aba\\" becomes a palindrome. Input: ```python s = \\"abc\\" ``` Output: ```python False ``` In this example, no single character removal can make the string a palindrome.","solution":"def can_form_palindrome(s: str) -> bool: from collections import Counter # Count frequency of each character char_count = Counter(s) # Count characters with odd occurrences odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # For a string to be rearranged into a palindrome: # If all characters have even occurrence or only one character has odd occurrence, it\'s possible # If one more than the above cases is allowed, removing one odd-count character is allowed return odd_count <= 1 or (len(s) > 1 and odd_count == 2)"},{"question":"# Coding Assessment Question Valid Triangle Strip You have been tasked with creating a function that verifies sections of a triangle strip. A triangle strip is a series of vertices in 2D space such that every consecutive triplet of vertices forms a triangle. Your goal is to determine if each triangle in the strip is valid (i.e., the area of the triangle is non-zero). **Task**: Write a Python function `valid_triangle_strip(vertices: List[Tuple[int, int]]) -> List[bool]` that accepts a list of vertices in 2D space, where each vertex is represented as a tuple of two integers `(x, y)`. The function should return a list of booleans where each boolean corresponds to a triangle in the strip, indicating whether the triangle is valid (True) or not (False). **Input Constraints**: - The list `vertices` may have between 3 and 1000 vertices. - Each vertex will have coordinates between -10^3 and 10^3. **Performance Requirement**: Your solution should efficiently handle the provided constraints and aim for clear and concise code. Example: ```python def valid_triangle_strip(vertices: List[Tuple[int, int]]) -> List[bool]: pass # Example Usage assert valid_triangle_strip([(0, 0), (1, 0), (0, 1), (2, 1), (1, 2)]) == [True, True, True] assert valid_triangle_strip([(0, 0), (1, 1), (2, 2), (3, 3)]) == [False, False] ``` Explanation: In the first example: - The triangles `(0,0)`, `(1,0)`, `(0,1)` and `(1,0)`, `(0,1)`, `(2,1)` and `(0,1)`, `(2,1)`, `(1,2)` are all valid because they form triangles with non-zero area. In the second example: - The triangles `(0, 0)`, `(1, 1)`, `(2, 2)` and `(1, 1)`, `(2, 2)`, `(3, 3)` are not valid because their vertices are collinear, resulting in triangles with zero area.","solution":"from typing import List, Tuple def valid_triangle_strip(vertices: List[Tuple[int, int]]) -> List[bool]: def is_collinear(p1, p2, p3): # Uses the area formula for three points to check for collinearity # If the area is 0, the points are collinear x1, y1 = p1 x2, y2 = p2 x3, y3 = p3 return (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) == 0 result = [] for i in range(2, len(vertices)): if is_collinear(vertices[i-2], vertices[i-1], vertices[i]): result.append(False) else: result.append(True) return result"},{"question":"**Question**: Implement a function to find the kth largest element in an unsorted array using a priority queue (min-heap) to achieve efficient performance. # Details - **Input**: - An integer array `nums` (the array of numbers). - An integer `k` (the position of the largest element to find, 1-based). - **Output**: - An integer representing the kth largest element in the array. - **Constraints**: - `1 <= len(nums) <= 10^5` - `-10^4 <= nums[i] <= 10^4` - `1 <= k <= len(nums)` # Function Signature ```python def kth_largest_element(nums: list, k: int) -> int: pass ``` # Example ```python def test_kth_largest_element(): assert kth_largest_element([3, 2, 1, 5, 6, 4], 2) == 5 assert kth_largest_element([3, 2, 3, 1, 2, 4, 5, 5, 6], 4) == 4 assert kth_largest_element([1, 1, 1, 1, 1], 1) == 1 assert kth_largest_element([7, 10, 4, 3, 20, 15], 3) == 10 assert kth_largest_element([5, -10, 3, -8, 12, 14], 4) == 3 print(\\"All test cases pass\\") test_kth_largest_element() ``` **Requirements**: - Implement the solution using a priority queue for efficient performance. - Ensure the implementation handles the constraints efficiently, particularly for large arrays.","solution":"import heapq def kth_largest_element(nums: list, k: int) -> int: Returns the kth largest element in the array. # Create a min-heap with the first k elements min_heap = nums[:k] heapq.heapify(min_heap) # Process the remaining elements for num in nums[k:]: if num > min_heap[0]: heapq.heappushpop(min_heap, num) # The root of the heap is the kth largest element return min_heap[0]"},{"question":"# Context You are developing an inventory management system that tracks the available stock of different items in a warehouse. Your system should allow items to be added, quantities to be updated, and information about the current stock to be retrieved. # Task Implement a class `Inventory` to manage item quantities. The system should support the following operations: 1. **Add an item**: Given an item name and its initial quantity, add it to the inventory. If the item already exists, increase its quantity by the given amount. 2. **Remove a quantity of an item**: Given an item name and a quantity, decrease its quantity by the given amount. If the quantity to remove is greater than the current quantity, set the quantity to zero. 3. **Get the current quantity of an item**: Given an item name, retrieve the current quantity of the item in the inventory. Items are represented as strings, and quantities are non-negative integers. Implement methods with the following signatures: ```python class Inventory: def add_item(self, item: str, quantity: int) -> None: pass def remove_item(self, item: str, quantity: int) -> None: pass def get_quantity(self, item: str) -> int: pass ``` # Requirements 1. Your methods should have an average-case time complexity of O(1) for both adding items and retrieving quantities. 2. Handle edge cases such as adding items with zero quantity, removing quantities greater than the available stock, and querying for non-existent items gracefully. # Constraints * Item names are case-sensitive strings with a maximum length of 50 characters. * Quantities are non-negative integers within the range [0, 10^6]. * The class should handle a maximum of 10^5 different items. # Example ```python inventory = Inventory() inventory.add_item(\\"Widget\\", 10) inventory.add_item(\\"Gadget\\", 5) inventory.remove_item(\\"Widget\\", 3) print(inventory.get_quantity(\\"Widget\\")) # Output: 7 print(inventory.get_quantity(\\"Gadget\\")) # Output: 5 inventory.remove_item(\\"Gadget\\", 10) print(inventory.get_quantity(\\"Gadget\\")) # Output: 0 ``` # Submission Submit a class `Inventory` implemented in Python, with the specified methods managing the item quantities as described.","solution":"class Inventory: def __init__(self): self.inventory = {} def add_item(self, item: str, quantity: int) -> None: if item not in self.inventory: self.inventory[item] = quantity else: self.inventory[item] += quantity def remove_item(self, item: str, quantity: int) -> None: if item in self.inventory: self.inventory[item] = max(0, self.inventory[item] - quantity) def get_quantity(self, item: str) -> int: return self.inventory.get(item, 0)"},{"question":"# Problem Statement You are tasked with writing a function that calculates the hypotenuse of a right triangle given the lengths of the other two sides. The function should handle input validation and appropriate error handling. # Function Signature ```python def calculate_hypotenuse(side1: float, side2: float) -> float: pass ``` # Input * `side1` (float) - Length of the first side in meters (must be positive). * `side2` (float) - Length of the second side in meters (must be positive). # Output * Returns the length of the hypotenuse (float) in meters. # Constraints * Both inputs must be positive non-zero values. * The function should raise a `ValueError` with a clear error message if any input is invalid. # Example ```python >>> calculate_hypotenuse(3, 4) 5.0 >>> calculate_hypotenuse(6, 8) 10.0 ``` # Additional Requirements * Use the Pythagorean theorem (`c = sqrt(a² + b²)`). # Guidelines 1. Implement the formula correctly using the `math` library. 2. Ensure to validate the inputs and handle errors gracefully. 3. Test your function with various inputs including edge cases.","solution":"import math def calculate_hypotenuse(side1: float, side2: float) -> float: Calculates the hypotenuse of a right triangle given the lengths of the other two sides. :param side1: Length of the first side in meters (must be positive). :param side2: Length of the second side in meters (must be positive). :return: Length of the hypotenuse in meters. :raises ValueError: If any input is not a positive non-zero value. if side1 <= 0 or side2 <= 0: raise ValueError(\\"Both sides must be positive non-zero values\\") hypotenuse = math.sqrt(side1 ** 2 + side2 ** 2) return hypotenuse"},{"question":"# Coding Assessment Question: Maximum Circular Subarray Sum **Objective:** Write a function, `max_circular_subarray_sum(arr: List[int]) -> int`, to find the maximum sum of a circular subarray. A circular subarray means the end of the array wraps around to the start. **Input:** - A list of integers `arr` where (1 leq len(arr) leq 10,000) and each integer (-30,000 leq arr[i] leq 30,000). **Output:** - An integer representing the maximum circular subarray sum. **Constraints:** - Use efficient algorithms to handle time complexity within acceptable limits. - Properly account for both standard and circular subarray scenarios. **Performance Requirements:** - Ensure the solution handles both small and large arrays effectively. - Optimize to avoid excessive space utilization and manage computational complexity. **Scenario/Context:** Consider developing features for a data analysis tool that evaluates sequences for financial data analysts. They need reliable and efficient methods to compute significant metrics like the maximum potential profit/loss in circularly linked financial records. **Function Signature:** ```python from typing import List def max_circular_subarray_sum(arr: List[int]) -> int: pass ``` **Example:** ```python # Example 1 print(max_circular_subarray_sum([5, -3, 5])) # Expected output: 10 # Example 2 print(max_circular_subarray_sum([1, -2, 3, -2])) # Expected output: 3 # Example 3 print(max_circular_subarray_sum([3, -1, 2, -1])) # Expected output: 4 # Example 4 print(max_circular_subarray_sum([3, -2, 2, -3])) # Expected output: 3 # Example 5 print(max_circular_subarray_sum([-2, -3, -1])) # Expected output: -1 ``` **Explanation:** For the input `[5, -3, 5]`, the maximum circular subarray sum is `10`, which includes the first `5` and the last `5` in the array. For the input `[1, -2, 3, -2]`, the subarray `[3]` gives the maximum sum of `3`. Your task is to generalize this approach for any array while considering circular subarrays.","solution":"from typing import List def max_subarray_sum(arr: List[int]) -> int: max_ending_here = max_so_far = arr[0] for x in arr[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far def min_subarray_sum(arr: List[int]) -> int: min_ending_here = min_so_far = arr[0] for x in arr[1:]: min_ending_here = min(x, min_ending_here + x) min_so_far = min(min_so_far, min_ending_here) return min_so_far def max_circular_subarray_sum(arr: List[int]) -> int: max_kadane = max_subarray_sum(arr) total_sum = sum(arr) min_kadane = min_subarray_sum(arr) if max_kadane < 0: return max_kadane return max(max_kadane, total_sum - min_kadane)"},{"question":"# Coding Assessment Question: JSON Data Summary You are given a list of JSON objects. Each JSON object represents a record with various attributes. Your task is to summarize the data by calculating the average, minimum, and maximum values for a specified numeric attribute across all records. Objective: Write a Python function `summarize_json_data` that: 1. Accepts a list of JSON objects and a string representing the attribute to summarize. 2. Computes the average, minimum, and maximum values for the specified attribute. 3. Returns a dictionary with keys `\'average\'`, `\'min\'`, and `\'max\'`, corresponding to the calculated values. Function Signature: ```python def summarize_json_data(records: list[dict], attribute: str) -> dict: pass ``` Input: * `records`: a list of JSON objects (dictionaries in Python). * `attribute`: a string specifying the name of the numeric attribute to summarize. Output: * `dict`: a dictionary with keys `\'average\'`, `\'min\'`, and `\'max\'`. Examples: **Example 1:** ```python records = [ {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"score\\": 85.5}, {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"score\\": 90.0}, {\\"name\\": \\"Charlie\\", \\"age\\": 35, \\"score\\": 88.0} ] attribute = \\"score\\" result = summarize_json_data(records, attribute) print(result) # Expected output: {\'average\': 87.83333333333333, \'min\': 85.5, \'max\': 90.0} ``` **Example 2:** ```python records = [ {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"score\\": 85.5}, {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"score\\": 90.0}, {\\"name\\": \\"Charlie\\", \\"age\\": 35, \\"score\\": 88.0} ] attribute = \\"age\\" result = summarize_json_data(records, attribute) print(result) # Expected output: {\'average\': 30.0, \'min\': 25, \'max\': 35} ``` Constraints: * Each JSON object is guaranteed to contain the specified attribute. * Each value for the specified attribute is a numeric type (either integer or float). * The list of records will contain at least one record. * The names of the keys in the JSON objects do not contain spaces or special characters. Notes: Consider edge cases such as all records having the same value for the specified attribute and ensure correct computation of average for both integer and floating-point numbers.","solution":"def summarize_json_data(records, attribute): Summarizes numeric data for a given attribute from a list of JSON objects. Args: records (list of dict): List of JSON objects. attribute (str): The attribute to summarize. Returns: dict: Dictionary containing \'average\', \'min\', and \'max\' for the specified attribute. attribute_values = [record[attribute] for record in records] avg_value = sum(attribute_values) / len(attribute_values) min_value = min(attribute_values) max_value = max(attribute_values) return { \'average\': avg_value, \'min\': min_value, \'max\': max_value }"},{"question":"# Graph Traversal Path Finding Implement a class that will find all possible paths between two nodes in a directed acyclic graph (DAG). Your class should support the following operations: 1. **Add Edge**: Add a directed edge between two nodes in the graph. 2. **Find Paths**: Find all possible paths between a given start node and an end node. **Objective**: Implement these operations to manage and search through the graph: 1. **Add Edge**: - Implement the method `add_edge(self, u, v)` in the `Graph` class. - This method should add a directed edge from node `u` to node `v`. 2. **Find Paths**: - Implement the method `find_paths(self, start, end)` in the `Graph` class. - This method should return a list of all possible paths from `start` to `end`, where each path is represented as a list of nodes. **Detailed Instructions**: 1. **Add Edge Operation** - The `add_edge(self, u, v)` method will take two integers, `u` and `v`, representing the nodes. - It should update the graph to include the directed edge from `u` to `v`. 2. **Find Paths Operation** - The `find_paths(self, start, end)` method will take two integers, `start` and `end`, representing the start and end nodes. - It should find and return all possible paths from `start` to `end` in a list of lists, where each sublist represents a path. Here is the structure of the `Graph` class (already provided): ```python class Graph: def __init__(self): self.adj_list = {} def add_edge(self, u, v): if u not in self.adj_list: self.adj_list[u] = [] self.adj_list[u].append(v) def find_paths(self, start, end): all_paths = [] self._find_paths_recursive(start, end, [], all_paths) return all_paths def _find_paths_recursive(self, current, end, path, all_paths): path.append(current) if current == end: all_paths.append(path.copy()) elif current in self.adj_list: for neighbor in self.adj_list[current]: self._find_paths_recursive(neighbor, end, path, all_paths) path.pop() ``` **Examples**: ```python # Adding Edges and Finding Paths graph = Graph() graph.add_edge(1, 2) graph.add_edge(1, 3) graph.add_edge(2, 4) graph.add_edge(3, 4) assert graph.find_paths(1, 4) == [[1, 2, 4], [1, 3, 4]] graph.add_edge(2, 3) assert graph.find_paths(1, 4) == [[1, 2, 4], [1, 2, 3, 4], [1, 3, 4]] ``` **Constraints**: 1. Assume that the node values are non-negative integers. 2. The graph is directed and acyclic. 3. The add_edge and find_paths operations should handle cyclic checks within their logic to prevent infinite loops. By conforming to these guidelines, ensure the new question aligns with the overall theme and complexity of the provided samples.","solution":"class Graph: def __init__(self): self.adj_list = {} def add_edge(self, u, v): if u not in self.adj_list: self.adj_list[u] = [] self.adj_list[u].append(v) def find_paths(self, start, end): all_paths = [] self._find_paths_recursive(start, end, [], all_paths) return all_paths def _find_paths_recursive(self, current, end, path, all_paths): path.append(current) if current == end: all_paths.append(path.copy()) elif current in self.adj_list: for neighbor in self.adj_list[current]: self._find_paths_recursive(neighbor, end, path, all_paths) path.pop()"},{"question":"# Problem Statement: You are given an array of integers and a target sum. Your task is to count the number of distinct pairs `(i, j)` in the array such that `i` and `j` are indices and `arr[i] + arr[j]` is equal to the target sum. The pairs `(i, j)` and `(j, i)` are considered the same and should be counted once. Build a function `count_pairs(arr: List[int], target_sum: int) -> int` which computes this number of distinct pairs for a given target sum. # Input Format: - `arr` (list of integers): The array of integers (1 ≤ len(arr) ≤ 100000, -1000000 ≤ arr[i] ≤ 1000000). - `target_sum` (integer): The target sum to which the pairs\' elements should add up (-2000000 ≤ target_sum ≤ 2000000). # Output Format: - Return an integer representing the count of distinct pairs whose sum equals the target sum. # Example: ```python >>> count_pairs([1, 5, 7, -1, 5], 6) 2 >>> count_pairs([1, 1, 1, 1], 2) 1 >>> count_pairs([1, 2, 3, 4, 5], 9) 1 ``` # Constraints: - Ensure your solution is efficient and handles the maximum input sizes within reasonable time limits. - Consider edge cases such as the smallest and largest possible values for array elements and target sum. - Optimize the algorithm to avoid excessive time complexity. # Implementation Details: - Use a dictionary to keep track of the occurrences of each element. - Iterate through the array and for each element, check if the complement (target_sum - current element) exists in the dictionary. - Count valid pairs ensuring that each pair is only counted once.","solution":"def count_pairs(arr, target_sum): Counts the number of distinct pairs (i, j) such that arr[i] + arr[j] is equal to target_sum. The pairs (i, j) and (j, i) are considered the same and counted once. :param arr: List[int] - The array of integers :param target_sum: int - The target sum for the pairs :return: int - Number of distinct pairs whose sum equals the target sum count = 0 seen = set() pairs = set() for num in arr: complement = target_sum - num if complement in seen: pair = tuple(sorted((num, complement))) if pair not in pairs: pairs.add(pair) count += 1 seen.add(num) return count"},{"question":"# Coding Assessment Question: Implement K-Means Clustering You are required to implement a K-Means Clustering algorithm. The model must be capable of training on a given dataset and assigning clusters to the given data points. Your implementation should leverage the principles discussed in the clustering algorithms. Task Requirements: 1. **Function 1**: Initialize centroids. - **Function Name**: `initialize_centroids` - **Input**: Data Points (`list of list of float`), Number of Clusters (`int`) - **Output**: List of initialized centroids (`list of list of float`). 2. **Function 2**: Assign clusters to data points. - **Function Name**: `assign_clusters` - **Input**: Data Points (`list of list of float`), Centroids (`list of list of float`) - **Output**: List of assigned cluster labels for each data point (`list of int`). 3. **Function 3**: Update centroid positions. - **Function Name**: `update_centroids` - **Input**: Data Points (`list of list of float`), Cluster Labels (`list of int`), Number of Clusters (`int`) - **Output**: Updated centroid positions (`list of list of float`). 4. **Function 4**: Calculate the SSE (Sum of Squared Errors). - **Function Name**: `calculate_sse` - **Input**: Data Points (`list of list of float`), Centroids (`list of list of float`), Cluster Labels (`list of int`) - **Output**: SSE value (`float`). 5. **Function 5**: Train the K-Means clustering model. - **Function Name**: `train_kmeans` - **Input**: Data Points (`list of list of float`), Number of Clusters (`int`), Maximum Iterations (`int`) - **Output**: Final centroids (`list of list of float`), Final cluster labels (`list of int`), SSE (`float`). 6. **Function 6**: Predict the cluster for new data points. - **Function Name**: `predict_clusters` - **Input**: New Data Points (`list of list of float`), Final Centroids (`list of list of float`) - **Output**: Predicted cluster labels (`list of int`). Constraints: 1. Assume the input data points are numeric. 2. Implement error handling for invalid inputs. 3. Optimize your solution for readability and performance. Example: ```python # Example 1. Initializing centroids data_points = [[1.0, 2.0], [3.0, 4.0], [5.0, 6.0], [7.0, 8.0]] centroids = initialize_centroids(data_points, number_of_clusters=2) # Example 2. Assigning clusters cluster_labels = assign_clusters(data_points, centroids) # Example 3. Updating centroids updated_centroids = update_centroids(data_points, cluster_labels, number_of_clusters=2) # Example 4. Calculating SSE sse = calculate_sse(data_points, updated_centroids, cluster_labels) # Example 5. Training K-Means clustering model final_centroids, final_cluster_labels, final_sse = train_kmeans(data_points, number_of_clusters=2, max_iterations=100) # Example 6. Predicting clusters for new data points new_data_points = [[2.0, 3.0], [6.0, 7.0]] predicted_labels = predict_clusters(new_data_points, final_centroids) ``` You are allowed to use any standard libraries in Python to accomplish your task.","solution":"import random import numpy as np def initialize_centroids(data_points, num_clusters): Randomly initialize centroids by selecting random points from the data_points. return random.sample(data_points, num_clusters) def assign_clusters(data_points, centroids): Assign each data point to the nearest centroid, based on Euclidean distance. cluster_labels = [] for point in data_points: distances = [np.linalg.norm(np.array(point) - np.array(centroid)) for centroid in centroids] cluster_labels.append(np.argmin(distances)) return cluster_labels def update_centroids(data_points, cluster_labels, num_clusters): Update centroids by calculating the mean of all data points assigned to each centroid. new_centroids = [] for k in range(num_clusters): cluster_points = [point for i, point in enumerate(data_points) if cluster_labels[i] == k] if cluster_points: new_centroids.append(np.mean(cluster_points, axis=0).tolist()) else: # If a cluster ended up with no points, reinitialize its centroid by picking a random point new_centroids.append(random.choice(data_points)) return new_centroids def calculate_sse(data_points, centroids, cluster_labels): Calculate the Sum of Squared Errors (SSE) for the given clustering. sse = 0.0 for i, point in enumerate(data_points): centroid = centroids[cluster_labels[i]] sse += np.linalg.norm(np.array(point) - np.array(centroid)) ** 2 return sse def train_kmeans(data_points, number_of_clusters, max_iterations): Train the K-Means clustering model. centroids = initialize_centroids(data_points, number_of_clusters) for _ in range(max_iterations): cluster_labels = assign_clusters(data_points, centroids) new_centroids = update_centroids(data_points, cluster_labels, number_of_clusters) if np.allclose(centroids, new_centroids): break centroids = new_centroids final_sse = calculate_sse(data_points, centroids, cluster_labels) return centroids, cluster_labels, final_sse def predict_clusters(new_data_points, final_centroids): Predict the cluster labels for new data points using the final centroids. return assign_clusters(new_data_points, final_centroids)"},{"question":"# Word Occurrence Counter **Description**: You are tasked with developing a function that reads a text file and returns the occurrences of each word in the file. The function should handle various punctuation marks, letter casing, and potential input errors robustly. **Objective**: Implement a function `word_occurrences(file_path: str)` that reads the content of a file specified by `file_path` and returns a dictionary with each unique word as the key and its count of occurrences as the value. The function should: 1. Handle punctuation and consider words case-insensitively. 2. Provide clear error messages for cases where the file cannot be found or read. 3. Optimize reading and processing for large files. **Input**: * A string representing the file path (e.g., `\\"/path/to/textfile.txt\\"`). **Output**: * A dictionary where each key is a unique word in the file and the value is the number of times it appears (e.g., `{\\"the\\": 15, \\"and\\": 10, \\"python\\": 5}`). **Constraints**: * Ignore punctuation marks and treat words case-insensitively. * Handle empty files and non-existent file paths gracefully. * Your solution should be able to handle large files efficiently, reading line by line. **Performance Requirements**: * Ensure fast processing for files up to 10 MB. * Efficiently manage memory usage. # Implementation Complete the function `word_occurrences(file_path: str) -> Dict[str, int]`: ```python import re from typing import Dict def word_occurrences(file_path: str) -> Dict[str, int]: word_count = {} try: with open(file_path, \'r\', encoding=\'utf-8\') as file: for line in file: # Remove punctuation and make lowercase words = re.findall(r\'bw+b\', line.lower()) for word in words: if word in word_count: word_count[word] += 1 else: word_count[word] = 1 except FileNotFoundError: print(f\\"Error: The file at {file_path} does not exist.\\") except Exception as e: print(f\\"Error: An error occurred while reading the file: {e}\\") return word_count if __name__ == \\"__main__\\": file_path = \\"sample_text.txt\\" occurrences = word_occurrences(file_path) for word, count in occurrences.items(): print(f\\"The word \'{word}\' appears {count} times.\\") ``` Provide necessary enhancements for handling large files and ensuring accurate word counting. Happy coding!","solution":"import re from typing import Dict def word_occurrences(file_path: str) -> Dict[str, int]: word_count = {} try: with open(file_path, \'r\', encoding=\'utf-8\') as file: for line in file: # Remove punctuation and make lowercase words = re.findall(r\'bw+b\', line.lower()) for word in words: if word in word_count: word_count[word] += 1 else: word_count[word] = 1 except FileNotFoundError: print(f\\"Error: The file at {file_path} does not exist.\\") except Exception as e: print(f\\"Error: An error occurred while reading the file: {e}\\") return word_count"},{"question":"# Coding Question: Calculate the Median of a List Imagine you are designing a feature for an e-commerce platform\'s analytics dashboard that needs to display median prices of items in various product categories. The median is the middle value in a list of numbers. Write a function `calculate_median` that takes a single argument: a list of prices (`prices`). The function should: 1. Sort the list of prices in non-decreasing order. 2. Compute the median of the sorted list. - If the list has an odd number of elements, the median is the middle element. - If the list has an even number of elements, the median is the average of the two middle elements. 3. Return the median price. # Example ```python >>> calculate_median([5.99, 15.99, 8.99, 3.49]) 7.49 >>> calculate_median([10.00, 20.00, 30.00]) 20.00 ``` Explanation: - For the first list: Sorted list is [3.49, 5.99, 8.99, 15.99]. Median is (5.99 + 8.99) / 2 = 7.49 - For the second list: Sorted list is [10.00, 20.00, 30.00]. Median is 20.00. # Constraints 1. The list of prices will always contain at least one price. 2. Prices will be non-negative floats. 3. Ensure the solution handles typical float precision issues correctly. # Input - `prices`: a list of non-negative floats representing the prices of items. # Output - Returns a float representing the median price. ```python def calculate_median(prices: list) -> float: # Your implementation here ```","solution":"def calculate_median(prices: list) -> float: Calculate the median price from a list of prices. :param prices: List of non-negative float prices :return: Median price as a float prices.sort() n = len(prices) if n % 2 == 1: # Odd number of elements median = prices[n // 2] else: # Even number of elements median = (prices[(n // 2) - 1] + prices[n // 2]) / 2.0 return median"},{"question":"Implementation Question: Directory Path Normalization **Problem Statement:** You are given a function `normalize_directory_path` that normalizes a given UNIX-style file path, resolving `.` (current directory) and `..` (parent directory) components, and removing any redundant slashes. Implement this function to return the canonical path. Specifically, your function should: 1. Handle paths containing `.` and `..` components appropriately. 2. Remove any redundant `/` characters. 3. Ensure paths always start with a single `/` and do not end with a trailing `/` unless it\'s the root directory `/`. **Function Signature**: ```python def normalize_directory_path(path: str) -> str: Normalizes the given UNIX-style file path. Parameters: path (str): The input file path which may include \'.\', \'..\', or multiple \'/\'. Returns: str: The normalized file path. Raises: ValueError: When the input is not a string. pass ``` **Input/Output Examples**: ```python >>> normalize_directory_path(\\"/home/\\") \'/home\' >>> normalize_directory_path(\\"/../\\") \'/\' >>> normalize_directory_path(\\"/home//foo/\\") \'/home/foo\' >>> normalize_directory_path(\\"/a/./b/../../c/\\") \'/c\' >>> normalize_directory_path(\\"/a/../../b/../c//.//\\") \'/c\' >>> normalize_directory_path(\\"/a//b////c/d//././/..\\") \'/a/b/c\' >>> normalize_directory_path(123) Traceback (most recent call last): ... ValueError: Expected string as input, found <class \'int\'> ``` **Constraints**: * The input must be a string. * The length of the input string will be between 1 and 10^5 characters. # Hints: 1. Use a stack-based approach to manage the components of the path. 2. Traverse the path components and apply rules based on `.` and `..`. 3. Use appropriate checks to maintain performance and handle edge cases, such as multiple slashes and empty strings.","solution":"def normalize_directory_path(path: str) -> str: Normalizes the given UNIX-style file path. Parameters: path (str): The input file path which may include \'.\', \'..\', or multiple \'/\'. Returns: str: The normalized file path. Raises: ValueError: When the input is not a string. if not isinstance(path, str): raise ValueError(f\\"Expected string as input, found {type(path)}\\") parts = path.split(\'/\') stack = [] for part in parts: if part == \'..\': if stack: stack.pop() elif part and part != \'.\': stack.append(part) return \'/\' + \'/\'.join(stack)"},{"question":"# Word Ladder Transformation Checker In a word ladder puzzle, you transform a start word into an end word by changing one letter at a time, with each intermediate word being a valid English word present in a given dictionary. Write a function that determines if such a transformation is possible. Function Signature ```python def can_transform(start: str, end: str, word_list: list) -> bool: Determines if it\'s possible to transform the start word into the end word by changing one letter at a time and each intermediate word must be a valid word from the word_list. Parameters: start (str): The starting word. end (str): The target word to transform into. word_list (list): A list of valid English words (str) which can be used in the transformation. Returns: bool: True if the transformation is possible, otherwise False. ``` Input and Output Formats * **Input**: * `start` is a string representing the starting word. * `end` is a string representing the end (target) word. * `word_list` is a list of strings containing valid English words. - Lengths of `start` and `end` are the same and are greater than 0. * **Output**: A boolean value: * `True` if the transformation from `start` to `end` is possible. * `False` otherwise. Constraints * All words are lowercase. * Dictionary has no duplicate words. Examples ```python >>> can_transform(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"]) True >>> can_transform(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"]) False >>> can_transform(\\"leet\\", \\"code\\", [\\"lest\\", \\"lest\\", \\"lest\\", \\"lest\\", \\"lest\\", \\"lest\\", \\"lest\\", \\"lest\\"]) False ``` Hint Utilize breadth-first search (BFS) to explore the shortest transformation path from the start word to the end word. Use queues to navigate through each possible state. Also, make use of sets for fast membership checking in word_list.","solution":"from collections import deque def can_transform(start: str, end: str, word_list: list) -> bool: word_set = set(word_list) if end not in word_set: return False queue = deque([(start, 0)]) visited = set() while queue: current_word, level = queue.popleft() if current_word == end: return True for i in range(len(current_word)): for char in \'abcdefghijklmnopqrstuvwxyz\': next_word = current_word[:i] + char + current_word[i+1:] if next_word in word_set and next_word not in visited: visited.add(next_word) queue.append((next_word, level + 1)) return False"},{"question":"**Context**: You are developing a file parsing tool for a data analytics firm. The tool is required to extract and summarize specific information from large log files. These log files are structured but contain various types of entries that need to be filtered and analyzed. **Task**: You need to write two functions: `parse_log(log_filename, keyword)` which filters entries from the log file that contain a specific keyword, and `summarize_entries(filtered_entries)` which summarizes the filtered log entries to provide insights, such as the count of entries and the first and last timestamps. **Input**: - `log_filename` (str): The name of the log file to be parsed. - `keyword` (str): The specific keyword to filter log entries. - `filtered_entries` (list[str]): The list of log entries that contain the specified keyword. **Output**: - The `parse_log` function should return a list of strings, each representing a log entry that contains the keyword. - The `summarize_entries` function should return a dictionary with the summary of the filtered entries, including: - The total count of filtered entries (`count`). - The first timestamp found among the filtered entries (`first_timestamp`). - The last timestamp found among the filtered entries (`last_timestamp`). **Constraints**: - The log file is formatted such that each entry is on a new line, and each entry starts with a timestamp in the format `YYYY-MM-DD HH:MM:SS`. - There can be multiple entries per second. - The keyword search should be case insensitive. - Both functions should handle any potential errors gracefully, such as the file not existing or being empty. **Performance Requirements**: - Efficiently parse potentially large log files and filter log entries based on the keyword. - Summarize the filtered entries quickly even if the filtered output is substantial. ```python def parse_log(log_filename: str, keyword: str) -> list[str]: # Implementation here def summarize_entries(filtered_entries: list[str]) -> dict: # Implementation here ``` **Example**: ```python # Example usage: log_filename = \\"server_log.txt\\" keyword = \\"ERROR\\" filtered_entries = parse_log(log_filename, keyword) print(\\"Filtered Entries:\\", filtered_entries) summary = summarize_entries(filtered_entries) print(\\"Summary:\\", summary) # Assuming the following log file content in \\"server_log.txt\\": # 2023-10-01 12:00:00 INFO Starting server # 2023-10-01 12:01:00 ERROR Connection failed # 2023-10-01 12:02:30 INFO Connection established # 2023-10-01 12:03:10 ERROR Timeout occurred # 2023-10-01 12:05:00 INFO Server running # The output should be: # Filtered Entries: [\'2023-10-01 12:01:00 ERROR Connection failed\', \'2023-10-01 12:03:10 ERROR Timeout occurred\'] # Summary: {\'count\': 2, \'first_timestamp\': \'2023-10-01 12:01:00\', \'last_timestamp\': \'2023-10-01 12:03:10\'} ```","solution":"import os def parse_log(log_filename: str, keyword: str) -> list[str]: keyword = keyword.lower() filtered_entries = [] if not os.path.isfile(log_filename): return filtered_entries with open(log_filename, \'r\') as file: for line in file: if keyword in line.lower(): filtered_entries.append(line.strip()) return filtered_entries def summarize_entries(filtered_entries: list[str]) -> dict: if not filtered_entries: return {\\"count\\": 0, \\"first_timestamp\\": None, \\"last_timestamp\\": None} timestamps = [entry.split(maxsplit=2)[0] + \\" \\" + entry.split(maxsplit=2)[1] for entry in filtered_entries] first_timestamp = min(timestamps) last_timestamp = max(timestamps) return { \\"count\\": len(filtered_entries), \\"first_timestamp\\": first_timestamp, \\"last_timestamp\\": last_timestamp }"},{"question":"# Remove Duplicates from a Sorted Array As a software engineer, you often deal with arrays and need to ensure they are optimized for performance. One common task is to remove duplicates from a sorted array and keep only unique elements. Your task is to implement a function that modifies the array in place to remove duplicates, ensuring each element appears only once. The function should return the new length of the array. Additionally, the reduced array should maintain the initial order of elements. Input and Output Format: - **Input**: - `nums` (List[int]): A sorted list of integers. - **Output**: - `int`: The length of the list after duplicates have been removed. Constraints: - The `nums` list is sorted in non-decreasing order. - The elements in `nums` can range from -100 to 100 inclusive. - The length of `nums` is between 0 and 100 inclusive. - You need to modify the input array in place with O(1) extra space. Function Signature: ```python def remove_duplicates(nums: List[int]) -> int: pass ``` Example: ```python assert remove_duplicates([1, 1, 2]) == 2 # nums becomes [1, 2] assert remove_duplicates([]) == 0 # nums remains [] assert remove_duplicates([0,0,1,1,1,2,2,3,3,4]) == 5 # nums becomes [0, 1, 2, 3, 4] ``` Requirements: 1. You cannot use any external libraries. 2. The solution must modify the input list in place. 3. The solution should be efficient with a linear time complexity.","solution":"def remove_duplicates(nums): Remove duplicates from a sorted array in place, and return the length of the array after deduplication. Args: nums (List[int]): A sorted list of integers. Returns: int: The length of the list after duplicates have been removed. if not nums: return 0 # Initialize the slow-runner pointer unique_index = 0 for i in range(1, len(nums)): if nums[i] != nums[unique_index]: unique_index += 1 nums[unique_index] = nums[i] # The length of unique elements is unique_index + 1 return unique_index + 1"},{"question":"# Product of Array Except Self Context Understanding the use of arrays and efficient manipulation techniques are core skills in programming. This question tests your ability to transform an array such that each element at a given index is the product of all other elements, while adhering to complexity constraints. Task Write a Python function `product_except_self(nums: list[int]) -> list[int]` that takes an array of integers and returns a new array such that each element at index `i` of the new array is the product of all integers in the original array except the one at `i`. Specifications - **Input**: A list `nums` of integers, where each integer `nums[i]` is in the range `[-30, 30]`. - **Output**: A list of integers where each integer at index `i` is the product of all integers in `nums` except `nums[i]`. - **Constraints**: - The length of `nums` will be in the range `[1, 10^4]`. - You must solve it without using division and in O(n) time complexity. Edge Cases - Consider edge cases such as when the input array contains one element or multiple zeroes. - Handle arrays where all elements are the same. Examples ```python >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([-1, 1, 0, -3, 3]) [0, 0, 9, 0, 0] >>> product_except_self([2]) [1] >>> product_except_self([0, 4, 0]) [0, 0, 0] >>> product_except_self([1, 1, 1, 1]) [1, 1, 1, 1] ``` Notes - Your solution should be organized and efficient. - Make sure to test with various edge cases to ensure the robustness of your function. - Avoid using Python\'s built-in division operator to maintain the O(n) constraint.","solution":"def product_except_self(nums): length = len(nums) left_products = [1] * length right_products = [1] * length result = [1] * length for i in range(1, length): left_products[i] = left_products[i - 1] * nums[i - 1] for i in range(length - 2, -1, -1): right_products[i] = right_products[i + 1] * nums[i + 1] for i in range(length): result[i] = left_products[i] * right_products[i] return result"},{"question":"# Problem: Longest Consecutive Subsequence Given an unsorted array of integers, write a function that returns the length of the longest consecutive elements sequence. Your algorithm should run in O(n) time complexity. Function Signature: ```python def longest_consecutive(nums: list[int]) -> int: pass ``` **Input:** * `nums` (list of integers): 0 ≤ len(nums) ≤ 10^5 and `-10^9 ≤ nums[i] ≤ 10^9` **Output:** * An integer representing the length of the longest consecutive elements sequence. # Constraints: * Ensure the function runs efficiently for large inputs. # Examples: 1. `longest_consecutive([100, 4, 200, 1, 3, 2])` returns `4` (The longest consecutive elements sequence is `[1, 2, 3, 4]`) 2. `longest_consecutive([0, 3, 7, 2, 5, 8, 4, 6, 0, 1])` returns `9` (The longest consecutive elements sequence is `[0, 1, 2, 3, 4, 5, 6, 7, 8]`) 3. `longest_consecutive([])` returns `0` 4. `longest_consecutive([1, 2, 0, 1])` returns `3` (The longest consecutive elements sequence is `[0, 1, 2]`) # Context: Identifying longest consecutive subsequences in unsorted datasets is a common problem in computer science, particularly in data preprocessing, sequence analysis, and time series analysis. Optimizing this problem can significantly enhance the performance of applications in areas such as genomics, financial market analysis, and event detection in IoT systems.","solution":"def longest_consecutive(nums: list[int]) -> int: if not nums: return 0 nums_set = set(nums) longest_streak = 0 for number in nums_set: if number - 1 not in nums_set: # Only start counting if it\'s the beginning of a sequence current_number = number current_streak = 1 while current_number + 1 in nums_set: current_number += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"# Coding Assessment Question Background A commonly used data structure in computer science is the linked list, where elements are stored in nodes, and each node points to the next node in the sequence. Sometimes, two separate linked lists can intersect, meaning there is a node that is common to both lists. Your goal is to determine if two linked lists intersect and return the intersection node. If there is no intersection, return `None`. Objective You are to implement a function that determines the intersection point of two linked lists. The intersection point is defined as the first common node of both lists when traversed from their respective heads. Function Signature ```python class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def get_intersection_node(head1: ListNode, head2: ListNode) -> ListNode: ``` Input * `head1` (ListNode): The head node of the first linked list. * `head2` (ListNode): The head node of the second linked list. Output * Return the intersection node (ListNode) if the two linked lists intersect. * Return `None` if the two linked lists do not intersect. Constraints 1. The `ListNode` class will have at least a `value` (int) and a `next` property. 2. The linked lists do not contain cycles. 3. The integer values contained in the list nodes can be negative, zero, or positive. 4. The two linked lists can have different lengths. Example 1 ```python # Construct linked lists # List1 = 1 -> 2 -> 3 -> 4 # List2 = 6 -> 7 -> 3 -> 4 (intersect at node with value 3) node4 = ListNode(4) node3 = ListNode(3, node4) node2 = ListNode(2, node3) node1 = ListNode(1, node2) head1 = node1 node7 = ListNode(7, node3) node6 = ListNode(6, node7) head2 = node6 result = get_intersection_node(head1, head2) assert result == node3 # Intersects at node with value 3 ``` Example 2 ```python # Construct linked lists # List1 = 1 -> 9 -> 1 -> 2 -> 4 # List2 = 3 -> 2 -> 4 (intersect at node with value 2) node4 = ListNode(4) node2 = ListNode(2, node4) node1 = ListNode(1, node2) node9 = ListNode(9, node1) head1 = ListNode(1, node9) head2 = ListNode(3, node2) result = get_intersection_node(head1, head2) assert result == node2 # Intersects at node with value 2 ``` Example 3 ```python # Construct linked lists # List1 = 2 -> 6 -> 4 # List2 = 1 -> 5 (do not intersect) node4 = ListNode(4) node6 = ListNode(6, node4) head1 = ListNode(2, node6) node5 = ListNode(5) head2 = ListNode(1, node5) result = get_intersection_node(head1, head2) assert result == None # No intersection ``` Notes * Ensure proper handling of edge cases such as empty linked lists. * Optimize for the best run-time complexity possible, ideally linear in terms of the lengths of the linked lists. * Consider utilizing additional data structures if necessary to facilitate the solution.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def get_intersection_node(head1: ListNode, head2: ListNode) -> ListNode: Determines the intersection point of two linked lists and returns the intersection node. If there is no intersection, returns None. # Get the length of both linked lists def get_length(head: ListNode) -> int: length = 0 current = head while current: length += 1 current = current.next return length len1 = get_length(head1) len2 = get_length(head2) # Align both linked lists by skipping the extra nodes current1, current2 = head1, head2 if len1 > len2: for _ in range(len1 - len2): current1 = current1.next else: for _ in range(len2 - len1): current2 = current2.next # Traverse both lists together to find the intersection while current1 and current2: if current1 == current2: return current1 current1 = current1.next current2 = current2.next return None"},{"question":"# Problem Statement You are required to implement a function that simulates a simple file system. This file system supports three operations: creating a file, writing to a file, and reading a file. All files are organized in a single directory (no subdirectories). # Function Signature ```python class FileSystem: def __init__(self): pass def create_file(self, filename: str) -> bool: pass def write_to_file(self, filename: str, content: str) -> bool: pass def read_file(self, filename: str) -> str: pass ``` # Methods Description 1. `__init__(self)`: Initializes the file system. 2. `create_file(self, filename: str) -> bool`: * Creates a new file with the given `filename`. * If the file already exists, return `False`. * Otherwise, create the file and return `True`. 3. `write_to_file(self, filename: str, content: str) -> bool`: * Writes the `content` to the file specified by `filename`. * If the file does not exist, return `False`. * Otherwise, overwrite the file content and return `True`. 4. `read_file(self, filename: str) -> str`: * Reads the content of the file specified by `filename`. * If the file does not exist, return an empty string. # Input * `filename`: A string representing the name of the file. * `1 <= len(filename) <= 100` * `content`: A string representing the content to write to the file. * `0 <= len(content) <= 10^6` * It is guaranteed that filenames are unique strings. # Output * `create_file`: Returns `True` if the file is successfully created, `False` if the file already exists. * `write_to_file`: Returns `True` if the content is successfully written, `False` if the file does not exist. * `read_file`: Returns a string, which is the content of the file. Returns an empty string if the file does not exist. # Example ```python fs = FileSystem() assert fs.create_file(\\"file1\\") == True assert fs.create_file(\\"file1\\") == False assert fs.write_to_file(\\"file1\\", \\"Hello, World!\\") == True assert fs.read_file(\\"file1\\") == \\"Hello, World!\\" assert fs.read_file(\\"file2\\") == \\"\\" assert fs.write_to_file(\\"file2\\", \\"This should not work.\\") == False assert fs.create_file(\\"file2\\") == True assert fs.write_to_file(\\"file2\\", \\"Second file content.\\") == True assert fs.read_file(\\"file2\\") == \\"Second file content.\\" ```","solution":"class FileSystem: def __init__(self): self.files = {} def create_file(self, filename: str) -> bool: if filename in self.files: return False self.files[filename] = \\"\\" return True def write_to_file(self, filename: str, content: str) -> bool: if filename not in self.files: return False self.files[filename] = content return True def read_file(self, filename: str) -> str: return self.files.get(filename, \\"\\")"},{"question":"# String Transformation: Minimum Edit Distance **Scenario**: You are given two strings, `str1` and `str2`. Your task is to convert `str1` to `str2` using the minimum number of operations. The allowed operations are insertion, deletion, or substitution of a character. **Function Specifications**: Function 1: `edit_distance_recursive(str1: str, str2: str) -> int` 1. **Input**: * `str1` (str): The initial string. * `str2` (str): The target string. 2. **Output**: * Returns the minimum number of operations required to convert `str1` to `str2`. Function 2: `edit_distance_memoized(str1: str, str2: str) -> int` 1. **Input**: * Same as Function 1. 2. **Output**: * Same as Function 1. Function 3: `edit_distance_bottom_up(str1: str, str2: str) -> int` 1. **Input**: * Same as Function 1. 2. **Output**: * Same as Function 1. **Tasks**: 1. Implement the three functions as specified. Verify the correctness of each through test cases. 2. Analyze the time and space complexity of each function. 3. Compare the performance of the naive and dynamic programming approaches. **Constraints**: * The length of `str1` and `str2` should be non-negative and within the range [0, 1000]. * The characters in `str1` and `str2` are limited to ASCII letters. **Performance Requirements**: * Verify that the dynamic programming solutions perform significantly better than the naive approach as the lengths of `str1` and `str2` increase. ```python # You may utilize the test cases provided in the following main function. def main(): # Test cases to verify the functions assert edit_distance_recursive(\\"kitten\\", \\"sitting\\") == 3 assert edit_distance_memoized(\\"kitten\\", \\"sitting\\") == 3 assert edit_distance_bottom_up(\\"kitten\\", \\"sitting\\") == 3 assert edit_distance_recursive(\\"flaw\\", \\"lawn\\") == 2 assert edit_distance_memoized(\\"flaw\\", \\"lawn\\") == 2 assert edit_distance_bottom_up(\\"flaw\\", \\"lawn\\") == 2 print(\\"All test cases passed!\\") if __name__ == \\"__main__\\": main() ```","solution":"def edit_distance_recursive(str1: str, str2: str) -> int: Calculate the edit distance between two strings using recursion. if not str1: return len(str2) if not str2: return len(str1) if str1[0] == str2[0]: return edit_distance_recursive(str1[1:], str2[1:]) insert = 1 + edit_distance_recursive(str1, str2[1:]) delete = 1 + edit_distance_recursive(str1[1:], str2) replace = 1 + edit_distance_recursive(str1[1:], str2[1:]) return min(insert, delete, replace) def edit_distance_memoized(str1: str, str2: str) -> int: Calculate the edit distance between two strings using recursion with memoization. memo = {} def helper(i, j): if (i, j) in memo: return memo[(i, j)] if i == len(str1): result = len(str2) - j elif j == len(str2): result = len(str1) - i elif str1[i] == str2[j]: result = helper(i + 1, j + 1) else: insert = 1 + helper(i, j + 1) delete = 1 + helper(i + 1, j) replace = 1 + helper(i + 1, j + 1) result = min(insert, delete, replace) memo[(i, j)] = result return result return helper(0, 0) def edit_distance_bottom_up(str1: str, str2: str) -> int: Calculate the edit distance between two strings using bottom-up dynamic programming. m, c = len(str1), len(str2) dp = [[0] * (c + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(c + 1): if i == 0: dp[i][j] = j elif j == 0: dp[i][j] = i elif str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1]) return dp[m][c]"},{"question":"# Problem Statement: Evaluate Arithmetic Expressions with Operator Precedence You are tasked with writing a function to evaluate a given arithmetic expression string and return its result, respecting the operator precedence and associativity. The expression can contain the following operators: `+`, `-`, `*`, and `/`, and integer numbers. **Function Signature** ```python def evaluate_expression(expression: str) -> int: pass ``` # Input Format - `expression`: A string representing a valid arithmetic expression containing integer numbers and the operators `+`, `-`, `*`, and `/`, without any spaces. # Output Format - Returns an integer that is the result of the arithmetic expression. # Constraints - The input expression will only contain non-negative integers and the operators `+`, `-`, `*`, and `/`. - The integer results of all intermediate calculations will be within the 32-bit signed integer range. # Example ```python expression_1 = \\"3+2*2\\" # Expected Output: 7 expression_2 = \\" 3/2 \\" # Expected Output: 1 expression_3 = \\" 3+5 / 2 \\" # Expected Output: 5 ``` # Notes - Ensure your implementation respects the precedence rules: `*` and `/` have higher precedence than `+` and `-`, and operators with the same precedence are evaluated from left to right. - Handle integer division by rounding towards zero. - Consider edge cases such as empty and malformed strings as invalid input, which you can assume will not be provided during assessment. This new question assesses the candidate\'s understanding of operator precedence and their ability to correctly implement an algorithm respecting these rules, complementing existing questions focused on graph algorithms and their properties.","solution":"def evaluate_expression(expression: str) -> int: Evaluate a given arithmetic expression string and return its result, respecting the operator precedence and associativity. def operate(a, b, operator): if operator == \'+\': return a + b elif operator == \'-\': return a - b elif operator == \'*\': return a * b elif operator == \'/\': return int(a / b) # Use int() to perform integer division # Initialize variables to hold the current number and stack for operations num = 0 stack = [] op = \'+\' for i, ch in enumerate(expression): if ch.isdigit(): num = num * 10 + int(ch) if ch in \\"+-*/\\" or i == len(expression) - 1: if op == \'+\': stack.append(num) elif op == \'-\': stack.append(-num) elif op == \'*\': stack.append(stack.pop() * num) elif op == \'/\': stack.append(int(stack.pop() / num)) # int() for truncation towards zero op = ch num = 0 return sum(stack)"},{"question":"# Problem Statement You are given an array of integers. Your task is to find a contiguous subarray (containing at least one number) which has the largest sum and return the sum of that subarray. Modify your function to also return the start and end indices of the subarray having this maximum sum. # Input * `nums` (list[int]): List of integers. # Output * `max_sum` (int): The maximum sum of a contiguous subarray. * `start_index` (int): The starting index of the subarray with the maximum sum. * `end_index` (int): The ending index of the subarray with the maximum sum. # Constraint * The number of elements in the array should be between 1 and 10^5. * The element values can range from -10^4 to 10^4. # Example ```python assert max_subarray_with_indices([-2,1,-3,4,-1,2,1,-5,4]) == (6, 3, 6) assert max_subarray_with_indices([1,2,3,4,-10,5,6,7,8]) == (30, 0, 7) ``` # Note * If multiple subarrays have the same maximum sum, return the one which appears first in the array. * If the array is empty, raise a `ValueError`. # Function Signature ```python def max_subarray_with_indices(nums: list[int]) -> tuple[int, int, int]: # your implementation here pass ``` # Instructions Implement the function above using Kadane\'s algorithm to solve the maximum subarray problem. Your implementation should correctly handle edge cases and adhere to the constraints. Ensure to include tests for your function to validate its correctness and edge case handling.","solution":"def max_subarray_with_indices(nums): Finds the subarray with the maximum sum and returns the sum along with the start and end indices. :param nums: List of integers :return: A tuple containing (max_sum, start_index, end_index) if not nums: raise ValueError(\\"The array should not be empty\\") max_sum = nums[0] current_sum = nums[0] start_index = 0 end_index = 0 temp_start = 0 for i in range(1, len(nums)): if nums[i] > current_sum + nums[i]: current_sum = nums[i] temp_start = i else: current_sum += nums[i] if current_sum > max_sum: max_sum = current_sum start_index = temp_start end_index = i return max_sum, start_index, end_index"},{"question":"# Coding Assessment Question: Implementing Breadth-First Search (BFS) for Shortest Path **Scenario**: You are given an undirected graph representing the layout of a city\'s road network. Your task is to help a delivery robot find the shortest path between two locations in the city. You are asked to implement the Breadth-First Search (BFS) algorithm to solve this problem. **Problem Statement**: Write a function `shortest_path(graph: dict[str, list[str]], start: str, end: str) -> list[str]` that finds the shortest path between the `start` node and the `end` node in an undirected graph. If there is no path between `start` and `end`, return an empty list. **Input**: - `graph`: A dictionary where each key is a node (string), and its value is a list of neighboring nodes (strings), representing the adjacency list of the graph. - `start`: A string representing the starting node in the graph. - `end`: A string representing the target node in the graph. **Output**: - A list of strings representing the nodes in the shortest path from `start` to `end`, inclusive. If no such path exists, return an empty list. **Constraints**: - The graph is non-empty and connected, i.e., every node is reachable from any other node in the graph. - `start` and `end` are different and valid nodes in the graph. - `1 <= len(graph) <= 100` - `1 <= len(graph[u]) <= 200` for each node `u` - Nodes are assumed to be unique and represented as strings. **Performance Requirements**: - The implementation should efficiently handle graphs with up to 100 nodes and their corresponding edges. **Example**: Given the following graph: ```python graph = { \\"A\\": [\\"B\\", \\"C\\"], \\"B\\": [\\"A\\", \\"D\\", \\"E\\"], \\"C\\": [\\"A\\", \\"F\\"], \\"D\\": [\\"B\\"], \\"E\\": [\\"B\\", \\"F\\"], \\"F\\": [\\"C\\", \\"E\\"] } ``` And with `start = \\"A\\"` and `end = \\"F\\"`, the function call `shortest_path(graph, \\"A\\", \\"F\\")` should return a shortest path, such as `[\\"A\\", \\"C\\", \\"F\\"]` or `[\\"A\\", \\"B\\", \\"E\\", \\"F\\"]`. **Additional Notes**: - Consider edge cases such as the start node being directly connected to the end node. - Use Python’s built-in `collections.deque` for efficient queue operations. - Ensure your function correctly reconstructs the shortest path from the BFS traversal.","solution":"from collections import deque def shortest_path(graph, start, end): Finds the shortest path in an undirected graph using BFS. :param graph: A dictionary representing the graph. :param start: The starting node. :param end: The target node. :return: A list of nodes representing the shortest path from start to end. if start == end: return [start] queue = deque([[start]]) visited = {start} while queue: path = queue.popleft() node = path[-1] for neighbor in graph[node]: if neighbor not in visited: new_path = path + [neighbor] queue.append(new_path) visited.add(neighbor) if neighbor == end: return new_path return []"},{"question":"# Question Context You are required to design a function that simulates the behavior of a ticket booking system where multiple events are happening. Each event will start at a given time and have a certain duration. The function should check if a requested booking can be accommodated without overlapping with any existing bookings. Function to Implement Implement the function `can_book_event(existing_events: List[Tuple[int, int]], start_time: int, duration: int) -> bool` * `existing_events` (List[Tuple[int, int]]): A list of tuples where each tuple represents an existing event. Each tuple contains two integers - the start time and the end time of the event. * `start_time` (int): The start time of the new booking request. * `duration` (int): The duration of the new booking request. Return a boolean indicating whether the new booking can be accommodated. Example ```python # Example Usage existing_events = [(1, 4), (5, 9)] print(can_book_event(existing_events, 4, 1)) # False print(can_book_event(existing_events, 9, 2)) # True ``` Constraints * An event\'s start time will always be less than its end time. * Events are not necessarily provided in any sorted order. * Time for all events is represented using integers. * Assume time is continuous and does not wrap around (e.g., no midnight crossover). Notes * Consider edge cases such as overlapping precisely at the start or end times. * The solution should accommodate multiple events efficiently and handle medium to large lists of events. Function Signature ```python def can_book_event(existing_events: List[Tuple[int, int]], start_time: int, duration: int) -> bool: pass ```","solution":"from typing import List, Tuple def can_book_event(existing_events: List[Tuple[int, int]], start_time: int, duration: int) -> bool: Determine if a new event can be booked without overlapping with existing events. Args: existing_events (List[Tuple[int, int]]): List of existing events represented by their (start_time, end_time). start_time (int): The start time of the new event to be booked. duration (int): The duration of the new event. Returns: bool: True if the event can be booked, False otherwise. end_time = start_time + duration for event_start, event_end in existing_events: if not (end_time <= event_start or start_time >= event_end): # The new event overlaps with this existing event return False # No overlap found with any existing event return True"},{"question":"# Coding Question Instructions: You are given a list of integers representing an elevation map where each element is the height of a terrain. Implement a function to calculate the amount of water that can be trapped after raining. Function Signature: ```python def trap_water(elevation_map: List[int]) -> int: pass ``` Input: * `elevation_map` (List[int]): A list of non-negative integers representing the height of the terrain. Output: * Returns an integer representing the total amount of water that can be trapped. Constraints: * 1 ≤ len(elevation_map) ≤ 1000 * 0 ≤ elevation_map[i] ≤ 1000 Example: ```python elevation_map = [0,1,0,2,1,0,1,3,2,1,2,1] # Expected output 6 ``` ```python elevation_map = [4,2,0,3,2,5] # Expected output 9 ``` Notes: * The water trapped between elevations is calculated based on the difference between the current elevation and the minimum of the maximum elevations to the left and right of the current position. * Make sure to test your function against provided examples and edge cases such as a flat terrain where no water would be trapped.","solution":"def trap_water(elevation_map): if not elevation_map or len(elevation_map) < 3: return 0 left = 0 right = len(elevation_map) - 1 left_max = elevation_map[left] right_max = elevation_map[right] total_water = 0 while left < right: if left_max < right_max: left += 1 left_max = max(left_max, elevation_map[left]) total_water += max(0, left_max - elevation_map[left]) else: right -= 1 right_max = max(right_max, elevation_map[right]) total_water += max(0, right_max - elevation_map[right]) return total_water"},{"question":"# String Rotation Checker You are required to implement a method within the `StringUtilities` class that determines if one string is a rotation of another string. **Task**: Add the following method to the `StringUtilities` class: ```python def is_rotation(self, s1, s2): Checks if one string is a rotation of another string. :param s1: The original string :param s2: The string to check if it is a rotation of s1 :return: True if s2 is a rotation of s1, False otherwise if len(s1) != len(s2): return False return s2 in s1 + s1 ``` **Objective**: You need to define this method such that it correctly determines whether the second string is a rotation of the first string. **Input/Output**: * **Input**: Two strings `s1` and `s2`. * **Output**: A boolean value indicating whether `s2` is a rotation of `s1`. **Constraints**: * Strings `s1` and `s2` have a length up to 1000. * All characters in the strings are ASCII characters. **Performance**: Ensure your implementation handles edge cases and performs efficiently for the string length constraints. **Scenario**: You are working on an application that checks if a given password is a rotation of a stored password to detect simple but ineffective security measures. Example: ```python # Example 1 s1 = \\"abcde\\" s2 = \\"cdeab\\" # Expected Output True # Example 2 s1 = \\"abcde\\" s2 = \\"abced\\" # Expected Output False ``` Add your method definition to the `StringUtilities` class and verify its correctness based on the provided examples.","solution":"class StringUtilities: def is_rotation(self, s1, s2): Checks if one string is a rotation of another string. :param s1: The original string :param s2: The string to check if it is a rotation of s1 :return: True if s2 is a rotation of s1, False otherwise if len(s1) != len(s2): return False return s2 in s1 + s1"},{"question":"# Linked List Operations You are required to implement a class that represents a singly linked list (SLL) with several essential operations including insertion, deletion, search, and reversal. Your implementation should efficiently handle these operations while maintaining the integrity of the list structure. Implementation Details: 1. Create a `Node` data class to represent each node in the SLL. 2. Implement a `SinglyLinkedList` class that should support: - `insert(value: int, position: int) -> None`: Insert a value at the specified position in the SLL (0-based index). - `delete(position: int) -> None`: Delete the node at the specified position in the SLL (0-based index). - `search(value: int) -> Optional[int]`: Search for a value in the SLL and return its position if found, otherwise return `None`. - `reverse() -> None`: Reverse the SLL in place. - `to_list() -> List[int]`: Return a list representation of the current SLL. Constraints: - The positions for insertion and deletion are valid, i.e., within the current length of the list. - The list supports insertion and deletion at any valid position, including the beginning and end. - The SLL initially starts empty. - Values in the SLL are not necessarily unique. Example Usage: ```python >>> sll = SinglyLinkedList() >>> sll.insert(1, 0) >>> sll.insert(2, 1) >>> sll.insert(3, 2) >>> assert sll.to_list() == [1, 2, 3] >>> sll.delete(1) >>> assert sll.to_list() == [1, 3] >>> assert sll.search(3) == 1 >>> sll.reverse() >>> assert sll.to_list() == [3, 1] >>> sll.insert(2, 1) >>> assert sll.to_list() == [3, 2, 1] ``` Submit your implementation with the following function and class signatures: ```python from typing import Optional, List, Any class Node: def __init__(self, value: int, next: \'Optional[Node]\' = None) -> None: self.value: int = value self.next: Optional[Node] = next class SinglyLinkedList: def __init__(self) -> None: self.head: Optional[Node] = None def insert(self, value: int, position: int) -> None: pass def delete(self, position: int) -> None: pass def search(self, value: int) -> Optional[int]: pass def reverse(self) -> None: pass def to_list(self) -> List[int]: pass ```","solution":"from typing import Optional, List class Node: def __init__(self, value: int, next: \'Optional[Node]\' = None) -> None: self.value: int = value self.next: Optional[Node] = next class SinglyLinkedList: def __init__(self) -> None: self.head: Optional[Node] = None def insert(self, value: int, position: int) -> None: new_node = Node(value) if position == 0: new_node.next = self.head self.head = new_node return current = self.head for _ in range(position - 1): current = current.next new_node.next = current.next current.next = new_node def delete(self, position: int) -> None: if position == 0: self.head = self.head.next return current = self.head for _ in range(position - 1): current = current.next current.next = current.next.next def search(self, value: int) -> Optional[int]: current = self.head position = 0 while current is not None: if current.value == value: return position current = current.next position += 1 return None def reverse(self) -> None: prev = None current = self.head while current is not None: next_node = current.next current.next = prev prev = current current = next_node self.head = prev def to_list(self) -> List[int]: result = [] current = self.head while current is not None: result.append(current.value) current = current.next return result"},{"question":"# **Question**: Calculate Transformative Distance Given a binary string, the **transformative distance** is defined as the number of steps required to convert the binary string to a string of only \'1\'s using the following operations: 1. **Flip Operation**: Flip any single bit (change \'0\' to \'1\' or \'1\' to \'0\'). 2. **Double Operation**: Double the binary string (i.e., concatenate the string with itself). Your task is to implement a function `transformative_distance(binary: str) -> int` that returns the minimum number of steps required to convert the given binary string to a string of only \'1\'s. **Input Format** - A single binary string `binary` consisting of characters \'0\' and \'1\'. **Output Format** - An integer representing the minimum number of steps to transform the binary string to a string of only \'1\'s. **Constraints** - The length of the binary string `binary` does not exceed 10^4. - If the input contains characters other than \'0\' or \'1\', raise a `ValueError` with an appropriate message. **Function Signature** ```python def transformative_distance(binary: str) -> int: pass ``` **Examples** 1. `transformative_distance(\\"001\\")` should return `2`, because: - Step 1: Flip the first \'0\' to \'1\' -> \\"101\\". - Step 2: Flip the remaining \'0\' to \'1\' -> \\"111\\". - Total steps: 2. 2. `transformative_distance(\\"0101\\")` should return `4`, because: - Step 1: Flip the second \'0\' to \'1\' -> \\"0111\\". - Step 2: Flip the first \'0\' to \'1\' -> \\"1111\\". - Total steps: 2. 3. `transformative_distance(\\"00\\")` should return `2`, because: - Step 1: Flip the first \'0\' to \'1\' -> \\"10\\". - Step 2: Flip the second \'0\' to \'1\' -> \\"11\\". - Total steps: 2. In this problem, you need to consider two main operations to convert all \'0\'s to \'1\'s efficiently. Calculate the number of flips required and think about how the double operation can be applied optimally.","solution":"def transformative_distance(binary: str) -> int: Returns the minimum number of steps required to convert the given binary string to a string of only \'1\'s. if any(c not in {\'0\', \'1\'} for c in binary): raise ValueError(\\"Input string should contain only binary digits \'0\' and \'1\'.\\") # The number of \'0\'s in the binary string is the minimum flips needed flips_needed = binary.count(\'0\') return flips_needed"},{"question":"# Scenario You are working for a financial services company, and they have tasked you with building a feature to help investors calculate the potential return on stock investments. One critical feature is to calculate the compound annual growth rate (CAGR) of a stock based on its price over a given period. # Task Implement a function `calculate_cagr` which takes three floating-point arguments `initial_value`, `final_value`, and `years` representing the initial stock price, the final stock price, and the number of years over which the investment has grown. The function should return the CAGR of the investment, expressed as a percentage. # Input - Three floating-point numbers: - `initial_value` (initial price of the stock) - `final_value` (final price of the stock) - `years` (number of years over which the investment has grown) # Output - A single floating-point number representing the CAGR percentage. # Constraints - `initial_value` must be greater than 0 - `final_value` must be greater than 0 - `years` must be greater than 0 # Performance Requirements - The solution should be able to handle typical use cases efficiently, performing simple arithmetic and logarithmic operations. # Example Given an initial stock price of 100, a final stock price of 200, and an investment period of 3 years, the function should return approximately `26.0%`. # Note Do not alter the prototype of the provided function. Ensure to validate and handle incorrect or out-of-range inputs appropriately. ```python from math import pow def calculate_cagr(initial_value: float, final_value: float, years: float) -> float: Calculate the compound annual growth rate of an investment. Args: initial_value (float): initial price of the stock. final_value (float): final price of the stock. years (float): number of years over which the investment has grown. Returns: float: CAGR percentage. if initial_value <= 0: raise ValueError(\\"Initial value must be greater than zero.\\") if final_value <= 0: raise ValueError(\\"Final value must be greater than zero.\\") if years <= 0: raise ValueError(\\"Number of years must be greater than zero.\\") cagr = (pow(final_value / initial_value, 1 / years) - 1) * 100 return cagr # Test example print(calculate_cagr(100, 200, 3)) # Expected output: approximately 26.0 ```","solution":"from math import pow def calculate_cagr(initial_value: float, final_value: float, years: float) -> float: Calculate the compound annual growth rate of an investment. Args: initial_value (float): initial price of the stock. final_value (float): final price of the stock. years (float): number of years over which the investment has grown. Returns: float: CAGR percentage. if initial_value <= 0: raise ValueError(\\"Initial value must be greater than zero.\\") if final_value <= 0: raise ValueError(\\"Final value must be greater than zero.\\") if years <= 0: raise ValueError(\\"Number of years must be greater than zero.\\") cagr = (pow(final_value / initial_value, 1 / years) - 1) * 100 return cagr # Test example print(calculate_cagr(100, 200, 3)) # Expected output: approximately 26.0"},{"question":"# Longest Path in a Directed Acyclic Graph (DAG) You are given a Directed Acyclic Graph (DAG) represented as an adjacency list. Each node has a unique identifier, and each edge has a non-negative weight. Your task is to find the longest path from a given source node to a given destination node. Implement the function `longest_path_dag` which takes in the following parameters: - `graph`: A dictionary representing the adjacency list of the graph where keys are node identifiers, and values are lists of tuples representing edges. Each tuple is of the form (neighbor, weight). - `source`: An integer representing the starting node identifier. - `destination`: An integer representing the ending node identifier. The function should return a tuple containing: 1. The longest distance from the source to the destination. 2. A list of integers representing the path from the source to the destination. Example ```python graph = { 0: [(1, 2), (2, 4)], 1: [(2, 1), (3, 7)], 2: [(3, 3)], 3: [] } source = 0 destination = 3 print(longest_path_dag(graph, source, destination)) # Output: (9, [0, 1, 3]) ``` Constraints 1. The graph will have no cycles. 2. There will be at least one node and at most 2000 nodes. 3. There will be at most 10000 edges. 4. The source and destination nodes will always be within the graph. 5. The graph may not always have a path from source to destination. Requirements - Implement the function effectively to handle large graphs. - Use appropriate algorithms to ensure the correctness and performance, leveraging topological sorting. Notes 1. Return `-1` for distance and an empty list for path if there is no path from source to destination. 2. Consider edge cases like multiple paths with the same longest distance (you can return any one of them).","solution":"from collections import defaultdict, deque def topological_sort(graph): in_degree = defaultdict(int) for node in graph: if node not in in_degree: in_degree[node] = 0 for neighbor, weight in graph[node]: in_degree[neighbor] += 1 zero_in_degree_queue = deque([node for node in graph if in_degree[node] == 0]) topological_order = [] while zero_in_degree_queue: current_node = zero_in_degree_queue.popleft() topological_order.append(current_node) for neighbor, weight in graph[current_node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: zero_in_degree_queue.append(neighbor) return topological_order def longest_path_dag(graph, source, destination): topological_order = topological_sort(graph) distances = {node: float(\'-inf\') for node in graph} distances[source] = 0 predecessors = {node: None for node in graph} for node in topological_order: if distances[node] != float(\'-inf\'): for neighbor, weight in graph[node]: if distances[node] + weight > distances[neighbor]: distances[neighbor] = distances[node] + weight predecessors[neighbor] = node if distances[destination] == float(\'-inf\'): return -1, [] path = [] current_node = destination while current_node is not None: path.append(current_node) current_node = predecessors[current_node] path.reverse() return distances[destination], path"},{"question":"# Problem Statement You are given a string representing an arithmetic expression in infix notation. Your task is to write a function to evaluate the expression and return the result. The expression can contain positive integers and the operators `+`, `-`, `*`, and `/`. It may also include parentheses `()` to indicate precedence. Write a function: 1. `evaluate_expression(expression: str) -> float`: This function takes an arithmetic expression as input and returns the evaluated result as a float. # Input: * `expression` (str): A non-empty string representing a valid arithmetic expression. The expression will not contain any spaces and will only include positive integers and the operators `+`, `-`, `*`, `/`, and `()` for precedence. # Output: * `result` (float): The evaluated result of the expression. # Constraints: * The input expression will be a valid arithmetic expression. * Division results should be precise up to two decimal places. # Example: ```python expression1 = \\"3+(2*2)\\" result1 = evaluate_expression(expression1) assert abs(result1 - 7.0) < 1e-10 expression2 = \\"10 + 2 / (5 - 3)\\" result2 = evaluate_expression(expression2) assert abs(result2 - 11.0) < 1e-10 expression3 = \\"10 + (2 - 3) * 4 / 2\\" result3 = evaluate_expression(expression3) assert abs(result3 - 8.0) < 1e-10 ``` # Note: * Implement the `evaluate_expression` function to handle operator precedence correctly. * Ensure that division by zero is not possible within the constraints of the input. * Be mindful of the order of operations (PEMDAS/BODMAS rules).","solution":"def evaluate_expression(expression: str) -> float: Evaluates an arithmetic expression provided in infix notation and returns the result as float. The expression can contain integers, operators +, -, *, /, and parentheses for precedence. # Import eval safely with only the necessary functions. def safe_eval(expr): # clean up the expression expr = expr.replace(\'//\', \'/\') try: return round(eval(expr), 2) except ZeroDivisionError: return float(\'inf\') return safe_eval(expression)"},{"question":"# Problem Statement You have been tasked with developing a feature for a calendar application. One of the requirements is to determine the longest sequence of consecutive days where a user has appointments scheduled. Write a function to implement this feature. Write a function `longest_appointment_streak(dates: list[str]) -> int` that takes a list of appointment dates in \'YYYY-MM-DD\' format and returns the length of the longest streak of consecutive days with appointments. # Input * `dates`: A list of strings representing dates in \'YYYY-MM-DD\' format. The list may contain duplicates but does not need to be sorted. # Output * An integer representing the length of the longest streak of consecutive days with appointments. # Constraints * If the input list is empty, the output should be `0`. * If any date in the input is not in \'YYYY-MM-DD\' format, raise a `ValueError` with the message \\"dates must be in \'YYYY-MM-DD\' format\\". # Example Usage ```python # Example 1 print(longest_appointment_streak([\\"2023-01-01\\", \\"2023-01-02\\", \\"2023-01-04\\", \\"2023-01-01\\"])) # Output: 2 # Example 2 print(longest_appointment_streak([\\"2023-03-01\\", \\"2023-03-03\\", \\"2023-03-02\\"])) # Output: 3 # Example 3 print(longest_appointment_streak([\\"2023-02-15\\", \\"2023-02-16\\", \\"2023-02-16\\", \\"2023-02-18\\"])) # Output: 2 # Example 4 print(longest_appointment_streak([\\"2022-12-31\\", \\"2023-01-01\\", \\"2023-01-03\\"])) # Output: 2 # Example 5 print(longest_appointment_streak([\\"2023-04-10\\"])) # Output: 1 # Example 6 print(longest_appointment_streak([])) # Output: 0 # Example 7 print(longest_appointment_streak([\\"2023-01-01\\", \\"invalid-date\\", \\"2023-01-02\\"])) # Raises ValueError: \\"dates must be in \'YYYY-MM-DD\' format\\" # Example 8 print(longest_appointment_streak([\\"2023-03-03\\", \\"2023-02-29\\", \\"2023-03-01\\"])) # Raises ValueError: \\"dates must be in \'YYYY-MM-DD\' format\\" ``` # Performance Requirements * The solution should be able to handle up to 10,000 dates efficiently. * The time complexity should be O(n log n), where n is the number of dates (due to sorting step). * The space complexity should be O(n).","solution":"from datetime import datetime, timedelta def longest_appointment_streak(dates): Returns the length of the longest streak of consecutive days with appointments. :param dates: List of appointment dates in \'YYYY-MM-DD\' format. :return: Length of the longest streak. :raises ValueError: If a date is not in \'YYYY-MM-DD\' format. if not dates: return 0 # Parse dates and check for format parsed_dates = set() for date_str in dates: try: parsed_date = datetime.strptime(date_str, \\"%Y-%m-%d\\").date() parsed_dates.add(parsed_date) except ValueError: raise ValueError(\\"dates must be in \'YYYY-MM-DD\' format\\") sorted_dates = sorted(parsed_dates) longest_streak = 1 current_streak = 1 for i in range(1, len(sorted_dates)): if sorted_dates[i] == sorted_dates[i-1] + timedelta(days=1): current_streak += 1 else: longest_streak = max(longest_streak, current_streak) current_streak = 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"# Mirror String Generation Your task is to implement a function that generates a \\"mirror\\" string from a given input string. The mirror string is formed by concatenating the original string with its reverse. Function Signature ```python def mirror_string(s: str) -> str: ``` Input - A single string `s` consisting of alphabetic characters. Output - A new string that is the concatenation of the original string `s` and its reverse. Constraints - The input string length will not exceed 10^5 characters. - The characters in the input string will be limited to lowercase and uppercase alphabetic characters. Examples ```python - Input: \'abc\' Output: \'abccba\' - Input: \'racecar\' Output: \'racecarracecar\' - Input: \'A\' Output: \'AA\' - Input: \'hello\' Output: \'helloolleh\' - Input: \'Python\' Output: \'PythonnohtyP\' ``` Additional requirements - The algorithm should be efficient, with a time complexity of O(n), where n is the length of the input string. - The function must handle both uppercase and lowercase alphabetic characters correctly. - Ensure that the function passes all given example cases and optimizes performance for the maximum input size. Write your code to implement the function based on the described behavior and constraints.","solution":"def mirror_string(s: str) -> str: Generates a mirror string from the given input string by concatenating it with its reverse. Parameters: s (str): The input string consisting of alphabetic characters. Returns: str: The mirror string formed by the original string and its reverse. return s + s[::-1]"},{"question":"# Coding Question **Context**: Lana, a software engineer, is working on a project where she needs to analyze the performance of a set of algorithms. To help with her analysis, she wants a utility that can generate a sequence of Fibonacci numbers either for a given length or within a specified range. **Task**: Write a Python function `generate_fibonacci_sequence` that: 1. Generates a sequence of Fibonacci numbers either up to a specified length or within a given range. 2. Allows the user to specify if they want the result as a list or saved to a file. **Function Signature**: ```python def generate_fibonacci_sequence(length: int=None, range_limit: int=None, file_path: str=None) -> list: Generates a Fibonacci sequence either up to a specified length or within a given range limit. If file_path is provided, saves the sequence to the file. Otherwise, returns the sequence as a list. :param length: int - optional, the number of Fibonacci numbers to generate :param range_limit: int - optional, the upper limit for the value of Fibonacci numbers :param file_path: str - optional, the path to the file where the sequence should be saved :return: list - the generated Fibonacci sequence when file_path is not provided pass ``` **Constraints**: * The function should not generate sequences if both `length` and `range_limit` are None or if both are provided. * The function should handle invalid inputs by raising appropriate exceptions. * Make sure the function performs efficiently for large sequences. **Examples**: When calling `generate_fibonacci_sequence(length=5)` without `file_path`: ```python [0, 1, 1, 2, 3] ``` When calling `generate_fibonacci_sequence(range_limit=10)` without `file_path`: ```python [0, 1, 1, 2, 3, 5, 8] ``` When calling `generate_fibonacci_sequence(length=7, file_path=\\"fibonacci.txt\\")`, the content of `fibonacci.txt` should be: ``` 0 1 1 2 3 5 8 ``` When calling `generate_fibonacci_sequence(range_limit=15, file_path=\\"fibonacci_range.txt\\")`, the content of `fibonacci_range.txt` should be: ``` 0 1 1 2 3 5 8 13 ``` Additionally, ensure your implementation handles large sequences efficiently and correctly identifies edge cases for invalid inputs.","solution":"def generate_fibonacci_sequence(length: int=None, range_limit: int=None, file_path: str=None) -> list: Generates a Fibonacci sequence either up to a specified length or within a given range limit. If file_path is provided, saves the sequence to the file. Otherwise, returns the sequence as a list. :param length: int - optional, the number of Fibonacci numbers to generate :param range_limit: int - optional, the upper limit for the value of Fibonacci numbers :param file_path: str - optional, the path to the file where the sequence should be saved :return: list - the generated Fibonacci sequence when file_path is not provided if (length is None and range_limit is None) or (length is not None and range_limit is not None): raise ValueError(\\"Specify either length or range_limit, not both or none.\\") sequence = [] a, b = 0, 1 if length is not None: for _ in range(length): sequence.append(a) a, b = b, a + b else: while a <= range_limit: sequence.append(a) a, b = b, a + b if file_path: with open(file_path, \\"w\\") as file: for number in sequence: file.write(f\\"{number}n\\") return None else: return sequence"},{"question":"Task You are asked to implement a function to merge multiple sorted linked lists into one sorted linked list. Each linked list is assumed to be individually sorted in ascending order. Your solution should efficiently combine all the linked lists into a single sorted linked list. # Function Signature ```python def merge_k_sorted_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: ... ``` # Input - `lists` (List[Optional[ListNode]]): A list of linked lists, where each linked list is sorted in ascending order. Each linked list is represented by a ListNode or None. # Constraints: - The number of linked lists `k` will be between 0 and 10^4. - Each linked list contains between 0 and 500 elements. - The value of each node in the linked lists is between -10^4 and 10^4. # Output - The function should return a single ListNode representing the head of the merged sorted linked list. # Example ```python >>> lists = [ >>> ListNode(1, ListNode(4, ListNode(5))), >>> ListNode(1, ListNode(3, ListNode(4))), >>> ListNode(2, ListNode(6)), >>> ] >>> merged_list = merge_k_sorted_lists(lists) >>> while merged_list: >>> print(merged_list.val) >>> merged_list = merged_list.next 1 1 2 3 4 4 5 6 ``` # Considerations: - You should aim for a solution with time complexity better than O(n * k), where n is the total number of elements in all the linked lists. - Use a priority queue (min-heap) to efficiently combine the elements while maintaining their order. - Consider edge cases such as when all input lists are empty or contain only a single element. # Hint: - Leveraging a min-heap can help you efficiently achieve the merging process in O(n log k) time complexity.","solution":"from typing import List, Optional import heapq class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_k_sorted_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: min_heap = [] # Create a heap for i, l in enumerate(lists): if l: heapq.heappush(min_heap, (l.val, i, l)) dummy = ListNode(0) current = dummy while min_heap: val, i, node = heapq.heappop(min_heap) current.next = ListNode(val) current = current.next if node.next: heapq.heappush(min_heap, (node.next.val, i, node.next)) return dummy.next"},{"question":"# Objective Given the coordinates of two points on the surface of the Earth, write a function that calculates the great-circle distance between them. The great-circle distance is the shortest distance over the Earth\'s surface, considering the curvature of the Earth. # Function Implementation Function 1: Calculate Great-Circle Distance - **Function Name**: `great_circle_distance` - **Input**: - `lat1` (float): Latitude of the first point (degrees). - `lon1` (float): Longitude of the first point (degrees). - `lat2` (float): Latitude of the second point (degrees). - `lon2` (float): Longitude of the second point (degrees). - **Output**: (float) Great-circle distance (kilometers). - **Constraints**: - Latitude values must be between -90 and 90 degrees. - Longitude values must be between -180 and 180 degrees. # Error Handling - Raise ValueError with appropriate messages if latitude or longitude values are out of range. # Example ```python def great_circle_distance(lat1: float, lon1: float, lat2: float, lon2: float) -> float: # Implement the function as specified above ``` Sample Usage ```python # Calculate the great-circle distance great_circle_distance(34.0522, -118.2437, 40.7128, -74.0060) # Expected output: 3940.295 # Calculate the great-circle distance for points on the equator great_circle_distance(0, 0, 0, 90) # Expected output: 10007.543 ``` # Notes - Use the `math` module\'s `radians`, `sin`, `cos`, `sqrt`, and `atan2` functions for calculations. - The radius of the Earth should be assumed as 6371.0 kilometers. - The formula for great-circle distance can be derived from the Haversine formula: [ text{{distance}} = 2 times R times text{{asin}}left(sqrt{sin^2left(frac{Deltaphi}{2}right) + cos(phi1) times cos(phi2) times sin^2left(frac{Deltalambda}{2}right)}right) ] Where: - (phi1, phi2) are the latitudes in radians - (Deltaphi) is the difference between the latitudes in radians - (Deltalambda) is the difference between the longitudes in radians - (R) is the Earth\'s radius (6371.0 km)","solution":"import math def great_circle_distance(lat1: float, lon1: float, lat2: float, lon2: float) -> float: Calculates the great-circle distance between two points specified by latitude and longitude on the Earth\'s surface. Parameters: - lat1: Latitude of the first point in degrees. - lon1: Longitude of the first point in degrees. - lat2: Latitude of the second point in degrees. - lon2: Longitude of the second point in degrees. Returns: - Great-circle distance in kilometers. Raises: - ValueError: If any of the latitude or longitude values are out of range. if not (-90 <= lat1 <= 90): raise ValueError(\\"Latitude 1 is out of range. Must be between -90 and 90.\\") if not (-180 <= lon1 <= 180): raise ValueError(\\"Longitude 1 is out of range. Must be between -180 and 180.\\") if not (-90 <= lat2 <= 90): raise ValueError(\\"Latitude 2 is out of range. Must be between -90 and 90.\\") if not (-180 <= lon2 <= 180): raise ValueError(\\"Longitude 2 is out of range. Must be between -180 and 180.\\") # Convert degrees to radians lat1, lon1, lat2, lon2 = map(math.radians, [lat1, lon1, lat2, lon2]) # Haversine formula dlat = lat2 - lat1 dlon = lon2 - lon1 a = math.sin(dlat / 2)**2 + math.cos(lat1) * math.cos(lat2) * math.sin(dlon / 2)**2 c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a)) # Radius of Earth in kilometers R = 6371.0 distance = R * c return distance"},{"question":"# Question: Inventory Management System You are asked to write a simple inventory management system for a small store. This system should manage adding, removing, and checking stock levels of items. Function 1: `add_item(inventory: dict, item_name: str, quantity: int) -> dict` **Add a specific quantity of an item to the inventory.** - **Input**: - `inventory` (dict): The current inventory, where keys are item names and values are their quantities. - `item_name` (str): The name of the item to add. - `quantity` (int): The quantity of the item to add. - **Output**: - `dict`: Updated inventory after adding the specified quantity of the item. - **Constraints**: - `quantity` must be greater than 0. Function 2: `remove_item(inventory: dict, item_name: str, quantity: int) -> dict` **Remove a specific quantity of an item from the inventory.** - **Input**: - `inventory` (dict): The current inventory, where keys are item names and values are their quantities. - `item_name` (str): The name of the item to remove. - `quantity` (int): The quantity of the item to remove. - **Output**: - `dict`: Updated inventory after removing the specified quantity of the item. - **Constraints**: - `quantity` must be greater than 0. - If `quantity` exceeds the current stock of the item, remove only as much as available (do not set the quantity to a negative value). Function 3: `check_stock(inventory: dict, item_name: str) -> int` **Check the stock level of a specific item.** - **Input**: - `inventory` (dict): The current inventory, where keys are item names and values are their quantities. - `item_name` (str): The name of the item to check. - **Output**: - `int`: The current stock level of the specified item. - **Constraints**: - If the item is not found in the inventory, return 0. # Testing & Validation - Include checks for invalid inputs such as negative quantity values. - Use various test cases to validate the correctness of your implementation. For example: - Adding items to the inventory. - Removing items, including attempting to remove more than is available. - Checking stock levels before and after adding/removing items. - Handling cases when items do not exist in the inventory during removal or stock checking.","solution":"def add_item(inventory: dict, item_name: str, quantity: int) -> dict: Add a specific quantity of an item to the inventory. if quantity <= 0: return inventory if item_name in inventory: inventory[item_name] += quantity else: inventory[item_name] = quantity return inventory def remove_item(inventory: dict, item_name: str, quantity: int) -> dict: Remove a specific quantity of an item from the inventory. if quantity <= 0: return inventory if item_name in inventory: inventory[item_name] = max(inventory[item_name] - quantity, 0) return inventory def check_stock(inventory: dict, item_name: str) -> int: Check the stock level of a specific item. return inventory.get(item_name, 0)"},{"question":"# Coding Assessment Question Given an integer array nums of length n and an integer target, implement a function `three_sum(nums: List[int], target: int) -> List[List[int]]` to find all unique triplets in the array which give the sum of the target. Input * `nums`: A list of integers (0 ≤ length of nums ≤ 10^3) * `target`: An integer representing the target sum. # Output * A list of lists, where each inner list contains three integers representing a triplet whose sum is equal to the target. Constraints * The solution set must not contain duplicate triplets. * The array of integers can contain both positive and negative numbers and zeros. Example Input 1: ```python nums = [-1, 0, 1, 2, -1, -4] target = 0 ``` Output 1: ```python [[-1, -1, 2], [-1, 0, 1]] ``` Input 2: ```python nums = [1, 2, -2, -1] target = 1 ``` Output 2: ```python [[1, -2, 2]] ``` Explanation * In the first example, the numbers -1, 0, and 1 add up to 0, and the numbers -1, -1, and 2 also add up to 0. * In the second example, the numbers 1, -2, and 2 add up to 1. Performance Requirements * Your solution should efficiently handle the constraints and provide the correct output within a reasonable time frame even for the upper limit of input size. Notes * You can assume the input list is not sorted. * Clearly explain your thought process and code implementation in comments.","solution":"def three_sum(nums, target): Returns all unique triplets in the array which sum to the given target. nums.sort() result = [] n = len(nums) for i in range(n): # Avoid duplicates for the first element of the triplet if i > 0 and nums[i] == nums[i - 1]: continue left, right = i + 1, n - 1 while left < right: sum_three = nums[i] + nums[left] + nums[right] if sum_three == target: result.append([ nums[i], nums[left], nums[right] ]) # Avoid duplicates for the second element of the triplet while left < right and nums[left] == nums[left + 1]: left += 1 # Avoid duplicates for the third element of the triplet while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif sum_three < target: left += 1 else: right -= 1 return result"},{"question":"# File Systems and Directory Operations **Context**: A software company is developing a tool to manage and organize files in a large directory structure. You have been tasked with implementing a function that traverses directories and performs various operations on the files. # Task: Implement the `organize_files` function to traverse the directory tree and perform specified operations on the files. The `organize_files` function should: 1. Recursively list all files in a given directory and its subdirectories. 2. Categorize files based on their extensions into designated folders (e.g., `.txt` files in a `TextFiles` folder, `.jpg` files in an `Images` folder). 3. Remove any empty directories after categorization. # Function Signature: ```python import os import shutil def organize_files( start_dir: str, organization_map: dict ) -> None: pass ``` # Input: - `start_dir (str)`: The root directory to start from. - `organization_map (dict)`: A dictionary mapping file extensions to their target directories (e.g., {\'.txt\': \'TextFiles\', \'.jpg\': \'Images\'}). # Output: - The function doesn\'t return anything. It organizes the files in place. # Constraints: - Assume valid input directories and mappings. - Handle any I/O exceptions that might occur during file operations. - Ensure that directory traversal is efficient and handles deep directory structures. # Example: ```python # Directory structure before running the function: # start_dir/ # ├── sample1.txt # ├── sample2.jpg # ├── folder1/ # │ └── sample3.txt # └── folder2/ # ├── sample4.jpg # └── folder3/ # └── sample5.txt organization_map = { \'.txt\': \'TextFiles\', \'.jpg\': \'Images\' } start_dir = \'start_dir\' organize_files(start_dir, organization_map) # Directory structure after running the function: # start_dir/ # ├── TextFiles/ # │ ├── sample1.txt # │ ├── sample3.txt # │ └── sample5.txt # ├── Images/ # │ ├── sample2.jpg # │ └── sample4.jpg # └── (empty directories removed) ``` **Expectation**: A solution that effectively traverses the directory tree for organizing files while robustly handling edge cases, such as file conflicts and I/O errors.","solution":"import os import shutil def organize_files(start_dir: str, organization_map: dict) -> None: Recursively list all files in the given directory and its subdirectories. Categorize files based on their extensions into designated folders. Remove any empty directories after categorization. :param start_dir: The root directory to start from. :param organization_map: A dictionary mapping file extensions to their target directories. # Traverse the directory tree for root, dirs, files in os.walk(start_dir, topdown=False): for name in files: file_path = os.path.join(root, name) _, ext = os.path.splitext(name) if ext in organization_map: target_dir = os.path.join(start_dir, organization_map[ext]) os.makedirs(target_dir, exist_ok=True) shutil.move(file_path, os.path.join(target_dir, name)) # Remove empty directories if root != start_dir and not os.listdir(root): os.rmdir(root)"},{"question":"# Coding Question Scenario You are creating a component of a banking application that generates unique transaction IDs. Each transaction ID is a string consisting of two parts: a 4-letter alphabetical prefix and a 6-digit numerical suffix. The goal is to verify the uniqueness of generated transaction IDs in the system. Objective Implement the `generate_unique_ids` function that generates a specified number of unique transaction IDs using a supplied prefix. The IDs should be distinct within a single function call and across multiple calls. Function Signature ```python class TransactionIDGenerator: def __init__(self): pass def generate_unique_ids(self, prefix: str, count: int) -> list[str]: ``` Input * `prefix`: A string of exactly 4 uppercase alphabetical characters. * `count`: An integer denoting the number of unique transaction IDs to generate. Output * A list of strings, where each string is a unique transaction ID starting with the given prefix and followed by a unique 6-digit numerical suffix. Constraints * The `prefix` will always be 4 uppercase letters (A-Z). * `count` will be a non-negative integer not exceeding 10^5. * The numerical suffix will be exactly 6 digits, ranging from \'000000\' to \'999999\'. * Each call to the function must ensure IDs are unique across that call and all previous calls. Example ```python gen = TransactionIDGenerator() assert gen.generate_unique_ids(\\"ABCD\\", 5) == [\\"ABCD000000\\", \\"ABCD000001\\", \\"ABCD000002\\", \\"ABCD000003\\", \\"ABCD000004\\"] assert gen.generate_unique_ids(\\"WXYZ\\", 3) == [\\"WXYZ000000\\", \\"WXYZ000001\\", \\"WXYZ000002\\"] assert gen.generate_unique_ids(\\"ABCD\\", 3) == [\\"ABCD000005\\", \\"ABCD000006\\", \\"ABCD000007\\"] ``` Constraints & Performance Requirements * The function should efficiently manage and generate IDs even for the upper limit of `count`. * The function should maintain the uniqueness of IDs generated across multiple invocations. * Optimize for memory usage while ensuring a simple and clear implementation. Instructions 1. Implement the `TransactionIDGenerator` class with the method `generate_unique_ids`. 2. Ensure the method maintains the uniqueness of transaction IDs for the specified prefix across multiple calls. 3. Handle edge cases and validate correctness using the provided examples and constraints.","solution":"class TransactionIDGenerator: def __init__(self): self.prefix_counter = {} def generate_unique_ids(self, prefix: str, count: int) -> list[str]: if prefix not in self.prefix_counter: self.prefix_counter[prefix] = 0 ids = [] for _ in range(count): suffix = f\\"{self.prefix_counter[prefix]:06d}\\" ids.append(f\\"{prefix}{suffix}\\") self.prefix_counter[prefix] += 1 return ids"},{"question":"# Problem Statement You are tasked with developing a function that calculates the minimum cost to reach the last cell in a grid of size `m x n` starting from the top-left cell (1,1). Each cell in the grid contains a cost, and you can only move right or down from a cell. The goal is to find the path to the bottom-right cell (m,n) which accumulates the minimum cost. # Function Signature ```python def min_path_sum(grid: List[List[int]]) -> int: Given a 2D list `grid` representing the cost in each cell, returns the minimum cost to reach the bottom-right cell. Parameters: grid (List[List[int]]): the 2D grid with the cost to enter each cell. Returns: int: the minimum cost to reach the bottom-right cell. ``` # Input - A 2D grid `grid` with integer costs, where 1 ≤ len(grid), len(grid[0]) ≤ 100 and each cell\'s cost is a non-negative integer. # Output - An integer representing the minimum cost to reach the bottom-right cell from the top-left cell. # Example Usage ```python assert min_path_sum([ [1, 3, 1], [1, 5, 1], [4, 2, 1] ]) == 7 assert min_path_sum([ [1, 2, 3], [4, 5, 6] ]) == 12 ``` # Explanation The solution requires setting up a dynamic programming table to keep track of the minimum cost to reach each cell. You start from the top-left and move either right or down, accumulating the minimum possible cost at each step until you reach the bottom-right cell. # Additional Notes - Ensure that the implementation handles the constraints efficiently to avoid excessive runtime. - Consider edge cases such as grids with minimal and maximal dimensions effectively. - Aim to utilize a space-optimized solution by leveraging the inherent properties of the grid.","solution":"from typing import List def min_path_sum(grid: List[List[int]]) -> int: Given a 2D list `grid` representing the cost in each cell, returns the minimum cost to reach the bottom-right cell. if not grid: return 0 m, n = len(grid), len(grid[0]) # Create a 2D dp array to store the minimum path sum at each cell dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] # Initialize the first row: for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Initialize the first column: for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill in the rest of the dp array for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[m-1][n-1]"},{"question":"# Scenario You have been contacted by an educational platform that wants to analyze students\' performance. They need a function to help determine the average scores of students, excluding the highest and lowest scores to avoid potential biases from outliers. # Problem Statement Implement a function `average_excluding_extremes` that computes the average of a list of scores, ignoring the highest and lowest scores. If the list contains less than 3 scores, return `None` as it\'s impossible to exclude both the highest and lowest scores. # Function Signature ```python def average_excluding_extremes(scores: List[int]) -> Optional[float]: ``` # Input * A list of `scores` where each element is an integer representing a student\'s score. # Output * A float representing the average of the scores excluding the highest and lowest scores. If the list contains less than 3 scores, return `None`. # Constraints * The `scores` list can contain at most 10^4 elements. * Each score is an integer between 0 and 100, inclusive. # Requirements * Ensure the function handles cases with duplicate highest and lowest scores appropriately. * Return the average with a precision of two decimal places. # Examples ```python assert average_excluding_extremes([50, 80, 90, 70, 60]) == 70.0 assert average_excluding_extremes([100, 90, 90, 90, 80]) == 90.0 assert average_excluding_extremes([100]) == None assert average_excluding_extremes([50, 50, 50, 50]) == 50.0 assert average_excluding_extremes([]) == None ``` # Performance * The function should handle edge cases efficiently and should not raise any errors for valid inputs. Write your implementation below: ```python def average_excluding_extremes(scores: List[int]) -> Optional[float]: if len(scores) < 3: return None scores = sorted(scores) average = sum(scores[1:-1]) / (len(scores) - 2) return round(average, 2) # Example test cases assert average_excluding_extremes([50, 80, 90, 70, 60]) == 70.0 assert average_excluding_extremes([100, 90, 90, 90, 80]) == 90.0 assert average_excluding_extremes([100]) == None assert average_excluding_extremes([50, 50, 50, 50]) == 50.0 assert average_excluding_extremes([]) == None ```","solution":"from typing import List, Optional def average_excluding_extremes(scores: List[int]) -> Optional[float]: Calculate the average of the list of scores excluding the highest and lowest scores. If there are fewer than 3 scores, return None. if len(scores) < 3: return None scores = sorted(scores) sum_of_scores = sum(scores[1:-1]) count_of_scores = len(scores) - 2 average = sum_of_scores / count_of_scores return round(average, 2)"},{"question":"# Problem Statement You are designing a feature for an e-commerce website that needs to analyze customer purchase data. The feature should identify how many unique products each customer has purchased over time. Your task is to implement a function that takes a list of customer transactions and returns a dictionary where the keys are the customer IDs and the values are sets containing the unique product IDs they have purchased. # Function Signature ```python def unique_products_purchased(transactions: List[Tuple[int, int]]) -> Dict[int, Set[int]]: pass ``` # Input * A list of tuples `transactions` of length `m`, where each tuple contains two integers: * `customer_id` — a unique identifier for each customer. * `product_id` — a unique identifier for each product. # Output * A dictionary where the keys are customer IDs and the values are sets of unique product IDs that the respective customers have purchased. # Constraints * Each transaction tuple will have valid non-negative integers. * The function should handle up to `10^6` transactions efficiently. # Examples ```python >>> unique_products_purchased([(1, 101), (2, 101), (1, 102), (3, 103), (1, 101)]) {1: {101, 102}, 2: {101}, 3: {103}} >>> unique_products_purchased([(1, 201), (2, 202), (2, 203), (1, 201), (3, 204)]) {1: {201}, 2: {202, 203}, 3: {204}} >>> unique_products_purchased([]) {} ``` # Notes 1. Ensure the function handles edge cases like empty input gracefully. 2. The function should be optimized to work efficiently even with the upper limit of transactions. 3. Consider using appropriate data structures to ensure the sets of unique product IDs are created and managed efficiently.","solution":"from typing import List, Tuple, Dict, Set def unique_products_purchased(transactions: List[Tuple[int, int]]) -> Dict[int, Set[int]]: Given a list of customer transactions, return a dictionary where the keys are customer IDs and the values are sets containing the unique product IDs they have purchased. purchase_dict = {} for customer_id, product_id in transactions: if customer_id not in purchase_dict: purchase_dict[customer_id] = set() purchase_dict[customer_id].add(product_id) return purchase_dict"},{"question":"# Context You are given a matrix where each cell represents a different elevation. Implementing various landscape transformations is an essential part of terrain analysis, where the task can often involve manipulating the elevation profiles. # Task Implement a function `set_zero_if_isolated(self) -> None` within the `Matrix` class that examines each cell\'s elevation and sets the cell’s value to zero if it\'s not a border cell and all of its orthogonal adjacent cells (up, down, left, right) are of higher value. If a cell is a border cell, it should remain unchanged. # Function Signature ```python class Matrix: def set_zero_if_isolated(self) -> None: # Your code here ``` # Input * The matrix is represented as a list of lists of integers, where each integer represents the elevation at that cell. # Output * The function modifies the matrix in place, setting the eligible cells\' values to zero without returning anything. # Constraints * Height (h) and width (w) of the matrix are in the range [1, 100]. # Example ```python >>> mat = Matrix([ ... [1, 2, 3], ... [4, 1, 5], ... [7, 8, 6] ... ]) >>> mat.set_zero_if_isolated() >>> mat.matrix [ [1, 2, 3], [4, 0, 5], [7, 8, 6] ] >>> mat = Matrix([ ... [5, 4], ... [3, 6] ... ]) >>> mat.set_zero_if_isolated() >>> mat.matrix [ [5, 4], [3, 6] ] ``` # Notes * Only cells that are not on the border of the matrix and strictly less than their orthogonal neighbors should be set to zero. * The matrix representation before and after should be consistently handled using the provided classes and methods for accurate testing.","solution":"class Matrix: def __init__(self, matrix): self.matrix = matrix def set_zero_if_isolated(self): rows, cols = len(self.matrix), len(self.matrix[0]) if rows <= 2 or cols <= 2: return original = [row[:] for row in self.matrix] for r in range(1, rows - 1): for c in range(1, cols - 1): if (original[r][c] < original[r-1][c] and original[r][c] < original[r+1][c] and original[r][c] < original[r][c-1] and original[r][c] < original[r][c+1]): self.matrix[r][c] = 0"},{"question":"# Database Query for Customer Orders You are given a database of customer orders with tables for `Customers`, `Orders`, and `OrderDetails`. Your task is to write a SQL query to fetch specific customer order details based on given conditions. # Detailed Requirements 1. **Table Definitions**: - **Customers**: Contains `CustomerID`, `CustomerName`, `ContactName`, `Country`. - **Orders**: Contains `OrderID`, `CustomerID`, `OrderDate`. - **OrderDetails**: Contains `OrderDetailID`, `OrderID`, `ProductID`, `Quantity`. 2. **Query Conditions**: * Fetch customer order details for all customers from a given country. * The required details include `CustomerName`, `OrderDate`, `ProductID`, and `Quantity`. * Order the result by `OrderDate` in descending order. 3. **Handling Edge Cases**: * If no matching customer orders are found, the query should return an empty result set. * Ensure robust handling of potential NULL values or missing data in any of the fields. 4. **Performance Considerations**: * Ensure the query is optimized for large datasets and runs efficiently within reasonable time limits. # SQL Query Structure ```sql SELECT Customers.CustomerName, Orders.OrderDate, OrderDetails.ProductID, OrderDetails.Quantity FROM Customers JOIN Orders ON Customers.CustomerID = Orders.CustomerID JOIN OrderDetails ON Orders.OrderID = OrderDetails.OrderID WHERE Customers.Country = \'<given_country>\' ORDER BY Orders.OrderDate DESC; ``` # Input * You will be executing the query with a specific country parameter (e.g., \\"USA\\"). # Output A table (result set) with the following columns: * `CustomerName` (str): The name of the customer. * `OrderDate` (date): The date when the order was placed. * `ProductID` (int): The ID of the product ordered. * `Quantity` (int): The quantity of the product ordered. # Constraints * The query should be able to handle up to 50,000 customer records without significant performance degradation. * Ensure accurate mapping and joining of customer and order details. * The result set should accurately reflect the filtering condition and ordering specification. # Example ```sql Given \'Country\' input as \'USA\', the query should fetch the following: +-----------------+---------------------+------------+----------+ | CustomerName | OrderDate | ProductID | Quantity | +-----------------+---------------------+------------+----------+ | John Doe | 2023-09-15 | 105 | 10 | | Jane Smith | 2023-09-10 | 108 | 5 | | Michael Johnson | 2023-09-01 | 202 | 7 | # Additional rows... +-----------------+---------------------+------------+----------+ ```","solution":"def sql_query_for_country_orders(country): Returns the SQL query to fetch customer order details for all customers from a given country. query = f SELECT Customers.CustomerName, Orders.OrderDate, OrderDetails.ProductID, OrderDetails.Quantity FROM Customers JOIN Orders ON Customers.CustomerID = Orders.CustomerID JOIN OrderDetails ON Orders.OrderID = OrderDetails.OrderID WHERE Customers.Country = \'{country}\' ORDER BY Orders.OrderDate DESC; return query"},{"question":"# Problem Statement Design a Python function that simulates a basic in-memory key-value store with time-bound key entries. This store should support setting a key with an associated value and an expiration time, retrieving the value of a key if it hasn\'t expired, and deleting a key manually. **Function Signatures:** ```python class InMemoryStore: def __init__(self): Initializes the in-memory key-value store. def set(self, key: str, value: Any, ttl: int) -> None: Set the value for a key with a given time-to-live (ttl). :param key: The key as a string. :param value: The value associated with the key. Can be any valid Python data type. :param ttl: Time-to-live for the key in seconds. :return: None def get(self, key: str) -> Any: Retrieve the value of a key if it hasn\'t expired. :param key: The key as a string. :return: The value associated with the key, or None if the key does not exist or has expired. def delete(self, key: str) -> None: Delete the key from the store if it exists. :param key: The key as a string. :return: None ``` # Input: - `set` function: A string `key`, any type `value`, and an integer `ttl` representing time-to-live in seconds. - `get` function: A string `key`. - `delete` function: A string `key`. # Output: - `get` function: Returns the value associated with `key` if it hasn\'t expired, otherwise returns `None`. - `set` and `delete` functions: Do not return anything (None). # Constraints: - `ttl` is a positive integer representing seconds. - The key is a lowercase string of ASCII characters. - Implement appropriate exception handling and validation for input parameters. # Example: ```python store = InMemoryStore() store.set(\\"foo\\", \\"bar\\", 10) print(store.get(\\"foo\\")) # Should return \\"bar\\" if called within 10 seconds store.delete(\\"foo\\") print(store.get(\\"foo\\")) # Should return None since \\"foo\\" was deleted store.set(\\"abc\\", 123, 5) print(store.get(\\"abc\\")) # Should return 123 if called within 5 seconds print(store.get(\\"xyz\\")) # Should return None since \\"xyz\\" does not exist ``` # Notes: 1. Ensure the `set` method correctly handles the `ttl` and allows the value to expire after the specified time. 2. Implement time-bound expiration checks efficiently. 3. The class should be performant and correctly handle concurrent access if utilized in a multithreaded environment.","solution":"import time from typing import Any class InMemoryStore: def __init__(self): # Store will hold the key-value pairs and their expiration times self.store = {} def set(self, key: str, value: Any, ttl: int) -> None: Set the value for a key with a given time-to-live (ttl). if not isinstance(key, str): raise TypeError(\\"Key must be a string\\") if not isinstance(ttl, int) or ttl <= 0: raise ValueError(\\"TTL must be a positive integer\\") expires_at = time.time() + ttl self.store[key] = (value, expires_at) def get(self, key: str) -> Any: Retrieve the value of a key if it hasn\'t expired. entry = self.store.get(key) if entry: value, expires_at = entry if time.time() < expires_at: return value else: # Remove expired key del self.store[key] return None def delete(self, key: str) -> None: Delete the key from the store if it exists. if key in self.store: del self.store[key]"},{"question":"# String Compression Algorithm in Python In data compression, algorithms aim to reduce the amount of space required to store data. One simple form of compression is run-length encoding (RLE), where consecutive identical elements are replaced with a single element and a count. You are required to implement a function in Python that performs basic string compression using the counts of repeated characters. If the compressed string is not shorter than the original, return the original string. # Function Signature ```python def string_compression(s: str) -> str: pass ``` # Input: - `s` (str): A non-empty string consisting of only uppercase and lowercase alphabetic characters. # Output: - Return the compressed string or the original string if compression does not reduce the length. # Constraints: - The input string `s` has a length between 1 and 10^5. # Implementation Notes: 1. Perform run-length encoding on the input string. 2. Traverse the string and count consecutive identical characters. 3. Construct the compressed string and compare its length with the original string. 4. Return the shorter string (or the original if lengths are the same). # Example Usage: ```python string_compression(\\"aabcccccaaa\\") # => \\"a2b1c5a3\\" string_compression(\\"abcdef\\") # => \\"abcdef\\" string_compression(\\"aabbcc\\") # => \\"aabbcc\\" string_compression(\\"aaAAaa\\") # => \\"aaAAaa\\" ``` # Unit Testing: Ensure your solution is thoroughly tested with the following sample cases as well as edge cases: - `string_compression(\\"aaaBBBccC\\")` should return `a3B3c2C1`. - `string_compression(\\"xyz\\")` should return `xyz`. - `string_compression(\\"aabcccccaaa\\")` should return `a2b1c5a3`. - `string_compression(\\"Aaa\\")` should return `Aaa`. - `string_compression(\\"aaaa\\")` should return `a4`. Implement your solution to ensure it handles both lower and upper case letters on an individual basis and efficiently processes long strings up to the constraint limit.","solution":"def string_compression(s: str) -> str: if not s: return s compressed_parts = [] current_char = s[0] current_count = 1 for char in s[1:]: if char == current_char: current_count += 1 else: compressed_parts.append(current_char + str(current_count)) current_char = char current_count = 1 compressed_parts.append(current_char + str(current_count)) compressed_string = \'\'.join(compressed_parts) return compressed_string if len(compressed_string) < len(s) else s"},{"question":"# Coding Assignment: Implement a Custom Sorting Algorithm Scenario As a senior software engineer at a logistics company, you have been assigned the task of developing a custom sorting algorithm that sorts packages based on multiple criteria. The criteria include package weight, delivery priority, and the destination warehouse\'s identifier. Problem Statement Implement a custom sorting algorithm that sorts packages primarily by their delivery priority, secondarily by their weight in ascending order, and finally by their destination warehouse\'s identifier in lexicographical order. The custom sort function will be used to organize packages for efficient loading and delivery. Requirements 1. **Function Signature**: Specify a function `custom_sort(packages: list[tuple[int, int, str]]) -> list[tuple[int, int, str]]`. 2. **Input Format**: - `packages`: A list of tuples. Each tuple represents a package and contains: - An integer for the package weight (in kilograms). - An integer for the delivery priority (where a lower number indicates higher priority). - A string representing the destination warehouse\'s identifier. 3. **Output Format**: - Return a list of tuples sorted based on the specified criteria (priority, weight, and destination). 4. **Constraints**: - The algorithm should handle lists with up to 10,000 packages. - Each package\'s weight will be a positive integer. - Delivery priority will be a non-negative integer. - Warehouse identifiers will be non-empty strings consisting of alphanumeric characters. 5. **Performance Requirements**: - Aim for a solution with a time complexity of (O(n log n)) due to the use of a sorting algorithm. - Ensure the solution is efficient in handling large lists of packages. Example ```python packages = [(10, 2, \'B1\'), (5, 1, \'A1\'), (8, 2, \'A2\'), (7, 1, \'B1\')] assert custom_sort(packages) == [(5, 1, \'A1\'), (7, 1, \'B1\'), (8, 2, \'A2\'), (10, 2, \'B1\')] ``` Notes 1. Implement the function `custom_sort`. 2. Utilize Python\'s built-in sorting capabilities, considering custom key functions if necessary. 3. Ensure your implementation is robust enough to handle edge cases and adheres to the constraints. Implement the solution in Python and verify its correctness using the provided example and additional test cases as needed.","solution":"def custom_sort(packages): Sorts the packages by delivery priority, weight, and destination warehouse. Parameters: packages (list of tuples): A list where each tuple contains (weight, priority, destination). Returns: list of tuples: Sorted list of packages. return sorted(packages, key=lambda x: (x[1], x[0], x[2]))"},{"question":"# Scenario You are working on software that needs to filter out specific elements from a list based on a custom condition applied to each entry. Your colleague is struggling to transform each element of a list based on a given function and remove elements that don\'t meet certain criteria. # Problem Statement Write a function `filter_and_transform(arr: List[int], condition: Callable[[int], bool], transform: Callable[[int], int]) -> List[int]` that takes a list of integers `arr`, a `condition` function, and a `transform` function. The function should first apply the `condition` to each element and only include elements where the condition returns `True`. Then, it should apply the `transform` function to each of the filtered elements and return the new list. # Input/Output Format * **Input**: * A list of integers `arr`, where `1 <= len(arr) <= 10^6` and each integer `1 <= arr[i] <= 10^6` * A callable `condition` function that takes an integer and returns a boolean * A callable `transform` function that takes an integer and returns an integer * **Output**: * A list of integers resulting from filtering and transforming, in the order they appear in the original list. # Constraints * The solution should be efficient and handle the upper limits within a reasonable time. * Handle edge cases appropriately where despite filtering, the resultant list can be empty. # Example ```python >>> filter_and_transform([1, 2, 3, 4, 5, 6], lambda x: x % 2 == 0, lambda x: x * 2) [4, 8, 12] >>> filter_and_transform([1, 3, 5, 7], lambda x: x > 5, lambda x: x + 1) [6, 8] >>> filter_and_transform([2, 4, 6, 8], lambda x: x % 2 != 0, lambda x: x - 1) [] >>> filter_and_transform([10, 20, 30, 40], lambda x: x < 25, lambda x: x // 2) [5, 10] ``` # Guidance Ensure your implementation effectively utilizes list comprehension or similar constructs to maintain both readability and performance. The condition filtering and transformation steps should be applied in sequence, guaranteeing that performance is optimized even for larger list sizes.","solution":"from typing import List, Callable def filter_and_transform(arr: List[int], condition: Callable[[int], bool], transform: Callable[[int], int]) -> List[int]: Filters elements of `arr` based on `condition` and then transforms them using `transform` function. Args: arr (List[int]): List of integers. condition (Callable[[int], bool]): Function to filter elements. transform (Callable[[int], int]): Function to transform elements. Returns: List[int]: List of transformed integers that meet the condition. return [transform(x) for x in arr if condition(x)]"},{"question":"# K Largest Elements You are required to implement a function to find the `k` largest elements from a given list of integers. Your implementation should return the `k` largest elements sorted in descending order. If the list contains fewer than `k` elements, return the whole list sorted in descending order. Input - `nums`: A list of integers. (0 ≤ length of `nums` ≤ (10^5)) - `k`: An integer representing the number of largest elements to find. (1 ≤ k ≤ (10^5)) Output - A list of integers representing the `k` largest elements in the input list, sorted in descending order. Constraints - The input list can contain negative numbers, zeros, and positive numbers. - If the input list `nums` is empty, an empty list should be returned. Example ```python nums = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5] k = 3 print(find_k_largest(nums, k)) # Output: [9, 6, 5] ``` **Function Signature** ```python def find_k_largest(nums: list[int], k: int) -> list[int]: pass ``` Instructions 1. Define the function `find_k_largest` using the provided signature. 2. Implement the logic to find the `k` largest elements efficiently. 3. Ensure your solution handles edge cases, such as empty input list, `k` larger than the length of the list, etc. 4. Optimize your solution to handle the maximum input size effectively.","solution":"def find_k_largest(nums: list[int], k: int) -> list[int]: Returns the k largest elements from the list `nums` in descending order. If the list has fewer than k elements, returns all elements sorted in descending order. if not nums or k <= 0: return [] # Ensure k does not exceed the length of nums k = min(k, len(nums)) # Use a heap to efficiently find the k largest elements import heapq largest_elements = heapq.nlargest(k, nums) # Sort the resulting elements in descending order largest_elements.sort(reverse=True) return largest_elements"},{"question":"# Problem Statement In geometry and physics, the concept of vector operations is fundamental for various calculations. One of the common operations is the dot product (scalar product) of two vectors. Your task is to implement a function that computes the dot product of two vectors. # Implement the Function ```python def dot_product(vector_a: list, vector_b: list) -> float: Calculate the dot product of two vectors. Parameters: - vector_a (list): A list of floats representing the first vector. - vector_b (list): A list of floats representing the second vector. Returns: - result (float): The dot product of the two vectors. Example: >>> dot_product([1, 2, 3], [4, 5, 6]) 32.0 >>> dot_product([1.5, 2.5], [3.5, 4.5]) 16.75 >>> dot_product([0, 0, 0], [1, 2, 3]) 0.0 >>> dot_product([1, 2], [3]) None # The vectors are of different lengths. Constraints: - Each vector can have up to 100 elements. - Each element in the vectors is a float. - If the vectors are of different lengths, return None. pass ``` # Requirements: 1. **Validation**: * Ensure the vectors are of the same length. If not, return `None`. 2. **Calculation**: * Calculate the dot product using the formula: ( text{Dot Product} = sum_{i=1}^{n} (a_i cdot b_i) ) 3. **Precision**: * Use floating-point arithmetic to accommodate decimals accurately. 4. **Edge Cases**: * Handle cases where all elements are zero. * Handle vectors of varying lengths correctly by returning `None` when lengths do not match. Implement the `dot_product` function as described. Use the provided test cases to ensure your function works correctly.","solution":"def dot_product(vector_a: list, vector_b: list) -> float: Calculate the dot product of two vectors. Parameters: - vector_a (list): A list of floats representing the first vector. - vector_b (list): A list of floats representing the second vector. Returns: - result (float): The dot product of the two vectors. If the vectors are of different lengths, returns None. if len(vector_a) != len(vector_b): return None return sum(a * b for a, b in zip(vector_a, vector_b))"},{"question":"# Problem Description You are given a class called `CharStack` that implements a stack to store characters. Your task is to extend the functionality of this `CharStack` by implementing a method that supports undo operations. The stack should allow undoing a specified number of recent push operations. # Objective Write a method called `undo_push` for the `CharStack` class that reverses the effect of the `push` method by the given number of steps. # Function Specification **Method Signature:** ```python class CharStack: def undo_push(self, n: int) -> None: pass ``` **Parameters:** * `n` (int): The number of push operations to undo. **Output:** * The method does not return anything. It modifies the current stack to remove the last `n` characters that were pushed. # Constraints: * Assume `n` will always be less than or equal to the number of elements in the stack. * The stack only contains single characters (e.g., `\'a\'`, `\'b\'`, etc.). # Requirements: 1. The method should remove exactly the last `n` elements that were pushed onto the stack. 2. The operation should be efficient, with an average O(n) complexity. # Examples: ```python # Example 1: cs = CharStack() cs.push(\'a\') cs.push(\'b\') cs.push(\'c\') cs.undo_push(2) print(cs.to_list()) # Output: [\'a\'] # Example 2: cs = CharStack() cs.push(\'x\') cs.push(\'y\') cs.push(\'z\') cs.undo_push(1) print(cs.to_list()) # Output: [\'x\', \'y\'] # Example 3: cs = CharStack() cs.push(\'p\') cs.push(\'q\') cs.undo_push(1) print(cs.to_list()) # Output: [\'p\'] ``` # Notes: 1. Ensure the `undo_push` method only affects the last `n` push operations while keeping the rest of the stack intact. 2. Provide adequate testing using the given scenarios to cover edge cases.","solution":"class CharStack: def __init__(self): self.stack = [] def push(self, char: str) -> None: self.stack.append(char) def pop(self) -> str: return self.stack.pop() def to_list(self) -> list: return self.stack.copy() def undo_push(self, n: int) -> None: for _ in range(n): self.pop()"},{"question":"# **Employee Salary Adjustments** # Problem Statement: Create a system to manage salary adjustments for employees at a company. Given the initial salary data of employees and a set of yearly salary adjustments (which could be positive for raises or negative for cuts), the system will calculate the updated salaries and generate a summary report. # Function Definitions: Function 1: `get_employee_data() -> dict` - **Input**: None. - **Output**: A dictionary where the keys are employee IDs (strings) and the values are the initial salaries (floats). - **Constraints**: * The function should prompt the user to input data for multiple employees and their salaries in the format `employee_id,initial_salary` until an empty string is entered. * The salary must be a non-negative number; if invalid input is detected, raise a `ValueError(\\"Invalid salary input\\")`. Function 2: `apply_salary_adjustments(employee_data: dict, adjustments: dict) -> dict` - **Input**: * `employee_data`: A dictionary of the initial salaries keyed by employee IDs as returned by `get_employee_data`. * `adjustments`: A dictionary where the keys are employee IDs (strings) and the values are the salary adjustments (floats). - **Output**: A dictionary with the updated salaries after adjustments. - **Constraints**: * If an employee ID in `adjustments` does not exist in `employee_data`, it should be ignored. * Adjustments can be positive or negative, resulting in corresponding changes in salaries. Function 3: `salary_summary_report(employee_data: dict) -> None` - **Input**: A dictionary of the updated salaries keyed by employee IDs as returned by `apply_salary_adjustments`. - **Output**: None. - **Operation**: * Prints a summary report of all employees, listing their employee ID and updated salary in a clear format. # Task Instructions: 1. Implement the `get_employee_data` function to collect initial salary data interactively from the user. 2. Implement the `apply_salary_adjustments` function to apply yearly adjustments to employee salaries. 3. Implement the `salary_summary_report` function to generate and print the summary report. 4. Write a main block to gather employee data, take a set of salary adjustments, apply the adjustments, and print the summary report. # Example: Assume the following input and corresponding interactions: Initial employee data input: ``` 101,50000 102,60000 103,55000 ``` Adjustments: ```python adjustments = { \'101\': 5000, \'102\': -3000, \'104\': 2000 # This employee ID does not exist in the initial data } ``` Expected functions and output: 1. The `get_employee_data()` function would collect and return: ```python { \'101\': 50000.0, \'102\': 60000.0, \'103\': 55000.0 } ``` 2. The `apply_salary_adjustments(employee_data, adjustments)` function would process and return: ```python { \'101\': 55000.0, \'102\': 57000.0, \'103\': 55000.0 } ``` 3. The `salary_summary_report(employee_data)` function would generate the following output: ``` Employee ID: 101, Updated Salary: 55000.0 Employee ID: 102, Updated Salary: 57000.0 Employee ID: 103, Updated Salary: 55000.0 ``` # Constraints: * Ensure proper exception handling for invalid salary inputs and non-existent employee IDs during adjustments. * Assume user inputs are in a consistent format for simplicity, handle parsing errors gracefully. * Integer or floating-point arithmetic may be used interchangeably for salary calculations.","solution":"def get_employee_data(): Prompts the user to enter the initial salary data of employees. Returns a dictionary with employee IDs as keys and initial salaries as values. employee_data = {} while True: input_data = input(\\"Enter employee data (ID,salary) or press enter to finish: \\") if not input_data: break try: employee_id, salary = input_data.split(\',\') salary = float(salary) if salary < 0: raise ValueError(\\"Invalid salary input\\") employee_data[employee_id] = salary except (ValueError, IndexError): raise ValueError(\\"Invalid salary input\\") return employee_data def apply_salary_adjustments(employee_data, adjustments): Apply yearly salary adjustments for the given employee data. Args: - employee_data (dict): A dictionary with employee IDs as keys and initial salaries as values. - adjustments (dict): A dictionary with employee IDs as keys and adjustment amounts as values. Returns: - dict: A dictionary with updated salaries. for emp_id, adjustment in adjustments.items(): if emp_id in employee_data: employee_data[emp_id] += adjustment return employee_data def salary_summary_report(employee_data): Prints a summary report of all employees\' updated salaries. Args: - employee_data (dict): A dictionary with employee IDs as keys and updated salaries as values. for emp_id, salary in employee_data.items(): print(f\\"Employee ID: {emp_id}, Updated Salary: {salary:.2f}\\")"},{"question":"# Problem Statement You are given a string `s` consisting of lowercase Latin letters. You need to implement a class `PalindromeQueries` that supports the following operations efficiently: 1. **Add character**: Add a single character to the end of the string. 2. **Check palindrome**: Check if the substring within a specified range `[l, r]` is a palindrome. A palindrome is a string that reads the same forward and backward. # Function Specifications 1. **`__init__(self, s: str) -> None`**: Initialize the class with the initial string `s`. 2. **`add_char(self, c: str) -> None`**: Add character `c` to the end of the string. 3. **`is_palindrome(self, l: int, r: int) -> bool`**: Check if the substring from index `l` to `r` (inclusive, 0-based index) is a palindrome. # Input/Output Specifications - Input: - An initial string `s` of length `n`. - Multiple `add_char` and `is_palindrome` operations. - Output: - For each `is_palindrome` operation, return `True` if the specified substring is a palindrome, otherwise return `False`. # Constraints - ( 1 leq n leq 10^5 ) - The number of `add_char` and `is_palindrome` operations can be of the order ( 10^4 ). # Example ```python pq = PalindromeQueries(\\"race\\") pq.add_char(\'c\') pq.add_char(\'a\') pq.add_char(\'r\') print(pq.is_palindrome(0, 6)) # Output: True pq.add_char(\'b\') print(pq.is_palindrome(1, 3)) # Output: False print(pq.is_palindrome(3, 5)) # Output: True pq.add_char(\'b\') pq.add_char(\'a\') pq.add_char(\'b\') print(pq.is_palindrome(4, 9)) # Output: True ``` # Task Your task is to implement the `PalindromeQueries` class with the functionality described above.","solution":"class PalindromeQueries: def __init__(self, s: str) -> None: self.s = s def add_char(self, c: str) -> None: self.s += c def is_palindrome(self, l: int, r: int) -> bool: substring = self.s[l:r+1] return substring == substring[::-1]"},{"question":"# Problem Description You are required to implement and enhance the functionalities of a Linked List to include circular reference detection and automated reversal. Additionally, you should handle duplicates within the list by maintaining a historical frequency table for all inserted elements. # Objectives 1. Implement the `detect_cycle` method to determine if the Linked List has a circular reference. 2. Add functionality to reverse the Linked List. 3. Enhance the Linked List to track the frequency of all elements inserted to it. # Requirements Part 1: `detect_cycle` * **Function Signature**: `def detect_cycle(self) -> bool:` * **Outputs**: A boolean `True` if there is a cycle in the Linked List, and `False` otherwise. Part 2: Reversing the List * Implement the `reverse` method to reverse the order of the Linked List. * **Function Signature**: `def reverse(self) -> None:` * **Outputs**: This method should not return any value but should modify the list in place. Part 3: Tracking Element Frequencies * Enhance the `Node` and `LinkedList` classes to maintain a historical frequency table: - The frequency table should keep track of the number of times each element has been inserted into the list. # Input and Output Format ```python # Example for Part 1 ll = LinkedList() ll.insert(1, 2, 3, 4) print(ll.detect_cycle()) # Output should be False node = ll.head.next.next.next # Last node node.next = ll.head.next # Creating a cycle print(ll.detect_cycle()) # Output should be True # Example for Part 2 ll = LinkedList() ll.insert(1, 2, 3) ll.reverse() print(ll.as_list()) # Output should be [3, 2, 1] # Example for Part 3 ll = LinkedList() ll.insert(1, 2, 1, 3, 1, 2) print(ll.frequency_table) # Output should be {1: 3, 2: 2, 3: 1} ``` # Performance and Constraints - Ensure the detection of cycles runs efficiently with time complexity of O(n). - Reversing the list should be done in place with O(n) time complexity. - The frequency table should always reflect the accurate count of elements without significantly degrading the performance. # Function Details 1. `detect_cycle(self) -> bool` 2. `reverse(self) -> None` 3. `as_list(self) -> List[int]` # Helper method to convert linked list to regular list for easy verification. 4. `insert(self, *values: int) -> None` 5. Other necessary attributes and methods to implement and track the frequency table. # Scenario Imagine you are building a system for an online music playlist application. Users frequently add, remove, and rearrange songs in their playlists. Ensuring that the playlist does not have circular references (songs looping indefinitely) is crucial for a smooth user experience. Additionally, the ability to reverse the order of a playlist and track the frequency of song additions can help create better recommendations and insights into user behavior.","solution":"class Node: def __init__(self, value): self.value = value self.next = None class LinkedList: def __init__(self): self.head = None self.frequency_table = {} def insert(self, *values): for value in values: new_node = Node(value) if self.head is None: self.head = new_node else: current = self.head while current.next: current = current.next current.next = new_node if value in self.frequency_table: self.frequency_table[value] += 1 else: self.frequency_table[value] = 1 def detect_cycle(self): slow = self.head fast = self.head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False def reverse(self): prev = None current = self.head while current: next_node = current.next current.next = prev prev = current current = next_node self.head = prev def as_list(self): result = [] current = self.head while current: result.append(current.value) current = current.next return result"},{"question":"# Interactive Directory System Context You have been tasked with developing a command-line interactive directory system that enables users to navigate through directories, add or remove files, and display the directory structure. This question aims to test your ability to handle nested data structures and implement basic file system operations. Problem Statement 1. **Navigate**: Implement a method `navigate(self, path: str)` that navigates to the specified directory. * **Input**: A string `path` representing the path to navigate to. Path segments are separated by forward slashes (`/`). * **Output**: Modify the current directory context. 2. **Add File**: Implement a method `add_file(self, filename: str)` to add a file to the current directory. * **Input**: `filename` is a string representing the name of the file to be added. * **Output**: Modify the directory to include the new file. 3. **Remove File**: Implement a method `remove_file(self, filename: str)` to remove a file from the current directory. * **Input**: `filename` is a string representing the name of the file to be removed. * **Output**: Modify the directory to remove the file specified. 4. **Display Structure**: Implement a method `display(self) -> None` to display the entire directory structure from the root. * **Input**: None. * **Output**: Print the full directory structure in a readable format. # Implementation Details * Implement the following methods inside the `DirectorySystem` class provided: ```python class DirectorySystem: def __init__(self): self.root = {\\"type\\": \\"directory\\", \\"contents\\": {}} self.current_dir = self.root def navigate(self, path: str): # Your implementation here def add_file(self, filename: str): # Your implementation here def remove_file(self, filename: str): # Your implementation here def display(self) -> None: # Your implementation here def _print_structure(self, directory, indent): for name, info in directory.items(): if info[\'type\'] == \'directory\': print(\\" \\" * indent + name + \\"/\\") self._print_structure(info[\'contents\'], indent + 1) else: print(\\" \\" * indent + name) ``` # Example Usage ```python ds = DirectorySystem() # Adding files to the root directory ds.add_file(\\"file1.txt\\") ds.add_file(\\"file2.txt\\") # Creating a new directory and navigating into it ds.navigate(\\"new_folder\\") ds.add_file(\\"file3.txt\\") # Display the directory structure ds.display() # Output should display the structure: # / # file1.txt # file2.txt # new_folder/ # file3.txt ``` # Constraints: - `filename` and `path` are guaranteed to be valid strings. - The system should correctly handle nested directories and files. - Navigating to a non-existing directory should raise an appropriate error. Explanation After implementing the above methods, briefly explain your approach and any challenges faced. --- By providing methods for navigation, file addition and removal, and directory structure display, this question tests the candidate\'s ability to manage nested data, handle strings for paths, and implement a user-friendly directory system.","solution":"class DirectorySystem: def __init__(self): self.root = {\\"type\\": \\"directory\\", \\"contents\\": {}} self.current_dir = self.root def navigate(self, path: str): parts = path.strip(\\"/\\").split(\\"/\\") temp_dir = self.root for part in parts: if not part: # Skip any empty strings (e.g., leading or trailing slashes) continue if part not in temp_dir[\\"contents\\"] or temp_dir[\\"contents\\"][part][\\"type\\"] != \\"directory\\": raise ValueError(f\\"Directory {part} does not exist.\\") temp_dir = temp_dir[\\"contents\\"][part] self.current_dir = temp_dir def add_file(self, filename: str): if filename in self.current_dir[\\"contents\\"]: raise ValueError(f\\"File {filename} already exists.\\") self.current_dir[\\"contents\\"][filename] = {\\"type\\": \\"file\\"} def remove_file(self, filename: str): if filename not in self.current_dir[\\"contents\\"] or self.current_dir[\\"contents\\"][filename][\\"type\\"] != \\"file\\": raise ValueError(f\\"File {filename} does not exist.\\") del self.current_dir[\\"contents\\"][filename] def display(self) -> None: print(\\"/\\") self._print_structure(self.root[\\"contents\\"], 1) def _print_structure(self, directory, indent): for name, info in directory.items(): if info[\\"type\\"] == \\"directory\\": print(\\" \\" * indent + name + \\"/\\") self._print_structure(info[\\"contents\\"], indent + 1) else: print(\\" \\" * indent + name)"},{"question":"# Coding Question You are asked to create a function that predicts the next most likely value in a numeric sequence using a simple Linear Regression model. The model should be able to handle a sequence of numbers, fit a line to the sequence using least squares method, and then predict the next value following the last number in the given sequence. # Problem Statement Write a Python function `predict_next_value` that takes in a sequence of numbers and fits a linear model to these numbers to predict the next value in the sequence. # Function Signature ```python def predict_next_value(sequence): Predict the next value in the given numeric sequence using Linear Regression. Arguments: sequence -- a list of numeric values representing the sequence Returns: A single numeric value representing the predicted next value. pass ``` # Input & Output * **Input**: - `sequence`: A list of numeric values (at least 2 values) representing the sequence. * **Output**: - A single numeric value representing the predicted next value in the sequence based on the fitted linear model. # Constraints - You should assume that the input list always contains at least two elements. - The prediction should be based on the least squares fit of a line to the given sequence. - The function should handle both positive and negative numeric values in the sequence. # Example Assuming the sequence ([1, 2, 3, 4, 5]): ```python sequence = [1, 2, 3, 4, 5] next_value = predict_next_value(sequence) print(next_value) # Expected result: 6.0 ``` # Notes - For simplicity, you can use the basic formula of linear regression and solve for the coefficients directly. - The sequence can be assumed to follow a linear trend. - Do not use built-in machine learning libraries; instead, implement the linear regression solution manually. # Hints - You can use the formula for the best-fit line as (y = mx + b), where (m) is the slope and (b) is the y-intercept. - The slope (m) can be calculated as: [ m = frac{N sum{xy} - sum{x} sum{y}}{N sum{x^2} - (sum{x})^2} ] where (N) is the number of points in the sequence. - The y-intercept (b) can be calculated as: [ b = frac{sum{y} - m sum{x}}{N} ] - Use the above equations to fit the line and predict the next value in the sequence.","solution":"def predict_next_value(sequence): Predict the next value in the given numeric sequence using Linear Regression. Arguments: sequence -- a list of numeric values representing the sequence Returns: A single numeric value representing the predicted next value. N = len(sequence) x = list(range(1, N+1)) # Generate x values (1, 2, 3, ..., N) y = sequence x_sum = sum(x) y_sum = sum(y) xy_sum = sum(xi * yi for xi, yi in zip(x, y)) xx_sum = sum(xi ** 2 for xi in x) # Calculate slope (m) and intercept (b) m = (N * xy_sum - x_sum * y_sum) / (N * xx_sum - x_sum ** 2) b = (y_sum - m * x_sum) / N # Predict the next value (for x = N+1) next_x = N + 1 next_value = m * next_x + b return next_value"},{"question":"**Scenario**: A bookstore wants to automate the process of arranging their books. Each book is identified by its unique ISBN number. The ISBN numbers are strings that may include dashes, and the bookstore wants to ensure efficient lookups by arranging the books in lexicographical order. **Problem**: Write a function `lexicographical_sort` that sorts a list of ISBN numbers in lexicographical order. **Function Signature**: ```python def lexicographical_sort(isbns: List[str]) -> None: Sorts the list of ISBN numbers in-place using lexicographical order. Parameters: isbns (List[str]): The list of ISBN numbers to be sorted. ``` # Input - A list of strings (`isbns`) where each string represents an ISBN number which may include dashes. # Output - The function should sort the list in-place, using lexicographical order. # Constraints - All elements in `isbns` are valid ISBN strings. - `isbns` should have at least one element. - The length of each ISBN string is variable but generally manageable. # Example ```python isbns = [\\"978-3-16-148410-0\\", \\"978-0-262-13472-9\\", \\"978-1-4028-9462-6\\"] lexicographical_sort(isbns) # The function will modify isbns in-place print(isbns) # Output should be: [\\"978-0-262-13472-9\\", \\"978-1-4028-9462-6\\", \\"978-3-16-148410-0\\"] ``` # Additional Notes - The implementation must handle edge cases such as empty input or lists with duplicate ISBN numbers. - Consider and handle potential issues with different ISBN formats (e.g., presence or absence of dashes). - Optimize for time complexity while keeping the implementation clear and concise.","solution":"from typing import List def lexicographical_sort(isbns: List[str]) -> None: Sorts the list of ISBN numbers in-place using lexicographical order. Parameters: isbns (List[str]): The list of ISBN numbers to be sorted. isbns.sort()"},{"question":"# Sum of Nested List Node Values **Context:** You\'re working with a nested list data structure that is used to store hierarchical information. Each element in the list can either be a single integer or another nested list. Your task is to implement a function that computes the sum of all integers in this nested list. **Problem Statement:** Implement a function `sum_nested_list(nested_list)` that computes the sum of all integers in a nested list. **Function Signature:** ```python def sum_nested_list(nested_list: List) -> int: pass ``` **Input:** - `nested_list`: A list where each element can either be an integer or another list. **Output:** - An integer representing the sum of all integers in the `nested_list`. **Constraints:** - The depth of the nested list is at most 5. - The total number of elements (integers and lists) in `nested_list` is at most 50. - Each integer in the nested list is between -100 and 100. **Example:** ```python # Example input nested_list = [1, [2, 3], [4, [5, 6]], 7, [8, [9, 10]]] # Example output 55 ``` **Notes:** - Your implementation should handle all levels of nesting correctly and efficiently. - Consider writing a recursive function for simplicity. - Make sure to test your solution with various nested list structures to handle edge cases like empty lists or single nested integers.","solution":"from typing import List, Union def sum_nested_list(nested_list: List[Union[int, List]]) -> int: Returns the sum of all integers in a nested list. total = 0 for element in nested_list: if isinstance(element, list): total += sum_nested_list(element) else: total += element return total"},{"question":"# Task You have been asked to implement a `FileCache` class that simulates a basic caching mechanism for file data. The cache should store lines from files, keyed by file path and line number. # Function Signature ```python class FileCache: def __init__(self): pass def get_line(self, file_path: str, line_number: int) -> str: pass def update_cache(self, file_path: str, line_number: int, line_content: str) -> None: pass def remove_line(self, file_path: str, line_number: int) -> None: pass def __str__(self) -> str: pass ``` # Requirements 1. **Initialization**: - The constructor should initialize the internal cache representation, likely a dictionary, where the keys are tuples of `file_path` and `line_number`, and the values are the actual line contents. 2. **Get Line**: - Fetches a line from the cache given a `file_path` and `line_number`. - If the requested line is not in the cache, it should raise a `KeyError`. 3. **Update Cache**: - Stores a line in the cache given a `file_path`, `line_number`, and `line_content`. - If the line is already present in the cache, it should update the content with the new `line_content`. 4. **Remove Line**: - Removes a specific line from the cache given a `file_path` and `line_number`. - If the specified entry does not exist, it should raise a `KeyError`. 5. **String Representation**: - Implement the `__str__` method to display the contents of the cache in a readable format, showing all file paths, line numbers, and their corresponding content. # Example Usage ```python cache = FileCache() cache.update_cache(\'file1.txt\', 1, \'This is line 1\') cache.update_cache(\'file1.txt\', 2, \'This is line 2\') cache.update_cache(\'file2.txt\', 1, \'Another file, line 1\') print(cache) # Should display contents of the cache print(cache.get_line(\'file1.txt\', 1)) # \'This is line 1\' print(cache.get_line(\'file2.txt\', 1)) # \'Another file, line 1\' cache.remove_line(\'file1.txt\', 2) print(cache) # file1.txt, line 2 should no longer be in the cache ``` # Constraints and Limits - You may assume the file paths and line numbers are unique within the cache context. - Any invalid operations (e.g., requesting a non-existent line, removing a non-existent line) should appropriately raise custom exceptions (`KeyError`).","solution":"class FileCache: def __init__(self): # Initialize the cache as an empty dictionary self.cache = {} def get_line(self, file_path: str, line_number: int) -> str: # Return the line from the cache or raise KeyError if not found key = (file_path, line_number) if key in self.cache: return self.cache[key] else: raise KeyError(f\\"Line {line_number} from file {file_path} not found in cache.\\") def update_cache(self, file_path: str, line_number: int, line_content: str) -> None: # Update or add the line content to the cache key = (file_path, line_number) self.cache[key] = line_content def remove_line(self, file_path: str, line_number: int) -> None: # Remove the line from the cache or raise KeyError if not found key = (file_path, line_number) if key in self.cache: del self.cache[key] else: raise KeyError(f\\"Line {line_number} from file {file_path} not found in cache.\\") def __str__(self) -> str: # Return a readable format string of the cache contents result = [] for key, value in self.cache.items(): file_path, line_number = key result.append(f\\"{file_path} (Line {line_number}): {value}\\") return \\"n\\".join(result)"},{"question":"Context: You are working with a list of student records, each containing a student\'s name and their grades across several subjects. Your task is to compute the average grade for each student and identify those students whose average grade is above a given threshold. You need to handle the input and calculate the output efficiently. # Task: Implement a function `students_above_threshold(students: List[Tuple[str, List[int]]], threshold: float) -> List[str]` that processes the list of students, calculates their average grade, and returns a list of names of students whose average grade is above the given threshold. # Detailed Steps: 1. Parse the list of student records. 2. Calculate the average grade for each student. 3. Identify students whose average grade is above the threshold. 4. Return a sorted list of student names who meet the criteria. # Input: * `students`: A list of tuples where each tuple contains: - A string representing the student\'s name. - A list of integers representing the grades obtained by the student. * `threshold`: A float value representing the grade threshold. # Output: * Returns a list of strings representing the names of students whose average grade is above the threshold, sorted in ascending order. # Constraints: * The names contain only uppercase alphabetical characters. * The grades are integers ranging from 0 to 100. * You should handle the possibility of a large number of student records efficiently. # Example: ```python def students_above_threshold(students: List[Tuple[str, List[int]]], threshold: float) -> List[str]: # Your implementation here # Usage students = [(\\"ALICE\\", [85, 90, 78]), (\\"BOB\\", [70, 68, 72]), (\\"CHARLIE\\", [88, 92, 95])] threshold = 80.0 result = students_above_threshold(students, threshold) print(result) # Expected output: [\'ALICE\', \'CHARLIE\'] ``` # Performance Requirements: * Your solution should handle large lists of students efficiently, within acceptable runtime limits. **Note:** Ensure your implementation focuses on both correctness and efficiency in handling potentially large input data sets.","solution":"from typing import List, Tuple def students_above_threshold(students: List[Tuple[str, List[int]]], threshold: float) -> List[str]: This function processes a list of students, calculates their average grade, and returns a sorted list of names of students whose average grade is above the given threshold. :param students: List of tuples where each tuple contains a student\'s name and a list of their grades :param threshold: A float value representing the grade threshold :return: List of student names whose average grade is above the threshold, sorted in ascending order students_above = [] for name, grades in students: average = sum(grades) / len(grades) if average > threshold: students_above.append(name) return sorted(students_above)"},{"question":"# Flood Fill Algorithm Implement the Flood Fill algorithm for a given 2D grid. The Flood Fill algorithm is similar to the \\"bucket fill\\" tool in paint programs. This algorithm starts from a given cell and replaces all connected, same-colored cells with a new color. **Function Signature:** ```python def flood_fill(grid: List[List[int]], sr: int, sc: int, new_color: int) -> List[List[int]]: pass ``` # Input: - **grid**: A 2D list of integers representing a grid where each cell\'s value is an integer. - **sr**: Integer, the starting row index. - **sc**: Integer, the starting column index. - **new_color**: Integer, the color to which the connected, same-colored cells should be changed. # Output: - Returns the modified grid after performing the flood fill. # Constraints: - The input grid will be a non-empty 2D list where each value is a non-negative integer. - 1 ≤ len(grid) ≤ 50 - 1 ≤ len(grid[0]) ≤ 50 - 0 ≤ sr < len(grid) - 0 ≤ sc < len(grid[0]) - 0 ≤ grid[i][j], new_color < 1000 # Example: ```python grid = [ [1, 1, 1], [1, 1, 0], [1, 0, 1] ] sr = 1 sc = 1 new_color = 2 result = flood_fill(grid, sr, sc, new_color) print(result) # Output should be: # [ # [2, 2, 2], # [2, 2, 0], # [2, 0, 1] # ] ``` # Performance Requirements: - The algorithm should efficiently handle connected components in grids up to 50x50 cells. - Ensure the function handles edge and corner cases properly and avoids recursive depth issues. You need to implement the Flood Fill algorithm ensuring it correctly processes the grid and handles boundary conditions effectively.","solution":"from typing import List def flood_fill(grid: List[List[int]], sr: int, sc: int, new_color: int) -> List[List[int]]: rows, cols = len(grid), len(grid[0]) original_color = grid[sr][sc] # Edge case: If the original color is the same as the new color, no change is needed. if original_color == new_color: return grid def fill(r: int, c: int): if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] != original_color: return grid[r][c] = new_color fill(r + 1, c) fill(r - 1, c) fill(r, c + 1) fill(r, c - 1) fill(sr, sc) return grid"},{"question":"# Question: Write a function `product_of_array_except_self(nums: List[int]) -> List[int]` that takes in an array of integers `nums` and returns an array `output` such that `output[i]` is equal to the product of all the elements of `nums` except `nums[i]`. You must solve it without using division and in O(n) time complexity. # Input and Output: * **Input**: `nums`: List of integers [n1, n2, ..., nk] where 2 ≤ length ≤ 10^5 and -30 ≤ ni ≤ 30. * **Output**: List of integers [p1, p2, ..., pk] where each pi is the product of all elements except the ith element. # Constraints: * The length of the input array `nums` is at least 2 and no more than 100,000. * Each element in the array is an integer in the range [-30, 30]. * Any number of elements in the array can be zero. * The product of any prefix or suffix of `nums` is guaranteed to fit in a 32-bit integer. # Edge cases to consider: * The array contains multiple zeroes. * The array contains negative numbers. * The array contains all the same numbers. # Function Signature: ```python from typing import List def product_of_array_except_self(nums: List[int]) -> List[int]: pass ``` # Example: ```python # Example 1 nums = [1, 2, 3, 4] print(product_of_array_except_self(nums)) # Output: [24, 12, 8, 6] # Example 2 nums = [-1, 1, 0, -3, 3] print(product_of_array_except_self(nums)) # Output: [0, 0, 9, 0, 0] ```","solution":"from typing import List def product_of_array_except_self(nums: List[int]) -> List[int]: length = len(nums) left_products = [1] * length # Fill left_products where left_products[i] is the product of all elements to the left of i for i in range(1, length): left_products[i] = left_products[i - 1] * nums[i - 1] right_products = 1 for i in range(length - 1, -1, -1): left_products[i] = left_products[i] * right_products right_products *= nums[i] return left_products"},{"question":"# Problem Statement You are tasked with designing a class called `StringProcessor` that processes a list of strings. The class must support the following operations: 1. **Initialization**: Construct the processor with a list of strings. 2. **Concatenate**: Concatenate all strings in the list into a single string. 3. **Longest Common Prefix**: Identify the longest common prefix among the strings. 4. **Update String**: Update a specific string in the list by its index. # Function Signatures ```python class StringProcessor: def __init__(self, strings: list[str]) -> None: Initializes the processor with the given list of strings. def concatenate(self) -> str: Concatenates all strings in the list into a single string. def longest_common_prefix(self) -> str: Returns the longest common prefix among the strings in the list. def update_string(self, index: int, new_string: str) -> None: Updates the string at the specified index with a new string. ``` # Input Constraints - The list of strings will have a length of up to `10^4` elements. - Each string\'s length will be up to `10^3` characters. - The strings will contain only lowercase English letters (`a` to `z`). - Strings may be updated frequently, and operations should be efficient. # Example Usage ```python # Initialize the processor with a list of strings sp = StringProcessor([\\"flower\\", \\"flow\\", \\"flight\\"]) # Concatenate all strings in the list print(sp.concatenate()) # Output: \\"flowerflowflight\\" # Find the longest common prefix among the strings print(sp.longest_common_prefix()) # Output: \\"fl\\" # Update the string at index 1 sp.update_string(1, \\"flour\\") # Find the longest common prefix again print(sp.longest_common_prefix()) # Output: \\"fl\\" # Concatenate all strings again print(sp.concatenate()) # Output: \\"flowerflourflight\\" ``` # Constraints - You should handle edge cases such as empty arrays, and updating with an invalid index. - Aim to optimize the performance of each operation to handle frequent calls efficiently.","solution":"class StringProcessor: def __init__(self, strings: list[str]) -> None: Initializes the processor with the given list of strings. self.strings = strings def concatenate(self) -> str: Concatenates all strings in the list into a single string. return \'\'.join(self.strings) def longest_common_prefix(self) -> str: Returns the longest common prefix among the strings in the list. if not self.strings: return \\"\\" min_len = min(len(s) for s in self.strings) prefix = [] for i in range(min_len): char_set = set(s[i] for s in self.strings) if len(char_set) == 1: prefix.append(self.strings[0][i]) else: break return \'\'.join(prefix) def update_string(self, index: int, new_string: str) -> None: Updates the string at the specified index with a new string. if 0 <= index < len(self.strings): self.strings[index] = new_string else: raise IndexError(\\"Index out of range\\")"},{"question":"# Problem statement You are given a function that performs operations on a string to identify certain patterns and extract information. Your task is to extend the functionality by implementing a new function which counts the frequency of each word in a string. # Requirements Implement the function `word_frequency()` that counts the frequency of each word in a given string and returns a dictionary with words as keys and their frequencies as values. # Function Signature ```python def word_frequency(text: str) -> dict: pass ``` # Input Parameters - `text`: A string consisting of words separated by spaces. # Output Return a dictionary where the keys are unique words from the input text and the values are the frequencies of these words. # Example ```python >>> word_frequency(\\"the cat in the hat\\") {\'the\': 2, \'cat\': 1, \'in\': 1, \'hat\': 1} >>> word_frequency(\\"hello world hello\\") {\'hello\': 2, \'world\': 1} >>> word_frequency(\\"one two two three three three\\") {\'one\': 1, \'two\': 2, \'three\': 3} >>> word_frequency(\\"\\") {} >>> word_frequency(\\"word\\") {\'word\': 1} ``` # Constraints - Consider words to be case-insensitive, meaning \\"Hello\\" and \\"hello\\" are the same word. - Punctuation marks attached to words should be removed before counting (e.g., \\"hello,\\" and \\"hello\\" should be considered the same). - Handle edge cases such as empty strings gracefully by returning an empty dictionary.","solution":"import re def word_frequency(text: str) -> dict: Counts the frequency of each word in a given string and returns a dictionary with words as keys and their frequencies as values. Parameters: text (str): Input string containing words separated by spaces. Returns: dict: Dictionary with words as keys and their frequencies as values. # Remove punctuation and convert to lowercase text = re.sub(r\'[^ws]\', \'\', text).lower() # Split the text into words words = text.split() # Initialize an empty dictionary to store word frequencies frequency_dict = {} # Count word frequencies for word in words: if word in frequency_dict: frequency_dict[word] += 1 else: frequency_dict[word] = 1 return frequency_dict"},{"question":"# Merge Sorted Lists Problem Statement: Write a Python function `merge_sorted_lists(list1: list, list2: list) -> list` that takes two sorted lists and merges them into a single sorted list. The function should merge the lists such that the resulting list is also sorted in ascending order. Input and Output Format: - **Input**: * Two lists, `list1` and `list2`, each containing integer elements sorted in non-decreasing order. - **Output**: * A single list containing all elements from `list1` and `list2`, sorted in non-decreasing order. Constraints: - The input lists may have different lengths, and either or both may be empty. - Merging should be done by comparing elements, not by simply concatenating and sorting. - Example merges: ```python merge_sorted_lists([1, 3, 5], [2, 4, 6]) # should return [1, 2, 3, 4, 5, 6] merge_sorted_lists([1, 1, 1], [2, 2, 2]) # should return [1, 1, 1, 2, 2, 2] merge_sorted_lists([], [2, 3, 4]) # should return [2, 3, 4] merge_sorted_lists([0, 4, 8], [1, 5, 9]) # should return [0, 1, 4, 5, 8, 9] ``` Requirements: 1. Use an efficient merging algorithm, such as the two-pointer technique. 2. Handle edge cases where one or both lists are empty. 3. Ensure the merged list is sorted without duplicates if the input lists are sorted without duplicates. # Sample Function Signature ```python def merge_sorted_lists(list1: list, list2: list) -> list: pass ```","solution":"def merge_sorted_lists(list1: list, list2: list) -> list: Merges two sorted lists into a single sorted list. merged_list = [] i, j = 0, 0 while i < len(list1) and j < len(list2): if list1[i] <= list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 while i < len(list1): merged_list.append(list1[i]) i += 1 while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"# Determine Temperature Conversion From Kelvin to Fahrenheit Problem Description: Given a temperature in Kelvin, convert it to Fahrenheit using the appropriate conversion formula. Formula: [ F = left(K - 273.15right) times frac{9}{5} + 32 ] Where: * ( F ) = temperature in Fahrenheit * ( K ) = temperature in Kelvin Function Signature: ```python def convert_kelvin_to_fahrenheit(kelvin: float) -> float: pass ``` Input: * A single float ( kelvin ) representing the temperature in Kelvin. (0 <= kelvin <= 10000) Output: * A float representing the converted temperature in Fahrenheit. Constraints: * The kelvin value must be between 0 and 10,000 inclusive. Examples: * **Example 1**: ```python convert_kelvin_to_fahrenheit(kelvin=0) ``` **Output**: ```python -459.67 ``` * **Example 2**: ```python convert_kelvin_to_fahrenheit(kelvin=273.15) ``` **Output**: ```python 32.0 ``` * **Example 3**: ```python convert_kelvin_to_fahrenheit(kelvin=300) ``` **Output**: ```python 80.33 ``` * **Example 4**: ```python convert_kelvin_to_fahrenheit(kelvin=10000) ``` **Output**: ```python 17640.33 ``` Notes: * The function should raise a `ValueError` for kelvin values outside the given range. Implement the `convert_kelvin_to_fahrenheit` function to achieve the temperature conversion from Kelvin to Fahrenheit using the provided formula.","solution":"def convert_kelvin_to_fahrenheit(kelvin: float) -> float: Converts a temperature from Kelvin to Fahrenheit. Parameters: kelvin (float): A temperature in Kelvin. Must be in the range 0 <= kelvin <= 10000. Returns: float: The temperature converted to Fahrenheit. Raises: ValueError: If the kelvin value is outside the range 0 <= kelvin <= 10000. if kelvin < 0 or kelvin > 10000: raise ValueError(\\"Kelvin value must be in the range 0 <= kelvin <= 10000\\") fahrenheit = (kelvin - 273.15) * 9/5 + 32 return fahrenheit"},{"question":"# Context You are working as a software developer tasked with creating a scheduling system for a conference. The conference has multiple sessions and each session can have multiple topics. You need to ensure that no two topics overlap within the same session. # Task Write a function `can_schedule_topics(session_length: int, topics: List[Tuple[int, int]]) -> bool` that determines if it is possible to schedule all topics within the session without any overlap. # Function Signature ```python def can_schedule_topics(session_length: int, topics: List[Tuple[int, int]]) -> bool: pass ``` # Input - `session_length`: An integer representing the total duration of the session. - `topics`: A list of tuples, where each tuple contains two integers representing the start and end time of a topic. # Output - Return `True` if it\'s possible to schedule all topics within the session without any overlaps, otherwise return `False`. # Constraints - The start and end times of each topic are within the range [0, session_length]. - The topics must not overlap in their time intervals. - Topics are considered overlapping if one topic\'s start time is before another topic\'s end time while the other topic\'s start time is also before the first topic\'s end time. # Example Example 1: ```python >>> can_schedule_topics(10, [(1, 3), (3, 5), (5, 7), (7, 10)]) True ``` Example 2: ```python >>> can_schedule_topics(8, [(0, 2), (1, 4), (3, 5)]) False ``` In the first example, the topics can be scheduled sequentially without any overlap. In the second example, there is an overlap between the first topic (0, 2) and the second topic (1, 4).","solution":"from typing import List, Tuple def can_schedule_topics(session_length: int, topics: List[Tuple[int, int]]) -> bool: Determines if it\'s possible to schedule all topics within the session without any overlaps. # Sort topics by their start times topics.sort() # Check for overlaps for i in range(1, len(topics)): if topics[i][0] < topics[i-1][1]: return False return True"},{"question":"# Problem: Weather Data Analyzer You are given a function that fetches weather data from an API. The API provides multiple data points including temperature, humidity, wind speed, and weather conditions. The current implementation uses the `requests` library to make the API call and `json` to parse the response. Your task is to enhance this function by introducing the following improvements: 1. **Error Handling**: Add robust error handling to manage potential request failures, network issues, or changes in the response format. 2. **Extensibility**: Modify the function so that it can also extract additional data points provided in the future without code changes. 3. **Efficiency**: Ensure the solution remains efficient, considering scenarios where the API response might contain large datasets. # Input - `url` (string): The URL of the weather API endpoint. # Output - A dictionary containing the extracted data points with keys like `temperature`, `humidity`, `wind_speed`, `condition`, etc. # Constraints - Ensure the function handles network failures gracefully. - The JSON parsing should be adaptable to potential changes in the response structure. - The solution should complete in a reasonable timeframe for standard API response sizes. - Validate the format and data type of the extracted data points. # Example Usage ```python url = \\"https://api.weather.com/v3/wx/conditions/current\\" result = enhanced_weather_data(url) print(result) # Expected output: { # \\"temperature\\": 22, # \\"humidity\\": 55, # \\"wind_speed\\": 13, # \\"condition\\": \\"Partly Cloudy\\", # // Potentially more data points if available in the future # } ``` # Implementation Tips - Use `try-except` blocks to handle network and parsing errors. - Consider using a dictionary or dynamic approach to extract additional data points. - Ensure you validate each data point to confirm it is correctly extracted and formatted.","solution":"import requests def enhanced_weather_data(url): Fetches weather data from the API and extracts key data points. Args: - url (string): The URL of the weather API endpoint. Returns: - dict: A dictionary containing the extracted data points. try: response = requests.get(url) response.raise_for_status() # Raise HTTPError for bad responses (4xx and 5xx) data = response.json() # Extract relevant data points keys_of_interest = [\'temperature\', \'humidity\', \'wind_speed\', \'condition\'] extracted_data = {key: data.get(key) for key in keys_of_interest} # Add additional keys dynamically if they exist for key, value in data.items(): if key not in extracted_data: extracted_data[key] = value return extracted_data except requests.exceptions.RequestException as e: # Handle any request-related errors return {\\"error\\": str(e)} except ValueError as e: # Handle JSON parsing errors return {\\"error\\": \\"Invalid JSON response\\"}"},{"question":"# Problem Statement You are asked to implement a function that reads a square matrix where all the rows and columns are sorted in ascending order, and search for a given integer. The function should return `True` if the integer is found in the matrix, and `False` otherwise. # Function Signature ```python def search_in_matrix(matrix: List[List[int]], target: int) -> bool: Args: matrix: A List of List of integers representing the matrix. target: An integer to be searched in the matrix. Returns: A boolean value, True if the target is found, otherwise False. ``` # Input and Output - **Input**: - `matrix`: A square matrix (list of lists) where each row and each column is sorted in non-decreasing order. - `target`: An integer to be searched in the matrix. - **Output**: - A boolean value indicating whether the target integer is found in the matrix. # Constraints - The size of the matrix (number of rows and columns) will be at most 500. - Each integer in the matrix will be in the range `[−10^9, 10^9]`. # Example ```python matrix = [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] search_in_matrix(matrix, 5) # Returns: True search_in_matrix(matrix, 20) # Returns: False ``` # Notes - The provided `search_in_matrix` function should: - Utilize the properties of the sorted rows and columns to efficiently search for the target. - Aim for a solution with better time complexity than a simple linear search.","solution":"from typing import List def search_in_matrix(matrix: List[List[int]], target: int) -> bool: Search for a target number in a given square matrix where each row and column are sorted in ascending order. if not matrix or not matrix[0]: return False rows, columns = len(matrix), len(matrix[0]) # Start from the top right corner row, col = 0, columns - 1 while row < rows and col >= 0: if matrix[row][col] == target: return True elif matrix[row][col] > target: col -= 1 # move left else: row += 1 # move down return False"},{"question":"# Coding Task: Implement a Simple Trie for Word Storage and Search Background Your task is to implement a simple Trie (pronounced as \\"try\\") data structure for storing and searching strings. The Trie should support the insertion of words and checking if a word or a prefix of a word exists in the Trie. Function Signature ```python class TrieNode: def __init__(self): Initializes a TrieNode with child nodes set to an empty dictionary and a boolean flag indicating if it\'s the end of a word. self.children = {} self.is_end_of_word = False class Trie: def __init__(self): Initializes the Trie with the root node. self.root = TrieNode() def insert(self, word): Inserts a word into the Trie. word : string : The word to be inserted. Example: >>> trie = Trie() >>> trie.insert(\\"apple\\") node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word): Searches for a word in the Trie. word : string : The word to search for. Returns True if the word exists in the Trie, otherwise False. Example: >>> trie = Trie() >>> trie.insert(\\"apple\\") >>> trie.search(\\"apple\\") True >>> trie.search(\\"app\\") False node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def startsWith(self, prefix): Checks if there is any word in the Trie that starts with the given prefix. prefix : string : The prefix to search for. Returns True if there is a word in the Trie that starts with the prefix, otherwise False. Example: >>> trie = Trie() >>> trie.insert(\\"apple\\") >>> trie.startsWith(\\"app\\") True >>> trie.startsWith(\\"appl\\") True >>> trie.startsWith(\\"apl\\") False node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True ``` Input 1. `word` or `prefix` - A string representing a word to be inserted or searched or a prefix to be checked. Output * `insert(word)`: Nothing, simply inserts the word into the Trie. * `search(word)`: Returns `True` if the word exists in the Trie, else `False`. * `startsWith(prefix)`: Returns `True` if there is any word in the Trie that starts with the given prefix, else `False`. Constraints * All words consist of lowercase English letters only. * The length of each `word` or `prefix` will not exceed 100. * The maximum number of words that can be stored in the Trie is 10^4. Example ```python trie = Trie() trie.insert(\\"apple\\") print(trie.search(\\"apple\\")) # Output: True print(trie.search(\\"app\\")) # Output: False print(trie.startsWith(\\"app\\")) # Output: True trie.insert(\\"app\\") print(trie.search(\\"app\\")) # Output: True ```","solution":"class TrieNode: def __init__(self): Initializes a TrieNode with child nodes set to an empty dictionary and a boolean flag indicating if it\'s the end of a word. self.children = {} self.is_end_of_word = False class Trie: def __init__(self): Initializes the Trie with the root node. self.root = TrieNode() def insert(self, word): Inserts a word into the Trie. word : string : The word to be inserted. Example: >>> trie = Trie() >>> trie.insert(\\"apple\\") node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word): Searches for a word in the Trie. word : string : The word to search for. Returns True if the word exists in the Trie, otherwise False. Example: >>> trie = Trie() >>> trie.insert(\\"apple\\") >>> trie.search(\\"apple\\") True >>> trie.search(\\"app\\") False node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def startsWith(self, prefix): Checks if there is any word in the Trie that starts with the given prefix. prefix : string : The prefix to search for. Returns True if there is a word in the Trie that starts with the prefix, otherwise False. Example: >>> trie = Trie() >>> trie.insert(\\"apple\\") >>> trie.startsWith(\\"app\\") True >>> trie.startsWith(\\"appl\\") True >>> trie.startsWith(\\"apl\\") False node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True"},{"question":"# Coding Question **Context:** Linked lists are a fundamental data structure used to implement various advanced data structures and algorithms. They consist of nodes where each node contains a value and a reference to the next node in the sequence. Cycles in linked lists can cause infinite loops in algorithms; hence, detecting them is crucial. **Task:** Implement a function `detect_cycle(head: ListNode) -> bool` that takes the head of a singly linked list and returns `True` if there is a cycle in the linked list, and `False` otherwise. A cycle occurs when a node in the list points back to one of the previous nodes, creating an infinite loop. **Function Signature:** ```python def detect_cycle(head: ListNode) -> bool: ``` **Definition for singly-linked list node:** ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` **Input:** * `head` (ListNode): The head node of a singly linked list. **Output:** * `bool`: `True` if there is a cycle in the linked list, `False` otherwise. **Methodology:** To detect a cycle, you can use Floyd\'s Cycle-Finding Algorithm (also known as the Tortoise and Hare Algorithm): - Use two pointers, slow and fast. - Move the slow pointer one step at a time and the fast pointer two steps at a time. - If there is a cycle, the fast pointer will eventually meet the slow pointer. - If the fast pointer reaches the end of the list, there is no cycle. **Constraints:** * The nodes\' values are irrelevant for the purpose of cycle detection. * The maximum number of nodes in the linked list is 10^4. **Examples:** ```python # Example 1 node1 = ListNode(3) node2 = ListNode(2) node3 = ListNode(0) node4 = ListNode(-4) node1.next = node2 node2.next = node3 node3.next = node4 node4.next = node2 # cycle here >>> detect_cycle(node1) True # Example 2 node1 = ListNode(1) node2 = ListNode(2) node1.next = node2 node2.next = node1 # cycle here >>> detect_cycle(node1) True # Example 3 node1 = ListNode(1) >>> detect_cycle(node1) False ``` **Testing:** Use the following template to test your function: ```python if __name__ == \\"__main__\\": import doctest doctest.testmod() ```","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def detect_cycle(head: ListNode) -> bool: Detects if there is a cycle in the linked list. Parameters: head (ListNode): The head node of the singly linked list. Returns: bool: True if there is a cycle in the linked list, False otherwise. if not head or not head.next: return False slow = head fast = head.next while slow != fast: if not fast or not fast.next: return False slow = slow.next fast = fast.next.next return True"},{"question":"# Question Develop a breadth-first search (BFS) traversal algorithm for a binary tree where the nodes may contain any integer value. The BFS traversal should visit each level of the tree from left to right and store the values of nodes in a nested list, where each nested list corresponds to one level of the tree. # Problem Statement: Implement a function `bfs_binary_tree` which takes the root node of a binary tree and outputs the BFS traversal as a list of lists. # Input and Output: **Input**: - The `root` node of a binary tree. **Output**: - A list of lists, where each sublist represents one level of the tree, containing the values of the nodes at that level. # Constraints: - The tree will have at most 100000 nodes. - Nodes will contain integer values. - Return an empty list if the input tree is empty. # Example: ```python Example 1: Input: root = TreeNode(1) / 2 3 Output: [[1], [2, 3]] Example 2: Input: root = TreeNode(4) / 2 7 / 1 3 Output: [[4], [2, 7], [1, 3]] ``` # Definition for a binary tree node: ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right ``` Implement the `bfs_binary_tree` function to match the above specification.","solution":"from collections import deque class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def bfs_binary_tree(root): Perform a BFS traversal on a binary tree and return the values level by level. Args: root (TreeNode): The root node of the binary tree. Returns: List[List[int]]: A list of lists, where each sublist contains the values of nodes at that level. if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.popleft() current_level.append(node.value) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(current_level) return result"},{"question":"# Coding Assessment: Compress String Context You are working on optimizing a system that involves storing large amounts of textual data. To save space, you need a function that compresses strings using a basic form of Run-Length Encoding (RLE). RLE is a simple compression algorithm that replaces sequences of identical consecutive characters with a single character, followed by the number of consecutive repetitions. Task Write a function `compress_string` that takes a string as input and returns its compressed version using Run-Length Encoding. Input - `s`: A string of ASCII characters. The string is guaranteed to have at least one character. Output - A compressed string where consecutive identical characters are replaced by the character followed by the number of repetitions. If the compressed string is not shorter than the original, return the original string instead. Constraints - The function should be case-sensitive (i.e., \'A\' and \'a\' are different characters). - Consider performance and readability in your implementation. Examples ```python def compress_string(s: str) -> str: # Your implementation here pass # Example Usage print(compress_string(\\"aabcccccaaa\\")) # Expected Output: \\"a2b1c5a3\\" print(compress_string(\\"abcd\\")) # Expected Output: \\"abcd\\" print(compress_string(\\"aabbbccccddddd\\")) # Expected Output: \\"a2b3c4d5\\" ``` In your solution: 1. Iterate through the input string and count consecutive identical characters. 2. Construct the compressed string using the format `<character><count>`. 3. Compare the lengths of the compressed string and the original string. 4. Return the compressed string if it is shorter; otherwise, return the original string.","solution":"def compress_string(s: str) -> str: Compresses the input string using Run-Length Encoding (RLE). :param s: input string to compress :return: compressed string or original string if compression is not shorter if not s: return s # handle empty string edge case compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1] + str(count)) count = 1 # Don\'t forget to add the last counted group compressed.append(s[-1] + str(count)) compressed_string = \'\'.join(compressed) return compressed_string if len(compressed_string) < len(s) else s"},{"question":"# Sudoku Solver Context You have been provided with a 9x9 Sudoku puzzle grid in which some of the cells are filled with digits (1-9) and others are empty (represented by 0). Your task is to complete this grid by filling in the empty cells such that each row, each column, and each of the nine 3x3 sub-grids contain all of the digits from 1 to 9 exactly once. This problem will test your understanding of backtracking algorithms and constraint satisfaction problems. Task 1. **Input Processing**: - Read the provided Sudoku puzzle from a 9x9 grid stored in a text file named `sudoku.txt`. 2. **Algorithm Implementation**: - Implement a backtracking algorithm to solve the Sudoku puzzle. - For each empty cell, try placing digits from 1 to 9 and recursively check if the grid can be solved with this placement. - If placing a digit leads to an invalid state, backtrack and try the next digit. 3. **Output Solution**: - Print the completed Sudoku grid. - Return the solved grid in the form of a 2D list of integers. Constraints - Use `numpy` library for handling the grid. - Ensure your solution adheres to standard Sudoku rules (no repeated numbers in any row, column, or 3x3 sub-grid). - Handle input and output through text files. Input - A text file named `sudoku.txt` containing a 9x9 grid of integers separated by spaces, where empty cells are represented by 0. Output - Print the completed Sudoku grid. - Return the solved grid as a 2D list of integers. Function Signature ```python def sudoku_solver(file_path: str) -> list: Function to solve a Sudoku puzzle using backtracking algorithm. Params: file_path: str: Path to the text file containing a 9x9 grid of integers. Returns: solved_grid: list: 2D list of integers representing the solved Sudoku grid. pass ``` Example Suppose `sudoku.txt` contains: ``` 5 3 0 0 7 0 0 0 0 6 0 0 1 9 5 0 0 0 0 9 8 0 0 0 0 6 0 8 0 0 0 6 0 0 0 3 4 0 0 8 0 3 0 0 1 7 0 0 0 2 0 0 0 6 0 6 0 0 0 0 2 8 0 0 0 0 4 1 9 0 0 5 0 0 0 0 8 0 0 7 9 ``` Your function should solve the grid and print the completed Sudoku puzzle as well as return it as a 2D list.","solution":"import numpy as np def sudoku_solver(file_path: str) -> list: def is_valid(board, row, col, num): # Check if `num` is not in the current row, column, and 3x3 sub-grid subgrid_row_start = row - row % 3 subgrid_col_start = col - col % 3 if num in board[row]: return False if num in [board[i][col] for i in range(9)]: return False if num in [board[subgrid_row_start + i][subgrid_col_start + j] for i in range(3) for j in range(3)]: return False return True def solve(board): for row in range(9): for col in range(9): if board[row][col] == 0: for num in range(1, 10): if is_valid(board, row, col, num): board[row][col] = num if solve(board): return True board[row][col] = 0 return False return True def read_sudoku(file_path): with open(file_path, \'r\') as file: grid = [list(map(int, line.strip().split())) for line in file] return np.array(grid) def print_sudoku(board): for row in board: print(\\" \\".join(map(str, row))) grid = read_sudoku(file_path) if solve(grid): print_sudoku(grid) return grid.tolist() else: return None"},{"question":"# Real-Time Educational Quiz Application with WebSocket You are tasked with developing the backend for a real-time educational quiz application that allows multiple clients to participate in a quiz simultaneously. The server needs to broadcast questions to all connected clients and handle responses in real-time using WebSocket connections. Function Specification: Implement the function `start_quiz_server(question_list: List[str]) -> None`. This function should: 1. Create a WebSocket server that listens for incoming client connections. 2. Broadcast quiz questions to all connected clients at regular intervals (e.g., every 10 seconds). 3. Receive and log client responses, noting the time each response was received. 4. Implement error handling to manage WebSocket connection errors and unexpected disconnections. 5. Provide a way to log server events, such as client connections/disconnections, questions broadcasted, and responses received. Input: - `question_list` (List[str]): A list of questions to be broadcasted to the clients. Constraints: - The server should manage multiple clients efficiently. - Each question should be broadcasted to all connected clients at regular intervals. - The server should handle new client connections dynamically. - Ensure the server can handle connection terminations gracefully. - Use non-blocking operations for WebSocket interactions. - Include signal handling to allow for graceful server termination (e.g., using SIGINT). Example Usage: ```python if __name__ == \\"__main__\\": questions = [ \\"What is the capital of France?\\", \\"What is the sum of 2 and 2?\\", \\"Name the largest planet in our solar system.\\" ] start_quiz_server(questions) ``` In this example, the server will start, listen for incoming WebSocket connections, and broadcast each question at 10-second intervals. Notes: - You do not need to implement the client-side code, but you may write it for your testing purposes. - Consider using frameworks like `websockets` or `aiohttp` to manage WebSocket connections. - Ensure robust error handling to manage unexpected client disconnections and dropped connections. - Implement logging for debugging and monitoring purposes.","solution":"import asyncio import websockets import logging from typing import List logging.basicConfig(level=logging.INFO) connected_clients = set() async def broadcast_questions(websocket, path, question_list): connected_clients.add(websocket) logging.info(f\\"New client connected. Total clients: {len(connected_clients)}\\") try: while True: for question in question_list: if websocket.closed: break await asyncio.sleep(10) await websocket.send(question) logging.info(f\\"Broadcasted question: {question}\\") except websockets.exceptions.ConnectionClosedOK: logging.info(\\"Client disconnected gracefully\\") except websockets.exceptions.ConnectionClosedError: logging.error(\\"Client disconnected with error\\") finally: connected_clients.remove(websocket) logging.info(f\\"Client disconnected. Total clients: {len(connected_clients)}\\") async def start_quiz_server(question_list: List[str], port=8765): server = await websockets.serve(lambda ws, path: broadcast_questions(ws, path, question_list), \\"localhost\\", port) logging.info(f\\"Quiz server started on ws://localhost:{port}\\") await server.wait_closed() def run_server(question_list: List[str]): asyncio.run(start_quiz_server(question_list)) if __name__ == \\"__main__\\": questions = [ \\"What is the capital of France?\\", \\"What is the sum of 2 and 2?\\", \\"Name the largest planet in our solar system.\\" ] run_server(questions)"},{"question":"Implement a Min-Heap Priority Queue Your task is to implement a Min-Heap Priority Queue class. A Min-Heap is a binary tree where the value of each node is at least as large as the values of its children, ensuring that the smallest element is always at the root. Requirements: 1. Implement the class `MinHeap`. 2. The class should contain the following methods: - `insert(item)`: Inserts an element into the heap. - `peek()`: Returns the smallest element in the heap without removing it. - `pop()`: Removes and returns the smallest element in the heap. 3. Ensure the heap maintains the min-heap property after each insertion and removal. 4. Implement appropriate validation checks for the methods. 5. The heap should be implemented using an array (list) where indices follow the binary heap properties. Input: - A series of operations (`insert`, `peek`, `pop`) that modify or query the heap. Output: - Values returned by `peek` and `pop` operations. Constraints: - Assume that the number of operations can be up to 100,000. - All values inserted into the heap are integers and are within the range of -10^5 to 10^5. # Example: ```python # Define your MinHeap class here. # Initialize the MinHeap min_heap = MinHeap() # Insert elements min_heap.insert(10) min_heap.insert(4) min_heap.insert(15) min_heap.insert(7) # Peek the smallest element print(min_heap.peek()) # Expected output: 4 # Pop the smallest element print(min_heap.pop()) # Expected output: 4 # Peek the new smallest element print(min_heap.peek()) # Expected output: 7 ``` Ensure your class meets these requirements and passes the provided example tests.","solution":"class MinHeap: def __init__(self): self.heap = [] def insert(self, item): self.heap.append(item) self._heapify_up(len(self.heap) - 1) def peek(self): if not self.heap: raise IndexError(\\"peek from an empty heap\\") return self.heap[0] def pop(self): if not self.heap: raise IndexError(\\"pop from an empty heap\\") if len(self.heap) == 1: return self.heap.pop() root = self.heap[0] self.heap[0] = self.heap.pop() self._heapify_down(0) return root def _heapify_up(self, index): parent_index = (index - 1) // 2 if index > 0 and self.heap[index] < self.heap[parent_index]: self.heap[index], self.heap[parent_index] = self.heap[parent_index], self.heap[index] self._heapify_up(parent_index) def _heapify_down(self, index): child_index = 2 * index + 1 if child_index >= len(self.heap): return if child_index + 1 < len(self.heap) and self.heap[child_index + 1] < self.heap[child_index]: child_index += 1 if self.heap[index] > self.heap[child_index]: self.heap[index], self.heap[child_index] = self.heap[child_index], self.heap[index] self._heapify_down(child_index)"},{"question":"**Problem Statement:** You are given a list of integers. Your task is to implement the `rotate_and_reverse_sort` function to sort this list in ascending order. The function should rotate the list to the right by a given number of times and then apply a modified selection sort to sort it into ascending order. # Function Signature: ```python def rotate_and_reverse_sort(collection: list[int], rotations: int) -> list[int]: pass ``` # Input: * A list `collection` of `N` integers where `1 <= N <= 10^5` and each integer is within the range `-10^9` to `10^9`. * An integer `rotations` where `0 <= rotations <= 10^6`. # Output: * A list of the same integers but sorted in ascending order. # Constraints: * Your solution should achieve the required rotation in `O(N)` time. * Implement a selection sort variation that operates in `O(N^2)` time for the sorting step. * Ensure the entire process maintains an overall time complexity feasible within given constraints. # Sample Input: ```python [4, 2, 5, 1, 3], 2 ``` # Sample Output: ```python [1, 2, 3, 4, 5] ``` # Detailed Requirements: 1. **Rotation:** * Rotate the list to the right by `rotations` times efficiently. * Use modulo operation to bring down the number of rotations within the list\'s length. 2. **Modified Selection Sort:** * Implement a variation of selection sort that continuously selects the minimum element from the unsorted portion and places it in the correct sorted position. * Ensure stability and correctness throughout the sorting process. 3. **Final Validation:** * Make sure the rotated and sorted list corresponds correctly to the requirements. * Address and handle edge cases such as empty lists or lists with just one element. # Considerations: * Efficient application of rotation is critical given the possible high value of `rotations`. * The selection sort should be implemented clearly to reflect the variation and any modifications needed to maintain efficiency. Implement the function `rotate_and_reverse_sort` accordingly.","solution":"def rotate_and_reverse_sort(collection: list[int], rotations: int) -> list[int]: def rotate_right(lst: list[int], k: int) -> list[int]: n = len(lst) if n == 0: return lst k = k % n # Reduce unnecessary full rotations return lst[-k:] + lst[:-k] def selection_sort(lst: list[int]) -> list[int]: n = len(lst) for i in range(n): min_index = i for j in range(i + 1, n): if lst[j] < lst[min_index]: min_index = j lst[i], lst[min_index] = lst[min_index], lst[i] return lst # Rotate the list rotated_collection = rotate_right(collection, rotations) # Sort the rotated list sorted_collection = selection_sort(rotated_collection) return sorted_collection"},{"question":"# Scenario You are working on a recommendation system for a video streaming platform. One of the features is to provide users with the option to generate personalized playlists based on their viewing history and preferences. To efficiently manage the playlists, you decide to implement a data structure that supports adding, removing, and getting the most frequently watched video in constant time. # Task Implement a PlaylistManager class that mediates operations on user playlists. # Detailed Requirements 1. **Class**: `PlaylistManager` 2. **Constructor**: `__init__(self)` - Initializes an empty playlist manager. 3. **Method**: `add_video(self, video_id: str) -> None` - Adds a video with the given `video_id` to the playlist. 4. **Method**: `remove_video(self, video_id: str) -> None` - Removes a video with the given `video_id` from the playlist. If the video is not in the playlist, do nothing. 5. **Method**: `get_most_frequent_video(self) -> Optional[str]` - Returns the `video_id` of the most frequently added video to the playlist. If the playlist is empty, return `None`. # Constraints 1. The `video_id` will be a non-empty string with a maximum length of 100 characters. 2. At any given time, there will be at most `10^5` videos in the playlist. 3. When there is a tie for the most frequent video, return one of them arbitrarily. # Example Usage ```python playlist_manager = PlaylistManager() # Add some videos to the playlist playlist_manager.add_video(\\"video1\\") playlist_manager.add_video(\\"video2\\") playlist_manager.add_video(\\"video1\\") # Most frequent video should be \\"video1\\" assert playlist_manager.get_most_frequent_video() == \\"video1\\" # Remove a video playlist_manager.remove_video(\\"video1\\") # Most frequent video should now be \\"video1\\" as it\'s still in the playlist with one occurrence assert playlist_manager.get_most_frequent_video() == \\"video1\\" # Removing \\"video1\\" one more time should make \\"video2\\" the most frequent video playlist_manager.remove_video(\\"video1\\") assert playlist_manager.get_most_frequent_video() == \\"video2\\" # If we remove all videos, the result should be None playlist_manager.remove_video(\\"video2\\") assert playlist_manager.get_most_frequent_video() == None ``` Provide an implementation of the `PlaylistManager` class adhering to the above requirements. Also, include sufficient unittests to validate the correctness of your implementation.","solution":"from collections import defaultdict import heapq class PlaylistManager: def __init__(self): self.video_counts = defaultdict(int) self.max_heap = [] self.removal_set = set() # To handle lazy removal in max_heap def add_video(self, video_id: str) -> None: self.video_counts[video_id] += 1 # Push the negative of count to use max heap heapq.heappush(self.max_heap, (-self.video_counts[video_id], video_id)) def remove_video(self, video_id: str) -> None: if video_id in self.video_counts: self.video_counts[video_id] -= 1 if self.video_counts[video_id] == 0: del self.video_counts[video_id] # Lazy removal: add to removal_set for later processing self.removal_set.add(video_id) def get_most_frequent_video(self) -> str: while self.max_heap: count, video_id = heapq.heappop(self.max_heap) # If the video is in the removal_set, skip it if video_id in self.removal_set: self.removal_set.remove(video_id) continue # Push back the valid video heapq.heappush(self.max_heap, (count, video_id)) return video_id return None"},{"question":"# Coding Assessment Question **Context**: You are developing a feature for a library management system that organizes books by their titles. The feature must be able to handle different cases and spaces in titles to ensure accurate sorting. Your task is to write a function to sort a list of book titles alphabetically. Write a Python function `sort_book_titles(titles: List[str]) -> List[str]` that takes a list of book titles and returns a new list with the titles sorted in alphabetical order, ignoring case and leading/trailing spaces. **Function Signature**: ```python def sort_book_titles(titles: List[str]) -> List[str]: ``` **Input**: - `titles`: List of strings, where each string is a book title containing alphabetic characters and spaces. **Output**: - A new list of strings with the book titles sorted alphabetically (ignoring case and leading/trailing spaces). **Constraints**: - The list will contain at least one title. - Titles may contain upper and lower case letters and spaces. - Ignore leading and trailing spaces during sorting. **Example**: ```python titles = [ \\" The Catcher in the Rye\\", \\"To Kill a Mockingbird\\", \\" 1984\\", \\"Pride and Prejudice\\", \\"The Great Gatsby\\" ] sorted_titles = sort_book_titles(titles) print(sorted_titles) # Should print: # [ # \\" 1984\\", # \\"Pride and Prejudice\\", # \\" The Catcher in the Rye\\", # \\"The Great Gatsby\\", # \\"To Kill a Mockingbird\\" # ] ``` **Additional Instructions**: 1. Ensure that the function performs efficiently even with a large number of book titles. 2. Preserve the original titles in the output list (don\'t strip the spaces in the returned list). 3. Validate that all elements in the input list are strings and contain valid characters (alphabetic and spaces). Handle any invalid elements gracefully.","solution":"from typing import List def sort_book_titles(titles: List[str]) -> List[str]: Sorts a list of book titles alphabetically, ignoring case and leading/trailing spaces. Args: titles (List[str]): List of book titles as strings. Returns: List[str]: Sorted list of book titles. return sorted(titles, key=lambda title: title.strip().lower())"},{"question":"# Question **Problem Statement**: You are tasked with creating a script that manipulates strings and detects if there is a repeated substring pattern in them. A string is said to have a repeated substring pattern if it can be constructed by repeating a substring multiple times (more than once). **Objective**: 1. Write a function called `has_repeated_substring(s: str) -> bool` that takes a string `s` and returns `True` if the string has a repeated substring pattern, otherwise returns `False`. **Constraints**: - The length of the string `s` will be in the range `[1, 1000]`. - The string will consist of lowercase English letters only. **Input**: - A string `s` containing lowercase English letters. **Output**: - A boolean value indicating whether the string `s` has a repeated substring pattern. **Examples**: 1. `has_repeated_substring(\\"abab\\")` should return `True`, because the string can be formed by repeating the substring \\"ab\\" twice. 2. `has_repeated_substring(\\"aba\\")` should return `False`, because there is no repeated substring pattern. 3. `has_repeated_substring(\\"abcabcabc\\")` should return `True`, because the string can be formed by repeating the substring \\"abc\\" three times. 4. `has_repeated_substring(\\"a\\")` should return `False`, because the string consists of a single character and cannot have a repeated pattern more than once. This will test your ability to work with strings efficiently and understand substring patterns. Your solution should handle edge cases and input validation appropriately.","solution":"def has_repeated_substring(s: str) -> bool: Returns True if the string has a repeated substring pattern, otherwise returns False. n = len(s) for i in range(1, n // 2 + 1): if n % i == 0: # Check if the length is divisible by i if s[:i] * (n // i) == s: return True return False"},{"question":"Coding Assessment Question # Objective Write a function that calculates the total surface area and volume of a cylindrical tank given its radius and height. # Description You are tasked with creating a function that calculates the total surface area and the volume of a cylindrical tank. The total surface area of a cylinder includes the area of the two circular bases and the rectangular side surface that wraps around. Given: - `radius` (r): Radius of the cylindrical tank in meters. - `height` (h): Height of the cylindrical tank in meters. You need to calculate: 1. The total surface area using the formula: (A = 2πr(h + r)) 2. The volume using the formula: (V = πr^2h) # Function Signatures ```python def calculate_cylinder_surface_area(radius: float, height: float) -> float: Calculate the total surface area of a cylindrical tank given its radius and height. Parameters: - radius (float): Radius of the cylindrical tank (meters) - height (float): Height of the cylindrical tank (meters) Returns: - float: The total surface area (square meters) def calculate_cylinder_volume(radius: float, height: float) -> float: Calculate the volume of a cylindrical tank given its radius and height. Parameters: - radius (float): Radius of the cylindrical tank (meters) - height (float): Height of the cylindrical tank (meters) Returns: - float: The volume (cubic meters) ``` # Input/Output Formats **Input:** - radius: float (in meters, positive) - height: float (in meters, positive) **Output:** - surface_area: float (in square meters) - volume: float (in cubic meters) # Constraints 1. (0 < text{radius}) 2. (0 < text{height}) # Example Usage ```python # Calculate surface area surface_area = calculate_cylinder_surface_area(3, 5) print(surface_area) # Expected: 150.79644737231007 # Calculate volume volume = calculate_cylinder_volume(3, 5) print(volume) # Expected: 141.3716694115407 ``` # Hint Use the constants: - **π** (Pi) = 3.14159 Ensure to handle edge cases by raising appropriate checks and errors.","solution":"import math def calculate_cylinder_surface_area(radius: float, height: float) -> float: Calculate the total surface area of a cylindrical tank given its radius and height. Parameters: - radius (float): Radius of the cylindrical tank (meters) - height (float): Height of the cylindrical tank (meters) Returns: - float: The total surface area (square meters) if radius <= 0 or height <= 0: raise ValueError(\\"Radius and height must be positive.\\") surface_area = 2 * math.pi * radius * (height + radius) return surface_area def calculate_cylinder_volume(radius: float, height: float) -> float: Calculate the volume of a cylindrical tank given its radius and height. Parameters: - radius (float): Radius of the cylindrical tank (meters) - height (float): Height of the cylindrical tank (meters) Returns: - float: The volume (cubic meters) if radius <= 0 or height <= 0: raise ValueError(\\"Radius and height must be positive.\\") volume = math.pi * radius ** 2 * height return volume"},{"question":"# Scenario You are a software developer working on an event management application. One of the requirements is to generate a timeline of events sorted by start time and grouped by day. Each event has a title, start time, and end time. # Task Implement a function that processes a list of events and structures them into a day-wise timeline, where events are sorted by their start time within each day. # Implement the Following Function ```python def generate_timeline(events: List[Dict[str, str]]) -> Dict[str, List[Dict[str, str]]]: Processes a list of events and structures them into a day-wise timeline. Args: - events (List[Dict[str, str]]): List of events, where each event is represented as a dictionary with the keys \'title\', \'start_time\' and \'end_time\'. \'start_time\' and \'end_time\' are strings in the format \'YYYY-MM-DD HH:MM\'. Returns: - Dict[str, List[Dict[str, str]]]: Dictionary where each key is a date in the format \'YYYY-MM-DD\' and the value is a list of events for that day. Each event in the list is a dictionary with \'title\', \'start_time\', and \'end_time\' keys. ``` # Constraints - Assume all event times are in the same timezone. - The function should handle an empty list of events gracefully. - If two events have the same start time, maintain their input order. - The input events list can be unsorted. # Expected Input and Output Formats - Input: ```python events = [ {\'title\': \'Meeting\', \'start_time\': \'2023-10-01 09:00\', \'end_time\': \'2023-10-01 10:00\'}, {\'title\': \'Workshop\', \'start_time\': \'2023-10-01 11:00\', \'end_time\': \'2023-10-01 12:30\'}, {\'title\': \'Conference\', \'start_time\': \'2023-10-02 09:00\', \'end_time\': \'2023-10-02 17:00\'}, {\'title\': \'Lunch\', \'start_time\': \'2023-10-01 12:00\', \'end_time\': \'2023-10-01 13:00\'} ] ``` - Output: ```python { \'2023-10-01\': [ {\'title\': \'Meeting\', \'start_time\': \'2023-10-01 09:00\', \'end_time\': \'2023-10-01 10:00\'}, {\'title\': \'Workshop\', \'start_time\': \'2023-10-01 11:00\', \'end_time\': \'2023-10-01 12:30\'}, {\'title\': \'Lunch\', \'start_time\': \'2023-10-01 12:00\', \'end_time\': \'2023-10-01 13:00\'} ], \'2023-10-02\': [ {\'title\': \'Conference\', \'start_time\': \'2023-10-02 09:00\', \'end_time\': \'2023-10-02 17:00\'} ] } ``` # Example ```python events = [ {\'title\': \'Meeting\', \'start_time\': \'2023-10-01 09:00\', \'end_time\': \'2023-10-01 10:00\'}, {\'title\': \'Workshop\', \'start_time\': \'2023-10-01 11:00\', \'end_time\': \'2023-10-01 12:30\'}, {\'title\': \'Conference\', \'start_time\': \'2023-10-02 09:00\', \'end_time\': \'2023-10-02 17:00\'}, {\'title\': \'Lunch\', \'start_time\': \'2023-10-01 12:00\', \'end_time\': \'2023-10-01 13:00\'} ] timeline = generate_timeline(events) print(timeline) # Output should be: # { # \'2023-10-01\': [ # {\'title\': \'Meeting\', \'start_time\': \'2023-10-01 09:00\', \'end_time\': \'2023-10-01 10:00\'}, # {\'title\': \'Workshop\', \'start_time\': \'2023-10-01 11:00\', \'end_time\': \'2023-10-01 12:30\'}, # {\'title\': \'Lunch\', \'start_time\': \'2023-10-01 12:00\', \'end_time\': \'2023-10-01 13:00\'} # ], # \'2023-10-02\': [ # {\'title\': \'Conference\', \'start_time\': \'2023-10-02 09:00\', \'end_time\': \'2023-10-02 17:00\'} # ] # } ```","solution":"from typing import List, Dict from collections import defaultdict import datetime def generate_timeline(events: List[Dict[str, str]]) -> Dict[str, List[Dict[str, str]]]: Processes a list of events and structures them into a day-wise timeline. Args: - events (List[Dict[str, str]]): List of events, where each event is represented as a dictionary with the keys \'title\', \'start_time\' and \'end_time\'. \'start_time\' and \'end_time\' are strings in the format \'YYYY-MM-DD HH:MM\'. Returns: - Dict[str, List[Dict[str, str]]]: Dictionary where each key is a date in the format \'YYYY-MM-DD\' and the value is a list of events for that day. Each event in the list is a dictionary with \'title\', \'start_time\', and \'end_time\' keys. timeline = defaultdict(list) # Group events by date for event in events: date = event[\'start_time\'].split(\' \')[0] timeline[date].append(event) # Sort events within each day by start time for date in timeline: timeline[date].sort(key=lambda x: x[\'start_time\']) return timeline"},{"question":"# Binary Tree Height Calculation and Level Order Traversal # Objective Your task is to implement two functionalities for a binary tree: calculating its height and performing a level-order traversal (breadth-first traversal). # Problem Description Part 1: Binary Tree Height Calculation Implement `calculate_height` function that accepts the root node of a binary tree and returns the height of the tree. The height of a tree is defined as the number of edges in the longest path from the root to a leaf node. Part 2: Level Order Traversal of Binary Tree Implement `level_order_traversal` function that accepts the root node of a binary tree and returns a list of lists, with each internal list representing the nodes at each level from the root to the leaves. # Function Signatures ```python class TreeNode: def __init__(self, value: int = 0, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.value = value self.left = left self.right = right def calculate_height(root: TreeNode) -> int: pass def level_order_traversal(root: TreeNode) -> List[List[int]]: pass ``` # Input/Output Specifications Part 1: Binary Tree Height Calculation * **Input**: The root node of a binary tree. * Example: A tree with root as `TreeNode(1)` and left child as `TreeNode(2)`: 1 / 2 * **Output**: An integer representing the height of the tree. * Example: `1` Part 2: Level Order Traversal of Binary Tree * **Input**: The root node of a binary tree. * Example: A tree with nodes `[3, 9, 20, None, None, 15, 7]` representing: 3 / 9 20 / 15 7 * **Output**: A list of lists, where each internal list contains the values of nodes at each level. * Example: `[[3], [9, 20], [15, 7]]` # Constraints * The number of nodes in the tree will not exceed 10^5. * Each node\'s value is an integer within the range [-10^9, 10^9]. # Examples Part 1: Binary Tree Height Calculation ```python >>> root = TreeNode(1, TreeNode(2), TreeNode(3)) >>> calculate_height(root) 1 >>> root = TreeNode(1, TreeNode(2, TreeNode(3, TreeNode(4), None), None), TreeNode(5)) >>> calculate_height(root) 3 ``` Part 2: Level Order Traversal of Binary Tree ```python >>> root = TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7))) >>> level_order_traversal(root) [[3], [9, 20], [15, 7]] >>> root = TreeNode(1) >>> level_order_traversal(root) [[1]] >>> level_order_traversal(None) [] ``` # Implementation Details * Ensure that your solutions handle empty inputs (null trees) gracefully. * For both parts, you can assume that the binary tree has no cycles and is a valid binary tree structure.","solution":"from typing import List, Optional class TreeNode: def __init__(self, value: int = 0, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.value = value self.left = left self.right = right def calculate_height(root: Optional[TreeNode]) -> int: if root is None: return 0 else: left_height = calculate_height(root.left) right_height = calculate_height(root.right) return max(left_height, right_height) + 1 def level_order_traversal(root: Optional[TreeNode]) -> List[List[int]]: if root is None: return [] result = [] queue = [root] while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.pop(0) current_level.append(node.value) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(current_level) return result"},{"question":"# Custom Linked List Manipulations You are tasked with implementing a custom singly linked list and performing various manipulations on it. The custom linked list will support insertion, deletion, and reversal of the list. # Problem Statement Implement a class `CustomLinkedList` which supports the following methods: - `insert(self, value: int) -> None`: Inserts a new element with the given `value` at the end of the list. - `delete(self, value: int) -> bool`: Deletes the first occurrence of the element with the given `value` from the list. Returns `True` if the element was found and deleted, `False` otherwise. - `reverse(self) -> None`: Reverses the linked list. Additionally, implement a method `to_list(self) -> list[int]` which returns a list representation of the current elements in the linked list. # Class and Method Signatures ```python class Node: def __init__(self, value: int): self.value = value self.next = None class CustomLinkedList: def __init__(self): self.head = None def insert(self, value: int) -> None: pass def delete(self, value: int) -> bool: pass def reverse(self) -> None: pass def to_list(self) -> list[int]: pass ``` # Example ```python # Initialization linked_list = CustomLinkedList() # Inserting elements linked_list.insert(1) linked_list.insert(2) linked_list.insert(3) print(linked_list.to_list()) # Expected output: [1, 2, 3] # Deleting an element deleted = linked_list.delete(2) print(deleted) # Expected output: True print(linked_list.to_list()) # Expected output: [1, 3] # Deleting a non-existent element deleted = linked_list.delete(4) print(deleted) # Expected output: False # Reversing the linked list linked_list.reverse() print(linked_list.to_list()) # Expected output: [3, 1] ``` # Constraints * The linked list will only contain integer values. * Duplicate values are allowed in the list. * The initial linked list is empty. * The `reverse()` method should reverse the list in-place.","solution":"class Node: def __init__(self, value: int): self.value = value self.next = None class CustomLinkedList: def __init__(self): self.head = None def insert(self, value: int) -> None: new_node = Node(value) if not self.head: self.head = new_node else: current = self.head while current.next: current = current.next current.next = new_node def delete(self, value: int) -> bool: if not self.head: return False if self.head.value == value: self.head = self.head.next return True current = self.head while current.next and current.next.value != value: current = current.next if not current.next: return False current.next = current.next.next return True def reverse(self) -> None: prev = None current = self.head while current: next_node = current.next current.next = prev prev = current current = next_node self.head = prev def to_list(self) -> list[int]: elements = [] current = self.head while current: elements.append(current.value) current = current.next return elements"},{"question":"# Problem Statement You are tasked with creating a function to evaluate the correctness and performance of different sorting algorithms. This function will generate random integers, sort them using provided sorting functions, and measure the time taken for the sorting process. # Specifications * **Function**: `evaluate_sorting_algorithms(algorithms: dict[str, callable], n: int) -> dict[str, float]` * **Input**: * A dictionary `algorithms` where keys are the names of the sorting algorithms (as strings) and values are the corresponding sorting functions. * An integer `n` specifying the number of random integers to generate for the evaluation. * **Output**: A dictionary where keys are the names of the sorting algorithms and values are the time taken (in seconds) to sort the generated list. # Constraints * The integer `n` will not exceed `10^6`. * The generated integers will lie between `-10^6` and `10^6`. * The sorting functions provided will have the signature `sort(arr: list[int]) -> list[int]`. # Example ```python import random import time def bubble_sort(arr): n = len(arr) for i in range(n): for j in range(0, n-i-1): if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] return arr def quick_sort(arr): if len(arr) <= 1: return arr pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quick_sort(left) + middle + quick_sort(right) algorithms = { \\"Bubble Sort\\": bubble_sort, \\"Quick Sort\\": quick_sort } def evaluate_sorting_algorithms(algorithms, n): results = {} random_lst = random.sample(range(-10**6, 10**6), n) for name, sort_func in algorithms.items(): lst_copy = random_lst[:] start_time = time.time() sorted_lst = sort_func(lst_copy) end_time = time.time() results[name] = end_time - start_time return results # Example usage results = evaluate_sorting_algorithms(algorithms, 10000) print(results) # Output might be {\'Bubble Sort\': 5.234, \'Quick Sort\': 0.002} ``` In the example provided, the function `evaluate_sorting_algorithms` is used to measure how long it takes for bubble sort and quick sort to sort a list of 10,000 random integers. The output is a dictionary indicating the time taken by each algorithm.","solution":"import random import time def evaluate_sorting_algorithms(algorithms, n): results = {} random_lst = random.sample(range(-10**6, 10**6), n) for name, sort_func in algorithms.items(): lst_copy = random_lst[:] start_time = time.time() sort_func(lst_copy) # Assuming the function sorts in place end_time = time.time() results[name] = end_time - start_time return results def bubble_sort(arr): n = len(arr) for i in range(n): for j in range(0, n-i-1): if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] return arr def quick_sort(arr): if len(arr) <= 1: return arr pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quick_sort(left) + middle + quick_sort(right)"},{"question":"# Problem Statement Write a function `count_paths` that takes an `m x n` grid of characters and returns the number of unique paths from the top-left corner to the bottom-right corner of the grid. In each step, you can only move down or right, and you must follow an alphabetically increasing path, i.e., each subsequent character in the path must be lexicographically greater than or equal to the previous character. Function Signature ```python def count_paths(grid: list[list[str]]) -> int: ``` Input - `grid` (list[list[str]]): A 2D list representing the `m x n` character grid, where the characters are lowercase English letters, and `1 <= m, n <= 50`. Output - An integer representing the total number of unique alphabetically non-decreasing paths from the top-left corner to the bottom-right corner of the grid. Constraints - You must explore all possible valid paths. - Optimize your solution to handle the largest values of `m` and `n` efficiently. # Example ```python grid1 = [ [\'a\', \'b\', \'c\'], [\'d\', \'e\', \'f\'], [\'g\', \'h\', \'i\'] ] print(count_paths(grid1)) # Output should be: 1 # Explanation: Only one path \\"abcdefi\\". grid2 = [ [\'a\', \'b\', \'c\'], [\'b\', \'c\', \'d\'], [\'c\', \'d\', \'e\'] ] print(count_paths(grid2)) # Output should be: 6 # Explanation: Possible paths: \\"abbce\\", \\"abbde\\", \\"abccde\\", \\"abde\\", \\"acde\\", \\"ade\\" ``` # Additional Notes - Be sure to handle edge cases such as grids with only one row or one column. - Test your function thoroughly to ensure all paths adhering to the lexicographical constraint are counted. This problem requires a deep understanding of recursion or dynamic programming to explore all potential paths, while maintaining the alphabetical order condition efficiently.","solution":"def count_paths(grid): m, n = len(grid), len(grid[0]) memo = {} def dfs(x, y, prev_char): if x >= m or y >= n or grid[x][y] < prev_char: return 0 if (x, y) == (m-1, n-1): return 1 if (x, y, prev_char) in memo: return memo[(x, y, prev_char)] right = dfs(x, y + 1, grid[x][y]) down = dfs(x + 1, y, grid[x][y]) memo[(x, y, prev_char)] = right + down return memo[(x, y, prev_char)] return dfs(0, 0, \'\') # Example usage: grid1 = [ [\'a\', \'b\', \'c\'], [\'d\', \'e\', \'f\'], [\'g\', \'h\', \'i\'] ] # Expected output: 1 print(count_paths(grid1)) grid2 = [ [\'a\', \'b\', \'c\'], [\'b\', \'c\', \'d\'], [\'c\', \'d\', \'e\'] ] # Expected output: 6 print(count_paths(grid2))"},{"question":"# Coding Assessment Question Context Given a binary matrix, a submatrix is any rectangular area within the matrix with all elements being 1. The problem involves finding the largest submatrix with all 1s for a given binary matrix. Problem Statement Write a function `largest_submatrix(matrix: List[List[int]]) -> int` that takes a binary matrix, represented as a list of lists of integers, and returns the area of the largest submatrix with all 1s. Function Signature ```python from typing import List def largest_submatrix(matrix: List[List[int]]) -> int: pass ``` Input - **matrix** (List[List[int]]): A binary matrix where each element is either 0 or 1. The matrix size is M x N (1 <= M, N <= 200). Output - **int**: The area of the largest submatrix with all 1s. Example ```python assert largest_submatrix([ [0, 1, 1, 0, 1], [1, 1, 0, 1, 0], [0, 1, 1, 1, 0], [1, 1, 1, 1, 0] ]) == 6 assert largest_submatrix([ [1, 0, 1, 1, 1], [0, 1, 1, 1, 1], [0, 1, 1, 1, 1], [1, 1, 1, 1, 0] ]) == 9 ``` Constraints 1. Avoid unnecessary iterations to meet the time complexity requirements. 2. The final implementation should handle large matrices efficiently. Notes - You might need to use a dynamic programming approach to solve this problem. - Consider preprocessing the matrix to transform it into a more manageable data structure that allows for faster submatrix calculation.","solution":"from typing import List def largest_submatrix(matrix: List[List[int]]) -> int: if not matrix or not matrix[0]: return 0 rows = len(matrix) cols = len(matrix[0]) # Create a dp array to store heights of histograms dp = [[0] * cols for _ in range(rows)] # Fill the dp array for i in range(rows): for j in range(cols): if matrix[i][j] == 1: dp[i][j] = dp[i-1][j] + 1 if i > 0 else 1 # Function to calculate maximum rectangle in histogram def max_histogram_area(heights: List[int]) -> int: stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area max_area = 0 # Calculate the maximum area rectangle in each histogram row for row in dp: max_area = max(max_area, max_histogram_area(row)) return max_area"},{"question":"# Matrix Diagonal Sum ***Scenario:*** You are designing a component for a spreadsheet application that performs specific operations on matrix data. One of the required features is to calculate the sum of all elements present on the main diagonal and the anti-diagonal of a given square matrix. This functionality helps users quickly verify the integrity and properties of the dataset within the matrix. # Problem Statement Implement a function `diagonal_sum(matrix: List[List[int]]) -> int` that takes a square matrix (2D list) and returns the sum of the elements on the main diagonal and the anti-diagonal. If an element lies on both diagonals (which can only happen in the center of an odd-dimensional matrix), it should only be included once in the sum. # Function Signature ```python def diagonal_sum(matrix: List[List[int]]) -> int: pass ``` # Input * `matrix`: A list of lists of integers representing a square matrix. The dimension `n` (length of sides of the matrix) will satisfy (1 <= `n` <= 1,000). # Output * An integer representing the sum of elements on the main diagonal and the anti-diagonal. # Examples 1. Input: `matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]` Output: `25` (1 + 5 + 9 + 3 + 7) 2. Input: `matrix = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]` Output: `3` (1 + 1 + 1) 3. Input: `matrix = [[5]]` Output: `5` (only one element) # Constraints or Considerations * Ensure your solution is optimized for performance given the possible matrix size. * Carefully handle elements that belong to both diagonals, counting them only once. # Performance Requirements * Expected to handle large matrices up to 1,000 x 1,000 efficiently. * Minimize both time complexity and space complexity wherever possible. Remember, test your solution with edge cases, such as the smallest and largest possible matrices, and document any assumptions or particular scenarios.","solution":"def diagonal_sum(matrix): n = len(matrix) total_sum = 0 for i in range(n): total_sum += matrix[i][i] # Add element from main diagonal total_sum += matrix[i][n-i-1] # Add element from anti-diagonal # If the matrix size is odd, subtract the middle element added twice if n % 2 == 1: total_sum -= matrix[n//2][n//2] return total_sum"},{"question":"# Coding Challenge Context You have been asked to implement a function that manipulates strings by alternating between uppercase and lowercase in a given sequence. Specifically, given a string, you should modify the string such that each character in even positions (0-indexed) is converted to uppercase and each character in odd positions is converted to lowercase. Task Implement a function: ```python def alternating_case(s: str) -> str: pass ``` Function Signature ```python def alternating_case(s: str) -> str: ``` Input * A string ( s ) (1 ≤ |s| ≤ 10^4) consisting of only alphabetic characters. Output * A modified string where each character in even positions is converted to uppercase and each character in odd positions is converted to lowercase. Examples ```python >>> alternating_case(\\"hello\\") \\"HeLlO\\" >>> alternating_case(\\"PyThOn\\") \\"PyThOn\\" >>> alternating_case(\\"ALTERNATINGcase\\") \\"AlTeRnAtInGcAsE\\" ``` Constraints * You should ensure your function works efficiently with the given constraints. * Handle both uppercase and lowercase letters appropriately according to their positions.","solution":"def alternating_case(s: str) -> str: Converts each character in a string to alternating case, starting with uppercase for characters at even positions (0-indexed) and lowercase for characters at odd positions. result = [] for i, char in enumerate(s): if i % 2 == 0: result.append(char.upper()) else: result.append(char.lower()) return \'\'.join(result)"},{"question":"# Question: Function to Implement: `balance_scale` Context: You are given a balance scale and a set of weights. The scale is initially balanced, and we can add weights on either side to maintain or reset the balance. Each weight has an integer value representing its mass. The task is to write a function to determine the mass difference when weights are added to different sides of the balance. Task: You need to implement the function `balance_scale`: ```python def balance_scale(left_weights: list[int], right_weights: list[int]) -> int: Input Parameters ---------------- left_weights: List of integers representing the masses of weights added to the left side of the scale. right_weights: List of integers representing the masses of weights added to the right side of the scale. Returns ------- mass_difference: Integer representing the absolute difference between the two sides. The function should calculate and return the positive difference between the total mass on the left side and the total mass on the right side. ``` Examples: 1. `balance_scale(left_weights=[5, 10, 15], right_weights=[10, 10])` should return `10`. 2. `balance_scale(left_weights=[1, 2, 3, 4], right_weights=[10])` should return `0`. 3. `balance_scale(left_weights=[], right_weights=[])` should return `0`. 4. `balance_scale(left_weights=[100], right_weights=[50, 25, 25])` should return `0`. 5. `balance_scale(left_weights=[5, -10], right_weights=[5])` should raise `ValueError(\\"Mass cannot be negative\\")`. Constraints: * The weights list will contain non-negative integers representing the mass values. * If any weight is negative, the function should raise a `ValueError(\\"Mass cannot be negative\\")`. Edge Cases: * Empty list for either side. * Negative values in the weights list. * Both sides having equal mass.","solution":"def balance_scale(left_weights: list[int], right_weights: list[int]) -> int: Calculate the positive difference between the total mass on the left side and the total mass on the right side. Parameters: left_weights (list[int]): List of integers representing the masses of weights added to the left side of the scale. right_weights (list[int]): List of integers representing the masses of weights added to the right side of the scale. Returns: int: Absolute difference between the mass on the left and right sides. if any(w < 0 for w in left_weights + right_weights): raise ValueError(\\"Mass cannot be negative\\") left_total = sum(left_weights) right_total = sum(right_weights) return abs(left_total - right_total)"},{"question":"# Hash Table Manipulation: Implement Collision-Handled Hash Table with Double Hashing In this task, you are required to handle collisions in a hash table using a double hashing technique. Scenario: You are developing a library system to store book titles based on their unique ISBN numbers. The ISBN numbers need to be hashed for efficient storage and retrieval. To handle hash collisions, you’ll use double hashing. Objective: Implement a function `insert_into_book_hash_table` that inserts book titles into a hash table using their ISBN numbers as keys with a double hashing technique to handle collisions. Additionally, implement a function `retrieve_from_book_hash_table` that retrieves a book title given its ISBN number. # Specifications: 1. Functions: * `insert_into_book_hash_table` - Takes a hash table (a list with `None` values indicating empty slots) and a list of tuples, where each tuple contains an ISBN and a book title, and inserts each book title into the hash table using its ISBN number. * `retrieve_from_book_hash_table` - Takes the hash table and an ISBN number, and returns the book title stored at the hash calculated from the ISBN. 2. Hashing Functions: * Primary hash function: `h1(key) = key % len(hash_table)` * Secondary hash function: `h2(key) = 1 + (key % (len(hash_table) - 1))` * The double hashing calculation for finding the next slot: `(h1(key) + i * h2(key)) % len(hash_table)` where `i` starts from 0 and is incremented until an empty slot is found for insertion or the desired key is found for retrieval. 3. Input/Output Formats: * **Input**: * For `insert_into_book_hash_table`: * `hash_table`: a list initialized with `None` representing the slots in the hash table. * `isbn_title_pairs`: a list of tuples, where each tuple contains an ISBN number (integer) and a book title (string). * For `retrieve_from_book_hash_table`: * `hash_table`: a list with book titles stored using their hashed ISBN numbers. * `isbn`: an integer representing the ISBN number. * **Output**: * For `insert_into_book_hash_table`: The function does not need to return anything. It modifies the `hash_table` in place. * For `retrieve_from_book_hash_table`: A string representing the book title corresponding to the given ISBN or `None` if the ISBN is not found. Function Signatures: ```python def insert_into_book_hash_table(hash_table: list, isbn_title_pairs: list) -> None: pass def retrieve_from_book_hash_table(hash_table: list, isbn: int) -> str: pass ``` Example Usage: ```python hash_table = [None] * 10 insert_into_book_hash_table(hash_table, [(12345, \'Book A\'), (67890, \'Book B\'), (54321, \'Book C\')]) expected_position = (12345 % 10) assert retrieve_from_book_hash_table(hash_table, 12345) == \'Book A\' assert retrieve_from_book_hash_table(hash_table, 67890) == \'Book B\' assert retrieve_from_book_hash_table(hash_table, 54321) == \'Book C\' assert retrieve_from_book_hash_table(hash_table, 11111) == None ``` Constraints: * ISBN numbers are positive integers. * Book titles are non-empty strings composed of alphanumeric characters and spaces. * The length of the hash table should be prime to minimize collisions. * Functions should handle large lists of books efficiently. * Existing entries in the hash table must not be overwritten during insertions. * Assume that the ISBNs provided are unique.","solution":"def h1(key, table_size): Primary hash function return key % table_size def h2(key, table_size): Secondary hash function return 1 + (key % (table_size - 1)) def insert_into_book_hash_table(hash_table, isbn_title_pairs): Inserts book titles into the hash table using double hashing. table_size = len(hash_table) for isbn, title in isbn_title_pairs: index = h1(isbn, table_size) i = 0 while hash_table[(index + i * h2(isbn, table_size)) % table_size] is not None: i += 1 hash_table[(index + i * h2(isbn, table_size)) % table_size] = (isbn, title) def retrieve_from_book_hash_table(hash_table, isbn): Retrieves a book title from the hash table given an ISBN number. table_size = len(hash_table) index = h1(isbn, table_size) i = 0 while hash_table[(index + i * h2(isbn, table_size)) % table_size] is not None: stored_isbn, title = hash_table[(index + i * h2(isbn, table_size)) % table_size] if stored_isbn == isbn: return title i += 1 return None"},{"question":"# Question Design a function `rotate_right` that takes a list of integers and an integer `k`, which specifies the number of positions to rotate the list to the right. The function should return the modified list after rotating. A right rotation on an array shifts each of the array\'s elements `k` units to the right. If `k` is greater than the length of the list, it rotates the list `k % len(list)` times instead. Function Signature ```python def rotate_right(nums: List[int], k: int) -> List[int]: ``` Input * `nums`: A list of integers. * `k`: A non-negative integer indicating the number of positions to rotate the list to the right. Output * A list of integers, representing the rotated list. Constraints * The list can have up to (10^5) elements. * Each element of the list is an integer within the range (-10^6) to (10^6). * The value of `k` will be a non-negative integer within the range from 0 to (10^6). Example ```python >>> rotate_right([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_right([0, 1, 2], 4) [2, 0, 1] >>> rotate_right([1, 2, 3], 0) [1, 2, 3] ``` In the first example, rotating the list `[1, 2, 3, 4, 5]` two positions to the right results in `[4, 5, 1, 2, 3]`. In the second example, rotating `[0, 1, 2]` four positions to the right is equivalent to rotating it once due to the list length being 3, resulting in `[2, 0, 1]`. In the third example, a rotation by 0 positions leaves the list unchanged.","solution":"from typing import List def rotate_right(nums: List[int], k: int) -> List[int]: Rotates the list `nums` to the right by `k` positions. if not nums: return nums k = k % len(nums) # In case k is greater than length of nums return nums[-k:] + nums[:-k]"},{"question":"# Problem Statement Given an array of integers, write a function to determine if the array can be rearranged to form an arithmetic progression. An arithmetic progression is a sequence of numbers such that the difference between any two consecutive terms is the same. # Function Signature ```python def can_form_arithmetic_progression(arr: List[int]) -> bool: ``` # Input * A list of integers `arr` where (2 leq text{len}(arr) leq 10^5) and (-10^6 leq text{arr[i]} leq 10^6), representing the elements of the array. # Output * Return `True` if the array can be rearranged to form an arithmetic progression, and `False` otherwise. # Constraints 1. The input list will contain at least two elements. 2. The elements of the input list are integers and can be both positive and negative. # Examples ```python >>> can_form_arithmetic_progression([3, 5, 1]) True >>> can_form_arithmetic_progression([1, 2, 4]) False >>> can_form_arithmetic_progression([-1, -3, -5, -7]) True >>> can_form_arithmetic_progression([0, 0, 0, 0]) True ``` # Explanation 1. **Example 1**: The array [3, 5, 1] can be rearranged to form [1, 3, 5] which is an arithmetic progression with a common difference of 2. 2. **Example 2**: The array [1, 2, 4] cannot be rearranged to form an arithmetic progression. 3. **Example 3**: The array [-1, -3, -5, -7] is already an arithmetic progression with a common difference of -2. 4. **Example 4**: The array [0, 0, 0, 0] is an arithmetic progression with a common difference of 0. # Performance Requirements 1. Ensure that your implementation works efficiently within the given constraint. 2. Aim for a time complexity of (O(n log n)) for sorting and (O(n)) for verifying the arithmetic progression.","solution":"from typing import List def can_form_arithmetic_progression(arr: List[int]) -> bool: Determines if the array can be rearranged to form an arithmetic progression. arr.sort() # First, sort the array # Calculate the common difference using the first two elements common_diff = arr[1] - arr[0] # Check if the difference between consecutive elements is consistent for i in range(2, len(arr)): if arr[i] - arr[i - 1] != common_diff: return False return True"},{"question":"# Context You are part of a development team tasked with building a recommendation system for a streaming service. The system should generate personalized movie recommendations based on the user’s viewing history and ratings. For this, you will implement a simplified version of a collaborative filtering algorithm. # Objective Implement the core functions required to generate movie recommendations. Your implementation must adhere to collaborative filtering principles and operate efficiently within the provided constraints. # Function Definitions 1. `initialize(user_data: dict[int, list[int]], movie_ratings: list[list[int]])`: - Initializes the recommendation system with user viewing history and movie ratings data. 2. `add_rating(user_id: int, movie_id: int, rating: int)`: - Updates the user’s rating for a specific movie. 3. `recommend(user_id: int) -> list[int]`: - Generates and returns a list of recommended movie IDs for the specified user. 4. `reset()`: - Resets the recommendation system to its initial state. # Input and Output Formats - **initialize(user_data: dict[int, list[int]], movie_ratings: list[list[int]])** * `user_data`: Dictionary, where keys are user IDs and values are lists of watched movie IDs. * `movie_ratings`: 2D list, where `movie_ratings[i][j]` is the rating of movie `j` by user `i`. - **add_rating(user_id: int, movie_id: int, rating: int)** * `user_id`: Integer, the ID of the user. * `movie_id`: Integer, the ID of the movie. * `rating`: Integer, the rating given by the user (1-5). - **recommend(user_id: int) -> list[int]** * `user_id`: Integer, the ID of the user. * Returns: List of integers, the recommended movie IDs. - **reset()** * No return value. Resets the data. # Constraints - `1 <= user_id <= 1000` - `1 <= movie_id <= 1000` - `1 <= rating <= 5` - Each movie rating is given a value from 1 to 5. - Each user can only rate a movie once. # Example Usage ```python # Initialize system initialize( user_data={1: [1, 2, 3], 2: [2, 3, 4]}, movie_ratings=[[0, 4, 5, 0], [5, 0, 0, 3]] ) # Add a new rating add_rating(1, 4, 5) # Get recommendations for a user print(recommend(1)) # Example output: [4, 5, 2] # Reset system reset() ``` # Task Implement the functions `initialize`, `add_rating`, `recommend`, and `reset` following the detailed guidelines and constraints.","solution":"import numpy as np class RecommendationSystem: def __init__(self): self.user_data = {} self.movie_ratings = None def initialize(self, user_data, movie_ratings): Initializes the recommendation system with user viewing history and movie ratings data. self.user_data = user_data self.movie_ratings = np.array(movie_ratings) def add_rating(self, user_id, movie_id, rating): Updates the user\'s rating for a specific movie. self.movie_ratings[user_id - 1, movie_id - 1] = rating if user_id not in self.user_data: self.user_data[user_id] = [] if movie_id not in self.user_data[user_id]: self.user_data[user_id].append(movie_id) def recommend(self, user_id): Generates and returns a list of recommended movie IDs for the specified user. user_ratings = self.movie_ratings[user_id - 1] watched_movies = set(self.user_data.get(user_id, [])) similarities = [] for idx, other_user_ratings in enumerate(self.movie_ratings): if idx + 1 == user_id: continue sim = np.dot(user_ratings, other_user_ratings) similarities.append((idx + 1, sim)) # Sort by similarity score in descending order similarities.sort(key=lambda x: x[1], reverse=True) # Collect movies from top similar users that current user hasn\'t watched recommendations = [] for other_user_id, _ in similarities: for movie_id in self.user_data.get(other_user_id, []): if movie_id not in watched_movies: recommendations.append(movie_id) if len(recommendations) >= 5: return recommendations return recommendations def reset(self): Resets the recommendation system to its initial state. self.user_data = {} self.movie_ratings = None # Instance of the system system = RecommendationSystem() # Wrapper functions to use instance def initialize(user_data, movie_ratings): system.initialize(user_data, movie_ratings) def add_rating(user_id, movie_id, rating): system.add_rating(user_id, movie_id, rating) def recommend(user_id): return system.recommend(user_id) def reset(): system.reset()"},{"question":"# Problem Statement You are given a sequence of numbers stored in a singly linked list. Your task is to create a function that detects a cycle in this linked list. A cycle occurs when a node\'s \\"next\\" pointer points back to a previous node in the list rather than pointing to `None`, thus forming a loop. Write a Python function called `detect_cycle()` that takes a `head` node of a singly linked list as its parameter and returns a boolean value indicating whether there is a cycle in the linked list or not. # Input - `head`: A `ListNode` object representing the head of the singly linked list. Each `ListNode` has two attributes: - `val`: An integer representing the value stored in the node. - `next`: A reference to the next `ListNode` in the sequence. If it is the end of the list, `next` is `None`. # Output - A boolean value. `True` if a cycle is detected, `False` otherwise. # Example ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def detect_cycle(head: ListNode) -> bool: slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False # Example usage # Creating a cycle list: 1 -> 2 -> 3 -> 4 -> 2 (cycle) node1 = ListNode(1) node2 = ListNode(2) node3 = ListNode(3) node4 = ListNode(4) node1.next = node2 node2.next = node3 node3.next = node4 node4.next = node2 print(detect_cycle(node1)) # Output: True # Creating a non-cycle list: 1 -> 2 -> 3 -> 4 node5 = ListNode(1) node6 = ListNode(2) node7 = ListNode(3) node8 = ListNode(4) node5.next = node6 node6.next = node7 node7.next = node8 print(detect_cycle(node5)) # Output: False ``` # Note - The function should operate in O(n) time complexity, where n is the number of nodes in the linked list. - The function should use O(1) space complexity – no extra data structures should be used, except for a few pointers for traversal.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def detect_cycle(head: ListNode) -> bool: slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False"},{"question":"# Problem Statement Create a function that determines whether a given string `s` is a valid palindrome, considering only alphanumeric characters and ignoring cases. Your solution should be designed to handle strings of considerable length efficiently. # Input Format * A single string ( s ). # Output Format * Return `True` if the string is a valid palindrome, or `False` otherwise. # Constraints * The string can contain any printable ASCII characters. * The length of the string can range from ( 0 ) to ( 10^5 ). # Example ```python For an input string \\"A man, a plan, a canal: Panama\\", the output should be True. For an input string \\"race a car\\", the output should be False. ``` # Instructions 1. Do not use built-in functions for reversing strings or checking palindromes. 2. Optimize for both time and space complexity. # Solution Template Here is a starting template for your solution: ```python def valid_palindrome(s): def is_alphanumeric(c): return c.isalnum() left, right = 0, len(s) - 1 while left < right: while left < right and not is_alphanumeric(s[left]): left += 1 while left < right and not is_alphanumeric(s[right]): right -= 1 if s[left].lower() != s[right].lower(): return False left += 1 right -= 1 return True if __name__ == \\"__main__\\": user_input = input(\\"Enter a string:n\\").strip() print(valid_palindrome(user_input)) ``` In your implementation, ensure that you handle all edge cases effectively and test the function against a variety of input scenarios before finalizing your code.","solution":"def valid_palindrome(s): Determines if a given string is a valid palindrome, considering only alphanumeric characters and ignoring case. def is_alphanumeric(c): Check if a character is alphanumeric. return c.isalnum() left, right = 0, len(s) - 1 while left < right: while left < right and not is_alphanumeric(s[left]): left += 1 while left < right and not is_alphanumeric(s[right]): right -= 1 if s[left].lower() != s[right].lower(): return False left += 1 right -= 1 return True"},{"question":"# Max Subarray Sum with Constraint Problem Description Given an integer array, implement a function to find the maximum sum of a contiguous subarray, where the length of the subarray is at least `m` and at most `n`. Function Signature ```python def max_subarray_sum_with_constraint(nums: List[int], m: int, n: int) -> int: pass ``` Input * `nums` (List[int]): A list of integers. (-10^4 <= nums[i] <= 10^4, 1 <= len(nums) <= 10^5) * `m` (integer): The minimum length of the subarray. (1 <= m <= len(nums)) * `n` (integer): The maximum length of the subarray. (m <= n <= len(nums)) Output * Return an integer representing the maximum sum of a contiguous subarray where the length is between `m` and `n`. Constraints * The solution should be optimized for large inputs. Example ```python assert max_subarray_sum_with_constraint([1, -2, 3, 4, -1, 2, 1, -5, 4], 2, 4) == 8 assert max_subarray_sum_with_constraint([-1, -2, -3], 1, 2) == -1 ``` Hints * Consider using a sliding window approach with auxiliary data structures to keep track of sums efficiently. * Dynamic programming could be useful to handle the constraint on the subarray length. --- The new question integrates seamlessly by maintaining the style, complexity, and scope of the provided example, testing the ability to efficiently handle subarray problems with length constraints.","solution":"from typing import List def max_subarray_sum_with_constraint(nums: List[int], m: int, n: int) -> int: if not nums: return 0 max_sum = float(\'-inf\') window_sum = 0 prefix_sum = [0] * (len(nums) + 1) # Calculate prefix sums for i in range(len(nums)): prefix_sum[i + 1] = prefix_sum[i] + nums[i] # Consider subarrays with length at least m and at most n for i in range(len(nums) - m + 1): for j in range(m, n + 1): if i + j <= len(nums): subarray_sum = prefix_sum[i + j] - prefix_sum[i] max_sum = max(max_sum, subarray_sum) return max_sum"},{"question":"Fibonacci Sequence Generator The Fibonacci sequence is a series of numbers in which each number is the sum of the two preceding ones, usually starting with 0 and 1. The sequence goes like this: 0, 1, 1, 2, 3, 5, 8, and so on. Your task is to implement a class `FibonacciGenerator` that generates Fibonacci numbers efficiently. The class will have the following methods: 1. **get_nth_fibonacci(n: int) -> int**: Return the nth Fibonacci number. 2. **generate_fibonacci_sequence(n: int) -> List[int]**: Return a list containing the first n Fibonacci numbers. 3. **is_fibonacci_number(num: int) -> bool**: Check if a given number is a Fibonacci number. # Requirements: * The input `n` for `get_nth_fibonacci` and `generate_fibonacci_sequence` will be a non-negative integer. * The input `num` for `is_fibonacci_number` will be a non-negative integer. * Your implementation should be efficient and able to handle large values of `n` without excessive time complexity. # Example: ```python class FibonacciGenerator: @staticmethod def get_nth_fibonacci(n: int) -> int: # Implement this method pass @staticmethod def generate_fibonacci_sequence(n: int) -> List[int]: # Implement this method pass @staticmethod def is_fibonacci_number(num: int) -> bool: # Implement this method pass # Example Usage: assert FibonacciGenerator.get_nth_fibonacci(0) == 0 assert FibonacciGenerator.get_nth_fibonacci(1) == 1 assert FibonacciGenerator.get_nth_fibonacci(6) == 8 assert FibonacciGenerator.generate_fibonacci_sequence(7) == [0, 1, 1, 2, 3, 5, 8] assert FibonacciGenerator.is_fibonacci_number(8) == True assert FibonacciGenerator.is_fibonacci_number(10) == False ``` Implement the class `FibonacciGenerator` with the specified methods using efficient algorithms for Fibonacci sequence generation and identification.","solution":"from math import isqrt class FibonacciGenerator: @staticmethod def get_nth_fibonacci(n: int) -> int: if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b @staticmethod def generate_fibonacci_sequence(n: int) -> list: if n == 0: return [] elif n == 1: return [0] sequence = [0, 1] for _ in range(2, n): sequence.append(sequence[-1] + sequence[-2]) return sequence @staticmethod def is_fibonacci_number(num: int) -> bool: def is_perfect_square(x): s = isqrt(x) return s * s == x # A number is a Fibonacci number if and only if one or both of (5*num^2 + 4) or (5*num^2 - 4) is a perfect square return is_perfect_square(5 * num * num + 4) or is_perfect_square(5 * num * num - 4)"},{"question":"# Problem Statement You are required to implement a function that determines if two given strings are anagrams while ignoring spaces and capital letters. Additionally, you should implement another function that checks if one string is a scrambled version of another. A scrambled string uses the same exact characters and appears as a permutation but may have been rotated. # Function 1: `is_anagram(str1: str, str2: str) -> bool` * **Input Parameters**: - `str1` (str): A string containing uppercase/lowercase letters and spaces. - `str2` (str): A string containing uppercase/lowercase letters and spaces. * **Output**: - Returns a boolean indicating whether the two strings are anagrams. * **Constraints**: - 0 <= `len(str1)`, `len(str2)` <= 10^4. # Function 2: `is_scramble(str1: str, str2: str) -> bool` * **Input Parameters**: - `str1` (str): A string containing uppercase/lowercase letters and spaces. - `str2` (str): A string containing uppercase/lowercase letters and spaces. * **Output**: - Returns a boolean indicating whether the second string is a scrambled version of the first string. * **Constraints**: - 0 <= `len(str1)`, `len(str2)` <= 10^4. # Requirements: 1. Implement `is_anagram(str1: str, str2: str) -> bool`. 2. Implement `is_scramble(str1: str, str2: str) -> bool`. # Examples: Example 1 ```python >>> is_anagram(\\"Listen\\", \\"Silent\\") True ``` Example 2 ```python >>> is_anagram(\\"Hello World\\", \\"hello dlrow\\") True ``` Example 3 ```python >>> is_anagram(\\"apple\\", \\"pale\\") False ``` Example 4 ```python >>> is_scramble(\\"abcde\\", \\"deabc\\") True ``` Example 5 ```python >>> is_scramble(\\"abc\\", \\"bca\\") True ``` Example 6 ```python >>> is_scramble(\\"apple\\", \\"pplea\\") True ``` Example 7 ```python >>> is_scramble(\\"apple\\", \\"ppleaa\\") False ``` # Explanation: 1. `is_anagram(\\"Listen\\", \\"Silent\\")` returns True because \\"Listen\\" and \\"Silent\\" both contain the same letters ignoring case and spaces. 2. `is_anagram(\\"Hello World\\", \\"hello dlrow\\")` returns True because both strings contain the same letters ignoring case and spaces. 3. `is_anagram(\\"apple\\", \\"pale\\")` returns False because they do not contain the same characters. 4. `is_scramble(\\"abcde\\", \\"deabc\\")` returns True because \\"deabc\\" is a scrambled version of \\"abcde\\". 5. `is_scramble(\\"abc\\", \\"bca\\")` returns True because \\"bca\\" is a scrambled version of \\"abc\\". 6. `is_scramble(\\"apple\\", \\"pplea\\")` returns True because \\"pplea\\" is a scrambled version of \\"apple\\". 7. `is_scramble(\\"apple\\", \\"ppleaa\\")` returns False because they do not contain the same characters.","solution":"def is_anagram(str1, str2): Determines if two strings are anagrams, ignoring spaces and capitalization. # Remove spaces and convert to lower case cleaned_str1 = str1.replace(\\" \\", \\"\\").lower() cleaned_str2 = str2.replace(\\" \\", \\"\\").lower() # Sort and compare return sorted(cleaned_str1) == sorted(cleaned_str2) def is_scramble(str1, str2): Determines if the second string is a scrambled version of the first string, meaning it is a permutation of the first string that could be rotated. # Edge case: if lengths differ, they can\'t possibly be scrambles if len(str1) != len(str2): return False # Concatenate str1 with itself and check if str2 is a substring doubled_str1 = str1 + str1 return str2 in doubled_str1"},{"question":"# Scenario You are working on a software project that involves analyzing large collections of text documents. A frequent task you need to perform is determining the frequency of individual words across a collection of documents. To efficiently tackle this problem, you decide to implement a specialized data structure known as a Trie, which allows for fast insertion and retrieval of words and their frequencies. # Task Implement a Trie data structure to store and query word frequencies for a given list of documents. # Detailed Requirements 1. **Class**: `Trie` 2. **Constructor**: `__init__(self)` - Initializes an empty Trie. 3. **Method**: `insert(self, word: str, count: int) -> None` - Input: A string `word` representing a word, and an integer `count` representing its frequency. - Inserts the word into the Trie and updates its frequency. 4. **Method**: `search(self, word: str) -> int` - Input: A string `word` to search. - Output: Returns the frequency of the word if it exists in the Trie, `0` otherwise. 5. **Method**: `delete(self, word: str) -> bool` - Input: A string `word` to delete. - Output: Returns `True` if the word was successfully deleted from the Trie, `False` otherwise. # Constraints 1. Words will consist of lowercase English alphabet characters only. 2. The length of a word will be between 1 and 100. 3. Document collections will contain up to 10^5 words in total. 4. Assume Trie operations (insertion, search, deletion) are case-sensitive. # Example Usage ```python trie = Trie() # Insert the word \\"apple\\" with frequency 3 trie.insert(\\"apple\\", 3) # Insert the word \\"app\\" with frequency 5 trie.insert(\\"app\\", 5) # Should return the frequency of \\"apple\\", which is 3 assert trie.search(\\"apple\\") == 3 # Should return the frequency of \\"app\\", which is 5 assert trie.search(\\"app\\") == 5 # Should return 0 because \\"banana\\" was not inserted assert trie.search(\\"banana\\") == 0 # Should delete the word \\"apple\\" successfully assert trie.delete(\\"apple\\") == True # Search for \\"apple\\" should now return 0 after deletion assert trie.search(\\"apple\\") == 0 # Search for \\"app\\" should still return 5 assert trie.search(\\"app\\") == 5 ``` Provide an implementation for the Trie class adhering to the above requirements. Ensure your solution includes sufficient unittests to validate its correctness.","solution":"class TrieNode: def __init__(self): self.children = {} self.frequency = 0 class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str, count: int) -> None: current = self.root for char in word: if char not in current.children: current.children[char] = TrieNode() current = current.children[char] current.frequency = count def search(self, word: str) -> int: current = self.root for char in word: if char not in current.children: return 0 current = current.children[char] return current.frequency def delete(self, word: str) -> bool: stack = [] current = self.root for char in word: if char not in current.children: return False stack.append((current, char)) current = current.children[char] current.frequency = 0 while stack: parent, char = stack.pop() if not current.children and current.frequency == 0: del parent.children[char] current = parent return True"},{"question":"# Scenario You are tasked with improving the delivery system for a courier service. Specifically, you need to optimize the delivery routes to minimize the total distance traveled while ensuring all deliveries are completed. This is a variant of the well-known Traveling Salesman Problem (TSP). # Task Implement a function `optimize_routes(locations: List[Tuple[int, int]]) -> List[int]` that finds an efficient route starting from the first location in the list, visiting each subsequent location exactly once, and returning to the starting point. # Input * `locations` (List[Tuple[int, int]]): A list of tuples representing the (x, y) coordinates of delivery locations. The first location is the starting point. # Output * (List[int]): A list of indices representing the order of locations to visit, starting and ending at the first location in the input list. # Examples ```python optimize_routes([(0, 0), (2, 2), (1, 1), (6, 6)]) # Expected Output: [0, 2, 1, 3, 0] optimize_routes([(1, 1), (4, 0), (0, 3), (4, 4)]) # Expected Output: [0, 2, 1, 3, 0] optimize_routes([(0, 0), (0, 1), (1, 1), (1, 0)]) # Expected Output: [0, 1, 2, 3, 0] ``` # Constraints * The number of locations will not exceed 10. * Coordinates are non-negative integers. * Ensure all intermediate solutions are general enough for varying distances and starting points. # Performance Requirements As the input size is limited, focus more on the accuracy and correctness of the solution rather than optimization. # Additional Notes Feel free to use any standard library functions necessary but ensure your solution correctly finds an efficient route for the given locations.","solution":"from typing import List, Tuple from itertools import permutations import math def calculate_distance(p1: Tuple[int, int], p2: Tuple[int, int]) -> float: return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2) def total_route_distance(route: List[int], locations: List[Tuple[int, int]]) -> float: total_distance = 0 for i in range(len(route) - 1): total_distance += calculate_distance(locations[route[i]], locations[route[i + 1]]) return total_distance def optimize_routes(locations: List[Tuple[int, int]]) -> List[int]: n = len(locations) best_route = None best_distance = float(\'inf\') # Generate all possible permutations of indices (excluding the starting point) for perm in permutations(range(1, n)): current_route = [0] + list(perm) + [0] current_distance = total_route_distance(current_route, locations) if current_distance < best_distance: best_distance = current_distance best_route = current_route return best_route"},{"question":"# Longest Consecutive Subsequence # Objective Your task is to implement a function that finds the length of the longest consecutive subsequence of integers in a given list. Additionally, you will adapt the algorithm to find the longest consecutive substring of characters in a given string. # Problem Description Part 1: Longest Consecutive Subsequence of Integers Implement the `longest_consecutive_subsequence` function that takes a list of integers and returns the length of the longest subsequence where elements are consecutive integers. Part 2: Longest Consecutive Substring of Characters Using your `longest_consecutive_subsequence` implementation, create a function `longest_consecutive_substring` that finds the longest substring of consecutive characters (in terms of ASCII values) in a given string and returns the length of that substring. # Function Signatures ```python def longest_consecutive_subsequence(collection: List[int]) -> int: pass def longest_consecutive_substring(string: str) -> int: pass ``` # Input/Output Specifications Part 1: Longest Consecutive Subsequence of Integers * **Input**: A list of integers. * Example: `[100, 4, 200, 1, 3, 2]` * **Output**: An integer representing the length of the longest consecutive elements sequence. * Example: `4` (for sequence `[1, 2, 3, 4]`) Part 2: Longest Consecutive Substring of Characters * **Input**: A string consisting of lowercase English letters. * Example: `\\"abcabd\\"` * **Output**: An integer representing the length of the longest substring where characters are consecutive in ASCII values. * Example: `3` (for substrings `\\"abc\\"`) # Constraints * For Part 1, the list can have up to 10^6 elements, and the integers range from -10^6 to 10^6. * For Part 2, the input string length will not exceed 10^6 characters. # Examples Part 1: Longest Consecutive Subsequence of Integers ```python >>> longest_consecutive_subsequence([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive_subsequence([0, 0, 1, 5, 6, 5, 2]) 3 >>> longest_consecutive_subsequence([10, 9, 8, 7, 6, 5]) 6 ``` Part 2: Longest Consecutive Substring of Characters ```python >>> longest_consecutive_substring(\\"abcabd\\") 3 >>> longest_consecutive_substring(\\"efghi\\") 5 >>> longest_consecutive_substring(\\"\\") 0 ``` # Implementation Details * Ensure that your solutions handle empty inputs gracefully. * For the longest consecutive substring, use ASCII values to determine consecutive characters.","solution":"from typing import List def longest_consecutive_subsequence(collection: List[int]) -> int: if not collection: return 0 num_set = set(collection) longest_streak = 0 for num in num_set: if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak def longest_consecutive_substring(string: str) -> int: if not string: return 0 longest_streak = 0 current_streak = 1 for i in range(1, len(string)): if ord(string[i]) - ord(string[i - 1]) == 1: current_streak += 1 else: longest_streak = max(longest_streak, current_streak) current_streak = 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"# Task-Based Queue Management System **Objective**: Develop a Task Management System using a queue to handle and prioritize tasks efficiently. **Requirements**: 1. Implement the `TaskQueue` class ensuring it supports the following operations: - **Initialization (`__init__(self)`)**: Construct an empty task queue. - **`add_task(self, task_id: Any, priority: int)`**: Add a task with a unique identifier and a priority to the queue. Higher integer values represent higher priority. - **`remove_task(self)`**: Remove and return the task with the highest priority. If two tasks have the same priority, remove and return the one that was added first. - **`peek_highest_priority_task(self)`**: Return the task with the highest priority without removing it. - **`__len__(self)`**: Return the current number of tasks in the queue. - **`is_empty(self)`**: Return `True` if the queue is empty, `False` otherwise. **Inputs**: - `task_id`: Any type of unique identifier for a task. - `priority`: An integer representing the task\'s priority value. **Outputs**: - Various methods will have particular return types (e.g., `remove_task()` returning the highest priority task). **Constraints**: - Tasks should be managed efficiently to ensure quick access to the highest priority task. - Assume the queue will not hold more than 10,000 tasks at any given time. - Ensure that `task_id` is unique when adding a task. - Handle errors gracefully, such as trying to remove or peek a task from an empty queue. **Testing**: Write test cases to confirm the correctness of your task management system, especially focusing on edge cases and varying scenarios of task additions and removals. **Example Usage**: ```python # Initializing an empty task queue task_queue = TaskQueue() # Adding tasks task_queue.add_task(\'task1\', 2) task_queue.add_task(\'task2\', 5) task_queue.add_task(\'task3\', 1) # Check the highest priority task print(task_queue.peek_highest_priority_task()) # Output: \'task2\' # Remove the highest priority task print(task_queue.remove_task()) # Output: \'task2\' # Check the length of the queue print(len(task_queue)) # Output: 2 # Remove another task and check the highest priority task task_queue.remove_task() print(task_queue.peek_highest_priority_task()) # Output: \'task3\' (remaining tasks are \'task3\' with priority 1) # Continue testing as required ```","solution":"import heapq class TaskQueue: def __init__(self): self.queue = [] self.counter = 0 def add_task(self, task_id, priority): heapq.heappush(self.queue, (-priority, self.counter, task_id)) self.counter += 1 def remove_task(self): if self.is_empty(): raise IndexError(\\"remove_task from empty queue\\") return heapq.heappop(self.queue)[2] def peek_highest_priority_task(self): if self.is_empty(): raise IndexError(\\"peek_highest_priority_task from empty queue\\") return self.queue[0][2] def __len__(self): return len(self.queue) def is_empty(self): return len(self.queue) == 0"},{"question":"# Task: Employee Attendance Tracker Scenario You have been tasked with developing an attendance tracking system for a small company. The system needs to maintain a list of employees and track their daily attendance. Construct a class `AttendanceTracker` with the following methods: - `add_employee(name: str) -> str`: This method accepts an employee\'s name and adds them to the system. It returns a success message if the employee is added successfully and an error message if the employee is already in the system. - `mark_attendance(name: str) -> str`: This method accepts an employee\'s name and marks their attendance for the current day. It returns a success message if the attendance is marked successfully and an error message if the employee is not found or has already been marked for the day. - `attendance_report() -> List[str]`: This method returns a list of strings with each employee\'s name followed by \\"Present\\" or \\"Absent\\" based on whether their attendance was marked for the day. Assume the system starts fresh each day, and the attendance list is reset every day at midnight. Input - `name` (str): A valid employee name (e.g. \\"John Doe\\"). Output - `add_employee` returns a success message (e.g., \\"Employee added successfully\\") or an error message (e.g., \\"Employee already exists\\"). - `mark_attendance` returns a success message (e.g., \\"Attendance marked successfully\\") or an error message (e.g., \\"Employee not found\\" or \\"Attendance already marked\\"). - `attendance_report` returns a list of strings with each employee\'s name followed by their attendance status for the day. Constraints - Each employee\'s name will be unique. - The `attendance_report` method should complete within a reasonable time even with up to 100 employees in the system. # Implementation Implement this class following the requirements and consider the described edge cases, performance bottlenecks, and potential error scenarios. Example ```python tracker = AttendanceTracker() print(tracker.add_employee(\\"John Doe\\")) # Returns: \\"Employee added successfully\\" print(tracker.add_employee(\\"Jane Smith\\")) # Returns: \\"Employee added successfully\\" print(tracker.add_employee(\\"John Doe\\")) # Returns: \\"Employee already exists\\" print(tracker.mark_attendance(\\"John Doe\\")) # Returns: \\"Attendance marked successfully\\" print(tracker.mark_attendance(\\"John Doe\\")) # Returns: \\"Attendance already marked\\" print(tracker.mark_attendance(\\"Jane Doe\\")) # Returns: \\"Employee not found\\" print(tracker.attendance_report()) # Returns: [\\"John Doe Present\\", \\"Jane Smith Absent\\"] ```","solution":"class AttendanceTracker: def __init__(self): self.employees = {} def add_employee(self, name: str) -> str: if name in self.employees: return \\"Employee already exists\\" else: self.employees[name] = False return \\"Employee added successfully\\" def mark_attendance(self, name: str) -> str: if name not in self.employees: return \\"Employee not found\\" elif self.employees[name]: return \\"Attendance already marked\\" else: self.employees[name] = True return \\"Attendance marked successfully\\" def attendance_report(self) -> list: report = [] for name, attended in self.employees.items(): status = \\"Present\\" if attended else \\"Absent\\" report.append(f\\"{name} {status}\\") return report"},{"question":"You are given the task of implementing a function that determines whether a string has all unique characters. Specifically, you need to create a function to check if any character repeats within the given string. # Function Signature ```python def has_unique_chars(s: str) -> bool: ``` # Input * `s`: A string of characters. # Output * Returns `True` if the string contains all unique characters, otherwise `False`. # Constraints * The input string may contain zero or more characters. * Empty strings should be considered as having all unique characters. # Examples ```python print(has_unique_chars(\\"abcdef\\")) # True print(has_unique_chars(\\"hello\\")) # False print(has_unique_chars(\\"\\")) # True print(has_unique_chars(\\"Python\\")) # True print(has_unique_chars(\\"Programming\\")) # False ``` # Additional Requirements 1. Ensure the implementation adheres to proper type checking. 2. Provide thorough validation and error handling as part of your code. # Notes * Consider case sensitivity; for example, \'A\' and \'a\' should be treated as distinct characters. * Focus on clarity and robustness of your implementation.","solution":"def has_unique_chars(s: str) -> bool: Determines if a string contains all unique characters. :param s: Input string to check :type s: str :return: True if all characters in the string are unique, False otherwise :rtype: bool # Using a set to keep track of characters seen so far seen_chars = set() for char in s: if char in seen_chars: return False seen_chars.add(char) return True"},{"question":"# Coding Assessment Question: Matrix Rotation in Image Processing **Problem Statement**: You are tasked with writing a function that performs a 90-degree clockwise rotation on a given `n x n` 2D matrix, which represents a grayscale image. This operation is common in image processing, where images need to be rotated for various transformations and alignments. Given the following constraints: - The input matrix is always square (`n x n`), where (1 leq n leq 1000). - Every value in the matrix is an integer, representing the grayscale intensity from 0 to 255. Implement a function `rotate_matrix` that, given a 2D matrix `image`, rotates the matrix by 90 degrees clockwise. Here\'s what you should focus on: 1. **Matrix Input**: Handle a square 2D matrix of integers. 2. **In-place Transformation**: Perform the rotation in place without using extra space for another matrix if possible. 3. **Edge Cases**: Ensure the function handles edge cases gracefully, such as an `n x n` matrix where (n = 1). **Function Signature**: ```python def rotate_matrix(image: list) -> None: pass ``` **Expected Inputs**: - `image` (`list[list[int]]`): A square 2D list of integers representing the grayscale image, where each value is between 0 and 255. **Expected Outputs**: - The function should modify the input matrix in place to represent the rotated image. It does not need to return any value. **Constraints**: - Ensure the input matrix is square (`n x n`). - Handle matrices of large sizes (up to `1000 x 1000` elements) efficiently. **Examples**: 1. ```python image = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(image) print(image) # Output should be: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] ``` 2. ```python image = [[1]] rotate_matrix(image) print(image) # Output should be: [[1]] ``` **Requirements**: - Ensure the function operates efficiently for large `n x n` matrices. - Modify the input matrix in place.","solution":"def rotate_matrix(image: list) -> None: Rotates the given n x n matrix by 90 degrees clockwise in place. Args: image (list[list[int]]): The n x n 2D list of integers representing the grayscale image. if not image or not image[0]: return n = len(image) # Step 1: Transpose the matrix for i in range(n): for j in range(i, n): image[i][j], image[j][i] = image[j][i], image[i][j] # Step 2: Reverse each row for i in range(n): image[i].reverse()"},{"question":"# Subject: String Manipulation and Pattern Matching You are assigned the task of identifying the overlapping repetitions of substrings within a given string and determining the maximum length of such repeating patterns. # Description Write a function that finds the longest repeating non-overlapping substring within a given string. A non-overlapping substring is one that does not reuse characters from an already found repeating substring. For example, in the string \\"banana\\", the longest repeating non-overlapping substring is \\"ana\\". # Implementation Function 1. **`find_longest_repeating_substring(s: str) -> str`**: - **Input**: A string `s` (where (1 leq text{len}(s) leq 1000)) - **Output**: Returns the longest repeating non-overlapping substring within `s`. If multiple substrings have the same maximum length, return the one which appears first. # Function Definition ```python def find_longest_repeating_substring(s: str) -> str: Find the longest repeating non-overlapping substring in the string s. Args: s (str): The string to search within. Returns: str: The longest repeating non-overlapping substring, or an empty string if none exist. pass ``` # Requirements - Do not use any external libraries except for `math`. - Ensure your solution is efficient and handles edge cases, such as strings with no repeating substrings. # Examples ```python # Example 1 print(find_longest_repeating_substring(\\"banana\\")) # Should return \\"ana\\" # Example 2 print(find_longest_repeating_substring(\\"abcdef\\")) # Should return \\"\\", as there are no repeating substrings # Example 3 print(find_longest_repeating_substring(\\"aabaaab\\")) # Should return \\"aab\\" ``` # Constraints - Your solution should aim for clarity and efficiency, making sure it runs within a reasonable time for input sizes up to 1000 characters.","solution":"def find_longest_repeating_substring(s: str) -> str: Find the longest repeating non-overlapping substring in the string s. Args: s (str): The string to search within. Returns: str: The longest repeating non-overlapping substring, or an empty string if none exist. n = len(s) if n <= 1: return \\"\\" # Helper function to find common prefix length between s[i:] and s[j:] def common_prefix_length(i, j): length = 0 while i < n and j < n and s[i] == s[j]: length += 1 i += 1 j += 1 return length # Initialize variables to track the longest repeating substring max_length = 0 start_index = 0 # Use a suffix array approach to identify longest repeating substrings suffixes = sorted(range(n), key=lambda i: s[i:]) for i in range(1, n): length = common_prefix_length(suffixes[i - 1], suffixes[i]) if length > max_length: max_length = length start_index = suffixes[i] return s[start_index:start_index + max_length] if max_length > 0 else \\"\\" # Example usage print(find_longest_repeating_substring(\\"banana\\")) # Should return \\"ana\\" print(find_longest_repeating_substring(\\"abcdef\\")) # Should return \\"\\" print(find_longest_repeating_substring(\\"aabaaab\\")) # Should return \\"aab\\""},{"question":"# Coding Assessment Question Question: You are given the task of creating an itinerary for a traveler based on their flight schedule. Each flight is represented by a tuple `(origin, destination)`. Your objective is to find the itinerary that allows the traveler to visit each location exactly once, starting from a specified origin and following lexicographical order in case of multiple choices. 1. **Input**: - A list of tuples `flights` where each tuple `(origin, destination)` represents a direct flight from `origin` to `destination`. - A string `start` representing the starting point of the itinerary. 2. **Output**: - A list of strings representing the traveler\'s itinerary, starting from the given `start` location. 3. **Constraints**: - `1 <= len(flights) <= 1000` - Each location is represented by a string with length between `1` and `3`. - The given flights list will form a valid itinerary such that a solution will always exist. 4. **Performance Requirements**: - Optimize the algorithm to handle the given constraints efficiently. - Ensure the solution finds the lexicographically smallest valid itinerary. Implementation: Write a function `find_itinerary` in Python that takes the above inputs and outputs the itinerary. Function signature: ```python def find_itinerary(flights: List[Tuple[str, str]], start: str) -> List[str]: ``` Example: ```python # Input flights = [(\\"JFK\\", \\"SFO\\"), (\\"JFK\\", \\"ATL\\"), (\\"SFO\\", \\"ATL\\"), (\\"ATL\\", \\"JFK\\"), (\\"ATL\\", \\"SFO\\")] start = \\"JFK\\" # Output [\\"JFK\\", \\"ATL\\", \\"JFK\\", \\"SFO\\", \\"ATL\\", \\"SFO\\"] ``` Description: Implement an itinerary finding algorithm to plan the travel following the described rules: - Start from the given starting location. - Choose the next flight based on lexicographical order if multiple destinations are available. - Visit each location exactly once and return to the starting location if possible. - Return the optimal itinerary as a list of strings.","solution":"from typing import List, Tuple import collections def find_itinerary(flights: List[Tuple[str, str]], start: str) -> List[str]: # Create a graph from the flights list and maintain the order of destinations lexicographically graph = collections.defaultdict(list) for origin, destination in sorted(flights): graph[origin].append(destination) itinerary = [] def visit(airport): while graph[airport]: next_airport = graph[airport].pop(0) visit(next_airport) itinerary.append(airport) visit(start) return itinerary[::-1]"},{"question":"**Problem Statement:** You are tasked with implementing and testing a Stack that supports tracking the maximum value in the stack. The stack should have the following functionalities: 1. `__init__(self)`: Initializes an empty stack. 2. `is_empty(self) -> bool`: Returns `True` if the stack is empty, `False` otherwise. 3. `push(self, data: Any) -> None`: Adds an element to the top of the stack. 4. `pop(self) -> Any`: Removes and returns the top element of the stack. Raises an `Exception` with the message `\\"Empty Stack\\"` if the stack is empty. 5. `top(self) -> Any`: Returns the top element of the stack without removing it. Raises an `Exception` with the message `\\"Empty Stack\\"` if the stack is empty. 6. `get_max(self) -> Any`: Returns the maximum value in the stack. Raises an `Exception` with the message `\\"Empty Stack\\"` if the stack is empty. # Input and Output Format: * **Input**: * The `push` method takes one argument which is the item to be added to the stack. * The `pop`, `top`, and `get_max` methods do not take any arguments. * **Output**: * The `push` method does not return any value. * The `pop` method returns the element being removed from the stack. * The `top` method returns the element at the top of the stack. * The `get_max` method returns the maximum value in the stack. * If the stack is empty, the `pop`, `top`, and `get_max` methods should raise an `Exception` with the message `\\"Empty Stack\\"`. # Constraints: * Do not use any built-in data structures that directly support max-tracking. * Ensure that the `get_max` operation runs in O(1) time complexity. # Example: ```python stack = MaxTrackingStack() stack.push(5) stack.push(1) stack.push(7) assert stack.get_max() == 7 stack.push(3) assert stack.top() == 3 assert stack.pop() == 3 assert stack.get_max() == 7 assert stack.pop() == 7 assert stack.get_max() == 5 assert stack.pop() == 1 assert stack.pop() == 5 try: stack.pop() except Exception as e: assert str(e) == \\"Empty Stack\\" ``` Implement the `MaxTrackingStack` class in Python with the methods specified above.","solution":"class MaxTrackingStack: def __init__(self): self.stack = [] self.max_stack = [] def is_empty(self) -> bool: return len(self.stack) == 0 def push(self, data: int) -> None: self.stack.append(data) if self.max_stack: self.max_stack.append(max(data, self.max_stack[-1])) else: self.max_stack.append(data) def pop(self) -> int: if self.is_empty(): raise Exception(\\"Empty Stack\\") self.max_stack.pop() return self.stack.pop() def top(self) -> int: if self.is_empty(): raise Exception(\\"Empty Stack\\") return self.stack[-1] def get_max(self) -> int: if self.is_empty(): raise Exception(\\"Empty Stack\\") return self.max_stack[-1]"},{"question":"# Greatest Common Divisor (GCD) of an Array Background: The Greatest Common Divisor (GCD) of two integers is the largest positive integer that divides both numbers without leaving a remainder. For multiple numbers, the GCD is the largest positive integer that divides all of them. Calculating the GCD of an array of integers is a fundamental task in number theory. Task: You are required to implement the function `array_gcd` as described in the code snippet provided to calculate the greatest common divisor of a list of integers. Your function should correctly handle edge cases and raise appropriate errors for invalid inputs. Function Signature: ```python def array_gcd(numbers: List[int]) -> int: Calculate the greatest common divisor of an array of integers. Input Parameters: numbers (List[int]): A list of integers for which to find the GCD. Returns: int: The greatest common divisor of the array of integers. Raises: ValueError: If the list is empty or contains non-positive integers. ``` Example Tests: ```python >>> array_gcd([12, 15, 21]) # common divisor is 3 3 >>> array_gcd([24, 36, 48]) # common divisor is 12 12 >>> array_gcd([7, 11, 13]) # common divisor is 1 (all are prime) 1 >>> array_gcd([1024, 2048, 3072]) # common divisor is 1024 1024 >>> array_gcd([12, 15, 0]) # list contains zero, which is invalid Traceback (most recent call last): ... ValueError: List must contain positive integers only >>> array_gcd([]) # list is empty Traceback (most recent call last): ... ValueError: List must not be empty ``` Constraints: * The function should handle a list size of at least 1 and up to (10^4) elements. * Each integer in the list should be positive and within the range [1, (10^6)]. * Utilize Euclidean Algorithm for efficient computation of GCD.","solution":"from typing import List from math import gcd from functools import reduce def array_gcd(numbers: List[int]) -> int: Calculate the greatest common divisor of an array of integers. Input Parameters: numbers (List[int]): A list of integers for which to find the GCD. Returns: int: The greatest common divisor of the array of integers. Raises: ValueError: If the list is empty or contains non-positive integers. if not numbers: raise ValueError(\\"List must not be empty\\") if any(num <= 0 for num in numbers): raise ValueError(\\"List must contain positive integers only\\") return reduce(gcd, numbers)"},{"question":"# Linked List Cycle Detection and Removal In this task, you are required to enhance a class `LinkedList` that implements a singly linked list. The goal is to add functionality to detect and remove a cycle (loop) if it exists within the linked list. A cycle in a linked list occurs when a node\'s `next` pointer points to a previous node, creating a loop. Your task involves two main functions: 1. `detect_cycle`: This method should return a boolean indicating whether a cycle is present in the linked list. 2. `remove_cycle`: This method should modify the linked list to remove the cycle, if detected. **Input**: - A singly linked list where each node has an integer value and a `next` pointer. - The linked list can be empty or have one or more elements. **Output**: - For `detect_cycle`: A boolean value indicating if the cycle is present. - For `remove_cycle`: The linked list should be modified in-place to remove any cycle. **Performance Requirements**: - The `detect_cycle` method should have a time complexity of O(n) and use O(1) additional space, where n is the number of nodes. - The `remove_cycle` method should also have time complexity of O(n) and use O(1) additional space. **Constraints**: - The linked list node values are integers. - The linked list may include any number of nodes, including zero. - You must not alter the node values during the cycle removal process; only the `next` pointers can be changed. **Example Usage**: ```python class Node: def __init__(self, data): self.data = data self.next = None class LinkedList: def __init__(self): self.head = None # Function to detect if there is a cycle in the linked list def detect_cycle(self): # Implement this method # Function to remove the cycle if it is detected def remove_cycle(self): # Implement this method # Example linked list with cycle ll = LinkedList() ll.head = Node(1) ll.head.next = Node(2) ll.head.next.next = Node(3) ll.head.next.next.next = Node(4) ll.head.next.next.next.next = Node(2) # Creates a cycle print(ll.detect_cycle()) # Should return True ll.remove_cycle() print(ll.detect_cycle()) # Should return False # Example linked list without cycle ll2 = LinkedList() ll2.head = Node(10) ll2.head.next = Node(20) ll2.head.next.next = Node(30) print(ll2.detect_cycle()) # Should return False ll2.remove_cycle() # Should not modify the list print(ll2.detect_cycle()) # Should return False ``` Write the `LinkedList` class with the `detect_cycle` and `remove_cycle` methods, ensuring it adheres to the specified functionality and performance requirements.","solution":"class Node: def __init__(self, data): self.data = data self.next = None class LinkedList: def __init__(self): self.head = None def detect_cycle(self): Detects cycle in the linked list using Floyd\'s Cycle-Finding Algorithm. Returns True if a cycle is detected, otherwise returns False. slow = fast = self.head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False def remove_cycle(self): Removes a detected cycle from the linked list. This method modifies the list in-place. slow = fast = self.head # First detect if there is a cycle has_cycle = False while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: has_cycle = True break if not has_cycle: return # Determine the starting point of the cycle slow = self.head while slow != fast: slow = slow.next fast = fast.next # Find the previous node of the starting point of the cycle prev = None while fast.next != slow: fast = fast.next # Remove the cycle fast.next = None"},{"question":"**Problem Statement**: You are required to implement a class that simulates a simple stock portfolio. The class should allow adding new stocks, removing stocks, recording daily price changes, and calculating the total value of the portfolio. **Class Specifications**: 1. **StockPortfolio**: - **Methods**: - `add_stock`: Adds a new stock with a given name and initial price. - **Input**: `name: str`, `price: float` - `remove_stock`: Removes a stock by its name. - **Input**: `name: str` - `record_price_change`: Records a new price for an existing stock. - **Input**: `name: str`, `new_price: float` - `calculate_total_value`: Calculates and returns the total value of the portfolio. - **Output**: `float` - **Attributes** (to be managed internally): - `_stocks`: A dictionary to store stock names as keys and their corresponding prices as values. **Details**: - The `add_stock` method should add a new stock with the provided name and price. If the stock already exists, it should update the price. - The `remove_stock` method should remove a stock from the portfolio by its name. If the stock does not exist, it should do nothing. - The `record_price_change` method should update the price of an existing stock. If the stock does not exist, it should raise a `ValueError` with the message \\"Stock not found\\". - The `calculate_total_value` method should return the sum of the prices of all the stocks currently in the portfolio. - You can assume stock names are unique. # Implementation You need to implement the following class: ```python class StockPortfolio: def __init__(self): self._stocks = {} def add_stock(self, name: str, price: float): # Adds or updates a stock with the given name and price pass def remove_stock(self, name: str): # Removes a stock by its name if it exists pass def record_price_change(self, name: str, new_price: float): # Records a new price for an existing stock pass def calculate_total_value(self) -> float: # Calculates and returns the total value of the portfolio pass ``` # Example Usage: ```python portfolio = StockPortfolio() portfolio.add_stock(\\"AAPL\\", 150.00) portfolio.add_stock(\\"GOOGL\\", 2800.00) portfolio.add_stock(\\"AMZN\\", 3400.00) print(portfolio.calculate_total_value()) # Expected Output: 6350.0 portfolio.record_price_change(\\"AAPL\\", 155.00) portfolio.remove_stock(\\"GOOGL\\") print(portfolio.calculate_total_value()) # Expected Output: 3555.0 ```","solution":"class StockPortfolio: def __init__(self): self._stocks = {} def add_stock(self, name: str, price: float): Adds or updates a stock with the given name and price. self._stocks[name] = price def remove_stock(self, name: str): Removes a stock by its name if it exists. if name in self._stocks: del self._stocks[name] def record_price_change(self, name: str, new_price: float): Records a new price for an existing stock. Raises ValueError if the stock does not exist. if name in self._stocks: self._stocks[name] = new_price else: raise ValueError(\\"Stock not found\\") def calculate_total_value(self) -> float: Calculates and returns the total value of the portfolio. return sum(self._stocks.values())"},{"question":"# Question You are tasked with developing a text processing function for a data analytics framework. Implement a function that generates a summary of word frequencies from a given corpus of text. The function should output the top `k` most frequent words along with their respective frequencies. Function Signature ```python def top_k_frequent_words(text: str, k: int) -> List[Tuple[str, int]]: ... ``` Input - **text** (str): A string containing the text to be analyzed. - **k** (int): The number of top frequent words to return. Output - List[Tuple[str, int]]: A list of tuples, where each tuple contains a word (str) and its frequency (int). The list should be sorted by frequency in descending order. In case of a tie in frequencies, sort the words alphabetically. Constraints - The text will contain only alphanumeric characters and spaces. - Words will be case-insensitive (treat \\"Word\\" and \\"word\\" as the same). - The number of words in the text will not exceed 10^5. - The value of `k` will be between 1 and the number of unique words in the text. Performance Requirement - The function should be implemented in O(n log n) time complexity, where n is the number of words in the text. Examples ```python >>> top_k_frequent_words(\\"The quick brown fox jumps over the lazy dog\\", 3) [(\'the\', 2), (\'brown\', 1), (\'dog\', 1)] >>> top_k_frequent_words(\\"a A a b B b c C c c\\", 2) [(\'c\', 4), (\'a\', 3)] ```","solution":"from typing import List, Tuple from collections import Counter def top_k_frequent_words(text: str, k: int) -> List[Tuple[str, int]]: # Convert all words to lower case and split the text into words words = text.lower().split() # Use Counter to count the frequencies of each word frequency = Counter(words) # Get all items and sort by (-frequency, word) to handle tie cases frequent_words = sorted(frequency.items(), key=lambda x: (-x[1], x[0])) # Return the top k frequent words return frequent_words[:k]"},{"question":"# K-Means Clustering Implementation and Analysis As a data analyst, you are required to group data points into clusters using the K-Means clustering algorithm. Your goal is to implement a method that classifies input samples into clusters and provides cluster labels for new data points. Your task involves the following steps: 1. **Implement K-Means clustering**: Write a function `train_and_predict(X, n_clusters, test_data)` that: * Takes as input: * `X`, a list of input samples (each sample itself a list of feature values). * `n_clusters`, an integer representing the number of clusters to form. * `test_data`, a list of input samples for which cluster labels are to be predicted. * Returns: * A list of predicted cluster labels for the input `test_data`. 2. **Use appropriate K-Means settings**: The K-Means clustering should use the following settings: * n_clusters: the specified number of clusters * Random state: 42 (to ensure reproducibility) 3. **Performance Requirements**: Ensure that clustering and prediction are efficiently handled for small to medium datasets. The algorithm should be able to process data points and provide clusters optimally. **Input and Output Format:** Input: ```python X = [[1.0, 2.0], [1.5, 1.8], [5.0, 8.0], [8.0, 8.0], [1.0, 0.6], [9.0, 11.0]] n_clusters = 2 test_data = [[1.0, 1.0], [8.0, 9.0]] ``` Output: ```python [0, 1] ``` Your implementation must account for the following constraints and ensure it performs these operations correctly and efficiently. ```python from sklearn.cluster import KMeans def train_and_predict(X, n_clusters, test_data): Train a K-Means model with given data and return cluster predictions on test data. Args: X (list of list of float): Input samples. n_clusters (int): Number of clusters. test_data (list of list of float): Test input samples. Returns: list of int: Predicted cluster labels for the test data. # Your implementation here return predictions # Example usage (you can use this for testing your function): X = [[1.0, 2.0], [1.5, 1.8], [5.0, 8.0], [8.0, 8.0], [1.0, 0.6], [9.0, 11.0]] n_clusters = 2 test_data = [[1.0, 1.0], [8.0, 9.0]] predictions = train_and_predict(X, n_clusters, test_data) print(predictions) # Expected output: [0, 1] ``` This problem involves implementing and applying a K-Means clustering algorithm to group data points into clusters and predict the cluster for new data points. Ensure that the settings specified are used and that the implementation handles the required tasks efficiently.","solution":"from sklearn.cluster import KMeans def train_and_predict(X, n_clusters, test_data): Train a K-Means model with given data and return cluster predictions on test data. Args: X (list of list of float): Input samples. n_clusters (int): Number of clusters. test_data (list of list of float): Test input samples. Returns: list of int: Predicted cluster labels for the test data. kmeans = KMeans(n_clusters=n_clusters, random_state=42) kmeans.fit(X) predictions = kmeans.predict(test_data) return list(predictions)"},{"question":"# Problem Statement You are given two strings `s1` and `s2` and must determine if `s2` is a rotated version of `s1`. A string is considered a rotated version of another string if it can be obtained by rotating the other string any number of positions. # Function Signature ```python def is_rotated_version(s1: str, s2: str) -> bool: Determines if one string is a rotated version of another. :param s1: The original string. :param s2: The string to check as a rotated version. :return: True if s2 is a rotated version of s1, False otherwise. ``` # Input - Two strings `s1` and `s2`: - Constraint: 0 <= len(s1), len(s2) <= 10^3 - Constraint: Both strings consist of printable ASCII characters. # Output - A boolean value: - `True` if `s2` is a rotated version of `s1`. - `False` otherwise. # Example ```python assert is_rotated_version(\\"abcde\\", \\"cdeab\\") == True assert is_rotated_version(\\"abcde\\", \\"abced\\") == False assert is_rotated_version(\\"waterbottle\\", \\"erbottlewat\\") == True assert is_rotated_version(\\"\\", \\"\\") == True assert is_rotated_version(\\"a\\", \\"a\\") == True assert is_rotated_version(\\"a\\", \\"b\\") == False ``` # Additional Instructions - Ensure your implementation handles edge cases such as empty strings and single characters. - Aim to optimize for readability and correctness.","solution":"def is_rotated_version(s1: str, s2: str) -> bool: Determines if one string is a rotated version of another. if len(s1) != len(s2): return False combined = s1 + s1 return s2 in combined"},{"question":"# Coding Challenge: Implement Efficient Dijkstra Algorithm **Context**: You have been provided with a basic graph structure and your task is to implement an efficient version of Dijkstra\'s shortest path algorithm. This algorithm should be optimized to efficiently handle larger datasets, identifying the shortest path distances from a source node to all other nodes in the graph. **Your Task**: Write a Python function `efficient_dijkstra(graph, start_node)` that performs the Dijkstra algorithm and includes performance optimizations to manage large datasets effectively. **Input**: - `graph`: A dictionary where keys are node identifiers and values are lists of tuples. Each tuple consists of a neighboring node and the edge weight. - `start_node`: The identifier of the starting node. **Output**: - `distances`: A dictionary where keys are node identifiers and values are the shortest path distance from the `start_node` to the respective node. **Constraints**: - The graph can contain up to 100,000 nodes. - Edge weights are non-negative. - Assume all node identifiers are unique. **Optimizations to Implement**: 1. **Priority Queue**: Use a priority queue (min-heap) to efficiently get the next node with the smallest distance. 2. **Early Termination**: Implement early stopping if the shortest path to the target node is found (if a target node is provided). 3. **Sparse Graph Handling**: Design the algorithm to handle sparse graphs efficiently. ```python import heapq def efficient_dijkstra(graph, start_node): Implement Dijkstra\'s algorithm using a priority queue for performance optimization. Args: graph (dict): A dictionary of nodes and their neighbors with edge weights. start_node (any): The starting node identifier. Returns: dict: A dictionary of shortest path distances from start_node to all other nodes. # Initialize distances dictionary distances = {node: float(\'inf\') for node in graph} distances[start_node] = 0 # Priority queue to manage exploration of nodes priority_queue = [(0, start_node)] while priority_queue: # Get the node with the smallest distance current_distance, current_node = heapq.heappop(priority_queue) # Skip if the current distance is not up-to-date if current_distance > distances[current_node]: continue # Explore neighbors for neighbor, weight in graph[current_node]: distance = current_distance + weight # Update the distance if found a shorter path if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances # Example usage: graph = { \'A\': [(\'B\', 1), (\'C\', 4)], \'B\': [(\'A\', 1), (\'C\', 2), (\'D\', 5)], \'C\': [(\'A\', 4), (\'B\', 2), (\'D\', 1)], \'D\': [(\'B\', 5), (\'C\', 1)] } start_node = \'A\' distances = efficient_dijkstra(graph, start_node) print(\\"Shortest path distances from start node:\\", distances) ``` **Note**: You should not use the high-level graph algorithms from libraries like NetworkX for the core implementation but can use standard data structures and algorithms from Python standard libraries.","solution":"import heapq def efficient_dijkstra(graph, start_node): Implement Dijkstra\'s algorithm using a priority queue for performance optimization. Args: graph (dict): A dictionary of nodes and their neighbors with edge weights. start_node (any): The starting node identifier. Returns: dict: A dictionary of shortest path distances from start_node to all other nodes. # Initialize distances dictionary distances = {node: float(\'inf\') for node in graph} distances[start_node] = 0 # Priority queue to manage exploration of nodes priority_queue = [(0, start_node)] while priority_queue: # Get the node with the smallest distance current_distance, current_node = heapq.heappop(priority_queue) # Skip if the current distance is not up-to-date if current_distance > distances[current_node]: continue # Explore neighbors for neighbor, weight in graph[current_node]: distance = current_distance + weight # Update the distance if found a shorter path if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances # Example usage: graph = { \'A\': [(\'B\', 1), (\'C\', 4)], \'B\': [(\'A\', 1), (\'C\', 2), (\'D\', 5)], \'C\': [(\'A\', 4), (\'B\', 2), (\'D\', 1)], \'D\': [(\'B\', 5), (\'C\', 1)] } start_node = \'A\' distances = efficient_dijkstra(graph, start_node) print(\\"Shortest path distances from start node:\\", distances)"},{"question":"**Prime Sum Pairs** Given a positive integer `n`, write a function to find all unique pairs of prime numbers `(p1, p2)` such that `p1 + p2 = n`. Each pair in the output should be sorted in ascending order. Implement the function `prime_sum_pairs(n: int) -> List[Tuple[int, int]]` that returns a list of tuples where each tuple contains two prime numbers. The pairs should be sorted in ascending order. # Constraints: - 1 ≤ n ≤ 1000 - The input `n` will always be a positive integer. # Input: An integer `n` representing the target sum of pairs of prime numbers. # Output: A list of tuples, where each tuple contains two prime numbers whose sum is `n`. # Example: ```python def prime_sum_pairs(n: int) -> List[Tuple[int, int]]: Find all unique pairs of prime numbers whose sum equals n. Args: n (int): The target sum. Returns: List[Tuple[int, int]]: A list of tuples with pairs of prime numbers. # Your code here ``` # Test Cases: ```python assert prime_sum_pairs(10) == [(3, 7), (5, 5)] assert prime_sum_pairs(26) == [(3, 23), (7, 19), (13, 13)] assert prime_sum_pairs(4) == [(2, 2)] assert prime_sum_pairs(1) == [] assert prime_sum_pairs(18) == [(5, 13), (7, 11)] ``` # Explanation: - For `n = 10`, the pairs are `(3, 7)` and `(5, 5)`. - For `n = 26`, the pairs are `(3, 23)`, `(7, 19)`, and `(13, 13)`. - For `n = 4`, the pair is `(2, 2)`. - For `n = 1`, there are no prime pairs. - For `n = 18`, the pairs are `(5, 13)` and `(7, 11)`. Your implementation should handle edge cases and ensure efficient computation of prime pairs.","solution":"from typing import List, Tuple def is_prime(num: int) -> bool: if num < 2: return False for i in range(2, int(num**0.5) + 1): if num % i == 0: return False return True def prime_sum_pairs(n: int) -> List[Tuple[int, int]]: primes = [i for i in range(2, n) if is_prime(i)] result = [] checked = set() for p1 in primes: p2 = n - p1 if p2 in primes and (p2, p1) not in checked: result.append((p1, p2)) checked.add((p1, p2)) checked.add((p2, p1)) return sorted(result)"},{"question":"# Problem Statement You are given a task to implement a simple file system simulation using a tree structure. This file system should support basic directory and file operations such as creation, deletion, and listing of contents. The goal is to practice implementing tree data structures and managing hierarchical relationships. # Goal Create a `SimpleFileSystem` class with the following capabilities: 1. **Directory and File Creation**: Support the creation of directories and files. 2. **Directory Deletion**: Allow deletion of directories, which should also remove all subdirectories and files under it. 3. **Listing Contents**: Listing the contents of a directory should display all files and subdirectories in an appropriate format. # Implementation SimpleFileSystem Class 1. **create_directory(path: str) -> None** * Creates a new directory at the specified path. * The path is a string that represents the hierarchies of directories. * Example: `create_directory(\\"/a/b/c\\")` should create directory `c` inside directory `b`, inside directory `a`. 2. **create_file(path: str) -> None** * Creates a new file at the specified path. * The path is a string that represents where the file should be created. * Example: `create_file(\\"/a/b/file.txt\\")` should create a file named `file.txt` inside directory `b`, inside directory `a`. 3. **delete_directory(path: str) -> None** * Deletes an entire directory, including all its subdirectories and files. * Example: `delete_directory(\\"/a/b\\")` should remove directory `b` and all contents within it. 4. **list_contents(path: str) -> List[str]** * Lists all files and directories within the specified directory path in an alphabetical order. * Example: `list_contents(\\"/a\\")` should return the list of names of files and subdirectories inside directory `a`. # Input and Output Format ```python class SimpleFileSystem: def __init__(self): # Initialize the root directory def create_directory(self, path: str) -> None: # Implementation for creating directories def create_file(self, path: str) -> None: # Implementation for creating files def delete_directory(self, path: str) -> None: # Implementation for deleting directories def list_contents(self, path: str) -> List[str]: # Implementation for listing contents of a directory # Expected Input fs = SimpleFileSystem() fs.create_directory(\\"/documents/reports\\") fs.create_file(\\"/documents/reports/january.pdf\\") fs.create_file(\\"/documents/reports/february.pdf\\") fs.create_directory(\\"/public/images\\") print(fs.list_contents(\\"/documents/reports\\")) # Expected Output: [\'february.pdf\', \'january.pdf\'] fs.delete_directory(\\"/documents\\") print(fs.list_contents(\\"/documents\\")) # Expected Output: [] # Constraints # Paths are always provided as absolute paths starting with \'/\'. ``` # Constraints and Performance Requirements 1. Assume the maximum depth of directories is constrained to 10 levels. 2. Your implementation should handle up to 1,000 directory paths efficiently. # Example Scenario ```python # Initialize the file system fs = SimpleFileSystem() # Create directories and files fs.create_directory(\\"/documents/reports/q1\\") fs.create_file(\\"/documents/reports/q1/january.pdf\\") fs.create_file(\\"/documents/reports/q1/february.pdf\\") fs.create_file(\\"/documents/reports/q1/march.pdf\\") # List contents print(fs.list_contents(\\"/documents/reports/q1\\")) # Expected Output: [\'february.pdf\', \'january.pdf\', \'march.pdf\'] # Delete directory fs.delete_directory(\\"/documents/reports\\") # List contents after deletion print(fs.list_contents(\\"/documents/reports\\")) # Expected Output: [] ``` # Write your SimpleFileSystem class below:","solution":"class SimpleFileSystem: def __init__(self): self.root = {} def _traverse(self, path: str): components = path.strip(\'/\').split(\'/\') current = self.root for component in components: if component not in current: current[component] = {} current = current[component] return current def create_directory(self, path: str) -> None: self._traverse(path) def create_file(self, path: str) -> None: components = path.strip(\'/\').split(\'/\') file_name = components[-1] dir_path = \'/\'.join(components[:-1]) directory = self._traverse(dir_path) directory[file_name] = None # Use None to represent a file def delete_directory(self, path: str) -> None: components = path.strip(\'/\').split(\'/\') current = self.root for component in components[:-1]: current = current.get(component, {}) if components[-1] in current: del current[components[-1]] def list_contents(self, path: str): directory = self._traverse(path) return sorted([key for key in directory.keys()]) # Example usage: fs = SimpleFileSystem() fs.create_directory(\\"/documents/reports\\") fs.create_file(\\"/documents/reports/january.pdf\\") fs.create_file(\\"/documents/reports/february.pdf\\") fs.create_directory(\\"/public/images\\") print(fs.list_contents(\\"/documents/reports\\")) # Expected Output: [\'february.pdf\', \'january.pdf\'] fs.delete_directory(\\"/documents\\") print(fs.list_contents(\\"/documents\\")) # Expected Output: []"},{"question":"# Coding Assessment Question In this exercise, you will work with sorting algorithms and optimize a given function to efficiently sort a list of integers. Your task is to implement a merge sort algorithm, which is a popular divide and conquer algorithm used for sorting. # Scenario Your task is to implement the merge sort algorithm. Merge sort works by recursively dividing the list into two halves until each sublist contains a single element, then merging the sublists back together in sorted order. # Function Definition Implement the function `merge_sort` that takes a list of N integers and returns a new list containing the same integers in sorted order. # Function Signature ```python def merge_sort(lst: List[int]) -> List[int]: pass ``` # Input * `lst` (List[int]): A list of N integers. # Output * Returns (List[int]): A new list containing the integers from `lst`, sorted in ascending order. # Constraints * 1 <= N <= 10^5 * Each integer in the list is between -10^6 and 10^6 inclusive. # Performance Requirements Your implementation must run in O(N log N) time complexity and use O(N) auxiliary space. # Examples ```python >>> merge_sort([34, 7, 23, 32, 5, 62]) [5, 7, 23, 32, 34, 62] >>> merge_sort([12, 11, 13, 5, 6, 7]) [5, 6, 7, 11, 12, 13] ```","solution":"from typing import List def merge_sort(lst: List[int]) -> List[int]: Recursively divides the list into halves and merges them in sorted order. if len(lst) <= 1: return lst mid = len(lst) // 2 left_half = merge_sort(lst[:mid]) right_half = merge_sort(lst[mid:]) return merge(left_half, right_half) def merge(left: List[int], right: List[int]) -> List[int]: Merges two sorted lists into one sorted list. sorted_list = [] left_index, right_index = 0, 0 # Merge the two lists by comparing their elements while left_index < len(left) and right_index < len(right): if left[left_index] < right[right_index]: sorted_list.append(left[left_index]) left_index += 1 else: sorted_list.append(right[right_index]) right_index += 1 # If there are remaining elements in the left or right list, add them sorted_list.extend(left[left_index:]) sorted_list.extend(right[right_index:]) return sorted_list"},{"question":"# Movie Rental System As part of a movie rental system, you need to implement a set of functionalities that manage movie rentals for a small shop. The shop keeps a catalog of available movies and tracks the rental status of each movie. 1. **Movie Catalog Management**: Implement a class `MovieCatalog` that can add new movies, remove movies, and retrieve movies based on their title. 2. **Rental Tracking**: Implement a rental system to manage which movies are currently rented out and which are available. Add functionalities to rent a movie and return a rented movie. 3. **Availability Check**: Ensure that the system checks if a movie is available before renting it out. # Input and Output Format * Implement three distinct functions in the `MovieCatalog` class: * `add_movie(title: str) -> None`: Adds a new movie to the catalog. * `remove_movie(title: str) -> None`: Removes a movie from the catalog. * `get_movies() -> List[str]`: Retrieves a list of all movie titles in the catalog. * Implement three distinct functions in the `RentalSystem` class: * `rent_movie(title: str) -> bool`: Rents a movie if it is available. Returns `True` if successful, otherwise `False`. * `return_movie(title: str) -> None`: Returns a rented movie back to the catalog. * `get_rented_movies() -> List[str]`: Retrieves a list of currently rented movie titles. # Constraints * Each movie title in the catalog is unique. * The system should handle up to 1000 different movie titles. * The rental system only allows renting and returning movies that exist in the catalog. * If a movie is rented and removed from the catalog, it should not be possible to rent it out until it is re-added. # Examples ```python # Example usage: # Create a new MovieCatalog instance catalog = MovieCatalog() # Add movies to the catalog catalog.add_movie(\\"The Matrix\\") catalog.add_movie(\\"Inception\\") catalog.add_movie(\\"Interstellar\\") print(catalog.get_movies()) # Should output: [\\"The Matrix\\", \\"Inception\\", \\"Interstellar\\"] # Create a new RentalSystem instance rental = RentalSystem(catalog) # Rent out a movie success = rental.rent_movie(\\"Inception\\") print(success) # Should output: True print(rental.get_rented_movies()) # Should output: [\\"Inception\\"] # Check catalog after renting print(catalog.get_movies()) # Should output: [\\"The Matrix\\", \\"Interstellar\\"] # Return the rented movie rental.return_movie(\\"Inception\\") print(rental.get_rented_movies()) # Should output: [] # Check catalog after return print(catalog.get_movies()) # Should output: [\\"The Matrix\\", \\"Interstellar\\", \\"Inception\\"] ``` Implement the `MovieCatalog` and `RentalSystem` classes based on the above requirements and guidelines.","solution":"from typing import List class MovieCatalog: def __init__(self): self.movies = [] def add_movie(self, title: str) -> None: if title not in self.movies: self.movies.append(title) def remove_movie(self, title: str) -> None: if title in self.movies: self.movies.remove(title) def get_movies(self) -> List[str]: return self.movies class RentalSystem: def __init__(self, catalog: MovieCatalog): self.catalog = catalog self.rented_movies = [] def rent_movie(self, title: str) -> bool: if title in self.catalog.get_movies() and title not in self.rented_movies: self.catalog.remove_movie(title) self.rented_movies.append(title) return True return False def return_movie(self, title: str) -> None: if title in self.rented_movies: self.rented_movies.remove(title) self.catalog.add_movie(title) def get_rented_movies(self) -> List[str]: return self.rented_movies"},{"question":"# Question You are asked to determine the frequency of the most frequent word in a given text file. The text file contains multiple lines of text. Task Write a function named `most_frequent_word_count(file_path: str) -> int` that reads from a text file and returns the frequency of the most frequent word in the file. For the purpose of this problem, words are defined as sequences of alphabetic characters, and case-insensitive matching should be performed (e.g., \\"Word\\" and \\"word\\" are the same). Input - `file_path` (str): A string representing the path to a text file with multiple lines of text. Output - (int): The frequency of the most frequently occurring word in the file. Constraints - The file will contain at least one word. - Words are delimited by non-alphabetic characters. # Example Consider a file \\"words.txt\\" with the following contents: ``` Hello World! hello again, World. HELLO hello world? ``` The function call `most_frequent_word_count(\\"words.txt\\")` should return `4` since \\"hello\\" occurs 4 times. # Additional Notes: - Ensure to handle large files efficiently. - Consider the impact of punctuation and non-alphabetic characters on word separation and punctuation stripping.","solution":"import re from collections import Counter def most_frequent_word_count(file_path: str) -> int: Reads a text file and returns the frequency of the most frequent word. Words are case-insensitive and non-alphabetic characters are delimiters. with open(file_path, \'r\') as file: text = file.read() # Use regex to find all words ignoring case words = re.findall(r\'b[a-zA-Z]+b\', text.lower()) # Count frequency of each word word_counts = Counter(words) # Return the frequency of the most common word if word_counts: return word_counts.most_common(1)[0][1] return 0"},{"question":"# Coding Assessment Question: You are given a problem where you need to calculate the number of distinct rectangles that can be formed in a grid of dots. # Objective: Write a function `count_rectangles(height: int, width: int) -> int` that calculates the number of rectangles that can be formed in a grid of dots with given dimensions. # Input: * `height` (integer): The number of rows of dots (1 <= height <= 1000). * `width` (integer): The number of columns of dots (1 <= width <= 1000). # Output: * An integer representing the number of distinct rectangles that can be formed within the grid. # Constraints: * The grid has `height + 1` rows and `width + 1` columns of dots. * **Performance**: The solution should be efficient enough to handle the upper bounds within a reasonable time frame. # Example: ```python def count_rectangles(height: int, width: int) -> int: # Your implementation here... pass # Test the function with the example case print(count_rectangles(2, 3)) # Expected output: 18 ``` # Explanation: In the example above, for a grid with 2 rows and 3 columns of dots (resulting in a 3x4 grid of dots), there are exactly 18 distinct rectangles that can be formed. # Additional Notes: * Consider edge cases where the height or width is the minimum possible value. * Ensure the code efficiently calculates the number of rectangles for larger grid dimensions.","solution":"def count_rectangles(height: int, width: int) -> int: Calculate the number of distinct rectangles that can be formed in a grid of dots with given dimensions. Parameters: height (int): The number of rows of dots (1 <= height <= 1000). width (int): The number of columns of dots (1 <= width <= 1000). Returns: int: The number of distinct rectangles that can be formed within the grid. return (height * (height + 1) * width * (width + 1)) // 4"},{"question":"# Problem Statement **Entropy Sort** You are given a list of integers. The \\"entropy\\" of a list is defined as the sum of the absolute differences between consecutive elements. Specifically, if we have a list `A` of length `n`, then the entropy `E` is given by: E(A) = |A[0] - A[1]| + |A[1] - A[2]| + ... + |A[n-2] - A[n-1]| Write a function `entropy_sort(arr: List[int]) -> Tuple[List[int], int]` that sorts the list in such a way that it minimizes the entropy and returns a tuple containing the sorted list and the entropy of the sorted list. **Constraints**: - `2 <= len(arr) <= 1000` - `-10^4 <= arr[i] <= 10^4` Input - `arr` (List[int]): A list of integers. Output - `Tuple[List[int], int]`: A tuple containing the sorted list that minimizes the entropy and the entropy of the sorted list. Example ```python def entropy_sort(arr: List[int]) -> Tuple[List[int], int]: # Implementation here… print(entropy_sort([1, 3, 4, 10, 2])) # output: ([1, 2, 3, 4, 10], 9) ``` Notes - The solution should aim to find the sequence which minimizes the total absolute difference. - You might explore sorting or reordering techniques to achieve this goal. Performance Requirements - The function should be able to handle the largest input size efficiently.","solution":"from typing import List, Tuple def entropy_sort(arr: List[int]) -> Tuple[List[int], int]: Sorts the list of integers to minimize entropy and returns the sorted list along with its entropy. # Sorting the list in non-decreasing order to minimize entropy sorted_arr = sorted(arr) # Calculate the entropy of the sorted list entropy = sum(abs(sorted_arr[i] - sorted_arr[i + 1]) for i in range(len(sorted_arr) - 1)) return (sorted_arr, entropy)"},{"question":"Problem Statement You are tasked with designing a class that can manage a collection of string sequences, applying a variety of operations efficiently. The class should allow addition, removal, sorting, and retrieval of sequences based on specified criteria. # Function Signature: ```python class SequenceManager: def __init__(self) -> None: # Initialization code def add_sequence(self, sequence: str) -> None: Add a new sequence to the collection. Args: sequence (str): The string sequence to be added. def remove_sequence(self, sequence: str) -> bool: Remove a sequence from the collection if it exists. Args: sequence (str): The string sequence to be removed. Returns: bool: True if the sequence was removed, False if it didn\'t exist. def get_sorted_sequences(self) -> list: Retrieve all sequences sorted in increasing order of length. Returns: list: A list of string sequences sorted by their length. def get_sequences_with_length(self, length: int) -> list: Retrieve all sequences with the specified length. Args: length (int): The length that the sequences must match. Returns: list: A list of string sequences matching the specified length. ``` ``` # Input - Sequence (`sequence: str`): A string sequence to be added or removed. - Length (`length: int`): An integer representing the required length of sequences to be retrieved. # Output - `add_sequence` has no return value. - `remove_sequence` returns a boolean indicating whether the sequence was successfully removed. - `get_sorted_sequences` returns a sorted list of sequences. - `get_sequences_with_length` returns a list of sequences matching the specified length. # Constraints - The sequences are non-empty strings with a maximum length of 100 characters. - The collection can contain up to 10,000 sequences. - The length argument for `get_sequences_with_length` will always be a non-negative integer. # Example ```python # Creating an instance of the SequenceManager class manager = SequenceManager() # Adding sequences to the collection manager.add_sequence(\\"ATCG\\") manager.add_sequence(\\"A\\") manager.add_sequence(\\"ATGCT\\") # Removing a sequence print(manager.remove_sequence(\\"ATCG\\")) # Output: True print(manager.remove_sequence(\\"GATTACA\\")) # Output: False # Retrieving all sequences sorted by length print(manager.get_sorted_sequences()) # Output: [\\"A\\", \\"ATGCT\\"] # Retrieving sequences with a specific length print(manager.get_sequences_with_length(1)) # Output: [\\"A\\"] print(manager.get_sequences_with_length(5)) # Output: [\\"ATGCT\\"] ``` # Additional Notes - Ensure your implementation supports efficient addition and retrieval operations. - Handle cases where the collection might be empty appropriately.","solution":"class SequenceManager: def __init__(self) -> None: self.sequences = set() # Using a set to keep track of sequences def add_sequence(self, sequence: str) -> None: Add a new sequence to the collection. Args: sequence (str): The string sequence to be added. self.sequences.add(sequence) def remove_sequence(self, sequence: str) -> bool: Remove a sequence from the collection if it exists. Args: sequence (str): The string sequence to be removed. Returns: bool: True if the sequence was removed, False if it didn\'t exist. if sequence in self.sequences: self.sequences.remove(sequence) return True return False def get_sorted_sequences(self) -> list: Retrieve all sequences sorted in increasing order of length. Returns: list: A list of string sequences sorted by their length. # Sorting sequences primarily by length and secondarily lexicographically return sorted(self.sequences, key=lambda x: (len(x), x)) def get_sequences_with_length(self, length: int) -> list: Retrieve all sequences with the specified length. Args: length (int): The length that the sequences must match. Returns: list: A list of string sequences matching the specified length. return [seq for seq in self.sequences if len(seq) == length]"},{"question":"**Scenario**: You are developing software to manage a library. Each book in the library is represented by a set of attributes like title, author, year of publication, and genre. The library system should support several operations such as searching for books by title or author, listing all books under a certain genre, and retrieving the details of the oldest book in the collection. Your task is to implement these functionalities. **Problem Statement**: Write a class `Library` that simulates the management of a library with books. The class must support adding books, searching for books by title or author, listing all books under a specific genre, and getting the details of the oldest book in the library. # Class Definition: ```python class Library: def __init__(self): # Initializes an empty library pass def add_book(self, title: str, author: str, year: int, genre: str) -> None: # Adds a new book to the library pass def search_by_title(self, title: str) -> list[dict]: # Searches for books by title (case-insensitive) and returns a list of matching book details pass def search_by_author(self, author: str) -> list[dict]: # Searches for books by author (case-insensitive) and returns a list of matching book details pass def list_books_by_genre(self, genre: str) -> list[dict]: # Lists all books under a specific genre and returns their details pass def get_oldest_book(self) -> dict: # Retrieves the details of the oldest book in the library pass ``` # Inputs and Class Methods: 1. `add_book(self, title: str, author: str, year: int, genre: str) -> None`: Adds a book to the library. - `title`: The title of the book - `author`: The author of the book - `year`: The year of publication - `genre`: The genre of the book 2. `search_by_title(self, title: str) -> list[dict]`: Searches for books by the given title (case-insensitive) and returns a list of dictionaries with book details. 3. `search_by_author(self, author: str) -> list[dict]`: Searches for books by the given author (case-insensitive) and returns a list of dictionaries with book details. 4. `list_books_by_genre(self, genre: str) -> list[dict]`: Lists all books under the given genre and returns their details as a list of dictionaries. 5. `get_oldest_book(self) -> dict`: Retrieves the details of the oldest book in the library as a dictionary. # Outputs: - The library data should be represented in the form of dictionaries. # Example: ```python library = Library() library.add_book(\\"1984\\", \\"George Orwell\\", 1949, \\"Dystopian\\") library.add_book(\\"Brave New World\\", \\"Aldous Huxley\\", 1932, \\"Dystopian\\") library.add_book(\\"A Brief History of Time\\", \\"Stephen Hawking\\", 1988, \\"Science\\") assert library.search_by_title(\\"1984\\") == [{\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"year\\": 1949, \\"genre\\": \\"Dystopian\\"}] assert library.search_by_author(\\"Aldous Huxley\\") == [{\\"title\\": \\"Brave New World\\", \\"author\\": \\"Aldous Huxley\\", \\"year\\": 1932, \\"genre\\": \\"Dystopian\\"}] assert library.list_books_by_genre(\\"Dystopian\\") == [ {\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"year\\": 1949, \\"genre\\": \\"Dystopian\\"}, {\\"title\\": \\"Brave New World\\", \\"author\\": \\"Aldous Huxley\\", \\"year\\": 1932, \\"genre\\": \\"Dystopian\\"}, ] assert library.get_oldest_book() == {\\"title\\": \\"Brave New World\\", \\"author\\": \\"Aldous Huxley\\", \\"year\\": 1932, \\"genre\\": \\"Dystopian\\"} ```","solution":"class Library: def __init__(self): # Initializes an empty list for storing books self.books = [] def add_book(self, title: str, author: str, year: int, genre: str) -> None: # Adds a new book to the library as a dictionary book = {\\"title\\": title, \\"author\\": author, \\"year\\": year, \\"genre\\": genre} self.books.append(book) def search_by_title(self, title: str) -> list: # Searches for books by title (case-insensitive) and returns a list of matching book details title_lower = title.lower() return [book for book in self.books if title_lower in book[\\"title\\"].lower()] def search_by_author(self, author: str) -> list: # Searches for books by author (case-insensitive) and returns a list of matching book details author_lower = author.lower() return [book for book in self.books if author_lower in book[\\"author\\"].lower()] def list_books_by_genre(self, genre: str) -> list: # Lists all books under a specific genre and returns their details genre_lower = genre.lower() return [book for book in self.books if genre_lower == book[\\"genre\\"].lower()] def get_oldest_book(self) -> dict: # Retrieves the details of the oldest book in the library if not self.books: return {} oldest_book = min(self.books, key=lambda x: x[\\"year\\"]) return oldest_book"},{"question":"# Coding Challenge: Order Fulfillment Optimization # Question: You are a software engineer responsible for developing an inventory management system for a retail business. The system needs a feature that helps in optimizing order fulfillment using the stock available in multiple warehouses. Each warehouse has a limited stock of each item, and your goal is to fulfill an order by sourcing items from the least number of warehouses. **Objective**: Develop a function that selects the fewest number of warehouses required to fulfill a customer\'s order. If it\'s not possible to fulfill the order with the available stock, the function should return an empty list. **Function Signature**: ```python def optimize_order_fulfillment(order: Dict[str, int], warehouses: List[Dict[str, int]]) -> List[int]: pass ``` **Parameters**: - `order` (Dict[str, int]): A dictionary representing the customer\'s order, where the keys are item names and the values are the quantities required. - `warehouses` (List[Dict[str, int]]): A list of dictionaries representing the stock available at each warehouse. Each dictionary\'s keys are item names and the values are the quantities available. **Returns**: - `List[int]`: A list of indices representing the warehouses used to fulfill the order, in ascending order. If the order cannot be fulfilled, return an empty list. **Constraints**: - The length of `warehouses` will be between 1 and 50. - The maximum number of unique items in `order` and each warehouse stock will not exceed 50. - Each item\'s quantity in `order` and `warehouses` will be a positive integer up to 1000. - The sum of all quantities for any item across all warehouses will not exceed 10000. **Performance Requirements**: - Aim for an efficient algorithm that can handle the upper limits of constraints within reasonable time limits. **Example**: ```python order = { \\"apple\\": 10, \\"banana\\": 5 } warehouses = [ {\\"apple\\": 7, \\"banana\\": 4}, {\\"apple\\": 3, \\"banana\\": 2}, {\\"apple\\": 5, \\"banana\\": 10} ] # Expected output is the list of indices of the chosen warehouses. print(optimize_order_fulfillment(order, warehouses)) # Output can vary, but an example valid output is [0, 1]. # The function should select the minimal number of warehouses that together can fulfill the order. ``` **Hint**: Consider using a combinatorial approach to evaluate different subsets of warehouses and their capacity to fulfill the order while ensuring the solution expands optimally to avoid excessive computational overhead. By matching the style, length, complexity, and alignment with the original provided question, the new question integrates seamlessly into the existing set.","solution":"from typing import Dict, List def optimize_order_fulfillment(order: Dict[str, int], warehouses: List[Dict[str, int]]) -> List[int]: from itertools import combinations # Function to check if a combination of warehouses can fulfill the order def can_fulfill(order: Dict[str, int], selected_indices: List[int], warehouses: List[Dict[str, int]]) -> bool: inventory = {} for idx in selected_indices: for item, quantity in warehouses[idx].items(): if item in inventory: inventory[item] += quantity else: inventory[item] = quantity for item, required_quantity in order.items(): if inventory.get(item, 0) < required_quantity: return False return True n = len(warehouses) for r in range(1, n + 1): for combo in combinations(range(n), r): if can_fulfill(order, combo, warehouses): return sorted(combo) return []"},{"question":"**Context:** In a software system, it is often necessary to sort elements dynamically as they are added. Imagine you are building a module for a system that needs to maintain a sorted list of elements where new elements are frequently inserted. # Task: Implement a class-based sorted list using a balanced binary search tree (BST). The sorted list should support the following operations: - `insert(item)`: Adds `item` to the sorted list while maintaining the sorted order. - `remove(item)`: Removes `item` from the list if it exists. - `find(item)`: Checks if `item` is in the list. - `get_sorted_elements()`: Returns the list of elements in sorted order. # Specifications: 1. Implement the sorted list such that: - `insert` operation has O(log n) time complexity. - `remove` operation has O(log n) time complexity. - `find` operation has O(log n) time complexity. 2. Handle all edge cases mentioned. # Input and Output: Your methods must match the following signatures: - `insert(item: int) -> None` - `remove(item: int) -> None` - `find(item: int) -> bool` - `get_sorted_elements() -> List[int]` # Constraints: - Assume all items are integers. - Maximum number of items: 10^5. - Attempting to remove or find an item that is not in the list should not raise an exception but should handle it gracefully. **Example:** ```python sl = SortedList() sl.insert(10) sl.insert(5) sl.insert(20) assert sl.get_sorted_elements() == [5, 10, 20] assert sl.find(10) == True assert sl.find(15) == False sl.remove(10) assert sl.get_sorted_elements() == [5, 20] assert sl.find(10) == False ```","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None class SortedList: def __init__(self): self.root = None def insert(self, item: int) -> None: if self.root is None: self.root = TreeNode(item) else: self._insert(self.root, item) def _insert(self, node, item): if item < node.value: if node.left is None: node.left = TreeNode(item) else: self._insert(node.left, item) else: if node.right is None: node.right = TreeNode(item) else: self._insert(node.right, item) def remove(self, item: int) -> None: self.root = self._remove(self.root, item) def _remove(self, node, item): if node is None: return node # Item not found, return None if item < node.value: node.left = self._remove(node.left, item) elif item > node.value: node.right = self._remove(node.right, item) else: # Node with the item found if node.left is None: return node.right elif node.right is None: return node.left else: temp_val = self._find_min(node.right).value node.value = temp_val node.right = self._remove(node.right, temp_val) return node def _find_min(self, node): current = node while current.left is not None: current = current.left return current def find(self, item: int) -> bool: return self._find(self.root, item) def _find(self, node, item): if node is None: return False if item < node.value: return self._find(node.left, item) elif item > node.value: return self._find(node.right, item) else: return True def get_sorted_elements(self) -> list: sorted_elements = [] self._inorder_traversal(self.root, sorted_elements) return sorted_elements def _inorder_traversal(self, node, elements): if node is not None: self._inorder_traversal(node.left, elements) elements.append(node.value) self._inorder_traversal(node.right, elements)"},{"question":"# Problem Description You are tasked with implementing a decision tree classifier to predict the class labels for a dataset. The objective is to build, train, and evaluate the decision tree model based on a provided dataset, and then use it to make predictions. # Inputs and Outputs * **Input**: - A CSV file named `classification_data.csv` containing features and corresponding class labels for each instance. - An integer `test_size` indicating the percentage of the dataset to be used as the test set (e.g., 20 for 20%). * **Output**: - A dictionary with three keys: - `\'accuracy\'`: The accuracy score of the model on the test set. - `\'confusion_matrix\'`: The confusion matrix for the model\'s predictions on the test set. - `\'predictions\'`: A list of predicted class labels for the test set. # Constraints - The dataset should have at least one feature column and one target column. - The `test_size` should be a positive integer between 10 and 50 (representing 10% to 50%). # Requirements You are required to: 1. Load and preprocess the data. 2. Split the data into training and testing sets based on the `test_size`. 3. Build and train the decision tree classifier on the training set. 4. Evaluate the model using the testing set. 5. Output the accuracy score, confusion matrix, and the list of predicted class labels for the test set. # Example Sample `classification_data.csv`: ```csv feature1,feature2,feature3,class 5.1,3.5,1.4,0 4.9,3.0,1.4,0 4.7,3.2,1.3,0 6.3,3.3,6.0,2 5.8,2.7,5.1,2 5.7,2.8,4.1,1 ... ``` Given: - `test_size = 20` Your function should return a dictionary with the accuracy score, confusion matrix, and predicted class labels for the test set. # Function Signature ```python import pandas as pd from sklearn.model_selection import train_test_split from sklearn.tree import DecisionTreeClassifier from sklearn.metrics import accuracy_score, confusion_matrix def decision_tree_classification(file_path: str, test_size: int) -> dict: # Loading and preprocessing data pass # Example usage results = decision_tree_classification(\'classification_data.csv\', test_size=20) print(results) # Example output: {\'accuracy\': 0.95, \'confusion_matrix\': [[5,0,0], [0,9,1], [0,0,5]], \'predictions\': [0, 1, 2, ...]} ```","solution":"import pandas as pd from sklearn.model_selection import train_test_split from sklearn.tree import DecisionTreeClassifier from sklearn.metrics import accuracy_score, confusion_matrix def decision_tree_classification(file_path: str, test_size: int) -> dict: # Load the data data = pd.read_csv(file_path) # Extract features and target X = data.iloc[:, :-1].values y = data.iloc[:, -1].values # Split the data into training and testing sets X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=test_size / 100, random_state=42) # Initialize and train the decision tree classifier clf = DecisionTreeClassifier(random_state=42) clf.fit(X_train, y_train) # Make predictions y_pred = clf.predict(X_test) # Compute accuracy accuracy = accuracy_score(y_test, y_pred) # Compute confusion matrix conf_matrix = confusion_matrix(y_test, y_pred) # Return the results return { \'accuracy\': accuracy, \'confusion_matrix\': conf_matrix.tolist(), \'predictions\': y_pred.tolist() }"},{"question":"# Coding Question: Optimal Task Scheduling Background You are managing a set of tasks each with a specific duration and deadline. To maximize efficiency, you want to schedule the tasks in such a way that the total time taken to complete all tasks is minimized, while ensuring no task exceeds its deadline. Objective Write a function `schedule_tasks(tasks: List[Tuple[int, int]]) -> int` that calculates the minimum total completion time while ensuring all tasks are completed within their respective deadlines. Input * A list of tuples, where each tuple contains two integers. The first integer is the duration of the task, and the second integer is the deadline by which the task must be completed. Output * Return an integer representing the total minimum completion time for all tasks. Constraints * All durations and deadlines are non-negative integers. * Each task can only start after the previous one has finished. * If it is not possible to complete all tasks within their deadlines, return `-1`. Example ```python >>> schedule_tasks([(3, 5), (2, 6), (1, 3)]) 6 >>> schedule_tasks([(4, 4), (2, 9), (1, 7)]) -1 ``` Notes * Using a greedy algorithm or priority queue may help achieve an optimal solution. * Ensure to handle edge cases such as: * If no tasks are provided, the total completion time should be `0`. * If any task cannot be scheduled within its deadline, return `-1`. Edge Cases * If the input list is empty, the function should return `0`. * If there are tasks that independently cannot meet their deadline, handle this logically through appropriate return values. Validation In addition to the above cases, your solution should run efficiently for a large number of tasks (up to 10^5).","solution":"def schedule_tasks(tasks): Returns the minimum total completion time while ensuring all tasks are completed within their respective deadlines. If it\'s not possible to complete all tasks within their deadlines, it returns -1. # Sort tasks based on their deadlines first, then by their durations tasks.sort(key=lambda x: (x[1], x[0])) current_time = 0 for duration, deadline in tasks: current_time += duration if current_time > deadline: return -1 return current_time"},{"question":"# Coding Question **Title: Validate International Bank Account Numbers (IBAN)** **Background**: An International Bank Account Number (IBAN) is a standardized way of identifying a bank account internationally, reducing errors in cross-border transactions. Validating an IBAN involves several checks, including the length and a modular arithmetic check. Write a Python function `validate_iban(ibans: List[str]) -> List[bool]` that will validate a list of IBANs and return a list of results, indicating whether each IBAN is valid or not. **Function Signature**: ```python def validate_iban(ibans: List[str]) -> List[bool]: ``` **Input**: - `ibans` (List[str]): A list of strings where each string is an IBAN to be validated. Each IBAN is guaranteed to be in uppercase and without spaces. **Output**: - (List[bool]): A list of boolean values where each boolean represents if the respective IBAN is valid or not. **Constraints**: - IBANs vary widely in length but are typically between 15 and 34 characters. - IBAN starts with two-letter country code followed by two check digits and up to 30 alphanumeric country-specific characters. **Examples**: ```python assert validate_iban([\'GB82WEST12345698765432\', \'DE89370400440532013000\', \'FR1420041010050500013M02606\']) == [True, True, True] assert validate_iban([\'GB82WEST1234569876543\', \'DE893704004405320130001\', \'FR1420041010050500013M0260\']) == [False, False, False] ``` **Implementation Guidelines**: 1. Move the first four characters to the end of the IBAN. 2. Replace each letter in the rearranged string with digits (A=10, B=11, ..., Z=35). 3. Convert the resulting string to an integer and check if the integer modulo 97 equals 1. 4. Return a list of boolean values indicating whether each IBAN in the input list is valid. **Notes**: - Ensure the IBAN has a valid length for the country code derived from the first two letters. - Optimize to handle a large list of IBANs efficiently. **Example (GB82WEST12345698765432 Validation)**: 1. Rearrange: `WEST12345698765432GB82` 2. Convert letters to numbers: `3214282912345698765432161182` 3. Validate: If `3214282912345698765432161182 % 97 == 1` then the IBAN is valid.","solution":"import string def validate_iban(ibans): Validates a list of IBANs Parameters: ibans (List[str]): A list of IBAN strings Returns: List[bool]: A list of boolean values where each boolean indicates if the respective IBAN is valid or not. iban_lengths = { \'AL\': 28, \'AD\': 24, \'AT\': 20, \'AZ\': 28, \'BE\': 16, \'BH\': 22, \'BA\': 20, \'BR\': 29, \'BG\': 22, \'CR\': 21, \'HR\': 21, \'CY\': 28, \'CZ\': 24, \'DK\': 18, \'DO\': 28, \'EE\': 20, \'FI\': 18, \'FR\': 27, \'GE\': 22, \'DE\': 22, \'GI\': 23, \'GR\': 27, \'GL\': 18, \'GT\': 28, \'HU\': 28, \'IS\': 26, \'IE\': 22, \'IL\': 23, \'IT\': 27, \'KZ\': 20, \'KW\': 30, \'LV\': 21, \'LB\': 28, \'LI\': 21, \'LT\': 20, \'LU\': 20, \'MK\': 19, \'MT\': 31, \'MR\': 27, \'MU\': 30, \'MC\': 27, \'MD\': 24, \'ME\': 22, \'NL\': 18, \'NO\': 15, \'PK\': 24, \'PS\': 29, \'PL\': 28, \'PT\': 25, \'RO\': 24, \'SM\': 27, \'SA\': 24, \'RS\': 22, \'SK\': 24, \'SI\': 19, \'ES\': 24, \'SE\': 24, \'CH\': 21, \'TN\': 24, \'TR\': 26, \'AE\': 23, \'GB\': 22, \'VG\': 24 } def iban_to_integer(iban): # Move the first four characters to the end rearranged_iban = iban[4:] + iban[:4] # Replace letters with numbers (A=10, B=11, ..., Z=35) numeric_iban = \'\'.join(str(string.ascii_uppercase.index(ch) + 10) if ch.isalpha() else ch for ch in rearranged_iban) return int(numeric_iban) def is_valid_iban(iban): if iban[:2] not in iban_lengths or len(iban) != iban_lengths[iban[:2]]: return False # Convert the IBAN to an integer and perform mod 97 operation return iban_to_integer(iban) % 97 == 1 return [is_valid_iban(iban) for iban in ibans]"},{"question":"**Context**: You have been hired to develop a sales management application for a chain of bookstores. One of the key features is generating inventory reports that list books sorted by their sales performance. Each book has a unique identifier, a name, and a recorded number of sales. **Task**: Implement the `top_selling_books` function, which returns a list of book identifiers sorted in descending order of their sales numbers. If two books have the same number of sales, sort them by their names in ascending alphabetical order. **Function Signature**: ```python def top_selling_books(sales_data: list) -> list: Return a list of book identifiers sorted by sales performance. :param sales_data: list, a list of tuples where each tuple contains: (book_id: str, book_name: str, sales: int) :return: list, a list of book identifiers sorted by the specified criteria ``` # Input: - `sales_data` (list): A list of tuples, where each tuple contains: - `book_id` (str): A unique identifier for the book. - `book_name` (str): The name of the book. - `sales` (int): The recorded number of sales for the book. # Output: - A list of book identifiers sorted in descending order of their sales numbers. If two books have the same number of sales, sort them by their names in ascending alphabetical order. # Constraints: - Each book has a unique identifier. - The sales number is a non-negative integer. - The list contains at least one book. # Example: ```python sales_data = [ (\\"id1\\", \\"Book A\\", 150), (\\"id2\\", \\"Book B\\", 250), (\\"id3\\", \\"Book C\\", 250), (\\"id4\\", \\"Book D\\", 100) ] assert top_selling_books(sales_data) == [\\"id2\\", \\"id3\\", \\"id1\\", \\"id4\\"] ``` # Note: - Consider how tie-breaking is handled when books have the same number of sales. - Ensure your solution is efficient and can handle large datasets. **Your implementation will be evaluated on correctness, efficiency, and handling of edge cases.**","solution":"def top_selling_books(sales_data): Return a list of book identifiers sorted by sales performance. :param sales_data: list, a list of tuples where each tuple contains: (book_id: str, book_name: str, sales: int) :return: list, a list of book identifiers sorted by the specified criteria # Sort based on sales in descending order, then by book name in ascending order sorted_books = sorted(sales_data, key=lambda x: (-x[2], x[1])) return [book[0] for book in sorted_books]"},{"question":"# Problem Statement: Implement a function `calculate_commit_difference` that determines the difference between two commits in a fictional version control system. Each commit is represented by a dictionary of file-names and their corresponding content in strings. The difference between two commits is a list of changes where each change includes the file name and a description of the change: `added`, `removed`, or `modified`. # Constraints: * The input will be two dictionaries where the keys are strings representing file names and the values are strings representing the content. * Each file name and its content will not exceed 100 characters. * File names will be unique within each commit. # Sample Input/Output: ```plaintext calculate_commit_difference( {\\"file1.txt\\": \\"Hello\\", \\"file2.txt\\": \\"World\\"}, {\\"file2.txt\\": \\"World!\\", \\"file3.txt\\": \\"New File\\"} ) Returns: [ {\\"file\\": \\"file1.txt\\", \\"change\\": \\"removed\\"}, {\\"file\\": \\"file2.txt\\", \\"change\\": \\"modified\\"}, {\\"file\\": \\"file3.txt\\", \\"change\\": \\"added\\"} ] calculate_commit_difference( {\\"a.txt\\": \\"Hi\\"}, {\\"a.txt\\": \\"Hi\\", \\"b.txt\\": \\"Bye\\"} ) Returns: [ {\\"file\\": \\"b.txt\\", \\"change\\": \\"added\\"} ] ``` # Function Signature: ```python def calculate_commit_difference(commit1: dict, commit2: dict) -> list: pass ``` # Requirements: 1. Traverse both dictionaries, comparing files by name. 2. Identify added files present in `commit2` but not in `commit1`. 3. Identify removed files present in `commit1` but not in `commit2`. 4. Determine modified files by comparing content for files present in both commits but with different content. # Explanation: 1. First, create a set of all file names across both commits. 2. For each file name, determine if the file was added, removed, or modified based on its presence in each commit and the content comparison. 3. Generate a list of dictionaries where each dictionary represents a change with a file name and the type of change. # Edge Cases: * When both commits are empty, the result should be an empty list. * If there are no differences between commits (same file names and contents), return an empty list.","solution":"def calculate_commit_difference(commit1: dict, commit2: dict) -> list: changes = [] all_files = set(commit1.keys()).union(commit2.keys()) for file in all_files: if file not in commit1: changes.append({\\"file\\": file, \\"change\\": \\"added\\"}) elif file not in commit2: changes.append({\\"file\\": file, \\"change\\": \\"removed\\"}) elif commit1[file] != commit2[file]: changes.append({\\"file\\": file, \\"change\\": \\"modified\\"}) return changes"},{"question":"# Problem Statement: You are given an integer array `nums` of size `n`, where `n` is even. Your task is to partition the array into two subsets whose sums are as close as possible. Write a function that returns the absolute difference in the sums of these two subsets. # Requirements: - You are to write a function: ```python def minimum_subset_sum_difference(nums: List[int]) -> int: ``` - **Input**: * A list of integers `nums` with an even number of elements. - **Output**: * An integer representing the minimum absolute difference between the sums of the two subsets. # Example: ```python # Example 1: minimum_subset_sum_difference([1, 6, 11, 5]) # Output: 1 # Example 2: minimum_subset_sum_difference([1, 2, 3, 4]) # Output: 0 # Example 3: minimum_subset_sum_difference([5, 5, 5, 5]) # Output: 0 ``` # Constraints: - The length of the array `n` is even and up to 1000. - Each element of the array can be any integer from -10^4 to 10^4. - Ensure the code runs efficiently for the upper limit of constraints. # Explanation: Given the array `nums`, the goal is to find two subsets with a minimum subset sum difference: * Subset 1 sum: sum1 * Subset 2 sum: sum2 * Objective is to minimize |sum1 - sum2| Here are a few examples to illustrate: 1. For the input `[1, 6, 11, 5]`, partition as `[1, 11]` and `[6, 5]` resulting in the sums 12 and 11 respectively. Absolute difference is 1. 2. For the input `[1, 2, 3, 4]`, partition as `[1, 4]` and `[2, 3]` resulting in the sums 5 and 5 respectively. Absolute difference is 0. 3. For the input `[5, 5, 5, 5]`, partition as `[5, 5]` and `[5, 5]` resulting in the sums 10 and 10 respectively. Absolute difference is 0. The problem now is clearly defined, and your goal is to write a function to find the minimum absolute difference.","solution":"from typing import List def minimum_subset_sum_difference(nums: List[int]) -> int: total_sum = sum(nums) n = len(nums) half_sum = total_sum // 2 # Initialize a DP array with False values dp = [[False] * (half_sum + 1) for _ in range(n + 1)] # Base case: A sum of 0 can always be achieved with empty set for i in range(n + 1): dp[i][0] = True # Fill the DP array for i in range(1, n + 1): for j in range(1, half_sum + 1): if nums[i - 1] <= j: dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]] else: dp[i][j] = dp[i - 1][j] # Find the maximum value that we can achieve which is less than or equal to half_sum for j in range(half_sum, -1, -1): if dp[n][j]: subset1_sum = j break subset2_sum = total_sum - subset1_sum return abs(subset2_sum - subset1_sum)"},{"question":"# Coding Assessment: Genetic Algorithm for Pathfinding Problem Statement You are required to implement a Genetic Algorithm for solving a simple pathfinding problem on a grid. The goal is to navigate from a starting point to a target point on the grid while avoiding obstacles. Objectives 1. Implement a `genetic_algorithm_pathfinding` function that finds an optimal path from a start point to a target point on a grid. 2. Your implementation should use genetic operations such as selection, crossover, mutation, and replacement. 3. Implement a `GridPath` class to represent and evaluate individual paths on the grid. Input - **Grid**: A 2D list representing the grid, where `0` indicates an open cell and `1` indicates an obstacle. - **Start Point**: A tuple `(x, y)` representing the starting coordinates. - **Target Point**: A tuple `(x, y)` representing the target coordinates. - **Algorithm Parameters**: Population size, mutation rate, crossover rate, number of generations, and selection method. Output - The path represented as a list of coordinates from the start to the target point, or an empty list if no path is found. # Constraints 1. **GridPath Class**: - `__init__(self, grid: List[List[int]], path: List[Tuple[int, int]] = []` - `evaluate_fitness(self) -> float` - `mutate(self, mutation_rate: float) -> \'GridPath\'` - `crossover(self, other: \'GridPath\') -> Tuple[\'GridPath\', \'GridPath\']` 2. **Genetic Algorithm Function**: ```python def genetic_algorithm_pathfinding( grid: List[List[int]], start_point: Tuple[int, int], target_point: Tuple[int, int], population_size: int = 100, mutation_rate: float = 0.01, crossover_rate: float = 0.8, generations: int = 1000, selection_method: str = \'roulette_wheel\' ) -> List[Tuple[int, int]]: ``` 3. **Performance Requirement**: The algorithm should efficiently handle typical grid sizes (e.g., 10x10) and find the shortest possible path within a reasonable number of generations. # Example Usage ```python # Define a sample grid grid = [ [0, 0, 0, 0, 1], [0, 1, 0, 1, 0], [0, 1, 0, 0, 0], [0, 0, 0, 1, 0], [1, 0, 0, 0, 0] ] # Define start and target points start_point = (0, 0) target_point = (4, 4) # Perform genetic algorithm pathfinding path = genetic_algorithm_pathfinding( grid=grid, start_point=start_point, target_point=target_point, population_size=50, mutation_rate=0.05, crossover_rate=0.7, generations=500, selection_method=\'roulette_wheel\' ) print(f\\"Found path: {path}\\") ``` Ensure your function is well-tested with various grid configurations to validate its correctness and performance.","solution":"import random from typing import List, Tuple class GridPath: def __init__(self, grid: List[List[int]], path: List[Tuple[int, int]] = None): self.grid = grid self.path = path or [] self.fitness = self.evaluate_fitness() def evaluate_fitness(self) -> float: if not self.path: return float(\'inf\') start_point, target_point = self.path[0], self.path[-1] manhattan_distance = abs(target_point[0] - start_point[0]) + abs(target_point[1] - start_point[1]) return len(self.path) + manhattan_distance def mutate(self, mutation_rate: float) -> \'GridPath\': new_path = self.path[:] for i in range(1, len(new_path)-1): if random.random() < mutation_rate: move_x, move_y = random.choice([(1, 0), (0, 1), (-1, 0), (0, -1)]) new_path[i] = (new_path[i][0] + move_x, new_path[i][1] + move_y) if new_path[i][0] < 0 or new_path[i][0] >= len(self.grid) or new_path[i][1] < 0 or new_path[i][1] >= len(self.grid[0]) or self.grid[new_path[i][0]][new_path[i][1]] == 1: new_path[i] = self.path[i] # revert to previous position if invalid return GridPath(self.grid, new_path) def crossover(self, other: \'GridPath\') -> Tuple[\'GridPath\', \'GridPath\']: cut1, cut2 = sorted(random.sample(range(1, len(self.path)-1), 2)) new_path1 = self.path[:cut1] + other.path[cut1:cut2] + self.path[cut2:] new_path2 = other.path[:cut1] + self.path[cut1:cut2] + other.path[cut2:] return GridPath(self.grid, new_path1), GridPath(self.grid, new_path2) def genetic_algorithm_pathfinding( grid: List[List[int]], start_point: Tuple[int, int], target_point: Tuple[int, int], population_size: int = 100, mutation_rate: float = 0.01, crossover_rate: float = 0.8, generations: int = 1000, selection_method: str = \'roulette_wheel\' ) -> List[Tuple[int, int]]: def generate_initial_path() -> List[Tuple[int, int]]: path = [start_point] while path[-1] != target_point: move_x, move_y = random.choice([(1, 0), (0, 1), (-1, 0), (0, -1)]) new_point = (path[-1][0] + move_x, path[-1][1] + move_y) if 0 <= new_point[0] < len(grid) and 0 <= new_point[1] < len(grid[0]) and grid[new_point[0]][new_point[1]] == 0: path.append(new_point) return path def roulette_wheel_selection(population: List[GridPath]) -> GridPath: total_fitness = sum(p.evaluate_fitness() for p in population) selection_point = random.uniform(0, total_fitness) current_sum = 0 for path in population: current_sum += path.evaluate_fitness() if current_sum >= selection_point: return path return population[-1] # Initialize population population = [GridPath(grid, generate_initial_path()) for _ in range(population_size)] for generation in range(generations): next_generation = [] for _ in range(population_size // 2): if selection_method == \'roulette_wheel\': parent1 = roulette_wheel_selection(population) parent2 = roulette_wheel_selection(population) else: raise ValueError(\'Unknown selection method: {}\'.format(selection_method)) if random.random() < crossover_rate: child1, child2 = parent1.crossover(parent2) else: child1, child2 = parent1, parent2 child1 = child1.mutate(mutation_rate) child2 = child2.mutate(mutation_rate) next_generation.extend([child1, child2]) population = sorted(next_generation, key=lambda p: p.evaluate_fitness())[:population_size] if any(p.path[-1] == target_point for p in population): break optimal_path = next(path for path in population if path.path[-1] == target_point) return optimal_path.path if optimal_path.path[-1] == target_point else [] # Test cases grid = [ [0, 0, 0, 0, 1], [0, 1, 0, 1, 0], [0, 1, 0, 0, 0], [0, 0, 0, 1, 0], [1, 0, 0, 0, 0] ] start_point = (0, 0) target_point = (4, 4) path = genetic_algorithm_pathfinding( grid=grid, start_point=start_point, target_point=target_point, population_size=50, mutation_rate=0.05, crossover_rate=0.7, generations=500, selection_method=\'roulette_wheel\' ) print(f\\"Found path: {path}\\") # Sample execution output"},{"question":"Image Processing Pipeline # Objective: Implement the `ImageProcessingPipeline` class to perform a series of transformations on an image, focusing on preprocessing and the application of various filters. # Constraints: 1. Your implementation should be memory efficient and handle images up to 8000x8000 pixels. 2. Minimize the working memory used, preferably under 500 MB. # Requirements: 1. Implement the `load_image` method: * Load an image from a given file path. 2. Implement the `resize_image` method: * Resize the image maintaining the aspect ratio within a maximum width and height. 3. Implement the `apply_filters` method: * Apply a given list of filters (e.g., grayscale, blur) to the loaded image. 4. Implement the `save_image` method: * Save the processed image to a specified file path. # Input: - Path to the image file as a string. - Maximum width and height for resizing. - A list of filter functions to apply. - Path to save the processed image. # Output: - Path to the saved processed image. # Example: ```python pipeline = ImageProcessingPipeline() pipeline.load_image(\\"input_image.png\\") pipeline.resize_image(max_width=800, max_height=600) pipeline.apply_filters([grayscale_filter, blur_filter]) pipeline.save_image(\\"output_image.png\\") # The processed image should be saved as \\"output_image.png\\" ``` # Edge Cases: 1. Images smaller than the resize dimensions. 2. Very large images, testing the memory efficiency. 3. Applying no filters to the image. # Performance Notes: - Ensure efficient memory management during image processing. - Handle various image formats appropriately. - Optimize filter application for large images to reduce processing time.","solution":"from PIL import Image import numpy as np class ImageProcessingPipeline: def __init__(self): self.image = None def load_image(self, file_path): Load an image from a given file path. self.image = Image.open(file_path) def resize_image(self, max_width, max_height): Resize the image maintaining the aspect ratio within a maximum width and height. if self.image is None: raise ValueError(\\"No image loaded\\") # Get current size width, height = self.image.size # Calculate the new size keeping aspect ratio aspect_ratio = width / height if width > max_width: width = max_width height = int(width / aspect_ratio) if height > max_height: height = max_height width = int(height * aspect_ratio) self.image = self.image.resize((width, height), Image.ANTIALIAS) def apply_filters(self, filters): Apply a given list of filters (e.g., grayscale, blur) to the loaded image. if self.image is None: raise ValueError(\\"No image loaded\\") for filter_func in filters: self.image = filter_func(self.image) def save_image(self, file_path): Save the processed image to a specified file path. if self.image is None: raise ValueError(\\"No image loaded\\") self.image.save(file_path) def grayscale_filter(image): Convert image to grayscale. return image.convert(\\"L\\") def blur_filter(image): Apply a simple blur filter to the image. return image.filter(ImageFilter.BLUR)"},{"question":"# Coding Challenge **Context**: As part of a software upgrade for a large shipping company, you need to write a function to simplify the process of calculating shipment weights. The function needs to compute the total weight of items by iterating through a list of weights. Additionally, it must identify and handle any invalid weight entries. **Objective**: Write a function `calculate_total_weight(weights)` that takes a list of weights as input, validates the weights, and returns the total valid weight. If a weight is invalid, it should be ignored, and an error message should be printed. Function Signature ```python def calculate_total_weight(weights: list) -> float: ... ``` # Input * `weights` (list): A list where each element represents the weight of an item. Weights can be positive integers, floats, or strings representing numbers. Units are in kilograms. # Output * A float representing the total weight of all valid entries. # Constraints * Each float or integer weight is between 0.01 and 100.00 kilograms. * Valid weights as strings will be properly formatted to represent floats (e.g., \\"2.5\\", \\"3.00\\"). * Invalid weights include negative values, non-numeric strings, and values out of the specified range. # Examples ```python assert calculate_total_weight([10, 20.5, \\"30\\", \\"40.2\\"]) == 100.7 assert calculate_total_weight([10, -5, \\"abc\\", 20, \\"15.5\\"]) == 45.5 assert calculate_total_weight([\\"10.0\\", \\"20.1\\", -5, 30, \\"40.00\\"]) == 100.1 assert calculate_total_weight([0, \\"0.5\\", 100, \\"abc\\", 50]) == 150.5 assert calculate_total_weight([\\"abc\\", -45, \\"70.1\\", \\"30\\"]) == 100.1 ``` # Guidelines 1. Iterate through the input list and validate each weight. 2. Values that are strings should be converted to floats if they represent valid weights. 3. Consider both negative and out-of-range values as invalid. 4. Print an error message for each invalid weight: `Invalid weight: {weight}`. 5. Use the `isinstance` function to check the type of each entry. 6. Aim for a solution that processes the weights in a single pass (O(n) complexity). **Note**: Ensure that your solution handles edge cases such as mixed types and various invalid entries appropriately.","solution":"def calculate_total_weight(weights): Computes the total weight of valid items in the list. Parameters: weights (list): List of item weights including integers, floats, and strings. Returns: float: Total weight of valid entries. total_weight = 0.0 for weight in weights: valid_weight = None try: # Convert string representations to floats if isinstance(weight, str): weight = float(weight) # Check if the weight is within the valid range if isinstance(weight, (int, float)) and 0.01 <= weight <= 100.00: valid_weight = weight else: raise ValueError except ValueError: print(f\\"Invalid weight: {weight}\\") if valid_weight is not None: total_weight += valid_weight return total_weight"},{"question":"# Question: Binary Tree Maximum Depth Calculation You are given a function `max_depth` to determine the maximum depth of a binary tree. The depth of a binary tree is the longest path from the root node to any leaf node. Your task is to implement this function using a recursive approach. # Function Signature ```python def max_depth(root: TreeNode) -> int: pass ``` # Definition for a binary tree node ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` # Input * `root`: The root node of the binary tree. # Output * An integer representing the maximum depth of the binary tree. # Constraints * The number of nodes in the tree is in the range `[0, 10^4]`. * `-100 <= Node.val <= 100` # Example ```python # Example 1: root1 = TreeNode(3) root1.left = TreeNode(9) root1.right = TreeNode(20) root1.right.left = TreeNode(15) root1.right.right = TreeNode(7) >>> max_depth(root1) 3 # Example 2: root2 = TreeNode(1) root2.left = TreeNode(2) >>> max_depth(root2) 2 # Example 3: root3 = None >>> max_depth(root3) 0 ``` # Explanation 1. In the first example, the depth of nodes 3 -> 20 -> 15 (or 20 -> 7) is 3. 2. In the second example, the depth of nodes 1 -> 2 is 2. 3. In the third example, there is no tree (root is None), so the depth is 0.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_depth(root: TreeNode) -> int: # If the root is None, the depth is 0 if root is None: return 0 # Recursively find the depth of the left and right subtrees left_depth = max_depth(root.left) right_depth = max_depth(root.right) # The depth of the current node is the maximum of the depths # of the left and right subtrees plus one for the current node return max(left_depth, right_depth) + 1"},{"question":"# Coding Assessment Question **Scenario**: You have been assigned to enhance a `Queue` class to incorporate additional features that make it more versatile and functional. These enhancements include support for circular queues, dynamic resizing, and methods to identify empty or full states. Your implementation should also efficiently handle various edge cases. **Requirements**: 1. **Circular Queue Support**: Modify the `Queue` class to function as a circular queue, enabling efficient use of space. 2. **Dynamic Resizing**: Implement a mechanism for the queue to automatically adjust its capacity based on the number of elements it holds. 3. **Full and Empty Checks**: Add methods to ascertain whether the queue is full or empty. 4. **Edge Case Handling**: Ensure edge cases, such as enqueueing to a full queue, dequeuing from an empty queue, and resizing operations, are managed effectively. **Function Implementation**: 1. **enqueue(value: int) -> None** - Parameter: - `value`: The value to be added to the queue. - Adds the specified value to the queue. Automatically resizes if the queue is full. 2. **dequeue() -> int** - Returns the value removed from the front of the queue. If the queue is empty, return `-1`. 3. **is_empty() -> bool** - Returns `True` if the queue is empty; otherwise, `False`. 4. **is_full() -> bool** - Returns `True` if the queue is full; otherwise, `False`. **Input**: ```python q = Queue(3) q.enqueue(10) q.enqueue(20) q.enqueue(30) print(q.dequeue()) # Should output 10 q.enqueue(40) print(q.dequeue()) # Should output 20 print(q.dequeue()) # Should output 30 print(q.dequeue()) # Should output 40 print(q.dequeue()) # Should output -1 (queue is empty) q.enqueue(50) q.enqueue(60) q.enqueue(70) print(q.is_full()) # Should output True q.enqueue(80) # Should dynamically resize the queue print(q.is_full()) # Should output False after resize print(q.dequeue()) # Should output 50 ``` **Output**: ```python 10 20 30 40 -1 True False 50 ``` **Constraints**: - The initial capacity of the queue provided in the constructor should be at least 1. - Values in the queue are between -1000 and 1000. - The dynamic resize should ideally double the capacity of the queue. - Ensure the implementation efficiently handles varying queue sizes and states. Verify your solution with various test cases, including edge conditions, to ensure robustness and correctness.","solution":"class Queue: def __init__(self, capacity): self.capacity = capacity self.queue = [None] * capacity self.head = 0 self.tail = 0 self.size = 0 def enqueue(self, value): if self.is_full(): self.resize() self.queue[self.tail] = value self.tail = (self.tail + 1) % self.capacity self.size += 1 def dequeue(self): if self.is_empty(): return -1 value = self.queue[self.head] self.queue[self.head] = None self.head = (self.head + 1) % self.capacity self.size -= 1 return value def is_empty(self): return self.size == 0 def is_full(self): return self.size == self.capacity def resize(self): new_capacity = self.capacity * 2 new_queue = [None] * new_capacity for i in range(self.size): new_queue[i] = self.queue[(self.head + i) % self.capacity] self.queue = new_queue self.capacity = new_capacity self.head = 0 self.tail = self.size"},{"question":"# Duplicate Integer Finder Background In many applications, it is essential to verify data integrity by ensuring that there are no duplicated entries in a dataset. Checking for duplicates can be particularly challenging with large sets of numbers. Objective You are to write a function that identifies and returns the first duplicate integer from a list. If there are no duplicates, the function should return `None`. Function Signature ```python def find_first_duplicate(nums: List[int]) -> int: pass ``` Input * `nums` (List[int]): A list of integers which may contain duplicates. The list can be empty or contain up to 10^6 elements. Output * Return an integer that is the first duplicate encountered in the list. If no duplicates exist, return `None`. Constraints * The integers in the list will be in the range representable by a 32-bit signed integer. Error Handling * You do not need to handle any errors outside of the given constraints. Examples ```python >>> find_first_duplicate([1, 2, 3, 4, 5, 3]) 3 >>> find_first_duplicate([1, 2, 3, 4, 5]) None >>> find_first_duplicate([5, 1, 2, 3, 5, 2, 1]) 5 >>> find_first_duplicate([10, 20, 20, 20]) 20 >>> find_first_duplicate([1]) None >>> find_first_duplicate([]) None ```","solution":"from typing import List def find_first_duplicate(nums: List[int]) -> int: Identifies and returns the first duplicate integer from a list. If no duplicates exist, returns None. seen = set() for num in nums: if num in seen: return num seen.add(num) return None"},{"question":"# Coding Challenge: Enhancing AVL Tree with Range Sum Query Context You have been provided with an efficient implementation of an AVL Tree, a self-balancing binary search tree. However, to extend its functionality, you need to incorporate an additional feature often required in advanced applications. Task You need to extend the `AVLTree` class with an additional function: 1. **Range Sum Query**: This operation calculates the sum of all values within a specified range [l, r]. Specifications **Operation: Range Sum Query** - **Function Signature**: `def range_sum(self, l, r):` - **Input**: `l` - The lower bound of the range (inclusive), `r` - The upper bound of the range (inclusive). - **Output**: It returns the sum of all values in the AVL tree that lie within the range [l, r]. Additional Requirements - Ensure that the AVL tree properties (balance factor and height) are intact after any modifications or insertions you perform. - Implement appropriate checks and modifications to maintain the AVL tree invariants. # Example Usage ```python # Initialize an AVL tree tree = AVLTree() # Insert elements tree.insert(10) tree.insert(20) tree.insert(30) tree.insert(40) tree.insert(50) tree.insert(25) # Perform range sum query print(tree.range_sum(10, 30)) # Should print the sum of values between 10 and 30 (inclusive) # Another range sum query print(tree.range_sum(15, 45)) # Should print the sum of values between 15 and 45 (inclusive) ``` # Constraints - Assume all values in the tree are unique. - Handle cases where the range [l, r] does not intersect with any values in the tree gracefully, returning 0 in such cases. - Performance requirements must adhere to the standard complexities of AVL tree operations, aiming for O(log n) complexity due to balanced nature of the tree. **Implementation Note**: Modify the `AVLTree` and `Node` classes as necessary to implement the new functionality, ensuring that insertion, deletion, and rotation operations maintain the AVL tree balance properties.","solution":"class Node: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 self.sum = key class AVLTree: def __init__(self): self.root = None def insert(self, root, key): if not root: return Node(key) if key < root.key: root.left = self.insert(root.left, key) else: root.right = self.insert(root.right, key) root.height = 1 + max(self.get_height(root.left), self.get_height(root.right)) root.sum = root.key + self.get_sum(root.left) + self.get_sum(root.right) balance = self.get_balance(root) # Left Left Case if balance > 1 and key < root.left.key: return self.right_rotate(root) # Right Right Case if balance < -1 and key > root.right.key: return self.left_rotate(root) # Left Right Case if balance > 1 and key > root.left.key: root.left = self.left_rotate(root.left) return self.right_rotate(root) # Right Left Case if balance < -1 and key < root.right.key: root.right = self.right_rotate(root.right) return self.left_rotate(root) return root def left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self.get_height(z.left), self.get_height(z.right)) y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) z.sum = z.key + self.get_sum(z.left) + self.get_sum(z.right) y.sum = y.key + self.get_sum(y.left) + self.get_sum(y.right) return y def right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self.get_height(z.left), self.get_height(z.right)) y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) z.sum = z.key + self.get_sum(z.left) + self.get_sum(z.right) y.sum = y.key + self.get_sum(y.left) + self.get_sum(y.right) return y def get_height(self, root): if not root: return 0 return root.height def get_balance(self, root): if not root: return 0 return self.get_height(root.left) - self.get_height(root.right) def get_sum(self, root): if not root: return 0 return root.sum def range_sum(self, l, r): return self._range_sum(self.root, l, r) def _range_sum(self, node, l, r): if not node: return 0 if node.key < l: return self._range_sum(node.right, l, r) elif node.key > r: return self._range_sum(node.left, l, r) return (node.key + self._range_sum(node.left, l, r) + self._range_sum(node.right, l, r)) # Helper method to insert values into the AVL tree def insert_values(tree, values): for value in values: tree.root = tree.insert(tree.root, value) tree = AVLTree() insert_values(tree, [10, 20, 30, 40, 50, 25]) print(tree.range_sum(10, 30)) # should print 85 print(tree.range_sum(15, 45)) # should print 115"},{"question":"# Coding Assessment: Analyze Movie Data from an API Objective You are required to write Python functions to fetch and analyze movie data from the Open Movie Database (OMDb) API using a movie title. Your solution should be efficient and handle potential errors gracefully. Requirements 1. **Function 1: `fetch_movie_data(title: str) -> dict`** - Input: - A string representing the movie title. - Output: - A dictionary containing the raw movie data fetched from the OMDb API. - Constraints: - If the title is invalid or data is not found, return an appropriate error message. 2. **Function 2: `analyze_movie_data(movie_data: dict) -> dict`** - Input: - A dictionary containing raw movie data. - Output: - A dictionary containing an analysis of the movie data including: - Title - Year of Release - Cast (list of actor names) - Director’s Name - Genre(s) - IMDB Rating - Plot Summary - Runtime Performance Requirements - Your solution should handle multiple API calls efficiently. - Consider handling any API delays or errors gracefully without breaking the program flow. Example ```python >>> movie_data = fetch_movie_data(\\"Inception\\") >>> analysis = analyze_movie_data(movie_data) >>> print(analysis) { \\"Title\\": \\"Inception\\", \\"Year of Release\\": \\"2010\\", \\"Cast\\": [\\"Leonardo DiCaprio\\", \\"Joseph Gordon-Levitt\\", \\"Elliot Page\\"], \\"Director’s Name\\": \\"Christopher Nolan\\", \\"Genre(s): [\\"Action\\", \\"Adventure\\", \\"Sci-Fi\\"], \\"IMDB Rating\\": \\"8.8\\", \\"Plot Summary\\": \\"A thief who steals corporate secrets through the use of dream-sharing technology...\\", \\"Runtime\\": \\"148 min\\" } ``` Notes 1. Pay attention to possible API restrictions and handle them properly using appropriate error messages. 2. Make sure that your analysis handles missing data gracefully and includes default values where necessary. Constraints - Ensure the movie title passed is a valid string. - Handle timeout scenarios and missing data fields properly.","solution":"import requests def fetch_movie_data(title: str) -> dict: Fetches movie data from the OMDb API using the provided movie title. Args: title (str): The title of the movie to fetch data for. Returns: dict: A dictionary containing the movie data or an error message. api_key = \'your_omdb_api_key\' url = f\\"http://www.omdbapi.com/?t={title}&apikey={api_key}\\" try: response = requests.get(url, timeout=5) response.raise_for_status() # Raise an HTTPError for bad responses data = response.json() if data.get(\'Response\') == \'False\': return {\\"Error\\": data.get(\'Error\', \'Movie not found\')} return data except requests.RequestException as e: return {\\"Error\\": str(e)} def analyze_movie_data(movie_data: dict) -> dict: Analyzes the input movie data and returns a dictionary with selected information. Args: movie_data (dict): The raw movie data. Returns: dict: A dictionary containing the analyzed movie data. if \\"Error\\" in movie_data: return movie_data # Return error message analysis = { \\"Title\\": movie_data.get(\\"Title\\", \\"N/A\\"), \\"Year of Release\\": movie_data.get(\\"Year\\", \\"N/A\\"), \\"Cast\\": movie_data.get(\\"Actors\\", \\"N/A\\").split(\\", \\") if movie_data.get(\\"Actors\\") else [\\"N/A\\"], \\"Director’s Name\\": movie_data.get(\\"Director\\", \\"N/A\\"), \\"Genre(s)\\": movie_data.get(\\"Genre\\", \\"N/A\\").split(\\", \\") if movie_data.get(\\"Genre\\") else [\\"N/A\\"], \\"IMDB Rating\\": movie_data.get(\\"imdbRating\\", \\"N/A\\"), \\"Plot Summary\\": movie_data.get(\\"Plot\\", \\"N/A\\"), \\"Runtime\\": movie_data.get(\\"Runtime\\", \\"N/A\\") } return analysis"},{"question":"# Scenario Imagine you are working on a text processing system and need to implement efficient string matching and substring extraction functionality. One common task is to find all occurrences of a given pattern within a text. # Task Implement the Aho-Corasick algorithm to process multiple string matching queries efficiently. Your implementation should be able to perform the following types of queries: 1. **Find Occurrences Query**: Locate all positions where a specific pattern appears in the text. 2. **Extract Substring Query**: Extract the substring from the text starting at a specific position and of a given length. 3. **Replace Occurrences Query**: Replace all occurrences of a specific pattern in the text with a new string. # Input and Output Format * **Input**: 1. `text` - A string representing the main text. 2. `queries` - A list of dictionary objects, each with: - `type` - One of `\'find_occurrences\'`, `\'extract_substring\'`, or `\'replace_occurrences\'`. - Additional parameters based on `type`: - For `\'find_occurrences\'`: `pattern` (substring to find). - For `\'extract_substring\'`: `start` (start position), `length` (number of characters). - For `\'replace_occurrences\'`: `pattern` (substring to replace), `replacement` (new substring). * **Output**: - A list of results, where each element is a list of integers (positions for occurrence queries) or a string (resulting text for extraction and replacement queries). # Constraints - The length of the `text` will be up to (10^6). - The number of queries will be up to (10^4). - Patterns and replacements will have a maximum length of (10^5). # Example ```python from typing import List, Dict, Union Query = Dict[str, Union[str, int]] def aho_corasick(queries: List[Query], text: str) -> List[Union[List[int], str]]: # Your implementation here to build the automaton and handle queries pass # Example usage: text = \\"abracadabra\\" queries = [ {\\"type\\": \\"find_occurrences\\", \\"pattern\\": \\"abra\\"}, {\\"type\\": \\"extract_substring\\", \\"start\\": 3, \\"length\\": 4}, {\\"type\\": \\"replace_occurrences\\", \\"pattern\\": \\"abra\\", \\"replacement\\": \\"magic\\"} ] print(aho_corasick(queries, text)) # Expected output: [[0, 7], \\"acad\\", \\"magiccadmagic\\"] ```","solution":"from collections import deque, defaultdict from typing import List, Dict, Union Query = Dict[str, Union[str, int]] class AhoCorasick: def __init__(self): self.num_nodes = 1 self.out = defaultdict(list) self.fail = defaultdict(int) self.goto = defaultdict(dict) def _add_pattern(self, pattern: str, index: int): current_state = 0 for symbol in pattern: if symbol not in self.goto[current_state]: self.goto[current_state][symbol] = self.num_nodes self.num_nodes += 1 current_state = self.goto[current_state][symbol] self.out[current_state].append(index) def _build_automaton(self, patterns: List[str]): for index, pattern in enumerate(patterns): self._add_pattern(pattern, index) queue = deque() for symbol in self.goto[0]: state = self.goto[0][symbol] queue.append(state) self.fail[state] = 0 while queue: r = queue.popleft() for symbol in self.goto[r]: s = self.goto[r][symbol] queue.append(s) state = self.fail[r] while state != 0 and symbol not in self.goto[state]: state = self.fail[state] if symbol in self.goto[state]: self.fail[s] = self.goto[state][symbol] else: self.fail[s] = 0 self.out[s].extend(self.out[self.fail[s]]) def search(self, text: str) -> List[List[int]]: current_state = 0 positions = [list() for _ in range(len(self.out))] for i, symbol in enumerate(text): while current_state != 0 and symbol not in self.goto[current_state]: current_state = self.fail[current_state] if symbol in self.goto[current_state]: current_state = self.goto[current_state][symbol] if current_state in self.out: for pattern_index in self.out[current_state]: positions[pattern_index].append(i) return positions def aho_corasick(queries: List[Query], text: str) -> List[Union[List[int], str]]: patterns = [query[\\"pattern\\"] for query in queries if query[\\"type\\"] == \\"find_occurrences\\"] ac = AhoCorasick() ac._build_automaton(patterns) found_positions = ac.search(text) results = [] for query in queries: if query[\\"type\\"] == \\"find_occurrences\\": pattern = query[\\"pattern\\"] pattern_index = patterns.index(pattern) pattern_length = len(pattern) positions = found_positions[pattern_index] actual_positions = [p - pattern_length + 1 for p in positions] results.append(actual_positions) elif query[\\"type\\"] == \\"extract_substring\\": start = query[\\"start\\"] length = query[\\"length\\"] results.append(text[start:start + length]) elif query[\\"type\\"] == \\"replace_occurrences\\": pattern = query[\\"pattern\\"] replacement = query[\\"replacement\\"] results.append(text.replace(pattern, replacement)) return results"},{"question":"Context A software company is building a server monitoring tool that periodically checks the CPU and memory usage of multiple servers to ensure they are operating within safe and expected thresholds. The tool should alert the administrators if any server exceeds specified CPU or memory usage limits. Task Your task is to implement a function called `monitor_servers` that will be responsible for checking the CPU and memory usage of a list of servers and identifying which servers exceed the defined thresholds. Function Signature ```python def monitor_servers( servers: dict[str, dict[str, int]], cpu_threshold: int, memory_threshold: int ) -> list[str]: ``` Input - `servers`: A dictionary where each key is a server identifier (a string), and the value is another dictionary with two keys: - `\'cpu\'`: an integer representing the current CPU usage percentage. - `\'memory\'`: an integer representing the current memory usage percentage. - `cpu_threshold`: An integer representing the maximum allowable CPU usage percentage. - `memory_threshold`: An integer representing the maximum allowable memory usage percentage. Output - A list of strings where each string is the identifier of a server that exceeds either the CPU threshold or the memory threshold. Constraints - Server identifiers will be unique strings. - CPU and memory usage percentages will range between 0 and 100. - Threshold values for both CPU and memory will also range between 0 and 100. - The number of servers ( n ) with ( 1 leq n leq 100 ). Example ```python servers = { \\"Server1\\": {\\"cpu\\": 85, \\"memory\\": 70}, \\"Server2\\": {\\"cpu\\": 60, \\"memory\\": 95}, \\"Server3\\": {\\"cpu\\": 45, \\"memory\\": 50}, \\"Server4\\": {\\"cpu\\": 90, \\"memory\\": 85} } cpu_threshold = 80 memory_threshold = 80 monitor_servers(servers, cpu_threshold, memory_threshold) # Output: [\'Server1\', \'Server2\', \'Server4\'] ``` Notes - The function should return the list of server identifiers in the order they appear in the input dictionary. - If no servers exceed the specified thresholds, the function should return an empty list. - Make sure to handle edge cases such as an empty dictionary of servers or threshold values set to 100, which means no servers will be considered beyond the threshold. Good luck and ensure the servers stay within safe operating limits!","solution":"def monitor_servers(servers, cpu_threshold, memory_threshold): This function checks a dictionary of servers for any that exceed the given CPU or memory thresholds. Args: servers (dict): A dictionary where the key is the server identifier (string) and the value is another dictionary with \'cpu\' and \'memory\' keys and corresponding usage percentages. cpu_threshold (int): Maximum allowable CPU usage percentage. memory_threshold (int): Maximum allowable memory usage percentage. Returns: list: A list of server identifiers (strings) that exceed either the CPU or memory thresholds. exceeded_servers = [] for server_id, usage in servers.items(): if usage[\'cpu\'] > cpu_threshold or usage[\'memory\'] > memory_threshold: exceeded_servers.append(server_id) return exceeded_servers"},{"question":"# Problem Statement You are given an integer array `arr` and another integer `k`. Your task is to rotate the array to the right by `k` steps. **Function Signature**: ```python def rotate_array(arr: List[int], k: int) -> List[int]: ``` # Input: - `arr`: A list of integers representing the array to be rotated. - `k`: An integer representing the number of positions to rotate the array by. # Output: - Returns the rotated list of integers. # Constraints: - `1 <= len(arr) <= 1000` (length of the array is within a reasonable range) - `-1000 <= arr[i] <= 1000` (elements of the array can be any integer) - `0 <= k <= 1000` (k is within the range of practical rotation steps) # Example: ```python assert rotate_array([1, 2, 3, 4, 5], 2) == [4, 5, 1, 2, 3] assert rotate_array([0, 1, 2], 4) == [2, 0, 1] ``` # Additional Information: - Rotating an array by `k` positions to the right means that every element in the array will be shifted `k` positions to the right, and elements that fall off the end will wrap around to the front of the array. - If `k` is larger than the length of the array, rotating by `k` steps is functionally the same as rotating by `k % len(arr)` steps, due to the wrap-around. # Note: - Consider both time and space complexity when designing your solution. - Aim to solve the problem with O(n) time complexity and O(1) additional space complexity if possible.","solution":"from typing import List def rotate_array(arr: List[int], k: int) -> List[int]: Rotate the array arr to the right by k steps. n = len(arr) k = k % n # Normalize k to avoid unnecessary full rotations return arr[-k:] + arr[:-k]"},{"question":"# Problem Statement You are tasked with writing a function that generates all possible unique permutations of a given string while maintaining the original order of the characters only for the first occurrence of each character. # Input Format 1. A single string `s` consisting of lowercase and uppercase English letters. # Output Format Return a list of all possible unique permutations of the string `s` that meet the criteria. # Constraints - The length of the string ( 1 leq len(s) leq 10 ) - The string will contain at least one character. # Example Example 1 ```python print(unique_ordered_permutations(\\"abc\\")) ``` Output: ``` [\'abc\', \'acb\', \'bac\', \'bca\', \'cab\', \'cba\'] ``` Example 2 ```python print(unique_ordered_permutations(\\"aab\\")) ``` Output: ``` [\'aab\', \'aba\', \'baa\'] ``` Example 3 ```python print(unique_ordered_permutations(\\"ABC\\")) ``` Output: ``` [\'ABC\', \'ACB\', \'BAC\', \'BCA\', \'CAB\', \'CBA\'] ``` # Function Signature ```python def unique_ordered_permutations(s: str) -> List[str]: # Your code here ``` # Notes - Use backtracking or a similar technique to generate all possible permutations. - Ensure that permutations are unique and characters\' original order is maintained for the initial occurrence. - Consider edge cases such as strings with all identical characters. --- Please write a function `unique_ordered_permutations` that meets the above requirements.","solution":"from itertools import permutations def unique_ordered_permutations(s: str): Generates all unique permutations of the string s while maintaining the original order of characters. unique_permutations = set(permutations(s)) return [\'\'.join(p) for p in unique_permutations]"},{"question":"# Question: Given the root of a binary tree, write a function `flatten_binary_tree_to_linked_list(root: Optional[Node]) -> None` to flatten the tree to a linked list in-place. The linked list should use the right pointers for traversal and follow the same order as a pre-order traversal of the binary tree. # Input and Output: * **Input**: `root`: the root node of the tree. * **Output**: This function should modify the tree in place without returning anything. # Constraints: * The number of nodes in the tree is in the range [1, 10^4]. * Each node\'s value is an integer within the range [-10^4, 10^4]. * It is guaranteed that the input tree is a valid binary tree. # Edge cases to consider: * A tree with only one node. * A tree where every node has only a left child. * A tree where every node has only a right child. # Function Signature: ```python from typing import Optional class Node: def __init__(self, data: int, left: Optional[Node] = None, right: Optional[Node] = None): self.data = data self.left = left self.right = right def flatten_binary_tree_to_linked_list(root: Optional[Node]) -> None: pass ``` # Example: ```python # Example 1 root = Node(1, Node(2, Node(3), Node(4)), Node(5, None, Node(6))) flatten_binary_tree_to_linked_list(root) # The tree should be modified to: # head -> 1 -> 2 -> 3 -> 4 -> 5 -> 6 # Example 2 root = Node(1, Node(2, Node(3))) flatten_binary_tree_to_linked_list(root) # The tree should be modified to: # head -> 1 -> 2 -> 3 ``` # Note: * You must do this in-place without using any extra space for another data structure, like arrays or lists.","solution":"from typing import Optional class Node: def __init__(self, data: int, left: Optional[\'Node\'] = None, right: Optional[\'Node\'] = None): self.data = data self.left = left self.right = right def flatten_binary_tree_to_linked_list(root: Optional[Node]) -> None: def flatten(node: Optional[Node]) -> Optional[Node]: if not node: return None if not node.left and not node.right: return node left_tail = flatten(node.left) right_tail = flatten(node.right) if left_tail: left_tail.right = node.right node.right = node.left node.left = None return right_tail if right_tail else left_tail flatten(root)"},{"question":"# Coding Assessment Question Problem Statement You are given a binary tree, where each node contains a positive integer value. Your task is to implement a function that calculates the maximum sum of nodes in any path from the root node to a leaf node. A path is defined as a sequence of nodes from the root to a leaf, and the sum is the total of the values of nodes along that path. Function Signature ```python def max_sum_path(root): Calculates the maximum sum of nodes in any path from root to leaf. Parameters: root (TreeNode): The root of the binary tree. Returns: int: The maximum sum of nodes from root to leaf. # your code here ``` Input Format - `root`: The root node of the binary tree. Output Format - An integer representing the maximum sum from the root to any leaf node. Constraints - The binary tree will have at least one node and at most (10^4) nodes. - Each node\'s value is a positive integer not exceeding (10^4). Example Given the binary tree: ``` 10 / 5 20 / / 3 8 2 25 ``` The maximum sum path is `10 -> 20 -> 25`, and calling `max_sum_path(root)` should return `55`. # Requirements 1. Implement a depth-first search (DFS) approach to traverse the tree. 2. At each step, calculate the sum of values from the root to each leaf. 3. Compare and keep track of the maximum sum encountered. 4. Return the maximum sum once all paths are evaluated. # Note 1. You may define a `TreeNode` class, if not provided, to represent the structure of each node in the binary tree: ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right ``` Ensure your implementation can handle binary trees with various structures and sizes efficiently.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def max_sum_path(root): Calculates the maximum sum of nodes in any path from root to leaf. Parameters: root (TreeNode): The root of the binary tree. Returns: int: The maximum sum of nodes from root to leaf. def helper(node): if not node: return 0 if not node.left and not node.right: return node.value left_sum = helper(node.left) if node.left else 0 right_sum = helper(node.right) if node.right else 0 return node.value + max(left_sum, right_sum) if not root: return 0 return helper(root)"},{"question":"# Context: You are given a pre-existing `BinarySearchTree` (BST) implementation. Your task is to enhance its functionality by adding methods to find the height of the tree and to balance an unbalanced tree. The balancing operation should transform the BST into a balanced binary search tree to ensure efficient search performance. # Problem: 1. Write a method `height(self)` that calculates and returns the height of the binary search tree. 2. Write a method `balance(self)` that balances the binary search tree. The method should restructure the tree into a balanced binary search tree, ensuring the height of the tree is minimized. # Implementation Details: - Class definition: `class BinarySearchTree:` - Methods to implement: * `def height(self):` * `def balance(self):` # Input: - `height()` takes no parameters. - `balance()` takes no parameters. # Output: - `height()` returns an integer representing the height of the tree. - `balance()` returns `None` but restructures the tree into a balanced binary search tree. # Constraints: - Assume each node in the BST has the following structure: ```python class TreeNode: def __init__(self, key, value): self.key = key self.value = value self.left = None self.right = None ``` - Internal implementation of the BST should handle nodes efficiently. - Do not use any built-in libraries or functions to auto-balance the tree. # Performance Requirements: - `height()` should have a time complexity of O(n), where n is the number of nodes in the tree. - `balance()` should have a time complexity of O(n), where n is the number of nodes in the tree. # Example Usage: ```python bst = BinarySearchTree() bst.insert(10, \'value10\') bst.insert(5, \'value5\') bst.insert(15, \'value15\') bst.insert(2, \'value2\') # Get the height of the tree print(bst.height()) # Output should be the height of the tree # Balance the binary search tree bst.balance() # Height after balancing print(bst.height()) # The height should now be minimal for a balanced BST ```","solution":"class TreeNode: def __init__(self, key, value): self.key = key self.value = value self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, key, value): if self.root is None: self.root = TreeNode(key, value) else: self._insert(self.root, key, value) def _insert(self, node, key, value): if key < node.key: if node.left is None: node.left = TreeNode(key, value) else: self._insert(node.left, key, value) else: if node.right is None: node.right = TreeNode(key, value) else: self._insert(node.right, key, value) def height(self): return self._height(self.root) def _height(self, node): if node is None: return -1 left_height = self._height(node.left) right_height = self._height(node.right) return 1 + max(left_height, right_height) def balance(self): nodes = [] self._in_order_traversal(self.root, nodes) self.root = self._build_balanced_bst(nodes, 0, len(nodes) - 1) def _in_order_traversal(self, node, nodes): if node is not None: self._in_order_traversal(node.left, nodes) nodes.append(node) self._in_order_traversal(node.right, nodes) def _build_balanced_bst(self, nodes, start, end): if start > end: return None mid = (start + end) // 2 node = nodes[mid] node.left = self._build_balanced_bst(nodes, start, mid - 1) node.right = self._build_balanced_bst(nodes, mid + 1, end) return node def to_array(self): # for testing purposes nodes = [] self._in_order_traversal(self.root, nodes) return [(node.key, node.value) for node in nodes]"},{"question":"# Problem Statement You are given a non-negative integer `x`. Write a Python function `reverse_bits(x: int) -> int` that takes `x`, a 32-bit unsigned integer, and returns the result of reversing the bits of `x`. # Input * A single integer `x` where ( 0 leq x < 2^{32} ). # Output * Return a single integer which is the result of reversing the bits of `x`. # Constraints * Your solution should ideally run in (O(1)) time. # Examples ```python def reverse_bits(x: int) -> int: # Your implementation here # Example 1 print(reverse_bits(43261596)) # Output: 964176192 # Example 2 print(reverse_bits(0)) # Output: 0 # Example 3 print(reverse_bits(1)) # Output: 2147483648 # Example 4 print(reverse_bits(4294967293)) # Output: 3221225471 ``` # Explanation - In the first example, the binary representation of 43261596 is `00000010100101000001111010011100`, and its reverse is `00111001011110000010100101000000` which corresponds to 964176192. - In the second example, the binary representation of 0 is `00000000000000000000000000000000`, and its reverse is the same, so the output is 0. - In the third example, the binary representation of 1 is `00000000000000000000000000000001`, and its reverse is `10000000000000000000000000000000` which corresponds to 2147483648. - In the fourth example, the binary representation of 4294967293 is `11111111111111111111111111111101`, and its reverse is `10111111111111111111111111111111` which corresponds to 3221225471. # Notes * Consider all bits, including leading zeros in the binary representation of the input integer. * You should focus on an efficient bit manipulation approach to reverse the bits.","solution":"def reverse_bits(x: int) -> int: Reverse the bits of a 32-bit unsigned integer. Args: x: int - a non-negative 32-bit unsigned integer Returns: int - the result of reversing the bits of x result = 0 for i in range(32): result = (result << 1) | (x & 1) x >>= 1 return result"},{"question":"# Coding Question **Context:** Working with strings and character manipulations is a common task in programming. Understanding how to efficiently process and transform strings is crucial for solving a wide range of problems. **Task:** You are required to implement a function `remove_duplicate_chars(s: str) -> str` that takes a string input, removes any duplicate characters, and returns the resulting string with only unique characters in the order of their first appearance. **Function Signature:** ```python def remove_duplicate_chars(s: str) -> str: ``` **Input:** * `s` (str): A string containing only printable ASCII characters. **Output:** * A string with all duplicate characters removed. **Constraints:** * The input string `s` can be empty. * The function should be case-sensitive. For example, \'A\' and \'a\' are considered different characters. * The order of characters in the output string should be the same as their first appearance in the input string. **Examples:** ```python >>> remove_duplicate_chars(\\"programming\\") \'progamin\' >>> remove_duplicate_chars(\\"abcabc\\") \'abc\' >>> remove_duplicate_chars(\\"\\") \'\' >>> remove_duplicate_chars(\\"aabbcc\\") \'abc\' >>> remove_duplicate_chars(\\"Hello, World!\\") \'Helo, Wrd!\' ``` **Edge Cases:** * An input of an empty string should return an empty string. * If the string contains all unique characters, the result should be the same as the input string. **Testing:** Use the following template to test your function: ```python if __name__ == \\"__main__\\": import doctest doctest.testmod() ```","solution":"def remove_duplicate_chars(s: str) -> str: Removes duplicate characters from the input string and returns the resulting string with only unique characters in the order of their first appearance. Args: s (str): A string containing only printable ASCII characters. Returns: str: A string with all duplicate characters removed. Example: >>> remove_duplicate_chars(\\"programming\\") \'progamin\' >>> remove_duplicate_chars(\\"abcabc\\") \'abc\' >>> remove_duplicate_chars(\\"\\") \'\' >>> remove_duplicate_chars(\\"aabbcc\\") \'abc\' >>> remove_duplicate_chars(\\"Hello, World!\\") \'Helo, Wrd!\' seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"# Assessment Question: Context: You are part of a team tasked with developing a text editor. One feature of the editor is the ability to automatically format selected words in a document. The user can select a range of words to capitalize in the document, based on their positions. Task: Implement a function `capitalize_range` that takes in a string representing the text document, along with integer positions marking the start and end word positions to be capitalized. The first word of the document is considered to be at position 1. # Function Signature: ```python def capitalize_range(document: str, start: int, end: int) -> str: ``` # Input: - `document`: a string representing the document, composed of words separated by single spaces. - `start`: an integer representing the starting word position (1-indexed, inclusive). - `end`: an integer representing the ending word position (1-indexed, inclusive). # Output: - Return a string with the specified range of words capitalized. # Constraints: - The words in `document` will only contain lowercase and uppercase English letters. - The start and end positions will always be valid and within the number of words in the document. - `1 <= start <= end <= number of words in document`. - The length of the document can range from 1 to 10^6 characters. # Example: ```python >>> document = \\"hello world this is a test document\\" >>> start = 2 >>> end = 4 >>> capitalize_range(document, start, end) \\"hello WORLD THIS IS a test document\\" >>> document = \\"one two three four\\" >>> start = 1 >>> end = 3 >>> capitalize_range(document, start, end) \\"ONE TWO THREE four\\" ``` # Requirements: - The function should split the document into words, capitalize the words in the specified range, and return the modified document as a single string. - Ensure that your function works efficiently with the maximum input size. Notes: - Be mindful of leading, trailing, and multiple spaces, though they won\'t be present in the input as per the constraints. - Do not alter the capitalization of words that are outside the specified range.","solution":"def capitalize_range(document: str, start: int, end: int) -> str: Capitalizes the words in the specified range [start, end] in the given document. Parameters: document (str): The document string. start (int): The starting word position (1-indexed, inclusive). end (int): The ending word position (1-indexed, inclusive). Returns: str: The document with specified range of words capitalized. words = document.split() for i in range(start - 1, end): words[i] = words[i].upper() return \' \'.join(words)"},{"question":"# Question: Implementing K-Nearest Neighbors from Scratch K-Nearest Neighbors (KNN) is a simple, instance-based learning algorithm used for classification and regression. In this implementation, you\'ll be required to write a custom KNN classifier from scratch without using any external machine learning libraries for the core KNN functionality. # Objective Implement the `KNearestNeighborsClassifier` class that supports basic KNN functionality. The class should be able to fit training data and predict classes for new data points. # Specifications 1. **Initialization**: - `__init__(self, n_neighbors: int = 3)`: Initialize the classifier with the number of neighbors. 2. **Fitting the Model**: - `fit(self, features: np.ndarray, target: np.ndarray) -> None`: Store the given features and target as training data. 3. **Predicting Values**: - `predict(self, features: np.ndarray) -> np.ndarray`: Predict the classes for the input data by finding the most common class among the nearest neighbors. 4. **Calculating Distance**: - `distance(self, point1: np.ndarray, point2: np.ndarray) -> float`: Compute the Euclidean distance between two data points. # Requirements: - **Input**: 2D numpy array `features` (shape: `(n_samples, n_features)`) and 1D numpy array `target` (shape: `(n_samples,)`). - **Output**: 1D numpy array of predictions with class labels for the input features. # Example ```python import numpy as np from sklearn.datasets import load_iris from sklearn.model_selection import train_test_split from sklearn.metrics import accuracy_score class KNearestNeighborsClassifier: def __init__(self, n_neighbors: int = 3): self.n_neighbors = n_neighbors def fit(self, features: np.ndarray, target: np.ndarray) -> None: self.features = features self.target = target def predict(self, features: np.ndarray) -> np.ndarray: return np.array([self._predict_single(sample) for sample in features]) def _predict_single(self, sample: np.ndarray) -> int: distances = [self.distance(sample, train_sample) for train_sample in self.features] neighbors_indices = np.argsort(distances)[:self.n_neighbors] neighbor_votes = self.target[neighbors_indices] return np.bincount(neighbor_votes).argmax() def distance(self, point1: np.ndarray, point2: np.ndarray) -> float: return np.sqrt(np.sum((point1 - point2) ** 2)) # Load dataset and prepare data iris = load_iris() X, y = iris.data, iris.target # Convert to binary classification (class 0 vs classes 1 and 2) X = X[y != 2] y = y[y != 2] # Split data into training and testing sets X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42) # Create and train KNN classifier knn = KNearestNeighborsClassifier(n_neighbors=3) knn.fit(X_train, y_train) # Make predictions and evaluate the model y_pred = knn.predict(X_test) accuracy = accuracy_score(y_test, y_pred) print(f\\"Accuracy: {accuracy:.2f}\\") ``` Implement the `KNearestNeighborsClassifier` so that the above example executes correctly.","solution":"import numpy as np class KNearestNeighborsClassifier: def __init__(self, n_neighbors: int = 3): self.n_neighbors = n_neighbors def fit(self, features: np.ndarray, target: np.ndarray) -> None: self.features = features self.target = target def predict(self, features: np.ndarray) -> np.ndarray: return np.array([self._predict_single(sample) for sample in features]) def _predict_single(self, sample: np.ndarray) -> int: distances = [self.distance(sample, train_sample) for train_sample in self.features] neighbors_indices = np.argsort(distances)[:self.n_neighbors] neighbor_votes = self.target[neighbors_indices] return np.bincount(neighbor_votes).argmax() def distance(self, point1: np.ndarray, point2: np.ndarray) -> float: return np.sqrt(np.sum((point1 - point2) ** 2))"},{"question":"# Event Scheduler with Conflict Resolution Design and implement a class `EventScheduler` that manages events based on their start and end times and resolves conflicts between events that overlap. Class Definition Implement the `EventScheduler` class with the following methods: - `add_event(name: str, start_time: int, end_time: int)`: Adds a new event to the scheduler. Events are represented by their name, start time, and end time. If there is a conflict with an existing event, throw a `ConflictError`. - `remove_event(name: str)`: Removes the event with the specified name. If the event is not found, throw an `EventNotFoundError`. - `get_events() -> List[Tuple[str, int, int]]`: Returns a list of all events as tuples of the form `(name, start_time, end_time)` sorted by start time. - `get_conflicting_events(start_time: int, end_time: int) -> List[str]`: Given a time range, returns a list of names of events that overlap with this range. Requirements: 1. The scheduler should handle up to 1000 events. 2. The class should efficiently manage event addition and conflict resolution. 3. Events have integer start and end times where `start_time < end_time`. 4. If an event with the same name is added again, replace the existing one only if the new event does not conflict with others. 5. Conflict detection should consider any overlap where one event starts before another one ends. ```python class ConflictError(Exception): pass class EventNotFoundError(Exception): pass class EventScheduler: def __init__(self): # Initialize your internal structures here pass def add_event(self, name: str, start_time: int, end_time: int) -> None: # Add your code here pass def remove_event(self, name: str) -> None: # Add your code here pass def get_events(self) -> List[Tuple[str, int, int]]: # Add your code here pass def get_conflicting_events(self, start_time: int, end_time: int) -> List[str]: # Add your code here pass # Example usage: # scheduler = EventScheduler() # scheduler.add_event(\\"Meeting\\", 9, 10) # scheduler.add_event(\\"Workout\\", 10, 11) # scheduler.add_event(\\"Lunch\\", 12, 13) # print(scheduler.get_events()) # scheduler.add_event(\\"Project Check-in\\", 9, 10) # ConflictError # scheduler.remove_event(\\"Lunch\\") # print(scheduler.get_events()) # print(scheduler.get_conflicting_events(9, 10)) ``` Implement the methods to satisfy the described functionality, managing events efficiently while ensuring robust conflict resolution and event retrieval.","solution":"class ConflictError(Exception): pass class EventNotFoundError(Exception): pass class EventScheduler: def __init__(self): self.events = {} def add_event(self, name: str, start_time: int, end_time: int) -> None: if any(self._is_conflict(e, start_time, end_time) for e in self.events.values()): raise ConflictError(\\"Event conflicts with an existing event.\\") self.events[name] = (start_time, end_time) def remove_event(self, name: str) -> None: if name not in self.events: raise EventNotFoundError(\\"Event not found.\\") del self.events[name] def get_events(self): return sorted([(name, st, et) for name, (st, et) in self.events.items()], key=lambda x: x[1]) def get_conflicting_events(self, start_time: int, end_time: int): return [name for name, (st, et) in self.events.items() if self._is_conflict((st, et), start_time, end_time)] def _is_conflict(self, event, start_time, end_time): return not (event[1] <= start_time or event[0] >= end_time)"},{"question":"# Inventory Management System: Restock Notification Your task is to implement a Python function that monitors the stock levels of items in an inventory and notifies when an item needs to be restocked. You will simulate inventory data and check against a specified threshold to determine when a restock is necessary. # Objectives - Check the current stock levels against a minimum threshold. - Return a list of items that need to be restocked. # Specifications 1. **Function Signature**: ```python def restock_notification(inventory: dict, threshold: int) -> list: ``` 2. **Inputs**: - `inventory` (dict): A dictionary where keys are item names and values are their stock counts (e.g., {\\"pencils\\": 10, \\"erasers\\": 3}). - `threshold` (int): The minimum stock level required. 3. **Outputs**: - `restock_list` (list): A list of item names that need to be restocked. If all items are above the threshold, return an empty list. # Constraints - The `inventory` dictionary and `threshold` are guaranteed to be non-empty and contain valid data. - Consider performance for large inventories (up to 10,000 items). # Example ```python assert restock_notification({\\"pencils\\": 10, \\"erasers\\": 3, \\"notebooks\\": 5}, 4) == [\\"erasers\\", \\"notebooks\\"] assert restock_notification({\\"pencils\\": 15, \\"erasers\\": 7}, 5) == [] ``` # Hints - Use dictionary comprehension or list comprehension for concise and efficient code. - Ensure the function handles edge cases, such as when no items need restocking. # Skeleton Code Template ```python def restock_notification(inventory: dict, threshold: int) -> list: restock_list = [item for item, count in inventory.items() if count < threshold] return restock_list # Sample usage if __name__ == \\"__main__\\": print(restock_notification({\\"pencils\\": 10, \\"erasers\\": 3, \\"notebooks\\": 5}, 4)) # Output: [\\"erasers\\", \\"notebooks\\"] print(restock_notification({\\"pencils\\": 15, \\"erasers\\": 7}, 5)) # Output: [] ```","solution":"def restock_notification(inventory: dict, threshold: int) -> list: Checks the current stock levels against a minimum threshold and returns a list of items that need to be restocked. Args: - inventory (dict): A dictionary with item names as keys and their stock counts as values. - threshold (int): The minimum stock level required. Returns: - list: A list of item names that need to be restocked. restock_list = [item for item, count in inventory.items() if count < threshold] return restock_list # Sample usage if __name__ == \\"__main__\\": print(restock_notification({\\"pencils\\": 10, \\"erasers\\": 3, \\"notebooks\\": 5}, 4)) # Output: [\\"erasers\\", \\"notebooks\\"] print(restock_notification({\\"pencils\\": 15, \\"erasers\\": 7}, 5)) # Output: []"},{"question":"# Knapsack Problem Problem Statement You are required to solve the classic Knapsack problem: given a set of items, each with a weight and a value, determine the maximum value that can be placed into a knapsack of a given capacity. Function Signature ```python def knapsack(values: list, weights: list, capacity: int) -> int: pass ``` Input * `values` is a list of integers where `values[i]` is the value of the i-th item. * `weights` is a list of integers where `weights[i]` is the weight of the i-th item. * `capacity` is a single integer representing the maximum weight that the knapsack can hold. Output * The function should return a single integer: * The maximum value that can be achieved with the given capacity. Constraints 1. 1 ≤ len(values) = len(weights) ≤ 100 2. 1 ≤ values[i], weights[i] ≤ 1000 3. 1 ≤ capacity ≤ 1000 Examples ```python >>> values = [60, 100, 120] >>> weights = [10, 20, 30] >>> capacity = 50 >>> knapsack(values, weights, capacity) 220 >>> values = [30, 14, 16, 9] >>> weights = [6, 3, 4, 2] >>> capacity = 10 >>> knapsack(values, weights, capacity) 46 >>> values = [10, 20, 30, 40] >>> weights = [1, 2, 3, 8] >>> capacity = 5 >>> knapsack(values, weights, capacity) 50 ``` Explanation 1. In the first example, the optimal solution is to take the two items with weights 20 and 30 achieving a maximum value of 220. 2. In the second example, the optimal solution is to take the items with weights 3, 4, and 2 achieving a total value of 46. 3. In the third example, the optimal solution is to take the items with weights 2 and 3 achieving a total value of 50.","solution":"def knapsack(values: list, weights: list, capacity: int) -> int: n = len(values) dp = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)] for i in range(1, n + 1): for w in range(capacity + 1): if weights[i - 1] <= w: dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weights[i - 1]] + values[i - 1]) else: dp[i][w] = dp[i - 1][w] return dp[n][capacity]"},{"question":"Task Question Creation for Coding Assessment # New Question **Scenario**: You are tasked with developing a function for checking overlapping schedules. In a workplace, employees may have varying schedules during the week. Each schedule is defined by a start time and an end time for a particular day. **Objective**: Your job is to implement a function `check_schedule_overlap(schedules: list[list[str]]) -> dict` to determine which employees have overlapping schedules. **Function Signature**: ```python def check_schedule_overlap(schedules: list[list[str]]) -> dict: # your code here ``` **Input**: * `schedules`: A list of lists where each inner list contains strings representing an employee\'s schedule. Each string inside the inner list is formatted as \\"Day Start-End\\", where: - `Day` is one of the days of the week (e.g., \\"Mon\\", \\"Tue\\", \\"Wed\\", \\"Thu\\", \\"Fri\\", \\"Sat\\", \\"Sun\\"). - `Start` and `End` are times in 24-hour format (e.g., \\"09:00\\", \\"18:00\\"). **Output**: * Returns a dictionary where the keys are tuples of employee indices (indicating the two employees whose schedules overlap) and the values are lists of days (strings) when the overlap occurs. **Constraints**: * Time intervals follow the format \\"HH:MM\\". Examples: \\"08:30\\", \\"17:45\\". * The schedules list will not have overlapping time intervals for a single employee. * The number of days per schedule does not exceed 7. * The employees are identified by their index in the outer list. * The schedules list may contain between 2 and 50 schedules, and each employee can have between 1 and 7 time intervals. **Edge Cases**: * No overlaps between any schedules. * Overlaps only on specific days. * Employees with non-consecutive schedules. # Example ```python schedules = [ [\\"Mon 09:00-11:00\\", \\"Tue 13:00-15:00\\", \\"Wed 09:00-11:00\\"], [\\"Mon 10:00-12:00\\", \\"Tue 14:00-16:00\\"], [\\"Mon 08:00-10:00\\", \\"Wed 10:00-12:00\\", \\"Fri 09:00-11:00\\"] ] check_schedule_overlap(schedules) # Returns: { # (0, 1): [\\"Mon\\", \\"Tue\\"], # (0, 2): [\\"Mon\\", \\"Wed\\"], # (1, 2): [\\"Mon\\"] # } schedules = [ [\\"Mon 09:00-11:00\\", \\"Tue 13:00-15:00\\"], [\\"Wed 10:00-12:00\\", \\"Thu 14:00-16:00\\"] ] check_schedule_overlap(schedules) # Returns: {} ``` Write your function to identify and record all overlaps efficiently. Ensure correct identification of overlaps for any given input within the constraints.","solution":"def check_schedule_overlap(schedules: list[list[str]]) -> dict: from collections import defaultdict def parse_schedule(schedule): day, time_range = schedule.split() start_time, end_time = map(lambda x: int(x.replace(\\":\\", \\"\\")), time_range.split(\'-\')) return day, start_time, end_time overlaps = defaultdict(list) for i in range(len(schedules)): for j in range(i + 1, len(schedules)): for sched1 in schedules[i]: day1, start1, end1 = parse_schedule(sched1) for sched2 in schedules[j]: day2, start2, end2 = parse_schedule(sched2) if day1 == day2 and not (end1 <= start2 or end2 <= start1): overlaps[(i, j)].append(day1) return overlaps"},{"question":"# Coding Assessment Question Context: The concept of Fibonacci sequence appears not only in mathematics but also in nature, art, and computer science. The Fibonacci sequence is defined such that each number is the sum of the two preceding ones, starting from 0 and 1. However, Fibonacci-like sequences can start with different pairs of numbers. Task: Implement a function `generalized_fibonacci` to compute the n-th term of a generalized Fibonacci sequence starting with any two given integers. The sequence is defined in the same way as the classical Fibonacci sequence, but with custom starting values. Specification: * **Function**: ```python def generalized_fibonacci(first: int, second: int, n: int) -> int: ``` * **Input**: * `first` - The first term of the sequence (int). * `second` - The second term of the sequence (int). * `n` - Which term to compute (int, ≥ 0). * **Output**: * Return the n-th term of the sequence as an integer. * **Constraints**: * If `n` is less than 0, raise an Exception: `n must be a non-negative integer`. * **Notes**: * The 0-th term is `first`. * The 1-st term is `second`. * For n > 1, the n-th term is the sum of the (n-1)-th and (n-2)-th terms. Examples: ```python >>> generalized_fibonacci(0, 1, 5) # classical Fibonacci sequence 5 >>> generalized_fibonacci(2, 3, 4) # sequence starts with 2, 3 10 >>> generalized_fibonacci(1, 1, 6) # sequence starts with 1, 1 13 >>> generalized_fibonacci(3, 7, 0) # 0-th term 3 >>> generalized_fibonacci(5, 8, -2) # invalid n Traceback (most recent call last): ... Exception: n must be a non-negative integer ```","solution":"def generalized_fibonacci(first: int, second: int, n: int) -> int: if n < 0: raise Exception(\\"n must be a non-negative integer\\") if n == 0: return first if n == 1: return second term_0, term_1 = first, second for _ in range(2, n + 1): term_0, term_1 = term_1, term_0 + term_1 return term_1"},{"question":"# Sum of Unique Elements Context You are given an array of integers. Your task is to find the sum of all unique elements (elements that appear exactly once in the array). Task Implement a function `sum_of_unique_elements(arr: List[int]) -> int`. The function should take a list of integers as input and return the sum of the elements that appear exactly once in the array. Input and Output Formats * **Input**: A list of integers, `arr` (1 <= len(arr) <= 10^4 and -10^6 <= arr[i] <= 10^6 for each integer arr[i]). * **Output**: An integer representing the sum of the unique elements in the list. Constraints * The length of the list will be at least 1 and at most 10^4. * The integers can range from -10^6 to 10^6. Example ```python assert sum_of_unique_elements([1, 2, 3, 2, 1, 4]) == 7 assert sum_of_unique_elements([10, 22, 10, 39, 22]) == 39 ``` # Performance Requirements * The solution should efficiently handle the upper limit of the input sizes within a reasonable time frame, ideally with a time complexity close to O(n) due to the constraints. Notes * Consider using a frequency counter to tally the occurrences of each element before computing the sum of unique elements. * Ensuring a linear time complexity will help manage the input size effectively. This question is aligned with the original set in terms of style, complexity, and scope. It explores a related area involving arrays and challenges the candidate to devise an efficient solution.","solution":"from typing import List def sum_of_unique_elements(arr: List[int]) -> int: Returns the sum of elements that appear exactly once in the array. from collections import Counter element_count = Counter(arr) unique_sum = sum(key for key, count in element_count.items() if count == 1) return unique_sum"},{"question":"# Scenario A software engineering team is working on a project that involves analyzing sequences of integers. They need a function to identify the longest contiguous subsequence within a list where the difference between consecutive integers is exactly one. You\'re tasked to implement this functionality. # Task Description Implement a function `longest_consecutive_subsequence` that takes a list of integers `input_list` and returns the longest contiguous subsequence where the difference between consecutive integers is exactly one. If there are multiple subsequences of the same maximum length, return the first one that appears. # Function Signature ```python def longest_consecutive_subsequence(input_list: List[int]) -> List[int]: pass ``` # Input * A single list of integers `input_list` that may contain both positive and negative values. # Output * A list of integers representing the longest contiguous subsequence where the difference between consecutive integers is exactly one. # Constraints * The input list `input_list` will contain at most 10^4 integers. # Example Example 1 ```python input_list = [1, 2, 3, 5, 6, 7, 8, 10] print(longest_consecutive_subsequence(input_list)) # Output: [5, 6, 7, 8] ``` Example 2 ```python input_list = [-1, 0, 1, 2, 4, 5, 7, 8] print(longest_consecutive_subsequence(input_list)) # Output: [-1, 0, 1, 2] ``` Example 3 ```python input_list = [10, 9, 4, 5, 6, 3, 2, 1, 0] print(longest_consecutive_subsequence(input_list)) # Output: [4, 5, 6] ``` Example 4 ```python input_list = [8, 9, 10, 11, 12, 0, -1, -2, -3] print(longest_consecutive_subsequence(input_list)) # Output: [8, 9, 10, 11, 12] ``` # Notes * Assume that the input list is non-empty. * You can use only Python\'s standard library to implement the solution.","solution":"from typing import List def longest_consecutive_subsequence(input_list: List[int]) -> List[int]: if not input_list: return [] longest_subseq = [] current_subseq = [] for i in range(len(input_list)): if i == 0 or input_list[i] == input_list[i-1] + 1: current_subseq.append(input_list[i]) else: if len(current_subseq) > len(longest_subseq): longest_subseq = current_subseq current_subseq = [input_list[i]] if len(current_subseq) > len(longest_subseq): longest_subseq = current_subseq return longest_subseq"},{"question":"# Coding Assessment Question: Context: A common task in data processing is the need to find a substring of text that meets certain criteria, especially when dealing with sequences or strings. This problem explores your ability to handle string manipulation and search algorithms. Given a string and a number, your task is to implement a function that identifies the longest substring composed of unique characters with a length that is less than or equal to the given number. Problem Statement: Write a Python function that, given a string `s` and an integer `k`, returns the longest substring composed of unique characters with a length that is less than or equal to `k`. If there are multiple substrings of the same maximum length, return the one that appears first. ```python def longest_unique_substring(s: str, k: int) -> str: Find the longest substring composed of unique characters with a length less than or equal to `k`. Args: s (str): The input string. k (int): The maximum allowable length for the substring. Returns: str: The longest substring with unique characters and length <= `k`. If multiple substrings have the same maximum length, return the first one. Examples: >>> longest_unique_substring(\\"abcabcbb\\", 3) \'abc\' >>> longest_unique_substring(\\"aaabbccccd\\", 2) \'ab\' >>> longest_unique_substring(\\"pwwkew\\", 3) \'wke\' # Implement your code here... ``` Constraints: - `s` will have at least one character and at most `10^4` characters. - `k` is a positive integer (1 <= k <= length of the string `s`). Expected output: - The solution returns the longest substring with unique characters that does not exceed the length `k`. Example: For `s = \\"abcabcbb\\"` and `k = 3`, the longest substring with unique characters is `\\"abc\\"`. Evaluation Criteria: Your solution will be evaluated based on: 1. Correctness: The function should return the appropriate substring. 2. Efficiency: The function should handle large strings efficiently. 3. Coding Style: Use clear and descriptive variable names, and ensure the code is readable and well-documented.","solution":"def longest_unique_substring(s: str, k: int) -> str: if not s or k <= 0: return \\"\\" n = len(s) longest_substring = \\"\\" for i in range(n): unique_chars = set() current_length = 0 for j in range(i, min(i + k, n)): if s[j] in unique_chars: break unique_chars.add(s[j]) current_length += 1 if current_length > len(longest_substring): longest_substring = s[i:i + current_length] return longest_substring"},{"question":"# Coding Assessment Question Problem Statement You are given the task of implementing a function to solve a system of linear equations using both the LU decomposition and the Gauss-Seidel iterative method. Your function should compare the results of these two methods with the built-in NumPy solver to ensure accuracy. Function Signature ```python import numpy as np from scipy.linalg import lu def validate_linear_solvers( matrices: list[np.ndarray], vectors: list[np.ndarray], tolerance: float = 1e-6, max_iterations: int = 500 ) -> bool: Validate the solution of linear systems using both LU decomposition and Gauss-Seidel method against NumPy\'s solver. Parameters ---------- matrices : list of np.ndarray List of NxN coefficient matrices. vectors : list of np.ndarray List of N-length right-hand side vectors. tolerance : float, optional Convergence tolerance for the Gauss-Seidel method (default is 1e-6). max_iterations : int, optional Maximum iterations allowed for the Gauss-Seidel method (default is 500). Returns ------- bool True if the solutions from both LU decomposition and Gauss-Seidel method are within the accepted tolerance for all given systems, False otherwise. ``` Detailed Requirements 1. **Input and Output**: - **Input**: - `matrices`: A list of square matrices (each NxN) representing the coefficient matrix for each system. - `vectors`: A list of right-hand side vectors (each of length N). - `tolerance`: A float, the tolerance for convergence in the Gauss-Seidel method. - `max_iterations`: An integer, the maximum number of iterations allowed for the Gauss-Seidel method. - **Output**: - Return a single boolean value indicating if all tests passed. 2. **Constraints**: - Each matrix must be square (NxN dimensions). - Each vector must be of compatible dimensions (length N). - Tolerance and iteration constraints must be respected. 3. **Performance Requirements**: - Efficiently handle multiple systems of linear equations. - Compare solutions obtained by LU decomposition and Gauss-Seidel with results from `numpy.linalg.solve`. - Ensure that the differences are within an acceptable tolerance. 4. **Scenario**: - Validate the correctness of the linear solvers for a set of coefficient matrices with various properties (positive definite, diagonally dominant, etc.). Example ```python def lu_solve(A: np.ndarray, b: np.ndarray) -> np.ndarray: P, L, U = lu(A) y = np.linalg.solve(L, np.matmul(P.T, b)) x = np.linalg.solve(U, y) return x def gauss_seidel_solve(A: np.ndarray, b: np.ndarray, tolerance: float, max_iterations: int) -> np.ndarray: n = len(A) x = np.zeros(n) for k in range(max_iterations): x_new = np.copy(x) for i in range(n): sum1 = np.dot(A[i, :i], x[:i]) sum2 = np.dot(A[i, i + 1:], x[i + 1:]) x_new[i] = (b[i] - sum1 - sum2) / A[i, i] if np.linalg.norm(x_new - x) < tolerance: return x_new x = x_new return x def validate_linear_solvers( matrices: list[np.ndarray], vectors: list[np.ndarray], tolerance: float = 1e-6, max_iterations: int = 500 ) -> bool: for A, b in zip(matrices, vectors): # Solve using LU decomposition x_lu = lu_solve(A, b) # Solve using Gauss-Seidel method x_gs = gauss_seidel_solve(A, b, tolerance, max_iterations) # Solve using NumPy\'s built-in solver x_np = np.linalg.solve(A, b) # Validate results if not np.allclose(x_lu, x_np, atol=tolerance): return False if not np.allclose(x_gs, x_np, atol=tolerance): return False return True # Example usage matrices = [np.array([[4, 1], [2, 3]]), np.array([[10, 2, 3], [2, 10, 4], [3, 4, 6]])] vectors = [np.array([1, 2]), np.array([7, 8, 9])] print(validate_linear_solvers(matrices, vectors)) # Should print: True ```","solution":"import numpy as np from scipy.linalg import lu def lu_solve(A: np.ndarray, b: np.ndarray) -> np.ndarray: P, L, U = lu(A) y = np.linalg.solve(L, np.dot(P.T, b)) x = np.linalg.solve(U, y) return x def gauss_seidel_solve(A: np.ndarray, b: np.ndarray, tolerance: float, max_iterations: int) -> np.ndarray: n = A.shape[0] x = np.zeros(n) for k in range(max_iterations): x_new = np.copy(x) for i in range(n): sum1 = A[i, :i].dot(x[:i]) sum2 = A[i, i+1:].dot(x[i+1:]) x_new[i] = (b[i] - sum1 - sum2) / A[i, i] if np.linalg.norm(x_new - x) < tolerance: return x_new x = x_new return x def validate_linear_solvers( matrices: list[np.ndarray], vectors: list[np.ndarray], tolerance: float = 1e-6, max_iterations: int = 500 ) -> bool: for A, b in zip(matrices, vectors): # Solve using LU decomposition x_lu = lu_solve(A, b) # Solve using Gauss-Seidel method x_gs = gauss_seidel_solve(A, b, tolerance, max_iterations) # Solve using NumPy\'s built-in solver x_np = np.linalg.solve(A, b) # Validate results if not np.allclose(x_lu, x_np, atol=tolerance): return False if not np.allclose(x_gs, x_np, atol=tolerance): return False return True"},{"question":"# Coding Question: Temperature Conversion and Classification You are tasked with developing a system that monitors and classifies temperature readings from various sensors. Your function should convert temperature values from Celsius to Fahrenheit and classify the temperature as \\"Cold\\", \\"Warm\\", or \\"Hot\\" based on its value in Celsius. **Problem Statement**: Write a function that converts a given temperature from Celsius to Fahrenheit and classifies the temperature. Function Signature ```python def convert_and_classify_temperature(celsius: float) -> Tuple[float, str]: Converts temperature from Celsius to Fahrenheit and classifies the temperature. Args: celsius (float): Temperature in degrees Celsius. Returns: Tuple[float, str]: Returns a tuple with: - fahrenheit (float): Temperature in degrees Fahrenheit. - classification (str): Classification of the temperature. Raises: ValueError: if the input temperature in Celsius is below absolute zero (-273.15). ``` Inputs: |Name | Units | Type | |--------|----------------------|-------| |celsius | (in degrees Celsius) | float | Outputs: |Name | Units | Type | |---------------|----------------------|-------| |fahrenheit | (in degrees Fahrenheit)| float | |classification | (Cold, Warm, Hot) | str | Constraints: 1. The input temperature in Celsius must not be below absolute zero (-273.15). 2. Use the formula `fahrenheit = celsius * 9/5 + 32` to convert Celsius to Fahrenheit. 3. Classify the temperature in Celsius as: - \\"Cold\\" if `celsius < 10` - \\"Warm\\" if `10 <= celsius <= 25` - \\"Hot\\" if `celsius > 25` Example: ```python >>> convert_and_classify_temperature(0) (32.0, \'Cold\') >>> convert_and_classify_temperature(20) (68.0, \'Warm\') >>> convert_and_classify_temperature(30) (86.0, \'Hot\') ``` **Note**: Ensure robust handling of invalid input by raising `ValueError` if the temperature in Celsius is below absolute zero (-273.15). **Performance Requirements**: * The time complexity should remain O(1), as both conversion and classification are computed using constant-time operations.","solution":"from typing import Tuple def convert_and_classify_temperature(celsius: float) -> Tuple[float, str]: Converts temperature from Celsius to Fahrenheit and classifies the temperature. Args: celsius (float): Temperature in degrees Celsius. Returns: Tuple[float, str]: Returns a tuple with: - fahrenheit (float): Temperature in degrees Fahrenheit. - classification (str): Classification of the temperature. Raises: ValueError: if the input temperature in Celsius is below absolute zero (-273.15). if celsius < -273.15: raise ValueError(\\"Temperature in Celsius cannot be below absolute zero (-273.15°C)\\") fahrenheit = celsius * 9/5 + 32 if celsius < 10: classification = \\"Cold\\" elif 10 <= celsius <= 25: classification = \\"Warm\\" else: classification = \\"Hot\\" return fahrenheit, classification"},{"question":"# Robot Path Tracker You are working on a robot simulation that involves tracking the robot\'s movements on a 2D grid. The robot starts at the origin (0, 0) and can move up, down, left, or right based on a series of commands. Write a program that computes the robot\'s final position after executing a sequence of movements. Function Signature: ```python def final_position(commands: List[str]) -> Tuple[int, int]: pass ``` Input: - `commands`: A list of strings where each string is a command that can either be \\"UP\\", \\"DOWN\\", \\"LEFT\\", or \\"RIGHT\\". Output: - Returns a tuple of two integers representing the final position of the robot on the 2D grid. Constraints: - The length of `commands` will not exceed 1000. - The commands list can be empty, in which case the robot remains at the origin. Example: ```python >>> final_position([\\"UP\\", \\"UP\\", \\"LEFT\\", \\"DOWN\\", \\"RIGHT\\", \\"RIGHT\\"]) (1, 1) >>> final_position([\\"UP\\", \\"UP\\", \\"DOWN\\", \\"DOWN\\", \\"LEFT\\", \\"LEFT\\"]) (-2, 0) ``` # Explanation: 1. For the first example, the robot moves: - \\"UP\\" to (0, 1) - \\"UP\\" to (0, 2) - \\"LEFT\\" to (-1, 2) - \\"DOWN\\" to (-1, 1) - \\"RIGHT\\" to (0, 1) - \\"RIGHT\\" to (1, 1) Thus, the final position is (1, 1). 2. For the second example, the robot moves: - \\"UP\\" to (0, 1) - \\"UP\\" to (0, 2) - \\"DOWN\\" to (0, 1) - \\"DOWN\\" to (0, 0) - \\"LEFT\\" to (-1, 0) - \\"LEFT\\" to (-2, 0) Thus, the final position is (-2, 0). Implement the `final_position` function to handle various combinations of movements and scenarios, ensuring the constraints and conditions are respected.","solution":"from typing import List, Tuple def final_position(commands: List[str]) -> Tuple[int, int]: x, y = 0, 0 for command in commands: if command == \\"UP\\": y += 1 elif command == \\"DOWN\\": y -= 1 elif command == \\"LEFT\\": x -= 1 elif command == \\"RIGHT\\": x += 1 return (x, y)"},{"question":"Palindromic Primes Detection Context A palindromic prime is a number that is both a palindrome and a prime. A palindrome is a number that reads the same forwards and backwards. For example, 131 is a palindromic prime because it is both a prime number and reads the same backward as forward. Write a function to determine if a given integer is a palindromic prime. Task Write a function `is_palindromic_prime(number: int) -> bool` that takes an integer as input and returns a boolean indicating whether the number is a palindromic prime. Input Format An integer `number` which can be: * positive or, * negative. Output Format A boolean value: * `True` if the number is a palindromic prime. * `False` otherwise. Constraints * The input must be an integer. * Handle both positive and negative integers. * Ensure the solution is efficient with a time complexity of (O(sqrt{n})) for the primality check and (O(log_{10}(n))) for the palindrome check. Example ```python >>> is_palindromic_prime(-2) False >>> is_palindromic_prime(2) True >>> is_palindromic_prime(3) True >>> is_palindromic_prime(11) True >>> is_palindromic_prime(101) True >>> is_palindromic_prime(131) True >>> is_palindromic_prime(10) False >>> is_palindromic_prime(12321) False ``` Constraints 1. Implement the function without using any external libraries for checking primality or finding palindromes. 2. Ensure robust error handling for non-integer inputs by raising an appropriate error. Note * You are not allowed to use libraries like `sympy` for primality checking. * Focus on writing clean and efficient code. Optional Extension Implement additional functions to: * Find and count all palindromic primes within a given range of integers.","solution":"def is_palindromic_prime(number: int) -> bool: Determines if the given number is a palindromic prime. :param number: An integer which can be positive or negative. :return: True if the number is a palindromic prime, False otherwise. if number < 2: return False def is_prime(n: int) -> bool: Checks if a number is prime. :param n: An integer greater than or equal to 2. :return: True if the number is prime, False otherwise. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def is_palindrome(n: int) -> bool: Checks if a number is a palindrome. :param n: An integer. :return: True if the number is a palindrome, False otherwise. str_n = str(n) return str_n == str_n[::-1] return is_prime(number) and is_palindrome(number)"},{"question":"# Problem Statement: Analyzing Water Distribution in a Pipeline Network You are tasked with verifying whether a given pipeline network has a balanced water distribution. A balanced network occurs when the sum of water inflow equals the sum of water outflow at every junction. # Function Signature ```python def is_network_balanced( inflow_matrix: list[list[int]], outflow_matrix: list[list[int]], threshold: float = 1e-1 ) -> bool: pass ``` # Detailed Requirements `is_network_balanced` Function 1. **Input**: - `inflow_matrix` (list[list[int]]): A 2D list where each sublist represents the inflows at each junction and each element represents the amount of water inflow through a specific pipeline connected to that junction. - `outflow_matrix` (list[list[int]]): A 2D list where each sublist represents the outflows at each junction and each element represents the amount of water outflow through a specific pipeline connected to that junction. - `threshold` (float): Optional; a tolerance level for numerical stability. Default is (1 times 10^{-1}). 2. **Output**: - Returns `True` if the network is balanced, otherwise returns `False`. 3. **Examples**: ```python >>> inflows = [[10, 5], [0], [15], [10]] >>> outflows = [[0], [5], [20], [15]] >>> is_network_balanced(inflows, outflows) False >>> inflows = [[10, 5], [5, 0], [0, 20], [15, 5]] >>> outflows = [[15], [5], [20], [20]] >>> is_network_balanced(inflows, outflows) True ``` # Constraints 1. Both the inflow and outflow matrices must have the same dimensions. 2. The inflow and outflow matrices must contain non-negative integers. 3. Each sublist in the inflow and outflow matrices represents the pipelines connected to a specific junction, and must have the same length for both matrices. # Notes - Ensure that the input matrices are properly formatted and are of compatible dimensions. - The algorithm should handle edge cases where junctions might have no inflow or outflow. - The implementation should take care of floating-point precision issues by using the specified `threshold` tolerance.","solution":"def is_network_balanced(inflow_matrix, outflow_matrix, threshold=1e-1): Determines whether the given network of pipelines is balanced in terms of water distribution. Args: inflow_matrix (list of list of int): 2D list where each sublist represents the inflows at each junction. outflow_matrix (list of list of int): 2D list where each sublist represents the outflows at each junction. threshold (float): Tolerance level for numerical stability. Default is 1e-1. Returns: bool: True if the network is balanced, otherwise False. for inflows, outflows in zip(inflow_matrix, outflow_matrix): if abs(sum(inflows) - sum(outflows)) > threshold: return False return True"},{"question":"# Problem Statement: Finding Unique Elements in List You are tasked with implementing a Python function to find unique elements in a given list. The function should return a list containing only the elements that appear exactly once in the input list, maintaining their original order of appearance. Function Signature ```python def find_unique_elements(arr: list) -> list: pass ``` Input - `arr` (list): A list of integers which can include both positive and negative numbers as well as zero. Output - Returns a list of integers that contains all and only the elements which appear exactly once in the input list, in their first occurrence order. Constraints - The length of the list `arr` is between 0 and 10^4. - The elements of `arr` are integers and can be both positive, negative as well as zero. Example ```python find_unique_elements([4, 5, 6, 5, 7, 4, 8, 6]) -> [7, 8] find_unique_elements([1, 2, 2, 3, 4, 4]) -> [1, 3] find_unique_elements([1, 1, 1, 2]) -> [2] find_unique_elements([7, 7, 8, 8, 9, 9]) -> [] find_unique_elements([]) -> [] ``` Instructions 1. Create a function to count the occurrences of each element in the input list. 2. Iterate over the input list and keep the elements that appear exactly once in a new list maintaining the first occurrence order. 3. Return the list that contains only the unique elements. Note - Use a dictionary or any other appropriate data structure to keep track of occurrences of each element. - Ensure your function handles edge cases such as empty lists and lists with all duplicate elements correctly. ```python def find_unique_elements(arr: list) -> list: # Your code here count = {} for num in arr: count[num] = count.get(num, 0) + 1 unique_elements = [num for num in arr if count[num] == 1] return unique_elements ```","solution":"def find_unique_elements(arr: list) -> list: Finds and returns a list of unique elements from the input list \'arr\'. An element is considered unique if it appears exactly once in the input list. count = {} # Count the occurrences of each element in the list for num in arr: count[num] = count.get(num, 0) + 1 # Collect elements that appear exactly once, maintaining their original order unique_elements = [num for num in arr if count[num] == 1] return unique_elements"},{"question":"# Question: E-commerce Inventory Management System You need to write a Python program that simulates a simple inventory management system for an e-commerce store. The system should allow the store manager to add, remove, update, and view items in the inventory. Requirements: 1. **Input**: - The program should provide a simple text-based menu interface for the user to interact with. - The user should be able to add new items, remove existing items, update item information, and view the list of all items. 2. **Item Details**: - Each item should have the following attributes: - `id`: A unique identifier (string) for the item. - `name`: The name of the item (string). - `quantity`: The number of units in stock (integer). - `price`: The price per unit (float). 3. **Inventory Actions**: - `Add Item`: Add a new item to the inventory. Ensure that the item id is unique. - `Remove Item`: Remove an item from the inventory using its id. - `Update Item`: Update the name, quantity, or price of an existing item. - `View Items`: Display the list of all items in the inventory, including their id, name, quantity, and price. 4. **Error Handling**: - The program should handle cases where the user tries to remove or update an item that does not exist. - Validate the user input to ensure correctness (e.g., quantity should be an integer, price should be a float). 5. **Storage**: - Initially, you can store the inventory in a simple list of dictionaries or a similar in-memory structure. Implementation Details: 1. **Helper Functions**: - Implement helper functions for each of the actions (e.g., add_item, remove_item, update_item, view_items) to keep the code organized. 2. **User Interface**: - The program should provide a clear and simple text-based interface for the user to navigate through the actions. 3. **Data Validation**: - Ensure that all inputs are validated (e.g., unique id for new items, valid types for quantity and price). # Example Usage: Upon running the script, the interface could look like this: ``` Welcome to the E-commerce Inventory Management System Please choose an action: 1. Add Item 2. Remove Item 3. Update Item 4. View Items 5. Exit ``` # Code Implementation: Implement your solution with the function signature given below: ```python def manage_inventory(): pass if __name__ == \\"__main__\\": manage_inventory() ``` # Sample Output: ``` Welcome to the E-commerce Inventory Management System Please choose an action: 1. Add Item 2. Remove Item 3. Update Item 4. View Items 5. Exit > 1 Enter item id: A001 Enter item name: Laptop Enter item quantity: 10 Enter item price: 999.99 Item added successfully! ``` Continue adding more interactions accordingly based on user choices.","solution":"def manage_inventory(): inventory = [] def add_item(): item_id = input(\\"Enter item id: \\").strip() for item in inventory: if item[\\"id\\"] == item_id: print(\\"An item with this id already exists.\\") return name = input(\\"Enter item name: \\").strip() try: quantity = int(input(\\"Enter item quantity: \\").strip()) price = float(input(\\"Enter item price: \\").strip()) except ValueError: print(\\"Invalid quantity or price format.\\") return inventory.append({\\"id\\": item_id, \\"name\\": name, \\"quantity\\": quantity, \\"price\\": price}) print(\\"Item added successfully!\\") def remove_item(): item_id = input(\\"Enter item id to remove: \\").strip() for i, item in enumerate(inventory): if item[\\"id\\"] == item_id: inventory.pop(i) print(\\"Item removed successfully!\\") return print(\\"Item not found.\\") def update_item(): item_id = input(\\"Enter item id to update: \\").strip() for item in inventory: if item[\\"id\\"] == item_id: name = input(\\"Enter new name: \\").strip() try: quantity = int(input(\\"Enter new quantity: \\").strip()) price = float(input(\\"Enter new price: \\").strip()) except ValueError: print(\\"Invalid quantity or price format.\\") return item[\\"name\\"] = name item[\\"quantity\\"] = quantity item[\\"price\\"] = price print(\\"Item updated successfully!\\") return print(\\"Item not found.\\") def view_items(): print(\\"Inventory:\\") for item in inventory: print(f\'ID: {item[\\"id\\"]}, Name: {item[\\"name\\"]}, Quantity: {item[\\"quantity\\"]}, Price: {item[\\"price\\"]}\') while True: print(\\"Please choose an action:\\") print(\\"1. Add Item\\") print(\\"2. Remove Item\\") print(\\"3. Update Item\\") print(\\"4. View Items\\") print(\\"5. Exit\\") action = input(\\"> \\").strip() if action == \\"1\\": add_item() elif action == \\"2\\": remove_item() elif action == \\"3\\": update_item() elif action == \\"4\\": view_items() elif action == \\"5\\": break else: print(\\"Invalid option. Please try again.\\") if __name__ == \\"__main__\\": manage_inventory()"},{"question":"# Number of Occurrences Challenge Given a list of integers, write a function that returns a dictionary where each key is an integer from the list, and the corresponding value is the number of times that integer appears in the list. # Function Signature ```python def count_occurrences(numbers: list[int]) -> dict[int, int]: pass ``` # Input * **numbers** (list of integers) - A list containing integers. # Output * **occurrence_dict** (dictionary) - A dictionary with integers from the list as keys and their counts as values. # Constraints * The length of the input list `numbers` will be between 0 and 10^6. * Each integer in the list `numbers` will be between -10^6 and 10^6. # Example ```python result = count_occurrences([1, 2, 2, 3, 1, 1, 4]) print(result) # Output: # {1: 3, 2: 2, 3: 1, 4: 1} result = count_occurrences([4, 4, 4, 4]) print(result) # Output: # {4: 4} result = count_occurrences([]) print(result) # Output: # {} ``` # Notes * The implementation should be efficient given the constraints that the input list can be quite large. * Your solution should handle edge cases such as an empty list properly.","solution":"def count_occurrences(numbers: list[int]) -> dict[int, int]: Returns a dictionary with the counts of each integer in the input list. occurrence_dict = {} for number in numbers: if number in occurrence_dict: occurrence_dict[number] += 1 else: occurrence_dict[number] = 1 return occurrence_dict"},{"question":"# Scenario You are tasked with developing a feature for a budgeting application that assists users in managing their expenses by categorizing and summarizing transactions by month. For this purpose, your task is to implement a function that calculates the total expense for each category for a given month. # Function Implementation Implement a function `summarize_expenses(transactions: List[Dict[str, Any]], month: str) -> Dict[str, float]` in Python that processes a list of transactions and outputs a summary of expenses grouped by category for the specified month. # Input and Output Formats * **Input**: 1. A list of dictionaries `transactions`, where each dictionary represents a transaction with the following keys: - `date`: A string in the format `\\"YYYY-MM-DD\\"` representing the date of the transaction. - `amount`: A float representing the amount of the transaction. - `category`: A string representing the category of the transaction. 2. A string `month` in the format `\\"YYYY-MM\\"` representing the month for which the expense summary needs to be calculated. * **Output**: A dictionary with category names as keys and the total expense (float) for that category in the specified month as values. # Constraints * All transaction dates will be valid dates. * Transaction amounts may be positive or negative. * Assume the categories are case-sensitive. # Requirements 1. Extract transactions that belong to the specified month. 2. Aggregate the total amount spent in each category. 3. Return a dictionary with the categories and their respective total expenses for the month. # Example ```python from typing import List, Dict, Any # Example Usage transactions = [ {\\"date\\": \\"2023-07-01\\", \\"amount\\": 50.0, \\"category\\": \\"Groceries\\"}, {\\"date\\": \\"2023-07-05\\", \\"amount\\": 20.0, \\"category\\": \\"Transport\\"}, {\\"date\\": \\"2023-07-07\\", \\"amount\\": 30.0, \\"category\\": \\"Groceries\\"}, {\\"date\\": \\"2023-08-01\\", \\"amount\\": 70.0, \\"category\\": \\"Bills\\"}, {\\"date\\": \\"2023-07-15\\", \\"amount\\": -10.0, \\"category\\": \\"Groceries\\"} ] print(summarize_expenses(transactions, \\"2023-07\\")) # Output: {\'Groceries\': 70.0, \'Transport\': 20.0} ``` # Detailed Steps 1. Parse the `transactions` list and filter the transactions that match the given `month`. 2. Initialize an empty dictionary to accumulate totals for each category. 3. Iterate through the filtered transactions, performing the following: - Extract the category and the amount. - Sum the amounts for each category. 4. Return the dictionary with each category\'s total expense for the specified month.","solution":"from typing import List, Dict, Any def summarize_expenses(transactions: List[Dict[str, Any]], month: str) -> Dict[str, float]: Summarizes the total expenses by category for a given month. :param transactions: List of transactions, where each transaction is a dictionary containing: - \\"date\\": A string in the format \\"YYYY-MM-DD\\". - \\"amount\\": A float representing the amount of the transaction. - \\"category\\": A string representing the category of the transaction. :param month: A string in the format \\"YYYY-MM\\" representing the month for summarizing expenses. :return: A dictionary with categories as keys and the total expenses for that category in the specified month as values. category_totals = {} for transaction in transactions: date = transaction[\\"date\\"] if date.startswith(month): category = transaction[\\"category\\"] amount = transaction[\\"amount\\"] if category in category_totals: category_totals[category] += amount else: category_totals[category] = amount return category_totals"},{"question":"# Coding Assessment Question **Objective**: Implement a function that checks if the elements of one list are a subsequence of another list. **Function Signature**: ```python def is_subsequence(subsequence: list, main_sequence: list) -> bool: pass ``` # Input & Output * **Input Format**: * `subsequence`: A list of elements to be checked as a subsequence. Elements may be of any type (integers, strings, etc.). * `main_sequence`: The list against which the subsequence is to be checked. Elements may be of any type and possibly different from `subsequence`. * **Output Format**: * A boolean value indicating whether `subsequence` is a subsequence of `main_sequence`. # Constraints * The total number of elements in both lists combined does not exceed (10^6). # Performance Requirements * Your implementation should handle the length efficiently within the given constraints. # Example 1. **Example 1**: * Input: `[1, 3, 4]`, `[1, 2, 3, 4, 5]` * Output: `True` 2. **Example 2**: * Input: `[\\"A\\", \\"C\\", \\"E\\"]`, `[\\"A\\", \\"B\\", \\"C\\", \\"D\\", \\"E\\"]` * Output: `True` 3. **Example 3**: * Input: `[3, 4, 1]`, `[1, 2, 3, 4, 5]` * Output: `False` 4. **Example 4**: * Input: `[]`, `[1, 2, 3, 4, 5]` * Output: `True` # Instructions * Implement the `is_subsequence` function according to the given requirements. * Ensure your function is efficient and handles edge cases effectively. * Do not print anything in the function; return the result directly.","solution":"def is_subsequence(subsequence: list, main_sequence: list) -> bool: Checks if the elements of `subsequence` are a subsequence of `main_sequence`. subseq_index = 0 main_seq_index = 0 while subseq_index < len(subsequence) and main_seq_index < len(main_sequence): if subsequence[subseq_index] == main_sequence[main_seq_index]: subseq_index += 1 main_seq_index += 1 return subseq_index == len(subsequence)"},{"question":"You are tasked with improving the function `compute_statistics` to enhance its accuracy and efficiency. The original function calculates and returns various statistical measures for a given list of numerical data, such as mean, median, mode, variance, and standard deviation. However, the function lacks optimization and does not handle edge cases or erroneous data gracefully. Objective Refactor the function `compute_statistics` to: 1. Handle lists with non-numeric values, empty lists, and lists with fewer elements gracefully. 2. Optimize performance for large datasets. 3. Include proper error handling and validation to ensure robust execution. Requirements - **Input**: - `data`: A list of numbers for which statistical measures need to be computed. - **Output**: - A dictionary containing the mean, median, mode, variance, and standard deviation. - **Constraints**: - Assume the input list can be extremely large (up to 10 million elements). - Ensure the function operates efficiently and does not consume excessive memory. Performance Requirements - Implement efficient algorithms for each statistical measure. - Ensure the computations are done in a way that minimizes memory usage and processing time. Edge Cases & Error Handling - Gracefully handle scenarios with non-numeric elements in the input list. - Handle empty or very small lists appropriately and return meaningful results or error messages. - Ensure the function can process large datasets without crashing. # Scenario You are analyzing a large dataset to derive key statistical insights. The function needs to be robust, accurate, and capable of handling various data quality issues without failing. Function Signature ```python def compute_statistics(data: list) -> dict: # Your improved implementation here ``` Example Consider the list `data = [1, 2, 2, 3, 4]`. ```python result = compute_statistics(data) ``` The result should be a dictionary similar to: ```python { \'mean\': 2.4, \'median\': 2, \'mode\': 2, \'variance\': 1.3, \'standard_deviation\': 1.14 } ``` The function should accurately compute and return the required statistical measures, handling any potential issues as described.","solution":"import statistics from collections import Counter def compute_statistics(data: list) -> dict: Compute various statistical measures (mean, median, mode, variance, standard deviation) for a given list of numbers. Parameters: data (list): List of numbers for which statistical measures are computed. Returns: dict: Dictionary containing mean, median, mode, variance, and standard deviation. try: # Ensure that all elements are numeric cleaned_data = [x for x in data if isinstance(x, (int, float))] if not cleaned_data: return { \'mean\': None, \'median\': None, \'mode\': None, \'variance\': None, \'standard_deviation\': None } data_count = len(cleaned_data) # Mean mean = statistics.mean(cleaned_data) # Median median = statistics.median(cleaned_data) # Mode mode = None try: mode = statistics.mode(cleaned_data) except statistics.StatisticsError: # When there is no unique mode mode = None # Variance and Standard Deviation variance = statistics.variance(cleaned_data) if data_count > 1 else 0.0 standard_deviation = statistics.stdev(cleaned_data) if data_count > 1 else 0.0 return { \'mean\': mean, \'median\': median, \'mode\': mode, \'variance\': variance, \'standard_deviation\': standard_deviation } except Exception as e: return { \'mean\': None, \'median\': None, \'mode\': None, \'variance\': None, \'standard_deviation\': None, \'error\': str(e) }"},{"question":"# Coding Question: Rotational Cipher Implementation **Context**: A Rotation Cipher, also known as a Caesar Cipher, is a type of substitution cipher in which each letter in the plaintext is \'rotated\' a fixed number of places down the alphabet. Non-letter characters should remain unaffected. The shift wraps around the end of the alphabet, so if the shift moves past \'z\', it starts again at \'a\'. Your task is to implement a function that takes a string and an integer shift value, then returns a new encrypted string using a rotational cipher. **Function Signature**: ```python def rotational_cipher(string: str, shift: int) -> str: ``` **Inputs**: 1. `string` (str): The input string to be encrypted. It may contain uppercase and lowercase letters, digits, spaces, and punctuation. 2. `shift` (int): The number of positions each letter in the string should be shifted. **Output**: A string representing the encrypted message. **Constraints**: * 1 <= len(string) <= 10^6 * -26 <= shift <= 26 **Example**: ```python >>> rotational_cipher(\\"Hello, World!\\", 3) \'Khoor, Zruog!\' >>> rotational_cipher(\\"abcd-xyz\\", -2) \'yzab-vwx\' >>> rotational_cipher(\\"Python 3.8\\", 4) \'Tyzlrs 3.8\' ``` **Requirements**: 1. Implement the rotational shift for both uppercase and lowercase letters. 2. Preserve non-alphabetic characters as they are. 3. Optimize for performance given the potential input size. 4. Handle negative shifts properly, which rotate characters to the left. **Additional Notes**: - Ensure the algorithm handles both positive and negative shifts by correctly wrapping letters within the alphabet. - Consider edge cases, such as an empty string or a zero shift which should return the original string.","solution":"def rotational_cipher(string: str, shift: int) -> str: Encrypts the input string using a rotational cipher with the given shift value. Args: string (str): The input string to be encrypted. shift (int): The number of positions each letter in the string should be shifted. Returns: str: Encrypted string using the rotational cipher. def shift_char(c, shift): if \'a\' <= c <= \'z\': return chr((ord(c) - ord(\'a\') + shift) % 26 + ord(\'a\')) elif \'A\' <= c <= \'Z\': return chr((ord(c) - ord(\'A\') + shift) % 26 + ord(\'A\')) else: return c # Non-alphabetical characters remain unchanged return \'\'.join(shift_char(c, shift) for c in string) # Usage examples: # print(rotational_cipher(\\"Hello, World!\\", 3)) # Khoor, Zruog! # print(rotational_cipher(\\"abcd-xyz\\", -2)) # yzab-vwx # print(rotational_cipher(\\"Python 3.8\\", 4)) # Tyzlrs 3.8"},{"question":"# Problem Statement: Given an array of integers where each element appears twice except for one element which appears only once, write a function to find that unique element. Implement an efficient algorithm that solves this problem with a linear runtime complexity and constant space complexity. # Function Requirements: 1. **`find_unique_element(arr: List[int]) -> int`**: - **Input**: - `arr` (list of integers): A list where each element appears exactly twice, except for one element which appears exactly once. - **Output**: - Return the unique element that appears only once as an integer. # Constraints: - The array will always contain at least one element. - The length of the array will be odd, guaranteeing a single unique element. - You may assume that the input list is non-empty and only contains integer values. - The function should run in O(n) time complexity and use O(1) extra space. # Example: ```python # Example 1 arr = [2, 3, 5, 4, 5, 3, 4] unique_element = find_unique_element(arr) assert unique_element == 2 # Example 2 arr = [1, 2, 3, 2, 3] unique_element = find_unique_element(arr) assert unique_element == 1 # Example 3 arr = [0, 1, 0] unique_element = find_unique_element(arr) assert unique_element == 1 ``` # Additional Requirements: - Ensure your implementation efficiently handles large arrays. - Use clear and concise comments to describe key steps in your algorithm. - Include test cases that check for edge cases, such as arrays with the smallest and largest possible sizes. # Hint: Consider using bitwise operations to solve this problem in linear time and constant space complexity.","solution":"from typing import List def find_unique_element(arr: List[int]) -> int: Returns the unique element that appears only once in the array. unique_element = 0 # XOR all elements. The duplicates will cancel out leaving the unique element. for num in arr: unique_element ^= num return unique_element"},{"question":"# Coding Question **Title: Identify Special Pythagorean Triples** **Background**: A Pythagorean triple consists of three positive integers (a), (b), and (c), such that (a^2 + b^2 = c^2). One such example is (3^2 + 4^2 = 9 + 16 = 25 = 5^2). However, for this problem, we are interested in finding special Pythagorean triples where (a < b < c) and (a + b + c = n). Write a Python function `special_pythagorean_triples(n: int) -> List[Tuple[int, int, int]]` that finds all sets of special Pythagorean triples for a given value of (n). **Function Signature**: ```python def special_pythagorean_triples(n: int) -> List[Tuple[int, int, int]]: ``` **Input**: - `n` (int): An integer representing the sum limit ( a + b + c ). (10 leq n leq 1000). **Output**: - (List[Tuple[int, int, int]]): A list of tuples, where each tuple contains a set of integers ((a, b, c)) representing a special Pythagorean triple. **Constraints**: - Ensure (a < b < c). - (a), (b), and (c) must be positive integers satisfying (a^2 + b^2 = c^2). **Examples**: ```python assert special_pythagorean_triples(30) == [(5, 12, 13)] assert special_pythagorean_triples(120) == [(20, 48, 52), (24, 45, 51), (30, 40, 50)] ``` **Implementation Guidelines**: 1. Iterate over possible values of (a) and (b) ensuring (a < b). 2. Calculate (c) based on the formula (c = n - a - b). 3. Check if the triple ((a, b, c)) satisfies the Pythagorean condition (a^2 + b^2 = c^2) and ensure (a < b < c). 4. Collect all such valid triples and return them. **Notes**: - Ensure to handle edge cases where no valid Pythagorean triple exists for the given (n). - The order of triples in the returned list does not matter. - Optimize to avoid unnecessary computations by breaking loops early if (a + b + c) exceeds (n).","solution":"from typing import List, Tuple def special_pythagorean_triples(n: int) -> List[Tuple[int, int, int]]: Returns a list of tuples of Pythagorean triples (a, b, c) such that a + b + c = n and a^2 + b^2 = c^2 with the condition a < b < c. triples = [] for a in range(1, n // 3): for b in range(a + 1, n // 2): c = n - a - b if c > b and a**2 + b**2 == c**2: triples.append((a, b, c)) return triples"},{"question":"# Coding Assessment Question As part of an e-commerce platform, you are asked to develop a function that not only calculates but also formats the cumulative sales statistics for a given list of orders. The function should calculate the total sales amount, the average order value, and count the number of orders placed. Additionally, it must handle input data validation and edge cases gracefully. Function Specifications You need to write a function `calculate_sales_stats` that generates sales statistics and handles various edge cases efficiently. **Function Signature**: ```python def calculate_sales_stats(orders: list[dict]) -> dict: ``` **Expected Input**: - `orders` (list of dict): A list where each item is a dictionary representing an order with the following structure: ```python { \\"id\\": \\"Order ID\\", \\"total_amount\\": \\"Total amount of the order\\" } ``` **Expected Output**: - Returns a dictionary with the following structure: ```python { \\"total_sales\\": \\"Total sales amount\\", \\"average_order_value\\": \\"Average order value\\", \\"order_count\\": \\"Number of orders\\" } ``` **Constraints**: - The function should perform input validation to ensure `orders` is a list of dictionaries and each dictionary contains valid `id` and `total_amount` fields. - Total sales and average order value should be formatted as strings representing currency (e.g., \\"1000.00\\"). - Handle cases where the `orders` list is empty by returning appropriate statistics. - Ensure the function is robust against invalid data (e.g., non-numeric `total_amount`). **Performance Requirements**: - Optimize for time complexity, ideally processing the list in a single pass. - Ensure the function can handle large lists of orders without significant performance degradation. **Context**: Envision you are developing an analytics dashboard for your e-commerce site. The formatted statistics will provide a clear and concise summary of sales performance. # Example Usage ```python orders = [ {\\"id\\": \\"001\\", \\"total_amount\\": \\"150.75\\"}, {\\"id\\": \\"002\\", \\"total_amount\\": \\"245.00\\"}, {\\"id\\": \\"003\\", \\"total_amount\\": \\"123.45\\"} ] result = calculate_sales_stats(orders) print(result) ``` # Example Output ```python { \\"total_sales\\": \\"519.20\\", \\"average_order_value\\": \\"173.07\\", \\"order_count\\": 3 } ``` # Notes: - The function should round to two decimal places where applicable. - Input data should be pre-validated to ensure that it adheres to the expected structure and value types. If any order data is invalid, it should be skipped in the computation.","solution":"def calculate_sales_stats(orders): Calculates and formats the total sales amount, average order value, and the number of orders from a given list of orders. # Initialize calculation variables total_sales = 0.0 valid_orders_counter = 0 for order in orders: if isinstance(order, dict) and \'total_amount\' in order: try: total_sales += float(order[\'total_amount\']) valid_orders_counter += 1 except (ValueError, TypeError): continue # Skip invalid total_amount values # Calculate average order value average_order_value = (total_sales / valid_orders_counter) if valid_orders_counter != 0 else 0.0 # Format values to currency format total_sales_formatted = f\\"{total_sales:.2f}\\" average_order_value_formatted = f\\"{average_order_value:.2f}\\" return { \\"total_sales\\": total_sales_formatted, \\"average_order_value\\": average_order_value_formatted, \\"order_count\\": valid_orders_counter }"},{"question":"# Problem Statement You are given a file containing several lines of text. Your task is to implement a function that reads the file and returns the `n` most frequent words in descending order of their frequency. If multiple words have the same frequency, they should be sorted alphabetically. # Requirements 1. Implement a function `top_n_frequent_words(file_path: str, n: int) -> list[str]` that reads the file and returns the `n` most frequent words. 2. Ignore case when counting frequencies (i.e., \\"Word\\" and \\"word\\" should be considered the same). 3. Ignore punctuation while counting frequencies. 4. If `n` is greater than the number of unique words, return all words sorted by frequency first and then alphabetically. 5. Handle edge cases such as empty files and files with less than `n` unique words gracefully. # Function Signature Complete the function `top_n_frequent_words` adhering to the following signature: ```python def top_n_frequent_words(file_path: str, n: int) -> list[str]: pass ``` # Input and Output * **Input**: * `file_path`: A string representing the path to the input file. * `n`: An integer representing the number of top frequent words to return. * **Output**: A list of the `n` most frequent words in descending order of frequency. # Constraints * The file contains up to 10^6 lines. * Each line has up to 100 words. * Words are delimited by spaces and may contain punctuation which should be ignored. * Words consist of alphabetical characters only after removing punctuation. # Example Suppose the content of the file \\"example.txt\\" is as follows: ``` Hello, this is a test. This test is only a test. Is this real? Is this just fantasy? Caught in a landslide, no escape from reality. ``` ```python >>> top_n_frequent_words(\\"example.txt\\", 3) [\\"is\\", \\"this\\", \\"test\\"] >>> top_n_frequent_words(\\"example.txt\\", 5) [\\"is\\", \\"this\\", \\"test\\", \\"a\\", \\"caught\\"] >>> top_n_frequent_words(\\"example.txt\\", 10) [\\"a\\", \\"caught\\", \\"escape\\", \\"fantasy\\", \\"from\\", \\"hello\\", \\"in\\", \\"is\\", \\"just\\", \\"landslide\\"] ``` # Notes * Focus on efficiently handling large input files. * Make sure to convert all words to lowercase before counting frequencies. * Use appropriate data structures to ensure the solution is efficient, especially for large inputs.","solution":"import string from collections import Counter def top_n_frequent_words(file_path: str, n: int) -> list[str]: def clean_word(word): return word.strip(string.punctuation).lower() with open(file_path, \'r\') as file: words = [] for line in file: words.extend(clean_word(word) for word in line.split()) word_counts = Counter(words) sorted_words = sorted(word_counts.items(), key=lambda x: (-x[1], x[0])) return [word for word, count in sorted_words[:n]]"},{"question":"```markdown # Problem Statement 2. **Function to Implement**: Write a function `run_length_encoding(s: str) -> str` that takes a single parameter: * `s` (str): A string consisting of only the characters \'a\' to \'z\' and \'A\' to \'Z\'. The function should return the run-length encoded string. # Constraints * 1 <= length of `s` <= 10^4 # Example ```python >>> run_length_encoding(\\"aaabccddd\\") \'a3b1c2d3\' >>> run_length_encoding(\\"wwwaaaadexyyyy\\") \'w3a4d1e1x1y4\' >>> run_length_encoding(\\"AaaaBBccD\\") \'A1a3B2c2D1\' ``` # Notes * The run-length encoding is case-sensitive, meaning \'a\' and \'A\' are considered distinct characters. * You may assume that the input string is non-empty. * If a character appears only once consecutively, it should still be followed by \'1\' in the output. # Task Breakdown 1. Iterate through the input string, keeping track of the count of each consecutive character. 2. Construct the resulting run-length encoded string. 3. Ensure the output string length does not exceed the input string length multiplied by 2. ```","solution":"def run_length_encoding(s): Returns the run-length encoded string of the input `s`. if not s: return \\"\\" encoded_string = [] current_char = s[0] current_count = 1 for char in s[1:]: if char == current_char: current_count += 1 else: encoded_string.append(current_char + str(current_count)) current_char = char current_count = 1 # Append the last character group encoded_string.append(current_char + str(current_count)) return \'\'.join(encoded_string)"},{"question":"# Context Sorting algorithms are fundamental concepts in computer science, with applications spanning from data organization to algorithm optimization. There exist various sorting methods, each with distinct time complexities and use cases. # Task You are required to implement a function that sorts a list of integers using the Merge Sort algorithm. Merge Sort is known for its stable and efficient O(n log n) time complexity. # Function Signature ```python def merge_sort(arr: list) -> list: Sorts a list of integers using the Merge Sort algorithm. Args: arr: A list of integers to be sorted. Returns: A new list containing the sorted integers. Raises: TypeError: If the input is not a list of integers. ``` # Constraints 1. The input list will contain integers, and it can be empty. 2. The input list can have up to 10^6 integers. 3. Time complexity should be O(n log n). # Input A list of integers `arr` with length `n` (0 ≤ n ≤ 10^6). # Output Return a new sorted list containing the same integers as in the input list, but in non-decreasing order. # Examples ```python >>> merge_sort([4, 1, 3, 9, 7]) [1, 3, 4, 7, 9] >>> merge_sort([10, 2, 8, 6, 7]) [2, 6, 7, 8, 10] >>> merge_sort([5, 5, 5, 2, 1]) [1, 2, 5, 5, 5] >>> merge_sort([]) [] ``` # Requirements - The function must use the Merge Sort algorithm. - It should handle lists with a large number of elements efficiently. - Consider edge cases like empty lists or lists with duplicate values. # Notes - The function should be pure, without modifying the input list. - Ensure that the implementation is recursive, as is standard for Merge Sort.","solution":"def merge_sort(arr): Sorts a list of integers using the Merge Sort algorithm. Args: arr: A list of integers to be sorted. Returns: A new list containing the sorted integers. Raises: TypeError: If the input is not a list of integers. if not isinstance(arr, list): raise TypeError(\\"Input should be a list of integers.\\") if not all(isinstance(x, int) for x in arr): raise TypeError(\\"All elements in the list should be integers.\\") if len(arr) <= 1: return arr def merge(left, right): sorted_list = [] left_index, right_index = 0, 0 while left_index < len(left) and right_index < len(right): if left[left_index] < right[right_index]: sorted_list.append(left[left_index]) left_index += 1 else: sorted_list.append(right[right_index]) right_index += 1 sorted_list.extend(left[left_index:]) sorted_list.extend(right[right_index:]) return sorted_list mid_point = len(arr) // 2 left_half = merge_sort(arr[:mid_point]) right_half = merge_sort(arr[mid_point:]) return merge(left_half, right_half)"},{"question":"# Coding Assessment Question In several data processing tasks, it is essential to analyze text and count the frequency of each word. Implementing an efficient word frequency counter is a common problem in natural language processing (NLP) that demands a mastery of dictionaries and string manipulation. Write a function `word_frequency_counter` that calculates the frequency of each word in a given text string while considering case insensitivity. The function should return the words in descending order of their frequency, with words having the same frequency sorted alphabetically. Function Signature: ```python def word_frequency_counter(text: str) -> dict: pass ``` # Input and Output - **Input**: - `text` - A string representing a passage of text. - **Output**: - Returns a dictionary where the keys are the words in lowercase and the values are their respective frequencies. # Constraints - Words are separated by spaces and can have punctuation attached to them (e.g., \\"word,\\" or \\"word.\\"). - Treat punctuation marks attached to words as part of the word. - The text string length will not exceed 10^6 characters. - Ignore special characters like emojis or other non-standard Unicode symbols. # Example ```python text = \\"Hello, world! Hello, everyone. Welcome to the world of self-learning.\\" result = word_frequency_counter(text) print(result) # Expected Output: # { # \\"hello,\\": 2, # \\"world!\\": 1, # \\"everyone.\\": 1, # \\"welcome\\": 1, # \\"to\\": 1, # \\"the\\": 1, # \\"world\\": 1, # \\"of\\": 1, # \\"self-learning.\\": 1 # } ``` # Requirements & Performance - **Word Counting**: - Consider case insensitivity by converting all words to lowercase. - Handle words with any punctuation as distinct entities without stripping the punctuation. - **Sorting**: - After counting, sort the words by their frequency in descending order. - If two words have the same frequency, sort them alphabetically in ascending order. - **Efficiency**: - Aim for an efficient implementation that processes the input text in linear time. Use appropriate data structures for word counting and sorting to achieve optimal performance. Make sure your solution can handle large text inputs efficiently and deals appropriately with punctuation within the text.","solution":"def word_frequency_counter(text: str) -> dict: from collections import defaultdict # Convert the text to lowercase to handle case insensitivity text = text.lower() # Split text into words words = text.split() # Use a dictionary to count the frequency of each word word_count = defaultdict(int) for word in words: word_count[word] += 1 # Sort the words by frequency (descending) and then alphabetically (ascending) sorted_word_count = dict(sorted(word_count.items(), key=lambda item: (-item[1], item[0]))) return sorted_word_count"},{"question":"# Scenario Bob is developing a text editor and wants to implement a feature that highlights the longest substring of unique characters in any given string. He\'s asking for your help to write a function that can determine this for him efficiently. # Coding Task Write a function `longest_unique_substring(s: str) -> str` that finds the longest substring in the given string `s` where all characters are unique. Return this substring. # Input and Output Format - **Input**: - `s` (a string consisting of ASCII characters, length 1 ≤ len(s) ≤ 1000) - **Output**: - A string representing the longest substring with all unique characters. If there are multiple substrings with the same length, return the first one found. # Constraints and Assumptions: - The given string `s` will contain any printable ASCII characters. - The length of the output substring will be at least 1, as there is at least one unique character in every input string. # Example - Example 1: - `s = \\"abcabcbb\\"` - Output: `\\"abc\\"` (The first longest substring where all characters are unique) - Example 2: - `s = \\"bbbbb\\"` - Output: `\\"b\\"` (Only one unique character in the repeating string) - Example 3: - `s = \\"pwwkew\\"` - Output: `\\"wke\\"` (The first longest substring with unique characters) **Note**: Consider using an efficient algorithm to handle the worse cases, especially for strings close to the maximum length. # Approach To solve this problem, you may use a sliding window and utilize a set to track the characters in the current window, adjusting the window size as needed to maintain only unique characters while maximizing the length of the substring.","solution":"def longest_unique_substring(s: str) -> str: Returns the longest substring with all unique characters. start = 0 max_len = 0 max_substr = \\"\\" seen_chars = {} for end, char in enumerate(s): if char in seen_chars and seen_chars[char] >= start: start = seen_chars[char] + 1 seen_chars[char] = end if end - start + 1 > max_len: max_len = end - start + 1 max_substr = s[start:end + 1] return max_substr"},{"question":"# Coding Assessment Question As a meteorologist, you often rely on accurate and up-to-date weather data to forecast the weather. To make sense of the data, it’s important to identify trends and patterns. One useful metric is the \\"temperature consistency\\" across a range of days. To help with this, you decide to write a program that can calculate the consistency of temperature readings over a specified period. Given a list of daily temperatures, your task is to implement a function that returns the number of consistent \\"subranges\\" in the list. A \\"subrange\\" is defined as a contiguous portion of the list where the temperature either continuously increases or continuously decreases by exactly 1 degree each day. For example, in the temperature list `[3, 2, 1, 2, 3]`, the subranges `3, 2, 1` and `1, 2, 3` both qualify as consistent subranges. Function Signature ```python def count_temperature_subranges(temperatures: List[int]) -> int: ``` Input - `temperatures`: A list of integers representing daily temperatures. Output - Return an integer representing the number of consistent subranges found in the list. Constraints - The length of the list can range from 2 to 1000. - The temperature values will be within the range of -100 to 100. Examples 1. `count_temperature_subranges([1, 2, 3, 4, 5])` should return `4` (subranges: [1,2], [2,3], [3,4], [4,5]). 2. `count_temperature_subranges([5, 4, 3, 2, 3, 4, 5])` should return `6` (subranges: [5,4], [4,3], [3,2], [2,3], [3,4], [4,5]). 3. `count_temperature_subranges([10, 9, 8, 8, 9, 10])` should return `4` (subranges: [10,9], [9,8], [8,9], [9,10]). Implement the function `count_temperature_subranges` to find the number of consistent subranges in a given list of temperature readings.","solution":"from typing import List def count_temperature_subranges(temperatures: List[int]) -> int: Returns the number of consistent subranges in the list of temperatures. A consistent subrange is a contiguous portion of the list where the temperature either continuously increases or continuously decreases by exactly 1 degree each day. count = 0 n = len(temperatures) i = 0 while i < n - 1: if abs(temperatures[i] - temperatures[i + 1]) == 1: start = i while i < n - 1 and abs(temperatures[i] - temperatures[i + 1]) == 1: i += 1 count += (i - start) else: i += 1 return count"},{"question":"# Scenario You are developing a software system for an online bookstore. One of the key features of this system is to provide customer recommendations based on book ratings. The recommendation algorithm should identify books that have the highest average rating and return them in a sorted list. # Problem Statement Write a function `top_rated_books` that processes a list of books with their ratings and returns the top N books with the highest average ratings. If two or more books have the same average rating, they should be sorted alphabetically by title. # Function Signature ```python def top_rated_books(books: List[Tuple[str, List[int]]], N: int) -> List[str]: Parameters: 1. books (List[Tuple[str, List[int]]]): A list of tuples where each tuple contains: - a string representing the book title. - a list of integers representing the ratings for that book. 2. N (int): The number of top-rated books to return. Returns: List[str]: A list of strings representing the titles of the top N books with the highest average ratings. If N is greater than the number of books, return the titles of all the books sorted by average rating. Raises: ValueError: If N is less than or equal to zero or if the books list is empty. ``` # Input * `books` is a list of tuples. Each tuple contains: * A string representing the book title. * A list of integers representing the ratings for that book (at least one rating). * `N` is a positive integer indicating the number of top-rated books to return. # Output * A list of strings representing the titles of the top N books with the highest average ratings. If multiple books have the same average rating, they should be sorted alphabetically by their title. # Constraints * Ensure `N` is positive. * Ensure each book has at least one rating. # Examples ```python # Example 1 books = [ (\\"Book A\\", [5, 4, 4]), (\\"Book B\\", [5, 5, 4]), (\\"Book C\\", [4, 4, 5]), (\\"Book D\\", [5, 5, 5]) ] results = top_rated_books(books, 2) print(results) # Expected output: [\'Book D\', \'Book B\'] # Example 2 books = [ (\\"Learn Python\\", [5, 4, 3]), (\\"Advanced Python\\", [4, 4, 4]), (\\"Python Algorithms\\", [5, 5]) ] results = top_rated_books(books, 3) print(results) # Expected output: [\'Python Algorithms\', \'Advanced Python\', \'Learn Python\'] # Edge Case 1 books = [ (\\"One Book\\", [3]) ] results = top_rated_books(books, 1) print(results) # Expected output: [\'One Book\'] # Edge Case 2 try: books = [ (\\"Book A\\", [4, 4, 4]), (\\"Book B\\", [5, 5, 5]) ] results = top_rated_books(books, 0) except ValueError as e: print(e) # Expected: N must be positive. # Edge Case 3 try: results = top_rated_books([], 1) except ValueError as e: print(e) # Expected: Book list cannot be empty. ``` # Additional Notes You should raise appropriate exceptions for invalid inputs according to the constraints described.","solution":"from typing import List, Tuple def top_rated_books(books: List[Tuple[str, List[int]]], N: int) -> List[str]: if N <= 0: raise ValueError(\\"N must be positive.\\") if not books: raise ValueError(\\"Book list cannot be empty.\\") # Calculate the average rating for each book avg_ratings = [ (title, sum(ratings) / len(ratings)) for title, ratings in books ] # Sort the books first by average rating (descending) and then by title (alphabetically) sorted_books = sorted(avg_ratings, key=lambda x: (-x[1], x[0])) # Extract the titles of the top N books top_books = [title for title, rating in sorted_books[:N]] return top_books"},{"question":"# Recommendation System Implementation You have been asked to implement a basic recommendation system using collaborative filtering. Your system will take user-item ratings and predict the ratings for items that a user has not yet rated. You will use the provided ratings data to create a function that can predict ratings and evaluate the accuracy of your predictions. Instructions 1. Implement a function `predict_ratings` that takes the matrix of user-item ratings, with rows corresponding to users and columns to items. This function should: * Compute the pairwise similarity between users using cosine similarity. * Predict the ratings for each user-item pair by considering the weighted average of ratings given by similar users. * Return a matrix of the same shape as the input, with predicted ratings replacing the missing values (typically represented as `0`). 2. Implement a function `evaluate_accuracy` that takes the original ratings matrix and the predicted ratings matrix. This function should: * Calculate and return the Root Mean Squared Error (RMSE) between the non-zero values of the original ratings matrix and the corresponding values in the predicted ratings matrix. Expected Input and Output * **Input**: * A 2D numpy array `ratings` of shape (num_users, num_items), where ratings[i][j] is the rating given by user i to item j, or `0` if no rating is given. * **Output**: * The `predict_ratings` function returns a matrix of the same shape as the input with predicted ratings. * The `evaluate_accuracy` function returns a single float representing the RMSE between the actual and predicted ratings. Performance Requirements * Ensure your functions work efficiently on datasets with up to 1,000 users and 1,000 items. Example ```python import numpy as np from sklearn.metrics.pairwise import cosine_similarity import numpy.linalg as LA def predict_ratings(ratings): # Compute user similarity matrix user_similarity = cosine_similarity(ratings) # Predict ratings pred_ratings = np.zeros_like(ratings) for i in range(ratings.shape[0]): for j in range(ratings.shape[1]): if ratings[i, j] == 0: # Compute weighted average based on similarity sim_total = np.sum(user_similarity[i, :]) weighted_sum = np.dot(user_similarity[i, :], ratings[:, j]) pred_ratings[i, j] = weighted_sum / sim_total if sim_total != 0 else 0 else: pred_ratings[i, j] = ratings[i, j] return pred_ratings def evaluate_accuracy(actual, predicted): # Mask for actual ratings values mask = actual > 0 diff = actual[mask] - predicted[mask] mse = np.mean(diff ** 2) return np.sqrt(mse) # Example usage ratings_matrix = np.array([ [5, 3, 0, 1], [4, 0, 0, 1], [1, 1, 0, 5], [1, 0, 0, 4], [0, 1, 5, 4], ]) predicted_ratings = predict_ratings(ratings_matrix) rmse = evaluate_accuracy(ratings_matrix, predicted_ratings) print(f\\"Predicted ratings:n{predicted_ratings}\\") print(f\\"RMSE: {rmse}\\") ``` You are expected to implement the `predict_ratings` and `evaluate_accuracy` functions and demonstrate their usage with a ratings matrix example of your choice.","solution":"import numpy as np from sklearn.metrics.pairwise import cosine_similarity def predict_ratings(ratings): Predict ratings for each user-item pair by considering the weighted average of ratings given by similar users using cosine similarity. Parameters: - ratings (np.ndarray): 2D array of user-item ratings, where 0 indicates no rating. Returns: - np.ndarray: Predicted ratings matrix of the same shape as input. # Compute user similarity matrix user_similarity = cosine_similarity(ratings) # Predict ratings using the weighted sum of similarities pred_ratings = np.zeros_like(ratings, dtype=np.float64) for i in range(ratings.shape[0]): for j in range(ratings.shape[1]): if ratings[i, j] == 0: # Compute weighted average based on similarity weighted_sum = np.dot(user_similarity[i, :], ratings[:, j]) sim_total = np.sum(user_similarity[i, :]) pred_ratings[i, j] = weighted_sum / sim_total if sim_total != 0 else 0 else: pred_ratings[i, j] = ratings[i, j] return pred_ratings def evaluate_accuracy(actual, predicted): Calculate the Root Mean Squared Error (RMSE) between the non-zero values of the actual and predicted ratings matrices. Parameters: - actual (np.ndarray): Original user-item ratings matrix. - predicted (np.ndarray): User-item ratings matrix with predicted values. Returns: - float: RMSE value. mask = actual > 0 diff = actual[mask] - predicted[mask] mse = np.mean(diff ** 2) return np.sqrt(mse)"},{"question":"# CSV Column Filter Function Implement a function to filter columns of a CSV file based on a given list of column indices. The function should read the CSV file, retain only the specified columns, and save the result to a new CSV file. Ensure the implementation handles large files efficiently and adheres to given constraints. Function Signature ```python def filter_csv_columns(input_file: str, output_file: str, columns: List[int]) -> None: Filter columns of a CSV file based on provided column indices. ``` Input * `input_file` (string): Path to the input CSV file. * `output_file` (string): Path to the output CSV file, where the filtered data should be saved. * `columns` (List[int]): List of zero-based column indices to retain. Output * A new CSV file at `output_file` containing only the specified columns from the input file. Constraints and Requirements * The function should raise a `ValueError` if any column index in `columns` is out of bounds for the input file. * The function should handle large files efficiently, reading and writing line by line to avoid memory overload. * Time complexity should be O(m) where \'m\' is the number of rows in the input file. * Additional space complexity should remain O(1) beyond input and output file storage. Example ```python input_file = \\"path/to/input.csv\\" output_file = \\"path/to/output.csv\\" columns = [0, 2, 4] filter_csv_columns(input_file, output_file, columns) # The output.csv will now contain only columns 0, 2, and 4 from input.csv ``` Testing Design and include unittests to verify your implementation, taking care to include edge cases such as: * An empty input CSV file. * A columns list containing out-of-bound indices. * A valid input file with specified columns existing within the boundaries.","solution":"import csv from typing import List def filter_csv_columns(input_file: str, output_file: str, columns: List[int]) -> None: Filter columns of a CSV file based on provided column indices. with open(input_file, mode=\'r\', newline=\'\', encoding=\'utf-8\') as infile: reader = csv.reader(infile) header = next(reader) # Validating column indices max_valid_index = len(header) - 1 for col in columns: if col < 0 or col > max_valid_index: raise ValueError(f\\"Column index {col} is out of bounds for the input file.\\") with open(output_file, mode=\'w\', newline=\'\', encoding=\'utf-8\') as outfile: writer = csv.writer(outfile) writer.writerow([header[i] for i in columns]) for row in reader: writer.writerow([row[i] for i in columns])"},{"question":"# Efficient Graph Representation and Path Finding Graphs can be represented in multiple ways, with adjacency list and adjacency matrix being the most common structures. Both representations have their advantages and trade-offs depending on the graph\'s density and the required operations. You are required to implement a graph class that supports the following operations: 1. **Adding an Edge**: This method allows you to add a directed edge from one vertex to another with a specified weight. 2. **Shortest Path Calculation**: Implement Dijkstra\'s algorithm to compute the shortest path from a given start vertex to all other vertices. # Class Structure and Method Specifications **Class: `Graph`** ```python class Graph: def __init__(self, num_vertices: int): self.num_vertices = num_vertices self.adj_list = {i: [] for i in range(num_vertices)} def add_edge(self, src: int, dest: int, weight: int) -> None: pass def shortest_path(self, start: int) -> list: pass ``` **Method 1: `add_edge`** * **Description**: Adds a directed edge from vertex `src` to vertex `dest` with the given `weight`. * **Input**: * `src` (int): Source vertex. * `dest` (int): Destination vertex. * `weight` (int): Weight of the edge. * **Output**: None. * **Constraints**: The vertices should be within the range [0, num_vertices-1]. **Method 2: `shortest_path`** * **Description**: Uses Dijkstra\'s algorithm to compute the shortest path from the `start` vertex to all other vertices. * **Input**: * `start` (int): The starting vertex for path calculation. * **Output**: A list where the value at index `i` represents the shortest distance from the `start` vertex to vertex `i`. If there is no path to vertex `i`, the value should be `float(\'inf\')`. * **Constraints**: The `start` vertex should be within the range [0, num_vertices-1]. # Example Usage ```python graph = Graph(5) graph.add_edge(0, 1, 10) graph.add_edge(0, 4, 3) graph.add_edge(1, 2, 2) graph.add_edge(2, 3, 9) graph.add_edge(3, 2, 7) graph.add_edge(4, 1, 1) graph.add_edge(4, 2, 2) distances = graph.shortest_path(0) print(distances) # Expected: [0, 4, 5, 14, 3] ``` **Note**: Ensure the `Graph` class handles graph creation efficiently, adheres to the constraints, and accurately implements the addition of edges and Dijkstra\'s shortest path algorithm. # Additional Constraints 1. The graph can have up to 10^4 vertices. 2. The weights of the edges are non-negative integers. 3. If vertices are not connected, the distance should be represented as `float(\'inf\')`.","solution":"import heapq class Graph: def __init__(self, num_vertices: int): self.num_vertices = num_vertices self.adj_list = {i: [] for i in range(num_vertices)} def add_edge(self, src: int, dest: int, weight: int) -> None: self.adj_list[src].append((dest, weight)) def shortest_path(self, start: int) -> list: distances = [float(\'inf\')] * self.num_vertices distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) if current_distance > distances[current_vertex]: continue for neighbor, weight in self.adj_list[current_vertex]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"# Problem Statement: As an analyst in a telecommunication company, you are tasked with developing an algorithm to efficiently manage and optimize network traffic. To do so, you need to analyze and find the shortest path between different nodes in a network. Represent the network as a weighted, directed graph where nodes represent network switches, and edges represent direct connections with associated latencies. You need to determine the shortest path from a specified source node to all other nodes using Dijkstra\'s algorithm. Your task is to write a function `shortest_paths(network: list[list[int]], source: int) -> list[int]` that applies Dijkstra\'s algorithm to find the shortest path from the source node to all other nodes in the network. # Function Signature: ```python def shortest_paths(network: list[list[int]], source: int) -> list[int]: ``` # Input Format: * `network`: A 2D list of size `n x n` where `network[i][j]` represents the latency from node `i` to node `j`. A latency of `0` indicates no direct connection. * `source`: A non-negative integer representing the source node. # Output Format: * Return a list of integers where the `i-th` element represents the shortest distance from the `source` node to node `i`. If a node is unreachable, its distance should be `float(\'inf\')`. # Constraints: * 1 ≤ n ≤ 500 (number of nodes) * 0 ≤ network[i][j] ≤ 10^5 (latency between nodes) * 0 ≤ source < n # Performance Requirements: * The solution should have a time complexity of (O(n^2)) using a simple priority queue or (O(n log n)) using a min-heap priority queue implementation of Dijkstra\'s algorithm. # Example: ```python >>> network = [ ... [0, 10, 0, 30, 100], ... [10, 0, 50, 0, 0], ... [0, 50, 0, 20, 10], ... [30, 0, 20, 0, 60], ... [100, 0, 10, 60, 0] ... ] >>> source = 0 >>> shortest_paths(network, source) [0, 10, 50, 30, 60] ``` # Explanation: In this example, the shortest paths from node 0 to nodes 0, 1, 2, 3, and 4 are 0, 10, 50, 30, and 60, respectively.","solution":"import heapq def shortest_paths(network: list[list[int]], source: int) -> list[int]: n = len(network) distances = [float(\'inf\')] * n distances[source] = 0 priority_queue = [(0, source)] # (distance, node) while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, latency in enumerate(network[current_node]): if latency > 0: # There is a direct connection distance = current_distance + latency if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"Coding Question: Run-Length Encoding and Decoding # Objective Implement a Run-Length Encoder and Decoder for text data. The task is to write two functions `run_length_encode` and `run_length_decode` that perform text compression using Run-Length Encoding (RLE) and expansion back to the original text. # Function Signatures ```python def run_length_encode(data: str) -> str: pass def run_length_decode(data: str) -> str: pass ``` # Input and Output run_length_encode * **Input**: - `data: str`: The text string to be encoded. * **Output**: - `str`: The Run-Length Encoded string. run_length_decode * **Input**: - `data: str`: The Run-Length Encoded string. * **Output**: - `str`: The original text string. # Constraints - The input data for encoding will be a non-empty string composed of alphanumeric characters. - The encoded data for decoding will be a valid RLE string. # Example ```python # Example encoding print(run_length_encode(\\"aaaabbbcca\\")) # \\"4a3b2c1a\\" print(run_length_encode(\\"abcd\\")) # \\"1a1b1c1d\\" # Example decoding print(run_length_decode(\\"4a3b2c1a\\")) # \\"aaaabbbcca\\" print(run_length_decode(\\"1a1b1c1d\\")) # \\"abcd\\" ``` # Explanation The `run_length_encode` function should compress the input string by identifying subsequences of repeated characters and representing them as a count followed by the character, in the format `count` + `character`. The `run_length_decode` function should take the encoded string and expand it back to the original string by replicating each character according to its count as specified. Handle all edge cases such as: - Strings without any repeating characters. - Strings with a single character repeated multiple times. - Proper handling of numeric and non-alphabetic characters in the input string.","solution":"def run_length_encode(data: str) -> str: Encodes the input string using run-length encoding. if not data: return \\"\\" encoded_str = \\"\\" count = 1 for i in range(1, len(data)): if data[i] == data[i - 1]: count += 1 else: encoded_str += str(count) + data[i - 1] count = 1 encoded_str += str(count) + data[-1] return encoded_str def run_length_decode(data: str) -> str: Decodes the run-length encoded string back to the original string. if not data: return \\"\\" decoded_str = \\"\\" count = \\"\\" for char in data: if char.isdigit(): count += char else: decoded_str += char * int(count) count = \\"\\" return decoded_str"},{"question":"# Scenario You are developing a simple game that requires calculating the longest common subsequence (LCS) between two given strings. The game checks the player\'s input against a predefined sequence to determine their score based on the length of the LCS. # Problem Statement Write a function `longest_common_subsequence` that takes two strings `s1` and `s2`, and returns the length of their longest common subsequence. # Input Format Two strings `s1` and `s2`. # Output Format An integer representing the length of the longest common subsequence between the input strings. # Constraints * 1 <= len(s1), len(s2) <= 1000 * The strings consist only of uppercase English letters (A-Z). # Function Signature ```python def longest_common_subsequence(s1: str, s2: str) -> int: # implementation here ``` # Examples Example 1 **Input**: ```python \\"ABCBDAB\\" \\"BDCAB\\" ``` **Output**: ```python 4 ``` **Explanation**: The longest common subsequence is \\"BDAB\\" or \\"BCAB\\" with length 4. Example 2 **Input**: ```python \\"AGGTAB\\" \\"GXTXAYB\\" ``` **Output**: ```python 4 ``` **Explanation**: The longest common subsequence is \\"GTAB\\" with length 4. # Implementation Notes * Use dynamic programming to efficiently calculate the length of the LCS. * Create a 2D table to store lengths of LCS of substrings. * Ensure the solution works within the constraints by optimizing both time and space complexity, using memoization or tabulation as required.","solution":"def longest_common_subsequence(s1: str, s2: str) -> int: Returns the length of the longest common subsequence between s1 and s2. m, n = len(s1), len(s2) # Create a 2D array to store lengths of longest common subsequence. dp = [[0] * (n + 1) for _ in range(m + 1)] # Build the dp array from bottom-up for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"# Problem Statement: A popular online store wants to offer a discount to its customers based on their spending. The discount is determined based on the total amount spent by the customer over a period of time. Your task is to write a function that computes the discount percentage based on predefined spending slabs. Here is how the discount percentages work: - If the total spending is less than 100, no discount (0%). - If the total spending is between 100 and 499, a discount of 5%. - If the total spending is between 500 and 999, a discount of 10%. - If the total spending is 1000 or more, a discount of 15%. Write a function named `calculate_discount(spending: float) -> float` that takes a float value representing the total spending amount and returns the discount percentage as a float. # Input: - `spending` (0 ≤ spending ≤ 100000): A float representing the total amount spent by the customer. # Output: - A float representing the discount percentage the customer is eligible for. # Example: ```python calculate_discount(50.0) # Output: 0.0 calculate_discount(250.0) # Output: 5.0 calculate_discount(750.0) # Output: 10.0 calculate_discount(1500.0) # Output: 15.0 ``` # Constraints: - Ensure your solution efficiently determines the discount percentage based on the given slabs. - Handle edge cases where the spending is exactly at the boundary of each slab (e.g., 100, 500, 1000).","solution":"def calculate_discount(spending: float) -> float: Determines the discount percentage based on the total spending. Parameters: spending (float): The total spending amount. Returns: float: The discount percentage. if spending < 100: return 0.0 elif 100 <= spending < 500: return 5.0 elif 500 <= spending < 1000: return 10.0 else: return 15.0"},{"question":"# Coding Assessment Question Scenario You are constructing a search engine indexer where documents are stored and frequently updated. Each document is associated with a unique ID and a string of text. You need to implement a data structure that allows for efficient text updates, frequent retrieval of word frequency, and top-k most frequent words queries within a given document. Task Implement a class `SearchEngineIndexer` that allows for storing, updating, and querying documents by their IDs. The class should support the following functionalities: # Class Definition ```python class SearchEngineIndexer: def __init__(self) -> None: # Initialize the class with necessary properties def add_document(self, doc_id: int, text: str) -> None: # Add or update the document with the given ID and text def get_word_frequency(self, doc_id: int, word: str) -> int: # Get the frequency of the word in the document with the given ID def top_k_words(self, doc_id: int, k: int) -> List[str]: # Get the top k most frequent words in the document with the given ID ``` # Method Details * **`__init__(self) -> None`**: * Initializes the SearchEngineIndexer. * **`add_document(self, doc_id: int, text: str) -> None`**: * Adds or updates the document with `doc_id` with the provided `text`. * Text is a string of words separated by spaces. * **`get_word_frequency(self, doc_id: int, word: str) -> int`**: * Returns the frequency of the specified `word` in the document with given `doc_id`. * **`top_k_words(self, doc_id: int, k: int) -> List[str]`**: * Returns a list of the top `k` most frequent words in the document with the given `doc_id`. * Words with the same frequency are sorted alphabetically. # Constraints * `1 <= k <= number of unique words in the document` * Document text length `<= 10^5` characters * Document count `<= 10^5` * `doc_id` is guaranteed to be unique for each document # Output Format * Function methods return appropriate data types (Integer or List of Strings). # Example ```python sei = SearchEngineIndexer() sei.add_document(1, \\"hello world hello hello coding world\\") assert sei.get_word_frequency(1, \\"hello\\") == 3 assert sei.get_word_frequency(1, \\"world\\") == 2 assert sei.top_k_words(1, 2) == [\\"hello\\", \\"world\\"] sei.add_document(2, \\"hello search search engine engine engine\\") assert sei.get_word_frequency(2, \\"engine\\") == 3 assert sei.top_k_words(2, 1) == [\\"engine\\"] ```","solution":"from collections import defaultdict from typing import List class SearchEngineIndexer: def __init__(self) -> None: self.documents = defaultdict(str) self.word_frequency = defaultdict(lambda: defaultdict(int)) def add_document(self, doc_id: int, text: str) -> None: self.documents[doc_id] = text words = text.split() self.word_frequency[doc_id] = defaultdict(int) for word in words: self.word_frequency[doc_id][word] += 1 def get_word_frequency(self, doc_id: int, word: str) -> int: return self.word_frequency[doc_id].get(word, 0) def top_k_words(self, doc_id: int, k: int) -> List[str]: word_count = self.word_frequency[doc_id] sorted_words = sorted(word_count.items(), key=lambda x: (-x[1], x[0])) return [word for word, _ in sorted_words[:k]]"},{"question":"# Data Encryption Implementation In this assessment, you are required to implement a Python function that encrypts a given text using a simple symmetric cipher. This function should demonstrate your understanding of string manipulation, encoding, and decryption techniques. Function Signature ```python def encrypt_text(plain_text: str, key: int) -> str: Encrypts the given plain text using a symmetric cipher with the provided key. :param plain_text: The text to be encrypted. :param key: The encryption key (a positive integer). :return: The encrypted text. ``` ```python def decrypt_text(encrypted_text: str, key: int) -> str: Decrypts the given encrypted text using a symmetric cipher with the provided key. :param encrypted_text: The text to be decrypted. :param key: The encryption key (a positive integer). :return: The decrypted text. ``` Instructions 1. **Symmetric Cipher**: Implement a simple symmetric encryption algorithm (e.g., Caesar cipher or similar). 2. **Character Encoding**: Ensure that the encryption handles both uppercase and lowercase letters, digits, and basic punctuation marks. 3. **Key Management**: The key used for encryption should be a positive integer, which shifts the characters based on their ASCII values. 4. **Decryption Function**: Implement a corresponding decryption function that reverses the encryption process. Constraints - The key must be a positive integer. - Both functions should handle all printable ASCII characters (from ASCII 32 to 126). Example Input: ```python plain_text = \\"Hello, World!\\" key = 3 encrypted_text = encrypt_text(plain_text, key) print(encrypted_text) ``` Expected Output for Encryption: ``` encrypted_text = \\"Khoor/#Zruog\\" ``` Input: ```python encrypted_text = \\"Khoor/#Zruog\\" key = 3 decrypted_text = decrypt_text(encrypted_text, key) print(decrypted_text) ``` Expected Output for Decryption: ``` decrypted_text = \\"Hello, World!\\" ``` Important Points - Ensure that the encryption and decryption functions are inverse operations. - Handle edge cases such as empty strings or strings with special characters. - Validate the key to be a positive integer before proceeding with encryption or decryption.","solution":"def encrypt_text(plain_text: str, key: int) -> str: Encrypts the given plain text using a symmetric cipher with the provided key. :param plain_text: The text to be encrypted. :param key: The encryption key (a positive integer). :return: The encrypted text. if not isinstance(key, int) or key <= 0: raise ValueError(\\"Key must be a positive integer\\") encrypted_text = \\"\\" for char in plain_text: if 32 <= ord(char) <= 126: encrypted_text += chr((ord(char) - 32 + key) % 95 + 32) else: encrypted_text += char return encrypted_text def decrypt_text(encrypted_text: str, key: int) -> str: Decrypts the given encrypted text using a symmetric cipher with the provided key. :param encrypted_text: The text to be decrypted. :param key: The encryption key (a positive integer). :return: The decrypted text. if not isinstance(key, int) or key <= 0: raise ValueError(\\"Key must be a positive integer\\") decrypted_text = \\"\\" for char in encrypted_text: if 32 <= ord(char) <= 126: decrypted_text += chr((ord(char) - 32 - key) % 95 + 32) else: decrypted_text += char return decrypted_text"},{"question":"# Problem Statement: You are tasked with enhancing a basic Genetic Algorithm to solve the Travelling Salesperson Problem (TSP). The aim is to improve its efficacy by introducing new functionalities and optimizations. # Requirements: 1. **Function to Generate Initial Population:** - Implement a function `generate_population(cities: List[TPos], population_size: int) -> List[TCandidate]` to create an initial population of potential solutions. 2. **Crossover Operator:** - Implement an efficient crossover operator `crossover(parent1: TCandidate, parent2: TCandidate) -> TCandidate` to combine the genetic material of two parent solutions. 3. **Mutation Operator:** - Develop a mutation function `mutate(candidate: TCandidate, mutation_rate: float) -> TCandidate` to introduce random variations in a candidate solution. 4. **Fitness Evaluation:** - Implement a function `evaluate_fitness(candidate: TCandidate, cities: List[TPos]) -> float` that calculates and returns the fitness of a candidate solution based on the total distance traveled. 5. **Selection Mechanism:** - Create a selection mechanism `select_parents(population: List[TCandidate], fitness_scores: List[float]) -> List[Tuple[TCandidate, TCandidate]]` to choose pairs of parents for producing the next generation. 6. **Performance Logging:** - Add functionality to log key metrics such as the best fitness score, average fitness score, and the number of generations. # Input/Output Formats: * **Input:** - `cities`: A list of tuples representing the coordinates of the cities. - `population_size`: An integer specifying the number of candidate solutions in the population. - `max_generations`: An integer setting the limit on the number of generations to evolve. - `mutation_rate`: A float indicating the probability of mutation occurring in a candidate solution. * **Output:** - The best solution found as a list of city indices representing the order of the tour. - Log of performance metrics. # Constraints: - The number of cities will not exceed 100. - The algorithm must produce a solution within a specified time limit (execution time < 2 minutes for the maximum number of cities). # Sample Usage: ```python cities = [(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)] population_size = 10 max_generations = 100 mutation_rate = 0.01 best_solution, metrics = enhanced_genetic_algorithm(cities, population_size, max_generations, mutation_rate) print(\\"Best Solution:\\", best_solution) print(\\"Metrics:\\", metrics) ``` **Note:** Ensure that the improvements do not compromise the basic functioning of the genetic algorithm and that it can handle various instance sizes efficiently.","solution":"import random import math from typing import List, Tuple # Type aliases for better readability TPos = Tuple[int, int] TCandidate = List[int] def generate_population(cities: List[TPos], population_size: int) -> List[TCandidate]: Generates an initial population of candidate solutions. population = [] num_cities = len(cities) for _ in range(population_size): candidate = list(range(num_cities)) random.shuffle(candidate) population.append(candidate) return population def crossover(parent1: TCandidate, parent2: TCandidate) -> TCandidate: Performs crossover between two parent solutions to produce a new candidate. size = len(parent1) start, end = sorted(random.sample(range(size), 2)) child = [None] * size child[start:end + 1] = parent1[start:end + 1] fill_pos = end + 1 for city in parent2: if city not in child: if fill_pos >= size: fill_pos = 0 child[fill_pos] = city fill_pos += 1 return child def mutate(candidate: TCandidate, mutation_rate: float) -> TCandidate: Mutates a candidate solution based on the mutation rate. size = len(candidate) for i in range(size): if random.random() < mutation_rate: j = random.randint(0, size - 1) candidate[i], candidate[j] = candidate[j], candidate[i] return candidate def evaluate_fitness(candidate: TCandidate, cities: List[TPos]) -> float: Calculates the fitness score of a candidate solution. total_distance = 0.0 num_cities = len(candidate) for i in range(num_cities): city1 = candidate[i] city2 = candidate[(i + 1) % num_cities] total_distance += math.dist(cities[city1], cities[city2]) return total_distance def select_parents(population: List[TCandidate], fitness_scores: List[float]) -> List[Tuple[TCandidate, TCandidate]]: Selects pairs of parents from the population using tournament selection. selected_parents = [] population_size = len(population) for _ in range(population_size): participants = random.sample(range(population_size), 3) p1, p2 = sorted(participants, key=lambda x: fitness_scores[x])[:2] selected_parents.append((population[p1], population[p2])) return selected_parents def enhanced_genetic_algorithm(cities: List[TPos], population_size: int, max_generations: int, mutation_rate: float): Runs the genetic algorithm. population = generate_population(cities, population_size) best_solution = None best_fitness = float(\'inf\') fitness_log = [] for generation in range(max_generations): fitness_scores = [evaluate_fitness(candidate, cities) for candidate in population] for candidate, fitness in zip(population, fitness_scores): if fitness < best_fitness: best_fitness = fitness best_solution = candidate fitness_log.append((generation, best_fitness, sum(fitness_scores) / population_size)) selected_parents = select_parents(population, fitness_scores) next_population = [] for parent1, parent2 in selected_parents: child = crossover(parent1, parent2) child = mutate(child, mutation_rate) next_population.append(child) population = next_population return best_solution, fitness_log"},{"question":"# Character Frequency Counter You need to write a function that takes a string and returns a dictionary with the counts of each character in the string. The dictionary keys should be characters from the string, and the values should be the corresponding counts of those characters. # Function Signature ```python def character_frequency(s: str) -> dict: ``` # Input * `s` (str): A string containing any characters including alphabetic, numeric, punctuation, and whitespace. # Output * A dictionary with each character from the input string as keys and their frequencies as values. # Constraints * The input string can have a length ranging from `0` to `100,000`. # Performance Requirements * The solution should efficiently count the characters in linear time, O(n), where n is the length of the input string. # Example ```python >>> character_frequency(\\"hello world\\") {\'h\': 1, \'e\': 1, \'l\': 3, \'o\': 2, \' \': 1, \'w\': 1, \'r\': 1, \'d\': 1} >>> character_frequency(\\"Example 123!!!\\") {\'E\': 1, \'x\': 1, \'a\': 1, \'m\': 1, \'p\': 1, \'l\': 1, \'e\': 1, \' \': 1, \'1\': 1, \'2\': 1, \'3\': 1, \'!\': 3} >>> character_frequency(\\"\\") {} >>> character_frequency(\\"aA\\") {\'a\': 1, \'A\': 1} >>> character_frequency(\\"aAaAa\\") {\'a\': 3, \'A\': 2} ``` # Description: Your task is to write a function `character_frequency` that takes a string `s` as input and returns a dictionary that maps each character to its frequency in the string. The function must handle all kinds of characters including alphabets, numbers, punctuation, and whitespace. Considerations: * Ensure your implementation efficiently counts the characters and uses appropriate data structures. * The function should handle both upper and lower case letters distinctly. * The function should correctly process empty strings and very large input strings up to the specified limit.","solution":"def character_frequency(s: str) -> dict: Returns a dictionary with the counts of each character in the string \'s\'. Parameters: s (str): The input string containing any characters including alphabetic, numeric, punctuation, and whitespace. Returns: dict: A dictionary where keys are characters from the input string and values are their respective counts. frequency_dict = {} for char in s: if char in frequency_dict: frequency_dict[char] += 1 else: frequency_dict[char] = 1 return frequency_dict"},{"question":"# Scenario You are developing a financial application that helps users calculate their future investment returns given a series of monthly contributions and an annual interest rate. One of the features requires computing the balance of the investment at the end of a specified number of months. # Problem Write a function `investment_growth(months: int, monthly_contribution: float, annual_interest_rate: float) -> float` that calculates the future balance of an investment given: - the number of months the investment is held, - a fixed monthly contribution, - and an annual interest rate compounded monthly. The formula to compute each month\'s balance is: ``` balance = previous_balance * (1 + monthly_interest_rate) + monthly_contribution ``` where `monthly_interest_rate` is `annual_interest_rate / 12 / 100`. # Input * `months` (int): The number of months the investment will be held. Must be a non-negative integer. * `monthly_contribution` (float): The amount to be contributed each month. Must be a non-negative float. * `annual_interest_rate` (float): The annual interest rate expressed as a percentage (e.g., 5 for 5%). Must be a non-negative float. # Output * `float`: The future balance of the investment at the end of the specified number of months. # Constraints 1. `months` must be a non-negative integer. 2. `monthly_contribution` must be a non-negative float. 3. `annual_interest_rate` must be a non-negative float. 4. If any input constraints are violated, the function should raise a `ValueError` with a descriptive message. # Examples 1. `investment_growth(6, 100, 5)` should return approximately `608.2838`. 2. `investment_growth(12, 200, 7)` should return approximately `2471.15318`. 3. `investment_growth(-5, 200, 7)` should raise a `ValueError`. 4. `investment_growth(12, -200, 7)` should raise a `ValueError`. 5. `investment_growth(12, 200, -7)` should raise a `ValueError`. # Implementation Implement your solution based on the analysis above: ```python def investment_growth(months: int, monthly_contribution: float, annual_interest_rate: float) -> float: :param months: Number of months the money is invested :type months: int :param monthly_contribution: The monthly contribution to the investment :type monthly_contribution: float :param annual_interest_rate: The annual interest rate as a percentage :type annual_interest_rate: float :return: The balance of the investment after the specified months Tests: >>> investment_growth(6, 100, 5) 608.2838 >>> investment_growth(12, 200, 7) 2471.15318 >>> investment_growth(-5, 200, 7) Traceback (most recent call last): ... ValueError: Months must be a non-negative integer. >>> investment_growth(12, -200, 7) Traceback (most recent call last): ... ValueError: Monthly contribution must be a non-negative float. >>> investment_growth(12, 200, -7) Traceback (most recent call last): ... ValueError: Annual interest rate must be a non-negative float. if months < 0 or not isinstance(months, int): raise ValueError(\\"Months must be a non-negative integer.\\") if monthly_contribution < 0 or not isinstance(monthly_contribution, float): raise ValueError(\\"Monthly contribution must be a non-negative float.\\") if annual_interest_rate < 0 or not isinstance(annual_interest_rate, float): raise ValueError(\\"Annual interest rate must be a non-negative float.\\") monthly_interest_rate = annual_interest_rate / 12 / 100 balance = 0.0 for _ in range(months): balance = balance * (1 + monthly_interest_rate) + monthly_contribution return round(balance, 5) if __name__ == \\"__main__\\": import doctest doctest.testmod() ```","solution":"def investment_growth(months: int, monthly_contribution: float, annual_interest_rate: float) -> float: Calculate the future balance of an investment given the number of months, monthly contribution, and annual interest rate compounded monthly. :param months: Number of months the investment is held :type months: int :param monthly_contribution: Amount contributed each month :type monthly_contribution: float :param annual_interest_rate: Annual interest rate as a percentage :type annual_interest_rate: float :return: Future balance after the specified number of months :rtype: float :raises ValueError: If any input constraints are violated Examples: >>> investment_growth(6, 100, 5) 608.28 >>> investment_growth(12, 200, 7) 2471.15 >>> investment_growth(-5, 200, 7) Traceback (most recent call last): ... ValueError: Months must be a non-negative integer. >>> investment_growth(12, -200, 7) Traceback (most recent call last): ... ValueError: Monthly contribution must be a non-negative float. >>> investment_growth(12, 200, -7) Traceback (most recent call last): ... ValueError: Annual interest rate must be a non-negative float. if not isinstance(months, int) or months < 0: raise ValueError(\\"Months must be a non-negative integer.\\") if not isinstance(monthly_contribution, float) or monthly_contribution < 0: raise ValueError(\\"Monthly contribution must be a non-negative float.\\") if not isinstance(annual_interest_rate, float) or annual_interest_rate < 0: raise ValueError(\\"Annual interest rate must be a non-negative float.\\") monthly_interest_rate = annual_interest_rate / 12 / 100 balance = 0.0 for _ in range(months): balance = balance * (1 + monthly_interest_rate) + monthly_contribution return round(balance, 2)"},{"question":"# Sum of Nodes in a Complete Binary Tree # Problem Statement You are given a complete binary tree with `num_nodes` nodes, where each node contains an integer value. Implement an algorithm to calculate the sum of all node values in this binary tree. For this task, implement the `CompleteBinaryTree` class with the following methods: - `__init__(self, num_nodes: int)`: Initializes the binary tree with the given number of nodes, arranged in a complete binary tree fashion. - `add_node(self, index: int, value: int)`: Adds a node with the given value at the specified index in the tree. Raises a `ValueError` for invalid indices or if the index is already occupied. - `sum_of_nodes(self) -> int`: Returns the sum of all node values in the binary tree. Input - A positive integer `num_nodes` representing the number of nodes in the binary tree. - Multiple pairs of integers `index` and `value` which represent the index at which node values should be added. Output - Returns the sum of all node values in the binary tree. # Example ```python cbt = CompleteBinaryTree(7) cbt.add_node(0, 10) cbt.add_node(1, 20) cbt.add_node(2, 30) cbt.add_node(3, 40) cbt.add_node(4, 50) cbt.add_node(5, 60) cbt.add_node(6, 70) assert cbt.sum_of_nodes() == 280 ``` You need to complete the class `CompleteBinaryTree` as per the specified requirements: ```python class CompleteBinaryTree: def __init__(self, num_nodes: int): # Initialize your data structures here pass def add_node(self, index: int, value: int): # Implement node addition logic with validation checks pass def sum_of_nodes(self) -> int: # Implement the logic to compute the sum of all node values pass ``` # Constraints - `1 <= num_nodes <= 10^4` - `0 <= index < num_nodes` # Notes - Ensure your solution handles edge cases appropriately. - Optimize for both time and space, adhering to the constraints and expected complexity.","solution":"class CompleteBinaryTree: def __init__(self, num_nodes: int): self.num_nodes = num_nodes self.tree = [None] * num_nodes def add_node(self, index: int, value: int): if index < 0 or index >= self.num_nodes: raise ValueError(f\\"Index {index} is out of the valid range 0 to {self.num_nodes - 1}\\") if self.tree[index] is not None: raise ValueError(f\\"Index {index} is already occupied\\") self.tree[index] = value def sum_of_nodes(self) -> int: return sum(value for value in self.tree if value is not None)"},{"question":"# Question: Graph Connectivity with DFS You are assigned to develop a system that checks connectivity within an undirected graph using Depth-First Search (DFS). The goal is to determine if there exists a path between two given vertices. **Objectives:** 1. Implement a class `Graph` with the following methods: - `add_edge(v: int, w: int) -> None`: Adds an undirected edge between vertices `v` and `w`. If vertices `v` or `w` do not exist, they should be added to the graph. - `is_connected(start: int, end: int) -> bool`: Checks if there is a path between vertices `start` and `end`. If any of the vertices do not exist in the graph, it should return False. 2. Perform the connectivity check using a depth-first search approach. **Constraints:** - You may assume the graph can contain a large number of vertices and edges. - The methods should handle scenarios where the vertices may not initially exist in the graph efficiently. **Function Signatures:** - `class Graph:` - `def __init__(self) -> None:` - `def add_edge(self, v: int, w: int) -> None:` - `def is_connected(self, start: int, end: int) -> bool:` **Example Usage:** ```python graph = Graph() graph.add_edge(0, 1) graph.add_edge(1, 2) graph.add_edge(2, 3) graph.add_edge(3, 4) print(graph.is_connected(0, 4)) # Output: True print(graph.is_connected(0, 5)) # Output: False graph.add_edge(4, 5) print(graph.is_connected(0, 5)) # Output: True ``` Your task is to implement the `Graph` class and ensure that it accurately checks connectivity between given vertices using DFS.","solution":"class Graph: def __init__(self) -> None: self.graph = {} def add_edge(self, v: int, w: int) -> None: if v not in self.graph: self.graph[v] = [] if w not in self.graph: self.graph[w] = [] self.graph[v].append(w) self.graph[w].append(v) def is_connected(self, start: int, end: int) -> bool: if start not in self.graph or end not in self.graph: return False visited = set() def dfs(v: int) -> bool: if v == end: return True visited.add(v) for neighbor in self.graph[v]: if neighbor not in visited: if dfs(neighbor): return True return False return dfs(start)"},{"question":"# Scenario A telecommunications company needs to optimize its network configuration by identifying redundant connections that, if removed, would simplify the network structure without affecting connectivity. The network is represented as an undirected graph, where nodes represent network hubs and edges represent connections between them. To achieve this task, implement Kruskal\'s algorithm to compute the Minimum Spanning Tree (MST) of the graph. In doing so, you will identify the edges that are essential for maintaining the network\'s connectivity with minimum cost. # Problem Statement You are given an implementation of Kruskal’s algorithm intended to find the Minimum Spanning Tree (MST) for a given connected, undirected, and weighted graph. The Graph and DisjointSet classes are provided. Using these classes, complete the function **find_mst** which takes an integer number of vertices, a list of edges (each edge represented by a tuple (u, v, w)), and returns a list of edges included in the MST. # Function Signature ```python def find_mst(num_vertices: int, edges: List[Tuple[int, int, int]]) -> List[Tuple[int, int, int]]: ``` # Input - **num_vertices**: An integer representing the number of vertices (V) in the graph. - **edges**: A list of tuples, where each tuple ( (u, v, w) ) represents an edge between vertex ( u ) and vertex ( v ) with weight ( w ). # Output - Returns a list of tuples, each representing an edge included in the MST, sorted by the order in which they were added to the MST. # Constraints - (1 leq num_vertices leq 1000) - (0 leq u, v < num_vertices) - ( 1 leq w leq 10^4 ) - All edge weights are non-negative. - The graph is connected and undirected. # Example ```python edges = [ (0, 1, 4), (0, 7, 8), (1, 2, 8), (1, 7, 11), (2, 3, 7), (2, 8, 2), (2, 5, 4), (3, 4, 9), (3, 5, 14), (4, 5, 10), (5, 6, 2), (6, 7, 1), (6, 8, 6), (7, 8, 7) ] num_vertices = 9 print(find_mst(num_vertices, edges)) # Expected Output: [ # (5, 6, 2), # (2, 8, 2), # (6, 7, 1), # (0, 1, 4), # (2, 5, 4), # (2, 3, 7), # (0, 7, 8), # (3, 4, 9) # ] ``` # Constraints and Performance Notes - Ensure the algorithm is efficient and scales well within the given constraints. - Your solution should have a time complexity of (O(E log E)).","solution":"class DisjointSet: def __init__(self, n): self.parent = list(range(n)) self.rank = [0] * n def find(self, u): if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) return self.parent[u] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 def find_mst(num_vertices, edges): Takes the number of vertices and the edges of the graph and returns the edges in the Minimum Spanning Tree (MST) using Kruskal\'s algorithm. # Sort edges by increasing weight edges.sort(key=lambda edge: edge[2]) # Initialize the disjoint set ds = DisjointSet(num_vertices) mst_edges = [] for u, v, weight in edges: # If u and v are in different sets, we can add the edge to the MST if ds.find(u) != ds.find(v): ds.union(u, v) mst_edges.append((u, v, weight)) return mst_edges"},{"question":"**Scenario:** You are tasked with developing an application for a marine research facility that needs to keep track of a collection of underwater organism observations. The data collected may include attributes such as species name, depth at which it was observed (in meters), and the timestamp of the observation. This information needs to be stored efficiently and queried effectively to support various research activities. **Task:** Implement a class `ObservationLog` that can store, retrieve, and analyze the observations of underwater organisms. The class should provide methods to add a new observation, retrieve observations by species, and find the deepest observation recorded. **Class Signature:** ```python class ObservationLog: def __init__(self): pass def add_observation(self, species: str, depth: float, timestamp: str) -> None: pass def get_observations_by_species(self, species: str) -> list: pass def get_deepest_observation(self) -> tuple: pass ``` **Methods Description:** - `add_observation(species: str, depth: float, timestamp: str) -> None:` Adds a new observation to the log. Each observation is defined by the species name, the depth at which it was observed, and the timestamp (in ISO 8601 format, e.g., \\"2023-10-17T08:55:00Z\\"). - `get_observations_by_species(species: str) -> list:` Retrieves a list of observations for the specified species. Each observation should be represented as a dictionary with keys \\"species\\", \\"depth\\", and \\"timestamp\\". - `get_deepest_observation() -> tuple:` Finds and returns the deepest observation recorded as a tuple (`species`, `depth`, `timestamp`). **Constraints/Requirements:** - The species names should be treated case-insensitively (e.g., \\"Shark\\" and \\"shark\\" are the same species). - Ensure efficient storage and retrieval of observations. - Handle errors gracefully, such as invalid timestamps or non-numeric depths. **Example**: ```python log = ObservationLog() log.add_observation(\\"Shark\\", 1200.5, \\"2023-10-17T08:55:00Z\\") log.add_observation(\\"whale\\", 1500.0, \\"2023-10-18T10:00:00Z\\") log.add_observation(\\"shark\\", 900.2, \\"2023-10-19T12:30:00Z\\") print(log.get_observations_by_species(\\"Shark\\")) # Expected output: [{\'species\': \'shark\', \'depth\': 1200.5, \'timestamp\': \\"2023-10-17T08:55:00Z\\"}, {\'species\': \'shark\', \'depth\': 900.2, \'timestamp\': \\"2023-10-19T12:30:00Z\\"}] print(log.get_deepest_observation()) # Expected output: (\'whale\', 1500.0, \'2023-10-18T10:00:00Z\') ``` Ensure your class maintains proper case-insensitivity for species names and efficiently manages the observation data.","solution":"import datetime class ObservationLog: def __init__(self): self.observations = [] def add_observation(self, species: str, depth: float, timestamp: str) -> None: # Normalize species name to lowercase for case-insensitivity species = species.lower() # Validate timestamp format try: datetime.datetime.fromisoformat(timestamp.replace(\\"Z\\", \\"+00:00\\")) except ValueError: raise ValueError(f\\"Invalid timestamp format: \'{timestamp}\'\\") # Validate depth if not isinstance(depth, (int, float)) or depth < 0: raise ValueError(f\\"Invalid depth value: \'{depth}\'\\") # Append the observation self.observations.append({ \\"species\\": species, \\"depth\\": depth, \\"timestamp\\": timestamp }) def get_observations_by_species(self, species: str) -> list: species = species.lower() return [obs for obs in self.observations if obs[\'species\'] == species] def get_deepest_observation(self) -> tuple: if not self.observations: return None deepest = max(self.observations, key=lambda obs: obs[\'depth\']) return (deepest[\\"species\\"], deepest[\\"depth\\"], deepest[\\"timestamp\\"])"},{"question":"# Coding Question: You are given a list of integers representing the prices of items in a store on consecutive days. Your task is to write a function `max_profit` that calculates and returns the maximum possible profit you can achieve by buying one item and selling it on a later day. If no profit can be made, return 0. Input: * A list of integers where each integer represents the price of an item on a particular day. Output: * An integer representing the maximum profit that can be made, or 0 if no profit can be made. Constraints: * If the list of prices is empty, raise a `ValueError` with the message \\"No prices provided\\". * Prices should be non-negative integers. **Examples:** ```python >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 >>> max_profit([1, 2, 3, 4, 5]) 4 >>> max_profit([]) Traceback (most recent call last): ... ValueError: No prices provided >>> max_profit([3, 3, 3, 3, 3]) 0 ``` Write the implementation of the function `max_profit(prices: list[int]) -> int` below.","solution":"def max_profit(prices): Returns the maximum profit from buying and selling an item on different days. If no profit can be made, returns 0. If the prices list is empty, raises a ValueError. :param prices: List of non-negative integers representing prices on consecutive days :return: Maximum possible profit as an integer if not prices: raise ValueError(\\"No prices provided\\") min_price = float(\'inf\') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"# Coding Assessment Question You are developing a system that requires generating a greeting message based on various inputs. Your task is to write a function that creates a personalized greeting message given the user\'s name and the current time. # Task Write a function `generate_greeting` that takes two parameters: - `name` (str): The name of the user. - `current_time` (str): The current time in \\"HH:MM\\" 24-hour format. The function should return a string that forms a personalized greeting, depending on the time of the day: - \\"Good Morning\\" for time between 05:00 and 11:59 - \\"Good Afternoon\\" for time between 12:00 and 16:59 - \\"Good Evening\\" for time between 17:00 and 20:59 - \\"Good Night\\" for time between 21:00 and 04:59 If the time string provided is invalid (not in \\"HH:MM\\" format or out of the 24-hour range), the function should return \\"Invalid time format\\". Function Signature ```python def generate_greeting(name: str, current_time: str) -> str: ``` Input/Output Formats - The input consists of: - `name`: A string representing the name of the user. - `current_time`: A string specifying the current time in \\"HH:MM\\" 24-hour format. - The output is: - A string that is a personalized greeting based on the time of day, or \\"Invalid time format\\" for invalid input. Constraints - `name` will consist of 1 to 50 English alphabet characters (both upper and lower case) and spaces. - `current_time` will be a string in \\"HH:MM\\" format. Performance Requirements - The function should handle the time parsing and greeting generation efficiently. - Edge cases should be considered and handled appropriately. # Example ```python >>> generate_greeting(\\"Alice\\", \\"06:30\\") \'Good Morning, Alice!\' >>> generate_greeting(\\"Bob\\", \\"14:45\\") \'Good Afternoon, Bob!\' >>> generate_greeting(\\"Charlie\\", \\"18:20\\") \'Good Evening, Charlie!\' >>> generate_greeting(\\"Dana\\", \\"22:05\\") \'Good Night, Dana!\' >>> generate_greeting(\\"Eve\\", \\"25:00\\") \'Invalid time format\' >>> generate_greeting(\\"Frank\\", \\"03:15\\") \'Good Night, Frank!\' >>> generate_greeting(\\"Gracie\\", \\"11:59\\") \'Good Morning, Gracie!\' ```","solution":"def generate_greeting(name: str, current_time: str) -> str: Generates a personalized greeting based on the current time. Parameters: - name (str): The name of the user. - current_time (str): The current time in \\"HH:MM\\" 24-hour format. Returns: A string that is a personalized greeting based on the time of day, or \\"Invalid time format\\" for invalid input. try: hours, minutes = map(int, current_time.split(\\":\\")) if not (0 <= hours < 24 and 0 <= minutes < 60): return \\"Invalid time format\\" if 5 <= hours <= 11: greeting = \\"Good Morning\\" elif 12 <= hours <= 16: greeting = \\"Good Afternoon\\" elif 17 <= hours <= 20: greeting = \\"Good Evening\\" else: # This includes hours which fall between 21:00 and 04:59 greeting = \\"Good Night\\" return f\\"{greeting}, {name}!\\" except (ValueError, IndexError): return \\"Invalid time format\\""},{"question":"# Problem Statement Write a `DictionaryCache` class in Python that simulates a simple caching mechanism using a dictionary. The cache should store key-value pairs and have a maximum capacity. When the cache exceeds its capacity, it should remove the least recently used (LRU) item. # Requirements - The cache should support the following operations: - `get(key)`: Retrieve the value associated with the key. If the key is not present, return `None`. Move the accessed key to the most recently used position. - `put(key, value)`: Insert or update the key-value pair in the cache. If the cache is full, remove the least recently used item before adding the new key-value pair. Move the key to the most recently used position. - `delete(key)`: Remove the key-value pair associated with the key. If the key is not present, do nothing. - `is_full()`: Returns True if the cache is full, False otherwise. - `size()`: Returns the number of items currently in the cache. - `clear()`: Clears all items from the cache. # Input and Output - **get(key)**: - Input: `key` (any hashable data type) - Output: The value associated with the key or `None` - **put(key, value)**: - Input: `key` (any hashable data type), `value` (any data type) - Output: None - **delete(key)**: - Input: `key` (any hashable data type) - Output: None - **is_full()**: - Input: None - Output: Boolean - **size()**: - Input: None - Output: Integer - **clear()**: - Input: None - Output: None # Constraints - The cache should have a fixed maximum capacity, provided during initialization. - The `put` and `get` operations should have an average time complexity of O(1). - Handle edge cases such as trying to delete a key that doesn\'t exist or retrieving a key from an empty cache. - The cache capacity must be at least 1. # Performance Requirements - Efficient memory usage and proper handling of the LRU mechanism. - The expected operations should have an average time complexity of O(1). # Example ```python # Creating a DictionaryCache with a capacity of 2 cache = DictionaryCache(2) # Adding elements to the cache cache.put(\'a\', 1) cache.put(\'b\', 2) # Retrieving elements print(cache.get(\'a\')) # 1 print(cache.get(\'b\')) # 2 # Adding another element cache.put(\'c\', 3) # Cache should remove the least recently used item (\'a\') print(cache.get(\'a\')) # None print(cache.get(\'b\')) # 2 print(cache.get(\'c\')) # 3 # Cache size print(cache.size()) # 2 # Clear the cache cache.clear() print(cache.size()) # 0 print(cache.get(\'b\')) # None ``` # Implementation Please write a class named `DictionaryCache` in Python that meets the requirements mentioned above. Ensure to include proper docstrings and test cases. ```python class DictionaryCache: def __init__(self, capacity): Initialize the cache with a given capacity. self.capacity = capacity self.cache = {} self.order = [] def get(self, key): Retrieve the value associated with the key. if key in self.cache: self.order.remove(key) self.order.append(key) return self.cache[key] return None def put(self, key, value): Insert or update the key-value pair in the cache. if key in self.cache: self.order.remove(key) elif len(self.cache) >= self.capacity: lru_key = self.order.pop(0) del self.cache[lru_key] self.cache[key] = value self.order.append(key) def delete(self, key): Remove the key-value pair associated with the key. if key in self.cache: self.order.remove(key) del self.cache[key] def is_full(self): Return True if the cache is full, False otherwise. return len(self.cache) >= self.capacity def size(self): Return the number of items currently in the cache. return len(self.cache) def clear(self): Clear all items from the cache. self.cache.clear() self.order.clear() ```","solution":"class DictionaryCache: def __init__(self, capacity): Initialize the cache with a given capacity. self.capacity = capacity self.cache = {} self.order = [] def get(self, key): Retrieve the value associated with the key. If the key is not present, return None. if key in self.cache: # Move the accessed key to the most recently used position self.order.remove(key) self.order.append(key) return self.cache[key] return None def put(self, key, value): Insert or update the key-value pair in the cache. If the cache is full, remove the least recently used item. if key in self.cache: # Update the value and move the key to the most recently used position self.order.remove(key) elif len(self.cache) >= self.capacity: # Remove the least recently used item lru_key = self.order.pop(0) del self.cache[lru_key] self.cache[key] = value self.order.append(key) def delete(self, key): Remove the key-value pair associated with the key. If the key is not present, do nothing. if key in self.cache: self.order.remove(key) del self.cache[key] def is_full(self): Returns True if the cache is full, False otherwise. return len(self.cache) >= self.capacity def size(self): Returns the number of items currently in the cache. return len(self.cache) def clear(self): Clears all items from the cache. self.cache.clear() self.order.clear()"},{"question":"# Coding Assessment Question Context Sorting algorithms are fundamental in computer science and have a wide range of applications, from data processing to efficient searching. Understanding and implementing sorting algorithms is crucial for optimizing performance in various computational tasks. Task Write a function `merge_sort(arr: List[int]) -> List[int]` that implements the Merge Sort algorithm to sort a list of integers in ascending order. This task will test your understanding of the divide-and-conquer strategy and your ability to implement recursive sorting algorithms. Input and Output Formats * **Input**: * `arr (List[int])`: A list of integers where 1 ≤ len(arr) ≤ 10^5 and -10^5 ≤ arr[i] ≤ 10^5. * **Output**: * A list of integers sorted in ascending order. Constraints and Performance Requirements * You must ensure that the solution is efficient for large lists with up to 100,000 elements. * Optimize for both time and space complexity. Special Notes 1. Ensure that your implementation handles edge cases, such as an empty list or a list with a single element. 2. Merge Sort has a time complexity of O(n log n) and is preferable for its stable sorting capabilities compared to other algorithms with similar time complexity. Example ```python def merge_sort(arr: List[int]) -> List[int]: pass ``` **Example Usage:** ```python >>> merge_sort([5, 2, 9, 1, 5, 6]) [1, 2, 5, 5, 6, 9] >>> merge_sort([8, 3, 7, 4, 2, 6]) [2, 3, 4, 6, 7, 8] >>> merge_sort([10]) [10] >>> merge_sort([]) [] ```","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half) def merge(left: List[int], right: List[int]) -> List[int]: sorted_list = [] left_index, right_index = 0, 0 while left_index < len(left) and right_index < len(right): if left[left_index] <= right[right_index]: sorted_list.append(left[left_index]) left_index += 1 else: sorted_list.append(right[right_index]) right_index += 1 sorted_list.extend(left[left_index:]) sorted_list.extend(right[right_index:]) return sorted_list"},{"question":"# Merge Sorted Arrays Scenario You are tasked with creating a utility for merging inventory data from two distinct inventory logs into a single sorted inventory log. Each log contains product IDs sorted in ascending order. Your utility should efficiently merge these logs into one sorted list of product IDs, without duplicates. Task Implement the function `merge_sorted_arrays` that merges two sorted lists of integers and removes any duplicates. Function Signature ```python def merge_sorted_arrays(arr1: List[int], arr2: List[int]) -> List[int]: ``` Input * **arr1** (List[int]): First list of sorted integers, representing product IDs. * **arr2** (List[int]): Second list of sorted integers, representing product IDs. Output * **List[int]**: A single merged and sorted list of integers, with duplicates removed. Constraints * Both input lists are sorted in ascending order. * The combined length of the two lists can be as large as 2 * 10^6 elements. * Ensure the function handles edge cases such as empty lists and overlapping values gracefully. Example ```python arr1 = [1, 3, 5, 7] arr2 = [2, 3, 6, 8] assert merge_sorted_arrays(arr1, arr2) == [1, 2, 3, 5, 6, 7, 8] arr1 = [1, 2, 3] arr2 = [] assert merge_sorted_arrays(arr1, arr2) == [1, 2, 3] arr1 = [1, 2, 2, 3] arr2 = [2, 3, 4] assert merge_sorted_arrays(arr1, arr2) == [1, 2, 3, 4] ```","solution":"from typing import List def merge_sorted_arrays(arr1: List[int], arr2: List[int]) -> List[int]: Merges two sorted lists of integers into one sorted list without duplicates. merged = [] i, j = 0, 0 # Traverse both arrays while i < len(arr1) and j < len(arr2): # If element of arr1 is smaller, add it and move pointer if arr1[i] < arr2[j]: if not merged or merged[-1] != arr1[i]: merged.append(arr1[i]) i += 1 # If element of arr2 is smaller, add it and move pointer elif arr1[i] > arr2[j]: if not merged or merged[-1] != arr2[j]: merged.append(arr2[j]) j += 1 else: # If elements are equal, add any one and move both pointers if not merged or merged[-1] != arr1[i]: merged.append(arr1[i]) i += 1 j += 1 # Add remaining elements from arr1 while i < len(arr1): if not merged or merged[-1] != arr1[i]: merged.append(arr1[i]) i += 1 # Add remaining elements from arr2 while j < len(arr2): if not merged or merged[-1] != arr2[j]: merged.append(arr2[j]) j += 1 return merged"},{"question":"# Matrix Rotation Operation Context: You are tasked with performing matrix manipulations frequently in a graphics application. One common operation is rotating a matrix 90 degrees clockwise. Requirements: 1. **Function to Rotate Matrix**: Implement a function `rotate_matrix(matrix: list[list[int]]) -> list[list[int]]` that rotates a given N x N matrix 90 degrees clockwise. * The function should: - Validate that the input is a non-empty square matrix. - Create and return a new matrix that is rotated 90 degrees clockwise. * Aim for an efficient implementation with respect to both time and space. Constraints: * Ensure that the function handles invalid inputs gracefully and provides meaningful error messages. * The provided matrix will be a list of lists with each inner list representing a row, and all rows will have the same length. Input: - A square matrix represented as `list[list[int]]`. Output: - A new matrix that is the result of rotating the input matrix 90 degrees clockwise. Example Usage: ```python >>> rotate_matrix([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] >>> rotate_matrix([ ... [1, 2], ... [3, 4] ... ]) [ [3, 1], [4, 2] ] >>> rotate_matrix([]) Traceback (most recent call last): ... ValueError: The input must be a non-empty square matrix. >>> rotate_matrix([[1, 2, 3], [4, 5], [6, 7, 8]]) Traceback (most recent call last): ... ValueError: The input must be a non-empty square matrix. ```","solution":"def rotate_matrix(matrix): Rotates a given N x N matrix 90 degrees clockwise. if not matrix or not all(len(row) == len(matrix) for row in matrix): raise ValueError(\\"The input must be a non-empty square matrix.\\") N = len(matrix) rotated_matrix = [[0] * N for _ in range(N)] for i in range(N): for j in range(N): rotated_matrix[j][N - 1 - i] = matrix[i][j] return rotated_matrix"},{"question":"# Sales Prediction using Linear Regression Implement a simple linear regression model to predict future sales based on a given historical dataset. You are given a dataset containing previous sales figures over time, and your task is to predict the sales for future periods. **Input**: * A `historical_data` list of tuples, where each tuple contains an integer representing the period (e.g., month number) and a float representing the sales in that period. * An integer `future_periods` indicating the number of future periods for which the sales predictions are required. **Output**: * A list of floats representing the predicted sales for each of the upcoming periods. The length of the list should be equal to `future_periods`. **Function Signature**: ```python def predict_sales(historical_data: list[tuple[int, float]], future_periods: int) -> list[float]: # Function implementation ``` **Constraints**: * The `historical_data` list will have at least 2 elements. * Periods in `historical_data` are consecutive and start from 1. * The sales values in `historical_data` are non-negative floats. * The `future_periods` is a positive integer. **Example**: ```python # Historical Sales Data historical_data = [ (1, 100.0), (2, 150.0), (3, 200.0), (4, 250.0), (5, 300.0) ] # Predict future sales for the next 3 periods future_periods = 3 # Expected output # The predicted sales should show a continued trend based on linear regression print(predict_sales(historical_data, future_periods)) # Output: [350.0, 400.0, 450.0] or close approximations ``` **Hint**: - You might consider using the least squares method to determine the linear regression coefficients. - Use the formula `y = mx + b` for prediction, where `m` is the slope and `b` is the intercept of the regression line.","solution":"def predict_sales(historical_data, future_periods): Predicts future sales using linear regression on historical data. Args: historical_data: a list of tuples, each containing an integer (period) and a float (sales for that period) future_periods: an integer, the number of future periods to predict sales for Returns: A list of floats representing the predicted sales for each of the upcoming periods import numpy as np # Extract periods (x) and sales (y) from historical data periods = np.array([data[0] for data in historical_data]) sales = np.array([data[1] for data in historical_data]) # Calculate the coefficients for the linear regression (y = mx + b) n = len(periods) x_mean = np.mean(periods) y_mean = np.mean(sales) # Calculate the slope (m) and intercept (b) for linear regression m = np.sum((periods - x_mean) * (sales - y_mean)) / np.sum((periods - x_mean) ** 2) b = y_mean - m * x_mean # Predict the sales for future periods predicted_sales = [] for i in range(1, future_periods + 1): future_period = periods[-1] + i predicted_sales.append(m * future_period + b) return predicted_sales"},{"question":"# Problem Statement Given the concept of palindromic numbers and their interesting properties, your task is to implement two functions that handle palindromic numbers in different scenarios. # Function 1: is_palindrome Write a function `is_palindrome(num: int) -> bool` that determines whether the given integer is a palindrome. Input - `num`: An integer (0 ≤ num ≤ 10^6). Output - `True` if `num` is a palindrome; `False` otherwise. Example ```python >>> is_palindrome(121) True >>> is_palindrome(123) False ``` # Function 2: smallest_palindrome_product Write a function `smallest_palindrome_product(digits: int) -> int` that finds the smallest palindromic number which is a product of two `digits`-digit numbers. Input - `digits`: An integer representing the number of digits (1 ≤ digits ≤ 3). Output - An integer representing the smallest palindromic number that is a product of two `digits`-digit numbers. Example ```python >>> smallest_palindrome_product(2) 121 >>> smallest_palindrome_product(3) 10201 ``` # Constraints - You may assume that there is always a palindromic number that is a product of two `digits`-digit numbers. - Optimize the function to work efficiently even for the upper bound of the input range. # Additional Notes 1. Consider checking the palindrome property of a number by converting it to a string and comparing it with its reverse. 2. Optimize the search for palindromic products to ensure the function performance on larger values.","solution":"def is_palindrome(num: int) -> bool: Determines if the given number is a palindrome. Args: - num: An integer (0 ≤ num ≤ 10^6). Returns: - True if num is a palindrome, False otherwise. str_num = str(num) return str_num == str_num[::-1] def smallest_palindrome_product(digits: int) -> int: Finds the smallest palindromic number which is a product of two `digits`-digit numbers. Args: - digits: An integer representing the number of digits (1 ≤ digits ≤ 3). Returns: - The smallest palindromic number that is a product of two `digits`-digit numbers. min_num = 10**(digits-1) max_num = 10**digits - 1 smallest_palindrome = float(\'inf\') for i in range(min_num, max_num + 1): for j in range(i, max_num + 1): # avoid repeating pairs product = i * j if is_palindrome(product): if product < smallest_palindrome: smallest_palindrome = product return smallest_palindrome"},{"question":"# Given Problem You are tasked with implementing a function to check if a given word or phrase is an anagram of another word or phrase. Anagrams are word or phrase pairs that contain the exact same characters with the same frequency, ignoring spaces and case differences. # Requirements 1. **Function Name**: `is_anagram` 2. **Arguments**: - `string1` (str): The first string to compare. - `string2` (str): The second string to compare. 3. **Output**: Return `True` if the strings are anagrams of each other, otherwise return `False`. 4. **Constraints**: - The input strings can contain alphabets and spaces. - Comparison must be case-insensitive. # Examples ```python is_anagram(\'Dormitory\', \'Dirty room\') # Output: True is_anagram(\'The Morse Code\', \'Here come dots\') # Output: True is_anagram(\'Hello\', \'Olelh\') # Output: True is_anagram(\'Test\', \'Taste\') # Output: False ``` # Implementation Write the function `is_anagram` to meet the above requirements. **Function Signature**: ```python def is_anagram(string1: str, string2: str) -> bool: pass ``` **Notes**: - Consider preprocessing the strings to remove spaces and convert to lower case before comparison. - You may utilize in-built string manipulation functions for the comparison.","solution":"def is_anagram(string1, string2): Checks if two strings are anagrams of each other, ignoring spaces and case differences. :param string1: The first string to compare. :param string2: The second string to compare. :return: True if the two strings are anagrams, otherwise False. # Remove spaces and lower the case of both strings cleaned_string1 = \'\'.join(string1.lower().split()) cleaned_string2 = \'\'.join(string2.lower().split()) # Compare the sorted characters of both cleaned strings return sorted(cleaned_string1) == sorted(cleaned_string2)"},{"question":"# Question: Flatten Nested Lists You are given a nested list of integers, where each element is either an integer or another nested list. Your task is to flatten this structure so that all integers are in a single, flat list. # Function Signature ```python def flatten_list(nested_list: list) -> list: # Implement your solution here ``` # Input * A list `nested_list` which contains integers or nested lists of integers. # Output * A list of integers that constitutes the flattened version of `nested_list`. # Constraints * The input list can contain up to 1000 elements. * The depth of the nested lists can be up to 5. * The nested list will only contain integers and other lists, no other types. # Performance Requirements * Your solution should handle lists with maximum depth efficiently. # Example ```python print(flatten_list([1, [2, [3, 4], 5], 6, [[7], 8], 9])) # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9] ``` # Scenario Imagine you\'re working with a complex data structure that stores information in nested lists due to categorization and grouping of related items. However, you need to process this data in a linear fashion. Your task is to flatten these nested lists into a single list. # Additional Test Cases ```python assert flatten_list([1, [2, 3], [4, [5, 6]], 7]) == [1, 2, 3, 4, 5, 6, 7] assert flatten_list([[1, 2, [3]], 4]) == [1, 2, 3, 4] assert flatten_list([[1, [2, [3, [4, 5]]]], 6]) == [1, 2, 3, 4, 5, 6] assert flatten_list([[], [[], [1]], 2]) == [1, 2] assert flatten_list([1]) == [1] ``` Implement a function `flatten_list` to solve the given problem.","solution":"def flatten_list(nested_list: list) -> list: def _flatten(current_list): for item in current_list: if isinstance(item, list): yield from _flatten(item) else: yield item return list(_flatten(nested_list))"},{"question":"# Coding Assessment Question: Palindromic Substring Checker **Context**: A palindromic string is a sequence of characters that reads the same backward as forward. Identifying palindromic substrings has applications in various fields such as bioinformatics, text processing, and string matching algorithms. # Problem Statement Your task is to implement the function `is_palindromic_substring(s: str, start: int, end: int) -> bool` that checks whether the substring of `s` bounded by the indices `start` (inclusive) and `end` (exclusive) is a palindrome. Your function should be efficient and able to handle large strings. # Function Specification * **Input**: * A string `s` (1 <= len(s) <= 10000) * An integer `start` (0 <= start < len(s)) * An integer `end` (start < end <= len(s)) * **Output**: * A boolean indicating whether the specified substring is a palindrome. * **Constraints**: * You should raise a `TypeError` if `start` or `end` is not an integer. * You should raise a `ValueError` if `start` or `end` is out of bounds or if `start` is greater than or equal to `end`. # Examples ```python >>> is_palindromic_substring(\\"racecar\\", 0, 7) True >>> is_palindromic_substring(\\"hello\\", 0, 5) False >>> is_palindromic_substring(\\"a\\", 0, 1) True >>> is_palindromic_substring(\\"abccba\\", 1, 5) True >>> is_palindromic_substring(\\"abccba\\", 1, 6) False >>> is_palindromic_substring(\\"banana\\", 1, 4) False >>> is_palindromic_substring(\\"banana\\", 2, 5) True >>> is_palindromic_substring(\\"hello\\", 0, 6) Traceback (most recent call last): ... ValueError: end index is out of bounds. >>> is_palindromic_substring(\\"hello\\", 3, 2) Traceback (most recent call last): ... ValueError: start index must be less than end index. >>> is_palindromic_substring(\\"world\\", \\"start\\", 4) Traceback (most recent call last): ... TypeError: start and end must be integers. ``` # Guidelines * Ensure the function checks for palindromic property within the given bounds efficiently. * Handle all edge cases, including substring boundaries, non-integer indices, and inconsistent index relationships properly. * Use slicing or two-pointer techniques to determine if the substring is a palindrome.","solution":"def is_palindromic_substring(s: str, start: int, end: int) -> bool: Checks if the substring from start to end-1 of the string s is a palindrome. Args: s (str): The input string. start (int): The starting index of the substring. end (int): The ending index of the substring. Returns: bool: True if the substring is a palindrome, False otherwise. Raises: TypeError: If start or end are not integers. ValueError: If start or end are out of bounds, or if start >= end. if not isinstance(start, int) or not isinstance(end, int): raise TypeError(\\"start and end must be integers.\\") if start < 0 or end > len(s) or start >= end: raise ValueError(\\"Invalid start or end indices.\\") # Extract the substring substring = s[start:end] # Check if the substring is equal to its reverse return substring == substring[::-1]"},{"question":"# Coding Question: Circular Linked List for Kitty\'s Adventures Background: Kitty loves adventures and often finds herself in different places. To remember and traverse the places she visits, she decides to use a circular linked list. Each node in the circular linked list will represent a place Kitty visits. The list should support operations to add a new place, remove a specific place, find if a place exists in the list, and find the total number of places Kitty has visited. Task: Implement the following operations in your CircularLinkedList class: 1. **Add Place**: Add a new place to the circular linked list. 2. **Remove Place**: Remove an existing place from the circular linked list. 3. **Find Place**: Check if a place exists in the circular linked list. 4. **Count Places**: Return the number of places in the circular linked list. Your CircularLinkedList class must have the following methods implementing the required operations: ```python class Place: def __init__(self, name: str): Initialize a place with the given name. :param name: Name of the place. self.name = name self.next = None class CircularLinkedList: def __init__(self): Initialize an empty circular linked list. self.head = None def add_place(self, name: str) -> None: Add a new place to the circular linked list. :param name: Name of the place. pass def remove_place(self, name: str) -> bool: Remove a specified place from the circular linked list. :param name: Name of the place. :return: True if the place was removed, False if the place was not found. pass def find_place(self, name: str) -> bool: Check if a specified place exists in the circular linked list. :param name: Name of the place. :return: True if the place exists, False otherwise. pass def count_places(self) -> int: Return the number of places in the circular linked list. :return: Number of places. pass ``` Input/Output Format: * `add_place(name: str)` - Adds a new place with the specified name. * `remove_place(name: str)` - Returns True if the place was found and removed, otherwise False. * `find_place(name: str)` - Returns True if the place exists, otherwise False. * `count_places()` - Returns the number of places in the circular linked list. Constraints: * Names of the places are unique alphanumeric strings. * The number of places will not exceed 10^5. Example Usage: ```python # Example initialization and operations places_list = CircularLinkedList() places_list.add_place(\\"Park\\") places_list.add_place(\\"Mall\\") places_list.add_place(\\"Zoo\\") print(places_list.count_places()) # Output: 3 print(places_list.find_place(\\"Mall\\")) # Output: True print(places_list.find_place(\\"Beach\\")) # Output: False print(places_list.remove_place(\\"Mall\\")) # Output: True print(places_list.count_places()) # Output: 2 ``` Ensure that your implementation handles the circular nature of the linked list and performs operations efficiently regardless of the list size.","solution":"class Place: def __init__(self, name: str): Initialize a place with the given name. :param name: Name of the place. self.name = name self.next = None class CircularLinkedList: def __init__(self): Initialize an empty circular linked list. self.head = None def add_place(self, name: str) -> None: Add a new place to the circular linked list. :param name: Name of the place. new_place = Place(name) if not self.head: self.head = new_place new_place.next = self.head else: current = self.head while current.next != self.head: current = current.next current.next = new_place new_place.next = self.head def remove_place(self, name: str) -> bool: Remove a specified place from the circular linked list. :param name: Name of the place. :return: True if the place was removed, False if the place was not found. if not self.head: return False if self.head.name == name: if self.head.next == self.head: self.head = None return True else: current = self.head while current.next != self.head: current = current.next current.next = self.head.next self.head = self.head.next return True previous = None current = self.head while current.next != self.head: if current.name == name: break previous = current current = current.next if current.name == name: previous.next = current.next return True return False def find_place(self, name: str) -> bool: Check if a specified place exists in the circular linked list. :param name: Name of the place. :return: True if the place exists, False otherwise. if not self.head: return False current = self.head while True: if current.name == name: return True current = current.next if current == self.head: break return False def count_places(self) -> int: Return the number of places in the circular linked list. :return: Number of places. if not self.head: return 0 count = 0 current = self.head while True: count += 1 current = current.next if current == self.head: break return count"},{"question":"# Data Analysis: Moving Average Calculation A data analyst needs to determine the moving average of a given set of data points. The moving average is calculated by taking the average of a specified number of consecutive elements in the data set. Given a list of integers representing the data points and an integer representing the window size, the task is to calculate the moving average for each possible window in the data set. # Task Implement a function that computes the moving average for a given list of integers and a specified window size. Function Signature ```python def moving_average(data: list, window_size: int) -> list: Calculates the moving average for a given list of integers and window size. Parameters: data (list): A list of integers representing the data points. window_size (int): The number of consecutive elements to consider for the moving average. Returns: list: A list of floats representing the moving averages. Raises: TypeError: If data is not a list or window_size is not an integer. ValueError: If window_size is less than 1 or exceeds the length of the data. pass ``` # Constraints 1. The `data` should be a list of integers. 2. The `window_size` should be a positive integer less than or equal to the length of the data list. 3. If these constraints are not met, raise appropriate exceptions (`TypeError` or `ValueError`). # Expected Output Format The function should return a list of floats representing the moving averages for each possible window in the data set. # Examples ```python assert moving_average([1, 2, 3, 4, 5], 2) == [1.5, 2.5, 3.5, 4.5] assert moving_average([1, 2, 3, 4, 5], 3) == [2.0, 3.0, 4.0] ``` # Hints 1. You may use list slicing to consider each window of data points. 2. Ensure you perform input validation before any calculations. # Notes * The moving average for a window size of 2 in the list `[1, 2, 3, 4, 5]` is calculated as: - `(1 + 2) / 2 = 1.5` - `(2 + 3) / 2 = 2.5` - `(3 + 4) / 2 = 3.5` - `(4 + 5) / 2 = 4.5` * The function should handle edge cases such as single-element window size (which returns the data list itself) or the window size equal to the length of the data list (which returns the average of the entire list).","solution":"def moving_average(data: list, window_size: int) -> list: Calculates the moving average for a given list of integers and window size. Parameters: data (list): A list of integers representing the data points. window_size (int): The number of consecutive elements to consider for the moving average. Returns: list: A list of floats representing the moving averages. Raises: TypeError: If data is not a list or window_size is not an integer. ValueError: If window_size is less than 1 or exceeds the length of the data. if not isinstance(data, list): raise TypeError(\\"data must be a list\\") if not all(isinstance(i, int) for i in data): raise ValueError(\\"all elements in data must be integers\\") if not isinstance(window_size, int): raise TypeError(\\"window_size must be an integer\\") if window_size < 1 or window_size > len(data): raise ValueError(\\"window_size must be greater than 0 and less than or equal to the length of data\\") moving_averages = [] for i in range(len(data) - window_size + 1): window = data[i:i + window_size] average = sum(window) / window_size moving_averages.append(average) return moving_averages"},{"question":"# Coding Question: Implement a Function to Detect Islands in a 2D Grid Context: In a 2D grid, an island is defined as a group of `1`s (land) connected vertically or horizontally. The grid is surrounded by water represented by `0`s (water). Your task is to implement a function to count the number of distinct islands in the grid. Task: 1. Implement the `count_islands` function as defined below. 2. Use Depth-First Search (DFS) to traverse and mark the visited cells to avoid counting the same island multiple times. Function Signature: ```python def count_islands(grid: list) -> int: Counts the number of distinct islands in the given 2D grid. Parameters: grid (list): A 2D list of integers where 1 represents land and 0 represents water. Returns: int: The number of distinct islands. ``` Example: ```python # Example input input_grid = [ [1, 1, 0, 0, 0], [1, 1, 0, 0, 1], [0, 0, 1, 0, 1], [0, 0, 0, 1, 1] ] # Expected output 3 ``` Constraints: * The input grid is a non-empty 2D list with dimensions M x N, where 1 ≤ M, N ≤ 300. * The grid only contains 0s and 1s. Objective: Ensure your implementation correctly counts and returns the number of distinct islands in the provided 2D grid.","solution":"def count_islands(grid: list) -> int: Counts the number of distinct islands in the given 2D grid. Parameters: grid (list): A 2D list of integers where 1 represents land and 0 represents water. Returns: int: The number of distinct islands. if not grid: return 0 def dfs(x, y): if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]) or grid[x][y] == 0: return grid[x][y] = 0 # mark as visited dfs(x + 1, y) dfs(x - 1, y) dfs(x, y + 1) dfs(x, y - 1) count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: dfs(i, j) count += 1 return count"},{"question":"# Coding Question: Implement an Efficient Interval Management System **Scenario**: You are implementing a system for managing time intervals efficiently. The system should support operations to add intervals and merge them efficiently. This is particularly useful for various scheduling, booking, or timeline management applications where combining overlapping intervals is a common requirement. **Given**: A class `IntervalManager` which handles time intervals represented as tuples of start and end times `(start, end)`. **Instructions**: 1. Implement the `IntervalManager` class with the following methods: - `__init__(self)`: Initialize your data structures. - `addInterval(self, interval: Tuple[int, int]) -> None`: Adds a new interval to the system, merging it with any overlapping intervals. - `getIntervals(self) -> List[Tuple[int, int]]`: Returns a list of non-overlapping intervals sorted by start time. **Constraints**: - Intervals are given as tuples `(start, end)` with `0 <= start < end <= 10^9`. - Your system should handle a large number of intervals efficiently. - Ensure the merging process is optimized. **Example**: ```python im = IntervalManager() im.addInterval((1, 3)) im.addInterval((2, 6)) im.addInterval((8, 10)) im.addInterval((15, 18)) print(im.getIntervals()) # Output: [(1, 6), (8, 10), (15, 18)] im.addInterval((5, 9)) print(im.getIntervals()) # Output: [(1, 10), (15, 18)] ``` **Required Classes and Methods** (Interface): ```python class IntervalManager: def __init__(self): # Initialize necessary data structures. def addInterval(self, interval: Tuple[int, int]) -> None: # Add interval to the data structure, merging overlaps if necessary. def getIntervals(self) -> List[Tuple[int, int]]: # Return the merged non-overlapping intervals sorted by start time. ``` Please ensure your solution is optimized for handling a large number of interval operations efficiently.","solution":"from typing import List, Tuple class IntervalManager: def __init__(self): self.intervals = [] def addInterval(self, interval: Tuple[int, int]) -> None: self.intervals.append(interval) self.intervals.sort() merged_intervals = [] for start, end in self.intervals: if not merged_intervals or merged_intervals[-1][1] < start: merged_intervals.append((start, end)) else: merged_intervals[-1] = (merged_intervals[-1][0], max(merged_intervals[-1][1], end)) self.intervals = merged_intervals def getIntervals(self) -> List[Tuple[int, int]]: return self.intervals"},{"question":"# Coding Challenge: Find the First Non-Repeating Character Given a string, write a function `first_non_repeating_character(s: str) -> int` that: - Returns the index of the first non-repeating character in the string. - If there are no non-repeating characters, return -1. A non-repeating character is defined as a character that appears only once in the string. Input: - A string `s` containing lowercase English letters. Output: - An integer representing the index of the first non-repeating character, or -1 if no such character exists. Constraints: - The length of the string `s` will not exceed 100,000. Example: Input: `\\"leetcode\\"` Output: `0` (The first non-repeating character is \'l\' and is at index 0.) Input: `\\"loveleetcode\\"` Output: `2` (The first non-repeating character is \'v\' and is at index 2.) Input: `\\"aabbcc\\"` Output: `-1` (There are no non-repeating characters.) Note: You should consider the efficiency of your solution, both in terms of time and space complexity. It might be helpful to use a data structure that allows you to count the occurrences of each character efficiently.","solution":"def first_non_repeating_character(s: str) -> int: Returns the index of the first non-repeating character in the string. If there are no non-repeating characters, returns -1. # Dictionary to store the count of each character char_count = {} # First pass: count each character in the string for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Second pass: find the first character with count 1 for index, char in enumerate(s): if char_count[char] == 1: return index # If no non-repeating character is found, return -1 return -1"},{"question":"# Coding Assessment Question Scenario: You are developing a network packet analysis tool that inspects and summarizes the type of data flowing through a network. One of the tasks involves parsing and validating IPv4 addresses. An IPv4 address is represented by four decimal numbers (each between 0 and 255), separated by dots, e.g., `192.168.0.1`. Task: Write a Python function `validate_ipv4(address: str) -> bool` that: * Takes a single string `address`. * Checks if the string is a valid IPv4 address. * Returns `True` if the address is valid, otherwise it returns `False`. # Specifications: * **Input**: A single string `address`. * **Output**: A boolean value. # Constraints: * An IPv4 address consists of exactly four decimal numbers, each ranging from 0 to 255, separated by dots. * Each number should not have leading zeros, unless it is zero itself. * If the input is an empty string or not a string, your function should raise a `TypeError` with the appropriate error message. Example Inputs and Outputs: 1. `validate_ipv4(\\"192.168.0.1\\")` should return `True` 2. `validate_ipv4(\\"255.255.255.255\\")` should return `True` 3. `validate_ipv4(\\"0.0.0.0\\")` should return `True` 4. `validate_ipv4(\\"256.100.50.25\\")` should return `False` 5. `validate_ipv4(\\"192.168@1.1\\")` should return `False` # Edge Cases: 1. If the input is `\\"\\"` (empty string), raise `TypeError` with the message \\"Input value must be a non-empty string\\". 2. If the input is not a string, raise `TypeError` with the message \\"Input value must be of type \'str\'\\". # Example Error Handling: 1. `validate_ipv4(\\"\\")` should raise a `TypeError` with the message \\"Input value must be a non-empty string\\". 2. `validate_ipv4(1234)` should raise a `TypeError` with the message \\"Input value must be of type \'str\'\\". # Note: Ensure your function correctly handles all specified edge cases and validates the address strictly according to the given rules.","solution":"def validate_ipv4(address: str) -> bool: Validates if the given address is a valid IPv4 address. Parameters: address (str): The IPv4 address to validate. Returns: bool: True if the address is a valid IPv4 address, otherwise False. Raises: TypeError: If address is not a string or is an empty string. if not isinstance(address, str): raise TypeError(\\"Input value must be of type \'str\'\\") if address == \\"\\": raise TypeError(\\"Input value must be a non-empty string\\") parts = address.split(\\".\\") if len(parts) != 4: return False for part in parts: if not part.isdigit(): return False num = int(part) if num < 0 or num > 255: return False # Check for leading zeros if part != str(num): return False return True"},{"question":"# Coding Assessment Question You are tasked with creating a string merging function that alternates characters from two input strings. The current implementation, `merge_alternate`, does not handle cases where input strings are of unequal length and struggles with cases involving non-alphabetic characters. Your goal is to improve the `merge_alternate` function with the following features: 1. **Handle strings of unequal length** by appending the remaining characters from the longer string once the shorter string\'s characters are exhausted. 2. Include **punctuation marks and special characters** in the merged output in their original positions. 3. Consider edge cases such as empty strings and provide meaningful output for these cases. # Function Signature ```python def enhanced_merge_alternate(str1: str, str2: str) -> str: pass ``` # Input and Output * **Input**: * `str1`: The first string to be merged. * `str2`: The second string to be merged. * **Output**: * Returns a new string where characters are alternately taken from `str1` and `str2`. Remaining characters from the longer string are appended at the end. # Constraints * Empty string inputs are allowed, and the function should return the non-empty string if one input is empty. * No use of external libraries for string manipulation is allowed. # Examples ```python >>> enhanced_merge_alternate(\\"abc\\", \\"123\\") \'a1b2c3\' >>> enhanced_merge_alternate(\\"abcd\\", \\"123\\") \'a1b2c3d\' >>> enhanced_merge_alternate(\\"\\", \\"xyz!\\") \'xyz!\' >>> enhanced_merge_alternate(\\"hello\\", \\"\\") \'hello\' >>> enhanced_merge_alternate(\\"!@#\\", \\"%^\\") \'!@%^#\' ``` # Notes * Pay attention to the order of characters from both strings; `str1`\'s characters should start the alternating sequence. * Maintain the integrity of non-alphabetic characters in their alternated sequence. * Ensure your function deals properly with edge cases such as mixed-length input and empty strings, as shown in the examples.","solution":"def enhanced_merge_alternate(str1: str, str2: str) -> str: Merges two strings by alternating characters, and appends the remaining characters from the longer string at the end. merged = [] len1, len2 = len(str1), len(str2) min_len = min(len1, len2) for i in range(min_len): merged.append(str1[i]) merged.append(str2[i]) if len1 > min_len: merged.append(str1[min_len:]) elif len2 > min_len: merged.append(str2[min_len:]) return \'\'.join(merged)"},{"question":"# Predicting House Prices with Linear Regression You are given a dataset containing information about houses and their respective prices. Your task is to implement a linear regression model to predict the sale price of a house based on its features. **Function Signature**: ```python def train_linear_regression(features: np.ndarray, labels: np.ndarray) -> Tuple[np.ndarray, float]: pass def predict_house_price(features: np.ndarray, weights: np.ndarray, bias: float) -> np.ndarray: pass ``` **Input**: - `features`: A 2D numpy array of shape `(n_samples, n_features)`, where `n_samples` is the number of samples and `n_features` is the number of features per sample. - `labels`: A 1D numpy array of shape `(n_samples,)` containing the actual house prices. **Output (for train_linear_regression)**: - `weights`: A 1D numpy array of shape `(n_features,)` containing the weights learned by the linear regression model. - `bias`: A float representing the bias term learned by the model. **Output (for predict_house_price)**: - `predictions`: A 1D numpy array of shape `(n_samples,)` containing the predicted house prices. **Constraints**: - Ensure that your linear regression implementation uses the closed-form solution (normal equation) for weight calculation. - All inputs must be provided in the appropriate formats and will contain valid data. - Aim for numerical stability and avoid overflows or underflows during calculations. # Implementation **Steps to follow**: 1. Compute the weights using the normal equation: ( mathbf{w} = (mathbf{X}^T mathbf{X})^{-1} mathbf{X}^T mathbf{y} ). 2. Compute the bias term as the mean of residuals. 3. Use the calculated weights and bias to predict house prices for new data. # Example ```python import numpy as np # Sample training data: features and labels features = np.array([ [1400, 3], [1600, 3], [1700, 2], [1875, 3], [1100, 2], [1550, 3], [2350, 4], [2450, 4], [1425, 3], [1700, 3] ]) prices = np.array([245000, 312000, 279000, 308000, 199000, 219000, 405000, 324000, 319000, 255000]) # Training the linear regression model weights, bias = train_linear_regression(features, prices) # Sample data to predict prices new_features = np.array([ [1500, 3], [1800, 4] ]) # Predicting house prices predicted_prices = predict_house_price(new_features, weights, bias) print(predicted_prices) ``` Write your implementations for the `train_linear_regression` and `predict_house_price` functions below, ensuring adherence to the above specifications and requirements.","solution":"import numpy as np from typing import Tuple def train_linear_regression(features: np.ndarray, labels: np.ndarray) -> Tuple[np.ndarray, float]: # Adding a column of ones to features to account for the bias term X = np.hstack([np.ones((features.shape[0], 1)), features]) # Using the normal equation to compute weights # w = (X^T X)^-1 X^T y XtX = X.T @ X XtX_inv = np.linalg.inv(XtX) Xty = X.T @ labels weights_with_bias = XtX_inv @ Xty bias = weights_with_bias[0] weights = weights_with_bias[1:] return weights, bias def predict_house_price(features: np.ndarray, weights: np.ndarray, bias: float) -> np.ndarray: # y = Xw + b predictions = features @ weights + bias return predictions"},{"question":"# Problem Statement You are tasked with writing a function that computes the smallest positive integer which, when its digits are summed, gives a specified target sum and also starts with a specified leading digit. Function Signature ```python def find_smallest_number_with_sum_and_leading_digit(target_sum: int, leading_digit: int) -> int: pass ``` Input: * An integer `target_sum`, indicating the target sum of the digits of the resultant number. * An integer `leading_digit`, indicating the leading digit of the resultant number. Output: * An integer representing the smallest positive number whose digits sum to `target_sum` and start with `leading_digit`. Constraints: 1. `1 <= target_sum <= 100` 2. `1 <= leading_digit <= 9` Examples: ```python assert find_smallest_number_with_sum_and_leading_digit(10, 3) == 37 assert find_smallest_number_with_sum_and_leading_digit(15, 6) == 69 assert find_smallest_number_with_sum_and_leading_digit(12, 7) == 75 ``` # Contextual Background Given the requirements to form a number with a specific digit sum and leading digit, your function should explore the combination of digits in an optimal way to ensure the smallest numerical result. This problem can be addressed by systematically constructing the number while keeping the constraints in mind. Write an efficient solution to generate and check possible numbers until the conditions are met. The solution should minimize computational complexity since the target sum and leading digit constraints are relatively small.","solution":"def find_smallest_number_with_sum_and_leading_digit(target_sum: int, leading_digit: int) -> int: Finds the smallest positive integer that starts with the specified leading_digit and whose digits sum up to the target_sum. # The number should start with the leading_digit # If the sum without the leading digit is greater than or equal to 0, continue composing the number. remaining_sum = target_sum - leading_digit if remaining_sum < 0: return -1 # Invalid case, target_sum is less than the leading digit. # Start building the result number as a string to facilitate digit manipulation. result = [leading_digit] # Fill other digits starting from the end (units place) to the start (left) while remaining_sum >= 9: result.append(9) remaining_sum -= 9 if remaining_sum > 0: result.append(remaining_sum) # Ensure the number is formed correctly with the leading digit, # the digits in the result list should be arranged in ascending order except the leading digit. result = [result[0]] + sorted(result[1:]) # Convert list of digits back to integer return int(\'\'.join(map(str, result)))"},{"question":"# Question You are a software engineer working on a data analysis library. Your task is to write a function that normalizes a dataset stored in a 2D NumPy array such that each feature (column) has a mean of 0 and a standard deviation of 1. This is also known as Z-score normalization. # Function Description Implement the function `normalize_dataset` which takes in a 2D NumPy array representing the dataset and returns the normalized dataset. # Input * A 2D NumPy array `dataset` of shape (n_samples, n_features), where n_samples is the number of samples and n_features is the number of features. # Output * A 2D NumPy array of the same shape as the input dataset, with each feature normalized to have a mean of 0 and a standard deviation of 1. # Constraints * The input array `dataset` will have at least one sample and one feature. * The values in the dataset are floating-point numbers. # Performance Requirements * Your function should handle datasets with up to 100,000 samples and 1,000 features efficiently. # Example ```python import numpy as np def normalize_dataset(dataset: np.ndarray) -> np.ndarray: mean = np.mean(dataset, axis=0) std = np.std(dataset, axis=0) std[std == 0] = 1 # Prevent division by zero normalized_data = (dataset - mean) / std return normalized_data # Example usage: dataset = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0]]) normalized_dataset = normalize_dataset(dataset) print(normalized_dataset) ``` In the above example, the `normalize_dataset` function will normalize each feature of the dataset such that they all have a mean of 0 and a standard deviation of 1.","solution":"import numpy as np def normalize_dataset(dataset: np.ndarray) -> np.ndarray: Normalizes the dataset such that each feature has a mean of 0 and a standard deviation of 1. Parameters: dataset (np.ndarray): 2D array of shape (n_samples, n_features). Returns: np.ndarray: Normalized dataset with the same shape as input. mean = np.mean(dataset, axis=0) std = np.std(dataset, axis=0) std[std == 0] = 1 # Prevent division by zero if a feature has zero standard deviation normalized_data = (dataset - mean) / std return normalized_data # Example usage: dataset = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0]]) normalized_dataset = normalize_dataset(dataset) print(normalized_dataset)"},{"question":"# Task: Implementing a LRU Cache As a software engineer at a tech company, you are tasked with optimizing the caching mechanisms in a web application to improve performance. One critical component is implementing a Least Recently Used (LRU) cache system. # Problem Statement You need to design and implement an efficient LRU cache. This cache should support the following operations: `get` and `put`. When the cache reaches its capacity, it should invalidate the least recently used item before inserting a new item. Your solution should have O(1) time complexity for both `get` and `put` operations by using appropriate data structures. # Requirements * Implement a class `LRUCache` with the following methods: - `__init__(capacity: int)`: Initialize the LRU cache with a given capacity. - `get(key: int) -> int`: Return the value of the key if the key exists in the cache; otherwise, return -1. - `put(key: int, value: int) -> None`: Insert or update the value if the key is not already present. If the cache has reached its capacity, invalidate the least recently used item before inserting the new item. # Constraints * The number of `get` and `put` operations will be between 1 and 100,000. * The capacity is between 1 and 10,000. * The key and value are non-negative integers. # Input Format * For the `LRUCache` class: an integer `capacity` representing the cache capacity. * For the `get` method: an integer `key` representing the key to access. * For the `put` method: two integers `key` and `value` to insert or update in the cache. # Output Format * For the `get` method: an integer representing the value of the specified key, or -1 if the key does not exist. * For the `put` method: no output. # Example ```python class LRUCache: def __init__(self, capacity: int): # Your initialization code here def get(self, key: int) -> int: # Your get method implementation here def put(self, key: int, value: int) -> None: # Your put method implementation here # Example Usage: cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) print(cache.get(1)) # Output: 1 cache.put(3, 3) # This operation will invalidate key 2 print(cache.get(2)) # Output: -1 (key 2 was invalidated) cache.put(4, 4) # This operation will invalidate key 1 print(cache.get(1)) # Output: -1 (key 1 was invalidated) print(cache.get(3)) # Output: 3 print(cache.get(4)) # Output: 4 ``` # Considerations 1. Use appropriate data structures such as an OrderedDict in Python to maintain the order of insertion and support O(1) time complexities. 2. Ensure that the implementation is robust and can handle a large number of `get` and `put` operations efficiently.","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = OrderedDict() def get(self, key: int) -> int: if key not in self.cache: return -1 else: self.cache.move_to_end(key) return self.cache[key] def put(self, key: int, value: int) -> None: if key in self.cache: self.cache.move_to_end(key) self.cache[key] = value if len(self.cache) > self.capacity: self.cache.popitem(last=False)"},{"question":"# Problem Statement You are tasked with implementing a function to flatten a nested list of integers while maintaining the order of elements as they appear in the input structure. The input list can contain other lists to any nesting depth, and your function should handle these appropriately. Implementation Details Implement the function `flatten_list(nested_list: list) -> list` that takes a nested list of integers and returns a flat list of those integers in the same order. Constraints 1. The input list can contain integers and other lists of integers, which may be nested to any depth. 2. If nested lists contain elements that are not integers, a `TypeError` should be raised. 3. The output list should contain all the integers from the nested structure, preserving their order. 4. Ensure that the function handles deeply nested structures efficiently. Input and Output Formats *Input*: * `nested_list`: A list, potentially containing other lists, with integer elements. *Output*: * A flat list of integers in the same order as they appear in the input structure. Example ```python >>> flatten_list([1, [2, 3], [[4, 5], 6], 7]) [1, 2, 3, 4, 5, 6, 7] >>> flatten_list([1, [2, [3, [4, [5]]]]]) [1, 2, 3, 4, 5] >>> flatten_list([3, [2, [1, 0], -1], -2]) Traceback (most recent call last): ... TypeError: All elements must be integers within the nested lists >>> flatten_list([4, [5, 6, [7, 8]], [9]]) [4, 5, 6, 7, 8, 9] >>> flatten_list([[1, 2, [3, 4]], 5]) [1, 2, 3, 4, 5] ``` Performance Requirements 1. Ensure the function efficiently handles various depths of nesting. 2. Time Complexity should be O(n), where n is the total number of integers in the nested structure. 3. Minimize any unnecessary memory usage for deep nesting scenarios.","solution":"def flatten_list(nested_list): Flattens a nested list of integers, maintaining the order of elements. Args: nested_list (list): The input list containing nested lists of integers. Returns: list: A flattened list of integers. Raises: TypeError: If any elements in the nested lists are not integers. def flatten_helper(lst): for item in lst: if isinstance(item, list): yield from flatten_helper(item) elif isinstance(item, int): yield item else: raise TypeError(\\"All elements must be integers within the nested lists\\") return list(flatten_helper(nested_list))"},{"question":"# Problem Description Given a string s, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order. The string consists of words and spaces, where a word is defined as a sequence of non-space characters. There will be at least one word in the input string. # Function Signature ```python def reverse_words_in_string(s: str) -> str: ``` # Input - **s**: A string that consists of words and spaces. (e.g., \\"Let\'s take LeetCode contest\\") # Output - A string where the characters in each word are reversed while the word order is maintained. (e.g., \\"s\'teL ekat edoCteeL tsetnoc\\") # Constraints - 1 <= len(s) <= (10^4) - The string s only consists of printable ASCII characters and spaces. - There are no leading or trailing spaces. - There is at least one word in the s. - Spaces separate words by exactly one space. # Example ```python # Example 1 s = \\"Let\'s take LeetCode contest\\" # Output: \\"s\'teL ekat edoCteeL tsetnoc\\" # Example 2 s = \\"hello world\\" # Output: \\"olleh dlrow\\" # Example 3 s = \\"a\\" # Output: \\"a\\" ``` # Requirements: - The solution should have a linear time complexity, i.e., O(n), where n is the length of the input string. - The solution should use only O(1) extra space, not counting the input and output string.","solution":"def reverse_words_in_string(s: str) -> str: Reverse the characters in each word of the given string while preserving whitespace and word order. :param s: Sentence consisting of words and spaces. :return: Sentence with each word reversed. return \' \'.join(word[::-1] for word in s.split(\' \'))"},{"question":"**Problem Statement: Array Rotation Challenge** You are tasked with implementing a function that rotates the elements of an array to the right by a specified number of steps. Given an array of integers and a non-negative integer ( k ), you need to return the array after rotating it ( k ) times to the right. # Function Signature ```python def rotate_array(arr: list[int], k: int) -> list[int]: pass ``` # Input * (text{arr}) (0 ≤ text{len(arr)} ≤ 10^5)): A list of integers. * (text{k}) (0 ≤ text{k} ≤ 10^5))): A non-negative integer. # Output * Returns the list of integers after rotating it ( k ) times to the right. # Example ```python >>> rotate_array([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_array([0, 1, 2], 4) [2, 0, 1] >>> rotate_array([], 3) [] ``` # Constraints * The function should handle edge cases, such as an empty array or ( k = 0 ). * Ensure the function runs efficiently for larger values of ( k ) and longer arrays. # Notes 1. **Rotation Logic**: - Consider using slicing to achieve the rotation efficiently. - To achieve the desired rotation, you can use the property that rotating ( k ) times where ( k ) is greater than the array length is equivalent to rotating ( k % text{len(arr)} ) times. 2. **Edge Cases**: - If ( text{len(arr)} = 0 ) or ( k = 0 ), the output should be the original array.","solution":"def rotate_array(arr, k): Rotates the elements of arr to the right by k steps. Args: arr: List[int] - The input list of integers. k: int - The number of steps to rotate the list. Returns: List[int] - The rotated list. if not arr or k == 0: return arr k %= len(arr) return arr[-k:] + arr[:-k]"},{"question":"# Secure String Hashing Context When working on applications that handle user credentials securely, it is important to hash passwords before storing them in a database to protect against unauthorized access. A secure hashing algorithm applies a one-way transformation to the input data, which is computationally infeasible to reverse. This question requires you to implement and test a secure password hashing function using a well-known cryptographic hash algorithm. Task Implement a function to securely hash passwords using the SHA-256 algorithm. Ensure the hash function is correctly integrating salts to provide enhanced security. Specific Objectives 1. **Hash Function**: Write a function that hashes a given password using SHA-256. 2. **Salting**: Enhance the basic hashing mechanism by adding a unique salt to each password before hashing. 3. **Verification**: Provide a way to verify that a given password matches a previously hashed password. Function Signature ```python import hashlib import os def hash_password(password: str, salt: bytes = None) -> str: pass def verify_password(stored_password_hash: str, provided_password: str) -> bool: pass ``` Input - `password`: A string representing the password to be hashed. - `salt`: An optional byte string to be used as the salt. If not provided, generate a new random salt. Output - `hash_password` returns a hexadecimal string representing the hashed password concatenated with the salt. - `verify_password` returns a boolean indicating whether the provided password matches the stored hashed password. Constraints - Passwords can be any string with length between 8 and 128 characters. - Salt length should be 16 bytes. Requirements - Use the SHA-256 algorithm for hashing. - Generate a random 16-byte salt if not provided. - The hashed password should be a concatenation of the salt and the hashed result. - Securely verify passwords by extracting and using the salt stored within the hashed password. Example ```python def hash_password(password: str, salt: bytes = None) -> str: if salt is None: salt = os.urandom(16) hashed = hashlib.sha256(salt + password.encode()).hexdigest() return salt.hex() + hashed def verify_password(stored_password_hash: str, provided_password: str) -> bool: salt = bytes.fromhex(stored_password_hash[:32]) stored_hash = stored_password_hash[32:] new_hash = hashlib.sha256(salt + provided_password.encode()).hexdigest() return new_hash == stored_hash if __name__ == \\"__main__\\": password = \\"SuperSecurePassword123\\" stored_hash = hash_password(password) print(f\\"Stored Hash: {stored_hash}\\") # Verification assert verify_password(stored_hash, \\"SuperSecurePassword123\\") == True assert verify_password(stored_hash, \\"WrongPassword\\") == False ``` Good luck!","solution":"import hashlib import os def hash_password(password: str, salt: bytes = None) -> str: if salt is None: # Generate a random 16-byte salt salt = os.urandom(16) # Hash the combination of salt and password using SHA-256 hashed = hashlib.sha256(salt + password.encode()).hexdigest() # Return the concatenation of the salt (converted to hex) and the hashed result return salt.hex() + hashed def verify_password(stored_password_hash: str, provided_password: str) -> bool: # The salt is the first 32 hex characters (which represent 16 bytes) salt = bytes.fromhex(stored_password_hash[:32]) # The actual hashed password is the remaining part of the stored password hash stored_hash = stored_password_hash[32:] # Hash the provided password with the extracted salt new_hash = hashlib.sha256(salt + provided_password.encode()).hexdigest() # Compare the newly created hash with the stored hash return new_hash == stored_hash"},{"question":"A Social Network Friend Recommendation System You are provided with a graph representing a social network. The nodes denote individuals, and the edges denote friendships between them. Your task is to implement a function that, given an individual\'s node, recommends potential new friends. The recommendation should be based on mutual friends – the function should return friends of friends who are not already directly connected to the individual. # Function Signature: ```python def recommend_friends(graph: dict, person: int) -> list: ``` # Input: - `graph`: A dictionary representing an undirected graph. The keys represent individual identifiers, and the values are lists of connected individuals (friends). - `person`: An integer representing the node for which friend recommendations are to be made. # Output: - Returns a list of integers representing recommended friends for the individual. - The list should be sorted in ascending order. - If there are no potential friends to recommend, the function should return an empty list. # Constraints: - Each individual identifier is a positive integer. - The graph may be of any size within reasonable limits (assume up to 1000 nodes). - The graph may be disconnected. # Example ```python graph = { 1: [2, 3], 2: [1, 4], 3: [1, 5], 4: [2, 5, 6], 5: [3, 4], 6: [4], 7: [] } print(recommend_friends(graph, 1)) # Output: [4, 5] print(recommend_friends(graph, 2)) # Output: [3, 5, 6] print(recommend_friends(graph, 3)) # Output: [2, 4] print(recommend_friends(graph, 6)) # Output: [2, 5] print(recommend_friends(graph, 7)) # Output: [] ``` # Explanation: - For `person` 1, mutual friends (friends of friends) are 4 and 5 (friend of 2 and 3, respectively), who are not directly connected to 1. - For `person` 2, mutual friends are 3, 5, and 6 (friends of 1 and 4, respectively), who are not directly connected to 2. - For `person` 3, mutual friends are 2 and 4 (friends of 1 and 5), who are not directly connected to 3. - For `person` 6, mutual friends are 2 and 5 (friends of 4), who are not directly connected to 6. - For `person` 7, there are no friends, so no recommendations can be made.","solution":"def recommend_friends(graph: dict, person: int) -> list: Recommends friends for the given person based on mutual friends. :param graph: A dictionary representing an undirected graph. :param person: An integer representing the individual\'s node in the graph. :returns: A list of recommended friends for the individual sorted in ascending order. if person not in graph: return [] direct_friends = set(graph[person]) potential_friends = set() for friend in direct_friends: for foaf in graph[friend]: # foaf: friend of a friend if foaf != person and foaf not in direct_friends: potential_friends.add(foaf) return sorted(potential_friends) # Example usage graph = { 1: [2, 3], 2: [1, 4], 3: [1, 5], 4: [2, 5, 6], 5: [3, 4], 6: [4], 7: [] } print(recommend_friends(graph, 1)) # Output: [4, 5] print(recommend_friends(graph, 2)) # Output: [3, 5, 6] print(recommend_friends(graph, 3)) # Output: [2, 4] print(recommend_friends(graph, 6)) # Output: [2, 5] print(recommend_friends(graph, 7)) # Output: []"},{"question":"Question: Implement a Simple Database Filter You are required to implement a basic database filtering functionality. Consider a very simple database as a list of dictionaries, where each dictionary represents a record. # Tasks to Implement: 1. **Filter records by field value**: Implement a function to filter the records based on a specific field and value. ```python def filter_by_field(records: List[Dict[str, Any]], field: str, value: Any) -> List[Dict[str, Any]]: pass ``` 2. **Filter records by multiple criteria (AND logic)**: Implement a function to filter the records that meet all specified criteria. ```python def filter_by_multiple_criteria(records: List[Dict[str, Any]], criteria: Dict[str, Any]) -> List[Dict[str, Any]]: pass ``` 3. **Sort records by a field**: Implement a function to sort the records based on a specific field, either in ascending or descending order. ```python def sort_by_field(records: List[Dict[str, Any]], field: str, ascending: bool = True) -> List[Dict[str, Any]]: pass ``` 4. **Select specific fields**: Implement a function to select and return only specified fields from each record. ```python def select_fields(records: List[Dict[str, Any]], fields: List[str]) -> List[Dict[str, Any]]: pass ``` 5. **Transform field values**: Implement a function to apply a given transformation function to a specified field in all records. ```python def transform_field(records: List[Dict[str, Any]], field: str, transform_fn: Callable[[Any], Any]) -> List[Dict[str, Any]]: pass ``` # Input & Output Specifications: - `records` is a list of dictionaries, where each dictionary represents a database record. - `field` is a string corresponding to a key in the dictionaries. - `value` can be any valid value to compare against. - `criteria` is a dictionary where keys are string field names, and values are the values to match. - `ascending` is a boolean indicating sort order. - `fields` is a list of strings specifying which fields to include in the result. - `transform_fn` is a function to apply to the specified field values. # Example Usage: ```python records = [ {\\"id\\": 1, \\"name\\": \\"Alice\\", \\"age\\": 30}, {\\"id\\": 2, \\"name\\": \\"Bob\\", \\"age\\": 25}, {\\"id\\": 3, \\"name\\": \\"Charlie\\", \\"age\\": 35} ] print(filter_by_field(records, \\"age\\", 30)) # Output: [{\\"id\\": 1, \\"name\\": \\"Alice\\", \\"age\\": 30}] print(filter_by_multiple_criteria(records, {\\"name\\": \\"Bob\\", \\"age\\": 25})) # Output: [{\\"id\\": 2, \\"name\\": \\"Bob\\", \\"age\\": 25}] print(sort_by_field(records, \\"age\\", ascending=False)) # Output: [{\\"id\\": 3, \\"name\\": \\"Charlie\\", \\"age\\": 35}, {\\"id\\": 1, \\"name\\": \\"Alice\\", \\"age\\": 30}, {\\"id\\": 2, \\"name\\": \\"Bob\\", \\"age\\": 25}] print(select_fields(records, [\\"id\\", \\"name\\"])) # Output: [{\\"id\\": 1, \\"name\\": \\"Alice\\"}, {\\"id\\": 2, \\"name\\": \\"Bob\\"}, {\\"id\\": 3, \\"name\\": \\"Charlie\\"}] print(transform_field(records, \\"age\\", lambda x: x + 5)) # Output: [{\\"id\\": 1, \\"name\\": \\"Alice\\", \\"age\\": 35}, {\\"id\\": 2, \\"name\\": \\"Bob\\", \\"age\\": 30}, {\\"id\\": 3, \\"name\\": \\"Charlie\\", \\"age\\": 40}] ``` # Constraints: - Assume maximum number of records is 1000. - Assume each dictionary has at most 20 fields. - Assume field names are unique within each dictionary. # Performance Requirements: Ensure that your implementation can handle the maximum constraints efficiently.","solution":"from typing import List, Dict, Any, Callable def filter_by_field(records: List[Dict[str, Any]], field: str, value: Any) -> List[Dict[str, Any]]: Returns records where the specified field matches the given value. return [record for record in records if record.get(field) == value] def filter_by_multiple_criteria(records: List[Dict[str, Any]], criteria: Dict[str, Any]) -> List[Dict[str, Any]]: Returns records that match all criteria specified in the criteria dictionary. return [record for record in records if all(record.get(field) == value for field, value in criteria.items())] def sort_by_field(records: List[Dict[str, Any]], field: str, ascending: bool = True) -> List[Dict[str, Any]]: Returns records sorted by the specified field, in ascending or descending order. return sorted(records, key=lambda x: x.get(field), reverse=not ascending) def select_fields(records: List[Dict[str, Any]], fields: List[str]) -> List[Dict[str, Any]]: Returns records with only the specified fields included. return [{field: record.get(field) for field in fields} for record in records] def transform_field(records: List[Dict[str, Any]], field: str, transform_fn: Callable[[Any], Any]) -> List[Dict[str, Any]]: Applies a transformation function to a specified field in all records. for record in records: if field in record: record[field] = transform_fn(record[field]) return records"},{"question":"# Coding Assessment Question Scenario You have been tasked with writing a function for a library management system to help sort book titles. All book titles are given as strings and may contain uppercase and lowercase letters. To ensure a consistent sorting order independent of case, you need to convert all the titles to lowercase before sorting. Each title can contain letters, numbers, punctuation, and special characters, but the sorting should be based solely on the alphabetical comparison of characters in lowercase form. Task Implement a function `sort_titles` that takes a list of book titles and returns a new list of titles sorted in alphabetical order without considering the case of the letters. Input - A list `titles` containing between 0 and 1000 strings. Each string can have a length between 1 and 100 characters. Output - A new list of strings sorted in alphabetical order, case-insensitively. Constraints - The input list will only contain printable ASCII characters. - Titles may include uppercase letters (`A-Z`), lowercase letters (`a-z`), digits (`0-9`), punctuation marks, and special characters. Examples ```python >>> sort_titles([\\"The Catcher in the Rye\\", \\"to KILL a Mockingbird\\", \\"1984\\", \\"Brave NEW World\\"]) [\'1984\', \'Brave NEW World\', \'The Catcher in the Rye\', \'to KILL a Mockingbird\'] >>> sort_titles([\\"bLue\\", \\"YELLOW\\", \\"Green\\", \\"red\\", \\"ORANGE\\", \\"Purple\\"]) [\'bLue\', \'Green\', \'ORANGE\', \'Purple\', \'red\', \'YELLOW\'] >>> sort_titles([\\"apple\\", \\"Banana\\", \\"cherry\\", \\"Date\\"]) [\'apple\', \'Banana\', \'cherry\', \'Date\'] >>> sort_titles([]) [] ``` Implementation ```python def sort_titles(titles): Sort a list of book titles in alphabetical order without considering case. # Sorting the titles case-insensitively return sorted(titles, key=lambda x: x.lower()) # Sample test cases to validate your function assert sort_titles([\\"The Catcher in the Rye\\", \\"to KILL a Mockingbird\\", \\"1984\\", \\"Brave NEW World\\"]) == [\'1984\', \'Brave NEW World\', \'The Catcher in the Rye\', \'to KILL a Mockingbird\'] assert sort_titles([\\"bLue\\", \\"YELLOW\\", \\"Green\\", \\"red\\", \\"ORANGE\\", \\"Purple\\"]) == [\'bLue\', \'Green\', \'ORANGE\', \'Purple\', \'red\', \'YELLOW\'] assert sort_titles([\\"apple\\", \\"Banana\\", \\"cherry\\", \\"Date\\"]) == [\'apple\', \'Banana\', \'cherry\', \'Date\'] assert sort_titles([]) == [] print(\\"All tests passed!\\") ``` This question maintains consistency with the provided sample in terms of complexity, aligning with string manipulation, and offers a unique scenario requiring sorting with case insensitivity.","solution":"def sort_titles(titles): Sort a list of book titles in alphabetical order without considering case. # Sorting the titles case-insensitively return sorted(titles, key=lambda x: x.lower())"},{"question":"# Longest Substring Without Repeating Characters Scenario: You are tasked with developing software for a social media application. A key feature of this app is to analyze user input messages and provide feedback based on various metrics. One such metric is to identify the longest substring in a message where no characters are repeated. Task: Your task is to implement a function that finds the length of the longest substring without repeating characters from a given string. # Function to Implement: 1. **`longest_unique_substring(s: str) -> int`**: * **Input**: * `s` (str): A string representing the user\'s message. * **Output**: * An integer representing the length of the longest substring without repeating characters. # Constraints: * The input string `s` can contain any printable ASCII characters. * The length of the input string `s` will be between 0 and 1000 characters. # Example: ```python # Example usage and expected outputs print(longest_unique_substring(\\"abcabcbb\\")) # Output: 3 (substring \\"abc\\") print(longest_unique_substring(\\"bbbbb\\")) # Output: 1 (substring \\"b\\") print(longest_unique_substring(\\"pwwkew\\")) # Output: 3 (substring \\"wke\\") print(longest_unique_substring(\\"\\")) # Output: 0 print(longest_unique_substring(\\" \\")) # Output: 1 print(longest_unique_substring(\\"dvdf\\")) # Output: 3 (substring \\"vdf\\") ``` Your implementation should handle edge cases, such as: * An empty string. * A string with all identical characters. * A string with all unique characters. Optimize the function for performance to handle the upper limit of input size efficiently.","solution":"def longest_unique_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. char_index_map = {} longest = 0 start = 0 for index, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = index longest = max(longest, index - start + 1) return longest"},{"question":"# Question: Find Peak Elements A peak element in an array is an element that is strictly greater than its neighbors. Given an array of integers, return the indices of all the peak elements. Implement a function that efficiently finds all the peak elements in the array. Function Signature ```python def find_peak_elements(nums: list[int]) -> list[int]: ``` # Input * `nums`: A list of integers representing the array. (1 ≤ len(nums) ≤ 10^5, -10^6 ≤ nums[i] ≤ 10^6) # Output * A list of integers representing the indices of all the peak elements. # Constraints * Your implementation should be efficient in terms of both time and space complexity, handling the upper limit of the array size effectively. * An element is considered a peak if it is greater than its neighbors. For the first and last element of the list, consider a single neighbor. # Example ```python find_peak_elements([1, 3, 2, 7, 5, 6, 4]) # Returns: [1, 3, 5] ``` # Additional Information * Make sure to handle edge cases such as arrays with only one element. * An element can be a peak even if the neighboring elements are equal, as long as it is greater than or equal to its neighbors. * You may find it helpful to use the binary search algorithm to achieve the desired efficiency, but it is not required. # Note Your function should avoid using built-in functions or libraries that would trivialize the problem, such as `numpy` for array operations.","solution":"def find_peak_elements(nums: list[int]) -> list[int]: Finds the indices of all peak elements in the list. A peak element is an element that is strictly greater than its neighbors. if len(nums) == 1: return [0] peaks = [] n = len(nums) # Check the first element if n > 1 and nums[0] > nums[1]: peaks.append(0) # Check the middle elements for i in range(1, n - 1): if nums[i] > nums[i - 1] and nums[i] > nums[i + 1]: peaks.append(i) # Check the last element if nums[-1] > nums[-2]: peaks.append(n - 1) return peaks"},{"question":"# Coding Assessment Question Real-Time Data Processing with Sliding Window **Scenario**: You are building a real-time data processing system that handles a potentially infinite stream of numerical data. One of the core tasks of this system is to compute the running average of the last `k` elements in the stream. Requirements: You are required to implement a class `SlidingWindow` that will provide the following functionalities: 1. **Add Element**: Add a new element from the data stream to the sliding window. 2. **Compute Average**: Compute and return the average of the most recent `k` elements in the sliding window. Implementation Details: 1. **Add Element (`add_element(self, val: int) -> None`)**: - Add a new integer `val` to the sliding window. - Ensure that the sliding window only keeps the last `k` elements. 2. **Compute Average (`compute_average(self) -> float`)**: - Calculate and return the average of the elements currently in the sliding window. - If the number of elements is less than `k`, return the average of all available elements. 3. **Efficiency**: - Optimize the class to ensure that both operations run in an average time complexity of O(1). 4. **Data Structure**: - You may use collections like `deque` from `collections` module to efficiently manage the sliding window. Constraints: - The class should handle real-time data which means the methods will be called frequently and performance is critical. - The sliding window size `k` will be a positive integer. - The data stream elements will be integer values and can range from -10^5 to 10^5. Class Signature: ```python from collections import deque class SlidingWindow: def __init__(self, k: int): Initialize the sliding window with a maximum size of k. self.k = k self.window = deque() self.current_sum = 0 def add_element(self, val: int) -> None: Add a new element to the sliding window and update the current sum. pass def compute_average(self) -> float: Compute and return the average of the elements in the sliding window. pass ``` You should complete the `SlidingWindow` class by implementing the `add_element` and `compute_average` methods to ensure that the sliding window maintains its size and computes the average efficiently. Your solution will be validated with multiple test cases, including edge cases where the stream has fewer elements than `k`.","solution":"from collections import deque class SlidingWindow: def __init__(self, k: int): Initialize the sliding window with a maximum size of k. self.k = k self.window = deque() self.current_sum = 0 def add_element(self, val: int) -> None: Add a new element to the sliding window and update the current sum. self.window.append(val) self.current_sum += val if len(self.window) > self.k: self.current_sum -= self.window.popleft() def compute_average(self) -> float: Compute and return the average of the elements in the sliding window. window_size = len(self.window) return self.current_sum / window_size if window_size > 0 else 0.0"},{"question":"# Unique File Finder You are given a list of file paths, where each file path consists of a directory and a file name separated by a slash (`/`). The goal is to identify and output the file paths of files that have unique names, ignoring the directory part of the paths. Write a function `find_unique_files(file_paths: List[str]) -> List[str]` that takes in a list of file paths and returns a list of file paths that contain files with unique names. Function Specifications: - **Input**: - `file_paths` (List[str]): A list of file paths represented as strings. Each path contains a directory and a file name separated by a slash. (0 <= len(file_paths) <= 1000) - **Output**: - A list of strings representing the file paths that have unique file names. Example: ```python # Example 1 file_paths = [ \\"dir1/file1.txt\\", \\"dir2/file2.txt\\", \\"dir3/file1.txt\\", \\"dir4/file3.txt\\" ] # Expected output: # The files with unique names are \\"file2.txt\\" and \\"file3.txt\\", so their paths should be returned [ \\"dir2/file2.txt\\", \\"dir4/file3.txt\\" ] # Example 2 file_paths = [ \\"dir1/file1.txt\\", \\"dir2/file1.txt\\", \\"dir3/file1.txt\\" ] # Expected output: # Since all file names are \\"file1.txt\\" and not unique, the result should be an empty list [] ``` Notes: - Your implementation should be efficient, handling up to the maximum input size gracefully. - The returned list can be in any order, as long as it contains the correct file paths. Constraints: - The directory and file names will only contain alphanumeric characters and dots (`.`). - Each file path string will have a length between 1 and 100 characters (inclusive).","solution":"from typing import List from collections import defaultdict def find_unique_files(file_paths: List[str]) -> List[str]: # Dictionary to keep track of file name counts and their corresponding paths file_count = defaultdict(int) file_path_map = defaultdict(list) for path in file_paths: directory, file_name = path.rsplit(\'/\', 1) file_count[file_name] += 1 file_path_map[file_name].append(path) # Filter out file paths that have unique file names unique_file_paths = [] for file_name, count in file_count.items(): if count == 1: unique_file_paths.extend(file_path_map[file_name]) return unique_file_paths"},{"question":"# Problem Statement You are tasked with implementing functionalities for managing a bookstore inventory system. The system tracks information about books including the ISBN, title, author, and publication year. It should also be able to find books matching certain criteria. # Your Task 1. **Add Book Information**: Implement a function to add a new book to the inventory with the following details: ISBN, title, author, and publication year. 2. **Search Books by Author**: Implement a function that searches for all books by a given author and returns their details sorted by publication year (ascending). # Instructions 1. **add_book**: * **Input**: `isbn` (int), `title` (str), `author` (str), and `year` (int) - the ISBN, title, author, and publication year of the book respectively. * **Output**: None * **Constraints**: * ISBN will be a positive integer and unique for each book. * Title and author will be non-empty strings. * Year will be a four-digit integer representing a plausible year (e.g., 1800 <= year <= current year). 2. **search_books_by_author**: * **Input**: `author` (str) - the author whose books are to be searched. * **Output**: List of tuples - each tuple contains the ISBN, title, and publication year of a book by the given author, sorted by the publication year. * **Constraints**: Author will be a non-empty string. If no books are found for the author, return an empty list. # Example ```python # Example of adding books >>> add_book(12345678, \\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 1925) >>> add_book(23456789, \\"To Kill a Mockingbird\\", \\"Harper Lee\\", 1960) >>> add_book(34567890, \\"1984\\", \\"George Orwell\\", 1949) >>> add_book(45678901, \\"Animal Farm\\", \\"George Orwell\\", 1945) # Example of searching books by author >>> search_books_by_author(\\"George Orwell\\") [(45678901, \\"Animal Farm\\", 1945), (34567890, \\"1984\\", 1949)] >>> search_books_by_author(\\"F. Scott Fitzgerald\\") [(12345678, \\"The Great Gatsby\\", 1925)] >>> search_books_by_author(\\"J.K. Rowling\\") [] ``` # Requirements - The solutions should handle edge cases involving invalid inputs. - Performance should be optimal for the expected use cases. - Adhere to the provided constraints for correctness. - Ensure that the `add_book` method does not add duplicate books (i.e., books with the same ISBN). Complete the function implementations for a small bookstore management system.","solution":"import datetime class BookStore: def __init__(self): self.inventory = {} def add_book(self, isbn, title, author, year): Adds a book to the inventory. Parameters: isbn (int): The ISBN of the book. title (str): The title of the book. author (str): The author of the book. year (int): The publication year of the book. Returns: None if isbn in self.inventory: raise ValueError(\\"ISBN already exists in the inventory.\\") if not (1800 <= year <= datetime.datetime.now().year): raise ValueError(\\"Publication year is out of valid range.\\") self.inventory[isbn] = {\'title\': title, \'author\': author, \'year\': year} def search_books_by_author(self, author): Searches for all books by a given author and returns their details sorted by publication year. Parameters: author (str): The author whose books are to be searched. Returns: list: A list of tuples containing the ISBN, title, and publication year of the books found. result = [] for isbn, details in self.inventory.items(): if details[\'author\'].lower() == author.lower(): result.append((isbn, details[\'title\'], details[\'year\'])) result.sort(key=lambda x: x[2]) # Sort by year ascending return result"},{"question":"# Coding Assessment Question Context and Scenario: You are creating a system for managing event attendees. Each attendee is represented by their unique ID, and these IDs are stored in a sorted list. To keep this system operational, you need to implement efficient algorithms for removing an attendee and finding attendees within a specific ID range. Task: 1. **Function 1: Sorted Removal** Write a function `sorted_removal(collection, item)` that removes an `item` from a sorted collection `collection` without disrupting the order. If the item is not found, the collection should remain unchanged. ```python def sorted_removal(collection: list[int], item: int) -> None: Remove an item from the sorted collection while maintaining sort order. :param collection: A list of integers in ascending order. :param item: The integer item to be removed. pass ``` **Example:** ```python collection = [1, 2, 3, 4, 5] sorted_removal(collection, 3) print(collection) # Output: [1, 2, 4, 5] sorted_removal(collection, 6) print(collection) # Output: [1, 2, 4, 5] ``` 2. **Function 2: Binary Range Search** Write a function `binary_range_search(collection, start, end)` that finds all items within a specific range `[start, end]` in a sorted collection. Return these items as a list. If no items fall within range, return an empty list. ```python def binary_range_search(collection: list[int], start: int, end: int) -> list[int]: Searches for items within the given range [start, end] in a sorted collection. :param collection: A list of integers in ascending order. :param start: The start of the range (inclusive). :param end: The end of the range (inclusive). :return: A list of integers within the specified range. pass ``` **Example:** ```python collection = [5, 8, 12, 15, 20, 22, 27, 30] print(binary_range_search(collection, 10, 25)) # Output: [12, 15, 20, 22] print(binary_range_search(collection, 21, 26)) # Output: [22] print(binary_range_search(collection, 31, 40)) # Output: [] ``` Constraints: - Elements in the input collection are comparable and follow the same data type. - Your implementation should ensure that the input collection remains sorted after removal. - You must handle edge cases: empty array, single-element array, item absent from the collection. - Use principles from binary search; avoid using Python\'s built-in methods directly for search and removal. Performance Requirements: - Your solution should efficiently handle large datasets up to ( 10^6 ) elements for removal and range search functions. - Ensure that removal and search operations run within logarithmic and linear time complexities respectively.","solution":"def sorted_removal(collection: list[int], item: int) -> None: Remove an item from the sorted collection while maintaining sort order. :param collection: A list of integers in ascending order. :param item: The integer item to be removed. # Binary search for the item left, right = 0, len(collection) - 1 while left <= right: mid = (left + right) // 2 if collection[mid] == item: # Remove the item found at index mid collection.pop(mid) return elif collection[mid] < item: left = mid + 1 else: right = mid - 1 def binary_range_search(collection: list[int], start: int, end: int) -> list[int]: Searches for items within the given range [start, end] in a sorted collection. :param collection: A list of integers in ascending order. :param start: The start of the range (inclusive). :param end: The end of the range (inclusive). :return: A list of integers within the specified range. def find_leftmost(collection, target): left, right = 0, len(collection) while left < right: mid = (left + right) // 2 if collection[mid] < target: left = mid + 1 else: right = mid return left def find_rightmost(collection, target): left, right = 0, len(collection) while left < right: mid = (left + right) // 2 if collection[mid] <= target: left = mid + 1 else: right = mid return left left_idx = find_leftmost(collection, start) right_idx = find_rightmost(collection, end) return collection[left_idx:right_idx]"},{"question":"# Problem Statement Write a function that takes a list of integers and returns a list of the same integers ordered in a manner such that all negative integers come before positive integers while preserving the relative order of the negative and positive integers. # Function Signature ```python def reorder_negatives_first(nums: List[int]) -> List[int]: ``` # Input * An integer list `nums` where the size of the list `1 leq len(nums) leq 10^6`. * Elements of the list `nums` are within the range (-10^9 leq nums[i] leq 10^9). # Output * Return a list of integers with all negative numbers appearing before all positive numbers and preserving their relative order. # Constraints 1. The input list will always contain at least one element. 2. The solution should maintain the original relative order of negative and positive numbers. 3. Your implementation should be efficient with respect to both time and space. # Examples ```python >>> reorder_negatives_first([1, -2, 3, -4, 5]) [-2, -4, 1, 3, 5] >>> reorder_negatives_first([-1, 2, -3, 4, -5]) [-1, -3, -5, 2, 4] >>> reorder_negatives_first([1, 2, 3]) [1, 2, 3] >>> reorder_negatives_first([-1, -2, -3]) [-1, -2, -3] ``` # Explanation 1. **Example 1**: The input list is `[1, -2, 3, -4, 5]`. By moving the negative numbers to the front while preserving the relative order, the resulting list is `[-2, -4, 1, 3, 5]`. 2. **Example 2**: The input list is `[-1, 2, -3, 4, -5]`. By moving the negative numbers to the front while preserving the relative order, the resulting list is `[-1, -3, -5, 2, 4]`. 3. **Example 3**: The input list is `[1, 2, 3]`. There are no negative numbers to move, so the list remains unchanged. 4. **Example 4**: The input list is `[-1, -2, -3]`. All numbers are negative, and the list remains unchanged. # Performance Requirements 1. Ensure your implementation efficiently handles the upper limit of the input size. 2. Aim for a time complexity around (O(n)) and space complexity of (O(n)).","solution":"from typing import List def reorder_negatives_first(nums: List[int]) -> List[int]: Returns a list with all negative numbers appearing before all positive numbers while preserving their relative order. negatives = [num for num in nums if num < 0] non_negatives = [num for num in nums if num >= 0] return negatives + non_negatives"},{"question":"# Context Bob is building a system that requires maintaining and retrieving user session data. He has a list of session intervals with start and end timestamps for various users and needs to determine the number of active sessions at any given time. # Task Write a function `find_maximum_active_sessions` that takes a list of session intervals and returns the maximum number of active sessions at any point in time. Each session interval consists of a start time and an end time (inclusive). # Input - A list of tuples representing the session intervals. Each tuple contains two integers `(start, end)`, where `start` is the start time and `end` is the end time (both inclusive). - The time values are integers and there can be up to 10000 sessions. # Output - An integer representing the maximum number of active sessions at any time. # Example ```python sessions = [ (1, 4), (2, 3), (3, 5), (7, 8) ] find_maximum_active_sessions(sessions) ``` Expected Output: ``` 3 ``` # Constraints - There are up to 10000 session intervals. # Performance Requirements - Ensure the solution handles the maximum input size efficiently with an optimal time complexity approach.","solution":"def find_maximum_active_sessions(sessions): Returns the maximum number of active sessions at any time. events = [] for start, end in sessions: events.append((start, 1)) # increment at start time events.append((end + 1, -1)) # decrement after end time # Sort events first by time; if equal time, then by type of event (-1 before 1) events.sort(key=lambda x: (x[0], x[1])) max_active = 0 current_active = 0 for time, event in events: current_active += event max_active = max(max_active, current_active) return max_active"},{"question":"# Coding Assessment Question As part of a software development team, you have to develop an algorithm to determine the smallest non-negative integer that is missing from a given list of non-negative integers, commonly known as the \\"first missing non-negative integer\\" problem. Task: Implement the function `first_missing_non_negative(nums: List[int]) -> int`. This function should return the smallest non-negative integer that is not present in the list `nums`. # Input: - `nums` (List[int]): A list of non-negative integers. The list may contain duplicates. # Output: - (int): The smallest non-negative integer not present in the list. # Constraints: - The size of `nums` will be in the range [1, 100,000]. - The values in `nums` are non-negative integers that can be quite large, up to the maximum value possible for a 32-bit signed integer. # Example: ```python assert first_missing_non_negative([0, 1, 2, 3]) == 4 assert first_missing_non_negative([3, 4, -1, 1]) == 0 assert first_missing_non_negative([0, 2, 2, 1, 1]) == 3 ``` Notes: - Aim for a solution with a time complexity better than O(n^2) to handle large datasets efficiently. - Consider edge cases such as empty lists or lists with large gaps in their values. - Avoid using extra space whenever possible; try to use the input list itself for any in-place operations.","solution":"def first_missing_non_negative(nums): Returns the smallest non-negative integer that is not present in the list nums. n = len(nums) # Ensure all numbers are within the range [0, n] for i in range(n): while 0 <= nums[i] < n and nums[nums[i]] != nums[i]: nums[nums[i]], nums[i] = nums[i], nums[nums[i]] # Find the first missing non-negative integer for i in range(n): if nums[i] != i: return i return n"},{"question":"# Coding Assessment Question: Magic Square Validation Scenario You have been hired by a software company to develop an application that validates Magic Squares. A Magic Square is a square grid of distinct integers where the sums of the numbers in each row, each column, and both main diagonals are the same. Objective Write a function `is_magic_square` that takes a 2D list of integers representing the square and checks if it is a Magic Square. Function Specifications: * **Name**: `is_magic_square` * **Input**: A single parameter `square` which is a list of lists of integers, where each inner list represents a row of the square. * **Output**: A boolean value. `True` if the input is a Magic Square, and `False` otherwise. * **Constraints**: - The input list must be a non-empty square matrix (i.e., it must have the same number of rows and columns). - If the input is not a square or any of the rows have different lengths, raise a `ValueError` with the message \\"Input must be a non-empty square matrix.\\" Performance Requirement: - The function should have a time complexity of ( O(n^2) ), where ( n ) is the side length of the square. Example: ```python def is_magic_square(square: list[list[int]]) -> bool: if len(square) == 0 or any(len(row) != len(square) for row in square): raise ValueError(\\"Input must be a non-empty square matrix.\\") n = len(square) magic_sum = sum(square[0]) for row in square: if sum(row) != magic_sum: return False for col in range(n): if sum(square[row][col] for row in range(n)) != magic_sum: return False if sum(square[i][i] for i in range(n)) != magic_sum: return False if sum(square[i][n - i - 1] for i in range(n)) != magic_sum: return False return True ``` Tests: ```python # Test cases for `is_magic_square` assert is_magic_square([[2, 7, 6], [9, 5, 1], [4, 3, 8]]) == True assert is_magic_square([[4, 9, 2], [3, 5, 7], [8, 1, 6]]) == True assert is_magic_square([[16, 23, 17], [78, 32, 21], [17, 64, 55]]) == False assert is_magic_square([[5]]) == True try: is_magic_square([[2, 7], [9, 5, 1]]) except ValueError as e: assert str(e) == \\"Input must be a non-empty square matrix.\\" try: is_magic_square([]) except ValueError as e: assert str(e) == \\"Input must be a non-empty square matrix.\\" ``` Ensure your code respects the specifications and successfully passes all the test cases provided.","solution":"def is_magic_square(square: list[list[int]]) -> bool: if len(square) == 0 or any(len(row) != len(square) for row in square): raise ValueError(\\"Input must be a non-empty square matrix.\\") n = len(square) magic_sum = sum(square[0]) for row in square: if sum(row) != magic_sum: return False for col in range(n): if sum(square[row][col] for row in range(n)) != magic_sum: return False if sum(square[i][i] for i in range(n)) != magic_sum: return False if sum(square[i][n - i - 1] for i in range(n)) != magic_sum: return False return True"},{"question":"# Question Objective Your task is to implement a function to evaluate the Infix expression and convert it into its equivalent Postfix expression using the Shunting Yard algorithm. The Shunting Yard algorithm converts an infix expression (i.e., human-readable mathematical notation) into a postfix expression (i.e., Reverse Polish notation) that can be easily evaluated by computers. Function Signature ```python def infix_to_postfix(expression: str) -> str: ``` Input * **expression (str)**: The input infix expression that consists of integer operands and operators (`+`, `-`, `*`, `/`) along with parentheses. The expression is guaranteed to be valid. `1 <= len(expression) <= 10^6`. Output * **Return (str)**: The equivalent postfix expression represented as a string. Constraints * All operators are binary. * The expression may include spaces but they are not part of the expression. Example ```python # Example 1: input: expression = \\"3 + 5\\" output: \\"3 5 +\\" # Example 2: input: expression = \\"( 1 + 2 ) * 3\\" output: \\"1 2 + 3 *\\" # Example 3: input: expression = \\"10 + 2 * 6\\" output: \\"10 2 6 * +\\" # Example 4: input: expression = \\"100 * ( 2 + 12 ) / 14\\" output: \\"100 2 12 + * 14 /\\" ``` Scenario Context Imagine you are developing a calculator application that needs to support complex arithmetic operations. The application reads user input in infix notation but needs to evaluate it efficiently. Converting the infix notation to postfix notation simplifies the evaluation process. **Your task** is to implement the conversion from the infix expression to the postfix expression as described previously.","solution":"def infix_to_postfix(expression: str) -> str: Convert infix expression to postfix using Shunting Yard algorithm. # Define operator precedence precedence = {\'+\': 1, \'-\': 1, \'*\': 2, \'/\': 2} # Define the stack and postfix list stack = [] postfix = [] # Remove all spaces from the expression expression = expression.replace(\\" \\", \\"\\") i = 0 while i < len(expression): ch = expression[i] if ch.isdigit(): # Number found, parse it fully (could be multiple digits) num = [] while i < len(expression) and expression[i].isdigit(): num.append(expression[i]) i += 1 postfix.append(\\"\\".join(num)) continue # we already incremented i elif ch == \'(\': stack.append(ch) elif ch == \')\': while stack and stack[-1] != \'(\': postfix.append(stack.pop()) stack.pop() # removing \'(\' from stack else: # Operator encountered while stack and stack[-1] != \'(\' and precedence[ch] <= precedence[stack[-1]]: postfix.append(stack.pop()) stack.append(ch) i += 1 while stack: postfix.append(stack.pop()) return \\" \\".join(postfix)"},{"question":"# Scenario You are developing a feature for a book library management system that allows users to quickly find books based on multiple criteria. Users should be able to search for books by title, author, publication year, and genre. Currently, the system only supports searching by title, and it returns all books that contain the search term anywhere in the title. # Objective Enhance the search functionality to support multiple criteria and return more precise results. # Instructions 1. Implement the function `search_books`: * It should take four optional parameters as input: `title`, `author`, `year`, and `genre`. * If a parameter is not provided, it should be ignored in the search. * It should return a list of dictionaries, where each dictionary represents a book that matches all given search criteria. ```python def search_books(title=None, author=None, year=None, genre=None): pass ``` 2. Books are represented as dictionaries with the following keys: `title`, `author`, `year`, and `genre`. # Constraints - The search should be case-insensitive for `title` and `author`. - The `year` criterion should match the exact year of publication. - The `genre` criterion should support partial matches (e.g., \\"fic\\" should match \\"Fiction\\"). - If no criteria are provided, return all books in the library. # Example Library Data ```python library = [ {\\"title\\": \\"To Kill a Mockingbird\\", \\"author\\": \\"Harper Lee\\", \\"year\\": 1960, \\"genre\\": \\"Fiction\\"}, {\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"year\\": 1949, \\"genre\\": \\"Dystopian\\"}, {\\"title\\": \\"The Great Gatsby\\", \\"author\\": \\"F. Scott Fitzgerald\\", \\"year\\": 1925, \\"genre\\": \\"Tragedy\\"}, {\\"title\\": \\"Harry Potter and the Philosopher\'s Stone\\", \\"author\\": \\"J.K. Rowling\\", \\"year\\": 1997, \\"genre\\": \\"Fantasy\\"}, {\\"title\\": \\"The Hobbit\\", \\"author\\": \\"J.R.R. Tolkien\\", \\"year\\": 1937, \\"genre\\": \\"Fantasy\\"} ] ``` # Expected Input and Output - **Input**: Various combinations of `title`, `author`, `year`, and `genre`. - **Output**: A list of dictionaries representing books that match all given criteria. # Example Usage ```python results = search_books(title=\\"harry potter\\") # Output: [{\\"title\\": \\"Harry Potter and the Philosopher\'s Stone\\", \\"author\\": \\"J.K. Rowling\\", \\"year\\": 1997, \\"genre\\": \\"Fantasy\\"}] results = search_books(author=\\"george orwell\\", genre=\\"dyst\\") # Output: [{\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"year\\": 1949, \\"genre\\": \\"Dystopian\\"}] results = search_books(year=1937) # Output: [{\\"title\\": \\"The Hobbit\\", \\"author\\": \\"J.R.R. Tolkien\\", \\"year\\": 1937, \\"genre\\": \\"Fantasy\\"}] ``` # Performance Requirements - The search functionality should efficiently handle up to 1000 books. # Additional Notes - Ensure that you handle edge cases, such as no books matching the criteria or the library being empty. - Provide meaningful error messages or results when no criteria match any book.","solution":"def search_books(library, title=None, author=None, year=None, genre=None): results = [] for book in library: if title and title.lower() not in book[\'title\'].lower(): continue if author and author.lower() not in book[\'author\'].lower(): continue if year and year != book[\'year\']: continue if genre and genre.lower() not in book[\'genre\'].lower(): continue results.append(book) return results # Example Library Data library = [ {\\"title\\": \\"To Kill a Mockingbird\\", \\"author\\": \\"Harper Lee\\", \\"year\\": 1960, \\"genre\\": \\"Fiction\\"}, {\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"year\\": 1949, \\"genre\\": \\"Dystopian\\"}, {\\"title\\": \\"The Great Gatsby\\", \\"author\\": \\"F. Scott Fitzgerald\\", \\"year\\": 1925, \\"genre\\": \\"Tragedy\\"}, {\\"title\\": \\"Harry Potter and the Philosopher\'s Stone\\", \\"author\\": \\"J.K. Rowling\\", \\"year\\": 1997, \\"genre\\": \\"Fantasy\\"}, {\\"title\\": \\"The Hobbit\\", \\"author\\": \\"J.R.R. Tolkien\\", \\"year\\": 1937, \\"genre\\": \\"Fantasy\\"} ]"},{"question":"# Prime Sieve Function Objective Your task is to implement a function that generates all prime numbers up to a given limit using the Sieve of Eratosthenes algorithm. This function should be efficient and capable of handling relatively large input sizes. Input The function will take: 1. **limit**: An integer `n` representing the upper limit (inclusive) up to which prime numbers should be generated. Output The function should return a list of all prime numbers from 2 up to and including `limit`. Constraints - `2 <= limit <= 10^6` Example Usage ```python # Example function call result = sieve_of_eratosthenes(30) print(result) # Expected output: [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] ``` Implementation Details 1. Use the Sieve of Eratosthenes algorithm to find all prime numbers up to the given limit. 2. Initialize a boolean array to mark non-prime numbers. 3. Iterate through the array, marking the multiples of each prime starting from 2. 4. Collect and return the numbers which are marked as prime. Function Signature ```python def sieve_of_eratosthenes(limit: int) -> list: # Your implementation here pass ```","solution":"def sieve_of_eratosthenes(limit: int) -> list: Returns a list of all prime numbers up to and including the given limit using the Sieve of Eratosthenes algorithm. if limit < 2: return [] # Step 1: Create a boolean array \\"prime[0..n]\\" and initialize all entries as true. # A value in prime[i] will finally be false if i is Not a prime, else true. prime = [True for _ in range(limit + 1)] p = 2 while p * p <= limit: # If prime[p] is not changed, then it is a prime if prime[p] == True: # Update all multiples of p to False for i in range(p * p, limit + 1, p): prime[i] = False p += 1 # Collecting all prime numbers prime_numbers = [p for p in range(2, limit + 1) if prime[p]] return prime_numbers"},{"question":"# Coding Assessment Question Context You need to extend a binary search tree (BST) implementation with a new functionality: finding the kth smallest element in the BST. This will test your understanding of tree traversal and order statistics. Task Implement a method `kth_smallest` within the `BST` class that returns the kth smallest element in the BST. Function Specification ```python def kth_smallest(self, k: int) -> int: Finds the kth smallest element in the BST. Parameters: k (int): The position (1-indexed) of the smallest element to find. Examples: >>> bst = BST() >>> bst.insert(5) >>> bst.insert(3) >>> bst.insert(7) >>> bst.insert(2) >>> bst.insert(4) >>> bst.insert(6) >>> bst.insert(8) >>> bst.kth_smallest(3) 4 >>> bst.kth_smallest(5) 6 When k is greater than the number of elements in the BST: >>> bst.kth_smallest(10) Traceback (most recent call last): ... IndexError: k is larger than the number of elements in the BST Returns: int: The kth smallest element in the BST pass ``` Constraints * The number of nodes, n, in the BST is such that 1 ≤ k ≤ n. * The BST is implemented such that all elements are unique. * Your solution should traverse the BST using an in-order traversal to achieve O(n) time complexity. Input Format A method `kth_smallest` is added to the `BST` class which takes an integer `k` as input. Output Format Returns an integer which is the kth smallest element in the BST. Examples * Input: A BST with elements [5, 3, 7, 2, 4, 6, 8] and `k = 3` * Expected Output: 4 * Input: A BST with elements [5, 3, 7, 2, 4, 6, 8] and `k = 5` * Expected Output: 6","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None def insert(self, key): if not self.root: self.root = TreeNode(key) else: self._insert(self.root, key) def _insert(self, node, key): if key < node.val: if node.left: self._insert(node.left, key) else: node.left = TreeNode(key) else: if node.right: self._insert(node.right, key) else: node.right = TreeNode(key) def kth_smallest(self, k): stack = [] curr = self.root while True: while curr: stack.append(curr) curr = curr.left curr = stack.pop() k -= 1 if k == 0: return curr.val curr = curr.right"},{"question":"# Problem Statement You are developing a simplified version of a social media website. Users can post messages, and other users can upvote those messages. Your task is to implement two main functionalities: 1. Post a new message. 2. Get the top-k upvoted messages. # Function Specifications Function 1: `post_message` - **Input**: - A string `user_id` representing the user who is posting the message. - A string `message` representing the content of the message. - **Output**: - Returns an integer `message_id` which is the unique identifier for the posted message. ```python def post_message(user_id: str, message: str) -> int: pass ``` Function 2: `upvote_message` - **Input**: - An integer `message_id` representing the unique identifier of the message being upvoted. - **Output**: - None ```python def upvote_message(message_id: int) -> None: pass ``` Function 3: `top_k_messages` - **Input**: - An integer `k` representing the number of top upvoted messages to retrieve. - **Output**: - A list of tuples, where each tuple contains two elements: 1. A string `message` representing the content of the message. 2. An integer `upvotes` representing the count of upvotes for that message. - The list should be sorted in descending order of upvotes. If two messages have the same number of upvotes, their order in the list can be arbitrary. ```python def top_k_messages(k: int) -> list[tuple[str, int]]: pass ``` # Constraints - A user_id and message will be between 1 and 100 characters in length. - A message_id will be a positive integer. - You can assume that `k` will always be less than or equal to the number of posted messages. - The content of messages does not need to be unique. - The number of messages posted will not exceed 100,000. # Example ```python # Posting messages message_id_1 = post_message(\\"user_a\\", \\"Hello World\\") message_id_2 = post_message(\\"user_b\\", \\"Hello Everyone\\") message_id_3 = post_message(\\"user_a\\", \\"Good Morning\\") # Upvoting messages upvote_message(message_id_1) upvote_message(message_id_1) upvote_message(message_id_2) # Getting top-k messages print(top_k_messages(2)) # Expected output: [(\\"Hello World\\", 2), (\\"Hello Everyone\\", 1)] ``` # Notes - Ensure to use a data structure that supports efficient insertion and retrieval operations. - Consider edge cases such as no messages posted or upvoted and retrieving top-k when k is larger than the number of messages available. - Optimize your solution to handle the largest input sizes efficiently.","solution":"class SocialMedia: def __init__(self): self.messages = {} self.upvotes = {} self.next_id = 1 def post_message(self, user_id: str, message: str) -> int: message_id = self.next_id self.next_id += 1 self.messages[message_id] = message self.upvotes[message_id] = 0 return message_id def upvote_message(self, message_id: int) -> None: if message_id in self.upvotes: self.upvotes[message_id] += 1 def top_k_messages(self, k: int) -> list[tuple[str, int]]: sorted_messages = sorted(self.upvotes.items(), key=lambda item: item[1], reverse=True) return [(self.messages[message_id], upvotes) for message_id, upvotes in sorted_messages[:k]]"},{"question":"# Question: Circular Array Rotation Context In a circular array, the end of the array wraps around to the beginning, forming a circle. Given an array of integers, perform a circular rotation to the right. That is, each element of the array is shifted to the right by one position, and the last element moves to the first position. Task Implement the `circular_array_rotation` function that takes an array and a number of rotations and returns the array after performing the specified number of circular rotations to the right. Function Signature ```python def circular_array_rotation(array: list[int], rotations: int) -> list[int]: pass ``` Input - `array`: List of integers (length n, where 0 <= n <= 10^5) - `rotations`: An integer representing the number of times to rotate the array to the right (0 <= rotations <= 10^9) Output - Return the array after applying the specified number of circular rotations to the right. Constraints - The function should handle large values of `rotations` efficiently. - Perform necessary edge case handling as discussed in the analysis. Example ```python assert circular_array_rotation([1, 2, 3, 4, 5], 2) == [4, 5, 1, 2, 3] assert circular_array_rotation([1, 2, 3, 4, 5], 5) == [1, 2, 3, 4, 5] assert circular_array_rotation([1, 2, 3, 4, 5], 0) == [1, 2, 3, 4, 5] assert circular_array_rotation([1], 3) == [1] assert circular_array_rotation([], 4) == [] ``` Note Ensure the solution handles edge cases such as an empty array or a single-element array efficiently and avoids unnecessary calculations with large rotation counts.","solution":"def circular_array_rotation(array: list[int], rotations: int) -> list[int]: Rotates the given array to the right by the specified number of rotations. if not array: # If the array is empty, no rotation is needed return array n = len(array) rotations = rotations % n # This reduces the number of rotations needed return array[-rotations:] + array[:-rotations]"},{"question":"# Question You are required to implement a function `max_in_subarray` that takes an integer array and a window size. The goal is to find the maximum element in every subarray of the given size that can be formed from the array. If the subarray size is larger than the array itself, the function should return an empty list. For example, given the array `[1, 3, 5, 2, 8, 7]` and a window size of `3`, the maximum elements in each subarray of size `3` are `[5, 5, 8, 8]`. # Function Signature ```python def max_in_subarray(arr: List[int], k: int) -> List[int]: pass ``` # Input - `arr` (List[int]): A list of integers. - `k` (int): The size of the subarray window. # Output - `List[int]`: A list containing the maximum elements of each subarray of size `k`. # Constraints - `1 <= len(arr) <= 10^6` - `0 <= arr[i] <= 10^9` - `1 <= k <= len(arr)` # Examples ```python >>> max_in_subarray([1, 3, 5, 2, 8, 7], 3) [5, 5, 8, 8] >>> max_in_subarray([4, 1, 2, 7, 5, 3, 6], 4) [7, 7, 7, 7] >>> max_in_subarray([9, 5, 3, 1], 2) [9, 5, 3] >>> max_in_subarray([1, 2, 3, 4], 5) [] ``` # Requirements - Optimize for both performance and readability. - Handle edge cases effectively. # Testing Ensure that your function passes the provided examples as well as edge cases like the smallest (`k=1`) and largest subarray sizes (`k=len(arr)`).","solution":"from typing import List from collections import deque def max_in_subarray(arr: List[int], k: int) -> List[int]: Finds the maximum element in every subarray of size k. if len(arr) < k: return [] q = deque() max_elements = [] for i in range(k): while q and arr[i] >= arr[q[-1]]: q.pop() q.append(i) for i in range(k, len(arr)): max_elements.append(arr[q[0]]) while q and q[0] <= i - k: q.popleft() while q and arr[i] >= arr[q[-1]]: q.pop() q.append(i) max_elements.append(arr[q[0]]) return max_elements"},{"question":"# Coding Assessment Question Scenario You are tasked with developing a feature for an event planning application. Users should be able to input events with a start and end time, and you will need to determine whether any new event conflicts with the existing ones. Task 1. **Function Implementation**: Implement a function `check_conflict` to verify if a newly scheduled event conflicts with any existing events. 2. **Detailed Steps**: - Define the function `check_conflict(new_event: Tuple[int, int], current_events: List[Tuple[int, int]]) -> bool`. 3. **Requirements**: * The `new_event` is a tuple representing the start and end times of the proposed event. * `current_events` is a list of tuples, where each tuple represents the start and end times of currently scheduled events. * The function should return `True` if there is any overlap between the `new_event` and existing events, and `False` otherwise. 4. **Example**: ```python >>> current_events = [(1, 5), (6, 10), (12, 15)] >>> new_event = (3, 7) >>> check_conflict(new_event, current_events) True >>> new_event = (10, 12) >>> check_conflict(new_event, current_events) False ``` Constraints * **Input**: - Each event (tuple) in the list and the new event has non-negative integer start and end times, where start time is less than the end time. - The list of current events can be empty, in which case the function should always return `False`. Performance Requirements * The function should have a time complexity of O(n), where n is the number of current events. * The space complexity should be O(1), not including the input list size.","solution":"from typing import List, Tuple def check_conflict(new_event: Tuple[int, int], current_events: List[Tuple[int, int]]) -> bool: Checks if the new_event conflicts with any of the current_events. Args: new_event (tuple): A tuple representing the start and end times of the proposed event. current_events (list): A list of tuples representing the start and end times of current scheduled events. Returns: bool: True if there is any overlap between the new_event and existing events, False otherwise. new_start, new_end = new_event for event in current_events: start, end = event if not (new_end <= start or new_start >= end): return True return False"},{"question":"# Factorial of a Large Number You are required to implement a function that returns the factorial of a non-negative integer ( n ). The factorial of a non-negative integer ( n ), denoted as ( n! ), is the product of all positive integers less than or equal to ( n ). Factorials grow at an exceptionally fast rate, so your function needs to handle very large numbers and return the result as a string to accommodate the size. The factorial of ( n ) can be defined as: [ n! = begin{cases} 1 & text{if } n = 0 text{ or } n = 1 n times (n-1) times (n-2) times dots times 1 & text{if } n > 1 end{cases} ] # Function Signature ```python def factorial_large_number(n: int) -> str: ``` # Input - `n`: A non-negative integer ( n ). # Output - A string representing the factorial of the input integer ( n ). # Constraints - The input integer ( n ) will be in the range of ( 0 leq n leq 1000 ). # Examples ```python factorial_large_number(5) # Output: \\"120\\" factorial_large_number(10) # Output: \\"3628800\\" factorial_large_number(0) # Output: \\"1\\" factorial_large_number(20) # Output: \\"2432902008176640000\\" factorial_large_number(100) # Output: \\"93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000\\" ``` **Note**: Ensure that your function effectively deals with large integers and edge cases such as ( n = 0 ), ( n = 1 ), and large values of ( n ). Also, remember to return the result as a string to handle the size properly.","solution":"import math def factorial_large_number(n: int) -> str: Returns the factorial of the non-negative integer n as a string. return str(math.factorial(n))"},{"question":"# Worms Game Simulation You are tasked with creating a simplified simulation of a worms game, wherein multiple worms traverse a 2D grid and leave a trail behind them. Each worm has a distinct movement pattern. # Worm Movement Rules: 1. Each worm starts at a randomly chosen position within the grid. 2. Each worm moves according to one of four possible patterns: - **Pattern A**: Always moves to the right; wraps around when it reaches the edge. - **Pattern B**: Always moves downward; wraps around when it reaches the edge. - **Pattern C**: Moves in a zig-zag pattern (up and right alternatively); wraps around as needed. - **Pattern D**: Moves in a square pattern (right, down, left, up); wraps around as needed. # Requirements 1. **Function to Simulate Multiple Worms**: Write a function `simulate_worms` that simulates the movement of multiple worms over a series of steps. - **Input**: - `width`: integer, width of the board. - `height`: integer, height of the board. - `num_worms`: integer, number of worms on the board. - `steps`: integer, number of steps to simulate. - **Output**: - The function should print the final state of the board, marking the paths taken by each worm. # Constraints - The width and height of the board will be positive integers within the range [5, 50]. - The number of worms will be a positive integer within the range [1, 5]. - Worms\' initial positions and movement patterns should be randomly assigned. - Avoid using external libraries except for random number generation. # Example ```python simulate_worms(10, 10, 2, 20) ``` This should initialize a 10x10 board with two worms and simulate 20 moves, finally printing the resulting state of the board. # Notes - Utilize the `random` module for generating initial positions and assigning movement patterns. - Ensure to handle the grid wrapping logic effectively so worms reappear on the opposite edge of the board when they move out of bounds. - Each worm should leave a distinguishable trail (such as different characters) to clearly observe their paths on the board.","solution":"import random def simulate_worms(width, height, num_worms, steps): Simulates worms moving on a grid and prints the final state of the board. # Initialize the board board = [[\'.\' for _ in range(width)] for _ in range(height)] # Directions for the movement patterns directions = { \'A\': (0, 1), # Move right \'B\': (1, 0), # Move down \'C\': [(1, 1), (-1, 1)], # Zig-zag (down-right, up-right) \'D\': [(0, 1), (1, 0), (0, -1), (-1, 0)] # Square pattern (right, down, left, up) } # Initialize worms with random positions and patterns worms = [] for _ in range(num_worms): x = random.randint(0, height-1) y = random.randint(0, width-1) pattern = random.choice([\'A\', \'B\', \'C\', \'D\']) worms.append((x, y, pattern)) def move(worm, direction): x, y, pattern = worm if pattern == \'C\': dx, dy = direction[random.randint(0, 1)] elif pattern == \'D\': dx, dy = direction[random.randint(0, 3)] else: dx, dy = direction new_x = (x + dx) % height new_y = (y + dy) % width return (new_x, new_y, pattern) for _ in range(steps): new_worms = [] for worm in worms: x, y, pattern = worm board[x][y] = \'*\' worm = move(worm, directions[pattern]) new_worms.append(worm) worms = new_worms # Print the final board state for row in board: print(\'\'.join(row))"},{"question":"# Reverse Engineer Polynomial Expressions You are provided with a csv file containing several polynomial expressions represented as lists of coefficients. Each row in the file represents a polynomial, with coefficients ordered from the highest to the lowest degree term. Your task is to write a Python function that reads the file, processes each polynomial expression, and identifies the roots of each polynomial using any numerical method of your choice. The function should then return the sum of the absolute values of all the real roots found. # Requirements: 1. Write a function `sum_real_roots(filename: str) -> float` which takes the filename of the csv file as input. 2. Each row in the csv file represents a polynomial, with coefficients for each term (separated by commas). 3. The function must identify the real roots of each polynomial using a numerical method (e.g., numpy\'s roots function, Newton\'s method). 4. Return the sum of the absolute values of all the real roots found across all polynomial expressions in the file. 5. Assume the csv file contains at least one polynomial and that coefficients are real numbers. # Input: - `filename`: A string representing the path to the csv file containing the polynomial coefficients. # Output: - A float representing the sum of the absolute values of all the real roots of the polynomials. # Constraints: - The file will have up to (10^6) rows, each representing a polynomial with degrees ranging from 0 to 100. - Polynomial coefficients are real numbers and can be positive, negative, or zero. # Example: ```python # Given a file \\"polynomials.csv\\" with the following content, # each line representing the coefficients of a polynomial: # 1.0, -3.0, 2.0 # 1.0, 0.0, -4.0 # Example Usage: sum_real_roots(\\"polynomials.csv\\") # -> 5.0 (Sample output, assuming roots found are 1, 2, -2) # Note: The actual roots may vary depending on the content of \\"polynomials.csv\\". ``` # Additional Information: - You may use libraries such as numpy or scipy to find the roots of polynomials. - Make sure to handle cases where polynomials have no real roots properly. Only real roots should contribute to the sum. - Consider using a dynamic threshold when determining whether a root is real, to account for potential numerical inaccuracies.","solution":"import numpy as np import csv def sum_real_roots(filename: str) -> float: Reads a csv file containing polynomial coefficients, finds the real roots of each polynomial, and returns the sum of the absolute values of all the real roots found. total_sum_abs_roots = 0.0 with open(filename, \'r\') as file: reader = csv.reader(file) for row in reader: # Convert the row into a list of floats (coefficients) coefficients = list(map(float, row)) # Find all roots of the polynomial roots = np.roots(coefficients) # Filter out the real roots and take their absolute values real_roots = [root.real for root in roots if np.isclose(root.imag, 0)] sum_abs_real_roots = sum(map(abs, real_roots)) # Add to the total sum total_sum_abs_roots += sum_abs_real_roots return total_sum_abs_roots"},{"question":"# Logistic Regression Model Evaluation As a data scientist, you are working on a classification project where you need to evaluate the performance of different logistic regression models on a given dataset. You have been provided with the model\'s predictions and the true labels for a test dataset. Your task is to enhance the logistic regression evaluation code by implementing the following requirements: 1. **Evaluation Metrics**: - Compute and print the following metrics: Accuracy, Precision, Recall, F1 Score, and the Area Under the Receiver Operating Characteristic Curve (AUC-ROC). 2. **Confusion Matrix**: - Compute and print the confusion matrix to give insights into the model\'s classification results. 3. **Error Handling**: Implement error handling for the following scenarios: - Mismatched lengths of prediction and true label arrays. - Invalid values in the prediction or true label arrays (values should be 0 or 1). 4. **Logging**: Add logging to provide insights into each stage of the evaluation process (e.g., loading data, computing metrics, successful evaluation). # Function to Implement ```python from typing import List def evaluate_logistic_regression(predictions: List[int], true_labels: List[int]): pass ``` # Input - `predictions`: A list of integers representing the model\'s binary predictions (0 or 1). - `true_labels`: A list of integers representing the true binary labels (0 or 1). # Output - Print logs for each stage of the evaluation (e.g., loading data, computing metrics, successful evaluation). - Print the evaluation metrics: Accuracy, Precision, Recall, F1 Score, AUC-ROC. - Print the confusion matrix. - Print an error message if the prediction and true label arrays have mismatched lengths or contain invalid values. # Constraints - The length of the prediction and true label arrays will not exceed 100,000 elements. - Only standard Python libraries (e.g., `numpy`, `sklearn.metrics`, `logging`) can be used. # Example Scenario Your function will process the predictions and true labels, compute the evaluation metrics, and print them, along with the confusion matrix and corresponding logs. Proper error handling and logging should be used to ensure robustness. ```python evaluate_logistic_regression([1, 0, 1, 1, 0, 1, 0], [1, 0, 0, 1, 0, 0, 1]) ```","solution":"from typing import List import numpy as np from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, roc_auc_score, confusion_matrix import logging def evaluate_logistic_regression(predictions: List[int], true_labels: List[int]): logging.basicConfig(level=logging.INFO) try: # Validate input lengths if len(predictions) != len(true_labels): raise ValueError(\\"Predictions and true labels must have the same length.\\") # Validate input values for p in predictions: if p not in [0, 1]: raise ValueError(\\"Predictions must only contain binary values (0 or 1).\\") for t in true_labels: if t not in [0, 1]: raise ValueError(\\"True labels must only contain binary values (0 or 1).\\") logging.info(\\"Input validation successful.\\") # Convert to numpy arrays for convenience predictions = np.array(predictions) true_labels = np.array(true_labels) # Computing metrics accuracy = accuracy_score(true_labels, predictions) precision = precision_score(true_labels, predictions) recall = recall_score(true_labels, predictions) f1 = f1_score(true_labels, predictions) auc_roc = roc_auc_score(true_labels, predictions) conf_matrix = confusion_matrix(true_labels, predictions) logging.info(\\"Metrics computation successful.\\") # Print metrics print(f\\"Accuracy: {accuracy:.4f}\\") print(f\\"Precision: {precision:.4f}\\") print(f\\"Recall: {recall:.4f}\\") print(f\\"F1 Score: {f1:.4f}\\") print(f\\"AUC-ROC: {auc_roc:.4f}\\") print(\\"Confusion Matrix:\\") print(conf_matrix) except ValueError as e: logging.error(str(e)) print(f\\"Error: {str(e)}\\")"},{"question":"# Scenario: You are developing a calendar application and one of the features involves determining if a given year is a leap year. Leap years are critical for accurately calculating the number of days in February and ensuring calendar correctness. A year is a leap year if it is divisible by 4; however, if the year is divisible by 100, it is not a leap year unless it is also divisible by 400. # Task: Implement the function `is_leap_year` that takes an integer representing a year as input and returns `True` if the year is a leap year, and `False` otherwise. # Function Signature: ```python def is_leap_year(year: int) -> bool: ``` # Input/Output: * **Input**: * `year` (int): A year in the Gregorian calendar (1 ≤ year ≤ 9999). * **Output**: * (bool): `True` if the given year is a leap year, `False` otherwise. # Constraints: * The input year will always be within the range [1, 9999]. # Example: ```python >>> is_leap_year(2000) True >>> is_leap_year(1900) False >>> is_leap_year(2004) True >>> is_leap_year(2100) False >>> is_leap_year(2024) True ``` # Notes: - A leap year is divisible by 4. - If the year is divisible by 100, it must also be divisible by 400 to be considered a leap year. - Ensure the function runs efficiently and handles all edge cases appropriately within the provided constraints.","solution":"def is_leap_year(year: int) -> bool: Returns True if the given year is a leap year, False otherwise. A year is a leap year if: - It is divisible by 4. - If it is divisible by 100, it must also be divisible by 400. if year % 4 == 0: if year % 100 == 0: if year % 400 == 0: return True else: return False else: return True else: return False"},{"question":"# Problem: Replace Substring in String You are tasked with writing a function that replaces every occurrence of a specific substring within a string with another substring. This function is essential for modifying and reformatting textual data based on given specifications. Function Signature ```python def replace_substring(original: str, to_replace: str, replacement: str) -> str: Replace all occurrences of a substring within a string with another substring. Parameters: original (str): The original string where replacements will be made. to_replace (str): The substring to be replaced. replacement (str): The substring to replace with. Returns: str: A string with all occurrences of \'to_replace\' replaced by \'replacement\'. Example: >>> replace_substring(\\"I love programming\\", \\"love\\", \\"enjoy\\") \'I enjoy programming\' >>> replace_substring(\\"aaaa\\", \\"a\\", \\"b\\") \'bbbb\' >>> replace_substring(\\"Hello World\\", \\"World\\", \\"Universe\\") \'Hello Universe\' ``` Input * A string `original` (0 <= len(original) <= 1000). * A string `to_replace` (1 <= len(to_replace) <= 1000). * A string `replacement` (0 <= len(replacement) <= 1000). Output * A string where every occurrence of `to_replace` has been replaced by `replacement`. Constraints * If `to_replace` is an empty string, the original string should be returned unchanged. * The replacement should be case-sensitive (i.e., \'love\' and \'Love\' are distinct). Examples ```python replace_substring(\\"I love programming\\", \\"love\\", \\"enjoy\\") # Should output: \'I enjoy programming\' replace_substring(\\"aaaa\\", \\"a\\", \\"b\\") # Should output: \'bbbb\' replace_substring(\\"Hello World\\", \\"World\\", \\"Universe\\") # Should output: \'Hello Universe\' replace_substring(\\"ababab\\", \\"ab\\", \\"xy\\") # Should output: \'xyxyxy\' replace_substring(\\"\\", \\"a\\", \\"b\\") # Should output: \'\' ```","solution":"def replace_substring(original: str, to_replace: str, replacement: str) -> str: Replace all occurrences of a substring within a string with another substring. Parameters: original (str): The original string where replacements will be made. to_replace (str): The substring to be replaced. replacement (str): The substring to replace with. Returns: str: A string with all occurrences of \'to_replace\' replaced by \'replacement\'. if to_replace == \\"\\": return original return original.replace(to_replace, replacement)"},{"question":"You are asked to create a class that models a simple hash table with chaining for collision resolution. The hash table should support basic operations such as insertion, deletion, and lookup. # Implementation Details Implement the class `SimpleHashTable` that supports the following methods: 1. `__init__(self, size: int) -> None`: - Initializes the hash table with a fixed number of slots specified by `size`. 2. `hash_function(self, key: str) -> int`: - A simple hash function that returns an index based on the key. You can use Python\'s built-in `hash()` function and take the modulo with the size of the table to determine the index. 3. `insert(self, key: str, value: T) -> None`: - Inserts a key-value pair into the hash table. If the key already exists, it updates its value. 4. `delete(self, key: str) -> None`: - Removes the key-value pair from the hash table. Raises `KeyError` if the key does not exist. 5. `lookup(self, key: str) -> T`: - Retrieves the value associated with the key. Raises `KeyError` if the key does not exist. 6. `clear_table(self) -> None`: - Clears all key-value pairs from the hash table. # Constraints - Keys are unique. - The hash table size is fixed upon initialization and cannot be resized. - Handle collisions using chaining (linked lists within each slot). # Example ```python hash_table = SimpleHashTable(size=10) hash_table.insert(\'apple\', 5) hash_table.insert(\'banana\', 3) assert hash_table.lookup(\'apple\') == 5 assert hash_table.lookup(\'banana\') == 3 hash_table.insert(\'apple\', 10) assert hash_table.lookup(\'apple\') == 10 hash_table.delete(\'banana\') try: hash_table.lookup(\'banana\') except KeyError: print(\'Key not found\') hash_table.clear_table() try: hash_table.lookup(\'apple\') except KeyError: print(\'Key not found\') ``` # Notes - Ensure proper collision handling with chaining. - Implement efficient lookup, insertion, and deletion operations. - Be cautious about handling edge cases like inserting duplicate keys or looking up non-existing keys.","solution":"class SimpleHashTable: def __init__(self, size: int) -> None: self.size = size self.table = [[] for _ in range(size)] def hash_function(self, key: str) -> int: return hash(key) % self.size def insert(self, key: str, value) -> None: index = self.hash_function(key) for item in self.table[index]: if item[0] == key: item[1] = value return self.table[index].append([key, value]) def delete(self, key: str) -> None: index = self.hash_function(key) for item in self.table[index]: if item[0] == key: self.table[index].remove(item) return raise KeyError(f\'Key {key} not found\') def lookup(self, key: str): index = self.hash_function(key) for item in self.table[index]: if item[0] == key: return item[1] raise KeyError(f\'Key {key} not found\') def clear_table(self) -> None: self.table = [[] for _ in range(self.size)]"},{"question":"# Question: Implement a Priority Queue with Custom Comparators You are tasked with implementing a priority queue with additional functionalities that are common in real-world applications. Specifically, the priority queue should support custom comparators for different types of prioritization. **Features to Implement**: 1. **Custom Comparator Initialization**: The priority queue should accept a custom comparator for ordering the elements. 2. **Support for Multiple Typings**: The queue should handle elements that could be of different types (integers, strings, objects). 3. **Bulk Operations**: Implement methods to add and remove multiple elements at once. 4. **Current Highest Priority Element**: Implement a method to retrieve the current highest priority element without removing it from the queue. # Function Definitions: ```python class CustomPriorityQueue: def __init__(self, comparator_func: callable) -> None: \'\'\' Initialize the priority queue with a custom comparator function. Args: comparator_func (callable): A function that compares two elements. \'\'\' self.comparator = comparator_func self.queue = [] def enqueue(self, element) -> None: \'\'\' Add an element to the priority queue. Args: element: The element to add. \'\'\' pass def dequeue(self): \'\'\' Remove and return the highest priority element from the queue. Returns: The element with the highest priority. \'\'\' pass def peek(self): \'\'\' Return the highest priority element without removing it from the queue. Returns: The element with the highest priority. \'\'\' pass def add_bulk(self, elements: list) -> None: \'\'\' Add multiple elements to the queue. Args: elements (list): A list of elements to add. \'\'\' pass def remove_bulk(self, count: int) -> list: \'\'\' Remove multiple elements from the queue. Args: count (int): The number of elements to remove. Returns: A list of removed elements. \'\'\' pass ``` Input Format: 1. For `enqueue`: `(element)` where `element` can be of different types compatible with the comparator. 2. For `dequeue`: No input. 3. For `peek`: No input. 4. For `add_bulk`: `([element1, element2, ...])` a list of elements to add. 5. For `remove_bulk`: `(count)` where `count` denotes the number of elements to remove from the queue. Output Format: 1. For `dequeue`: Returns the highest priority element. 2. For `peek`: Returns the highest priority element without removing it. 3. For `remove_bulk`: Returns a list of removed elements. Constraints: - The priority queue should manage elements efficiently following the comparator\'s ordering. - Handle different types within the queue while respecting the comparator. - Ensure bulk operations are performed efficiently without compromising performance. Example Usage: ```python # Custom comparator function (min-heap based on integer values) def comparator(x, y): return x - y # Creating an instance of CustomPriorityQueue with the custom comparator priority_queue = CustomPriorityQueue(comparator) # Enqueue elements priority_queue.enqueue(5) priority_queue.enqueue(1) priority_queue.enqueue(3) # Peek at the current highest priority element print(priority_queue.peek()) # Output: 1 # Add bulk elements priority_queue.add_bulk([7, 2, 4]) # Remove and get the highest priority element print(priority_queue.dequeue()) # Output: 1 # Remove multiple elements print(priority_queue.remove_bulk(2)) # Output: [2, 3] ``` This problem tests your understanding of priority queues, custom comparators, and efficient management of bulk operations while maintaining robust internal ordering logic.","solution":"import heapq class CustomPriorityQueue: def __init__(self, comparator_func: callable) -> None: \'\'\' Initialize the priority queue with a custom comparator function. Args: comparator_func (callable): A function that compares two elements. \'\'\' self.comparator = comparator_func self.queue = [] def enqueue(self, element) -> None: \'\'\' Add an element to the priority queue. Args: element: The element to add. \'\'\' heapq.heappush(self.queue, (self._priority(element), element)) def dequeue(self): \'\'\' Remove and return the highest priority element from the queue. Returns: The element with the highest priority. \'\'\' return heapq.heappop(self.queue)[1] def peek(self): \'\'\' Return the highest priority element without removing it from the queue. Returns: The element with the highest priority. \'\'\' return self.queue[0][1] if self.queue else None def add_bulk(self, elements: list) -> None: \'\'\' Add multiple elements to the queue. Args: elements (list): A list of elements to add. \'\'\' for element in elements: self.enqueue(element) def remove_bulk(self, count: int) -> list: \'\'\' Remove multiple elements from the queue. Args: count (int): The number of elements to remove. Returns: A list of removed elements. \'\'\' removed_elements = [] for _ in range(count): if self.queue: removed_elements.append(self.dequeue()) return removed_elements def _priority(self, element): return CustomPriorityQueue.PriorityWrapper(self.comparator, element) class PriorityWrapper: def __init__(self, comparator_func, element): self.comparator_func = comparator_func self.element = element def __lt__(self, other): return self.comparator_func(self.element, other.element) < 0 def __eq__(self, other): return self.comparator_func(self.element, other.element) == 0"},{"question":"# Coding Assessment Question Scenario You have been hired by a logistics company to optimize delivery routes. Your task is to develop a function that calculates the minimum time required to deliver all packages given certain constraints about road connections and traffic conditions between cities. Problem Statement Implement a function `find_min_delivery_time(n: int, roads: List[Tuple[int, int, int]]) -> int` where: * `n` is the number of cities. * `roads` is a list of tuples, where each tuple contains three integers `(u, v, t)` indicating there is a bidirectional road between city `u` and city `v` that takes `t` time units to travel. The function should return the minimum time required to deliver packages from city 1 to all other cities. Implementation Details: * **Input Format**: - `n` (2 ≤ n ≤ 1000): The number of cities. City indices range from 1 to `n`. - `roads`: A list of tuples representing the road connections and travel times. Each tuple `(u, v, t)` means there is a direct road between city `u` and city `v` that takes `t` time units. * **Output Format**: - Return an integer representing the minimum time required to deliver packages from city 1 to all other cities. * **Performance Requirements**: - Use an efficient shortest path algorithm, such as Dijkstra’s algorithm, to compute the minimum time. Constraints: * At least one road exists between any two cities in some direct or indirect manner. * The travel time `t` is a positive integer. Example: * Example 1: ```python >>> find_min_delivery_time(4, [(1, 2, 4), (1, 3, 2), (2, 3, 5), (2, 4, 10), (3, 4, 3)]) 5 ``` Explanation: The shortest path from city 1 to city 4 is 1 -> 3 -> 4 with a total travel time of 2 + 3 = 5. * Example 2: ```python >>> find_min_delivery_time(3, [(1, 2, 2), (2, 3, 1), (1, 3, 7)]) 3 ``` Explanation: The shortest path from city 1 to city 3 is 1 -> 2 -> 3 with a total travel time of 2 + 1 = 3. Notes: * Validate the input parameters to ensure they fall within the specified ranges. * Document any assumptions made about the function implementation.","solution":"from typing import List, Tuple import heapq def find_min_delivery_time(n: int, roads: List[Tuple[int, int, int]]) -> int: Finds the minimum time required to deliver packages from city 1 to all other cities. Parameters: n (int): The number of cities. roads (List[Tuple[int, int, int]]): List of tuples representing roads between cities and travel times. Returns: int: The minimum time required to deliver packages from city 1 to all other cities. # Create adjacency list representation of the graph adj = {i: [] for i in range(1, n + 1)} for u, v, t in roads: adj[u].append((v, t)) adj[v].append((u, t)) # Implement Dijkstra\'s Algorithm def dijkstra(start: int): dist = {i: float(\'inf\') for i in range(1, n + 1)} dist[start] = 0 min_heap = [(0, start)] # (distance, city) while min_heap: current_dist, u = heapq.heappop(min_heap) if current_dist > dist[u]: continue for neighbor, weight in adj[u]: distance = current_dist + weight if distance < dist[neighbor]: dist[neighbor] = distance heapq.heappush(min_heap, (distance, neighbor)) return dist distances = dijkstra(1) return max(distances.values())"},{"question":"# Prime Factors and Their Power Sum Context: In mathematics, the prime factors of a number are the prime numbers that divide it exactly (with no remainder). Each prime factor can appear more than once in the factorization of the number. The power sum of the prime factors (including their multiplicities) is the sum of each prime factor multiplied by its respective power. For example, the prime factorization of 72 is 2^3 * 3^2, so the power sum is 2*3 + 3*2 = 6 + 6 = 12. Objective: Write a function to calculate the power sum of the prime factors of a given number. Function Signature: ```python def prime_factors_power_sum(number: int) -> int: ``` Input: * `number` (int): a positive integer, where 1 ≤ number ≤ 10^6. Output: * (int): the sum of the prime factors multiplied by their respective powers. Constraints: * The function should handle integer inputs between 1 and 10^6 efficiently. * Make use of efficient prime factorization techniques to deal with the upper input limits. Example: ```python assert prime_factors_power_sum(72) == 12 # 2^3 * 3^2 => 2*3 + 3*2 = 6 + 6 = 12 assert prime_factors_power_sum(30) == 10 # 2^1 * 3^1 * 5^1 => 2*1 + 3*1 + 5*1 = 2 + 3 + 5 = 10 ``` Notes: * Consider precomputing prime numbers up to the square root of the maximum input value for efficient factorization. * Ensure the solution is optimized for both time and space complexity.","solution":"def prime_factors_power_sum(number: int) -> int: Calculate the power sum of the prime factors of a given number. Parameters: number (int): a positive integer Returns: int: the sum of the prime factors multiplied by their respective powers if number < 2: return 0 original_number = number factor_sum = 0 factor_count = [] # Check for number of 2s in the factorization count = 0 while number % 2 == 0: number //= 2 count += 1 if count > 0: factor_count.append((2, count)) # Check for odd numbers from 3 to sqrt(number) for i in range(3, int(number**0.5) + 1, 2): count = 0 while number % i == 0: number //= i count += 1 if count > 0: factor_count.append((i, count)) # If number is a prime number greater than 2 if number > 2: factor_count.append((number, 1)) # Calculate the power sum for factor, count in factor_count: factor_sum += factor * count return factor_sum"},{"question":"# Question: String Subsequence Finder You are tasked with implementing a function that finds all unique subsequences of a given string using a recursive approach. A subsequence is a sequence derived by deleting some or none of the characters without changing the order of the remaining characters. Requirements: - Implement a function `find_subsequences(s: str) -> list[str]` that performs the task. - Do not use Python\'s built-in library functions for generating subsequences or combinations. - Aim to handle strings of length up to `n` efficiently, where `n` is the length of the input string. Constraints: - The input string `s` will only contain lowercase English letters. - The length of the input string `s` will not exceed 15. # Input Example: ```python s = \\"abc\\" ``` # Output Example: ```python [\\"\\", \\"a\\", \\"b\\", \\"c\\", \\"ab\\", \\"ac\\", \\"bc\\", \\"abc\\"] ``` # Implementation Challenge: - Consider all edge cases, including an empty input string. - Ensure that each subsequence is returned only once in the output list. # Performance Considerations: - Ensure that your solution efficiently handles generating subsequences within the given constraints.","solution":"def find_subsequences(s: str) -> list[str]: Returns all unique subsequences of the given string `s`. def subsequences_helper(s: str, index: int, current: str, result: set): if index == len(s): result.add(current) return # Exclude the current character subsequences_helper(s, index + 1, current, result) # Include the current character subsequences_helper(s, index + 1, current + s[index], result) result = set() subsequences_helper(s, 0, \\"\\", result) return sorted(result) # Sorting for predictable order # Examples to test the function manually # print(find_subsequences(\\"abc\\")) # Output should be [\\"\\", \\"a\\", \\"ab\\", \\"abc\\", \\"ac\\", \\"b\\", \\"bc\\", \\"c\\"] # print(find_subsequences(\\"\\")) # Output should be [\\"\\"]"},{"question":"# Sorting a List of Tuples Given the following specifications: * You are implementing a function to sort a list of tuples based on the second element in each tuple. * If two tuples have the same second element, they should be sorted based on the first element. * You must ensure that the sorting is stable, which means that the relative order of tuples with the same elements should be preserved as in the original list. **Function Signature:** ```python def sort_tuples(lst: List[Tuple[int, int]]) -> List[Tuple[int, int]]: pass ``` **Input:** * A list of tuples `lst`, where each tuple consists of two integers. **Output:** * A list of tuples sorted based on the rules described above. **Constraints:** * `1 <= len(lst) <= 1000` * Each tuple contains two integer elements where `-1000 <= each element <= 1000`. **Problem Requirements:** * Analyze the provided list of tuples. * Sort the tuples first by the second element, and in the case of a tie, by the first element. * Ensure the sorting algorithm maintains the stability property. **Example:** ```python assert sort_tuples([(1, 3), (4, 2), (2, 3), (3, 1)]) == [(3, 1), (4, 2), (1, 3), (2, 3)] assert sort_tuples([(5, 5), (2, 2), (2, 5), (1, 5)]) == [(2, 2), (2, 5), (5, 5), (1, 5)] assert sort_tuples([(1, 1), (1, 0)]) == [(1, 0), (1, 1)] assert sort_tuples([(8, -8), (-8, 8), (0, 0), (5, 5)]) == [(8, -8), (0, 0), (5, 5), (-8, 8)] ``` **Notes:** * Ensure your function handles both small and large lists efficiently. * Take care of edge cases where the elements have minimum or maximum possible values. * The use of Python\'s built-in sorted function with an appropriate key is encouraged for simplicity.","solution":"from typing import List, Tuple def sort_tuples(lst: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Sorts a list of tuples based on the second element of each tuple. If two tuples have the same second element, they are sorted by the first element. Args: lst: List of tuples, where each tuple contains two integers. Returns: A sorted list of tuples. return sorted(lst, key=lambda x: (x[1], x[0]))"},{"question":"**Scenario**: You are developing a file processing application that processes large volumes of log files from various servers. One common task is to process and analyze the log entries, which are organized in a specific time-stamped order. A crucial feature is to efficiently find the log file that has the highest number of log entries within a given timeframe. **Objective**: Implement the `find_file_with_most_entries` function that identifies the log file with the maximum number of entries within the specified start and end times. The function should accept a list of log files, each represented as a list of timestamped entries, and the start and end times to define the relevant time window. # Function Signature ```python def find_file_with_most_entries(log_files: list[list[str]], start_time: str, end_time: str) -> int: pass ``` # Input - `log_files`: A list of log files, where each log file is represented as a list of timestamped entries (strings in \\"YYYY-MM-DD HH:MM:SS\\" format). - `start_time`: A string representing the start time in \\"YYYY-MM-DD HH:MM:SS\\" format. - `end_time`: A string representing the end time in \\"YYYY-MM-DD HH:MM:SS\\" format. # Output - An integer representing the index of the log file with the most entries within the specified timeframe. # Constraints - Each timestamped entry in the log files is unique. - All timestamps are in the same format and chronologically ordered within each file. - The function should return -1 if no log entries fall within the specified timeframe. # Example Usage ```python >>> log_files = [ [\\"2023-01-01 10:00:00\\", \\"2023-01-01 10:05:00\\", \\"2023-01-01 10:10:00\\"], [\\"2023-01-01 10:00:00\\", \\"2023-01-01 10:01:00\\", \\"2023-01-01 10:02:00\\", \\"2023-01-01 10:03:00\\"], [\\"2023-01-01 10:05:00\\", \\"2023-01-01 10:10:00\\"] ] >>> start_time = \\"2023-01-01 10:00:00\\" >>> end_time = \\"2023-01-01 10:05:00\\" >>> find_file_with_most_entries(log_files, start_time, end_time) 1 >>> start_time = \\"2023-01-01 10:06:00\\" >>> end_time = \\"2023-01-01 10:09:00\\" >>> find_file_with_most_entries(log_files, start_time, end_time) -1 ``` # Additional Notes - Ensure the function handles edge cases, such as when no entries fall within the specified timeframe. - Optimize the function for performance given that the number of log files and their individual sizes can be large. - Properly parse and compare timestamp strings to efficiently determine the relevant entries.","solution":"from datetime import datetime def find_file_with_most_entries(log_files: list[list[str]], start_time: str, end_time: str) -> int: Finds the index of the log file with the most entries within the specified time window. Args: log_files: list of log files, each represented as a list of timestamped entries. start_time: start time in \\"YYYY-MM-DD HH:MM:SS\\" format. end_time: end time in \\"YYYY-MM-DD HH:MM:SS\\" format. Returns: int: index of the log file with the most entries within the given timeframe, or -1 if no entries fall within the timeframe. start_dt = datetime.strptime(start_time, \\"%Y-%m-%d %H:%M:%S\\") end_dt = datetime.strptime(end_time, \\"%Y-%m-%d %H:%M:%S\\") max_entries = 0 result_index = -1 for i, log_file in enumerate(log_files): count = 0 for timestamp in log_file: entry_dt = datetime.strptime(timestamp, \\"%Y-%m-%d %H:%M:%S\\") if start_dt <= entry_dt <= end_dt: count += 1 if count > max_entries: max_entries = count result_index = i return result_index"},{"question":"# Implementing a Basic File System Design a basic in-memory file system that can create files, write data to files, read data from files, and delete files. The file system should support operations on multiple files and maintain the structure in a hierarchical manner with directories. Function Signatures: ```python class FileSystem: def __init__(self): pass def create_file(self, path: str) -> bool: pass def write_to_file(self, path: str, data: str) -> bool: pass def read_from_file(self, path: str) -> str: pass def delete_file(self, path: str) -> bool: pass ``` Methods: - `__init__(self)`: Initializes the file system. - `create_file(self, path: str) -> bool`: Creates a file at the specified path. Returns `True` if successful, `False` if the file already exists or an invalid path is given. - `write_to_file(self, path: str, data: str) -> bool`: Writes the data to the file at the specified path. Returns `True` if successful, `False` if the file does not exist. - `read_from_file(self, path: str) -> str`: Reads the data from the file at the specified path. Returns the file content as a string. If the file does not exist, returns an empty string. - `delete_file(self, path: str) -> bool`: Deletes the file at the specified path. Returns `True` if successful, `False` if the file does not exist. Constraints: - File paths are given as strings and can include directories separated by forward slashes (\'/\'). - Assume that directory creation is implicit when creating a file inside it. - Only files and directories will be part of the file system, no symbolic links or other advanced file system features. Example: ```python fs = FileSystem() # Creating files print(fs.create_file(\\"/a/b/c.txt\\")) # Expected: True print(fs.create_file(\\"/a/b/c.txt\\")) # Expected: False (already exists) # Writing and reading data print(fs.write_to_file(\\"/a/b/c.txt\\", \\"Hello, World!\\")) # Expected: True print(fs.read_from_file(\\"/a/b/c.txt\\")) # Expected: \\"Hello, World!\\" # Deleting files print(fs.delete_file(\\"/a/b/c.txt\\")) # Expected: True print(fs.delete_file(\\"/a/b/c.txt\\")) # Expected: False (file already deleted) ```","solution":"class FileSystem: def __init__(self): self.files = {} def create_file(self, path: str) -> bool: if path in self.files: return False self.files[path] = \\"\\" return True def write_to_file(self, path: str, data: str) -> bool: if path not in self.files: return False self.files[path] = data return True def read_from_file(self, path: str) -> str: return self.files.get(path, \\"\\") def delete_file(self, path: str) -> bool: if path in self.files: del self.files[path] return True return False"},{"question":"# Array Rotation Checker You are given two arrays `A` and `B` with unique elements. Your task is to write a function `is_rotation` that determines if array `B` is a rotation of array `A`. A rotation means that while the elements in `B` are in a different order compared to `A`, one of the rotations of `A` will exactly match `B`. Note that the order of elements and the relative position between elements must be preserved. # Implementation Details: 1. **`is_rotation` method** should: - Accept two lists, `A` and `B`. - Return a boolean value indicating whether `B` is a rotation of `A`. # Input/Output: - **Input**: ```python def is_rotation(A, B): # A: List of unique elements # B: List of unique elements ``` - **Output**: - Return `True` if `B` is a rotation of `A`. Else return `False`. # Constraints: 1. Both arrays `A` and `B` have the same length. 2. Arrays consist of unique integers. 3. The length of the arrays does not exceed 1000 elements. # Example: ```python # Example 1 A = [1, 2, 3, 4, 5] B = [3, 4, 5, 1, 2] print(is_rotation(A, B)) # Output: True (because B is [1,2,3,4,5] rotated by 3 positions) # Example 2 A = [10, 20, 30, 40] B = [40, 10, 20, 30] print(is_rotation(A, B)) # Output: True (because B is [10, 20, 30, 40] rotated by 1 position) # Example 3 A = [7, 8, 9] B = [9, 7, 8] print(is_rotation(A, B)) # Output: False (because B is not a valid rotation of A) ``` # Notes: - Consider employing an efficient approach to avoid unnecessary computations. - While there may be multiple ways to validate the rotation, ensure that your solution is optimized for larger input sizes. - Ensure you handle edge cases such as arrays with minimal elements (e.g., size 1 or 2).","solution":"def is_rotation(A, B): Determines if array B is a rotation of array A. Args: A (list): The original list of unique elements. B (list): The list to check if it is a rotation of A. Returns: bool: True if B is a rotation of A, False otherwise. if len(A) != len(B): return False if not A and not B: return True # Check if B is a sublist of A+A return \'\'.join(map(str, B)) in \'\'.join(map(str, A + A))"},{"question":"# Sum of Cumulative Products Scenario In data processing, sometimes it is required to compute the sum of products of consecutive elements from two lists. For two lists, list1 and list2 of the same length, the cumulative product at each step is the product of the corresponding elements from list1 and list2. The final result is the sum of all these cumulative products. Your task is to compute the sum of cumulative products of two equally sized lists of integers. Task Implement a function `sum_cumulative_products` that calculates and returns the sum of cumulative products of two equally sized lists of integers. If the two lists are not of the same size, the function should raise a `ValueError`. Function Signature ```python def sum_cumulative_products(list1: list[int], list2: list[int]) -> int: pass ``` Parameters - `list1 (list[int])`: The first list of integers for which products are to be computed. - `list2 (list[int])`: The second list of integers for which products are to be computed. Returns - An integer representing the sum of the cumulative products of the two lists. Constraints - Both input lists must be of the same length. - The elements of the lists are integers. Examples - `sum_cumulative_products([1, 2, 3], [4, 5, 6])` should return `32` because 1*4 + 2*5 + 3*6 = 4 + 10 + 18 = 32 - `sum_cumulative_products([7, 0, -2], [3, 8, -5])` should return `-37` because 7*3 + 0*8 + (-2)*(-5) = 21 + 0 + 10 = 31 - `sum_cumulative_products([1, 2], [1])` should raise `ValueError(\\"Both lists must have the same length\\")`. - `sum_cumulative_products([1], [-1])` should return `-1` because 1*(-1) = -1","solution":"def sum_cumulative_products(list1, list2): Calculate the sum of cumulative products of two equally sized lists of integers. Args: list1 (list[int]): The first list of integers. list2 (list[int]): The second list of integers. Returns: int: The sum of the cumulative products. Raises: ValueError: If the two lists are not of the same size. if len(list1) != len(list2): raise ValueError(\\"Both lists must have the same length\\") return sum(a * b for a, b in zip(list1, list2))"},{"question":"# Count Paths in a Matrix Background: You are given an `m x n` matrix. Your task is to count the number of distinct paths from the top-left corner to the bottom-right corner of the matrix. You can only move either down or right at any point in time. Task: Implement a method that calculates the number of unique paths from the top-left to the bottom-right corner of the matrix. Function Signature: ```python def count_paths(m: int, n: int) -> int: ``` Input: - `m` (int): The number of rows in the matrix. - `n` (int): The number of columns in the matrix. Output: - An integer representing the number of unique paths from the top-left corner to the bottom-right corner. Constraints: - `1 <= m, n <= 100` Example: ```python print(count_paths(2, 2)) # Should print: 2 print(count_paths(3, 2)) # Should print: 3 print(count_paths(3, 3)) # Should print: 6 ``` Implementation Guidelines: - Use a dynamic programming approach to efficiently compute the number of unique paths. - Consider edge cases where the number of rows or columns is 1. - Avoid redundant calculations by using a memoization technique or an iterative approach to store intermediate results. Solution: ```python def count_paths(m: int, n: int) -> int: if m == 0 or n == 0: return 0 dp = [[1] * n for _ in range(m)] for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1] ``` This new question aligns with the existing set by maintaining a similar level of complexity, scope, and length as the given sample. It requires an understanding of dynamic programming concepts, making it a complementary addition to the task set.","solution":"def count_paths(m: int, n: int) -> int: if m == 0 or n == 0: return 0 # Initialize a 2D dp array with dimensions m x n dp = [[1] * n for _ in range(m)] # Fill the dp array according to the number of paths formula for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] # The bottom-right corner will hold the number of unique paths return dp[m-1][n-1]"},{"question":"# Implement Version Control Diff Tracker Objective You are to implement a light-weight version control diff tracker that allows keeping track of changes made to a text file over time. This tracker will record successive changes and allow you to compare any two versions to see the differences between them. Requirements 1. **Initialization**: Initialize the version control system with an initial version of a text represented as a string. 2. **Save Version**: Implement a method to save the current state of the text as a new version. 3. **Get Difference**: Implement a method to compare any two versions and return the differences between them. Specifications 1. The initial text is a string and may contain alphanumeric characters and special symbols. 2. Versions are identified by integers starting from 0 (initial version). 3. The `save_version` method should create a new version of the text. 4. The `get_diff` method should take two version indices and return a list of differences between them line-by-line. 5. The differences should be returned in a format that indicates line additions, deletions, and changes. For simplicity, you can use a single character prefix for representation: - `+` for added lines - `-` for removed lines - `~` for changed lines Input & Output * **Initialization**: ```python vcs = VersionControl(initial_text: str) ``` * `initial_text` is the initial content of the text file. * **Save Version**: ```python vcs.save_version(new_text: str) -> int ``` * `new_text` is the updated content of the text file. * Returns the version number of the newly saved version. * **Get Difference**: ```python differences = vcs.get_diff(version1: int, version2: int) -> List[str] ``` * `version1` and `version2` are the indices of the versions to be compared. * Returns a list of strings where each string represents a changed line with the appropriate prefix. Example ```python # Initialize version control with initial text initial_text = \\"Hello worldnThis is a test file.nVersion control is useful.\\" vcs = VersionControl(initial_text) # Save new versions version_1 = vcs.save_version(\\"Hello worldnThis is a modified test file.nVersion control is useful.\\") version_2 = vcs.save_version(\\"Hello universenThis is a modified test file.nVersion control is essential.\\") # Get differences between versions diff_0_1 = vcs.get_diff(0, 1) print(diff_0_1) # Output: [\\"~ This is a modified test file.\\"] diff_1_2 = vcs.get_diff(1, 2) print(diff_1_2) # Output: [\\"~ Hello universe\\", \\"~ Version control is essential.\\"] ``` Implement the Version Control class so that it can efficiently keep track of versions, save new versions, and provide meaningful differences between versions.","solution":"class VersionControl: def __init__(self, initial_text): self.versions = [initial_text.splitlines()] def save_version(self, new_text): self.versions.append(new_text.splitlines()) return len(self.versions) - 1 def get_diff(self, version1, version2): from difflib import unified_diff lines1 = self.versions[version1] lines2 = self.versions[version2] diff = list(unified_diff(lines1, lines2, lineterm=\'\')) result = [] for line in diff: if line.startswith(\'---\') or line.startswith(\'+++\') or line.startswith(\'@@\'): continue elif line.startswith(\'-\'): result.append(\'- \' + line[1:].strip()) elif line.startswith(\'+\'): result.append(\'+ \' + line[1:].strip()) elif line.startswith(\' \'): continue return result"},{"question":"# Problem Statement Write a function to determine if a given string is a valid floating-point number. The rules for valid floating-point numbers are as follows: 1. It can optionally start with a plus or minus sign (`+` or `-`). 2. It must contain at least one digit. 3. It may have a decimal point (`.`) followed by zero or more digits. 4. It may optionally include an exponent part, which is a power of 10 indicated by either `e` or `E`, followed optionally by a plus or minus sign and then an integer. Your task is to implement the function `is_valid_float`, which takes a string and checks if it is a valid floating-point number based on the rules above. # Function Signature ```python def is_valid_float(s: str) -> bool: ... ``` # Input - `s`: A string representing the number to be validated. # Output - A boolean value indicating whether the input string is a valid floating-point number. # Constraints - The function should return `False` for strings that do not conform to the floating-point number rules. - The input string may have leading and trailing whitespaces. You should trim them before validation. # Requirements 1. Implement proper input validation to check if the string is a valid floating-point number. 2. Handle edge cases such as strings with only signs, multiple decimal points, or invalid exponent notations. 3. Do not use regular expressions for this problem. Use basic string and numerical operations. # Example ```python >>> is_valid_float(\\"3.14\\") True >>> is_valid_float(\\"1e10\\") True >>> is_valid_float(\\"-3.14e-10\\") True >>> is_valid_float(\\".e1\\") False >>> is_valid_float(\\"123\\") True >>> is_valid_float(\\" 3.14 \\") True >>> is_valid_float(\\"+-3.14\\") False >>> is_valid_float(\\"abc\\") False ``` # Note Ensure that basic string manipulations, such as trimming whitespaces and splitting substrings, are well-handled.","solution":"def is_valid_float(s: str) -> bool: Checks if the given string is a valid floating-point number. # Trim leading and trailing whitespace s = s.strip() # Check if the string is empty after trimming if not s: return False # Initialize state variables seen_digit = False seen_dot = False seen_exponent = False # Process each character in the string for i, char in enumerate(s): if char in \'+-\': if i > 0 and s[i-1] not in \'eE\': return False elif char.isdigit(): seen_digit = True elif char == \'.\': if seen_dot or seen_exponent: return False seen_dot = True elif char in \'eE\': if seen_exponent or not seen_digit: return False seen_exponent = True seen_digit = False # reset seen_digit for the exponent part else: return False # Return True only if a digit has been seen and the string ends correctly return seen_digit"},{"question":"# Problem Statement You are tasked with implementing a function using dynamic programming techniques to calculate the nth Fibonacci number. The Fibonacci function should be implemented both recursively and iteratively to analyze the strengths and weaknesses of each approach. Additionally, the recursive implementation should use memoization to improve performance. # Requirements 1. **Recursive Implementation with Memoization**: - Function Name: `recursive_fibonacci` - Input: Single integer `n` - Output: Integer representing the nth Fibonacci number. - Constraints: * Assume the input is a non-negative integer. * Return an error message for negative inputs. 2. **Iterative Implementation**: - Function Name: `iterative_fibonacci` - Input: Single integer `n` - Output: Integer representing the nth Fibonacci number. - Constraints: * Assume the input is a non-negative integer. * Return an error message for negative inputs. 3. You should use Python\'s `functools.lru_cache` for memoization within the recursive function. # Example For example, the implementation should yield the following outputs: ```python assert recursive_fibonacci(5) == 5 assert iterative_fibonacci(5) == 5 assert recursive_fibonacci(0) == 0 assert iterative_fibonacci(0) == 0 assert recursive_fibonacci(-1) == \\"Error: Input must be a non-negative integer.\\" assert iterative_fibonacci(-1) == \\"Error: Input must be a non-negative integer.\\" ``` # Function Definitions **Recursive Implementation with Memoization** ```python from functools import lru_cache @lru_cache def recursive_fibonacci(n: int) -> int: if n < 0: return \\"Error: Input must be a non-negative integer.\\" if n == 0: return 0 if n == 1: return 1 return recursive_fibonacci(n - 1) + recursive_fibonacci(n - 2) ``` **Iterative Implementation** ```python def iterative_fibonacci(n: int) -> int: if n < 0: return \\"Error: Input must be a non-negative integer.\\" if n == 0: return 0 if n == 1: return 1 fib_0, fib_1 = 0, 1 for _ in range(2, n + 1): fib_0, fib_1 = fib_1, fib_0 + fib_1 return fib_1 ``` Implement these functions and ensure they pass the provided example cases.","solution":"from functools import lru_cache @lru_cache def recursive_fibonacci(n: int) -> int: if n < 0: return \\"Error: Input must be a non-negative integer.\\" if n == 0: return 0 if n == 1: return 1 return recursive_fibonacci(n - 1) + recursive_fibonacci(n - 2) def iterative_fibonacci(n: int) -> int: if n < 0: return \\"Error: Input must be a non-negative integer.\\" if n == 0: return 0 if n == 1: return 1 fib_0, fib_1 = 0, 1 for _ in range(2, n + 1): fib_0, fib_1 = fib_1, fib_0 + fib_1 return fib_1"},{"question":"# Coding Challenge: Longest Common Consecutive Substring Objective: Create a function that finds the longest common consecutive substring from two given strings. Function Signature: ```python def longest_common_consecutive_substring(str1: str, str2: str) -> str: pass ``` Input: * `str1`: A string of length `1 <= len(str1) <= 1000`. * `str2`: A string of length `1 <= len(str2) <= 1000`. Output: * A string representing the longest common consecutive substring between `str1` and `str2`. If there are multiple with the same length, return any one of them. Constraints: * The solution must operate efficiently for the given string lengths. Example: ```python assert longest_common_consecutive_substring(\\"abcdef\\", \\"zabcf\\") == \\"abc\\" assert longest_common_consecutive_substring(\\"12345\\", \\"23456\\") == \\"2345\\" assert longest_common_consecutive_substring(\\"abcdef\\", \\"ghijkl\\") == \\"\\" ``` # Task Description: 1. **Substring Identification:** Implement the function to check all substrings of `str1` and `str2` to find the longest common consecutive substring. 2. **Optimization:** Utilize dynamic programming or other efficient algorithms to ensure the solution can handle the upper boundaries of input sizes.","solution":"def longest_common_consecutive_substring(str1: str, str2: str) -> str: Finds the longest common consecutive substring from two given strings. :param str1: First input string :param str2: Second input string :return: The longest common consecutive substring m, n = len(str1), len(str2) max_length = 0 ending_index = 0 # Creating a 2D array to store lengths of longest common suffixes of substrings dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 if dp[i][j] > max_length: max_length = dp[i][j] ending_index = i # If no common substring is found, return an empty string if max_length == 0: return \\"\\" # The longest common substring return str1[ending_index - max_length: ending_index]"},{"question":"# Problem Description You are required to implement a function `generate_employee_report` that processes a list of employee records and generates a report based on department and average salary. Each employee record contains an ID, name, department, and salary. The function should compute the average salary per department and return a sorted list of department names based on the average salary in descending order. # Input * A list of dictionaries where each dictionary represents an employee record with the keys: \\"id\\" (string), \\"name\\" (string), \\"department\\" (string), and \\"salary\\" (float). # Output * A list of strings where each string is a department name, sorted by the average salary of employees within the department in descending order. # Constraints * Input list size will not exceed 10^4. * Each salary value is a positive float and will not exceed 10^6. * Employee departments will have unique names and will not exceed 100 different departments. # Requirements * You must use a dictionary to aggregate the salary data by department. * Compute the average salary for each department correctly. * Sort the departments by the computed average salary in descending order. # Function Signature ```python from typing import List, Dict def generate_employee_report(employees: List[Dict[str, object]]) -> List[str]: ``` # Example ```python employees = [ {\\"id\\": \\"E001\\", \\"name\\": \\"Alice\\", \\"department\\": \\"HR\\", \\"salary\\": 50000.0}, {\\"id\\": \\"E002\\", \\"name\\": \\"Bob\\", \\"department\\": \\"Engineering\\", \\"salary\\": 75000.0}, {\\"id\\": \\"E003\\", \\"name\\": \\"Charlie\\", \\"department\\": \\"HR\\", \\"salary\\": 55000.0}, {\\"id\\": \\"E004\\", \\"name\\": \\"David\\", \\"department\\": \\"Engineering\\", \\"salary\\": 70000.0}, {\\"id\\": \\"E005\\", \\"name\\": \\"Eve\\", \\"department\\": \\"Marketing\\", \\"salary\\": 60000.0} ] print(generate_employee_report(employees)) # Expected output: [\'Engineering\', \'Marketing\', \'HR\'] ``` # Note * Ensure your solution handles edge cases such as departments with a single employee or departments with identical average salaries. * Ensure the output list maintains a consistent and predictable order in case of identical average salaries.","solution":"from typing import List, Dict def generate_employee_report(employees: List[Dict[str, object]]) -> List[str]: department_salary = {} # Aggregate salary data by department for employee in employees: dept = employee[\\"department\\"] salary = employee[\\"salary\\"] if dept not in department_salary: department_salary[dept] = [] department_salary[dept].append(salary) # Calculate average salary per department dept_avg_salary = {dept: sum(salaries) / len(salaries) for dept, salaries in department_salary.items()} # Sort departments by average salary in descending order sorted_departments = sorted(dept_avg_salary.keys(), key=lambda dept: dept_avg_salary[dept], reverse=True) return sorted_departments"},{"question":"# Coding Assessment Question: A company uses an internal system to monitor the temperature of their data centers. Each data center has a set of temperature readings that are recorded every hour. As a developer, you are required to write a function to find the maximum temperature difference recorded in any of the data centers within a given period. **Function Details**: * Write a function `max_temp_difference(readings: List[int]) -> int` that calculates the maximum temperature difference within a data center. **Input**: * `readings` (List[int]): A list of integers representing the hourly temperature readings of a single data center. The list will have at least two readings. **Output**: * A single integer value representing the maximum temperature difference. **Constraints**: * The length of the `readings` list will be between 2 and 10^4 (both inclusive). * The temperature readings will be integers within the range -100 to 100. **Performance Requirements**: * The implementation must be efficient, with a time complexity of O(n), where n is the number of temperature readings. **Scenario**: Monitoring the temperature is crucial for maintaining optimal performance and avoiding system failures. Finding the maximum difference can help in detecting drastic temperature changes that might indicate problems like equipment malfunctions or environmental issues in the data center. **Example Use Cases**: * `max_temp_difference([30, 20, 25, 28, 18, 27])` should return `10`. * `max_temp_difference([-10, -20, 5, -5, 0, -15, 9])` should return `29`. **Edge Cases**: * Inputs like `max_temp_difference([40, 40])` should return `0`; minimal temperature change. * Inputs like `max_temp_difference([1, 100, -100, 50])` should return `200`; large temperature variation. Provide a solution that accurately computes the maximum temperature difference utilizing an optimized approach tailored for a large dataset input range.","solution":"from typing import List def max_temp_difference(readings: List[int]) -> int: if not readings or len(readings) < 2: return 0 min_temp = readings[0] max_temp = readings[0] for temp in readings: if temp < min_temp: min_temp = temp if temp > max_temp: max_temp = temp return max_temp - min_temp"},{"question":"# Problem Statement: You\'re given a rectangular grid with non-negative integer values representing the cost of entering each cell. You are required to find the path from the top-left corner to the bottom-right corner that minimizes the cost. You can only move to the right or down from any cell. Input: * A grid of size `m x n` where `grid[i][j]` is the cost to enter the cell `(i, j)`. Output: * The minimum cost to reach the bottom-right corner of the grid from the top-left corner. # Constraints: * (1 leq m, n leq 100) * (0 leq grid[i][j] leq 100) # Example: ```python grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] expected_output = 7 ``` (The path is 1 → 3 → 1 → 1 → 1, with a total cost of 7) Implement the function `min_path_cost(grid)` to return the above output for the given input grid. Function Signature: ```python def min_path_cost(grid: List[List[int]]) -> int: ... ``` This question tests the candidate\'s ability to implement dynamic programming techniques to solve grid-based pathfinding problems.","solution":"from typing import List def min_path_cost(grid: List[List[int]]) -> int: Returns the minimum cost to reach the bottom-right corner of the grid from the top-left corner. Only moves to the right or down are allowed. m, n = len(grid), len(grid[0]) # Initialize a dp array with the same dimensions as grid dp = [[0]*n for _ in range(m)] # Fill the dp array dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column (can only come from above) for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp array for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[m-1][n-1]"},{"question":"Implementing a to Uppercase Method You are tasked with developing a custom to_UpperCase method for a given class StringManipulator that processes a list of strings. The goal is to iterate through each string in the list, convert it to uppercase, and return the new list of uppercase strings. # Requirements: 1. **Class Definition**: Define a class `StringManipulator` with a method `to_UpperCase(self, str_list: list) -> list` that: - **Parameters**: - `str_list`: List of strings to be converted to uppercase. - **Returns**: - A new list where each string from `str_list` is converted to uppercase. 2. **Input**: - The input list will contain strings of lowercase alphabetic characters with a length of up to 1000 characters. 3. **Output**: - Return a new list with each string converted to uppercase. 4. **Constraints**: - Strings must only contain lowercase alphabetic characters from \'a\' to \'z\'. - Ensure performance efficiency in handling large lists containing thousands of strings. ```python # Define your class here class StringManipulator: def to_UpperCase(self, str_list: list) -> list: Convert each string in the list to uppercase. Parameters: - str_list <type: list>: list of strings to be converted to uppercase. Return: - <type: list>: list of strings converted to uppercase. pass # Implementation here ``` # Scenario: You are developing a string manipulation tool as part of a text processing library. A specific requirement is to transform an input list of lowercase strings to uppercase. This will aid in scenarios where uniform case format is essential (e.g., preparing data for case-insensitive comparisons or computations). Implement and integrate your method into a module expecting to deal with large datasets efficiently. Use the provided class template to create the solution. Your class and method will be used in parts of a larger system that processes substantial amounts of textual data in various applications.","solution":"class StringManipulator: def to_UpperCase(self, str_list: list) -> list: Convert each string in the list to uppercase. Parameters: - str_list <type: list>: list of strings to be converted to uppercase. Return: - <type: list>: list of strings converted to uppercase. return [s.upper() for s in str_list]"},{"question":"# Question: Implement an Algorithm to Optimize Pathfinding in a Grid with Variable Costs Context: You are given a grid represented as a 2D array where each cell contains a non-negative integer value representing the traversal cost to move through that cell. The challenge is to find the optimal path from the top-left corner of the grid to the bottom-right corner with the minimum total traversal cost. Different cells in the grid have different traversal costs, and you can only move right or down at each step. The goal is to implement an efficient algorithm to compute this minimum-cost path. Task: Develop a function `find_min_cost_path` in a grid with variable costs to determine the minimum path cost from the top-left corner to the bottom-right corner of the grid. 1. Identify the optimal way to traverse the grid from the top-left to bottom-right with the least cost. 2. Implement the function to compute this minimum traversal cost. Specifications: 1. **Input**: - `cost_grid`: A 2D list of non-negative integers representing the traversal costs. 2. **Output**: - `min_cost`: An integer representing the minimum cost to traverse from the top-left to the bottom-right corner of the grid. 3. **Constraints**: - The dimensions of `cost_grid` will be `m x n` where 1 ≤ m, n ≤ 100. - The cost values are non-negative integers (0 ≤ cost ≤ 100). Example Input: ```python cost_grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] ``` Example Output: ```python 7 ``` This output indicates the minimum cost to traverse from the top-left corner to the bottom-right corner is 7, following the path: 1 → 3 → 1 → 1 → 1. Instructions: 1. **Path Calculation**: Use dynamic programming or another efficient pathfinding algorithm to find the minimum cost path. 2. **Initialization and Recurrence**: Populate the dynamic programming table with correct initial values and define the recurrence relation to compute the minimum traversal cost. 3. **Testing**: Provide at least 3 test cases to verify your implementation.","solution":"def find_min_cost_path(cost_grid): Returns the minimum cost to traverse from the top-left corner to the bottom-right corner of the grid. :param cost_grid: List[List[int]] - A 2D list representing the traversal costs. :return: int - The minimum traversal cost. if not cost_grid: return 0 m, n = len(cost_grid), len(cost_grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = cost_grid[0][0] for i in range(1, m): dp[i][0] = dp[i-1][0] + cost_grid[i][0] for j in range(1, n): dp[0][j] = dp[0][j-1] + cost_grid[0][j] for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + cost_grid[i][j] return dp[-1][-1]"},{"question":"# Inventory Management System You are tasked with implementing a simplified inventory management system for a warehouse. The objective is to showcase your understanding of object-oriented programming concepts, data storage, and method interactions. # Functional Requirements: 1. **Product Class**: Implement a `Product` class that stores information such as `product_id`, `name`, `category`, `quantity`, and `price`. 2. **Inventory Class**: Implement an `Inventory` class to manage a collection of products with functionalities to add, remove, update, and list products. 3. **Search Functionality**: Implement a search function within the `Inventory` class allowing searches by `product_id` or `category`. # Input and Output Specifications: - **Input**: 1. Define the attributes for a `Product` instance: `product_id`, `name`, `category`, `quantity`, and `price`. 2. Methods in `Inventory` class to add, remove, update, and search products. - **Output**: 1. Methods returning the status of operations (e.g., product added, product not found). 2. When listing products, return a sorted list based on product names. # Constraints: 1. Ensure unique `product_id` for each product. 2. Maintain data integrity with correct types (e.g., `quantity` as int and `price` as float). 3. Provide meaningful error messages for invalid actions like updating a non-existent product or adding a product with an existing `product_id`. # Performance Requirements: 1. Efficient search and retrieval of product records. 2. Minimal overhead for data updates and inventory operations. # Implementation Scenario: You are required to implement the `Product` and `Inventory` classes as described. Example signatures are provided below: ```python class Product: def __init__(self, product_id: int, name: str, category: str, quantity: int, price: float): self.product_id = product_id self.name = name self.category = category self.quantity = quantity self.price = price class Inventory: def __init__(self): self.products = {} def add_product(self, product: Product): # Implement the method to add a product to the inventory pass def remove_product(self, product_id: int): # Implement the method to remove a product from the inventory by product_id pass def update_product(self, product_id: int, name: str = None, category: str = None, quantity: int = None, price: float = None): # Implement the method to update product details pass def list_products(self): # Implement the method to return a list of all products sorted by name pass def search_products(self, search_term: str, by: str = \'product_id\'): # Implement the search functionality by product_id or category pass ``` *Note*: The full structure should include appropriate error handling and data validation within each method.","solution":"class Product: def __init__(self, product_id: int, name: str, category: str, quantity: int, price: float): self.product_id = product_id self.name = name self.category = category self.quantity = quantity self.price = price class Inventory: def __init__(self): self.products = {} def add_product(self, product: Product): if product.product_id in self.products: return \\"Product id already exists.\\" self.products[product.product_id] = product return \\"Product added successfully.\\" def remove_product(self, product_id: int): if product_id not in self.products: return \\"Product id not found.\\" del self.products[product_id] return \\"Product removed successfully.\\" def update_product(self, product_id: int, name: str = None, category: str = None, quantity: int = None, price: float = None): if product_id not in self.products: return \\"Product id not found.\\" if name is not None: self.products[product_id].name = name if category is not None: self.products[product_id].category = category if quantity is not None: self.products[product_id].quantity = quantity if price is not None: self.products[product_id].price = price return \\"Product updated successfully.\\" def list_products(self): return sorted(self.products.values(), key=lambda x: x.name) def search_products(self, search_term: str, by: str = \'product_id\'): result = [] if by == \'product_id\': for product in self.products.values(): if str(product.product_id) == search_term: result.append(product) elif by == \'category\': for product in self.products.values(): if product.category == search_term: result.append(product) return result"},{"question":"# Problem Statement You are tasked with implementing a version of the `BinarySearchTree` class. This new version will include additional operations to manage and retrieve data, specifically: 1. Finding the height of the tree. 2. Performing a level-order traversal of the tree. 3. Checking whether the tree is balanced. # Requirements - Implement the `BinarySearchTree` class to include methods for inserting values and performing standard BST operations if not already provided. - Add three new methods to the class: * `height` to calculate the height of the tree. * `level_order_traversal` to output the level-order traversal of the tree. * `is_balanced` to check if the tree is balanced. # Function Implementation Method Header 1. **BinarySearchTree class and node initialization**: ```python class TreeNode: def __init__(self, value: int, left: TreeNode = None, right: TreeNode = None) -> None: self.value = value self.left = left self.right = right class BinarySearchTree: def __init__(self) -> None: self.root = None ``` 2. **Inserting a value into the tree**: ```python def insert(self, value: int) -> None: # Method to insert value into the BST ``` 3. **Calculating the height of the tree**: ```python def height(self) -> int: ``` - **returns**: An integer representing the height of the tree. 4. **Performing a level-order traversal**: ```python def level_order_traversal(self) -> List[int]: ``` - **returns**: A list of integers representing the level-order traversal of the tree. 5. **Checking if the tree is balanced**: ```python def is_balanced(self) -> bool: ``` - **returns**: A boolean value indicating whether the tree is balanced. # Input and Output Formats - Values in the BST will be integers. - `height` returns the height of the BST as an integer. - `level_order_traversal` returns a list of integers following level-order traversal. - `is_balanced` returns a boolean indicating whether the tree is balanced. # Constraints - The tree will contain at most 1000 nodes. - Node values will be integers within the range of -10^6 to 10^6. # Example ```python # Example usage of the BinarySearchTree class bst = BinarySearchTree() bst.insert(10) bst.insert(5) bst.insert(15) bst.insert(3) bst.insert(7) print(bst.height()) # Expected Output: 3 print(bst.level_order_traversal()) # Expected Output: [10, 5, 15, 3, 7] print(bst.is_balanced()) # Expected Output: True ``` # Notes - For a tree to be balanced, the height of the two subtrees of every node never differs by more than one. - Ensure robust handling of edge cases such as an empty tree, single node tree, etc.","solution":"class TreeNode: def __init__(self, value: int, left: \'TreeNode\' = None, right: \'TreeNode\' = None) -> None: self.value = value self.left = left self.right = right class BinarySearchTree: def __init__(self) -> None: self.root = None def insert(self, value: int) -> None: if self.root is None: self.root = TreeNode(value) else: self._insert_recursive(self.root, value) def _insert_recursive(self, node, value): if value < node.value: if node.left is None: node.left = TreeNode(value) else: self._insert_recursive(node.left, value) else: if node.right is None: node.right = TreeNode(value) else: self._insert_recursive(node.right, value) def height(self) -> int: def _height(node): if node is None: return 0 left_height = _height(node.left) right_height = _height(node.right) return max(left_height, right_height) + 1 return _height(self.root) def level_order_traversal(self) -> list: from collections import deque if not self.root: return [] queue = deque([self.root]) level_order = [] while queue: current = queue.popleft() level_order.append(current.value) if current.left: queue.append(current.left) if current.right: queue.append(current.right) return level_order def is_balanced(self) -> bool: def _check_balance(node): if node is None: return 0, True left_height, left_balanced = _check_balance(node.left) right_height, right_balanced = _check_balance(node.right) current_height = max(left_height, right_height) + 1 is_balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 return current_height, is_balanced _, result = _check_balance(self.root) return result"},{"question":"# File Processing and Data Aggregation You are asked to process multiple CSV files containing transaction records for an e-commerce platform and aggregate the data to generate summary statistics. Implement a function that reads the transactions from multiple CSV files, finds the total revenue and the average transaction amount, and returns these summary statistics. **Function Signature** ```python def aggregate_transactions(file_paths: List[str]) -> dict: ``` # Input 1. `file_paths` (List[str]): A list of file paths, each leading to a CSV file that contains transaction data. Each CSV file has the same structure with the following columns: - \\"transaction_id\\" (str): Unique identifier for each transaction. - \\"user_id\\" (str): Unique identifier for the user making the transaction. - \\"transaction_amount\\" (float): The amount of the transaction. - \\"transaction_date\\" (str): The date and time of the transaction in the format \\"YYYY-MM-DD HH:MM:SS\\". # Output A `dict` with the following keys: * `\\"total_revenue\\"` (float): The sum of all transaction amounts. * `\\"average_transaction_amount\\"` (float): The average amount of all transactions. # Constraints * The function should handle cases where some files may be missing or empty. * Ensure that the function can process a large number of transactions efficiently. * All amounts should be rounded to two decimal places. **Examples** ```python file_paths = [ \\"transactions_jan.csv\\", \\"transactions_feb.csv\\", \\"transactions_mar.csv\\" ] result = aggregate_transactions(file_paths) print(result) # Example Output: # {\'total_revenue\': 15000.50, \'average_transaction_amount\': 125.43} ``` # Hint You can use the `pandas` library for reading and processing the CSV files, but it is not mandatory.","solution":"import pandas as pd from typing import List def aggregate_transactions(file_paths: List[str]) -> dict: total_revenue = 0.0 total_transactions = 0 for file_path in file_paths: try: df = pd.read_csv(file_path) total_revenue += df[\'transaction_amount\'].sum() total_transactions += len(df) except (FileNotFoundError, pd.errors.EmptyDataError): continue average_transaction_amount = (total_revenue / total_transactions) if total_transactions > 0 else 0.0 return { \\"total_revenue\\": round(total_revenue, 2), \\"average_transaction_amount\\": round(average_transaction_amount, 2) }"},{"question":"# Bus Route Optimization Problem Description You are given a list of bus routes, where each route is represented by the list of bus stops that the bus visits in order, and a source stop and destination stop. Your task is to determine the minimum number of bus switches required to travel from the source stop to the destination stop. If it is not possible to reach the destination stop from the source stop using any combination of the given routes, return -1. Function Signature Write a Python function `min_bus_switches(routes: List[List[int]], source: int, destination: int) -> int` that takes three parameters: - `routes`: A list of lists where each inner list represents a bus route. - `source`: An integer representing the stop you are starting from. - `destination`: An integer representing the stop you want to reach. Return The function should return: - An integer representing the minimum number of bus switches required to reach the destination from the source. - `-1` if it is not possible to reach the destination from the source. Constraints - The number of bus stops `n` in any route will be between 1 and 1000. - The number of bus routes `k` will be between 1 and 1000. - The bus stops\' ID will be unique and can be any positive integer. Example ```python def min_bus_switches(routes: List[List[int]], source: int, destination: int) -> int: # Your code here # Example Test Cases routes1 = [ [1, 2, 7], [3, 6, 7] ] source1 = 1 destination1 = 6 print(min_bus_switches(routes1, source1, destination1)) # Output: 2 routes2 = [ [1, 2, 7, 8], [9, 6, 8] ] source2 = 1 destination2 = 6 print(min_bus_switches(routes2, source2, destination2)) # Output: 2 routes3 = [ [1, 2, 7, 9], [3, 6, 8] ] source3 = 1 destination3 = 6 print(min_bus_switches(routes3, source3, destination3)) # Output: -1 ``` In the first example, the best way to reach from stop 1 to stop 6 is to take the first bus to stop 7 and then switch to the second bus at stop 7 to reach stop 6, which requires 2 bus switches. In other examples, it demonstrates another valid path and a scenario where destination is unreachable. Requirements - Implement the `min_bus_switches` function to solve the problem using an appropriate pathfinding algorithm. - Ensure optimal performance within the given constraints.","solution":"from collections import deque, defaultdict from typing import List def min_bus_switches(routes: List[List[int]], source: int, destination: int) -> int: if source == destination: return 0 stop_to_routes = defaultdict(set) for route_index, route in enumerate(routes): for stop in route: stop_to_routes[stop].add(route_index) queue = deque([(source, 0)]) visited_stops = set([source]) visited_routes = set() while queue: current_stop, switches = queue.popleft() for route_index in stop_to_routes[current_stop]: if route_index in visited_routes: continue visited_routes.add(route_index) for stop in routes[route_index]: if stop == destination: return switches + 1 if stop not in visited_stops: visited_stops.add(stop) queue.append((stop, switches + 1)) return -1"},{"question":"# Fibonacci in Matrix Multiplication You are assigned the task of implementing an efficient algorithm to compute the nth Fibonacci number using matrix multiplication. This approach leverages the properties of matrix exponentiation for efficient computation. Function Definition: 1. **fibonacci_matrix(n: int) -> int** This function should compute the nth Fibonacci number. - **Input**: `n` (int) – The index of the Fibonacci number to compute. - **Output**: The nth Fibonacci number. Constraints: - `n` should be a non-negative integer (0 ≤ n ≤ 10^18). - Use matrix multiplication to achieve the desired result in logarithmic time complexity. Example Output: For `fibonacci_matrix(10)`, the output should be: ```python print(fibonacci_matrix(10)) # 55 ``` Hints and Context: - Use the matrix representation of Fibonacci numbers: ``` [F(n+1), F(n) ] = [1, 1]^n [F(n), F(n-1)] = [1, 0] ``` - Implement matrix multiplication and matrix exponentiation functions to support the computation. - This approach helps in understanding efficient algorithms for large-scale computations, crucial for performance-critical applications. This problem encourages the use of optimization techniques to handle large inputs, showcasing an understanding of advanced algorithms.","solution":"def fibonacci_matrix(n: int) -> int: Returns the nth Fibonacci number using matrix multiplication. def matrix_mult(A, B): return [ [A[0][0] * B[0][0] + A[0][1] * B[1][0], A[0][0] * B[0][1] + A[0][1] * B[1][1]], [A[1][0] * B[0][0] + A[1][1] * B[1][0], A[1][0] * B[0][1] + A[1][1] * B[1][1]] ] def matrix_power(matrix, power): result = [[1, 0], [0, 1]] # Identity matrix while power: if power % 2 != 0: result = matrix_mult(result, matrix) matrix = matrix_mult(matrix, matrix) power //= 2 return result if n == 0: return 0 if n == 1: return 1 F = [[1, 1], [1, 0]] # Initial matrix result = matrix_power(F, n - 1) # The nth Fibonacci number is in cell [0][0] return result[0][0] # Example usage: print(fibonacci_matrix(10)) # Should output 55"},{"question":"# Grid Traversal Problem Given a 2D grid of size `m x n`, write a function `unique_paths` to find the number of unique paths from the top-left corner to the bottom-right corner. You can only move either down or right at any point in time. Function Signature ```python def unique_paths(m: int, n: int) -> int: ``` # Input - `m`: An integer, 1 ≤ m ≤ 100 representing the number of rows in the grid. - `n`: An integer, 1 ≤ n ≤ 100 representing the number of columns in the grid. # Output - An integer representing the number of unique paths from the start to the destination. # Examples ```python assert unique_paths(3, 7) == 28 assert unique_paths(3, 2) == 3 assert unique_paths(1, 1) == 1 assert unique_paths(100, 1) == 1 assert unique_paths(1, 100) == 1 ``` # Explanation 1. The function `unique_paths(3, 7)` should return `28` because there are 28 possible routes from the top-left corner to the bottom-right corner in a 3x7 grid. 2. The function `unique_paths(3, 2)` should return `3` as there are three distinct ways to travel from the top-left to the bottom-right of a 3x2 grid: - Right, Right, Down, Down, Down - Right, Down, Right, Down, Down - Down, Right, Right, Down, Down 3. The function `unique_paths(1, 1)` should return `1` as there is only one cell and thus one way to traverse from the start to the destination. 4. The function `unique_paths(100, 1)` and `unique_paths(1, 100)` should return `1` as there is only one unique path when the grid has only one row or one column. Performance Requirements - Your solution should handle large grids efficiently (e.g., `m = 100` and `n = 100`). # Notes 1. Consider using dynamic programming for an efficient solution. 2. Take care of edge cases where either `m` or `n` is 1.","solution":"def unique_paths(m: int, n: int) -> int: Calculate the number of unique paths in an m x n grid from top-left to bottom-right. # Create a 2D list initialized with 1s dp = [[1] * n for _ in range(m)] # Iterate through the grid starting from cell (1, 1) for i in range(1, m): for j in range(1, n): # Number of ways to reach (i, j) is the sum of ways to reach (i-1, j) and (i, j-1) dp[i][j] = dp[i-1][j] + dp[i][j-1] # The bottom-right cell contains the result return dp[m-1][n-1]"},{"question":"# String Manipulation for Data Sanitization Context: You are tasked with creating a function that sanitizes a string according to a set of rules for cleaning up text data. The function should replace specific characters and remove extra whitespace, ensuring the text adheres to a clean format suitable for further processing or storage. Function Signature: ```python def sanitize_string(input_string: str, replacements: dict[str, str], remove_extra_whitespace: bool) -> str: pass ``` Input: - A string `input_string` representing the text to be sanitized. - A dictionary `replacements` where each key-value pair specifies a character to replace (key) and its replacement (value). - A boolean `remove_extra_whitespace` indicating whether to remove extra spaces (consecutive spaces) from the string. Output: - A sanitized string, after applying the replacements and whitespace removal if specified. Constraints: - The input string can contain any visible characters and whitespace. - The `replacements` dictionary can have any number of key-value pairs. - If `remove_extra_whitespace` is True, ensure that all consecutive whitespaces in the string are replaced with a single space. - Handle typical and edge cases, including but not limited to empty strings, strings without any replacements needed, and strings composed entirely of spaces. Example: ```python input_string = \\"Hello, World! This isn\'t some random text.\\" replacements = {\\"!\\": \\".\\", \\"\'\\": \\"\\"} remove_extra_whitespace = True print(sanitize_string(input_string, replacements, remove_extra_whitespace)) # Output: \\"Hello, World. This isnt some random text.\\" ``` # Description: In the above example: - The exclamation mark \'!\' is replaced by a period \'.\'. - The apostrophe \\"\'\\" is removed. - The extra whitespaces are condensed to single spaces. # Requirements: - Implement the function `sanitize_string` to handle character replacements and optional whitespace removal. - Ensure the function is efficient and performs proper validation. - Avoid using any external libraries for the string manipulation. # Note: - Do not include any print statements in your function. - Make sure your implementation is consistent with the input and output formats specified.","solution":"def sanitize_string(input_string: str, replacements: dict[str, str], remove_extra_whitespace: bool) -> str: # replace characters according to the replacement dictionary for key, value in replacements.items(): input_string = input_string.replace(key, value) # remove extra whitespaces if required if remove_extra_whitespace: input_string = \' \'.join(input_string.split()) return input_string"},{"question":"# Problem Statement: You are designing a program to help analyze patterns in a list of transactions. Each transaction contains an item ID and its purchased quantity. Your goal is to implement a function that identifies the top N most frequently purchased items. # Function Definition Implement a function `top_n_purchased_items(transactions: List[Tuple[int, int]], N: int) -> List[int]` that: - Takes a list of transactions where each transaction is a tuple `(item_id: int, quantity: int)`. - Takes an integer `N` representing the number of top items to return based on the frequency of purchases. - Returns a list of the top N item IDs sorted in descending order of purchase frequency. If two items have the same frequency, sort them by their item ID in ascending order. # Input - `transactions`: A list of tuples, where each tuple contains two integers: - The `item_id` of the item purchased. - The `quantity` representing the number of units purchased in that transaction. - `N`: An integer representing the number of top items to return. # Output - A list of integers representing the item IDs of the top N most frequently purchased items. # Constraints - The length of `transactions` will be between 1 and 10^5. - The value of `item_id` will be between 1 and 10^6. - The value of `quantity` will be between 1 and 1000. - 1 ≤ N ≤ number of unique items in `transactions`. # Examples ```python # Example 1: >>> transactions = [(1, 5), (2, 3), (1, 2), (3, 4), (3, 1), (2, 2)] >>> N = 2 >>> top_n_purchased_items(transactions, N) [1, 2] # Example 2: >>> transactions = [(10, 1), (11, 2), (11, 3), (12, 1), (10, 2)] >>> N = 1 >>> top_n_purchased_items(transactions, N) [11] # Example 3: >>> transactions = [(1, 1)] >>> N = 1 >>> top_n_purchased_items(transactions, N) [1] ``` # Notes - Consider edge cases such as when there are ties in the frequency of purchases. - Optimize for performance given the constraints on the input size. - Ensure your function handles typical error conditions gracefully. # Solution Template Here\'s a basic template to get you started. You can fill in the details as needed. ```python from typing import List, Tuple from collections import Counter def top_n_purchased_items(transactions: List[Tuple[int, int]], N: int) -> List[int]: # Create a Counter to tally the frequency of each item_id frequency_counter = Counter() # Populate the Counter with item_id frequencies for item_id, quantity in transactions: frequency_counter[item_id] += quantity # Get the top N item IDs with the highest frequencies top_items = frequency_counter.most_common(N) # Extract just the item IDs from the top_items and return them return [item_id for item_id, freq in top_items] # Examples if __name__ == \\"__main__\\": print(top_n_purchased_items([(1, 5), (2, 3), (1, 2), (3, 4), (3, 1), (2, 2)], 2)) # [1, 2] print(top_n_purchased_items([(10, 1), (11, 2), (11, 3), (12, 1), (10, 2)], 1)) # [11] print(top_n_purchased_items([(1, 1)], 1)) # [1] ```","solution":"from typing import List, Tuple from collections import Counter def top_n_purchased_items(transactions: List[Tuple[int, int]], N: int) -> List[int]: # Create a Counter to tally the frequency of each item_id frequency_counter = Counter() # Populate the Counter with item_id frequencies for item_id, quantity in transactions: frequency_counter[item_id] += quantity # Get the items sorted by frequency (desc), then by item_id (asc) sorted_items = sorted(frequency_counter.items(), key=lambda x: (-x[1], x[0])) # Extract the top N item IDs top_items = [item_id for item_id, frequency in sorted_items[:N]] return top_items"},{"question":"# Rotate Matrix by 90 degrees You are given an `n` x `n` matrix (a two-dimensional array) representing an image. Implement a function `rotate_matrix` that rotates the matrix by 90 degrees clockwise. # Task 1. **rotate_matrix(matrix: List[List[int]]) -> List[List[int]]** - Input: A two-dimensional list of integers where each sub-list represents a row in the matrix. - Output: A two-dimensional list of integers representing the matrix rotated by 90 degrees clockwise. - Constraints: - The input `matrix` is guaranteed to be non-empty and square (same number of rows and columns). # Example Usage ```python >>> rotate_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix([[1, 2], [3, 4]]) [[3, 1], [4, 2]] ``` # Edge Cases 1. **Minimum Size**: - Test with the smallest possible square matrix, i.e., 1x1 matrix. 2. **Handle Even and Odd dimensions**: - Ensure functionality for both even (e.g., 2x2, 4x4) and odd (e.g., 3x3, 5x5) dimension matrices. # Additional Requirements 1. **In-place Modification**: - If possible, implement the rotation in place to achieve better space complexity. However, returning a new matrix is acceptable if in-place modification becomes complex. Implement the `rotate_matrix` function with the described requirements and handle edge cases.","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotates the n x n matrix by 90 degrees clockwise. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row to get the final rotated matrix for row in matrix: row.reverse() return matrix"},{"question":"# Matrix Rotation by 90 Degrees Challenge You have been provided with a NxN matrix and your task is to rotate the matrix counterclockwise by 90 degrees. This challenge tests your understanding of matrix manipulation and in-place algorithm optimization. Task 1. Implement the function: - `rotate_matrix_90(matrix: List[List[int]]) -> List[List[int]]`: This function takes a 2D list (NxN matrix) as input and returns a new matrix that represents the original matrix rotated counterclockwise by 90 degrees. Input and Output Formats: **Input**: - A 2D list `matrix` of size NxN where N is the number of rows and columns. The matrix will contain integers. **Output**: - A 2D list representing the original matrix rotated counterclockwise by 90 degrees. Constraints: - The input is guaranteed to be a non-empty square matrix. - (1 leq N leq 1000) - The matrix elements can be any integer within the range of standard integer limits. Examples: ```python rotate_matrix_90([ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ]) # Output: # [ # [ 3, 6, 9 ], # [ 2, 5, 8 ], # [ 1, 4, 7 ] # ] ``` ```python rotate_matrix_90([ [1] ]) # Output: # [ # [1] # ] ``` ```python rotate_matrix_90([ [1, 2], [3, 4] ]) # Output: # [ # [2, 4], # [1, 3] # ] ``` Implement the `rotate_matrix_90` function ensuring your solution is efficient and handles the maximum possible matrix size within reasonable time. Consider edge cases such as the smallest (1x1) matrix and even-sized matrices.","solution":"def rotate_matrix_90(matrix): Rotates the given NxN matrix counterclockwise by 90 degrees. N = len(matrix) # Create a new matrix to store the result of rotation rotated_matrix = [[0] * N for _ in range(N)] for i in range(N): for j in range(N): rotated_matrix[N - j - 1][i] = matrix[i][j] return rotated_matrix"},{"question":"**Context**: You are developing a system that processes customer reviews for various products. Each product can have multiple reviews, and your goal is to aggregate these reviews to provide an average rating for each product. You need to create a function that calculates the average rating based on the provided reviews. **Objective**: Implement a function `calculate_average_rating` that computes the average rating for a given product from a list of review scores. **Requirements**: 1. **Function Signature**: ```python def calculate_average_rating(reviews: List[int]) -> float: ... ``` 2. **Functionality**: * Accept a list of integer review scores. * Calculate the average of the review scores. * Return the average rating as a float. 3. **Implementation Details**: * Only consider valid review scores ranging from 1 to 5 inclusive. * Handle the case where the review list is empty by returning a rating of 0.0. # Input and Output Formats * **Input**: * `reviews` (List[int]): A list of integer review scores. * **Output**: * A float representing the average rating of the reviews. # Constraints 1. Each review score will be an integer. 2. Review scores are between 1 and 5 inclusive. 3. The list can be empty. **You should focus on:** * Correct computation of the average rating. * Handling edge cases like an empty list. * Ensuring that the function returns a float. # Example 1. Calculate the average rating from a list of reviews: ```python reviews = [4, 5, 3, 4, 5] print(calculate_average_rating(reviews)) # Expected: 4.2 ``` 2. Handle an empty list of reviews: ```python reviews = [] print(calculate_average_rating(reviews)) # Expected: 0.0 ```","solution":"from typing import List def calculate_average_rating(reviews: List[int]) -> float: if not reviews: return 0.0 valid_reviews = [score for score in reviews if 1 <= score <= 5] if not valid_reviews: return 0.0 average_rating = sum(valid_reviews) / len(valid_reviews) return round(average_rating, 1)"},{"question":"**Context:** You are provided with a stack data structure that supports basic operations such as push, pop, and peek. However, there\'s no feature to sort the stack in ascending order efficiently. **Objective:** Implement the `sort_stack` method in the given `Stack` class that sorts the entire stack in ascending order. This method must handle all standard cases effectively, including when the stack has no elements or just one element, and must do so with a linear auxiliary space complexity using another stack. **Function Signature:** ```python def sort_stack(self) -> None: Sort the stack in ascending order in-place using an auxiliary stack. Returns: None Examples: >>> stack = Stack() >>> stack.push(34) >>> stack.push(3) >>> stack.push(31) >>> stack.push(98) >>> stack.push(92) >>> stack.push(23) >>> list(stack) [23, 92, 98, 31, 3, 34] >>> stack.sort_stack() >>> list(stack) [3, 23, 31, 34, 92, 98] ``` **Constraints:** - The method should use an auxiliary stack as the only extra data structure (i.e., O(n) auxiliary space complexity where n is the number of elements in the stack). - The stack should be sorted within O(n^2) time complexity. **Examples:** 1. Sorting a stack with multiple elements: ```python stack = Stack() stack.push(34) stack.push(3) stack.push(31) stack.push(98) stack.push(92) stack.push(23) assert list(stack) == [23, 92, 98, 31, 3, 34] stack.sort_stack() assert list(stack) == [3, 23, 31, 34, 92, 98] ``` 2. Sorting an empty stack: ```python stack = Stack() assert list(stack) == [] stack.sort_stack() assert list(stack) == [] ``` 3. Sorting a stack with a single element: ```python stack = Stack() stack.push(1) assert list(stack) == [1] stack.sort_stack() assert list(stack) == [1] ```","solution":"class Stack: def __init__(self): self.items = [] def push(self, item): self.items.append(item) def pop(self): if not self.is_empty(): return self.items.pop() def peek(self): if not self.is_empty(): return self.items[-1] def is_empty(self): return len(self.items) == 0 def __iter__(self): # To allow comparison using list() for testing return iter(self.items[::-1]) def sort_stack(self): Sort the stack in ascending order using an auxiliary stack. auxiliary_stack = Stack() while not self.is_empty(): # Take the top element from the original stack current = self.pop() # Transfer elements from auxiliary stack back to original stack # until correct position for current is found while not auxiliary_stack.is_empty() and auxiliary_stack.peek() > current: self.push(auxiliary_stack.pop()) # Place current in its sorted position auxiliary_stack.push(current) # Transfer sorted elements back to the original stack while not auxiliary_stack.is_empty(): self.push(auxiliary_stack.pop())"},{"question":"# Kth Smallest Element in a Matrix You are given an `n x n` matrix where each row and column is sorted in ascending order. Your task is to find the `k-th` smallest element in the matrix. # Function Signature: ```python def kth_smallest(matrix: List[List[int]], k: int) -> int: ``` # Input: - A `n x n` matrix `matrix`, where `matrix[i][j]` represents the element at the `i-th` row and `j-th` column. - Each row and column of `matrix` is sorted in ascending order. - An integer `k`, representing the position of the element you need to find when the matrix is flattened into a sorted list. # Output: - An integer representing the `k-th` smallest element in the matrix. # Example: Input: ```python matrix = [ [1, 5, 9], [10, 11, 13], [12, 13, 15] ] k = 8 ``` Output: ```python 13 ``` # Constraints: - 1 <= n <= 300 (For simplicity) - The time complexity should be at most O(n^2 * log n) due to the constraints. - 1 <= matrix[i][j] <= 10^9 - All elements in the matrix are distinct. **Note**: - You can use algorithms such as binary search on the value range or a min-heap to solve this problem efficiently. - Handle edge cases appropriately, such as when `k` equals 1 or `n * n`.","solution":"from typing import List import heapq def kth_smallest(matrix: List[List[int]], k: int) -> int: Finds the k-th smallest element in an n x n sorted matrix. Each row and column is sorted in ascending order. :param matrix: List of lists of integers representing the sorted matrix :param k: The k-th position to find the smallest element :return: The k-th smallest element in the matrix n = len(matrix) # Min-heap to store the elements in order for processing min_heap = [] # Initialize the heap with the first element of each row for r in range(min(n, k)): heapq.heappush(min_heap, (matrix[r][0], r, 0)) # Extract the smallest element k times for _ in range(k - 1): element, r, c = heapq.heappop(min_heap) # If there are more elements in the current row, add the next column element if c + 1 < n: heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1)) # The top element of the heap is now the k-th smallest element return heapq.heappop(min_heap)[0]"},{"question":"# Coding Assessment Question Context You are working with a class that implements a stack data structure using two queues. The goal is to enhance the stack functionality by implementing the `pop` method efficiently using the two queues. This will test your understanding of queue operations and stack concepts. Task Implement a method `pop` within the `StackUsingQueues` class that removes and returns the top element from the stack. Function Specification ```python def pop(self) -> int: Removes and returns the top element of the stack. Examples: >>> stack = StackUsingQueues() >>> stack.push(1) >>> stack.push(2) >>> stack.push(3) >>> stack.pop() 3 >>> stack.pop() 2 >>> stack.pop() 1 When the stack is empty: >>> stack = StackUsingQueues() >>> stack.pop() Traceback (most recent call last): ... IndexError: pop from an empty stack Returns: int: The value of the top element. pass ``` Constraints * The `pop` method should operate using O(n) time complexity, where n is the number of elements in the stack. * You may use two internal queues to manage the stack\'s state. * Aim to optimize the space complexity while ensuring correctness. Input Format A method `pop` is added to the `StackUsingQueues` class with no input parameters. Handle an empty stack scenario by raising an `IndexError` with the message \\"pop from an empty stack\\". Output Format The method should return the value of the top element of the stack, and the stack should be updated internally. Examples * Input: `StackUsingQueues` with elements pushed in order [1, 2, 3]; after calling `pop()` * Expected Output: 3 * Stack state after `pop`: [1, 2] * Input: `StackUsingQueues()` with no elements; after calling `pop()` * Expected Output: Raises `IndexError` with message \\"pop from an empty stack\\"","solution":"from collections import deque class StackUsingQueues: def __init__(self): self.queue1 = deque() self.queue2 = deque() def push(self, x: int): self.queue1.append(x) def pop(self) -> int: if not self.queue1: raise IndexError(\\"pop from an empty stack\\") # Move all elements except the last to the second queue while len(self.queue1) > 1: self.queue2.append(self.queue1.popleft()) # The last element in queue1 is the \\"top\\" of the stack top_element = self.queue1.popleft() # Swap the names of the queues self.queue1, self.queue2 = self.queue2, self.queue1 return top_element"},{"question":"# Question: Longest Consecutive Subsequence in an Array Context: You are working as a software developer and your current task is to analyze a large dataset of user activity logs. To efficiently process and extract meaningful insights, you need to determine the longest sequence of continuous user activity based on timestamped log entries. Task: Implement a function `longest_consecutive_subsequence(nums)` that finds the length of the longest consecutive elements sequence in an unsorted array of integers. The sequence must consist of consecutive integers regardless of their order in the array. Function Signature: ```python def longest_consecutive_subsequence(nums: List[int]) -> int: pass ``` Input: - `nums`: A list of integers representing timestamped activity logs. Output: - An integer representing the length of the longest consecutive elements sequence. Constraints: - The length of the list `nums` satisfies `0 <= len(nums) <= 10^5`. - The integers in `nums` are within the range `-10^9` to `10^9`. Example: ```python nums = [100, 4, 200, 1, 3, 2] assert longest_consecutive_subsequence(nums) == 4 # The longest consecutive sequence is [1, 2, 3, 4] nums = [1, 9, 3, 10, 4, 20, 2] assert longest_consecutive_subsequence(nums) == 4 # The longest consecutive sequence is [1, 2, 3, 4] nums = [] assert longest_consecutive_subsequence(nums) == 0 # No sequence in an empty list ``` Notes: - Optimize for both time and space complexity where possible. - Handle edge cases such as empty list and list with a single element correctly. - Consider using appropriate data structures that facilitate efficient lookups and insertions.","solution":"def longest_consecutive_subsequence(nums): Given an unsorted array of integers, find the length of the longest consecutive elements sequence. if not nums: return 0 num_set = set(nums) longest_sequence = 0 for num in num_set: # Check if it\'s the start of a sequence if num - 1 not in num_set: current_num = num current_sequence = 1 while current_num + 1 in num_set: current_num += 1 current_sequence += 1 longest_sequence = max(longest_sequence, current_sequence) return longest_sequence"},{"question":"# Data Processing and Plotting with Matplotlib Scenario: You need to write a Python function that takes a CSV file containing daily temperature data and produces a line plot of the temperature trends over time. This is particularly useful in visualizing weather patterns or any kind of time-series data. Task: Write a function `plot_temperature_trends(file_path: str) -> None` that: 1. Reads the specified CSV file, which contains two columns: \'Date\' and \'Temperature\', with \'Date\' in the format \'YYYY-MM-DD\'. 2. Parses the date column into Python datetime objects. 3. Creates a line plot of the temperature data with Date on the x-axis and Temperature on the y-axis. 4. Saves the plot as an image file named \'temperature_trends.png\'. Requirements: * Use `pandas` for CSV file reading and data manipulation, `matplotlib` for plotting, and `datetime` for parsing the dates. * Include error handling for file reading issues and parsing errors. * Ensure the function gracefully handles cases where the CSV file is empty or improperly formatted. Input: * `file_path` (str): A string containing the path to the CSV file. Output: * The function does not return any value but saves the line plot as \'temperature_trends.png\' in the current directory. Constraints: * Assume the CSV file has at least one row of valid data. * Ensure the function handles exceptions related to file I/O and data parsing gracefully. Example: Given a CSV file \'temperature_data.csv\' with the following content: ``` Date,Temperature 2023-01-01,5 2023-01-02,6 2023-01-03,4 2023-01-04,7 2023-01-05,6 ``` ```python plot_temperature_trends(\\"temperature_data.csv\\") ``` This will create a plot visualizing the temperature trends from January 1, 2023, to January 5, 2023, and save it as \'temperature_trends.png\'.","solution":"import pandas as pd import matplotlib.pyplot as plt from datetime import datetime import os def plot_temperature_trends(file_path: str) -> None: try: # Read the CSV file data = pd.read_csv(file_path) # Check for required columns if \'Date\' not in data.columns or \'Temperature\' not in data.columns: raise ValueError(\\"CSV file must contain \'Date\' and \'Temperature\' columns.\\") # Parse the \'Date\' column to datetime data[\'Date\'] = pd.to_datetime(data[\'Date\'], format=\'%Y-%m-%d\') # Set the \'Date\' column as the index data.set_index(\'Date\', inplace=True) # Create a line plot plt.figure(figsize=(10,5)) plt.plot(data.index, data[\'Temperature\'], marker=\'o\') plt.title(\'Temperature Trends Over Time\') plt.xlabel(\'Date\') plt.ylabel(\'Temperature\') plt.grid(True) plt.savefig(\'temperature_trends.png\') plt.close() except FileNotFoundError: print(f\\"Error: The file \'{file_path}\' was not found.\\") except pd.errors.EmptyDataError: print(\\"Error: The file is empty.\\") except pd.errors.ParserError: print(\\"Error: Failed to parse the file.\\") except Exception as e: print(f\\"An error occurred: {e}\\")"},{"question":"# Programming Assessment Question **Context**: You are developing an application that processes sequences of numbers. Part of your task is to identify the contiguous subarray within a one-dimensional list of numbers which has the largest sum. **Task**: Implement a function `max_subarray_sum()` that finds the maximum sum of any contiguous subarray within the given list of integers. Function Signature: ```python def max_subarray_sum(nums: list[int]) -> int: pass ``` Input: * `nums`: List of integers. Output: * Integer, representing the maximum sum of any contiguous subarray. Constraints: * The input list `nums` will contain at most 1,000,000 integers. * Each integer in the list will be between `-10^7` and `10^7`. Requirements: * Use an efficient algorithm to determine the maximum sum of the subarray. * Ensure the solution runs in linear time, O(n). Example: ```python max_subarray_sum([-2,1,-3,4,-1,2,1,-5,4]) # Output: 6 (subarray with the maximum sum is [4,-1,2,1]). max_subarray_sum([1]) # Output: 1 (only one element in the array). max_subarray_sum([-1, -2, -3, -4]) # Output: -1 (subarray with the maximum sum is just [-1]). max_subarray_sum([]) # Output: 0 (empty array has sum of 0). ``` Additional Notes: * Consider edge cases such as lists with only negative numbers or an empty list. * Ensure the function handles the constraints correctly and efficiently. * The optimal solution should have a linear time complexity, ideally using Kadane\'s algorithm. This new question follows the same style, complexity, and scope as the provided question. It requires a fundamental understanding of algorithms, efficient data structures, and edge case handling within specified constraints.","solution":"def max_subarray_sum(nums: list[int]) -> int: Finds the maximum sum of any contiguous subarray within the given list of integers. Parameters: nums (list[int]): List of integers. Returns: int: The maximum sum of any contiguous subarray. if not nums: return 0 current_sum = max_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"Implementing a Binary Search Tree (BST) You are tasked with implementing a Binary Search Tree (BST) that supports the following operations: 1. Insertion of a new node. 2. Searching for a node. 3. Deletion of a node. 4. Traversal methods: in-order, pre-order, post-order, and level-order. 5. Finding the minimum and maximum values in the tree. # Function Requirements 1. `insert(self, data)`: Insert a single element into the BST. 2. `search(self, data)`: Perform a search for an element; return `True` if found, otherwise return `False`. 3. `delete(self, data)`: Remove an element from the BST. 4. `traverse(self, order)`: Return a list of elements in the specified traversal order (`inorder`, `preorder`, `postorder`, `levelorder`). 5. `find_min(self)`: Return the minimum value in the BST. 6. `find_max(self)`: Return the maximum value in the BST. # Input and Output - `insert(self, data)` - **Input**: An integer `data`. - **Output**: None. - `search(self, data)` - **Input**: An integer `data`. - **Output**: `True` if the element is found; `False` if not found. - `delete(self, data)` - **Input**: An integer `data`. - **Output**: None. - `traverse(self, order)` - **Input**: A string `order` indicating the traversal type. - **Output**: A list of integers representing the elements in the specified traversal order. - `find_min(self)` - **Input**: None. - **Output**: The minimum value in the BST. - `find_max(self)` - **Input**: None. - **Output**: The maximum value in the BST. # Constraints - Only integer keys are supported. - The BST should handle cases where the node to be deleted has zero, one, or two children. - The traversal functionalities should handle empty trees gracefully. # Example ```python bst = BST() # Insert elements bst.insert(15) bst.insert(10) bst.insert(20) print(bst.traverse(\'inorder\')) # => [10, 15, 20] # Search elements print(bst.search(15)) # => True print(bst.search(5)) # => False # Delete an element bst.delete(10) print(bst.traverse(\'inorder\')) # => [15, 20] # Traverse elements print(bst.traverse(\'preorder\')) # => [15, 20] print(bst.traverse(\'postorder\')) # => [20, 15] print(bst.traverse(\'levelorder\')) # => [15, 20] # Find minimum and maximum values print(bst.find_min()) # => 15 print(bst.find_max()) # => 20 ``` # Implementation Implement the necessary methods to complete the `BST` class, focusing on the characteristics and principles of a binary search tree.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, root, key): if key < root.val: if root.left is None: root.left = Node(key) else: self._insert(root.left, key) else: if root.right is None: root.right = Node(key) else: self._insert(root.right, key) def search(self, key): return self._search(self.root, key) def _search(self, root, key): if root is None or root.val == key: return root is not None if key < root.val: return self._search(root.left, key) return self._search(root.right, key) def delete(self, key): self.root = self._delete(self.root, key) def _delete(self, root, key): if root is None: return root if key < root.val: root.left = self._delete(root.left, key) elif key > root.val: root.right = self._delete(root.right, key) else: if root.left is None: return root.right elif root.right is None: return root.left root.val = self._min_value_node(root.right).val root.right = self._delete(root.right, root.val) return root def _min_value_node(self, node): current = node while current.left is not None: current = current.left return current def traverse(self, order): if order == \\"inorder\\": return self._inorder(self.root, []) elif order == \\"preorder\\": return self._preorder(self.root, []) elif order == \\"postorder\\": return self._postorder(self.root, []) elif order == \\"levelorder\\": return self._levelorder(self.root) else: raise ValueError(f\\"Unknown order type: {order}\\") def _inorder(self, root, result): if root: self._inorder(root.left, result) result.append(root.val) self._inorder(root.right, result) return result def _preorder(self, root, result): if root: result.append(root.val) self._preorder(root.left, result) self._preorder(root.right, result) return result def _postorder(self, root, result): if root: self._postorder(root.left, result) self._postorder(root.right, result) result.append(root.val) return result def _levelorder(self, root): result, queue = [], [] if root is not None: queue.append(root) while queue: node = queue.pop(0) result.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return result def find_min(self): min_node = self._min_value_node(self.root) return min_node.val if min_node else None def find_max(self): max_node = self.root if max_node: while max_node.right: max_node = max_node.right return max_node.val if max_node else None"},{"question":"# Question You are provided with a list of courses with their prerequisites. Each course is identified by a name, and its prerequisites are represented as a list of course names that must be completed before taking the course. Your task is to implement a function `course_schedule` that determines if it is possible to complete all courses offered. # Function Signature ```python def course_schedule(courses: Dict[str, List[str]]) -> bool: ... ``` # Input Format - `courses`: A dictionary where keys are course names (strings), and values are lists of strings representing prerequisites. # Output Format - Return `True` if it is possible to complete all courses, otherwise return `False`. # Constraints 1. The number of courses, n, will be between 1 and 100. 2. No course will have itself as a prerequisite. 3. If prerequisites form a cycle, it\'s impossible to complete all courses. # Examples Example 1: ```python courses = { \\"Math\\": [\\"Physics\\"], \\"Physics\\": [\\"Chemistry\\"], \\"Chemistry\\": [] } assert course_schedule(courses) == True ``` Example 2: ```python courses = { \\"Math\\": [\\"Physics\\"], \\"Physics\\": [\\"Math\\"] } assert course_schedule(courses) == False ``` # Explanation In Example 1, you can complete \\"Chemistry\\" first, then \\"Physics\\", and finally \\"Math\\". Thus, it\'s possible to finish all courses. In Example 2, \\"Math\\" depends on \\"Physics\\" and vice versa, creating a cycle. Therefore, it\'s not possible to complete these courses. # Additional Requirements 1. Raise a `ValueError` if any course has itself as a prerequisite.","solution":"def course_schedule(courses): Determines if it is possible to complete all courses offered. Args: courses (Dict[str, List[str]]): A dictionary where keys are course names and values are lists of prerequisites. Returns: bool: True if it is possible to complete all courses, False otherwise. # Helper function for Depth First Search to detect cycles def dfs(course): if course in visiting: # a cycle is detected return False if course in visited: # this course has been checked before and is cycle-free return True visiting.add(course) for prereq in courses[course]: if not dfs(prereq): return False visiting.remove(course) visited.add(course) return True visiting = set() # to track the visiting nodes visited = set() # to track the visited nodes for course in courses: for prereq in courses[course]: if course == prereq: raise ValueError(\\"A course cannot have itself as a prerequisite\\") for course in courses: if not dfs(course): return False return True"},{"question":"# Problem Statement You are tasked with writing a program to determine if a series of pings sent to a host are successful or not. You need to simulate a ping operation and keep track of the sequence of successful and failed pings. # Requirements 1. Implement a class named `PingMonitor` which provides the following methods: - `ping(self) -> str`: Simulates sending a ping to the host and returns `\'Success\'` or `\'Fail\'` with a 70% success rate. - `record_ping(self, result: str) -> None`: Takes the result of a ping (`\'Success\'` or `\'Fail\'`) and records it internally. - `success_rate(self) -> float`: Calculates and returns the percentage of successful pings. 2. Your implementation should: - Properly simulate the ping operation with the specified success rate. - Maintain a list or similar structure to record the results of pings. - Calculate the success rate as the ratio of successful pings to total pings sent. # Input Format The methods inside the `PingMonitor` class do not take specific user input directly but will be called and tested within a script. # Output Format - The `ping` method returns either `\'Success\'` or `\'Fail\'`. - The `record_ping` method does not return anything (it updates internal state). - The `success_rate` method returns the success rate as a float. # Example ```python import random class PingMonitor: def __init__(self): self.results = [] def ping(self) -> str: return \'Success\' if random.random() < 0.7 else \'Fail\' def record_ping(self, result: str) -> None: self.results.append(result) def success_rate(self) -> float: if not self.results: return 0.0 return self.results.count(\'Success\') / len(self.results) * 100 # Example Usage monitor = PingMonitor() for _ in range(100): result = monitor.ping() monitor.record_ping(result) print(f\\"Success rate: {monitor.success_rate():.2f}%\\") ``` *Expected Output*: The success rate will vary, but it should be close to 70%. # Notes - Utilize the `random` module to simulate the 70% success rate. - Ensure to handle edge cases where no pings have been recorded yet.","solution":"import random class PingMonitor: def __init__(self): self.results = [] def ping(self) -> str: Simulates sending a ping to the host. Returns \'Success\' with a 70% probability and \'Fail\' with a 30% probability. return \'Success\' if random.random() < 0.7 else \'Fail\' def record_ping(self, result: str) -> None: Records the result of a ping (\'Success\' or \'Fail\'). self.results.append(result) def success_rate(self) -> float: Calculates and returns the success rate of pings as a percentage. if not self.results: return 0.0 success_count = self.results.count(\'Success\') return (success_count / len(self.results)) * 100"},{"question":"# Pathfinding in a Grid using A* Algorithm Overview You have been tasked with developing a part of a navigation system that uses the A* algorithm to find the shortest path in a grid. The grid is represented as a 2D list where each element indicates whether it\'s a walkable cell (0) or an obstacle (1). The system should be able to identify the shortest possible path from a start cell to a target cell, considering obstacles in the grid. Problem Statement Write a function `find_shortest_path(grid: list[list[int]], start: tuple[int, int], target: tuple[int, int]) -> list[tuple[int, int]]` that takes a 2D list `grid`, a tuple `start` indicating the starting cell, and a tuple `target` indicating the target cell. The function should return a list of tuples representing the coordinates of the cells in the shortest path from `start` to `target`, inclusive of both. If no path exists, return an empty list. Input - `grid`: A 2D list where each element is either 0 (walkable) or 1 (obstacle). - `start`: A tuple of two integers representing the starting cell\'s coordinates (row, column). - `target`: A tuple of two integers representing the target cell\'s coordinates (row, column). Output - A list of tuples where each tuple represents the coordinates of a cell in the path from `start` to `target`, inclusive of both. If no such path exists, return an empty list. Constraints - The grid will have at least one row and one column and not more than 100 rows and 100 columns. - The \'start\' and \'target\' cells will always contain 0 (walkable). - Both `start` and `target` cells will be valid and within grid bounds. - No diagonal movement is allowed; you can only move up, down, left, or right. Performance You should ensure that your implementation handles the constraint limits efficiently, especially for larger grids. Example ```python from typing import List, Tuple, Union import heapq def heuristic(a: Tuple[int, int], b: Tuple[int, int]) -> int: return abs(a[0] - b[0]) + abs(a[1] - b[1]) def find_shortest_path(grid: List[List[int]], start: Tuple[int, int], target: Tuple[int, int]) -> List[Tuple[int, int]]: rows, cols = len(grid), len(grid[0]) open_set = [] heapq.heappush(open_set, (0, start)) came_from = {} g_score = {start: 0} f_score = {start: heuristic(start, target)} directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] while open_set: _, current = heapq.heappop(open_set) if current == target: path = [] while current in came_from: path.append(current) current = came_from[current] path.append(start) return path[::-1] for d in directions: neighbor = (current[0] + d[0], current[1] + d[1]) if 0 <= neighbor[0] < rows and 0 <= neighbor[1] < cols and grid[neighbor[0]][neighbor[1]] == 0: tentative_g_score = g_score[current] + 1 if neighbor not in g_score or tentative_g_score < g_score[neighbor]: came_from[neighbor] = current g_score[neighbor] = tentative_g_score f_score[neighbor] = tentative_g_score + heuristic(neighbor, target) heapq.heappush(open_set, (f_score[neighbor], neighbor)) return [] # Example Test Case grid = [ [0, 0, 0, 0], [1, 1, 0, 1], [0, 0, 0, 0], [0, 1, 1, 0] ] start = (0, 0) target = (3, 3) assert find_shortest_path(grid, start, target) == [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2), (2, 3), (3, 3)] ``` Implement the A* algorithm in the function to ensure the given test case passes and your code correctly identifies the shortest path in the grid.","solution":"from typing import List, Tuple, Union import heapq def heuristic(a: Tuple[int, int], b: Tuple[int, int]) -> int: Calculate the Manhattan distance between points a and b. return abs(a[0] - b[0]) + abs(a[1] - b[1]) def find_shortest_path(grid: List[List[int]], start: Tuple[int, int], target: Tuple[int, int]) -> List[Tuple[int, int]]: Finds the shortest path from start to target in a grid using the A* algorithm. rows, cols = len(grid), len(grid[0]) open_set = [] heapq.heappush(open_set, (0, start)) came_from = {} g_score = {start: 0} f_score = {start: heuristic(start, target)} directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] while open_set: _, current = heapq.heappop(open_set) if current == target: path = [] while current in came_from: path.append(current) current = came_from[current] path.append(start) return path[::-1] for d in directions: neighbor = (current[0] + d[0], current[1] + d[1]) if 0 <= neighbor[0] < rows and 0 <= neighbor[1] < cols and grid[neighbor[0]][neighbor[1]] == 0: tentative_g_score = g_score[current] + 1 if neighbor not in g_score or tentative_g_score < g_score[neighbor]: came_from[neighbor] = current g_score[neighbor] = tentative_g_score f_score[neighbor] = tentative_g_score + heuristic(neighbor, target) heapq.heappush(open_set, (f_score[neighbor], neighbor)) return []"},{"question":"# Coding Assessment Question Problem Statement You are given a linked list where nodes are defined as shown below. Your task is to write a function that detects whether there is a cycle in the linked list using Floyd\'s Cycle Detection Algorithm (Tortoise and Hare Algorithm). Node Definition ```python class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next ``` Function Definition You need to implement the following function: ```python def has_cycle(head: ListNode) -> bool: Detects whether there is a cycle in the linked list using Floyd\'s Cycle Detection Algorithm. :param head: The head node of the linked list. :return: True if there is a cycle in the linked list, False otherwise. pass ``` Input - A `ListNode` object representing the head of the linked list. Output - A boolean value indicating whether a cycle exists in the linked list. Example ```python # Example 1 # Linked list: A -> B -> C -> D -> B (cycle) head = ListNode(\\"A\\") nodeB = ListNode(\\"B\\") nodeC = ListNode(\\"C\\") nodeD = ListNode(\\"D\\") head.next = nodeB nodeB.next = nodeC nodeC.next = nodeD nodeD.next = nodeB print(has_cycle(head)) # Output: True # Example 2 # Linked list: 1 -> 2 -> 3 -> 4 -> 5 -> NULL (no cycle) head = ListNode(1) node2 = ListNode(2) node3 = ListNode(3) node4 = ListNode(4) node5 = ListNode(5) head.next = node2 node2.next = node3 node3.next = node4 node4.next = node5 print(has_cycle(head)) # Output: False # Example 3 # Linked list: NULL head = None print(has_cycle(head)) # Output: False ``` Constraints - The linked list can have any number of nodes, including zero (an empty linked list). - Nodes can have any type of value (integers, strings, etc.). Notes - Ensure your solution handles an empty linked list correctly by returning `False`. - Test for cycles by running two pointers at different speeds through the list. - Carefully manage the pointers to avoid infinite loops or errors. Performance Requirements - The time complexity should be O(n), where n is the number of nodes in the linked list. - The space complexity should be O(1), using only a constant amount of extra space.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def has_cycle(head: ListNode) -> bool: Detects whether there is a cycle in the linked list using Floyd\'s Cycle Detection Algorithm. :param head: The head node of the linked list. :return: True if there is a cycle in the linked list, False otherwise. if not head: return False slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False"},{"question":"# Coding Assessment Question Context You are working on an email filtering system that categorizes emails into different folders based on certain keywords in the subject or email body. This system helps users manage their emails more efficiently by automating the process of sorting emails into relevant folders such as \\"Work\\", \\"Personal\\", \\"Spam\\", etc. Question Write a Python function called `categorize_emails` that assigns each email to a specific folder based on predefined keywords. The function should take a list of emails and the categorization rules as inputs and return a dictionary where the keys are the folder names and the values are lists of emails sorted into those folders. The email processing should follow these steps: 1. Iterate over each email. 2. Check the subject and body of the email for the presence of the keywords defined in the categorization rules. 3. Assign the email to the appropriate folder based on the matched keyword. 4. If an email matches multiple keywords, it should be added to all corresponding folders. Function Signature ```python def categorize_emails(emails: list[dict], rules: dict) -> dict: pass ``` Input - `emails` (list of dicts): Each dictionary represents an email and has two keys: - `subject` (str): The subject of the email. - `body` (str): The body content of the email. - `rules` (dict): A dictionary where keys are folder names (e.g., \\"Work\\", \\"Personal\\", \\"Spam\\") and values are lists of keywords (e.g., [\\"urgent\\", \\"meeting\\", \\"project\\"]). Output - A dictionary where the keys are folder names and the values are lists of emails (each email is represented as a dictionary with `subject` and `body`). Constraints - Ensure that the email is added to all matching folders if multiple keywords are found across different categories. - If an email does not match any of the keywords, it should not be included in the output dictionary. - Handle edge cases where the inputs might be empty or contain invalid data gracefully. Example ```python # Example use case emails = [ {\\"subject\\": \\"Project Update\\", \\"body\\": \\"The next meeting is scheduled for Monday\\"}, {\\"subject\\": \\"Discount Offer\\", \\"body\\": \\"Get 50% off on all purchases\\"}, {\\"subject\\": \\"Family Gathering\\", \\"body\\": \\"We are planning a family reunion next weekend\\"} ] rules = { \\"Work\\": [\\"project\\", \\"meeting\\"], \\"Personal\\": [\\"family\\", \\"reunion\\"], \\"Spam\\": [\\"discount\\", \\"offer\\"] } sorted_emails = categorize_emails(emails, rules) print(sorted_emails) # Output: { # \\"Work\\": [{\\"subject\\": \\"Project Update\\", \\"body\\": \\"The next meeting is scheduled for Monday\\"}], # \\"Personal\\": [{\\"subject\\": \\"Family Gathering\\", \\"body\\": \\"We are planning a family reunion next weekend\\"}], # \\"Spam\\": [{\\"subject\\": \\"Discount Offer\\", \\"body\\": \\"Get 50% off on all purchases\\"}] # } ``` Guidelines - Use string operations to check for keyword presence in the subject and body of emails. - Ensure the function handles different cases of keywords (e.g., \\"urgent\\" vs \\"Urgent\\"). - Optimize for readability and maintainability. - Consider using built-in modules and libraries for efficiency.","solution":"def categorize_emails(emails, rules): Categorizes emails into folders based on keywords in the subject and body. Args: emails (list of dicts): Each dictionary represents an email with keys \'subject\' and \'body\'. rules (dict): A dictionary where keys are folder names and values are lists of keywords. Returns: dict: A dictionary where the keys are folder names and the values are lists of emails. categorized_emails = {folder: [] for folder in rules} for email in emails: subject = email[\'subject\'].lower() body = email[\'body\'].lower() for folder, keywords in rules.items(): for keyword in keywords: if keyword.lower() in subject or keyword.lower() in body: categorized_emails[folder].append(email) break # No need to check other keywords for this folder # Remove empty folders categorized_emails = {folder: emails for folder, emails in categorized_emails.items() if emails} return categorized_emails"},{"question":"# Coding Assessment Question Context You are working on a logistics monitoring system that tracks the delivery of goods along a network of warehouses. Each warehouse supports certain types of goods, and each route between warehouses has a particular capacity limit for goods transfer. Your task is to help the system determine the maximum capacity of goods that can be transferred from the origin warehouse to the destination warehouse, given certain constraints. Problem Statement Implement the function `find_max_capacity` to determine the maximum capacity of goods that can be transferred from the origin warehouse to the destination warehouse. Function Signature ```python from typing import List, Tuple def find_max_capacity(num_warehouses: int, routes: List[Tuple[int, int, int]], start: int, destination: int) -> int: ``` Input * `num_warehouses` (int): Total number of warehouses. * `routes` (List[Tuple[int, int, int]]): A list of tuples where each tuple represents a route between two warehouses and the capacity limit of that route. Each tuple is in the form (warehouse1, warehouse2, capacity). * `start` (int): The index of the origin warehouse (0-indexed). * `destination` (int): The index of the destination warehouse (0-indexed). Output * An integer representing the maximum capacity of goods that can be transferred from the origin to the destination warehouse through the available routes. Constraints * ( 2 leq num_warehouses leq 100 ) * ( 1 leq len(routes) leq 1000 ) * Each warehouse is indexed from 0 to `num_warehouses-1`. * Capacity values in the routes are positive integers. Example ```python >>> num_warehouses = 4 >>> routes = [(0, 1, 10), (1, 2, 5), (0, 2, 15), (2, 3, 10), (1, 3, 7)] >>> start = 0 >>> destination = 3 >>> find_max_capacity(num_warehouses, routes, start, destination) 10 >>> num_warehouses = 3 >>> routes = [(0, 1, 4), (1, 2, 3)] >>> start = 0 >>> destination = 2 >>> find_max_capacity(num_warehouses, routes, start, destination) 3 ``` Notes - Ensure to test the function with edge cases. - The function should handle scenarios where no path is available gracefully. - Consider optimizing the solution for efficiency given the constraints.","solution":"from typing import List, Tuple import heapq def find_max_capacity(num_warehouses: int, routes: List[Tuple[int, int, int]], start: int, destination: int) -> int: def dijkstra_max_capacity(): max_capacity = [0] * num_warehouses max_capacity[start] = float(\'inf\') # Max-heap to store the current capacity from the start node heap = [(-max_capacity[start], start)] while heap: current_capacity, u = heapq.heappop(heap) current_capacity = -current_capacity if u == destination: return current_capacity for v, edge_capacity in adj[u]: capacity = min(current_capacity, edge_capacity) if capacity > max_capacity[v]: max_capacity[v] = capacity heapq.heappush(heap, (-capacity, v)) return 0 # Adjacency list representation of the graph adj = [[] for _ in range(num_warehouses)] for u, v, capacity in routes: adj[u].append((v, capacity)) adj[v].append((u, capacity)) return dijkstra_max_capacity()"},{"question":"# Question You are given a string `s` that consists of lowercase letters and a function `shift_amounts` that returns a list of integers. You need to create a new string by shifting each character in `s` to the right by the corresponding number specified in the `shift_amounts` list. The shift is circular, meaning that after \'z\', it wraps around back to \'a\'. For example, shifting \'z\' by 1 would result in \'a\', and shifting \'y\' by 2 would result in \'a\'. Write a function `shift_string(s: str, shift_amounts: List[int]) -> str` that performs this operation and returns the resulting string. # Input and Output Formats Inputs: - `s`: A string of lowercase letters, with a length of at most 10^5. - `shift_amounts`: A list of integers where each integer represents the number of positions a character in `s` should be shifted to the right (modulo 26). Output: - A string that represents the modified version of `s` after applying the shifts. # Example ```python # Example Input s = \\"abc\\" shift_amounts = [1, 2, 3] # Example Function Call print(shift_string(s, shift_amounts)) # Expected Output \\"bdf\\" ``` In the example, the string \\"abc\\" is shifted to \\"bdf\\" because: - \'a\' is shifted by 1 to become \'b\'. - \'b\' is shifted by 2 to become \'d\'. - \'c\' is shifted by 3 to become \'f\'. # Constraints - The length of the string `s` is equal to the length of the list `shift_amounts`. - All characters in the string `s` are lowercase English letters. - All integers in `shift_amounts` are non-negative.","solution":"from typing import List def shift_string(s: str, shift_amounts: List[int]) -> str: Shift each character in the string `s` by the corresponding amounts in `shift_amounts`. :param s: A string of lowercase letters. :param shift_amounts: A list of integers representing the shift amounts. :return: The modified string after applying the shifts. shifted_string = [] for i in range(len(s)): original_char = s[i] shift_amount = shift_amounts[i] % 26 shifted_char = chr((ord(original_char) - ord(\'a\') + shift_amount) % 26 + ord(\'a\')) shifted_string.append(shifted_char) return \'\'.join(shifted_string)"},{"question":"**Word Ladder Problem** Your task is to implement the Word Ladder problem using breadth-first search (BFS). The goal is to convert a given begin word to a given end word, using a list of word transformations of exactly one letter at a time. # Requirements - Implement a function `word_ladder(begin_word: str, end_word: str, word_list: List[str]) -> int` that returns the length of the shortest transformation sequence from begin_word to end_word using transformation rules. - Each transformation must change exactly one letter. - Each intermediate word must be in the given word_list. - If no such transformation sequence exists, return 0. # Inputs - String `begin_word`: the starting word. - String `end_word`: the target word. - List of strings `word_list`: the list of words available for transformations (1 ≤ len(word_list) ≤ 5000 and words are of same length). # Outputs - Integer representing the length of the shortest transformation sequence from begin_word to end_word. If the end_word cannot be reached, return 0. # Constraints - Assume all words in word_list are the same length as begin_word and end_word. - The word_list does not contain duplicates. - The begin_word is not necessarily in the word_list but the end_word must be. # Example ```python def word_ladder(begin_word: str, end_word: str, word_list: List[str]) -> int: # Your code here # Example usage: result = word_ladder(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"]) print(result) # Outputs: # 5 result = word_ladder(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"]) print(result) # Outputs: # 0 ``` **Prompt** Using the described algorithm and principles above: 1. Implement the `word_ladder` function. 2. Ensure the function showcases good performance practices. 3. Provide meaningful comments and documentation within the code.","solution":"from typing import List from collections import deque, defaultdict def word_ladder(begin_word: str, end_word: str, word_list: List[str]) -> int: Returns the length of the shortest transformation sequence from begin_word to end_word using BFS. Each transformation changes exactly one letter and each intermediate word must be in the word_list. If no such transformation sequence exists, returns 0. if end_word not in word_list: return 0 # All words are of same length word_length = len(begin_word) # Create a dictionary to hold all possible intermediate states all_combo_dict = defaultdict(list) for word in word_list: for i in range(word_length): intermediate_word = word[:i] + \\"*\\" + word[i+1:] all_combo_dict[intermediate_word].append(word) # BFS to find the shortest path queue = deque([(begin_word, 1)]) visited = {begin_word: True} while queue: current_word, level = queue.popleft() for i in range(word_length): intermediate_word = current_word[:i] + \\"*\\" + current_word[i+1:] for word in all_combo_dict[intermediate_word]: if word == end_word: return level + 1 if word not in visited: visited[word] = True queue.append((word, level + 1)) all_combo_dict[intermediate_word] = [] # Clear intermediate words list to save memory return 0"},{"question":"# Recursive Fibonacci Sequence You are tasked with implementing the Fibonacci sequence in Python using a recursive approach. The function should take a single integer as the input and return the nth Fibonacci number. Function Signature ```python def fibonacci(n: int) -> int: ``` Parameters: - `n` (int): The position in the Fibonacci sequence (0-indexed) to compute the Fibonacci number for. Returns: - `int`: The nth Fibonacci number. # Requirements: 1. Implement a recursive function to compute the nth Fibonacci number. 2. Ensure the base cases (0 and 1) are handled appropriately. 3. Handle both small and large values of `n`, considering the constraints. # Constraints: - ( 0 le n le 30 ) # Example Usage: ```python print(fibonacci(0)) # 0 print(fibonacci(1)) # 1 print(fibonacci(5)) # 5 print(fibonacci(10)) # 55 print(fibonacci(20)) # 6765 print(fibonacci(30)) # 832040 ``` Implement the `fibonacci` function and ensure it passes the provided test cases.","solution":"def fibonacci(n: int) -> int: Returns the nth Fibonacci number using a recursive approach. Parameters: n (int): The position in the Fibonacci sequence (0-indexed) to compute the Fibonacci number for. Returns: int: The nth Fibonacci number. if n == 0: return 0 elif n == 1: return 1 else: return fibonacci(n - 1) + fibonacci(n - 2)"},{"question":"# Problem Statement: You are given a set of points on a 2D plane and are required to determine the maximum number of points that lie on the same straight line. **Objective:** Write a function `max_points_on_line(points: List[Tuple[int, int]]) -> int` that takes a list of points represented as tuples `(x, y)` and returns the maximum number of points that lie on a single straight line. **Input:** * A list of tuples `points` where each tuple represents a point\'s coordinates `(x, y)` on the 2D plane. **Output:** * An integer representing the maximum number of points that lie on the same straight line. **Constraints:** * The number of points will be between 1 and 2000. * Each coordinate value `x, y` will be between -10,000 and 10,000. * Points can have duplicate entries. **Example 1:** ```python assert max_points_on_line([(1, 1), (2, 2), (3, 3)]) == 3 ``` **Example 2:** ```python assert max_points_on_line([(1, 1), (3, 2), (5, 3), (4, 1), (2, 3), (1, 4)]) == 3 ``` **Scenario:** Suppose you are developing an application to manage and analyze geographical locations data. One of the features requires finding trends or alignments among provided data points, and this could help in predicting paths or detecting linear patterns efficiently.","solution":"from collections import defaultdict from math import gcd from typing import List, Tuple def max_points_on_line(points: List[Tuple[int, int]]) -> int: if len(points) <= 1: return len(points) def get_slope(p1, p2): dx, dy = p2[0] - p1[0], p2[1] - p1[1] if dx == 0: return (0, p1[0]) if dy == 0: return (p1[1], 0) d = gcd(dx, dy) return (dy // d, dx // d) max_points = 0 for i in range(len(points)): slopes = defaultdict(int) same_point_count = 1 for j in range(i + 1, len(points)): if points[i] == points[j]: same_point_count += 1 continue slope = get_slope(points[i], points[j]) slopes[slope] += 1 current_max = same_point_count for count in slopes.values(): current_max = max(current_max, count + same_point_count) max_points = max(max_points, current_max) return max_points"},{"question":"# Problem Statement: You are responsible for implementing a caching layer to optimize the performance of a web service that deals with user profiles. The process involves ensuring that user profile data retrieval is efficient by using a least recently used (LRU) cache mechanism. Write a class that simulates an LRU cache which can store user profile data (key-value pairs) with a fixed size limit. The cache should allow user profile retrieval and updating while maintaining the LRU property. # Class Signature: ```python class LRUCache: def __init__(self, capacity: int): Initialize the LRU cache with a given capacity. :param capacity: The maximum capacity of the cache. pass def get(self, key: int) -> str: Retrieve the value of the key if the key exists in the cache, otherwise return \\"\\". :param key: The key of the user profile. :return: The value of the user profile if key exists, else \\"\\". pass def put(self, key: int, value: str) -> None: Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, remove the least recently used key. :param key: The key of the user profile. :param value: The value of the user profile. :return: None pass ``` # Input/Output: * `__init__(capacity)` - Initialize the cache with given capacity. * Arguments: * `capacity` (int): The maximum capacity of the cache. * `get(key)` - Retrieve the value of the key if the key exists in the cache, otherwise return an empty string. * Arguments: * `key` (int): The key of the user profile. * Returns: * The value of the user profile if the key exists, else an empty string. * `put(key, value)` - Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds capacity from this operation, remove the least recently used key. * Arguments: * `key` (int): The key of the user profile. * `value` (str): The value of the user profile. * Returns: None # Constraints: 1. `1 <= capacity <= 1000` 2. `1 <= key <= 10^5` 3. `1 <= len(value) <= 10^5` # Example: ```python # Your LRUCache object will be instantiated and called as such: lru = LRUCache(capacity=2) lru.put(1, \\"UserProfileA\\") lru.put(2, \\"UserProfileB\\") assert lru.get(1) == \\"UserProfileA\\" # returns \\"UserProfileA\\" lru.put(3, \\"UserProfileC\\") # LRU key was 2, evicts key 2, cache is {1: \\"UserProfileA\\", 3: \\"UserProfileC\\"} assert lru.get(2) == \\"\\" # returns an empty string (not found) lru.put(4, \\"UserProfileD\\") # LRU key was 1, evicts key 1, cache is {4: \\"UserProfileD\\", 3: \\"UserProfileC\\"} assert lru.get(1) == \\"\\" # returns an empty string (not found) assert lru.get(3) == \\"UserProfileC\\" # returns \\"UserProfileC\\" assert lru.get(4) == \\"UserProfileD\\" # returns \\"UserProfileD\\" ```","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): Initialize the LRU cache with a given capacity. :param capacity: The maximum capacity of the cache. self.capacity = capacity self.cache = OrderedDict() def get(self, key: int) -> str: Retrieve the value of the key if the key exists in the cache, otherwise return \\"\\". :param key: The key of the user profile. :return: The value of the user profile if key exists, else \\"\\". if key in self.cache: # Move the accessed element to the end (most recently used) self.cache.move_to_end(key) return self.cache[key] return \\"\\" def put(self, key: int, value: str) -> None: Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, remove the least recently used key. :param key: The key of the user profile. :param value: The value of the user profile. :return: None if key in self.cache: # Update the value and move the element to the end (most recently used) self.cache.move_to_end(key) self.cache[key] = value if len(self.cache) > self.capacity: # Pop the first item (least recently used) self.cache.popitem(last=False)"},{"question":"# Question: Character Frequency Counter with Exclusion List Create a function that counts the frequency of each character in a given string, while excluding a set of specified characters from both the count and the output. The result should be a dictionary with characters as keys and their respective counts as values, excluding the specified characters. Requirements: 1. Write a function `character_frequency` that accepts two parameters: a string and a set of characters to exclude. 2. The function should return a dictionary where keys are the characters from the string and values are their counts, excluding the specified characters. 3. Handle edge cases such as empty strings and all characters excluded responsibly. Function Signature: ```python def character_frequency(text: str, exclude: set) -> dict: pass ``` Input: * `text` – A string consisting of characters for which the frequency count is required. * `exclude` – A set of characters that should be excluded from the count. Output: * A dictionary containing character frequencies, excluding the characters specified in `exclude`. Constraints: * The input string can have a maximum length of (10^6) characters. * The set of excluded characters can have a maximum length of 100 characters. Example Usage: ```python >>> character_frequency(\\"hello world\\", {\' \', \'e\'}) {\'h\': 1, \'l\': 3, \'o\': 2, \'w\': 1, \'r\': 1, \'d\': 1} >>> character_frequency(\\"mississippi\\", {\'s\', \'p\'}) {\'m\': 1, \'i\': 4} ``` # Explanation * In the first example, the input string is `\\"hello world\\"` and the exclusion set is `{\' \', \'e\'}`. Therefore, the resulting dictionary excludes spaces and the letter \'e\'. * In the second example, the input string is `\\"mississippi\\"` and the exclusion set is `{\'s\', \'p\'}`. Therefore, the resulting dictionary excludes the letters \'s\' and \'p\'.","solution":"def character_frequency(text: str, exclude: set) -> dict: Counts the frequency of each character in the text, excluding characters in the exclude set. Parameters: text (str): The input string. exclude (set): A set of characters to exclude from the count. Returns: dict: A dictionary with characters as keys and their frequency as values, excluding specified characters. freq = {} for char in text: if char not in exclude: if char in freq: freq[char] += 1 else: freq[char] = 1 return freq"},{"question":"# Array Element Replacement Given an array of integers, write a function that replaces every element in the array with the product of all other elements in the array, except the one being replaced. The function should not use division for this transformation. Ensure to handle edge cases such as arrays with a single element or arrays containing zeros. Function Signature ```python def replace_with_product(arr: list[int]) -> list[int]: pass ``` Input * `arr` (list of int): An array of integers. Output * Returns a list of `int` where each element is the product of all other elements in the original array. Constraints * `1 <= len(arr) <= 10^3` * `-10^6 <= arr[i] <= 10^6` Performance Requirements The function should be optimized to run in O(n) time complexity where `n` is the length of the array. Example ```python # Example Usage assert replace_with_product([1, 2, 3, 4]) == [24, 12, 8, 6] assert replace_with_product([5, 6, 7]) == [42, 35, 30] assert replace_with_product([3, 0, 4]) == [0, 12, 0] assert replace_with_product([0, 0, 2]) == [0, 0, 0] assert replace_with_product([1]) == [1] ``` Edge Cases * If the array consists of one element, return an array with the same element since there are no other elements to multiply. * If the array contains zeros, ensure that the replacements are correctly calculated with appropriate handling of zero multiplication. Implementation Notes * Consider using prefix and suffix products to maintain O(n) time complexity. * Handle possible overflow scenarios based on the constraints given. Additional Notes * The zeros and the handling of empty arrays should be done carefully to avoid any ambiguous results or runtime errors.","solution":"def replace_with_product(arr: list[int]) -> list[int]: n = len(arr) if n == 0: return [] # Handle case when there\'s only one element if n == 1: return arr # Create two lists for prefix products and suffix products prefix_products = [1] * n suffix_products = [1] * n # Fill the prefix products for i in range(1, n): prefix_products[i] = prefix_products[i - 1] * arr[i - 1] # Fill the suffix products for i in range(n - 2, -1, -1): suffix_products[i] = suffix_products[i + 1] * arr[i + 1] # Calculate the result by multiplying prefix and suffix products result = [1] * n for i in range(n): result[i] = prefix_products[i] * suffix_products[i] return result"},{"question":"# Text Parsing and Keyword Extraction Objective: You are required to implement a function that processes a given text to identify and extract keywords. The function should take a single input parameter, the text, and return a list of unique keywords from the text, sorted in alphabetical order. Keywords are defined as words that occur more than once in the text and are not part of a predefined list of stopwords. Function Signature: ```python def extract_keywords(text: str) -> List[str]: ``` Inputs: 1. `text` (str): The input text from which to extract keywords. Outputs: 1. (List[str]): A list of unique keywords, sorted in alphabetical order. Constraints: 1. The text will be in English and can contain punctuation. 2. Ignore case when processing words. 3. Use a predefined list of stopwords provided below. Requirements: 1. Remove punctuation from the text. 2. Convert all words to lowercase. 3. Ignore words that are in the stopwords list. 4. Identify words that occur more than once in the text. 5. Ensure the returned list is sorted alphabetically and contains unique items. # Example: ```python # Example usage: keywords = extract_keywords(\\"This is a simple example. This example is only a test.\\") print(keywords) # Expected output: [\'example\', \'is\', \'this\'] # Assume the predefined list of stopwords: stopwords = [\\"a\\", \\"is\\", \\"the\\", \\"this\\", \\"and\\", \\"on\\", \\"in\\", \\"at\\", \\"of\\", \\"for\\", \\"to\\", \\"with\\", \\"only\\"] ``` # Notes: 1. Use the following list of stopwords for filtering out common words: ```python stopwords = [\\"a\\", \\"is\\", \\"the\\", \\"this\\", \\"and\\", \\"on\\", \\"in\\", \\"at\\", \\"of\\", \\"for\\", \\"to\\", \\"with\\", \\"only\\"] ``` 2. Remove punctuation using Python\'s `string.punctuation`. 3. Consider using collections like `Counter` from the `collections` module for counting word occurrences. 4. Your implementation should be efficient and easy to understand. Good luck, and happy coding!","solution":"import string from collections import Counter from typing import List stopwords = [\\"a\\", \\"is\\", \\"the\\", \\"this\\", \\"and\\", \\"on\\", \\"in\\", \\"at\\", \\"of\\", \\"for\\", \\"to\\", \\"with\\", \\"only\\"] def extract_keywords(text: str) -> List[str]: # Remove punctuation from the text text = text.translate(str.maketrans(\\"\\", \\"\\", string.punctuation)) # Convert the text to lowercase and split into words words = text.lower().split() # Filter out stopwords and count word occurrences filtered_words = [word for word in words if word not in stopwords] word_counts = Counter(filtered_words) # Extract words occurring more than once keywords = [word for word, count in word_counts.items() if count > 1] # Return the sorted list of unique keywords return sorted(keywords)"},{"question":"# K-Nearest Neighbors Classifier You are tasked with designing a simple k-nearest neighbors (k-NN) classifier for a small dataset of points in a 2D plane. This classifier will be used to predict the label of a new point based on the majority label of its k-nearest neighbors. Function Signature ```python def knn_classifier(train_data: List[Tuple[float, float, int]], test_point: Tuple[float, float], k: int) -> int: pass ``` Input - A list of tuples, `train_data`, where each tuple consists of two floats representing the coordinates (x, y) of a point and an integer representing the label of the point. Example: `[(2.0, 3.0, 0), (1.0, 1.0, 1)]`. - A tuple of two floats, `test_point`, representing the coordinates (x, y) of the point to classify. Example: `(1.5, 2.0)`. - An integer, `k`, representing the number of nearest neighbors to consider. Output - An integer, representing the predicted label of the `test_point`. # Constraints - The length of `train_data` will be at least 1 and at most 100. - The value of `k` will be at least 1 and at most the length of `train_data`. - Coordinate values for both `train_data` points and `test_point` will be between -1000.0 and 1000.0. # Performance Requirements - Your implementation should handle the dataset efficiently with a time complexity of O(n log n) for sorting. # Sample Input/Output ```python train_data = [(2.0, 3.0, 0), (1.0, 1.0, 1), (3.0, 4.0, 0), (5.0, 1.0, 1)] test_point = (2.5, 2.0) k = 3 assert knn_classifier(train_data, test_point, k) == 0 train_data = [(1.0, 1.0, 0), (2.0, 2.0, 0), (3.0, 3.0, 1), (4.0, 4.0, 1)] test_point = (3.1, 3.1) k = 2 assert knn_classifier(train_data, test_point, k) == 1 train_data = [(10.0, 10.0, 1), (20.0, 20.0, 0), (30.0, 30.0, 0)] test_point = (15.0, 15.0) k = 1 assert knn_classifier(train_data, test_point, k) == 1 ``` # Hints - Calculate the Euclidean distance between the `test_point` and each point in `train_data`. - Sort the distances to determine the k-nearest neighbors. - Count the labels of the k-nearest neighbors and return the majority label.","solution":"from typing import List, Tuple import math from collections import Counter def knn_classifier(train_data: List[Tuple[float, float, int]], test_point: Tuple[float, float], k: int) -> int: Predicts the label of the test_point based on k-nearest neighbors from the train_data. def euclidean_distance(point1, point2): return math.sqrt((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2) # Calculate distances from the test_point to each point in train_data distances = [(euclidean_distance(test_point, (data[0], data[1])), data[2]) for data in train_data] # Sort distances by the first item in the tuple (the distance) distances.sort(key=lambda x: x[0]) # Get the k-nearest labels k_nearest_labels = [label for (dist, label) in distances[:k]] # Determine the most common label among the k-nearest neighbors label_count = Counter(k_nearest_labels) # Return the label with the highest count return label_count.most_common(1)[0][0]"},{"question":"# Task: Matrix Rotation with Error Handling Problem Statement You are provided with a function that rotates a given square matrix by 90 degrees clockwise. The current function performs basic rotation but lacks comprehensive validation checks and error handling. Your task is to enhance this function to incorporate additional validation, handle edge cases, and improve its robustness. Function Signature ```python def rotate_matrix(matrix: list[list[int]]) -> list[list[int]]: pass ``` Input - `matrix` (list[list[int]]): A 2D list representing a square matrix of integers. Output - A **2D list** representing the rotated matrix. Constraints 1. The matrix should be a non-empty square matrix. 2. All elements in the matrix should be integers. 3. If the input matrix does not meet the constraints, raise appropriate `ValueError`. Example ```python >>> rotate_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix([[1]]) [[1]] >>> rotate_matrix([[1, 2], [3, \'a\']]) Traceback (most recent call last): ... ValueError: All elements must be integers >>> rotate_matrix([]) Traceback (most recent call last): ... ValueError: Matrix must be non-empty >>> rotate_matrix([[1, 2, 3], [4, 5, 6]]) Traceback (most recent call last): ... ValueError: Matrix must be square ``` Requirements - Implement additional validations and error handling. - Ensure the function rotates the matrix only when the input meets all constraints. - Optimize the function for efficiency while maintaining clarity.","solution":"def rotate_matrix(matrix: list[list[int]]) -> list[list[int]]: Rotates a given square matrix 90 degrees clockwise. Args: matrix (list[list[int]]): A 2D list representing a square matrix of integers. Returns: list[list[int]]: The rotated matrix. Raises: ValueError: If the matrix is not square, empty, or contains non-integer elements. if not matrix or not all(matrix): raise ValueError(\\"Matrix must be non-empty\\") n = len(matrix) # Check if matrix is square if not all(len(row) == n for row in matrix): raise ValueError(\\"Matrix must be square\\") # Check if all elements are integers if not all(isinstance(elem, int) for row in matrix for elem in row): raise ValueError(\\"All elements must be integers\\") # Rotate the matrix 90 degrees clockwise rotated_matrix = [[matrix[n - j - 1][i] for j in range(n)] for i in range(n)] return rotated_matrix"},{"question":"# Sum Of Unique Elements **Objective**: Write a function to find the sum of all unique elements in a list of integers. Requirements: 1. **Core Task**: Implement a function that accepts a list of integers and returns the sum of all elements that appear exactly once in the list. 2. **Expected Output**: The function should return an integer representing the sum of unique elements. 3. **Constraints**: - Input list will have a length of at least 1 and can have up to 10^4 elements. - Elements in the list are integers and can range from -10^6 to 10^6. 4. **Performance**: Aim for a solution that runs in linear time relative to the input size to accommodate larger inputs efficiently. Example: ```python def sum_of_unique_elements(lst): This function calculates the sum of all elements that appear exactly once in the input list. # Your implementation here # Example calls print(sum_of_unique_elements([1, 2, 3, 2])) # Output: 4 (1 + 3) print(sum_of_unique_elements([4, 5, 4, 5, 6])) # Output: 6 (6) print(sum_of_unique_elements([10, 10, 10])) # Output: 0 (no unique elements) ```","solution":"def sum_of_unique_elements(lst): This function calculates the sum of all elements that appear exactly once in the input list. from collections import Counter # Count frequency of each element count = Counter(lst) # Sum elements that appear exactly once unique_sum = sum(key for key, value in count.items() if value == 1) return unique_sum # Example calls print(sum_of_unique_elements([1, 2, 3, 2])) # Output: 4 (1 + 3) print(sum_of_unique_elements([4, 5, 4, 5, 6])) # Output: 6 (6) print(sum_of_unique_elements([10, 10, 10])) # Output: 0 (no unique elements)"},{"question":"# Majority Element in an Array **Context**: You are given an array of integers, where the majority element is the element that appears more than `n/2` times in the array, where `n` is the size of the array. It is guaranteed that there is always a majority element in the array. Your task is to efficiently find this majority element using an algorithm with linear time complexity. **Objective**: Write a function `find_majority_element(arr: list[int]) -> int` that finds and returns the majority element in the array. **Constraints**: - The array will always have at least 1 element. - There is always exactly one majority element guaranteed. **Input**: - A list of integers `arr` of size `n`. **Output**: - An integer representing the majority element. **Function Signature**: ```python def find_majority_element(arr: list[int]) -> int: ``` **Examples**: ```python assert find_majority_element([3, 2, 3]) == 3 assert find_majority_element([2, 2, 1, 1, 1, 2, 2]) == 2 assert find_majority_element([1, 1, 1, 1, 2, 3, 4, 1]) == 1 assert find_majority_element([6, 5, 5, 6, 6, 6, 6]) == 6 assert find_majority_element([7, 7, 8, 8, 8, 8, 8]) == 8 ``` **Performance Expectations**: - The algorithm should execute in O(n) time complexity and O(1) space complexity. **Hint**: Consider using the Boyer-Moore Voting Algorithm, which is a well-known approach to solve this problem efficiently using constant space.","solution":"def find_majority_element(arr: list[int]) -> int: Finds and returns the majority element in the array using Boyer-Moore Voting Algorithm. candidate, count = arr[0], 1 for num in arr[1:]: if count == 0: candidate, count = num, 1 elif num == candidate: count += 1 else: count -= 1 return candidate"},{"question":"# Program Description You are tasked with writing a function that evaluates mathematical expressions given as strings. The operations to be supported are addition (`+`), subtraction (`-`), multiplication (`*`), division (`/`), and modulus (`%`). The expressions can contain integers and the operations only, without any need for parentheses or floating-point numbers. Your function should correctly handle whitespaces and invalid characters or operations. # Function Signature ```python def evaluate_expression(expression: str) -> int: ``` # Input - **expression**: A string representing a mathematical expression. The string may contain leading/trailing whitespaces and can have a mix of integers and the operations `+`, `-`, `*`, `/`, `%`. # Output - An integer representing the result of the evaluated expression. # Constraints - Only integers and the given operations are valid within the expression. - Do not use the `eval` function or any similar built-in functions for direct evaluation of the string expression. - You may assume the length of the expression string does not exceed (10^5). - Division by zero should raise a `ZeroDivisionError`. # Exceptions The function should raise a `ValueError` in the following cases: - The input string is empty after trimming whitespaces. - The input string contains invalid characters or operations. # Example ```python >>> evaluate_expression(\' 3 + 5 * 2 \') 13 >>> evaluate_expression(\'10 - 2 / 2\') 9 >>> evaluate_expression(\'6 % 4 + 2 * 3\') 8 >>> evaluate_expression(\'a + b\') Traceback (most recent call last): ... ValueError: Invalid character in expression >>> evaluate_expression(\'12 / 0\') Traceback (most recent call last): ... ZeroDivisionError: Division by zero ``` # Implementation Notes - Ensure robust error handling for invalid inputs. - Consider edge cases like division by zero, invalid characters, and strings with leading/trailing whitespaces. - Make sure the function correctly parses and evaluates the mathematical expression according to mathematical precedence rules. - Ensure the function performs efficiently with regard to the input size constraints.","solution":"def evaluate_expression(expression: str) -> int: import re # Validate the expression and remove whitespaces expression = expression.replace(\' \', \'\') if not expression or re.search(r\'[^0-9+-*/%]\', expression): raise ValueError(\\"Invalid character in expression\\") # Helper function to apply operators def apply_operator(a, b, operator): if operator == \'+\': return a + b if operator == \'-\': return a - b if operator == \'*\': return a * b if operator == \'/\': if b == 0: raise ZeroDivisionError(\\"Division by zero\\") return a // b # Integer division if operator == \'%\': if b == 0: raise ZeroDivisionError(\\"Division by zero\\") return a % b raise ValueError(\\"Invalid operator\\") # Convert expression to postfix notation using the Shunting Yard algorithm precedence = {\'+\': 1, \'-\': 1, \'*\': 2, \'/\': 2, \'%\': 2} operators = [] output = [] i = 0 while i < len(expression): if expression[i].isdigit(): num = \'\' while i < len(expression) and expression[i].isdigit(): num += expression[i] i += 1 output.append(int(num)) continue while (operators and operators[-1] in precedence and precedence[operators[-1]] >= precedence[expression[i]]): output.append(operators.pop()) operators.append(expression[i]) i += 1 while operators: output.append(operators.pop()) # Evaluate postfix expression stack = [] for token in output: if isinstance(token, int): stack.append(token) else: b = stack.pop() a = stack.pop() stack.append(apply_operator(a, b, token)) return stack[0]"},{"question":"# Problem Statement Implement a scheduler that processes a list of jobs, each with a specific priority and execution time, and manages the execution order based on the priority and round-robin scheduling. The scheduler should run in a fixed time slice manner but give higher priority jobs an earlier chance to execute. # Requirements: 1. **Job Class**: - Attributes: - `name` (string): The name of the job. - `priority` (int): The priority where a lower number means higher priority. Valid priority values are between 1 (highest priority) and 10 (lowest priority). - `execution_time` (int): The total time in milliseconds required to complete the job. - Methods: - `__init__`: Initialize the job with the specified attributes. 2. **Scheduler Class**: - Attributes: - `time_slice` (int): A fixed time slice in milliseconds for the scheduler. - Methods: - `__init__`: Initialize the scheduler with the specified time slice. - `add_job`: Add a job to the scheduler. - `execute`: Execute the jobs based on their priorities and the time slice until all jobs are completed. Return the order of job completions as a list. # Example: ```python class Job: def __init__(self, name: str, priority: int, execution_time: int): self.name = name self.priority = priority self.execution_time = execution_time class Scheduler: def __init__(self, time_slice: int): self.time_slice = time_slice self.jobs = [] def add_job(self, job: Job): self.jobs.append(job) def execute(self) -> list[str]: # Your implementation here to simulate the scheduler execution. pass # Example usage scheduler = Scheduler(time_slice=100) scheduler.add_job(Job(name=\\"job1\\", priority=1, execution_time=250)) scheduler.add_job(Job(name=\\"job2\\", priority=2, execution_time=100)) scheduler.add_job(Job(name=\\"job3\\", priority=1, execution_time=150)) result = scheduler.execute() print(result) # expected output will vary based on the logic; for instance [\'job2\', \'job3\', \'job1\'] ``` # Notes: - Consider using a priority queue to manage jobs based on their priority. - Ensure that jobs with the same priority are handled in the order they were added. - Handle edge cases such as when the execution time is smaller than the time slice. - Take into account cases where no jobs are available or all jobs are already completed.","solution":"from queue import PriorityQueue from typing import List class Job: def __init__(self, name: str, priority: int, execution_time: int): self.name = name self.priority = priority self.execution_time = execution_time def __lt__(self, other): return self.priority < other.priority class Scheduler: def __init__(self, time_slice: int): self.time_slice = time_slice self.jobs = PriorityQueue() def add_job(self, job: Job): self.jobs.put((job.priority, job)) def execute(self) -> List[str]: queue = [] while not self.jobs.empty(): priority, job = self.jobs.get() queue.append(job) completed_jobs = [] current_time = 0 while queue: job = queue.pop(0) time_to_run = min(self.time_slice, job.execution_time) job.execution_time -= time_to_run current_time += time_to_run if job.execution_time > 0: queue.append(job) # Re-add the job to the queue if it still needs time else: completed_jobs.append(job.name) return completed_jobs"},{"question":"# Matrix Determinant Calculation You are tasked with implementing a function to calculate the determinant of a square matrix. The input will be a 2D list representing a square matrix, and the function should return the determinant as an integer or a floating-point number. Function Signature ```python def calculate_determinant(matrix: List[List[Union[int, float]]]) -> Union[int, float] ``` Input * **matrix**: A 2D list of integers or floats, representing a square matrix. (e.g., `[[4, 3], [6, 3]]`) Output * Returns a single integer or float that is the determinant of the matrix. Breakdown of Implementation Requirements: 1. **Base Case**: Directly return the determinant for 1x1 and 2x2 matrices. 2. **Recursion**: For larger matrices, implement recursive calculation of the determinant using cofactor expansion. 3. **Helper Functions**: Implement helper functions if needed to handle submatrix creation or minor expansion. Constraints * Only valid square matrices will be provided. * Matrices can vary in size from 1x1 up to 10x10. * Elements of the matrices are always integers or floats. # Example ```python # Example 2x2 matrix matrix_2x2 = [[4, 3], [6, 3]] det_2x2 = calculate_determinant(matrix_2x2) print(det_2x2) # Expected output: -6 # Example 3x3 matrix matrix_3x3 = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] det_3x3 = calculate_determinant(matrix_3x3) print(det_3x3) # Expected output: 0 ``` You are required to handle the calculation accurately for matrices up to size 10x10. Ensure to consider time complexity in your implementation to handle the larger possible inputs efficiently.","solution":"from typing import List, Union def calculate_determinant(matrix: List[List[Union[int, float]]]) -> Union[int, float]: Calculate the determinant of a square matrix. :param matrix: 2D list representing a square matrix :return: The determinant of the matrix as an integer or float size = len(matrix) # Base cases for 1x1 and 2x2 matrices if size == 1: return matrix[0][0] elif size == 2: return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0] # Recursive case for larger matrices def get_submatrix(mat, row, col): Helper function to get the submatrix after removing the specified row and column. return [row[:col] + row[col + 1:] for row in (mat[:row] + mat[row + 1:])] determinant = 0 for c in range(size): sign = (-1) ** c submatrix = get_submatrix(matrix, 0, c) determinant += sign * matrix[0][c] * calculate_determinant(submatrix) return determinant"},{"question":"# Coding Challenge: Count Distinct Prime Factors Background A prime factor of a number is a factor that is a prime number. For instance, the prime factors of 28 are 2 and 7. Task Write a function `count_distinct_prime_factors(n: int) -> int` that returns the number of distinct prime factors of a given integer `n`. Input - A single integer `n` (2 <= n <= 10^5). Output - Return the number of distinct prime factors of `n`. Examples ```python assert count_distinct_prime_factors(28) == 2 # prime factors are 2 and 7 assert count_distinct_prime_factors(30) == 3 # prime factors are 2, 3, and 5 assert count_distinct_prime_factors(1) == 0 # 1 has no prime factors assert count_distinct_prime_factors(100) == 2 # prime factors are 2 and 5 assert count_distinct_prime_factors(97) == 1 # prime factor is 97 ``` # Constraints - The input will always be a single integer. - You must handle inputs within the range [2, 100000]. - Your solution should be optimized for performance.","solution":"def count_distinct_prime_factors(n: int) -> int: Returns the number of distinct prime factors of n. def sieve(limit): is_prime = [True] * (limit + 1) p = 2 while (p * p <= limit): if is_prime[p] == True: for i in range(p * p, limit + 1, p): is_prime[i] = False p += 1 prime_numbers = [p for p in range(2, limit + 1) if is_prime[p]] return prime_numbers prime_factors = set() primes = sieve(int(n**0.5) + 1) for prime in primes: if n % prime == 0: prime_factors.add(prime) while (n % prime == 0): n //= prime if n > 1: prime_factors.add(n) return len(prime_factors)"},{"question":"# Problem: Advanced Sorting Algorithms Implementation Your task is to implement advanced sorting algorithms that handle various data structures and ordering requirements efficiently. You\'ll implement functions for each sorting algorithm and validate their accuracy and performance. Task Requirements: 1. **Function Signature**: - Implement the following sorting algorithms: * Quick Sort * Merge Sort * Heap Sort * Counting Sort * Bucket Sort - The function names should be in the format `sort_algorithm_name(arr)`, where `algorithm_name` is the name of the sorting algorithm lower case and underscores (e.g., `sort_quick`). 2. **Input and Output**: - The sorting functions should accept a list of integers `arr` and return a sorted list of integers. - If the input list is empty, the function should return an empty list. - If invalid input is provided (e.g., non-integer elements), the function should raise a `TypeError` with an appropriate message. 3. **Constraints**: - Ensure the sorting functions can handle lists of varying sizes up to at least `10^5` elements efficiently. - The input list will contain only integer values within the range of -10^6 to 10^6. 4. **Performance Requirements**: - Ensure Quick Sort and Merge Sort run in average O(n log n) time. - Ensure Heap Sort runs in O(n log n) time. - Ensure Counting Sort and Bucket Sort run in O(n) time under appropriate conditions. Example Functions: 1. **Quick Sort** ```python def sort_quick(arr: list) -> list: if not all(isinstance(x, int) for x in arr): raise TypeError(\\"sort_quick() only accepts lists of integers\\") if len(arr) < 2: return arr pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return sort_quick(left) + middle + sort_quick(right) ``` 2. **Merge Sort** ```python def sort_merge(arr: list) -> list: if not all(isinstance(x, int) for x in arr): raise TypeError(\\"sort_merge() only accepts lists of integers\\") if len(arr) < 2: return arr def merge(left, right): result = [] while left and right: if left[0] <= right[0]: result.append(left.pop(0)) else: result.append(right.pop(0)) result.extend(left or right) return result mid = len(arr) // 2 left = sort_merge(arr[:mid]) right = sort_merge(arr[mid:]) return merge(left, right) ``` 3. **Heap Sort** ```python def sort_heap(arr: list) -> list: if not all(isinstance(x, int) for x in arr): raise TypeError(\\"sort_heap() only accepts lists of integers\\") def heapify(arr, n, i): largest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[i] < arr[left]: largest = left if right < n and arr[largest] < arr[right]: largest = right if largest != i: arr[i], arr[largest] = arr[largest], arr[i] heapify(arr, n, largest) n = len(arr) for i in range(n//2, -1, -1): heapify(arr, n, i) for i in range(n-1, 0, -1): arr[i], arr[0] = arr[0], arr[i] heapify(arr, i, 0) return arr ``` Test Your Functions: Ensure to cover the following cases in your tests: - Typical valid inputs showing correct sorting. - An empty list input returning an empty list. - A list with a single element returning the same single element. - Invalid inputs like non-integer elements raising appropriate errors. Provide at least one test example for each sorting algorithm function in the form of `assert` statements to validate their behavior.","solution":"def sort_quick(arr): Quick Sort algorithm implementation. if not all(isinstance(x, int) for x in arr): raise TypeError(\\"sort_quick() only accepts lists of integers\\") if len(arr) < 2: return arr pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return sort_quick(left) + middle + sort_quick(right) def sort_merge(arr): Merge Sort algorithm implementation. if not all(isinstance(x, int) for x in arr): raise TypeError(\\"sort_merge() only accepts lists of integers\\") if len(arr) < 2: return arr def merge(left, right): result = [] while left and right: if left[0] <= right[0]: result.append(left.pop(0)) else: result.append(right.pop(0)) result.extend(left or right) return result mid = len(arr) // 2 left = sort_merge(arr[:mid]) right = sort_merge(arr[mid:]) return merge(left, right) def sort_heap(arr): Heap Sort algorithm implementation. if not all(isinstance(x, int) for x in arr): raise TypeError(\\"sort_heap() only accepts lists of integers\\") def heapify(arr, n, i): largest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[i] < arr[left]: largest = left if right < n and arr[largest] < arr[right]: largest = right if largest != i: arr[i], arr[largest] = arr[largest], arr[i] heapify(arr, n, largest) n = len(arr) for i in range(n // 2 - 1, -1, -1): heapify(arr, n, i) for i in range(n - 1, 0, -1): arr[i], arr[0] = arr[0], arr[i] heapify(arr, i, 0) return arr def sort_counting(arr): Counting Sort algorithm implementation. if not all(isinstance(x, int) for x in arr): raise TypeError(\\"sort_counting() only accepts lists of integers\\") if len(arr) == 0: return arr max_val = max(arr) min_val = min(arr) range_of_elements = max_val - min_val + 1 count_arr = [0] * range_of_elements output_arr = [0] * len(arr) for i in range(len(arr)): count_arr[arr[i] - min_val] += 1 for i in range(1, len(count_arr)): count_arr[i] += count_arr[i-1] for i in range(len(arr) - 1, -1, -1): output_arr[count_arr[arr[i] - min_val] - 1] = arr[i] count_arr[arr[i] - min_val] -= 1 return output_arr def sort_bucket(arr): Bucket Sort algorithm implementation. if not all(isinstance(x, int) for x in arr): raise TypeError(\\"sort_bucket() only accepts lists of integers\\") if len(arr) == 0: return arr bucket_count = len(arr) max_val = max(arr) min_val = min(arr) range_val = max_val - min_val buckets = [[] for _ in range(bucket_count)] for i in range(len(arr)): index = (arr[i] - min_val) * (bucket_count - 1) // range_val buckets[index].append(arr[i]) for i in range(bucket_count): buckets[i] = sort_quick(buckets[i]) sorted_arr = [] for bucket in buckets: sorted_arr.extend(bucket) return sorted_arr"},{"question":"# String Calculation Validity Checker You are required to write a function `is_valid_calculation` that checks whether a given string is a valid calculation string. The function should parse and validate a string that contains non-negative integers and the operators `+`, `-`, `*`, or `/`. A valid calculation string should not start or end with an operator and should not have consecutive operators. # Function Signature ```python def is_valid_calculation(calculation: str) -> bool: pass ``` # Input 1. `calculation`: A string containing the calculation you need to validate. # Output * Returns `True` if the calculation string is valid, `False` otherwise. # Constraints * Each integer in the string will be non-negative and can have an arbitrary number of digits. * Allowed operators are `+`, `-`, `*`, `/`. * Spaces are not allowed in the input string. * It\'s guaranteed that the string will only contain digits and the allowed operators. # Example ```python print(is_valid_calculation(\\"3+5*2-4/2\\")) # Output: True print(is_valid_calculation(\\"3++5-2\\")) # Output: False print(is_valid_calculation(\\"5*2-\\")) # Output: False print(is_valid_calculation(\\"+3*5-2\\")) # Output: False ``` # Note 1. Write a helper function within `is_valid_calculation` if necessary to check individual segments of the string. 2. Remember to handle edge cases such as empty strings or strings that are purely operators. 3. Do not use `eval()` or any similar direct evaluation functions to validate the string. Instead, perform direct checks to ensure the string adheres to the format and rules of a valid calculation.","solution":"def is_valid_calculation(calculation: str) -> bool: Checks whether a given string is a valid calculation string. if not calculation: return False operators = {\'+\', \'-\', \'*\', \'/\'} if calculation[0] in operators or calculation[-1] in operators: return False previous_char = \'\' for char in calculation: if char in operators: if previous_char in operators: return False previous_char = char return True"},{"question":"```markdown # String Compression and Decompression You are to implement two functions: one that compresses a given string using basic run-length encoding and another that decompresses a run-length encoded string back to its original form. This simple compression technique will help in understanding the basics of data compression algorithms. **Function Signatures**: ```python def compress_string(input_string: str) -> str: def decompress_string(compressed_string: str) -> str: ``` # Input (Compression) * `input_string` (str): A string consisting of uppercase and lowercase English letters. # Output (Compression) * Returns the compressed version of the input string. # Input (Decompression) * `compressed_string` (str): A compressed string which is the output of the `compress_string` function. # Output (Decompression) * Returns the decompressed version of the compressed string. # Constraints * If any of the functions receive an invalid input (i.e., non-alphabetic characters for `compress_string`), raise a ValueError: `\\"Invalid input string\\"`. * The `input_string` can have a maximum length of 1000 characters. # Example ```python >>> compress_string(\\"aaabbcddd\\") \'a3b2c1d3\' >>> decompress_string(\\"a3b2c1d3\\") \'aaabbcddd\' >>> compress_string(\\"aabbbc\\") \'a2b3c1\' >>> decompress_string(\\"a2b3c1\\") \'aabbbc\' >>> compress_string(\\"AAAaaa\\") \'A3a3\' >>> decompress_string(\\"A3a3\\") \'AAAaaa\' ``` # Additional Information For the `compress_string` function, output the compressed format in which the character is followed by the count of its consecutive occurrence (i.e., \'a2\' for two \'a\'s). For the `decompress_string` function, translate this format back into the original string. Ensure that the encoding and decoding processes are symmetric and reversible. ```","solution":"def compress_string(input_string: str) -> str: if not input_string.isalpha(): raise ValueError(\\"Invalid input string\\") compressed_string = \\"\\" count = 1 for i in range(1, len(input_string)): if input_string[i] == input_string[i - 1]: count += 1 else: compressed_string += input_string[i - 1] + str(count) count = 1 compressed_string += input_string[-1] + str(count) return compressed_string def decompress_string(compressed_string: str) -> str: decompressed_string = \\"\\" i = 0 while i < len(compressed_string): char = compressed_string[i] i += 1 count_str = \\"\\" while i < len(compressed_string) and compressed_string[i].isdigit(): count_str += compressed_string[i] i += 1 count = int(count_str) decompressed_string += char * count return decompressed_string"},{"question":"# Task To test your understanding of list manipulation and logic skills, implement a function that finds the longest contiguous subarray with equal numbers of 0s and 1s. # Function Signature ```python def find_max_length(nums: list[int]) -> int: Find the length of the longest contiguous subarray with an equal number of 0s and 1s. :param nums: A list of integers containing only 0s and 1s. :return: The length of the longest contiguous subarray with equal numbers of 0s and 1s. ``` # Description - **Input**: A list of integers `nums` containing only 0s and 1s. - **Output**: Return the length of the longest contiguous subarray with an equal number of 0s and 1s. # Constraints - `0 <= len(nums) <= 10^5` - `nums[i]` is `0` or `1` # Example ```python assert find_max_length([0, 1]) == 2 # The entire array is the longest subarray with equal number of 0s and 1s. assert find_max_length([0, 1, 0]) == 2 # The longest subarray is [0, 1] with length 2. assert find_max_length([1, 1, 0, 0, 1, 0, 1, 1]) == 6 # The longest subarray is [0, 0, 1, 0, 1, 1] with length 6. assert find_max_length([0, 0, 1, 1, 0]) == 4 # The longest subarray is [0, 0, 1, 1] with length 4. assert find_max_length([1, 1, 1, 0, 0, 0, 1]) == 6 # The longest subarray is [1, 1, 1, 0, 0, 0] with length 6. assert find_max_length([0, 1, 1, 0, 1, 0, 0]) == 6 # The longest subarray is [0, 1, 1, 0, 1, 0] with length 6. ``` # Guidelines 1. **Definition**: The task here is to identify a subarray within `nums` where the count of 0s and 1s are equal. 2. **Approach**: - Use a hashmap (dictionary) to store the first occurrence of each prefix sum encountered. - Transform the array by replacing 0s with -1s and then compute the prefix sum. - Utilize the hashmap to determine the length of the longest subarray with a net sum of zero, representing equal numbers of 0s and 1s. 3. **Efficiency Considerations**: Aim for a time complexity of O(n) and a space complexity of O(n). # Note Consider edge cases such as arrays of very short length, and arrays with all elements being either all 0s or all 1s.","solution":"def find_max_length(nums): count_index_map = {0: -1} max_length = 0 count = 0 for i, num in enumerate(nums): count += 1 if num == 1 else -1 if count in count_index_map: max_length = max(max_length, i - count_index_map[count]) else: count_index_map[count] = i return max_length"},{"question":"# Scenario At a large social media company, there is a need to analyze user engagement based on comments and likes on posts. Your task is to implement a function that helps in this analysis by identifying the most engaged user for a specific date. To accomplish this, you will create a function `most_engaged_user` that processes the engagement data and determines which user had the highest engagement ratio for a given date. # Task Implement the function `most_engaged_user` that performs the following steps: 1. Calculate the engagement ratio for each user on the specified date. 2. The engagement ratio for a user is defined as the total number of likes divided by the total number of comments they received on their posts on that date. 3. Return the username of the user with the highest engagement ratio. # Function Signature ```python def most_engaged_user(data: pd.DataFrame, date: str) -> str: ``` # Input - `data`: A pandas DataFrame with four columns: `username` (user\'s name), `date` (date in \'YYYY-MM-DD\' format), `comments` (number of comments), `likes` (number of likes). - `date`: A string representing the date in \'YYYY-MM-DD\' format for which engagement needs to be calculated. # Output - Returns a string: the username of the most engaged user on the given date. If there are multiple users with the highest engagement ratio, return the first one encountered. # Constraints - The dataset contains at least one entry. - All numeric values (comments and likes) are non-negative integers. # Performance - The solution should efficiently handle data up to 100,000 rows with potentially thousands of unique users. # Example ```python import pandas as pd data = pd.DataFrame({ \'username\': [\'user1\', \'user2\', \'user3\', \'user1\', \'user3\', \'user2\'], \'date\': [\'2023-10-01\', \'2023-10-01\', \'2023-10-01\', \'2023-10-02\', \'2023-10-02\', \'2023-10-02\'], \'comments\': [10, 5, 8, 7, 10, 3], \'likes\': [100, 50, 70, 50, 100, 20] }) date = \'2023-10-01\' print(most_engaged_user(data, date)) # Output should be \'user1\' ``` In this example, on the date \'2023-10-01\', user1 has the highest engagement ratio with 10 likes per comment (100 likes / 10 comments). Therefore, the function returns \'user1\'.","solution":"import pandas as pd def most_engaged_user(data: pd.DataFrame, date: str) -> str: Returns the username of the user with the highest engagement ratio on the given date. Parameters: data (pd.DataFrame): DataFrame containing columns \'username\', \'date\', \'comments\', and \'likes\'. date (str): The date in \'YYYY-MM-DD\' format for which to find the engagement ratio. Returns: str: The username with the highest engagement ratio. # Filter data for the specified date date_data = data[data[\'date\'] == date] if date_data.empty: return None # Calculate engagement ratio (likes / comments) for each user on the specified date date_data[\'engagement_ratio\'] = date_data[\'likes\'] / date_data[\'comments\'] # Find the user with the highest engagement ratio most_engaged_user = date_data.loc[date_data[\'engagement_ratio\'].idxmax()][\'username\'] return most_engaged_user"},{"question":"# Minimum Number of Coin Flips (Greedy Algorithm) Context: You are given a list of `n` coins, each showing either heads or tails. Your task is to determine the minimum number of coin flips needed to make all the coins show the same side (either all heads or all tails). Input: The input is a list of integers, where `0` represents a coin showing heads and `1` represents a coin showing tails. Output: Return a single integer, which is the minimum number of flips required to make all coins show the same side. Requirements: * You should consider an efficient algorithm to minimize the number of flips. Constraints: * The list can contain up to `10^5` coins. * The list will consist of only `0`s and `1`s. Example: Given the following list: ``` [0, 1, 0, 1, 1] ``` The output should be: ``` 2 ``` Explanation: To make all coins show the same side, you can flip either the two `0`s to `1`s, or the three `1`s to `0`s. The minimum number of flips required is `2`. # Task: Implement the function `min_coin_flips(coins: List[int]) -> int` which takes the list of coin states and returns the minimum number of flips required. ```python from typing import List def min_coin_flips(coins: List[int]) -> int: # Your implementation goes here pass # Example Usage: # assert min_coin_flips([0, 1, 0, 1, 1]) == 2 ```","solution":"from typing import List def min_coin_flips(coins: List[int]) -> int: Returns the minimum number of flips required to make all coins show the same side. count_heads = coins.count(0) count_tails = coins.count(1) return min(count_heads, count_tails)"},{"question":"# Movie Recommendations System You are tasked with implementing a simple movie recommendation system based on user ratings using collaborative filtering. Implement a class `MovieRecommender` with a method `recommend_movies` that takes a user ID and recommends the top N movies that the user has not yet rated. # Function Signature ```python class MovieRecommender: def __init__(self, ratings: List[Tuple[int, int, float]]) -> None: pass def recommend_movies(self, user_id: int, top_n: int) -> List[int]: pass ``` # Input - `ratings`: A list of tuples, where each tuple contains three values: - A user ID (integer). - A movie ID (integer). - A rating given by the user to the movie (float between 0 and 5). - `user_id`: An integer representing the user ID for whom the recommendations are to be generated. - `top_n`: An integer representing the number of top recommendations to return. # Output - A list of movie IDs (integers) representing the top N recommended movies for the given user ID. # Example Scenario Consider the following ratings: ```python ratings = [ (1, 101, 4.5), (1, 102, 3.0), (2, 101, 4.0), (2, 103, 5.0), (3, 102, 2.0), (3, 103, 4.5) ] ``` If user 1 already rated movies 101 and 102, the recommendations might include movie 103. # Constraints - The ratings data should be used to calculate user similarity based on rated movies. - Only recommend movies that the user has not yet rated. - If there are fewer than `top_n` recommendations available, return all possible recommendations. - Handle cases where a user has rated no movies or where there are no ratings data available. # Sample Test Case ```python ratings = [ (1, 101, 4.5), (1, 102, 3.0), (2, 101, 4.0), (2, 103, 5.0), (3, 102, 2.0), (3, 103, 4.5) ] recommender = MovieRecommender(ratings) # Recommend 2 movies for user 1 recommendations = recommender.recommend_movies(1, 2) # Output might be [103], as user 1 has not rated movie 103 yet. ``` # Tips - Calculate similarity scores between users based on their ratings. - Use collaborative filtering to identify top movies that similar users liked. - Efficiently handle the lookup of movies not rated by the user to avoid redundant recommendations.","solution":"from collections import defaultdict from typing import List, Tuple class MovieRecommender: def __init__(self, ratings: List[Tuple[int, int, float]]) -> None: self.user_ratings = defaultdict(dict) self.movie_ratings = defaultdict(list) for user_id, movie_id, rating in ratings: self.user_ratings[user_id][movie_id] = rating self.movie_ratings[movie_id].append((user_id, rating)) def recommend_movies(self, user_id: int, top_n: int) -> List[int]: if user_id not in self.user_ratings: return [] user_seen_movies = self.user_ratings[user_id] # Calculate the average rating of each movie movie_avg_rating = { movie_id: sum(rating for _, rating in ratings) / len(ratings) for movie_id, ratings in self.movie_ratings.items() } # Collect movies the user has not rated recommendations = [ (movie_id, avg_rating) for movie_id, avg_rating in movie_avg_rating.items() if movie_id not in user_seen_movies ] # Sort recommendations based on average rating and take the top N recommendations.sort(key=lambda x: -x[1]) return [movie_id for movie_id, _ in recommendations[:top_n]]"},{"question":"Data Processing and Visualization with Matplotlib You are given a dataset of global monthly average temperatures spanning several decades. Your task is to write a Python function that reads the data, processes it, and then visualizes the monthly temperature trends using a line plot. # Your Task Write a Python function, `plot_monthly_temperature_trends`, which will: 1. Read temperature data from a CSV file. 2. Process the data to calculate the average temperature for each month across all years. 3. Produce a line plot showing the monthly temperature trends. # Function Signature ```python def plot_monthly_temperature_trends(csv_file_path: str) -> None: ``` Implementation Details - The input CSV file has three columns: \\"Year\\", \\"Month\\", and \\"Temperature\\". - Calculate the average temperature for each of the 12 months (January to December) over all the years. - Plot the average temperature against each month using a line plot. - Save the plot as `\\"temperature_trends.png\\"`. Example Given an input CSV file `temperature_data.csv` with the following content: ``` Year,Month,Temperature 2000,January,5.6 2000,February,6.2 ... 2021,November,10.1 2021,December,8.3 ``` Your function should generate a line plot with months on the x-axis (January, February, ..., December) and average temperatures on the y-axis. # Constraints - Ensure that your function correctly handles varying data lengths and missing values. - Install and use the `pandas` library for data manipulation. - Install and use the `matplotlib` library for plotting the data. # Hints - Use the `pandas` library to read and process the CSV data. - Use the `matplotlib` library to create and save the plot. - You might find the `groupby` method in `pandas` useful for calculating monthly averages.","solution":"import pandas as pd import matplotlib.pyplot as plt def plot_monthly_temperature_trends(csv_file_path: str) -> None: Reads temperature data from a CSV file, processes it to calculate the average temperature for each month across all years, and produces a line plot showing the monthly temperature trends. # Read the CSV file into a DataFrame df = pd.read_csv(csv_file_path) # Group by \'Month\' and calculate the mean of \'Temperature\' monthly_avg = df.groupby(\'Month\')[\'Temperature\'].mean() # Ensure the months are in the correct order months_order = [\\"January\\", \\"February\\", \\"March\\", \\"April\\", \\"May\\", \\"June\\", \\"July\\", \\"August\\", \\"September\\", \\"October\\", \\"November\\", \\"December\\"] monthly_avg = monthly_avg.reindex(months_order) # Plot the data plt.figure(figsize=(10, 6)) plt.plot(monthly_avg.index, monthly_avg.values, marker=\'o\', linestyle=\'-\', color=\'b\') plt.title(\'Average Monthly Temperature Trends\') plt.xlabel(\'Month\') plt.ylabel(\'Average Temperature (°C)\') plt.grid(True) plt.xticks(rotation=45) plt.tight_layout() # Save the plot as \\"temperature_trends.png\\" plt.savefig(\\"temperature_trends.png\\") plt.close()"},{"question":"# K-Nearest Neighbors (KNN) Classifier Enhancement You are provided with a basic implementation of the K-Nearest Neighbors (KNN) classifier, a fundamental algorithm used in classification tasks. The classifier labels a data point based on the majority vote from its k nearest neighbors. # Task Enhance the given KNN classifier implementation to include the following features: 1. **Weighted Voting**: Modify the classification decision to use weighted voting, where closer neighbors have a larger influence on the decision than further ones. 2. **Distance Metrics**: Extend the classifier to support multiple distance metrics such as Euclidean, Manhattan, and Minkowski distances. The selection of the distance metric should be an input parameter. 3. **Cross-Validation**: Implement k-fold cross-validation to estimate the performance of the classifier for a given dataset and value of k. The number of folds should be specified as an input parameter. # Input - `X_train (numpy.ndarray)`: A 2D array where each row represents a training data point and each column represents a feature. - `y_train (numpy.ndarray)`: A 1D array containing the class labels corresponding to the training data. - `X_test (numpy.ndarray)`: A 2D array where each row represents a test data point to be classified. - `k (int)`: The number of nearest neighbors to consider for classification. - `distance_metric (str)`: A string specifying the distance metric to use (\'euclidean\', \'manhattan\', \'minkowski\'). - `num_folds (int)`: The number of folds to use for cross-validation (for performance estimation). # Output - `y_pred (numpy.ndarray)`: A 1D array containing the predicted class labels for the test data. - `cv_scores (list)`: A list containing the cross-validation accuracy scores for each fold. # Constraints - `k` must be a positive integer less than or equal to the number of training data points. - `distance_metric` must be one of \'euclidean\', \'manhattan\', or \'minkowski\'. - `num_folds` must be a positive integer less than or equal to the number of training data points. # Example Usage ```python import numpy as np # Sample data X_train = np.array([[1, 2], [3, 4], [5, 6], [7, 8]]) y_train = np.array([0, 1, 0, 1]) X_test = np.array([[2, 3], [4, 5]]) k = 3 distance_metric = \'euclidean\' num_folds = 2 y_pred, cv_scores = enhanced_knn_classifier(X_train, y_train, X_test, k, distance_metric, num_folds) print(\\"Predicted Labels:\\", y_pred) print(\\"Cross-Validation Scores:\\", cv_scores) ``` # Note You may use standard libraries available in Python such as numpy and scipy. Ensure your solution is efficient, handles various edge cases, and is well-documented. # Extension Points - Add detailed documentation and comments to explain your approach clearly. - Implement unit tests to verify the correctness of your function.","solution":"import numpy as np from collections import defaultdict from scipy.spatial import distance def calculate_distance(instance1, instance2, metric=\'euclidean\', p=3): if metric == \'euclidean\': return np.linalg.norm(instance1 - instance2) elif metric == \'manhattan\': return np.sum(np.abs(instance1 - instance2)) elif metric == \'minkowski\': return np.sum(np.abs(instance1 - instance2) ** p) ** (1 / p) else: raise ValueError(\\"Unsupported distance metric\\") def knn_predict(X_train, y_train, X_test, k, distance_metric): y_pred = [] for test_point in X_test: distances = [] for i, train_point in enumerate(X_train): dist = calculate_distance(test_point, train_point, metric=distance_metric) distances.append((dist, y_train[i])) # Sort based on distance and get the first k elements distances.sort(key=lambda x: x[0]) nearest_neighbors = distances[:k] votes = defaultdict(int) for dist, label in nearest_neighbors: # Weighted voting votes[label] += 1 / (dist + 1e-5) # 1e-5 to avoid division by zero # Determine the class with the highest vote sorted_votes = sorted(votes.items(), key=lambda x: x[1], reverse=True) y_pred.append(sorted_votes[0][0]) return np.array(y_pred) def k_fold_cross_validation(X, y, k, distance_metric, num_folds): fold_size = len(X) // num_folds accuracies = [] for i in range(num_folds): start = i * fold_size end = start + fold_size X_val = X[start:end] y_val = y[start:end] X_train = np.concatenate((X[:start], X[end:]), axis=0) y_train = np.concatenate((y[:start], y[end:]), axis=0) y_pred = knn_predict(X_train, y_train, X_val, k, distance_metric) accuracy = np.sum(y_pred == y_val) / len(y_val) accuracies.append(accuracy) return accuracies def enhanced_knn_classifier(X_train, y_train, X_test, k, distance_metric, num_folds): if k <= 0 or k > len(X_train): raise ValueError(\\"k must be a positive integer less than or equal to the number of training data points\\") if distance_metric not in [\'euclidean\', \'manhattan\', \'minkowski\']: raise ValueError(\\"Unsupported distance metric\\") if num_folds <= 0 or num_folds > len(X_train): raise ValueError(\\"num_folds must be a positive integer less than or equal to the number of training data points\\") y_pred = knn_predict(X_train, y_train, X_test, k, distance_metric) cv_scores = k_fold_cross_validation(X_train, y_train, k, distance_metric, num_folds) return y_pred, cv_scores"},{"question":"# Problem Statement A software application needs a feature to manage the inventory of products in a warehouse. Each product has a unique ID, name, quantity, and price. Users should be able to perform various operations such as adding a new product, updating the details of an existing product, deleting a product from the inventory, and retrieving the details of a product. Implement a class `Inventory` that encapsulates the following functionalities: # Methods: 1. `add_product(product_id: int, name: str, quantity: int, price: float) -> str`: Adds a new product to the inventory. If a product with the same ID already exists, update its details. 2. `update_product(product_id: int, name: str, quantity: int, price: float) -> str`: Updates the details of an existing product. If the product does not exist, return a message indicating so. 3. `delete_product(product_id: int) -> str`: Deletes a product from the inventory. If the product does not exist, return a message indicating so. 4. `get_product(product_id: int) -> dict`: Retrieves the details of a product. If the product does not exist, return a message indicating so. # Constraints: - `product_id` is a positive integer. - `name` is a non-empty string. - `quantity` should be a non-negative integer. - `price` should be a non-negative float. # Requirements: 1. The `Inventory` class should manage the products internally using an appropriate data structure. 2. The methods should return descriptive messages for each operation. # Example Usage: ```python >>> inventory = Inventory() >>> inventory.add_product(101, \\"Laptop\\", 50, 999.99) \'Product added successfully\' >>> inventory.get_product(101) {\'product_id\': 101, \'name\': \'Laptop\', \'quantity\': 50, \'price\': 999.99} >>> inventory.update_product(101, \\"Laptop\\", 60, 949.99) \'Product updated successfully\' >>> inventory.get_product(101) {\'product_id\': 101, \'name\': \'Laptop\', \'quantity\': 60, \'price\': 949.99} >>> inventory.delete_product(101) \'Product deleted successfully\' >>> inventory.get_product(101) \'Product not found\' ``` Use a dictionary to store products where the key is the `product_id` and the value is another dictionary with the product details. ```python class Inventory: def __init__(self): self.products = {} def add_product(self, product_id: int, name: str, quantity: int, price: float) -> str: self.products[product_id] = {\'name\': name, \'quantity\': quantity, \'price\': price} return \'Product added successfully\' def update_product(self, product_id: int, name: str, quantity: int, price: float) -> str: if product_id in self.products: self.products[product_id] = {\'name\': name, \'quantity\': quantity, \'price\': price} return \'Product updated successfully\' else: return \'Product not found\' def delete_product(self, product_id: int) -> str: if product_id in self.products: del self.products[product_id] return \'Product deleted successfully\' else: return \'Product not found\' def get_product(self, product_id: int) -> dict: return self.products.get(product_id, \'Product not found\') ```","solution":"class Inventory: def __init__(self): self.products = {} def add_product(self, product_id: int, name: str, quantity: int, price: float) -> str: self.products[product_id] = {\'name\': name, \'quantity\': quantity, \'price\': price} return \'Product added successfully\' def update_product(self, product_id: int, name: str, quantity: int, price: float) -> str: if product_id in self.products: self.products[product_id] = {\'name\': name, \'quantity\': quantity, \'price\': price} return \'Product updated successfully\' else: return \'Product not found\' def delete_product(self, product_id: int) -> str: if product_id in self.products: del self.products[product_id] return \'Product deleted successfully\' else: return \'Product not found\' def get_product(self, product_id: int) -> dict: return self.products.get(product_id, \'Product not found\')"},{"question":"# Problem Statement You are building an application that needs to manage a collection of user data efficiently. Specifically, you need to implement a simple, in-memory storage system that supports adding users, removing users, and retrieving the user with the longest name. Create a class `UserManager` with the following methods: 1. `add_user(name: str) -> None`: Adds a user with the given name. 2. `remove_user(name: str) -> bool`: Removes a user with the given name and returns `True`. If the user does not exist, return `False`. 3. `get_user_with_longest_name() -> str`: Returns the name of the user with the longest name. If there are multiple users with the same longest length, return the one that was added first. If there are no users, return an empty string \\"\\". # Input and Output Format * **Input**: Methods of the `UserManager` class managing user names represented as strings. * **Output**: The respective outputs of the `UserManager` methods specified above. # Constraints - User names consist of letters only and have a length range from 1 to 100. - The number of operations (adding, removing, and retrieving) will not exceed 10^4. # Example ```python # Example usage um = UserManager() um.add_user(\\"Alice\\") um.add_user(\\"Bob\\") print(um.get_user_with_longest_name()) # Output: \\"Alice\\" print(um.remove_user(\\"Alice\\")) # Output: True print(um.get_user_with_longest_name()) # Output: \\"Bob\\" print(um.remove_user(\\"Charlie\\")) # Output: False ``` # Task Implement the `UserManager` class as specified. ```python class UserManager: def __init__(self): self.users = [] self.user_set = set() def add_user(self, name: str) -> None: if name not in self.user_set: self.users.append(name) self.user_set.add(name) def remove_user(self, name: str) -> bool: if name in self.user_set: self.users.remove(name) self.user_set.remove(name) return True return False def get_user_with_longest_name(self) -> str: if not self.users: return \\"\\" return max(self.users, key=len) # Example usage um = UserManager() um.add_user(\\"Alice\\") um.add_user(\\"Bob\\") print(um.get_user_with_longest_name()) # Output: \\"Alice\\" print(um.remove_user(\\"Alice\\")) # Output: True print(um.get_user_with_longest_name()) # Output: \\"Bob\\" print(um.remove_user(\\"Charlie\\")) # Output: False ```","solution":"class UserManager: def __init__(self): self.users = [] self.user_set = set() def add_user(self, name: str) -> None: if name not in self.user_set: self.users.append(name) self.user_set.add(name) def remove_user(self, name: str) -> bool: if name in self.user_set: self.users.remove(name) self.user_set.remove(name) return True return False def get_user_with_longest_name(self) -> str: if not self.users: return \\"\\" return max(self.users, key=len) # Example usage um = UserManager() um.add_user(\\"Alice\\") um.add_user(\\"Bob\\") print(um.get_user_with_longest_name()) # Output: \\"Alice\\" print(um.remove_user(\\"Alice\\")) # Output: True print(um.get_user_with_longest_name()) # Output: \\"Bob\\" print(um.remove_user(\\"Charlie\\")) # Output: False"},{"question":"# Problem Statement You are tasked with implementing a function to calculate the sum of the first n perfect squares. A perfect square is a number that is the square of an integer. # Functional Requirements - **Function Name**: `sum_of_squares` - **Input**: - An integer (`n`), which represents the number of the first perfect squares to sum. - **Output**: - An integer representing the sum of the first `n` perfect squares. - **Constraints**: - If `n` is less than or equal to 0, return 0. - Handle non-integer and floating-point inputs by converting them to their integer part. - The input conversion should discard any fractional part. # Non-Functional Requirements - **Error Handling**: Ensure the function gracefully handles empty, null, and non-numeric inputs by returning 0. - **Performance**: The solution should efficiently handle large `n` values without significant time or memory overhead. # Example Input/Output ```python >>> sum_of_squares(5) 55 # 1^2 + 2^2 + 3^2 + 4^2 + 5^2 = 1 + 4 + 9 + 16 + 25 = 55 >>> sum_of_squares(1) 1 # 1^2 = 1 >>> sum_of_squares(-1) 0 # Since n is less than or equal to 0, return 0. >>> sum_of_squares(0) 0 # Since n is less than or equal to 0, return 0. >>> sum_of_squares(2.5) 5 # 1^2 + 2^2 = 1 + 4 = 5 >>> sum_of_squares(\'3\') 14 # 1^2 + 2^2 + 3^2 = 1 + 4 + 9 = 14 >>> sum_of_squares(\'\') 0 # Empty input should return 0. ``` # Implementation Implement the function `sum_of_squares` based on the requirements specified above.","solution":"def sum_of_squares(n): Returns the sum of the first n perfect squares. If n is less than or equal to 0, return 0. If n is a non-integer or float, convert it to its integer part. Non-numeric inputs and empty inputs are considered as 0. try: n = int(float(n)) # Convert input to integer by first converting to float (for strings like \'2.5\') except (ValueError, TypeError): return 0 # Handle non-numeric and empty inputs if n <= 0: return 0 return sum(i * i for i in range(1, n + 1))"},{"question":"# Task Tracker Develop a task tracking system where users can add tasks with a specific priority and retrieve tasks based on their priority level. The system should allow adding, removing, and retrieving tasks efficiently. Function Signature ```python class TaskTracker: def __init__(self): pass def add_task(self, task: str, priority: int) -> None: pass def get_highest_priority_task(self) -> str: pass def remove_task(self, task: str) -> None: pass ``` Methods: - `add_task(task: str, priority: int) -> None`: Adds a task with a specified priority to the system. - `get_highest_priority_task() -> str`: Retrieves and returns the task with the highest priority. If there are multiple tasks with the same priority, return the one that was added first. If no tasks are available, return \\"No tasks available\\". - `remove_task(task: str) -> None`: Removes the specified task from the system. If the task is not found, it should do nothing. Input: - `task` (str): A string representing the task description. - `priority` (int): An integer representing the task\'s priority level, with lower numbers indicating higher priority. Output: - The corresponding return type for each method as specified above. Constraints: - Priorities will be non-negative integers. - Tasks are uniquely identified by their string descriptions. - Assume the maximum number of tasks to be handled does not exceed `10^5`. Example: ```python # Initialize the Task Tracker tracker = TaskTracker() # Add tasks with different priorities tracker.add_task(\\"Finish project report\\", 2) tracker.add_task(\\"Prepare presentation\\", 1) tracker.add_task(\\"Reply to emails\\", 3) # Get the task with the highest priority print(tracker.get_highest_priority_task()) # Output: \\"Prepare presentation\\" # Remove a task tracker.remove_task(\\"Prepare presentation\\") # Get the highest priority task again print(tracker.get_highest_priority_task()) # Output: \\"Finish project report\\" ``` Notes: - Ensure the system handles tasks efficiently, especially considering the possible volume of tasks. - Handle edge cases where methods are called with no tasks available appropriately.","solution":"import heapq class TaskTracker: def __init__(self): self.tasks = [] self.task_map = {} self.counter = 0 def add_task(self, task: str, priority: int) -> None: heapq.heappush(self.tasks, (priority, self.counter, task)) self.task_map[task] = (priority, self.counter) self.counter += 1 def get_highest_priority_task(self) -> str: while self.tasks: priority, count, task = self.tasks[0] if task in self.task_map and self.task_map[task] == (priority, count): return task heapq.heappop(self.tasks) return \\"No tasks available\\" def remove_task(self, task: str) -> None: if task in self.task_map: del self.task_map[task]"},{"question":"# Question: Merge Multi-sorted Lists Context You are tasked with merging several sorted lists into a single sorted list. This problem is common in scenarios where multiple sources of data need to be combined and sorted efficiently. Task Implement the `merge_multi_sorted_lists` function that takes a list of sorted lists and merges them into a single sorted list. Your implementation should make use of efficient merging strategies to handle potentially large datasets. Function Signature ```python def merge_multi_sorted_lists(lists: list[list[int]]) -> list[int]: pass ``` Input - `lists`: List of `k` sorted lists, where `0 <= k <= 10^5` and the length of each list is `m` such that `0 <= m <= 10^5`. Output - Return a single list containing all elements from the input lists, sorted in non-decreasing order. Constraints - The function should have a time complexity of O(n log k) where `n` is the total number of elements across all lists. - The function should have a space complexity of O(n). - Assume all integers fit within standard memory constraints (e.g., 32-bit signed integers). Example ```python assert merge_multi_sorted_lists([[1, 4, 5], [1, 3, 4], [2, 6]]) == [1, 1, 2, 3, 4, 4, 5, 6] assert merge_multi_sorted_lists([[], [], []]) == [] assert merge_multi_sorted_lists([[5]]) == [5] assert merge_multi_sorted_lists([[0, 3, 6], [1, 4], [2, 5, 8]]) == [0, 1, 2, 3, 4, 5, 6, 8] assert merge_multi_sorted_lists([[1, 2, 3], [10, 20, 30], [-5, 0, 5]]) == [-5, 0, 1, 2, 3, 5, 10, 20, 30] ``` Note Your implementation should be optimized for performance, handling very large datasets efficiently. Utilizing data structures such as heaps can help achieve the desired time complexity.","solution":"from heapq import heappush, heappop def merge_multi_sorted_lists(lists: list[list[int]]) -> list[int]: Function to merge multiple sorted lists into a single sorted list. Parameters: lists (list[list[int]]): List of sorted lists. Returns: list[int]: Merged sorted list. min_heap = [] for i, lst in enumerate(lists): if lst: heappush(min_heap, (lst[0], i, 0)) merged_list = [] while min_heap: value, list_idx, element_idx = heappop(min_heap) merged_list.append(value) if element_idx + 1 < len(lists[list_idx]): heappush(min_heap, (lists[list_idx][element_idx + 1], list_idx, element_idx + 1)) return merged_list"},{"question":"# Coding Question: Advanced Data Aggregation A data analyst needs to aggregate specific details from a dataset stored in a list format. The dataset comprises various entries, where each entry is a dictionary containing multi-dimensional data. The analyst needs to extract and aggregate useful metrics efficiently. Task: Write a function `aggregate_data` that processes a list of dictionaries and returns the total, average, and count of a specified numeric key. Additionally, the function should handle entries with missing keys by ignoring them and ensure seamless handling of edge cases, such as empty lists. Requirements: 1. **Input**: - A list of dictionaries `data`, with each dictionary representing an entry. - A string `key`, representing the key to aggregate. 2. **Output**: - A dictionary with three keys: `\\"total\\"`, `\\"average\\"`, and `\\"count\\"`. - `\\"total\\"` is the sum of all values of the specified key. - `\\"average\\"` is the mean of all values of the specified key. - `\\"count\\"` is the number of valid entries considered. Constraints: - The list length (n) is between 0 and 10^6. - Each key\'s value in the dictionaries is a numeric value within the range of -10^9 to 10^9. - Handle scenarios where `data` might be an empty list. Example: ```python >>> aggregate_data([{\'a\': 5, \'b\': 10}, {\'a\': 15}, {\'b\': 20}, {\'a\': 10, \'b\': 5}], \'a\') {\'total\': 30, \'average\': 10.0, \'count\': 3} >>> aggregate_data([{}, {\'b\': 20}, {}], \'a\') {\'total\': 0, \'average\': 0, \'count\': 0} >>> aggregate_data([], \'a\') {\'total\': 0, \'average\': 0, \'count\': 0} ``` # Your task: 1. Implement the function `aggregate_data` with the required functionality. 2. Ensure that your function handles large datasets efficiently. 3. Process entries robustly, ignoring entries without the specified key. **Function signature**: ```python def aggregate_data(data: list, key: str) -> dict: pass ``` Note: - Do not use any external libraries for aggregation functions. - Provide a brief explanation of your strategy and how you handle edge cases and exceptions, such as entries missing the specified key.","solution":"def aggregate_data(data: list, key: str) -> dict: Aggregates the total, average, and count of a specified numeric key from the list of dictionaries. :param data: A list of dictionaries, each representing an entry. :param key: The key to aggregate from each dictionary. :return: A dictionary with \'total\', \'average\', and \'count\' of the specified key. total = 0 count = 0 for entry in data: if key in entry and isinstance(entry[key], (int, float)): total += entry[key] count += 1 average = total / count if count != 0 else 0 return {\'total\': total, \'average\': average, \'count\': count}"},{"question":"# Scenario You are enhancing a numerical computing library with a function that determines the Greatest Common Divisor (GCD) of two positive integers. This function will be useful in various numerical applications, such as simplifying fractions and implementing other mathematical algorithms. # Objective Write a Python function named `compute_gcd` that accepts two positive integers and returns their Greatest Common Divisor. The function should handle input validation and provide meaningful error messages for invalid inputs. # Function Signature ```python def compute_gcd(a: int, b: int) -> int: pass ``` # Input 1. `a` (int): A positive integer. 2. `b` (int): A positive integer. # Output * Returns an integer representing the Greatest Common Divisor of the two input values. # Constraints * Both input values `a` and `b` must be positive integers. # Requirements 1. The function should return a ValueError if either `a` or `b` is not a positive integer. 2. The function should return a TypeError if the inputs are not integers. # Examples ```python >>> compute_gcd(48, 18) 6 >>> compute_gcd(54, 24) 6 >>> compute_gcd(101, 10) 1 >>> compute_gcd(252, 105) 21 >>> compute_gcd(58, 64) 2 >>> compute_gcd(-48, 18) Traceback (most recent call last): ... ValueError: Inputs must be positive integers. >>> compute_gcd(48, 0) Traceback (most recent call last): ... ValueError: Inputs must be positive integers. >>> compute_gcd(48.5, 18) Traceback (most recent call last): ... TypeError: Inputs must be integers. >>> compute_gcd(\'48\', 18) Traceback (most recent call last): ... TypeError: \'<\' not supported between instances of \'str\' and \'int\' ``` # Notes * The Euclidean algorithm is an efficient method to compute the GCD. * The solution should manage large integer inputs efficiently. * Input edge cases should be handled appropriately, such as both inputs being the same. Provide well-documented code and include any assumptions made in your solution.","solution":"def compute_gcd(a: int, b: int) -> int: Compute the greatest common divisor (GCD) of two positive integers using the Euclidean algorithm. Parameters: a (int): A positive integer. b (int): A positive integer. Returns: int: The GCD of a and b. Raises: ValueError: If either of a or b is not a positive integer. TypeError: If the inputs are not integers. if not isinstance(a, int) or not isinstance(b, int): raise TypeError(\\"Inputs must be integers.\\") if a <= 0 or b <= 0: raise ValueError(\\"Inputs must be positive integers.\\") while b != 0: a, b = b, a % b return a"},{"question":"# Coding Task: Factorial Digit Sum Calculation **Objective**: Implement an algorithm to compute the sum of digits of the factorial of a given number `n`. Additionally, implement a method to check if a given number is equal to the sum of the digits of any factorial of a given `m`. Functions to Implement: 1. **`factorial_digit_sum(n: int) -> int`**: - **Input**: - `n` (Integer): The number for which the factorial\'s digit sum needs to be computed. - **Output**: - Returns the sum of the digits of the factorial of `n`. - **Constraints**: - `n` must be a non-negative integer. - **Exception Handling**: - Raise `ValueError` if `n` is negative. - Raise `TypeError` if `n` is not an integer. 2. **`is_sum_of_factorial_digits(m: int) -> bool`**: - **Input**: - `m` (Integer): The number to check if it is equal to the sum of the digits of the factorial of some integer. - **Output**: - Returns `True` if `m` is equal to the sum of the digits of the factorial of some integer, otherwise `False`. - **Constraints**: - `m` must be a non-negative integer. - **Exception Handling**: - Raise `ValueError` if `m` is negative. - Raise `TypeError` if `m` is not an integer. **Example Usages**: ```python assert factorial_digit_sum(5) == 3 # 5! = 120 and 1 + 2 + 0 = 3 assert factorial_digit_sum(10) == 27 # 10! = 3628800 and 3 + 6 + 2 + 8 + 8 + 0 + 0 = 27 assert is_sum_of_factorial_digits(27) == True # 27 is the sum of the digits of 10! assert is_sum_of_factorial_digits(100) == False # 100 is not the sum of the digits of any factorial ``` **Notes**: - Ensure that your code handles large input efficiently. - Provide appropriate documentation and doctests for each function. - Ensure precision and handle edge cases effectively. - Optimize the implementation where possible to manage large computations gracefully.","solution":"import math def factorial_digit_sum(n: int) -> int: Returns the sum of the digits of the factorial of n. :param n: Non-negative integer :return: Sum of digits of factorial of n :raises ValueError: If n is negative :raises TypeError: If n is not an integer if not isinstance(n, int): raise TypeError(\\"Input must be an integer.\\") if n < 0: raise ValueError(\\"Input must be a non-negative integer.\\") factorial_result = math.factorial(n) digit_sum = sum(int(digit) for digit in str(factorial_result)) return digit_sum def is_sum_of_factorial_digits(m: int) -> bool: Checks if m is equal to the sum of the digits of the factorial of some integer. :param m: Non-negative integer :return: True if m is equal to the sum of the digits of some factorial, otherwise False :raises ValueError: If m is negative :raises TypeError: If m is not an integer if not isinstance(m, int): raise TypeError(\\"Input must be an integer.\\") if m < 0: raise ValueError(\\"Input must be a non-negative integer.\\") current_n = 0 while True: current_sum = factorial_digit_sum(current_n) if current_sum == m: return True elif current_sum > m: return False current_n += 1"},{"question":"# Problem Statement: You are developing a system for managing a library of books and need to implement a functionality that determines the most popular author based on the number of books borrowed. # Requirements: Implement a function `find_most_popular_author(transactions: List[Tuple[str, str]]) -> str` that takes a list of tuples representing borrow transactions and returns the author whose books have been borrowed the most. Each transaction is represented by a tuple containing: - A string representing the book\'s title. - A string representing the book\'s author. If there are multiple authors with the highest number of books borrowed, return any one of them. # Input: - A list of tuples, where each tuple contains two strings. # Output: - A single string representing the most popular author. # Constraints: - The input list will contain at least one transaction. - The length of the input list won\'t exceed (10^5). - Each title and author string will have a length of up to 100 characters. # Example: ```python def find_most_popular_author(transactions: List[Tuple[str, str]]) -> str: pass # Example Usage: transactions = [ (\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\"), (\\"1984\\", \\"George Orwell\\"), (\\"To Kill a Mockingbird\\", \\"Harper Lee\\"), (\\"Animal Farm\\", \\"George Orwell\\"), (\\"The Catcher in the Rye\\", \\"J.D. Salinger\\") ] print(find_most_popular_author(transactions)) # Should output \\"George Orwell\\" transactions = [ (\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\"), (\\"1984\\", \\"George Orwell\\"), (\\"To Kill a Mockingbird\\", \\"Harper Lee\\"), (\\"The Catcher in the Rye\\", \\"J.D. Salinger\\"), (\\"Moby Dick\\", \\"Herman Melville\\") ] print(find_most_popular_author(transactions)) # Output could be any author since each has 1 transaction ``` # Note: - Ensure that the function handles large input efficiently. - In the event of a tie for the most popular author, any one of the tied authors can be returned.","solution":"from collections import Counter from typing import List, Tuple def find_most_popular_author(transactions: List[Tuple[str, str]]) -> str: Determines the most popular author based on the number of books borrowed. Args: transactions : List[Tuple[str, str]] A list of tuples each containing the book\'s title and the book\'s author. Returns: str The author whose books have been borrowed the most. if not transactions: return \\"\\" author_count = Counter(author for _, author in transactions) most_popular_author, _ = author_count.most_common(1)[0] return most_popular_author"},{"question":"Array Rotation Check # Scenario You are designing a function for a data preprocessing pipeline that involves determining if one array is a rotation of another. Given two arrays, you need to implement a function that checks if one array is a rotation of the other. # Task Write a function `is_rotation` that: 1. Takes two arrays `arr1` and `arr2`. 2. Checks if `arr2` is a rotation of `arr1`. # Function Signature ```python def is_rotation(arr1: List[int], arr2: List[int]) -> bool: ``` # Input - `arr1` (List[int]): The original array. - `arr2` (List[int]): The array to check if it is a rotation of `arr1`. # Output - Returns a boolean value: `True` if `arr2` is a rotation of `arr1`, `False` otherwise. # Constraints - The arrays will contain only integers. - The length of the arrays will not exceed 1000. - Both arrays will have the same length. # Examples ```python # Example 1 arr1 = [1, 2, 3, 4, 5] arr2 = [3, 4, 5, 1, 2] # arr2 is rotation of arr1 (rotated by 2 positions) assert is_rotation(arr1, arr2) == True # Example 2 arr1 = [1, 2, 3, 4, 5] arr2 = [4, 5, 1, 2, 3] # arr2 is rotation of arr1 (rotated by 3 positions) assert is_rotation(arr1, arr2) == True # Example 3 arr1 = [1, 2, 3, 4, 5] arr2 = [2, 3, 4, 5, 6] # arr2 is not a rotation of arr1 assert is_rotation(arr1, arr2) == False ``` # Note You should take advantage of the properties of arrays and string manipulation to implement an efficient solution.","solution":"from typing import List def is_rotation(arr1: List[int], arr2: List[int]) -> bool: if len(arr1) != len(arr2): return False concatenated = arr1 + arr1 str_arr2 = \'\'.join(map(str, arr2)) str_concatenated = \'\'.join(map(str, concatenated)) return str_arr2 in str_concatenated"},{"question":"# Coding Question: Determine If a String Has All Unique Characters As part of a new feature in your application, you need to validate if a given string has all unique characters. You have been asked to implement this feature efficiently. Function Signature: Implement the function `is_unique`: ```python def is_unique(s: str) -> bool: pass ``` Input: * `s`: A string consisting of lowercase and/or uppercase English letters. Output: * Returns `True` if all characters in the input string are unique, otherwise returns `False`. Constraints: * The input string `s` will have at least 1 character and at most 10^5 characters. Examples: ```python >>> is_unique(\\"abcdef\\") True >>> is_unique(\\"aabbcc\\") False >>> is_unique(\\"aAb\\") True ``` Explanation: 1. The string `\\"abcdef\\"` has all unique characters, so the function returns `True`. 2. The string `\\"aabbcc\\"` has repeated characters (\'a\', \'b\', \'c\'), so the function returns `False`. 3. The string `\\"aAb\\"` has unique characters considering case sensitivity, so the function returns `True`. Hint: Consider using data structures that can help track seen characters efficiently (e.g., sets or dictionaries).","solution":"def is_unique(s: str) -> bool: Check if all characters in the string are unique. Parameters: s (str): The input string consisting of lowercase and/or uppercase English letters. Returns: bool: True if all characters are unique; False otherwise. seen_chars = set() for char in s: if char in seen_chars: return False seen_chars.add(char) return True"},{"question":"# Binary Tree Mirror Reflection You are given a class `TreeNode` that represents a binary tree node and contains an integer value, and pointers to its left and right children. Your task is to implement a method to transform a given binary tree into its mirror reflection. # Problem Statement Implement the function `mirror_tree` to produce the mirror reflection of a binary tree. The mirror of a binary tree is another binary tree with the left and right children of all non-leaf nodes interchanged. # Constraints 1. The number of nodes in the tree is between 1 and 10,000. 2. The value of each node is an integer between -1000 and 1000. # Input Format ```plaintext - A reference to the root node of a binary tree. ``` # Output Format ```plaintext - A reference to the root node of the mirrored binary tree. ``` # Example Given a binary tree: ```plaintext 1 / 2 3 / 4 5 ``` After mirroring, the binary tree becomes: ```plaintext 1 / 3 2 / 5 4 ``` # Implementation Define the `TreeNode` class and complete the `mirror_tree` method as follows: 1. Swap the left and right child for each node in the tree. 2. Ensure that all nodes are visited and mirrored correctly. ```python class TreeNode: def __init__(self, val: int = 0, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.val = val self.left = left self.right = right def mirror_tree(root: TreeNode) -> TreeNode: if root is None: return None # Swap the left and right children root.left, root.right = root.right, root.left # Recursively apply mirror_tree to left and right subtrees if root.left: mirror_tree(root.left) if root.right: mirror_tree(root.right) return root ``` # Notes 1. The function should handle large trees efficiently. 2. Make sure that the original tree structure is appropriately transformed into its mirror reflection.","solution":"class TreeNode: def __init__(self, val: int = 0, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.val = val self.left = left self.right = right def mirror_tree(root: TreeNode) -> TreeNode: if root is None: return None # Swap the left and right children root.left, root.right = root.right, root.left # Recursively apply mirror_tree to left and right subtrees if root.left: mirror_tree(root.left) if root.right: mirror_tree(root.right) return root"},{"question":"# Problem Statement: Balanced Parentheses with Wildcards You are given a string `s` which contains only the characters `\'(\'`, `\')\'`, and `\'*\'`. Write a function to check whether it is possible to replace the wildcard characters `\'*\'` with `\'(\'`, `\')\'`, or an empty string such that the resulting string is a valid string of balanced parentheses. # Task Write a function `is_wildcard_balanced(s: str) -> bool` that returns `True` if the string can be balanced, and `False` otherwise. # Input - A single string `s` containing only `\'(\'`, `\')\'`, and `\'*\'`. (1 ≤ len(s) ≤ 100) # Output - `True` if it is possible to balance the string by replacing the wildcards. - `False` otherwise. # Example ```python def is_wildcard_balanced(s: str) -> bool: # Your code here print(is_wildcard_balanced(\\"(*))\\")) # Expected output: True print(is_wildcard_balanced(\\"(*)\\")) # Expected output: True print(is_wildcard_balanced(\\"(*)))\\")) # Expected output: False ``` # Constraints - Ensure your function runs efficiently with a reasonable performance for the given task. - Handle edge cases such as strings with sequential or nested wildcards. # Notes - A string of parentheses is balanced if every opening bracket `\'(\'` has a corresponding closing bracket `\')\'` and the pairs are appropriately nested. - The wildcard `\'*\'` can be replaced by either `\'(\'`, `\')\'`, or an empty string. [Question 3]:","solution":"def is_wildcard_balanced(s: str) -> bool: Checks if the given string with \'(\', \')\', and \'*\' can be balanced. Args: s (str): The input string containing \'(\', \')\', and \'*\'. Returns: bool: True if the string can be balanced, False otherwise. low = high = 0 for char in s: if char == \'(\': low += 1 high += 1 elif char == \')\': if low > 0: low -= 1 high -= 1 elif char == \'*\': if low > 0: low -= 1 high += 1 if high < 0: return False return low == 0"},{"question":"# Question: Spiral Matrix Transversal You are given an (n times n) matrix where each element has an integer value. Your task is to write a function `spiral_order` that returns the matrix elements in a spiral order traversal starting from the top-left corner. Function Signature ```python def spiral_order(matrix: List[List[int]]) -> List[int]: ``` Input - `matrix` (List[List[int]]): A list of lists representing an (n times n) matrix of integers (1 ≤ n ≤ 100). Output - Returns a list of integers representing the elements of the matrix in spiral order. Example ```python assert spiral_order([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [1, 2, 3, 6, 9, 8, 7, 4, 5] assert spiral_order([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]) == [1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10] ``` Explanation - For the first example, the spiral order traversal starts from element 1, moves to 2, 3, then down to 6, 9, goes left to 8, 7 and finally up to 4 and then inwards to 5. - For the second example, the traversal starts at 1, moves right to 2, 3, 4, then down to 8, 12, 16, moves left to 15, 14, 13, goes up to 9, goes inward to 5, 6, 7, 11, and finally 10. # Constraints: - The matrix will always have dimensions (n times n) where 1 ≤ n ≤ 100. - The elements of the matrix will be integers within the range ([-10^4, 10^4]).","solution":"from typing import List def spiral_order(matrix: List[List[int]]) -> List[int]: Returns the elements of matrix in spiral order. result = [] if not matrix: return result top, left = 0, 0 bottom, right = len(matrix) - 1, len(matrix[0]) - 1 while top <= bottom and left <= right: for i in range(left, right + 1): result.append(matrix[top][i]) top += 1 for i in range(top, bottom + 1): result.append(matrix[i][right]) right -= 1 if top <= bottom: for i in range(right, left - 1, -1): result.append(matrix[bottom][i]) bottom -= 1 if left <= right: for i in range(bottom, top - 1, -1): result.append(matrix[i][left]) left += 1 return result"},{"question":"# Scenario You are working on a large-scale e-commerce platform where personalization and recommendations are crucial for enhancing user experience. One common task is to recommend products to users based on their browsing history. Recently, you decide to implement a Suggestion Engine that recommends products based on similarity scores with previously viewed products. # Task Implement a `SuggestionEngine` class that accommodates efficient addition of viewed products and recommends similar products based on a simple cosine similarity measure between product feature vectors. # Detailed Requirements 1. **Class**: `SuggestionEngine` 2. **Method**: `add_product(self, product_id: str, features: List[float])` - Input: A string `product_id` representing the unique identifier of the product. A list `features` of floats representing the feature vector of the product. - Adds the product and its features to the suggestion engine. 3. **Method**: `recommend(self, viewed_products: List[str], top_k: int) -> List[str]` - Input: A list `viewed_products` of strings representing the product IDs that the user has viewed. An integer `top_k` representing the number of top recommendations to return. - Output: A list of `top_k` product IDs recommended based on the similarity to the viewed products. - The recommendation is based on the average similarity score computed by cosine similarity between the viewed products and all other products. # Constraints 1. The length of each feature vector will be the same. 2. The number of products `p` will be `1 <= p <= 10^5`. 3. Each feature vector length will be between 1 and 300. 4. Similarity computation should be efficient to handle large datasets. # Example Usage ```python engine = SuggestionEngine() # Add some products with their feature vectors engine.add_product(\\"product_1\\", [0.1, 0.2, 0.3]) engine.add_product(\\"product_2\\", [0.4, 0.0, 0.5]) engine.add_product(\\"product_3\\", [0.2, 0.3, 0.4]) engine.add_product(\\"product_4\\", [0.6, 0.7, 0.8]) # Recommend products similar to what the user has viewed recommended_products = engine.recommend([\\"product_1\\", \\"product_2\\"], 2) print(recommended_products) # Output should be the most similar product IDs ``` Provide the implementation of the `SuggestionEngine` class as per above requirements, including necessary helper functions and sufficient unittests to validate the correctness of the solution. Ensure high performance of similarity computations for large input data. # Helper Function: Cosine Similarity ```python import math def cosine_similarity(vec1: List[float], vec2: List[float]) -> float: dot_product = sum(x * y for x, y in zip(vec1, vec2)) magnitude1 = math.sqrt(sum(x ** 2 for x in vec1)) magnitude2 = math.sqrt(sum(x ** 2 for x in vec2)) if magnitude1 == 0 or magnitude2 == 0: return 0 return dot_product / (magnitude1 * magnitude2) ``` Insert your code for the `SuggestionEngine` class implementation and unittests below.","solution":"import math from typing import List, Dict def cosine_similarity(vec1: List[float], vec2: List[float]) -> float: dot_product = sum(x * y for x, y in zip(vec1, vec2)) magnitude1 = math.sqrt(sum(x ** 2 for x in vec1)) magnitude2 = math.sqrt(sum(x ** 2 for x in vec2)) if magnitude1 == 0 or magnitude2 == 0: return 0.0 return dot_product / (magnitude1 * magnitude2) class SuggestionEngine: def __init__(self): self.product_features: Dict[str, List[float]] = {} def add_product(self, product_id: str, features: List[float]): self.product_features[product_id] = features def recommend(self, viewed_products: List[str], top_k: int) -> List[str]: viewed_features = [self.product_features[pid] for pid in viewed_products if pid in self.product_features] if not viewed_features: return [] avg_viewed_features = [sum(feat) / len(viewed_features) for feat in zip(*viewed_features)] similarity_scores = [] for pid, features in self.product_features.items(): if pid not in viewed_products: similarity = cosine_similarity(avg_viewed_features, features) similarity_scores.append((pid, similarity)) similarity_scores.sort(key=lambda x: x[1], reverse=True) return [pid for pid, _ in similarity_scores[:top_k]]"},{"question":"# Coding Assessment Question Scenario You are contributing to the development of an automated system to categorize items in a large archive. As part of this effort, you need to implement a function that identifies whether a given year is a leap year. This function will assist in scheduling and categorization tasks that rely on date calculations. # Objective Implement the `is_leap_year` function that determines if a given year is a leap year in the Gregorian calendar. A year is a leap year if: - It is divisible by 4, and - If it is divisible by 100, it must also be divisible by 400 to be considered a leap year. # Function Signature ```python def is_leap_year(year: int) -> bool: pass ``` # Constraints - The year will always be a positive integer. - Ensure the function operates in O(1) time complexity and O(1) space complexity. # Input - `year` (int): A positive integer representing the year to be checked. # Output - (bool): A boolean value indicating whether the given year is a leap year. # Examples ```python assert is_leap_year(2000) == True assert is_leap_year(1900) == False assert is_leap_year(2004) == True assert is_leap_year(2001) == False assert is_leap_year(2020) == True assert is_leap_year(2100) == False ``` # Implementation Details 1. Implement the `is_leap_year` function that adheres to the specified behavior and constraints. 2. Create a test function `test_is_leap_year()` to verify the correctness of your implementation, covering normal cases and edge cases clearly. ```python def test_is_leap_year(): # Test general cases assert is_leap_year(2000) == True, \\"Test Case 1 Failed\\" assert is_leap_year(1900) == False, \\"Test Case 2 Failed\\" assert is_leap_year(2004) == True, \\"Test Case 3 Failed\\" assert is_leap_year(2001) == False, \\"Test Case 4 Failed\\" assert is_leap_year(2020) == True, \\"Test Case 5 Failed\\" assert is_leap_year(2100) == False, \\"Test Case 6 Failed\\" print(\\"All test cases pass\\") ```","solution":"def is_leap_year(year: int) -> bool: Determines if a given year is a leap year. if year % 4 == 0: if year % 100 == 0: if year % 400 == 0: return True else: return False else: return True else: return False"}]'),S={name:"App",components:{PoemCard:C},data(){return{searchQuery:"",visibleCount:4,poemsData:N,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},F={class:"search-container"},L={class:"card-container"},O={key:0,class:"empty-state"},R=["disabled"],P={key:0},D={key:1};function z(r,e,l,p,s,a){const m=g("PoemCard");return n(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",F,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[y,s.searchQuery]]),s.searchQuery?(n(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")}," ✕ ")):u("",!0)]),t("div",L,[(n(!0),i(b,null,v(a.displayedPoems,(o,f)=>(n(),w(m,{key:f,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),i("div",O,' No results found for "'+d(s.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(n(),i("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),i("span",D,"Loading...")):(n(),i("span",P,"See more"))],8,R)):u("",!0)])}const Y=h(S,[["render",z],["__scopeId","data-v-f353bbce"]]),B=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"drive/29.md","filePath":"drive/29.md"}'),j={name:"drive/29.md"},V=Object.assign(j,{setup(r){return(e,l)=>(n(),i("div",null,[x(Y)]))}});export{B as __pageData,V as default};
