import{_ as d,o as s,c as n,a as t,m as _,t as m,C as h,M as g,U as b,f as l,F as y,p as x,e as v,q as w}from"./chunks/framework.B1z0IdBH.js";const q={name:"PoemCard",props:{poem:{type:Object,required:!0}}},k={class:"poem-container"},L={class:"review"},T={class:"review-title"},N={class:"review-content"};function E(i,e,u,c,r,a){return s(),n("div",k,[t("div",L,[t("div",T,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),_(m(u.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",N,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),_(m(u.poem.solution),1)])])])}const R=d(q,[["render",E],["__scopeId","data-v-8df4f779"]]),A=JSON.parse(`[{"question":"def transform_durations(n, durations): Transforms the list so that any duration that exceeds 60 seconds is replaced by 60 seconds. Parameters: n (int): Number of durations durations (List[int]): List of message durations Returns: List[int]: Transformed list of durations >>> transform_durations(5, [45, 67, 120, 30, 90]) [45, 60, 60, 30, 60] >>> transform_durations(3, [15, 10, 5]) [15, 10, 5]","solution":"def transform_durations(n, durations): Transforms the list so that any duration that exceeds 60 seconds is replaced by 60 seconds. Parameters: n (int): Number of durations durations (List[int]): List of message durations Returns: List[int]: Transformed list of durations return [min(duration, 60) for duration in durations]"},{"question":"def find_min_street_lamps(n: int, roads: List[Tuple[int, int, int]], max_time: int) -> int: Determine the minimum number of street lamps required so that every intersection in the city is adequately lit. >>> find_min_street_lamps(4, [(1, 2, 2), (2, 3, 4), (3, 4, 1), (4, 1, 3)], 3) == 2 >>> find_min_street_lamps(1, [], 1) == 1 >>> find_min_street_lamps(5, [(1, 2, 1), (1, 3, 1), (1, 4, 1), (1, 5, 1), (2, 3, 1), (2, 4, 1), (2, 5, 1), (3, 4, 1), (3, 5, 1), (4, 5, 1)], 1) == 1 >>> find_min_street_lamps(6, [(1, 2, 1), (3, 4, 1), (5, 6, 1)], 1) == 3","solution":"import heapq def dijkstra(n, graph, start, max_time): distances = [float('inf')] * n distances[start] = 0 min_heap = [(0, start)] while min_heap: current_distance, u = heapq.heappop(min_heap) if current_distance > distances[u]: continue for v, weight in graph[u]: distance = current_distance + weight if distance < distances[v]: distances[v] = distance heapq.heappush(min_heap, (distance, v)) return [i for i in range(n) if distances[i] <= max_time] def find_min_street_lamps(n, roads, max_time): graph = [[] for _ in range(n)] for u, v, w in roads: graph[u-1].append((v-1, w)) graph[v-1].append((u-1, w)) all_intersections = set(range(n)) street_lamps = 0 while all_intersections: u = all_intersections.pop() reachable = set(dijkstra(n, graph, u, max_time)) all_intersections -= reachable street_lamps += 1 return street_lamps def solution(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) m = int(data[1]) roads = [] index = 2 for _ in range(m): u, v, w = map(int, (data[index], data[index+1], data[index+2])) roads.append((u, v, w)) index += 3 max_time = int(data[index]) print(find_min_street_lamps(n, roads, max_time))"},{"question":"def is_valid_parentheses(s: str) -> bool: Determine if the input string containing only '(' and ')' is a valid parentheses string. >>> is_valid_parentheses(\\"()\\") == True >>> is_valid_parentheses(\\"(())\\") == True >>> is_valid_parentheses(\\"((()()))\\") == True >>> is_valid_parentheses(\\"(((((())))))\\") == True","solution":"def is_valid_parentheses(s): Determine if the input string containing only '(' and ')' is a valid parentheses string. Args: s (str): Input string containing only '(' and ')'. Returns: bool: True if the string is a valid parentheses string, False otherwise. stack = [] for char in s: if char == '(': stack.append(char) elif char == ')': if not stack: return False stack.pop() return not stack # The stack should be empty if the string is valid"},{"question":"from typing import List def largest_identical_square(matrix: List[List[int]]) -> int: Implement a function that, given a matrix of integers, returns the size of the largest square submatrix which contains all identical elements. >>> largest_identical_square([[1]]) == 1 >>> largest_identical_square([ ... [2, 2, 3, 4], ... [5, 2, 2, 2], ... [9, 2, 2, 2], ... [7, 7, 7, 7] ... ]) == 2 >>> largest_identical_square([ ... [1, 2], ... [3, 4] ... ]) == 1 >>> largest_identical_square([ ... [2, 2, 2], ... [2, 2, 2], ... [2, 2, 2] ... ]) == 3 >>> largest_identical_square([[1]*500 for _ in range(500)]) == 500","solution":"from typing import List def largest_identical_square(matrix: List[List[int]]) -> int: if not matrix or not matrix[0]: return 0 nrows = len(matrix) ncols = len(matrix[0]) dp = [[0] * ncols for _ in range(nrows)] max_square_size = 1 for i in range(nrows): for j in range(ncols): if i == 0 or j == 0: dp[i][j] = 1 else: if matrix[i][j] == matrix[i-1][j] and matrix[i][j] == matrix[i][j-1] and matrix[i][j] == matrix[i-1][j-1]: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 else: dp[i][j] = 1 max_square_size = max(max_square_size, dp[i][j]) return max_square_size"},{"question":"def largest_min_distance(n: int, k: int, positions: List[int]) -> int: Function to determine the largest possible minimum distance between any two chests when exactly k chests are hidden along the trail at n possible positions. >>> largest_min_distance(5, 3, [1, 2, 8, 4, 9]) == 3 >>> largest_min_distance(5, 2, [1, 2, 3, 4, 5]) == 4 >>> largest_min_distance(4, 2, [1, 2, 3, 4]) == 3 >>> largest_min_distance(3, 2, [1, 100000000, 200000000]) == 199999999 >>> largest_min_distance(5, 3, [1, 3, 6, 9, 12]) == 5","solution":"def largest_min_distance(n, k, positions): Function to determine the largest possible minimum distance between any two chests when exactly k chests are hidden along the trail at n possible positions. positions.sort() def is_possible(min_dist): count = 1 last_position = positions[0] for i in range(1, n): if positions[i] - last_position >= min_dist: count += 1 last_position = positions[i] if count == k: return True return False low, high = 1, positions[-1] - positions[0] best_dist = 0 while low <= high: mid = (low + high) // 2 if is_possible(mid): best_dist = mid low = mid + 1 else: high = mid - 1 return best_dist"},{"question":"def min_weights(n: int) -> int: Find the minimum number of weights needed to measure every weight from 1 to the given input weight n using powers of 3. Example: >>> min_weights(17) 3 >>> min_weights(40) 4","solution":"def min_weights(n): Find the minimum number of weights needed to measure every weight from 1 to the given input weight n using powers of 3. weights = [] current_weight = 1 while current_weight <= n: weights.append(current_weight) current_weight *= 3 return len(weights)"},{"question":"def lexicographically_smallest_after_swap(n: int, arr: List[int]) -> List[int]: Determine the lexicographically smallest array after exactly one swap. Parameters: n (int): The number of elements in the array. arr (list): The array of non-negative integers. Returns: list: The lexicographically smallest array. >>> lexicographically_smallest_after_swap(5, [3, 2, 1, 5, 4]) [1, 2, 3, 5, 4] >>> lexicographically_smallest_after_swap(6, [1, 9, 8, 7, 6, 5]) [1, 5, 8, 7, 6, 9]","solution":"def lexicographically_smallest_after_swap(n, arr): Determine the lexicographically smallest array after exactly one swap. Parameters: n (int): The number of elements in the array. arr (list): The array of non-negative integers. Returns: list: The lexicographically smallest array. sorted_arr = sorted(arr) for i in range(n): if arr[i] != sorted_arr[i]: swap_pos = arr.index(sorted_arr[i]) # Perform the swap to get the smallest lexicographical order arr[i], arr[swap_pos] = arr[swap_pos], arr[i] break return arr"},{"question":"def total_cells_in_grid(N: int, M: int) -> int: Computes the total number of cells in a grid with N rows and M columns. :param N: Number of rows, 1 <= N <= 100 :param M: Number of columns, 1 <= M <= 100 :return: Total number of cells in the grid >>> total_cells_in_grid(3, 4) 12 >>> total_cells_in_grid(5, 5) 25 >>> total_cells_in_grid(1, 10) 10","solution":"def total_cells_in_grid(N, M): Computes the total number of cells in a grid with N rows and M columns. :param N: Number of rows, 1 <= N <= 100 :param M: Number of columns, 1 <= M <= 100 :return: Total number of cells in the grid return N * M"},{"question":"def inverted_right_triangle(N: int): Prints an inverted right triangle of height N using the '*' character. :param N: int >>> inverted_right_triangle(5) ***** **** *** ** * >>> inverted_right_triangle(3) *** ** *","solution":"def inverted_right_triangle(N): Prints an inverted right triangle of height N using '*' character. :param N: int for i in range(N, 0, -1): print('*' * i)"},{"question":"def unique_palindromic_substrings(S: str) -> int: Given a string S consisting of lowercase English letters, determine the number of unique \\"substring palindromes\\" in S. A \\"substring palindrome\\" is a contiguous substring of S that reads the same backwards as forwards. >>> unique_palindromic_substrings(\\"ababa\\") 5 >>> unique_palindromic_substrings(\\"aaaa\\") 4 >>> unique_palindromic_substrings(\\"abc\\") 3 >>> unique_palindromic_substrings(\\"a\\") 1 >>> unique_palindromic_substrings(\\"abac\\") 4 from solution import unique_palindromic_substrings def test_palindromic_substrings_example(): assert unique_palindromic_substrings(\\"ababa\\") == 5 def test_single_character_string(): assert unique_palindromic_substrings(\\"a\\") == 1 def test_all_unique_characters(): assert unique_palindromic_substrings(\\"abc\\") == 3 def test_repeated_characters(): assert unique_palindromic_substrings(\\"aaa\\") == 3 def test_mixed_characters(): assert unique_palindromic_substrings(\\"abac\\") == 4 def test_no_palindrome(): assert unique_palindromic_substrings(\\"abcd\\") == 4","solution":"def unique_palindromic_substrings(S: str) -> int: Returns the number of unique palindromic substrings in the given string S. def is_palindrome(s): return s == s[::-1] palindromic_substrings = set() for i in range(len(S)): for j in range(i + 1, len(S) + 1): substring = S[i:j] if is_palindrome(substring): palindromic_substrings.add(substring) return len(palindromic_substrings)"},{"question":"def calculate_heights_after_days(k: int, d: int, initial_heights: List[int], growth_rates: List[int]) -> List[int]: Calculates the height of each plant after a specified number of days. Parameters: k (int): Number of plants. d (int): Number of days. initial_heights (List[int]): List of initial heights of each plant. growth_rates (List[int]): List of growth rates (per day) of each plant. Returns: List[int]: List of heights after d days. Examples: >>> calculate_heights_after_days(3, 10, [5, 3, 7], [2, 1, 3]) [25, 13, 37] >>> calculate_heights_after_days(3, 10, [5, 3, 7], [0, 0, 0]) [5, 3, 7] >>> calculate_heights_after_days(3, 2, [5, 3, 7], [2, 1, 3]) [9, 5, 13]","solution":"def calculate_heights_after_days(k, d, initial_heights, growth_rates): Calculates the height of each plant after a specified number of days. Parameters: k (int): Number of plants. d (int): Number of days. initial_heights (list): List of initial heights of each plant. growth_rates (list): List of growth rates (per day) of each plant. Returns: list: List of heights after d days. final_heights = [] for i in range(k): final_height = initial_heights[i] + growth_rates[i] * d final_heights.append(final_height) return final_heights"},{"question":"def check_permutation_in_substring(S: str, T: str) -> bool: Determines if a permutation of S exists as a substring of T. >>> check_permutation_in_substring(\\"abc\\", \\"cbabadcbbabbcbabaabccbabc\\") True >>> check_permutation_in_substring(\\"hello\\", \\"world\\") False from collections import Counter def test_sample_input_1(): S = \\"abc\\" T = \\"cbabadcbbabbcbabaabccbabc\\" assert check_permutation_in_substring(S, T) == True def test_sample_input_2(): S = \\"hello\\" T = \\"world\\" assert check_permutation_in_substring(S, T) == False def test_example_1(): S = \\"a\\" T = \\"a\\" assert check_permutation_in_substring(S, T) == True def test_example_2(): S = \\"abc\\" T = \\"def\\" assert check_permutation_in_substring(S, T) == False def test_example_3(): S = \\"ab\\" T = \\"eidbaooo\\" assert check_permutation_in_substring(S, T) == True def test_example_4(): S = \\"ab\\" T = \\"eidboaoo\\" assert check_permutation_in_substring(S, T) == False def test_example_5(): S = \\"abcd\\" T = \\"dcbaebcaedcab\\" assert check_permutation_in_substring(S, T) == True","solution":"def check_permutation_in_substring(S, T): Determines if a permutation of S exists as a substring of T. from collections import Counter len_s = len(S) counter_s = Counter(S) for i in range(len(T) - len_s + 1): substring = T[i:i+len_s] if Counter(substring) == counter_s: return True return False"},{"question":"class Library: A library management system to handle shelves and books. The system allows adding shelves, adding books, and querying the number of books on a specific shelf. Example: >>> lib = Library() >>> lib.add_shelf(10, 20) >>> lib.add_shelf(15, 25) >>> lib.add_book(12) >>> lib.add_book(17) >>> lib.query_shelf(1) 2 >>> lib.query_shelf(2) 1 def __init__(self): # Initialize the library system pass def add_shelf(self, l: int, r: int): Add a shelf with a range of book serial numbers. pass def add_book(self, s: int): Add a book with a specific serial number. pass def query_shelf(self, i: int) -> int: Query the number of books on the i-th shelf. pass","solution":"class Library: def __init__(self): self.shelves = [] self.book_count = [] self.books = set() def add_shelf(self, l, r): self.shelves.append((l, r)) self.book_count.append(0) # Update book count for the new shelf for book in self.books: if l <= book <= r: self.book_count[-1] += 1 def add_book(self, s): self.books.add(s) # Update book counts for all shelves for i, (l, r) in enumerate(self.shelves): if l <= s <= r: self.book_count[i] += 1 def query_shelf(self, i): return self.book_count[i - 1]"},{"question":"def can_split_into_k_consecutive_subarrays(n: int, k: int, arr: List[int]) -> str: Determines if the array can be split into k consecutive subarrays of equal sum. Args: n: int : The number of elements in the array k: int : The number of required subarrays arr: List[int] : The array of positive integers Returns: str : \\"YES\\" if it is possible to split the array into k consecutive subarrays with equal sum, otherwise \\"NO\\". >>> can_split_into_k_consecutive_subarrays(6, 3, [2, 2, 2, 2, 2, 2]) 'YES' >>> can_split_into_k_consecutive_subarrays(6, 2, [1, 2, 3, 4, 5, 6]) 'NO'","solution":"def can_split_into_k_consecutive_subarrays(n, k, arr): Determines if the array can be split into k consecutive subarrays of equal sum. Args: n : int : The number of elements in the array k : int : The number of required subarrays arr : List[int] : The array of positive integers Returns: str : \\"YES\\" if it is possible to split the array into k consecutive subarrays with equal sum, otherwise \\"NO\\". if n % k != 0: return \\"NO\\" target_sum = sum(arr) // k current_sum = 0 subarray_count = 0 for num in arr: current_sum += num if current_sum == target_sum: subarray_count += 1 current_sum = 0 elif current_sum > target_sum: return \\"NO\\" return \\"YES\\" if subarray_count == k else \\"NO\\""},{"question":"from typing import List, Tuple def longest_simple_path(n: int, roads: List[Tuple[int, int]]) -> int: Compute the length of the longest simple path in the given network of intersections and roads. Parameters: n (int): The number of intersections. roads (List[Tuple[int, int]]): List of roads where each road is represented by a tuple of two integers. Returns: int: The length of the longest simple path. Examples: >>> longest_simple_path(4, [(1, 2), (1, 3), (3, 4)]) 3 >>> longest_simple_path(2, [(1, 2)]) 1 >>> longest_simple_path(5, [(1, 2), (2, 3), (3, 4), (4, 5)]) 4 >>> longest_simple_path(5, [(1, 2), (1, 3), (1, 4), (1, 5)]) 2 >>> longest_simple_path(7, [(1, 2), (2, 3), (3, 4), (4, 5), (2, 6), (6, 7)]) 5 pass","solution":"from collections import defaultdict, deque def longest_simple_path(n, roads): # Create an adjacency list graph = defaultdict(list) for u, v in roads: graph[u].append(v) graph[v].append(u) # Function to perform BFS and return the furthest node and its distance def bfs(start): visited = [-1] * (n + 1) queue = deque([(start, 0)]) visited[start] = 0 farthest_node = start max_distance = 0 while queue: node, dist = queue.popleft() if dist > max_distance: max_distance = dist farthest_node = node for neighbor in graph[node]: if visited[neighbor] == -1: visited[neighbor] = dist + 1 queue.append((neighbor, dist + 1)) return farthest_node, max_distance # Perform BFS from an arbitrary node (1) to find one end of the longest path far_node_1, _ = bfs(1) # Perform BFS from this farthest node to find the maximum distance in the network _, max_distance = bfs(far_node_1) return max_distance # Example usage: n = 4 roads = [(1, 2), (1, 3), (3, 4)] print(longest_simple_path(n, roads)) # Output should be 3"},{"question":"def count_trailing_zeros(n: int) -> int: Returns the number of trailing zeros in the factorial of n. >>> count_trailing_zeros(10) 2 >>> count_trailing_zeros(25) 6 >>> count_trailing_zeros(0) 0 def process_input(data_sets: List[int]) -> List[int]: Processes the list of data sets and returns the results as a list of number of trailing zeros for each set. >>> process_input([10, 25]) [2, 6] >>> process_input([0, 5, 50]) [0, 1, 12] >>> process_input([125, 130]) [31, 32]","solution":"def count_trailing_zeros(n): Returns the number of trailing zeros in the factorial of n. count = 0 while n >= 5: n //= 5 count += n return count def process_input(data_sets): Processes the list of data sets and returns the results as a list of number of trailing zeros for each set. results = [] for n in data_sets: results.append(count_trailing_zeros(n)) return results # Example usage: # data_sets = [10, 25] # print(process_input(data_sets)) # Output: [2, 6]"},{"question":"def range_sum(arr, queries): Returns the sum of the elements in the array for each range specified in the queries. Parameters: arr (list): List of integers representing the array. queries (list): List of tuples, where each tuple consists of two integers (L, R) representing the range. Returns: list : List of integers representing the sum for each query. from solution import range_sum def test_range_sum_example(): arr = [1, 2, 3, 4, 5] queries = [(0, 2), (1, 3), (0, 4)] assert range_sum(arr, queries) == [6, 9, 15] def test_range_sum_single_element_ranges(): arr = [5, 1, 7, 3, -2, 4] queries = [(0, 0), (1, 1), (2, 2)] assert range_sum(arr, queries) == [5, 1, 7] def test_range_sum_all_elements_same(): arr = [3, 3, 3, 3, 3] queries = [(0, 4), (0, 0), (1, 3)] assert range_sum(arr, queries) == [15, 3, 9] def test_range_sum_negative_numbers(): arr = [-1, -2, -3, -4, -5] queries = [(0, 2), (1, 4), (0, 4)] assert range_sum(arr, queries) == [-6, -14, -15] def test_range_sum_mixed_numbers(): arr = [2, -1, 3, -4, 5] queries = [(0, 1), (2, 4), (1, 3)] assert range_sum(arr, queries) == [1, 4, -2]","solution":"def range_sum(arr, queries): Returns the sum of the elements in the array for each range specified in the queries. Parameters: arr (list): List of integers representing the array. queries (list): List of tuples, where each tuple consists of two integers (L, R) representing the range. Returns: list : List of integers representing the sum for each query. prefix_sums = [0] * (len(arr) + 1) for i in range(1, len(arr) + 1): prefix_sums[i] = prefix_sums[i - 1] + arr[i - 1] results = [] for L, R in queries: results.append(prefix_sums[R + 1] - prefix_sums[L]) return results # Example usage: # N, Q = 5, 3 # arr = [1, 2, 3, 4, 5] # queries = [(0, 2), (1, 3), (0, 4)] # print(range_sum(arr, queries)) # Output: [6, 9, 15]"},{"question":"def min_edges_to_remove(n: int, m: int, edges: List[Tuple[int, int, int]]) -> int: Return the minimum number of edges to remove to split the graph into two connected components. :param n: Number of vertices :param m: Number of edges :param edges: List of edges (u, v, w) :return: Minimum number of edges to remove >>> min_edges_to_remove(4, 4, [(1, 2, 1), (2, 3, 2), (3, 4, 1), (4, 1, 3)]) == 1 >>> min_edges_to_remove(5, 6, [(1, 2, 5), (2, 3, 3), (3, 4, 4), (4, 5, 2), (5, 1, 6), (2, 5, 1)]) == 1 >>> min_edges_to_remove(3, 2, [(1, 2, 1), (2, 3, 2)]) == 1 >>> min_edges_to_remove(2, 1, [(1, 2, 0)]) == 1 >>> min_edges_to_remove(6, 7, [(1, 2, 2), (2, 3, 3), (3, 4, 1), (4, 5, 2), (5, 6, 4), (6, 1, 5), (1, 4, 3)]) == 1 >>> min_edges_to_remove(3, 3, [(1, 2, 1), (2, 3, 1), (1, 3, 1)]) == 1 pass","solution":"from heapq import heapify, heappop from collections import defaultdict def min_edges_to_remove(n, m, edges): Return the minimum number of edges to remove to split the graph into two connected components. :param n: Number of vertices :param m: Number of edges :param edges: List of edges (u, v, w) :return: Minimum number of edges to remove # Function to find the representative of a node def find_parent(parent, u): if parent[u] == u: return u parent[u] = find_parent(parent, parent[u]) return parent[u] # Function to unite two sets def union(parent, rank, u, v): root_u = find_parent(parent, u) root_v = find_parent(parent, v) if root_u != root_v: if rank[root_u] > rank[root_v]: parent[root_v] = root_u elif rank[root_u] < rank[root_v]: parent[root_u] = root_v else: parent[root_v] = root_u rank[root_u] += 1 # Initialize parent and rank arrays parent = list(range(n + 1)) rank = [0] * (n + 1) # Sort the edges based on their weights edges.sort(key=lambda x: x[2]) # Kruskal's Algorithm to use Minimum Spanning Tree technique mst_edges = [] for u, v, w in edges: if find_parent(parent, u) != find_parent(parent, v): union(parent, rank, u, v) mst_edges.append((u, v, w)) # The maximum weight edge in the MST is the answer if len(mst_edges) == 0: return 0 return 1"},{"question":"def sort_files(test_cases): Sorts the files based on the given criteria which can be either 'name' or 'size'. Args: test_cases (list): A list of dictionaries where each dictionary represents a test case containing number_of_files (int), files (list of tuples), and criterion (str). Returns: list: Sorted list of file names for each test case according to the given criteria. Example: >>> test_cases = [ >>> { >>> 'number_of_files': 3, >>> 'files': [('FileA', 10), ('fileb', 8), ('fileC', 15)], >>> 'criterion': 'name' >>> }, >>> { >>> 'number_of_files': 2, >>> 'files': [('alpha', 20), ('Beta', 15)], >>> 'criterion': 'size' >>> } >>> ] >>> sort_files(test_cases) [['FileA', 'fileb', 'fileC'], ['Beta', 'alpha']]","solution":"def sort_files(test_cases): results = [] for case in test_cases: N = case['number_of_files'] files = case['files'] criterion = case['criterion'] if criterion == 'name': files.sort(key=lambda x: x[0].lower()) elif criterion == 'size': files.sort(key=lambda x: (x[1], x[0].lower())) result = [file[0] for file in files] results.append(result) return results"},{"question":"def longest_valid_code_length(codes): Returns the length of the longest valid secret code that is a palindrome. If there are multiple codes with the same maximum length, returns the smallest one. If no valid code is found, returns -1. >>> longest_valid_code_length([\\"12321\\"]) 5 >>> longest_valid_code_length([\\"12345\\", \\"6789\\"]) -1 >>> longest_valid_code_length([\\"12321\\", \\"12345\\", \\"45654\\", \\"6789\\"]) 5 >>> longest_valid_code_length([\\"12321\\", \\"45654\\", \\"78987\\", \\"123\\", \\"32123\\"]) 5 >>> longest_valid_code_length([]) -1 >>> longest_valid_code_length([\\"000\\", \\"0000\\", \\"1110\\", \\"0110\\"]) 4","solution":"def longest_valid_code_length(codes): Returns the length of the longest valid secret code that is a palindrome. If there are multiple codes with the same maximum length, returns the smallest one. If no valid code is found, returns -1. valid_codes = [code for code in codes if code == code[::-1]] if not valid_codes: return -1 longest_code = max(valid_codes, key=lambda x: (len(x), int(x))) return len(longest_code) # Example usage # N = 5 # codes = [\\"12321\\", \\"45654\\", \\"78987\\", \\"12345\\", \\"6789\\"] # print(longest_valid_code_length(codes)) # Output: 5"},{"question":"def is_balanced(string: str) -> str: Determines if a given string with brackets and alphanumeric characters is balanced. >>> is_balanced(\\"{[a + (b + c)] + (d + e)}\\") \\"Yes\\" >>> is_balanced(\\"((()))\\") \\"Yes\\" >>> is_balanced(\\"{a + b * c) + (d + e}\\") \\"No\\" >>> is_balanced(\\"[(])\\") \\"No\\" >>> is_balanced(\\"\\") \\"Yes\\"","solution":"def is_balanced(string): Determines if a given string with brackets and alphanumeric characters is balanced. stack = [] opening = {'(': ')', '{': '}', '[': ']'} closing = {')': '(', '}': '{', ']': '['} for char in string: if char in opening: stack.append(char) elif char in closing: if stack and stack[-1] == closing[char]: stack.pop() else: return \\"No\\" return \\"Yes\\" if not stack else \\"No\\""},{"question":"def smallest_subarray_with_sum_at_least_k(n: int, k: int, scores: List[int]) -> Union[int, Tuple[int, List[int]]]: Find the smallest sub-array (contiguous segment) of scores such that the sum of its elements is >= k. If no such sub-array exists, return -1. Args: n (int): the number of training sessions k (int): the threshold scores (List[int]): list of integers representing the scores Returns: Union[int, Tuple[int, List[int]]]: If a sub-array exists, return a tuple containing the length of the smallest sub-array and the sub-array itself. If no such sub-array exists, return -1. Examples: >>> smallest_subarray_with_sum_at_least_k(10, 15, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) (2, [8, 9]) >>> smallest_subarray_with_sum_at_least_k(3, 15, [1, 2, 3]) -1","solution":"def smallest_subarray_with_sum_at_least_k(n, k, scores): min_length = float('inf') start = 0 current_sum = 0 subarray = [] for end in range(n): current_sum += scores[end] while current_sum >= k: if (end - start + 1) < min_length: min_length = end - start + 1 subarray = scores[start:end+1] current_sum -= scores[start] start += 1 if min_length == float('inf'): return -1 else: return (min_length, subarray)"},{"question":"import heapq from typing import List, Tuple, Union def find_min_toll_fee(n: int, m: int, b: int, highways: List[Tuple[int, int, int]], c1: int, c2: int) -> Union[int, str]: Determine the minimum toll fee required for Lisa to travel from city c1 to city c2 without exceeding her budget. >>> find_min_toll_fee(6, 7, 10, [(1, 2, 2), (2, 3, 3), (3, 4, 4), (4, 5, 3), (5, 6, 2), (1, 3, 5), (3, 6, 4)], 1, 6) 9 >>> find_min_toll_fee(4, 3, 5, [(1, 2, 3), (2, 3, 4), (3, 4, 5)], 1, 4) 'IMPOSSIBLE' pass # Test cases to validate the solution def test_find_min_toll_fee(): n, m, b = 6, 7, 10 highways = [(1, 2, 2), (2, 3, 3), (3, 4, 4), (4, 5, 3), (5, 6, 2), (1, 3, 5), (3, 6, 4)] c1, c2 = 1, 6 assert find_min_toll_fee(n, m, b, highways, c1, c2) == 9 n, m, b = 4, 3, 5 highways = [(1, 2, 3), (2, 3, 4), (3, 4, 5)] c1, c2 = 1, 4 assert find_min_toll_fee(n, m, b, highways, c1, c2) == \\"IMPOSSIBLE\\" n, m, b = 3, 0, 10 highways = [] c1, c2 = 1, 3 assert find_min_toll_fee(n, m, b, highways, c1, c2) == \\"IMPOSSIBLE\\" n, m, b = 3, 1, 10 highways = [(1, 3, 6)] c1, c2 = 1, 3 assert find_min_toll_fee(n, m, b, highways, c1, c2) == 6 n, m, b = 3, 2, 5 highways = [(1, 2, 4), (2, 3, 5)] c1, c2 = 1, 3 assert find_min_toll_fee(n, m, b, highways, c1, c2) == \\"IMPOSSIBLE\\"","solution":"import heapq def find_min_toll_fee(n, m, b, highways, c1, c2): # Graph represented as adjacency list graph = {i: [] for i in range(1, n+1)} for u, v, t in highways: graph[u].append((v, t)) graph[v].append((u, t)) # Min-heap to perform Dijkstra's algorithm pq = [(0, c1)] # (cost, city) min_cost = {i: float('inf') for i in range(1, n+1)} min_cost[c1] = 0 while pq: current_cost, u = heapq.heappop(pq) if current_cost > b: continue # Ignore if the cost exceeds budget if u == c2: return current_cost for v, toll in graph[u]: new_cost = current_cost + toll if new_cost < min_cost[v]: min_cost[v] = new_cost heapq.heappush(pq, (new_cost, v)) return \\"IMPOSSIBLE\\" # Example usage: # n, m, b = 6, 7, 10 # highways = [(1, 2, 2), (2, 3, 3), (3, 4, 4), (4, 5, 3), (5, 6, 2), (1, 3, 5), (3, 6, 4)] # c1, c2 = 1, 6 # print(find_min_toll_fee(n, m, b, highways, c1, c2)) # Output should be 9"},{"question":"from typing import List, Tuple def preprocess_primes(limit: int): Preprocess primes using the Sieve of Eratosthenes up to the given limit. Returns a boolean list indicating prime status and a list of prime counts. pass def count_primes_in_range(l: int, r: int, prime_sieve: List[bool], prime_counts: List[int]) -> int: Returns the count of prime numbers between l and r, inclusive. prime_sieve: list of booleans where prime_sieve[i] is True if i is a prime number prime_counts: list where prime_counts[i] is the number of prime numbers <= i pass def process_queries(queries: List[Tuple[int, int]], prime_sieve: List[bool], prime_counts: List[int]) -> List[int]: Processes a list of queries and returns the results. pass import pytest def test_preprocess_primes(): sieve, prime_counts = preprocess_primes(30) assert sieve[2] == True assert sieve[3] == True assert sieve[4] == False assert sieve[29] == True assert prime_counts[10] == 4 assert prime_counts[19] == 8 assert prime_counts[30] == 10 def test_process_queries(): sieve, prime_counts = preprocess_primes(1000000) queries = [ (1, 10), (11, 19), (20, 30) ] expected_outputs = [4, 4, 2] assert process_queries(queries, sieve, prime_counts) == expected_outputs def test_large_range_queries(): sieve, prime_counts = preprocess_primes(1000000) queries = [ (1, 1000000), (1, 500000), (500000, 1000000), (10000, 20000) ] expected_outputs = [ prime_counts[1000000] - prime_counts[0], prime_counts[500000] - prime_counts[0], prime_counts[1000000] - prime_counts[499999], prime_counts[20000] - prime_counts[9999] ] assert process_queries(queries, sieve, prime_counts) == expected_outputs if __name__ == \\"__main__\\": pytest.main()","solution":"def count_primes_in_range(l, r, prime_sieve, prime_counts): Returns the count of prime numbers between l and r, inclusive. prime_sieve: list of booleans where prime_sieve[i] is True if i is a prime number prime_counts: list where prime_counts[i] is the number of prime numbers <= i return prime_counts[r] - prime_counts[l - 1] def preprocess_primes(limit=1000000): Preprocess primes using the Sieve of Eratosthenes up to the given limit. Returns a boolean list indicating prime status and a list of prime counts. sieve = [True] * (limit + 1) sieve[0] = sieve[1] = False for start in range(2, int(limit**0.5) + 1): if sieve[start]: for multiple in range(start*start, limit + 1, start): sieve[multiple] = False prime_counts = [0] * (limit + 1) for i in range(1, limit + 1): prime_counts[i] = prime_counts[i - 1] + (1 if sieve[i] else 0) return sieve, prime_counts def process_queries(queries, prime_sieve, prime_counts): Processes a list of queries and returns the results. results = [] for l, r in queries: results.append(count_primes_in_range(l, r, prime_sieve, prime_counts)) return results"},{"question":"from typing import List def can_segment_string(S: str, words: List[str]) -> str: Determine if the string S can be segmented into a sequence of one or more dictionary words from the set. >>> can_segment_string(\\"leetcode\\", [\\"leet\\", \\"code\\"]) 'YES' >>> can_segment_string(\\"applepenapple\\", [\\"apple\\", \\"pen\\"]) 'YES' >>> can_segment_string(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) 'NO'","solution":"def can_segment_string(S, words): Determine if the string S can be segmented into a sequence of one or more dictionary words from the set. word_set = set(words) dp = [False] * (len(S) + 1) dp[0] = True for i in range(1, len(S) + 1): for j in range(i): if dp[j] and S[j:i] in word_set: dp[i] = True break return \\"YES\\" if dp[len(S)] else \\"NO\\""},{"question":"def minimum_delivery_cost(n: int, m: int, routes: List[Tuple[int, int, int]]) -> Union[int, str]: Calculate the minimum cost required to deliver parcels to various cities using different transportation routes. Args: n (int): Number of cities. m (int): Number of transportation routes. routes (List[Tuple[int, int, int]]): List of routes with their respective costs. Returns: Union[int, str]: The minimum total cost required to cover all cities, or \\"IMPOSSIBLE\\" if it is impossible. >>> minimum_delivery_cost(4, 5, [(1, 2, 2), (1, 3, 3), (2, 3, 1), (2, 4, 4), (3, 4, 5)]) 7 >>> minimum_delivery_cost(3, 1, [(1, 2, 3)]) 'IMPOSSIBLE'","solution":"def find(parent, i): if parent[i] == i: return i else: parent[i] = find(parent, parent[i]) return parent[i] def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[yroot] < rank[xroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def kruskal(n, edges): result = 0 # Store the minimum cost edges = sorted(edges, key=lambda item: item[2]) # Sort edges by their weights parent = []; rank = [] for node in range(n): parent.append(node) rank.append(0) e = 0 # Count of edges included in the minimum spanning tree i = 0 # Initial index of sorted edges while e < n - 1 and i < len(edges): u, v, w = edges[i] i += 1 x = find(parent, u - 1) y = find(parent, v - 1) if x != y: e += 1 result += w union(parent, rank, x, y) if e == n - 1: return result else: return \\"IMPOSSIBLE\\" def minimum_delivery_cost(n, m, routes): return kruskal(n, routes) # Example usage: # n = 4 # m = 5 # routes = [ # (1, 2, 2), # (1, 3, 3), # (2, 3, 1), # (2, 4, 4), # (3, 4, 5), # ] # print(minimum_delivery_cost(n, m, routes)) # Output: 7"},{"question":"def is_leap_year(year: int) -> str: Determines whether a given year is a leap year in the Gregorian calendar. >>> is_leap_year(2000) == \\"YES\\" >>> is_leap_year(1900) == \\"NO\\" >>> is_leap_year(2016) == \\"YES\\" >>> is_leap_year(2019) == \\"NO\\" >>> is_leap_year(1) == \\"NO\\" >>> is_leap_year(400) == \\"YES\\" >>> is_leap_year(1000000) == \\"YES\\" >>> is_leap_year(2) == \\"NO\\" >>> is_leap_year(3) == \\"NO\\" >>> is_leap_year(100) == \\"NO\\" >>> is_leap_year(500) == \\"NO\\"","solution":"def is_leap_year(year): Determines whether a given year is a leap year in the Gregorian calendar. Args: year (int): The year to check. Returns: str: 'YES' if the year is a leap year, otherwise 'NO'. if year % 4 == 0: if year % 100 == 0: if year % 400 == 0: return \\"YES\\" else: return \\"NO\\" else: return \\"YES\\" else: return \\"NO\\""},{"question":"def evaluate_expression(expression: str) -> float: Given a valid arithmetic expression in a specific notation, compute its value. >>> evaluate_expression(\\"5\\") 5.00 >>> evaluate_expression(\\"( + 4 5 )\\") 9.00 >>> evaluate_expression(\\"( * ( - 10 3 ) ( / 6 2 ) )\\") 21.00 >>> evaluate_expression(\\"( + 7 ( * 2 3 ) )\\") 13.00 >>> evaluate_expression(\\"( - ( * 3 ( / 6 2 ) ) 1 )\\") 8.00 >>> evaluate_expression(\\"( / 10 2 )\\") 5.00 >>> evaluate_expression(\\"( + ( * 2 3 ) ( / 9 3 ) )\\") 9.00","solution":"def evaluate_expression(expression): def helper(expr): expr = expr.strip() if expr.isdigit(): return float(expr) if expr[0] == '(': expr = expr[1:-1].strip() parts = [] i = 0 start = 0 while i < len(expr): if expr[i] == ' ': if expr[start:i].strip(): parts.append(expr[start:i].strip()) start = i + 1 elif expr[i] == '(': nest = 1 j = i + 1 # find the closing parenthesis while j < len(expr) and nest > 0: if expr[j] == '(': nest += 1 elif expr[j] == ')': nest -= 1 j += 1 parts.append(expr[i:j].strip()) i = j - 1 start = j i += 1 if expr[start:].strip(): parts.append(expr[start:].strip()) op = parts[0] x = helper(parts[1]) y = helper(parts[2]) if op == '+': return x + y elif op == '-': return x - y elif op == '*': return x * y elif op == '/': return x / y return round(helper(expression), 2)"},{"question":"def number_to_words(n: int) -> str: Convert a non-negative integer to its words representation. >>> number_to_words(5) == \\"five\\" >>> number_to_words(12345) == \\"twelve thousand three hundred forty five\\" >>> number_to_words(100001) == \\"one hundred thousand one\\"","solution":"def number_to_words(n): Convert a non-negative integer to its words representation. below_20 = [\\"zero\\", \\"one\\", \\"two\\", \\"three\\", \\"four\\", \\"five\\", \\"six\\", \\"seven\\", \\"eight\\", \\"nine\\", \\"ten\\", \\"eleven\\", \\"twelve\\", \\"thirteen\\", \\"fourteen\\", \\"fifteen\\", \\"sixteen\\", \\"seventeen\\", \\"eighteen\\", \\"nineteen\\"] tens = [\\"\\", \\"\\", \\"twenty\\", \\"thirty\\", \\"forty\\", \\"fifty\\", \\"sixty\\", \\"seventy\\", \\"eighty\\", \\"ninety\\"] def words(n): if n < 20: return below_20[n] elif n < 100: return tens[n // 10] + ('' if n % 10 == 0 else ' ' + below_20[n % 10]) elif n < 1000: return below_20[n // 100] + ' hundred' + ('' if n % 100 == 0 else ' ' + words(n % 100)) elif n < 1000000: return words(n // 1000) + ' thousand' + ('' if n % 1000 == 0 else ' ' + (words(n % 1000))) return words(n)"},{"question":"def has_duplicate_item(n: int, m: int, grid: List[List[int]]) -> str: Determines if there is any duplicate item code in the grid, excluding empty shelves (item code 0). Args: n (int): number of rows in the warehouse grid m (int): number of columns in the warehouse grid grid (list of list of int): the warehouse grid with item codes and 0 for empty shelves Returns: str: \\"YES\\" if there is any duplicate item code, otherwise \\"NO\\" >>> has_duplicate_item(2, 2, [[1, 2], [3, 4]]) \\"NO\\" >>> has_duplicate_item(3, 3, [[10, 20, 30], [40, 20, 50], [60, 70, 80]]) \\"YES\\" >>> has_duplicate_item(3, 3, [[0, 0, 0], [0, 0, 0], [0, 0, 0]]) \\"NO\\" >>> has_duplicate_item(3, 3, [[0, 1, 0], [2, 0, 3], [4, 5, 0]]) \\"NO\\" >>> has_duplicate_item(2, 2, [[10**9, 1], [2, 10**9]]) \\"YES\\" >>> has_duplicate_item(1, 5, [[1, 2, 3, 4, 5]]) \\"NO\\" >>> has_duplicate_item(3, 3, [[1, 1, 0], [2, 0, 3], [4, 0, 5]]) \\"YES\\" >>> has_duplicate_item(3, 3, [[1, 2, 3], [4, 0, 1], [5, 6, 0]]) \\"YES\\"","solution":"def has_duplicate_item(n, m, grid): Determines if there is any duplicate item code in the grid, excluding empty shelves (item code 0). Args: n (int): number of rows in the warehouse grid m (int): number of columns in the warehouse grid grid (list of list of int): the warehouse grid with item codes and 0 for empty shelves Returns: str: \\"YES\\" if there is any duplicate item code, otherwise \\"NO\\" item_seen = set() for row in grid: for item in row: if item != 0: if item in item_seen: return \\"YES\\" item_seen.add(item) return \\"NO\\""},{"question":"def determine_operation(x: int, y: int, z: int) -> str: Determines whether x + y = z, x * y = z, or neither. Returns '+' if x + y = z, '*' if x * y = z, 'x' if neither. >>> determine_operation(10, 5, 15) '+' >>> determine_operation(4, 5, 20) '*' >>> determine_operation(2, 3, 8) 'x'","solution":"def determine_operation(x, y, z): Determines whether x + y = z, x * y = z, or neither. Returns '+' if x + y = z, '*' if x * y = z, 'x' if neither. if x + y == z: return '+' elif x * y == z: return '*' else: return 'x'"},{"question":"def count_even_sum_pairs(N: int, arr: List[int]) -> int: Returns the number of pairs (i, j) such that: 1. 0 <= i < j < N 2. The sum of the elements at indices i and j is even >>> count_even_sum_pairs(5, [1, 2, 3, 4, 5]) 4 >>> count_even_sum_pairs(4, [2, 4, 6, 8]) 6 from solution import count_even_sum_pairs def test_example1(): assert count_even_sum_pairs(5, [1, 2, 3, 4, 5]) == 4 def test_example2(): assert count_even_sum_pairs(4, [2, 4, 6, 8]) == 6 def test_all_even(): assert count_even_sum_pairs(3, [2, 2, 2]) == 3 def test_all_odd(): assert count_even_sum_pairs(3, [1, 1, 1]) == 3 def test_mixed_even_odd(): assert count_even_sum_pairs(4, [1, 2, 3, 4]) == 2 def test_single_element(): assert count_even_sum_pairs(1, [1]) == 0 def test_no_even_no_odd(): assert count_even_sum_pairs(6, [2, 4, 6, 8, 10, 12]) == 15 assert count_even_sum_pairs(5, [1, 3, 5, 7, 9]) == 10 def test_empty_array(): assert count_even_sum_pairs(0, []) == 0","solution":"def count_even_sum_pairs(N, arr): Returns the number of pairs (i, j) such that: 1. 0 <= i < j < N 2. The sum of the elements at indices i and j is even even_count = 0 odd_count = 0 for num in arr: if num % 2 == 0: even_count += 1 else: odd_count += 1 # Pairs of even numbers even_pairs = (even_count * (even_count - 1)) // 2 # Pairs of odd numbers odd_pairs = (odd_count * (odd_count - 1)) // 2 return even_pairs + odd_pairs"},{"question":"import math from typing import Tuple def calculate_hypotenuse(a: int, b: int) -> int: Returns the length of the hypotenuse of a right-angled triangle with legs of lengths a and b, rounded to the nearest integer. >>> calculate_hypotenuse(3, 4) 5 >>> calculate_hypotenuse(5, 12) 13 >>> calculate_hypotenuse(8, 15) 17 # Your code goes here # Unit tests def test_calculate_hypotenuse_known_values(): assert calculate_hypotenuse(3, 4) == 5 assert calculate_hypotenuse(5, 12) == 13 assert calculate_hypotenuse(8, 15) == 17 def test_calculate_hypotenuse_with_various_inputs(): assert calculate_hypotenuse(7, 24) == 25 assert calculate_hypotenuse(9, 12) == 15 assert calculate_hypotenuse(1, 1) == 1 # Since sqrt(2) rounded is 1 def test_calculate_hypotenuse_with_high_values(): assert calculate_hypotenuse(300, 400) == 500 assert calculate_hypotenuse(1000, 1000) == 1414 def test_calculate_hypotenuse_with_edge_cases(): assert calculate_hypotenuse(1, 1000) == 1000 assert calculate_hypotenuse(999, 1) == 999","solution":"import math def calculate_hypotenuse(a, b): Returns the length of the hypotenuse of a right-angled triangle with legs of lengths a and b, rounded to the nearest integer. hypotenuse = math.sqrt(a**2 + b**2) return round(hypotenuse)"},{"question":"def longest_sequence_length(start: int) -> int: Calculates the longest sequence length of unique numbers starting from the given number. >>> longest_sequence_length(1) 3 >>> longest_sequence_length(3) 3 def process_test_cases(test_cases: List[int]) -> List[int]: Processes multiple test cases and returns results for each. >>> process_test_cases([1, 3]) [3, 3] >>> process_test_cases([1000000000, 999999]) [3, 3]","solution":"def longest_sequence_length(start): Calculates the longest sequence length of unique numbers starting from the given number. return 3 def process_test_cases(test_cases): Processes multiple test cases and returns results for each. results = [] for t in test_cases: results.append(longest_sequence_length(t)) return results"},{"question":"def max_cookies_per_tray(M: int, C: int) -> int: Return the maximum number of cookies a single tray will get. >>> max_cookies_per_tray(3, 8) 3 >>> max_cookies_per_tray(4, 7) 2 >>> max_cookies_per_tray(5, 12) 3","solution":"def max_cookies_per_tray(M, C): Return the maximum number of cookies a single tray will get. base_cookies = C // M remainder = C % M if remainder > 0: return base_cookies + 1 return base_cookies"},{"question":"def longest_increasing_subsequence(sequence): Returns the length of the longest strictly increasing subsequence in the given sequence. >>> longest_increasing_subsequence([5, 2, 8, 6, 3, 6, 9, 7]) == 4 >>> longest_increasing_subsequence([3, 10, 2, 1]) == 2 >>> longest_increasing_subsequence([1, 2, 3, 4, 5]) == 5","solution":"def longest_increasing_subsequence(sequence): Returns the length of the longest strictly increasing subsequence in the given sequence. if not sequence: return 0 n = len(sequence) lis = [1] * n # Initialize LIS value for all indexes as 1 # Compute optimized LIS values in a bottom-up manner for i in range(1, n): for j in range(i): if sequence[i] > sequence[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 # Return the maximum value in lis[] return max(lis)"},{"question":"def reverse_segments(n: int, q: int, candies: List[int], queries: List[Tuple[int, int]]) -> List[List[int]]: Perform Q reverse operations on the arrangement of N candies. >>> reverse_segments(5, 3, [1, 2, 3, 4, 5], [(1, 3), (2, 4), (1, 5)]) [[3, 2, 1, 4, 5], [3, 4, 1, 2, 5], [5, 2, 1, 4, 3]] >>> reverse_segments(1, 1, [1], [(1, 1)]) [[1]] >>> reverse_segments(5, 0, [1, 2, 3, 4, 5], []) [] >>> reverse_segments(4, 1, [1, 2, 3, 4], [(1, 4)]) [[4, 3, 2, 1]] >>> reverse_segments(6, 2, [1, 2, 3, 4, 5, 6], [(1, 3), (4, 6)]) [[3, 2, 1, 4, 5, 6], [3, 2, 1, 6, 5, 4]]","solution":"def reverse_segments(n, q, candies, queries): result = [] for L, R in queries: # Adjust the indices to be 0-based for Python lists L -= 1 R -= 1 # Reverse the subsequence candies = candies[:L] + candies[L:R+1][::-1] + candies[R+1:] # Append the current arrangement to the result result.append(list(candies)) return result # Driver code to interact with console I/O if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() n = int(data[0]) q = int(data[1]) candies = list(map(int, data[2:n+2])) queries = [] index = n + 2 for _ in range(q): L = int(data[index]) R = int(data[index+1]) queries.append((L, R)) index += 2 results = reverse_segments(n, q, candies, queries) for result in results: print(\\" \\".join(map(str, result)))"},{"question":"from typing import List def longest_ascending_descending(s: str) -> int: Find the length of the longest substring that forms an 'ascending plus descending' numeric pattern. >>> longest_ascending_descending(\\"1234321\\") 7 >>> longest_ascending_descending(\\"1294878\\") 4 >>> longest_ascending_descending(\\"12321\\") 5 >>> longest_ascending_descending(\\"1111\\") 0 >>> longest_ascending_descending(\\"54321\\") 0 >>> longest_ascending_descending(\\"12345\\") 0 >>> longest_ascending_descending(\\"124321\\") 6 pass def longest_ascending_descending_multiple(test_cases: List[str]) -> List[int]: Given a list of test cases, find the length of the longest substring for each case that forms an 'ascending plus descending' numeric pattern. >>> longest_ascending_descending_multiple([\\"1234321\\", \\"1294878\\", \\"12321\\"]) [7, 4, 5] >>> longest_ascending_descending_multiple([\\"1111\\", \\"54321\\", \\"12345\\"]) [0, 0, 0] >>> longest_ascending_descending_multiple([\\"124321\\", \\"234567\\", \\"543210\\"]) [6, 0, 0] pass","solution":"def longest_ascending_descending(s): max_len = 0 for i in range(len(s)): peak = i while peak + 1 < len(s) and s[peak] < s[peak + 1]: peak += 1 decline = peak while decline + 1 < len(s) and s[decline] > s[decline + 1]: decline += 1 if peak > i and decline > peak: max_len = max(max_len, decline - i + 1) return max_len def longest_ascending_descending_multiple(test_cases): results = [] for s in test_cases: results.append(longest_ascending_descending(s)) return results"},{"question":"def total_distance_walked(test_cases: List[List[int]]) -> List[int]: Calculate the total distance walked for each test case. Args: test_cases (List[List[int]]): A list of test cases, where each test case is a list of integers representing the positions at which a walker changes direction. Returns: List[int]: A list of integers representing the total distance walked for each test case. Examples: >>> total_distance_walked([[2, 5, 8], [-3, -1, 2, 4], [0, 0, 0, 0, 7]]) [6, 7, 7] >>> total_distance_walked([[0]]) [0] >>> total_distance_walked([[5, 5, 5]]) [0] >>> total_distance_walked([[-5, -3, -1, 0]]) [5] >>> total_distance_walked([[100000, -100000]]) [200000] >>> total_distance_walked([[-10, 0, 10], [1, 1, 1, 1], [-1, -1, 1, 1]]) [20, 0, 2]","solution":"def total_distance_walked(test_cases): results = [] for positions in test_cases: total_distance = sum(abs(positions[i] - positions[i-1]) for i in range(1, len(positions))) results.append(total_distance) return results"},{"question":"class ListNode: def __init__(self, letter: str, num: int): self.letter = letter self.num = num self.next = None def reverseList(head: ListNode) -> ListNode: Reverse the nodes of a linked list such that alphabets are in reverse order but integers remain in their respective positions. >>> head = create_list([('a', 1), ('b', 3), ('c', 5), ('d', 2)]) >>> extract_values(reverseList(head)) [('d', 1), ('c', 3), ('b', 5), ('a', 2)] >>> head = create_list([('a', 1)]) >>> extract_values(reverseList(head)) [('a', 1)] >>> head = create_list([]) >>> reverseList(head) None >>> head = create_list([('a', 1), ('b', 2), ('c', 3), ('d', 4)]) >>> extract_values(reverseList(head)) [('d', 1), ('c', 2), ('b', 3), ('a', 4)] >>> head = create_list([('x', 9), ('y', 8), ('z', 7)]) >>> extract_values(reverseList(head)) [('z', 9), ('y', 8), ('x', 7)] pass def create_list(values): dummy = ListNode('', 0) current = dummy for letter, num in values: current.next = ListNode(letter, num) current = current.next return dummy.next def extract_values(head): result = [] current = head while current: result.append((current.letter, current.num)) current = current.next return result def test_reverseList_basic(): head = create_list([('a', 1), ('b', 3), ('c', 5), ('d', 2)]) reversed_head = reverseList(head) assert extract_values(reversed_head) == [('d', 1), ('c', 3), ('b', 5), ('a', 2)] def test_reverseList_single_element(): head = create_list([('a', 1)]) reversed_head = reverseList(head) assert extract_values(reversed_head) == [('a', 1)] def test_reverseList_empty(): head = create_list([]) reversed_head = reverseList(head) assert reversed_head == None def test_reverseList_even_elements(): head = create_list([('a', 1), ('b', 2), ('c', 3), ('d', 4)]) reversed_head = reverseList(head) assert extract_values(reversed_head) == [('d', 1), ('c', 2), ('b', 3), ('a', 4)] def test_reverseList_non_alphabetic_order(): head = create_list([('x', 9), ('y', 8), ('z', 7)]) reversed_head = reverseList(head) assert extract_values(reversed_head) == [('z', 9), ('y', 8), ('x', 7)]","solution":"class ListNode: def __init__(self, letter: str, num: int): self.letter = letter self.num = num self.next = None def reverseList(head: ListNode) -> ListNode: if not head: return None # Collect all the letters letters = [] current = head while current: letters.append(current.letter) current = current.next # Reverse the collected letters letters.reverse() # Assign the reversed letters back to the nodes current = head index = 0 while current: current.letter = letters[index] index += 1 current = current.next return head"},{"question":"def possible_to_color_graph(n: int, m: int, edges: List[Tuple[int, int]]) -> str: Given an undirected graph with \`n\` nodes and \`m\` edges, determine if it is possible to color the graph using exactly 3 colors such that no two adjacent nodes share the same color. If possible, output a valid coloring. Otherwise, output -1. >>> possible_to_color_graph(6, 7, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (1, 4)]) 'YESn1 2 1 2 1 3' >>> possible_to_color_graph(4, 5, [(1, 2), (2, 3), (3, 4), (4, 1), (1, 3)]) 'NO'","solution":"def possible_to_color_graph(n, m, edges): from collections import defaultdict, deque graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) colors = [0] * (n + 1) def bfs(start): queue = deque([start]) colors[start] = 1 while queue: node = queue.popleft() for neighbor in graph[node]: if colors[neighbor] == 0: colors[neighbor] = 4 - colors[node] if colors[node] != 3 else 1 queue.append(neighbor) elif colors[neighbor] == colors[node]: return False return True for node in range(1, n + 1): if colors[node] == 0: if not bfs(node): return \\"NO\\" return \\"YESn\\" + ' '.join(map(str, colors[1:])) # Example usage: # n = 6 # m = 7 # edges = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (1, 4)] # print(possible_to_color_graph(n, m, edges))"},{"question":"def tournament_schedule(n: int, preferences: List[int]) -> Tuple[int, List[List[int]]]: Determine the minimum number of days required for the tournament and provide a schedule of knights participating each day. Args: n (int): The number of knights. preferences (List[int]): A list of integers where the i-th integer represents the preferred day of the i-th knight. Returns: Tuple[int, List[List[int]]]: The minimum number of days required for the tournament and the schedule of knights. Examples: >>> tournament_schedule(5, [1, 2, 2, 3, 1]) (3, [[1, 5], [2, 3], [4]]) >>> tournament_schedule(6, [1, 2, 3, 4, 2, 3]) (4, [[1], [2, 5], [3, 6], [4]]) pass # Unit Test: from solution import tournament_schedule def test_tournament_schedule(): # Test case 1 n1 = 5 preferences1 = [1, 2, 2, 3, 1] k1, schedule1 = tournament_schedule(n1, preferences1) assert k1 == 3 assert schedule1 == [[1, 5], [2, 3], [4]] # Test case 2 n2 = 6 preferences2 = [1, 2, 3, 4, 2, 3] k2, schedule2 = tournament_schedule(n2, preferences2) assert k2 == 4 assert schedule2 == [[1], [2, 5], [3, 6], [4]] # Test case 3: Single knight n3 = 1 preferences3 = [1] k3, schedule3 = tournament_schedule(n3, preferences3) assert k3 == 1 assert schedule3 == [[1]] # Test case 4: All knights have the same preferred day n4 = 5 preferences4 = [2, 2, 2, 2, 2] k4, schedule4 = tournament_schedule(n4, preferences4) assert k4 == 1 assert schedule4 == [[1, 2, 3, 4, 5]] # Test case 5: Each knight prefers a different day n5 = 5 preferences5 = [1, 2, 3, 4, 5] k5, schedule5 = tournament_schedule(n5, preferences5) assert k5 == 5 assert schedule5 == [[1], [2], [3], [4], [5]]","solution":"def tournament_schedule(n, preferences): # Create a dictionary to store the days and corresponding knights days = {} for knight, preferred_day in enumerate(preferences, start=1): if preferred_day not in days: days[preferred_day] = [] days[preferred_day].append(knight) # Sort the days to get the correct schedule sorted_days = sorted(days.items()) k = len(sorted_days) schedule = [knights for day, knights in sorted_days] return k, schedule # Example usage: n = 5 preferences = [1, 2, 2, 3, 1] print(tournament_schedule(n, preferences))"},{"question":"def find_positions(n, query_fn): Help Alice and Bob find one prime position of '1' and one composite position of '0'. n: The length of the switch sequence (2 <= n <= 1000) query_fn: Function to ask query to the wall, receives a binary string and returns the number of differing positions Example: >>> n = 4 >>> target = \\"1110\\" # Hidden switches sequence >>> def mock_query_fn(target, switch_seq): ... difference_count = 0 ... for t, s in zip(target, switch_seq): ... if t != s: ... difference_count += 1 ... return difference_count >>> query_fn = lambda query_str: mock_query_fn(target, query_str) >>> find_positions(n, query_fn) \\"2 4\\"","solution":"def is_prime(num): Utility function to check if a number is prime. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def find_positions(n, query_fn): Function to find one prime position of '1' and one composite position of '0'. n: length of the switch sequence (2 <= n <= 1000) query_fn: function to ask query to the wall, receives a binary string and returns the number of differing positions prime_positions = [i for i in range(2, n+1) if is_prime(i)] composite_positions = [i for i in range(2, n+1) if not is_prime(i)] for prime_pos in prime_positions: query_str = ''.join('1' if i == prime_pos else '0' for i in range(1, n + 1)) if query_fn(query_str) < n: # There is a chance that the current prime_pos is '1' break for composite_pos in composite_positions: query_str = ''.join('0' if i == composite_pos else '1' for i in range(1, n + 1)) if query_fn(query_str) < n: # There is a chance that the current composite_pos is '0' break return prime_pos, composite_pos"},{"question":"def minimum_operations(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Returns the minimum number of operations required to reduce each array in the test cases to a single integer. Parameters: t (int): The number of test cases. test_cases (list of tuples): Each tuple contains the length of the array and the array itself. Returns: list: List of minimum operations for each test case.","solution":"def minimum_operations(t, test_cases): Returns the minimum number of operations required to reduce each array in the test cases to a single integer. Parameters: t (int): The number of test cases. test_cases (list of tuples): Each tuple contains the length of the array and the array itself. Returns: list: List of minimum operations for each test case. results = [] for i in range(t): n, arr = test_cases[i] results.append(n - 1) return results"},{"question":"def max_wood_pieces(n: int, heights: List[int]) -> int: Given a list of heights of trees, determine the maximum number of wood pieces you can collect by cutting down some trees, ensuring no two adjacent trees are cut down, and only even-height trees yield wood pieces. Args: n (int): The number of trees in the forest. heights (List[int]): The heights of the trees. Returns: int: The maximum number of wood pieces that can be collected. Examples: >>> max_wood_pieces(7, [4, 7, 2, 8, 6, 10, 1]) 3 >>> max_wood_pieces(5, [3, 5, 7, 9, 11]) 0","solution":"def max_wood_pieces(n, heights): if n == 0: return 0 # dp[i] will store the maximum wood pieces we can collect by considering the first i trees dp = [0] * n # Start by considering the first tree if heights[0] % 2 == 0: dp[0] = 1 if n == 1: return dp[0] # Now, consider the second tree if heights[1] % 2 == 0: dp[1] = max(dp[0], 1) else: dp[1] = dp[0] # Fill dp array for subsequent trees for i in range(2, n): if heights[i] % 2 == 0: dp[i] = max(dp[i-1], dp[i-2] + 1) else: dp[i] = dp[i-1] return dp[-1]"},{"question":"def compute_contribution_scores(n: int, m: int, projects: List[str]) -> List[str]: Compute the contribution score for each employee based on their projects. >>> compute_contribution_scores(3, 2, [\\"2 1 3 10.5\\", \\"3 1 2 3 15.2\\"]) [\\"25.70\\", \\"15.20\\", \\"25.70\\"] >>> compute_contribution_scores(4, 3, [\\"2 1 2 5.0\\", \\"2 2 3 6.1\\", \\"1 4 7.3\\"]) [\\"5.00\\", \\"11.10\\", \\"6.10\\", \\"7.30\\"] >>> compute_contribution_scores(2, 1, [\\"2 1 2 8.5\\"]) [\\"8.50\\", \\"8.50\\"] >>> compute_contribution_scores(1, 1, [\\"1 1 9.0\\"]) [\\"9.00\\"] >>> compute_contribution_scores(3, 3, [\\"1 1 3.0\\", \\"1 2 4.0\\", \\"1 3 5.0\\"]) [\\"3.00\\", \\"4.00\\", \\"5.00\\"]","solution":"def compute_contribution_scores(n, m, projects): # Initialize the contribution scores for each employee to zero contribution_scores = [0.0] * n for project in projects: project_data = list(map(float, project.split())) k = int(project_data[0]) # number of employees in this project employees = list(map(int, project_data[1:k+1])) # employee indices impact_score = project_data[-1] # impact score of the project # Add the impact score to each employee's contribution score for employee in employees: contribution_scores[employee - 1] += impact_score # Format each contribution score to exactly two decimal places formatted_scores = [format(score, \\".2f\\") for score in contribution_scores] return formatted_scores"},{"question":"def rearrange_array(n: int, arr: List[int]) -> List[int]: Rearrange the array into a permutation such that the difference between adjacent elements is never equal to 1. If no such permutation exists, return an empty array. >>> rearrange_array(5, [4, 3, 5, 1, 2]) # Output example: [5, 1, 4, 2, 3] >>> rearrange_array(3, [1, 2, 2]) # Output: []","solution":"def rearrange_array(n, arr): Returns a permutation of the array such that the difference between any two adjacent elements is not 1. If no such permutation exists, returns an empty array. from collections import Counter count = Counter(arr) if any(count[num] > (n + 1) // 2 for num in count): return [] arr.sort() result = [0] * n left = 0 right = (n + 1) // 2 j = 0 for i in range(n): if i & 1: result[i] = arr[right] right += 1 else: result[i] = arr[left] left += 1 for i in range(1, n): if abs(result[i] - result[i - 1]) == 1: return [] return result"},{"question":"def max_enchantment_points(N: int, K: int, enchantment_points: List[int]) -> int: Determine the maximum enchantment points you can collect while adhering to the constraints. You can select at most K fruits such that no two selected fruits are adjacent in the array. Args: N: The number of fruits. K: The maximum number of fruits you can select. enchantment_points: An array representing the enchantment points of each fruit. Returns: The maximum enchantment points you can collect. Examples: >>> max_enchantment_points(7, 3, [1, 10, 3, 5, 7, 2, 9]) 26 >>> max_enchantment_points(5, 1, [4, 5, 6, 7, 8]) 8","solution":"def max_enchantment_points(N, K, enchantment_points): # Create a list to store the maximum enchantment points we can get using i fruits. # Initialize with -infinity to indicate initially they are not reachable. dp = [-float('inf')] * (K + 1) dp[0] = 0 # Zero fruits selected means zero enchantment points # Iterate through the enchantment points list for points in enchantment_points: # Iterate from K down to 1 to prevent using the same point more than once. for k in range(K, 0, -1): if dp[k-1] != -float('inf'): dp[k] = max(dp[k], dp[k-1] + points) return max(dp) # The answer is the maximum value in the dp array."},{"question":"def game_winner(n: int, arr: List[int]) -> str: Determines the winner of the game. Alice starts first, and players alternate turns. The player who cannot make a move loses the game. Args: n: int, the number of integers in the array. arr: list of int, the array of integers. Returns: str: \\"Alice\\" if Alice wins the game, \\"Bob\\" if Bob wins the game. >>> game_winner(3, [2, 1, 4]) \\"Alice\\" >>> game_winner(4, [1, 1, 1, 1]) \\"Bob\\" >>> game_winner(2, [10, 20]) \\"Alice\\"","solution":"def game_winner(n, arr): Determines the winner of the game. Alice starts first, and players alternate moves. The player who cannot make a move loses the game. Args: n: int, the number of integers in the array. arr: list of int, the array of integers. Returns: str: \\"Alice\\" if Alice wins the game, \\"Bob\\" if Bob wins the game. # If the total number of elements n is odd, Alice wins (Alice always starts) # If n is even, Bob wins (Alice always starts but Bob makes the last move) return \\"Alice\\" if n % 2 == 1 else \\"Bob\\""},{"question":"def count_divisible_pairs(N: int, K: int, A: List[int]) -> int: Returns the number of pairs (i, j) such that 1 <= i < j <= N and the sum A_i + A_j is divisible by K. Args: N: The number of elements in the list K: The divisor A: The list of integers Returns: The number of pairs whose sum is divisible by K. >>> count_divisible_pairs(5, 3, [1, 2, 3, 4, 5]) 4 >>> count_divisible_pairs(6, 5, [5, 10, 15, 20, 25, 30]) 15","solution":"def count_divisible_pairs(N, K, A): Returns the number of pairs (i, j) such that 1 <= i < j <= N and the sum A_i + A_j is divisible by K. :param N: Number of elements in the list :param K: Divisor :param A: List of integers :return: Number of pairs remainder_count = [0] * K for number in A: remainder_count[number % K] += 1 count = 0 count += (remainder_count[0] * (remainder_count[0] - 1)) // 2 for i in range(1, (K // 2) + 1): if i != K - i: count += remainder_count[i] * remainder_count[K - i] if K % 2 == 0: count += (remainder_count[K // 2] * (remainder_count[K // 2] - 1)) // 2 return count"},{"question":"def is_transform_possible(T, test_cases): Determines if array A can be transformed into array B by performing a series of swaps of adjacent elements. Args: T : int : number of test cases test_cases : List[Tuple[int, List[int], List[int]]] : list of test cases, each containing: - int : size of the arrays (N) - List[int] : array A of size N - List[int] : array B of size N Returns: List[str] : returns a list of \\"POSSIBLE\\" or \\"IMPOSSIBLE\\" for each test case >>> is_transform_possible(2, [(3, [1, 3, 2], [1, 2, 3]), (4, [4, 1, 3, 2], [1, 2, 3, 4])]) ['POSSIBLE', 'POSSIBLE'] >>> is_transform_possible(1, [(3, [1, 3, 2], [1, 2, 4])]) ['IMPOSSIBLE']","solution":"def is_transform_possible(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] A = test_cases[i][1] B = test_cases[i][2] if sorted(A) == sorted(B): results.append(\\"POSSIBLE\\") else: results.append(\\"IMPOSSIBLE\\") return results"},{"question":"def has_pair_with_sum(n, arr, target): Given a list of integers, determines if there are two distinct indices i and j in the list such that the sum of the integers at those indices equals the given target value. >>> has_pair_with_sum(5, [1, 4, 45, 6, 10], 16) == \\"YES\\" >>> has_pair_with_sum(4, [1, 2, 3, 9], 8) == \\"NO\\" >>> has_pair_with_sum(2, [5, 5], 10) == \\"YES\\" >>> has_pair_with_sum(3, [1, 2, 4], 5) == \\"YES\\" >>> has_pair_with_sum(3, [1, 2, 4], 8) == \\"NO\\" >>> has_pair_with_sum(4, [-1, -2, -3, -4], -5) == \\"YES\\" >>> has_pair_with_sum(4, [2, 4, 6, 8], 12) == \\"YES\\" >>> has_pair_with_sum(4, [0, 0, 0, 0], 0) == \\"YES\\" Parameters: n (int): The number of integers in the list. arr (list of int): The list of integers. target (int): The target sum value. Returns: str: \\"YES\\" if there are two such distinct indices, otherwise \\"NO\\".","solution":"def has_pair_with_sum(n, arr, target): Given a list of integers, determines if there are two distinct indices i and j in the list such that the sum of the integers at those indices equals the given target value. Parameters: n (int): The number of integers in the list. arr (list of int): The list of integers. target (int): The target sum value. Returns: str: \\"YES\\" if there are two such distinct indices, otherwise \\"NO\\". seen = set() for num in arr: if target - num in seen: return \\"YES\\" seen.add(num) return \\"NO\\""},{"question":"def can_reorder_to_avoid_initial_positions(n: int, arr: List[int]) -> str: Determine if it is possible to reorder the list so that no integer remains in its initial position. Parameters: n (int): The length of the list. arr (list of int): The list of n integers. Returns: str: \\"YES\\" if such a reordering is possible, \\"NO\\" otherwise. Examples: >>> can_reorder_to_avoid_initial_positions(4, [1, 2, 3, 4]) \\"YES\\" >>> can_reorder_to_avoid_initial_positions(1, [1]) \\"NO\\"","solution":"def can_reorder_to_avoid_initial_positions(n, arr): Determine if it is possible to reorder the list so that no integer remains in its initial position. Parameters: n (int): The length of the list. arr (list of int): The list of n integers. Returns: str: \\"YES\\" if such a reordering is possible, \\"NO\\" otherwise. if n == 1: return \\"NO\\" return \\"YES\\""},{"question":"def shortest_path(n, m, maze) -> int: Finds the shortest path in a maze from the top-left corner to the bottom-right corner. n: number of rows m: number of columns maze: 2D array representing the maze Returns the minimum number of moves required to reach the bottom-right corner from the top-left corner, or -1 if there is no possible path. >>> shortest_path(4, 4, [ ... [0, 1, 0, 0], ... [0, 0, 0, 1], ... [1, 0, 1, 0], ... [0, 0, 0, 0] ... ]) 6 >>> shortest_path(3, 3, [ ... [0, 1, 1], ... [1, 1, 0], ... [0, 0, 0] ... ]) -1 pass","solution":"from collections import deque def shortest_path(n, m, maze): Finds the shortest path in a maze from the top-left corner to the bottom-right corner. n: number of rows m: number of columns maze: 2D array representing the maze if maze[0][0] == 1 or maze[n-1][m-1] == 1: return -1 # Directions for moving up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # BFS initialization queue = deque([(0, 0, 0)]) # (row, column, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() # If we reached the bottom-right corner if x == n - 1 and y == m - 1: return dist # Explore neighbors for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and maze[nx][ny] == 0: queue.append((nx, ny, dist + 1)) visited.add((nx, ny)) return -1 # No path found"},{"question":"def max_profit(prices): Returns the maximum profit from a single buy and sell transaction. >>> max_profit([7, 1, 5, 3, 6, 4]) == 5 >>> max_profit([7, 6, 4, 3, 1]) == 0 >>> max_profit([1, 2, 3, 4, 5]) == 4 def process_test_cases(t, test_cases): Process multiple test cases and return a list of results for each test case. >>> t = 3 >>> test_cases = [(6, [7, 1, 5, 3, 6, 4]), (5, [7, 6, 4, 3, 1]), (5, [1, 2, 3, 4, 5])] >>> process_test_cases(t, test_cases) == [5, 0, 4] >>> t = 1 >>> test_cases = [(6, [])] >>> process_test_cases(t, test_cases) == [0] >>> t = 2 >>> test_cases = [(4, [5, 2, 6, 1]), (3, [2, 2, 2])] >>> process_test_cases(t, test_cases) == [4, 0]","solution":"def max_profit(prices): Returns the maximum profit from a single buy and sell transaction. if not prices: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit def process_test_cases(t, test_cases): Process multiple test cases and return a list of results for each test case. results = [] for i in range(t): n = test_cases[i][0] prices = test_cases[i][1] results.append(max_profit(prices)) return results"},{"question":"def lexicographically_smallest_permutation(s: str) -> str: Returns the lexicographically smallest permutation of the string s. >>> lexicographically_smallest_permutation(\\"code\\") 'cdeo' >>> lexicographically_smallest_permutation(\\"abbc\\") 'abbc' >>> lexicographically_smallest_permutation(\\"zebra\\") 'aberz' >>> lexicographically_smallest_permutation(\\"alphabet\\") 'aabehlpt'","solution":"def lexicographically_smallest_permutation(s): Returns the lexicographically smallest permutation of the string s. return ''.join(sorted(s))"},{"question":"def find_pairs(nums, target): Returns all unique pairs of numbers from the given set that add up to the target value. Each pair is returned in ascending order and the entire list of pairs is sorted. Parameters: nums (list): A list of unique integers. target (int): The target sum for the pairs. Returns: list or str: A list of tuples representing the pairs that add up to the target or \\"No pairs found\\" if no such pairs exist. Examples: >>> find_pairs([2, 7, 11, 15, 1, 8], 10) [(2, 8)] >>> find_pairs([1, 2, 3, 4, 5], 10) 'No pairs found' >>> find_pairs([1, 2, 3, 4, 5], 5) [(1, 4), (2, 3)]","solution":"def find_pairs(nums, target): Returns all unique pairs of numbers from the given set that add up to the target value. Each pair is returned in ascending order and the entire list of pairs is sorted. pairs = [] nums_set = set(nums) for num in nums: complement = target - num if complement in nums_set and complement != num: pairs.append((min(num, complement), max(num, complement))) nums_set.discard(num) # remove this number from the set to prevent duplicates pairs = list(set(pairs)) # remove any duplicates pairs.sort() # sort pairs in ascending order return pairs if pairs else \\"No pairs found\\""},{"question":"from typing import List def min_moves_to_exit_maze(n: int, m: int, maze: List[str]) -> int: Returns the minimum number of moves required to get from the top-left cell to the bottom-right cell in the maze, or -1 if it is impossible. >>> min_moves_to_exit_maze(5, 5, [ ... \\".....\\", ... \\".#.\\", ... \\".....\\", ... \\"#..\\", ... \\".....\\" ... ]) == 8 >>> min_moves_to_exit_maze(3, 3, [ ... \\"...\\", ... \\"#\\", ... \\"...\\" ... ]) == -1 >>> min_moves_to_exit_maze(2, 2, [ ... \\"..\\", ... \\"..\\" ... ]) == 2 >>> min_moves_to_exit_maze(5, 5, [ ... \\".....\\", ... \\".....\\", ... \\".....\\", ... \\".....\\", ... \\".....\\" ... ]) == 8 >>> min_moves_to_exit_maze(5, 5, [ ... \\"#\\", ... \\"#\\", ... \\"#\\", ... \\"#\\", ... \\"#\\" ... ]) == -1 pass","solution":"from collections import deque def min_moves_to_exit_maze(n, m, maze): Returns the minimum number of moves required to get from the top-left cell to the bottom-right cell in the maze, or -1 if it is impossible. def is_valid(x, y): return 0 <= x < n and 0 <= y < m and maze[x][y] == '.' moves = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if (x, y) == (n-1, m-1): return dist for dx, dy in moves: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"def longest_mountain(arr: List[int]) -> int: Given an array of integers, find out the length of the longest subarray that forms a valid mountain. A mountain subarray satisfies the following conditions: 1. The subarray contains at least three elements. 2. There exists an index \`i\` (1 <= i < length of subarray - 1) such that: - \`arr[0] < arr[1] < ... < arr[i]\` - \`arr[i] > arr[i+1] > ... > arr[length-1]\` >>> longest_mountain([2, 1, 4, 7, 3, 2, 5, 7, 6]) 5 >>> longest_mountain([2, 2, 2, 2, 2, 2]) 0 >>> longest_mountain([1, 3, 2]) 3 >>> longest_mountain([1, 2, 3, 4, 5]) 0 >>> longest_mountain([2, 1, 4, 7, 3, 2, 2, 1, 4, 6, 5, 4, 3, 6, 2]) 6 >>> longest_mountain([3, 3, 3, 3]) 0","solution":"def longest_mountain(arr): n = len(arr) if n < 3: return 0 longest = 0 for i in range(1, n - 1): if arr[i-1] < arr[i] > arr[i+1]: # peek of the mountain left = i right = i # Move left pointer to the start of the mountain while left > 0 and arr[left-1] < arr[left]: left -= 1 # Move right pointer to the end of the mountain while right < n-1 and arr[right+1] < arr[right]: right += 1 # Update the longest mountain length longest = max(longest, right - left + 1) return longest"},{"question":"from typing import List def find_rule_breakers(n: int, events: List[str]) -> List[str]: Finds readers who violated the borrowing policy by borrowing more than one book at once. Args: n (int): Number of events in the log. events (List[str]): List of event records. Returns: List[str]: List of unique reader IDs who violated the policy, sorted in ascending order. >>> find_rule_breakers(7, [\\"r1 b1 borrow 2023-03-01 10:00:00\\", \\"r2 b2 borrow 2023-03-01 10:05:00\\", \\"r1 b1 return 2023-03-02 09:00:00\\", \\"r1 b3 borrow 2023-03-02 09:05:00\\", \\"r3 b4 borrow 2023-03-02 09:10:00\\", \\"r3 b5 borrow 2023-03-02 09:15:00\\", \\"r2 b2 return 2023-03-02 09:20:00\\"]) ['r3'] >>> find_rule_breakers(6, [\\"r1 b1 borrow 2023-03-01 10:00:00\\", \\"r1 b1 return 2023-03-01 15:00:00\\", \\"r2 b2 borrow 2023-03-01 10:05:00\\", \\"r2 b2 return 2023-03-01 20:00:00\\", \\"r3 b3 borrow 2023-03-02 09:00:00\\", \\"r3 b3 return 2023-03-02 09:30:00\\"]) [] >>> find_rule_breakers(8, [\\"r1 b1 borrow 2023-03-01 10:00:00\\", \\"r1 b2 borrow 2023-03-01 11:00:00\\", \\"r2 b1 borrow 2023-03-01 12:00:00\\", \\"r2 b2 borrow 2023-03-01 13:00:00\\", \\"r2 b1 return 2023-03-01 14:00:00\\", \\"r1 b2 return 2023-03-01 14:00:00\\", \\"r3 b1 borrow 2023-03-01 13:00:00\\", \\"r3 b2 borrow 2023-03-01 13:10:00\\"]) ['r1', 'r2', 'r3'] >>> find_rule_breakers(2, [\\"r1 b1 borrow 2023-03-01 10:00:00\\", \\"r2 b2 borrow 2023-03-01 10:00:00\\"]) []","solution":"def find_rule_breakers(n, events): Finds readers who violated the borrowing policy by borrowing more than one book at once. Args: n (int): Number of events in the log. events (List[str]): List of event records. Returns: List[str]: List of unique reader IDs who violated the policy, sorted in ascending order. from collections import defaultdict borrowed_books = defaultdict(int) # Keeps count of borrowed books per reader rule_breakers = set() # Keeps track of readers who violated the policy for event in events: reader_id, book_id, event_type, _ = event.split(maxsplit=3) if event_type == \\"borrow\\": borrowed_books[reader_id] += 1 if borrowed_books[reader_id] > 1: rule_breakers.add(reader_id) elif event_type == \\"return\\": borrowed_books[reader_id] -= 1 return sorted(rule_breakers)"},{"question":"from typing import List def count_words_with_a(words: List[str]) -> int: This function takes a list of words and returns the count of those words that contain the letter 'a' (case-insensitive). >>> count_words_with_a([\\"apple\\", \\"banana\\", \\"grape\\", \\"apricot\\"]) 4 >>> count_words_with_a([\\"blueberry\\", \\"cherry\\", \\"fig\\", \\"kiwi\\"]) 0 pass","solution":"def count_words_with_a(words): This function takes a list of words and returns the count of those words that contain the letter 'a' (case-insensitive). count = 0 for word in words: if 'a' in word.lower(): count += 1 return count"},{"question":"def count_moves_to_sort(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Calculate the minimum number of moves needed to sort the array \`a\` in non-decreasing order. Args: t (int): Number of test cases. test_cases (List[Tuple[int, List[int]]]): List of test cases, where each test case is a tuple containing the length of the array and the array itself. Returns: List[int]: List containing the minimum number of moves for each test case. Examples: >>> count_moves_to_sort(3, [(5, [5, 1, 4, 2, 3]), (4, [1, 3, 2, 4]), (3, [2, 1, 3])]) [6, 1, 1] >>> count_moves_to_sort(2, [(4, [1, 2, 3, 4]), (5, [1, 2, 3, 4, 5])]) [0, 0] >>> count_moves_to_sort(1, [(4, [4, 3, 2, 1])]) [6] >>> count_moves_to_sort(1, [(1, [1])]) [0] >>> count_moves_to_sort(1, [(5, [5, 4, 3, 2, 1])]) [10] pass","solution":"def count_moves_to_sort(t, test_cases): results = [] for i in range(t): n, a = test_cases[i] swaps = 0 sorted_flag = False # Perform a bubble sort and count the swaps while not sorted_flag: sorted_flag = True for j in range(n-1): if a[j] > a[j+1]: a[j], a[j+1] = a[j+1], a[j] swaps += 1 sorted_flag = False results.append(swaps) return results"},{"question":"def count_components(n: int, edges: List[Tuple[int, int]]) -> int: Returns the number of connected components in an undirected graph. :param n: Number of vertices :param edges: List of edges as pairs (u, v) :return: Number of connected components >>> count_components(6, [(1, 2), (2, 3), (4, 5)]) == 3 >>> count_components(8, [(1, 2), (3, 4), (4, 5), (6, 7), (7, 8)]) == 3 >>> count_components(5, []) == 5 >>> count_components(1, []) == 1 >>> count_components(2, []) == 2 >>> count_components(4, [(1, 2), (2, 3), (3, 4)]) == 1 >>> count_components(4, [(1, 2)]) == 3 >>> count_components(100, [(10, 20), (20, 30)]) == 98","solution":"def count_components(n, edges): Returns the number of connected components in an undirected graph. :param n: Number of vertices :param edges: List of edges as pairs (u, v) :return: Number of connected components from collections import defaultdict, deque # Build graph graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # To keep track of visited nodes visited = set() def bfs(start): queue = deque([start]) while queue: node = queue.popleft() for neighbor in graph[node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) components = 0 # Check all nodes from 1 to n for node in range(1, n + 1): if node not in visited: bfs(node) components += 1 return components # Example usage: # N = 6 # M = 3 # edges = [(1, 2), (2, 3), (4, 5)] # print(count_components(N, edges)) # Output should be 3"},{"question":"def find_anagram_groups(words): Returns a list of lists, where each list contains anagrams of each other. Each list is sorted in lexicographical order, and the final output is sorted by the first word of each list. >>> find_anagram_groups([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) [[\\"ate\\", \\"eat\\", \\"tea\\"], [\\"bat\\"], [\\"nat\\", \\"tan\\"]] >>> find_anagram_groups([\\"listen\\", \\"silent\\", \\"enlist\\", \\"hello\\", \\"ohell\\"]) [[\\"enlist\\", \\"listen\\", \\"silent\\"], [\\"hello\\", \\"ohell\\"]]","solution":"def find_anagram_groups(words): Returns a list of lists, where each list contains anagrams of each other. Each list is sorted in lexicographical order, and the final output is sorted by the first word of each list. from collections import defaultdict anagram_dict = defaultdict(list) # Group words by sorted character tuple for word in words: sorted_word = ''.join(sorted(word)) anagram_dict[sorted_word].append(word) # Sort each anagram group lexicographically for key in anagram_dict: anagram_dict[key].sort() # Convert to list and sort by the first word of each anagram group result = list(anagram_dict.values()) result.sort(key=lambda x: x[0]) return result"},{"question":"from collections import defaultdict, deque from typing import List, Tuple def moving_average(trades: List[Tuple[str, int]], window_size: int) -> List[str]: This function processes a sequence of stock trades and provides the moving average stock price over the specified window size. Parameters: trades (List[Tuple[str, int]]): list of tuples, where each tuple contains a string (stock symbol) and an integer (trade price) window_size (int): the size of the moving window for which the average price needs to be calculated Returns: List[str]: list of strings, where each string represents a stock symbol followed by the latest moving average price rounded to two decimal places >>> moving_average([(\\"AAPL\\", 250), (\\"AAPL\\", 260), (\\"AAPL\\", 270), (\\"GOOG\\", 600), (\\"GOOG\\", 590), (\\"AAPL\\", 280)], 3) ['AAPL 250.00', 'AAPL 255.00', 'AAPL 260.00', 'GOOG 600.00', 'GOOG 595.00', 'AAPL 270.00'] >>> moving_average([(\\"AAPL\\", 250), (\\"AAPL\\", 260), (\\"AAPL\\", 270)], 2) ['AAPL 250.00', 'AAPL 255.00', 'AAPL 265.00'] >>> moving_average([(\\"AAPL\\", 250)], 1) ['AAPL 250.00'] >>> moving_average([(\\"AAPL\\", 300), (\\"GOOG\\", 500), (\\"AAPL\\", 305), (\\"GOOG\\", 505), (\\"AAPL\\", 310)], 2) ['AAPL 300.00', 'GOOG 500.00', 'AAPL 302.50', 'GOOG 502.50', 'AAPL 307.50'] >>> moving_average([(\\"AAPL\\", 300), (\\"AAPL\\", 310), (\\"AAPL\\", 315), (\\"AAPL\\", 320)], 3) ['AAPL 300.00', 'AAPL 305.00', 'AAPL 308.33', 'AAPL 315.00'] >>> moving_average([], 3) []","solution":"from collections import defaultdict, deque def moving_average(trades, window_size): This function processes a sequence of stock trades and provides the moving average stock price over the specified window size. Parameters: - trades: list of tuples, where each tuple contains a string (stock symbol) and an integer (trade price) - window_size: integer, the size of the moving window for which the average price needs to be calculated Output: - list of strings, where each string represents a stock symbol followed by the latest moving average price rounded to two decimal places output = [] trade_history = defaultdict(deque) trade_sums = defaultdict(int) for symbol, price in trades: if len(trade_history[symbol]) == window_size: trade_sums[symbol] -= trade_history[symbol].popleft() trade_history[symbol].append(price) trade_sums[symbol] += price average = trade_sums[symbol] / len(trade_history[symbol]) output.append(f\\"{symbol} {average:.2f}\\") return output"},{"question":"def count_paper_pairs(n: int, papers: List[str]) -> int: Determines the number of pairs of papers that share at least one keyword. >>> count_paper_pairs(3, [\\"paperA biology chemistry\\", \\"paperB physics biology\\", \\"paperC chemistry mathematics\\"]) 2 >>> count_paper_pairs(5, [\\"paperD physics chemistry\\", \\"paperE biology\\", \\"paperF physics\\", \\"paperG mathematics\\", \\"paperH chemistry biology\\"]) 3 def process_input(input_lines: List[str]) -> List[int]: Processes the input lines to determine the number of pairs of papers that share keywords. >>> process_input([\\"3\\", \\"paperA biology chemistry\\", \\"paperB physics biology\\", \\"paperC chemistry mathematics\\", \\"0\\"]) [2] >>> process_input([\\"5\\", \\"paperD physics chemistry\\", \\"paperE biology\\", \\"paperF physics\\", \\"paperG mathematics\\", \\"paperH chemistry biology\\", \\"0\\"]) [3]","solution":"def count_paper_pairs(n, papers): from collections import defaultdict keyword_to_papers = defaultdict(set) # Parse papers and build a dictionary to track papers by keyword for paper in papers: data = paper.split() paper_id = data[0] keywords = data[1:] for keyword in keywords: keyword_to_papers[keyword].add(paper_id) # Use a set to keep track of all unique pairs pairs = set() # For each papers set in keyword_to_papers, create a combination of papers that have that keyword for paper_set in keyword_to_papers.values(): paper_list = list(paper_set) size = len(paper_list) for i in range(size): for j in range(i + 1, size): pair = tuple(sorted([paper_list[i], paper_list[j]])) pairs.add(pair) return len(pairs) def process_input(input_lines): results = [] index = 0 while index < len(input_lines): n = int(input_lines[index].strip()) if n == 0: break index += 1 papers = [] for _ in range(n): papers.append(input_lines[index].strip()) index += 1 result = count_paper_pairs(n, papers) results.append(result) return results"},{"question":"def minimum_vans(m, n, vans, packages): Determine the minimum number of vans required to deliver all packages. :param m: Number of warehouses :param n: Number of delivery points :param vans: List of integers representing number of vans available at each warehouse :param packages: List of integers representing number of packages at each delivery point :return: Minimum number of vans required or -1 if impossible >>> minimum_vans(3, 4, [10, 5, 3], [8, 3, 15, 9]) 4 >>> minimum_vans(2, 3, [1, 1], [5, 6, 7]) -1 >>> minimum_vans(2, 2, [2, 2], [1, 1]) 2","solution":"def minimum_vans(m, n, vans, packages): Determine the minimum number of vans required to deliver all packages. :param m: Number of warehouses :param n: Number of delivery points :param vans: List of integers representing number of vans available at each warehouse :param packages: List of integers representing number of packages at each delivery point :return: Minimum number of vans required or -1 if impossible total_vans = sum(vans) total_packages = len(packages) # If total vans are less than delivery points, we cannot deliver all packages. if total_vans < total_packages: return -1 return total_packages # Example use case if __name__ == \\"__main__\\": # Reading inputs manually m, n = 2, 2 vans = [2, 2] packages = [1, 1] print(minimum_vans(m, n, vans, packages)) # Output: 2"},{"question":"def check_robot_performance(n: int, performance_data: List[Tuple[int, int]]) -> List[str]: Determines if each robot meets the minimum performance criteria. Parameters: n (int): The number of robots. performance_data (list of tuples): List containing tuples in which each tuple contains two integers representing the number of tasks attempted and the number of successful attempts. Returns: list of str: List containing \\"QUALIFIED\\" or \\"DISQUALIFIED\\" for each robot based on its performance. >>> check_robot_performance(3, [(10, 5), (7, 4), (8, 3)]) [\\"QUALIFIED\\", \\"QUALIFIED\\", \\"DISQUALIFIED\\"] >>> check_robot_performance(2, [(6, 2), (5, 3)]) [\\"DISQUALIFIED\\", \\"QUALIFIED\\"]","solution":"def check_robot_performance(n, performance_data): Determines if each robot meets the minimum performance criteria. Parameters: n (int): The number of robots. performance_data (list of tuples): List containing tuples in which each tuple contains two integers representing the number of tasks attempted and the number of successful attempts. Returns: list of str: List containing \\"QUALIFIED\\" or \\"DISQUALIFIED\\" for each robot based on its performance. results = [] for ai, si in performance_data: if si >= ai / 2: results.append(\\"QUALIFIED\\") else: results.append(\\"DISQUALIFIED\\") return results"},{"question":"def min_trips(n: int, k: int, residents: List[int]) -> int: Determines the minimum number of trips required to deliver food to all houses. Parameters: n (int): Number of houses. k (int): Maximum number of houses the truck can deliver to in a single trip. residents (list): List of integers representing the number of residents in each house. Returns: int: Minimum number of trips required. >>> min_trips(6, 3, [2, 3, 4, 5, 1, 2]) 2 >>> min_trips(1, 1, [10]) 1 >>> min_trips(5, 5, [1, 2, 3, 4, 5]) 1 >>> min_trips(10, 3, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 4 >>> min_trips(999, 1, [1]*999) 999","solution":"def min_trips(n, k, residents): Determines the minimum number of trips required to deliver food to all houses. Parameters: n (int): Number of houses. k (int): Maximum number of houses the truck can deliver to in a single trip. residents (list): List of integers representing the number of residents in each house. Returns: int: Minimum number of trips required. return (n + k - 1) // k"},{"question":"def count_adjacent_swaps_to_sort(arr: List[int]) -> int: Returns the number of adjacent swaps needed to sort the list in ascending order. >>> count_adjacent_swaps_to_sort([5, 3, 2, 4, 1]) # 8 >>> count_adjacent_swaps_to_sort([1, 3, 5, 2, 4, 6]) # 3 >>> count_adjacent_swaps_to_sort([1, 2, 3, 4, 5]) # 0 >>> count_adjacent_swaps_to_sort([5, 4, 3, 2, 1]) # 10 >>> count_adjacent_swaps_to_sort([1]) # 0 >>> count_adjacent_swaps_to_sort([1, 2]) # 0 >>> count_adjacent_swaps_to_sort([2, 1]) # 1 >>> count_adjacent_swaps_to_sort(list(range(100, 0, -1))) # 4950","solution":"def count_adjacent_swaps_to_sort(arr): Returns the number of adjacent swaps needed to sort the list in ascending order. n = len(arr) swaps = 0 for i in range(n): for j in range(0, n-i-1): if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] swaps += 1 return swaps"},{"question":"from typing import List def longest_non_negative_stretch(n: int, altitude_changes: List[int]) -> int: Given a list of integers representing the daily altitude changes, find the length of the longest subsequence where all elements are non-negative (i.e., the altitude did not decrease). Args: n (int): the number of days Philip tracked the birds. altitude_changes (List[int]): list of integers representing the altitude changes over n days. Returns: int: the length of the longest stretch of days with non-negative altitude changes. Examples: >>> longest_non_negative_stretch(10, [-1, 2, 3, -5, 4, 0, 3, 2, -2, 3]) 4 >>> longest_non_negative_stretch(5, [0, 0, 0, 0, 0]) 5 >>> longest_non_negative_stretch(7, [-1, -2, -3, -4, -5, -6, -7]) 0","solution":"def longest_non_negative_stretch(n, altitude_changes): longest_stretch = 0 current_stretch = 0 for change in altitude_changes: if change >= 0: current_stretch += 1 longest_stretch = max(longest_stretch, current_stretch) else: current_stretch = 0 return longest_stretch"},{"question":"def min_travel_distance(n: int, d_max: int, distances: List[List[int]]) -> int: Calculate the minimal total travel distance for a spaceship to visit all planets exactly once and return to the starting planet without exceeding the fuel limit. If it's not possible, return -1. Args: n (int): Number of planets. d_max (int): Maximum permissible travel distance. distances (List[List[int]]): A 2D list representing distances between planets. Returns: int: Minimal total travel distance or -1 if the journey is not possible within the fuel limit. Examples: >>> min_travel_distance(4, 100, [ ... [0, 20, 42, 35], ... [20, 0, 30, 34], ... [42, 30, 0, 12], ... [35, 34, 12, 0]]) 97 >>> min_travel_distance(3, 10, [ ... [0, 1, 100], ... [1, 0, 100], ... [100, 100, 0]]) -1","solution":"from itertools import permutations def min_travel_distance(n, d_max, distances): if n == 1: return 0 if d_max >= 0 else -1 def calc_distance(route): return sum(distances[route[i]][route[i+1]] for i in range(len(route)-1)) + distances[route[-1]][route[0]] planets = list(range(n)) min_distance = float('inf') for perm in permutations(planets[1:]): route = [0] + list(perm) distance = calc_distance(route) if distance < min_distance: min_distance = distance return min_distance if min_distance <= d_max else -1 # Example Usage n = 4 d_max = 100 distances = [ [0, 20, 42, 35], [20, 0, 30, 34], [42, 30, 0, 12], [35, 34, 12, 0] ] print(min_travel_distance(n, d_max, distances)) # Output: 97"},{"question":"def unique_names(n: int, names: List[str]) -> List[str]: Take a list of names and return a list of the names with appropriate suffixes added to duplicate names to make each name unique. >>> unique_names(5, [\\"alice\\", \\"bob\\", \\"alice\\", \\"alice\\", \\"bob\\"]) [\\"alice\\", \\"bob\\", \\"alice_1\\", \\"alice_2\\", \\"bob_1\\"] >>> unique_names(3, [\\"carl\\", \\"carl\\", \\"carl\\"]) [\\"carl\\", \\"carl_1\\", \\"carl_2\\"]","solution":"def unique_names(n, names): name_count = {} result = [] for name in names: if name in name_count: name_count[name] += 1 new_name = f\\"{name}_{name_count[name]}\\" else: name_count[name] = 0 new_name = name result.append(new_name) return result"},{"question":"def num_disconnected_sets(n: int, m: int, connections: List[Tuple[int, int]], q: int, removals: List[Tuple[int, int]]) -> List[int]: Determine the number of distinct sets of computers which are still connected after each specified connection is removed. Arguments: n : int : The number of computers. m : int : The number of initial connections. connections : List[Tuple[int, int]] : A list of tuples where each tuple contains two integers representing a bidirectional connection between computers. q : int : The number of connections to be removed. removals : List[Tuple[int, int]] : A list of tuples where each tuple contains two integers representing a connection to be removed. Returns: List[int] : A list of integers representing the number of distinct sets of connected computers after each specified connection is removed. >>> num_disconnected_sets(6, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)], 2, [(2, 3), (4, 5)]) [2, 3] >>> num_disconnected_sets(6, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)], 0, []) [] >>> num_disconnected_sets(6, 0, [], 1, [(1, 2)]) [6] >>> num_disconnected_sets(4, 3, [(1, 2), (2, 3), (3, 4)], 1, [(2, 3)]) [2]","solution":"def num_disconnected_sets(n, m, connections, q, removals): Returns the number of distinct sets of connected computers after each specified connection is removed. # Initialize parent and rank for union-find parent = list(range(n)) rank = [0] * n def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 def reconnect(): for i in range(n): parent[i] = i for u, v in connections: union(u - 1, v - 1) results = [] for remove_u, remove_v in removals: connections = [conn for conn in connections if conn != (remove_u, remove_v)] reconnect() distinct_sets = len(set(find(x) for x in range(n))) results.append(distinct_sets) return results"},{"question":"def manage_list(n: int, q: int, initial_list: List[int], operations: List[str]) -> List[int]: Perform a sequence of operations on a list and return the results of count operations. >>> manage_list(7, 11, [1, 2, 3, 4, 5, 6, 7], ['1 3 10', '1 10 20', '2 5', '2 8', '3 6 15', '4 10', '4 15', '4 2', '4 7', '4 100']) [1, 1, 1, 1, 0] >>> manage_list(1, 1, [1], ['1 5 20']) [] >>> manage_list(1, 1, [1], ['2 2']) [] >>> manage_list(1, 1, [1], ['3 2 10']) [] >>> manage_list(3, 2, [1, 2, 1], ['4 1', '4 2']) [2, 1] >>> manage_list(4, 5, [2, 3, 4, 5], ['1 2 7', '2 3', '3 1 10', '4 7', '4 10']) [1, 1] from solution import manage_list def test_example_case(): n = 7 q = 11 initial_list = [1, 2, 3, 4, 5, 6, 7] operations = [ '1 3 10', '1 10 20', '2 5', '2 8', '3 6 15', '4 10', '4 15', '4 2', '4 7', '4 100' ] result = manage_list(n, q, initial_list, operations) assert result == [1, 1, 1, 1, 0] def test_insert_out_of_bounds(): n = 1 q = 1 initial_list = [1] operations = ['1 5 20'] result = manage_list(n, q, initial_list, operations) assert result == [] assert initial_list == [1, 20] def test_remove_out_of_bounds(): n = 1 q = 1 initial_list = [1] operations = ['2 2'] result = manage_list(n, q, initial_list, operations) assert result == [] def test_replace_out_of_bounds(): n = 1 q = 1 initial_list = [1] operations = ['3 2 10'] result = manage_list(n, q, initial_list, operations) assert result == [] assert initial_list == [1] def test_count_elements(): n = 3 q = 2 initial_list = [1, 2, 1] operations = ['4 1', '4 2'] result = manage_list(n, q, initial_list, operations) assert result == [2, 1] def test_mixed_operations(): n = 4 q = 5 initial_list = [2, 3, 4, 5] operations = ['1 2 7', '2 3', '3 1 10', '4 7', '4 10'] result = manage_list(n, q, initial_list, operations) assert result == [1, 1] assert initial_list == [10, 7, 4, 5]","solution":"def manage_list(n, q, initial_list, operations): result_list = initial_list result = [] for operation in operations: op = operation.split() type_of_operation = int(op[0]) if type_of_operation == 1: x = int(op[1]) y = int(op[2]) if x > len(result_list): result_list.append(y) else: result_list.insert(x - 1, y) elif type_of_operation == 2: x = int(op[1]) if 1 <= x <= len(result_list): result_list.pop(x - 1) elif type_of_operation == 3: x = int(op[1]) y = int(op[2]) if 1 <= x <= len(result_list): result_list[x - 1] = y elif type_of_operation == 4: y = int(op[1]) result.append(result_list.count(y)) return result"},{"question":"def prefix_sum(array): Computes the prefix sum of the given array. pass def range_sum(prefix, L, R): Computes the range sum using the prefix sum array. pass def sum_queries(n, q, array, queries): Computes the sum for each query in the list of queries. >>> sum_queries(5, 3, [1, 2, 3, 4, 5], [(1, 3), (2, 4), (1, 5)]) [6, 9, 15] >>> sum_queries(5, 0, [1, 2, 3, 4, 5], []) [] >>> sum_queries(1, 1, [10], [(1, 1)]) [10] >>> sum_queries(3, 1, [10**9, 10**9, 10**9], [(1, 3)]) [3000000000] pass","solution":"def prefix_sum(array): Computes the prefix sum of the given array. prefix = [0] * (len(array) + 1) for i in range(1, len(array) + 1): prefix[i] = prefix[i - 1] + array[i - 1] return prefix def range_sum(prefix, L, R): Computes the range sum using the prefix sum array. return prefix[R] - prefix[L - 1] def sum_queries(n, q, array, queries): Computes the sum for each query in the list of queries. prefix = prefix_sum(array) results = [] for L, R in queries: results.append(range_sum(prefix, L, R)) return results"},{"question":"from typing import List def determine_winner(grid: List[List[int]]) -> str: Determines the winner of the rectangle game given the grid. >>> determine_winner([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 'John' >>> determine_winner([[1, 2], [3, 4]]) 'Jane' from solution import determine_winner def test_john_wins(): grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] assert determine_winner(grid) == \\"John\\" def test_jane_wins(): grid = [[1, 2], [3, 4]] assert determine_winner(grid) == \\"Jane\\" def test_john_wins_with_odd_total(): grid = [[1]] assert determine_winner(grid) == \\"John\\" def test_jane_wins_with_even_total(): grid = [[2]] assert determine_winner(grid) == \\"Jane\\" def test_large_grid_odd_total(): grid = [[1] * 1000 for _ in range(1000)] grid[999][999] = 2 # Make the total sum odd assert determine_winner(grid) == \\"John\\" def test_large_grid_even_total(): grid = [[1] * 1000 for _ in range(1000)] assert determine_winner(grid) == \\"Jane\\"","solution":"def determine_winner(grid): Determines the winner of the rectangle game given the grid. Parameters: - grid: a list of lists representing the grid with scores in the cells Returns: - A string \\"John\\" if John wins, otherwise \\"Jane\\". total_sum = 0 for row in grid: total_sum += sum(row) if total_sum % 2 == 1: return \\"John\\" else: return \\"Jane\\" # Example usage: r, c = 2, 2 matrix = [ [1, 2], [3, 4] ] print(determine_winner(matrix))"},{"question":"def max_children(n: int, k: int, a: List[int]) -> int: Sara wants to know the maximum number of children she can distribute the candies to such that each child receives exactly the same number of candies, and no candies are left undistributed. Input: n (int): total number of candies (1  n  200 000) k (int): number of different types of candies (1  k  200 000) a (List[int]): list of integers where ai represents the number of candies of the i-th type (1  ai  10^9) Output: int: the maximum number of children who can receive the same total number of candies. Examples: >>> max_children(10, 3, [2, 3, 5]) 1 >>> max_children(12, 4, [2, 4, 6, 8]) 2 >>> max_children(8, 2, [4, 4]) 4","solution":"def max_children(n, k, a): from math import gcd from functools import reduce def find_gcd(arr): return reduce(gcd, arr) return find_gcd(a)"},{"question":"def min_moves_to_reorganize(r: int, c: int, station: List[List[str]]) -> int: Determine the minimum number of moves needed to achieve the goal of no track having more than one container and no container is left on its original track. >>> min_moves_to_reorganize(3, 4, [[\\"#\\", \\"C\\", \\"#\\", \\"B\\"], [\\"A\\", \\"#\\", \\"D\\", \\"#\\"], [\\"#\\", \\"#\\", \\"Z\\", \\"#\\"]]) 4 >>> min_moves_to_reorganize(2, 3, [[\\"#\\", \\"B\\", \\"#\\"], [\\"C\\", \\"#\\", \\"#\\"]]) 2","solution":"def min_moves_to_reorganize(r, c, station): from heapq import heappush, heappop priority_queue = [] empty_slots = [] move_count = 0 # Collect all containers and empty slots for i in range(r): for j in range(c): if station[i][j] != '#': heappush(priority_queue, (station[i][j], i, j)) else: empty_slots.append((i, j)) # Move containers to empty slots ensuring no container stays in original track while priority_queue: priority, orig_i, orig_j = heappop(priority_queue) # Find the first valid empty slot that is not in the same track for slot in empty_slots: new_i, new_j = slot if new_i != orig_i: empty_slots.remove(slot) move_count += 1 break return move_count # Example usage # r = 3, c = 4 # station = [ # \\"#C#B\\", # \\"A#D#\\", # \\"Z#\\" # ] # Output: 4 r, c = 3, 4 station = [ \\"#C#B\\", \\"A#D#\\", \\"Z#\\" ] print(min_moves_to_reorganize(r, c, [list(row) for row in station])) # Should output 4"},{"question":"def can_be_palindrome_by_removing_one(s: str) -> str: This function evaluates a string and determines whether it can be converted to a palindrome by removing at most one character. Input: s (str) - a single string Output: Returns \\"Yes\\" if the string can be turned into a palindrome by removing at most one character, and \\"No\\" otherwise. Examples: >>> can_be_palindrome_by_removing_one(\\"radakr\\") \\"Yes\\" >>> can_be_palindrome_by_removing_one(\\"abcdefdba\\") \\"No\\" >>> can_be_palindrome_by_removing_one(\\"racecar\\") \\"Yes\\" >>> can_be_palindrome_by_removing_one(\\"abca\\") \\"Yes\\" >>> can_be_palindrome_by_removing_one(\\"abc\\") \\"No\\" >>> can_be_palindrome_by_removing_one(\\"\\") \\"Yes\\" >>> can_be_palindrome_by_removing_one(\\"a\\") \\"Yes\\" >>> can_be_palindrome_by_removing_one(\\"aa\\") \\"Yes\\" >>> can_be_palindrome_by_removing_one(\\"aba\\") \\"Yes\\" >>> can_be_palindrome_by_removing_one(\\"abccba\\") \\"Yes\\"","solution":"def can_be_palindrome_by_removing_one(s): This function returns 'Yes' if the input string can be turned into a palindrome by removing at most one character, otherwise it returns 'No'. def is_palindrome_range(start, end): while start < end: if s[start] != s[end]: return False start += 1 end -= 1 return True left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: if is_palindrome_range(left + 1, right) or is_palindrome_range(left, right - 1): return \\"Yes\\" else: return \\"No\\" left += 1 right -= 1 return \\"Yes\\""},{"question":"import heapq from typing import List def easiest_path(n: int, m: int, grid: List[List[int]]) -> int: Find the path from the top-left to the bottom-right with the minimum possible maximum altitude difference. >>> easiest_path(4, 3, [ ... [1, 2, 2], ... [3, 4, 2], ... [2, 2, 1], ... [1, 3, 3] ... ]) 1 >>> easiest_path(1, 1, [[5]]) 0 >>> easiest_path(3, 1, [ ... [1], ... [4], ... [7] ... ]) 3 >>> easiest_path(3, 3, [ ... [5, 5, 5], ... [5, 5, 5], ... [5, 5, 5] ... ]) 0 >>> easiest_path(2, 2, [ ... [1, 3], ... [2, 4] ... ]) 2","solution":"import heapq def easiest_path(n, m, grid): Find the path from the top-left to the bottom-right with the minimum possible maximum altitude difference. def neighbors(x, y): for nx, ny in [(x-1, y), (x+1, y), (x, y-1), (x, y+1)]: if 0 <= nx < n and 0 <= ny < m: yield nx, ny # Priority queue with elements (current_max_diff, x, y) pq = [(0, 0, 0)] max_diff = [[float('inf')] * m for _ in range(n)] max_diff[0][0] = 0 while pq: current_max_diff, x, y = heapq.heappop(pq) if (x, y) == (n-1, m-1): return current_max_diff for nx, ny in neighbors(x, y): diff = abs(grid[nx][ny] - grid[x][y]) new_max_diff = max(current_max_diff, diff) if new_max_diff < max_diff[nx][ny]: max_diff[nx][ny] = new_max_diff heapq.heappush(pq, (new_max_diff, nx, ny)) return -1 # It should never reach here due to guaranteed path condition # Example usage: # n, m = 4, 3 # grid = [ # [1, 2, 2], # [3, 4, 2], # [2, 2, 1], # [1, 3, 3] # ] # print(easiest_path(n, m, grid)) # Output: 1"},{"question":"def generate_triangle_patterns(dataset: list) -> str: Generate and returns right-angle triangle patterns based on the given dataset. Each integer N represents the number of rows for the triangle. The function will stop processing when an N=0 is encountered. >>> generate_triangle_patterns([3]) '*n**n***' >>> generate_triangle_patterns([3, 2]) '*n**n***nn*n**' >>> generate_triangle_patterns([3, 0]) '*n**n***' >>> generate_triangle_patterns([]) '' >>> generate_triangle_patterns([100]) 'n'.join(['*' * (i + 1) for i in range(100)])","solution":"def generate_triangle_patterns(dataset): Generate and returns right-angle triangle patterns based on the given dataset. Parameters: dataset (list): A list of integers where each integer N represents the number of rows for the triangle. Returns: list: A list of strings, each representing a right-angle triangle pattern. result = [] for N in dataset: if N == 0: break pattern = \\"n\\".join([\\"*\\" * (i + 1) for i in range(N)]) result.append(pattern) return \\"nn\\".join(result)"},{"question":"def count_palindromic_substrings(S: str) -> int: Returns the number of palindromic substrings in the given string S. >>> count_palindromic_substrings(\\"abba\\") 6 >>> count_palindromic_substrings(\\"abc\\") 3 >>> count_palindromic_substrings(\\"aaa\\") 6 >>> count_palindromic_substrings(\\"a\\") 1 >>> count_palindromic_substrings(\\"abcd\\") 4 >>> count_palindromic_substrings(\\"racecar\\") 10 >>> count_palindromic_substrings(\\"madam\\") 7 >>> count_palindromic_substrings(\\"abccba\\") 9 >>> count_palindromic_substrings(\\"noon\\") 6","solution":"def count_palindromic_substrings(S): Returns the number of palindromic substrings in the given string S. n = len(S) count = 0 # Create a 2D table to keep track of palindromic substrings dp = [[False] * n for _ in range(n)] # Single character substrings are palindromes for i in range(n): dp[i][i] = True count += 1 # Check for palindromic substrings of length 2 and more for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 if S[i] == S[j]: if length == 2 or dp[i + 1][j - 1]: dp[i][j] = True count += 1 return count"},{"question":"def binary_tree_to_bst(nums: List[int]) -> int: Convert a binary tree represented as an array into a binary search tree (BST) with the minimum number of swaps. Args: nums (List[int]): List of integers representing the values of the nodes in the binary tree. Returns: int: Minimum number of swaps required to convert the binary tree into a BST. Examples: >>> binary_tree_to_bst([5, 2, 4, 1, 3, 6, 7]) 3 >>> binary_tree_to_bst([]) 0 >>> binary_tree_to_bst([1]) 0 >>> binary_tree_to_bst([1, 2, 3, 4, 5, 6, 7]) 0 >>> binary_tree_to_bst([3, 1, 4, 0, 2, 5, 6]) 2 >>> binary_tree_to_bst([7, 6, 5, 4, 3, 2, 1]) 3","solution":"def binary_tree_to_bst(nums): Convert binary tree to BST with the minimum number of swaps. if not nums: return 0 # Indexing the elements indexed_nums = list(enumerate(nums)) # Sort the array to know the target positions of elements in BST indexed_nums.sort(key=lambda x: x[1]) visited = {i: False for i in range(len(nums))} swaps = 0 for i in range(len(nums)): # If already visited or already at the correct position, continue if visited[i] or indexed_nums[i][0] == i: continue # Calculate cycle size cycle_size = 0 x = i while not visited[x]: visited[x] = True x = indexed_nums[x][0] cycle_size += 1 # If the cycle size is n, we do (n-1) swaps. if cycle_size > 0: swaps += (cycle_size - 1) return swaps"},{"question":"def read_movie_titles(file_path): Read movie titles from a text file. :param file_path: str, path to the movie titles file. :return: list of movie titles. def read_movie_ratings(file_path): Read movie ratings from a text file. :param file_path: str, path to the ratings file. :return: dict of movie titles and their ratings. def calculate_average_ratings(ratings): Calculate the average rating for each movie. :param ratings: dict of movie titles and their respective ratings. :return: dict of movie titles and their average ratings. def get_top_10_movies(avg_ratings): Get the top 10 highest-rated movies. :param avg_ratings: dict of movie titles and their average ratings. :return: list of top 10 highest-rated movie titles. if __name__ == \\"__main__\\": import pytest def test_read_movie_titles(tmp_path): file_content = \\"Movie AnMovie BnMovie Cn\\" movie_file = tmp_path / \\"movie_titles.txt\\" movie_file.write_text(file_content) expected_movies = [\\"Movie A\\", \\"Movie B\\", \\"Movie C\\"] assert read_movie_titles(movie_file) == expected_movies def test_read_movie_ratings(tmp_path): file_content = \\"Movie A, 5nMovie B, 3nMovie A, 4nMovie C, 2n\\" ratings_file = tmp_path / \\"ratings.txt\\" ratings_file.write_text(file_content) expected_ratings = { \\"Movie A\\": [5, 4], \\"Movie B\\": [3], \\"Movie C\\": [2] } assert read_movie_ratings(ratings_file) == expected_ratings def test_calculate_average_ratings(): ratings = { \\"Movie A\\": [5, 4], \\"Movie B\\": [3], \\"Movie C\\": [2] } expected_avg_ratings = { \\"Movie A\\": 4.5, \\"Movie B\\": 3.0, \\"Movie C\\": 2.0 } assert calculate_average_ratings(ratings) == expected_avg_ratings def test_get_top_10_movies(): avg_ratings = { \\"Movie A\\": 4.5, \\"Movie B\\": 4.5, \\"Movie C\\": 2.0, \\"Movie D\\": 3.5, \\"Movie E\\": 5.0, \\"Movie F\\": 4.0, \\"Movie G\\": 3.7, \\"Movie H\\": 3.9, \\"Movie I\\": 2.5, \\"Movie J\\": 4.2, \\"Movie K\\": 4.3, } expected_top_10 = [ \\"Movie E\\", \\"Movie A\\", \\"Movie B\\", \\"Movie K\\", \\"Movie J\\", \\"Movie F\\", \\"Movie H\\", \\"Movie G\\", \\"Movie D\\", \\"Movie I\\" ] assert get_top_10_movies(avg_ratings) == expected_top_10 pytest.main()","solution":"def read_movie_titles(file_path): with open(file_path, \\"r\\") as file: return [line.strip() for line in file.readlines()] def read_movie_ratings(file_path): ratings = {} with open(file_path, \\"r\\") as file: for line in file: movie_title, rating = line.strip().split(\\", \\") rating = int(rating) if movie_title not in ratings: ratings[movie_title] = [] ratings[movie_title].append(rating) return ratings def calculate_average_ratings(ratings): avg_ratings = {} for movie_title, rating_list in ratings.items(): avg_ratings[movie_title] = sum(rating_list) / len(rating_list) return avg_ratings def get_top_10_movies(avg_ratings): sorted_movies = sorted(avg_ratings.items(), key=lambda x: (-x[1], x[0])) top_10_movies = [title for title, _ in sorted_movies[:10]] return top_10_movies def main(): movie_titles = read_movie_titles(\\"movie_titles.txt\\") movie_ratings = read_movie_ratings(\\"ratings.txt\\") avg_ratings = calculate_average_ratings(movie_ratings) top_10_movies = get_top_10_movies(avg_ratings) for movie in top_10_movies: print(movie) if __name__ == \\"__main__\\": main()"},{"question":"def num_paths(n: int, m: int, grid: List[str]) -> int: Returns the number of distinct paths from the top-left to the bottom-right corner of the grid. Parameters: n (int): number of rows in the grid m (int): number of columns in the grid grid (List[str]): grid representation where '.' is a passable cell and '#' is an impassable cell Returns: int: number of distinct paths Examples: >>> num_paths(3, 3, [\\"...\\", \\".#.\\", \\"...\\"]) 2 >>> num_paths(4, 4, [\\"....\\", \\"..\\", \\"....\\", \\"....\\"]) 4 >>> num_paths(3, 3, [\\"#..\\", \\"...\\", \\"...\\"]) 0","solution":"def num_paths(n, m, grid): Returns the number of distinct paths from the top-left to the bottom-right corner of the grid. if grid[0][0] == '#' or grid[n-1][m-1] == '#': return 0 dp = [[0]*m for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(m): if grid[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[-1][-1] # Example usage: # n = 3 # m = 3 # grid = [ # \\"...\\", # \\".#.\\", # \\"...\\" # ] # print(num_paths(n, m, grid)) # Output: 2"},{"question":"def min_operations_to_non_decreasing(n: int, heights: List[int]) -> int: Determines the minimum number of operations required to make the towers' heights non-decreasing. Parameters: n (int): The number of towers. heights (list of int): The initial heights of the towers. Returns: int: The minimum number of operations required. >>> min_operations_to_non_decreasing(5, [2, 0, 3, 4, 0]) 2 >>> min_operations_to_non_decreasing(6, [0, 0, 0, 0, 0, 0]) 5 >>> min_operations_to_non_decreasing(4, [1, 2, 3, 4]) 0 >>> min_operations_to_non_decreasing(3, [0, 0, 0]) 2 >>> min_operations_to_non_decreasing(1, [0]) 0 >>> min_operations_to_non_decreasing(5, [1, 2, 0, 4, 5]) 1 >>> min_operations_to_non_decreasing(5, [1, 1, 1, 1, 1]) 0 >>> min_operations_to_non_decreasing(5, [1, 0, 1, 0, 1]) 2 >>> min_operations_to_non_decreasing(3, [1, 0, 1000000000]) 1","solution":"def min_operations_to_non_decreasing(n, heights): Determines the minimum number of operations required to make the towers' heights non-decreasing. Parameters: n (int): The number of towers. heights (list of int): The initial heights of the towers. Returns: int: The minimum number of operations required. operations = 0 for i in range(1, n): if heights[i] == 0: # Find the next non-zero height next_non_zero_index = i while next_non_zero_index < n and heights[next_non_zero_index] == 0: next_non_zero_index += 1 next_non_zero_height = heights[next_non_zero_index] if next_non_zero_index < n else heights[i - 1] + 1 heights[i] = max(heights[i - 1], next_non_zero_height) operations += 1 return operations"},{"question":"def min_partitions_with_equal_zeros_and_ones(binary_string: str) -> int: Partition a binary string into the minimum number of substrings such that each substring contains an equal number of '0's and '1's. >>> min_partitions_with_equal_zeros_and_ones(\\"110011\\") 1 >>> min_partitions_with_equal_zeros_and_ones(\\"00110011\\") 2 def solve(test_cases: List[str]) -> List[int]: Given a list of binary strings, return a list of integers where each integer represents the minimum number of substrings that have an equal number of '0's and '1's. >>> solve([\\"110011\\", \\"00110011\\"]) [1, 2]","solution":"def min_partitions_with_equal_zeros_and_ones(binary_string): count_0, count_1 = 0, 0 partitions = 0 for char in binary_string: if char == '0': count_0 += 1 else: count_1 += 1 if count_0 == count_1: partitions += 1 return partitions def solve(test_cases): results = [] for binary_string in test_cases: results.append(min_partitions_with_equal_zeros_and_ones(binary_string)) return results"},{"question":"def min_adjustments_needed(n: int, heights: List[int]) -> int: Determines the minimum number of buildings that need to be adjusted such that every pair of adjacent buildings has a height difference of at most 1. You can only decrease the height of a building. >>> min_adjustments_needed(5, [4, 3, 2, 1, 5]) 1 >>> min_adjustments_needed(5, [1, 3, 5, 7, 9]) 4 >>> min_adjustments_needed(5, [5, 4, 3, 2, 1]) 0","solution":"def min_adjustments_needed(n, heights): Returns the minimum number of buildings that need to be adjusted such that every pair of adjacent buildings has a height difference of at most 1. We can only decrease the height of a building. count_adjustments = 0 for i in range(1, n): if heights[i] > heights[i-1] + 1: count_adjustments += 1 heights[i] = heights[i-1] + 1 return count_adjustments"},{"question":"def count_subordinates(n: int, employees: List[Tuple[int, int]]) -> List[int]: Calculates the number of direct and indirect subordinates for each employee. Args: n (int): The number of employees. employees (List[Tuple[int, int]]): A list where each tuple contains two integers: the employee ID and the manager ID. Returns: List[int]: A list of integers where the i-th element is the total number of direct and indirect subordinates of the employee with ID i. >>> n = 6 >>> employees = [(0, -1), (1, 0), (2, 0), (3, 1), (4, 1), (5, 2)] >>> count_subordinates(n, employees) [5, 2, 1, 0, 0, 0] >>> n = 1 >>> employees = [(0, -1)] >>> count_subordinates(n, employees) [0]","solution":"from typing import List, Tuple def count_subordinates(n: int, employees: List[Tuple[int, int]]) -> List[int]: from collections import defaultdict # Build the adjacency list for the tree tree = defaultdict(list) root = -1 for emp, manager in employees: if manager == -1: root = emp else: tree[manager].append(emp) # Array to store the results subordinates_count = [0] * n # Function to perform DFS and count subordinates def dfs(employee): total_subordinates = 0 for subordinate in tree[employee]: total_subordinates += 1 + dfs(subordinate) subordinates_count[employee] = total_subordinates return total_subordinates # Start DFS from the root (the CEO) dfs(root) return subordinates_count"},{"question":"from typing import List, Tuple def max_height_stacks(test_cases: List[List[Tuple[int, int, int]]]) -> List[int]: Returns a list of maximum heights for each test case by stacking containers. >>> data = 2 ... 4 ... 4 4 5 ... 3 3 6 ... 2 2 3 ... 1 1 2 ... 3 ... 10 10 1 ... 9 9 2 ... 8 8 3 >>> test_cases = process_input(data) >>> max_height_stacks(test_cases) [16, 6] pass # Replace with your implementation def process_input(data: str) -> List[List[Tuple[int, int, int]]]: Processes the input to extract test cases conveniently. >>> data = 2 ... 4 ... 4 4 5 ... 3 3 6 ... 2 2 3 ... 1 1 2 ... 3 ... 10 10 1 ... 9 9 2 ... 8 8 3 >>> process_input(data) [ [(4, 4, 5), (3, 3, 6), (2, 2, 3), (1, 1, 2)], [(10, 10, 1), (9, 9, 2), (8, 8, 3)] ] pass # Replace with your implementation def process_output(results: List[int]) -> None: Formats the output to the required format. >>> results = [16, 6] >>> process_output(results) 16 6 pass # Replace with your implementation","solution":"def max_height_stacks(test_cases): Returns a list of maximum heights for each test case by stacking containers. results = [] for containers in test_cases: # Sort containers by base area in descending order containers.sort(key=lambda x: x[0] * x[1], reverse=True) # Initialize a dp array to store the maximum height at each index n = len(containers) dp = [0] * n # Fill dp array, where dp[i] represents the maximum height achievable with container i at the bottom for i in range(n): dp[i] = containers[i][2] # Height of container i for j in range(i): if containers[j][0] > containers[i][0] and containers[j][1] > containers[i][1]: dp[i] = max(dp[i], dp[j] + containers[i][2]) # The answer is the maximum value in dp array results.append(max(dp)) return results def process_input(data): Processes the input to extract test cases conveniently. lines = data.strip().split('n') T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): N = int(lines[index]) containers = [] for j in range(N): l, w, h = map(int, lines[index + j + 1].split()) containers.append((l, w, h)) test_cases.append(containers) index += N + 1 return test_cases def process_output(results): Formats the output to the required format. for result in results: print(result) # Example usage: data = 2 4 4 4 5 3 3 6 2 2 3 1 1 2 3 10 10 1 9 9 2 8 8 3 test_cases = process_input(data) results = max_height_stacks(test_cases) process_output(results)"},{"question":"def is_anagram(s1: str, s2: str) -> str: Determines if s2 is an anagram of s1. Parameters: s1 (str): First string s2 (str): Second string Returns: str: \\"YES\\" if s2 is an anagram of s1, otherwise \\"NO\\" Examples: >>> is_anagram(\\"listen\\", \\"silent\\") \\"YES\\" >>> is_anagram(\\"hello\\", \\"billion\\") \\"NO\\"","solution":"def is_anagram(s1, s2): Checks if s2 is an anagram of s1. Parameters: s1 (str): First string s2 (str): Second string Returns: str: \\"YES\\" if s2 is an anagram of s1, otherwise \\"NO\\" # Sort both strings and compare return \\"YES\\" if sorted(s1) == sorted(s2) else \\"NO\\""},{"question":"def max_unique_city_designs(N: int, M: int, X: int, city_ids: List[int]) -> int: Determines the maximum number of unique city designs Ana can place in her album. Parameters: N (int): The total number of postcards in Ana's collection. M (int): The number of different cities. X (int): The maximum number of postcards Ana can place in her album. city_ids (list of int): The city IDs for each postcard in Ana's collection. Returns: int: The maximum number of unique city designs Ana can place in her album. >>> max_unique_city_designs(7, 3, 5, [1, 1, 2, 2, 2, 3, 3]) 3 >>> max_unique_city_designs(10, 3, 10, [1, 1, 1, 2, 2, 2, 3, 3, 3, 3]) 3 >>> max_unique_city_designs(6, 6, 3, [1, 2, 3, 4, 5, 6]) 3 >>> max_unique_city_designs(5, 1, 10, [1, 1, 1, 1, 1]) 1 >>> max_unique_city_designs(6, 6, 4, [1, 2, 3, 4, 5, 6]) 4","solution":"def max_unique_city_designs(N, M, X, city_ids): Determines the maximum number of unique city designs Ana can place in her album. Parameters: N (int): The total number of postcards in Ana's collection. M (int): The number of different cities. X (int): The maximum number of postcards Ana can place in her album. city_ids (list of int): The city IDs for each postcard in Ana's collection. Returns: int: The maximum number of unique city designs Ana can place in her album. from collections import Counter city_count = Counter(city_ids) unique_city_designs = len(city_count) if unique_city_designs <= X: return unique_city_designs return X"},{"question":"from typing import List def count_derangements(n: int) -> int: Calculate the number of derangements (permutations where no element remains in its original position) for a given n (length of the string). # Implementation here def special_permutations(strings: List[str]) -> List[int]: For each string in the list \`strings\`, calculate the number of special permutations. # Implementation here def process_input(input_lines: List[str]) -> List[str]: Process input to extract the number of strings and the strings themselves. # Implementation here def compute_special_permutations(input_lines: List[str]) -> List[int]: Process the input lines and compute the special permutations count for each string. # Implementation here def test_example_case(): input_lines = [ \\"3\\", \\"AB\\", \\"ABC\\", \\"ABCD\\" ] expected_output = [1, 2, 9] assert compute_special_permutations(input_lines) == expected_output def test_single_char(): input_lines = [ \\"1\\", \\"A\\" ] expected_output = [0] assert compute_special_permutations(input_lines) == expected_output def test_two_chars(): input_lines = [ \\"1\\", \\"AB\\" ] expected_output = [1] assert compute_special_permutations(input_lines) == expected_output def test_three_chars(): input_lines = [ \\"1\\", \\"XYZ\\" ] expected_output = [2] assert compute_special_permutations(input_lines) == expected_output def test_four_chars(): input_lines = [ \\"1\\", \\"WXYZ\\" ] expected_output = [9] assert compute_special_permutations(input_lines) == expected_output def test_empty_string(): input_lines = [ \\"1\\", \\"\\" ] expected_output = [1] assert compute_special_permutations(input_lines) == expected_output def test_long_string(): input_lines = [ \\"1\\", \\"ABCDEFGHIJKL\\" ] expected_output = [176214841] assert compute_special_permutations(input_lines) == expected_output","solution":"import math def count_derangements(n): Calculate the number of derangements (permutations where no element remains in its original position) for a given n (length of the string). if n == 0: return 1 elif n == 1: return 0 elif n == 2: return 1 der = [0] * (n + 1) der[0] = 1 der[1] = 0 der[2] = 1 for i in range(3, n + 1): der[i] = (i - 1) * (der[i - 1] + der[i - 2]) return der[n] def special_permutations(strings): For each string in the list \`strings\`, calculate the number of special permutations. results = [] for string in strings: n = len(string) results.append(count_derangements(n)) return results def process_input(input_lines): Process input to extract the number of strings and the strings themselves. m = int(input_lines[0]) strings = input_lines[1:m + 1] return strings def compute_special_permutations(input_lines): Process the input lines and compute the special permutations count for each string. strings = process_input(input_lines) return special_permutations(strings)"},{"question":"class ParkingLot: Class to simulate the Parking Lot management. >>> parking_lot = ParkingLot(10, 3) >>> parking_lot.arrive(\\"ordinary\\") 3 >>> parking_lot.arrive(\\"handicap\\") 0 >>> parking_lot.arrive(\\"handicap\\") 1 >>> parking_lot.arrive(\\"ordinary\\") 4 >>> parking_lot.depart(0) >>> parking_lot.arrive(\\"handicap\\") 0 def __init__(self, total_spots, handicap_spots): Initializes the parking lot with given total spots and handicap spots. pass def arrive(self, car_type): Handles the arrival of a car of the specified type ('ordinary' or 'handicap'). Returns the spot number if the car is parked; otherwise, returns 'Turned Away'. pass def depart(self, spot_number): Handles the departure of a car from the specified spot number. It updates the state to indicate the spot is now empty. pass","solution":"class ParkingLot: def __init__(self, total_spots, handicap_spots): self.total_spots = total_spots self.handicap_spots = handicap_spots self.parking_status = [] for i in range(handicap_spots): self.parking_status.append(2) # empty handicap spot for i in range(total_spots - handicap_spots): self.parking_status.append(0) # empty ordinary spot def arrive(self, car_type): if car_type == \\"handicap\\": for i in range(self.handicap_spots): if self.parking_status[i] == 2: # empty handicap spot self.parking_status[i] = 3 # occupied handicap spot return i for i in range(self.handicap_spots, self.total_spots): if self.parking_status[i] == 0: # empty ordinary spot self.parking_status[i] = 3 # occupied handicap spot return i elif car_type == \\"ordinary\\": for i in range(self.handicap_spots, self.total_spots): if self.parking_status[i] == 0: # empty ordinary spot self.parking_status[i] = 1 # occupied ordinary spot return i return \\"Turned Away\\" def depart(self, spot_number): if self.parking_status[spot_number] == 1: # if occupied ordinary spot self.parking_status[spot_number] = 0 # empty ordinary spot elif self.parking_status[spot_number] == 3: # if occupied handicap spot self.parking_status[spot_number] = 2 if spot_number < self.handicap_spots else 0 # change back to empty spot"},{"question":"def balanced_array(k: int) -> List[int]: Constructs a balanced array of length 2 * k with k positive and k negative integers. Each positive integer in the array must be equal to its corresponding negative integer in absolute value. >>> balanced_array(1) [-1, 1] >>> balanced_array(2) [-1, 1, -2, 2] def generate_balanced_arrays(test_cases: List[int]) -> List[List[int]]: Produces balanced arrays for each test case. :param test_cases: A list of integers representing the value of k for each test case. :return: A list of balanced arrays corresponding to each test case. >>> generate_balanced_arrays([1]) [[-1, 1]] >>> generate_balanced_arrays([2]) [[-1, 1, -2, 2]] >>> generate_balanced_arrays([1, 2]) [[-1, 1], [-1, 1, -2, 2]]","solution":"def balanced_array(k): Constructs a balanced array of length 2 * k with k positive and k negative integers. Each positive integer in the array must be equal to its corresponding negative integer in absolute value. balanced_arr = [] for i in range(1, k + 1): balanced_arr.append(-i) balanced_arr.append(i) return balanced_arr def generate_balanced_arrays(test_cases): Produces balanced arrays for each test case. :param test_cases: A list of integers representing the value of k for each test case. :return: A list of balanced arrays corresponding to each test case. results = [] for k in test_cases: results.append(balanced_array(k)) return results"},{"question":"def sum_of_digits(n): Returns the sum of the digits of n. return sum(int(digit) for digit in str(n)) def find_sequence(n, k, x): Determines if there exists a sequence of length n starting with x where each number is the sum of its digits multiplied by k. If it exists, returns the sequence. >>> find_sequence(4, 3, 5) [5, 15, 18, 27] >>> find_sequence(3, 2, 8) [8, 16, 14] def sequence_exists(n, k, x): Checks and prints whether a sequence of length n exists starting with x where each number is the sum of its digits multiplied by k. Prints the sequence if it exists. >>> sequence_exists(4, 3, 5) YESn5 15 18 27 >>> sequence_exists(3, 2, 8) YESn8 16 14","solution":"def sum_of_digits(n): Returns the sum of the digits of n. return sum(int(digit) for digit in str(n)) def find_sequence(n, k, x): Determines if there exists a sequence of length n starting with x where each number is the sum of its digits multiplied by k. If it exists, returns the sequence. sequence = [x] while len(sequence) < n: next_number = sum_of_digits(sequence[-1]) * k sequence.append(next_number) return sequence def sequence_exists(n, k, x): Checks and prints whether a sequence of length n exists starting with x where each number is the sum of its digits multiplied by k. Prints the sequence if it exists. if n == 1: print(\\"YES\\") print(x) return seq = find_sequence(n, k, x) print(\\"YES\\") print(\\" \\".join(map(str, seq)))"},{"question":"def is_schedule_valid(lectures): Returns True if there are no overlapping lectures in the list of lectures, False otherwise. def validate_schedules(test_cases): Validates the schedules for multiple test cases. Each test case includes multiple lecturers and each lecturer has a list of lectures with start and end times. def test_is_schedule_valid(): assert is_schedule_valid([(10, 20), (20, 30), (30, 40)]) == True assert is_schedule_valid([(5, 10), (15, 20)]) == True assert is_schedule_valid([(5, 10), (8, 12)]) == False assert is_schedule_valid([(10, 15), (15, 20), (0, 5), (8, 12)]) == False assert is_schedule_valid([(0, 10), (10, 20), (5, 15)]) == False def test_validate_schedules(): test_cases = [ [[(10, 20), (20, 30), (30, 40)], [(5, 10), (15, 20)]], [[(5, 10), (8, 12)], [(10, 15), (15, 20), (0, 5), (8, 12)]], [[(0, 10), (10, 20), (5, 15)]] ] assert validate_schedules(test_cases) == [\\"valid schedule\\", \\"invalid schedule\\", \\"invalid schedule\\"] def test_single_lecture(): test_cases = [ [[(10, 20)]] ] assert validate_schedules(test_cases) == [\\"valid schedule\\"] def test_multiple_lectures_no_overlap(): test_cases = [ [[(0, 5), (5, 10), (10, 15)]] ] assert validate_schedules(test_cases) == [\\"valid schedule\\"] def test_single_lecturer_multiple_overlap(): test_cases = [ [[(0, 5), (4, 10)]] ] assert validate_schedules(test_cases) == [\\"invalid schedule\\"]","solution":"def is_schedule_valid(lectures): Returns True if there are no overlapping lectures in the list of lectures, False otherwise. lectures.sort(key=lambda x: x[0]) # Sort lectures by start time for i in range(1, len(lectures)): if lectures[i][0] < lectures[i-1][1]: return False return True def validate_schedules(test_cases): Validates the schedules for multiple test cases. Each test case includes multiple lecturers and each lecturer has a list of lectures with start and end times. results = [] for lectures_for_each_lecturer in test_cases: valid = True for lectures in lectures_for_each_lecturer: if not is_schedule_valid(lectures): valid = False break if valid: results.append(\\"valid schedule\\") else: results.append(\\"invalid schedule\\") return results # Read input def main(): import sys input = sys.stdin.read data = input().split() index = 0 T = int(data[index]) index += 1 test_cases = [] for _ in range(T): L = int(data[index]) index += 1 lecturers = [] for _ in range(L): N = int(data[index]) index += 1 lectures = [] for _ in range(N): S = int(data[index]) E = int(data[index+1]) index += 2 lectures.append((S, E)) lecturers.append(lectures) test_cases.append(lecturers) results = validate_schedules(test_cases) for result in results: print(result) if __name__ == '__main__': main()"},{"question":"def harvest_fruits(n: int, k: int) -> int: In a certain kingdom, there is a unique type of tree known as the \\"Pyramid Tree\\". This tree has n levels, with level 1 being at the top and level n at the bottom. Each level i (1  i  n) has exactly i nodes. Each node generates one unit of fruit every day, and the fruits are rolled down to the nodes directly below it (if any). When fruits from two or more nodes reach the same node, only one unit of fruit remains as the rest are squeezed out. Each day, after the fruits are collected at the bottom level n, the fruits start rolling down from the top level to the bottom. Fruits from each node in level i roll down to the closest neighboring nodes in level i+1. If there are multiple possible paths, the fruits are distributed uniformly as much as possible to balance the load. Help the kingdom determine how many units of fruit can be harvested at the bottom level n on day k. >>> harvest_fruits(4, 3) 4 >>> harvest_fruits(5, 2) 5","solution":"def harvest_fruits(n, k): Given the number of levels n and the number of days k, returns the number of units of fruit harvested at the bottom level. return n # since the number of fruits at the bottom level reaches steady state which is \`n\`."},{"question":"def knapsack_max_value(test_cases): Returns the maximum value that can be achieved without exceeding the weight limit for each test case. Args: test_cases (List[Tuple[int, int, List[Tuple[int, int]]]]): List of test case tuples, where each tuple contains: - N (int): The number of items. - W (int): The weight limit. - items (List[Tuple[int, int]]): List of items represented as tuples of (weight, value). Returns: List[int]: List of maximum values for each test case. >>> knapsack_max_value([(3, 50, [(10, 60), (20, 100), (30, 120)])]) [220] >>> knapsack_max_value([(3, 50, [(10, 60), (20, 100), (30, 120)]), (2, 50, [(10, 60), (55, 100)])]) [220, 60] >>> knapsack_max_value([(0, 50, [])]) [0] >>> knapsack_max_value([(3, 0, [(10, 60), (20, 100), (30, 120)])]) [0] >>> knapsack_max_value([(3, 50, [(60, 60), (70, 70), (80, 80)])]) [0]","solution":"def knapsack_max_value(test_cases): Returns the maximum value that can be achieved without exceeding the weight limit for each test case. results = [] for N, W, items in test_cases: dp = [0] * (W + 1) for weight, value in items: for w in range(W, weight - 1, -1): dp[w] = max(dp[w], dp[w - weight] + value) results.append(dp[W]) return results"},{"question":"def count_divisors(n: int) -> int: Returns the number of divisors for a given number. >>> count_divisors(1) 1 >>> count_divisors(2) 2 >>> count_divisors(3) 2 >>> count_divisors(6) 4 >>> count_divisors(10) 4 >>> count_divisors(16) 5 pass def most_senior_employee(T: int, test_cases: List[tuple]) -> List[int]: Returns the ID of the most senior employee from a list of test cases. >>> most_senior_employee(2, [(3, [10, 6, 8]), (4, [15, 9, 16, 22])]) [6, 16] >>> most_senior_employee(1, [(5, [1, 2, 3, 4, 5])]) [4] >>> most_senior_employee(1, [(3, [7, 11, 13])]) [7] >>> most_senior_employee(1, [(2, [9, 12])]) [12] >>> most_senior_employee(1, [(3, [100, 99, 98])]) [100] pass","solution":"def count_divisors(n): Returns the number of divisors of n. count = 0 for i in range(1, int(n ** 0.5) + 1): if n % i == 0: count += 1 if i != n // i: count += 1 return count def most_senior_employee(T, test_cases): Returns the ID of the most senior employee for each test case. results = [] for i in range(T): N, employee_ids = test_cases[i] max_divisors = -1 senior_id = None for emp_id in employee_ids: divisors = count_divisors(emp_id) if divisors > max_divisors or (divisors == max_divisors and (senior_id is None or emp_id < senior_id)): max_divisors = divisors senior_id = emp_id results.append(senior_id) return results"},{"question":"from typing import List def max_value_j_minus_i(n: int, a: List[int]) -> int: Finds the maximum value of j-i such that a[j]  a[i]. Parameters: n (int): The length of the array. a (List[int]): The elements of the array. Returns: int: The maximum value of j-i such that a[j]  a[i]. Examples: >>> max_value_j_minus_i(6, [5, 3, 4, 3, 5, 9]) 5 >>> max_value_j_minus_i(4, [1, 2, 3, 4]) 3 >>> max_value_j_minus_i(5, [4, 3, 2, 1, 5]) 4 from solution import max_value_j_minus_i def test_example_1(): assert max_value_j_minus_i(6, [5, 3, 4, 3, 5, 9]) == 5 def test_example_2(): assert max_value_j_minus_i(4, [1, 2, 3, 4]) == 3 def test_example_3(): assert max_value_j_minus_i(5, [4, 3, 2, 1, 5]) == 4 def test_all_elements_equal(): assert max_value_j_minus_i(4, [2, 2, 2, 2]) == 3 def test_decreasing_sequence(): assert max_value_j_minus_i(5, [5, 4, 3, 2, 1]) == 0 def test_single_element(): assert max_value_j_minus_i(1, [1]) == 0 def test_large_numbers(): assert max_value_j_minus_i(3, [10**9, 10**9, 10**9]) == 2 def test_mixed_large_and_small_numbers(): assert max_value_j_minus_i(6, [10**9, 1, 10**9, 2, 3, 10**9]) == 5","solution":"def max_value_j_minus_i(n, a): Finds the maximum value of j-i such that a[j]  a[i]. Parameters: n (int): The length of the array. a (List[int]): The elements of the array. Returns: int: The maximum value of j-i such that a[j]  a[i]. left_min = [0] * n right_max = [0] * n left_min[0] = a[0] for i in range(1, n): left_min[i] = min(left_min[i - 1], a[i]) right_max[n - 1] = a[n - 1] for j in range(n - 2, -1, -1): right_max[j] = max(right_max[j + 1], a[j]) i, j, max_diff = 0, 0, 0 while i < n and j < n: if left_min[i] <= right_max[j]: max_diff = max(max_diff, j - i) j += 1 else: i += 1 return max_diff"},{"question":"def count_tall_buildings(buildings: List[int], queries: List[Tuple[int, int]]) -> List[int]: Given a list of N integers representing the heights of a series of buildings standing in a row, you will be asked to process Q queries. Each query will provide two integers L and R, representing a range of buildings. Your task is to count how many of these buildings in the given range have heights that are strictly greater than both their neighboring buildings. >>> count_tall_buildings( ... buildings=[3, 4, 5, 2, 1, 7], ... queries=[(1, 4), (2, 6)] ... ) == [1, 2] >>> count_tall_buildings( ... buildings=[10], ... queries=[(1, 1)] ... ) == [1] >>> count_tall_buildings( ... buildings=[4, 4, 4, 4, 4], ... queries=[(1, 5), (1, 3)] ... ) == [0, 0] >>> count_tall_buildings( ... buildings=[7, 1, 7], ... queries=[(1, 2), (2, 3), (1, 3)] ... ) == [1, 1, 2] >>> count_tall_buildings( ... buildings=[1, 2, 3, 4, 5], ... queries=[(1, 3), (3, 5), (1, 5)] ... ) == [0, 1, 1] >>> count_tall_buildings( ... buildings=[5, 4, 3, 2, 1], ... queries=[(1, 3), (3, 5), (1, 5)] ... ) == [1, 0, 1]","solution":"def count_tall_buildings(buildings, queries): results = [] for L, R in queries: count = 0 for i in range(L - 1, R): if (i == 0 or buildings[i] > buildings[i - 1]) and (i == len(buildings) - 1 or buildings[i] > buildings[i + 1]): count += 1 results.append(count) return results"},{"question":"from typing import List, Tuple def range_difference(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the range difference for each test case. Args: test_cases (List[Tuple[int, List[int]]]): A list of tuples containing the number of elements and the array of elements. Returns: List[int]: A list containing the difference between the maximum and minimum element in each array. def parse_input(input_data: str) -> List[Tuple[int, List[int]]]: Parse the input data to extract test cases. Args: input_data (str): The input data as a string. Returns: List[Tuple[int, List[int]]]: A list of test cases where each test case is a tuple containing the number of elements and the array of elements. # Test cases def test_range_difference(): input_data = 3 5 5 3 8 1 4 4 2 2 2 2 6 7 7 9 10 1 2 test_cases = parse_input(input_data) assert range_difference(test_cases) == [7, 0, 9] def test_single_element_array(): input_data = 1 1 3 test_cases = parse_input(input_data) assert range_difference(test_cases) == [0] def test_all_elements_same(): input_data = 1 4 1 1 1 1 test_cases = parse_input(input_data) assert range_difference(test_cases) == [0] def test_large_array(): n = 10**5 array = [i for i in range(n)] test_cases = [(n, array)] assert range_difference(test_cases) == [n-1] def test_mixed_numbers(): input_data = 2 5 -1 -2 -3 -4 -100 4 50 50 50 50 test_cases = parse_input(input_data) assert range_difference(test_cases) == [99, 0]","solution":"def range_difference(test_cases): results = [] for case in test_cases: n, array = case results.append(max(array) - min(array)) return results def parse_input(input_data): lines = input_data.split('n') T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): N = int(lines[index]) array = list(map(int, lines[index + 1].split())) test_cases.append((N, array)) index += 2 return test_cases"},{"question":"def reverse_number(n: int) -> int: Returns the reverse of integer n. For example, reverse_number(123) returns 321. pass def is_palindrome(n: int) -> bool: Checks if integer n is a palindrome. For example, is_palindrome(121) returns True, is_palindrome(123) returns False. pass def palindrome_chain_length(n: int) -> int: Returns the number of iterations required to transform n into a palindrome by repeatedly reversing its digits and adding the result to the original number. pass def iterations_to_palindrome(numbers: List[int]) -> List[int]: Takes a list of positive integers and returns the number of iterations required to transform each integer into a palindrome. It assumes end of input is indicated by the integer 0. pass # Test cases for the functions def test_reverse_number(): assert reverse_number(123) == 321 assert reverse_number(4000) == 4 assert reverse_number(1) == 1 assert reverse_number(120) == 21 def test_is_palindrome(): assert is_palindrome(121) is True assert is_palindrome(123) is False assert is_palindrome(1) is True assert is_palindrome(11) is True assert is_palindrome(1221) is True def test_palindrome_chain_length(): assert palindrome_chain_length(87) == 4 assert palindrome_chain_length(89) == 24 assert palindrome_chain_length(75) == 2 def test_iterations_to_palindrome(): assert iterations_to_palindrome([87, 89, 75, 0]) == [4, 24, 2] assert iterations_to_palindrome([123, 56, 0]) == [1, 1] assert iterations_to_palindrome([0]) == [] assert iterations_to_palindrome([1, 22, 0]) == [0, 0]","solution":"def reverse_number(n): Returns the reverse of integer n. For example, reverse_number(123) returns 321. return int(str(n)[::-1]) def is_palindrome(n): Checks if integer n is a palindrome. For example, is_palindrome(121) returns True, is_palindrome(123) returns False. return str(n) == str(n)[::-1] def palindrome_chain_length(n): Returns the number of iterations required to transform n into a palindrome by repeatedly reversing its digits and adding the result to the original number. iterations = 0 while not is_palindrome(n): n += reverse_number(n) iterations += 1 return iterations def iterations_to_palindrome(numbers): Takes a list of positive integers and returns the number of iterations required to transform each integer into a palindrome. It assumes end of input is indicated by the integer 0. results = [] for number in numbers: if number == 0: break results.append(palindrome_chain_length(number)) return results"},{"question":"def find_longest_subarray(test_cases): Given a list of integers, find the longest contiguous subarray that has the same integer in all its positions. Args: test_cases (List[Tuple[int, List[int]]]): List of tuples where each tuple includes the length of the array and the array itself. Returns: List[Tuple[int, int]]: List of tuples with the length of the longest contiguous subarray and the integer that forms this subarray. Example: >>> find_longest_subarray([ (7, [2, 2, 3, 3, 3, 2, 2]), (5, [1, 1, 1, 1, 1]), (8, [4, 4, 4, 4, 3, 3, 3, 3]), (6, [5, 5, 2, 2, 2, 5]) ]) [(3, 3), (5, 1), (4, 3), (3, 2)]","solution":"def find_longest_subarray(test_cases): results = [] for a in test_cases: n, arr = a max_length = 1 current_length = 1 best_value = arr[0] current_value = arr[0] for i in range(1, n): if arr[i] == current_value: current_length += 1 else: if current_length > max_length or (current_length == max_length and current_value < best_value): max_length = current_length best_value = current_value current_value = arr[i] current_length = 1 if current_length > max_length or (current_length == max_length and current_value < best_value): max_length = current_length best_value = current_value results.append((max_length, best_value)) return results # Example usage: # test_cases = [ # (7, [2, 2, 3, 3, 3, 2, 2]), # (5, [1, 1, 1, 1, 1]), # (8, [4, 4, 4, 4, 3, 3, 3, 3]), # (6, [5, 5, 2, 2, 2, 5]) # ] # print(find_longest_subarray(test_cases)) # Output: [(3, 3), (5, 1), (4, 3), (3, 2)]"},{"question":"def roman_to_integer(s: str) -> int: Convert a Roman numeral to an integer. >>> roman_to_integer(\\"III\\") 3 >>> roman_to_integer(\\"IV\\") 4 >>> roman_to_integer(\\"IX\\") 9 >>> roman_to_integer(\\"LVIII\\") 58 >>> roman_to_integer(\\"MCMXCIV\\") 1994","solution":"def roman_to_integer(s): Convert a Roman numeral to an integer. roman_values = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000} total = 0 previous_value = 0 for char in reversed(s): current_value = roman_values[char] if current_value < previous_value: total -= current_value else: total += current_value previous_value = current_value return total"},{"question":"def manage_leds(N: int, commands: List[Tuple[int, int]]) -> List[str]: Manages LEDs based on toggle and query commands. Parameters: N (int): Number of LEDs. commands (list of tuple): List of commands where each command is a tuple (type, index). Returns: list of str: A list containing results for Query Commands (\\"ON\\" or \\"OFF\\"). >>> manage_leds(5, [(1, 1), (2, 1), (1, 1), (2, 1), (1, 3), (2, 3)]) [\\"ON\\", \\"OFF\\", \\"ON\\"] >>> manage_leds(3, [(2, 1), (2, 2), (2, 3)]) [\\"OFF\\", \\"OFF\\", \\"OFF\\"] >>> manage_leds(1, [(1, 1), (1, 1), (1, 1), (2, 1)]) [\\"ON\\"] >>> manage_leds(5, []) [] >>> manage_leds(5, [(1, i) for i in range(1, 6)] + [(2, i) for i in range(1, 6)]) [\\"ON\\", \\"ON\\", \\"ON\\", \\"ON\\", \\"ON\\"]","solution":"def manage_leds(N, commands): Manages LEDs based on toggle and query commands. Parameters: N (int): Number of LEDs. commands (list of tuple): List of commands where each command is a tuple (type, index). Returns: list of str: A list containing results for Query Commands (\\"ON\\" or \\"OFF\\"). # Initialize the LEDs; all are initially OFF leds = [False] * N # Store the results of Query Commands result = [] for command in commands: if command[0] == 1: # Toggle Command index = command[1] - 1 # Convert to 0-based index leds[index] = not leds[index] elif command[0] == 2: # Query Command index = command[1] - 1 # Convert to 0-based index result.append(\\"ON\\" if leds[index] else \\"OFF\\") return result"},{"question":"def find_common_problems(T: int, test_cases: List[Tuple[int, List[int], int, List[int]]]) -> List[str]: Determine the common problems Alice and Bob have both solved from multiple test cases. Args: T (int): The number of test cases. test_cases (List[Tuple[int, List[int], int, List[int]]]): List of tuples containing test case data. Returns: List[str]: A list containing the common problems sorted in ascending order for each test case. If there are no common problems, return \\"No common problems\\". Example: >>> find_common_problems(2, [(3, [1, 3, 5], 3, [3, 5, 7]), (4, [1, 2, 3, 4], 4, [5, 6, 7, 8])]) [\\"3 5\\", \\"No common problems\\"] pass # Unit tests import pytest def test_common_problems_example(): T = 2 test_cases = [ (3, [1, 3, 5], 3, [3, 5, 7]), (4, [1, 2, 3, 4], 4, [5, 6, 7, 8]) ] expected = [\\"3 5\\", \\"No common problems\\"] assert find_common_problems(T, test_cases) == expected def test_no_common_problems(): T = 1 test_cases = [ (3, [1, 2, 3], 3, [4, 5, 6]) ] expected = [\\"No common problems\\"] assert find_common_problems(T, test_cases) == expected def test_all_common_problems(): T = 1 test_cases = [ (3, [1, 2, 3], 3, [1, 2, 3]) ] expected = [\\"1 2 3\\"] assert find_common_problems(T, test_cases) == expected def test_some_common_problems(): T = 1 test_cases = [ (5, [1, 10, 20, 30, 40], 6, [5, 10, 20, 25, 30, 50]) ] expected = [\\"10 20 30\\"] assert find_common_problems(T, test_cases) == expected def test_no_elements_in_one_list(): T = 1 test_cases = [ (3, [1, 2, 3], 0, []) ] expected = [\\"No common problems\\"] assert find_common_problems(T, test_cases) == expected","solution":"def find_common_problems(T, test_cases): results = [] for i in range(T): n, A = test_cases[i][0], set(test_cases[i][1]) m, B = test_cases[i][2], set(test_cases[i][3]) common = sorted(list(A & B)) if common: results.append(\\" \\".join(map(str, common))) else: results.append(\\"No common problems\\") return results # Example function call # T = 2 # test_cases = [ # (3, [1, 3, 5], 3, [3, 5, 7]), # (4, [1, 2, 3, 4], 4, [5, 6, 7, 8]) # ] # print(find_common_problems(T, test_cases)) # should output [\\"3 5\\", \\"No common problems\\"]"},{"question":"def unique_paths_with_obstacles(grid: List[List[int]]) -> int: Calculate the number of unique paths for a robot to reach the bottom-right corner of a grid from the top-left corner. The grid can have obstacles represented by 1s and free cells represented by 0s. The robot can only move down or right. >>> unique_paths_with_obstacles([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) 2 >>> unique_paths_with_obstacles([[0, 1], [0, 0]]) 1 >>> unique_paths_with_obstacles([[1, 0], [0, 0]]) 0 >>> unique_paths_with_obstacles([[0, 0], [0, 1]]) 0 >>> unique_paths_with_obstacles([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 6 >>> unique_paths_with_obstacles([[0]]) 1 >>> unique_paths_with_obstacles([[0, 0, 0], [1, 1, 0], [0, 0, 0]]) 1","solution":"def unique_paths_with_obstacles(grid): m, n = len(grid), len(grid[0]) # If the start or end points are blocked, return 0 if grid[0][0] == 1 or grid[m-1][n-1] == 1: return 0 # Initialize the dp array dp = [[0] * n for _ in range(m)] dp[0][0] = 1 # Start point # Fill the first row for j in range(1, n): if grid[0][j] == 0: dp[0][j] = dp[0][j-1] else: dp[0][j] = 0 # Fill the first column for i in range(1, m): if grid[i][0] == 0: dp[i][0] = dp[i-1][0] else: dp[i][0] = 0 # Fill the rest of the dp array for i in range(1, m): for j in range(1, n): if grid[i][j] == 0: dp[i][j] = dp[i-1][j] + dp[i][j-1] else: dp[i][j] = 0 return dp[m-1][n-1]"},{"question":"def process_library_data(input_data: str) -> str: Process the library data and answer queries regarding the books in the collection. >>> process_library_data('3nTheHobbit Fantasy 1937n1984 Dystopian 1949nDune SciFi 1965n2nFantasy 1937nSciFi 1965n0') 'Query:nTheHobbitnnQuery:nDune' >>> process_library_data('4nTreasureIsland Adventure 1883nHeartOfDarkness Adventure 1899nGatsby Classic 1925nMockingbird Classic 1960n2nClassic 1925nAdventure 1883n0') 'Query:nGatsbynnQuery:nTreasureIsland'","solution":"def process_library_data(input_data): results = [] lines = input_data.strip().split('n') index = 0 while index < len(lines): N = int(lines[index]) if N == 0: break index += 1 books = [] for _ in range(N): entry = lines[index].split() title = entry[0] genre = entry[1] year = int(entry[2]) books.append((title, genre, year)) index += 1 Q = int(lines[index]) index += 1 queries = [] for _ in range(Q): genre, year = lines[index].split() year = int(year) queries.append((genre, year)) index += 1 if results: results.append('') for genre, year in queries: matching_books = [title for title, book_genre, book_year in books if book_genre == genre and book_year == year] if matching_books: results.append('Query:') results.extend(matching_books) else: results.append('Query:') results.append('No books found') return 'n'.join(results) # Example usage: # input_data = '''3 # TheHobbit Fantasy 1937 # 1984 Dystopian 1949 # Dune SciFi 1965 # 2 # Fantasy 1937 # SciFi 1965 # 4 # TreasureIsland Adventure 1883 # HeartOfDarkness Adventure 1899 # Gatsby Classic 1925 # Mockingbird Classic 1960 # 2 # Classic 1925 # Adventure 1883 # 0''' # print(process_library_data(input_data))"},{"question":"from typing import List, Tuple from collections import deque, defaultdict def find_diameter(n: int, roads: List[Tuple[int, int]]) -> int: In a city with n houses and a tree structure formed by m bidirectional roads, find the diameter of the tree. Example: >>> find_diameter(5, [(1, 2), (1, 3), (3, 4), (3, 5)]) 3 >>> find_diameter(2, [(1, 2)]) 1 Test Cases: >>> find_diameter(3, [(1, 2), (2, 3)]) 2 >>> find_diameter(3, [(1, 2), (1, 3)]) 2 >>> find_diameter(7, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)]) 4 >>> find_diameter(4, [(1, 2), (2, 3), (3, 4)]) 3 >>> find_diameter(4, [(1, 2), (2, 3), (2, 4)]) 2","solution":"from collections import deque, defaultdict def find_diameter(n, roads): if n == 2: return 1 def bfs(start_node): visited = [-1] * n visited[start_node] = 0 queue = deque([start_node]) furthest_node, max_distance = start_node, 0 while queue: current = queue.popleft() current_distance = visited[current] for neighbor in adj[current]: if visited[neighbor] == -1: visited[neighbor] = current_distance + 1 if visited[neighbor] > max_distance: max_distance = visited[neighbor] furthest_node = neighbor queue.append(neighbor) return furthest_node, max_distance adj = defaultdict(list) for u, v in roads: adj[u-1].append(v-1) adj[v-1].append(u-1) # First BFS to find the furthest node from an arbitrary start (node 0) furthest_node, _ = bfs(0) # Second BFS to find the distance to the furthest node from the previous furthest node _, diameter = bfs(furthest_node) return diameter"},{"question":"from typing import List from collections import Counter from heapq import heappush, heappop def rearrange_string(S: str) -> str: Rearranges the string S such that no two adjacent characters are the same. If it is not possible, returns \\"Not Possible\\". def process_test_cases(test_cases: List[str]) -> List[str]: Processes multiple test cases and returns the results. results = [] for S in test_cases: results.append(rearrange_string(S)) return results def main(): Reads input, processes test cases, and outputs results. import sys input = sys.stdin.read data = input().split() T = int(data[0]) test_cases = [] for i in range(1, T + 1): test_cases.append(data[i]) results = process_test_cases(test_cases) for result in results: print(result) # Unit Test def test_rearrange_string_possible(): assert rearrange_string(\\"aab\\") == \\"aba\\" or rearrange_string(\\"aab\\") == \\"baa\\" def test_rearrange_string_not_possible(): assert rearrange_string(\\"aaab\\") == \\"Not Possible\\" def test_rearrange_string_single_character(): assert rearrange_string(\\"a\\") == \\"a\\" def test_rearrange_string_two_different_characters(): assert rearrange_string(\\"ab\\") == \\"ab\\" or rearrange_string(\\"ab\\") == \\"ba\\" def test_rearrange_string_two_same_characters(): assert rearrange_string(\\"aa\\") == \\"Not Possible\\" def test_rearrange_string_complex(): result = rearrange_string(\\"aaabbcc\\") for i in range(1, len(result)): assert result[i] != result[i-1] def test_rearrange_string_large_input(): input_str = \\"a\\" * 50000 + \\"b\\" * 50000 result = rearrange_string(input_str) if result == \\"Not Possible\\": assert True else: for i in range(1, len(result)): assert result[i] != result[i-1]","solution":"from heapq import heappush, heappop from collections import Counter def rearrange_string(S): Rearranges the string S such that no two adjacent characters are the same. If it is not possible, returns \\"Not Possible\\". # Create a frequency dictionary freq = Counter(S) # Create a max heap based on character frequencies max_heap = [] for char, count in freq.items(): heappush(max_heap, (-count, char)) prev_char = None prev_count = 0 result = [] while max_heap: count, char = heappop(max_heap) result.append(char) # If there is a previous character that needs to be pushed back into heap if prev_char and prev_count < 0: heappush(max_heap, (prev_count, prev_char)) # Update previous character and its count prev_char = char prev_count = count + 1 result_str = \\"\\".join(result) if len(result_str) == len(S): return result_str else: return \\"Not Possible\\" def process_test_cases(test_cases): results = [] for S in test_cases: results.append(rearrange_string(S)) return results # Function to read input and output results def main(): import sys input = sys.stdin.read data = input().split() T = int(data[0]) test_cases = [] for i in range(1, T + 1): test_cases.append(data[i]) results = process_test_cases(test_cases) for result in results: print(result)"},{"question":"def max_trees(house_positions: List[int]) -> int: Returns the maximum number of trees that can be planted such that no three trees are in a straight line. >>> max_trees([1, 2, 3, 4, 5]) 2 >>> max_trees([1, 3, 5, 7, 9, 11]) 2 >>> max_trees([1]) 1 >>> max_trees([1, 2]) 2 >>> max_trees([5, 1, 3, 7, 6, 8]) 2 >>> max_trees(list(range(1, 1001))) 2","solution":"def max_trees(house_positions): Returns the maximum number of trees that can be planted such that no three trees are in a straight line. n = len(house_positions) # When there are 2 or less houses, we can always plant trees in front of each of them if n <= 2: return n # Sort the house positions house_positions.sort() # We can always plant at least 2 trees such that they are not in a straight line return 2"},{"question":"import heapq from typing import List, Tuple def shortest_path(N: int, M: int, S: int, E: int, edges: List[Tuple[int, int, int]]) -> int: Find the shortest path in an undirected graph using Dijkstra's algorithm. Args: N (int): Number of nodes. M (int): Number of edges. S (int): Start node. E (int): End node. edges (list of tuples): List of edges, each tuple is (u, v, w). Returns: int: Length of the shortest path from S to E, or -1 if there is no path. pass def test_shortest_path_example(): N, M = 6, 9 S, E = 1, 6 edges = [ (1, 2, 7), (1, 3, 9), (1, 6, 14), (2, 3, 10), (2, 4, 15), (3, 4, 11), (3, 6, 2), (4, 5, 6), (5, 6, 9) ] assert shortest_path(N, M, S, E, edges) == 11 def test_shortest_path_no_path(): N, M = 3, 2 S, E = 1, 3 edges = [ (1, 2, 1), (2, 3, 1) ] assert shortest_path(N, M, S, E, edges) == 2 def test_shortest_path_single_path(): N, M = 4, 4 S, E = 1, 4 edges = [ (1, 2, 1), (2, 3, 1), (3, 4, 1) ] assert shortest_path(N, M, S, E, edges) == 3 def test_shortest_path_no_connection(): N, M = 4, 2 S, E = 1, 4 edges = [ (1, 2, 1), (3, 4, 1) ] assert shortest_path(N, M, S, E, edges) == -1","solution":"import heapq def shortest_path(N, M, S, E, edges): Find the shortest path in an undirected graph using Dijkstra's algorithm. Args: N (int): Number of nodes. M (int): Number of edges. S (int): Start node. E (int): End node. edges (list of tuples): List of edges, each tuple is (u, v, w). Returns: int: Length of the shortest path from S to E, or -1 if there is no path. graph = {i: [] for i in range(1, N+1)} for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) # Dijkstra's algorithm initialization pq = [(0, S)] # Priority queue of (distance, node) dist = {i: float('inf') for i in range(1, N+1)} dist[S] = 0 visited = set() while pq: current_dist, current_node = heapq.heappop(pq) if current_node in visited: continue visited.add(current_node) if current_node == E: return current_dist for neighbor, weight in graph[current_node]: if neighbor not in visited: new_distance = current_dist + weight if new_distance < dist[neighbor]: dist[neighbor] = new_distance heapq.heappush(pq, (new_distance, neighbor)) return -1 if dist[E] == float('inf') else dist[E]"},{"question":"def calculate_scores(n: int, A: str, B: str) -> (int, int): Determine the final score of both players after all possible pairs of characters have been compared. Args: n (int): Length of the strings. A (str): First string consisting of n lowercase English letters. B (str): Second string consisting of n lowercase English letters. Returns: tuple: Two space-separated integers, the score of Mike and the score of Eva, respectively. Examples: >>> calculate_scores(5, \\"abcde\\", \\"abfde\\") (4, 1) >>> calculate_scores(3, \\"xyz\\", \\"pqr\\") (0, 3) import unittest class TestCalculateScores(unittest.TestCase): def test_calculate_scores_example1(self): self.assertEqual(calculate_scores(5, \\"abcde\\", \\"abfde\\"), (4, 1)) def test_calculate_scores_example2(self): self.assertEqual(calculate_scores(3, \\"xyz\\", \\"pqr\\"), (0, 3)) def test_calculate_scores_all_same(self): self.assertEqual(calculate_scores(4, \\"aaaa\\", \\"aaaa\\"), (4, 0)) def test_calculate_scores_all_different(self): self.assertEqual(calculate_scores(4, \\"abcd\\", \\"wxyz\\"), (0, 4)) def test_calculate_scores_mixed(self): self.assertEqual(calculate_scores(6, \\"abcdef\\", \\"abcxyz\\"), (3, 3)) if __name__ == \\"__main__\\": unittest.main()","solution":"def calculate_scores(n, A, B): mike_score = 0 eva_score = 0 for i in range(n): if A[i] == B[i]: mike_score += 1 else: eva_score += 1 return mike_score, eva_score if __name__ == \\"__main__\\": n = int(input().strip()) A = input().strip() B = input().strip() mike_score, eva_score = calculate_scores(n, A, B) print(mike_score, eva_score)"},{"question":"from typing import List, Tuple def max_treasures(n: int, m: int, treasures: List[int], paths: List[Tuple[int, int]]) -> int: Find the maximum number of treasures Alice can collect from room 1 to room n. Args: n (int): Number of rooms. m (int): Number of paths. treasures (List[int]): List containing the number of treasures in each room. paths (List[Tuple[int,int]]): List containing the paths represented by tuples (u, v), where u is the starting room and v is the ending room. Returns: int: The maximum number of treasures Alice can collect. If there is no way to reach room n, return -1. >>> max_treasures(5, 6, [5, 2, 3, 7, 1], [(1, 2), (2, 3), (3, 4), (2, 4), (4, 5), (3, 5)]) 18 >>> max_treasures(3, 1, [1, 2, 3], [(1, 2)]) -1 >>> max_treasures(3, 2, [1, 2, 3], [(1, 2), (2, 3)]) 6 >>> max_treasures(4, 4, [5, 7, 2, 3], [(1, 2), (1, 3), (2, 4), (3, 4)]) 15 >>> max_treasures(2, 1, [5, 10], [(1, 2)]) 15","solution":"from collections import deque, defaultdict def max_treasures(n, m, treasures, paths): graph = defaultdict(list) for u, v in paths: graph[u].append(v) # Initialize the maximum treasures to collect from each room as -1 (unreachable) max_treasures = [-1] * (n + 1) max_treasures[1] = treasures[0] # Starting from room 1 queue = deque([1]) while queue: curr_room = queue.popleft() for next_room in graph[curr_room]: if max_treasures[next_room] < max_treasures[curr_room] + treasures[next_room - 1]: max_treasures[next_room] = max_treasures[curr_room] + treasures[next_room - 1] queue.append(next_room) return max_treasures[n] if max_treasures[n] != -1 else -1"},{"question":"def max_packages(n, m, truck_capacities, package_weights): Returns the maximum number of packages that can be delivered by the trucks without exceeding their capacity. :param n: Number of trucks :param m: Number of packages :param truck_capacities: List of integers representing the maximum weight capacity of each truck :param package_weights: List of integers representing the weight of each package :return: Maximum number of packages that can be delivered from solution import max_packages def test_sample_case(): assert max_packages(3, 5, [15, 10, 20], [5, 8, 12, 2, 7]) == 5 def test_single_truck_single_package(): assert max_packages(1, 1, [10], [5]) == 1 def test_single_truck_multiple_packages(): assert max_packages(1, 3, [10], [5, 2, 3]) == 3 def test_multiple_trucks_equal_capacity(): assert max_packages(2, 4, [10, 10], [5, 5, 5, 5]) == 4 def test_multiple_trucks_varying_capacity(): assert max_packages(2, 6, [10, 15], [1, 2, 3, 4, 5, 6]) == 6 def test_no_capacity_to_carry_packages(): assert max_packages(2, 4, [3, 3], [5, 5, 5, 5]) == 0","solution":"def max_packages(n, m, truck_capacities, package_weights): Returns the maximum number of packages that can be delivered by the trucks without exceeding their capacity. :param n: Number of trucks :param m: Number of packages :param truck_capacities: List of integers representing the maximum weight capacity of each truck :param package_weights: List of integers representing the weight of each package :return: Maximum number of packages that can be delivered truck_capacities.sort(reverse=True) package_weights.sort(reverse=True) total_packages_delivered = 0 for capacity in truck_capacities: current_load = 0 for i in range(len(package_weights)): if package_weights[i] != -1 and current_load + package_weights[i] <= capacity: current_load += package_weights[i] package_weights[i] = -1 total_packages_delivered += 1 return total_packages_delivered"},{"question":"def can_reach_in_exact_moves(n: int, m: int, k: int, sx: int, sy: int, tx: int, ty: int) -> bool: Determines if the robot can reach the target cell from the starting cell in exactly k moves. Parameters: n (int): Number of rows in the warehouse grid. m (int): Number of columns in the warehouse grid. k (int): Exact number of moves the robot can make. sx (int): Starting cell row. sy (int): Starting cell column. tx (int): Target cell row. ty (int): Target cell column. Returns: bool: True if the robot can reach the target cell in exactly k moves, otherwise False. Examples: >>> can_reach_in_exact_moves(5, 5, 6, 1, 1, 3, 3) True >>> can_reach_in_exact_moves(5, 5, 3, 1, 1, 2, 2) False >>> can_reach_in_exact_moves(5, 5, 4, 1, 1, 1, 1) True","solution":"def can_reach_in_exact_moves(n, m, k, sx, sy, tx, ty): Determines if the robot can reach the target cell from the starting cell in exactly k moves. # Calculate the Manhattan distance between the start and target cells manhattan_distance = abs(sx - tx) + abs(sy - ty) # Check if the remaining number of moves after reaching the target # is non-negative and even. This ensures that we can reach the target # and use any remaining moves to move back and forth without changing position. return (k >= manhattan_distance) and ((k - manhattan_distance) % 2 == 0)"},{"question":"def minimum_bookshelf_width(n: int, t: List[int], m: int, pairs: List[Tuple[int, int]]) -> int: Determine the minimum possible width of the bookshelf satisfying the constraints. >>> minimum_bookshelf_width(4, [3, 1, 4, 2], 2, [(1, 2), (3, 4)]) 10 >>> minimum_bookshelf_width(3, [2, 2, 2], 3, [(1, 2), (2, 3), (1, 3)]) -1 >>> minimum_bookshelf_width(5, [5, 3, 2, 4, 1], 0, []) 15 >>> minimum_bookshelf_width(1, [3], 0, []) 3 >>> minimum_bookshelf_width(6, [1, 3, 2, 5, 4, 6], 3, [(1, 2), (4, 5), (5, 6)]) 21","solution":"def minimum_bookshelf_width(n, t, m, pairs): from collections import defaultdict, deque # Create an adjacency list for the graph adjacency_list = defaultdict(list) for a, b in pairs: adjacency_list[a - 1].append(b - 1) adjacency_list[b - 1].append(a - 1) visited = [False] * n def bfs(start): queue = deque([start]) visited[start] = True component = [] while queue: node = queue.popleft() component.append(node) for neighbor in adjacency_list[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return component components = [] for i in range(n): if not visited[i]: component = bfs(i) components.append(component) width = 0 for component in components: sub_width = 0 edges = 0 for node in component: sub_width += t[node] edges += len(adjacency_list[node]) if edges // 2 != len(component) - 1: return -1 # Not a tree, hence not possible to place them as needed width += sub_width return width"},{"question":"def minimum_time(n, conveyor_speeds, t, tasks): Function to determine the minimum time required for each task to be completed. Parameters: n (int): Number of conveyor belts. conveyor_speeds (list of int): List of speeds for each conveyor belt. t (int): Number of tasks. tasks (list of int): List of number of items for each task. Returns: list of int: List containing the minimum time required for each task. pass from minimum_time import minimum_time def test_example(): # Test case from the example provided assert minimum_time(3, [2, 3, 1], 4, [10, 21, 5, 17]) == [4, 7, 2, 6] def test_single_conveyor(): # Test with a single conveyor belt assert minimum_time(1, [5], 3, [25, 30, 100]) == [5, 6, 20] def test_multiple_conveyors_different_tasks(): # Test with multiple conveyors with a variety of task sizes assert minimum_time(4, [1, 3, 4, 2], 5, [12, 20, 30, 7, 18]) == [3, 5, 8, 2, 5] def test_large_number_of_tasks(): # Test with a large number of tasks to check performance and handling conveyor_speeds = [5, 3, 4] tasks = [100, 200, 300, 400, 500, 600, 700, 800, 900, 1000] expected_output = [20, 40, 60, 80, 100, 120, 140, 160, 180, 200] assert minimum_time(3, conveyor_speeds, 10, tasks) == expected_output","solution":"def minimum_time(n, conveyor_speeds, t, tasks): Function to determine the minimum time required for each task to be completed. Parameters: n (int): Number of conveyor belts. conveyor_speeds (list of int): List of speeds for each conveyor belt. t (int): Number of tasks. tasks (list of int): List of number of items for each task. Returns: list of int: List containing the minimum time required for each task. conveyor_speeds.sort(reverse=True) # Sorting conveyor speeds in descending order for optimization times = [] for items in tasks: min_time = float('inf') for speed in conveyor_speeds: time = (items + speed - 1) // speed # Calculate time needed if all items were handled by this belt min_time = min(min_time, time) times.append(min_time) return times"},{"question":"def find_unique_books(n: int, book_titles: List[str]) -> List[str]: Identify unique book titles that appear exactly once in the entire collection. Return a list of unique titles sorted in alphabetical order. If there are no unique titles, return [\\"no unique books\\"]. Parameters: n (int): The number of shared books. book_titles (List[str]): List of book titles. Returns: List[str]: List of unique book titles sorted alphabetically, or [\\"no unique books\\"] if no unique titles are found. Examples: >>> find_unique_books(5, [\\"harrypotter\\", \\"lordoftherings\\", \\"harrypotter\\", \\"gameofthrones\\", \\"prideandprejudice\\"]) [\\"gameofthrones\\", \\"lordoftherings\\", \\"prideandprejudice\\"] >>> find_unique_books(4, [\\"threehundred\\", \\"inception\\", \\"threehundred\\", \\"inception\\"]) [\\"no unique books\\"]","solution":"def find_unique_books(n, book_titles): from collections import Counter # Count the occurrences of each book title book_count = Counter(book_titles) # Filter titles that appear exactly once unique_books = [book for book, count in book_count.items() if count == 1] # Sort the unique books alphabetically unique_books.sort() # Return the result if unique_books: return unique_books else: return [\\"no unique books\\"]"},{"question":"def minimal_difference(n: int, arr: List[int]) -> int: Divide the list of integers into two groups such that the absolute difference between the sums of the two groups is minimized. >>> minimal_difference(4, [1, 6, 11, 5]) 1 >>> minimal_difference(3, [10, 20, 15]) 5 >>> minimal_difference(5, [3, 1, 4, 2, 2]) 0","solution":"def minimal_difference(n, arr): import itertools total = sum(arr) min_diff = total # Initialize with a large number (total is the upper bound) for group_size in range(n + 1): for group in itertools.combinations(arr, group_size): group_sum = sum(group) current_diff = abs(total - 2 * group_sum) if current_diff < min_diff: min_diff = current_diff return min_diff"},{"question":"def count_arithmetic_triplets(n: int, sequence: List[int]) -> int: Returns the number of triplets in the sequence that form an arithmetic progression. Args: n (int): The number of elements in the sequence. sequence (List[int]): List of integers representing the sequence. Returns: int: The count of triplets that form an arithmetic progression. Examples: >>> count_arithmetic_triplets(7, [1, 3, 5, 7, 9, 11, 13]) 5 >>> count_arithmetic_triplets(5, [2, 4, 6, 8, 10]) 3","solution":"def count_arithmetic_triplets(n, sequence): Returns the number of triplets in the sequence that form an arithmetic progression. count = 0 for i in range(n - 2): if sequence[i + 1] - sequence[i] == sequence[i + 2] - sequence[i + 1]: count += 1 return count"},{"question":"def max_flowers(n: int, m: int, flower_types: List[int]) -> int: Returns the maximum number of flowers Linda can plant in a row such that no two adjacent flowers are of the same type. >>> max_flowers(1, 1, [1]) 1 >>> max_flowers(5, 5, [1, 2, 3, 4, 5]) 5 >>> max_flowers(5, 3, [1, 2, 1, 2, 3]) 5 >>> max_flowers(6, 3, [1, 1, 2, 2, 3, 3]) 3 >>> max_flowers(4, 1, [1, 1, 1, 1]) 1 >>> max_flowers(6, 2, [1, 2, 1, 2, 1, 2]) 6 >>> max_flowers(4, 3, [1, 3, 2, 2]) 3 from typing import List # Unit Tests def test_max_flowers_single_flower(): assert max_flowers(1, 1, [1]) == 1 def test_max_flowers_all_different(): assert max_flowers(5, 5, [1, 2, 3, 4, 5]) == 5 def test_max_flowers_alternating_types(): assert max_flowers(5, 3, [1, 2, 1, 2, 3]) == 5 def test_max_flowers_some_same_in_row(): assert max_flowers(6, 3, [1, 1, 2, 2, 3, 3]) == 3 def test_max_flowers_all_same_type(): assert max_flowers(4, 1, [1, 1, 1, 1]) == 1 def test_max_flowers_alternating_pairs(): assert max_flowers(6, 2, [1, 2, 1, 2, 1, 2]) == 6 def test_max_flowers_random_types(): assert max_flowers(4, 3, [1, 3, 2, 2]) == 3","solution":"def max_flowers(n, m, flower_types): Returns the maximum number of flowers Linda can plant in a row such that no two adjacent flowers are of the same type. if n == 1: return 1 max_count = 1 # We can always plant at least one flower for i in range(1, n): if flower_types[i] != flower_types[i - 1]: max_count += 1 return max_count"},{"question":"def preprocess_grid(grid): Preprocesses the grid to compute a prefix_sum array for efficient subgrid sum calculation. >>> preprocess_grid([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [ [0, 0, 0, 0], [0, 1, 3, 6], [0, 5, 12, 21], [0, 12, 27, 45] ] def query_weight(prefix_sum, r1, c1, r2, c2): Calculates the weight of a subgrid given the prefix_sum array and subgrid corners. >>> prefix_sum = [ ... [0, 0, 0, 0], ... [0, 1, 3, 6], ... [0, 5, 12, 21], ... [0, 12, 27, 45] ... ] >>> query_weight(prefix_sum, 1, 1, 2, 2) 12 >>> query_weight(prefix_sum, 2, 2, 3, 3) 28 def solve(grid, queries): Solves the problem by processing the grid and answering each query with the subgrid weight. >>> grid = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> queries = [ ... (1, 1, 2, 2), ... (2, 2, 3, 3), ... (1, 1, 3, 3) ... ] >>> solve(grid, queries) [12, 28, 45]","solution":"def preprocess_grid(grid): n = len(grid) m = len(grid[0]) prefix_sum = [[0] * (m + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, m + 1): prefix_sum[i][j] = grid[i-1][j-1] + prefix_sum[i-1][j] + prefix_sum[i][j-1] - prefix_sum[i-1][j-1] return prefix_sum def query_weight(prefix_sum, r1, c1, r2, c2): return prefix_sum[r2][c2] - prefix_sum[r1-1][c2] - prefix_sum[r2][c1-1] + prefix_sum[r1-1][c1-1] def solve(grid, queries): prefix_sum = preprocess_grid(grid) results = [] for r1, c1, r2, c2 in queries: results.append(query_weight(prefix_sum, r1, c1, r2, c2)) return results"},{"question":"def min_steps_to_reach_end(n: int, arr: List[int]) -> int: Determine the minimum number of steps required to reach the last position of the sequence. >>> min_steps_to_reach_end(5, [2, 3, 1, 1, 4]) 2 >>> min_steps_to_reach_end(6, [3, 2, 1, 0, 4, 2]) -1 >>> min_steps_to_reach_end(8, [1, 1, 2, 3, 1, 1, 1, 1]) 5 >>> min_steps_to_reach_end(1, [0]) 0 >>> min_steps_to_reach_end(2, [1, 2]) 1 >>> min_steps_to_reach_end(3, [3, 2, 1]) 1 >>> min_steps_to_reach_end(10, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 4 >>> min_steps_to_reach_end(4, [1, 1, 1, 1]) 3","solution":"def min_steps_to_reach_end(n, arr): if n == 1: return 0 max_reach, steps, jumps = arr[0], arr[0], 1 if max_reach == 0: return -1 for i in range(1, n): if i == n - 1: return jumps max_reach = max(max_reach, i + arr[i]) steps -= 1 if steps == 0: jumps += 1 if i >= max_reach: return -1 steps = max_reach - i return -1"},{"question":"def prime_counts_for_ranges(test_cases): Given a list of test cases, return the count of prime numbers for each range. >>> prime_counts_for_ranges([(1, 10)]) [4] >>> prime_counts_for_ranges([(11, 20)]) [4] >>> prime_counts_for_ranges([(20, 30)]) [2] >>> prime_counts_for_ranges([(1, 10), (11, 20), (20, 30)]) [4, 4, 2] >>> prime_counts_for_ranges([(1, 100000)]) [9592] >>> prime_counts_for_ranges([(29, 29)]) [1] >>> prime_counts_for_ranges([(0, 1)]) [0]","solution":"def sieve_of_eratosthenes(n): Generate a boolean array prime[0..n] where prime[i] will be True if i is a prime number prime = [True] * (n + 1) p = 2 while (p * p <= n): if prime[p] == True: for i in range(p * p, n + 1, p): prime[i] = False p += 1 prime[0], prime[1] = False, False return prime def count_primes_between_l_and_r(l, r, primes): Count the number of primes between l and r inclusive. return sum(primes[l:r + 1]) def prime_counts_for_ranges(test_cases): Given a list of test cases, return the count of prime numbers for each range. results = [] max_r = max(r for _, r in test_cases) primes = sieve_of_eratosthenes(max_r) for l, r in test_cases: results.append(count_primes_between_l_and_r(l, r, primes)) return results"},{"question":"def kth_smallest_element(nums: List[int], k: int) -> int: Returns the kth smallest element in sorted order of the array. >>> kth_smallest_element([4, 7, 1, 3, 9], 2) 3 >>> kth_smallest_element([1, 5, 2, 7, 3, 6], 4) 5 >>> kth_smallest_element([9, 8, 7], 1) 7 >>> kth_smallest_element([10**9, 2, 3, 1], 2) 2 >>> kth_smallest_element([3, 1, 2, 3, 2, 1], 4) 2","solution":"def kth_smallest_element(nums, k): Returns the kth smallest element in sorted order of the array. # Sort the array nums.sort() # Return the (k-1)th element (0-based index) return nums[k - 1]"},{"question":"def minimize_power_loss(n: int, m: int, connections: List[Tuple[int, int, int]]) -> Union[Tuple[int, int, List[int]], int]: Establish a network of power cables such that every building can be reached from any other building while ensuring that the total power loss rate is minimized. :param n: The number of buildings. :param m: The number of power cables. :param connections: List of tuples where each tuple contains three integers (ai, bi, li) representing the buildings connected by the power cable, and the power loss rate of that cable. :return: A tuple containing the total power loss rate of the minimal connecting network, the number of cables used, and the indices of these cables in ascending order. If it is impossible to connect all buildings, return -1. Example: >>> minimize_power_loss(4, 5, [(1, 2, 2), (2, 3, 1), (3, 4, 4), (1, 3, 5), (2, 4, 3)]) (6, 3, [1, 2, 5]) >>> minimize_power_loss(3, 1, [(1, 2, 5)]) -1","solution":"def minimize_power_loss(n, m, connections): import heapq from collections import defaultdict if n == 1: return 0, 0, [] graph = defaultdict(list) for idx, (u, v, w) in enumerate(connections): graph[u].append((w, v, idx + 1)) graph[v].append((w, u, idx + 1)) visited = set() min_heap = [(0, 1, -1)] # (power_loss, node, cable index) total_loss = 0 cables_used = [] while min_heap and len(visited) < n: loss, node, cable_idx = heapq.heappop(min_heap) if node in visited: continue visited.add(node) if cable_idx != -1: total_loss += loss cables_used.append(cable_idx) for cost, neighbour, idx in graph[node]: if neighbour not in visited: heapq.heappush(min_heap, (cost, neighbour, idx)) if len(visited) != n: return -1 cables_used.sort() return total_loss, len(cables_used), cables_used"},{"question":"def longest_increasing_subarray_length(n: int, heights: List[int]) -> int: Determine the length of the longest strictly increasing contiguous subarray of the plant heights. >>> longest_increasing_subarray_length(7, [1, 2, 2, 3, 4, 1, 5]) 3 >>> longest_increasing_subarray_length(5, [5, 4, 3, 2, 1]) 1 >>> longest_increasing_subarray_length(6, [1, 3, 5, 2, 4, 6]) 3","solution":"def longest_increasing_subarray_length(n, heights): if n == 0: return 0 max_length = 1 current_length = 1 for i in range(1, n): if heights[i] > heights[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"def minimize_absolute_differences(arr: List[int]) -> List[int]: Rearranges the array such that the sum of absolute differences between consecutive elements is as small as possible. Args: arr: List[int] - An array of n unique integers Returns: List[int] - The rearranged array >>> minimize_absolute_differences([3, 1, 4, 1, 5]) [1, 5, 1, 4, 3] # or [1, 1, 3, 4, 5] >>> minimize_absolute_differences([3, 2, 1]) [1, 3, 2] # or [1, 2, 3]","solution":"def minimize_absolute_differences(arr): Rearranges the array such that the sum of absolute differences between consecutive elements is as small as possible. Args: arr: List[int] - An array of n unique integers Returns: List[int] - The rearranged array arr.sort() n = len(arr) # Create a new list by taking from the two ends alternately result = [] for i in range((n + 1) // 2): result.append(arr[i]) if i != n // 2: result.append(arr[-(i + 1)]) return result"},{"question":"def find_largest_value_in_path(grid: List[List[int]]) -> int: Finds the largest value along any simple path from (0, 0) to (m-1, n-1). Parameters: grid (List[List[int]]): 2D list representing the grid. Returns: int: The largest value encountered in any simple path. >>> find_largest_value_in_path([[4, 5, 6], [7, 8, 9], [10, 2, 1]]) 10 >>> find_largest_value_in_path([[1, 2, 3], [2, 3, 4], [3, 4, 5]]) 5 >>> find_largest_value_in_path([[10, 10, 10], [10, 10, 10], [10, 10, 10]]) 10 >>> find_largest_value_in_path([[1, 1, 1], [1, 1, 1], [1, 1, 1000]]) 1000 >>> find_largest_value_in_path([[1]]) 1","solution":"def find_largest_value_in_path(grid): Finds the largest value along any simple path from (0, 0) to (m-1, n-1). Parameters: grid (List[List[int]]): 2D list representing the grid. Returns: int: The largest value encountered in any simple path. m = len(grid) n = len(grid[0]) # Initialize a memoization table to store the largest value encountered for any path # ending in the current cell. dp = [[-float('inf')] * n for _ in range(m)] dp[0][0] = grid[0][0] # Starting point is the value of top-left corner for i in range(m): for j in range(n): if i > 0: dp[i][j] = max(dp[i][j], max(dp[i-1][j], grid[i][j])) if j > 0: dp[i][j] = max(dp[i][j], max(dp[i][j-1], grid[i][j])) if i < m-1: dp[i+1][j] = max(dp[i+1][j], dp[i][j], grid[i+1][j]) if j < n-1: dp[i][j+1] = max(dp[i][j+1], dp[i][j], grid[i][j+1]) return dp[m-1][n-1]"},{"question":"def max_water_trapped(heights): Returns the maximum amount of water that can be trapped between elevations. >>> max_water_trapped([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> max_water_trapped([]) 0 >>> max_water_trapped([1,1,1,1,1]) 0 >>> max_water_trapped([1,2,3,4,5]) 0 >>> max_water_trapped([5,4,3,2,1]) 0 >>> max_water_trapped([3,0,2,0,4]) 7 >>> max_water_trapped([2,2,2,2,2]) 0 >>> max_water_trapped([1]) 0 >>> max_water_trapped([1,2]) 0","solution":"def max_water_trapped(heights): Returns the maximum amount of water that can be trapped between elevations. if not heights: return 0 n = len(heights) left, right = 0, n - 1 left_max, right_max = heights[left], heights[right] trapped_water = 0 while left < right: if heights[left] < heights[right]: left += 1 left_max = max(left_max, heights[left]) trapped_water += left_max - heights[left] else: right -= 1 right_max = max(right_max, heights[right]) trapped_water += right_max - heights[right] return trapped_water"},{"question":"def are_permutations(str1: str, str2: str) -> bool: Determines if two strings are permutations of each other. Args: str1 (str): First string. str2 (str): Second string. Returns: bool: True if the strings are permutations of each other, False otherwise. >>> are_permutations(\\"abcd\\", \\"bcda\\") True >>> are_permutations(\\"abcde\\", \\"edcba\\") True >>> are_permutations(\\"abcd\\", \\"efg\\") False >>> are_permutations(\\"xyz\\", \\"abc\\") False","solution":"def are_permutations(str1, str2): Determines if two strings are permutations of each other. Args: str1 (str): First string. str2 (str): Second string. Returns: bool: True if the strings are permutations of each other, False otherwise. if len(str1) != len(str2): return False return sorted(str1) == sorted(str2) # Example usage # result = are_permutations(\\"abcd\\", \\"bcda\\") # print(result) # output should be: True"},{"question":"def find_critical_roads(n, k, roads): Identify the k most critical roads in Treeland's infrastructure. Parameters: n (int): The number of cities. k (int): The number of critical roads to identify. roads (list of tuples): List of roads where each road is a tuple (x_i, y_i). Returns: list of tuples: The k most critical roads. pass # Test cases def test_small_tree(): n = 5 k = 2 roads = [(1, 2), (1, 3), (3, 4), (2, 5)] critical_roads = find_critical_roads(n, k, roads) assert len(critical_roads) == k assert critical_roads[0] in roads assert critical_roads[1] in roads def test_large_tree(): n = 7 k = 3 roads = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (5, 7)] critical_roads = find_critical_roads(n, k, roads) assert len(critical_roads) == k assert critical_roads[0] in roads assert critical_roads[1] in roads assert critical_roads[2] in roads def test_simple_tree(): n = 2 k = 1 roads = [(1, 2)] critical_roads = find_critical_roads(n, k, roads) assert len(critical_roads) == k assert critical_roads[0] in roads","solution":"def find_critical_roads(n, k, roads): Returns the k critical roads in the country's infrastructure. Parameters: n (int): The number of cities. k (int): The number of critical roads to identify. roads (list of tuples): List of roads where each road is a tuple (x_i, y_i). Returns: list of tuples: The k most critical roads. # Since every road is critical in a tree (removal of any road splits the component into two) # We can return any k roads from the given list return roads[:k]"},{"question":"def max_non_overlapping_bridges(m, coordinates): Returns the maximum number of non-overlapping bridges that can be built. Each bridge connects exactly two cities at distinct coordinates. Args: m (int): The number of cities. coordinates (List[int]): The coordinates of the cities. Returns: int: The maximum number of non-overlapping bridges. Examples: >>> max_non_overlapping_bridges(5, [1, 5, 3, 9, 7]) 2 >>> max_non_overlapping_bridges(2, [1, 2]) 1","solution":"def max_non_overlapping_bridges(m, coordinates): Returns the maximum number of non-overlapping bridges that can be built. Each bridge connects exactly two cities at distinct coordinates. # Sort coordinates coordinates.sort() # Maximum bridges is simply half of the number of cities (each coordinated paired) return m // 2"},{"question":"def max_concurrent_tasks(task_intervals) -> int: Given a list of task intervals, each interval being a tuple (start, end), finds the maximum number of concurrent tasks. task_intervals: List[Tuple[int, int]] Returns an integer indicating the maximum number of concurrent tasks. pass if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() T = int(data[0]) tasks = [(int(data[i]), int(data[i+1])) for i in range(1, len(data), 2)] print(max_concurrent_tasks(tasks))","solution":"def max_concurrent_tasks(task_intervals): Given a list of task intervals, each interval being a tuple (start, end), finds the maximum number of concurrent tasks. task_intervals: List[Tuple[int, int]] Returns an integer indicating the maximum number of concurrent tasks. events = [] for start, end in task_intervals: events.append((start, 'start')) events.append((end, 'end')) events.sort(key=lambda x: (x[0], x[1] == 'end')) current_tasks = 0 max_tasks = 0 for time, event in events: if event == 'start': current_tasks += 1 max_tasks = max(max_tasks, current_tasks) else: current_tasks -= 1 return max_tasks if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() T = int(data[0]) tasks = [(int(data[i]), int(data[i+1])) for i in range(1, len(data), 2)] print(max_concurrent_tasks(tasks))"},{"question":"def max_water_trapped(heights: List[int]) -> int: Calculate the maximum water that can be trapped within the buildings. :param heights: List[int] - A list of integers representing the heights of buildings :return: int - The maximum units of water that can be trapped >>> max_water_trapped([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> max_water_trapped([4, 2, 0, 3, 2, 5, 4, 2]) 9 >>> max_water_trapped([1, 2, 1, 0, 1]) 1 >>> max_water_trapped([1, 1, 1, 1]) 0 >>> max_water_trapped([0, 0, 0, 0]) 0 >>> max_water_trapped([3]) 0 >>> max_water_trapped([3, 0]) 0 >>> max_water_trapped([3, 0, 2, 0, 4]) 7 >>> max_water_trapped([5, 4, 3, 2, 1]) 0","solution":"def max_water_trapped(heights): Calculate the maximum water that can be trapped within the buildings. :param heights: List[int] - A list of integers representing the heights of buildings :return: int - The maximum units of water that can be trapped if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n # Fill left_max left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) # Fill right_max right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) # Calculate the accumulated water water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"def min_street_lights_required(t: int, n_list: List[int]) -> List[int]: Determine the minimum number of street lights required to illuminate all the houses. >>> min_street_lights_required(1, [1]) [1] >>> min_street_lights_required(1, [2]) [1] >>> min_street_lights_required(1, [3]) [1] >>> min_street_lights_required(3, [1, 2, 3]) [1, 1, 1] >>> min_street_lights_required(1, [4]) [2] >>> min_street_lights_required(1, [5]) [2] >>> min_street_lights_required(1, [6]) [2] >>> min_street_lights_required(1, [10000]) [3334]","solution":"def min_street_lights_required(t, n_list): result = [] for n in n_list: result.append((n + 2) // 3) return result"},{"question":"def max_beauty(n: int, m: int, initial: List[int], beauty_values: List[int]) -> int: Calculate the maximum beauty value the gardener can achieve. Parameters: n (int): Number of pots m (int): Number of flower types in the predefined set initial (list of int): The initial arrangement of flowers in pots beauty_values (list of int): The beauty values of the predefined set of flower types Returns: int: Maximum beauty value Example: >>> max_beauty(3, 4, [1, 2, 3], [10, 20, 30, 40]) 120 >>> max_beauty(2, 3, [2, 3], [15, 25, 35]) 70 >>> max_beauty(1, 3, [1], [5, 10, 20]) 20 >>> max_beauty(4, 2, [1, 1, 1, 1], [30, 50]) 200 >>> max_beauty(30, 100, [i for i in range(1, 31)], [i*2 for i in range(1, 101)]) 6000","solution":"def max_beauty(n, m, initial, beauty_values): Calculate the maximum beauty value the gardener can achieve. Parameters: n (int): Number of pots m (int): Number of flower types in the predefined set initial (list of int): The initial arrangement of flowers in pots beauty_values (list of int): The beauty values of the predefined set of flower types Returns: int: Maximum beauty value max_beauty_value = max(beauty_values) # Get the maximum beauty value from the predefined set return max_beauty_value * n # Max value is achieved by replacing all pots with the flower of max beauty"},{"question":"def order_teams(n: int, ratings: List[int]) -> List[int]: Returns a permutation of n integers - a valid order of team presentations such that no team with a lower rating follows a team with a higher rating. Parameters: n (int): Number of teams ratings (list): List of integer ratings of the teams Returns: list: A permutation of n integers representing the order of team presentations pass # Unit tests def test_order_teams_example1(): n = 5 ratings = [3, 1, 4, 3, 2] result = order_teams(n, ratings) valid_result = [2, 5, 1, 4, 3] # This is one of the many valid orders assert result == valid_result def test_order_teams_example2(): n = 4 ratings = [2, 2, 2, 2] result = order_teams(n, ratings) valid_result = [1, 2, 3, 4] # This is one valid order assert sorted(result) == sorted(valid_result) # Any permutation that preserves the order def test_order_teams_single_team(): n = 1 ratings = [5] result = order_teams(n, ratings) assert result == [1] def test_order_teams_descending_order(): n = 3 ratings = [3, 2, 1] result = order_teams(n, ratings) valid_result = [3, 2, 1] assert result == valid_result def test_order_teams_ascending_order(): n = 3 ratings = [1, 2, 3] result = order_teams(n, ratings) valid_result = [1, 2, 3] assert result == valid_result def test_order_teams_random_order(): n = 6 ratings = [6, 1, 5, 2, 4, 3] result = order_teams(n, ratings) valid_result = [2, 4, 6, 5, 3, 1] # This is one of the many valid orders assert sorted(result) == sorted(valid_result) def test_order_teams_repeated_ratings(): n = 5 ratings = [2, 1, 2, 1, 2] result = order_teams(n, ratings) valid_result = [2, 4, 1, 3, 5] # This is one of the many valid orders assert sorted(result) == sorted(valid_result)","solution":"def order_teams(n, ratings): Returns a permutation of n integers - a valid order of team presentations such that no team with a lower rating follows a team with a higher rating. Parameters: n (int): Number of teams ratings (list): List of integer ratings of the teams Returns: list: A permutation of n integers representing the order of team presentations # Create a list of (rating, index) tuples indexed_ratings = [(ratings[i], i + 1) for i in range(n)] # Sort the list based on ratings (first element of each tuple) indexed_ratings.sort() # Extract the indices (team numbers) from the sorted list ordered_teams = [team[1] for team in indexed_ratings] return ordered_teams"},{"question":"def distinct_paths(x: int, y: int) -> int: Determine the number of distinct shortest paths from (0, 0) to (x, y). The input consists of two integers x and y (0  x, y  100). >>> distinct_paths(2, 2) 6 >>> distinct_paths(3, 3) 20 >>> distinct_paths(4, 2) 15","solution":"def distinct_paths(x, y): from math import comb # The number of distinct shortest paths from (0, 0) to (x, y) is given by combinations return comb(x + y, x)"},{"question":"def unique_books_with_genres(n: int, books_genres: List[str]) -> List[str]: Transforms the list of books to a list of unique book names sorted alphabetically along with their respective genres. >>> unique_books_with_genres(8, [\\"HarryPotter Fantasy\\", \\"TheHobbit Fantasy\\", \\"harrypotter Fantasy\\", \\"WarAndPeace Classic\\", \\"TheHobbit fantasy\\", \\"WarAndPeace Classic\\", \\"ToKillAMockingbird Classic\\", \\"HarryPotter Fantasy\\"]) [\\"5\\", \\"HarryPotter Fantasy\\", \\"TheHobbit Fantasy\\", \\"ToKillAMockingbird Classic\\", \\"WarAndPeace Classic\\", \\"harrypotter Fantasy\\"] >>> unique_books_with_genres(4, [\\"BookOne SciFi\\", \\"BookTwo SciFi\\", \\"BookThree SciFi\\", \\"BookOne SciFi\\"]) [\\"3\\", \\"BookOne SciFi\\", \\"BookThree SciFi\\", \\"BookTwo SciFi\\"] >>> unique_books_with_genres(4, [\\"bookOne SciFi\\", \\"bookone SciFi\\", \\"Bookone SciFi\\", \\"BOOKONE SciFi\\"]) [\\"4\\", \\"BOOKONE SciFi\\", \\"Bookone SciFi\\", \\"bookOne SciFi\\", \\"bookone SciFi\\"] >>> unique_books_with_genres(4, [\\"BookOne SciFi\\", \\"BookTwo Fantasy\\", \\"BookThree Adventure\\", \\"BookFour Horror\\"]) [\\"4\\", \\"BookFour Horror\\", \\"BookOne SciFi\\", \\"BookThree Adventure\\", \\"BookTwo Fantasy\\"]","solution":"def unique_books_with_genres(n, books_genres): Transforms the list of books to a list of unique book names sorted alphabetically along with their respective genres. unique_books = {} for book_genre in books_genres: book, genre = book_genre.split() if book not in unique_books: unique_books[book] = genre sorted_unique_books = sorted(unique_books.items()) output = [] output.append(str(len(sorted_unique_books))) for book, genre in sorted_unique_books: output.append(f\\"{book} {genre}\\") return output"},{"question":"def generate_planting_plan(n, m, k): Generates a valid planting plan for a grid of size n x m with k different types of crops, or returns 'NO' if it is not possible to create one with the given k crop types. >>> generate_planting_plan(3, 3, 2) [\\"YES\\", \\"1 2 1\\", \\"2 1 2\\", \\"1 2 1\\"] >>> generate_planting_plan(2, 2, 1) [\\"NO\\"] >>> generate_planting_plan(3, 3, 3) [\\"YES\\", \\"1 2 3\\", \\"2 3 1\\", \\"3 1 2\\"] >>> generate_planting_plan(2, 2, 2) [\\"YES\\", \\"1 2\\", \\"2 1\\"] >>> generate_planting_plan(1, 1, 1) [\\"YES\\", \\"1\\"] >>> generate_planting_plan(4, 4, 3) [\\"YES\\", \\"1 2 3 1\\", \\"2 3 1 2\\", \\"3 1 2 3\\", \\"1 2 3 1\\"]","solution":"def generate_planting_plan(n, m, k): if k == 1 and (n > 1 or m > 1): return [\\"NO\\"] plan = [[0] * m for _ in range(n)] for i in range(n): for j in range(m): plan[i][j] = ((i + j) % k) + 1 return [\\"YES\\"] + [' '.join(map(str, row)) for row in plan]"},{"question":"def can_place_boxes_on_shelves(n: int, m: int, box_weights: List[int], shelf_limits: List[int]) -> str: Determines if it is possible to place all boxes on the shelves without exceeding the weight limits. >>> can_place_boxes_on_shelves(3, 2, [10, 20, 30], [50, 50]) \\"YES\\" >>> can_place_boxes_on_shelves(3, 2, [10, 20, 30], [40, 15]) \\"NO\\"","solution":"def can_place_boxes_on_shelves(n, m, box_weights, shelf_limits): Determines if it is possible to place all boxes on the shelves without exceeding the weight limits. Parameters: n (int): Number of boxes m (int): Number of shelves box_weights (list of int): Weights of the boxes shelf_limits (list of int): Weight limits of the shelves Returns: str: \\"YES\\" if all boxes can be placed without exceeding shelf limits, \\"NO\\" otherwise box_weights.sort(reverse=True) shelf_limits.sort(reverse=True) for i in range(min(n, m)): if box_weights[i] > shelf_limits[i]: return \\"NO\\" return \\"YES\\""},{"question":"def game_results(test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine who will win for each test case if both players play optimally. Args: test_cases (list): List of test cases, where each test case is a tuple (n, sequence). Returns: list: List of strings with the results for each test case. # Implement the logic to determine the winner for each test case from typing import List, Tuple def test_gara_win_odd_sequence(): assert game_results([(3, [1, 2, 3])]) == [\\"Gara\\"] def test_kankuro_win_even_sequence(): assert game_results([(4, [1, 3, 2, 4])]) == [\\"Kankuro\\"] def test_mixed_cases(): assert game_results([(3, [1, 2, 3]), (4, [5, 3, 2, 1]), (4, [1, 3, 2, 4]), (5, [1, 2, 3, 4, 5])]) == [\\"Gara\\", \\"Kankuro\\", \\"Kankuro\\", \\"Gara\\"] def test_multiple_cases(): assert game_results([(2, [1, 2]), (2, [2, 1]), (5, [1, 2, 3, 4, 5])]) == [\\"Kankuro\\", \\"Kankuro\\", \\"Gara\\"] def test_long_sequence(): long_seq = list(range(1, 1001)) assert game_results([(1000, long_seq)]) == [\\"Kankuro\\"]","solution":"def can_gara_win(sequence): Determine if Gara can secure a victory in the game with the given sequence. Args: sequence (list): List of integers representing the sequence. Returns: str: \\"Gara\\" if Gara can secure a victory, \\"Kankuro\\" otherwise. # The logic here follows that if there is a strictly increasing subsequence # of length >= 2 then the number of such subsequences will determine the outcome. n = len(sequence) # If the number of elements is odd, Gara will always win, because # Gara can make the first move and there will be an odd number of moves # to be made, so Gara gets the last move. if n % 2 == 1: return \\"Gara\\" else: # Since the total length of the sequence is even, Kankuro will always # have the last move assuming both play optimally. return \\"Kankuro\\" def game_results(test_cases): Process multiple test cases and determine the results for each case. Args: test_cases (list): List of test cases, where each test case is a tuple (n, sequence). Returns: list: List of strings with the results for each test case. results = [] for n, sequence in test_cases: results.append(can_gara_win(sequence)) return results"},{"question":"from typing import List, Tuple def longest_continuous_subsequence(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Alex is playing a card game with a deck of N cards. Each card has a distinct value. Alex likes to play a continuous sub-sequence of cards if they form a valid sequence according to a specific rule: the difference between every two consecutive cards in the sub-sequence should be exactly 1. Given the number of test cases and the test cases themselves, determine the length of the longest continuous sub-sequence that satisfies the rule for each test case. Args: T (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of tuples where each tuple contains an integer N (the number of cards) and a list of integers representing the values of the cards. Returns: List[int]: A list of integers representing the lengths of the longest valid continuous sub-sequences for each test case. Examples: >>> T = 2 >>> test_cases = [(6, [10, 12, 11, 14, 13, 15]), (5, [3, 5, 2, 4, 1])] >>> longest_continuous_subsequence(T, test_cases) [6, 5] >>> T = 1 >>> test_cases = [(1, [5])] >>> longest_continuous_subsequence(T, test_cases) [1]","solution":"def longest_continuous_subsequence(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] cards = test_cases[i][1] if N == 0: results.append(0) continue cards.sort() max_length = 1 current_length = 1 for j in range(1, N): if cards[j] == cards[j-1] + 1: current_length += 1 else: current_length = 1 max_length = max(max_length, current_length) results.append(max_length) return results # To use the function: def solution(input_str): lines = input_str.splitlines() T = int(lines[0]) test_cases = [(int(lines[i*2+1]), list(map(int, lines[i*2+2].split()))) for i in range(T)] results = longest_continuous_subsequence(T, test_cases) for result in results: print(result)"},{"question":"def find_kth_sum_of_cubes(k: int) -> int: Implement a function that takes in a positive integer k and returns the kth number in the sorted list of all the numbers that are the sum of two positive cubes in two or more different ways. A number x is the sum of two positive cubes in two different ways if there exist distinct pairs of positive integers (a, b) and (c, d) such that x = a^3 + b^3 = c^3 + d^3. Args: k (int): A positive integer representing the position. Returns: int: The kth number in the sorted list of all numbers that are the sum of cubes in two or more different ways. Examples: >>> find_kth_sum_of_cubes(1) 1729 >>> find_kth_sum_of_cubes(2) 4104","solution":"def find_kth_sum_of_cubes(k): # A dictionary for storing sums of cubes and their pairs cube_sums = {} # Iterate over a range of numbers to find sums of cubes limit = 100 for a in range(1, limit): for b in range(a, limit): cube_sum = a**3 + b**3 if cube_sum in cube_sums: cube_sums[cube_sum].add((a, b)) else: cube_sums[cube_sum] = {(a, b)} # Filter out the sums that have at least two different pairs valid_sums = [sum_ for sum_, pairs in cube_sums.items() if len(pairs) > 1] # Sort the valid sums and return the kth element valid_sums.sort() return valid_sums[k - 1]"},{"question":"def process_operations(n: int, m: int, operations: List[List[int]]) -> List[int]: Perform update and query operations on a grid. :param n: Number of rows in the grid. :param m: Number of columns in the grid. :param operations: List of operations to perform on the grid. :return: List of results from the query operations. The operations are of two types: 1. \`1 x y v\` - Update the value at cell (x, y) to v. 2. \`2 x1 y1 x2 y2\` - Find the sum of the values in the subgrid from (x1, y1) to (x2, y2). Example: >>> process_operations(4, 4, [ [1, 1, 1, 3], [1, 2, 2, 2], [2, 1, 1, 2, 2], [1, 3, 3, 5], [2, 2, 2, 4, 4] ]) [5, 7] pass","solution":"class Grid: def __init__(self, n, m): self.n = n self.m = m self.grid = [[0] * m for _ in range(n)] def update(self, x, y, v): self.grid[x-1][y-1] = v def query(self, x1, y1, x2, y2): sum_value = 0 for i in range(x1-1, x2): for j in range(y1-1, y2): sum_value += self.grid[i][j] return sum_value def process_operations(n, m, operations): grid = Grid(n, m) results = [] for operation in operations: if operation[0] == 1: _, x, y, v = operation grid.update(x, y, v) elif operation[0] == 2: _, x1, y1, x2, y2 = operation result = grid.query(x1, y1, x2, y2) results.append(result) return results"},{"question":"from typing import List def find_longest_unique_sequence(nums: List[int], k: int) -> int: Find the length of the longest unique number sequence within the list where all numbers are no more than k steps apart from each other. >>> find_longest_unique_sequence([1, 3, 5, 7, 8, 9], 4) 4 >>> find_longest_unique_sequence([1, 2, 3, 4], 2) 3 pass # Your implementation here","solution":"from typing import List def find_longest_unique_sequence(nums: List[int], k: int) -> int: nums = sorted(set(nums)) n = len(nums) if n == 0: return 0 max_length = 1 start = 0 for end in range(1, n): if nums[end] - nums[start] > k: start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"from typing import List def can_partition_servers(N: int, T: int, comm_time: List[List[int]]) -> str: Determines if the servers can be partitioned into groups such that each group's maximum communication time does not exceed the threshold T. >>> can_partition_servers(4, 2, [[0, 1, 4, 2], [1, 0, 4, 3], [4, 4, 0, 2], [2, 3, 2, 0]]) == \\"YES\\" >>> can_partition_servers(4, 2, [[0, 5, 4, 2], [5, 0, 4, 3], [4, 4, 0, 2], [2, 3, 2, 0]]) == \\"NO\\" >>> can_partition_servers(4, 0, [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]) == \\"YES\\" >>> can_partition_servers(4, 4, [[0, 1, 3, 4], [1, 0, 2, 3], [3, 2, 0, 2], [4, 3, 2, 0]]) == \\"YES\\" >>> can_partition_servers(1, 0, [[0]]) == \\"YES\\"","solution":"def can_partition_servers(N, T, comm_time): def floyd_warshall(graph): distance = list(map(lambda i: list(map(lambda j: j, i)), graph)) for k in range(N): for i in range(N): for j in range(N): distance[i][j] = min(distance[i][j], distance[i][k] + distance[k][j]) return distance critical_distance = floyd_warshall(comm_time) def is_group_within_threshold(threshold): visited = [False] * N def dfs(node, threshold): stack = [node] while stack: current = stack.pop() for neighbor in range(N): if not visited[neighbor] and critical_distance[current][neighbor] <= threshold: visited[neighbor] = True stack.append(neighbor) components = 0 for node in range(N): if not visited[node]: components += 1 visited[node] = True dfs(node, threshold) return components return \\"YES\\" if is_group_within_threshold(T) == 1 else \\"NO\\""},{"question":"def rotate_string(s: str, d: int) -> str: Rotates the string s to the right by d positions. Parameters: s (str): The input string to rotate. d (int): The number of positions to rotate the string to the right. Returns: str: The rotated string. >>> rotate_string(\\"hello\\", 2) == \\"lohel\\" >>> rotate_string(\\"rotate\\", 3) == \\"aterot\\"","solution":"def rotate_string(s, d): Rotates the string s to the right by d positions. Parameters: s (str): The input string to rotate. d (int): The number of positions to rotate the string to the right. Returns: str: The rotated string. n = len(s) d = d % n # To handle the cases when d is larger than the length of s return s[-d:] + s[:-d]"},{"question":"def preprocess_prefix_sums(arr): Preprocesses the array to compute the prefix sums for efficient range-sum queries. pass def range_sum(prefix_sums, l, r): Computes the sum of elements in the range [l, r] using the prefix sums array. pass def process_queries(n, arr, queries): Processes multiple queries for range sums. Args: n (int): The number of elements in the array. arr (List[int]): The list of elements. queries (List[Tuple[int, int]]): The list of queries, each consisting of two integers indicating the range. Returns: List[int]: The list of sums corresponding to each query. Example: >>> n = 5 >>> arr = [1, 2, 3, 4, 5] >>> queries = [(1, 3), (2, 4), (1, 5)] >>> process_queries(n, arr, queries) [6, 9, 15] pass # Test Cases def test_preprocess_prefix_sums(): assert preprocess_prefix_sums([1, 2, 3, 4, 5]) == [0, 1, 3, 6, 10, 15] def test_range_sum(): prefix_sums = preprocess_prefix_sums([1, 2, 3, 4, 5]) assert range_sum(prefix_sums, 1, 3) == 6 assert range_sum(prefix_sums, 2, 4) == 9 assert range_sum(prefix_sums, 1, 5) == 15 def test_process_queries(): n = 5 arr = [1, 2, 3, 4, 5] queries = [(1, 3), (2, 4), (1, 5)] assert process_queries(n, arr, queries) == [6, 9, 15] def test_additional_cases(): n = 4 arr = [5, 1, 2, 4] queries = [(1, 2), (3, 4), (1, 4)] assert process_queries(n, arr, queries) == [6, 6, 12] n = 3 arr = [10, 20, 30] queries = [(1, 1), (1, 2), (1, 3), (2, 3), (3, 3)] assert process_queries(n, arr, queries) == [10, 30, 60, 50, 30] n = 1 arr = [100] queries = [(1, 1)] assert process_queries(n, arr, queries) == [100]","solution":"def preprocess_prefix_sums(arr): Preprocesses the array to compute the prefix sums for efficient range-sum queries. n = len(arr) prefix_sums = [0] * (n + 1) for i in range(n): prefix_sums[i + 1] = prefix_sums[i] + arr[i] return prefix_sums def range_sum(prefix_sums, l, r): Computes the sum of elements in the range [l, r] using the prefix sums array. return prefix_sums[r] - prefix_sums[l - 1] def process_queries(n, arr, queries): Processes multiple queries for range sums. prefix_sums = preprocess_prefix_sums(arr) result = [] for l, r in queries: result.append(range_sum(prefix_sums, l, r)) return result # Example usage: n = 5 arr = [1, 2, 3, 4, 5] queries = [(1, 3), (2, 4), (1, 5)] print(process_queries(n, arr, queries)) # Output: [6, 9, 15]"},{"question":"def is_isomorphic(s: str, t: str) -> bool: Determine if two strings are isomorphic. Args: s (str): The first string. t (str): The second string. Returns: bool: True if the strings are isomorphic, False otherwise. >>> is_isomorphic(\\"egg\\", \\"add\\") True >>> is_isomorphic(\\"foo\\", \\"bar\\") False >>> is_isomorphic(\\"paper\\", \\"title\\") True pass def check_isomorphic_strings(test_cases): Check multiple pairs of strings if they are isomorphic. Args: test_cases (List[Tuple[str, str]]): List of pairs of strings to be checked. Returns: List[str]: List of results \\"Yes\\" or \\"No\\" for each pair. >>> check_isomorphic_strings([(\\"egg\\", \\"add\\"), (\\"foo\\", \\"bar\\"), (\\"paper\\", \\"title\\")]) [\\"Yes\\", \\"No\\", \\"Yes\\"] >>> check_isomorphic_strings([(\\"ab\\", \\"aa\\"), (\\"abc\\", \\"xyz\\"), (\\"aabb\\", \\"ccdd\\"), (\\"\\", \\"\\")]) [\\"No\\", \\"Yes\\", \\"Yes\\", \\"Yes\\"] pass","solution":"def is_isomorphic(s: str, t: str) -> bool: if len(s) != len(t): return False map_s_t = {} map_t_s = {} for char_s, char_t in zip(s, t): if (char_s in map_s_t and map_s_t[char_s] != char_t) or (char_t in map_t_s and map_t_s[char_t] != char_s): return False map_s_t[char_s] = char_t map_t_s[char_t] = char_s return True def check_isomorphic_strings(test_cases): results = [] for s, t in test_cases: if is_isomorphic(s, t): results.append(\\"Yes\\") else: results.append(\\"No\\") return results # Example usage: # test_cases = [(\\"egg\\", \\"add\\"), (\\"foo\\", \\"bar\\"), (\\"paper\\", \\"title\\")] # print(check_isomorphic_strings(test_cases))"},{"question":"def process_operations(n: int, operations: List[List[str]]) -> List[str]: Process a series of operations on a list of integers to maintain and retrieve the median value. Args: n (int): The number of operations operations (List[List[str]]): List of operations: - \\"a x\\" (add x to the list, where x is an integer, -10^9  x  10^9) - \\"r x\\" (remove x from the list, where x is an integer) - \\"m\\" (print the current median value of the list) Returns: List[str]: A list of median values after each \\"m\\" operation. Example: >>> process_operations( ... 7, [['a', '1'], ['a', '2'], ['a', '3'], ['m'], ['r', '2'], ['m'], ['a', '4'], ['m']] ... ) ['2.0', '2.0', '3.0']","solution":"import bisect class MedianMaintainer: def __init__(self): self.data = [] def add(self, x): bisect.insort(self.data, x) def remove(self, x): if x in self.data: self.data.remove(x) def get_median(self): n = len(self.data) if n % 2 == 1: return float(self.data[n // 2]) else: return (self.data[n // 2 - 1] + self.data[n // 2]) / 2.0 def process_operations(n, operations): mm = MedianMaintainer() results = [] for operation in operations: if operation[0] == 'a': mm.add(int(operation[1])) elif operation[0] == 'r': mm.remove(int(operation[1])) elif operation[0] == 'm': results.append(f\\"{mm.get_median():.1f}\\") return results"},{"question":"def smallest_x(a: int, b: int) -> int: Returns the smallest non-negative integer x such that (a + x) % b == 0 >>> smallest_x(5, 3) 1 >>> smallest_x(10, 7) 4 >>> smallest_x(9, 3) 0 >>> smallest_x(0, 5) 0 >>> smallest_x(7, 7) 0 >>> smallest_x(123456789, 1000) 211 >>> smallest_x(4, 10) 6 >>> smallest_x(999999999, 1) 0","solution":"def smallest_x(a, b): Returns the smallest non-negative integer x such that (a + x) % b == 0 remainder = a % b if remainder == 0: return 0 else: return b - remainder"},{"question":"def new_items_count(n: int, collection: List[int], m: int, marketplace: List[int]) -> int: Determines the number of new items in the marketplace that are not in Alice's collection. :param n: int, number of items in Alice's collection :param collection: list of int, IDs of items in Alice's collection :param m: int, number of items in the marketplace :param marketplace: list of int, IDs of items in the marketplace :return: int, number of new items in the marketplace not in Alice's collection >>> new_items_count(5, [1, 2, 3, 4, 5], 5, [4, 5, 6, 7, 8]) 3 >>> new_items_count(3, [1, 2, 3], 3, [1, 2, 3]) 0 >>> new_items_count(3, [1, 2, 3], 3, [4, 5, 6]) 3 >>> new_items_count(4, [1, 2, 3, 4], 4, [2, 3, 5, 6]) 2","solution":"def new_items_count(n, collection, m, marketplace): Determines the number of new items in the marketplace that are not in Alice's collection. :param n: int, number of items in Alice's collection :param collection: list of int, IDs of items in Alice's collection :param m: int, number of items in the marketplace :param marketplace: list of int, IDs of items in the marketplace :return: int, number of new items in the marketplace not in Alice's collection collection_set = set(collection) marketplace_set = set(marketplace) new_items = marketplace_set - collection_set return len(new_items)"},{"question":"def min_steps_to_unique(k: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Calculate the minimum number of steps required to make all elements of the array unique by multiplying any element of the array by 2. Args: k (int): Number of test cases. test_cases (List[Tuple[int, List[int]]]): List of tuples where each tuple contains an integer \`m\` (size of the array) and a list of \`m\` integers. Returns: List[int]: List of integers corresponding to the minimum number of steps to make the array unique for each test case. >>> min_steps_to_unique(3, [(3, [2, 2, 3]), (4, [1, 2, 3, 3]), (2, [5, 5])]) [1, 1, 1] >>> min_steps_to_unique(1, [(2, [1000, 1000])]) [1] >>> min_steps_to_unique(3, [(3, [1, 2, 3]), (4, [-1, -2, -3, -4]), (3, [1000, -1000, 500])]) [0, 0, 0]","solution":"def min_steps_to_unique(k, test_cases): def min_steps(arr): seen = set() steps = 0 for num in arr: while num in seen: num *= 2 steps += 1 seen.add(num) return steps results = [] for m, b in test_cases: results.append(min_steps(b)) return results"},{"question":"def is_palindrome(s: str) -> bool: Determines if a string is a palindrome, considering case insensitivity and ignoring non-alphanumeric characters. >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") True >>> is_palindrome(\\"race a car\\") False >>> is_palindrome(\\"\\") True >>> is_palindrome(\\"0P\\") False","solution":"def is_palindrome(s: str) -> bool: Returns True if the given string s is a palindrome, considering case insensitivity and ignoring non-alphanumeric characters. # Filter out non-alphanumeric characters and convert to lowercase cleaned_str = ''.join(char.lower() for char in s if char.isalnum()) # Check if the cleaned string is equal to its reverse return cleaned_str == cleaned_str[::-1]"},{"question":"import heapq def find_kth_largest(nums, k): Finds the k-th largest element in an unsorted array. Parameters: nums (list of int): The array of integers. k (int): The position of the k-th largest element. Returns: int: The k-th largest element in the array. def test_sample_inputs(): assert find_kth_largest([3, 2, 1, 5, 6, 4], 2) == 5 assert find_kth_largest([10, 20, 15, 12, 40, 25, 18, 30], 4) == 20 def test_all_elements_same(): assert find_kth_largest([1, 1, 1, 1, 1, 1], 1) == 1 assert find_kth_largest([1, 1, 1, 1, 1, 1], 3) == 1 def test_k_is_one(): assert find_kth_largest([3, 2, 1, 5, 6, 4], 1) == 6 assert find_kth_largest([10, 20, 15, 12, 40, 25, 18, 30], 1) == 40 def test_negative_numbers(): assert find_kth_largest([-10, -7, -5, -3, -2, -1], 2) == -2 assert find_kth_largest([-10, -7, -5, -3, -2, -1], 6) == -10 def test_mixed_sign_numbers(): assert find_kth_largest([-10, 7, -5, 3, -2, 1], 3) == 1 assert find_kth_largest([-10, 7, -5, 3, -2, 1], 4) == -2","solution":"import heapq def find_kth_largest(nums, k): Finds the k-th largest element in an unsorted array. Parameters: nums (list of int): The array of integers. k (int): The position of the k-th largest element. Returns: int: The k-th largest element in the array. # Use a min-heap of size k to keep track of the k largest elements seen so far min_heap = [] for num in nums: heapq.heappush(min_heap, num) if len(min_heap) > k: heapq.heappop(min_heap) return min_heap[0]"},{"question":"def max_min_tower_heights(n: int, blocks: List[int]) -> Tuple[int, int]: Determine the maximum and minimum heights of the tower they can create with the given blocks. Args: n: int - the number of blocks blocks: List[int] - the list of integers representing the numbers on the blocks Returns: Tuple[int, int] - a tuple containing the maximum and minimum heights of the tower >>> max_min_tower_heights(5, [4, 3, 2, 6, 7]) (5, 5) >>> max_min_tower_heights(3, [10, 20, 10]) (3, 2) >>> max_min_tower_heights(1, [100]) (1, 1) >>> max_min_tower_heights(4, [5, 5, 5, 5]) (4, 1) >>> max_min_tower_heights(4, [1, 2, 3, 4]) (4, 4) >>> max_min_tower_heights(6, [1, 2, 2, 3, 3, 4]) (6, 4) pass","solution":"def max_min_tower_heights(n, blocks): Returns the maximum and minimum heights of the tower that can be built. # The maximum height is simply the number of blocks max_height = n # For the minimum height, we count the unique numbers in the blocks min_height = len(set(blocks)) return max_height, min_height # Example usage: # n = 5 # blocks = [4, 3, 2, 6, 7] # print(max_min_tower_heights(n, blocks)) # Output should be (5, 5)"},{"question":"from typing import List, Tuple def find_overtime_employees(employee_data: List[Tuple[str, int, int, int, int, int, int, int]]) -> List[str]: Given a list of employee working hours for a week, returns the IDs of employees who worked overtime (> 40 hours). >>> find_overtime_employees([(\\"E01\\", 8, 8, 8, 8, 8, 0, 0), (\\"E02\\", 7, 7, 7, 7, 7, 7, 7)]) ['E02'] >>> find_overtime_employees([(\\"E01\\", 8, 8, 8, 8, 8, 0, 0), (\\"E02\\", 6, 6, 6, 6, 6, 6, 1)]) ['NO OVERTIME']","solution":"def find_overtime_employees(employee_data): Given a list of employee working hours for a week, returns the IDs of employees who worked overtime (> 40 hours). overtime_employees = [] for data in employee_data: employee_id = data[0] weekly_hours = data[1:] total_hours = sum(weekly_hours) if total_hours > 40: overtime_employees.append(employee_id) if not overtime_employees: return [\\"NO OVERTIME\\"] return overtime_employees"},{"question":"def num_paths(n: int, m: int, k: int, forbidden: List[Tuple[int, int]]) -> int: Determine the number of different valid paths the robot can take to reach the bottom-right corner without passing through forbidden cells. >>> num_paths(3, 3, 1, [(2, 2)]) 2 >>> num_paths(3, 3, 2, [(2, 2), (3, 1)]) 1 >>> num_paths(3, 3, 3, [(2, 2), (3, 1), (1, 3)]) 0 from typing import List, Tuple def test_num_paths(): assert num_paths(3, 3, 1, [(2, 2)]) == 2 assert num_paths(3, 3, 2, [(2, 2), (3, 1)]) == 1 assert num_paths(3, 3, 3, [(2, 2), (3, 1), (1, 3)]) == 0 assert num_paths(3, 3, 0, []) == 6 assert num_paths(1, 1, 0, []) == 1 assert num_paths(2, 2, 1, [(1, 2)]) == 1 assert num_paths(2, 2, 1, [(2, 1)]) == 1 assert num_paths(2, 2, 2, [(1, 2), (2, 1)]) == 0 if __name__ == \\"__main__\\": test_num_paths() print(\\"All tests passed.\\")","solution":"def num_paths(n, m, k, forbidden): # Create a grid initialized with 0 grid = [[0] * m for _ in range(n)] # Mark the forbidden cells for x, y in forbidden: grid[x-1][y-1] = -1 # Start position if grid[0][0] != -1: grid[0][0] = 1 # Fill the grid with path counts for i in range(n): for j in range(m): if grid[i][j] == -1: continue if i > 0 and grid[i-1][j] != -1: grid[i][j] += grid[i-1][j] if j > 0 and grid[i][j-1] != -1: grid[i][j] += grid[i][j-1] # The number of paths to the bottom-right corner return grid[n-1][m-1] if grid[n-1][m-1] != -1 else 0"},{"question":"def sum_of_unique_elements(M: int) -> int: Returns the sum of all unique elements in an MxM matrix where elements are given by (i + j) % M. >>> sum_of_unique_elements(2) 1 >>> sum_of_unique_elements(3) 3 >>> sum_of_unique_elements(4) 6 >>> sum_of_unique_elements(1) 0 >>> sum_of_unique_elements(5) 10 def process_test_cases(test_cases: List[int]) -> List[int]: Processes multiple test cases to calculate the sum of all unique elements in their respective MxM matrices. >>> process_test_cases([2]) [1] >>> process_test_cases([3, 4]) [3, 6] >>> process_test_cases([1, 2, 3]) [0, 1, 3] >>> process_test_cases([10**18]) [(10**18 * (10**18 - 1)) // 2]","solution":"def sum_of_unique_elements(M): Returns the sum of all unique elements in an MxM matrix where elements are given by (i + j) % M. return (M * (M - 1)) // 2 def process_test_cases(test_cases): results = [] for M in test_cases: results.append(sum_of_unique_elements(M)) return results"},{"question":"def calculate_bonus(Y: int) -> int: Returns the total bonus for an employee based on their years of service. :param Y: int : Number of years the employee has worked at the company (1  Y  50) :return: int: Total bonus the employee is entitled to","solution":"def calculate_bonus(Y): Returns the total bonus for an employee based on their years of service. :param Y: int : Number of years the employee has worked at the company (1  Y  50) :return: int: Total bonus the employee is entitled to base_bonus = Y * 100 additional_bonus = 0 if Y >= 5: additional_bonus += 500 if Y >= 10: additional_bonus += 1000 return base_bonus + additional_bonus"},{"question":"def is_palindrome(s): Check if the given string is a palindrome. return s == s[::-1] def longest_palindromic_subsequence(s): Find the length of the longest palindromic subsequence in the given string. n = len(s) dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = 1 for cl in range(2, n + 1): for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j] and cl == 2: dp[i][j] = 2 elif s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) return dp[0][n - 1] def galaxy_coin_value(val): Determine the GalaxyCoin value of the given string. if is_palindrome(val): return len(val) return 2 * longest_palindromic_subsequence(val) def solve(t, cases): Solve the GalaxyCoin problem for multiple test cases. results = [galaxy_coin_value(val) for val in cases] return results # Test cases if __name__ == \\"__main__\\": print(solve(3, [\\"abba\\", \\"abc\\", \\"cbbd\\"])) # Output: [4, 2, 4] print(solve(1, [\\"aaa\\"])) # Output: [3] print(solve(2, [\\"abcd\\", \\"dcba\\"])) # Output: [2, 2]","solution":"def is_palindrome(s): return s == s[::-1] def longest_palindromic_subsequence(s): n = len(s) dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = 1 for cl in range(2, n+1): for i in range(n-cl+1): j = i + cl - 1 if s[i] == s[j] and cl == 2: dp[i][j] = 2 elif s[i] == s[j]: dp[i][j] = dp[i+1][j-1] + 2 else: dp[i][j] = max(dp[i][j-1], dp[i+1][j]) return dp[0][n-1] def galaxy_coin_value(val): if is_palindrome(val): return len(val) return 2 * longest_palindromic_subsequence(val) def solve(t, cases): results = [] for val in cases: results.append(galaxy_coin_value(val)) return results"},{"question":"def encrypt_words(words: List[str], shifts: List[int]) -> List[str]: Encrypts a list of words using the Caesar cipher technique with respective shift values. :param words: List of words to be encrypted. :param shifts: List of shift values for each word. :return: List of encrypted words. >>> encrypt_words([\\"abc\\", \\"xyz\\", \\"hello\\"], [1, 3, 5]) [\\"bcd\\", \\"abc\\", \\"mjqqt\\"] >>> encrypt_words([\\"a\\", \\"m\\", \\"z\\"], [25, 25, 25]) [\\"z\\", \\"l\\", \\"y\\"] >>> encrypt_words([\\"abcdefghijklmnopqrstuvwxyz\\"], [1]) [\\"bcdefghijklmnopqrstuvwxyza\\"] >>> encrypt_words([\\"abc\\", \\"xyz\\", \\"hello\\"], [0, 0, 0]) [\\"abc\\", \\"xyz\\", \\"hello\\"] >>> encrypt_words([\\"xyz\\", \\"abc\\", \\"hello\\"], [1, 25, 13]) [\\"yza\\", \\"zab\\", \\"uryyb\\"] >>> encrypt_words([\\"a\\", \\"z\\"], [1, 1]) [\\"b\\", \\"a\\"]","solution":"def encrypt_words(words, shifts): Encrypts a list of words using the Caesar cipher technique with respective shift values. :param words: List of words to be encrypted. :param shifts: List of shift values for each word. :return: List of encrypted words. encrypted_words = [] for word, shift in zip(words, shifts): encrypted_word = [] for char in word: # Calculate the new character after shifting new_char = chr(((ord(char) - ord('a') + shift) % 26) + ord('a')) encrypted_word.append(new_char) encrypted_words.append(''.join(encrypted_word)) return encrypted_words"},{"question":"from collections import deque from typing import List def shortest_path_labyrinth(n: int, grid: List[str]) -> int: Determine the shortest path from the top-left to the bottom-right corner of a labyrinth. A labyrinth is represented by a grid, where '#' represents a barrier and '.' represents an empty cell. You can move up, down, left, or right. The function returns the length of the shortest path, or -1 if no such path exists. >>> shortest_path_labyrinth(4, [\\"....\\", \\"..#.\\", \\"..#.\\", \\"....\\"]) 6 >>> shortest_path_labyrinth(4, [\\"....\\", \\"\\", \\"....\\", \\"....\\"]) -1","solution":"from collections import deque def shortest_path_labyrinth(n, grid): directions = [(0,1), (1,0), (0,-1), (-1,0)] def is_within_bounds(x, y): return 0 <= x < n and 0 <= y < n visited = [[False for _ in range(n)] for _ in range(n)] queue = deque([(0, 0, 0)]) # (x, y, distance) visited[0][0] = True while queue: x, y, dist = queue.popleft() if x == n-1 and y == n-1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if is_within_bounds(nx, ny) and not visited[nx][ny] and grid[nx][ny] == '.': visited[nx][ny] = True queue.append((nx, ny, dist + 1)) return -1"},{"question":"def fizzbuzz_sequence(n: int) -> list: Generates the sequence based on FizzBuzz rules for integer n. Parameters: n (int): The length of the sequence. Returns: list: The resulting sequence with integers or substituted strings. >>> fizzbuzz_sequence(1) == [1] >>> fizzbuzz_sequence(2) == [1, \\"Fizz\\"] >>> fizzbuzz_sequence(3) == [1, \\"Fizz\\", \\"Buzz\\"] >>> fizzbuzz_sequence(10) == [1, \\"Fizz\\", \\"Buzz\\", \\"Fizz\\", 5, \\"FizzBuzz\\", 7, \\"Fizz\\", \\"Buzz\\", \\"Fizz\\"] >>> fizzbuzz_sequence(15) == [1, \\"Fizz\\", \\"Buzz\\", \\"Fizz\\", 5, \\"FizzBuzz\\", 7, \\"Fizz\\", \\"Buzz\\", \\"Fizz\\", 11, \\"FizzBuzz\\", 13, \\"Fizz\\", \\"Buzz\\"]","solution":"def fizzbuzz_sequence(n): Generates the sequence based on FizzBuzz rules for integer n. Parameters: n (int): The length of the sequence. Returns: list: The resulting sequence with integers or substituted strings. result = [] for k in range(1, n+1): if k % 6 == 0: result.append(\\"FizzBuzz\\") elif k % 2 == 0: result.append(\\"Fizz\\") elif k % 3 == 0: result.append(\\"Buzz\\") else: result.append(k) return result"},{"question":"def is_happy_number(n: int) -> bool: Determines if a number is a happy number. A happy number is a number defined by the following process: 1. Replace the number by the sum of the squares of its digits. 2. Repeat the process until the number equals 1 or it loops endlessly in a cycle. 3. If it equals 1, then it is a happy number. 4. If it does not, then it is not a happy number. Args: n: A positive integer. Returns: bool: True if n is a happy number, False otherwise.","solution":"def is_happy_number(n: int) -> bool: Determines if a number is a happy number. A happy number is a number defined by the following process: 1. Replace the number by the sum of the squares of its digits. 2. Repeat the process until the number equals 1 or it loops endlessly in a cycle. 3. If it equals 1, then it is a happy number. 4. If it does not, then it is not a happy number. Args: n: A positive integer. Returns: bool: True if n is a happy number, False otherwise. def get_next(number): return sum(int(x) ** 2 for x in str(number)) seen = set() while n != 1 and n not in seen: seen.add(n) n = get_next(n) return n == 1"},{"question":"def can_delete_lexicographically(S: str) -> str: Determines if S can be completely deleted such that after each operation, the new string is lexicographically smaller than the previous one. >>> can_delete_lexicographically(\\"aaa\\") 'YES' >>> can_delete_lexicographically(\\"zyx\\") 'YES' >>> can_delete_lexicographically(\\"cba\\") 'YES' >>> can_delete_lexicographically(\\"acbd\\") 'NO' >>> can_delete_lexicographically(\\"abcdef\\") 'NO'","solution":"def can_delete_lexicographically(S): Determines if S can be completely deleted such that after each operation, the new string is lexicographically smaller than the previous one. n = len(S) # Function to check the characters in non-increasing order def is_non_strictly_decreasing(s): return all(s[i] >= s[i + 1] for i in range(len(s) - 1)) if is_non_strictly_decreasing(S): return 'YES' return 'NO'"},{"question":"def calculate_minimum_energy(H: int, W: int, N: int, robots: List[Tuple[int, int, int, int]]) -> int: Calculate the minimum total energy required for all robots to reach their destinations. Parameters: H (int): The height of the warehouse grid. W (int): The width of the warehouse grid. N (int): The number of robots. robots (list of tuples): Each tuple contains (S_i, T_i, D_i, E_i) representing the start and destination positions of the i-th robot. Returns: int: The minimum total energy required. Examples: >>> calculate_minimum_energy(5, 5, 3, [(1, 1, 5, 5), (2, 2, 4, 4), (3, 3, 1, 1)]) 16 >>> calculate_minimum_energy(10, 10, 1, [(1, 1, 10, 10)]) 18 >>> calculate_minimum_energy(5, 5, 2, [(3, 3, 3, 3), (1, 1, 1, 1)]) 0 >>> calculate_minimum_energy(1, 1, 1, [(1, 1, 1, 1)]) 0 >>> calculate_minimum_energy(100, 100, 2, [(1, 1, 100, 100), (100, 100, 1, 1)]) 396","solution":"def calculate_minimum_energy(H, W, N, robots): Calculate the minimum total energy required for all robots to reach their destinations. Parameters: H (int): The height of the warehouse grid. W (int): The width of the warehouse grid. N (int): The number of robots. robots (list of tuples): Each tuple contains (S_i, T_i, D_i, E_i) representing the start and destination positions of the i-th robot. Returns: int: The minimum total energy required. total_energy = 0 for start_x, start_y, dest_x, dest_y in robots: # Calculate the Manhattan distance between the start and destination points distance = abs(dest_x - start_x) + abs(dest_y - start_y) total_energy += distance return total_energy"},{"question":"def count_paths(input_string: str) -> int: You are developing a game where the player navigates a grid of size n x m. The grid contains barriers and the player's movement is constrained by these obstacles. The player's goal is to move from the top-left corner of the grid (1,1) to the bottom-right corner of the grid (n,m). However, the player can only move right or down in each step. Calculate the number of distinct paths the player can take to reach the goal. Input :param input_string: str - The first line contains two integers n and m (1  n, m  1000)  the dimensions of the grid. The next n lines each contain m characters, describing the grid. Each character is either: '.' indicating an open cell the player can traverse. '#' indicating a barrier cell the player cannot traverse. Output :return: int - The number of distinct paths from the top-left to the bottom-right corner of the grid. Example >>> count_paths('3 3n. . .n. # .n. . .') 2 >>> count_paths('3 3n. . #n. # .n# . .') 0 >>> count_paths('2 2n. .n. .') 2 >>> count_paths('1 1n.') 1 >>> count_paths('1 1n#') 0","solution":"def num_paths(grid): n = len(grid) m = len(grid[0]) # Ensure top-left and bottom-right are not barriers if grid[0][0] == '#' or grid[n-1][m-1] == '#': return 0 # Initialize DP table dp = [[0]*m for _ in range(n)] # Start position dp[0][0] = 1 # Fill DP table for i in range(n): for j in range(m): if grid[i][j] == '.': if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[-1][-1] def parse_input(input_string): lines = input_string.strip().split('n') n, m = map(int, lines[0].split()) grid = [list(line.split()) for line in lines[1:]] return grid # Complete solution function def count_paths(input_string): # Parse the input string grid = parse_input(input_string) # Calculate number of distinct paths using DP return num_paths(grid)"},{"question":"def run_length_encoding(text: str) -> str: Encodes the input text using Run-Length Encoding (RLE). Parameters: - text (str): The input string to encode. Returns: - str: The encoded string using RLE. Examples: >>> run_length_encoding(\\"aaabbcccc\\") 'a3b2c4' >>> run_length_encoding(\\"abcd\\") 'a1b1c1d1'","solution":"def run_length_encoding(text): Encodes the input text using Run-Length Encoding (RLE). Parameters: - text (str): The input string to encode. Returns: - str: The encoded string using RLE. if not text: return \\"\\" encoded_string = [] current_char = text[0] count = 1 for char in text[1:]: if char == current_char: count += 1 else: encoded_string.append(f\\"{current_char}{count}\\") current_char = char count = 1 # Append the last character and its count encoded_string.append(f\\"{current_char}{count}\\") return ''.join(encoded_string)"},{"question":"def is_bipartite_graph(n: int, edges: List[Tuple[int, int]]) -> str: Determine if it is possible to divide the graph's nodes into two disjoint sets such that there are no edges within the same set. >>> is_bipartite_graph(3, [(1, 2), (1, 3), (2, 3)]) == \\"NO\\" >>> is_bipartite_graph(4, [(1, 2), (1, 3), (2, 4), (3, 4)]) == \\"YES\\" >>> is_bipartite_graph(4, [(1, 2), (3, 4)]) == \\"YES\\" >>> is_bipartite_graph(1, []) == \\"YES\\" >>> is_bipartite_graph(6, [(1, 2), (2, 3), (4, 5), (5, 6)]) == \\"YES\\" >>> is_bipartite_graph(5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)]) == \\"NO\\"","solution":"def is_bipartite_graph(n, edges): from collections import deque # Create adjacency list for the graph graph = {i: [] for i in range(1, n + 1)} for u, v in edges: graph[u].append(v) graph[v].append(u) # 0: Uncolored, 1: Color 1, -1: Color 2 color = {i: 0 for i in range(1, n + 1)} def bfs(start): queue = deque([start]) color[start] = 1 while queue: node = queue.popleft() current_color = color[node] for neighbor in graph[node]: if color[neighbor] == 0: color[neighbor] = -current_color queue.append(neighbor) elif color[neighbor] == current_color: return False return True for node in range(1, n + 1): if color[node] == 0: # Unvisited if not bfs(node): return 'NO' return 'YES' if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().strip().split() n = int(data[0]) m = int(data[1]) edges = [(int(data[2 + i * 2]), int(data[2 + i * 2 + 1])) for i in range(m)] print(is_bipartite_graph(n, edges))"},{"question":"def create_new_array(N: int, A: List[int]) -> List[int]: Given an array of integers, this function returns a new array where each element at position i is the sum of all elements in the original array except the one at position i. Parameters: N (int): The number of elements in the array. A (list): List of integers. Returns: list: The new list with the desired sums. >>> create_new_array(3, [1, 2, 3]) [5, 4, 3] from typing import List","solution":"def create_new_array(N, A): Given an array of integers, this function returns a new array where each element at position i is the sum of all elements in the original array except the one at position i. Parameters: N (int): The number of elements in the array. A (list): List of integers. Returns: list: The new list with the desired sums. total_sum = sum(A) # Calculate the sum of all elements once B = [] for i in range(N): B.append(total_sum - A[i]) # Append the sum excluding A[i] return B # Example usage: # N = 3 # A = [1, 2, 3] # print(create_new_array(N, A)) # Output should be [5, 4, 3]"},{"question":"def min_increments_to_max(arr): Returns the minimum number of increments required to make all elements in the array equal to the maximum element. >>> min_increments_to_max([1, 2, 3, 4, 5]) 10 >>> min_increments_to_max([5, 5, 5]) 0 >>> min_increments_to_max([1, 1, 1, 100]) 297","solution":"def min_increments_to_max(arr): Returns the minimum number of increments required to make all elements in the array equal to the maximum element. max_element = max(arr) return sum(max_element - x for x in arr)"},{"question":"def max_trees_cut_to_increasing(arr: List[int]) -> int: Returns the maximum number of trees that can be cut down so that the remaining trees form a strictly increasing sequence. Parameters: arr (list): List of integers representing the heights of the trees. Returns: int: Maximum number of trees that can be cut down.","solution":"def max_trees_cut_to_increasing(arr): Returns the maximum number of trees that can be cut down so that the remaining trees form a strictly increasing sequence. Parameters: arr (list): List of integers representing the heights of the trees. Returns: int: Maximum number of trees that can be cut down. n = len(arr) # To find the length of the longest increasing subsequence # (LIS) using dynamic programming lis = [1] * n for i in range(1, n): for j in range(0, i): if arr[i] > arr[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 # The number of trees to cut to form the longest increasing subsequence max_lis_len = max(lis) return n - max_lis_len"},{"question":"def can_rearrange(N: int, arr: List[int]) -> str: Determines if the array can be rearranged such that the difference between each pair of adjacent elements is at most 1. >>> can_rearrange(4, [1, 2, 3, 4]) == \\"YES\\" >>> can_rearrange(3, [5, 1, 2]) == \\"NO\\"","solution":"def can_rearrange(N, arr): Determines if the array can be rearranged such that the difference between each pair of adjacent elements is at most 1. arr.sort() for i in range(N - 1): if abs(arr[i] - arr[i+1]) > 1: return \\"NO\\" return \\"YES\\""},{"question":"def min_stops(n: int, c: int, m: int, s: int, water_stations: List[int]) -> int: Determine the minimum number of stops a runner needs to make at the water stations to complete the marathon. Args: n (int): The endpoint of the marathon. c (int): The capacity of the water bottle. m (int): The number of water stations. s (int): The number of stages. water_stations (List[int]): The positions of the water stations along the route in ascending order. Returns: int: The minimum number of stops a runner needs to make, or -1 if it is impossible to complete the marathon. Examples: >>> min_stops(10, 3, 3, 2, [2, 5, 8]) 3 >>> min_stops(10, 7, 2, 3, [3, 9]) 1 >>> min_stops(10, 5, 3, 2, [2, 4, 7]) 2","solution":"def min_stops(n, c, m, s, water_stations): # Start initially from 0 distance current_position = 0 stops = 0 i = 0 # Add the final destination as a virtual water station water_stations.append(n) while current_position < n: last_position = current_position # Try to go maximum distance without refilling while i < len(water_stations) and water_stations[i] - current_position <= c: last_position = water_stations[i] i += 1 # If we can't move any further if last_position == current_position: return -1 # Update the current position to the furthest we can reach with current water current_position = last_position # If the runner hasn't reached the end, increment the number of stops if current_position < n: stops += 1 return stops"},{"question":"def minimum_preparation_time(n, m, t, orders): Calculate the minimum total preparation time to fulfill all orders. Parameters: n (int): Number of different types of baked goods. m (int): Number of orders. t (List[int]): Preparation time for each type of baked good. orders (List[Tuple[int, int]]): List of orders, where each order is a tuple (type, quantity). Returns: int: Minimum total preparation time to fulfill all orders. Example: >>> minimum_preparation_time(3, 4, [5, 3, 8], [(1, 2), (2, 5), (3, 1), (2, 3)]) 41 >>> minimum_preparation_time(2, 2, [2, 4], [(1, 3), (2, 2)]) 14 pass","solution":"def minimum_preparation_time(n, m, t, orders): Calculate the minimum total preparation time to fulfill all orders. Parameters: n (int): Number of different types of baked goods. m (int): Number of orders. t (List[int]): Preparation time for each type of baked good. orders (List[Tuple[int, int]]): List of orders, where each order is a tuple (type, quantity). Returns: int: Minimum total preparation time to fulfill all orders. total_time = 0 for order in orders: type_i, quantity_i = order total_time += t[type_i - 1] * quantity_i return total_time"},{"question":"def find_min_integer_to_remove(numbers: List[int]) -> int: Returns the smallest integer to be removed to maximize the sum of the remaining integers. If there are multiple choices, return the smallest integer. >>> find_min_integer_to_remove([1, 2, 3, 4, 5]) == 1 >>> find_min_integer_to_remove([-1, -2, -3, -4]) == -4 >>> find_min_integer_to_remove([1, -2, 3, -4]) == -4 >>> find_min_integer_to_remove([1000000, 999999]) == 999999 >>> find_min_integer_to_remove([4, 4, 4, 4]) == 4 >>> find_min_integer_to_remove([0, -1, -1, -1]) == -1 >>> find_min_integer_to_remove(list(range(1, 100001))) == 1","solution":"def find_min_integer_to_remove(numbers): Returns the smallest integer to be removed to maximize the sum of the remaining integers. If there are multiple choices, return the smallest integer. total_sum = sum(numbers) max_sum = float('-inf') candidate = None for num in sorted(numbers): current_sum = total_sum - num if current_sum > max_sum: max_sum = current_sum candidate = num elif current_sum == max_sum: candidate = min(candidate, num) return candidate"},{"question":"def find_longest_subsequence_length(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Finds the length of the longest subsequence that can be rearranged to form a contiguous sequence. >>> find_longest_subsequence_length(2, [(6, [1, 6, 3, 5, 7, 2]), (4, [10, 12, 11, 15])]) [3, 3] >>> find_longest_subsequence_length(1, [(5, [10, 10, 10, 10, 10])]) [1] >>> find_longest_subsequence_length(1, [(0, [])]) [0] >>> find_longest_subsequence_length(1, [(7, [4, 5, 6, 7, 8, 9, 10])]) [7] >>> find_longest_subsequence_length(1, [(6, [31, 32, 33, 31, 34, 32])]) [4]","solution":"def find_longest_subsequence_length(T, test_cases): Finds the length of the longest subsequence that can be rearranged to form a contiguous sequence. results = [] for i in range(T): N = test_cases[i][0] sequence = test_cases[i][1] if N == 0: results.append(0) continue # Use a set to remove duplicates and then convert to sorted list sequence_set = set(sequence) sorted_sequence = sorted(sequence_set) max_length = 1 current_length = 1 for j in range(1, len(sorted_sequence)): if sorted_sequence[j] == sorted_sequence[j - 1] + 1: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 results.append(max_length) return results"},{"question":"def can_robot_reach_end(n, m, grid): Determines if there exists a path from the top-left to the bottom-right of the grid. >>> can_robot_reach_end(3, 3, [\\".**\\", \\"..*\\", \\"...\\"]) \\"YES\\" >>> can_robot_reach_end(3, 3, [\\".*.\\", \\".*.\\", \\".*.\\"]) \\"NO\\"","solution":"def can_robot_reach_end(n, m, grid): Determines if there exists a path from the top-left to bottom-right of the grid. if grid[0][0] == '*' or grid[n-1][m-1] == '*': return \\"NO\\" # Create a dp table to store the reachability of each cell dp = [[False] * m for _ in range(n)] dp[0][0] = True for i in range(n): for j in range(m): if grid[i][j] == '*': dp[i][j] = False else: if i > 0: dp[i][j] = dp[i][j] or dp[i-1][j] if j > 0: dp[i][j] = dp[i][j] or dp[i][j-1] return \\"YES\\" if dp[-1][-1] else \\"NO\\""},{"question":"def longest_palindrome_length(s: str) -> int: Determines the length of the longest palindrome that can be formed using the characters of the given string. >>> longest_palindrome_length(\\"abccccdd\\") 7 >>> longest_palindrome_length(\\"aA\\") 1 pass from solution import longest_palindrome_length def test_example_1(): assert longest_palindrome_length(\\"abccccdd\\") == 7 def test_example_2(): assert longest_palindrome_length(\\"aA\\") == 1 def test_all_same_characters(): assert longest_palindrome_length(\\"aaaa\\") == 4 def test_mixed_case(): assert longest_palindrome_length(\\"Aa\\") == 1 def test_empty_string(): assert longest_palindrome_length(\\"\\") == 0 def test_palindromic_string(): assert longest_palindrome_length(\\"racecar\\") == 7 def test_no_possible_palindrome(): assert longest_palindrome_length(\\"abcdef\\") == 1 def test_mixed_characters(): assert longest_palindrome_length(\\"aabbccddeeff\\") == 12","solution":"def longest_palindrome_length(s): Determines the length of the longest palindrome that can be formed using the characters of the given string. from collections import Counter count = Counter(s) length = 0 odd_found = False for freq in count.values(): if freq % 2 == 0: length += freq else: length += freq - 1 odd_found = True if odd_found: length += 1 return length"},{"question":"def shortest_sequence_length(n: int) -> int: Returns the length of the shortest valid sequence of chemical identifiers. Args: n (int): The number of chemicals available. Returns: int: The length of the shortest valid sequence of chemical identifiers. Example: >>> shortest_sequence_length(5) 1 >>> shortest_sequence_length(10) 1 pass","solution":"def shortest_sequence_length(n): Returns the length of the shortest valid sequence of chemical identifiers. return 1"},{"question":"def perform_operations(n: int, array: List[int], operations: List[Tuple[int, ...]]) -> List[List[int]]: Perform the specified add, multiply, and query operations on the array. Args: n: int - the size of the initial array. array: list of int - the initial array of integers. operations: list of tuples - the operations to perform on the array. Returns: list of lists: the results of the query operations. Example: >>> perform_operations(5, [1, 2, 3, 4, 5], [(1, 2), (3,), (2, 3), (3,)]) [[3, 4, 5, 6, 7], [9, 12, 15, 18, 21]] >>> perform_operations(3, [1, 1, 1], [(1, 1), (1, 2), (3,)]) [[4, 4, 4]]","solution":"def perform_operations(n, array, operations): Perform the specified add, multiply, and query operations on the array. Args: n: int - the size of the initial array. array: list of int - the initial array of integers. operations: list of tuples - the operations to perform on the array. Returns: list of lists: the results of the query operations. results = [] # List to store the outcomes of 'query' operations for operation in operations: if operation[0] == 1: # add(x) x = operation[1] array = [elem + x for elem in array] elif operation[0] == 2: # multiply(y) y = operation[1] array = [elem * y for elem in array] elif operation[0] == 3: # query results.append(array) return results"},{"question":"def find_longest_consecutive_subsequence(nums: List[int]) -> List[int]: Returns the longest subsequence such that consecutive elements have a difference of 1. :param nums: A list of integers. :return: The longest subsequence with consecutive differences of 1. >>> find_longest_consecutive_subsequence([1, 2, 3, 5, 6, 7, 8]) == [5, 6, 7, 8] >>> find_longest_consecutive_subsequence([10, 11, 12, 14, 15, 16, 17, 18]) == [14, 15, 16, 17, 18] >>> find_longest_consecutive_subsequence([]) == [] >>> find_longest_consecutive_subsequence([5]) == [5] >>> find_longest_consecutive_subsequence([1, 3, 5, 7]) == [1] pass","solution":"def find_longest_consecutive_subsequence(nums): Returns the longest subsequence such that consecutive elements have a difference of 1. :param nums: A list of integers. :return: The longest subsequence with consecutive differences of 1. if not nums: return [] nums_set = set(nums) longest_seq = [] for num in nums: if num - 1 not in nums_set: # start of a new sequence current_seq = [] current_num = num while current_num in nums_set: current_seq.append(current_num) current_num += 1 if len(current_seq) > len(longest_seq): longest_seq = current_seq return longest_seq"},{"question":"def can_form_scalene_triangle(a: int, b: int, c: int) -> str: Returns 'YES' if the lengths a, b, and c can form a scalene triangle, 'NO' otherwise. >>> can_form_scalene_triangle(7, 10, 5) 'YES' >>> can_form_scalene_triangle(3, 3, 3) 'NO' >>> can_form_scalene_triangle(8, 15, 17) 'YES' def process_test_cases(T: int, test_cases: List[Tuple[int, int, int]]) -> List[str]: Processes multiple test cases and returns a list of results for each test case.","solution":"def can_form_scalene_triangle(a, b, c): Returns 'YES' if the lengths a, b, and c can form a scalene triangle, 'NO' otherwise. if a != b and b != c and a != c and a + b > c and a + c > b and b + c > a: return 'YES' return 'NO' def process_test_cases(T, test_cases): Processes multiple test cases and returns a list of results for each test case. results = [] for i in range(T): a, b, c = test_cases[i] results.append(can_form_scalene_triangle(a, b, c)) return results # Example usage: # T = 3 # test_cases = [(7, 10, 5), (3, 3, 3), (8, 15, 17)] # results = process_test_cases(T, test_cases) # for result in results: # print(result)"},{"question":"def most_frequent_substring(s: str) -> str: Find the binary string \`t\` that appears the most times either as a Type 1 or Type 2 subsequence of \`s\`. If there are multiple such strings, return the lexicographically smallest one if there is a tie. >>> most_frequent_substring(\\"00110\\") \\"0\\" >>> most_frequent_substring(\\"111\\") \\"1\\" >>> most_frequent_substring(\\"1011001\\") \\"1\\" >>> most_frequent_substring(\\"0\\") \\"0\\" >>> most_frequent_substring(\\"1\\") \\"1\\" >>> most_frequent_substring(\\"0101\\") \\"0\\" >>> most_frequent_substring(\\"1001101001101\\") \\"1\\" >>> most_frequent_substring(\\"010101010101\\") \\"0\\"","solution":"def most_frequent_substring(s): from collections import defaultdict n = len(s) count = defaultdict(int) # Type 1: Count all substrings (continuous segments) for i in range(n): for j in range(i + 1, n + 1): count[s[i:j]] += 1 # Type 2: Count all 0-separated subsequences substrings = set(count.keys()) # Collect all substrings to use as possible subsequences for subseq in substrings: idx = -1 while True: idx = s.find(subseq[0], idx + 1) if idx == -1: break matched = True pos = idx + 1 for char in subseq[1:]: pos = s.find('0', pos) if pos == -1: matched = False break pos = s.find(char, pos + 1) if pos == -1: matched = False break if matched: count[subseq] += 1 # Finding the most frequent binary string most_frequent_str = max(count, key=lambda x: (count[x], -len(x), -ord(x[0]))) return most_frequent_str"},{"question":"def pac_man_maze_path(n: int, m: int, maze: List[str]) -> str: Determines whether there is a path from top-left to bottom-right in the maze. Uses Depth-First Search (DFS) to explore the maze. :param n: Number of rows in the maze :param m: Number of columns in the maze :param maze: List of strings representing the maze layout :return: \\"YES\\" if there is a path, otherwise \\"NO\\"","solution":"def pac_man_maze_path(n, m, maze): Determines whether there is a path from top-left to bottom-right in the maze. Uses Depth-First Search (DFS) to explore the maze. :param n: Number of rows in the maze :param m: Number of columns in the maze :param maze: List of strings representing the maze layout :return: \\"YES\\" if there is a path, otherwise \\"NO\\" def is_valid(x, y): return 0 <= x < n and 0 <= y < m and maze[x][y] == '.' and not visited[x][y] def dfs(x, y): if x == n - 1 and y == m - 1: return True visited[x][y] = True for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if is_valid(nx, ny) and dfs(nx, ny): return True return False visited = [[False] * m for _ in range(n)] return \\"YES\\" if dfs(0, 0) else \\"NO\\""},{"question":"def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: Given a square matrix, returns its transpose. >>> transpose_matrix([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) [[1, 4, 7], [2, 5, 8], [3, 6, 9]] >>> transpose_matrix([ [5] ]) [[5]] >>> transpose_matrix([ [1, 2], [3, 4] ]) [[1, 3], [2, 4]] >>> transpose_matrix([ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ]) [[1, 5, 9, 13], [2, 6, 10, 14], [3, 7, 11, 15], [4, 8, 12, 16]]","solution":"def transpose_matrix(matrix): Given a square matrix, returns its transpose. n = len(matrix) transpose = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): transpose[j][i] = matrix[i][j] return transpose def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) matrix = [] index = 1 for i in range(n): row = list(map(int, data[index:index + n])) index += n matrix.append(row) transpose = transpose_matrix(matrix) for row in transpose: print(\\" \\".join(map(str, row))) if __name__ == \\"__main__\\": main()"},{"question":"def count_primes_in_range(l: int, r: int) -> int: Returns the number of prime numbers between l and r (inclusive). >>> count_primes_in_range(10, 20) 4 >>> count_primes_in_range(1, 10) 4 >>> count_primes_in_range(10, 10) 0 >>> count_primes_in_range(14, 15) 0 >>> count_primes_in_range(1, 2) 1 >>> count_primes_in_range(1, 100) 25","solution":"def count_primes_in_range(l, r): Returns the number of prime numbers between l and r (inclusive). if l > r: return 0 # Sieve of Eratosthenes to find all primes less than equal to r is_prime = [True] * (r + 1) is_prime[0], is_prime[1] = False, False p = 2 while p * p <= r: if is_prime[p]: for i in range(p * p, r + 1, p): is_prime[i] = False p += 1 # Count primes in given range [l, r] count = 0 for i in range(l, r + 1): if is_prime[i]: count += 1 return count"},{"question":"def max_soldiers_killed(n: int) -> int: Calculates the maximum number of soldiers that can be killed during the game. Args: n (int): Number of soldiers in each army (4  n  1000, n is even) Returns: int: Maximum total number of soldiers that can be killed Examples: >>> max_soldiers_killed(4) 3 >>> max_soldiers_killed(6) 5 >>> max_soldiers_killed(10) 9 >>> max_soldiers_killed(1000) 999","solution":"def max_soldiers_killed(n): Calculates the maximum number of soldiers that can be killed in the game. Args: n: int - Number of soldiers in each army (4  n  1000, n is even) Returns: int - Maximum total number of soldiers that can be killed # Given the problem description, the pattern emerges that the maximum number # of soldiers killed is n - 1. return n - 1"},{"question":"def maximize_items(n: int, T: int, values: List[int]) -> Tuple[int, int]: Determines the best possible stack of items such that the number of items is maximized, followed by the greatest total value of items, and the greatest single value if needed. >>> maximize_items(5, 10, [1, 2, 3, 4, 5]) (4, 10) >>> maximize_items(6, 15, [5, 5, 5, 10, 2, 1]) (4, 13) >>> maximize_items(2, 5, [8, 3]) (1, 3)","solution":"def maximize_items(n, T, values): values.sort(reverse=True) # Sort values in descending order best_count = 0 best_sum = 0 best_values = [] def get_stack(items): current_sum = 0 stack = [] for item in items: if current_sum + item <= T: current_sum += item stack.append(item) return stack for i in range(n): stack = get_stack(values[i:]) stack_sum = sum(stack) if len(stack) > best_count or (len(stack) == best_count and stack_sum > best_sum): best_count = len(stack) best_sum = stack_sum best_values = stack return best_count, best_sum"},{"question":"def min_operations_to_transform(n: int, A: str, B: str) -> int: Calculate the minimum number of operations required to transform an empty string into string B. Args: n (int): The length of strings A and B A (str): The first string B (str): The second string Returns: int: The minimum number of operations to transform the empty string into string B. Examples: >>> min_operations_to_transform(4, \\"abcd\\", \\"abdc\\") 8 >>> min_operations_to_transform(5, \\"hello\\", \\"ohell\\") 10 >>> min_operations_to_transform(6, \\"abcdef\\", \\"fedcba\\") 12","solution":"def min_operations_to_transform(n, A, B): Calculate the minimum number of operations required to transform an empty string into string B. Args: n (int): The length of strings A and B A (str): The first string B (str): The second string Returns: int: The minimum number of operations to transform the empty string into string B. # We need to append each character of B which takes n operations # And then delete the character from the end of string which again takes n operations return 2 * n"},{"question":"def max_consecutive_ones(n: int, s: str) -> int: This function returns the maximum number of consecutive '1's that can be obtained after toggling one substring of the given binary string s exactly once. >>> max_consecutive_ones(6, \\"110110\\") == 5 >>> max_consecutive_ones(5, \\"00000\\") == 5 >>> max_consecutive_ones(7, \\"1010101\\") == 3 >>> max_consecutive_ones(7, \\"1111111\\") == 7 >>> max_consecutive_ones(5, \\"01010\\") == 3 >>> max_consecutive_ones(1, \\"0\\") == 1 >>> max_consecutive_ones(1, \\"1\\") == 1","solution":"def max_consecutive_ones(n, s): This function returns the maximum number of consecutive '1's that can be obtained after toggling one substring of the given binary string s exactly once. if '0' not in s: # If the string already consists only of '1's return n max_ones = 0 s = list(s) for i in range(n): for j in range(i, n): # Create a copy of the list to toggle a substring new_s = s[:] # Toggle the substring s[i:j+1] for k in range(i, j + 1): new_s[k] = '1' if new_s[k] == '0' else '0' # Calculate the maximum number of consecutive '1's in the new string current_max_ones = max(len(x) for x in ''.join(new_s).split('0')) max_ones = max(max_ones, current_max_ones) return max_ones"},{"question":"def length_of_LIS(nums: List[int]) -> int: Returns the length of the longest increasing subsequence. >>> length_of_LIS([10, 22, 9, 33, 21, 50]) 4 >>> length_of_LIS([3, 10, 2, 1, 20]) 3 >>> length_of_LIS([3, 2]) 1 >>> length_of_LIS([50, 3, 10, 7, 40, 80]) 4 >>> length_of_LIS([]) 0 >>> length_of_LIS([10]) 1 >>> length_of_LIS([2, 2, 2, 2, 2]) 1","solution":"def length_of_LIS(nums): Returns the length of the longest increasing subsequence. if not nums: return 0 dp = [1] * len(nums) for i in range(len(nums)): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def min_security_cameras(n: int, m: int, connections: List[Tuple[int, int]]) -> int: Determine the minimum number of security cameras required to cover all rooms and corridors. Parameters: n (int): Number of rooms m (int): Number of corridors connections (list of tuples): List of tuples where each tuple represents a corridor between two rooms. Returns: int: Minimum number of security cameras required >>> min_security_cameras(3, 3, [(1, 2), (2, 3), (3, 1)]) 3 >>> min_security_cameras(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) 5 from typing import List, Tuple def test_min_security_cameras_simple_cases(): assert min_security_cameras(3, 3, [(1, 2), (2, 3), (3, 1)]) == 3 assert min_security_cameras(2, 1, [(1, 2)]) == 2 def test_min_security_cameras_medium_cases(): assert min_security_cameras(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) == 5 assert min_security_cameras(6, 6, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1)]) == 6 def test_min_security_cameras_no_corridors(): assert min_security_cameras(4, 0, []) == 4 def test_min_security_cameras_no_rooms(): assert min_security_cameras(1, 0, []) == 1 def test_min_security_cameras_equal_rooms_corridors(): assert min_security_cameras(5, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)]) == 5","solution":"def min_security_cameras(n, m, connections): Determine the minimum number of security cameras required to cover all rooms and corridors. Parameters: n (int): Number of rooms m (int): Number of corridors connections (list of tuples): List of tuples where each tuple represents a corridor between two rooms. Returns: int: Minimum number of security cameras required return max(n, m)"},{"question":"class Inventory: def __init__(self): Initializes an empty inventory. pass def add_item(self, item: str, quantity: int) -> None: Adds a specific quantity of a product to the inventory. >>> inventory = Inventory() >>> inventory.add_item('apple', 10) >>> inventory.add_item('banana', 5) >>> inventory.check_stock('apple') == 10 True >>> inventory.check_stock('banana') == 5 True pass def remove_item(self, item: str, quantity: int) -> bool: Removes a specific quantity of a product from the inventory. Returns True if the removal is successful, and False if there is an insufficient quantity. >>> inventory = Inventory() >>> inventory.add_item('apple', 10) >>> inventory.remove_item('apple', 5) == True True >>> inventory.check_stock('apple') == 5 True pass def check_stock(self, item: str) -> int: Checks the current quantity of a particular product in the inventory. Returns the quantity if the product exists, or 0 if the product is not found. >>> inventory = Inventory() >>> inventory.check_stock('mango') == 0 True pass def get_all_items(self) -> list: Returns a list of tuples containing all items and their quantities in the inventory. Each tuple contains (item_name, quantity). >>> inventory = Inventory() >>> inventory.add_item('apple', 10) >>> inventory.add_item('banana', 5) >>> inventory.get_all_items() == [('apple', 10), ('banana', 5)] True pass","solution":"class Inventory: def __init__(self): Initializes an empty inventory. self.items = {} def add_item(self, item: str, quantity: int) -> None: Adds a specific quantity of a product to the inventory. if item in self.items: self.items[item] += quantity else: self.items[item] = quantity def remove_item(self, item: str, quantity: int) -> bool: Removes a specific quantity of a product from the inventory. Returns True if the removal is successful, and False if there is an insufficient quantity. if item in self.items and self.items[item] >= quantity: self.items[item] -= quantity if self.items[item] == 0: del self.items[item] return True return False def check_stock(self, item: str) -> int: Checks the current quantity of a particular product in the inventory. Returns the quantity if the product exists, or 0 if the product is not found. return self.items.get(item, 0) def get_all_items(self) -> list: Returns a list of tuples containing all items and their quantities in the inventory. Each tuple contains (item_name, quantity). return sorted(self.items.items())"},{"question":"def min_operations_to_uniform_water(t, test_cases): Determine the minimum number of operations needed to water the garden uniformly. Args: t: int - the number of test cases. test_cases: list - a list of dictionaries, each containing: - 'm': the number of rows in the garden grid. - 'n': the number of columns in the garden grid. - 'grid': a list of lists representing the water requirements. Returns: list - a list of integers, each integer representing the minimum number of operations needed for each test case. pass def from_input_string(input_string): lines = input_string.strip().split('n') t = int(lines[0]) test_cases = [] line_index = 1 for _ in range(t): m, n = map(int, lines[line_index].split()) line_index += 1 grid = [] for _ in range(m): row = list(map(int, lines[line_index].split())) line_index += 1 grid.append(row) test_cases.append({'m': m, 'n': n, 'grid': grid}) return t, test_cases def to_output_string(output): return 'n'.join(map(str, output)) def from_output_string(output_string): return list(map(int, output_string.strip().split('n'))) # Unit tests def test_case_1(): input_string = \\"3n2 3n2 2 3n2 2 2n3 3n1 1 1n1 2 2n1 1 1n2 2n5 5n5 5n\\" expected_output_string = \\"2n2n1n\\" t, test_cases = from_input_string(input_string) actual_output = min_operations_to_uniform_water(t, test_cases) expected_output = from_output_string(expected_output_string) assert actual_output == expected_output def test_case_2(): input_string = \\"1n3 4n1 1 1 1n2 2 2 2n1 1 1 1n\\" expected_output_string = \\"2n\\" t, test_cases = from_input_string(input_string) actual_output = min_operations_to_uniform_water(t, test_cases) expected_output = from_output_string(expected_output_string) assert actual_output == expected_output def test_case_3(): input_string = \\"2n1 1n1n4 4n1 1 1 1n1 1 1 2n1 2 1 1n1 1 1 1n\\" expected_output_string = \\"1n2n\\" t, test_cases = from_input_string(input_string) actual_output = min_operations_to_uniform_water(t, test_cases) expected_output = from_output_string(expected_output_string) assert actual_output == expected_output","solution":"def min_operations_to_uniform_water(t, test_cases): results = [] for case in test_cases: m, n, grid = case['m'], case['n'], case['grid'] unique_values = set() for row in grid: unique_values.update(row) results.append(len(unique_values)) return results # Read inputs def from_input_string(input_string): lines = input_string.strip().split('n') t = int(lines[0]) test_cases = [] line_index = 1 for _ in range(t): m, n = map(int, lines[line_index].split()) line_index += 1 grid = [] for _ in range(m): row = list(map(int, lines[line_index].split())) line_index += 1 grid.append(row) test_cases.append({'m': m, 'n': n, 'grid': grid}) return t, test_cases def to_output_string(output): return 'n'.join(map(str, output)) def from_output_string(output_string): return list(map(int, output_string.strip().split('n')))"},{"question":"from typing import List def access_levels(ids: List[str]) -> List[int]: Returns a list of access levels corresponding to the given security IDs. Args: ids: List of strings where each string represents a security ID. Returns: List of integers representing the access levels. >>> access_levels([\\"user123\\", \\"admin\\", \\"12345\\", \\"user\\", \\"\\"]) == [3, 2, 1, 3, 0] >>> access_levels([\\"emp01\\", \\"manager\\", \\"42\\", \\"director@\\"]) == [3, 2, 1, 3] pass def test_access_levels(): assert access_levels([\\"user123\\", \\"admin\\", \\"12345\\", \\"user\\", \\"\\"]) == [3, 2, 1, 3, 0] assert access_levels([\\"emp01\\", \\"manager\\", \\"42\\", \\"director@\\"]) == [3, 2, 1, 3] assert access_levels([\\"abcd\\", \\"1234\\", \\"\\", \\"abc1\\"]) == [2, 1, 0, 3] assert access_levels([\\"\\", \\"654321\\", \\"@!^\\", \\"aB1*\\"]) == [0, 1, 3, 3] assert access_levels([\\"abcde\\", \\"12\\", \\"\\"]) == [2, 1, 0] assert access_levels([\\"xyz987\\", \\"test\\", \\"789\\"]) == [3, 2, 1] assert access_levels([\\"45abcd\\", \\"123\\", \\"+-12abc\\"]) == [3, 1, 3]","solution":"def access_levels(ids): Returns a list of access levels corresponding to the given security IDs. Args: ids: List of strings where each string represents a security ID. Returns: List of integers representing the access levels. result = [] for id in ids: if not id: result.append(0) elif any(char.isdigit() for char in id) and any(char.isalpha() for char in id): result.append(3) elif all(char.isalpha() for char in id): result.append(2) elif all(char.isdigit() for char in id): result.append(1) else: result.append(3) # Any other case with special characters included with letters/numbers return result"},{"question":"def min_operations(source: str, target: str) -> int: Compute the minimum number of operations required to transform source into target using insertion, deletion, or substitution. >>> min_operations(\\"kitten\\", \\"sitting\\") 3 >>> min_operations(\\"flaw\\", \\"lawn\\") 2","solution":"def min_operations(source, target): Compute the minimum number of operations required to transform source into target using insertion, deletion, or substitution. m, n = len(source), len(target) # Create a DP table to store the results of subproblems dp = [[0] * (n + 1) for _ in range(m + 1)] # Base case: If one string is empty, then insert all characters of the other string for i in range(m + 1): dp[i][0] = i for j in range(n + 1): dp[0][j] = j # Fill dp table for i in range(1, m + 1): for j in range(1, n + 1): if source[i - 1] == target[j - 1]: dp[i][j] = dp[i - 1][j - 1] # Characters match, no extra operation needed else: dp[i][j] = 1 + min(dp[i - 1][j], # Remove dp[i][j - 1], # Insert dp[i - 1][j - 1])# Replace return dp[m][n]"},{"question":"def solve_islands_problem(R: int, C: int, K: int, grid_input: List[str]) -> int: Determine the maximum number of distinct islands that can be formed by converting K water cells to land cells. Args: R (int): Number of rows. C (int): Number of columns. K (int): Number of water cells to convert. grid_input (List[str]): List of strings representing the grid rows. Returns: int: Maximum number of distinct islands. Examples: >>> solve_islands_problem(4, 4, 2, [\\"1 0 0 1\\", \\"0 1 0 0\\", \\"0 0 1 0\\", \\"1 0 0 1\\"]) 6 >>> solve_islands_problem(3, 3, 1, [\\"1 0 1\\", \\"0 1 0\\", \\"1 0 1\\"]) 5 >>> solve_islands_problem(1, 1, 0, [\\"1\\"]) 1 >>> solve_islands_problem(2, 2, 1, [\\"0 0\\", \\"0 0\\"]) 1 >>> solve_islands_problem(2, 2, 2, [\\"0 0\\", \\"0 0\\"]) 2","solution":"def max_distinct_islands(grid, R, C, K): def dfs(r, c, visited, label): stack = [(r, c)] visited[r][c] = label while stack: x, y = stack.pop() for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < R and 0 <= ny < C and grid[nx][ny] == 1 and visited[nx][ny] == 0: visited[nx][ny] = label stack.append((nx, ny)) def count_islands(): visited = [[0] * C for _ in range(R)] label = 0 for r in range(R): for c in range(C): if grid[r][c] == 1 and visited[r][c] == 0: label += 1 dfs(r, c, visited, label) return label original_islands = count_islands() max_islands = original_islands water_cells = [(r, c) for r in range(R) for c in range(C) if grid[r][c] == 0] if K == 0: return original_islands def backtrack(start, k): nonlocal max_islands if k == 0: max_islands = max(max_islands, count_islands()) return for i in range(start, len(water_cells)): r, c = water_cells[i] grid[r][c] = 1 backtrack(i + 1, k - 1) grid[r][c] = 0 backtrack(0, K) return max_islands def solve_islands_problem(R, C, K, grid_input): grid = [list(map(int, row.split())) for row in grid_input] return max_distinct_islands(grid, R, C, K)"},{"question":"from typing import List def find_two_sum(nums: List[int], target: int) -> List[int]: Given an array of integers and a target integer, determine the indices of the two numbers in the array that add up to the target integer. Args: nums (List[int]): A list of integers. target (int): The target integer. Returns: List[int]: A list of two integers, representing the indices of the two numbers in \`nums\` that add up to \`target\`. Example: >>> find_two_sum([2, 7, 11, 15], 9) [0, 1] >>> find_two_sum([3, 2, 4], 6) [1, 2] def test_find_two_sum_example1(): assert find_two_sum([2, 7, 11, 15], 9) == [0, 1] def test_find_two_sum_example2(): assert find_two_sum([3, 2, 4], 6) == [1, 2] def test_find_two_sum_with_negative_numbers(): assert find_two_sum([-1, -2, -3, -4, -5], -8) == [2, 4] def test_find_two_sum_with_mixed_sign_numbers(): assert find_two_sum([1, 2, 3, -4, 5], 1) == [3, 4] def test_find_two_sum_zeros_and_positive(): assert find_two_sum([0, 4, 3, 0], 0) == [0, 3] def test_find_two_sum_duplicates(): assert find_two_sum([1, 1, 1, 1], 2) == [0, 1]","solution":"from typing import List def find_two_sum(nums: List[int], target: int) -> List[int]: Return indices of the two numbers that add up to the target. num_to_index = {} for index, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], index] num_to_index[num] = index"},{"question":"def matrix_sum_divisible(R: int, C: int, D: int, matrix: List[List[int]]) -> str: Check if there exists a row or column such that the sum of its elements is divisible by a given integer D. >>> matrix_sum_divisible(3, 3, 4, [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) == \\"YES\\" >>> matrix_sum_divisible(2, 3, 10, [ [1, 2, 3], [4, 5, 6] ]) == \\"NO\\" >>> matrix_sum_divisible(2, 2, 5, [ [2, 3], [3, 2] ]) == \\"YES\\"","solution":"def check_sum_divisible(matrix, R, C, D): for row in matrix: if sum(row) % D == 0: return \\"YES\\" for col in range(C): col_sum = sum(matrix[row][col] for row in range(R)) if col_sum % D == 0: return \\"YES\\" return \\"NO\\" def matrix_sum_divisible(R, C, D, matrix): return check_sum_divisible(matrix, R, C, D)"},{"question":"def student_scores_analysis(scores_str): Given a comma-separated string of student scores, this function returns the highest score, the lowest score, and the mean score rounded to two decimal places as a tuple. >>> student_scores_analysis(\\"85,70,90,55,60,78,94,82,67,80\\") (94, 55, 76.10) >>> student_scores_analysis(\\"50,50,50,50,50\\") (50, 50, 50.00) >>> student_scores_analysis(\\"0,100,50,100,0\\") (100, 0, 50.00) >>> scores_str = ','.join(map(str, range(50))) >>> student_scores_analysis(scores_str) (49, 0, 24.50)","solution":"def student_scores_analysis(scores_str): Given a comma-separated string of student scores, this function returns the highest score, the lowest score, and the mean score rounded to two decimal places as a tuple. Parameters: scores_str (str): Comma-separated scores string Returns: highest (int): The highest score lowest (int): The lowest score mean (float): The mean score rounded to two decimal places scores = list(map(int, scores_str.split(','))) highest = max(scores) lowest = min(scores) mean = round(sum(scores) / len(scores), 2) return highest, lowest, mean"},{"question":"from typing import List, Tuple def schedule_tasks(tasks: List[Tuple[int, int, str]]) -> List[str]: Schedule tasks based on their priority and arrival time. Args: tasks (List[Tuple[int, int, str]]): A list of tuples representing tasks. Returns: List[str]: A list of task names in the order they should be executed. Examples: >>> schedule_tasks([(0, 1, \\"A\\"), (1, 2, \\"B\\"), (2, 1, \\"C\\"), (3, 0, \\"D\\")]) [\\"D\\", \\"A\\", \\"C\\", \\"B\\"] >>> schedule_tasks([(0, 2, \\"task1\\"), (2, 1, \\"task2\\"), (1, 1, \\"task3\\"), (3, 3, \\"task4\\")]) [\\"task3\\", \\"task2\\", \\"task1\\", \\"task4\\"] >>> schedule_tasks([(0, 0, \\"x\\"), (0, 1, \\"y\\")]) [\\"x\\", \\"y\\"] pass","solution":"from typing import List, Tuple def schedule_tasks(tasks: List[Tuple[int, int, str]]) -> List[str]: # Sort the tasks first by priority, then by arrival time tasks.sort(key=lambda x: (x[1], x[0])) # Extract and return the task names in sorted order return [task[2] for task in tasks]"},{"question":"def min_total_idle_time(n: int, production_times: List[int]) -> int: Determine the minimized total idle time for a robotic arm when processing widgets in the optimal order. The robotic arm processes widgets in a sequential manner, moving from one to the next without any time cost, and the goal is to minimize the total idle time, which can always be zero given the conditions. >>> min_total_idle_time(4, [3, 6, 2, 8]) == 0 >>> min_total_idle_time(5, [2, 3, 5, 1, 2]) == 0 >>> min_total_idle_time(3, [10, 1, 3]) == 0 >>> min_total_idle_time(1, [5]) == 0 >>> min_total_idle_time(6, [4, 8, 1, 2, 2, 6]) == 0 >>> min_total_idle_time(6, [5, 12, 3, 9, 1, 4]) == 0 >>> min_total_idle_time(3, [1, 2, 3]) == 0 >>> min_total_idle_time(4, [1, 2, 3, 4]) == 0 >>> min_total_idle_time(3, [3, 2, 1]) == 0 >>> min_total_idle_time(4, [4, 3, 2, 1]) == 0","solution":"def min_total_idle_time(n, production_times): Given the number of widgets and their respective production times, returns the minimized total idle time of the robotic arm. # Sorting the production times helps in minimizing the idle time production_times.sort() return 0 # As the optimal order has 0 idle time"},{"question":"def is_palindromic_sequence(n, queries): For each sequence in queries, determine if it can be converted to a palindrome consisting only of \\"A\\" by replacing wildcards (\\"?\\") with \\"A\\". :param int n: Number of queries :param list queries: List of sequences to be checked :return: List of boolean values, each indicating if the sequence can be converted to a valid palindrome :rtype: list of bool pass # Test cases: def test_all_a(): assert is_palindromic_sequence(1, [\\"AAAA\\"]) == [True] def test_single_char(): assert is_palindromic_sequence(1, [\\"A\\"]) == [True] assert is_palindromic_sequence(1, [\\"?\\"]) == [True] def test_mixed_chars_with_wildcards(): assert is_palindromic_sequence(3, [\\"A?A\\", \\"AA?B\\", \\"?A?\\"]) == [True, False, True] def test_non_palindromic_no_wildcards(): assert is_palindromic_sequence(1, [\\"ABAB\\"]) == [False] def test_all_wildcards(): assert is_palindromic_sequence(1, [\\"??\\"]) == [True] assert is_palindromic_sequence(1, [\\"????\\"]) == [True] def test_wildcard_non_palin(): assert is_palindromic_sequence(1, [\\"A?B\\"]) == [False] def test_large_input(): seq = '?' * 100000 # a large sequence of 100000 wildcards, should return True assert is_palindromic_sequence(1, [seq]) == [True]","solution":"def is_palindromic_sequence(n, queries): For each sequence in queries, determine if it can be converted to a palindrome consisting only of \\"A\\" by replacing wildcards (\\"?\\") with \\"A\\". :param int n: Number of queries :param list queries: List of sequences to be checked :return: List of boolean values, each indicating if the sequence can be converted to a valid palindrome :rtype: list of bool results = [] for seq in queries: can_be_palindrome = True length = len(seq) # Compare from the two ends of the string moving toward the center for i in range(length // 2): left_char = seq[i] right_char = seq[length - 1 - i] if left_char == 'A' and right_char == 'A': continue elif left_char == '?' or right_char == '?': continue else: can_be_palindrome = False break results.append(can_be_palindrome) return results"},{"question":"def banking_system(transactions): Simulates a simple banking system with savings and checking accounts. Processes a list of transactions and modifies account balances accordingly. Transactions format: - Deposit (\\"D\\", \\"account_type\\", amount) - Withdraw (\\"W\\", \\"account_type\\", amount) >>> transactions = [(\\"D\\", \\"savings\\", 500), (\\"D\\", \\"checking\\", 200), (\\"W\\", \\"savings\\", 100), (\\"W\\", \\"checking\\", 300), (\\"W\\", \\"checking\\", 200)] >>> banking_system(transactions) Savings balance: 400 Checking balance: 0 >>> transactions = [(\\"D\\", \\"checking\\", 150), (\\"W\\", \\"checking\\", 150), (\\"W\\", \\"savings\\", 50)] >>> banking_system(transactions) Both accounts empty >>> transactions = [] >>> banking_system(transactions) Both accounts empty >>> transactions = [(\\"D\\", \\"savings\\", 1000), (\\"D\\", \\"checking\\", 2000)] >>> banking_system(transactions) Savings balance: 1000 Checking balance: 2000 >>> transactions = [(\\"D\\", \\"savings\\", 1000), (\\"W\\", \\"savings\\", 2000)] >>> banking_system(transactions) Savings balance: 1000 Checking balance: 0","solution":"def banking_system(transactions): savings_balance = 0 checking_balance = 0 for transaction in transactions: operation, account_type, amount = transaction if operation == \\"D\\": if account_type == \\"savings\\": savings_balance += amount elif account_type == \\"checking\\": checking_balance += amount elif operation == \\"W\\": if account_type == \\"savings\\": if savings_balance >= amount: savings_balance -= amount elif account_type == \\"checking\\": if checking_balance >= amount: checking_balance -= amount if savings_balance <= 0 and checking_balance <= 0: print(\\"Both accounts empty\\") else: print(f\\"Savings balance: {savings_balance}\\") print(f\\"Checking balance: {checking_balance}\\") # Example usage: transactions = [ (\\"D\\", \\"savings\\", 500), (\\"D\\", \\"checking\\", 200), (\\"W\\", \\"savings\\", 100), (\\"W\\", \\"checking\\", 300), (\\"W\\", \\"checking\\", 200) ] banking_system(transactions)"},{"question":"def has_pair_with_sum(arr: List[int], target: int) -> bool: Returns True if there are two distinct indices i and j in the array such that the sum of the elements at these indices is equal to the target. Otherwise, returns False. >>> has_pair_with_sum([1, 2, 3, 4, 5, 6], 9) True >>> has_pair_with_sum([1, 2, 3, 4, 5], 10) False >>> has_pair_with_sum([-1, -2, -3, -4, -5], -8) True >>> has_pair_with_sum([1000000, 999999, 500000, 500001], 1500001) True >>> has_pair_with_sum([1, 2], 3) True","solution":"def has_pair_with_sum(arr, target): Returns True if there are two distinct indices i and j in the array such that the sum of the elements at these indices is equal to the target. Otherwise, returns False. seen = set() for num in arr: if target - num in seen: return True seen.add(num) return False"},{"question":"def smallest_subarray_length(n: int, arr: List[int]) -> int: Given an array \`arr\` with \`n\` integers, determine the smallest subarray size that contains at least one of the maximum and one of the minimum elements of the array. >>> smallest_subarray_length(5, [1, 5, 2, 5, 1]) 2 >>> smallest_subarray_length(6, [7, 1, 7, 1, 7, 1]) 2 >>> smallest_subarray_length(4, [4, 4, 4, 4]) 1 >>> smallest_subarray_length(1000000, [10] * 1000000) 1 >>> smallest_subarray_length(10, [1, 9, 1, 9, 1, 9, 1, 9, 1, 9]) 2 >>> smallest_subarray_length(2, [1, 1]) 1 >>> smallest_subarray_length(2, [1, 1000000000]) 2 >>> smallest_subarray_length(2, [1000000000, 1]) 2 >>> smallest_subarray_length(1, [1]) 1 >>> smallest_subarray_length(1, [999999999]) 1","solution":"def smallest_subarray_length(n, arr): minimum = min(arr) maximum = max(arr) if minimum == maximum: return 1 min_indices = [] max_indices = [] for i in range(n): if arr[i] == minimum: min_indices.append(i) if arr[i] == maximum: max_indices.append(i) min_indices.reverse() max_indices.reverse() min_len = float('inf') for mi in min_indices: for mj in max_indices: if abs(mi - mj) + 1 < min_len: min_len = abs(mi - mj) + 1 return min_len"},{"question":"def longest_subsequence_with_difference(N: int, arr: List[int], D: int) -> int: Given a list of integers and a difference D, finds the length of the longest subsequence where the difference between consecutive elements is exactly D. If no such subsequence exists, returns 0. Parameters: N (int): The number of integers in the list. arr (list of int): The list of integers. D (int): The required difference between consecutive elements. Returns: int: The length of the longest subsequence with the required difference. pass def test_longest_subsequence_with_difference(): assert longest_subsequence_with_difference(7, [1, 5, 9, 1, 5, 9, 13], 4) == 4 assert longest_subsequence_with_difference(5, [2, 2, 2, 2, 2], 0) == 5 assert longest_subsequence_with_difference(4, [1, 3, 5, 7], 2) == 4 assert longest_subsequence_with_difference(4, [1, 3, 5, 7], 1) == 1 assert longest_subsequence_with_difference(1, [1], 0) == 1 assert longest_subsequence_with_difference(6, [1, 2, 3, 4, 5, 6], 1) == 6 assert longest_subsequence_with_difference(0, [], 1) == 0 assert longest_subsequence_with_difference(5, [10, 5, 0, -5, -10], -5) == 5 assert longest_subsequence_with_difference(6, [1, 2, 3, 4, 5, 6], 10) == 1","solution":"def longest_subsequence_with_difference(N, arr, D): Given a list of integers and a difference D, finds the length of the longest subsequence where the difference between consecutive elements is exactly D. If no such subsequence exists, returns 0. Parameters: N (int): The number of integers in the list. arr (list of int): The list of integers. D (int): The required difference between consecutive elements. Returns: int: The length of the longest subsequence with the required difference. if N == 0: return 0 # Dictionary to keep track of longest subsequences ending with each number dp = {} max_length = 0 for num in arr: if num - D in dp: dp[num] = dp[num - D] + 1 else: dp[num] = 1 max_length = max(max_length, dp[num]) return max_length"},{"question":"def correct_sequence(N: int, A: List[int]) -> List[int]: Ensure the number sequence is strictly increasing by one every minute starting from the first number recorded. >>> correct_sequence(6, [5, 6, 5, 7, 8, 9]) [5, 6, 7, 8, 9, 10] >>> correct_sequence(3, [1, 2, 1]) [1, 2, 3] >>> correct_sequence(5, [10, 11, 9, 12, 13]) [10, 11, 12, 13, 14] >>> correct_sequence(1, [100]) [100] >>> correct_sequence(4, [7, 8, 6, 9]) [7, 8, 9, 10]","solution":"def correct_sequence(N, A): corrected_sequence = [A[0]] for i in range(1, N): next_value = corrected_sequence[-1] + 1 corrected_sequence.append(next_value) return corrected_sequence # Example usage: # N = 6 # A = [5, 6, 5, 7, 8, 9] # print(correct_sequence(N, A)) # Output: [5, 6, 7, 8, 9, 10]"},{"question":"def solve(N: int, Q: int, A: List[int], queries: List[Tuple[int, int]]) -> List[int]: Process a series of queries asking for the sum of elements between two specified indices in the array. Args: N : int : Number of elements in the array Q : int : Number of queries A : List[int] : Array of integers queries : List[Tuple[int, int]] : List of queries with each query consisting of two integers (L, R) Returns: List[int] : List of sums for each query >>> solve(5, 3, [1, 2, 3, 4, 5], [(1, 3), (2, 4), (1, 5)]) [6, 9, 15] >>> solve(6, 2, [3, 1, 4, 1, 5, 9], [(3, 5), (1, 6)]) [10, 23]","solution":"def preprocess_prefix_sums(array): Preprocess the prefix sums for the given array. n = len(array) prefix_sums = [0] * (n + 1) for i in range(1, n + 1): prefix_sums[i] = prefix_sums[i-1] + array[i-1] return prefix_sums def range_sum(prefix_sums, L, R): Get the sum of the subarray from index L to R (1-based). return prefix_sums[R] - prefix_sums[L-1] def solve(N, Q, A, queries): prefix_sums = preprocess_prefix_sums(A) results = [] for L, R in queries: results.append(range_sum(prefix_sums, L, R)) return results"},{"question":"from typing import List def find_paths(grid: List[List[int]]) -> int: Find the number of distinct paths from the top-left corner to the bottom-right corner of the grid, moving only down or right at any step while avoiding obstacles. >>> find_paths([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) 2 >>> find_paths([[0, 1, 0], [0, 1, 0], [0, 0, 0]]) 1 >>> find_paths([[0, 0, 0, 0], [1, 1, 1, 0], [0, 0, 0, 0], [0, 0, 0, 0]]) 1 >>> find_paths([[0, 1], [0, 0]]) 1 pass def process_input(input_data: str) -> List[int]: pass def main(input_data: str) -> None: pass input_data = 3 3 0 0 0 0 1 0 0 0 0 3 3 0 1 0 0 1 0 0 0 0 4 4 0 0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 2 2 0 1 0 0 0 0 main(input_data)","solution":"def find_paths(grid): n = len(grid) m = len(grid[0]) # Create a DP table to store the number of ways to reach each cell. dp = [[0 for _ in range(m)] for _ in range(n)] # Initialize the starting point dp[0][0] = 1 for i in range(n): for j in range(m): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[n-1][m-1] def process_input(input_data): lines = input_data.split('n') result = [] idx = 0 while idx < len(lines): n, m = map(int, lines[idx].split()) if n == 0 and m == 0: break idx += 1 grid = [] for _ in range(n): grid.append(list(map(int, lines[idx].split()))) idx += 1 result.append(find_paths(grid)) return result def main(input_data): results = process_input(input_data) for res in results: print(res) input_data = 3 3 0 0 0 0 1 0 0 0 0 3 3 0 1 0 0 1 0 0 0 0 4 4 0 0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 2 2 0 1 0 0 0 0 main(input_data)"},{"question":"def min_buildings_needed(grid): Determine the minimum number of buildings needed to ensure each row and column contains at least one building. Parameters: grid (List[str]): A list of strings representing the grid. Returns: int: The minimum number of buildings needed. Examples: >>> min_buildings_needed([\\"....\\", \\".B..\\", \\"....\\"]) 3 >>> min_buildings_needed([\\"..\\", \\"..\\"]) 2 >>> min_buildings_needed([\\".B.\\", \\".B.\\", \\".B.\\"]) 0 pass def test_min_buildings_needed(): grid = [ \\"..\\", \\"..\\" ] assert min_buildings_needed(grid) == 2 grid = [ \\"B.\\", \\".B\\", ] assert min_buildings_needed(grid) == 0 grid = [ \\"...\\", \\"...\\", \\"...\\" ] assert min_buildings_needed(grid) == 3 grid = [ \\"B.B\\", \\".B.\\", \\"B.B\\" ] assert min_buildings_needed(grid) == 0 grid = [ \\"....\\", \\".B..\\", \\"....\\" ] assert min_buildings_needed(grid) == 3 grid = [ \\"....\\", \\"....\\", \\"....\\", \\"....\\" ] assert min_buildings_needed(grid) == 4 grid = [ \\".B..\\", \\"B...\\", \\"...B\\", \\"..B.\\" ] assert min_buildings_needed(grid) == 0","solution":"def min_buildings_needed(grid): Determine the minimum number of buildings needed to ensure each row and column contains at least one building. Parameters: grid (List[str]): A list of strings representing the grid. Returns: int: The minimum number of buildings needed. n = len(grid) m = len(grid[0]) if n > 0 else 0 rows_with_building = set() cols_with_building = set() for r in range(n): for c in range(m): if grid[r][c] == 'B': rows_with_building.add(r) cols_with_building.add(c) needed_rows = n - len(rows_with_building) needed_cols = m - len(cols_with_building) return max(needed_rows, needed_cols)"},{"question":"def min_possible_sum(n, arr): Returns the minimum possible sum of the list after applying the operation any number of times. The operation allows choosing two different indices i and j such that a_i is divisible by a_j, and setting a_i = a_i / a_j. Parameters: n (int): The number of elements in the list. arr (list): The list of integers. Returns: int: The minimum possible sum of the list. pass # Unit Tests def test_min_possible_sum_case1(): assert min_possible_sum(4, [4, 8, 2, 1]) == 4 def test_min_possible_sum_case2(): assert min_possible_sum(3, [10, 20, 30]) == 3 def test_min_possible_sum_case3(): assert min_possible_sum(7, [16, 4, 8, 2, 32, 1, 16]) == 7 def test_min_possible_sum_with_single_element(): assert min_possible_sum(1, [100000000]) == 1 def test_min_possible_sum_with_large_numbers(): assert min_possible_sum(5, [1000000000, 500000000, 250000000, 125000000, 62500000]) == 5","solution":"def min_possible_sum(n, arr): Returns the minimum possible sum of the list after applying the operation any number of times. The operation allows choosing two different indices i and j such that a_i is divisible by a_j, and setting a_i = a_i / a_j. Parameters: n (int): The number of elements in the list. arr (list): The list of integers. Returns: int: The minimum possible sum of the list. # The minimum sum is simply the sum of all the smallest elements. return n # since each element is reduced to 1"},{"question":"from collections import deque from typing import List, Tuple def shortest_travel_time(n: int, m: int, edges: List[Tuple[int, int]]) -> int: Returns the shortest time required to travel from node 1 to node n in a directed graph. If there's no such path, returns -1. :param n: Number of nodes :param m: Number of edges :param edges: List of tuples representing the directed edges in the graph :return: Shortest travel time or -1 if no path exists # Test cases def test_shortest_travel_time_example1(): n = 5 m = 6 edges = [(1, 2), (2, 3), (3, 4), (4, 5), (1, 3), (3, 5)] assert shortest_travel_time(n, m, edges) == 2 def test_shortest_travel_time_example2(): n = 4 m = 2 edges = [(1, 2), (2, 3)] assert shortest_travel_time(n, m, edges) == -1 def test_shortest_travel_time_single_node(): n = 1 m = 0 edges = [] assert shortest_travel_time(n, m, edges) == 0 def test_shortest_travel_time_disconnected_graph(): n = 5 m = 3 edges = [(1, 2), (2, 3), (4, 5)] assert shortest_travel_time(n, m, edges) == -1 def test_shortest_travel_time_direct_path(): n = 4 m = 3 edges = [(1, 2), (1, 3), (3, 4)] assert shortest_travel_time(n, m, edges) == 2","solution":"from collections import deque def shortest_travel_time(n, m, edges): Returns the shortest time required to travel from node 1 to node n in a directed graph. If there's no such path, returns -1. :param n: Number of nodes :param m: Number of edges :param edges: List of tuples representing the directed edges in the graph :return: Shortest travel time or -1 if no path exists if n == 1: return 0 # No travel needed if starting and ending node are the same # Create adjacency list adj = {i: [] for i in range(1, n+1)} for u, v in edges: adj[u].append(v) # Queue for BFS queue = deque([(1, 0)]) # (current_node, current_time) visited = set() while queue: current, time = queue.popleft() if current == n: return time if current not in visited: visited.add(current) for neighbor in adj[current]: if neighbor not in visited: queue.append((neighbor, time + 1)) # If we exit the loop without finding node n return -1"},{"question":"from typing import List def findPairs(nums: List[int], k: int) -> int: Given an integer array nums and an integer k, find the number of unique k-diff pairs in the array. A k-diff pair is defined as an integer pair (a, b), where a and b are both numbers in the array and their absolute difference is k. Args: nums (List[int]): The list of integers. k (int): The difference value. Returns: int: The number of unique k-diff pairs in the array. Examples: >>> findPairs([3, 1, 4, 1, 5], 2) 2 >>> findPairs([1, 2, 3, 4, 5], 1) 4 >>> findPairs([1, 3, 1, 5, 4], 0) 1 >>> findPairs([1, 2, 3, 4, 5], 6) 0 >>> findPairs([1, 2, 3, 4, 5], -1) 0 >>> findPairs([1, 1, 1, 2, 2, 2], 1) 1 >>> findPairs([1], 0) 0 >>> findPairs(list(range(0, 10000, 2)), 2) 4999 >>> findPairs([3, 1, 4, 1, 5], 10000000) 0","solution":"from typing import List def findPairs(nums: List[int], k: int) -> int: if k < 0: return 0 pairs = set() seen = set() for num in nums: if num - k in seen: pairs.add((num - k, num)) if num + k in seen: pairs.add((num, num + k)) seen.add(num) return len(pairs)"},{"question":"def sort_employees(employees): Sorts a list of employees based on age and name. Arguments: employees -- list of tuples, where each tuple contains a string (name) and an int (age) Returns: list of tuples sorted based on the specified criteria","solution":"def sort_employees(employees): Sorts a list of employees based on age and name. Arguments: employees -- list of tuples, where each tuple contains a string (name) and an int (age) Returns: list of tuples sorted based on the specified criteria return sorted(employees, key=lambda x: (x[1], x[0])) def format_sorted_employees(employees): Formats the sorted employees list to match the specified output format. Arguments: employees -- list of tuples, where each tuple contains a string (name) and an int (age) Returns: list of formatted strings return [f\\"{name} {age}\\" for name, age in employees] if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().splitlines() N = int(data[0]) employees = [(line.split()[0], int(line.split()[1])) for line in data[1:]] sorted_employees = sort_employees(employees) formatted_output = format_sorted_employees(sorted_employees) for line in formatted_output: print(line)"},{"question":"def unique_paths(m: int, n: int) -> int: Calculate the number of unique paths from top-left to bottom-right of an MxN grid. Args: m: int - Number of rows in the grid. n: int - Number of columns in the grid. Returns: int - Number of unique paths. >>> unique_paths(3, 2) 3 >>> unique_paths(3, 3) 6 >>> unique_paths(1, 1) 1 >>> unique_paths(2, 2) 2 >>> unique_paths(3, 7) 28 >>> unique_paths(7, 3) 28 >>> unique_paths(10, 10) 48620 >>> unique_paths(5, 10) 715","solution":"def unique_paths(m, n): Calculate the number of unique paths from top-left to bottom-right of an MxN grid. # Create a 2D array to store the number of paths for each cell dp = [[0] * n for _ in range(m)] # Initialize the first row and first column for i in range(m): dp[i][0] = 1 for j in range(n): dp[0][j] = 1 # Fill the dp array for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1]"},{"question":"def max_sum_non_adjacent(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Finds the maximum sum of non-adjacent elements for each test case. Args: t (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of tuples, where each tuple contains an integer n and a list of n integers. Returns: List[int]: A list of integers, where each integer is the maximum sum of non-adjacent elements for the corresponding test case. Examples: >>> max_sum_non_adjacent(1, [(5, [3, 2, 5, 10, 7])]) [15] >>> max_sum_non_adjacent(3, [(5, [3, 2, 5, 10, 7]), (4, [3, 2, 7, 10]), (2, [5, 5])]) [15, 13, 5]","solution":"def max_sum_non_adjacent(t, test_cases): Returns an array of integers where each integer is the maximum sum of non-adjacent elements for the corresponding test case. results = [] for i in range(t): n, arr = test_cases[i] if n == 0: results.append(0) continue if n == 1: results.append(arr[0]) continue # Dynamic programming approach prev1, prev2 = 0, 0 for num in arr: curr = max(prev1, prev2 + num) prev2 = prev1 prev1 = curr results.append(prev1) return results"},{"question":"def is_prime(num): Returns True if the number is prime, otherwise False. if num <= 1: return False for i in range(2, int(num**0.5) + 1): if num % i == 0: return False return True def max_prime_subsequence_sum(n, a): Returns the maximum sum of any sub-sequence of prime numbers in the list. If there are no prime numbers in the list, returns 0. >>> max_prime_subsequence_sum(5, [3, 11, 8, 13, 4]) 27 >>> max_prime_subsequence_sum(4, [1, 6, 8, 10]) 0 >>> max_prime_subsequence_sum(7, [7, 5, 9, 3, 12, 2, 11]) 28","solution":"def is_prime(num): Returns True if the number is prime, otherwise False. if num <= 1: return False for i in range(2, int(num**0.5) + 1): if num % i == 0: return False return True def max_prime_subsequence_sum(n, a): Returns the maximum sum of any sub-sequence of prime numbers in the list. If there are no prime numbers in the list, returns 0. prime_sum = sum(x for x in a if is_prime(x)) return prime_sum"},{"question":"def number_of_people_knowing_rumor(initial_people: int, new_people_per_day: int, days: int) -> int: Returns the total number of people who know about the rumor after a given number of days. Parameters: initial_people (int): Initial number of people who know the rumor. new_people_per_day (int): Number of new people each one tells per day. days (int): Number of days. Returns: int: Total number of people who know the rumor. >>> number_of_people_knowing_rumor(3, 2, 1) 9 >>> number_of_people_knowing_rumor(3, 2, 2) 27 >>> number_of_people_knowing_rumor(3, 2, 0) 3 >>> number_of_people_knowing_rumor(3, 0, 2) 3 >>> number_of_people_knowing_rumor(1, 1, 5) 32 >>> number_of_people_knowing_rumor(1000, 1, 3) 8000","solution":"def number_of_people_knowing_rumor(initial_people, new_people_per_day, days): Returns the total number of people who know about the rumor after a given number of days. Parameters: initial_people (int): Initial number of people who know the rumor. new_people_per_day (int): Number of new people each one tells per day. days (int): Number of days. Returns: int: Total number of people who know the rumor. if days == 0: return initial_people total_people = initial_people for _ in range(days): total_people += total_people * new_people_per_day return total_people"},{"question":"def parse_input_and_compute_execution_times(n: int, lines: List[str]) -> List[Tuple[str, int]]: Analyze a log file and compute the total execution time for each unique operation ID. Parameters: n (int): Number of log entries lines (List[str]): List of log entries where each entry contains a timestamp, an operation ID, and the operation type (START or END) Returns: List[Tuple[str, int]]: A list of tuples where each tuple contains an operation ID and its total execution time Examples: >>> parse_input_and_compute_execution_times(6, [\\"1 op1 START\\", \\"2 op2 START\\", \\"5 op1 END\\", \\"6 op3 START\\", \\"7 op2 END\\", \\"10 op3 END\\"]) [(\\"op1\\", 4), (\\"op2\\", 5), (\\"op3\\", 4)] >>> parse_input_and_compute_execution_times(2, [\\"1 op1 START\\", \\"5 op1 END\\"]) [(\\"op1\\", 4)] >>> parse_input_and_compute_execution_times(4, [\\"1 op1 START\\", \\"2 op2 START\\", \\"3 op1 END\\", \\"4 op2 END\\"]) [(\\"op1\\", 2), (\\"op2\\", 2)] >>> parse_input_and_compute_execution_times(6, [\\"1 op3 START\\", \\"2 op1 START\\", \\"3 op3 END\\", \\"4 op2 START\\", \\"5 op1 END\\", \\"6 op2 END\\"]) [(\\"op3\\", 2), (\\"op1\\", 3), (\\"op2\\", 2)] >>> parse_input_and_compute_execution_times(6, [\\"1000000000 op1 START\\", \\"1000000001 op2 START\\", \\"1000000005 op1 END\\", \\"1000000006 op3 START\\", \\"1000000007 op2 END\\", \\"1000000010 op3 END\\"]) [(\\"op1\\", 5), (\\"op2\\", 6), (\\"op3\\", 4)]","solution":"def compute_execution_times(log_entries): Computes the total execution time for each unique operation ID based on log entries. Args: log_entries: List of tuples containing log data (timestamp, operation_ID, operation_type) Returns: A dictionary with operation_ID as keys and their total execution time as values start_times = {} execution_times = {} order = [] for timestamp, operation_id, operation_type in log_entries: if operation_type == \\"START\\": start_times[operation_id] = timestamp if operation_id not in execution_times: execution_times[operation_id] = 0 order.append(operation_id) elif operation_type == \\"END\\": if operation_id in start_times: execution_times[operation_id] += timestamp - start_times[operation_id] result = [(op_id, execution_times[op_id]) for op_id in order] return result def parse_input_and_compute_execution_times(n, lines): log_entries = [] for line in lines: parts = line.split() timestamp = int(parts[0]) operation_id = parts[1] operation_type = parts[2] log_entries.append((timestamp, operation_id, operation_type)) return compute_execution_times(log_entries)"},{"question":"def smallest_rearranged_number(n: int) -> int: Find the smallest rearranged number greater than the given number \`n\`. If no such number exists, return -1. >>> smallest_rearranged_number(123) == 132 >>> smallest_rearranged_number(321) == -1 >>> smallest_rearranged_number(2041) == 2104 >>> smallest_rearranged_number(201) == 210 >>> smallest_rearranged_number(9) == -1 >>> smallest_rearranged_number(1111) == -1 >>> smallest_rearranged_number(1234) == 1243 >>> smallest_rearranged_number(4321) == -1 >>> smallest_rearranged_number(1020) == 1200","solution":"def smallest_rearranged_number(n): Find the smallest rearranged number greater than the given number \`n\`. If no such number exists, return -1. digits = list(str(n)) length = len(digits) # Find the first digit from the end that is smaller than its next digit for i in range(length - 2, -1, -1): if digits[i] < digits[i + 1]: break else: return -1 # No such digit found, n is the largest rearranged number # Find the smallest digit on the right side of digits[i] that is larger than digits[i] for j in range(length - 1, i, -1): if digits[j] > digits[i]: break # Swap the found digits[i] and digits[j] digits[i], digits[j] = digits[j], digits[i] # Reverse the sequence after the position i to get the smallest number digits = digits[:i + 1] + sorted(digits[i + 1:]) return int(\\"\\".join(digits))"},{"question":"def booking_system(requests): Determines if each booking request can be fulfilled and returns the appropriate response for each request. Each request consists of team name, start time, and end time. If the room is available for the requested time, it returns \\"Booking successful\\", otherwise \\"Room already booked\\". Example: >>> booking_system([\\"TeamA 1000 1030\\", \\"TeamB 1015 1100\\", \\"TeamC 1100 1130\\"]) [\\"Booking successful\\", \\"Room already booked\\", \\"Booking successful\\"]","solution":"def booking_system(requests): Determines if each booking request can be fulfilled and returns the appropriate response. bookings = [] # List to store the current bookings result = [] for request in requests: team_name, start, end = request.split() start = int(start) end = int(end) # Check if the requested time overlaps with existing bookings available = True for booking in bookings: if not (end <= booking[0] or start >= booking[1]): available = False break if available: # Add to bookings if available bookings.append((start, end)) result.append(\\"Booking successful\\") else: result.append(\\"Room already booked\\") return result"},{"question":"def min_path_sum(grid): Find the minimum path sum from the top-left corner to the bottom-right corner of a given grid. >>> min_path_sum([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 7 >>> min_path_sum([ ... [1, 2], ... [1, 1] ... ]) 3","solution":"def min_path_sum(grid): if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] for i in range(1, m): dp[i][0] = dp[i - 1][0] + grid[i][0] for j in range(1, n): dp[0][j] = dp[0][j - 1] + grid[0][j] for i in range(1, m): for j in range(1, n): dp[i][j] = grid[i][j] + min(dp[i - 1][j], dp[i][j - 1]) return dp[m - 1][n - 1] # Function to parse input as described in the task def main(): import sys input = sys.stdin.read data = input().split() m = int(data[0]) n = int(data[1]) grid = [] idx = 2 for i in range(m): row = [int(data[idx + j]) for j in range(n)] grid.append(row) idx += n print(min_path_sum(grid))"},{"question":"def find_minimal_maintenance_cost(N: int, M: int, roads: List[Tuple[int, int, int]]) -> int: Calculate the minimal total maintenance cost to ensure all intersections in a city are connected, or determine if it is impossible. Args: N (int): Number of intersections. M (int): Number of bidirectional roads. roads (List[Tuple[int, int, int]]): List of tuples where each tuple consists of three integers u, v, and w representing a road between intersections u and v with maintenance cost w. Returns: int: The minimal total maintenance cost to connect all intersections, or -1 if it is impossible. Examples: >>> find_minimal_maintenance_cost(4, 5, [(1, 2, 3), (2, 3, 2), (3, 4, 4), (4, 1, 1), (2, 4, 5)]) 6 >>> find_minimal_maintenance_cost(3, 0, []) -1 pass from typing import List, Tuple def test_example_case(): N = 4 M = 5 roads = [ (1, 2, 3), (2, 3, 2), (3, 4, 4), (4, 1, 1), (2, 4, 5) ] assert find_minimal_maintenance_cost(N, M, roads) == 6 def test_case_with_two_intersections_one_edge(): N = 2 M = 1 roads = [(1, 2, 2)] assert find_minimal_maintenance_cost(N, M, roads) == 2 def test_case_with_no_edges(): N = 3 M = 0 roads = [] assert find_minimal_maintenance_cost(N, M, roads) == -1 def test_case_with_all_nodes_already_connected_in_mesh_topology(): N = 3 M = 3 roads = [ (1, 2, 3), (2, 3, 4), (1, 3, 1) ] assert find_minimal_maintenance_cost(N, M, roads) == 4 def test_disjoint_set(): N = 4 M = 2 roads = [ (1, 2, 1), (3, 4, 2) ] assert find_minimal_maintenance_cost(N, M, roads) == -1 def test_large_case(): N = 1000 M = 999 roads = [(i, i+1, 1) for i in range(1, 1000)] assert find_minimal_maintenance_cost(N, M, roads) == 999","solution":"def find_minimal_maintenance_cost(N, M, roads): parent = list(range(N + 1)) rank = [0] * (N + 1) def find(u): if parent[u] != u: parent[u] = find(parent[u]) return parent[u] def union(u, v): root_u = find(u) root_v = find(v) if root_u != root_v: if rank[root_u] > rank[root_v]: parent[root_v] = root_u elif rank[root_u] < rank[root_v]: parent[root_u] = root_v else: parent[root_v] = root_u rank[root_u] += 1 edges = sorted(roads, key=lambda x: x[2]) mst_cost = 0 edges_used = 0 for u, v, w in edges: if find(u) != find(v): union(u, v) mst_cost += w edges_used += 1 if edges_used == N - 1: break if edges_used == N - 1: return mst_cost else: return -1"},{"question":"from typing import List, Tuple def sieve(n: int) -> List[int]: Sieve of Eratosthenes finds all primes up to n. def find_primes_in_range(a: int, b: int) -> List[int]: Finds all prime numbers in the inclusive range [a, b]. def display_prime_ranges(test_cases: List[Tuple[int, int]]) -> List[str]: For each test case, returns a space-separated string of primes in the range [a, b]. >>> display_prime_ranges([(2, 10), (11, 20), (22, 29)]) ['2 3 5 7', '11 13 17 19', '23 29'] def test_sieve(): assert sieve(10) == [2, 3, 5, 7] assert sieve(30) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] def test_find_primes_in_range(): assert find_primes_in_range(2, 10) == [2, 3, 5, 7] assert find_primes_in_range(11, 20) == [11, 13, 17, 19] assert find_primes_in_range(22, 29) == [23, 29] assert find_primes_in_range(1, 1) == [] # no primes in this range def test_display_prime_ranges(): test_cases = [(2, 10), (11, 20), (22, 29)] expected_output = [\\"2 3 5 7\\", \\"11 13 17 19\\", \\"23 29\\"] assert display_prime_ranges(test_cases) == expected_output if __name__ == \\"__main__\\": test_sieve() test_find_primes_in_range() test_display_prime_ranges() print(\\"All tests passed.\\")","solution":"def sieve(n): Sieve of Eratosthenes finds all primes up to n is_prime = [True] * (n + 1) p = 2 while (p * p <= n): if is_prime[p]: for i in range(p * p, n + 1, p): is_prime[i] = False p += 1 prime_numbers = [] for p in range(2, n + 1): if is_prime[p]: prime_numbers.append(p) return prime_numbers def find_primes_in_range(a, b): Finds all prime numbers in the inclusive range [a, b] if a < 2: a = 2 sieve_limit = int(b**0.5) + 1 primes_up_to_sqrt_b = sieve(sieve_limit) is_prime_in_range = [True] * (b - a + 1) for prime in primes_up_to_sqrt_b: # Find the minimum number in the range [a, b] that is # a multiple of prime and greater than or equal to prime^2 start = max(prime*prime, (a + prime - 1) // prime * prime) for j in range(start, b + 1, prime): is_prime_in_range[j - a] = False primes_in_range = [num for num, is_prime in enumerate(is_prime_in_range, start=a) if is_prime] return primes_in_range def display_prime_ranges(test_cases): results = [] for (a, b) in test_cases: primes = find_primes_in_range(a, b) results.append(\\" \\".join(map(str, primes))) return results"},{"question":"def sum_of_max_elements(matrix: List[List[int]]) -> int: Returns the sum of the maximum element in each row of the given matrix. Args: matrix (list of list of int): A 2D list representing the matrix. Returns: int: Sum of the maximum elements in each row. Examples: >>> sum_of_max_elements([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 18 >>> sum_of_max_elements([ ... [42] ... ]) 42 pass def get_matrix_and_sum(n: int, matrix_values: List[int]) -> int: Given the size of the matrix and the matrix values, this function constructs the matrix and returns the sum of the maximum elements in each row. Args: n (int): size of the matrix. matrix_values (list of list of int): matrix elements Returns: int: Sum of the maximum elements in each row. Examples: >>> get_matrix_and_sum(3, [1, 2, 3, 4, 5, 6, 7, 8, 9]) 18 >>> get_matrix_and_sum(1, [42]) 42 pass","solution":"def sum_of_max_elements(matrix): Returns the sum of the maximum element in each row of the given matrix. Args: matrix (list of list of int): A 2D list representing the matrix. Returns: int: Sum of the maximum elements in each row. return sum(max(row) for row in matrix) def get_matrix_and_sum(n, matrix_values): Given the size of the matrix and the matrix values, this function constructs the matrix and returns the sum of the maximum elements in each row. Args: n (int): size of the matrix. matrix_values (list of list of int): matrix elements Returns: int: Sum of the maximum elements in each row. matrix = [] idx = 0 for i in range(n): row = [matrix_values[idx + j] for j in range(n)] matrix.append(row) idx += n return sum_of_max_elements(matrix)"},{"question":"def find_tournament_champion(N: int, skills: List[int]) -> int: Simulate the tournament and find the champion's skill rating. :param N: int - the number of players :param skills: List[int] - the skill ratings of the players :return: int - the skill rating of the champion Examples: >>> find_tournament_champion(4, [3, 1, 4, 2]) 4 >>> find_tournament_champion(8, [1, 2, 3, 4, 5, 6, 7, 8]) 8 pass import pytest def test_find_tournament_champion(): assert find_tournament_champion(4, [3, 1, 4, 2]) == 4 assert find_tournament_champion(8, [1, 2, 3, 4, 5, 6, 7, 8]) == 8 assert find_tournament_champion(2, [1, 2]) == 2 assert find_tournament_champion(4, [2, 3, 3, 2]) == 3 skills = [i for i in range(1, 1025)] assert find_tournament_champion(1024, skills) == 1024 assert find_tournament_champion(8, [5, 1, 8, 6, 2, 7, 4, 3]) == 8 skills = [5] * 8 assert find_tournament_champion(8, skills) == 5","solution":"def find_tournament_champion(N, skills): Simulate the tournament and find the champion's skill rating. :param N: int - the number of players :param skills: List[int] - the skill ratings of the players :return: int - the skill rating of the champion while len(skills) > 1: next_round = [] for i in range(0, len(skills), 2): next_round.append(max(skills[i], skills[i+1])) skills = next_round return skills[0]"},{"question":"from typing import List def max_reservations(M: int, N: int, table_capacities: List[int], reservations: List[int]) -> int: This function takes the number of tables (M), number of reservations (N), a list of table capacities, and a list of reservations and returns the maximum number of reservations that can be accommodated. >>> max_reservations(3, 4, [5, 8, 6], [2, 4, 4, 8]) 3 >>> max_reservations(3, 0, [5, 8, 6], []) 0 >>> max_reservations(0, 4, [], [2, 4, 4, 8]) 0 >>> max_reservations(3, 3, [5, 8, 6], [2, 5, 6]) 3 >>> max_reservations(3, 4, [5, 5, 5], [2, 5, 6, 1]) 3 >>> max_reservations(2, 2, [1000000, 2000000], [1500000, 2500000]) 1 >>> max_reservations(4, 4, [5, 6, 7, 8], [5, 6, 7, 8]) 4","solution":"def max_reservations(M, N, table_capacities, reservations): This function takes the number of tables (M), number of reservations (N), a list of table capacities, and a list of reservations and returns the maximum number of reservations that can be accommodated. table_capacities.sort() reservations.sort() table_index = 0 reservation_index = 0 accommodated_reservations = 0 while table_index < M and reservation_index < N: if reservations[reservation_index] <= table_capacities[table_index]: accommodated_reservations += 1 reservation_index += 1 table_index += 1 else: table_index += 1 return accommodated_reservations"},{"question":"def is_sum_of_two_squares(n: int) -> bool: Check if a number can be represented as a sum of two perfect squares. pass def check_sums(x: int, y: int) -> str: Returns \\"Yes\\" if both x and y can be represented as the sum of two perfect squares, otherwise returns \\"No\\". >>> check_sums(5, 10) 'Yes' >>> check_sums(3, 17) 'No' pass def test_check_sums_yes(): assert check_sums(5, 10) == \\"Yes\\" assert check_sums(0, 0) == \\"Yes\\" assert check_sums(1, 4) == \\"Yes\\" assert check_sums(2, 50) == \\"Yes\\" assert check_sums(9, 25) == \\"Yes\\" def test_check_sums_no(): assert check_sums(3, 17) == \\"No\\" assert check_sums(7, 11) == \\"No\\" assert check_sums(34, 19) == \\"No\\" assert check_sums(3, 2) == \\"No\\" assert check_sums(23, 12) == \\"No\\"","solution":"import math def is_sum_of_two_squares(n): Check if n can be represented as a sum of two perfect squares. for a in range(int(math.isqrt(n)) + 1): b = n - a * a if math.isqrt(b) ** 2 == b: return True return False def check_sums(x, y): Returns \\"Yes\\" if both x and y can be represented as the sum of two perfect squares, otherwise returns \\"No\\". if is_sum_of_two_squares(x) and is_sum_of_two_squares(y): return \\"Yes\\" else: return \\"No\\""},{"question":"def generate_sequence(a: int, b: int, N: int) -> List[int]: Generate the first N numbers of the special sequence starting with a and b. pass def process_test_cases(T: int, test_cases: List[Tuple[int, int, int]]) -> List[List[int]]: Process T number of test cases and return the results. pass # Unit tests def test_generate_sequence(): assert generate_sequence(1, 1, 5) == [1, 1, 2, 3, 5] assert generate_sequence(2, 3, 6) == [2, 3, 5, 8, 13, 21] assert generate_sequence(5, 8, 4) == [5, 8, 13, 21] assert generate_sequence(0, 0, 3) == [0, 0, 0] assert generate_sequence(10, 20, 2) == [10, 20] def test_process_test_cases(): assert process_test_cases(3, [(1, 1, 5), (2, 3, 6), (5, 8, 4)]) == [ [1, 1, 2, 3, 5], [2, 3, 5, 8, 13, 21], [5, 8, 13, 21] ] assert process_test_cases(1, [(0, 1, 5)]) == [ [0, 1, 1, 2, 3] ]","solution":"def generate_sequence(a, b, N): Generate the first N numbers of the special sequence starting with a and b. sequence = [a, b] for _ in range(2, N): sequence.append(sequence[-1] + sequence[-2]) return sequence def process_test_cases(T, test_cases): Process T number of test cases and return the results. results = [] for case in test_cases: a, b, N = case sequence = generate_sequence(a, b, N) results.append(sequence) return results"},{"question":"def is_point_inside_polygon(n: int, polygon: List[Tuple[int, int]], point: Tuple[int, int]) -> str: Determine if a given point is inside a convex polygon. Args: n : int : number of vertices of the polygon polygon : List[Tuple[int, int]] : list of tuples representing the vertices of the polygon point : Tuple[int, int] : tuple representing the coordinates of the point to check Returns: str : \\"INSIDE\\" if the point is inside the polygon, otherwise \\"OUTSIDE\\" pass def process_input(datasets: List[Union[int, Tuple[int, int]]]) -> List[str]: Process the input datasets to determine if points are inside their respective polygons. Args: datasets : List[Union[int, Tuple[int, int]]] : list containing multiple datasets Returns: List[str] : list of results for each dataset, \\"INSIDE\\" or \\"OUTSIDE\\" pass def test_is_point_inside_polygon(): datasets = [ 4, (0, 0), (4, 0), (4, 4), (0, 4), (2, 2), 3, (1, 1), (2, 5), (6, 2), (3, 3), ] results = process_input(datasets) expected_results = [\\"INSIDE\\", \\"OUTSIDE\\"] assert results == expected_results def test_point_outside_on_side(): datasets = [ 4, (0, 0), (4, 0), (4, 4), (0, 4), (4, 2), ] results = process_input(datasets) expected_results = [\\"OUTSIDE\\"] assert results == expected_results def test_point_outside(): datasets = [ 5, (0, 0), (4, 0), (4, 4), (2, 6), (0, 4), (2, 7), ] results = process_input(datasets) expected_results = [\\"OUTSIDE\\"] assert results == expected_results def test_convex_polygon(): datasets = [ 7, (0, 0), (4, 0), (6, 2), (5, 5), (3, 6), (1, 5), (0, 4), (3, 3), ] results = process_input(datasets) expected_results = [\\"INSIDE\\"] assert results == expected_results","solution":"def is_point_inside_polygon(n, polygon, point): def cross_product_sign(p1, p2, p3): Returns positive if p3 is to the left of the line formed by p1 and p2, negative if to the right, and 0 if p3 is on the line. return (p2[0] - p1[0]) * (p3[1] - p1[1]) - (p2[1] - p1[1]) * (p3[0] - p1[0]) def is_convex(poly): Returns True if the polygon vertices are in clockwise or counter-clockwise order. pos = neg = False for i in range(len(poly)): p1, p2, p3 = poly[i], poly[(i + 1) % len(poly)], poly[(i + 2) % len(poly)] sign = cross_product_sign(p1, p2, p3) if sign > 0: pos = True elif sign < 0: neg = True if pos and neg: return False return True def check_point(p, poly): Returns whether the point is inside the polygon. for i in range(len(poly)): p1, p2 = poly[i], poly[(i + 1) % len(poly)] if cross_product_sign(p1, p2, p) <= 0: return \\"OUTSIDE\\" return \\"INSIDE\\" if not is_convex(polygon): return \\"OUTSIDE\\" return check_point(point, polygon) def process_input(datasets): results = [] index = 0 while index < len(datasets): n = datasets[index] index += 1 polygon = [] for _ in range(n): polygon.append(datasets[index]) index += 1 point = datasets[index] index += 1 results.append(is_point_inside_polygon(n, polygon, point)) return results"},{"question":"def final_heights(n: int, heights: List[int], growth: List[int], intervals: List[int]) -> List[int]: Computes the final heights of the trees after the given intervals based on their respective growth changes. Parameters: n (int): Number of trees heights (List[int]): Initial heights of the trees growth (List[int]): Growth changes for the trees intervals (List[int]): Intervals after which the growth changes occur Returns: List[int]: Final heights of the trees Example: >>> final_heights(5, [10, 20, 30, 40, 50], [-5, 10, 0, -20, 25], [1, 2, 3, 4, 5]) [5, 30, 30, 20, 75] >>> final_heights(3, [5, 15, 25], [10, 20, 30], [1, 2, 3]) [15, 35, 55] pass","solution":"def final_heights(n, heights, growth, intervals): Computes the final heights of the trees after the given intervals based on their respective growth changes. Parameters: n (int): Number of trees heights (List[int]): Initial heights of the trees growth (List[int]): Growth changes for the trees intervals (List[int]): Intervals after which the growth changes occur Returns: List[int]: Final heights of the trees final_heights = [heights[i] + growth[i] for i in range(n)] return final_heights"},{"question":"def check_anomaly(n: int, timestamps: List[str]) -> str: This function checks if any event occurred more than once within a 10-second interval in the given log file. Parameters: n (int): The number of events logged timestamps (list of str): The exact times the events occurred in the format \\"hh:mm:ss\\" Returns: str: \\"YES\\" if there is any event that occurred more than once within any 10-second interval, otherwise \\"NO\\"","solution":"def check_anomaly(n, timestamps): This function checks if any event occurred more than once within a 10-second interval in the given log file. Parameters: n (int): The number of events logged timestamps (list of str): The exact times the events occurred in the format \\"hh:mm:ss\\" Returns: str: \\"YES\\" if there is any event that occurred more than once within any 10-second interval, otherwise \\"NO\\" def to_seconds(time): h, m, s = map(int, time.split(':')) return h * 3600 + m * 60 + s times_in_seconds = [to_seconds(time) for time in timestamps] for i in range(len(times_in_seconds) - 1): if times_in_seconds[i + 1] - times_in_seconds[i] <= 10: return \\"YES\\" return \\"NO\\""},{"question":"def can_pair_employees(skill_levels: List[int]) -> str: Determine if its possible to pair all the employees such that no two employees in a pair have the same skill level. Parameters: skill_levels (list of int): List of skill levels of the employees Returns: str: \\"Yes\\" if it's possible to pair employees as described, \\"No\\" otherwise Examples: >>> can_pair_employees([1, 2, 3, 4, 5, 6]) 'Yes' >>> can_pair_employees([1, 1, 2, 2]) 'Yes' >>> can_pair_employees([1, 2, 2]) 'No' from typing import List def test_can_pair_employees(): assert can_pair_employees([1, 2, 3, 4, 5, 6]) == \\"Yes\\" assert can_pair_employees([1, 1, 2, 2]) == \\"Yes\\" assert can_pair_employees([1, 2, 2]) == \\"No\\" assert can_pair_employees([3, 3, 3, 3, 3]) == \\"No\\" assert can_pair_employees([1, 2, 3, 1, 2, 3]) == \\"Yes\\" assert can_pair_employees([1, 1, 1, 1, 1, 1]) == \\"No\\" assert can_pair_employees([1, 2, 2, 3, 3, 3]) == \\"Yes\\" test_can_pair_employees()","solution":"def can_pair_employees(skill_levels): Determine if its possible to pair all the employees such that no two employees in a pair have the same skill level. Parameters: skill_levels (list of int): List of skill levels of the employees Returns: str: \\"Yes\\" if it's possible to pair employees as described, \\"No\\" otherwise from collections import Counter skill_counts = Counter(skill_levels) # If any skill level appears more than half the number of employees, it's not possible to pair everyone n = len(skill_levels) max_count = max(skill_counts.values()) if max_count > n // 2: return \\"No\\" else: return \\"Yes\\""},{"question":"def calculate_online_durations(logs): Calculate the total online duration for each user from the given log entries. :param logs: List of logs where each log is a tuple (timestamp, username, status). :return: A dictionary with username as key and total online duration in seconds as value. >>> calculate_online_durations([(10, \\"alice\\", \\"online\\"), (15, \\"bob\\", \\"online\\"), (30, \\"alice\\", \\"offline\\"), (35, \\"bob\\", \\"offline\\"), (50, \\"alice\\", \\"online\\"), (80, \\"alice\\", \\"offline\\"), (100, \\"bob\\", \\"online\\")]) {'alice': 50, 'bob': 20} >>> calculate_online_durations([(5, \\"user1\\", \\"online\\"), (10, \\"user1\\", \\"offline\\"), (15, \\"user1\\", \\"online\\"), (20, \\"user1\\", \\"offline\\")]) {'user1': 10} >>> calculate_online_durations([(1, \\"userA\\", \\"online\\"), (100, \\"userA\\", \\"offline\\")]) {'userA': 99} >>> calculate_online_durations([(0, \\"alice\\", \\"online\\"), (5, \\"alice\\", \\"offline\\"), (10, \\"bob\\", \\"online\\"), (20, \\"bob\\", \\"offline\\")]) {'alice': 5, 'bob': 10} >>> calculate_online_durations([(1, \\"a\\", \\"online\\"), (2, \\"a\\", \\"offline\\"), (1, \\"b\\", \\"online\\"), (2, \\"b\\", \\"offline\\"), (1, \\"c\\", \\"online\\"), (3, \\"c\\", \\"offline\\")]) {'a': 1, 'b': 1, 'c': 2}","solution":"def calculate_online_durations(logs): Calculate the total online duration for each user from the given log entries. :param logs: List of logs where each log is a tuple (timestamp, username, status). :return: A dictionary with username as key and total online duration in seconds as value. user_sessions = {} online_times = {} for log in logs: timestamp, username, status = log if username not in online_times: online_times[username] = 0 if status == \\"online\\": user_sessions[username] = timestamp elif status == \\"offline\\": if username in user_sessions: online_times[username] += (timestamp - user_sessions[username]) del user_sessions[username] return {user: online_times[user] for user in sorted(online_times)} # Example usage: logs_input = [(10, \\"alice\\", \\"online\\"), (15, \\"bob\\", \\"online\\"), (30, \\"alice\\", \\"offline\\"), (35, \\"bob\\", \\"offline\\"), (50, \\"alice\\", \\"online\\"), (80, \\"alice\\", \\"offline\\"), (100, \\"bob\\", \\"online\\")] print(calculate_online_durations(logs_input)) # Expected output: {'alice': 50, 'bob': 20}"},{"question":"def is_prime(n: int) -> bool: Determines if a number n is prime. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(0) False >>> is_prime(1) False >>> is_prime(-5) False >>> is_prime(17) True def sum_of_primes(arr: List[int]) -> int: Returns the sum of all prime numbers in the list. >>> sum_of_primes([1, 3, 4, 5, 6, 7]) 15 >>> sum_of_primes([-3, -2, -1, 0, 1, 4, 6, 8, 9]) 0 >>> sum_of_primes([2, 17, 19, 23]) 61 >>> sum_of_primes([-5, -7, 1, 3, 7]) 10","solution":"def is_prime(n): Determines if a number n is prime. if n <= 1: return False for i in range(2, int(n ** 0.5) + 1): if n % i == 0: return False return True def sum_of_primes(arr): Returns the sum of all prime numbers in the list. return sum(x for x in arr if is_prime(x))"},{"question":"from typing import List, Tuple def min_diff_in_groups(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given T test cases of problem difficulty ratings, find the minimum difference between the sums of two groups of problems for each test case. Args: T (int): Number of test cases. test_cases (List[Tuple[int, List[int]]]): List of tuples where each tuple contains an integer n (number of problems) and a list of integers (difficulty ratings). Returns: List[int]: List of integers where each integer is the minimum difference between the sums of the two groups for a test case. >>> T = 2 >>> test_cases = [ ... (4, [1, 3, 5, 9]), ... (6, [4, 5, 6, 7, 8, 9]) ... ] >>> min_diff_in_groups(T, test_cases) [0, 1]","solution":"def min_diff_in_groups(T, test_cases): results = [] for i in range(T): n, difficulties = test_cases[i] total_sum = sum(difficulties) half_sum = total_sum // 2 # Initialize a dp array dp = [False] * (half_sum + 1) dp[0] = True for difficulty in difficulties: for j in range(half_sum, difficulty - 1, -1): dp[j] |= dp[j - difficulty] for j in range(half_sum, -1, -1): if dp[j]: diff = total_sum - 2 * j results.append(diff) break return results # Example usage: T = 2 test_cases = [ (4, [1, 3, 5, 9]), (6, [4, 5, 6, 7, 8, 9]) ] print(min_diff_in_groups(T, test_cases)) # Output: [0, 1]"},{"question":"def max_subarray_sum(n: int, arr: List[int]) -> int: Returns the maximum sum of a contiguous subsequence of houses. :param n: int, number of houses :param arr: List[int], treasure values of the houses :return: int, maximum sum of a contiguous subsequence of houses >>> max_subarray_sum(9, [-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 >>> max_subarray_sum(5, [-8, -3, -6, -2, -5]) == -2 >>> max_subarray_sum(1, [5]) == 5 >>> max_subarray_sum(1, [-5]) == -5 >>> max_subarray_sum(4, [1, 2, 3, 4]) == 10 >>> max_subarray_sum(5, [1, 2, 3, -2, 5]) == 9 >>> max_subarray_sum(8, [-2, 1, -3, 4, -1, 2, 1, -5]) == 6 >>> max_subarray_sum(5, [0, 0, 0, 0, 0]) == 0","solution":"def max_subarray_sum(n, arr): Returns the maximum sum of a contiguous subsequence of houses. :param n: int, number of houses :param arr: List[int], treasure values of the houses :return: int, maximum sum of a contiguous subsequence of houses current_sum = max_sum = arr[0] for value in arr[1:]: current_sum = max(value, current_sum + value) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def is_possible_to_place_fences(n: int, d: int, heights: List[int]) -> str: Determine if it is possible to place decorative fences between all pairs of consecutive flowerbeds. Args: n : int : number of flowerbeds d : int : maximum allowed height difference heights : List[int] : list of integers representing the heights of the flowers in the flowerbeds Returns: str : \\"Yes\\" if it is possible to place the fences, followed by the fence heights on a new line if possible, otherwise \\"No\\". Examples: >>> is_possible_to_place_fences(5, 3, [4, 7, 9, 11, 14]) 'Yesn3 2 2 3' >>> is_possible_to_place_fences(3, 1, [5, 7, 8]) 'No'","solution":"def is_possible_to_place_fences(n, d, heights): Function to determine if it is possible to place fences between every pair of consecutive flowerbeds given the height differences. differences = [] for i in range(n - 1): diff = abs(heights[i] - heights[i + 1]) if diff > d: return \\"No\\" differences.append(diff) return \\"Yesn\\" + ' '.join(map(str, differences))"},{"question":"def longest_subarray(arr: List[int]) -> int: Returns the length of the longest subarray with all elements having the same value. >>> longest_subarray([4, 6, 6, 6, 5, 5, 5, 5, -2, -2, 3, 3, 3, 3, 3]) 5 >>> longest_subarray([1, 2, 3, 4, 5]) 1 >>> longest_subarray([1, 2, 2, 3, 3, 3]) 3","solution":"def longest_subarray(arr): Returns the length of the longest subarray with all elements having the same value. if not arr: return 0 max_length = 1 current_length = 1 for i in range(1, len(arr)): if arr[i] == arr[i-1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 max_length = max(max_length, current_length) return max_length"},{"question":"def maximalRectangle(matrix: List[List[int]]) -> int: Determine the area of the largest rectangle containing only 1s in a given binary matrix. >>> maximalRectangle([ ... [1, 0, 1, 0, 0], ... [1, 0, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 0, 0, 1, 0] ... ]) 6 >>> maximalRectangle([ ... [1], ... ]) 1 >>> maximalRectangle([ ... [0, 0], ... [0, 0] ... ]) 0 >>> maximalRectangle([ ... [1, 1], ... [1, 1] ... ]) 4 >>> maximalRectangle([]) 0 >>> maximalRectangle([ ... [1, 1, 0, 1], ... [1, 1, 1, 1], ... [0, 1, 1, 1] ... ]) 6","solution":"def maximalRectangle(matrix): if not matrix: return 0 m = len(matrix) n = len(matrix[0]) max_area = 0 heights = [0] * n for i in range(m): for j in range(n): if matrix[i][j] == 1: heights[j] += 1 else: heights[j] = 0 max_area = max(max_area, largestRectangleArea(heights)) return max_area def largestRectangleArea(heights): stack = [] max_area = 0 for i, h in enumerate(heights + [0]): while stack and heights[stack[-1]] >= h: height = heights[stack.pop()] width = i if not stack else i - stack[-1] - 1 max_area = max(max_area, height * width) stack.append(i) return max_area # Example usage # matrix = [ # [1, 0, 1, 0, 0], # [1, 0, 1, 1, 1], # [1, 1, 1, 1, 1], # [1, 0, 0, 1, 0] # ] # print(maximalRectangle(matrix)) # Output: 6"},{"question":"def longest_chain(words: List[str]) -> int: Determine the longest chain of words where each successive word is formed by permuting the previous word's letters and adding exactly one additional letter. Arguments: words -- a list of words containing lowercase English letters Returns: An integer representing the length of the longest possible chain. Example: >>> longest_chain([\\"a\\", \\"ab\\", \\"abc\\", \\"cad\\", \\"def\\", \\"fdea\\"]) == 3 >>> longest_chain([\\"a\\"]) == 1 pass def test_example_case(): words = [\\"a\\", \\"ab\\", \\"abc\\", \\"cad\\", \\"def\\", \\"fdea\\"] assert longest_chain(words) == 3 def test_case_of_single_word(): assert longest_chain([\\"a\\"]) == 1 def test_case_of_no_permutation_chain_possible(): words = [\\"a\\", \\"b\\", \\"c\\", \\"d\\"] assert longest_chain(words) == 1 def test_case_with_letters_adding_up_long_chain(): words = [\\"a\\", \\"ab\\", \\"abc\\", \\"abcd\\"] assert longest_chain(words) == 4 def test_case_with_disconnected_chains(): words = [\\"a\\", \\"ab\\", \\"abc\\", \\"bca\\", \\"d\\", \\"de\\", \\"def\\"] assert longest_chain(words) == 3 def test_case_with_multiple_possible_longest_chains(): words = [\\"a\\", \\"ab\\", \\"abc\\", \\"abcd\\", \\"abcde\\", \\"f\\", \\"fg\\", \\"fgh\\", \\"fghi\\"] assert longest_chain(words) == 5 def test_case_with_duplicates(): words = [\\"a\\", \\"ab\\", \\"abc\\", \\"ab\\", \\"abc\\"] assert longest_chain(words) == 3 def test_case_with_all_chars(): words = [\\"a\\", \\"b\\", \\"c\\", \\"ba\\", \\"abc\\", \\"xyz\\", \\"xyza\\"] assert longest_chain(words) == 3","solution":"def longest_chain(words): from collections import defaultdict def can_form_chain(word1, word2): if len(word2) == len(word1) + 1: char_count = defaultdict(int) for char in word2: char_count[char] += 1 for char in word1: if char_count[char] == 0: return False char_count[char] -= 1 return True return False word_set = set(words) dp = {word: 1 for word in words} words = sorted(words, key=len) for word in words: for next_word in word_set: if can_form_chain(word, next_word): dp[next_word] = max(dp[next_word], dp[word] + 1) return max(dp.values())"},{"question":"def compress_string(s: str) -> str: Compress the string using the specified algorithm. Parameters: s (str): The input string containing only lowercase Latin letters. Returns: str: The compressed version of the input string. Examples: >>> compress_string(\\"aaabbccc\\") 'a3b2c3' >>> compress_string(\\"abcd\\") 'abcd' >>> compress_string(\\"aaabbccccd\\") 'a3b2c4d' >>> compress_string(\\"a\\") 'a' >>> compress_string(\\"aabba\\") 'a2b2a' >>> compress_string(\\"\\") '' >>> compress_string(\\"aaaaaaaaaaaa\\") 'a12'","solution":"def compress_string(s): Compress the string using the specified algorithm. Parameters: s (str): The input string containing only lowercase Latin letters. Returns: str: The compressed version of the input string. if not s: return \\"\\" compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1]) if count > 1: compressed.append(str(count)) count = 1 # Add the last group compressed.append(s[-1]) if count > 1: compressed.append(str(count)) return ''.join(compressed)"},{"question":"def can_form_common_anagram(t: int, test_cases: List[Tuple[int, str, str]]) -> List[str]: You are given two strings a and b of the same length n consisting of lowercase Latin letters. The target is to make strings a and b each anagrams of some common string c by removing exactly one character from each string. Args: t (int): number of test cases. test_cases (List[Tuple[int, str, str]]): list containing each test case as tuple (n, a, b) Returns: List[str]: list containing \\"YES\\" or \\"NO\\" for each respective test case. Example usage: >>> can_form_common_anagram(3, [(5, \\"abcbc\\", \\"bccba\\"), (3, \\"aaa\\", \\"bbb\\"), (4, \\"xxyy\\", \\"yyxx\\")]) [\\"YES\\", \\"NO\\", \\"YES\\"]","solution":"def can_form_common_anagram(t, test_cases): results = [] for case in test_cases: n, a, b = case freq_a = {} freq_b = {} # Counting frequency of each character in a and b for char in a: if char in freq_a: freq_a[char] += 1 else: freq_a[char] = 1 for char in b: if char in freq_b: freq_b[char] += 1 else: freq_b[char] = 1 # Check if there's at least one common character can_form = False for char in freq_a: if char in freq_b: can_form = True break if can_form: results.append(\\"YES\\") else: results.append(\\"NO\\") return results # Example usage: t = 3 test_cases = [ (5, \\"abcbc\\", \\"bccba\\"), (3, \\"aaa\\", \\"bbb\\"), (4, \\"xxyy\\", \\"yyxx\\") ] print(can_form_common_anagram(t, test_cases))"},{"question":"def shortest_path(n: int, m: int, roads: List[Tuple[int, int, int]], start: int, end: int) -> Union[int, str]: Determine the shortest path between two towns given a list of roads and their associated distances. Args: n: int - The number of towns. m: int - The number of roads. roads: List[Tuple[int, int, int]] - A list of tuples where each tuple represents a road connecting two towns with a specific distance (ai, bi, ci). start: int - The starting town. end: int - The destination town. Returns: Union[int, str] - The shortest distance between the starting town and the destination town. If there is no path, return \\"No path\\". Example: >>> shortest_path(4, 4, [(1, 2, 10), (2, 3, 10), (3, 4, 10), (1, 4, 30)], 1, 3) 20 >>> shortest_path(3, 2, [(1, 2, 5), (2, 3, 7)], 1, 3) 12 >>> shortest_path(5, 2, [(1, 2, 10), (2, 3, 10), (4, 5, 6)], 1, 5) \\"No path\\"","solution":"import heapq def shortest_path(n, m, roads, start, end): graph = {i: [] for i in range(1, n+1)} for ai, bi, ci in roads: graph[ai].append((ci, bi)) graph[bi].append((ci, ai)) # Use Dijkstra's algorithm to find the shortest path priority_queue = [(0, start)] distances = {i: float('inf') for i in range(1, n+1)} distances[start] = 0 while priority_queue: current_distance, current_town = heapq.heappop(priority_queue) if current_town == end: return current_distance for weight, neighbor in graph[current_town]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return \\"No path\\""},{"question":"def can_achieve_target(dice_a, dice_b, target): Determine if a given target number can be achieved by rolling both dice and summing the two resulting numbers. >>> can_achieve_target([1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], 7) == \\"Yes\\" >>> can_achieve_target([1, 1, 2, 2, 3, 3], [2, 2, 3, 3, 4, 4], 10) == \\"No\\"","solution":"def can_achieve_target(dice_a, dice_b, target): Returns 'Yes' if there is a combination of faces from both Dice A and Dice B whose sums equal the target number. Otherwise, returns 'No'. for face_a in dice_a: for face_b in dice_b: if face_a + face_b == target: return \\"Yes\\" return \\"No\\""},{"question":"from typing import List def smallest_range_subset(n: int, values: List[int], k: int) -> List[int]: Returns the subset with the smallest range that contains at least k stamps. >>> smallest_range_subset(5, [4, 8, 1, 7, 2], 2) [1, 2] >>> smallest_range_subset(6, [10, 20, 30, 40, 50, 60], 3) [10, 20, 30] >>> smallest_range_subset(4, [-5, -4, -3, -2], 2) [-5, -4]","solution":"def smallest_range_subset(n, values, k): Returns the subset with the smallest range that contains at least k stamps. values.sort() min_range = float('inf') best_subset = [] for i in range(n - k + 1): current_range = values[i + k - 1] - values[i] if current_range < min_range: min_range = current_range best_subset = values[i:i + k] return best_subset"},{"question":"from typing import List class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def add_two_numbers(nums1: List[int], nums2: List[int]) -> ListNode: Add two numbers represented by two integer arrays and return the sum as a linked list. >>> listnode_to_list(add_two_numbers([2, 4, 3], [5, 6, 4])) [7, 0, 8] >>> listnode_to_list(add_two_numbers([0], [0])) [0] >>> listnode_to_list(add_two_numbers([9, 9, 9], [9, 9, 9])) [8, 9, 9, 1] >>> listnode_to_list(add_two_numbers([1, 8], [0])) [1, 8] def listnode_to_list(node: ListNode) -> List[int]: result = [] while node is not None: result.append(node.val) node = node.next return result","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def add_two_numbers(nums1, nums2): def list_to_number(lst): num = 0 for i in range(len(lst)): num += lst[i] * (10 ** i) return num def number_to_list(num): if num == 0: return [0] result = [] while num > 0: result.append(num % 10) num = num // 10 return result num1 = list_to_number(nums1) num2 = list_to_number(nums2) total = num1 + num2 result_list = number_to_list(total) dummy_head = ListNode() current = dummy_head for digit in result_list: current.next = ListNode(digit) current = current.next return dummy_head.next"},{"question":"def analyze_conversation_log(log_lines: List[str]) -> Tuple[int, int, int]: Analyzes a list of conversation log lines and returns the count of each message type. Args: log_lines (list of str): The list containing the lines from the conversation log. Returns: tuple: A tuple containing three integers (request_count, complaint_count, suggestion_count). from solution import analyze_conversation_log def test_analyze_conversation_log_example(): log_lines = [ '1 Can I change my order?', '2 The item I received is damaged.', '1 What are your working hours?', '3 You should offer more payment options.', '2 I am not happy with the delivery time.' ] assert analyze_conversation_log(log_lines) == (2, 2, 1) def test_analyze_conversation_log_all_requests(): log_lines = [ '1 Can I change my order?', '1 What are your working hours?', '1 Can I get a refund?' ] assert analyze_conversation_log(log_lines) == (3, 0, 0) def test_analyze_conversation_log_all_complaints(): log_lines = [ '2 The item is broken.', '2 I did not receive my order.', '2 The delivery was very late.' ] assert analyze_conversation_log(log_lines) == (0, 3, 0) def test_analyze_conversation_log_all_suggestions(): log_lines = [ '3 Add more sizes.', '3 Offer more discounts.', '3 Improve your website.' ] assert analyze_conversation_log(log_lines) == (0, 0, 3) def test_analyze_conversation_log_mixed(): log_lines = [ '1 Can I change my order?', '3 Add more sizes.', '2 The item is broken.', '1 I want to cancel my order.', '3 Improve your website.', '2 Delivery is too slow.' ] assert analyze_conversation_log(log_lines) == (2, 2, 2)","solution":"def analyze_conversation_log(log_lines): Analyzes a list of conversation log lines and returns the count of each message type. Args: log_lines (list of str): The list containing the lines from the conversation log. Returns: tuple: A tuple containing three integers (request_count, complaint_count, suggestion_count). request_count = 0 complaint_count = 0 suggestion_count = 0 for line in log_lines: identifier = int(line.split()[0]) if identifier == 1: request_count += 1 elif identifier == 2: complaint_count += 1 elif identifier == 3: suggestion_count += 1 return (request_count, complaint_count, suggestion_count)"},{"question":"from typing import List def max_area(heights: List[int]) -> int: Given a list of integers representing the heights of buildings, return the maximum area of water that can be contained between two buildings. The area of water between two buildings is calculated as the width between the two buildings multiplied by the minimum height of the two buildings. >>> max_area([1, 8, 6, 2, 5, 4, 8, 3, 7]) 49 >>> max_area([0]) 0 >>> max_area([5, 5]) 5 >>> max_area([0, 2, 3, 4, 0, 2, 3]) 12 >>> max_area([5, 4, 3, 2, 1]) 6 >>> max_area([1, 2, 3, 4, 5]) 6","solution":"def max_area(heights): Returns the maximum area of water that can be contained between two buildings. left, right = 0, len(heights) - 1 max_area = 0 while left < right: height = min(heights[left], heights[right]) width = right - left current_area = height * width max_area = max(max_area, current_area) if heights[left] < heights[right]: left += 1 else: right -= 1 return max_area"},{"question":"def min_difference(n: int, weights: List[int]) -> int: Determine the minimum possible absolute difference of the total weights of the two groups. >>> min_difference(4, [1, 2, 3, 4]) 0 >>> min_difference(3, [10, 20, 15]) 5","solution":"def min_difference(n, weights): total_sum = sum(weights) target = total_sum // 2 dp = [0] * (target + 1) for weight in weights: for j in range(target, weight - 1, -1): dp[j] = max(dp[j], dp[j - weight] + weight) return total_sum - 2 * dp[target]"},{"question":"def longest_even_odd_subseq(arr: List[int]) -> int: Jiro and Aoi are stranded on an island, and they want to play a game to keep their spirits up. They have a sequence of n integers, and they want to find the longest contiguous subsequence which has an equal number of even and odd numbers. The function takes in the sequence and returns the length of the longest contiguous subsequence with an equal number of even and odd numbers. Args: arr (List[int]): The list of integers. Returns: int: The length of the longest contiguous subsequence with equal number of even and odd numbers. >>> longest_even_odd_subseq([1, 2, 3, 4, 5, 6, 7]) 6 >>> longest_even_odd_subseq([2, 4, 6, 1, 3, 5]) 6 >>> longest_even_odd_subseq([1, 3, 5, 7, 9]) 0","solution":"def longest_even_odd_subseq(arr): Returns the length of the longest contiguous subsequence with an equal number of even and odd numbers. n = len(arr) # Dictionary to store the first occurrence of each diff value diff_map = {0: -1} max_len = 0 diff = 0 # This will store the difference of counts of even and odd numbers for i in range(n): if arr[i] % 2 == 0: diff += 1 # Even number else: diff -= 1 # Odd number if diff in diff_map: max_len = max(max_len, i - diff_map[diff]) else: diff_map[diff] = i return max_len"},{"question":"def max_beauty_subarray(n: int, beauty_factors: List[int]) -> int: Returns the maximum sum of beauty factors in any contiguous subarray. Parameters: n (int): The number of flowers. beauty_factors (List[int]): A list of integers representing the beauty factors of the flowers. Returns: int: The maximum sum of beauty factors in any contiguous subarray. Examples: >>> max_beauty_subarray(5, [-1, 2, 3, -5, 4]) 5 >>> max_beauty_subarray(4, [-2, -3, -1, -4]) -1","solution":"def max_beauty_subarray(n, beauty_factors): Returns the maximum sum of beauty factors in any contiguous subarray. Parameters: n (int): The number of flowers. beauty_factors (List[int]): A list of integers representing the beauty factors of the flowers. Returns: int: The maximum sum of beauty factors in any contiguous subarray. # Initialize variables max_current = beauty_factors[0] max_global = beauty_factors[0] for i in range(1, n): max_current = max(beauty_factors[i], max_current + beauty_factors[i]) if max_current > max_global: max_global = max_current return max_global"},{"question":"from typing import List, Tuple def longest_safe_subsequence(n: int, dosages: List[int], m: int, toxic_pairs: List[Tuple[int, int]]) -> int: Determine the length of the longest subsequence of capsules that can be taken safely without including any toxic combination. >>> longest_safe_subsequence(5, [3, 5, 7, 8, 10], 3, [(3, 5), (7, 10), (8, 10)]) 3 >>> longest_safe_subsequence(6, [1, 2, 3, 4, 5, 6], 2, [(2, 3), (4, 5)]) 4 >>> longest_safe_subsequence(4, [1, 2, 3, 4], 0, []) 4 >>> longest_safe_subsequence(3, [1, 2, 3], 3, [(1, 2), (2, 3), (1, 3)]) 1 >>> longest_safe_subsequence(5, [3, 5, 7, 8, 10], 2, [(3, 5), (7, 10)]) 3","solution":"from itertools import combinations def longest_safe_subsequence(n, dosages, m, toxic_pairs): toxic_set = set((min(pair), max(pair)) for pair in toxic_pairs) def is_safe(subseq): for i in range(len(subseq)): for j in range(i + 1, len(subseq)): if (min(subseq[i], subseq[j]), max(subseq[i], subseq[j])) in toxic_set: return False return True max_length = 0 for length in range(1, n + 1): for subseq in combinations(dosages, length): if is_safe(subseq): max_length = max(max_length, length) return max_length"},{"question":"def find_minimum_capacity(N: int, M: int, preferences: List[List[int]]) -> int: Determine the minimum capacity limit L such that all participants can attend at least one workshop. >>> find_minimum_capacity(4, 3, [[1, 2, 3], [2, 3, 1], [3, 1, 2], [1, 3, 2]]) 2 >>> find_minimum_capacity(3, 2, [[1, 2], [2, 1], [1, 2]]) 2","solution":"def can_all_attend(preferences, N, M, L): workshop_slots = [0] * M for participant_pref in preferences: for workshop in participant_pref: if workshop_slots[workshop - 1] < L: workshop_slots[workshop - 1] += 1 break return sum(workshop_slots) == N def find_minimum_capacity(N, M, preferences): low, high = 1, N while low < high: mid = (low + high) // 2 if can_all_attend(preferences, N, M, mid): high = mid else: low = mid + 1 return low # Input and output handling part (not strictly needed for the solution definition) def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) M = int(data[1]) preferences = [] idx = 2 for _ in range(N): preferences.append(list(map(int, data[idx:idx + M]))) idx += M print(find_minimum_capacity(N, M, preferences))"},{"question":"def remaining_string_length(s: str) -> int: Return the length of the string after performing all possible deletions of adjacent different characters ('a' and 'b' or 'b' and 'a'). >>> remaining_string_length(\\"abb\\") 1 >>> remaining_string_length(\\"ababa\\") 1","solution":"def remaining_string_length(s): Function to return the length of the string after performing all possible deletions of adjacent different characters ('a' and 'b' or 'b' and 'a'). stack = [] for char in s: if stack and stack[-1] != char: stack.pop() else: stack.append(char) return len(stack)"},{"question":"def can_assign_routes(n, intervals) -> bool: Determine if it's possible to assign the routes to Trucks A and B such that no two routes conflict. Parameters: n (int): The number of delivery routes. intervals (List[Tuple[int, int, int, int]]): A list of tuples where each tuple contains four integers sa_i, ea_i, sb_i, eb_i describing the intervals for the routes if taken by Truck A or Truck B. Returns: bool: True if it's possible to assign the routes to Trucks A and B such that no two routes conflict, False otherwise. Examples: >>> can_assign_routes(3, [(1, 3, 4, 6), (2, 5, 7, 8), (4, 6, 9, 11)]) True >>> can_assign_routes(4, [(1, 4, 2, 5), (3, 5, 3, 6), (4, 7, 1, 3), (8, 10, 9, 11)]) False pass from solution import can_assign_routes def test_possible_single_truck(): assert can_assign_routes(3, [(1, 3, 4, 6), (2, 5, 7, 8), (4, 6, 9, 11)]) == True def test_possible_multiple_trucks_not_needed(): assert can_assign_routes(2, [(1, 3, 4, 6), (4, 6, 7, 8)]) == True def test_impossible(): assert can_assign_routes(4, [(1, 4, 2, 5), (3, 5, 3, 6), (4, 7, 1, 3), (8, 10, 9, 11)]) == False def test_possible_complex_case(): assert can_assign_routes(4, [(1, 2, 4, 5), (3, 4, 6, 7), (5, 6, 8, 9), (7, 8, 10, 11)]) == True def test_possible_with_zero_cases(): assert can_assign_routes(0, []) == True def test_possible_edge_case(): assert can_assign_routes(1, [(1, 2, 3, 4)]) == True","solution":"def can_assign_routes(n, intervals): def can_schedule_non_conflicting(intervals): intervals.sort(key=lambda x: x[1]) # sort by the end time end_time = -1 for start, end in intervals: if start <= end_time: return False end_time = end return True truck_a_intervals = [(sai, eai) for sai, eai, _, _ in intervals] truck_b_intervals = [(sbi, ebi) for _, _, sbi, ebi in intervals] return can_schedule_non_conflicting(truck_a_intervals) or can_schedule_non_conflicting(truck_b_intervals) if __name__ == \\"__main__\\": n = int(input().strip()) intervals = [tuple(map(int, input().strip().split())) for _ in range(n)] result = can_assign_routes(n, intervals) print(\\"Possible\\" if result else \\"Impossible\\")"},{"question":"def are_packets_missing(start: int, end: int, k: int) -> bool: Determines if there are missing packets between two given sequence numbers in a circular manner. Returns True if packets are missing, False otherwise. >>> are_packets_missing(3, 4, 10) False >>> are_packets_missing(9, 0, 10) False >>> are_packets_missing(3, 6, 10) True >>> are_packets_missing(7, 2, 10) True >>> are_packets_missing(0, 0, 10) False >>> are_packets_missing(0, 3, 10) True","solution":"def are_packets_missing(start, end, k): Determines if there are missing packets between two given sequence numbers in a circular manner. Returns True if packets are missing, False otherwise. :param start: The start sequence number :param end: The end sequence number :param k: The total number of sequence numbers in the circular manner :return: Boolean indicating if there are missing packets # Check for direct next packet scenario considering the circular nature of sequence numbers if (end == (start + 1) % k) or (start == end): return False else: return True"},{"question":"def max_subarray_sum(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Finds the maximum subarray sum for each test case. Parameters: T (int): The number of test cases. test_cases (list of tuples): Each tuple contains an integer N and a list of N integers representing the magical energy levels of the runes. Returns: list: A list of integers representing the maximum subarray sum for each test case. Example: >>> max_subarray_sum(3, [(8, [-2, 1, -3, 4, -1, 2, 1, -5, 4]), (1, [5]), (5, [1, 2, 3, -2, 5])]) [6, 5, 9] from solution import max_subarray_sum def test_example_cases(): T = 3 test_cases = [ (8, [-2, 1, -3, 4, -1, 2, 1, -5, 4]), (1, [5]), (5, [1, 2, 3, -2, 5]) ] assert max_subarray_sum(T, test_cases) == [6, 5, 9] def test_single_element_cases(): T = 2 test_cases = [ (1, [-10]), (1, [10]) ] assert max_subarray_sum(T, test_cases) == [-10, 10] def test_all_negative(): T = 3 test_cases = [ (5, [-1, -2, -3, -4, -5]), (4, [-7, -1, -5, -3]), (3, [-100, -200, -300]) ] assert max_subarray_sum(T, test_cases) == [-1, -1, -100] def test_all_positive(): T = 3 test_cases = [ (3, [1, 2, 3]), (4, [1, 2, 3, 4]), (5, [5, 4, 3, 2, 1]) ] assert max_subarray_sum(T, test_cases) == [6, 10, 15] def test_mixed_values(): T = 2 test_cases = [ (6, [3, -2, 5, -1, 4, -2]), (7, [-2, 1, 2, -1, 3, -1, -2]) ] assert max_subarray_sum(T, test_cases) == [9, 5]","solution":"def max_subarray_sum(T, test_cases): Finds the maximum subarray sum for each test case. Parameters: T (int): The number of test cases. test_cases (list of tuples): Each tuple contains an integer N and a list of N integers representing the magical energy levels of the runes. Returns: list: A list of integers representing the maximum subarray sum for each test case. max_sums = [] for i in range(T): N, runes = test_cases[i] max_current = runes[0] max_global = runes[0] for j in range(1, N): max_current = max(runes[j], max_current + runes[j]) if max_current > max_global: max_global = max_current max_sums.append(max_global) return max_sums"},{"question":"def process_string(input_string: str) -> str: Computes the sum of all digit characters in the string and removes all digit characters from the string. Returns the modified string followed by the computed sum. >>> process_string(\\"a1b2c3\\") 'abc 6' >>> process_string(\\"abc\\") 'abc 0' >>> process_string(\\"1234\\") ' 10'","solution":"def process_string(input_string): Computes the sum of all digit characters in the string and removes all digit characters from the string. Returns the modified string followed by the computed sum. sum_of_digits = 0 modified_string = [] for char in input_string: if char.isdigit(): sum_of_digits += int(char) else: modified_string.append(char) return ''.join(modified_string) + ' ' + str(sum_of_digits)"},{"question":"def optimal_expected_average(k: int, scores: List[float]) -> float: Determine the optimal strategy for forming teams that maximizes the average expected score of a team over time. Args: k (int): Number of team members. scores (List[float]): Expected scores for teams with varying number of experienced members. Returns: float: The optimal expected average score per team. Examples: >>> optimal_expected_average(3, [10.0, 20.0, 25.0, 30.0]) 25.000000 >>> optimal_expected_average(3, [5.0, 5.0, 5.0, 5.0]) 5.000000","solution":"def optimal_expected_average(k, scores): Determine the optimal average expected score. :param k: int, number of team members :param scores: list of floats, expected scores for teams with varying number of experienced members :return: float, the optimal expected average score per team # The optimal strategy is to have k-1 members who have participated before. # Thus, we use the second highest score in the list \`scores[k-1]\` return scores[k - 1] # Example usage # k = 3 # scores = [10.0, 20.0, 25.0, 30.0] # print(f\\"{optimal_expected_average(k, scores):.6f}\\") # Output: 25.000000"},{"question":"def longest_palindromic_substring(s: str) -> str: Returns the longest palindromic substring within a given string s. >>> longest_palindromic_substring(\\"babad\\") 'bab' >>> longest_palindromic_substring(\\"cbbd\\") 'bb'","solution":"def longest_palindromic_substring(s): Returns the longest palindromic substring within a given string s. n = len(s) if n == 0: return \\"\\" start = 0 max_length = 1 for i in range(1, n): low = i - 1 high = i while low >= 0 and high < n and s[low] == s[high]: if high - low + 1 > max_length: start = low max_length = high - low + 1 low -= 1 high += 1 low = i - 1 high = i + 1 while low >= 0 and high < n and s[low] == s[high]: if high - low + 1 > max_length: start = low max_length = high - low + 1 low -= 1 high += 1 return s[start:start + max_length]"},{"question":"def find_max_subsequence(arr: List[int]) -> int: Returns the maximum sum of any contiguous subsequence in the array. :param arr: List of integers :return: Integer, maximum subsequence sum >>> find_max_subsequence([3, -2, 5, -1, 4, -10]) 9 >>> find_max_subsequence([-3, -2, -1, -5]) -1 >>> find_max_subsequence([1, 2, 3, -2, 5]) 9 >>> find_max_subsequence([4, -1, 2, 1]) 6","solution":"def find_max_subsequence(arr): Returns the maximum sum of any contiguous subsequence in the array. :param arr: List of integers :return: Integer, maximum subsequence sum if not arr: return 0 max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"def max_berries(n: int, berries: List[int]) -> int: Determines the maximum number of berries that can be gathered by starting from the end bush and skipping exactly one bush in between. Args: n (int): The number of bushes in the forest. berries (list of int): The number of berries on each bush. Returns: int: The maximum number of berries gathered following the rule. Examples: >>> max_berries(4, [4, 1, 2, 7]) 11 >>> max_berries(5, [1, 3, 5, 7, 9]) 15","solution":"def max_berries(n, berries): Determines the maximum number of berries that can be gathered by starting from the end bush and skipping exactly one bush in between. Args: n (int): The number of bushes in the forest. berries (list of int): The number of berries on each bush. Returns: int: The maximum number of berries gathered following the rule. # Edge case where there is only one bush if n == 1: return berries[0] # Initialize two variables to store the max berries without and with skipping the previous bush incl = berries[0] # Include first bush berries excl = 0 # Exclude first bush berries for i in range(1, n): # Current excl will be the max of previous incl and excl new_excl = max(incl, excl) # Current incl will be previous excl plus current berries incl = excl + berries[i] excl = new_excl # Return the maximum of incl and excl return max(incl, excl)"},{"question":"def max_sum_increasing_subsequence(arr): Find the maximum sum of a strictly increasing subsequence in the list. Parameters: arr (list): List of integers. Returns: int: The maximum sum of a strictly increasing subsequence. Examples: >>> max_sum_increasing_subsequence([5]) 5 >>> max_sum_increasing_subsequence([10, 9, 8, 7]) 10 >>> max_sum_increasing_subsequence([10, 5, 4, 3, 11, 6]) 21 >>> max_sum_increasing_subsequence([1, 101, 2, 3, 100, 4, 5]) 106 >>> max_sum_increasing_subsequence([3, 4, 5, 10]) 22 >>> max_sum_increasing_subsequence([5, 5, 5, 5]) 5 >>> max_sum_increasing_subsequence([-1, -2, -3, 4, -5, 6]) 10 >>> max_sum_increasing_subsequence([]) 0","solution":"def max_sum_increasing_subsequence(arr): Find the maximum sum of a strictly increasing subsequence in the list. Parameters: arr (list): List of integers. Returns: int: The maximum sum of a strictly increasing subsequence. n = len(arr) if n == 0: return 0 # Initialize the dp array dp = arr[:] # Build the dp array to find the maximum sum increasing subsequence for i in range(1, n): for j in range(i): if arr[i] > arr[j] and dp[i] < dp[j] + arr[i]: dp[i] = dp[j] + arr[i] # Find the maximum value in dp array return max(dp)"},{"question":"def count_unique_strings(k: int, s: str) -> int: Returns the number of unique strings that can be formed by moving any contiguous substring of length k to the end of the string. >>> count_unique_strings(2, \\"abcda\\") 4 >>> count_unique_strings(3, \\"aaaaa\\") 1 from solution import count_unique_strings def test_example_1(): assert count_unique_strings(2, \\"abcda\\") == 4 def test_example_2(): assert count_unique_strings(3, \\"aaaaa\\") == 1 def test_single_character_move(): assert count_unique_strings(1, \\"abc\\") == 3 def test_entire_string_move(): assert count_unique_strings(3, \\"abc\\") == 1 def test_no_repetition(): assert count_unique_strings(2, \\"abcdef\\") == 5 def test_all_characters_same(): assert count_unique_strings(2, \\"aaaaaa\\") == 1","solution":"def count_unique_strings(k, s): Returns the number of unique strings that can be formed by moving any contiguous substring of length k to the end of the string. unique_strings = set() n = len(s) for i in range(n - k + 1): new_string = s[:i] + s[i+k:] + s[i:i+k] unique_strings.add(new_string) return len(unique_strings)"},{"question":"def max_valley_trees(n: int, heights: List[int]) -> int: Given a list of integers representing the heights of pine trees planted along both sides of a straight road, find the maximum number of trees that form a valley. Args: n (int): the number of trees. heights (List[int]): the heights of the trees. Returns: int: the maximum number of trees that can be arranged to form a valley. Examples: >>> max_valley_trees(7, [5, 3, 1, 2, 4, 6, 7]) 7 >>> max_valley_trees(6, [7, 4, 2, 1, 8, 3]) 5","solution":"def max_valley_trees(n, heights): if n < 3: return 0 left = [1] * n right = [1] * n # Calculate the longest decreasing subsequence length from left to right for i in range(1, n): if heights[i] < heights[i - 1]: left[i] = left[i - 1] + 1 # Calculate the longest increasing subsequence length from right to left for i in range(n - 2, -1, -1): if heights[i] < heights[i + 1]: right[i] = right[i + 1] + 1 max_valley_length = 0 # Find the maximum valley length for i in range(n): if left[i] > 1 and right[i] > 1: max_valley_length = max(max_valley_length, left[i] + right[i] - 1) return max_valley_length"},{"question":"def pair_with_sum_exists(n, x, array): Finds if there exists a pair of elements in the array such that their sum is equal to x. Returns \\"YES\\" if such a pair exists, otherwise returns \\"NO\\". Arguments: n -- integer, number of elements in the array x -- integer, target sum array -- list of integers, the array of distinct integers >>> pair_with_sum_exists(5, 9, [1, 2, 3, 7, 8]) 'YES' >>> pair_with_sum_exists(6, 10, [5, 6, 1, 2, -7, 15]) 'NO' def from_input_string(input_string): lines = input_string.strip().split('n') n, x = map(int, lines[0].split()) array = list(map(int, lines[1].split())) return n, x, array def to_input_string(inputs): n, x, array = inputs return f\\"{n} {x}n{' '.join(map(str, array))}\\" def from_output_string(output_string): return output_string.strip() def to_output_string(output): return output","solution":"def pair_with_sum_exists(n, x, array): Checks if there exists a pair of elements in the array such that their sum is equal to x. Returns \\"YES\\" if such a pair exists, otherwise returns \\"NO\\". nums_seen = set() for num in array: if x - num in nums_seen: return \\"YES\\" nums_seen.add(num) return \\"NO\\" def from_input_string(input_string): lines = input_string.strip().split('n') n, x = map(int, lines[0].split()) array = list(map(int, lines[1].split())) return n, x, array def to_input_string(inputs): n, x, array = inputs return f\\"{n} {x}n{' '.join(map(str, array))}\\" def from_output_string(output_string): return output_string.strip() def to_output_string(output): return output"},{"question":"from typing import List, Tuple def highest_usage_sensor(sensor_logs: List[Tuple[int, int]], timeframe: List[int]) -> int: Determine which sensor has the highest total usage duration within the given timeframe. >>> highest_usage_sensor([(1, 300), (2, 200), (2, 500), (3, 100), (1, 200), (3, 400)], [100, 600]) 2 >>> highest_usage_sensor([(1, 300), (2, 300), (3, 300)], [100, 400]) 1 >>> highest_usage_sensor([(1, 300), (1, 200), (1, 500)], [200, 1000]) 1 >>> highest_usage_sensor([(1, 50), (2, 40), (3, 30)], [100, 200]) is None True >>> highest_usage_sensor([(1, 150), (2, 250), (3, 450), (2, 600), (1, 700)], [100, 500]) 3 pass","solution":"from typing import List, Tuple def highest_usage_sensor(sensor_logs: List[Tuple[int, int]], timeframe: List[int]) -> int: sensor_usage = {} # Filter logs within the timeframe and calculate total usage for each sensor for sensor_id, usage_duration in sensor_logs: if timeframe[0] <= usage_duration <= timeframe[1]: if sensor_id not in sensor_usage: sensor_usage[sensor_id] = 0 sensor_usage[sensor_id] += usage_duration max_duration = -1 highest_sensor_id = None # Determine the sensor with the maximum usage within the timeframe for sensor_id in sorted(sensor_usage.keys()): if sensor_usage[sensor_id] > max_duration: max_duration = sensor_usage[sensor_id] highest_sensor_id = sensor_id return highest_sensor_id"},{"question":"def unique_paths_with_obstacles(m: int, n: int, grid: List[List[str]]) -> int: Calculate the number of unique paths from the top-left corner to the bottom-right corner of a grid. This grid contains obstacles represented by \\"x\\" and empty cells represented by \\"y\\". Args: m (int): the number of rows in the grid n (int): the number of columns in the grid grid (List[List[str]]): the grid itself as a list of lists of strings, with \\"x\\" as obstacles and \\"y\\" as empty cells Returns: int: the number of unique paths from the top-left corner to the bottom-right corner >>> unique_paths_with_obstacles(3, 4, [['y', 'y', 'y', 'y'], ['y', 'x', 'x', 'y'], ['y', 'y', 'y', 'y']]) 4 >>> unique_paths_with_obstacles(2, 2, [['y', 'y'], ['y', 'x']]) 0","solution":"def unique_paths_with_obstacles(m, n, grid): if grid[0][0] == 'x' or grid[m-1][n-1] == 'x': return 0 dp = [[0] * n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 'x': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1]"},{"question":"def max_common_interests(N: int, user_tags: List[List[int]]) -> int: Returns the maximum number of common interest tags shared by any pair of users. Args: N : int : number of users user_tags : list of list of int : users' interest tags Returns: int : maximum number of common interest tags shared by any pair of users def parse_input(input_data: str) -> Tuple[int, List[List[int]]]: Parses the input data. Args: input_data : str : input data where the first line is the number of users and the subsequent lines are the user's interest tags Returns: Tuple[int, List[List[int]]] : Number of users and a list of their interest tags from max_common_interests import max_common_interests, parse_input def test_example_1(): input_data = \\"4n1 2 3 4n2 3 5n1 3 5n2 4 6n\\" N, user_tags = parse_input(input_data) assert max_common_interests(N, user_tags) == 2 def test_no_common_interests(): input_data = \\"3n1 2 3n4 5 6n7 8 9n\\" N, user_tags = parse_input(input_data) assert max_common_interests(N, user_tags) == 0 def test_all_common_interests(): input_data = \\"2n1 2 3n1 2 3n\\" N, user_tags = parse_input(input_data) assert max_common_interests(N, user_tags) == 3 def test_single_user(): input_data = \\"1n1 2 3 4n\\" N, user_tags = parse_input(input_data) assert max_common_interests(N, user_tags) == 0 def test_large_input(): input_data = \\"3n1 2 3 4n2 3 4 5n3 4 5 6n\\" N, user_tags = parse_input(input_data) assert max_common_interests(N, user_tags) == 3","solution":"def max_common_interests(N, user_tags): Returns the maximum number of common interest tags shared by any pair of users. Args: N : int : number of users user_tags : list of list of int : users' interest tags Returns: int : maximum number of common interest tags shared by any pair of users max_common = 0 user_sets = [set(tags) for tags in user_tags] for i in range(N): for j in range(i + 1, N): common_tags = user_sets[i] & user_sets[j] max_common = max(max_common, len(common_tags)) return max_common # Helper function to parse input def parse_input(input_data): data = input_data.split('n') N = int(data[0]) user_tags = [list(map(int, line.split())) for line in data[1:N+1]] return N, user_tags"},{"question":"def min_vehicles_to_transport_packages(num_packages, max_capacity, package_weights): Determines the minimum number of vehicles required to load all the packages considering the maximum weight capacity of each vehicle. >>> min_vehicles_to_transport_packages(5, 10, [2, 3, 4, 5, 6]) 2 >>> min_vehicles_to_transport_packages(1, 10, [5]) 1 >>> min_vehicles_to_transport_packages(3, 10, [2, 3, 5]) 1 >>> min_vehicles_to_transport_packages(6, 10, [2, 8, 6, 7, 3, 4]) 3 >>> min_vehicles_to_transport_packages(5, 10, [10, 10, 10, 10, 10]) 5 >>> min_vehicles_to_transport_packages(4, 10, [3, 3, 3, 3]) 2 >>> min_vehicles_to_transport_packages(50000, 100, [1]*50000) 500 >>> min_vehicles_to_transport_packages(0, 10, []) 0","solution":"def min_vehicles_to_transport_packages(num_packages, max_capacity, package_weights): Returns the minimum number of vehicles required to transport all packages given each vehicle's maximum capacity. package_weights.sort(reverse=True) vehicles = 0 while package_weights: current_vehicle_load = 0 vehicles += 1 for weight in package_weights[:]: if current_vehicle_load + weight <= max_capacity: current_vehicle_load += weight package_weights.remove(weight) return vehicles"},{"question":"def longest_subarray_with_k_distinct(N: int, K: int, A: List[int]) -> int: Find the length of the longest contiguous subarray that contains at most K different integers. >>> longest_subarray_with_k_distinct(6, 2, [1, 2, 1, 2, 3, 3]) # 4 >>> longest_subarray_with_k_distinct(5, 3, [1, 2, 3, 4, 5]) # 3 pass","solution":"def longest_subarray_with_k_distinct(N, K, A): from collections import defaultdict left = 0 right = 0 freq = defaultdict(int) max_length = 0 distinct_count = 0 while right < N: if freq[A[right]] == 0: distinct_count += 1 freq[A[right]] += 1 right += 1 while distinct_count > K: freq[A[left]] -= 1 if freq[A[left]] == 0: distinct_count -= 1 left += 1 max_length = max(max_length, right - left) return max_length"},{"question":"def longest_zero_sum_subsequence(arr: List[int]) -> int: A researcher is studying sequences of numbers and their properties. He is particularly interested in finding the longest contiguous subsequence where the sum of the subsequence is zero. Given a sequence of integers, find the length of such a subsequence. >>> longest_zero_sum_subsequence([0]) == 1 >>> longest_zero_sum_subsequence([1]) == 0 >>> longest_zero_sum_subsequence([1, 2, 3]) == 0 >>> longest_zero_sum_subsequence([1, 2, -3]) == 3 >>> longest_zero_sum_subsequence([1, 2, -3, 1, 2, -2, -2, 3]) == 5 >>> longest_zero_sum_subsequence([1, -1, 2, -2, 3, -3]) == 6 >>> longest_zero_sum_subsequence([1, -1, 1, -1, 1, -1]) == 6 >>> longest_zero_sum_subsequence([1, 2, 3, -3, -2, -1]) == 6","solution":"def longest_zero_sum_subsequence(arr): prefix_sum = 0 prefix_sum_dict = {} max_length = 0 for i, val in enumerate(arr): prefix_sum += val if prefix_sum == 0: max_length = i + 1 if prefix_sum in prefix_sum_dict: max_length = max(max_length, i - prefix_sum_dict[prefix_sum]) else: prefix_sum_dict[prefix_sum] = i return max_length"},{"question":"def minimum_additional_roads(n: int, m: int, roads: List[Tuple[int, int]]) -> int: Compute the minimum number of roads required to ensure that every pair of castles is connected either directly or indirectly. >>> minimum_additional_roads(5, 2, [(1, 2), (3, 4)]) 2 >>> minimum_additional_roads(3, 1, [(1, 2)]) 1 >>> minimum_additional_roads(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) 0 >>> minimum_additional_roads(3, 0, []) 2 >>> minimum_additional_roads(6, 2, [(1, 2), (3, 4)]) 3 >>> minimum_additional_roads(1, 0, []) 0 >>> minimum_additional_roads(5, 6, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1), (1, 3)]) 0","solution":"def count_components(n, roads): parent = list(range(n)) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootX] = rootY for u, v in roads: union(u - 1, v - 1) return len(set(find(x) for x in range(n))) def minimum_additional_roads(n, m, roads): # Count the number of connected components connected_components = count_components(n, roads) # Number of roads to add is number of disjoint components minus 1 return connected_components - 1"},{"question":"from collections import defaultdict import heapq class RoadNetwork: def __init__(self, M): self.M = M self.graph = defaultdict(list) def add_road(self, a, b, c): self.graph[a].append((b, c)) self.graph[b].append((a, c)) def max_capacity(self, a, b): if a == b: return float('inf') max_cap = [0] * (self.M + 1) max_cap[a] = float('inf') pq = [(-float('inf'), a)] while pq: curr_capacity, node = heapq.heappop(pq) curr_capacity = -curr_capacity if node == b: return curr_capacity for neighbor, capacity in self.graph[node]: new_capacity = min(curr_capacity, capacity) if new_capacity > max_cap[neighbor]: max_cap[neighbor] = new_capacity heapq.heappush(pq, (-new_capacity, neighbor)) return 0 def process_queries(M, R, queries): Processes the queries to build the road network and find the maximum capacity between villages. Parameters: M (int): The number of villages. R (int): The number of queries. queries (List[Tuple[int, int, int, int]]): The list of queries. Returns: List[int]: The results of queries of type 1. >>> process_queries(5, 6, [(0, 1, 2, 4), (0, 2, 3, 3), (1, 1, 3, 0), (0, 3, 4, 2), (1, 1, 4, 0), (1, 2, 4, 0), (0, 4, 5, 5)]) [3, 2, 2] >>> process_queries(3, 3, [(1, 1, 2, 0), (0, 1, 2, 5), (1, 1, 3, 0)]) [0, 0] >>> process_queries(4, 3, [(0, 1, 2, 5), (1, 1, 1, 0), (1, 2, 2, 0)]) [float('inf'), float('inf')] >>> process_queries(4, 4, [(0, 1, 2, 1000000000), (0, 2, 3, 1000000000), (0, 3, 4, 1000000000), (1, 1, 4, 0)]) [1000000000]","solution":"from collections import defaultdict import heapq class RoadNetwork: def __init__(self, M): self.M = M self.graph = defaultdict(list) def add_road(self, a, b, c): self.graph[a].append((b, c)) self.graph[b].append((a, c)) def max_capacity(self, a, b): if a == b: return float('inf') max_cap = [0] * (self.M + 1) max_cap[a] = float('inf') pq = [(-float('inf'), a)] while pq: curr_capacity, node = heapq.heappop(pq) curr_capacity = -curr_capacity if node == b: return curr_capacity for neighbor, capacity in self.graph[node]: new_capacity = min(curr_capacity, capacity) if new_capacity > max_cap[neighbor]: max_cap[neighbor] = new_capacity heapq.heappush(pq, (-new_capacity, neighbor)) return 0 def process_queries(M, R, queries): rn = RoadNetwork(M) results = [] for query in queries: t, a, b, c = query if t == 0: rn.add_road(a, b, c) elif t == 1: results.append(rn.max_capacity(a, b)) return results"},{"question":"def most_frequent_character(s: str) -> str: Returns the most frequently occurring character in the string s. In case of a tie, returns the lexicographically smallest character. >>> most_frequent_character(\\"aabbbcc\\") == \\"b\\" >>> most_frequent_character(\\"aabbcc\\") == \\"a\\" >>> most_frequent_character(\\"cccccccc\\") == \\"c\\" >>> most_frequent_character(\\"\\") == \\"\\" >>> most_frequent_character(\\"abcdefghijklmnopqrstuvwxyz\\") == \\"a\\" >>> most_frequent_character(\\"abccbaabccbaaab\\") == \\"a\\"","solution":"def most_frequent_character(s): Returns the most frequently occurring character in the string s. In case of a tie, returns the lexicographically smallest character. # Dictionary to store the frequency of each character frequency = {} # Calculate frequency of each character for char in s: if char in frequency: frequency[char] += 1 else: frequency[char] = 1 # Find the most frequent character max_frequency = -1 most_frequent_char = '' for char in frequency: if frequency[char] > max_frequency or (frequency[char] == max_frequency and char < most_frequent_char): max_frequency = frequency[char] most_frequent_char = char return most_frequent_char"},{"question":"def longest_mountain(prices: List[int]) -> int: Given a list of historical stock prices, determine the length of the longest mountain sequence within that list. If no mountain sequence exists, return 0. A mountain sequence is defined as a contiguous subarray of stock prices such that there exists a peak at some index i in the subarray where: - The stock prices strictly increase from the starting index to the peak index i. - The stock prices strictly decrease from the peak index i to the end of the subarray. >>> longest_mountain([2, 1, 4, 7, 3, 2, 5, 4, 3]) 5 >>> longest_mountain([2, 2, 2, 2, 2]) 0 >>> longest_mountain([1, 2, 3, 4, 5, 6, 5, 4, 3, 2, 1, 0]) 12","solution":"def longest_mountain(prices): Returns the length of the longest mountain sequence in the given list of prices. n = len(prices) if n < 3: return 0 longest = 0 for i in range(1, n - 1): if prices[i - 1] < prices[i] > prices[i + 1]: left = i right = i while left > 0 and prices[left - 1] < prices[left]: left -= 1 while right < n - 1 and prices[right] > prices[right + 1]: right += 1 longest = max(longest, right - left + 1) return longest"},{"question":"def calculate_trapped_water(height: List[int]) -> int: Calculate the total amount of water trapped in the given elevation map. Args: height (list): A list of non-negative integers representing the height of the bars. Returns: int: The total amount of water trapped. Examples: >>> calculate_trapped_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> calculate_trapped_water([2, 0, 2]) 2 >>> calculate_trapped_water([5, 4, 3, 2, 1]) 0","solution":"def calculate_trapped_water(height): Calculate the total amount of water trapped in the given elevation map. Args: height (list): A list of non-negative integers representing the height of the bars. Returns: int: The total amount of water trapped. if not height or len(height) < 3: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - height[i] return trapped_water # Example usage: n = 12 heights = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1] print(calculate_trapped_water(heights)) # Output: 6"},{"question":"def max_non_overlapping_sensors(sensors: list) -> int: Given a list of sensors where each sensor is defined by the coordinates of the top-left and bottom-right corners, determines the maximum number of non-overlapping sensors that can be installed. Parameters: sensors (list of tuples): List of sensors, each defined by a tuple of four integers (x1, y1, x2, y2). Returns: int: Maximum number of non-overlapping sensors. >>> max_non_overlapping_sensors([(1, 1, 4, 4), (2, 2, 5, 5), (6, 6, 8, 8)]) 2 >>> max_non_overlapping_sensors([(1, 1, 3, 3), (2, 2, 5, 5), (4, 4, 6, 6), (5, 1, 7, 3), (8, 8, 10, 10)]) 3","solution":"def max_non_overlapping_sensors(sensors): Given a list of sensors where each sensor is defined by the coordinates of the top-left and bottom-right corners, determines the maximum number of non-overlapping sensors that can be installed. Parameters: sensors (list of tuples): List of sensors, each defined by a tuple of four integers (x1, y1, x2, y2). Returns: int: Maximum number of non-overlapping sensors. # Sort the sensors by their bottom-right x coordinate (x2), and in case of tie by y2 sensors.sort(key=lambda sensor: (sensor[2], sensor[3])) count = 0 last_x2, last_y2 = -1, -1 for sensor in sensors: x1, y1, x2, y2 = sensor # Check if current sensor does not overlap with the last placed sensor if x1 > last_x2 or y1 > last_y2: count += 1 last_x2, last_y2 = x2, y2 return count"},{"question":"def can_arrange_paintings(N, paintings): Determine if the paintings can be arranged such that no two consecutive paintings have the same height. Parameters: N (int): Number of paintings paintings (list of tuples): Each tuple contains two integers, (height, width) of each painting. Returns: str: \\"YES\\" if the arrangement is possible, otherwise \\"NO\\". # Example usage: # >>> can_arrange_paintings(4, [(2, 5), (3, 6), (2, 8), (4, 3)]) # \\"YES\\" # >>> can_arrange_paintings(4, [(2, 5), (3, 6), (3, 8), (4, 3)]) # \\"NO\\"","solution":"def can_arrange_paintings(N, paintings): Determine if the paintings can be arranged such that no two consecutive paintings have the same height. Parameters: N (int): Number of paintings paintings (list of tuples): Each tuple contains two integers, (height, width) of each painting. Returns: str: \\"YES\\" if the arrangement is possible, otherwise \\"NO\\". heights = [painting[0] for painting in paintings] # Traverse through the list and check if consecutive heights are the same for i in range(N-1): if heights[i] == heights[i + 1]: return \\"NO\\" return \\"YES\\" # Example usage: N = 4 paintings = [(2, 5), (3, 6), (2, 8), (4, 3)] print(can_arrange_paintings(N, paintings)) # Output: YES"},{"question":"def can_form(s: str, word: str) -> bool: Checks if 'word' can be formed by deleting some characters of 's' without reordering the remaining characters. >>> can_form(\\"abpcplea\\", \\"apple\\") True >>> can_form(\\"abpcplea\\", \\"ale\\") True >>> can_form(\\"abpcplea\\", \\"monkey\\") False >>> can_form(\\"abc\\", \\"ac\\") True pass def words_from_string(s: str, words: List[str]) -> List[str]: Finds all words from the list that can be formed by deleting some characters of 's' without reordering the remaining characters. >>> words_from_string(\\"abpcplea\\", [\\"apple\\", \\"ale\\", \\"monkey\\"]) [\\"apple\\", \\"ale\\"] >>> words_from_string(\\"abcd\\", [\\"a\\", \\"b\\", \\"ab\\", \\"bd\\", \\"xyz\\"]) [\\"a\\", \\"b\\", \\"ab\\", \\"bd\\"] >>> words_from_string(\\"xyz\\", [\\"a\\", \\"b\\", \\"xyz\\"]) [\\"xyz\\"] >>> words_from_string(\\"abcde\\", [\\"ace\\", \\"bd\\", \\"e\\", \\"abcdef\\"]) [\\"ace\\", \\"bd\\", \\"e\\"] pass def solution(): Reads input, processes it and prints results. pass","solution":"def can_form(s, word): Checks if 'word' can be formed by deleting some characters of 's' without reordering the remaining characters. it = iter(s) return all(char in it for char in word) def words_from_string(s, words): Finds all words from the list that can be formed by deleting some characters of 's' without reordering the remaining characters. result = [] for word in words: if can_form(s, word): result.append(word) return result def solution(): s = input().strip() n = int(input().strip()) words = [input().strip() for _ in range(n)] result = words_from_string(s, words) for word in result: print(word)"},{"question":"import bisect from collections import defaultdict from typing import List, Tuple, Union class InventoryManagementSystem: A class to manage the inventory levels of products with version control. def __init__(self, n: int): # Initialize the inventory management system with 'n' products. pass def update(self, product_id: int, timestamp: int, level: int) -> None: Update the inventory level of a product at a specific time. pass def query(self, product_id: int, timestamp: int) -> Union[int, str]: Query the inventory level of a product at a particular timestamp. >>> ims = InventoryManagementSystem(5) >>> ims.update(1, 5, 100) >>> ims.update(3, 3, 50) >>> ims.update(1, 10, 300) >>> ims.query(1, 7) 100 >>> ims.query(3, 2) 'No record' >>> ims.query(3, 4) 50 pass def manage_inventory(n: int, operations: List[Tuple[str, int, int, int]]) -> List[Union[int, str]]: Manage inventory operations and process updates and queries. >>> manage_inventory(5, [(\\"update\\", 1, 5, 100), (\\"update\\", 3, 3, 50), (\\"update\\", 1, 10, 300), (\\"query\\", 1, 7), (\\"query\\", 3, 2), (\\"query\\", 3, 4)]) [100, 'No record', 50] results = [] ims = InventoryManagementSystem(n) for operation in operations: if operation[0] == 'update': _, product_id, timestamp, level = operation ims.update(product_id, timestamp, level) elif operation[0] == 'query': _, product_id, timestamp = operation result = ims.query(product_id, timestamp) results.append(result) return results","solution":"import bisect from collections import defaultdict class InventoryManagementSystem: def __init__(self, n): self.n = n self.history = defaultdict(list) def update(self, product_id, timestamp, level): self.history[product_id].append((timestamp, level)) def query(self, product_id, timestamp): if product_id not in self.history: return \\"No record\\" timestamps = [t for t, l in self.history[product_id]] pos = bisect.bisect_right(timestamps, timestamp) if pos == 0: return \\"No record\\" return self.history[product_id][pos - 1][1] def manage_inventory(n, operations): ims = InventoryManagementSystem(n) results = [] for operation in operations: if operation[0] == \\"update\\": _, product_id, timestamp, level = operation ims.update(product_id, timestamp, level) elif operation[0] == \\"query\\": _, product_id, timestamp = operation result = ims.query(product_id, timestamp) results.append(result) return results"},{"question":"def max_teams(n, skill_levels): Determines the maximum number of teams that can be formed based on the given rules. Args: n (int): The number of participants. skill_levels (list of int): The skill levels of the participants. Returns: int: The maximum number of teams that can be formed. Examples: >>> max_teams(6, [1, 5, 3, 3, 2, 4]) 2 >>> max_teams(4, [1, 4, 7, 10]) 0 >>> max_teams(9, [1, 2, 3, 4, 5, 6, 7, 8, 9]) 3","solution":"def max_teams(n, skill_levels): Determines the maximum number of teams that can be formed based on the given rules. Args: n (int): The number of participants. skill_levels (list of int): The skill levels of the participants. Returns: int: The maximum number of teams that can be formed. skill_levels.sort() i = 0 teams_count = 0 while i + 2 < n: if skill_levels[i + 2] - skill_levels[i] <= 2: teams_count += 1 i += 3 else: i += 1 return teams_count"},{"question":"from typing import List, Tuple def minimum_bomb_detonations(n: int, roads: List[Tuple[int, int]]) -> int: Calculate the minimum number of bomb detonations required to destroy all cities. >>> minimum_bomb_detonations(5, [(1, 2), (2, 3), (4, 5)]) 2 >>> minimum_bomb_detonations(4, []) 4 >>> minimum_bomb_detonations(1, []) 1 >>> minimum_bomb_detonations(4, [(1, 2), (2, 3), (3, 4)]) 1 >>> minimum_bomb_detonations(6, [(1, 2), (3, 4), (5, 6)]) 3","solution":"def minimum_bomb_detonations(n, roads): def dfs(city, graph, visited): stack = [city] while stack: node = stack.pop() for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True stack.append(neighbor) from collections import defaultdict graph = defaultdict(list) for v, w in roads: graph[v].append(w) graph[w].append(v) visited = [False] * (n + 1) components = 0 for city in range(1, n + 1): if not visited[city]: visited[city] = True dfs(city, graph, visited) components += 1 return components"},{"question":"def can_traverse(n: int, m: int, grid: List[str]) -> str: Determine if it's possible to traverse from the top-left corner to the bottom-right corner without stepping on any asterisks. :param n: Number of rows in the grid :param m: Number of columns in the grid :param grid: List of strings representing the grid, with '.' or '*' :return: \\"YES\\" if traversal is possible, otherwise \\"NO\\" >>> can_traverse(3, 3, ['.*.', '...', '*..']) 'YES' >>> can_traverse(3, 3, ['*..', '.*.', '...']) 'NO' >>> can_traverse(2, 2, ['.*', '*.' ]) 'NO' >>> can_traverse(4, 4, ['....', '.*..', '....', '.*..']) 'YES' >>> can_traverse(1, 1, ['*']) 'NO' >>> can_traverse(1, 1, ['.']) 'YES' >>> can_traverse(3, 4, ['....', '****', '....']) 'NO'","solution":"def can_traverse(n, m, grid): Determine if it's possible to traverse from the top-left corner to the bottom-right corner without stepping on any asterisks. :param n: Number of rows in the grid :param m: Number of columns in the grid :param grid: List of strings representing the grid, with '.' or '*' :return: \\"YES\\" if traversal is possible, otherwise \\"NO\\" from collections import deque if grid[0][0] == '*' or grid[n-1][m-1] == '*': return \\"NO\\" directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] visited = [[False] * m for _ in range(n)] queue = deque([(0, 0)]) visited[0][0] = True while queue: x, y = queue.popleft() if x == n-1 and y == m-1: return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and grid[nx][ny] == '.': visited[nx][ny] = True queue.append((nx, ny)) return \\"NO\\""},{"question":"def min_operations(seq1: str, seq2: str) -> int: Compute the minimum number of operations required to convert seq1 into seq2. Allowed operations are insert a character, delete a character, or replace a character. Uses dynamic programming to solve the problem. >>> min_operations(\\"kitten\\", \\"sitting\\") 3 >>> min_operations(\\"flaw\\", \\"lawn\\") 2 >>> min_operations(\\"abc\\", \\"abcd\\") 1 >>> min_operations(\\"\\", \\"\\") 0 >>> min_operations(\\"a\\", \\"a\\") 0 >>> min_operations(\\"a\\", \\"b\\") 1 >>> min_operations(\\"abcdef\\", \\"ghijk\\") 6 >>> min_operations(\\"aaa\\", \\"aa\\") 1 >>> min_operations(\\"\\", \\"a\\") 1 >>> min_operations(\\"a\\", \\"\\") 1 pass def process_test_cases(test_cases: List[Tuple[str, str]]) -> List[int]: Process multiple test cases and return a list of results for each test case. >>> process_test_cases([(\\"kitten\\", \\"sitting\\"), (\\"flaw\\", \\"lawn\\"), (\\"abc\\", \\"abcd\\")]) [3, 2, 1] >>> process_test_cases([(\\"abcdef\\", \\"ghijkl\\"), (\\"apple\\", \\"aple\\"), (\\"spelling\\", \\"spelling\\")]) [6, 1, 0] >>> process_test_cases([(\\"\\", \\"\\"), (\\"a\\", \\"\\"), (\\"\\", \\"a\\")]) [0, 1, 1] pass","solution":"def min_operations(seq1, seq2): Compute the minimum number of operations required to convert seq1 into seq2. Allowed operations are insert a character, delete a character, or replace a character. Uses dynamic programming to solve the problem. m = len(seq1) n = len(seq2) # Create a table to store results of subproblems dp = [[0 for x in range(n + 1)] for x in range(m + 1)] # Fill dp table for i in range(m + 1): for j in range(n + 1): # If seq1 is empty, we need to insert all characters of seq2 if i == 0: dp[i][j] = j # Minimum operations = j # If seq2 is empty, we need to delete all characters of seq1 elif j == 0: dp[i][j] = i # Minimum operations = i # If the characters are same, no operation is required elif seq1[i - 1] == seq2[j - 1]: dp[i][j] = dp[i - 1][j - 1] # If the characters are different, consider all possibilities and find the minimum else: dp[i][j] = 1 + min(dp[i][j - 1], # Insert dp[i - 1][j], # Remove dp[i - 1][j - 1]) # Replace return dp[m][n] def process_test_cases(test_cases): results = [] for seq1, seq2 in test_cases: results.append(min_operations(seq1, seq2)) return results"},{"question":"def can_form_palindrome(s: str) -> bool: Checks if any permutation of the string s can form a palindrome. Parameters: s (str): Input string containing only lowercase English letters. Returns: bool: True if any permutation of s can form a palindrome, False otherwise. >>> can_form_palindrome(\\"aabb\\") True >>> can_form_palindrome(\\"abc\\") False >>> can_form_palindrome(\\"carerac\\") True","solution":"from collections import Counter def can_form_palindrome(s): Checks if any permutation of the string s can form a palindrome. Parameters: s (str): Input string containing only lowercase English letters. Returns: bool: True if any permutation of s can form a palindrome, False otherwise. # Count the frequency of each character in the string char_count = Counter(s) # Count how many characters have an odd frequency odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # For a string to be able to form a palindrome, it can have at most one character with an odd frequency return odd_count <= 1"},{"question":"def min_water_stations(D: int, M: int) -> int: Determines the minimum number of water stations required for a marathon. Participants have a maximum distance they can run without needing water. Parameters: D (int): Total distance of the marathon. M (int): Maximum distance a participant can run without water. Returns: int: Minimum number of water stations needed. >>> min_water_stations(42, 10) 4 >>> min_water_stations(100, 20) 4 >>> min_water_stations(30, 15) 1 >>> min_water_stations(1, 1) 0 # Test cases to validate the solution def test_min_water_stations(): assert min_water_stations(42, 10) == 4 assert min_water_stations(100, 20) == 4 assert min_water_stations(30, 30) == 0 assert min_water_stations(1, 1) == 0 assert min_water_stations(15, 20) == 0 assert min_water_stations(30, 15) == 1 assert min_water_stations(17, 10) == 1 assert min_water_stations(1000000000, 1000000) == 999 assert min_water_stations(1000000000, 500000000) == 1 assert min_water_stations(10**9, 1) == 999999999 assert min_water_stations(1, 10**9) == 0","solution":"def min_water_stations(D, M): Determines the minimum number of water stations required for a marathon. Parameters: D (int): Total distance of the marathon. M (int): Maximum distance a participant can run without water. Returns: int: Minimum number of water stations needed. if D <= M: return 0 return (D + M - 1) // M - 1"},{"question":"def is_path_possible(n: int, k: int, kingdom: List[List[int]]) -> str: Determines if there exists a path from the top-left corner to the bottom-right corner of the matrix where the difference in heights between consecutive cells does not exceed k. Args: n (int): The size of the matrix (nxn). k (int): The maximum allowed difference in heights between consecutive cells. kingdom (List[List[int]]): The matrix representing heights within the kingdom. Returns: str: \\"YES\\" if such a path exists, otherwise \\"NO\\". Examples: >>> is_path_possible(3, 2, [[1, 3, 2], [6, 5, 4], [7, 8, 5]]) 'YES' >>> is_path_possible(3, 1, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 'NO'","solution":"def is_path_possible(n, k, kingdom): from collections import deque directions = [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)] def is_valid(x, y, height): return 0 <= x < n and 0 <= y < n and not visited[x][y] and abs(kingdom[x][y] - height) <= k visited = [[False] * n for _ in range(n)] queue = deque([(0, 0)]) visited[0][0] = True while queue: x, y = queue.popleft() if x == n - 1 and y == n - 1: return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny, kingdom[x][y]): visited[nx][ny] = True queue.append((nx, ny)) return \\"NO\\""},{"question":"def find_most_consistent_performer(test_cases: List[Tuple[int, List[List[int]]]]) -> List[int]: Returns the 1-based index of the employee with the most consistent performance based on quarterly scores. Args: test_cases: List of tuples, where each tuple contains: - An integer n, the number of employees - A list of n lists, each containing 4 integers representing quarterly scores Returns: List of integers representing the index of the most consistent performer for each test case >>> find_most_consistent_performer([(3, [[90, 80, 85, 95], [85, 85, 85, 85], [80, 90, 70, 60]])]) [2] >>> find_most_consistent_performer([(2, [[75, 75, 75, 75], [80, 80, 90, 70]])]) [1]","solution":"def find_most_consistent_performer(test_cases): Returns the 1-based index of the employee with the most consistent performance based on quarterly scores. Args: test_cases: List of tuples, where each tuple contains: - An integer n, the number of employees - A list of n lists, each containing 4 integers representing quarterly scores Returns: List of integers representing the index of the most consistent performer for each test case def variance(scores): Calculate the variance of 4 quarterly scores. average = sum(scores) / 4 return sum((x - average) ** 2 for x in scores) / 4 results = [] for test in test_cases: n, scores_list = test consistencies = [(variance(scores), index + 1) for index, scores in enumerate(scores_list)] # Select the employee with the lowest variance most_consistent = min(consistencies, key=lambda x: (x[0], x[1])) results.append(most_consistent[1]) return results"},{"question":"def maximalRectangleArea(grid: List[str]) -> int: Find the largest rectangular area consisting of only empty cells in a rectangular grid. >>> maximalRectangleArea([ ... \\".T...\\", ... \\".TTT.\\", ... \\"...TT\\", ... \\".....\\" ... ]) 6 >>> maximalRectangleArea([ ... \\"T..T\\", ... \\".TT.\\", ... \\"....\\", ... \\"T.TT\\" ... ]) 4 >>> maximalRectangleArea([ ... \\"TTTT\\", ... \\"TTTT\\", ... \\"TTTT\\" ... ]) 0 >>> maximalRectangleArea([ ... \\"...\\", ... \\"...\\", ... \\"...\\" ... ]) 9","solution":"def maximalRectangleArea(grid): if not grid: return 0 # Transform the grid into a list of lists with 0s and 1s matrix = [[0 if cell == 'T' else 1 for cell in row] for row in grid] n = len(matrix) m = len(matrix[0]) # Initialize the histogram heights heights = [0] * m max_area = 0 for i in range(n): for j in range(m): if matrix[i][j] == 0: heights[j] = 0 else: heights[j] += 1 # Update max_area with the maximum area in histogram max_area = max(max_area, maxHistogramArea(heights)) return max_area def maxHistogramArea(heights): stack = [] max_area = 0 heights.append(0) # Append a zero height to ensure the stack gets emptied at the end for i in range(len(heights)): while stack and heights[i] < heights[stack[-1]]: h = heights[stack.pop()] w = i if not stack else i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) heights.pop() # Remove the appended zero height return max_area"},{"question":"def merge_intervals(intervals: List[List[int]]) -> List[List[int]]: Given a collection of intervals, merge all overlapping intervals. Args: intervals (List[List[int]]): A list of intervals, where each interval is a pair of integers [start, end]. Returns: List[List[int]]: A list of merged intervals, sorted by their start value. Examples: >>> merge_intervals([[1, 3], [2, 6], [8, 10], [15, 18]]) [[1, 6], [8, 10], [15, 18]] >>> merge_intervals([[1, 4], [4, 5]]) [[1, 5]] >>> merge_intervals([[1, 3], [4, 6], [7, 9]]) [[1, 3], [4, 6], [7, 9]]","solution":"def merge_intervals(intervals): Task: Given a collection of intervals, merge all overlapping intervals. Args: intervals (List[List[int]]): A list of intervals, where each interval is a pair of integers [start, end]. Returns: List[List[int]]: A list of merged intervals, sorted by their start value. if not intervals: return [] # Sort the intervals by their starting point intervals.sort(key=lambda x: x[0]) merged = [] for interval in intervals: # if the list of merged intervals is empty or if the current interval does not overlap with the previous one, append it if not merged or merged[-1][1] < interval[0]: merged.append(interval) else: # otherwise, there is an overlap, so we merge the current and previous intervals merged[-1][1] = max(merged[-1][1], interval[1]) return merged"},{"question":"def calculate_weighted_sum(n: int, sequence: List[int], queries: List[Tuple[int, int]]) -> List[int]: Given a sequence of n integers and q queries, returns the weighted sum of elements for each query. Args: - n (int): The size of the sequence. - sequence (List[int]): The sequence of integers. - queries (List[Tuple[int, int]]): A list of queries, each query is a tuple (l, r). Returns: - List[int]: A list of results for each query. Examples: >>> n = 5 >>> sequence = [1, 2, 3, 4, 5] >>> queries = [(1, 3), (2, 4), (1, 5)] >>> calculate_weighted_sum(n, sequence, queries) [14, 29, 55] >>> n = 4 >>> sequence = [10, 20, 30, 40] >>> queries = [(1, 2), (3, 4)] >>> calculate_weighted_sum(n, sequence, queries) [50, 250]","solution":"def calculate_weighted_sum(n, sequence, queries): Given a sequence of n integers and q queries, returns the weighted sum of elements for each query. results = [] for l, r in queries: result = sum(sequence[i-1] * i for i in range(l, r + 1)) results.append(result) return results"},{"question":"def longest_odd_sum_subarray(n: int, arr: List[int]) -> int: Find the length of the longest subarray with an odd sum. >>> longest_odd_sum_subarray(5, [3, 2, 4, 1, 5]) 5 >>> longest_odd_sum_subarray(4, [2, 4, 6, 8]) 0 >>> longest_odd_sum_subarray(3, [1, 2, 3]) 3 pass # Test cases def test_case_1(): assert longest_odd_sum_subarray(5, [3, 2, 4, 1, 5]) == 5 def test_case_2(): assert longest_odd_sum_subarray(4, [2, 4, 6, 8]) == 0 def test_case_3(): assert longest_odd_sum_subarray(3, [1, 2, 3]) == 3 def test_case_4(): assert longest_odd_sum_subarray(3, [1, 1, 1]) == 3 def test_case_5(): assert longest_odd_sum_subarray(5, [1, 2, 3, 4, 6]) == 5 def test_case_6(): assert longest_odd_sum_subarray(5, [2, 4, 6, 8, 10]) == 0 def test_case_7(): assert longest_odd_sum_subarray(2, [1, 2]) == 2","solution":"def longest_odd_sum_subarray(n, arr): odd_count = sum(1 for x in arr if x % 2 != 0) even_count = n - odd_count if odd_count == 0: return 0 # No odd numbers, no odd sum subarray possible if even_count % 2 == 0 and odd_count % 2 == 0: return n - 1 # Both counts even means total sum must be even, remove one element for odd sum return n # Otherwise, we can use the whole array"},{"question":"def find_median(N, numbers): Finds and returns the median of a list of numbers. If the list contains an even number of elements, the median is the average of the two middle numbers. pass from solution import find_median def test_find_median_odd_count(): assert find_median(5, [2, 3, 1, 4, 5]) == 3 def test_find_median_even_count(): assert find_median(4, [1, 2, 3, 4]) == 2.5 def test_find_median_single_element(): assert find_median(1, [1000]) == 1000 def test_find_median_two_elements(): assert find_median(2, [1, 3]) == 2.0 def test_find_median_with_negative_numbers(): assert find_median(5, [-3, -1, -2, -4, -5]) == -3 assert find_median(4, [-4, -2, -3, -1]) == -2.5 def test_find_median_mixed_numbers(): assert find_median(5, [-1, 0, 1, 2, 3]) == 1 assert find_median(6, [-2, -1, 0, 1, 2, 3]) == 0.5 def test_find_median_large_numbers(): assert find_median(3, [1000000, 1000, -1000000]) == 1000 assert find_median(4, [500000, 1000000, 1500000, 2000000]) == 1250000","solution":"def find_median(N, numbers): Finds and returns the median of a list of numbers. If the list contains an even number of elements, the median is the average of the two middle numbers. sorted_numbers = sorted(numbers) middle_index = N // 2 if N % 2 == 1: # If odd, return the middle number median = sorted_numbers[middle_index] else: # If even, return the average of the two middle numbers median = (sorted_numbers[middle_index - 1] + sorted_numbers[middle_index]) / 2 if median % 1 == 0: return int(median) else: return float(\\"{:.1f}\\".format(median))"},{"question":"def max_pages(n: int, P: int, pages: List[int]) -> int: Determines the maximum number of pages that can be selected without exceeding the given limit P and with the fewest number of books. :param n: int: Number of books. :param P: int: Maximum allowable total number of pages. :param pages: List[int]: A list containing the number of pages in each book. :return: int: Maximum number of pages that can be selected. >>> max_pages(5, 1500, [500, 700, 300, 200, 600]) 1500 >>> max_pages(4, 750, [400, 400, 500, 300]) 700 >>> max_pages(1, 100, [50]) 50","solution":"def max_pages(n, P, pages): Determines the maximum number of pages that can be selected without exceeding the given limit P and with the fewest number of books. :param n: int: Number of books. :param P: int: Maximum allowable total number of pages. :param pages: List[int]: A list containing the number of pages in each book. :return: int: Maximum number of pages that can be selected. # Use dynamic programming to solve the subset sum problem with the additional constraint. dp = [0] * (P + 1) for page in pages: for j in range(P, page - 1, -1): dp[j] = max(dp[j], dp[j - page] + page) return dp[P]"},{"question":"class SegmentTree: def __init__(self, array): Initialize the Segment Tree. def build(self, array): Build the Segment Tree. def update(self, pos, value): Update the value at a specific position in the Segment Tree. def sum_range(self, l, r): Compute the sum of elements within a specific range. def process_operations(n, sequence, operations): Process a list of operations on a sequence of integers. Parameters: n: int Number of integers in the sequence. sequence: List[int] Initial values of the sequence. operations: List[Tuple[int, int, int]] List of operations to be performed. Returns: List[int]: Results of the sum operations. Example: >>> n = 5 >>> sequence = [1, 2, 3, 4, 5] >>> operations = [(2, 1, 3), (1, 3, 10), (2, 2, 5), (1, 5, 20), (2, 1, 5)] >>> process_operations(n, sequence, operations) [6, 39, 33]","solution":"class SegmentTree: def __init__(self, array): self.n = len(array) self.tree = [0] * (2 * self.n) self.build(array) def build(self, array): # Insert leaf nodes in tree for i in range(self.n): self.tree[self.n + i] = array[i] # Build the tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1] def update(self, pos, value): # Change the index to leaf pos += self.n # Update the value at the leaf node self.tree[pos] = value # Update the values of nodes in the path while pos > 1: pos //= 2 self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1] def sum_range(self, l, r): # Change indices to leaf nodes l += self.n r += self.n sum_val = 0 while l <= r: if l % 2 == 1: sum_val += self.tree[l] l += 1 if r % 2 == 0: sum_val += self.tree[r] r -= 1 l //= 2 r //= 2 return sum_val def process_operations(n, sequence, operations): seg_tree = SegmentTree(sequence) result = [] for operation in operations: if operation[0] == 1: seg_tree.update(operation[1] - 1, operation[2]) elif operation[0] == 2: result.append(seg_tree.sum_range(operation[1] - 1, operation[2] - 1)) return result"},{"question":"def calculate_max_sum(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Calculate the maximum possible sum of the frequencies of the selected keys for the desired melody. Args: t (int): The number of test cases. test_cases (List[Tuple[int, int, List[int]]]): A list of test cases, each containing: n (int): The number of keys on the xylophone. m (int): The length of the desired melody. frequencies (List[int]): The frequencies of the keys. Returns: List[int]: A list containing the maximum possible sum of the frequencies of the selected keys for each test case. Example: >>> t = 2 >>> test_cases = [(5, 3, [10, 20, 30, 40, 50]), (4, 2, [15, 25, 35, 45])] >>> calculate_max_sum(t, test_cases) [120, 80]","solution":"def calculate_max_sum(t, test_cases): results = [] for i in range(t): n, m, frequencies = test_cases[i] # Sort the frequencies in descending order to select the m highest frequencies frequencies.sort(reverse=True) # Sum the m highest frequencies max_sum = sum(frequencies[:m]) results.append(max_sum) return results"},{"question":"def find_indices_with_sum(nums, target): Determines if there are two distinct indices i and j in the list such that the sum of the integers at these indices equals the target. >>> find_indices_with_sum([2, 7, 11, 15, 1], 9) 'YES' >>> find_indices_with_sum([1, 2, 3, 4], 8) 'NO' >>> find_indices_with_sum([-109, 109], 0) 'YES' >>> find_indices_with_sum([-1, -2, -3, -4], -6) 'YES' >>> find_indices_with_sum([1000000000, 500000000, 1500000000], 2500000000) 'YES' >>> find_indices_with_sum([2, 4, 3, 6], 7) 'YES' >>> find_indices_with_sum([3, 2, -3, 1], 0) 'YES' >>> find_indices_with_sum([5, 6, 7, 8], 20) 'NO'","solution":"def find_indices_with_sum(nums, target): Determines if there are two distinct indices i and j in the list such that the sum of the integers at these indices equals the target. seen = set() for num in nums: if target - num in seen: return \\"YES\\" seen.add(num) return \\"NO\\""},{"question":"from typing import List, Tuple def minimal_travel_time(N: int, M: int, tunnels: List[Tuple[int, int, int, int]], K: int, sequence: List[int]) -> int: Determines the minimum total travel time for a group of travelers to journey through a series of castles following a particular order given the constraints of tunnel cooldowns. Parameters: - N (int): Number of castles - M (int): Number of tunnels - tunnels (List[Tuple[int, int, int, int]]): List of tuples representing tunnels between castles where each tuple contains (u: int, v: int, t: int, c: int) - K (int): Number of stops the travelers need to make - sequence (List[int]): Sequence of castles to be visited Returns: - int: Minimum time required for the travelers to complete their journey Example: >>> minimal_travel_time(4, 5, [(1, 2, 10, 5), (1, 3, 20, 0), (2, 4, 15, 0), (3, 4, 30, 0), (1, 4, 25, 10)], 3, [1, 3, 4]) 50 >>> minimal_travel_time(3, 3, [(1, 2, 10, 0), (2, 3, 20, 0), (1, 3, 25, 5)], 2, [1, 3]) 25 >>> minimal_travel_time(5, 6, [(1, 2, 5, 0), (2, 3, 10, 0), (1, 3, 15, 0), (3, 4, 5, 0), (4, 5, 10, 0), (3, 5, 15, 0)], 4, [1, 2, 3, 5]) 30 >>> minimal_travel_time(4, 4, [(1, 2, 15, 5), (2, 3, 15, 10), (1, 3, 10, 5), (3, 4, 10, 0)], 3, [1, 3, 4]) 20","solution":"def minimal_travel_time(N, M, tunnels, K, sequence): from heapq import heappop, heappush from collections import defaultdict import sys adj = defaultdict(list) for u, v, t, c in tunnels: adj[u].append((v, t, c)) adj[v].append((u, t, c)) def dijkstra(start, end): heap = [(0, start, 0)] visited = {} while heap: travel_time, current, cooldown = heappop(heap) if (current, cooldown) in visited and visited[(current, cooldown)] <= travel_time: continue visited[(current, cooldown)] = travel_time if current == end: return travel_time for neighbor, travel_cost, cooldown_period in adj[current]: next_time = travel_time + travel_cost if next_time < visited.get((neighbor, cooldown_period), sys.maxsize): heappush(heap, (next_time, neighbor, cooldown_period)) return sys.maxsize total_time = 0 for i in range(K - 1): total_time += dijkstra(sequence[i], sequence[i + 1]) return total_time"},{"question":"def maxProfit(prices: List[int]) -> int: Given a sequence of integers, representing the stock prices of a company over consecutive days, find the maximum profit you can achieve by making at most two transactions. A transaction is defined by buying and then selling one share of the stock. It is not allowed to engage in multiple transactions at the same time (you must sell the stock before you buy again). Examples: >>> maxProfit([3,3,5,0,0,3,1,4]) 6 >>> maxProfit([1,2,3,4,5]) 4 >>> maxProfit([7,6,4,3,1]) 0 >>> maxProfit([1]) 0","solution":"def maxProfit(prices): if not prices or len(prices) == 1: return 0 n = len(prices) # Initialization first_buy = float('-inf') first_sell = 0 second_buy = float('-inf') second_sell = 0 for price in prices: first_buy = max(first_buy, -price) first_sell = max(first_sell, first_buy + price) second_buy = max(second_buy, first_sell - price) second_sell = max(second_sell, second_buy + price) return max(second_sell, 0)"},{"question":"def two_sum_exists(n: int, nums: List[int], k: int) -> str: Determine if there exist two distinct indices i and j in the list such that nums[i] + nums[j] = k. Returns \\"YES\\" if such indices exist, otherwise \\"NO\\". >>> two_sum_exists(5, [1, 2, 3, 4, 5], 9) \\"YES\\" >>> two_sum_exists(4, [1, 2, 3, 9], 8) \\"NO\\"","solution":"def two_sum_exists(n, nums, k): Returns \\"YES\\" if there exist two distinct indices i and j in the nums list such that nums[i] + nums[j] = k. Otherwise, returns \\"NO\\". seen = set() for num in nums: if k - num in seen: return \\"YES\\" seen.add(num) return \\"NO\\""},{"question":"def levenshtein_distance(s1: str, s2: str) -> int: Calculate the Levenshtein distance between two strings. >>> levenshtein_distance(\\"kitten\\", \\"sitting\\") 3","solution":"def levenshtein_distance(s1: str, s2: str) -> int: Calculate the Levenshtein distance between two strings. n, m = len(s1), len(s2) # Initialize a dp array dp = [[0] * (m + 1) for _ in range(n + 1)] # Base cases for transforming empty string to another string for i in range(n + 1): dp[i][0] = i for j in range(m + 1): dp[0][j] = j # Fill the dp array for i in range(1, n + 1): for j in range(1, m + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = min(dp[i - 1][j] + 1, # deletion dp[i][j - 1] + 1, # insertion dp[i - 1][j - 1] + 1) # substitution return dp[n][m]"},{"question":"def min_operations_to_subsequence(a: str, b: str) -> int: Returns the minimum number of operations required to make string a a subsequence of string b. >>> min_operations_to_subsequence(\\"abc\\", \\"ahbgdc\\") 0 >>> min_operations_to_subsequence(\\"axc\\", \\"ahbgdc\\") 2","solution":"def min_operations_to_subsequence(a, b): Returns the minimum number of operations required to make string a a subsequence of string b. m, n = len(a), len(b) j = 0 for i in range(n): if j < m and a[j] == b[i]: j += 1 # The number of characters left in 'a' that were not found in order in 'b' return m - j"},{"question":"def min_reversals_to_balance(n: int, S: str) -> int: Function to determine the minimum number of reversals needed to make a parentheses string balanced. :param n: Length of the string S :param S: Parentheses string consisting of '(' and ')' :return: Minimum number of reversals needed >>> min_reversals_to_balance(4, \\")(())\\") 1 >>> min_reversals_to_balance(6, \\"((()))\\") 0 >>> min_reversals_to_balance(8, \\"()()((()\\") 1 >>> min_reversals_to_balance(5, \\"(()()\\") -1 >>> min_reversals_to_balance(0, \\"\\") 0 >>> min_reversals_to_balance(6, \\"((((((\\") 3 >>> min_reversals_to_balance(6, \\"))))))\\") 3","solution":"def min_reversals_to_balance(n, S): Function to determine the minimum number of reversals needed to make a parentheses string balanced. :param n: Length of the string S :param S: Parentheses string consisting of '(' and ')' :return: Minimum number of reversals needed if n % 2 == 1: # If length is odd, it's impossible to balance return -1 left_brackets = 0 right_brackets_needed = 0 for char in S: if char == '(': left_brackets += 1 else: # char == ')' if left_brackets == 0: right_brackets_needed += 1 else: left_brackets -= 1 # Each unmatched pair of left or right brackets can be balanced by one reversal return (left_brackets // 2) + (right_brackets_needed // 2) + (left_brackets % 2 + right_brackets_needed % 2)"},{"question":"def count_possible_y(n: int, d: int) -> int: Given the number of cows, n, and an integer d, determine how many possible values of y exist such that for every cow label x (1  x  n), the relationship x % y = d holds true. >>> count_possible_y(10, 1) 10 >>> count_possible_y(15, 2) 14 >>> count_possible_y(1, 1) 1 >>> count_possible_y(5, 10) 0 >>> count_possible_y(20, 5) 16","solution":"def count_possible_y(n, d): if d > n: return 0 return n - d + 1"},{"question":"def isValidSudoku(board: List[List[str]]) -> bool: Check if a given Sudoku board is valid. The Sudoku board could be partially filled, where empty cells are denoted by the character \`'.'\`. The function should return \`True\` if the given board configuration is valid according to Sudoku rules, and \`False\` otherwise. :param board: List[List[str]]: 2D list representing the board :return: bool: True if the board configuration is valid, otherwise False >>> board = [ ...[\\"5\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], ...[\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], ...[\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], ...[\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], ...[\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], ...[\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], ...[\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], ...[\\".\\",\\"\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], ...[\\".\\",\\"\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] ...] >>> isValidSudoku(board) True","solution":"def isValidSudoku(board): Check if a given Sudoku board is valid. :param board: List[List[str]]: 2D list representing the board :return: bool: True if the board configuration is valid, otherwise False def is_valid_unit(unit): numbers = [num for num in unit if num != '.'] return len(numbers) == len(set(numbers)) # Check rows for row in board: if not is_valid_unit(row): return False # Check columns for col in range(9): if not is_valid_unit([board[row][col] for row in range(9)]): return False # Check 3x3 sub-boxes for box_row in range(3): for box_col in range(3): unit = [ board[row][col] for row in range(box_row * 3, (box_row + 1) * 3) for col in range(box_col * 3, (box_col + 1) * 3) ] if not is_valid_unit(unit): return False return True"},{"question":"def count_and_say(n: int) -> str: Generate the n-th term of the described sequence. >>> count_and_say(1) \\"1\\" >>> count_and_say(2) \\"11\\" >>> count_and_say(3) \\"21\\" >>> count_and_say(4) \\"1211\\" >>> count_and_say(5) \\"111221\\" >>> count_and_say(6) \\"312211\\" >>> count_and_say(10) \\"13211311123113112211\\"","solution":"def count_and_say(n): def next_term(term): result = \\"\\" count = 1 for i in range(1, len(term)): if term[i] == term[i - 1]: count += 1 else: result += str(count) + term[i - 1] count = 1 result += str(count) + term[-1] return result term = \\"1\\" for _ in range(n - 1): term = next_term(term) return term"},{"question":"def generate_employee_id(name: str, number: int) -> str: Generates a unique employee ID based on the provided full name and unique number. Parameters: name (str): The full name of the employee in the format \\"FirstName LastName\\". number (int): The unique number assigned to the employee. Returns: str: The generated employee ID. Examples: >>> generate_employee_id(\\"John Doe\\", 1) 'JD-1' >>> generate_employee_id(\\"Alice Smith\\", 2) 'AS-2' pass def process_new_hires(n: int, hires: list) -> list: Processes multiple new hires and generates unique employee IDs for each. Parameters: n (int): The number of new hires. hires (list of tuples): List of (name, number) tuples for each hire. Returns: list: List of generated employee IDs for each new hire. Examples: >>> process_new_hires(3, [(\\"John Doe\\", 1), (\\"Alice Smith\\", 2), (\\"Bob Johnson\\", 3)]) ['JD-1', 'AS-2', 'BJ-3'] >>> process_new_hires(2, [(\\"Chris Evans\\", 25), (\\"Tony Stark\\", 26)]) ['CE-25', 'TS-26'] pass def test_generate_employee_id(): assert generate_employee_id(\\"John Doe\\", 1) == \\"JD-1\\" assert generate_employee_id(\\"Alice Smith\\", 2) == \\"AS-2\\" assert generate_employee_id(\\"Bob Johnson\\", 3) == \\"BJ-3\\" assert generate_employee_id(\\"Chris Evans\\", 25) == \\"CE-25\\" assert generate_employee_id(\\"Tony Stark\\", 26) == \\"TS-26\\" assert generate_employee_id(\\"John Snow\\", 1000) == \\"JS-1000\\" assert generate_employee_id(\\"Samwell Tarly\\", 1001) == \\"ST-1001\\" def test_process_new_hires(): hires_data = [ (\\"John Doe\\", 1), (\\"Alice Smith\\", 2), (\\"Bob Johnson\\", 3) ] assert process_new_hires(3, hires_data) == [\\"JD-1\\", \\"AS-2\\", \\"BJ-3\\"] hires_data = [ (\\"Chris Evans\\", 25), (\\"Tony Stark\\", 26) ] assert process_new_hires(2, hires_data) == [\\"CE-25\\", \\"TS-26\\"] hires_data = [ (\\"John Doe\\", 1), (\\"Alice Smith\\", 2), (\\"Bob Johnson\\", 3), (\\"Chris Evans\\", 25), (\\"Tony Stark\\", 26) ] assert process_new_hires(5, hires_data) == [\\"JD-1\\", \\"AS-2\\", \\"BJ-3\\", \\"CE-25\\", \\"TS-26\\"]","solution":"def generate_employee_id(name, number): Generates a unique employee ID based on the provided full name and unique number. Parameters: name (str): The full name of the employee in the format \\"FirstName LastName\\". number (int): The unique number assigned to the employee. Returns: str: The generated employee ID. first_name, last_name = name.split() employee_id = first_name[0].upper() + last_name[0].upper() + '-' + str(number) return employee_id def process_new_hires(n, hires): Processes multiple new hires and generates unique employee IDs for each. Parameters: n (int): The number of new hires. hires (list of tuples): List of (name, number) tuples for each hire. Returns: list: List of generated employee IDs for each new hire. employee_ids = [] for name, number in hires: employee_ids.append(generate_employee_id(name, number)) return employee_ids"},{"question":"from typing import List def zigzag_array(n: int, arr: List[int]) -> List[int]: Rearranges the array such that it forms a zigzag sequence. Parameters: n (int): Number of elements in the array arr (list of int): The array of elements Returns: list of int: The array rearranged in zigzag sequence >>> zigzag_array(5, [1, 2, 3, 4, 5]) [1, 3, 2, 5, 4] >>> zigzag_array(6, [4, 3, 7, 8, 6, 2]) [3, 7, 4, 8, 2, 6]","solution":"def zigzag_array(n, arr): Rearranges the array such that it forms a zigzag sequence. Parameters: n (int): Number of elements in the array arr (list of int): The array of elements Returns: list of int: The array rearranged in zigzag sequence for i in range(1, n, 2): if i+1 < n: if arr[i-1] > arr[i]: arr[i-1], arr[i] = arr[i], arr[i-1] if arr[i] < arr[i+1]: arr[i], arr[i+1] = arr[i+1], arr[i] else: # when i+1 == n and it's the last element if arr[i-1] > arr[i]: arr[i-1], arr[i] = arr[i], arr[i-1] return arr"},{"question":"def maximum_gap(nums): Finds the maximum difference between the successive elements in the sorted form of the given array. >>> maximum_gap([3, 6, 9, 1]) 3 >>> maximum_gap([10, 5, 1, 8]) 4 >>> maximum_gap([1, 2, 3, 4, 5, 6]) 1 >>> maximum_gap([1, 1000000000]) 999999999 >>> maximum_gap([1, 1, 1, 1]) 0 >>> maximum_gap([-1000000000, 0, 1000000000]) 1000000000 >>> maximum_gap([5, 5]) 0 >>> maximum_gap([4, 6, 2, 10, 5, 1]) 4 pass","solution":"def maximum_gap(nums): Finds the maximum difference between the successive elements in the sorted form of the given array nums. if len(nums) < 2: return 0 nums.sort() max_gap = 0 for i in range(1, len(nums)): max_gap = max(max_gap, nums[i] - nums[i - 1]) return max_gap def read_input_and_compute_max_gap(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) nums = list(map(int, data[1:n+1])) print(maximum_gap(nums))"},{"question":"def min_number_of_pages(n: int, k: int, stamps: List[int]) -> int: Returns the minimum number of pages needed to place all stamps. n: int : Number of stamps k: int : Maximum number of stamps per page stamps: List[int] : List of stamp numbers >>> min_number_of_pages(6, 3, [1, 2, 3, 1, 2, 3]) == 2 >>> min_number_of_pages(5, 2, [4, 4, 4, 4, 4]) == 1 >>> min_number_of_pages(4, 3, [1, 1, 1, 1]) == 1 >>> min_number_of_pages(4, 2, [1, 2, 3, 4]) == 2 >>> min_number_of_pages(0, 3, []) == 0 >>> min_number_of_pages(7, 2, [1, 2, 1, 2, 3, 3, 4]) == 3 >>> min_number_of_pages(5, 5, [1, 2, 3, 4, 5]) == 1","solution":"def min_number_of_pages(n, k, stamps): Returns the minimum number of pages needed to place all stamps. n: int : Number of stamps k: int : Maximum number of stamps per page stamps: List[int] : List of stamp numbers # Use a set to keep track of unique stamps seen so far unique_stamps = set() # Counter for pages pages = 0 for stamp in stamps: # Add the stamp to the set of unique stamps unique_stamps.add(stamp) # If the set reaches the capacity of k if len(unique_stamps) == k: # Increment the page count pages += 1 # Reset the set for new page unique_stamps = set() # Account for leftover stamps if any if unique_stamps: pages += 1 return pages"},{"question":"def reorganize_collection(N: int, collection: List[str]) -> List[str]: Reorganize a collection of strings by placing all words at the beginning in lexicographically sorted order and all numbers at the end in ascending numerical order. Args: N : int : number of strings in the collection collection : list : a list of strings (each string either a word or a number) Returns: list : a list of rearranged strings as described >>> reorganize_collection(5, [\\"apple\\", \\"4\\", \\"banana\\", \\"2\\", \\"cherry\\"]) [\\"apple\\", \\"banana\\", \\"cherry\\", \\"2\\", \\"4\\"] >>> reorganize_collection(4, [\\"3\\", \\"1\\", \\"2\\", \\"apple\\"]) [\\"apple\\", \\"1\\", \\"2\\", \\"3\\"] >>> reorganize_collection(3, [\\"banana\\", \\"apple\\", \\"23\\"]) [\\"apple\\", \\"banana\\", \\"23\\"]","solution":"def reorganize_collection(N, collection): Reorganize a collection of strings by placing all words at the beginning in lexicographically sorted order and all numbers at the end in ascending numerical order. Args: N : int : number of strings in the collection collection : list : a list of strings (each string either a word or a number) Returns: list : a list of rearranged strings as described words = [] numbers = [] for item in collection: if item.isdigit(): numbers.append(item) else: words.append(item) words.sort() numbers.sort(key=int) return words + numbers"},{"question":"def has_subarray_with_sum(N: int, M: int, B: List[int]) -> str: Determines if there exists a contiguous subarray whose sum is equal to M. Args: N -- the number of elements in the list M -- the target sum B -- list of integers Returns: \\"YES\\" if such subarray exists, otherwise \\"NO\\" >>> has_subarray_with_sum(5, 7, [1, 2, 3, 4, 5]) 'YES' >>> has_subarray_with_sum(5, 15, [1, 2, 3, 4, 5]) 'YES' >>> has_subarray_with_sum(3, 10, [2, 2, 2]) 'NO' from solution import has_subarray_with_sum def test_case_1(): assert has_subarray_with_sum(5, 7, [1, 2, 3, 4, 5]) == \\"YES\\" def test_case_2(): assert has_subarray_with_sum(5, 15, [1, 2, 3, 4, 5]) == \\"YES\\" def test_case_3(): assert has_subarray_with_sum(3, 10, [2, 2, 2]) == \\"NO\\" def test_case_4(): assert has_subarray_with_sum(2, 5, [1, 4]) == \\"YES\\" def test_case_5(): assert has_subarray_with_sum(5, 0, [1, -1, 1, -1, 1]) == \\"YES\\" def test_case_6(): assert has_subarray_with_sum(4, 10, [10, -10, 10, -10]) == \\"YES\\" def test_large_input(): N = 100000 M = 1000 B = [1] * 100000 assert has_subarray_with_sum(N, M, B) == \\"YES\\" def test_large_input_no_sum(): N = 100000 M = 1000000000 B = [1] * 100000 assert has_subarray_with_sum(N, M, B) == \\"NO\\"","solution":"def has_subarray_with_sum(N, M, B): Determines if there exists a contiguous subarray whose sum is equal to M. Args: N -- the number of elements in the list M -- the target sum B -- list of integers Returns: \\"YES\\" if such subarray exists, otherwise \\"NO\\" current_sum = 0 prefix_sums = {0} for i in range(N): current_sum += B[i] if (current_sum - M) in prefix_sums: return \\"YES\\" prefix_sums.add(current_sum) return \\"NO\\""},{"question":"def can_proceed(P, M, num_potions, num_spells, H, Mp): Determine whether the player has collected enough health and magic points to proceed to the next level. Args: P (int): Health increase per potion. M (int): Magic point increase per spell. num_potions (int): Number of potions collected. num_spells (int): Number of spells collected. H (int): Required health to proceed. Mp (int): Required magic points to proceed. Returns: str: 'Proceed' if the player can proceed to the next level, otherwise 'Stay'. Examples: >>> can_proceed(10, 5, 100, 100, 500, 500) 'Proceed' >>> can_proceed(10, 0, 100, 0, 1000, 1) 'Stay' from solution import can_proceed def test_can_proceed_both_sufficient(): assert can_proceed(10, 5, 100, 100, 500, 500) == \\"Proceed\\" def test_can_proceed_health_insufficient(): assert can_proceed(10, 0, 100, 0, 1000, 1) == \\"Stay\\" def test_can_proceed_magic_insufficient(): assert can_proceed(10, 2, 10, 1, 100, 100) == \\"Stay\\" def test_can_proceed_both_just_enough(): assert can_proceed(10, 5, 100, 100, 1000, 500) == \\"Proceed\\" def test_can_proceed_both_exact(): assert can_proceed(10, 5, 10, 10, 100, 50) == \\"Proceed\\" def test_can_proceed_health_exact_magic_zero(): assert can_proceed(10, 0, 10, 10, 100, 0) == \\"Proceed\\" def test_can_proceed_magic_exact_health_zero(): assert can_proceed(0, 5, 10, 10, 0, 50) == \\"Proceed\\"","solution":"def can_proceed(P, M, num_potions, num_spells, H, Mp): Returns 'Proceed' if the player can proceed to the next level, otherwise returns 'Stay'. total_health = P * num_potions total_magic_points = M * num_spells if total_health >= H and total_magic_points >= Mp: return 'Proceed' else: return 'Stay' if __name__ == \\"__main__\\": import sys input = sys.stdin.read() P, M, num_potions, num_spells, H, Mp = map(int, input.strip().split()) print(can_proceed(P, M, num_potions, num_spells, H, Mp))"},{"question":"def alternating_sum(n: int) -> int: Computes the result of the summation with alternating addition and subtraction up to n. >>> alternating_sum(5) 3 >>> alternating_sum(8) -4 >>> alternating_sum(1) 1 >>> alternating_sum(2) -1 >>> alternating_sum(3) 2 >>> alternating_sum(4) -2 >>> alternating_sum(10**9) -500000000 >>> alternating_sum(10**9 - 1) 500000000 >>> alternating_sum(999999999) 500000000 >>> alternating_sum(1000000000) -500000000","solution":"def alternating_sum(n): Computes the result of the summation with alternating addition and subtraction up to n. Parameters: n (int): The upper limit of the sequence. Returns: int: The result of the summation. if n % 2 == 0: return -(n // 2) else: return (n // 2) + 1"},{"question":"def has_pair_with_sum(n: int, lst: List[int], target_sum: int) -> str: Determine whether there is a pair of distinct integers in the list that adds up to the target sum. Parameters: n (int): The number of elements in the list. lst (list): A list of integers. target_sum (int): The target sum. Returns: str: \\"YES\\" if there are two distinct integers that add up to the target sum, otherwise \\"NO\\". Examples: >>> has_pair_with_sum(5, [1, 2, 3, 4, 5], 9) \\"YES\\" >>> has_pair_with_sum(4, [1, 2, 3, 4], 8) \\"NO\\"","solution":"def has_pair_with_sum(n, lst, target_sum): Checks if there are two distinct integers in the list \`lst\` that add up to \`target_sum\`. Parameters: n (int): The number of elements in the list. lst (list): A list of integers. target_sum (int): The target sum. Returns: str: \\"YES\\" if there are two distinct integers that add up to the target sum, otherwise \\"NO\\". seen = set() for num in lst: if (target_sum - num) in seen: return \\"YES\\" seen.add(num) return \\"NO\\""},{"question":"from typing import List, Dict def prime_factors(n: int) -> List[Dict[int, int]]: Given an integer n, returns the prime factorization of all numbers from 1 to n (inclusive). The prime factorization of a number k is a representation of k as a product of prime numbers. >>> prime_factors(5) [{1: 1}, {2: 1}, {3: 1}, {2: 2}, {5: 1}] >>> prime_factors(10) [ {1: 1}, {2: 1}, {3: 1}, {2: 2}, {5: 1}, {2: 1, 3: 1}, {7: 1}, {2: 3}, {3: 2}, {2: 1, 5: 1} ] pass def test_prime_factors_5(): result = prime_factors(5) expected = [{1: 1}, {2: 1}, {3: 1}, {2: 2}, {5: 1}] assert result == expected def test_prime_factors_10(): result = prime_factors(10) expected = [ {1: 1}, {2: 1}, {3: 1}, {2: 2}, {5: 1}, {2: 1, 3: 1}, {7: 1}, {2: 3}, {3: 2}, {2: 1, 5: 1} ] assert result == expected def test_prime_factors_1(): result = prime_factors(1) expected = [{1: 1}] assert result == expected def test_prime_factors_3(): result = prime_factors(3) expected = [{1: 1}, {2: 1}, {3: 1}] assert result == expected def test_prime_factors_15(): result = prime_factors(15) expected = [ {1: 1}, {2: 1}, {3: 1}, {2: 2}, {5: 1}, {2: 1, 3: 1}, {7: 1}, {2: 3}, {3: 2}, {2: 1, 5: 1}, {11: 1}, {2: 2, 3: 1}, {13: 1}, {2: 1, 7: 1}, {3: 1, 5: 1} ] assert result == expected","solution":"def prime_factors(n): Returns a list of dictionaries where each dictionary represents the prime factorization of integers from 1 to n. def factorize(num): if num == 1: return {1: 1} factors = {} divisor = 2 while num >= 2: while num % divisor == 0: if divisor in factors: factors[divisor] += 1 else: factors[divisor] = 1 num //= divisor divisor += 1 return factors return [factorize(i) for i in range(1, n + 1)]"},{"question":"def paint_fence(n: int) -> int: Calculate the number of ways to paint the fence with \`n\` posts using two colors such that no more than two adjacent posts have the same color. :param n: Number of fence posts :type n: int :return: Number of ways to paint the fence :rtype: int >>> paint_fence(1) 2 >>> paint_fence(2) 4 >>> paint_fence(3) 6 >>> paint_fence(4) 10 >>> paint_fence(5) 16 pass def process_input(input_data: List[int]) -> List[int]: Processes the input data and returns the number of ways to paint the fence for each dataset. :param input_data: List of integers where each integer represents the number of fence posts :type input_data: List[int] :return: List of results for each input dataset :rtype: List[int] >>> process_input([3, 4, 5, 0]) [6, 10, 16] >>> process_input([1, 2, 3, 0]) [2, 4, 6] >>> process_input([2, 0]) [4] pass","solution":"def paint_fence(n): Calculate the number of ways to paint the fence with \`n\` posts using two colors such that no more than two adjacent posts have the same color. :param n: Number of fence posts :type n: int :return: Number of ways to paint the fence :rtype: int if n == 1: return 2 # AA or BB elif n == 2: return 4 # AB, BA, AA, BB same = 2 # cases where the last two posts are the same color diff = 2 # cases where the last two posts are different colors for i in range(3, n+1): new_same = diff new_diff = (same + diff) * 1 # New post can be different color from the last one same = new_same diff = new_diff return same + diff def process_input(input_data): results = [] for n in input_data: if n == 0: break results.append(paint_fence(n)) return results"},{"question":"def minimum_total_space(n: int, k: int, spaces: List[int]) -> int: Given the number of ingredient types n, the number of containers k, and an array of spaces required for each type of ingredient, this function returns the minimum total space required for exactly k containers. >>> minimum_total_space(5, 3, [4, 2, 7, 3, 9]) 9 >>> minimum_total_space(4, 4, [1, 1, 1, 1]) 4 >>> minimum_total_space(6, 2, [6, 2, 10, 3, 8, 7]) 5","solution":"def minimum_total_space(n, k, spaces): Given the number of ingredient types n, the number of containers k, and an array of spaces required for each type of ingredient, this function returns the minimum total space required for exactly k containers. # Sort the spaces in ascending order sorted_spaces = sorted(spaces) # Sum up the smallest k spaces to get the minimum total space for k containers return sum(sorted_spaces[:k]) # Example usage if __name__ == \\"__main__\\": n, k = 6, 2 spaces = [6, 2, 10, 3, 8, 7] print(minimum_total_space(n, k, spaces)) # Output: 5"},{"question":"def min_moves_to_redistribute(n: int, cities: List[int]) -> int: Returns the minimum number of moves required to redistribute the residents such that the number of residents in each city is as close to the average number of residents as possible. Parameters: n (int): The number of cities. cities (List[int]): The number of residents in each city. Returns: int: The minimum number of moves required. Examples: >>> min_moves_to_redistribute(5, [1, 2, 5, 4, 8]) 5 >>> min_moves_to_redistribute(3, [3, 3, 3]) 0 >>> min_moves_to_redistribute(4, [0, 0, 0, 0]) 0 >>> min_moves_to_redistribute(4, [0, 10, 0, 10]) 10 >>> min_moves_to_redistribute(4, [5, 3, 6, 2]) 3 >>> min_moves_to_redistribute(5, [1, 2, 3, 4, 0]) 3 >>> min_moves_to_redistribute(3, [1, 6, 2]) 3 >>> min_moves_to_redistribute(2, [7, 2]) 2 pass","solution":"def min_moves_to_redistribute(n, cities): Returns the minimum number of moves required to redistribute the residents such that the number of residents in each city is as close to the average number of residents as possible. Parameters: n (int): The number of cities. cities (List[int]): The number of residents in each city. Returns: int: The minimum number of moves required. total_residents = sum(cities) average_residents = total_residents // n moves = 0 for city in cities: moves += abs(city - average_residents) return moves // 2"},{"question":"def most_frequent_integer(n: int, m: int, grid: List[List[int]]) -> int: Find the most frequent integer in the grid. If multiple integers have the same highest frequency, return the smallest one among them. >>> most_frequent_integer(3, 3, [[1, 2, 3], [3, 3, 2], [2, 2, 1]]) 2 >>> most_frequent_integer(4, 2, [[1, 4], [4, 4], [3, 1], [3, 2]]) 4","solution":"def most_frequent_integer(n, m, grid): from collections import Counter # Flatten the grid into a single list combined_list = [num for row in grid for num in row] # Use Counter to get frequencies of each number freq = Counter(combined_list) # Find the maximum frequency max_freq = max(freq.values()) # Find the smallest number with the maximum frequency result = min(num for num in freq if freq[num] == max_freq) return result"},{"question":"from typing import List def daily_temperatures(T: List[int]) -> List[int]: Given a list of temperatures T, returns a list of how many days you would need to wait until a warmer temperature. If there is no future day for which this is possible, returns 0 for that day. >>> daily_temperatures([73, 74, 75, 71, 69, 72, 76]) [1, 1, 4, 2, 1, 1, 0] >>> daily_temperatures([70, 70, 70, 70, 70, 70, 70]) [0, 0, 0, 0, 0, 0, 0] >>> daily_temperatures([80, 79, 78, 77, 76, 75, 74]) [0, 0, 0, 0, 0, 0, 0] >>> daily_temperatures([66, 67, 68, 69, 70, 71, 72]) [1, 1, 1, 1, 1, 1, 0] >>> daily_temperatures([71, 73, 72, 69, 75, 74, 72]) [1, 3, 2, 1, 0, 0, 0]","solution":"def daily_temperatures(T): Given a list of temperatures T, returns a list of how many days you would need to wait until a warmer temperature. If there is no future day for which this is possible, returns 0 for that day. answer = [0] * len(T) stack = [] for i, current_temp in enumerate(T): while stack and T[stack[-1]] < current_temp: prev_idx = stack.pop() answer[prev_idx] = i - prev_idx stack.append(i) return answer"},{"question":"def min_deletions_to_make_unique_adjacent(arr: List[int]) -> int: Given an integer array consisting of N non-negative integers, determine the minimum number of deletions required such that the array contains no two adjacent elements with the same value. >>> min_deletions_to_make_unique_adjacent([1, 1, 2, 3, 3]) 2 >>> min_deletions_to_make_unique_adjacent([4, 4, 4, 4, 4, 4]) 5 >>> min_deletions_to_make_unique_adjacent([1, 2, 3, 4, 5]) 0 >>> min_deletions_to_make_unique_adjacent([7, 7, 7, 7, 7, 7, 7]) 6 >>> min_deletions_to_make_unique_adjacent([1, 2, 1, 2, 1, 2, 1]) 0 >>> min_deletions_to_make_unique_adjacent([9]) 0","solution":"def min_deletions_to_make_unique_adjacent(arr): Returns the minimum number of deletions required such that the array contains no two adjacent elements with the same value. if not arr: return 0 deletions = 0 for i in range(1, len(arr)): if arr[i] == arr[i - 1]: deletions += 1 return deletions"},{"question":"def santa_distribution_time(t, test_cases): Returns the minimum time required to distribute toys to all towns for each test case. Args: t : int : the number of test cases test_cases : list : list of tuples where each tuple contains: - a tuple (n, m) where n is the number of towns and m is the number of gates - a list of tuples (u, v, w) representing gates with travel time w between towns u and v Returns: list : list of integers representing the minimum time required for each test case Example: >>> santa_distribution_time(2, [((2, 1), [(0, 1, 5)]), ((3, 3), [(0, 1, 3), (1, 2, 4), (0, 2, 7)])]) [5, 7] pass def test_santa_distribution_time(): t = 2 test_cases = [ ((2, 1), [(0, 1, 5)]), ((3, 3), [(0, 1, 3), (1, 2, 4), (0, 2, 7)]) ] assert santa_distribution_time(t, test_cases) == [5, 7] def test_multiple_routes(): t = 1 test_cases = [ ((4, 5), [(0, 1, 2), (1, 2, 2), (0, 2, 6), (2, 3, 1), (1, 3, 10)]) ] assert santa_distribution_time(t, test_cases) == [5] def test_single_town(): t = 1 test_cases = [ ((1, 0), []) ] assert santa_distribution_time(t, test_cases) == [0] def test_all_towns_directly_connected(): t = 1 test_cases = [ ((3, 3), [(0, 1, 1), (0, 2, 1), (1, 2, 2)]) ] assert santa_distribution_time(t, test_cases) == [1]","solution":"import heapq def santa_distribution_time(t, test_cases): Returns the minimum time required to distribute toys to all towns for each test case. def dijkstra(n, graph): # Create a priority queue pq = [(0, 0)] # (time, town) distances = {i: float('inf') for i in range(n)} distances[0] = 0 visited = set() while pq: current_time, u = heapq.heappop(pq) if u in visited: continue visited.add(u) for v, w in graph[u]: if current_time + w < distances[v]: distances[v] = current_time + w heapq.heappush(pq, (distances[v], v)) return max(distances.values()) results = [] for i in range(t): n, m = test_cases[i][0] edges = test_cases[i][1] graph = {i: [] for i in range(n)} for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) results.append(dijkstra(n, graph)) return results # Function to handle input and output def handle_input_output(): import sys input = sys.stdin.read data = input().split() t = int(data[0]) index = 1 test_cases = [] for _ in range(t): n = int(data[index]) m = int(data[index + 1]) edges = [] index += 2 for _ in range(m): u = int(data[index]) v = int(data[index + 1]) w = int(data[index + 2]) edges.append((u, v, w)) index += 3 test_cases.append(((n, m), edges)) results = santa_distribution_time(t, test_cases) for result in results: print(result)"},{"question":"import heapq from typing import List, Tuple def find_shortest_path(n: int, m: int, roads: List[Tuple[int, int, int]], start: int, end: int) -> int: Find the minimum transportation cost to reach a warehouse from another warehouse. Uses Dijkstra's algorithm to find the shortest path from start to end in a weighted graph. Parameters: n (int): Number of nodes (warehouses). m (int): Number of edges (roads). roads (List[Tuple[int, int, int]]): List of tuples where each tuple (u, v, w) represents a road from node u to node v with weight w. start (int): Starting node. end (int): Ending node. Returns: int: Minimum transportation cost from start to end. If no valid path, returns -1. >>> find_shortest_path(4, 4, [(1, 2, 5), (2, 3, 10), (1, 4, 1), (4, 3, 1)], 1, 3) 2 >>> find_shortest_path(2, 1, [(1, 2, 3)], 2, 1) -1","solution":"import heapq def find_shortest_path(n, m, roads, start, end): Uses Dijkstra's algorithm to find the shortest path from start to end in a weighted graph. Parameters: n (int): Number of nodes (warehouses). m (int): Number of edges (roads). roads (List[Tuple[int, int, int]]): List of tuples where each tuple (u, v, w) represents a road from node u to node v with weight w. start (int): Starting node. end (int): Ending node. Returns: int: Minimum transportation cost from start to end. If no valid path, returns -1. # Create adjacency list graph = [[] for _ in range(n + 1)] for u, v, w in roads: graph[u].append((v, w)) # Dijkstra's algorithm heap = [(0, start)] # (cost, node) distances = {i: float('inf') for i in range(1, n + 1)} distances[start] = 0 while heap: current_cost, u = heapq.heappop(heap) if u == end: return current_cost if current_cost > distances[u]: continue for v, weight in graph[u]: distance = current_cost + weight if distance < distances[v]: distances[v] = distance heapq.heappush(heap, (distance, v)) return -1 if distances[end] == float('inf') else distances[end]"},{"question":"def find_minimal_difference(arr: List[int]) -> int: Given an array of N positive integers, find two distinct indices i and j (1  i, j  N, i  j) such that the difference between arr[i] and arr[j] is minimal among all possible pairs in the array. Args: arr (List[int]): The list of positive integers. Returns: int: The minimal difference between any pair of elements. Examples: >>> find_minimal_difference([1, 5, 3, 19, 18]) 1 >>> find_minimal_difference([1, 2, 3, 4, 5]) 1 >>> find_minimal_difference([5, 4, 3, 2, 1]) 1 >>> find_minimal_difference([10, 10, 10, 10]) 0 >>> find_minimal_difference([1000000000, 999999999]) 1","solution":"def find_minimal_difference(arr): Finds the minimal difference between any pair of elements in the array by sorting the array and checking the differences between consecutive elements. Args: arr (list of int): The list of positive integers. Returns: int: The minimal difference between any pair of elements. arr.sort() min_diff = float('inf') for i in range(1, len(arr)): diff = arr[i] - arr[i-1] if diff < min_diff: min_diff = diff return min_diff"},{"question":"def count_candies(n: int) -> int: Returns the number of candies dispensed by the vending machine for the given amount of money n. Parameters: n (int): The amount of money inserted. Returns: int: Number of candies dispensed. Examples: >>> count_candies(4) 8 >>> count_candies(7) 22 >>> count_candies(1) 4 >>> count_candies(1000000000) 2000000000","solution":"def count_candies(n): Returns the number of candies dispensed by the vending machine for the given amount of money n. Parameters: n (int): The amount of money inserted. Returns: int: Number of candies dispensed. if n % 2 == 0: return n * 2 else: return n * 3 + 1"},{"question":"def transform_to_equal_array(n, arr): Transforms the array such that all elements become equal by performing allowed operations, and returns the number of operations and the operations performed. :param n: Length of the array :param arr: List of integers :return: Tuple of the number of operations and the list of operations Example usage: >>> transform_to_equal_array(3, [3, 2, 1]) (2, [(3, 1), (3, 2)]) >>> transform_to_equal_array(4, [4, 3, 2, 1]) (3, [(4, 1), (4, 2), (4, 3)]) # Example unit tests if __name__ == \\"__main__\\": def test_example_1(): n = 3 arr = [3, 2, 1] expected_operations = [(3, 1), (3, 2)] count, operations = transform_to_equal_array(n, arr) assert count == len(expected_operations) assert operations == expected_operations def test_example_2(): n = 4 arr = [4, 3, 2, 1] expected_operations = [(4, 1), (4, 2), (4, 3)] count, operations = transform_to_equal_array(n, arr) assert count == len(expected_operations) assert operations == expected_operations def test_single_element_array(): n = 1 arr = [1] expected_operations = [] count, operations = transform_to_equal_array(n, arr) assert count == 0 assert operations == expected_operations def test_all_elements_equal(): n = 5 arr = [2, 2, 2, 2, 2] expected_operations = [] count, operations = transform_to_equal_array(n, arr) assert count == 0 assert operations == expected_operations def test_all_elements_unique(): n = 5 arr = [5, 4, 3, 2, 1] expected_operations = [(5, 1), (5, 2), (5, 3), (5, 4)] count, operations = transform_to_equal_array(n, arr) assert count == len(expected_operations) assert operations == expected_operations test_example_1() test_example_2() test_single_element_array() test_all_elements_equal() test_all_elements_unique()","solution":"def transform_to_equal_array(n, arr): Transforms the array such that all elements become equal by performing allowed operations, and returns the number of operations and the operations performed. :param n: Length of the array :param arr: List of integers :return: Tuple of the number of operations and the list of operations min_value = min(arr) operations = [] # Find all positions of the minimum value min_positions = [i + 1 for i, value in enumerate(arr) if value == min_value] # Ensure at least one minimum position exists to start the comparison operations for i in range(n): if arr[i] != min_value: operations.append((min_positions[0], i + 1)) return len(operations), operations"},{"question":"def max_songs(subscription, n, b, sizes, d=None): Calculates the maximum number of songs Alex can listen to given the subscription type and constraints. :param subscription: String, either \\"Premium\\" or \\"Standard\\" :param n: Integer, the total number of songs :param b: Integer, the daily bandwidth limit in MB :param sizes: List of Integers, sizes of each song in MB :param d: Integer, the daily limit of songs for Standard subscription, optional :return: Integer, the maximum number of songs Alex can listen to # Unit tests from solution import max_songs def test_premium_no_limit(): assert max_songs(\\"Premium\\", 5, 100, [10, 20, 30, 40, 50]) == 4 assert max_songs(\\"Premium\\", 5, 150, [10, 20, 30, 40, 50]) == 5 def test_standard_with_limit(): assert max_songs(\\"Standard\\", 5, 100, [10, 20, 30, 40, 50], 3) == 3 assert max_songs(\\"Standard\\", 5, 80, [10, 20, 30, 40, 50], 3) == 3 assert max_songs(\\"Standard\\", 5, 50, [10, 20, 30, 40, 50], 2) == 2 def test_premium_edge_cases(): assert max_songs(\\"Premium\\", 1, 100, [101]) == 0 assert max_songs(\\"Premium\\", 1, 100, [100]) == 1 def test_standard_edge_cases(): assert max_songs(\\"Standard\\", 1, 100, [101], 1) == 0 assert max_songs(\\"Standard\\", 1, 100, [100], 1) == 1 assert max_songs(\\"Standard\\", 3, 90, [50, 40, 30], 2) == 2 assert max_songs(\\"Standard\\", 3, 70, [50, 40, 30], 2) == 2 def test_various_cases(): assert max_songs(\\"Standard\\", 6, 100, [20, 30, 25, 10, 5, 40], 4) == 4 assert max_songs(\\"Premium\\", 4, 60, [10, 20, 15, 30]) == 3","solution":"def max_songs(subscription, n, b, sizes, d=None): Calculates the maximum number of songs Alex can listen to given the subscription type and constraints. :param subscription: String, either \\"Premium\\" or \\"Standard\\" :param n: Integer, the total number of songs :param b: Integer, the daily bandwidth limit in MB :param sizes: List of Integers, sizes of each song in MB :param d: Integer, the daily limit of songs for Standard subscription, optional :return: Integer, the maximum number of songs Alex can listen to sizes.sort() songs_count = 0 total_bandwidth_used = 0 for size in sizes: if total_bandwidth_used + size > b: break if subscription == \\"Standard\\" and songs_count >= d: break total_bandwidth_used += size songs_count += 1 return songs_count"},{"question":"def count_trees_greater_equal_heights(tree_heights: List[int], queries: List[int]) -> List[int]: Returns the list of counts of trees greater than or equal to given heights. :param tree_heights: List[int], List of heights of trees in the garden. :param queries: List[int], List of heights to query. :return: List[int], List of counts of trees greater than or equal to query heights. >>> count_trees_greater_equal_heights([2, 3, 4, 3, 1], [4, 1, 5]) [1, 5, 0] >>> count_trees_greater_equal_heights([5, 5, 5, 5, 5], [5, 6, 0]) [5, 0, 5] >>> count_trees_greater_equal_heights([1], [1, 2, 0]) [1, 0, 1] >>> count_trees_greater_equal_heights([], [1, 2, 3]) [0, 0, 0] >>> count_trees_greater_equal_heights([1, 2, 3, 4, 5, 6], [3, 4, 7]) [4, 3, 0] >>> count_trees_greater_equal_heights([1, 2, 3, 4, 5], [3]) [3] >>> count_trees_greater_equal_heights([1, 2, 3, 4, 5], [0]) [5]","solution":"def count_trees_greater_equal_heights(tree_heights, queries): Returns the list of counts of trees greater than or equal to given heights. :param tree_heights: List[int], List of heights of trees in the garden. :param queries: List[int], List of heights to query. :return: List[int], List of counts of trees greater than or equal to query heights. results = [] for h in queries: count = sum(1 for height in tree_heights if height >= h) results.append(count) return results"},{"question":"def min_travel_time(m: int, travel_times: List[List[int]]) -> int: Calculate the minimum total travel time required for Samantha to visit all parks exactly once and return to the starting park. Args: m (int): The number of national parks. travel_times (List[List[int]]): A matrix representing the travel times between parks. Returns: int: The minimum total travel time. Examples: >>> min_travel_time(3, [[0, 10, 15], [10, 0, 20], [15, 20, 0]]) == 45 >>> min_travel_time(4, [[0, 10, 15, 20], [10, 0, 25, 25], [15, 25, 0, 30], [20, 25, 30, 0]]) == 80","solution":"def min_travel_time(m, travel_times): # Initialize dp array with infinity dp = [[float('inf')] * m for _ in range(1 << m)] dp[1][0] = 0 # Starting from park 0 with only park 0 visited for mask in range(1 << m): for u in range(m): if mask & (1 << u): # If u is in the current set represented by mask for v in range(m): if not mask & (1 << v): # If v is not in the current set new_mask = mask | (1 << v) dp[new_mask][v] = min(dp[new_mask][v], dp[mask][u] + travel_times[u][v]) # Answer is to return to the starting park final_mask = (1 << m) - 1 # All parks visited return min(dp[final_mask][i] + travel_times[i][0] for i in range(m)) # Example usage: m = 3 travel_times = [ [0, 10, 15], [10, 0, 20], [15, 20, 0] ] print(min_travel_time(m, travel_times)) # Output: 45"},{"question":"def can_form_palindrome(N: int) -> str: Determines if it is possible to rearrange the digits of N to form a palindrome. Parameters: N (int): The input integer. Returns: str: \\"YES\\" if it is possible to rearrange the digits to form a palindrome, otherwise \\"NO\\" >>> can_form_palindrome(121) 'YES' >>> can_form_palindrome(12345) 'NO'","solution":"def can_form_palindrome(N): Determines if it is possible to rearrange the digits of N to form a palindrome. Parameters: N (int): The input integer. Returns: str: \\"YES\\" if it is possible to rearrange the digits to form a palindrome, otherwise \\"NO\\" from collections import Counter # Convert number to string and count occurrences of each digit digit_counts = Counter(str(N)) # Count digits with odd occurrences odd_count = sum(1 for count in digit_counts.values() if count % 2 != 0) # A number can be rearranged into a palindrome if at most one digit has an odd count return \\"YES\\" if odd_count <= 1 else \\"NO\\" # Example usage print(can_form_palindrome(121)) # Output: YES print(can_form_palindrome(12345)) # Output: NO"},{"question":"from typing import List, Tuple def can_schedule(day_events: List[Tuple[str, str]], new_event: Tuple[str, str]) -> bool: Check if a new event can be added to the schedule without time conflicts. >>> can_schedule([(\\"09:00\\", \\"10:00\\"), (\\"11:30\\", \\"12:30\\"), (\\"14:00\\", \\"15:00\\")], (\\"12:30\\", \\"13:00\\")) True >>> can_schedule([(\\"09:00\\", \\"10:00\\"), (\\"10:00\\", \\"11:00\\"), (\\"11:00\\", \\"12:00\\")], (\\"10:30\\", \\"11:15\\")) False pass def test_no_overlapping_events(): assert can_schedule([(\\"09:00\\", \\"10:00\\"), (\\"11:30\\", \\"12:30\\"), (\\"14:00\\", \\"15:00\\")], (\\"12:30\\", \\"13:00\\")) == True def test_overlapping_event_start(): assert can_schedule([(\\"09:00\\", \\"10:00\\"), (\\"10:00\\", \\"11:00\\"), (\\"11:00\\", \\"12:00\\")], (\\"10:30\\", \\"11:15\\")) == False def test_event_same_start_time(): assert can_schedule([(\\"09:00\\", \\"10:00\\"), (\\"10:00\\", \\"11:00\\")], (\\"10:00\\", \\"10:30\\")) == False def test_event_same_end_time(): assert can_schedule([(\\"09:00\\", \\"10:00\\"), (\\"10:00\\", \\"11:00\\")], (\\"09:30\\", \\"10:00\\")) == False def test_back_to_back_events(): assert can_schedule([(\\"09:00\\", \\"10:00\\"), (\\"10:00\\", \\"11:00\\")], (\\"11:00\\", \\"12:00\\")) == True def test_full_day_no_event(): assert can_schedule([], (\\"00:00\\", \\"23:59\\")) == True def test_event_last_minute(): assert can_schedule([(\\"09:00\\", \\"10:00\\"), (\\"10:00\\", \\"11:00\\")], (\\"23:59\\", \\"23:59\\")) == True def test_one_minute_overlap(): assert can_schedule([(\\"09:00\\", \\"09:30\\"), (\\"10:00\\", \\"10:30\\")], (\\"09:29\\", \\"09:30\\")) == False","solution":"def time_to_minutes(time_str): Convert time string in \\"HH:mm\\" format to minutes since 00:00. hours, minutes = map(int, time_str.split(':')) return hours * 60 + minutes def can_schedule(day_events, new_event): Check if the new event can be scheduled without overlapping existing events. new_start, new_end = new_event new_start_minutes = time_to_minutes(new_start) new_end_minutes = time_to_minutes(new_end) for start, end in day_events: start_minutes = time_to_minutes(start) end_minutes = time_to_minutes(end) # Check for overlap if not (new_end_minutes <= start_minutes or new_start_minutes >= end_minutes): return False return True"},{"question":"def final_bike_count(n, q, initial_bikes, operations): Calculate the final state of each docking station after a sequence of operations. Parameters: n (int): number of docking stations q (int): number of operations initial_bikes (list): initial number of bikes at each docking station operations (list): list of operations in the format \\"P x\\" or \\"R x\\" Returns: list: final number of bikes at each docking station Examples: >>> final_bike_count(3, 5, [5, 3, 7], [\\"P 1\\", \\"P 2\\", \\"R 3\\", \\"P 3\\", \\"R 2\\"]) [4, 3, 7] >>> final_bike_count(2, 4, [2, 4], [\\"P 2\\", \\"R 1\\", \\"P 1\\", \\"R 2\\"]) [2, 4]","solution":"def final_bike_count(n, q, initial_bikes, operations): Calculate the final state of each docking station after a sequence of operations. Parameters: n (int): number of docking stations q (int): number of operations initial_bikes (list): initial number of bikes at each docking station operations (list): list of operations in the format \\"P x\\" or \\"R x\\" Returns: list: final number of bikes at each docking station # Initialize docking station bike counts bikes = initial_bikes[:] # Process each operation for operation in operations: op, x = operation.split() x = int(x) - 1 # Convert to zero-indexed if op == \\"P\\": bikes[x] -= 1 elif op == \\"R\\": bikes[x] += 1 return bikes"},{"question":"def find_height_groups(T: int, test_cases: List[Tuple[int, List[int], int]]) -> List[str]: Find all the unique height groups with at least \`k\` people in each group in descending order of height. Args: T (int): Number of test cases. test_cases (List[Tuple[int, List[int], int]]): List of test cases where each test case is a tuple containing: - Number of people in the list (int). - Heights of the people (List[int]). - Minimum number of people required to form a group (int). Returns: List[str]: List of strings representing the unique height groups with at least \`k\` people in each group, sorted in descending order of height. If no such group exists, the result should be \`-1\`. Example: >>> find_height_groups(1, [(7, [170, 160, 160, 180, 190, 170, 150], 2)]) ['170 160'] >>> find_height_groups(2, [(7, [170, 160, 160, 180, 190, 170, 150], 2), (5, [200, 200, 150, 150, 150], 3)]) ['170 160', '150'] # Your code goes here import pytest from solution import find_height_groups def test_single_case_with_valid_groups(): T = 1 test_cases = [ (7, [170, 160, 160, 180, 190, 170, 150], 2) ] result = find_height_groups(T, test_cases) assert result == [\\"170 160\\"] def test_single_case_with_no_valid_groups(): T = 1 test_cases = [ (5, [200, 200, 150, 150, 150], 3) ] result = find_height_groups(T, test_cases) assert result == [\\"150\\"] def test_multiple_cases(): T = 2 test_cases = [ (7, [170, 160, 160, 180, 190, 170, 150], 2), (5, [200, 200, 150, 150, 150], 3) ] result = find_height_groups(T, test_cases) assert result == [\\"170 160\\", \\"150\\"] def test_with_group_size_one(): T = 1 test_cases = [ (6, [100, 100, 100, 101, 101, 102], 1) ] result = find_height_groups(T, test_cases) assert result == [\\"102 101 100\\"] def test_no_group_with_sufficient_size(): T = 1 test_cases = [ (5, [105, 110, 115, 120, 125], 2) ] result = find_height_groups(T, test_cases) assert result == [\\"-1\\"] def test_all_heights_meet_k_requirement(): T = 1 test_cases = [ (6, [130, 130, 131, 131, 132, 132], 2) ] result = find_height_groups(T, test_cases) assert result == [\\"132 131 130\\"]","solution":"def find_height_groups(T, test_cases): results = [] for test_case in test_cases: n, heights, k = test_case height_count = {} for height in heights: if height in height_count: height_count[height] += 1 else: height_count[height] = 1 valid_heights = [height for height, count in height_count.items() if count >= k] if valid_heights: valid_heights.sort(reverse=True) results.append(\\" \\".join(map(str, valid_heights))) else: results.append(\\"-1\\") return results"},{"question":"def max_subarray(arr: List[int]) -> List[int]: Find a subarray with the maximum possible sum. Return the subarray which has the smallest length and starts at the smallest index if multiple answers exist. >>> max_subarray([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == [4, -1, 2, 1] >>> max_subarray([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] >>> max_subarray([-1, -2, -3, -4, -5]) == [-1] >>> max_subarray([1, 2, 3, -6, 4, 5, 6]) == [4, 5, 6] >>> max_subarray([0, 0, 0, 0, 0]) == [0] >>> max_subarray([3, -2, 5, -1, 1, -1, 1, -1, 5, -2, 1, -3, 4]) == [3, -2, 5, -1, 1, -1, 1, -1, 5] >>> max_subarray([-2, -3, 4, -1, -2, 1, 5, -3]) == [4, -1, -2, 1, 5]","solution":"def max_subarray(arr): n = len(arr) max_sum = -float('inf') current_sum = 0 start = end = temp_start = 0 for i in range(n): if current_sum <= 0: temp_start = i current_sum = arr[i] else: current_sum += arr[i] if current_sum > max_sum: max_sum = current_sum start = temp_start end = i elif current_sum == max_sum: if (i - temp_start) < (end - start): start = temp_start end = i return arr[start:end+1]"},{"question":"def min_changes_to_palindrome(S: str) -> int: Calculates the minimum number of character changes required to make the string S a palindrome. Parameters: S (str): The input string consisting of lowercase English letters. Returns: int: The minimum number of changes needed to make S a palindrome. >>> min_changes_to_palindrome(\\"abca\\") 1 >>> min_changes_to_palindrome(\\"race\\") 2 >>> min_changes_to_palindrome(\\"madam\\") 0 >>> min_changes_to_palindrome(\\"a\\") 0 >>> min_changes_to_palindrome(\\"aa\\") 0","solution":"def min_changes_to_palindrome(S): Calculates the minimum number of character changes required to make the string S a palindrome. Parameters: S (str): The input string consisting of lowercase English letters. Returns: int: The minimum number of changes needed to make S a palindrome. n = len(S) changes = 0 for i in range(n // 2): if S[i] != S[n - i - 1]: changes += 1 return changes"},{"question":"def can_be_constructed_by_repeating_substring(S: str) -> str: Determines if string S can be constructed by repeating a smaller substring. >>> can_be_constructed_by_repeating_substring(\\"ababab\\") 'YES' >>> can_be_constructed_by_repeating_substring(\\"abcabcabc\\") 'YES' >>> can_be_constructed_by_repeating_substring(\\"abcdabcd\\") 'YES' >>> can_be_constructed_by_repeating_substring(\\"aabb\\") 'NO'","solution":"def can_be_constructed_by_repeating_substring(S): Determines if string S can be constructed by repeating a smaller substring. Parameters: S (str): Input string Returns: str: 'YES' if S can be constructed by repeating a smaller substring, 'NO' otherwise n = len(S) for i in range(1, n // 2 + 1): if n % i == 0: if S[:i] * (n // i) == S: return \\"YES\\" return \\"NO\\""},{"question":"def max_sessions(sessions: List[Tuple[int, int]]) -> int: Determines the maximum number of non-overlapping sessions an employee can attend. >>> max_sessions([[1, 2], [2, 3], [3, 4], [1, 3], [4, 5]]) 4 >>> max_sessions([[1, 4], [2, 5], [3, 6]]) 1","solution":"def max_sessions(sessions): Determines the maximum number of non-overlapping sessions an employee can attend. Parameters: sessions (List[Tuple[int, int]]): A list of tuples where each tuple contains start and end times of a session Returns: int: Maximum number of sessions an employee can attend # Sort sessions by their end times sessions.sort(key=lambda x: x[1]) # Initialize the count of maximum sessions and the end time of the last attended session max_count = 0 last_end_time = 0 # Iterate over the sorted sessions for start, end in sessions: if start >= last_end_time: # If the session starts after or exactly when the last one ends, attend this one max_count += 1 last_end_time = end return max_count"},{"question":"def unique_integers(n: int, m: int, a: List[int], queries: List[Tuple[int, int]]) -> List[int]: Returns the number of unique integers for each of the given queries. n: int : size of the array m: int : number of queries a: list : array of n integers queries: list : list of tuples with two integers denoting the left and right indexes for each query Returns a list of integers representing the answer for each query. >>> unique_integers(5, 3, [5, 2, 7, 2, 5], [(1, 3), (2, 5), (1, 5)]) [3, 3, 3] >>> unique_integers(7, 4, [1, 1, 2, 2, 3, 3, 4], [(1, 4), (2, 5), (3, 7), (1, 7)]) [2, 3, 3, 4]","solution":"def unique_integers(n, m, a, queries): Returns the number of unique integers for each of the given queries. n: int : size of the array m: int : number of queries a: list : array of n integers queries: list : list of tuples with two integers denoting the left and right indexes for each query Returns a list of integers representing the answer for each query. result = [] for l, r in queries: # Slicing the list from index l-1 to r (inclusive) subarray = a[l-1:r] unique_elements = len(set(subarray)) # Using set to count unique elements result.append(unique_elements) return result"},{"question":"from typing import List, Tuple def max_scheduled_scientists(n: int, schedules: List[Tuple[int, int, int]]) -> int: Calculate the maximum number of scientists that can be accommodated based on their schedules. >>> max_scheduled_scientists(4, [(1, 4, 1), (2, 6, 1), (5, 7, 1), (3, 8, 2)]) 3 >>> max_scheduled_scientists(3, [(1, 3, 2), (2, 5, 2), (4, 6, 2)]) 2 >>> max_scheduled_scientists(5, [(1, 5, 1), (2, 6, 1), (3, 8, 2), (5, 9, 1), (6, 10, 2)]) 3 >>> max_scheduled_scientists(3, [(1, 3, 1), (4, 6, 1), (7, 9, 1)]) 3 >>> max_scheduled_scientists(3, [(1, 4, 1), (2, 5, 1), (3, 6, 1)]) 1 >>> max_scheduled_scientists(4, [(1, 3, 1), (4, 6, 1), (1, 3, 2), (4, 6, 2)]) 4 >>> max_scheduled_scientists(4, [(1, 4, 1), (3, 5, 1), (2, 6, 2), (5, 7, 2)]) 2","solution":"def max_scheduled_scientists(n, schedules): from collections import defaultdict # Group schedules by device device_schedules = defaultdict(list) for start, end, device in schedules: device_schedules[device].append((start, end)) def max_non_overlapping_intervals(intervals): # Sort intervals based on their end times intervals.sort(key=lambda x: x[1]) count = 0 end_time = 0 for start, end in intervals: if start >= end_time: count += 1 end_time = end return count # Calculate max scientists for each device and sum them up total_scientists = 0 for device, intervals in device_schedules.items(): total_scientists += max_non_overlapping_intervals(intervals) return total_scientists"},{"question":"from typing import List, Tuple def find_pairs(nums: List[int], target: int) -> List[Tuple[int, int]]: Create a function that takes a list of integers and a single integer target value. The function should return a list of unique pairs (tuples) from the input list that add up to the target value. Each pair should be in ascending order, and the list of pairs should also be sorted in ascending order. >>> find_pairs([1, 2, 3, 4, 5, 6], 7) [(1, 6), (2, 5), (3, 4)] >>> find_pairs([0, -1, 2, -3, 1], -2) [(-3, 1)] >>> find_pairs([1, 2, 3, 4, 5], 10) [] >>> find_pairs([1, 1, 2, 2, 3, 3, 4, 4], 5) [(1, 4), (2, 3)] >>> find_pairs([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5], 0) [(-5, 5), (-4, 4), (-3, 3), (-2, 2), (-1, 1)]","solution":"from typing import List, Tuple def find_pairs(nums: List[int], target: int) -> List[Tuple[int, int]]: Returns a list of unique pairs (tuples) from the input list that add up to the target value. Each pair should be in ascending order, and the list of pairs should also be sorted in ascending order. nums.sort() seen = set() pairs = set() for num in nums: complement = target - num if complement in seen: pairs.add((min(num, complement), max(num, complement))) seen.add(num) return sorted(pairs)"},{"question":"def count_increasing_pairs(n: int, array: List[int]) -> int: Counts the number of pairs of consecutive elements where the next element is greater than the current element. Parameters: n (int): Number of elements in the array. array (list of int): The elements of the array. Returns: int: Number of pairs where the next element is greater than the current. Examples: >>> count_increasing_pairs(5, [1, 2, 3, 2, 3]) 3 >>> count_increasing_pairs(6, [3, 3, 4, 2, 5, 6]) 3","solution":"def count_increasing_pairs(n, array): Counts the number of pairs of consecutive elements where the next element is greater than the current element. Parameters: n (int): Number of elements in the array. array (list of int): The elements of the array. Returns: int: Number of pairs where the next element is greater than the current. count = 0 for i in range(n - 1): if array[i] < array[i + 1]: count += 1 return count"},{"question":"def largest_rectangle_area(heights): Calculates the area of the largest rectangle that can be formed by consecutive buildings. Args: heights (List[int]): List of integers representing the heights of the buildings. Returns: int: The area of the largest rectangle. Examples: >>> largest_rectangle_area([2, 1, 5, 6, 2, 3]) 10 >>> largest_rectangle_area([1, 2, 3, 4, 5]) 9 >>> largest_rectangle_area([5, 4, 1, 2, 3]) 8 >>> largest_rectangle_area([4, 4, 4, 4]) 16 >>> largest_rectangle_area([6, 2, 5, 4, 5, 1, 6]) 12","solution":"def largest_rectangle_area(heights): Calculates the area of the largest rectangle that can be formed by consecutive buildings. :param heights: List of integers representing the heights of the buildings. :return: The area of the largest rectangle. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def optimal_player_sum(n: int, card_values: List[int], m: int) -> int: Returns the final sum of the first player's cards after both players pick m cards each optimally. >>> optimal_player_sum(6, [4, 3, 5, 1, 6, 2], 2) 11 >>> optimal_player_sum(1, [5], 1) 5 >>> optimal_player_sum(4, [3, 3, 3, 3], 2) 6 >>> optimal_player_sum(6, [10, 9, 8, 7, 6, 5], 3) 27 >>> optimal_player_sum(2, [10, 1], 1) 10 >>> optimal_player_sum(5, [50, 40, 30, 20, 10], 2) 90","solution":"def optimal_player_sum(n, card_values, m): Returns the final sum of the first player's cards after both players pick m cards each optimally. :param n: Number of cards on the table. :param card_values: List of integers representing the card values. :param m: Number of cards each player will pick. :return: Sum of the first player's cards after the game. # Sort the card values in descending order sorted_cards = sorted(card_values, reverse=True) # First player's strategy: Pick the first m highest cards first_player_sum = sum(sorted_cards[:m]) return first_player_sum"},{"question":"def min_total_bonuses(n: int, scores: List[int]) -> int: Determines the minimum total number of bonuses distributed among the employees based on their performance scores. Args: n: The number of employees. scores: A list of integers representing the performance scores of the employees. Returns: The minimum total number of bonuses distributed. >>> min_total_bonuses(6, [1, 2, 2, 3, 2, 1]) 10 >>> min_total_bonuses(4, [1, 2, 3, 4]) 10 >>> min_total_bonuses(4, [4, 3, 2, 1]) 10 >>> min_total_bonuses(4, [1, 1, 1, 1]) 4","solution":"def min_total_bonuses(n, scores): if n == 0: return 0 bonuses = [1] * n # First pass: Left to right for i in range(1, n): if scores[i] > scores[i - 1]: bonuses[i] = bonuses[i - 1] + 1 # Second pass: Right to left for i in range(n - 2, -1, -1): if scores[i] > scores[i + 1]: bonuses[i] = max(bonuses[i], bonuses[i + 1] + 1) return sum(bonuses)"},{"question":"def boring_sort(n, strings): Sorts strings by their boringness factor (sum of ASCII values of characters). >>> boring_sort(5, [\\"abc\\", \\"def\\", \\"ghi\\", \\"aaa\\", \\"zz\\"]) [\\"zz\\", \\"aaa\\", \\"abc\\", \\"def\\", \\"ghi\\"] >>> boring_sort(1, [\\"alphabet\\"]) [\\"alphabet\\"] >>> boring_sort(3, [\\"abc\\", \\"bca\\", \\"cab\\"]) [\\"abc\\", \\"bca\\", \\"cab\\"] >>> boring_sort(4, [\\"a\\", \\"aa\\", \\"aaa\\", \\"aaaa\\"]) [\\"a\\", \\"aa\\", \\"aaa\\", \\"aaaa\\"] >>> boring_sort(5, [\\"aaaa\\", \\"bbbb\\", \\"cccc\\", \\"ddd\\", \\"eeee\\"]) [\\"ddd\\", \\"aaaa\\", \\"bbbb\\", \\"cccc\\", \\"eeee\\"]","solution":"def boring_sort(n, strings): Sorts strings by their boringness factor (sum of ASCII values of characters). :param n: The number of strings :param strings: List of n strings to be sorted :return: List of strings sorted by their boringness factor def boringness_factor(s): return sum(ord(c) for c in s) # Sort strings with a key that determines their boringness factor sorted_strings = sorted(strings, key=boringness_factor) return sorted_strings"},{"question":"from typing import List def find_special_number_in_array(arr: List[int]) -> int: Write a function that takes an array of integers arr and returns the largest number in the array that is equal to the sum of three distinct elements of the array. If no such number exists, return -1. >>> find_special_number_in_array([2, 4, 3, 6, 8, 1]) 8 >>> find_special_number_in_array([1, 1, 1, 1]) -1 def test_examples(): assert find_special_number_in_array([2, 4, 3, 6, 8, 1]) == 8 assert find_special_number_in_array([1, 1, 1, 1]) == -1 assert find_special_number_in_array([5, 10, 15]) == -1 assert find_special_number_in_array([2, 2, 2, 2, 2]) == -1 assert find_special_number_in_array([1, 5, 7, 2, 3, 12, 10]) == 12 assert find_special_number_in_array([10]) == -1 assert find_special_number_in_array([1, 2, 3, 5]) == -1 assert find_special_number_in_array([1, 2, 3, 6, 8, 15]) == 15","solution":"from typing import List def find_special_number_in_array(arr: List[int]) -> int: n = len(arr) arr_set = set(arr) max_special_number = -1 for i in range(n): for j in range(i + 1, n): for k in range(j + 1, n): sum_three = arr[i] + arr[j] + arr[k] if sum_three in arr_set: max_special_number = max(max_special_number, sum_three) return max_special_number"},{"question":"def is_bps(s: str) -> str: Check if the given string is a Balanced Parentheses String (BPS). >>> is_bps(\\"()\\") 'Yes' >>> is_bps(\\"((()))\\") 'Yes' >>> is_bps(\\"(\\") 'No' >>> is_bps(\\"(()))\\") 'No'","solution":"def is_bps(s): Check if the given string is a Balanced Parentheses String (BPS). Parameters: s (str): the input string containing only '(' and ')' Returns: str: \\"Yes\\" if the string is a BPS, \\"No\\" otherwise. stack = [] for char in s: if char == '(': stack.append(char) elif char == ')': if not stack: return \\"No\\" stack.pop() return \\"Yes\\" if not stack else \\"No\\""},{"question":"def can_divide_grid(n, grid): Determine if it is possible to divide the grid into two identical shapes. Parameters: n (int): The size of the grid. grid (List[str]): A list of strings representing the grid. Returns: str: \\"YES\\" if it is possible to divide the grid into two identical shapes, \\"NO\\" otherwise. >>> can_divide_grid(4, ['.#..', '..#.', '.#..', '..#.']) 'YES' >>> can_divide_grid(3, ['#', '#', '#']) 'NO' >>> can_divide_grid(2, ['', '']) 'YES' def solution(t, test_cases): Determine the results for multiple test cases. Parameters: t (int): The number of test cases. test_cases (List[Tuple[int, List[str]]]): The list of test cases. Returns: List[str]: The list of results for each test case. >>> solution(3, [(4, ['.#..', '..#.', '.#..', '..#.']), (3, ['#', '#', '#']), (2, ['', ''])]) ['YES', 'NO', 'YES']","solution":"def can_divide_grid(n, grid): def check_vertical(): for mid in range(1, n): left = [row[:mid] for row in grid] right = [row[mid:] for row in grid] if left == right or left == [row[::-1] for row in right]: return True return False def check_horizontal(): for mid in range(1, n): top = grid[:mid] bottom = grid[mid:] if top == bottom or top == bottom[::-1]: return True return False if check_vertical() or check_horizontal(): return \\"YES\\" return \\"NO\\" def solution(t, test_cases): results = [] for i in range(t): n, grid = test_cases[i] results.append(can_divide_grid(n, grid)) return results"},{"question":"def shortest_subarray_length_with_k_distinct(n: int, k: int, arr: List[int]) -> int: Returns the length of the shortest contiguous subarray that contains at least one instance of k distinct integers. >>> shortest_subarray_length_with_k_distinct(8, 3, [1, 2, 1, 2, 3, 4, 5, 3]) 3 >>> shortest_subarray_length_with_k_distinct(5, 6, [1, 2, 3, 4, 5]) -1 >>> shortest_subarray_length_with_k_distinct(1, 1, [1]) 1 >>> shortest_subarray_length_with_k_distinct(4, 1, [2, 2, 2, 2]) 1 >>> shortest_subarray_length_with_k_distinct(4, 2, [2, 2, 2, 2]) -1 >>> shortest_subarray_length_with_k_distinct(7, 3, [1, 2, 1, 2, 3, 4, 3]) 3 >>> shortest_subarray_length_with_k_distinct(4, 4, [1, 2, 3, 4]) 4 >>> shortest_subarray_length_with_k_distinct(8, 3, [4, 1, 2, 3, 2, 4, 3, 2]) 3","solution":"def shortest_subarray_length_with_k_distinct(n, k, arr): Returns the length of the shortest contiguous subarray that contains at least one instance of k distinct integers. from collections import defaultdict if k > n: return -1 left = 0 right = 0 distinct_count = 0 frequency = defaultdict(int) min_length = float('inf') while right < n: frequency[arr[right]] += 1 if frequency[arr[right]] == 1: distinct_count += 1 while distinct_count >= k: min_length = min(min_length, right - left + 1) frequency[arr[left]] -= 1 if frequency[arr[left]] == 0: distinct_count -= 1 left += 1 right += 1 return min_length if min_length != float('inf') else -1"},{"question":"def min_days_to_distribute_gift_bags(N, K, M): Calculates the minimum number of days needed to distribute N gift bags given that a maximum of K gift bags can be distributed each day and there are M days to finish the distribution. >>> min_days_to_distribute_gift_bags(20, 5, 7) 4 >>> min_days_to_distribute_gift_bags(15, 3, 10) 5 >>> min_days_to_distribute_gift_bags(12, 4, 5) 3 >>> min_days_to_distribute_gift_bags(50, 8, 5) 5 >>> min_days_to_distribute_gift_bags(1000, 1, 1000) 1000 >>> min_days_to_distribute_gift_bags(10, 10, 1) 1 >>> min_days_to_distribute_gift_bags(1, 1, 1) 1 >>> min_days_to_distribute_gift_bags(9, 3, 10) 3 >>> min_days_to_distribute_gift_bags(1000, 1000, 1) 1","solution":"def min_days_to_distribute_gift_bags(N, K, M): Calculates the minimum number of days needed to distribute N gift bags given that a maximum of K gift bags can be distributed each day and there are M days to finish the distribution. # Ensure that we are not exceeding the maximum allowed days max_possible_days = min((N + K - 1) // K, M) return max_possible_days"},{"question":"from typing import List, Tuple from collections import deque, defaultdict def min_time_to_complete_tasks(n: int, m: int, dependencies: List[Tuple[int, int]]) -> int: Calculate the minimum time required to complete all tasks, given the number of tasks and dependencies. Args: n: int - The number of tasks. m: int - The number of dependencies. dependencies: List[Tuple[int, int]] - The list of dependencies where each tuple (a, b) indicates task a must be completed before task b. Returns: int - The minimum time required to complete all tasks. >>> min_time_to_complete_tasks(5, 4, [(1, 2), (1, 3), (3, 4), (4, 5)]) 4 >>> min_time_to_complete_tasks(5, 3, [(1, 2), (2, 3), (4, 5)]) 3 if __name__ == \\"__main__\\": n1, m1 = 5, 4 dependencies1 = [(1, 2), (1, 3), (3, 4), (4, 5)] print(min_time_to_complete_tasks(n1, m1, dependencies1)) # Expected output: 4 n2, m2 = 5, 3 dependencies2 = [(1, 2), (2, 3), (4, 5)] print(min_time_to_complete_tasks(n2, m2, dependencies2)) # Expected output: 3","solution":"from collections import deque, defaultdict def min_time_to_complete_tasks(n, m, dependencies): indegree = [0] * (n + 1) adj_list = defaultdict(list) # Build adjacency list and compute in-degrees for a, b in dependencies: adj_list[a].append(b) indegree[b] += 1 # Queue for tasks with no incoming edges queue = deque() for i in range(1, n + 1): if indegree[i] == 0: queue.append(i) time = 0 tasks_completed = 0 # Process tasks while there are tasks in the queue while queue: # Number of tasks that can be done in parallel at this time unit size = len(queue) tasks_completed += size for _ in range(size): task = queue.popleft() for neighbor in adj_list[task]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) time += 1 # If all tasks are completed, return the time taken if tasks_completed == n: return time else: return -1 # This would mean there is a cycle or some error # Sample usage with the provided examples if __name__ == \\"__main__\\": n1, m1 = 5, 4 dependencies1 = [(1, 2), (1, 3), (3, 4), (4, 5)] print(min_time_to_complete_tasks(n1, m1, dependencies1)) # Expected output: 4 n2, m2 = 5, 3 dependencies2 = [(1, 2), (2, 3), (4, 5)] print(min_time_to_complete_tasks(n2, m2, dependencies2)) # Expected output: 3"},{"question":"def count_teams(N: int, roles: List[str]) -> int: Count the number of ways to form teams of 3 with one person of each role, where roles can be \\"Engineer\\", \\"Product Manager\\", and \\"Designer\\". :param N: Integer, number of employees :param roles: List of strings, role of each employee :return: Integer, number of ways to form the teams >>> count_teams(6, ['Engineer', 'Product Manager', 'Designer', 'Engineer', 'Product Manager', 'Designer']) 8 >>> count_teams(3, ['Engineer', 'Product Manager', 'Designer']) 1 >>> count_teams(4, ['Engineer', 'Engineer', 'Product Manager', 'Product Manager']) 0","solution":"def count_teams(N, roles): Count the number of ways to form teams of 3 with one person of each role. :param N: Integer, number of employees :param roles: List of strings, role of each employee :return: Integer, number of ways to form the teams role_counts = {\\"Engineer\\": 0, \\"Product Manager\\": 0, \\"Designer\\": 0} for role in roles: if role in role_counts: role_counts[role] += 1 return role_counts[\\"Engineer\\"] * role_counts[\\"Product Manager\\"] * role_counts[\\"Designer\\"]"},{"question":"from typing import List, Tuple def most_frequently_viewed_product(product_views: List[Tuple[int, int]], queries: List[Tuple[int, int]]) -> List[int]: Find the most frequently viewed product within specified time intervals. For each query, determine the product ID of the most frequently viewed product in the given time interval. If there's a tie, output the smallest product ID among the tied products. :param product_views: List of tuples, each containing a timestamp and a product ID. :param queries: List of tuples, each containing a start and end time for queries. :return: List of product IDs that are most frequently viewed in the specified intervals. >>> most_frequently_viewed_product([(1, 101), (2, 102), (2, 101), (3, 102), (4, 101), (5, 103)], [(1, 3), (2, 4), (1, 5)]) [101, 101, 101] >>> most_frequently_viewed_product([(5, 201), (10, 202), (10, 201), (15, 202), (20, 201), (25, 203)], [(5, 15), (10, 20), (1, 25)]) [201, 201, 201] >>> most_frequently_viewed_product([], [(1, 3)]) [None] >>> most_frequently_viewed_product([(1, 301), (2, 302), (3, 302), (4, 301)], [(1, 4)]) [301] >>> most_frequently_viewed_product([(1, 401)], [(1, 1)]) [401]","solution":"from collections import defaultdict from bisect import bisect_left, bisect_right def most_frequently_viewed_product(product_views, queries): Find the most frequently viewed product in the specified time intervals. :param product_views: List of tuples, each containing a timestamp and a product ID. :param queries: List of tuples, each containing a start and end time for queries. :return: List of product IDs that are most frequently viewed in the specified intervals. # Dictionary to store views based on time time_product_dict = defaultdict(list) for timestamp, product_id in product_views: time_product_dict[timestamp].append(product_id) # Convert dictionary to sorted list of tuples for quick lookups sorted_times = sorted(time_product_dict.keys()) # Function to get product counts in a given time range def get_product_counts(start, end): product_counts = defaultdict(int) start_idx = bisect_left(sorted_times, start) end_idx = bisect_right(sorted_times, end) - 1 for time in sorted_times[start_idx:end_idx + 1]: for product in time_product_dict[time]: product_counts[product] += 1 return product_counts results = [] for start, end in queries: product_counts = get_product_counts(start, end) # Determine the most frequently viewed product max_views = 0 most_viewed_product = None for product, count in product_counts.items(): if count > max_views or (count == max_views and product < most_viewed_product): max_views = count most_viewed_product = product results.append(most_viewed_product) return results # Wrapper to read input and output results def e_commerce_site(input_lines): lines = input_lines.strip().split('n') n = int(lines[0]) product_views = [] for i in range(1, n + 1): t, p = map(int, lines[i].split()) product_views.append((t, p)) q = int(lines[n + 1]) queries = [] for j in range(n + 2, n + 2 + q): start, end = map(int, lines[j].split()) queries.append((start, end)) return most_frequently_viewed_product(product_views, queries)"},{"question":"def can_fill_quantities(container_capacities: List[int], water_quantities: List[int]) -> str: Determine whether you can fill each of the water quantities exactly using the given containers at least once. Each container can be used only once. >>> can_fill_quantities([10, 20, 30], [20, 40]) \\"YES\\" >>> can_fill_quantities([15, 25], [10, 15, 40]) \\"NO\\"","solution":"from itertools import combinations def can_fill_quantities(container_capacities, water_quantities): n = len(container_capacities) possible_sums = set() # Generate all possible sums using the container capacities for i in range(1, n+1): for combination in combinations(container_capacities, i): possible_sums.add(sum(combination)) # Check if all water quantities can be exactly filled for quantity in water_quantities: if quantity not in possible_sums: return \\"NO\\" return \\"YES\\""},{"question":"def custom_sort(arr): Given an unsorted array of integers, this function sorts the array in a specific order: 1. Sorts the array in ascending order. 2. Reorders the array such that every third element is taken first, followed by every second element, and then every first element. Parameters: arr (list): The list of integers to be sorted and reordered. Returns: list: The reordered list. from solution import custom_sort def test_custom_sort_example(): assert custom_sort([3, 1, 2, 5, 4]) == [1, 4, 2, 5, 3] def test_custom_sort_single_element(): assert custom_sort([1]) == [1] assert custom_sort([5]) == [5] def test_custom_sort_two_elements(): assert custom_sort([2, 1]) == [1, 2] assert custom_sort([5, 3]) == [3, 5] def test_custom_sort_three_elements(): assert custom_sort([2, 3, 1]) == [1, 2, 3] assert custom_sort([7, 5, 6]) == [5, 6, 7] def test_custom_sort_multiple_elements(): assert custom_sort([10, 20, 30, 40, 50, 60]) == [10, 40, 20, 50, 30, 60] assert custom_sort([1, 3, 5, 7, 9, 2, 4, 6, 8]) == [1, 4, 7, 2, 5, 8, 3, 6, 9] assert custom_sort([9, 8, 7, 6, 5, 4, 3, 2, 1]) == [1, 4, 7, 2, 5, 8, 3, 6, 9] def test_custom_sort_empty(): assert custom_sort([]) == []","solution":"def custom_sort(arr): Given an unsorted array of integers, this function sorts the array in a specific order: 1. Sorts the array in ascending order. 2. Reorders the array such that every third element is taken first, followed by every second element, and then every first element. Parameters: arr (list): The list of integers to be sorted and reordered. Returns: list: The reordered list. if not arr: return [] sorted_arr = sorted(arr) n = len(sorted_arr) third_elements = sorted_arr[::3] second_elements = sorted_arr[1::3] first_elements = sorted_arr[2::3] result = third_elements + second_elements + first_elements return result"},{"question":"from typing import List def min_swaps_to_sort_string(s: str) -> int: Determine the minimum number of swaps required to make the string either non-decreasing or non-increasing. >>> min_swaps_to_sort_string(\\"bac\\") 1 >>> min_swaps_to_sort_string(\\"abc\\") 0 >>> min_swaps_to_sort_string(\\"ccc\\") 0 >>> min_swaps_to_sort_string(\\"cba\\") 0 >>> min_swaps_to_sort_string(\\"bca\\") 1 >>> min_swaps_to_sort_string(\\"cab\\") 1 >>> min_swaps_to_sort_string(\\"bbbaaa\\") 0 >>> min_swaps_to_sort_string(\\"aabbcc\\") 0 def min_swaps_all_cases(test_cases: List[str]) -> List[int]: Determine the minimum number of swaps for a list of test cases. >>> min_swaps_all_cases([\\"bac\\", \\"abc\\", \\"ccc\\", \\"cba\\", \\"bca\\", \\"cab\\", \\"bbbaaa\\", \\"aabbcc\\"]) [1, 0, 0, 0, 1, 1, 0, 0] def test_min_swaps_to_sort_string(): assert min_swaps_to_sort_string(\\"bac\\") == 1 assert min_swaps_to_sort_string(\\"abc\\") == 0 assert min_swaps_to_sort_string(\\"ccc\\") == 0 assert min_swaps_to_sort_string(\\"cba\\") == 0 assert min_swaps_to_sort_string(\\"bca\\") == 1 assert min_swaps_to_sort_string(\\"cab\\") == 1 assert min_swaps_to_sort_string(\\"bbbaaa\\") == 0 assert min_swaps_to_sort_string(\\"aabbcc\\") == 0 def test_min_swaps_all_cases(): test_cases = [\\"bac\\", \\"abc\\", \\"ccc\\", \\"cba\\", \\"bca\\", \\"cab\\", \\"bbbaaa\\", \\"aabbcc\\"] expected_results = [1, 0, 0, 0, 1, 1, 0, 0] results = min_swaps_all_cases(test_cases) assert results == expected_results","solution":"def min_swaps_to_sort_string(s: str) -> int: n = len(s) def count_swaps(target): swaps = 0 j = 0 for i in range(n): while j < n and target[j] != s[i]: j += 1 if j < n: swaps += abs(i - j) j += 1 return swaps sorted_string = ''.join(sorted(s)) rev_sorted_string = ''.join(sorted(s, reverse=True)) return min(count_swaps(sorted_string), count_swaps(rev_sorted_string)) def min_swaps_all_cases(test_cases): results = [] for s in test_cases: results.append(min_swaps_to_sort_string(s)) return results if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() t = int(data[0]) test_cases = data[1:t + 1] results = min_swaps_all_cases(test_cases) for res in results: print(res)"},{"question":"def move_robot(commands: str) -> (int, int): Determine the final coordinates of the robot after executing all the commands on an infinitely large, two-dimensional grid. Parameters: commands (str): A string consisting of commands ('U', 'D', 'L', 'R'). Returns: (int, int): Final coordinates of the robot as a tuple (x, y). Examples: >>> move_robot(\\"UUDDLRLR\\") (0, 0) >>> move_robot(\\"UURR\\") (2, 2)","solution":"def move_robot(commands): Determine the final coordinates of the robot after executing all the commands on an infinitely large, two-dimensional grid. Parameters: commands (str): A string consisting of commands ('U', 'D', 'L', 'R'). Returns: (int, int): Final coordinates of the robot as a tuple (x, y). x, y = 0, 0 for command in commands: if command == 'U': y += 1 elif command == 'D': y -= 1 elif command == 'L': x -= 1 elif command == 'R': x += 1 return x, y # Read input from standard input if __name__ == \\"__main__\\": import sys commands = sys.stdin.read().strip() final_coordinates = move_robot(commands) print(final_coordinates[0], final_coordinates[1])"},{"question":"def count_primes_in_interval(L: int, R: int) -> int: Returns the number of prime numbers in the interval [L, R] (both inclusive). >>> count_primes_in_interval(10, 20) 4 >>> count_primes_in_interval(14, 16) 0 >>> count_primes_in_interval(2, 2) 1 >>> count_primes_in_interval(2, 7) 4 # implement the function def sieve_of_eratosthenes(max_num: int) -> List[int]: Helper function to generate a list of primes up to max_num using the Sieve of Eratosthenes. def test_single_prime(): assert count_primes_in_interval(2, 2) == 1 def test_no_primes(): assert count_primes_in_interval(14, 16) == 0 def test_multiple_primes(): assert count_primes_in_interval(10, 20) == 4 # primes are 11, 13, 17, 19 def test_entirely_prime_range(): assert count_primes_in_interval(2, 7) == 4 # primes are 2, 3, 5, 7 def test_large_range(): assert count_primes_in_interval(1, 100) == 25 # there are 25 primes between 1 and 100 def test_invalid_input_L_greater_than_R(): try: count_primes_in_interval(20, 10) except ValueError as e: assert str(e) == 'Inputs should be in range 1  L  R  10^6' def test_invalid_input_L_out_of_range(): try: count_primes_in_interval(0, 10) except ValueError as e: assert str(e) == 'Inputs should be in range 1  L  R  10^6' def test_invalid_input_R_out_of_range(): try: count_primes_in_interval(10, 1000001) except ValueError as e: assert str(e) == 'Inputs should be in range 1  L  R  10^6'","solution":"def sieve_of_eratosthenes(max_num): Helper function to generate a list of primes up to max_num using the Sieve of Eratosthenes. is_prime = [True] * (max_num + 1) is_prime[0], is_prime[1] = False, False for start in range(2, int(max_num ** 0.5) + 1): if is_prime[start]: for multiple in range(start * start, max_num + 1, start): is_prime[multiple] = False return [num for num, prime in enumerate(is_prime) if prime] def count_primes_in_interval(L, R): Returns the number of prime numbers in the interval [L, R] (both inclusive). if L < 1 or R < 1 or L > R or R > 10**6: raise ValueError(\\"Inputs should be in range 1  L  R  10^6\\") primes = sieve_of_eratosthenes(R) count = 0 for prime in primes: if L <= prime <= R: count += 1 return count"},{"question":"def first_repeating_character(s: str) -> str: Returns the first repeating character in the string \`s\`. If there is no repeating character, returns '_'. >>> first_repeating_character(\\"abacabad\\") 'a' >>> first_repeating_character(\\"abcdef\\") '_'","solution":"def first_repeating_character(s): Returns the first repeating character in the string \`s\`. If there is no repeating character, returns '_'. seen = set() for char in s: if char in seen: return char seen.add(char) return '_'"},{"question":"def parse_input(input_str: str): Parse input data to extract employee time information. Args: input_str (str): Input string containing multiple datasets of employee times. Returns: List[Tuple[Tuple[int, int], List[List[int]]]]: Parsed datasets. >>> parse_input(\\"3 2n10 20n15 30n25 35n2 3n5 10 15n10 20 30n0 0n\\") [((3, 2), [[10, 20], [15, 30], [25, 35]]), ((2, 3), [[5, 10, 15], [10, 20, 30]])] pass def calculate_total_time(datasets): Calculate total time for each employee to complete all obstacles. Args: datasets (List[Tuple[Tuple[int, int], List[List[int]]]]): List of parsed datasets. Returns: List[int]: Total times for each employee. >>> calculate_total_time([((3, 2), [[10, 20], [15, 30], [25, 35]]), ((2, 3), [[5, 10, 15], [10, 20, 30]])]) [30, 45, 60, 30, 60] pass","solution":"def calculate_total_time(datasets): result = [] for dataset in datasets: m, n = dataset[0] times = dataset[1] for i in range(m): result.append(sum(times[i])) return result def parse_input(input_str): lines = input_str.strip().split('n') datasets = [] i = 0 while i < len(lines): m, n = map(int, lines[i].split()) if m == 0 and n == 0: break i += 1 times = [] for _ in range(m): times.append(list(map(int, lines[i].split()))) i += 1 datasets.append(((m, n), times)) return datasets"},{"question":"def next_palindrome(n: int) -> int: Finds the smallest palindrome number greater than the given number n. >>> next_palindrome(123) 131 >>> next_palindrome(450) 454 def process_test_cases(T: int, cases: List[int]) -> List[int]: Processes list of test cases and returns a list of results. >>> process_test_cases(2, [123, 450]) [131, 454] >>> process_test_cases(3, [987, 999, 1000]) [989, 1001, 1001]","solution":"def next_palindrome(n): Finds the smallest palindrome number greater than the given number n. n += 1 while str(n) != str(n)[::-1]: n += 1 return n def process_test_cases(T, cases): Processes list of test cases and returns a list of results. results = [] for case in cases: results.append(next_palindrome(case)) return results"},{"question":"def remove_consecutive_duplicates(T: int, test_cases: List[str]) -> List[str]: Removes consecutive duplicate characters from each string in the test cases. Parameters: - T: integer, the number of test cases. - test_cases: list of strings, strings to process. Returns: List of resulting strings after removing consecutive duplicates for each test case. Examples: >>> remove_consecutive_duplicates(3, [\\"aabbcc\\", \\"abcaa\\", \\"aabbca\\"]) [\\"abc\\", \\"abca\\", \\"abca\\"] >>> remove_consecutive_duplicates(1, [\\"\\"]) [\\"\\"] >>> remove_consecutive_duplicates(1, [\\"a\\"]) [\\"a\\"] >>> remove_consecutive_duplicates(1, [\\"b\\"]) [\\"b\\"] >>> remove_consecutive_duplicates(1, [\\"abcdef\\"]) [\\"abcdef\\"] >>> remove_consecutive_duplicates(1, [\\"aaaaaaa\\"]) [\\"a\\"] >>> remove_consecutive_duplicates(2, [\\"aabbaa\\", \\"ccddaabbbcc\\"]) [\\"aba\\", \\"cdabc\\"]","solution":"def remove_consecutive_duplicates(T, test_cases): Removes consecutive duplicate characters from each string in the test cases. Parameters: - T: integer, the number of test cases. - test_cases: list of strings, strings to process. Returns: List of resulting strings after removing consecutive duplicates for each test case. results = [] for S in test_cases: if not S: results.append(\\"\\") continue result = [S[0]] for char in S[1:]: if char != result[-1]: result.append(char) results.append(\\"\\".join(result)) return results"},{"question":"def knapsack(n: int, W: int, items: List[Tuple[int, int]]) -> int: Compute the maximum total value of items that can be included in the truck without exceeding the maximum weight limit. >>> knapsack(4, 7, [(1, 1), (3, 4), (4, 5), (5, 7)]) 9 >>> knapsack(3, 50, [(10, 60), (20, 100), (30, 120)]) 220","solution":"def knapsack(n, W, items): # Create a 2D DP array initialized to 0 dp = [[0] * (W + 1) for _ in range(n + 1)] # Iterate over all items for i in range(1, n + 1): weight, value = items[i - 1] for w in range(1, W + 1): if weight <= w: # Maximize value by including or excluding the current item dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weight] + value) else: # Exclude current item dp[i][w] = dp[i - 1][w] # Return the maximum value which is found at dp[n][W] return dp[n][W] # Example usage n = 4 W = 7 items = [(1, 1), (3, 4), (4, 5), (5, 7)] print(knapsack(n, W, items)) # Output: 9 n = 3 W = 50 items = [(10, 60), (20, 100), (30, 120)] print(knapsack(n, W, items)) # Output: 220"},{"question":"def canReachDestination(n: int, m: int, k: int, grid: List[List[int]]) -> str: Determine if there exists a path from the top-left corner to the bottom-right corner in a grid such that the height difference between consecutive cells in the path is at most k. Parameters: n (int): number of rows in the grid m (int): number of columns in the grid k (int): maximum allowed height difference between consecutive cells grid (List[List[int]]): the grid of terrain heights Returns: str: \\"YES\\" if such a path exists, otherwise \\"NO\\" Examples: >>> canReachDestination(3, 3, 2, [[1, 2, 3], [2, 3, 4], [3, 4, 5]]) \\"YES\\" >>> canReachDestination(3, 3, 1, [[1, 2, 3], [2, 3, 5], [3, 5, 5]]) \\"NO\\" >>> canReachDestination(1, 1, 0, [[0]]) \\"YES\\" from typing import List","solution":"def canReachDestination(n, m, k, grid): def isValid(x, y): return 0 <= x < n and 0 <= y < m def dfs(x, y): if x == n - 1 and y == m - 1: return True visited.add((x, y)) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if isValid(nx, ny) and (nx, ny) not in visited and abs(grid[x][y] - grid[nx][ny]) <= k: if dfs(nx, ny): return True return False visited = set() return \\"YES\\" if dfs(0, 0) else \\"NO\\""},{"question":"def smallest_subsequence(s: str, k: int) -> str: Returns the lexicographically smallest subsequence of length k from the given string s. >>> smallest_subsequence(\\"abcde\\", 3) \\"abc\\" >>> smallest_subsequence(\\"bacd\\", 2) \\"ac\\" >>> smallest_subsequence(\\"zxyab\\", 3) \\"xab\\"","solution":"def smallest_subsequence(s, k): Returns the lexicographically smallest subsequence of length k from the given string s. stack = [] to_remove = len(s) - k for i, ch in enumerate(s): while stack and to_remove > 0 and stack[-1] > ch: stack.pop() to_remove -= 1 stack.append(ch) return ''.join(stack[:k])"},{"question":"def count_substrings_with_same_first_last_char(s: str) -> int: Computes the number of distinct non-empty substrings that have the same first and last character. >>> count_substrings_with_same_first_last_char(\\"abcab\\") 7 >>> count_substrings_with_same_first_last_char(\\"aaaa\\") 10","solution":"def count_substrings_with_same_first_last_char(s): Computes the number of distinct non-empty substrings that have the same first and last character. n = len(s) result = 0 for i in range(n): j = i + 1 while j <= n: if s[i] == s[j - 1]: result += 1 j += 1 return result"},{"question":"def roman_to_arabic(roman: str) -> int: Convert a Roman numeral to an Arabic numeral. >>> roman_to_arabic(\\"I\\") 1 >>> roman_to_arabic(\\"IV\\") 4 >>> roman_to_arabic(\\"IX\\") 9 def arabic_to_roman(arabic: int) -> str: Convert an Arabic numeral to a Roman numeral. >>> arabic_to_roman(1) \\"I\\" >>> arabic_to_roman(4) \\"IV\\" >>> arabic_to_roman(9) \\"IX\\" def mixed_numeral_calculator(operation: str, numeral1: str, numeral2: str, resultformat: str) -> str: Perform operations on mixed numeral systems and return the result in the specified format. >>> mixed_numeral_calculator('+', '50', 'L', 'A') \\"100\\" >>> mixed_numeral_calculator('*', 'X', 'X', 'R') \\"C\\"","solution":"def roman_to_arabic(roman): roman_values = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000} total = 0 prev_value = 0 for char in reversed(roman): value = roman_values[char] if value < prev_value: total -= value else: total += value prev_value = value return total def arabic_to_roman(arabic): val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syms = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman = '' i = 0 while arabic > 0: for _ in range(arabic // val[i]): roman += syms[i] arabic -= val[i] i += 1 return roman def mixed_numeral_calculator(operation, numeral1, numeral2, resultformat): if numeral1.isdigit(): num1 = int(numeral1) else: num1 = roman_to_arabic(numeral1) if numeral2.isdigit(): num2 = int(numeral2) else: num2 = roman_to_arabic(numeral2) if not (1 <= num1 <= 3999 and 1 <= num2 <= 3999): return \\"error\\" if operation == '+': result = num1 + num2 elif operation == '-': result = num1 - num2 elif operation == '*': result = num1 * num2 elif operation == '/': if num2 == 0: return \\"error\\" result = num1 // num2 else: return \\"error\\" if resultformat == 'A': return str(result) elif resultformat == 'R': if not (1 <= result <= 3999): return \\"error\\" return arabic_to_roman(result) else: return \\"error\\""},{"question":"def possible_to_sort(n: int, x: int, y: int, arr: List[int]) -> Union[List[int], str]: Determines if it's possible to sort the array using the allowed operations. If possible, returns the sorted array. Otherwise, returns \\"Not possible\\". >>> possible_to_sort(5, 1, 2, [3, 1, 4, 1, 5]) [1, 1, 3, 4, 5] >>> possible_to_sort(3, 2, 3, [3, 2, 1]) \\"Not possible\\" pass","solution":"def possible_to_sort(n, x, y, arr): Determines if it's possible to sort the array using the allowed operations. If possible, returns the sorted array. Otherwise, returns \\"Not possible\\". if x == 0 or y == 0: return \\"Not possible\\" def can_swap_within_segment(segment): Helper function to determine if the segment can be fully sorted using swaps with given differences. indices = set(range(len(segment))) visited = set() # Use DFS to explore all reachable indices def dfs(index): if index in visited: return visited.add(index) if index + x < len(segment) and index + x not in visited: dfs(index + x) if index - x >= 0 and index - x not in visited: dfs(index - x) if index + y < len(segment) and index + y not in visited: dfs(index + y) if index - y >= 0 and index - y not in visited: dfs(index - y) for i in range(len(segment)): if i not in visited: component = [] dfs(i) for j in visited: component.append(segment[j]) # Sort the found component component.sort() k = 0 for j in sorted(visited): segment[j] = component[k] k += 1 visited = set() return segment sorted_arr = sorted(arr) segments = {} # A map to keep track of segments identified by their starting points for start in range(n): reachable = [start] reachable_set = {start} i = 0 while i < len(reachable): current = reachable[i] if current + x < n and current + x not in reachable_set: reachable.append(current + x) reachable_set.add(current + x) if current - x >= 0 and current - x not in reachable_set: reachable.append(current - x) reachable_set.add(current - x) if current + y < n and current + y not in reachable_set: reachable.append(current + y) reachable_set.add(current + y) if current - y >= 0 and current - y not in reachable_set: reachable.append(current - y) reachable_set.add(current - y) i += 1 reachable.sort() if tuple(reachable) not in segments: segments[tuple(reachable)] = can_swap_within_segment([arr[i] for i in reachable]) for segment in segments.values(): if segment != sorted(segment): return \\"Not possible\\" result = [0] * n for segment in segments.items(): indices, values = segment values.sort() for i, index in enumerate(indices): result[index] = values[i] return result # Example usage if __name__ == \\"__main__\\": n, x, y = 5, 1, 2 arr = [3, 1, 4, 1, 5] print(possible_to_sort(n, x, y, arr)) # Output: [1, 1, 3, 4, 5] n, x, y = 3, 2, 3 arr = [3, 2, 1] print(possible_to_sort(n, x, y, arr)) # Output: Not possible"},{"question":"def is_arithmetic_progression(n: int, numbers: List[int]) -> str: Determines if the list of numbers forms an arithmetic progression. Args: n (int): The number of elements in the list. numbers (list of int): The elements of the list. Returns: str: \\"YES\\" if the list forms an arithmetic progression, otherwise \\"NO\\". >>> is_arithmetic_progression(5, [2, 4, 6, 8, 10]) 'YES' >>> is_arithmetic_progression(4, [3, 1, 3, 7]) 'NO' >>> is_arithmetic_progression(3, [5, 5, 5]) 'YES' from typing import List def test_valid_progression(): assert is_arithmetic_progression(5, [2, 4, 6, 8, 10]) == \\"YES\\" def test_invalid_progression(): assert is_arithmetic_progression(4, [3, 1, 3, 7]) == \\"NO\\" def test_constant_progression(): assert is_arithmetic_progression(3, [5, 5, 5]) == \\"YES\\" def test_single_element(): assert is_arithmetic_progression(1, [5]) == \\"NO\\" def test_two_elements(): assert is_arithmetic_progression(2, [7, 10]) == \\"YES\\" assert is_arithmetic_progression(2, [10, 7]) == \\"YES\\" def test_reverse_order(): assert is_arithmetic_progression(5, [10, 8, 6, 4, 2]) == \\"YES\\" def test_zero_difference(): assert is_arithmetic_progression(4, [4, 4, 4, 4]) == \\"YES\\"","solution":"def is_arithmetic_progression(n, numbers): Determines if the list of numbers forms an arithmetic progression. Args: n (int): The number of elements in the list. numbers (list of int): The elements of the list. Returns: str: \\"YES\\" if the list forms an arithmetic progression, otherwise \\"NO\\". if n <= 1: return \\"NO\\" numbers.sort() common_difference = numbers[1] - numbers[0] for i in range(2, n): if numbers[i] - numbers[i - 1] != common_difference: return \\"NO\\" return \\"YES\\""},{"question":"import math from functools import reduce def max_min_gcd(n: int, sequence: List[int]) -> int: Returns the maximum possible value of the smallest number in the sequence after performing an arbitrary number of GCD operations. :param n: An integer, the number of elements in the sequence. :param sequence: A list of integers, the initial sequence of numbers. :return: An integer, the maximum possible value of the smallest number in the sequence. >>> max_min_gcd(3, [10, 14, 35]) 1 >>> max_min_gcd(4, [12, 15, 18, 21]) 3","solution":"import math from functools import reduce def max_min_gcd(n, sequence): Returns the maximum possible value of the smallest number in the sequence after performing an arbitrary number of GCD operations. :param n: An integer, the number of elements in the sequence. :param sequence: A list of integers, the initial sequence of numbers. :return: An integer, the maximum possible value of the smallest number in the sequence. # Calculate the GCD of the entire sequence overall_gcd = reduce(math.gcd, sequence) return overall_gcd"},{"question":"def find_unsorted_subarray(arr): Returns the length of the smallest subarray that needs to be sorted to make the entire array sorted in non-decreasing order. >>> find_unsorted_subarray([1, 2, 3, 4, 5]) 0 >>> find_unsorted_subarray([5, 4, 3, 2, 1]) 5 >>> find_unsorted_subarray([1, 3, 2, 4, 5]) 2 >>> find_unsorted_subarray([1, 2, 6, 4, 5, 7]) 3 >>> find_unsorted_subarray([1, 3, 3, 2, 2, 4, 5]) 4 >>> find_unsorted_subarray([1]) 0 >>> find_unsorted_subarray([2, 1]) 2 >>> find_unsorted_subarray([1, 2, 3, 6, 5, 4]) 3 >>> find_unsorted_subarray([6, 5, 4, 7, 8, 9]) 3","solution":"def find_unsorted_subarray(arr): Returns the length of the smallest subarray that needs to be sorted to make the entire array sorted in non-decreasing order. n = len(arr) if n <= 1: return 0 start = 0 end = n - 1 while start < n - 1 and arr[start] <= arr[start + 1]: start += 1 while end > 0 and arr[end] >= arr[end - 1]: end -= 1 if start >= end: return 0 min_subarray = min(arr[start:end + 1]) max_subarray = max(arr[start:end + 1]) while start > 0 and arr[start - 1] > min_subarray: start -= 1 while end < n - 1 and arr[end + 1] < max_subarray: end += 1 return end - start + 1"},{"question":"def min_hacking_tools_required(T, test_cases): Determine the minimum number of hacking tools required to hack all the servers. Args: T : int : number of test cases test_cases : list : list of dictionaries with the following keys: 'n' : int : the number of servers 'servers' : list : list of integers representing the security levels of the servers 'm' : int : the number of hacking tools 'tools' : list : list of integers representing the power levels of the hacking tools Returns: list : a list of integers where each integer represents the minimum number of hacking tools required for the corresponding test case. If it is not possible to hack all the servers, return -1. Example: >>> min_hacking_tools_required(1, [{'n': 5, 'servers': [4, 3, 5, 7, 6], 'm': 4, 'tools': [3, 5, 2, 8]}]) [3] >>> min_hacking_tools_required(1, [{'n': 3, 'servers': [5, 6, 7], 'm': 2, 'tools': [5, 6]}]) [-1]","solution":"def min_hacking_tools_required(T, test_cases): results = [] for case in test_cases: n = case['n'] servers = sorted(case['servers']) m = case['m'] tools = sorted(case['tools']) if max(servers) > max(tools): results.append(-1) continue server_index = 0 tool_index = 0 tools_used = 0 while server_index < n: if tool_index == m: results.append(-1) break if tools[tool_index] >= servers[server_index]: tools_used += 1 powered_servers = tools[tool_index] while server_index < n and servers[server_index] <= powered_servers: server_index += 1 tool_index += 1 if server_index == n: results.append(tools_used) return results"},{"question":"def is_palindrome(s: str) -> bool: Determines if the input string is a palindrome considering only alphanumeric characters and ignoring case sensitivity. :param s: Input string :return: True if the string is a palindrome, else False >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") == True >>> is_palindrome(\\"race a car\\") == False >>> is_palindrome(\\"\\") == True >>> is_palindrome(\\"a\\") == True >>> is_palindrome(\\"A\\") == True >>> is_palindrome(\\"1\\") == True >>> is_palindrome(\\"No lemon, no melon\\") == True >>> is_palindrome(\\"Hello, World!\\") == False >>> is_palindrome(\\"12321\\") == True >>> is_palindrome(\\"123321\\") == True >>> is_palindrome(\\"123456\\") == False","solution":"def is_palindrome(s): Determines if the input string is a palindrome considering only alphanumeric characters and ignoring case sensitivity. :param s: Input string :return: True if the string is a palindrome, else False cleaned_str = ''.join(char.lower() for char in s if char.isalnum()) return cleaned_str == cleaned_str[::-1]"},{"question":"from typing import List, Tuple def can_reach_all_locations(N: int, M: int, roads: List[Tuple[int, int]]) -> str: Determine if there exists a node that can reach all other nodes in a directed graph. Args: - N: an integer denoting the number of locations (nodes) - M: an integer denoting the number of roads (edges) - roads: a list of M tuples where each tuple contains two integers u and v indicating a one-way road from location u to location v Returns: - \\"YES\\" if there is a node that can reach all other nodes; otherwise, \\"NO\\" Example: >>> can_reach_all_locations(4, 4, [(1, 2), (2, 3), (3, 4), (4, 2)]) 'YES' >>> can_reach_all_locations(3, 0, []) 'NO' >>> can_reach_all_locations(4, 2, [(1, 2), (3, 4)]) 'NO' >>> can_reach_all_locations(1, 0, []) 'YES' >>> can_reach_all_locations(5, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)]) 'YES' >>> can_reach_all_locations(6, 7, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (2, 5)]) 'YES'","solution":"from collections import defaultdict, deque def can_reach_all_locations(N, M, roads): def bfs(start): visited = set() queue = deque([start]) while queue: node = queue.popleft() if node not in visited: visited.add(node) queue.extend(graph[node]) return visited # build the graph graph = defaultdict(list) for u, v in roads: graph[u].append(v) # try each node to check if it can reach all other nodes for start in range(1, N+1): if len(bfs(start)) == N: return \\"YES\\" return \\"NO\\" # Sample input N = 4 M = 4 roads = [ (1, 2), (2, 3), (3, 4), (4, 2) ] print(can_reach_all_locations(N, M, roads)) # Output: YES"},{"question":"from typing import List def shortest_superstring(strings: List[str]) -> str: Find and return the shortest string that contains all the given strings as substrings. Args: strings (List[str]): A list of strings. Returns: str: The shortest string containing all input strings as substrings. Example: >>> shortest_superstring([\\"alex\\", \\"loves\\", \\"leetcode\\"]) 'alexlovesleetcode' >>> shortest_superstring([\\"cat\\", \\"hat\\"]) 'cathat' or 'hatcat' # Unit Tests def test_example_1(): assert shortest_superstring([\\"alex\\", \\"loves\\", \\"leetcode\\"]) == \\"alexlovesleetcode\\" def test_example_2(): result = shortest_superstring([\\"cat\\", \\"hat\\"]) assert result in (\\"cathat\\", \\"hatcat\\") def test_no_overlap(): assert shortest_superstring([\\"abc\\", \\"def\\", \\"ghi\\"]) == \\"abcdefghi\\" def test_partial_overlap(): assert shortest_superstring([\\"ab\\", \\"bc\\", \\"cd\\"]) == \\"abcd\\" def test_duplicate_strings(): assert shortest_superstring([\\"aaa\\", \\"aaa\\", \\"aaa\\"]) == \\"aaa\\" def test_single_string(): assert shortest_superstring([\\"hello\\"]) == \\"hello\\" def test_nested_overlap(): assert shortest_superstring([\\"a\\", \\"ab\\", \\"abc\\"]) == \\"abc\\"","solution":"from itertools import permutations def shortest_superstring(strings): def overlap(a, b): max_overlap = 0 for i in range(1, min(len(a), len(b)) + 1): if a[-i:] == b[:i]: max_overlap = i return max_overlap def merge(a, b): k = overlap(a, b) return a + b[k:] n = len(strings) min_len = float('inf') min_string = None for perm in permutations(strings): candidate = perm[0] for i in range(1, n): candidate = merge(candidate, perm[i]) if len(candidate) < min_len: min_len = len(candidate) min_string = candidate return min_string"},{"question":"class CarRentalSystem: A car rental system to manage car reservations ensuring no double-booking. Methods: def addCar(self, carID: int) -> None: Adds a new car to the rental system. def checkAvailability(self, carID: int, start: int, end: int) -> str: Checks the availability of a car for a given time interval. Returns 'YES' if available, otherwise 'NO'. def makeReservation(self, carID: int, start: int, end: int) -> str: Makes a reservation for a car for a given time interval. Returns 'RESERVED' if successful, otherwise 'UNAVAILABLE'. >>> system = CarRentalSystem() >>> system.addCar(1) >>> system.checkAvailability(1, 10, 20) 'YES' >>> system.makeReservation(1, 10, 20) 'RESERVED' >>> system.checkAvailability(1, 15, 25) 'NO' >>> system.checkAvailability(1, 20, 30) 'YES' >>> system.makeReservation(2, 15, 25) 'UNAVAILABLE' def test_add_and_check_availability(): system = CarRentalSystem() system.addCar(1) assert system.checkAvailability(1, 10, 20) == \\"YES\\" assert system.checkAvailability(2, 10, 20) == \\"NO\\" def test_make_reservation(): system = CarRentalSystem() system.addCar(1) assert system.makeReservation(1, 10, 20) == \\"RESERVED\\" assert system.checkAvailability(1, 15, 25) == \\"NO\\" assert system.checkAvailability(1, 20, 30) == \\"YES\\" assert system.makeReservation(2, 15, 25) == \\"UNAVAILABLE\\" def test_multiple_reservations(): system = CarRentalSystem() system.addCar(1) system.makeReservation(1, 10, 20) assert system.makeReservation(1, 20, 30) == \\"RESERVED\\" assert system.makeReservation(1, 25, 35) == \\"UNAVAILABLE\\" assert system.checkAvailability(1, 20, 30) == \\"NO\\" def test_nonexistent_car(): system = CarRentalSystem() assert system.checkAvailability(2, 10, 20) == \\"NO\\" assert system.makeReservation(2, 10, 20) == \\"UNAVAILABLE\\"","solution":"class CarRentalSystem: def __init__(self): self.cars = {} def addCar(self, carID): if carID not in self.cars: self.cars[carID] = [] def checkAvailability(self, carID, start, end): if carID not in self.cars: return \\"NO\\" for (s, e) in self.cars[carID]: if not (end <= s or start >= e): return \\"NO\\" return \\"YES\\" def makeReservation(self, carID, start, end): if self.checkAvailability(carID, start, end) == \\"NO\\": return \\"UNAVAILABLE\\" self.cars[carID].append((start, end)) return \\"RESERVED\\""},{"question":"def min_moves_to_gather_coins(n, positions): Given the number of positions n and a string \`positions\`, calculates the minimum number of moves required to gather all the coins into consecutive positions. :param n: int - number of positions on the line :param positions: str - binary string of length n :return: int - minimum number of moves required >>> min_moves_to_gather_coins(5, '10001') 3 >>> min_moves_to_gather_coins(9, '000000000') 0 >>> min_moves_to_gather_coins(6, '110011') 4 pass def test_example_1(): assert min_moves_to_gather_coins(5, '10001') == 3 def test_example_2(): assert min_moves_to_gather_coins(9, '000000000') == 0 def test_example_3(): assert min_moves_to_gather_coins(6, '110011') == 4 def test_no_coins(): assert min_moves_to_gather_coins(5, '00000') == 0 def test_single_coin(): assert min_moves_to_gather_coins(5, '00010') == 0 def test_all_consecutive_coins(): assert min_moves_to_gather_coins(5, '11110') == 0 def test_scattered_coins(): assert min_moves_to_gather_coins(7, '1010001') == 4 def test_large_input(): n = 100000 positions = (\\"0\\" * 49999) + \\"1\\" + (\\"0\\" * 49999) assert min_moves_to_gather_coins(n, positions) == 0","solution":"def min_moves_to_gather_coins(n, positions): Given the number of positions n and a string \`positions\`, calculates the minimum number of moves required to gather all the coins into consecutive positions. :param n: int - number of positions on the line :param positions: str - binary string of length n :return: int - minimum number of moves required coin_positions = [i for i, pos in enumerate(positions) if pos == '1'] if not coin_positions: return 0 median_idx = len(coin_positions) // 2 median = coin_positions[median_idx] moves = 0 for i, pos in enumerate(coin_positions): moves += abs(pos - (median - median_idx + i)) return moves"},{"question":"def count_training_pairs(test_cases): Given the badge sets for each member, determine the number of basic training pairs and the number of expert training pairs. Input: - test_cases: List of lists, where each sublist corresponds to a test case and contains lists of badges each member has. Output: - List of tuples, where each tuple contains the number of basic training pairs and the number of expert training pairs, respectively. Example: >>> count_training_pairs([[[1, 2], [2, 3]], [[1, 2], [2, 3], [1, 2]]]) [(1, 0), (3, 1)] # Implementation here # Parsing the input def parse_input(input_data): Parse the input data into test cases. Input: - input_data: String containing raw input data. Output: - Parsed list of test cases. Example: >>> parse_input(\\"2n2n2 1 2n2 2 3n3n2 1 2n2 2 3n2 1 2n\\") [[[1, 2], [2, 3]], [[1, 2], [2, 3], [1, 2]]] # Implementation here def solution(input_data): Combine input parsing, processing and result formating. Input: - input_data: String containing raw input data. Output: - Formatted string result according to the problem statement. Example: >>> solution(\\"2n2n2 1 2n2 2 3n3n2 1 2n2 2 3n2 1 2n\\") \\"1 0n3 1\\" # Implementation here # Unit Test def test_solution(): # Sample test case 1 input_data = \\"2n2n2 1 2n2 2 3n3n2 1 2n2 2 3n2 1 2n\\" expected_output = \\"1 0n3 1\\" assert solution(input_data) == expected_output # Additional test case 1 input_data = \\"1n2n2 1 3n2 3 4n\\" expected_output = \\"1 0\\" assert solution(input_data) == expected_output # Additional test case 2 input_data = \\"1n3n2 1 2n2 1 2n2 2 3n\\" expected_output = \\"3 1\\" assert solution(input_data) == expected_output # Additional test case 3 input_data = \\"1n4n2 1 2n2 2 3n2 1 2n2 2 3n\\" expected_output = \\"6 2\\" assert solution(input_data) == expected_output # Additional test case 4 input_data = \\"1n1n3 1 2 3n\\" expected_output = \\"0 0\\" assert solution(input_data) == expected_output # Additional test case 5 input_data = \\"1n3n1 100n1 101n1 102n\\" expected_output = \\"0 0\\" assert solution(input_data) == expected_output # Additional test case 6 input_data = \\"1n2n3 10 20 30n3 30 40 50n\\" expected_output = \\"1 0\\" assert solution(input_data) == expected_output test_solution()","solution":"def count_training_pairs(test_cases): results = [] for badges_list in test_cases: n = len(badges_list) basic_pairs = 0 expert_pairs = 0 badge_dict = {} for idx, badges in enumerate(badges_list): badg_tuple = tuple(sorted(badges)) if badg_tuple not in badge_dict: badge_dict[badg_tuple] = [] badge_dict[badg_tuple].append(idx) # Counting expert_pairs for key in badge_dict: count = len(badge_dict[key]) if count > 1: expert_pairs += count * (count - 1) // 2 for i in range(n): for j in range(i + 1, n): if set(badges_list[i]).intersection(set(badges_list[j])): basic_pairs += 1 results.append((basic_pairs, expert_pairs)) return results # Parsing the input def parse_input(input_data): input_lines = input_data.strip().split('n') T = int(input_lines[0]) test_cases = [] index = 1 for _ in range(T): N = int(input_lines[index]) index += 1 badges_list = [] for _ in range(N): badges = list(map(int, input_lines[index].split()[1:])) badges_list.append(badges) index += 1 test_cases.append(badges_list) return test_cases def solution(input_data): test_cases = parse_input(input_data) results = count_training_pairs(test_cases) return \\"n\\".join(f\\"{basic} {expert}\\" for basic, expert in results)"},{"question":"def minimize_difficulty(m: int, l: int, districts: List[int]) -> List[int]: Returns the list of district numbers to exclude to minimize the total difficulty while maintaining the cycle. Args: m (int): The number of districts in Distlak. l (int): The number of representatives to exclude. districts (List[int]): The list of district numbers in the order they are connected. Returns: List[int]: The list of district numbers to exclude, in increasing order of district number. Examples: >>> minimize_difficulty(7, 2, [1, 2, 3, 4, 5, 6, 7]) [6, 7] >>> minimize_difficulty(5, 1, [1, 2, 3, 4, 5]) [5]","solution":"def minimize_difficulty(m, l, districts): Returns the list of district numbers to exclude to minimize the total difficulty while maintaining the cycle. # To minimize the total difficulty, exclude the districts with the highest indices to_exclude = sorted(districts)[-l:] return sorted(to_exclude)"},{"question":"def most_frequent_hashtag(posts): Given a list of posts, extracts all hashtags from them and determines which hashtag appears the most frequently. If multiple hashtags have the highest frequency, return the one that appears first in the posts list. :param posts: List of strings where each string is a post containing hashtags :return: The most frequently occurring hashtag # Your implementation here # Function to handle the input and output def handle_input(): import sys input = sys.stdin.read data = input().split('n') N = int(data[0].strip()) posts = [data[i+1].strip() for i in range(N)] print(most_frequent_hashtag(posts)) # Unit Tests def test_single_post_single_hashtag(): posts = [\\"Hello world #hello\\"] assert most_frequent_hashtag(posts) == \\"#hello\\" def test_single_post_multiple_hashtags(): posts = [\\"Hello world #hello #world\\"] assert most_frequent_hashtag(posts) == \\"#hello\\" def test_multiple_posts_single_hashtag(): posts = [\\"Hello world #hello\\", \\"Another post #hello\\"] assert most_frequent_hashtag(posts) == \\"#hello\\" def test_multiple_posts_multiple_hashtags(): posts = [ \\"Hello world #hello\\", \\"Another post #world\\", \\"Fun day at the park #fun\\", \\"Repeat hashtag #hello\\" ] assert most_frequent_hashtag(posts) == \\"#hello\\" def test_tie_in_frequency(): posts = [ \\"Post one #first #tie\\", \\"Post two #second #tie\\", \\"Post three #first\\" ] assert most_frequent_hashtag(posts) == \\"#first\\" def test_hashtags_with_numbers(): posts = [ \\"Check this out #feature1\\", \\"Another cool thing #feature2\\", \\"Feature one again #feature1\\", \\"Second feature again #feature2\\", \\"A third tag #feature3\\" ] assert most_frequent_hashtag(posts) == \\"#feature1\\"","solution":"def most_frequent_hashtag(posts): Given a list of posts, extracts all hashtags from them and determines which hashtag appears the most frequently. If multiple hashtags have the highest frequency, return the one that appears first in the posts list. :param posts: List of strings where each string is a post containing hashtags :return: The most frequently occurring hashtag from collections import Counter, defaultdict import re hashtag_pattern = re.compile(r'#w+') hashtag_counts = Counter() first_appearance = defaultdict(int) index = 0 for post in posts: hashtags = hashtag_pattern.findall(post) for hashtag in hashtags: hashtag_counts[hashtag] += 1 if hashtag not in first_appearance: first_appearance[hashtag] = index index += 1 # Finding the most frequent hashtag, and in case of a tie, the one that appears first most_frequent = max(hashtag_counts.items(), key=lambda x: (x[1], -first_appearance[x[0]])) return most_frequent[0] # Function to handle the input and output def handle_input(): import sys input = sys.stdin.read data = input().split('n') N = int(data[0].strip()) posts = [data[i+1].strip() for i in range(N)] print(most_frequent_hashtag(posts))"},{"question":"def find_pairs(arr, target): Returns a list of unique pairs (a, b) such that a + b equals the target value. Pairs are returned in ascending order and each pair (a, b) is unique. >>> find_pairs([1, 9, 8, 2, 4, 6], 10) [(1, 9), (2, 8), (4, 6)] >>> find_pairs([1, 2, 3], 10) [] >>> find_pairs([1, 2, 4, 4], 8) [(4, 4)] def solve(test_cases): Solves the given test cases to find all unique pairs that sum to a target value. >>> test_cases = [(6, 10, [1, 9, 8, 2, 4, 6]), (4, 8, [1, 2, 4, 4])] >>> solve(test_cases) ['(1, 9)n(2, 8)n(4, 6)', '(4, 4)'] >>> test_cases = [(3, 10, [1, 2, 3])] >>> solve(test_cases) ['No pairs'] def parse_input(input_str): Parses the input string into the test case format. >>> input_str = \\"2n6 10n1 9 8 2 4 6n4 8n1 2 4 4\\" >>> parse_input(input_str) [(6, 10, [1, 9, 8, 2, 4, 6]), (4, 8, [1, 2, 4, 4])]","solution":"def find_pairs(arr, target): Returns a list of unique pairs (a, b) such that a + b equals target value. Pairs are returned in ascending order and each pair (a, b) is unique. pairs = set() seen = set() for num in arr: complement = target - num if complement in seen: pair = tuple(sorted((num, complement))) pairs.add(pair) seen.add(num) return sorted(pairs) def solve(test_cases): results = [] for case in test_cases: n, x, array = case pairs = find_pairs(array, x) if pairs: results.append('n'.join(f\\"({a}, {b})\\" for a, b in pairs)) else: results.append(\\"No pairs\\") return results def parse_input(input_str): lines = input_str.strip().split('n') T = int(lines[0]) test_cases = [] idx = 1 for _ in range(T): n, x = map(int, lines[idx].split()) array = list(map(int, lines[idx + 1].split())) test_cases.append((n, x, array)) idx += 2 return test_cases # To use this solution, make sure to parse your input and call \`solve\` function: # input_str = ... (some string containing the input text) # test_cases = parse_input(input_str) # results = solve(test_cases) # for result in results: # print(result)"},{"question":"def is_arithmetic_progression(sequence): Checks if a given sequence is an arithmetic progression. >>> is_arithmetic_progression([2, 4, 6, 8]) True >>> is_arithmetic_progression([3, 5, 9, 11, 13]) False def check_arithmetic_progressions(test_cases): For each test case, determine if the sequence forms an arithmetic progression. >>> check_arithmetic_progressions([(4, [2, 4, 6, 8]), (5, [3, 5, 9, 11, 13])]) ['YES', 'NO']","solution":"def is_arithmetic_progression(sequence): Checks if a given sequence is an arithmetic progression. if len(sequence) < 2: return False # Calculate the difference between first two elements diff = sequence[1] - sequence[0] # Check if each consecutive elements have the same difference for i in range(1, len(sequence)): if sequence[i] - sequence[i - 1] != diff: return False return True def check_arithmetic_progressions(test_cases): results = [] for case in test_cases: n, sequence = case if is_arithmetic_progression(sequence): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"import re from typing import List from collections import defaultdict def check_balanced_equations(equations: List[str]) -> List[str]: Given a list of strings representing chemical equations, determine if each of the equations is balanced. A balanced equation is one where the number of atoms of each element on the left side (reactants) is equal to the number of atoms of each element on the right side (products). :param equations: A list of strings where each string is a chemical equation. :return: A list of strings where each string is either \\"YES\\" or \\"NO\\". >>> check_balanced_equations([\\"H2+O2=H2O2\\"]) [\\"YES\\"] >>> check_balanced_equations([\\"2H2+O2=2H2O\\"]) [\\"YES\\"] >>> check_balanced_equations([\\"C6H12O6+6O2=6CO2+6H2O\\"]) [\\"YES\\"] >>> check_balanced_equations([\\"H2+O2=H2O\\"]) [\\"NO\\"] >>> check_balanced_equations([\\"2H2+O2=2H2O\\", \\"CH4+2O2=CO2+2H2O\\"]) [\\"YES\\", \\"YES\\"] >>> check_balanced_equations([\\"C3H8+5O2=3CO2+4H2O\\"]) [\\"YES\\"] >>> check_balanced_equations([\\"C3H8+4O2=3CO2+4H2O\\"]) [\\"NO\\"]","solution":"import re from collections import defaultdict def is_balanced(equation): reactants, products = equation.split('=') reactant_compounds = reactants.split('+') product_compounds = products.split('+') reactant_atoms = count_atoms(reactant_compounds) product_atoms = count_atoms(product_compounds) return reactant_atoms == product_atoms def count_atoms(compounds): element_pattern = re.compile(r'([A-Z][a-z]?)(d*)') counts = defaultdict(int) for compound in compounds: coefficient, elements = parse_compound(compound) for element, number in elements: counts[element] += coefficient * int(number) if number else coefficient return counts def parse_compound(compound): coeff_pattern = re.compile(r'^(d+)?(.*)') match = coeff_pattern.fullmatch(compound) coefficient = int(match.group(1)) if match.group(1) else 1 elements = re.findall(r'([A-Z][a-z]?)(d*)', match.group(2)) return coefficient, elements def check_balanced_equations(equations): results = [] for equation in equations: if is_balanced(equation): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def find_longest_subarray(cards): Returns the length of the longest subarray and maximum sum of values of the cards in that subarray. >>> find_longest_subarray([('R', 1), ('B', 2), ('R', 3), ('B', 4), ('R', 5), ('B', 6)]) == (6, 21) >>> find_longest_subarray([('R', 10), ('B', 5), ('R', 8), ('B', 7), ('R', 10)]) == (4, 30) >>> find_longest_subarray([('R', 10), ('R', 5)]) == (0, 0) >>> find_longest_subarray([('R', 1), ('B', 1)]) == (2, 2) >>> find_longest_subarray([('R', 5), ('B', 7), ('R', 3), ('B', 12), ('R', 8), ('B', 25), ('R', 1), ('B', 1)]) == (8, 62) >>> find_longest_subarray([('R', 1000000), ('B', 1000000)]) == (2, 2000000)","solution":"def find_longest_subarray(cards): Returns the length of the longest subarray and maximum sum of values of the cards in that subarray. n = len(cards) max_len = 0 max_sum = 0 balance_dict = {0: -1} current_balance = 0 current_sum = 0 for i, (color, value) in enumerate(cards): if color == 'R': current_balance += 1 else: current_balance -= 1 current_sum += value if current_balance in balance_dict: start_index = balance_dict[current_balance] subarray_length = i - start_index subarray_sum = current_sum if start_index == -1 else current_sum - sum(v for c, v in cards[:start_index+1]) if subarray_length > max_len or (subarray_length == max_len and subarray_sum > max_sum): max_len = subarray_length max_sum = subarray_sum else: balance_dict[current_balance] = i return max_len, max_sum"},{"question":"def longest_increasing_subsequence_length(n: int, arr: List[int]) -> int: Determine the maximum possible length of the strictly increasing sequence that can be obtained. >>> longest_increasing_subsequence_length(6, [2, 1, 3, 2, 3, 4]) 4 >>> longest_increasing_subsequence_length(5, [5, 4, 3, 2, 1]) 1 def test_longest_increasing_subsequence_length(): assert longest_increasing_subsequence_length(6, [2, 1, 3, 2, 3, 4]) == 4 assert longest_increasing_subsequence_length(5, [5, 4, 3, 2, 1]) == 1 assert longest_increasing_subsequence_length(0, []) == 0 assert longest_increasing_subsequence_length(4, [1, 3, 2, 4]) == 3 assert longest_increasing_subsequence_length(7, [10, 20, 10, 30, 20, 50, 40]) == 4 assert longest_increasing_subsequence_length(1, [100]) == 1 import pytest if __name__ == \\"__main__\\": pytest.main()","solution":"def longest_increasing_subsequence_length(n, arr): if n == 0: return 0 dp = [1] * n for i in range(1, n): for j in range(i): if arr[i] > arr[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"from typing import List def process_operations(n: int, operations: List[str]) -> str: Processes a series of operations (INSERT or REMOVE) on an initially empty data store and returns the state. :param n: Number of operations :param operations: List of operations to perform :return: State of the data store as a space-separated string or \\"EMPTY\\" if the data store is empty >>> process_operations(6, [\\"INSERT 5\\", \\"INSERT 3\\", \\"REMOVE 5\\", \\"INSERT 2\\", \\"REMOVE 3\\", \\"INSERT 5\\"]) '2 5' >>> process_operations(3, [\\"REMOVE 1\\", \\"INSERT 4\\", \\"REMOVE 4\\"]) 'EMPTY'","solution":"def process_operations(n, operations): Processes a series of operations (INSERT or REMOVE) on an initially empty data store and returns the state. :param n: Number of operations :param operations: List of operations to perform :return: State of the data store as a space-separated string or \\"EMPTY\\" if the data store is empty data_store = [] for operation in operations: command, x = operation.split() x = int(x) if command == \\"INSERT\\": data_store.append(x) elif command == \\"REMOVE\\": if x in data_store: data_store.remove(x) return \\" \\".join(map(str, data_store)) if data_store else \\"EMPTY\\""},{"question":"from typing import List def max_container_water(heights: List[int]) -> int: Given a list of integers representing the heights of vertical lines on a 2D graph, find the two lines that form a container that holds the most water. >>> max_container_water([1, 8, 6, 2, 5, 4, 8, 3, 7]) 49 >>> max_container_water([1, 1]) 1 >>> max_container_water([4, 3, 2, 1, 4]) 16 >>> max_container_water([1, 2, 1]) 2 pass","solution":"from typing import List def max_container_water(heights: List[int]) -> int: left, right = 0, len(heights) - 1 max_water = 0 while left < right: width = right - left height = min(heights[left], heights[right]) max_water = max(max_water, width * height) if heights[left] < heights[right]: left += 1 else: right -= 1 return max_water"},{"question":"def time_to_open_lock(keys_count, start_index): Returns the minimum time units needed to try all keys sequentially to guarantee the lock will be opened. Arguments: keys_count -- Total number of keys (N) start_index -- The initial key index to start trying from (1-based index) pass # Unit Tests def test_time_to_open_lock_smallest_case(): assert time_to_open_lock(1, 1) == 1 def test_time_to_open_lock_general_case(): assert time_to_open_lock(5, 2) == 5 assert time_to_open_lock(10, 5) == 10 def test_time_to_open_lock_single_key_different_start(): assert time_to_open_lock(1, 1) == 1 def test_time_to_open_lock_larger_case(): assert time_to_open_lock(50, 25) == 50","solution":"def time_to_open_lock(keys_count, start_index): Returns the minimum time units needed to try all keys sequentially to guarantee the lock will be opened. Arguments: keys_count -- Total number of keys (N) start_index -- The initial key index to start trying from (1-based index) return keys_count"},{"question":"def divide_teams(n: int, skill_levels: List[int]) -> Tuple[int, List[int], int, List[int]]: Divide participants into two teams fairly based on their skill levels. Conditions: 1. Each team must have at least one participant. 2. The absolute difference in the number of participants between the two teams must not exceed one. 3. The absolute difference in the total skill levels of the two teams must not exceed twice the skill level of the participant with the maximum skill level. >>> divide_teams(4, [10, 20, 30, 40]) (2, [30, 10], 2, [40, 20]) >>> divide_teams(3, [5, 15, 25]) (1, [15], 2, [5, 25])","solution":"def divide_teams(n, skill_levels): skill_levels.sort() team1 = [] team2 = [] # Greedily divide the sorted skills into two teams for i in range(n): if len(team1) <= len(team2): team1.append(skill_levels[i]) else: team2.append(skill_levels[i]) # Ensuring conditions are met max_skill_level = max(skill_levels) skill_diff = abs(sum(team1) - sum(team2)) # Printing the result a = len(team1) b = len(team2) if skill_diff <= 2 * max_skill_level: return a, team1, b, team2 else: team1.append(team2.pop()) if len(team1) < len(team2) else team2.append(team1.pop()) a = len(team1) b = len(team2) return a, team1, b, team2"},{"question":"def has_zero_sum_subarray(arr: List[int]) -> str: Given an array of integers, determines if there is a subarray (contiguous elements) that sums to zero. If such a subarray exists, returns \\"YES\\", otherwise returns \\"NO\\". The array may contain negative numbers. >>> has_zero_sum_subarray([4, 2, -3, 1, 6]) 'YES' >>> has_zero_sum_subarray([4, 2, 0, 1]) 'YES' >>> has_zero_sum_subarray([3, 4, 5, 6, 7]) 'NO' pass def test_case_1(): assert has_zero_sum_subarray([4, 2, -3, 1, 6]) == \\"YES\\" def test_case_2(): assert has_zero_sum_subarray([4, 2, 0, 1]) == \\"YES\\" def test_case_3(): assert has_zero_sum_subarray([3, 4, 5, 6, 7]) == \\"NO\\" def test_case_4(): assert has_zero_sum_subarray([-3, 2, 2, -2, 2, -2]) == \\"YES\\" def test_case_5(): assert has_zero_sum_subarray([1, 2, 3, -3, -2]) == \\"YES\\" def test_case_6(): assert has_zero_sum_subarray([-1, -1, -1, -1, 4]) == \\"YES\\" def test_case_7(): assert has_zero_sum_subarray([1]) == \\"NO\\" def test_case_8(): assert has_zero_sum_subarray([-1, 1]) == \\"YES\\" def test_case_9(): assert has_zero_sum_subarray([0]) == \\"YES\\" def test_case_10(): assert has_zero_sum_subarray([1, -1, 2, -2]) == \\"YES\\"","solution":"def has_zero_sum_subarray(arr): Determines if there is a subarray that sums to zero. prefix_sum_set = set() current_sum = 0 for num in arr: current_sum += num # Check if current sum is zero, which means subarray [0..k] sums to zero if current_sum == 0 or current_sum in prefix_sum_set: return \\"YES\\" prefix_sum_set.add(current_sum) return \\"NO\\""},{"question":"def can_form_palindrome(s: str) -> str: Determines if the string s can be transformed into a palindrome by appending zero or more digits. >>> can_form_palindrome(\\"12321\\") \\"YES\\" >>> can_form_palindrome(\\"987\\") \\"NO\\" >>> can_form_palindrome(\\"12\\") \\"NO\\" >>> can_form_palindrome(\\"9\\") \\"YES\\" def process_test_cases(t: int, cases: list) -> list: Processes the test cases and returns the results for each case. >>> process_test_cases(4, [\\"12321\\", \\"987\\", \\"12\\", \\"9\\"]) [\\"YES\\", \\"NO\\", \\"NO\\", \\"YES\\"]","solution":"def can_form_palindrome(s: str) -> str: Determines if the string s can be transformed into a palindrome by appending zero or more digits. if s == s[::-1]: return \\"YES\\" else: return \\"NO\\" def process_test_cases(t: int, cases: list) -> list: Processes the test cases and returns the results for each case. results = [] for s in cases: results.append(can_form_palindrome(s)) return results"},{"question":"def min_coins_to_sort_heights(n: int, heights: List[int]) -> int: Returns the minimum number of coins needed to arrange the children in strictly increasing height order. Args: n : int : number of children heights : list of int : the heights of the children Returns: int : the minimum number of coins needed >>> min_coins_to_sort_heights(5, [3, 1, 4, 2, 5]) 2 >>> min_coins_to_sort_heights(4, [1, 3, 2, 4]) 1","solution":"def min_coins_to_sort_heights(n, heights): Returns the minimum number of coins needed to arrange the children in strictly increasing height order. Args: n : int : number of children heights : list of int : the heights of the children Returns: int : the minimum number of coins needed # Initialize a list 'dp' where dp[i] is the length of the Longest Increasing Subsequence (LIS) ending at index i. dp = [1] * n for i in range(1, n): for j in range(i): if heights[i] > heights[j]: dp[i] = max(dp[i], dp[j] + 1) # To get the minimum number of moves, we need to subtract the length of the LIS from the total number of elements 'n' # because LIS elements are already in their correct positions and we need to move the rest elements. lis_length = max(dp) min_coins = n - lis_length return min_coins # Example usage: # n = 5 # heights = [3, 1, 4, 2, 5] # The output should be 2"},{"question":"def sum_of_two_largest_unique_numbers(n: int, numbers: List[int]) -> int: Returns the sum of the two largest unique numbers in the list. If there are fewer than two unique numbers, return 0. >>> sum_of_two_largest_unique_numbers(5, [4, 1, 2, 3, 3]) == 7 >>> sum_of_two_largest_unique_numbers(3, [6, 6, 6]) == 0","solution":"def sum_of_two_largest_unique_numbers(n, numbers): Returns the sum of the two largest unique numbers in the list. If there are fewer than two unique numbers, return 0. unique_numbers = list(set(numbers)) if len(unique_numbers) < 2: return 0 unique_numbers.sort(reverse=True) return unique_numbers[0] + unique_numbers[1]"},{"question":"def minimum_abs_difference(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: You are given a list of n integers representing the heights of n mountains. Farmer John wants to build a road that connects two different mountains such that the absolute height difference between the two mountains is minimized. He wants to know the minimum possible height difference after connecting exactly one pair of mountains with a road. Input: t: the number of test cases. test_cases: A list of tuples, each containing: - an integer n: the number of mountains. - a list of n space-separated integers representing the heights of the mountains. Output: A list of integers representing the minimum possible absolute height differences for each test case. Example: >>> minimum_abs_difference(3, [(4, [1, 3, 4, 10]), (5, [10, 20, 30, 40, 50]), (2, [5, 8])]) [1, 10, 3]","solution":"def minimum_abs_difference(t, test_cases): results = [] for i in range(t): n, heights = test_cases[i] heights.sort() min_diff = float('inf') for j in range(1, n): min_diff = min(min_diff, heights[j] - heights[j-1]) results.append(min_diff) return results"},{"question":"def generate_unique_ids(timestamps): Generates unique IDs for each signup timestamp. Args: timestamps (list of str): List of timestamps in the format \\"DD/MM/YY HH:MM:SS\\". Returns: list of str: List of unique IDs in the format \\"YYYYMMDDHHMMSSXXXX\\". Examples: >>> generate_unique_ids([\\"01/01/21 10:01:03\\"]) [\\"202101011001030001\\"] >>> generate_unique_ids([\\"01/01/21 10:01:03\\", \\"01/01/21 10:02:34\\", \\"01/01/21 10:03:45\\"]) [\\"202101011001030001\\", \\"202101011002340002\\", \\"202101011003450003\\"] >>> generate_unique_ids([\\"28/02/21 23:59:59\\", \\"01/03/21 00:00:00\\"]) [\\"202102282359590001\\", \\"202103010000000002\\"]","solution":"def generate_unique_ids(timestamps): Generates unique IDs for each signup timestamp. Args: timestamps (list of str): List of timestamps in the format \\"DD/MM/YY HH:MM:SS\\". Returns: list of str: List of unique IDs in the format \\"YYYYMMDDHHMMSSXXXX\\". unique_ids = [] counter = 1 for timestamp in timestamps: date, time = timestamp.split() day, month, year = date.split('/') hour, minute, second = time.split(':') formatted_date = f\\"20{year}{month}{day}{hour}{minute}{second}\\" unique_id = f\\"{formatted_date}{counter:04d}\\" unique_ids.append(unique_id) counter += 1 return unique_ids"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates the given arithmetic expression and returns the result. >>> evaluate_expression(\\"3+2\\") 5 >>> evaluate_expression(\\"3+2*2\\") 7 >>> evaluate_expression(\\"1+(4+5+2)-3\\") 9 >>> evaluate_expression(\\"(1+(4+5+2)-3)+(6+8)\\") 23 >>> evaluate_expression(\\"-2+1\\") -1 >>> evaluate_expression(\\"-5*-2\\") 10 >>> evaluate_expression(\\"10/2\\") 5 >>> evaluate_expression(\\"2+3*4/2-1\\") 7 >>> evaluate_expression(\\"1/(1-1)\\") None # Division by zero should return None def process_test_cases(T: int, expressions: List[str]) -> List[int]: Processes multiple test cases and returns the results as a list. >>> process_test_cases(3, [\\"3+2*2\\", \\"(1+(4+5+2)-3)+(6+8)\\", \\"-2+1\\"]) [7, 23, -1]","solution":"def evaluate_expression(expression): Evaluates the given arithmetic expression and returns the result. try: # Using Python's eval() for simplicity in handling arithmetic expressions # Assuming the expression is well-formed and safe as per the problem statement result = eval(expression) return int(result) # Cast the result to int as expected in the output except: return None # In case of any error, return None (though per problem statement, expressions are valid) def process_test_cases(T, expressions): Processes multiple test cases and returns the results as a list. results = [] for expression in expressions: result = evaluate_expression(expression) results.append(result) return results"},{"question":"def most_frequent_character(s: str) -> str: Returns the character that appears the most frequently in the string s. If there is a tie, return the character that appears first alphabetically among them. >>> most_frequent_character(\\"democratic\\") \\"c\\" >>> most_frequent_character(\\"banana\\") \\"a\\"","solution":"def most_frequent_character(s): Returns the character that appears the most frequently in the string s. If there is a tie, return the character that appears first alphabetically among them. from collections import Counter # Count the frequency of each character freq = Counter(s) # Get the maximum frequency max_freq = max(freq.values()) # Find all characters with the maximum frequency most_frequent_chars = [char for char, count in freq.items() if count == max_freq] # Return the alphabetically first character return min(most_frequent_chars)"},{"question":"def min_access_points(n: int, m: int, grid: List[str]) -> int: Returns the minimum number of access points needed to cover all buildings in Gridville. >>> min_access_points(3, 4, [\\"....\\", \\".BB.\\", \\".B..\\"]) == 1 >>> min_access_points(2, 5, [\\"B.B.B\\", \\"BBB.B\\"]) == 2 >>> min_access_points(3, 4, [\\"....\\", \\"....\\", \\"....\\"]) == 0 >>> min_access_points(3, 4, [\\"BBBB\\", \\"BBBB\\", \\"BBBB\\"]) == 1 >>> min_access_points(1, 7, [\\"B.B.B.B\\"]) == 4 >>> min_access_points(6, 1, [\\"B\\", \\".\\", \\"B\\", \\"B\\", \\".\\", \\"B\\"]) == 3","solution":"def min_access_points(n, m, grid): Returns the minimum number of access points needed to cover all buildings. visited = [[False] * m for _ in range(n)] def in_bounds(x, y): return 0 <= x < n and 0 <= y < m def explore(x, y): stack = [(x, y)] while stack: cx, cy = stack.pop() if not in_bounds(cx, cy) or visited[cx][cy] or grid[cx][cy] == '.': continue visited[cx][cy] = True for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: stack.append((cx + dx, cy + dy)) access_points = 0 for i in range(n): for j in range(m): if grid[i][j] == 'B' and not visited[i][j]: access_points += 1 explore(i, j) return access_points"},{"question":"from typing import List, Tuple def bipartite_partition(n: int, m: int, connections: List[Tuple[int, int]]) -> str: Determine if it's possible to partition the network into two groups such that no two directly connected computers are in the same group. If it's possible, return a string representing the two groups (e.g., 'ABAB'). If not, return -1. >>> bipartite_partition(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) 'ABAB' >>> bipartite_partition(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) 'ABABA' >>> bipartite_partition(3, 3, [(1, 2), (2, 3), (3, 1)]) -1","solution":"def bipartite_partition(n, m, connections): from collections import deque, defaultdict graph = defaultdict(list) for a, b in connections: graph[a].append(b) graph[b].append(a) colors = {} for node in range(1, n + 1): if node not in colors: queue = deque([node]) colors[node] = 'A' while queue: current = queue.popleft() for neighbor in graph[current]: if neighbor not in colors: colors[neighbor] = 'B' if colors[current] == 'A' else 'A' queue.append(neighbor) elif colors[neighbor] == colors[current]: return -1 return ''.join(colors[i] for i in range(1, n + 1)) # Example usage # n, m = 4, 4 # connections = [(1, 2), (2, 3), (3, 4), (4, 1)] # print(bipartite_partition(n, m, connections)) # Output: ABAB"},{"question":"def max_profit(n: int, projects: List[Tuple[int, int]]) -> int: Calculate the maximum profit possible by scheduling the projects appropriately. >>> max_profit(2, [(1, 100), (2, 200)]) 300 >>> max_profit(4, [(4, 70), (2, 60), (4, 50), (3, 40)]) 220 >>> max_profit(3, [(1, 10), (2, 20), (1, 30)]) 50","solution":"import heapq def max_profit(n, projects): projects.sort(key=lambda x: x[0]) # Sort by deadline max_heap = [] total_profit = 0 for deadline, profit in projects: if len(max_heap) < deadline: heapq.heappush(max_heap, profit) total_profit += profit elif max_heap[0] < profit: total_profit += profit - heapq.heappop(max_heap) heapq.heappush(max_heap, profit) return total_profit"},{"question":"def alphabet_position(text: str) -> str: Converts a string to a new string where each character is replaced by its respective position in the alphabet. Non-alphabet characters are ignored. >>> alphabet_position(\\"hello\\") == \\"8 5 12 12 15\\" >>> alphabet_position(\\"world\\") == \\"23 15 18 12 4\\" >>> alphabet_position(\\"hello world!123\\") == \\"8 5 12 12 15 23 15 18 12 4\\" >>> alphabet_position(\\"HELLO WORLD\\") == \\"8 5 12 12 15 23 15 18 12 4\\" >>> alphabet_position(\\"\\") == \\"\\"","solution":"def alphabet_position(text): Returns a string with each letter in the input string replaced by its respective position in the alphabet. Non-alphabet characters are ignored. positions = [] for char in text.lower(): if char.isalpha(): positions.append(str(ord(char) - ord('a') + 1)) return ' '.join(positions)"},{"question":"def can_transform_by_rotations(s1: str, s2: str) -> str: Determine if s2 can be obtained by rotating s1 any number of times. >>> can_transform_by_rotations(\\"HELLO\\", \\"LOHEL\\") \\"YES\\" >>> can_transform_by_rotations(\\"WORLD\\", \\"DLROW\\") \\"NO\\" >>> can_transform_by_rotations(\\"HELLO\\", \\"WORLD\\") \\"NO\\" >>> can_transform_by_rotations(\\"ABC\\", \\"ABCD\\") \\"NO\\" >>> can_transform_by_rotations(\\"SAME\\", \\"SAME\\") \\"YES\\" >>> can_transform_by_rotations(\\"A\\", \\"A\\") \\"YES\\" >>> can_transform_by_rotations(\\"A\\", \\"B\\") \\"NO\\"","solution":"def can_transform_by_rotations(s1, s2): Determine if s2 can be obtained by rotating s1 any number of times. if len(s1) != len(s2): return \\"NO\\" # Concatenate s1 with itself double_s1 = s1 + s1 # Check if s2 is a substring of the concatenated result if s2 in double_s1: return \\"YES\\" else: return \\"NO\\""},{"question":"def count_unique_colors(n: int, colors: List[int]) -> int: Returns the number of unique colors in the collection. Parameters: n (int): The number of marbles in the collection. colors (list of int): A list of integers representing the color of each marble. Returns: int: The number of unique colors. Examples: >>> count_unique_colors(5, [1, 2, 3, 2, 1]) 3 >>> count_unique_colors(4, [5, 5, 5, 5]) 1 >>> count_unique_colors(6, [1, 2, 3, 4, 5, 6]) 6","solution":"def count_unique_colors(n, colors): Returns the number of unique colors in the collection. Parameters: n (int): The number of marbles in the collection. colors (list of int): A list of integers representing the color of each marble. Returns: int: The number of unique colors. return len(set(colors))"},{"question":"def num_unique_paths(n: int, grid: List[str]) -> int: Determine the number of unique paths from the top-left to the bottom-right corner of the grid. >>> test_grid_without_obstacles() >>> test_grid_with_obstacles() >>> test_single_cell_grid() >>> test_blocked_path() >>> test_large_grid()","solution":"def num_unique_paths(n, grid): if n == 0 or grid[0][0] == '#' or grid[n-1][n-1] == '#': return 0 dp = [[0] * n for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(n): if grid[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[n-1][n-1]"},{"question":"from typing import List def decompress(encoded_message: str, word_lengths: List[int]) -> List[str]: Reconstructs the sequence of words from the compressed format. Parameters: encoded_message (str): The compressed message represented by a continuous string of lowercase letters. word_lengths (List[int]): A list of integer lengths representing the lengths of respective words in the encoded_message. Returns: List[str]: A list containing decompressed words. Examples: >>> decompress(\\"hellothere\\", [5, 5]) ['hello', 'there'] >>> decompress(\\"codingisfun\\", [6, 2, 3]) ['coding', 'is', 'fun'] >>> decompress(\\"python\\", [6]) ['python'] >>> decompress(\\"packagingtests\\", [8, 4, 4]) ['packagin', 'gtes', 'ts'] >>> decompress(\\"hellothereworld\\", [5, 5, 5]) ['hello', 'there', 'world'] >>> decompress(\\"a\\", [1]) ['a'] >>> decompress(\\"abcdef\\", [1, 2, 3]) ['a', 'bc', 'def'] >>> decompress(\\"a\\" * 1000, [1] * 1000) ['a'] * 1000","solution":"from typing import List def decompress(encoded_message: str, word_lengths: List[int]) -> List[str]: Reconstructs the sequence of words from the compressed format. Parameters: encoded_message (str): The compressed message represented by a continuous string of lowercase letters. word_lengths (List[int]): A list of integer lengths representing the lengths of respective words in the encoded_message. Returns: List[str]: A list containing decompressed words. words = [] index = 0 for length in word_lengths: words.append(encoded_message[index:index + length]) index += length return words"},{"question":"from typing import List def top_k_frequent_words(words: List[str], k: int) -> List[str]: Find the top k frequent words in a given list of strings. :param words: List[str] - a list of words :param k: int - the number of most frequent words to return :return: List[str] - the k most frequent words sorted by frequency and alphabetically pass def test_example1(): words = [\\"i\\", \\"love\\", \\"leetcode\\", \\"i\\", \\"love\\", \\"coding\\"] k = 2 assert top_k_frequent_words(words, k) == [\\"i\\", \\"love\\"] def test_example2(): words = [\\"the\\", \\"day\\", \\"is\\", \\"sunny\\", \\"the\\", \\"the\\", \\"the\\", \\"sunny\\"] k = 4 assert top_k_frequent_words(words, k) == [\\"the\\", \\"sunny\\", \\"day\\", \\"is\\"] def test_single_word(): words = [\\"hello\\"] k = 1 assert top_k_frequent_words(words, k) == [\\"hello\\"] def test_tiebreaker(): words = [\\"beta\\", \\"alpha\\", \\"alpha\\", \\"beta\\", \\"gamma\\"] k = 2 assert top_k_frequent_words(words, k) == [\\"alpha\\", \\"beta\\"] def test_all_unique_words(): words = [\\"one\\", \\"two\\", \\"three\\", \\"four\\", \\"five\\"] k = 3 assert top_k_frequent_words(words, k) == [\\"five\\", \\"four\\", \\"one\\"] def test_k_is_one(): words = [\\"apple\\", \\"banana\\", \\"orange\\", \\"apple\\", \\"apple\\", \\"banana\\"] k = 1 assert top_k_frequent_words(words, k) == [\\"apple\\"] def test_all_same_frequency(): words = [\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"b\\", \\"c\\", \\"d\\", \\"a\\"] k = 3 assert top_k_frequent_words(words, k) == [\\"a\\", \\"b\\", \\"c\\"]","solution":"from collections import Counter def top_k_frequent_words(words, k): Find the top k frequent words in a given list of strings. :param words: List[str] - a list of words :param k: int - the number of most frequent words to return :return: List[str] - the k most frequent words sorted by frequency and alphabetically # Count the frequency of each word word_counts = Counter(words) # Sort the words first by frequency in non-ascending order, then alphabetically in case of ties sorted_words = sorted(word_counts.keys(), key=lambda word: (-word_counts[word], word)) # Return the top k frequent words return sorted_words[:k]"},{"question":"def track_sales(input_data): Process the sales data and return the total sales amount for each category for each dataset in the order they appear. Args: input_data: List of strings representing the input data Returns: A list of strings representing the total sales amount for each category of each dataset Test Cases: >>> input_data = [\\"2\\", \\"Electronics 200\\", \\"Clothing 150\\", \\"0\\"] >>> track_sales(input_data) [\\"Electronics: 200\\", \\"Clothing: 150\\"] >>> input_data = [\\"2\\", \\"Electronics 200\\", \\"Clothing 150\\", \\"3\\", \\"Groceries 300\\", \\"Electronics 100\\", \\"Furniture 400\\", \\"0\\"] >>> track_sales(input_data) [\\"Electronics: 200\\", \\"Clothing: 150\\", \\"Groceries: 300\\", \\"Electronics: 100\\", \\"Furniture: 400\\"] >>> input_data = [\\"0\\"] >>> track_sales(input_data) [] >>> input_data = [\\"3\\", \\"Electronics 100\\", \\"Electronics 200\\", \\"Electronics 300\\", \\"0\\"] >>> track_sales(input_data) [\\"Electronics: 600\\"] >>> input_data = [\\"2\\", \\"Clothing 150\\", \\"Electronics 200\\", \\"2\\", \\"Furniture 50\\", \\"OfficeSupplies 75\\", \\"0\\"] >>> track_sales(input_data) [\\"Clothing: 150\\", \\"Electronics: 200\\", \\"Furniture: 50\\", \\"OfficeSupplies: 75\\"]","solution":"def track_sales(input_data): Process the sales data and return the total sales amount for each category for each dataset in the order they appear. Args: input_data: List of strings representing the input data Returns: A list of strings representing the total sales amount for each category of each dataset data_iter = iter(input_data) result = [] while True: m = int(next(data_iter)) if m == 0: break sales = {} for _ in range(m): line = next(data_iter) category, amount = line.split() amount = int(amount) if category in sales: sales[category] += amount else: sales[category] = amount for category, total in sales.items(): result.append(f\\"{category}: {total}\\") return result"},{"question":"def assign_identifiers(datasets: List[Tuple[int, int]]) -> List[List[List[int]]]: Assign unique identifiers to each intersection in the grid such that the identifiers form a strictly increasing sequence in each row and column. Args: datasets: List of tuples where each tuple contains two integers n and m, representing the number of rows and columns of the grid respectively. Returns: A list of grids where each grid is a list of lists of integers representing the identifiers assigned to the intersections. Examples: >>> assign_identifiers([(2, 2)]) [[[1, 2], [3, 4]]] >>> assign_identifiers([(3, 3)]) [[[1, 2, 3], [4, 5, 6], [7, 8, 9]]] >>> assign_identifiers([(4, 4)]) [[[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]] pass def print_grid(grid: List[List[int]]) -> str: Convert the grid to a string format suitable for printing. Args: grid: A list of lists of integers representing the grid. Returns: A string representation of the grid. pass def main(input_data: str) -> str: Main function to handle input and output. Args: input_data: A string containing the input data with each dataset separated by newlines and ending with '0 0'. Returns: A string containing the output grids separated by double newlines. pass def test_assign_identifiers_example(): input_data = \\"2 2n3 3n4 4n0 0\\" expected_output = \\"1 2n3 4nn1 2 3n4 5 6n7 8 9nn1 2 3 4n5 6 7 8n9 10 11 12n13 14 15 16\\" assert main(input_data) == expected_output def test_single_row_grid(): input_data = \\"1 5n0 0\\" expected_output = \\"1 2 3 4 5\\" assert main(input_data) == expected_output def test_single_column_grid(): input_data = \\"5 1n0 0\\" expected_output = \\"1n2n3n4n5\\" assert main(input_data) == expected_output def test_single_cell_grid(): input_data = \\"1 1n0 0\\" expected_output = \\"1\\" assert main(input_data) == expected_output def test_empty_input(): input_data = \\"0 0\\" expected_output = \\"\\" assert main(input_data) == expected_output def test_various_grids(): input_data = \\"3 2n2 3n0 0\\" expected_output = \\"1 2n3 4n5 6nn1 2 3n4 5 6\\" assert main(input_data) == expected_output","solution":"def assign_identifiers(datasets): results = [] for n, m in datasets: if n == 0 and m == 0: break grid = [[0] * m for _ in range(n)] counter = 1 for r in range(n): for c in range(m): grid[r][c] = counter counter += 1 results.append(grid) return results def print_grid(grid): return \\"n\\".join(\\" \\".join(map(str, row)) for row in grid) def main(input_data): datasets = [] for line in input_data.splitlines(): n, m = map(int, line.split()) datasets.append((n, m)) grids = assign_identifiers(datasets) output = \\"\\" for i, grid in enumerate(grids): output += print_grid(grid) if i < len(grids) - 1: output += \\"nn\\" return output"},{"question":"def process_queries(N, A, Q, queries): Processes the queries and returns the results for type 2 queries. Parameters: N : int - Number of elements in array A A : list of int - Array containing N integers Q : int - Number of queries queries : list of tuple - Each tuple represents a query Returns: list of int - Results for each type 2 query pass # Function to parse input data and run the provided function def main(input_data): input_lines = input_data.strip().split(\\"n\\") N = int(input_lines[0]) A = list(map(int, input_lines[1].split())) Q = int(input_lines[2]) queries = [] for i in range(3, 3 + Q): query = list(map(int, input_lines[i].split())) queries.append(query) results = process_queries(N, A, Q, queries) for result in results: print(result) # Example test cases def test_example_case(): input_data = 5 1 2 3 4 5 4 2 1 5 1 3 10 2 2 4 2 3 3 expected_output = \\"15n16n10n\\" import sys, io old_stdout = sys.stdout sys.stdout = io.StringIO() main(input_data) output = sys.stdout.getvalue() sys.stdout = old_stdout assert output == expected_output def test_single_update_query(): input_data = 3 5 5 5 1 1 2 10 expected_output = \\"\\" import sys, io old_stdout = sys.stdout sys.stdout = io.StringIO() main(input_data) output = sys.stdout.getvalue() sys.stdout = old_stdout assert output == expected_output def test_only_sum_query(): input_data = 4 1 2 3 4 1 2 1 4 expected_output = \\"10n\\" import sys, io old_stdout = sys.stdout sys.stdout = io.StringIO() main(input_data) output = sys.stdout.getvalue() sys.stdout = old_stdout assert output == expected_output def test_update_before_sum_query(): input_data = 3 1 1 1 2 1 1 5 2 1 3 expected_output = \\"7n\\" import sys, io old_stdout = sys.stdout sys.stdout = io.StringIO() main(input_data) output = sys.stdout.getvalue() sys.stdout = old_stdout assert output == expected_output def test_large_numbers(): input_data = 2 1000000000 1000000000 2 2 1 2 1 2 1 expected_output = \\"2000000000n\\" import sys, io old_stdout = sys.stdout sys.stdout = io.StringIO() main(input_data) output = sys.stdout.getvalue() sys.stdout = old_stdout assert output == expected_output def test_large_input(): N = 5000 A = [1] * N Q = 2000 queries = [\\"2 1 {}\\".format(N)] for i in range(1, Q): queries.append(\\"1 {} 2\\".format(i)) input_data = \\"{}n{}n{}n{}\\".format(N, ' '.join(map(str, A)), Q, 'n'.join(queries)) expected_output = \\"{}n\\".format(N) import sys, io old_stdout = sys.stdout sys.stdout = io.StringIO() main(input_data) output = sys.stdout.getvalue() sys.stdout = old_stdout assert output == expected_output","solution":"def process_queries(N, A, Q, queries): Processes the queries and returns the results for type 2 queries. Parameters: N : int - Number of elements in array A A : list of int - Array containing N integers Q : int - Number of queries queries : list of tuple - Each tuple represents a query Returns: list of int - Results for each type 2 query results = [] for query in queries: if query[0] == 1: i_q, x_q = query[1], query[2] if A[i_q - 1] != x_q: A[i_q - 1] = x_q elif query[0] == 2: l_q, r_q = query[1], query[2] results.append(sum(A[l_q - 1 : r_q])) return results # Function to parse input data and run the provided function def main(input_data): input_lines = input_data.strip().split(\\"n\\") N = int(input_lines[0]) A = list(map(int, input_lines[1].split())) Q = int(input_lines[2]) queries = [] for i in range(3, 3 + Q): query = list(map(int, input_lines[i].split())) queries.append(query) results = process_queries(N, A, Q, queries) for result in results: print(result)"},{"question":"def can_convert(s: str, t: str) -> str: Determines if you can convert string s into string t by replacing exactly one character in s with another character and rearranging the characters. >>> can_convert(\\"abcd\\", \\"abcf\\") 'YES' >>> can_convert(\\"abcd\\", \\"efgh\\") 'NO' def process_test_cases(test_cases: List[Tuple[str, str]]) -> List[str]: Process multiple test cases to determine if you can convert string s into string t for each pair in the test cases. >>> process_test_cases([(\\"abcd\\", \\"abcf\\"), (\\"abcd\\", \\"efgh\\"), (\\"aaaa\\", \\"aaab\\")]) ['YES', 'NO', 'YES'] from solution import can_convert, process_test_cases def test_can_convert(): assert can_convert(\\"abcd\\", \\"abcf\\") == \\"YES\\" assert can_convert(\\"abcd\\", \\"efgh\\") == \\"NO\\" assert can_convert(\\"aaaa\\", \\"aaab\\") == \\"YES\\" assert can_convert(\\"abc\\", \\"abc\\") == \\"NO\\" assert can_convert(\\"abc\\", \\"bca\\") == \\"NO\\" assert can_convert(\\"abcdefgh\\", \\"abcdffgh\\") == \\"YES\\" assert can_convert(\\"abcd\\", \\"ab\\") == \\"NO\\" def test_process_test_cases(): assert process_test_cases([(\\"abcd\\", \\"abcf\\"), (\\"abcd\\", \\"efgh\\"), (\\"aaaa\\", \\"aaab\\")]) == [\\"YES\\", \\"NO\\", \\"YES\\"] assert process_test_cases([(\\"abc\\", \\"abc\\"), (\\"abc\\", \\"bca\\")]) == [\\"NO\\", \\"NO\\"] assert process_test_cases([(\\"abcdefgh\\", \\"abcdffgh\\")]) == [\\"YES\\"] assert process_test_cases([(\\"abcd\\", \\"ab\\")]) == [\\"NO\\"]","solution":"def can_convert(s, t): Determines if you can convert string s into string t by replacing exactly one character in s with another character and rearranging the characters. if s == t: return \\"NO\\" if len(s) != len(t): return \\"NO\\" from collections import Counter s_counter = Counter(s) t_counter = Counter(t) diff_count = sum((s_counter - t_counter).values()) + sum((t_counter - s_counter).values()) return \\"YES\\" if diff_count == 2 else \\"NO\\" def process_test_cases(test_cases): results = [] for s, t in test_cases: results.append(can_convert(s, t)) return results"},{"question":"import heapq from typing import List, Tuple, Union def minimum_toll_cost(n: int, m: int, s: int, d: int, streets: List[Tuple[int, int, int]]) -> Union[int, str]: Determine the minimum toll cost to travel from start intersection to destination intersection. Parameters: n (int): Number of intersections. m (int): Number of streets. s (int): Starting intersection index. d (int): Destination intersection index. streets (list): List of tuples where each tuple consists of (u, v, t) indicating a street from intersection u to intersection v with a toll cost of t. Returns: int or str: Minimum toll cost or \\"IMPOSSIBLE\\" if there's no path from s to d. pass def test_minimum_toll_cost_example1(): assert minimum_toll_cost(4, 4, 1, 4, [(1, 2, 5), (2, 3, 10), (3, 4, 1), (2, 4, 7)]) == 12 def test_minimum_toll_cost_example2(): assert minimum_toll_cost(3, 2, 1, 3, [(1, 2, 2), (2, 1, 2)]) == \\"IMPOSSIBLE\\" def test_minimum_toll_cost_no_streets(): assert minimum_toll_cost(3, 0, 1, 3, []) == \\"IMPOSSIBLE\\" def test_minimum_toll_cost_direct_connection(): assert minimum_toll_cost(2, 1, 1, 2, [(1, 2, 1)]) == 1 def test_minimum_toll_cost_multiple_connections(): assert minimum_toll_cost(2, 2, 1, 2, [(1, 2, 10), (1, 2, 5)]) == 5 def test_minimum_toll_cost_long_path(): assert minimum_toll_cost(5, 6, 1, 5, [(1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 5, 1), (1, 3, 10), (3, 5, 10)]) == 4","solution":"import heapq def minimum_toll_cost(n, m, s, d, streets): Determine the minimum toll cost to travel from start intersection to destination intersection. Parameters: n (int): Number of intersections. m (int): Number of streets. s (int): Starting intersection index. d (int): Destination intersection index. streets (list): List of tuples where each tuple consists of (u, v, t) indicating a street from intersection u to intersection v with a toll cost of t. Returns: int or str: Minimum toll cost or \\"IMPOSSIBLE\\" if there's no path from s to d. graph = {i: [] for i in range(1, n + 1)} for u, v, t in streets: graph[u].append((v, t)) # Priority queue for Dijkstra's algorithm pq = [(0, s)] tolls = {i: float('inf') for i in range(1, n + 1)} tolls[s] = 0 while pq: current_toll, u = heapq.heappop(pq) if current_toll > tolls[u]: continue for v, t in graph[u]: new_toll = current_toll + t if new_toll < tolls[v]: tolls[v] = new_toll heapq.heappush(pq, (new_toll, v)) return tolls[d] if tolls[d] != float('inf') else \\"IMPOSSIBLE\\""},{"question":"def is_valid_parentheses(s: str) -> str: Determines if the input string of parentheses is valid. >>> is_valid_parentheses(\\"()\\") \\"YES\\" >>> is_valid_parentheses(\\"()[]{}\\") \\"YES\\" >>> is_valid_parentheses(\\"(]\\") \\"NO\\" >>> is_valid_parentheses(\\"([)]\\") \\"NO\\" >>> is_valid_parentheses(\\"{[()]}\\") \\"YES\\"","solution":"def is_valid_parentheses(s): Determines if the input string of parentheses is valid. stack = [] mapping = {')': '(', '}': '{', ']': '['} for char in s: if char in mapping: top_element = stack.pop() if stack else '#' if mapping[char] != top_element: return \\"NO\\" else: stack.append(char) return \\"YES\\" if not stack else \\"NO\\""},{"question":"def organize_competition(m: int, n: int, skill_levels: List[int], requirements: List[List[int]]) -> List[int]: Determine an assignment of students to challenges such that each challenge is assigned exactly one student, or report that no such assignment exists. Parameters: m (int): The number of students. n (int): The number of challenges. skill_levels (List[int]): The skill levels of the students. requirements (List[List[int]]): A matrix where each entry indicates whether a student has the appropriate skill for a given challenge. Returns: List[int]: The indices of the students assigned to each challenge in order or [-1] if no such assignment exists. Examples: >>> organize_competition(3, 3, [3, 2, 4], [[1, 0, 1], [1, 1, 0], [1, 1, 1]]) [1, 3, 2] >>> organize_competition(2, 3, [1, 3], [[1, 0], [0, 1], [1, 0]]) [-1]","solution":"from collections import defaultdict, deque def find_assignment(m, n, skill_levels, requirements): graph = defaultdict(list) for chall in range(n): for student in range(m): if requirements[chall][student] == 1: graph[student].append(chall + m) graph[chall + m].append(student) matches = {} def bfs(): queue = deque() layers = {} for u in range(m): if u not in matches: queue.append(u) layers[u] = 0 found = False while queue: u = queue.popleft() for v in graph[u]: if v in matches: nxt = matches[v] if nxt not in layers: layers[nxt] = layers[u] + 1 queue.append(nxt) else: found = True return layers, found def dfs(u, layers): if u in layers: for v in graph[u]: if v not in matches or (matches[v] in layers and layers[matches[v]] == layers[u] + 1 and dfs(matches[v], layers)): matches[u] = v matches[v] = u return True layers.pop(u) return False return True while bfs()[1]: layers, _ = bfs() for u in range(m): if u not in matches: dfs(u, layers) if len(matches) // 2 == n: result = [0] * n for student in matches: if student < m: result[matches[student] - m] = student + 1 return result else: return [-1] # Helper function to handle the input and output format. def organize_competition(m, n, skill_levels, requirements): return find_assignment(m, n, skill_levels, requirements)"},{"question":"def first_sold_out_product(T, test_cases): Determine the first product that sold out (zero units) on any given day. Args: T: Integer representing the number of test cases. test_cases: A list of tuples, where each tuple consists of: - An integer d representing the number of days. - A list of d lists of integers representing the sales data for each day. Returns: A list of lists, where each inner list contains the first product (1-indexed) that sold exactly zero units for each day. If no product sold exactly zero units on a given day, output \\"None\\" for that day. >>> first_sold_out_product(2, [(3, [[1, 2, 3, 0, 4], [5, 6, 7, 8, 9], [0, 1, 2, 3]]), (2, [[0, 0, 1], [2, 2, 0, 2, 2]])]) [[\\"4\\", \\"None\\", \\"1\\"], [\\"1\\", \\"3\\"]] pass def parse_input(input_data): Parse the input data into the number of test cases and the test cases. Args: input_data: A string containing the input data. Returns: T: Integer representing the number of test cases. test_cases: A list of tuples, where each tuple consists of: - An integer d representing the number of days. - A list of d lists of integers representing the sales data for each day. pass def format_output(results): Format the results for output. Args: results: A list of lists, where each inner list contains the results for a test case. Returns: A string formatted for output. pass def main(input_data): Main function to process the input data and produce the output. Args: input_data: A string containing the input data. Returns: A string containing the formatted output. pass","solution":"def first_sold_out_product(T, test_cases): results = [] for days_and_sales in test_cases: d, sales_data = days_and_sales daily_results = [] for sales in sales_data: zero_index = next((i+1 for i, sale in enumerate(sales) if sale == 0), \\"None\\") daily_results.append(zero_index) results.append(daily_results) return results def parse_input(input_data): lines = input_data.strip().split('n') T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): d = int(lines[index]) sales_data = [list(map(int, lines[index + 1 + i].split())) for i in range(d)] test_cases.append((d, sales_data)) index += d + 1 return T, test_cases def format_output(results): return 'n'.join('n'.join(map(str, day_results)) for day_results in results) def main(input_data): T, test_cases = parse_input(input_data) results = first_sold_out_product(T, test_cases) return format_output(results)"},{"question":"def can_partition_equal_subset_sum(n: int, arr: List[int]) -> str: Given an integer n and an array of positive integers, determine if it's possible to partition the array into two or more subsets with equal sum of elements in each subset. Args: n: int - number of elements in the array arr: List[int] - the array of positive integers Returns: str - \\"YES\\" if it's possible to partition the array into subsets with equal sum, otherwise \\"NO\\" Examples: >>> can_partition_equal_subset_sum(5, [4, 2, 5, 5, 2]) \\"YES\\" >>> can_partition_equal_subset_sum(4, [1, 1, 3, 2]) \\"NO\\"","solution":"def can_partition_equal_subset_sum(n, arr): total_sum = sum(arr) # If total_sum is not even, we cannot divide it into two equal integers if total_sum % 2 != 0: return \\"NO\\" target_sum = total_sum // 2 subset_dp = [False] * (target_sum + 1) subset_dp[0] = True for num in arr: for j in range(target_sum, num - 1, -1): subset_dp[j] = subset_dp[j] or subset_dp[j - num] return \\"YES\\" if subset_dp[target_sum] else \\"NO\\" # Example usage: # n = 5 # arr = [4, 2, 5, 5, 2] # print(can_partition_equal_subset_sum(n, arr)) # Output: \\"YES\\""},{"question":"def is_prime(n: int) -> bool: Returns True if n is a prime number, else False. >>> is_prime(2) True >>> is_prime(4) False def largest_prime_leq(M: int) -> int: Returns the largest prime number less than or equal to M. If no prime number exists, returns -1. >>> largest_prime_leq(10) 7 >>> largest_prime_leq(2) 2 def solve_primes(inputs: List[int]) -> List[int]: Given the inputs, returns a list of the largest prime numbers less than or equal to each input number. >>> solve_primes([3, 10, 14, 2]) [7, 13, 2]","solution":"def is_prime(n): Returns True if n is a prime number, else False. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def largest_prime_leq(M): Returns the largest prime number less than or equal to M. If no prime number exists, returns -1. for num in range(M, 1, -1): if is_prime(num): return num return -1 def solve_primes(inputs): Given the inputs, returns a list of the largest prime numbers less than or equal to each input number. T = inputs[0] results = [] for i in range(1, T + 1): M = inputs[i] results.append(largest_prime_leq(M)) return results"},{"question":"class SegmentTree: def __init__(self, data): self.n = len(data) self.tree = [0] * (2 * self.n) # Initialize the segment tree self.build(data) def build(self, data): # Build the tree from the data array for i in range(self.n): self.tree[self.n + i] = data[i] for i in range(self.n - 1, 0, -1): self.tree[i] = min(self.tree[2 * i], self.tree[2 * i + 1]) def update(self, pos, value): # Update value at position pos pos += self.n self.tree[pos] = value while pos > 1: pos //= 2 self.tree[pos] = min(self.tree[2 * pos], self.tree[2 * pos + 1]) def range_min(self, l, r): # Get the minimum value in the range [l, r) l += self.n r += self.n min_val = float('inf') while l < r: if l % 2: min_val = min(min_val, self.tree[l]) l += 1 if r % 2: r -= 1; min_val = min(min_val, self.tree[r]) l //= 2 r //= 2 return min_val def process_queries(n, array, queries): Process update and range minimum queries on the array. >>> process_queries(5, [1, 5, 2, 4, 3], [(2, 1, 3), (1, 2, 1), (2, 1, 3)]) [1, 1] >>> process_queries(1, [1], [(2, 1, 1), (1, 1, 2), (2, 1, 1)]) [1, 2] seg_tree = SegmentTree(array) results = [] for query in queries: if query[0] == 1: # Update query _, x, y = query seg_tree.update(x - 1, y) elif query[0] == 2: # Range minimum query _, l, r = query results.append(seg_tree.range_min(l - 1, r)) return results","solution":"class SegmentTree: def __init__(self, data): self.n = len(data) self.tree = [0] * (2 * self.n) # Initialize the segment tree self.build(data) def build(self, data): # Build the tree from the data array for i in range(self.n): self.tree[self.n + i] = data[i] for i in range(self.n - 1, 0, -1): self.tree[i] = min(self.tree[2 * i], self.tree[2 * i + 1]) def update(self, pos, value): # Update value at position pos pos += self.n self.tree[pos] = value while pos > 1: pos //= 2 self.tree[pos] = min(self.tree[2 * pos], self.tree[2 * pos + 1]) def range_min(self, l, r): # Get the minimum value in the range [l, r) l += self.n r += self.n min_val = float('inf') while l < r: if l % 2: min_val = min(min_val, self.tree[l]) l += 1 if r % 2: r -= 1 min_val = min(min_val, self.tree[r]) l //= 2 r //= 2 return min_val def process_queries(n, array, queries): seg_tree = SegmentTree(array) results = [] for query in queries: if query[0] == 1: # Update query _, x, y = query seg_tree.update(x - 1, y) elif query[0] == 2: # Range minimum query _, l, r = query results.append(seg_tree.range_min(l - 1, r)) return results"},{"question":"def longest_palindromic_substring(s: str) -> str: Returns the longest palindromic substring in s. pass # Unit tests def test_example1(): assert longest_palindromic_substring(\\"babad\\") == \\"bab\\" # Note: \\"aba\\" is also a valid answer, but the first occurrence is \\"bab\\" def test_example2(): assert longest_palindromic_substring(\\"cbbd\\") == \\"bb\\" def test_single_character(): assert longest_palindromic_substring(\\"a\\") == \\"a\\" assert longest_palindromic_substring(\\"z\\") == \\"z\\" def test_no_palindrome_more_than_one(): assert longest_palindromic_substring(\\"abc\\") == \\"a\\" # \\"a\\", \\"b\\", or \\"c\\" are all valid answers, let's go with the first occurrence def test_entire_string_is_palindrome(): assert longest_palindromic_substring(\\"racecar\\") == \\"racecar\\" assert longest_palindromic_substring(\\"level\\") == \\"level\\" def test_mixed_case(): assert longest_palindromic_substring(\\"Aba\\") == \\"A\\" def test_repeated_characters(): assert longest_palindromic_substring(\\"aaaa\\") == \\"aaaa\\" assert longest_palindromic_substring(\\"aabbcc\\") == \\"aa\\" # \\"aa\\", \\"bb\\", or \\"cc\\" are all valid def test_mult_substr_same_length(): assert longest_palindromic_substring(\\"abacdfgdcaba\\") == \\"aba\\" # First occurrence among the longest substrings","solution":"def longest_palindromic_substring(s): Returns the longest palindromic substring in s. def expand_around_center(s, left, right): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return s[left + 1:right] if len(s) == 0: return \\"\\" longest = s[0] for i in range(len(s)): # Odd length palindromes temp = expand_around_center(s, i, i) if len(temp) > len(longest): longest = temp # Even length palindromes temp = expand_around_center(s, i, i + 1) if len(temp) > len(longest): longest = temp return longest"},{"question":"def max_revenue(n, prices): Calculate the maximum revenue obtainable by cutting the rod of length \`n\` given the \`prices\` for each length. if n == 0: return 0 revenue = [0] * (n + 1) for i in range(1, n + 1): max_val = float('-inf') for j in range(i): max_val = max(max_val, prices[j] + revenue[i - j - 1]) revenue[i] = max_val return revenue[n] # Unit Tests def test_max_revenue_case_1(): assert max_revenue(8, [1, 5, 8, 9, 10, 17, 17, 20]) == 22 def test_max_revenue_single_length(): assert max_revenue(1, [2]) == 2 assert max_revenue(2, [3, 5]) == 6 def test_max_revenue_no_gain(): assert max_revenue(4, [0, 0, 0, 0]) == 0 def test_max_revenue_lengthy_rod(): assert max_revenue(5, [2, 5, 7, 8, 10]) == 12 def test_max_revenue_complex_case(): assert max_revenue(9, [3, 5, 8, 9, 10, 17, 17, 20, 24]) == 27","solution":"def max_revenue(n, prices): Calculate the maximum revenue obtainable by cutting the rod of length \`n\` given the \`prices\` for each length. if n == 0: return 0 revenue = [0] * (n + 1) for i in range(1, n + 1): max_val = float('-inf') for j in range(i): max_val = max(max_val, prices[j] + revenue[i - j - 1]) revenue[i] = max_val return revenue[n] def main(): import sys input = sys.stdin.read data = input().strip().split('n') case_number = 1 idx = 0 while idx < len(data): n = int(data[idx]) if n == 0: break prices = list(map(int, data[idx + 1].split())) result = max_revenue(n, prices) print(f\\"Case #{case_number}: {result}\\") case_number += 1 idx += 2 if __name__ == \\"__main__\\": main()"},{"question":"def maximum_sum_of_values(N: int, node_values: List[int], edges: List[Tuple[int, int]]) -> int: Find the maximum possible sum of the values of the selected nodes such that no two selected nodes are directly connected by an edge. Args: N (int): Number of nodes. node_values (List[int]): List of values associated with each node. edges (List[Tuple[int, int]]): List of edges, where each edge connects two nodes. Returns: int: The maximum possible sum of the values of the selected nodes. Examples: >>> maximum_sum_of_values(3, [1, 2, 3], [(1, 2), (1, 3)]) 5 >>> maximum_sum_of_values(4, [1, 1, 1, 1], [(1, 2), (1, 3), (1, 4)]) 3 >>> maximum_sum_of_values(5, [5, 1, 1, 1, 10], [(1, 2), (1, 3), (3, 4), (3, 5)]) 16","solution":"def maximum_sum_of_values(N, node_values, edges): from collections import defaultdict import sys sys.setrecursionlimit(200000) graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) dp = [[0, 0] for _ in range(N + 1)] visited = [False] * (N + 1) def dfs(node): visited[node] = True dp[node][0] = node_values[node - 1] # Including node dp[node][1] = 0 # Excluding node for neighbor in graph[node]: if not visited[neighbor]: dfs(neighbor) dp[node][0] += dp[neighbor][1] dp[node][1] += max(dp[neighbor][0], dp[neighbor][1]) dfs(1) return max(dp[1][0], dp[1][1]) # Example usage: # maximum_sum_of_values(3, [1, 2, 3], [(1, 2), (1, 3)]) should return 5"},{"question":"from typing import List, Tuple def calculate_reading_times(log_entries: List[str]) -> List[Tuple[str, int]]: Calculate the total reading time required for each user. Args: log_entries (List[str]): A list of log entries. Returns: List[Tuple[str, int]]: A list of tuples with user_id and their total reading time, sorted by user_id in lexicographical order. Examples: >>> calculate_reading_times([\\"2 Alice start\\", \\"3 Bob start\\", \\"7 Alice end\\", \\"8 Bob end\\", \\"10 Charlie start\\", \\"15 Charlie end\\"]) [(\\"Alice\\", 5), (\\"Bob\\", 5), (\\"Charlie\\", 5)] >>> calculate_reading_times([\\"1 Dave start\\", \\"5 Dave end\\", \\"6 Erin start\\", \\"10 Erin end\\"]) [(\\"Dave\\", 4), (\\"Erin\\", 4)] >>> calculate_reading_times([\\"3 Frank start\\", \\"7 Frank end\\", \\"9 George start\\", \\"15 George end\\", \\"19 Frank start\\", \\"25 Frank end\\"]) [(\\"Frank\\", 10), (\\"George\\", 6)] >>> calculate_reading_times([\\"2 User1 start\\", \\"100 User2 start\\", \\"100 User1 end\\", \\"200 User2 end\\"]) [(\\"User1\\", 98), (\\"User2\\", 100)] >>> calculate_reading_times([\\"1 A start\\", \\"2 B start\\", \\"3 A end\\", \\"4 B end\\", \\"5 C start\\", \\"6 C end\\"]) [(\\"A\\", 2), (\\"B\\", 2), (\\"C\\", 1)]","solution":"def calculate_reading_times(log_entries): import collections user_times = collections.defaultdict(int) user_start_times = {} for entry in log_entries: timestamp, user_id, action = entry.split() timestamp = int(timestamp) if action == 'start': user_start_times[user_id] = timestamp elif action == 'end': if user_id in user_start_times: start_time = user_start_times[user_id] user_times[user_id] += timestamp - start_time return sorted(user_times.items())"},{"question":"def garden_simulation(m: int, n: int, grid: List[str]) -> List[str]: Simulate the spreading of plants in the garden. Args: m (int): Number of rows in the garden. n (int): Number of columns in the garden. grid (List[str]): Initial state of the garden with plants (P) and empty cells (.). Returns: List[str]: Final state of the garden after all possible plants have spread. Examples: >>> garden_simulation(3, 3, ['.P.', '..P', 'P..']) ['PPP', 'PPP', 'PPP'] >>> garden_simulation(4, 4, ['P..P', '.PP.', '..P.', 'P..P']) ['PPPP', 'PPPP', 'PPPP', 'PPPP'] pass def test_example_cases(): assert garden_simulation(3, 3, ['.P.', '..P', 'P..']) == [ 'PPP', 'PPP', 'PPP' ] assert garden_simulation(4, 4, ['P..P', '.PP.', '..P.', 'P..P']) == [ 'PPPP', 'PPPP', 'PPPP', 'PPPP' ] def test_empty_garden(): assert garden_simulation(2, 2, ['..', '..']) == [ '..', '..' ] assert garden_simulation(1, 1, ['.']) == ['.'] def test_full_garden(): assert garden_simulation(2, 2, ['PP', 'PP']) == [ 'PP', 'PP' ] def test_mixed_garden(): assert garden_simulation(3, 3, ['P..', '...', '..P']) == [ 'PPP', 'PPP', 'PPP' ] def test_large_garden(): grid = ['P' + '.' * 48 + 'P'] * 50 expected = ['P' * 50] * 50 assert garden_simulation(50, 50, grid) == expected","solution":"def spread_plants(m, n, garden): from collections import deque # Directions for north, south, east, west directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Queue to perform BFS queue = deque() # Add initial plants' positions to queue for i in range(m): for j in range(n): if garden[i][j] == 'P': queue.append((i, j)) # BFS to spread the plants while queue: x, y = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and garden[nx][ny] == '.': garden[nx][ny] = 'P' queue.append((nx, ny)) return garden def garden_simulation(m, n, grid): garden = [list(row) for row in grid] spread_plants(m, n, garden) return [''.join(row) for row in garden]"},{"question":"def smallest_lexicographical_string(n: int, s: str) -> str: Returns the smallest lexicographical string that can be obtained by performing the operations any number of times. >>> smallest_lexicographical_string(5, \\"abcde\\") \\"aaaaa\\" >>> smallest_lexicographical_string(6, \\"abacbc\\") \\"aaaaaa\\" >>> smallest_lexicographical_string(4, \\"dcab\\") \\"aaaa\\"","solution":"def smallest_lexicographical_string(n, s): Returns the smallest lexicographical string that can be obtained by performing the operations any number of times. # It's enough to notice that we can always replace any pair of different characters ('x', 'y') # into min(x, y). So we can always get all 'a's by successive replacements. return 'a' * n"},{"question":"def largest_numeric_value(T, tablets): Returns the largest numeric value possible for each tablet's text. Parameters: T (int): Number of tablets tablets (list of str): List of strings where each string is the text on a tablet Returns: list of str: List of largest numeric values as strings Examples: >>> largest_numeric_value(3, [\\"aBc1d2Ef3gh\\", \\"xyz98w7\\", \\"noDigitsHere123\\"]) [\\"321\\", \\"987\\", \\"321\\"] >>> largest_numeric_value(1, [\\"ge13083@*&\\"]) [\\"83310\\"]","solution":"def largest_numeric_value(T, tablets): Returns the largest numeric value possible for each tablet's text. Parameters: T (int): Number of tablets tablets (list of str): List of strings where each string is the text on a tablet Returns: list of str: List of largest numeric values as strings results = [] for text in tablets: digits = sorted([char for char in text if char.isdigit()], reverse=True) largest_value = ''.join(digits) results.append(largest_value) return results"},{"question":"def longest_non_decreasing_subsequence_length(sequence: List[int]) -> int: Returns the length of the longest non-decreasing subsequence in the given sequence. >>> longest_non_decreasing_subsequence_length([5, 3, 4, 8, 6, 7]) = 4 >>> longest_non_decreasing_subsequence_length([2, 2, 2, 2, 2]) = 5 >>> longest_non_decreasing_subsequence_length([10, 9, 8, 7]) = 1 >>> longest_non_decreasing_subsequence_length([]) = 0 >>> longest_non_decreasing_subsequence_length([1]) = 1 >>> longest_non_decreasing_subsequence_length([1, 3, 2, 5, 4, 7, 6, 10, 9]) = 5 >>> longest_non_decreasing_subsequence_length([-1, -2, -3, -4, -5]) = 1","solution":"def longest_non_decreasing_subsequence_length(sequence): Returns the length of the longest non-decreasing subsequence in the given sequence. if not sequence: return 0 n = len(sequence) dp = [1] * n # dp[i] will store the length of the longest non-decreasing subsequence ending at i for i in range(1, n): for j in range(i): if sequence[i] >= sequence[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def final_position(x_0: int, y_0: int, n: int, moves: str) -> tuple: Determines the final position of a robot given initial coordinates and a series of moves. Parameters: x_0 (int): Initial x-coordinate y_0 (int): Initial y-coordinate n (int): Number of moves moves (str): String representing series of moves Returns: tuple: Final coordinates (x_f, y_f) Examples: >>> final_position(0, 0, 5, 'ULDRU') (0, 1) >>> final_position(-2, 3, 4, 'RRDD') (0, 1) >>> final_position(2, -1, 3, 'UDL') (1, -1)","solution":"def final_position(x_0, y_0, n, moves): Determines the final position of a robot given initial coordinates and a series of moves. Parameters: x_0 (int): Initial x-coordinate y_0 (int): Initial y-coordinate n (int): Number of moves moves (str): String representing series of moves Returns: tuple: Final coordinates (x_f, y_f) x, y = x_0, y_0 for move in moves: if move == 'U': y += 1 elif move == 'D': y -= 1 elif move == 'L': x -= 1 elif move == 'R': x += 1 return x, y"},{"question":"def sequence_length(n: int) -> int: Given an integer n, return the length of the sequence that follows the given rules and ends at 1. Rules: 1. The sequence starts with an integer \`n\`. 2. If \`n\` is even, divide it by 2. 3. If \`n\` is odd and greater than 1, multiply it by 3 and add 1. 4. Continue the sequence with the new number and repeat the steps until you reach 1. Examples: >>> sequence_length(6) 9 >>> sequence_length(1) 1 >>> sequence_length(19) 21","solution":"def sequence_length(n): Returns the length of the sequence starting from n and ending at 1 following the given rules. length = 1 while n != 1: if n % 2 == 0: n //= 2 else: n = 3 * n + 1 length += 1 return length"},{"question":"def min_deletions_to_k_distinct_chars(s: str, k: int) -> int: Returns the minimum number of characters that need to be deleted so that any substring of the given string has at most k distinct characters. >>> min_deletions_to_k_distinct_chars(\\"abaccc\\", 2) 1 >>> min_deletions_to_k_distinct_chars(\\"abcabcabc\\", 2) 3","solution":"from collections import Counter def min_deletions_to_k_distinct_chars(s, k): Returns the minimum number of characters that need to be deleted so that any substring of the given string has at most k distinct characters. char_count = Counter(s) if len(char_count) <= k: return 0 # Sorted character frequencies frequencies = sorted(char_count.values(), reverse=True) # Calculate the number of deletions required to reduce the number of distinct characters to k deletions = 0 while len(frequencies) > k: deletions += frequencies.pop() return deletions"},{"question":"def generate_diamond(n: int, c: str) -> list: Generates a diamond pattern with the given character 'c' and 'n' layers. Parameters: n (int): number of layers in the upper half (including the middle) of the diamond c (str): the character used to form the diamond Returns: list: a list of strings containing the diamond pattern >>> generate_diamond(3, '#') [' #', ' #', '#', ' #', ' #'] >>> generate_diamond(2, '*') [' *', '***', ' *'] >>> generate_diamond(5, '@') [' @', ' @@@', ' @@@@@', ' @@@@@@@', '@@@@@@@@@', ' @@@@@@@', ' @@@@@', ' @@@', ' @']","solution":"def generate_diamond(n, c): Generates a diamond pattern with the given character 'c' and 'n' layers. Parameters: n (int): number of layers in the upper half (including the middle) of the diamond c (str): the character used to form the diamond Returns: list: a list of strings containing the diamond pattern diamond = [] for i in range(n): spaces = ' ' * (n - i - 1) chars = c * (2 * i + 1) diamond.append(spaces + chars) for i in range(n-2, -1, -1): spaces = ' ' * (n - i - 1) chars = c * (2 * i + 1) diamond.append(spaces + chars) return diamond"},{"question":"from typing import List def count_hello_strings(n: int, strings: List[str]) -> int: Count the number of strings in the list that can be rearranged to form the keyword string \\"hello\\". >>> count_hello_strings(5, [\\"hello\\", \\"hello\\", \\"olhel\\", \\"help\\", \\"elloh\\"]) 4 >>> count_hello_strings(3, [\\"check\\", \\"world\\", \\"olelh\\"]) 1","solution":"def count_hello_strings(n, strings): from collections import Counter keyword = \\"hello\\" keyword_count = Counter(keyword) count = 0 for string in strings: if Counter(string) == keyword_count: count += 1 return count"},{"question":"from itertools import combinations from typing import List def can_select_books(N: int, pages: List[int], M: int, P: int) -> str: Determines if exactly M books can be selected such that the sum of their pages is exactly P. Parameters: N (int): Number of books. pages (List[int]): List containing number of pages in each book. M (int): Number of books to select. P (int): Total number of pages desired. Returns: str: 'YES' if selection is possible, otherwise 'NO'. Examples: >>> can_select_books(4, [100, 200, 300, 400], 2, 500) 'YES' >>> can_select_books(5, [100, 150, 200, 250, 300], 3, 900) 'NO' >>> can_select_books(3, [100, 200, 300], 2, 600) 'NO' >>> can_select_books(6, [100, 200, 300, 400, 500, 600], 3, 1200) 'YES' >>> can_select_books(2, [500, 500], 1, 500) 'YES'","solution":"from itertools import combinations def can_select_books(N, pages, M, P): Determines if exactly M books can be selected such that the sum of their pages is exactly P. Parameters: N (int): Number of books. pages (list of int): List containing number of pages in each book. M (int): Number of books to select. P (int): Total number of pages desired. Returns: str: 'YES' if selection is possible, otherwise 'NO'. for combo in combinations(pages, M): if sum(combo) == P: return \\"YES\\" return \\"NO\\" # Example of usage: N = 4 pages = [100, 200, 300, 400] M = 2 P = 500 print(can_select_books(N, pages, M, P)) # Output: YES"},{"question":"from typing import List def form_queue(heights: List[int]) -> List[int]: Returns the sequence of heights forming the queue with the maximum number of people. The queue should be such that every person is standing behind someone taller than themselves. If there are multiple sequences possible, return the one which starts with the shortest height. >>> form_queue([5, 3, 2, 6, 1]) == [1, 2, 3, 5, 6] >>> form_queue([4, 2, 3, 2]) == [2, 3, 4] # Write your implementation here # Unit Tests def test_example_1(): assert form_queue([5, 3, 2, 6, 1]) == [1, 2, 3, 5, 6] def test_example_2(): assert form_queue([4, 2, 3, 2]) == [2, 3, 4] def test_all_same_height(): assert form_queue([5, 5, 5, 5]) == [5] def test_decreasing_order(): assert form_queue([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] def test_increasing_order(): assert form_queue([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] def test_random_order(): assert form_queue([7, 1, 4, 6, 3, 2, 8, 5]) == [1, 2, 3, 4, 5, 6, 7, 8] def test_single_person(): assert form_queue([2]) == [2]","solution":"def form_queue(heights): Returns the sequence of heights forming the queue with the maximum number of people. The queue should be such that every person is standing behind someone taller than themselves. If there are multiple sequences possible, return the one which starts with the shortest height. unique_heights = sorted(set(heights)) return unique_heights # Example usage: # n = 5 # heights = [5, 3, 2, 6, 1] # Output: [1, 2, 3, 5, 6]"},{"question":"def min_difficulty_sum(t: int, participants: List[Tuple[Tuple[int, int], List[int]]]) -> List[int]: Given the number of participants and details about their problem sets, find the minimum sum of the difficulty levels for solving exactly k problems for each participant. Parameters: t (int): The number of participants participants (List[Tuple[Tuple[int, int], List[int]]]): A list where each element contains a tuple with the first element being a tuple of two integers n and k, and the second element being a list of n integers representing the difficulty levels of the problems. Returns: List[int]: A list of integers, each denoting the minimum sum of the difficulty levels for solving exactly k problems for each participant. >>> t = 2 >>> participants = [((5, 3), [9, 5, 7, 3, 8]), ((4, 2), [4, 9, 2, 6])] >>> min_difficulty_sum(t, participants) [15, 6]","solution":"def min_difficulty_sum(t, participants): results = [] for i in range(t): n, k = participants[i][0] difficulties = participants[i][1] difficulties.sort() results.append(sum(difficulties[:k])) return results # Example of usage: t = 2 participants = [ ((5, 3), [9, 5, 7, 3, 8]), ((4, 2), [4, 9, 2, 6]) ] print(min_difficulty_sum(t, participants)) # Output: [15, 6]"},{"question":"def count_distinct_sub_palindromes(s: str) -> int: Counts the number of distinct sub-palindromes in the string \`s\`. :param s: A string consisting of lowercase English letters only :return: The number of distinct sub-palindromes in the string # Write your code here # Unit Test def test_single_character(): assert count_distinct_sub_palindromes(\\"a\\") == 1 def test_two_different_characters(): assert count_distinct_sub_palindromes(\\"ab\\") == 2 def test_two_same_characters(): assert count_distinct_sub_palindromes(\\"aa\\") == 3 def test_regular_case(): assert count_distinct_sub_palindromes(\\"ababa\\") == 9 def test_complex_case(): assert count_distinct_sub_palindromes(\\"abcdecba\\") == 8 def test_repeated_characters(): assert count_distinct_sub_palindromes(\\"aaaa\\") == 10 def test_mixed_characters(): assert count_distinct_sub_palindromes(\\"abccba\\") == 9 def test_palindrome_with_middle(): assert count_distinct_sub_palindromes(\\"racecar\\") == 10","solution":"def count_distinct_sub_palindromes(s): Counts the number of distinct sub-palindromes in the string \`s\`. n = len(s) result = 0 # Counting odd-length palindromes for center in range(n): l, r = center, center while l >= 0 and r < n and s[l] == s[r]: result += 1 l -= 1 r += 1 # Counting even-length palindromes for center in range(n - 1): l, r = center, center + 1 while l >= 0 and r < n and s[l] == s[r]: result += 1 l -= 1 r += 1 return result"},{"question":"from typing import List def find_day_of_week(dates: List[str]) -> List[str]: Takes a list of date strings in the format DD-MM-YYYY and returns a list of the corresponding days of the week. >>> find_day_of_week([\\"01-01-2023\\", \\"14-02-2024\\", \\"25-12-2025\\"]) [\\"Sunday\\", \\"Wednesday\\", \\"Thursday\\"] >>> find_day_of_week([\\"29-02-2020\\", \\"28-02-2021\\"]) [\\"Saturday\\", \\"Sunday\\"] pass","solution":"from datetime import datetime def find_day_of_week(dates): Takes a list of date strings in the format DD-MM-YYYY and returns a list of the corresponding days of the week. days_of_week = [] for date in dates: dt = datetime.strptime(date, '%d-%m-%Y') days_of_week.append(dt.strftime('%A')) return days_of_week"},{"question":"def min_non_overlapping_slots(n, segments): Determines the minimum number of non-overlapping time slots required to schedule all the participants' segments. Args: n (int): The number of participants. segments (list of tuples): Each tuple contains six integers representing the start and end times for swimming, cycling, and running segments for each participant respectively. Returns: int: The minimum number of non-overlapping time slots required. Examples: >>> min_non_overlapping_slots(3, [(1, 2, 3, 4, 5, 6), (2, 3, 4, 5, 6, 7), (3, 4, 5, 6, 7, 8)]) 1 >>> min_non_overlapping_slots(2, [(1, 3, 5, 6, 7, 9), (2, 4, 6, 8, 9, 10)]) 2","solution":"import heapq def min_non_overlapping_slots(n, segments): Determines the minimum number of non-overlapping time slots required to schedule all the participants' segments. segments.sort(key=lambda x: x[0]) # Sort by the start time of swimming swims, cycles, runs = [], [], [] for s1, e1, s2, e2, s3, e3 in segments: swims.append((s1, e1)) cycles.append((s2, e2)) runs.append((s3, e3)) def count_slots(times): times.sort(key=lambda x: x[1]) # Sort by the end time of the segment min_heap = [] for start, end in times: if min_heap and min_heap[0] <= start: heapq.heappop(min_heap) heapq.heappush(min_heap, end) return len(min_heap) swim_slots = count_slots(swims) cycle_slots = count_slots(cycles) run_slots = count_slots(runs) return max(swim_slots, cycle_slots, run_slots)"},{"question":"def is_visually_appealing(n, heights): Determines if it is possible to color the buildings such that the skyline remains visually appealing. Parameters: n (int): The number of buildings heights (List[int]): The heights of the buildings Returns: str: \\"YES\\" if the skyline can be visually appealing, otherwise \\"NO\\" Examples: >>> is_visually_appealing(4, [4, 3, 3, 4]) \\"YES\\" >>> is_visually_appealing(3, [2, 1, 2]) \\"YES\\" >>> is_visually_appealing(5, [1, 2, 3, 4, 5]) \\"YES\\" def process_test_cases(t, test_cases): Processes multiple test cases to determine if each one has a visually appealing skyline. Parameters: t (int): The number of test cases test_cases (List[Tuple[int, List[int]]]): List of tuples, each containing the number of buildings and the list of building heights Returns: List[str]: A list of results for each test case, either \\"YES\\" or \\"NO\\" Examples: >>> process_test_cases(3, [(4, [4, 3, 3, 4]), (3, [2, 1, 2]), (5, [1, 2, 3, 4, 5])]) [\\"YES\\", \\"YES\\", \\"YES\\"] >>> process_test_cases(1, [(3, [4, 4, 4])]) [\\"NO\\"]","solution":"def is_visually_appealing(n, heights): Determines if it is possible to color the buildings such that the skyline remains visually appealing. if n == 1: return \\"YES\\" # Iterate through the heights for i in range(1, n): if heights[i] != heights[i-1]: return \\"YES\\" return \\"NO\\" def process_test_cases(t, test_cases): results = [] for i in range(t): n, heights = test_cases[i] result = is_visually_appealing(n, heights) results.append(result) return results"},{"question":"def minimum_towers(n: int, edges: List[Tuple[int, int]]) -> int: Determine the minimum number of communication towers required to ensure that every planet can send messages to every other planet directly or indirectly through the towers. >>> minimum_towers(1, []) 0 >>> minimum_towers(3, [(1, 2), (2, 3)]) 1 >>> minimum_towers(4, [(1, 2), (2, 3), (2, 4)]) 2","solution":"def minimum_towers(n, edges): from collections import defaultdict import sys sys.setrecursionlimit(200000) if n == 1: return 0 def dfs(node, parent, depth): depths[node] = depth max_depth_node = node for neighbor in graph[node]: if neighbor != parent: farthest_node = dfs(neighbor, node, depth + 1) if depths[farthest_node] > depths[max_depth_node]: max_depth_node = farthest_node return max_depth_node graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) depths = [-1] * (n + 1) # Perform first DFS from any node, say node 1 start_node = 1 farthest_node = dfs(start_node, -1, 0) # Perform second DFS from the farthest node found depths = [-1] * (n + 1) farthest_node2 = dfs(farthest_node, -1, 0) diameter_length = depths[farthest_node2] return (diameter_length + 1) // 2"},{"question":"def process_queries(n: int, m: int, arr: List[int], queries: List[List[int]]) -> List[int]: Process a list of queries on an array. Args: - n (int): Number of elements in the array. - m (int): Number of queries. - arr (List[int]): The initial array of integers. - queries (List[List[int]]): A list of queries to execute. Returns: - List[int]: Results of the sum queries. Example: >>> process_queries(6, 5, [4, 3, 7, 1, 2, 8], [[2, 2, 5], [1, 3, 6, 5], [2, 1, 6], [3, 2, 4, 10], [2, 2, 4]]) [13, 45, 30]","solution":"def process_queries(n, m, arr, queries): results = [] for query in queries: if query[0] == 1: # Increment subarray _, l, r, x = query for i in range(l - 1, r): arr[i] += x elif query[0] == 2: # Sum subarray _, l, r = query results.append(sum(arr[l-1:r])) elif query[0] == 3: # Replace subarray _, l, r, y = query for i in range(l - 1, r): arr[i] = y return results"},{"question":"def max_performance(n: int, A: List[int], B: List[int]) -> int: Returns the maximum possible product of skill level and speed. Parameters: n (int): Number of participants. A (list of int): Skill levels of participants. B (list of int): Speeds of participants. Returns: int: The maximum product of skill level and speed. >>> max_performance(3, [2, 3, 5], [1, 4, 2]) 20 >>> max_performance(4, [1, 2, 3, 4], [2, 3, 1, 4]) 16","solution":"def max_performance(n, A, B): Returns the maximum possible product of skill level and speed. Parameters: n (int): Number of participants. A (list of int): Skill levels of participants. B (list of int): Speeds of participants. Returns: int: The maximum product of skill level and speed. max_product = 0 for skill in A: for speed in B: max_product = max(max_product, skill * speed) return max_product"},{"question":"def min_prime_sum_moves(T: int) -> int: Determine the minimum number of prime numbers needed to sum up to T. >>> min_prime_sum_moves(18) 2 >>> min_prime_sum_moves(5) 1 >>> min_prime_sum_moves(17) 1 >>> min_prime_sum_moves(30) 2 >>> min_prime_sum_moves(1) -1 >>> min_prime_sum_moves(3) 1 >>> min_prime_sum_moves(11) 1 >>> min_prime_sum_moves(10) 2","solution":"def min_prime_sum_moves(T): def sieve_of_eratosthenes(n): # Create a boolean array \\"prime[0..n]\\" and initialize # all entries it as true. A value in prime[i] will # finally be false if i is Not a prime, else true. prime = [True for _ in range(n+1)] p = 2 while p * p <= n: # If prime[p] is not changed, then it is a prime if prime[p]: # Updating all multiples of p to not prime for i in range(p * p, n+1, p): prime[i] = False p += 1 # Collecting all prime numbers return [p for p in range(2, n+1) if prime[p]] def find_min_primes(T, primes): # DP Array to store minimum number of primes needed for each value dp = [float('inf')] * (T + 1) dp[0] = 0 # 0 primes needed to form 0 for prime in primes: for j in range(prime, T + 1): if dp[j - prime] != float('inf'): dp[j] = min(dp[j], dp[j - prime] + 1) return dp[T] if dp[T] != float('inf') else -1 primes = sieve_of_eratosthenes(T) return find_min_primes(T, primes) # Example T = 18 print(min_prime_sum_moves(T)) # Output should be 2"},{"question":"def min_operations_to_make_equal(n: int, arr: List[int]) -> int: Returns the minimum number of operations needed to make all elements in the array the same using the described operation. If it's impossible, returns -1. >>> min_operations_to_make_equal(4, [7, 7, 7, 7]) 0 >>> min_operations_to_make_equal(3, [1, 2, 3]) -1 >>> min_operations_to_make_equal(5, [2, 5, 2, 8, 2]) -1","solution":"def min_operations_to_make_equal(n, arr): Returns the minimum number of operations needed to make all elements in the array the same using the described operation. If it's impossible, returns -1. if n == 1: return 0 target_value = arr[0] for value in arr: if value != target_value: return -1 return 0"},{"question":"def count_integers_gte(array: List[int], queries: List[Tuple[int, int, int]]) -> List[int]: Given an array of integers and queries of the form (Li, Ri, Ci), this function returns a list of counts of integers greater than or equal to Ci between indices Li and Ri (both inclusive). >>> count_integers_gte([1, 2, 3, 4, 5], [(1, 3, 2), (2, 5, 4)]) [2, 2] >>> count_integers_gte([10, 20, 30, 40, 50], [(1, 5, 5), (1, 3, 15)]) [5, 2]","solution":"def count_integers_gte(array, queries): Given an array and queries of form (Li, Ri, Ci), returns list of counts of integers greater than or equal to Ci between indices Li and Ri (both inclusive). result = [] for L, R, C in queries: count = 0 for i in range(L - 1, R): if array[i] >= C: count += 1 result.append(count) return result # Example usage: N = 5 Q = 2 array = [1, 2, 3, 4, 5] queries = [(1, 3, 2), (2, 5, 4)] print(count_integers_gte(array, queries)) # Output: [2, 2]"},{"question":"class PerformanceMetrics: A class to track performance metrics and compute average response time. >>> pm = PerformanceMetrics() >>> pm.add_metric(1, 100) >>> print(pm.get_average()) # 100.0 100.0 >>> pm.add_metric(2, 200) >>> print(pm.get_average()) # 150.0 150.0 >>> pm.add_metric(3, 300) >>> print(pm.get_average()) # 200.0 200.0 def __init__(self): pass def add_metric(self, t, r): pass def get_average(self): pass # Unit Tests def test_add_metric_and_get_average(): pm = PerformanceMetrics() # No metrics added yet assert pm.get_average() == 0.0 pm.add_metric(1, 100) assert pm.get_average() == 100.0 pm.add_metric(2, 200) assert pm.get_average() == 150.0 # (100 + 200) / 2 = 150.00 pm.add_metric(3, 300) assert pm.get_average() == 200.0 # (100 + 200 + 300) / 3 = 200.00 pm.add_metric(4, 400) pm.add_metric(5, 500) assert pm.get_average() == 300.0 # (100 + 200 + 300 + 400 + 500) / 5 = 300.00 def test_get_average_empty(): pm = PerformanceMetrics() assert pm.get_average() == 0.0 def test_add_single_metric(): pm = PerformanceMetrics() pm.add_metric(1, 250) assert pm.get_average() == 250.0","solution":"class PerformanceMetrics: def __init__(self): self.total_response_time = 0 self.count = 0 def add_metric(self, t, r): self.total_response_time += r self.count += 1 def get_average(self): if self.count == 0: return 0.0 return round(self.total_response_time / self.count, 2)"},{"question":"def is_palindromic(number): Check if a number is palindromic. str_num = str(number) return str_num == str_num[::-1] def count_palindromic_numbers(n, m): Returns the count of palindromic numbers between n and m (inclusive). >>> count_palindromic_numbers(10, 20) 1 >>> count_palindromic_numbers(1, 100) 18 >>> count_palindromic_numbers(123, 130) 0","solution":"def is_palindromic(number): Check if a number is palindromic. str_num = str(number) return str_num == str_num[::-1] def count_palindromic_numbers(n, m): Returns the count of palindromic numbers between n and m (inclusive). count = 0 for num in range(n, m + 1): if is_palindromic(num): count += 1 return count def main(): Main function to take input and output the count of palindromic numbers. import sys input = sys.stdin.read().strip() n, m = map(int, input.split()) result = count_palindromic_numbers(n, m) print(result)"},{"question":"def handle_queries(n: int, queries: List[str]) -> List[int]: Handles the toggle and count queries on traffic light intersections grid. Parameters: n (int): Size of the grid (n x n). queries (List[str]): List of all the queries to be performed on the grid. Returns: List[int]: Results of count queries. >>> handle_queries(5, [\\"toggle 2 3\\", \\"toggle 3 3\\", \\"count 1 1 5 5\\", \\"toggle 2 3\\", \\"count 1 1 5 5\\", \\"count 3 3 5 5\\"]) [2, 1, 1]","solution":"def handle_queries(n, queries): Handles the toggle and count queries on traffic light intersections grid. Parameters: n (int): Size of the grid (n x n). queries (List[str]): List of all the queries to be performed on the grid. Returns: List[int]: Results of count queries. grid = [[0] * n for _ in range(n)] results = [] for query in queries: parts = query.split() if parts[0] == 'toggle': i, j = int(parts[1]) - 1, int(parts[2]) - 1 grid[i][j] = 1 - grid[i][j] # Toggle the state elif parts[0] == 'count': l1, r1, l2, r2 = map(lambda x: int(x) - 1, parts[1:]) count = 0 for x in range(l1, l2 + 1): for y in range(r1, r2 + 1): count += grid[x][y] results.append(count) return results"},{"question":"def isValid(s: str) -> bool: Determine if the input string is valid based on the rules: 1. Open brackets must be closed by the same type of brackets. 2. Open brackets must be closed in the correct order. Examples: >>> isValid(\\"()\\") True >>> isValid(\\"()[]{}\\") True >>> isValid(\\"(]\\") False >>> isValid(\\"([)]\\") False >>> isValid(\\"{[]}\\") True","solution":"def isValid(s: str) -> bool: Determine if the input string is valid based on the rules: 1. Open brackets must be closed by the same type of brackets. 2. Open brackets must be closed in the correct order. stack = [] bracket_map = {')': '(', '}': '{', ']': '['} for char in s: if char in bracket_map: top_element = stack.pop() if stack else '#' if bracket_map[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"def min_tiles(r: int, c: int) -> int: Determine the minimum number of 1x1 square tiles required to cover a rectangle of given dimensions. Parameters: r (int): The number of rows (height of the rectangle) c (int): The number of columns (width of the rectangle) Returns: int: The minimum number of 1x1 square tiles required to cover the rectangle Examples: >>> min_tiles(3, 5) 15 >>> min_tiles(4, 4) 16","solution":"def min_tiles(r, c): Returns the minimum number of 1x1 square tiles required to cover a rectangle of dimensions r x c. return r * c"},{"question":"class Park: def __init__(self, initial_trees): Initializes the park with the given initial number of trees in sections. :param initial_trees: List of integers representing the initial number of trees in each section. def add_trees(self, section, number): Add trees to a specific section. :param section: The section number (1-based index). :param number: The number of trees to add. def remove_trees(self, section, number): Remove trees from a specific section without going negative. :param section: The section number (1-based index). :param number: The number of trees to remove. def query_trees(self, section): Returns the current number of trees in the specified section. :param section: The section number (1-based index). :return: The number of trees in the section. def manage_park(input_data): Performs park management operations based on the input data. :param input_data: Raw input data containing the number of sections, initial trees, operations to perform. :return: Result of query operations. # Unit tests def test_manage_park_add(): input_data = \\"3n5 10 15n1nADD 2 5nQUERY 2\\" expected_output = \\"15\\" assert manage_park(input_data) == expected_output def test_manage_park_remove(): input_data = \\"3n5 10 15n1nREMOVE 1 3nQUERY 1\\" expected_output = \\"2\\" assert manage_park(input_data) == expected_output def test_manage_park_query(): input_data = \\"3n5 10 15n1nQUERY 3\\" expected_output = \\"15\\" assert manage_park(input_data) == expected_output def test_manage_park_multiple_operations(): input_data = \\"3n5 10 15n6nADD 1 5nREMOVE 2 10nQUERY 1nQUERY 2nADD 3 10nQUERY 3\\" expected_output = \\"10n0n25\\" assert manage_park(input_data) == expected_output def test_manage_park_remove_more_than_available(): input_data = \\"3n5 10 15n1nREMOVE 1 10nQUERY 1\\" expected_output = \\"0\\" assert manage_park(input_data) == expected_output def test_manage_park_add_and_remove(): input_data = \\"3n5 10 15n4nADD 1 5nREMOVE 1 3nADD 2 5nQUERY 2\\" expected_output = \\"15\\" assert manage_park(input_data) == expected_output","solution":"class Park: def __init__(self, initial_trees): Initializes the park with the given initial number of trees in sections. :param initial_trees: List of integers representing the initial number of trees in each section. self.sections = initial_trees def add_trees(self, section, number): Add trees to a specific section. :param section: The section number (1-based index). :param number: The number of trees to add. self.sections[section - 1] += number def remove_trees(self, section, number): Remove trees from a specific section without going negative. :param section: The section number (1-based index). :param number: The number of trees to remove. self.sections[section - 1] = max(0, self.sections[section - 1] - number) def query_trees(self, section): Returns the current number of trees in the specified section. :param section: The section number (1-based index). :return: The number of trees in the section. return self.sections[section - 1] def manage_park(input_data): input_lines = input_data.strip().split('n') N = int(input_lines[0]) initial_trees = list(map(int, input_lines[1].split())) Q = int(input_lines[2]) operations = input_lines[3:] park = Park(initial_trees) result = [] for operation in operations: parts = operation.split() if parts[0] == \\"ADD\\": section = int(parts[1]) number = int(parts[2]) park.add_trees(section, number) elif parts[0] == \\"REMOVE\\": section = int(parts[1]) number = int(parts[2]) park.remove_trees(section, number) elif parts[0] == \\"QUERY\\": section = int(parts[1]) result.append(str(park.query_trees(section))) return 'n'.join(result)"},{"question":"def find_common_segment(segments): Finds the largest common segment where all the sensors have recorded bird presence. segments: List of tuples [(a1, b1), (a2, b2), ..., (aN, bN)] Returns: A tuple (L, R) indicating the endpoints of the largest common segment or 'No Common Segment' if no common segment exists. >>> find_common_segment([(0, 5), (2, 8), (4, 6)]) (4, 5) >>> find_common_segment([(0, 3), (4, 7)]) 'No Common Segment' >>> find_common_segment([(1, 10), (3, 6), (5, 7), (6, 9)]) (6, 6) >>> find_common_segment([(-5, 5)]) (-5, 5) >>> find_common_segment([(-5, -1), (-3, 2), (-4, 0)]) (-3, -1) def process_input(input_str): Processes the input string and returns a list of segment tuples. input_str: A string representing the input. Returns: A list of tuples where each tuple represents a segment. >>> process_input(\\"3n0 5n2 8n4 6\\") [(0, 5), (2, 8), (4, 6)] >>> process_input(\\"2n0 3n4 7\\") [(0, 3), (4, 7)]","solution":"def find_common_segment(segments): Finds the largest common segment where all the sensors have recorded bird presence. segments: List of tuples [(a1, b1), (a2, b2), ..., (aN, bN)] Returns: A tuple (L, R) indicating the endpoints of the largest common segment or 'No Common Segment' if no common segment exists. L = -1_000_000 R = 1_000_000 for (a, b) in segments: L = max(L, a) R = min(R, b) if L <= R: return (L, R) else: return 'No Common Segment' # Read input def process_input(input_str): lines = input_str.strip().split('n') N = int(lines[0]) segments = [tuple(map(int, line.split())) for line in lines[1:N+1]] return segments"},{"question":"MOD = 10**9 + 7 def partition_count(n): Returns the number of distinct ways to split n into one or more non-negative integers in non-increasing order modulo 10^9 + 7. dp = [0] * (n + 1) dp[0] = 1 # There's one way to partition 0 (an empty sum) for i in range(1, n + 1): for j in range(i, n + 1): dp[j] = (dp[j] + dp[j - i]) % MOD return dp[n] def distinct_partition_modulo(k): return partition_count(k) >>> distinct_partition_modulo(0) 1 >>> distinct_partition_modulo(2) 2 >>> distinct_partition_modulo(5) 7 >>> distinct_partition_modulo(10) 42","solution":"MOD = 10**9 + 7 def partition_count(n): Returns the number of distinct ways to split n into one or more non-negative integers in non-increasing order modulo 10^9 + 7. dp = [0] * (n + 1) dp[0] = 1 # There's one way to partition 0 (an empty sum) for i in range(1, n + 1): for j in range(i, n + 1): dp[j] = (dp[j] + dp[j - i]) % MOD return dp[n] def distinct_partition_modulo(k): return partition_count(k)"},{"question":"def filter_books(n, books, query): Filters book records based on the provided query. Args: n (int): Number of books. books (list): List of tuples where each tuple contains (ID, title, author, year). query (str): Query string containing one or more filtering criteria. Returns: list: List of IDs that match all provided criteria. >>> books = [ ... (1, \\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 1925), ... (2, \\"To Kill a Mockingbird\\", \\"Harper Lee\\", 1960), ... (3, \\"1984\\", \\"George Orwell\\", 1949), ... (4, \\"Brave New World\\", \\"Aldous Huxley\\", 1932), ... (5, \\"Catch-22\\", \\"Joseph Heller\\", 1961) ... ] >>> filter_books(5, books, \\"title:the\\") [1] >>> filter_books(5, books, \\"author:orwell\\") [3] >>> filter_books(5, books, \\"year_range:1930-1960\\") [2, 3, 4] >>> filter_books(5, books, \\"title:world author:huxley\\") [4] >>> filter_books(5, books, \\"\\") [1, 2, 3, 4, 5]","solution":"def filter_books(n, books, query): Filters book records based on the provided query. Args: n (int): Number of books. books (list): List of tuples where each tuple contains (ID, title, author, year). query (str): Query string containing one or more filtering criteria. Returns: list: List of IDs that match all provided criteria. def matches(book, title_keyword, author_name, start_year, end_year): if title_keyword and title_keyword.lower() not in book[1].lower(): return False if author_name and author_name.lower() not in book[2].lower(): return False if start_year and end_year and not (start_year <= book[3] <= end_year): return False return True criteria = query.split() title_keyword = author_name = start_year = end_year = None for crit in criteria: if crit.startswith(\\"title:\\"): title_keyword = crit[len(\\"title:\\"):] elif crit.startswith(\\"author:\\"): author_name = crit[len(\\"author:\\"):] elif crit.startswith(\\"year_range:\\"): start_year, end_year = map(int, crit[len(\\"year_range:\\"):].split('-')) filtered_books = [book[0] for book in books if matches(book, title_keyword, author_name, start_year, end_year)] return filtered_books"},{"question":"def count_flipped_ones(T, test_cases): Takes the number of test cases T, and a list of binary strings test_cases. Returns a list of integers representing the number of '1's in the flipped version of each binary string. >>> count_flipped_ones(3, [\\"1100\\", \\"101010\\", \\"1111\\"]) [2, 3, 0] >>> count_flipped_ones(1, [\\"0000\\"]) [4] >>> count_flipped_ones(1, [\\"010101\\"]) [3] >>> count_flipped_ones(1, [\\"111111\\"]) [0] >>> count_flipped_ones(2, [\\"00000\\", \\"11110000\\"]) [5, 4] >>> count_flipped_ones(1, [\\"\\"]) [0] >>> count_flipped_ones(2, [\\"0\\", \\"1\\"]) [1, 0] >>> count_flipped_ones(2, [\\"0\\" * 10**5, \\"1\\" * 10**5]) [10**5, 0]","solution":"def count_flipped_ones(T, test_cases): Takes the number of test cases T, and a list of binary strings test_cases. Returns a list of integers representing the number of '1's in the flipped version of each binary string. results = [] for binary_string in test_cases: # Flipping bits and counting number of '1's count = sum(1 for bit in binary_string if bit == '0') results.append(count) return results"},{"question":"import sys from typing import List, Tuple def tsp(n: int, m: int, edges: List[Tuple[int, int, int]]) -> int: Determine the shortest circular route covering all stations and returning to the initial station. Args: n (int): The number of research stations. m (int): The number of paths. edges (List[Tuple[int, int, int]]): A list of tuples representing the bidirectional paths between stations, where each tuple contains three integers u, v, and w. Returns: int: The length of the shortest circular route covering all stations and returning to the initial station. Examples: >>> tsp(4, 4, [(1, 2, 1), (2, 3, 4), (3, 4, 2), (4, 1, 3)]) 10 >>> tsp(3, 3, [(1, 2, 2), (2, 3, 3), (3, 1, 1)]) 6 pass def main(): input = sys.stdin.read data = input().split() n = int(data[0]) m = int(data[1]) edges = [] idx = 2 for _ in range(m): u = int(data[idx]) v = int(data[idx + 1]) w = int(data[idx + 2]) edges.append((u, v, w)) idx += 3 result = tsp(n, m, edges) print(result) import pytest def test_basic(): assert tsp(4, 4, [(1, 2, 1), (2, 3, 4), (3, 4, 2), (4, 1, 3)]) == 10 def test_basic2(): assert tsp(3, 3, [(1, 2, 2), (2, 3, 3), (3, 1, 1)]) == 6 def test_small_cycle(): assert tsp(3, 3, [(1, 2, 10), (2, 3, 5), (3, 1, 2)]) == 17 def test_large_graph(): assert tsp(4, 5, [(1, 2, 1), (2, 3, 2), (3, 4, 1), (4, 1, 4), (1, 3, 5)]) == 8","solution":"import sys def tsp(n, m, edges): # Create the distance matrix, initialize with infinite distances dist = [[float('inf')] * n for _ in range(n)] for u, v, w in edges: u -= 1 v -= 1 dist[u][v] = w dist[v][u] = w # Initialize the dp table and path table dp = [[float('inf')] * n for _ in range(1 << n)] dp[1][0] = 0 # Fill the dp table for mask in range(1 << n): for i in range(n): if dp[mask][i] == float('inf'): continue for j in range(n): if mask & (1 << j) == 0: new_mask = mask | (1 << j) dp[new_mask][j] = min(dp[new_mask][j], dp[mask][i] + dist[i][j]) # Finding the minimum route cost that returns to node 0 answer = min(dp[(1 << n) - 1][i] + dist[i][0] for i in range(1, n)) return answer # Read input from stdin def main(): input = sys.stdin.read data = input().split() n = int(data[0]) m = int(data[1]) edges = [] idx = 2 for _ in range(m): u = int(data[idx]) v = int(data[idx + 1]) w = int(data[idx + 2]) edges.append((u, v, w)) idx += 3 result = tsp(n, m, edges) print(result)"},{"question":"def find_unpaired_bookend(t, cases): Identify the style of the bookend that does not have a pair in each test case. >>> find_unpaired_bookend(2, [(7, [3, 5, 3, 4, 5, 4, 7]), (6, [9, 1, 9, 2, 2, 3])]) [7, 1, 3] >>> find_unpaired_bookend(1, [(5, [1, 2, 2, 3, 1])]) [3]","solution":"def find_unpaired_bookend(t, cases): results = [] for case in cases: n = case[0] bookends = case[1] style_count = {} for style in bookends: style_count[style] = style_count.get(style, 0) + 1 for style, count in style_count.items(): if count % 2 != 0: results.append(style) return results # Sample usage t = 2 cases = [ (7, [3, 5, 3, 4, 5, 4, 7]), (6, [9, 1, 9, 2, 2, 3]) ] print(find_unpaired_bookend(t, cases)) # Should output [7, 1, 3]"},{"question":"from collections import OrderedDict class LRUCache: Implement an LRU Cache class with the following operations: - LRUCache(int capacity): Initialize the LRU cache with a positive size capacity. - int get(int key): Return the value of the key if the key exists, otherwise return -1. - void put(int key, int value): Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key. This task will help optimize the data access layer of the application by using an LRU caching mechanism. >>> lru_cache = LRUCache(2) >>> lru_cache.put(1, 1) >>> lru_cache.put(2, 2) >>> lru_cache.get(1) 1 >>> lru_cache.put(3, 3) >>> lru_cache.get(2) -1 >>> lru_cache.put(4, 4) >>> lru_cache.get(1) -1 >>> lru_cache.get(3) 3 >>> lru_cache.get(4) 4 def __init__(self, capacity: int): pass def get(self, key: int) -> int: pass def put(self, key: int, value: int) -> None: pass","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.cache = OrderedDict() self.capacity = capacity def get(self, key: int) -> int: if key in self.cache: self.cache.move_to_end(key) # mark as recently used return self.cache[key] return -1 def put(self, key: int, value: int) -> None: if key in self.cache: self.cache.move_to_end(key) # mark as recently used self.cache[key] = value if len(self.cache) > self.capacity: self.cache.popitem(last=False) # remove least recently used item"},{"question":"def total_duration(time_records: str) -> str: Takes multiple time records in HH:MM:SS format and returns the total duration in HH:MM:SS format. >>> total_duration(\\"00:45:30\\") \\"00:45:30\\" >>> total_duration(\\"00:30:00 00:20:00 00:10:00\\") \\"01:00:00\\" >>> total_duration(\\"01:20:35 02:40:20\\") \\"04:00:55\\" >>> total_duration(\\"10:30:30 10:30:30\\") \\"21:01:00\\" >>> total_duration(\\"00:00:59 00:00:01\\") \\"00:01:00\\" >>> total_duration(\\"23:59:59 00:00:01\\") \\"24:00:00\\" >>> total_duration(\\"01:02:03 00:00:04\\") \\"01:02:07\\" >>> total_duration(\\"03:00:00 02:00:00\\") \\"05:00:00\\"","solution":"def total_duration(time_records): Takes multiple time records in HH:MM:SS format and returns the total duration in HH:MM:SS format. total_hours = 0 total_minutes = 0 total_seconds = 0 for record in time_records.split(): hours, minutes, seconds = map(int, record.split(':')) total_hours += hours total_minutes += minutes total_seconds += seconds # Convert seconds into minutes and remainder seconds total_minutes += total_seconds // 60 total_seconds = total_seconds % 60 # Convert minutes into hours and remainder minutes total_hours += total_minutes // 60 total_minutes = total_minutes % 60 # Format the result into HH:MM:SS return f\\"{total_hours:02}:{total_minutes:02}:{total_seconds:02}\\""},{"question":"def find_winner(n: int) -> str: Determines the winner of the game given n cards. Parameters: n (int): The number of cards. Each card has a distinct integer from 1 to n. Returns: str: \\"Alice\\" if Alice wins, \\"Bob\\" if Bob wins. Examples: >>> find_winner(1) \\"Alice\\" >>> find_winner(3) \\"Alice\\" >>> find_winner(6) \\"Bob\\"","solution":"def find_winner(n): Determines the winner of the game given n cards. Parameters: n (int): The number of cards. Each card has a distinct integer from 1 to n. Returns: str: \\"Alice\\" if Alice wins, \\"Bob\\" if Bob wins. # If n is 1, Alice wins. if n == 1: return \\"Alice\\" # If n is greater than 1 and even, Bob wins. Otherwise, Alice wins. return \\"Bob\\" if n % 2 == 0 else \\"Alice\\""},{"question":"from typing import List, Tuple def preprocess_tree(n: int, edges: List[Tuple[int, int]]) -> Tuple[List[int], List[int]]: Preprocess the tree to prepare for efficient path length queries. :param n: Number of nodes in the tree :param edges: List of tuples representing edges in the tree :return: parent, depth arrays used for LCA computation pass # Implement this function def lca(u: int, v: int, parent: List[int], depth: List[int]) -> int: Function to find the Lowest Common Ancestor (LCA) of two nodes using the parent and depth arrays. :param u: First node :param v: Second node :param parent: List of parent nodes :param depth: List of depths :return: Lowest Common Ancestor of u and v pass # Implement this function def distance(u: int, v: int, parent: List[int], depth: List[int]) -> int: Compute the distance between two nodes using LCA. :param u: starting node :param v: ending node :param parent: parent array from BFS :param depth: depth array from BFS :return: distance between nodes u and v pass # Implement this function def process_queries(n: int, edges: List[Tuple[int, int]], queries: List[Tuple[int, int]]) -> List[int]: Process the tree and queries to find the length of the path between each pair of nodes specified in the queries. :param n: Number of nodes in the tree :param edges: List of tuples representing edges in the tree :param queries: List of tuples representing the queries :return: List of integers representing the length of the path for each query pass # Implement this function # Example Unit Tests def test_example_case(): n = 5 edges = [(1, 2), (1, 3), (3, 4), (3, 5)] queries = [(2, 4), (2, 5), (4, 5)] expected_results = [3, 3, 2] assert process_queries(n, edges, queries) == expected_results def test_simple_case(): n = 2 edges = [(1, 2)] queries = [(1, 2)] expected_results = [1] assert process_queries(n, edges, queries) == expected_results def test_straight_line_tree(): n = 4 edges = [(1, 2), (2, 3), (3, 4)] queries = [(1, 4), (2, 4)] expected_results = [3, 2] assert process_queries(n, edges, queries) == expected_results def test_balanced_tree(): n = 7 edges = [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)] queries = [(4, 5), (4, 6), (3, 7)] expected_results = [2, 4, 1] assert process_queries(n, edges, queries) == expected_results def test_deep_tree(): n = 5 edges = [(1, 2), (2, 3), (3, 4), (4, 5)] queries = [(1, 5), (2, 5), (1, 3)] expected_results = [4, 3, 2] assert process_queries(n, edges, queries) == expected_results","solution":"from collections import defaultdict, deque def preprocess_tree(n, edges): Preprocess the tree to prepare for efficient path length queries. :param n: Number of nodes in the tree :param edges: List of tuples representing edges in the tree :return: parent, depth arrays used for LCA computation tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) parent = [-1] * (n + 1) depth = [-1] * (n + 1) # Depth and Parent arrays def bfs(): queue = deque([1]) depth[1] = 0 while queue: node = queue.popleft() for neighbor in tree[node]: if depth[neighbor] == -1: depth[neighbor] = depth[node] + 1 parent[neighbor] = node queue.append(neighbor) bfs() return parent, depth def lca(u, v, parent, depth): Function to find the Lowest Common Ancestor (LCA) of two nodes using the parent and depth arrays if depth[u] < depth[v]: u, v = v, u # Lift node u to the same level as node v while depth[u] > depth[v]: u = parent[u] # Find LCA while u != v: u = parent[u] v = parent[v] return u def distance(u, v, parent, depth): Compute the distance between two nodes using LCA :param u: starting node :param v: ending node :param parent: parent array from BFS :param depth: depth array from BFS :return: distance between nodes u and v ancestor = lca(u, v, parent, depth) return depth[u] + depth[v] - 2 * depth[ancestor] def process_queries(n, edges, queries): parent, depth = preprocess_tree(n, edges) results = [] for u, v in queries: results.append(distance(u, v, parent, depth)) return results"},{"question":"from typing import List, Tuple def check_max_flow(n: int, m: int, edges: List[Tuple[int, int, int, int, int]]) -> str: Determine if the current flow in a weighted directed graph satisfies the conditions of the max-flow min-cut theorem. >>> check_max_flow(4, 5, [(1, 2, 10, 5, 5), (1, 3, 5, 2, 3), (2, 3, 4, 4, 0), (2, 4, 10, 0, 10), (3, 4, 8, 6, 2)]) == \\"NO\\" >>> check_max_flow(3, 3, [(1, 2, 5, 5, 0), (1, 3, 7, 7, 0), (2, 3, 3, 3, 0)]) == \\"YES\\" pass def test_check_max_flow(): assert check_max_flow(4, 5, [ (1, 2, 10, 5, 5), (1, 3, 5, 2, 3), (2, 3, 4, 4, 0), (2, 4, 10, 0, 10), (3, 4, 8, 6, 2) ]) == \\"NO\\" assert check_max_flow(3, 3, [ (1, 2, 5, 5, 0), (1, 3, 7, 7, 0), (2, 3, 3, 3, 0), ]) == \\"YES\\" assert check_max_flow(2, 1, [ (1, 2, 10, 10, 0) ]) == \\"YES\\" assert check_max_flow(2, 1, [ (1, 2, 10, 5, 5) ]) == \\"NO\\" assert check_max_flow(4, 4, [ (1, 2, 10, 10, 0), (2, 3, 10, 10, 0), (3, 4, 10, 10, 0), (1, 4, 10, 9, 1) ]) == \\"NO\\"","solution":"def check_max_flow(n, m, edges): from collections import defaultdict, deque graph = defaultdict(list) capacity = {} flow = {} # Initialize the graph, capacity, and flow from the given edges for u, v, c, f, r in edges: graph[u].append(v) graph[v].append(u) capacity[(u, v)] = c capacity[(v, u)] = 0 # Reverse edge initial capacity is 0 flow[(u, v)] = f flow[(v, u)] = -f # Reverse flow # Implement BFS to find if there's an augmenting path def bfs(source, sink, parent): visited = set() queue = deque([source]) visited.add(source) while queue: curr = queue.popleft() for neighbor in graph[curr]: if neighbor not in visited and flow[(curr, neighbor)] < capacity[(curr, neighbor)]: queue.append(neighbor) visited.add(neighbor) parent[neighbor] = curr if neighbor == sink: return True return False source, sink = 1, n parent = {} # Check for the existence of an augmenting path if bfs(source, sink, parent): return \\"NO\\" else: return \\"YES\\""},{"question":"from itertools import combinations from typing import List, Tuple def min_dishes_to_satisfy_all(t: int, test_cases: List[Tuple[int, int, List[List[int]]]]) -> List[int]: Determine the minimum number of unique dishes to satisfy all friends' dietary preferences. Args: t (int): The number of test cases. test_cases (List[Tuple[int, int, List[List[int]]]]): A list of test cases. Each test case is represented as a tuple containing: - \`n\` (int): The number of friends. - \`m\` (int): The number of dishes. - dietary preferences (List[List[int]]): A list of dietary preferences for each friend. Each friend's preferences are represented as a list starting with an integer \`ki\` followed by \`ki\` dish IDs. Returns: List[int]: A list of integers representing the minimum number of unique dishes required for each test case. Example: >>> test_cases = [ (3, 5, [[2, 1, 2], [3, 2, 3, 5], [2, 1, 4]]), (4, 4, [[1, 1], [1, 2], [1, 3], [1, 4]]) ] >>> min_dishes_to_satisfy_all(2, test_cases) [2, 4]","solution":"from itertools import combinations def min_dishes_to_satisfy_all(t, test_cases): results = [] for i in range(t): n, m, preferences = test_cases[i] all_friends_preferences = [set(pref[1:]) for pref in preferences] min_dishes = m for r in range(1, m+1): for combo in combinations(range(1, m+1), r): prepared_dishes = set(combo) if all(any(prepared_dish in prepared_dishes for prepared_dish in friend_pref) for friend_pref in all_friends_preferences): min_dishes = r break if min_dishes <= r: break results.append(min_dishes) return results"},{"question":"def is_magic_number(n): Checks if the number is a magic number. A magic number has a non-zero digit which is repeated consecutively. >>> is_magic_number(233) True >>> is_magic_number(858558) True >>> is_magic_number(123) False >>> is_magic_number(405) False >>> is_magic_number(10011) True def count_magic_numbers(arr): Counts the total number of magic numbers in the given array. >>> count_magic_numbers([233, 858558, 123, 405, 10011]) 3 >>> count_magic_numbers([129, 321, 455433]) 1 >>> count_magic_numbers([111, 444, 999, 101010]) 3","solution":"def is_magic_number(n): Checks if the number is a magic number. A magic number has a non-zero digit which is repeated consecutively. n = abs(n) str_n = str(n) for i in range(1, len(str_n)): if str_n[i] == str_n[i-1] and str_n[i] != '0': return True return False def count_magic_numbers(arr): Counts the total number of magic numbers in the given array. count = 0 for num in arr: if is_magic_number(num): count += 1 return count"},{"question":"def card_game_winner(test_cases): Simulate a card game to find the winner or determine a tie. For each test case, determine if there is a single winner with the highest sum or if there is a tie. Args: test_cases (List[List[int]]): A list of test cases, each containing the number of friends followed by their respective card sums. Returns: List[str]: A list containing 'winner' or 'tie' for each test case. Examples: >>> card_game_winner([[3, 120, 90, 120]]) ['tie'] >>> card_game_winner([[4, 100, 150, 50, 120]]) ['winner'] >>> card_game_winner([[2, 200, 200]]) ['tie']","solution":"def card_game_winner(test_cases): results = [] for case in test_cases: num_friends = case[0] sums = case[1:] max_sum = max(sums) if sums.count(max_sum) > 1: results.append(\\"tie\\") else: results.append(\\"winner\\") return results # Example use test_cases = [ [3, 120, 90, 120], [4, 100, 150, 50, 150], [2, 200, 200] ] print(card_game_winner(test_cases)) # Output should be ['tie', 'tie', 'tie']"},{"question":"def subarray_sums(arr, n, k): Given an array arr of size n and an integer k, compute an array result such that result[i] is the sum of elements in the subarray starting from index i of length k. If k elements starting from index i are not possible, result[i] should be the sum of elements from index i to the end of the array. Examples: >>> subarray_sums([1, 2, 3, 4, 5, 6, 7, 8], 8, 3) [6, 9, 12, 15, 18, 21, 15, 8] >>> subarray_sums([1, 2, 3], 3, 1) [1, 2, 3]","solution":"def subarray_sums(arr, n, k): Given an array arr of size n and an integer k, compute an array result such that result[i] is the sum of elements in the subarray starting from index i of length k. If k elements starting from index i are not possible, result[i] should be the sum of elements from index i to the end of the array. result = [0] * n for i in range(n): result[i] = sum(arr[i:i + k]) return result"},{"question":"def max_treasures(T: int, test_cases: List[Tuple[int, int, List[int], List[Tuple[int, int]], int]]) -> List[int]: Determine the maximum number of treasures a participant can collect starting from a specified planet. Args: T (int): The number of test cases. test_cases (List[Tuple[int, int, List[int], List[Tuple[int, int]], int]]): A list of test cases, where each test case is a tuple with the following elements: - N (int): Number of planets. - M (int): Number of warp gates. - treasures (List[int]): A list of integers representing the treasure value on each planet. - edges (List[Tuple[int, int]]): A list of tuples representing the directed warp gates between planets. - S (int): The starting planet. Returns: List[int]: A list of integers where each integer represents the maximum number of treasures collected for the corresponding test case. >>> max_treasures(2, [(5, 4, [1, 2, 3, 4, 5], [(1, 2), (1, 3), (3, 4), (2, 5)], 1), (3, 2, [10, 20, 30], [(1, 2), (2, 3)], 1)]) [15, 60] >>> max_treasures(1, [(3, 0, [10, 20, 30], [], 1)]) [10] >>> max_treasures(1, [(1, 0, [10], [], 1)]) [10] >>> max_treasures(1, [(6, 3, [1, 2, 3, 4, 5, 6], [(1, 2), (3, 4), (5, 6)], 1)]) [3] >>> max_treasures(1, [(7, 6, [4, 2, 7, 1, 6, 3, 5], [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7)], 1)]) [28]","solution":"def max_treasures(T, test_cases): def dfs(planet, treasures, visited, graph): visited[planet] = True total_treasures = treasures[planet - 1] for neighbour in graph[planet]: if not visited[neighbour]: total_treasures += dfs(neighbour, treasures, visited, graph) return total_treasures results = [] for case in test_cases: N, M, treasures, edges, S = case # Build graph graph = {i: [] for i in range(1, N+1)} for u, v in edges: graph[u].append(v) # Run DFS from the starting planet visited = [False] * (N + 1) max_treasure = dfs(S, treasures, visited, graph) results.append(max_treasure) return results"},{"question":"def decrypt_message(s: str) -> int: Determines the minimum possible value of the string \`s\` after encryption. Each character in \`s\` is assigned a unique prime number starting from the smallest prime 2. >>> decrypt_message(\\"a\\") 2 >>> decrypt_message(\\"ab\\") 6 >>> decrypt_message(\\"abc\\") 30 >>> decrypt_message(\\"abcdefghijklmnopqrstuvwxyz\\") 23286236435849736090006331688050736307","solution":"def decrypt_message(s): Determines the minimum possible value of the string \`s\` after encryption. Each character in \`s\` is assigned a unique prime number starting from the smallest prime 2. def generate_primes(n): Generate the first n prime numbers. primes = [] candidate = 2 while len(primes) < n: is_prime = all(candidate % p != 0 for p in primes) if is_prime: primes.append(candidate) candidate += 1 return primes # Generate enough prime numbers length = len(s) primes = generate_primes(length) # Calculate the encrypted value as the product of prime numbers value = 1 for i in range(length): value *= primes[i] return value"},{"question":"def max_distinct_substring_length_p(s: str, p: int) -> int: Returns the maximum number of distinct characters in any substring of s with length p. >>> max_distinct_substring_length_p(\\"abacabad\\", 4) 3 >>> max_distinct_substring_length_p(\\"aaabbbaaa\\", 3) 2 >>> max_distinct_substring_length_p(\\"xyzxyz\\", 2) 2 >>> max_distinct_substring_length_p(\\"abcd\\", 2) 2 >>> max_distinct_substring_length_p(\\"abcd\\", 4) 4 >>> max_distinct_substring_length_p(\\"aabbcc\\", 2) 2 pass def process_test_cases(test_cases: list) -> list: Processes multiple test cases and returns the results. >>> process_test_cases([(\\"abacabad\\", 4), (\\"aaabbbaaa\\", 3), (\\"xyzxyz\\", 2)]) [3, 2, 2] >>> process_test_cases([(\\"abcd\\", 2), (\\"aabbcc\\", 2)]) [2, 2] pass def read_input(input_lines: list) -> list: Reads input from a list of strings and returns a list of test cases. >>> read_input([\\"3\\", \\"abacabad 4\\", \\"aaabbbaaa 3\\", \\"xyzxyz 2\\"]) [(\\"abacabad\\", 4), (\\"aaabbbaaa\\", 3), (\\"xyzxyz\\", 2)] pass","solution":"def max_distinct_substring_length_p(s, p): Returns the maximum number of distinct characters in any substring of s with length p. max_distinct = 0 for i in range(len(s) - p + 1): substr = s[i:i + p] distinct_char_count = len(set(substr)) max_distinct = max(max_distinct, distinct_char_count) return max_distinct def process_test_cases(test_cases): Processes multiple test cases and returns the results. results = [] for s, p in test_cases: result = max_distinct_substring_length_p(s, p) results.append(result) return results # Read the number of test cases def read_input(input_lines): Reads input from a list of strings and returns a list of test cases. t = int(input_lines[0]) test_cases = [] for i in range(1, t + 1): parts = input_lines[i].split() s = parts[0] p = int(parts[1]) test_cases.append((s, p)) return test_cases"},{"question":"def unique_building_visits(logs): Determine the number of unique visits each employee made to different buildings. Args: logs (List[Tuple[int, int]]): List of tuples where each tuple contains employee_id and building_id. Returns: List[Tuple[int, int]]: List of tuples where each tuple contains employee_id and unique building visits. >>> unique_building_visits([(1, 1), (2, 1), (1, 2), (1, 3), (2, 2), (3, 1), (1, 1)]) [(1, 3), (2, 2), (3, 1)] >>> unique_building_visits([(4, 5), (4, 5), (4, 5), (5, 4), (5, 5)]) [(4, 1), (5, 2)] >>> unique_building_visits([(1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]) [(1, 1), (2, 1), (3, 1), (4, 1), (5, 1)] >>> unique_building_visits([]) [] >>> unique_building_visits([(1, 1), (1, 2), (2, 2), (2, 3), (3, 1), (3, 1), (4, 4), (1, 3), (2, 3), (3, 2)]) [(1, 3), (2, 2), (3, 2), (4, 1)]","solution":"def unique_building_visits(logs): from collections import defaultdict visit_dict = defaultdict(set) for employee_id, building_id in logs: visit_dict[employee_id].add(building_id) result = [(employee_id, len(buildings)) for employee_id, buildings in visit_dict.items()] result.sort() return result"},{"question":"def maxProfit(prices: List[int]) -> int: Determine the greatest possible profit from at most two stock transactions. Parameters: prices (List[int]): A list of integers representing the stock prices over k days. Returns: int: The maximum profit achievable with at most two transactions. Examples: >>> maxProfit([3, 3, 5, 0, 0, 3, 1, 4]) 6 >>> maxProfit([1, 2, 3, 4, 5, 6, 7]) 6 >>> maxProfit([7, 6, 4, 3, 1]) 0 pass","solution":"def maxProfit(prices): Returns the maximum profit with at most two transactions. if not prices: return 0 n = len(prices) # Initialize profits array profit = [0] * n # Forward traversal, compute maximum profit if we sell a stock on i-th day max_price = prices[-1] for i in range(n-2, -1, -1): if prices[i] > max_price: max_price = prices[i] profit[i] = max(profit[i+1], max_price - prices[i]) # Backward traversal, compute maximum profit if we buy a stock on i-th day and add it to the result of forward phase min_price = prices[0] for i in range(1, n): if prices[i] < min_price: min_price = prices[i] profit[i] = max(profit[i-1], profit[i] + (prices[i] - min_price)) return profit[-1]"},{"question":"def min_routers_needed(n: int, m: int) -> int: Return the minimum number of routers needed to cover an n x m grid. >>> min_routers_needed(2, 2) 1 >>> min_routers_needed(3, 3) 1 >>> min_routers_needed(4, 4) 4 >>> min_routers_needed(5, 5) 4 >>> min_routers_needed(6, 6) 4 >>> min_routers_needed(4, 6) 4 >>> min_routers_needed(100, 100) 1156","solution":"def min_routers_needed(n, m): Return the minimum number of routers needed to cover an n x m grid. Each router covers its own cell and its immediate neighbors. Args: n (int): number of rows in the grid. m (int): number of columns in the grid. Returns: int: minimum number of routers required. return ((n + 2) // 3) * ((m + 2) // 3)"},{"question":"def is_straight_line_possible(N, M, K, obstacles, x1, y1, x2, y2): Determine if it is possible to draw a straight line between two points on a canvas without crossing any obstacles. A straight line can be either horizontal, vertical, or diagonal at 45 degrees. Args: N (int): The height of the canvas. M (int): The width of the canvas. K (int): Number of obstacles on the canvas. obstacles (list of tuples): Coordinates of the obstacles. x1 (int): X-coordinate of the start point. y1 (int): Y-coordinate of the start point. x2 (int): X-coordinate of the end point. y2 (int): Y-coordinate of the end point. Returns: str: \\"YES\\" if a straight line is possible, otherwise \\"NO\\". Examples: >>> is_straight_line_possible(5, 5, 0, [], 0, 0, 0, 4) \\"YES\\" >>> is_straight_line_possible(5, 5, 1, [(0, 2)], 0, 0, 0, 4) \\"NO\\" >>> is_straight_line_possible(5, 5, 1, [(2, 2)], 0, 0, 4, 4) \\"NO\\" from solution import is_straight_line_possible def test_horizontal_clear_path(): assert is_straight_line_possible(5, 5, 0, [], 0, 0, 0, 4) == \\"YES\\" assert is_straight_line_possible(5, 5, 1, [(0, 2)], 0, 0, 0, 4) == \\"NO\\" def test_vertical_clear_path(): assert is_straight_line_possible(5, 5, 0, [], 0, 0, 4, 0) == \\"YES\\" assert is_straight_line_possible(5, 5, 1, [(2, 0)], 0, 0, 4, 0) == \\"NO\\" def test_diagonal_clear_path(): assert is_straight_line_possible(5, 5, 0, [], 0, 0, 4, 4) == \\"YES\\" assert is_straight_line_possible(5, 5, 1, [(2, 2)], 0, 0, 4, 4) == \\"NO\\" def test_non_diagonal_path(): assert is_straight_line_possible(5, 5, 0, [], 0, 0, 1, 2) == \\"NO\\" def test_multiple_obstacles_with_clear_path(): assert is_straight_line_possible(5, 5, 2, [(1, 2), (3, 2)], 0, 0, 4, 4) == \\"YES\\" assert is_straight_line_possible(5, 5, 3, [(1, 2), (3, 2), (2, 2)], 0, 0, 4, 4) == \\"NO\\"","solution":"def is_straight_line_possible(N, M, K, obstacles, x1, y1, x2, y2): obstacle_set = set((o_i, o_j) for o_i, o_j in obstacles) def check_path(x1, y1, x2, y2): if x1 == x2: step = 1 if y1 < y2 else -1 for y in range(y1, y2 + step, step): if (x1, y) in obstacle_set: return False return True elif y1 == y2: step = 1 if x1 < x2 else -1 for x in range(x1, x2 + step, step): if (x, y1) in obstacle_set: return False return True elif abs(x2 - x1) == abs(y2 - y1): x_step = 1 if x1 < x2 else -1 y_step = 1 if y1 < y2 else -1 for i in range(abs(x2 - x1) + 1): if (x1 + i * x_step, y1 + i * y_step) in obstacle_set: return False return True else: return False return \\"YES\\" if check_path(x1, y1, x2, y2) else \\"NO\\""},{"question":"def max_score(arr): Given an array of integers, find the maximum absolute difference between any two elements. >>> max_score([1, 2, 3, 4, 5]) 4 >>> max_score([1, 3, -1, 7]) 8 def max_score_from_test_cases(test_cases): Given a list of test cases, where each test case is a tuple (N, arr), returns a list of maximum scores Bob can achieve for each test case. >>> max_score_from_test_cases([(5, [1, 2, 3, 4, 5]), (4, [1, 3, -1, 7])]) [4, 8] def parse_input(input_string): Parses the input string and returns the list of test cases. >>> parse_input(\\"2n5n1 2 3 4 5n4n1 3 -1 7n\\") [(5, [1, 2, 3, 4, 5]), (4, [1, 3, -1, 7])]","solution":"def max_score(arr): min_elem = min(arr) max_elem = max(arr) return abs(max_elem - min_elem) def max_score_from_test_cases(test_cases): results = [] for N, arr in test_cases: results.append(max_score(arr)) return results def parse_input(input_string): lines = input_string.strip().split('n') T = int(lines[0]) current_line = 1 test_cases = [] for _ in range(T): N = int(lines[current_line]) arr = list(map(int, lines[current_line + 1].split())) test_cases.append((N, arr)) current_line += 2 return test_cases"},{"question":"def can_be_palindrome(n: int, sequence: List[int]) -> str: Determine if a sequence of integers can be rearranged into a palindrome. >>> can_be_palindrome(6, [4, 3, 2, 2, 3, 4]) \\"Yes\\" >>> can_be_palindrome(5, [1, 1, 2, 2, 3]) \\"Yes\\" >>> can_be_palindrome(4, [1, 2, 3, 4]) \\"No\\"","solution":"def can_be_palindrome(n, sequence): from collections import Counter count = Counter(sequence) odd_count = sum(1 for freq in count.values() if freq % 2 != 0) return \\"Yes\\" if odd_count <= 1 else \\"No\\""},{"question":"import heapq from typing import List, Tuple def find_shortest_path(N: int, M: int, roads: List[Tuple[int, int, int]], start: int, destination: int) -> int: Find the minimum travel time from start city to destination city using Dijkstra's algorithm. Args: N : int : Number of cities M : int : Number of roads roads : list of tuples : Each tuple contains (u, v, t) representing a directed road from city u to city v with travel time t start : int : Start city destination : int : Destination city Returns: int : Minimum travel time from start to destination. If no path exists, return -1. >>> find_shortest_path(4, 4, [(1, 2, 1), (2, 3, 3), (3, 4, 1), (1, 3, 7)], 1, 4) 5 >>> find_shortest_path(3, 3, [(1, 2, 2), (2, 3, 2), (1, 3, 5)], 1, 3) 4 >>> find_shortest_path(5, 5, [(1, 2, 2), (1, 3, 4), (2, 4, 7), (3, 4, 1), (4, 5, 3)], 1, 5) 8 >>> find_shortest_path(2, 1, [(1, 2, 5)], 1, 2) 5 >>> find_shortest_path(3, 1, [(1, 2, 2)], 1, 3) -1 >>> find_shortest_path(1, 0, [], 1, 1) 0","solution":"import heapq def find_shortest_path(N, M, roads, start, destination): Find the minimum travel time from start city to destination city using Dijkstra's algorithm. Args: N : int : Number of cities M : int : Number of roads roads : list of tuples : Each tuple contains (u, v, t) representing a directed road from city u to city v with travel time t start : int : Start city destination : int : Destination city Returns: int : Minimum travel time from start to destination. If no path exists, return -1. graph = {i: [] for i in range(1, N+1)} for u, v, t in roads: graph[u].append((v, t)) # Dijkstra's Algorithm Initialization min_heap = [(0, start)] # (travel_time, city) min_time = {i: float('inf') for i in range(1, N+1)} min_time[start] = 0 while min_heap: curr_time, curr_city = heapq.heappop(min_heap) for neighbor, travel_time in graph[curr_city]: new_time = curr_time + travel_time if new_time < min_time[neighbor]: min_time[neighbor] = new_time heapq.heappush(min_heap, (new_time, neighbor)) return min_time[destination] if min_time[destination] != float('inf') else -1"},{"question":"def max_attractiveness(n: int, strengths: List[int]) -> int: Determine the maximum total attractiveness by selecting booths such that no two selected booths are adjacent. Args: n : int : Number of booths at the book fair strengths : List[int] : List of strengths of the booths Returns: int : Maximum total attractiveness that can be achieved under the given constraints Examples: >>> max_attractiveness(6, [8, 10, 12, 7, 9, 11]) 31 >>> max_attractiveness(4, [5, 5, 10, 100]) 105 >>> max_attractiveness(3, [8, 6, 12]) 20 from solution import max_attractiveness def test_example1(): assert max_attractiveness(6, [8, 10, 12, 7, 9, 11]) == 31 def test_example2(): assert max_attractiveness(4, [5, 5, 10, 100]) == 105 def test_example3(): assert max_attractiveness(3, [8, 6, 12]) == 20 def test_single_booth(): assert max_attractiveness(1, [10]) == 10 def test_two_booths(): assert max_attractiveness(2, [5, 10]) == 10 def test_even_number_of_booths(): assert max_attractiveness(4, [10, 2, 7, 10]) == 20 def test_odd_number_of_booths(): assert max_attractiveness(5, [10, 2, 7, 10, 5]) == 22","solution":"def max_attractiveness(n, strengths): if n == 0: return 0 if n == 1: return strengths[0] dp = [0] * n dp[0] = strengths[0] dp[1] = max(strengths[0], strengths[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + strengths[i]) return dp[-1]"},{"question":"def longest_increasing_path(n: int, m: int, grid: List[str]) -> int: Eva loves puzzles and has a special one involving a grid of letters. Find the length of the longest contiguous path in the grid where each letter in the path is in increasing alphabetical order, and each step in the path moves one cell either up, down, left, or right. Example: >>> longest_increasing_path(3, 4, [\\"abcd\\", \\"bcde\\", \\"cdef\\"]) 6 >>> longest_increasing_path(4, 4, [\\"abcd\\", \\"axby\\", \\"azcp\\", \\"mnop\\"]) 4 def solve(input_str: str) -> int: lines = input_str.strip().split('n') n, m = map(int, lines[0].split()) grid = [line for line in lines[1:]] return longest_increasing_path(n, m, grid) import pytest def test_example1(): input_str = \\"3 4nabcdnbcdencdef\\" assert solve(input_str) == 6 def test_example2(): input_str = \\"4 4nabcdnaxbynazcpnmnop\\" assert solve(input_str) == 4 def test_min_case(): input_str = \\"1 1na\\" assert solve(input_str) == 1 def test_single_row(): input_str = \\"1 4nabcf\\" assert solve(input_str) == 3 def test_single_column(): input_str = \\"4 1nanbncnk\\" assert solve(input_str) == 3 def test_l_shape(): input_str = \\"3 3naaanabcnccc\\" assert solve(input_str) == 3 def test_no_increase(): input_str = \\"3 3ncccncccnccc\\" assert solve(input_str) == 1","solution":"def longest_increasing_path(n, m, grid): def dfs(x, y): if dp[x][y] != -1: return dp[x][y] max_length = 1 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and ord(grid[nx][ny]) == ord(grid[x][y]) + 1: max_length = max(max_length, 1 + dfs(nx, ny)) dp[x][y] = max_length return max_length directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] dp = [[-1] * m for _ in range(n)] longest_path = 1 for i in range(n): for j in range(m): longest_path = max(longest_path, dfs(i, j)) return longest_path # Helper function to parse input in the required format def solve(input_str): lines = input_str.strip().split('n') n, m = map(int, lines[0].split()) grid = [line for line in lines[1:]] return longest_increasing_path(n, m, grid)"},{"question":"def min_operations_to_strictly_increasing(arr): This function calculates the minimum number of elements to be removed to make the array strictly increasing. >>> min_operations_to_strictly_increasing([5, 4, 3, 2, 1]) 4 >>> min_operations_to_strictly_increasing([4, 4, 4, 4]) 3 >>> min_operations_to_strictly_increasing([6, 5, 6, 5, 6, 5]) 5 def process_test_cases(t, test_cases): This function processes multiple test cases and returns the results. >>> process_test_cases(3, [(5, [5, 4, 3, 2, 1]), (4, [4, 4, 4, 4]), (6, [6, 5, 6, 5, 6, 5])]) [4, 3, 5]","solution":"def min_operations_to_strictly_increasing(arr): This function calculates the minimum number of elements to be removed to make the array strictly increasing. n = len(arr) if n == 0: return 0 # Since the array is initially non-increasing, the maximum length of strictly increasing subsequence is 1. return n - 1 def process_test_cases(t, test_cases): This function processes multiple test cases and returns the results. results = [] for i in range(t): n = test_cases[i][0] # the number of elements in the array arr = test_cases[i][1] # the array results.append(min_operations_to_strictly_increasing(arr)) return results"},{"question":"def largest_stack_size(operations: List[str]) -> int: Calculate the largest size of the stack during the sequence of operations. The operations are given in a list of strings where each string is either \\"PUSH n\\" or \\"POP\\". >>> largest_stack_size(['PUSH 5', 'PUSH 3', 'POP', 'PUSH 2', 'PUSH 8', 'POP', 'POP']) 3 >>> largest_stack_size(['PUSH 10', 'PUSH 20', 'PUSH 30', 'POP', 'POP']) 3 >>> largest_stack_size(['PUSH 1', 'POP', 'PUSH 2', 'POP', 'PUSH 3', 'POP', 'PUSH 4', 'POP']) 1 >>> largest_stack_size(['PUSH 10', 'PUSH 20', 'POP', 'PUSH 30', 'POP', 'PUSH 40', 'POP', 'POP']) 2 >>> largest_stack_size(['PUSH 5', 'PUSH 5', 'PUSH 5', 'POP', 'POP', 'POP']) 3","solution":"def largest_stack_size(operations): stack = [] max_size = 0 for operation in operations: if operation.startswith(\\"PUSH\\"): _, n = operation.split() stack.append(int(n)) max_size = max(max_size, len(stack)) elif operation == \\"POP\\": stack.pop() return max_size"},{"question":"from typing import List def find_missing_integer(nums: List[int]) -> int: This function finds the missing integer that was used for all bitwise OR operations in the given sequence of numbers. >>> find_missing_integer([4, 5, 7, 7]) 3 >>> find_missing_integer([1, 1, 1, 1]) 0 >>> find_missing_integer([8, 10, 11, 15]) 7 >>> find_missing_integer([0]) 0 >>> find_missing_integer([3, 7]) 4 >>> find_missing_integer([1, 3, 3, 7, 7, 15, 15]) 14","solution":"def find_missing_integer(nums): This function finds the missing integer that was used for all bitwise OR operations in the given sequence of numbers. result = 0 for i in range(1, len(nums)): result |= (nums[i] ^ nums[i-1]) return result"},{"question":"class Plot: Represents a rectangular plot of land with potential trees. Args: matrix (list[list[int]]): Two-dimensional grid representing the plot where 1 is a tree and 0 is an empty space. Methods: add_row(row: list[int]): Adds a new row to the bottom of the plot. add_column(col: list[int]): Adds a new column to the right side of the plot. count_trees() -> int: Returns the number of trees in the plot. transplant_trees(other_plot: 'Plot', coordinates: list[int]): Transplants trees from another plot to the current plot. def __init__(self, matrix): pass def add_row(self, row): pass def add_column(self, col): pass def count_trees(self): pass def transplant_trees(self, other_plot, coordinates): pass def test_initialization(): plot = Plot([[1, 0], [0, 1]]) assert plot.matrix == [[1, 0], [0, 1]] def test_add_row(): plot = Plot([[1, 0], [0, 1]]) plot.add_row([0, 0]) assert plot.matrix == [[1, 0], [0, 1], [0, 0]] def test_add_invalid_row(): plot = Plot([[1, 0], [0, 1]]) try: plot.add_row([0, 0, 1]) except ValueError as e: assert str(e) == \\"Row length must match the number of columns in the plot\\" def test_add_column(): plot = Plot([[1, 0], [0, 1]]) plot.add_column([0, 1]) assert plot.matrix == [[1, 0, 0], [0, 1, 1]] def test_add_invalid_column(): plot = Plot([[1, 0], [0, 1]]) try: plot.add_column([0]) except ValueError as e: assert str(e) == \\"Column length must match the number of rows in the plot\\" def test_count_trees(): plot = Plot([[1, 0], [0, 1]]) assert plot.count_trees() == 2 def test_transplant_trees(): plot1 = Plot([[0, 1, 0], [1, 0, 0], [0, 0, 1]]) plot2 = Plot([[1, 1], [0, 0]]) plot1.transplant_trees(plot2, [0, 0, 1, 1]) assert plot1.matrix == [[1, 1, 0], [0, 0, 0], [0, 0, 1]] def test_transplant_invalid_coordinates(): plot1 = Plot([[0, 1, 0], [1, 0, 0], [0, 0, 1]]) plot2 = Plot([[1, 1], [0, 0]]) try: plot1.transplant_trees(plot2, [0, 0, 2, 2]) except ValueError as e: assert str(e) == \\"The dimensions of the transplant section must match the size of the other plot section\\"","solution":"class Plot: def __init__(self, matrix): self.matrix = matrix def add_row(self, row): if len(row) != len(self.matrix[0]): raise ValueError(\\"Row length must match the number of columns in the plot\\") self.matrix.append(row) def add_column(self, col): if len(col) != len(self.matrix): raise ValueError(\\"Column length must match the number of rows in the plot\\") for i in range(len(self.matrix)): self.matrix[i].append(col[i]) def count_trees(self): return sum(sum(row) for row in self.matrix) def transplant_trees(self, other_plot, coordinates): x1, y1, x2, y2 = coordinates if x2 - x1 != len(other_plot.matrix) - 1 or y2 - y1 != len(other_plot.matrix[0]) - 1: raise ValueError(\\"The dimensions of the transplant section must match the size of the other plot section\\") for i in range(x1, x2 + 1): for j in range(y1, y2 + 1): self.matrix[i][j] = other_plot.matrix[i - x1][j - y1]"},{"question":"def has_pair_with_sum(nums: List[int], target: int) -> str: Returns 'Yes' if there are two distinct numbers in the list that add up to the target. Otherwise, returns 'No'. >>> has_pair_with_sum([3, 1, 4, 6, 5], 9) 'Yes' >>> has_pair_with_sum([2, 5, 1], 4) 'No'","solution":"def has_pair_with_sum(nums, target): Returns 'Yes' if there are two distinct numbers in the list that add up to the target. Otherwise, returns 'No'. seen = set() for num in nums: if target - num in seen: return 'Yes' seen.add(num) return 'No'"},{"question":"def minimum_days_to_equal_height(n: int, blocks: List[int]) -> int: Calculates the minimum number of days required to make the height of all blocks equal. Each day, one block can be added on top of an existing block or removed from the top of it. Parameters: n (int): The number of blocks. blocks (list of int): The heights of the blocks. Returns: int: Minimum number of days to equalize all blocks. Example: >>> minimum_days_to_equal_height(4, [4, 7, 9, 10]) 8 >>> minimum_days_to_equal_height(4, [5, 5, 5, 5]) 0","solution":"def minimum_days_to_equal_height(n, blocks): Calculates the minimum number of days required to make the height of all blocks equal. Parameters: n (int): The number of blocks. blocks (list of int): The heights of the blocks. Returns: int: Minimum number of days to equalize all blocks. # Find the median height as it minimizes the number of operations sorted_blocks = sorted(blocks) median_height = sorted_blocks[n // 2] # Calculate the total number of days required to make all blocks equal to the median height days_required = sum(abs(height - median_height) for height in blocks) return days_required"},{"question":"def longest_same_char_substring(t: int, test_cases: List[Tuple[int, str]]) -> List[int]: Given t test cases, each with a string s of length n, this function returns a list of integers representing the length of the longest substring of s that consists of the same character. >>> longest_same_char_substring(3, [(5, \\"aabbb\\"), (6, \\"aaabbb\\"), (1, \\"z\\")]) == [3, 3, 1] >>> longest_same_char_substring(2, [(1, \\"a\\"), (5, \\"aaaaa\\")]) == [1, 5] >>> longest_same_char_substring(2, [(8, \\"abababab\\"), (8, \\"aabbaabb\\")]) == [1, 2]","solution":"def longest_same_char_substring(t, test_cases): Given t test cases, each with a string s of length n, this function returns a list of integers representing the length of the longest substring of s that consists of the same character. results = [] for case in test_cases: s = case[1] max_length = 1 current_length = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: current_length += 1 else: if current_length > max_length: max_length = current_length current_length = 1 if current_length > max_length: max_length = current_length results.append(max_length) return results"},{"question":"from typing import List, Tuple def calculate_growth(n: int, heights: List[int]) -> Tuple[int, int]: Calculate the minimum and maximum possible growth of a tree over the given months. >>> calculate_growth(5, [10, -1, 15, -1, 20]) (10, 10) >>> calculate_growth(7, [3, -1, -1, 8, -1, -1, 17]) (14, 14)","solution":"def calculate_growth(n, heights): Calculate the minimum and maximum possible growth of a tree over the given months. min_growth = 0 max_growth = 0 prev_height = heights[0] for i in range(1, n): if heights[i] != -1: min_growth += heights[i] - prev_height max_growth += heights[i] - prev_height prev_height = heights[i] return min_growth, max_growth # Example usage: # n = 5 # heights = [10, -1, 15, -1, 20] # print(calculate_growth(n, heights)) # Output: (10, 10)"},{"question":"def findPeakElement(arr: List[int]) -> int: Finds any peak element in the array \`arr\` and returns its index. >>> findPeakElement([1, 2, 3, 1]) 2 >>> findPeakElement([1, 2, 1, 3, 5, 6, 4]) 1","solution":"def findPeakElement(arr): Finds any peak element in the array \`arr\` and returns its index. # Binary search for peak element left, right = 0, len(arr) - 1 while left < right: mid = (left + right) // 2 if arr[mid] > arr[mid + 1]: right = mid else: left = mid + 1 return left"},{"question":"def max_sum_of_non_overlapping_substrings(s: str) -> int: You are given a string containing digits from 0 to 9. Your task is to find the maximum sum of two non-overlapping substrings such that the sum of the digits in the first substring and the sum of the digits in the second substring are the largest possible. Note: The two substrings must not overlap and can be empty. Args: s (str): A string containing digits from 0 to 9. Returns: int: The maximum possible sum of the two non-overlapping substrings. Examples: >>> max_sum_of_non_overlapping_substrings(\\"123456\\") 21 >>> max_sum_of_non_overlapping_substrings(\\"5050\\") 10","solution":"def max_sum_of_non_overlapping_substrings(s): n = len(s) max_sum = 0 left_sums = [0] * (n + 1) right_sums = [0] * (n + 1) # Calculate prefix sums from the left for i in range(n): left_sums[i + 1] = left_sums[i] + int(s[i]) # Calculate prefix sums from the right for i in range(n - 1, -1, -1): right_sums[i] = right_sums[i + 1] + int(s[i]) # Find the maximum sum by splitting at every possible position for i in range(n + 1): max_sum = max(max_sum, left_sums[i] + right_sums[i]) return max_sum"},{"question":"def scheduler(input_string: str) -> List[int]: You are tasked with assembling a scheduler for a series of events happening in different rooms. Each event has a specified start and end time. The goal of the scheduler is to ensure that no two events overlap in the same room and to minimize the number of rooms required. Input: 3 0 30 5 10 15 20 4 1 10 2 3 5 7 8 9 0 Output: [2, 2] >>> scheduler(\\"3n0 30n5 10n15 20n4n1 10n2 3n5 7n8 9n0\\") [2, 2] >>> scheduler(\\"3n0 10n15 20n25 30n0\\") [1] >>> scheduler(\\"5n0 5n1 10n2 7n8 9n10 15n0\\") [3] >>> scheduler(\\"1n0 5n0\\") [1]","solution":"def min_rooms_for_events(datasets): results = [] for events in datasets: if not events: continue times = [] for start, end in events: times.append((start, 'start')) times.append((end, 'end')) times.sort() current_rooms = 0 max_rooms = 0 for time, t_type in times: if t_type == 'start': current_rooms += 1 max_rooms = max(max_rooms, current_rooms) else: current_rooms -= 1 results.append(max_rooms) return results def parse_input(input_string): datasets = [] lines = input_string.strip().split('n') i = 0 while i < len(lines): m = int(lines[i]) if m == 0: break events = [] for j in range(i + 1, i + 1 + m): start, end = map(int, lines[j].split()) events.append((start, end)) datasets.append(events) i = i + 1 + m return datasets def scheduler(input_string): datasets = parse_input(input_string) return min_rooms_for_events(datasets)"},{"question":"def max_robbed_amount(n: int, houses: List[int]) -> int: Determine the maximum amount of money you can rob without robbing two adjacent houses. >>> max_robbed_amount(5, [2, 7, 9, 3, 1]) 12 >>> max_robbed_amount(3, [2, 1, 1]) 3","solution":"def max_robbed_amount(n, houses): if n == 0: return 0 if n == 1: return houses[0] dp = [0] * n dp[0] = houses[0] dp[1] = max(houses[0], houses[1]) for i in range(2, n): dp[i] = max(dp[i - 1], dp[i - 2] + houses[i]) return dp[n - 1]"},{"question":"def min_total_time_to_fix_bugs(num_participants: int, bug_tickets: List[int], time_per_bug: List[int]) -> int: Given the number of participants, the number of bug tickets each participant has, and the time each participant takes to fix one bug, this function returns the minimum total time required for all bugs to be fixed. :param num_participants: int - number of participants :param bug_tickets: list of int - number of bug tickets assigned to each participant :param time_per_bug: list of int - time taken by each participant to fix one bug :return: int - minimum total time required for all bugs to be fixed Examples: >>> min_total_time_to_fix_bugs(3, [4, 2, 3], [3, 5, 1]) 12 >>> min_total_time_to_fix_bugs(2, [1, 2], [1, 2]) 4 >>> min_total_time_to_fix_bugs(1, [10], [10]) 100 >>> min_total_time_to_fix_bugs(4, [2, 2, 2, 2], [2, 3, 2, 1]) 6 >>> min_total_time_to_fix_bugs(5, [1, 1, 1, 1, 1], [1, 2, 3, 4, 5]) 5","solution":"def min_total_time_to_fix_bugs(num_participants, bug_tickets, time_per_bug): Given the number of participants, the number of bug tickets each participant has, and the time each participant takes to fix one bug, this function returns the minimum total time required for all bugs to be fixed. :param num_participants: int - number of participants :param bug_tickets: list of int - number of bug tickets assigned to each participant :param time_per_bug: list of int - time taken by each participant to fix one bug :return: int - minimum total time required for all bugs to be fixed # Calculate the total time each participant needs to fix their bugs total_times = [bug_tickets[i] * time_per_bug[i] for i in range(num_participants)] # The minimum total time required is the maximum time that any participant needs return max(total_times) # Example usage: num_participants = 3 bug_tickets = [4, 2, 3] time_per_bug = [3, 5, 1] print(min_total_time_to_fix_bugs(num_participants, bug_tickets, time_per_bug)) # Output: 12"},{"question":"def min_length_after_operations(t: int, cases: List[str]) -> List[int]: Returns the minimum length of the string that can be achieved after performing the given operations any number of times in any order. Parameters: t (int): The number of test cases. cases (list of str): List containing strings as test cases. Returns: list of int: Minimum lengths for each test case. >>> min_length_after_operations(2, [\\"abba\\", \\"abab\\"]) == [0, 0] >>> min_length_after_operations(3, [\\"aab\\", \\"bba\\", \\"aabb\\"]) == [1, 1, 0]","solution":"def min_length_after_operations(t, cases): Returns the minimum length of the string that can be achieved after performing the given operations any number of times in any order. Parameters: t (int): The number of test cases. cases (list of str): List containing strings as test cases. Returns: list of int: Minimum lengths for each test case. results = [] for s in cases: # Count the number of 'a's and 'b's in the string count_a = s.count('a') count_b = s.count('b') # The minimum length is the absolute difference between count_a and count_b min_length = abs(count_a - count_b) results.append(min_length) return results"},{"question":"from typing import List def calculate_operation(operations: List[str]) -> List[int]: Performs set of instructions to execute specified operations on given numerical inputs and returns the results as a list of integers. Parameters: - operations: List[str] - a list of strings where each string is a command of exactly three characters. Returns: - List[int] - a list of integers representing the results of each operation. Example: >>> calculate_operation([\\"+32\\", \\"-45\\", \\"*32\\", \\"+07\\", \\"-12\\"]) [5, -1, 6, 7, -1]","solution":"def calculate_operation(operations): results = [] for op in operations: operation = op[0] num1 = int(op[1]) num2 = int(op[2]) if operation == '+': results.append(num1 + num2) elif operation == '-': results.append(num1 - num2) elif operation == '*': results.append(num1 * num2) return results"},{"question":"from typing import List def sort_by_length(strings: List[str]) -> List[str]: Sorts an array of strings by their lengths in non-decreasing order. Strings with the same length should retain their relative order. >>> sort_by_length([\\"a\\", \\"abc\\", \\"ab\\"]) [\\"a\\", \\"ab\\", \\"abc\\"] >>> sort_by_length([\\"longer\\", \\"long\\", \\"lo\\", \\"longest\\", \\"l\\"]) [\\"l\\", \\"lo\\", \\"long\\", \\"longer\\", \\"longest\\"] >>> sort_by_length([\\"aaa\\", \\"bbb\\", \\"ccc\\"]) [\\"aaa\\", \\"bbb\\", \\"ccc\\"] >>> sort_by_length([\\"aa\\", \\"a\\", \\"aaa\\", \\"b\\", \\"ba\\"]) [\\"a\\", \\"b\\", \\"aa\\", \\"ba\\", \\"aaa\\"] >>> sort_by_length([\\"single\\"]) [\\"single\\"] >>> long_strings = [\\"a\\" * 100, \\"b\\" * 99, \\"c\\" * 100, \\"d\\" * 98] >>> sort_by_length(long_strings) [\\"d\\" * 98, \\"b\\" * 99, \\"a\\" * 100, \\"c\\" * 100] >>> sort_by_length([]) [] >>> sort_by_length([\\"1\\", \\"123\\", \\"12\\", \\"12345\\", \\"1234\\"]) [\\"1\\", \\"12\\", \\"123\\", \\"1234\\", \\"12345\\"]","solution":"from typing import List def sort_by_length(strings: List[str]) -> List[str]: Sorts a list of strings by their lengths in non-decreasing order. Strings with the same length should retain their relative order. # Custom comparator for sorting based on length while maintaining stability return sorted(strings, key=lambda s: len(s))"},{"question":"from typing import List, Tuple def can_complete_marathon(n: int, participants: List[Tuple[int, int]]) -> List[str]: Determine if participants can complete their intended distance within the allowed time. Args: n (int): The number of participants. participants (List[Tuple[int, int]]): A list of tuples, each containing the intended distance di in kilometers and the average speed si in kilometers per hour of the participants. Returns: List[str]: A list of \\"YES\\" or \\"NO\\" for each participant. Example: >>> can_complete_marathon(3, [(21, 6), (42, 8), (21, 3)]) [\\"YES\\", \\"YES\\", \\"NO\\"]","solution":"def can_complete_marathon(n, participants): max_time_hours = 7 # Maximum allowed time in hours results = [] for distance, speed in participants: time_needed = distance / speed if time_needed <= max_time_hours: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def max_wizards_for_tournament(M: int, wand_powers: List[int]) -> int: Returns the maximum number of wizards that can line up for the tournament such that the wand powers are in strictly increasing order. Args: M: int : Total number of wizards. wand_powers: List[int] : List of magical powers for each wizard's wand. Returns: int : The maximum number of wizards that can participate in the tournament. Examples: >>> max_wizards_for_tournament(6, [3, 10, 2, 1, 20, 4]) 3 >>> max_wizards_for_tournament(5, [1, 2, 3, 4, 5]) 5 >>> max_wizards_for_tournament(5, [5, 4, 3, 2, 1]) 1 >>> max_wizards_for_tournament(8, [10, 22, 9, 33, 21, 50, 41, 60]) 5 >>> max_wizards_for_tournament(1, [10]) 1 >>> max_wizards_for_tournament(2, [10, 5]) 1 >>> max_wizards_for_tournament(2, [5, 10]) 2 >>> max_wizards_for_tournament(3, [5, 5, 5]) 1 >>> max_wizards_for_tournament(0, []) 0","solution":"def max_wizards_for_tournament(M, wand_powers): Returns the maximum number of wizards that can line up for the tournament such that the wand powers are in strictly increasing order. if M == 0: return 0 # Length of Longest Increasing Subsequence (LIS) algorithm (Dynamic Programming) lis = [1] * M for i in range(1, M): for j in range(i): if wand_powers[i] > wand_powers[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 return max(lis) # Example usage: M = 6 wand_powers = [3, 10, 2, 1, 20, 4] print(max_wizards_for_tournament(M, wand_powers)) # Prints: 3"},{"question":"def smallest_permutations(input_string: str) -> str: Given an input string with multiple test cases, each containing an array of integers, determine the lexicographically smallest permutation of the array that can be obtained by performing swaps as described. :param input_string: a str containing all the test cases :return: a str with the smallest permutations for each test case, each permutation on a new line. Example ------- >>> input_string = \\"3n5n3 1 2 5 4n4n9 5 3 7n3n10 8 2\\" >>> smallest_permutations(input_string) \\"1 2 3 4 5n3 5 7 9n2 8 10\\"","solution":"def lexicographically_smallest_permutations(test_cases): results = [] for case in test_cases: array = case['array'] sorted_array = sorted(array) results.append(sorted_array) return results def process_input(input_string): input_lines = input_string.strip().split(\\"n\\") t = int(input_lines[0]) index = 1 test_cases = [] for _ in range(t): n = int(input_lines[index]) array = list(map(int, input_lines[index + 1].split())) test_cases.append({'n': n, 'array': array}) index += 2 return test_cases def format_output(arrays): return \\"n\\".join(\\" \\".join(map(str, array)) for array in arrays) # Combine all above parts into one function to process the input def smallest_permutations(input_string): test_cases = process_input(input_string) results = lexicographically_smallest_permutations(test_cases) return format_output(results)"},{"question":"def max_profit(N: int, prices: List[int]) -> int: Returns the maximum profit that can be achieved from a single buy-sell transaction. If no profit can be achieved, returns 0. >>> max_profit(6, [7, 1, 5, 3, 6, 4]) 5 >>> max_profit(5, [7, 6, 4, 3, 1]) 0","solution":"def max_profit(N, prices): Returns the maximum profit that can be achieved from a single buy-sell transaction. If no profit can be achieved, returns 0. if N < 2: return 0 min_price = prices[0] max_profit = 0 for i in range(1, N): current_price = prices[i] potential_profit = current_price - min_price max_profit = max(max_profit, potential_profit) min_price = min(min_price, current_price) return max_profit"},{"question":"def min_moves_to_make_equal(arr): Calculate the minimum number of moves required to make all elements of the array equal. >>> min_moves_to_make_equal([2, 4, 1]) == 5 >>> min_moves_to_make_equal([3, 1, 2, 2]) == 4 def solve(T, test_cases): Process multiple test cases and return the results for each one. >>> solve(2, [(3, [2, 4, 1]), (4, [3, 1, 2, 2])]) == [5, 4] >>> solve(1, [(2, [5, 10])]) == [5] >>> solve(3, [(4, [1, 1, 1, 1]), (5, [0, 0, 0, 0, 0]), (3, [1, 2, 3])]) == [0, 0, 3]","solution":"def min_moves_to_make_equal(arr): # Find the maximum element in arr max_elem = max(arr) # Calculate the total number of increments to make all elements equal to max_elem min_moves = sum(max_elem - elem for elem in arr) return min_moves def solve(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] arr = test_cases[i][1] results.append(min_moves_to_make_equal(arr)) return results"},{"question":"def calculate_tournament_scores(matchups: List[str]) -> Tuple[int, List[Tuple[str, int]]]: Calculate the final scores of each team after all matchups based on the tournament results. Parameters: matchups (list of str): List of match results Returns: tuple: A tuple containing the total number of unique teams and a list of tuples with each team's name and total score. Example: >>> calculate_tournament_scores([ ... \\"Alpha Bravo Alpha-win\\", ... \\"Charlie Delta Charlie-win\\", ... \\"Echo Foxtrot Echo-win\\", ... \\"Alpha Delta Delta-win\\", ... \\"Bravo Echo Bravo-win\\", ... \\"Charlie Alpha Alpha-win\\", ... \\"Delta Foxtrot Delta-win\\"]) (6, [ (\\"Alpha\\", 6), (\\"Delta\\", 6), (\\"Bravo\\", 3), (\\"Charlie\\", 3), (\\"Echo\\", 3), (\\"Foxtrot\\", 0) ]) >>> calculate_tournament_scores([ ... \\"A B A-win\\", ... \\"C D C-win\\", ... \\"E A E-win\\", ... \\"B E B-win\\"]) (5, [ (\\"A\\", 3), (\\"B\\", 3), (\\"C\\", 3), (\\"E\\", 3), (\\"D\\", 0) ])","solution":"def calculate_tournament_scores(matchups): Calculate the final scores of each team after all matchups based on the tournament results. Parameters: matchups (list of str): List of match results Returns: tuple: A tuple containing the total number of unique teams and a list of tuples with each team's name and total score. from collections import defaultdict scores = defaultdict(int) for match in matchups: team1, team2, result = match.split() if result == f\\"{team1}-win\\": scores[team1] += 3 elif result == f\\"{team2}-win\\": scores[team2] += 3 # Determine the unique teams unique_teams = set(scores.keys()) for match in matchups: team1, team2, _ = match.split() unique_teams.add(team1) unique_teams.add(team2) n = len(unique_teams) leaderboard = [(team, scores[team]) for team in unique_teams] # Sort by score in descending order, by name alphabetically in case of tie leaderboard.sort(key=lambda x: (-x[1], x[0])) return n, leaderboard"},{"question":"def is_bipartite(n: int, m: int, edges: List[Tuple[int, int]]) -> str: Given an undirected graph with n vertices and m edges, find if the graph is bipartite. A bipartite graph is a graph whose vertices can be divided into two disjoint and independent sets U and V such that every edge connects a vertex in U to one in V. Parameters: n (int): The number of vertices in the graph. m (int): The number of edges in the graph. edges (List[Tuple[int, int]]): A list of tuples representing the edges of the graph. Returns: str: \\"YES\\" if the graph is bipartite, \\"NO\\" otherwise. Examples: >>> is_bipartite(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) 'YES' >>> is_bipartite(3, 3, [(1, 2), (2, 3), (3, 1)]) 'NO'","solution":"def is_bipartite(n, m, edges): from collections import deque # Initialize adjacency list adj = [[] for _ in range(n)] for u, v in edges: adj[u - 1].append(v - 1) adj[v - 1].append(u - 1) # Initialize color array, -1 means uncolored color = [-1] * n def bfs(start): queue = deque([start]) color[start] = 0 # start coloring with 0 while queue: node = queue.popleft() for neighbor in adj[node]: if color[neighbor] == -1: # if not colored color[neighbor] = 1 - color[node] # color with opposite color queue.append(neighbor) elif color[neighbor] == color[node]: # if the neighbor has the same color return False return True for i in range(n): if color[i] == -1: if not bfs(i): return \\"NO\\" return \\"YES\\""},{"question":"def is_valid_network(n: int, p: int, addresses: List[str]) -> str: Determines if no two addresses share a common prefix longer than \`p\` characters. >>> is_valid_network(4, 3, [\\"a1b2c3\\", \\"a1bXyz\\", \\"001abc\\", \\"xyz999\\"]) \\"NO\\" >>> is_valid_network(3, 2, [\\"a1b2\\", \\"cde34\\", \\"a2b3\\"]) \\"YES\\" >>> is_valid_network(2, 1, [\\"a\\", \\"ab\\"]) \\"NO\\"","solution":"def is_valid_network(n, p, addresses): Determines if the network is valid by ensuring no two addresses share a common prefix longer than \`p\` characters. Args: n (int): Number of addresses. p (int): Maximum allowed common prefix length. addresses (list of str): List of addresses. Returns: str: \\"YES\\" if the network is valid, otherwise \\"NO\\". prefixes = set() for address in addresses: prefix = address[:p] if prefix in prefixes: return \\"NO\\" prefixes.add(prefix) return \\"YES\\" # Example usage: # n = 4 # p = 3 # addresses = [\\"a1b2c3\\", \\"a1bXyz\\", \\"001abc\\", \\"xyz999\\"] # print(is_valid_network(n, p, addresses)) # Output: NO"},{"question":"def who_wins(n: int) -> str: Determines the winner of the game given the starting integer N. Parameters: n (int): The starting number Returns: str: \\"Alice\\" if Alice will win, \\"Bob\\" otherwise >>> who_wins(5) 'Alice' >>> who_wins(18) 'Bob'","solution":"def who_wins(n): Determines the winner of the game given the starting integer N. Parameters: n (int): The starting number Returns: str: \\"Alice\\" if Alice will win, \\"Bob\\" otherwise # If N is 1 right away, Alice will lose because she has no moves if n == 1: return \\"Bob\\" # This game actually can be reduced to a mathematical observation # If you see the pattern, for every n=1 Bob wins, for n=2 Alice wins, for n=3 Bob wins, n=4 Alice wins and so on.. # It is observed that if \`n\` is even Alice wins. If \`n\` is odd Bob wins. # This is due to Alice either directly subtracting 1 or making a move which keeps it odd or even alternatively. return \\"Alice\\" if n % 2 == 0 else \\"Bob\\""},{"question":"def max_houses_to_visit(n: int, k: int, candies: List[int]) -> int: Determines the maximum number of houses that can be visited while collecting exactly k candies. Parameters: n (int): Number of houses k (int): Capacity of the bag in candies candies (list of int): List where ith value is the number of candies at house i Returns: int: Maximum number of houses visited while collecting exactly k candies, or -1 if it is not possible. >>> max_houses_to_visit(5, 8, [2, 3, 1, 2, 2]) 4 >>> max_houses_to_visit(6, 3, [1, 1, 1, 1, 1, 1]) 3 >>> max_houses_to_visit(4, 10, [2, 2, 2, 2]) -1 >>> max_houses_to_visit(3, 7, [1, 2, 3]) -1 >>> max_houses_to_visit(1, 5, [5]) 1","solution":"def max_houses_to_visit(n, k, candies): Determines the maximum number of houses that can be visited while collecting exactly k candies. Parameters: n (int): Number of houses k (int): Capacity of the bag in candies candies (list of int): List where ith value is the number of candies at house i Returns: int: Maximum number of houses visited while collecting exactly k candies, or -1 if it is not possible. for start in range(n): total_candies = 0 for end in range(start, n): total_candies += candies[end] if total_candies == k: return end - start + 1 if total_candies > k: break return -1"},{"question":"def min_operations_to_equal_grid(n: int, m: int, grid: List[List[int]]) -> int: Returns the minimum number of operations required to make all the elements in the grid equal. Parameters: n (int): the number of rows in the grid. m (int): the number of columns in the grid. grid (List[List[int]]): the initial values in the grid. Returns: int: the minimum number of operations required to make all elements in the grid equal. >>> min_operations_to_equal_grid(3, 4, [ [1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6] ]) 5 >>> min_operations_to_equal_grid(2, 3, [ [4, 4, 4], [4, 4, 4] ]) 0 >>> min_operations_to_equal_grid(2, 2, [ [2, 9], [12, 7] ]) 10","solution":"def min_operations_to_equal_grid(n, m, grid): Returns the minimum number of operations required to make all the elements in the grid equal. max_val = max([max(row) for row in grid]) min_val = min([min(row) for row in grid]) # Difference between max value and min value in the grid return max_val - min_val"},{"question":"from typing import List def countPairsWithSum(arr: List[int], target: int) -> int: Returns the number of unique pairs of elements in arr such that their sum is equal to target. >>> countPairsWithSum([1, 2, 3, 4, 3], 6) 2 >>> countPairsWithSum([1, 2, 3, 4], 10) 0 >>> countPairsWithSum([1, 1, 1, 1, 1], 2) 1 >>> countPairsWithSum([1, 2, 2, 3, 4], 6) 1 >>> countPairsWithSum([1000000000, 1000000000, -1000000000], 0) 1 >>> countPairsWithSum([-1, 1, 0, 2, -2, -3, 3], 0) 3 >>> countPairsWithSum([1], 2) 0 >>> countPairsWithSum([], 2) 0 pass","solution":"def countPairsWithSum(arr, target): Returns the number of unique pairs of elements in arr such that their sum is equal to target. seen = set() pairs = set() for num in arr: complement = target - num if complement in seen: pairs.add(tuple(sorted((num, complement)))) seen.add(num) return len(pairs)"},{"question":"def allocate_medals(participants): Allocates medals (gold, silver, bronze) based on the scores of participants. :param participants: list of tuples (handle, score) :return: tuple containing the handles of participants winning the gold, silver, and bronze medals >>> allocate_medals([(\\"abigail\\", 98), (\\"ben\\", 97), (\\"charles\\", 96), (\\"diana\\", 95)]) (\\"abigail\\", \\"ben\\", \\"charles\\") >>> allocate_medals([(\\"alice\\", 95), (\\"bob\\", 85), (\\"carol\\", 95), (\\"dave\\", 85), (\\"eve\\", 75)]) (\\"None\\", \\"None\\", \\"eve\\") # your code here # Unit tests def test_allocatemedals(): assert allocate_medals([(\\"alice\\", 95), (\\"bob\\", 85), (\\"carol\\", 95), (\\"dave\\", 85), (\\"eve\\", 75)]) == (\\"None\\", \\"None\\", \\"eve\\") assert allocate_medals([(\\"abigail\\", 98), (\\"ben\\", 97), (\\"charles\\", 96), (\\"diana\\", 95)]) == (\\"abigail\\", \\"ben\\", \\"charles\\") assert allocate_medals([(\\"alice\\", 90), (\\"bob\\", 90), (\\"carol\\", 90)]) == (\\"None\\", \\"None\\", \\"None\\") assert allocate_medals([(\\"user1\\", 30), (\\"user2\\", 20), (\\"user3\\", 10)]) == (\\"user1\\", \\"user2\\", \\"user3\\") assert allocate_medals([(\\"y\\", 50), (\\"z\\", 50), (\\"a\\", 40), (\\"b\\", 30)]) == (\\"None\\", \\"a\\", \\"b\\") assert allocate_medals([(\\"u1\\", 100), (\\"u2\\", 100), (\\"u3\\", 99), (\\"u4\\", 98), (\\"u5\\", 97)]) == (\\"None\\", \\"u3\\", \\"u4\\") assert allocate_medals([(\\"u1\\", 8), (\\"u2\\", 10), (\\"u3\\", 8), (\\"u4\\", 7), (\\"u5\\", 9)]) == (\\"u2\\", \\"u5\\", \\"None\\") if __name__ == \\"__main__\\": import pytest pytest.main()","solution":"def allocate_medals(participants): Allocates medals (gold, silver, bronze) based on the scores of participants. :param participants: list of tuples (handle, score) :return: tuple containing the handles of participants winning the gold, silver, and bronze medals from collections import defaultdict # Dictionary to store scores and corresponding handles score_to_handles = defaultdict(list) # Fill the dictionary with participants' scores and handles for handle, score in participants: score_to_handles[score].append(handle) # Get unique scores sorted in descending order unique_scores = sorted(score_to_handles.keys(), reverse=True) # Determine medalists gold, silver, bronze = \\"None\\", \\"None\\", \\"None\\" # Gold medalist if len(unique_scores) >= 1 and len(score_to_handles[unique_scores[0]]) == 1: gold = score_to_handles[unique_scores[0]][0] # Silver medalist if len(unique_scores) >= 2 and len(score_to_handles[unique_scores[1]]) == 1: silver = score_to_handles[unique_scores[1]][0] # Bronze medalist if len(unique_scores) >= 3 and len(score_to_handles[unique_scores[2]]) == 1: bronze = score_to_handles[unique_scores[2]][0] return gold, silver, bronze def main(): import sys input = sys.stdin.read data = input().splitlines() n = int(data[0]) participants = [tuple(line.split()) for line in data[1:n+1]] participants = [(handle, int(score)) for handle, score in participants] gold, silver, bronze = allocate_medals(participants) print(gold) print(silver) print(bronze)"},{"question":"from typing import List, Tuple class Library: def __init__(self, initial_ratings: List[int]): Initialize the library with the initial ratings of the books. self.ratings = initial_ratings def update_rating(self, i: int, new_value: int): Update the rating of the book with the given ID to the new value. pass def range_query(self, l: int, r: int) -> int: Calculate the total rating of all books from ID l to ID r (inclusive). pass def manage_library(N: int, Q: int, initial_ratings: List[int], queries: List[Tuple[int, int, int]]) -> List[int]: Manage a collection of books in a library with update and range queries. Args: N: Number of books. Q: Number of queries. initial_ratings: A list of integers representing initial ratings of the books. queries: A list of tuple, representing the queries. Returns: A list of integers representing the results of range queries. >>> manage_library(5, 5, [5, 3, 6, 2, 1], [(2, 1, 3), (1, 3, 10), (2, 2, 4), (1, 4, 8), (2, 1, 5)]) [14, 15, 27] >>> manage_library(4, 4, [1, 2, 3, 4], [(2, 1, 4), (1, 2, 5), (2, 1, 3), (2, 3, 4)]) [10, 9, 7] pass","solution":"class Library: def __init__(self, initial_ratings): self.ratings = initial_ratings self.N = len(initial_ratings) self.tree = [0] * (self.N + 1) for i in range(self.N): self._update_tree(i + 1, self.ratings[i]) def _update_tree(self, i, delta): while i <= self.N: self.tree[i] += delta i += (i & -i) def _query_tree(self, i): s = 0 while i > 0: s += self.tree[i] i -= (i & -i) return s def update_rating(self, i, new_value): delta = new_value - self.ratings[i - 1] self.ratings[i - 1] = new_value self._update_tree(i, delta) def range_query(self, l, r): return self._query_tree(r) - self._query_tree(l - 1) def manage_library(N, Q, initial_ratings, queries): library = Library(initial_ratings) result = [] for query in queries: if query[0] == 1: library.update_rating(query[1], query[2]) elif query[0] == 2: result.append(library.range_query(query[1], query[2])) return result # Example usage: N = 5 Q = 5 initial_ratings = [5, 3, 6, 2, 1] queries = [(2, 1, 3), (1, 3, 10), (2, 2, 4), (1, 4, 8), (2, 1, 5)] print(manage_library(N, Q, initial_ratings, queries))"},{"question":"def kth_smallest(matrix, n, m, k): Finds the k-th smallest element in a sorted matrix. Parameters: matrix (list of list of int): The sorted matrix. n (int): Number of rows. m (int): Number of columns. k (int): Position of the element to find (1-based index). Returns: int: The k-th smallest element in the matrix. Examples: >>> kth_smallest([[1, 5, 9], [10, 11, 13], [12, 13, 15]], 3, 3, 8) 13 >>> kth_smallest([[1, 2], [3, 4]], 2, 2, 2) 2 >>> kth_smallest([[10]], 1, 1, 1) 10 >>> kth_smallest([[1, 2, 2], [3, 3, 4]], 2, 3, 4) 3 >>> kth_smallest([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3, 3, 9) 9","solution":"import heapq def kth_smallest(matrix, n, m, k): Finds the k-th smallest element in a sorted matrix. Parameters: matrix (list of list of int): The sorted matrix. n (int): Number of rows. m (int): Number of columns. k (int): Position of the element to find (1-based index). Returns: int: The k-th smallest element in the matrix. flat_list = [item for row in matrix for item in row] heapq.heapify(flat_list) # Retrieve the k-th smallest element from the min-heap for _ in range(k - 1): heapq.heappop(flat_list) return heapq.heappop(flat_list)"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def find_height(root): Recursively finds the height of the binary tree. >>> find_height(TreeNode(1)) == 0 pass def lca(root, p, q): Finds the lowest common ancestor (LCA) of two given nodes in the tree. >>> root = TreeNode(1) >>> node2 = TreeNode(2) >>> node3 = TreeNode(3) >>> root.left = node2 >>> root.right = node3 >>> lca(root, node2, node3).val == 1 pass def parse_tree(edges): Parses the list of edges into a binary tree. >>> edges = [(1, 2), (1, 3), (2, 4), (2, 5)] >>> _, root = parse_tree(edges) >>> root.val == 1 >>> root.left.val == 2 >>> root.right.val == 3 >>> root.left.left.val == 4 >>> root.left.right.val == 5 pass def find_height_or_lca(n, vals, edges, p, q): Find either the height of the tree or the LCA of two nodes. >>> n = 5 >>> vals = [1, 2, 3, 4, 5] >>> edges = [(1, 2), (1, 3), (2, 4), (2, 5)] >>> p = 4 >>> q = 5 >>> find_height_or_lca(n, vals, edges, p, q) 1 2 2 pass","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def find_height(root): if root is None: return -1 else: left_height = find_height(root.left) right_height = find_height(root.right) return 1 + max(left_height, right_height) def lca(root, p, q): if root is None or root == p or root == q: return root left = lca(root.left, p, q) right = lca(root.right, p, q) if left is not None and right is not None: return root return left if left is not None else right def parse_tree(edges): from collections import defaultdict import sys sys.setrecursionlimit(150000) nodes = {} for u, v in edges: if u not in nodes: nodes[u] = TreeNode(u) if v not in nodes: nodes[v] = TreeNode(v) # Let's assume the u is the parent and v is the child if nodes[u].left is None: nodes[u].left = nodes[v] else: nodes[u].right = nodes[v] for node in nodes.values(): if node.val == 1: root = node return nodes, root def find_height_or_lca(n, vals, edges, p, q): nodes, root = parse_tree(edges) # To find LCA, we need the nodes objects p and q. p_node = nodes[p] q_node = nodes[q] # Print height of the tree print(1) print(find_height(root)) # Find and print LCA of p and q ancestor = lca(root, p_node, q_node) print(2) print(ancestor.val) # Example inputs n = 5 vals = [1, 2, 3, 4, 5] edges = [(1, 2), (1, 3), (2, 4), (2, 5)] p = 4 q = 5 find_height_or_lca(n, vals, edges, p, q) n = 7 vals = [1, 2, 3, 4, 5, 6, 7] edges = [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)] p = 4 q = 6 find_height_or_lca(n, vals, edges, p, q) n = 4 vals = [1, 2, 3, 4] edges = [(1, 2), (2, 3), (3, 4)] p = 2 q = 4 find_height_or_lca(n, vals, edges, p, q)"},{"question":"def max_travel_time(n, m, k, roads, routes): Calculate the maximum travel time among all delivery trucks' routes. Args: n (int): Number of intersections m (int): Number of roads k (int): Number of delivery trucks roads (list): List of tuples representing the roads (ui, vi, wi) routes (list): List of tuples representing the trucks' routes (ti, li, [pi, qi, ...]) Returns: int: The maximum travel time among all trucks Examples: >>> max_travel_time(5, 6, 2, [(0, 1, 4), (0, 2, 2), (1, 3, 6), (2, 3, 1), (3, 4, 3), (1, 2, 2)], [(8, 2, 0, 1, 3), (10, 2, 2, 3, 4)]) 10 >>> max_travel_time(3, 1, 1, [(0, 1, 5)], [(0, 2, 0, 1)]) 5","solution":"def max_travel_time(n, m, k, roads, routes): from collections import defaultdict # Create an adjacency list to represent the graph graph = defaultdict(list) for u, v, w in roads: graph[u].append((v, w)) def calculate_travel_time(route): total_time = 0 for (p, q) in zip(route[:-1], route[1:]): for v, w in graph[p]: if v == q: total_time += w break return total_time max_time = 0 for t, l, *stops in routes: travel_time = calculate_travel_time(stops) max_time = max(max_time, travel_time) return max_time"},{"question":"class MagicGates: def __init__(self, n): Initialize the gates, all closed initially. self.gates = [0] * n # 0 represents closed, 1 represents open def open_gate(self, x): Open gate x. self.gates[x - 1] = 1 def close_gate(self, x): Close gate x. self.gates[x - 1] = 0 def count_open_gates(self, l, r): Count the number of open gates from l to r (inclusive). return sum(self.gates[l - 1:r]) def handle_events(n, q, events): Handle the events as described, and return the results for 'count' events. Args: n (int): Number of gates. q (int): Number of events. events (List[str]): List of events in the given format. Returns: List[int]: Results for the 'count' events. >>> handle_events(5, 6, [\\"open 1\\", \\"open 2\\", \\"count 1 3\\", \\"close 2\\", \\"count 1 5\\", \\"open 3\\"]) [2, 1] >>> handle_events(5, 3, [\\"count 1 5\\", \\"close 3\\", \\"count 2 4\\"]) [0, 0] gates = MagicGates(n) results = [] for event in events: parts = event.split() if parts[0] == \\"open\\": gates.open_gate(int(parts[1])) elif parts[0] == \\"close\\": gates.close_gate(int(parts[1])) elif parts[0] == \\"count\\": results.append(gates.count_open_gates(int(parts[1]), int(parts[2]))) return results","solution":"class MagicGates: def __init__(self, n): self.gates = [0] * n # 0 represents closed, 1 represents open def open_gate(self, x): self.gates[x - 1] = 1 def close_gate(self, x): self.gates[x - 1] = 0 def count_open_gates(self, l, r): return sum(self.gates[l - 1:r]) def handle_events(n, q, events): gates = MagicGates(n) results = [] for event in events: parts = event.split() if parts[0] == \\"open\\": gates.open_gate(int(parts[1])) elif parts[0] == \\"close\\": gates.close_gate(int(parts[1])) elif parts[0] == \\"count\\": results.append(gates.count_open_gates(int(parts[1]), int(parts[2]))) return results"},{"question":"def max_rides(n: int, m: int, paths: List[Tuple[int, int, int]]) -> int: Compute the maximum number of unique rides that can be experienced using only open paths. Args: n: An integer representing the number of rides. m: An integer representing the number of paths. paths: A list of tuples where each tuple contains three integers, u, v, and s, representing a path between ride u and ride v, and the state of the path (1 for open and 0 for closed). Returns: An integer representing the maximum number of unique rides that can be experienced. Examples: >>> max_rides(5, 6, [(0, 1, 1), (1, 2, 0), (2, 3, 1), (1, 3, 1), (3, 4, 1), (0, 4, 0)]) 4 >>> max_rides(4, 3, [(0, 1, 1), (1, 2, 1), (2, 3, 1)]) 4 >>> max_rides(4, 3, [(0, 1, 0), (1, 2, 0), (2, 3, 0)]) 1 >>> max_rides(6, 5, [(0, 1, 1), (1, 2, 1), (3, 4, 1), (4, 5, 1), (5, 0, 0)]) 3 >>> max_rides(1, 0, []) 1","solution":"def max_rides(n, m, paths): from collections import defaultdict from itertools import permutations # Building the graph with only open paths graph = defaultdict(list) for u, v, s in paths: if s == 1: graph[u].append(v) graph[v].append(u) def dfs(node, visited): max_count = 1 visited.add(node) for neighbor in graph[node]: if neighbor not in visited: count = 1 + dfs(neighbor, visited) max_count = max(max_count, count) visited.remove(node) return max_count max_rides_count = 0 for start_node in range(n): max_rides_count = max(max_rides_count, dfs(start_node, set())) return max_rides_count"},{"question":"def min_moves_to_reach_goal(N: int, grid: List[List[int]]) -> int: Determine the minimum number of moves required to reach the goal in a grid-based video game where a character moves with constraints on the obstacle levels. Args: N (int): Size of the grid (N x N). grid (List[List[int]]): Obstacle levels in the grid. Returns: int: Minimum number of moves to reach the bottom-right corner from the top-left corner, or -1 if it is not possible. Examples: >>> min_moves_to_reach_goal(3, [ ... [1, 2, 3], ... [2, 3, 4], ... [3, 4, 5] ... ]) == 4 >>> min_moves_to_reach_goal(2, [ ... [1, 9], ... [9, 1] ... ]) == -1 >>> min_moves_to_reach_goal(4, [ ... [1, 1, 1, 1], ... [1, 2, 3, 4], ... [4, 3, 2, 1], ... [1, 1, 1, 1] ... ]) == 6 >>> min_moves_to_reach_goal(1, [ ... [5] ... ]) == 0 >>> min_moves_to_reach_goal(3, [ ... [1, 2, 1], ... [2, 9, 2], ... [1, 2, 1] ... ]) == 4","solution":"from collections import deque def min_moves_to_reach_goal(N, grid): def is_valid(x, y, current_level): return 0 <= x < N and 0 <= y < N and abs(grid[x][y] - current_level) <= 1 directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] queue = deque([(0, 0, 0)]) # (x, y, moves) visited = set() visited.add((0, 0)) while queue: x, y, moves = queue.popleft() if (x, y) == (N - 1, N - 1): return moves current_level = grid[x][y] for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny, current_level) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, moves + 1)) return -1 # Example usage: # N = 3 # grid = [ # [1, 2, 3], # [2, 3, 4], # [3, 4, 5] # ] # print(min_moves_to_reach_goal(N, grid)) # Output: 4"},{"question":"def length_of_longest_substring(s: str) -> int: Write a program that finds the length of the longest substring of a given string that contains no repeating characters. :param s: Input string :return: An integer representing the length of the longest substring with all unique characters >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"abcdef\\") 6 >>> length_of_longest_substring(\\"aaaaaa\\") 1 >>> length_of_longest_substring(\\"abcbacbb\\") 3 >>> length_of_longest_substring(\\"\\") 0 >>> length_of_longest_substring(\\"a\\") 1 >>> length_of_longest_substring(\\"bbbbbbbbb\\") 1","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. char_map = {} left = 0 max_len = 0 for right in range(len(s)): if s[right] in char_map: left = max(char_map[s[right]] + 1, left) char_map[s[right]] = right max_len = max(max_len, right - left + 1) return max_len"},{"question":"def can_reach_end(grid: List[List[int]]) -> str: Determines if the robot can reach the bottom-right corner of the grid avoiding obstacles. >>> can_reach_end([ ... [0, 0, 0, 0], ... [1, 1, 0, 1], ... [0, 0, 0, 0], ... [0, 1, 1, 0] ... ]) \\"Yes\\" >>> can_reach_end([ ... [0, 0, 1], ... [0, 1, 0], ... [1, 0, 0] ... ]) \\"No\\" >>> can_reach_end([ ... [0] ... ]) \\"Yes\\" >>> can_reach_end([ ... [0, 0], ... [0, 0] ... ]) \\"Yes\\" >>> can_reach_end([ ... [1, 0], ... [0, 0] ... ]) \\"No\\" >>> can_reach_end([ ... [0, 0], ... [0, 1] ... ]) \\"No\\"","solution":"def can_reach_end(grid): Determines if the robot can reach the bottom-right corner of the grid avoiding obstacles. n = len(grid) m = len(grid[0]) def is_valid_move(x, y): return 0 <= x < n and 0 <= y < m and grid[x][y] == 0 def dfs(x, y): if not is_valid_move(x, y): return False if (x, y) == (n-1, m-1): return True grid[x][y] = -1 # Mark as visited directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] for dx, dy in directions: if dfs(x + dx, y + dy): return True return False return \\"Yes\\" if dfs(0, 0) else \\"No\\""},{"question":"def determine_total_coins(N: int, queries_responses: List[Tuple[int, int, bool]]) -> int: Determines the total number of gold coins, considering double coins for unoccupied rooms. :param N: int - Number of rooms. :param queries_responses: list of tuples - Each tuple contains (room_index, coins_count, is_occupied) :return: int - Total number of gold coins across all rooms. pass def test_determine_total_coins_all_occupied(): # Test with all rooms occupied N = 5 queries_responses = [ (1, 4, True), (2, 2, True), (3, 3, True), (4, 1, True), (5, 5, True), ] assert determine_total_coins(N, queries_responses) == 15 def test_determine_total_coins_some_unoccupied(): # Test with some rooms unoccupied N = 5 queries_responses = [ (1, 4, True), (2, 2, False), (3, 3, True), (4, 0, False), (5, 5, True), ] # Room 2 coins doubled: 2 * 2 = 4, Room 4 coins doubled: 0 * 2 = 0 assert determine_total_coins(N, queries_responses) == 16 def test_determine_total_coins_all_unoccupied(): # Test with all rooms unoccupied N = 5 queries_responses = [ (1, 4, False), (2, 2, False), (3, 3, False), (4, 1, False), (5, 5, False), ] # All coins doubled assert determine_total_coins(N, queries_responses) == 30 def test_determine_total_coins_mixed(): # Test with a mix of occupied and unoccupied N = 6 queries_responses = [ (1, 4, True), (2, 2, False), (3, 3, True), (4, 0, True), (5, 1, False), (6, 5, False), ] # Room 2 coins doubled: 2 * 2 = 4, Room 5 coins doubled: 1 * 2 = 2, Room 6 coins doubled: 5 * 2 = 10 assert determine_total_coins(N, queries_responses) == 23","solution":"def determine_total_coins(N, queries_responses): Determines the total number of gold coins, considering double coins for unoccupied rooms. :param N: int - Number of rooms. :param queries_responses: list of tuples - Each tuple contains (room_index, coins_count, is_occupied) :return: int - Total number of gold coins across all rooms. total_coins = 0 for i in range(N): room_index, coins_count, is_occupied = queries_responses[i] if not is_occupied: coins_count *= 2 total_coins += coins_count return total_coins"},{"question":"def num_anagram_groups(test_cases): Returns the number of groups of anagrams for each test case. :param test_cases: List of test cases, where each test case is a list of strings. :return: List of integers representing the number of anagram groups for each test case.","solution":"def num_anagram_groups(test_cases): Returns the number of groups of anagrams for each test case. :param test_cases: List of test cases, where each test case is a list of strings. :return: List of integers representing the number of anagram groups for each test case. results = [] for strings in test_cases: anagram_dict = {} for s in strings: sorted_s = ''.join(sorted(s)) if sorted_s in anagram_dict: anagram_dict[sorted_s] += 1 else: anagram_dict[sorted_s] = 1 results.append(len(anagram_dict)) return results"},{"question":"def smallest_lexicographical_string(s: str) -> str: Given a string that contains only lowercase English alphabets, return the lexicographically smallest possible string that can be obtained by removing characters from the input string. Characters should be removed in a sequential manner. Examples: >>> smallest_lexicographical_string(\\"bcabc\\") \\"abc\\" >>> smallest_lexicographical_string(\\"cbacdcbc\\") \\"acdb\\"","solution":"def smallest_lexicographical_string(s): last_occurrence = {ch: i for i, ch in enumerate(s)} stack = [] seen = set() for i, ch in enumerate(s): if ch not in seen: while stack and stack[-1] > ch and last_occurrence[stack[-1]] > i: seen.remove(stack.pop()) seen.add(ch) stack.append(ch) return ''.join(stack)"},{"question":"from typing import List def count_consecutive_palindromic_substrings(T: int, strings: List[str]) -> List[int]: Jessica loves palindromes and has recently learned about \\"consecutive palindromic substrings\\". A consecutive palindromic substring is a sequence of characters in which each substring of length greater than 1 is a palindrome. Jessica wants to count the number of such consecutive palindromic substrings in a given string. Parameters: T (int): The number of test cases. strings (List[str]): List of input strings for each test case. Returns: List[int]: Number of consecutive palindromic substrings for each input string. Examples: >>> count_consecutive_palindromic_substrings(3, [\\"aaa\\", \\"abc\\", \\"abba\\"]) [6, 3, 6] >>> count_consecutive_palindromic_substrings(2, [\\"kayak\\", \\"level\\"]) [7, 7]","solution":"def count_consecutive_palindromic_substrings(T, strings): def is_palindrome(s): return s == s[::-1] results = [] for s in strings: count = 0 n = len(s) for i in range(n): for j in range(i, n): if is_palindrome(s[i:j+1]): count += 1 results.append(count) return results"},{"question":"def max_teams(n, seniorities): Given the number of employees n and a list of their unique seniority levels, determine the maximum number of teams that can be formed. :param n: Integer, number of employees (2  n  100) :param seniorities: List of integers, unique seniority levels of the employees :return: Integer, maximum number of teams that can be formed Examples: >>> max_teams(5, [5, 2, 3, 4, 1]) 4 >>> max_teams(6, [10, 20, 30, 25, 15, 5]) 5 >>> max_teams(3, [1, 2, 3]) 2 >>> max_teams(4, [4, 3, 2, 1]) 3 >>> max_teams(2, [10, 1]) 1 >>> max_teams(7, [15, 10, 5, 20, 25, 30, 35]) 6","solution":"def max_teams(n, seniorities): Given the number of employees n and a list of their unique seniority levels, determine the maximum number of teams that can be formed. :param n: Integer, number of employees (2  n  100) :param seniorities: List of integers, unique seniority levels of the employees :return: Integer, maximum number of teams that can be formed # Sort seniorities in descending order to assign leaders seniorities.sort(reverse=True) # Each leader will have at least one subordinate with lower seniority teams = n - 1 return teams"},{"question":"from typing import List def can_create_playlist(playlist: str, tapes: List[List[str]]) -> str: Determine if the playlist can be created by selecting one track from each tape. Parameters: playlist (str): The playlist Sam wants to create. tapes (list of list of str): List of tapes with each tape containing 5 different tracks. Returns: str: \\"YES\\" if the playlist can be created, otherwise \\"NO\\" >>> can_create_playlist(\\"play\\", [[\\"p\\", \\"q\\", \\"r\\", \\"s\\", \\"t\\"], ... [\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\"], ... [\\"y\\", \\"z\\", \\"x\\", \\"w\\", \\"v\\"], ... [\\"k\\", \\"l\\", \\"m\\", \\"n\\", \\"o\\"], ... [\\"u\\", \\"v\\", \\"w\\", \\"x\\", \\"y\\"]]) 'YES' >>> can_create_playlist(\\"beat\\", [[\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\"], ... [\\"f\\", \\"g\\", \\"h\\", \\"i\\", \\"j\\"], ... [\\"k\\", \\"l\\", \\"m\\", \\"n\\", \\"o\\"], ... [\\"p\\", \\"q\\", \\"r\\", \\"s\\", \\"t\\"]]) 'NO'","solution":"def can_create_playlist(playlist, tapes): Determine if the playlist can be created by selecting one track from each tape. Parameters: playlist (str): The playlist Sam wants to create. tapes (list of list of str): List of tapes with each tape containing 5 different tracks. Returns: str: \\"YES\\" if the playlist can be created, otherwise \\"NO\\" from collections import defaultdict # Dictionary to store tapes corresponding to each letter letter_to_tape = defaultdict(list) for i, tape in enumerate(tapes): for letter in tape: letter_to_tape[letter].append(i) # Keeping track of used tapes by index used_tapes = set() # Function to check if we can form the playlist using DFS def can_form_playlist(index): if index == len(playlist): return True track = playlist[index] for tape_index in letter_to_tape[track]: if tape_index not in used_tapes: used_tapes.add(tape_index) if can_form_playlist(index + 1): return True used_tapes.remove(tape_index) return False return \\"YES\\" if can_form_playlist(0) else \\"NO\\""},{"question":"def total_blocks(H: int, W: int, grid: List[List[int]]) -> int: Calculate the total number of blocks in the grid. Parameters: H (int): number of rows in the grid W (int): number of columns in the grid grid (list of list of int): grid containing the height of blocks in each cell Returns: int: total number of blocks in the entire grid # Unit tests def test_example_case(): H = 3 W = 3 grid = [ [2, 1, 3], [4, 2, 2], [1, 5, 1], ] assert total_blocks(H, W, grid) == 21 def test_single_cell(): H = 1 W = 1 grid = [ [5], ] assert total_blocks(H, W, grid) == 5 def test_all_ones(): H = 2 W = 2 grid = [ [1, 1], [1, 1], ] assert total_blocks(H, W, grid) == 4 def test_large_numbers(): H = 2 W = 2 grid = [ [100, 100], [100, 100], ] assert total_blocks(H, W, grid) == 400 def test_non_square_grid(): H = 2 W = 3 grid = [ [1, 1, 1], [2, 2, 2], ] assert total_blocks(H, W, grid) == 9","solution":"def total_blocks(H, W, grid): Calculate the total number of blocks in the grid. Parameters: H (int): number of rows in the grid W (int): number of columns in the grid grid (list of list of int): grid containing the height of blocks in each cell Returns: int: total number of blocks in the entire grid total = 0 for row in grid: total += sum(row) return total"},{"question":"import re from typing import Tuple def compress(text: str) -> str: Compresses a text using basic run-length encoding. Parameters: text (str): The input string to be compressed. Returns: str: The compressed string. pass def expand(text: str) -> str: Expands a run-length encoded text. Parameters: text (str): The compressed string to be expanded. Returns: str: The original expanded string. pass def process_text(text: str) -> str: Determines whether to compress or expand the input text and performs the respective operation. Parameters: text (str): The input string. Returns: str: The processed string. pass # Unit Tests def test_compress(): assert compress(\\"aaabccccd\\") == \\"a3b1c4d1\\" assert compress(\\"hhhhhhhhhhhh\\") == \\"h12\\" assert compress(\\"abc\\") == \\"a1b1c1\\" assert compress(\\"a\\") == \\"a1\\" def test_expand(): assert expand(\\"a3b1c4d1\\") == \\"aaabccccd\\" assert expand(\\"h12\\") == \\"hhhhhhhhhhhh\\" assert expand(\\"a1b1c1\\") == \\"abc\\" assert expand(\\"a1\\") == \\"a\\" def test_process_text(): assert process_text(\\"aaabccccd\\") == \\"a3b1c4d1\\" assert process_text(\\"a3b1c4d1\\") == \\"aaabccccd\\" assert process_text(\\"hhhhhhhhhhhh\\") == \\"h12\\" assert process_text(\\"h12\\") == \\"hhhhhhhhhhhh\\" assert process_text(\\"abc\\") == \\"a1b1c1\\" assert process_text(\\"a1b1c1\\") == \\"abc\\"","solution":"import re def compress(text): Compresses a text using basic run-length encoding. Parameters: text (str): The input string to be compressed. Returns: str: The compressed string. compressed = [] count = 1 for i in range(1, len(text)): if text[i] == text[i-1]: count += 1 else: compressed.append(text[i-1] + str(count)) count = 1 compressed.append(text[-1] + str(count)) return ''.join(compressed) def expand(text): Expands a run-length encoded text. Parameters: text (str): The compressed string to be expanded. Returns: str: The original expanded string. expanded = [] for char, num in re.findall(r'([a-z])(d+)', text): expanded.append(char * int(num)) return ''.join(expanded) def process_text(text): Determines whether to compress or expand the input text and performs the respective operation. Parameters: text (str): The input string. Returns: str: The processed string. if re.match(r'^[a-z]d+', text): return expand(text) else: return compress(text)"},{"question":"def construct_even_sum_grid(N: int, M: int): Construct a N x M grid with numbers between -100 and 100 such that the sum of numbers in each row is an even number and the sum of numbers in each column is an even number. If no such grid can be constructed, return 'No solution'. >>> construct_even_sum_grid(2, 2) [[1, 1], [1, 1]] >>> construct_even_sum_grid(3, 3) [[1, 2, 3], [4, 5, 6], [7, 8, 9]]","solution":"def construct_even_sum_grid(N, M): # create the grid filled initially with zeroes grid = [[0 for _ in range(M)] for _ in range(N)] # fill the grid with numbers so that each row and each column sum is even counter = 1 for i in range(N): for j in range(M): grid[i][j] = counter counter += 1 # Adjust values to make sums even for i in range(N): if sum(grid[i]) % 2 != 0: # if row sum is odd, adjust the last element grid[i][-1] += 1 for j in range(M): column_sum = sum(grid[i][j] for i in range(N)) if column_sum % 2 != 0: # if column sum is odd, adjust the last element in the column grid[-1][j] += 1 return grid"},{"question":"def is_subsequence(main_str: str, pattern: str) -> str: Determine if pattern is a subsequence of main_str. :param main_str: The main string to search within. :param pattern: The pattern string to search for as a subsequence. :return: \\"YES\\" if pattern is a subsequence of main_str, otherwise \\"NO\\". >>> is_subsequence(\\"abcde\\", \\"ace\\") \\"YES\\" >>> is_subsequence(\\"abcde\\", \\"aec\\") \\"NO\\" >>> is_subsequence(\\"hello\\", \\"hello\\") \\"YES\\" >>> is_subsequence(\\"hello\\", \\"hill\\") \\"NO\\" >>> is_subsequence(\\"abc\\", \\"\\") \\"YES\\" >>> is_subsequence(\\"\\", \\"a\\") \\"NO\\" >>> is_subsequence(\\"a\\", \\"a\\") \\"YES\\" >>> is_subsequence(\\"a\\", \\"b\\") \\"NO\\" >>> is_subsequence(\\"abc\\", \\"abc\\") \\"YES\\" >>> is_subsequence(\\"abc\\", \\"cba\\") \\"NO\\" >>> is_subsequence(\\"abpcplea\\", \\"apple\\") \\"YES\\" >>> is_subsequence(\\"abpcplea\\", \\"applf\\") \\"NO\\"","solution":"def is_subsequence(main_str, pattern): Determine if pattern is a subsequence of main_str. :param main_str: The main string to search within. :param pattern: The pattern string to search for as a subsequence. :return: \\"YES\\" if pattern is a subsequence of main_str, otherwise \\"NO\\". m, n = len(pattern), len(main_str) i, j = 0, 0 while i < m and j < n: if pattern[i] == main_str[j]: i += 1 j += 1 return \\"YES\\" if i == m else \\"NO\\""},{"question":"import heapq from typing import List, Tuple def shortest_path(n: int, m: int, s: int, t: int, roads: List[Tuple[int, int, int]]) -> int: Calculate the shortest distance from the starting intersection to the destination intersection. Args: n (int): The number of intersections. m (int): The number of roads. s (int): The starting intersection. t (int): The destination intersection. roads (List[Tuple[int, int, int]]): A list of roads where each road is represented as a tuple (u, v, w), where u is the start intersection, v is the end intersection, and w is the distance. Returns: int: The shortest distance from the starting intersection to the destination intersection. If the destination is not reachable from the starting intersection, return -1. Examples: >>> shortest_path(4, 4, 1, 3, [(1, 2, 1), (2, 3, 3), (1, 3, 10), (3, 4, 2)]) 4 >>> shortest_path(3, 2, 1, 3, [(1, 2, 5), (2, 3, 7)]) 12 >>> shortest_path(6, 4, 5, 2, [(1, 3, 2), (1, 4, 4), (3, 4, 1), (4, 2, 1)]) -1 def test_shortest_path_example1(): n, m, s, t = 4, 4, 1, 3 roads = [(1, 2, 1), (2, 3, 3), (1, 3, 10), (3, 4, 2)] assert shortest_path(n, m, s, t, roads) == 4 def test_shortest_path_example2(): n, m, s, t = 3, 2, 1, 3 roads = [(1, 2, 5), (2, 3, 7)] assert shortest_path(n, m, s, t, roads) == 12 def test_shortest_path_example3(): n, m, s, t = 6, 4, 5, 2 roads = [(1, 3, 2), (1, 4, 4), (3, 4, 1), (4, 2, 1)] assert shortest_path(n, m, s, t, roads) == -1 def test_shortest_path_single_node(): n, m, s, t = 1, 0, 1, 1 roads = [] assert shortest_path(n, m, s, t, roads) == 0 def test_shortest_path_no_possible_path(): n, m, s, t = 2, 1, 1, 2 roads = [(1, 2, 7)] assert shortest_path(n, m, s, t, roads) == 7 n, m, s, t = 2, 1, 2, 1 roads = [(1, 2, 7)] assert shortest_path(n, m, s, t, roads) == -1 def test_shortest_path_disconnect(): n, m, s, t = 5, 3, 1, 5 roads = [(1, 2, 2), (2, 3, 4), (3, 4, 6)] assert shortest_path(n, m, s, t, roads) == -1","solution":"import heapq def shortest_path(n, m, s, t, roads): # Create an adjacency list adj_list = {i: [] for i in range(1, n + 1)} for u, v, w in roads: adj_list[u].append((v, w)) # Dijkstra's algorithm def dijkstra(start, end): # Distance to each node initialized to infinity dist = {i: float('inf') for i in range(1, n + 1)} dist[start] = 0 priority_queue = [(0, start)] # (distance, node) heapq.heapify(priority_queue) while priority_queue: current_dist, current_node = heapq.heappop(priority_queue) if current_node == end: return current_dist if current_dist > dist[current_node]: continue for neighbor, weight in adj_list[current_node]: distance = current_dist + weight if distance < dist[neighbor]: dist[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return -1 if dist[end] == float('inf') else dist[end] return dijkstra(s, t)"},{"question":"def longest_contiguous_ones_in_range(l: int, r: int) -> int: Given integers l and r, return the length of the longest contiguous sequence of 1's in the binary representations of any integer within the inclusive range from l to r. def process_test_cases(t: int, cases: List[Tuple[int, int]]) -> List[int]: Given the number of test cases t and a list of tuples containing pairs (l, r), return a list of results where each result is the length of the longest contiguous sequence of 1's in the binary representations of any integer within the inclusive range from l to r. >>> process_test_cases(3, [(10, 15), (5, 8), (1, 1)]) [4, 3, 1] >>> process_test_cases(2, [(3, 10), (5, 8)]) [3, 3] # Example unit tests from typing import List, Tuple def test_longest_contiguous_ones_in_range(): assert longest_contiguous_ones_in_range(10, 15) == 4 assert longest_contiguous_ones_in_range(5, 8) == 3 assert longest_contiguous_ones_in_range(1, 1) == 1 assert longest_contiguous_ones_in_range(1, 2) == 1 assert longest_contiguous_ones_in_range(7, 7) == 3 def test_process_test_cases(): assert process_test_cases(3, [(10, 15), (5, 8), (1, 1)]) == [4, 3, 1] assert process_test_cases(2, [(3, 10), (5, 8)]) == [3, 3] assert process_test_cases(1, [(2, 4)]) == [2] assert process_test_cases(4, [(1, 5), (5, 10), (10, 15), (10, 100)]) == [2, 3, 4, 6]","solution":"def longest_contiguous_ones_in_range(l, r): Given integers l and r, return the length of the longest contiguous sequence of 1's in the binary representations of any integer within the inclusive range from l to r. max_length = 0 for num in range(l, r + 1): binary = bin(num)[2:] # Get binary representation max_length = max(max_length, max(len(s) for s in binary.split('0'))) return max_length def process_test_cases(t, cases): results = [] for l, r in cases: results.append(longest_contiguous_ones_in_range(l, r)) return results"},{"question":"def is_sum_of_two_fibonacci_numbers(n: int) -> str: Checks if the given number can be represented as the sum of two distinct Fibonacci numbers. :param n: The number to check. :return: \\"YES\\" if the number can be represented as the sum of two distinct Fibonacci numbers, \\"NO\\" otherwise. >>> is_sum_of_two_fibonacci_numbers(21) \\"YES\\" >>> is_sum_of_two_fibonacci_numbers(17) \\"NO\\" >>> is_sum_of_two_fibonacci_numbers(34) \\"YES\\" >>> is_sum_of_two_fibonacci_numbers(1) \\"NO\\" >>> is_sum_of_two_fibonacci_numbers(1000000000) \\"NO\\" >>> is_sum_of_two_fibonacci_numbers(19) \\"NO\\" >>> is_sum_of_two_fibonacci_numbers(10) \\"YES\\"","solution":"def is_sum_of_two_fibonacci_numbers(n): Checks if the given number can be represented as the sum of two distinct Fibonacci numbers. :param n: The number to check. :return: \\"YES\\" if the number can be represented as the sum of two distinct Fibonacci numbers, \\"NO\\" otherwise. if n <= 2: return \\"NO\\" # Generate Fibonacci numbers up to n fib = [0, 1] while fib[-1] + fib[-2] <= n: fib.append(fib[-1] + fib[-2]) # Check if the number can be written as the sum of two distinct Fibonacci numbers fib_set = set(fib) for i in range(len(fib)): if (n - fib[i]) in fib_set and (n - fib[i] != fib[i]): return \\"YES\\" return \\"NO\\""},{"question":"from typing import List def longest_rle_subsequence_length(arr: List[int]) -> int: Returns the length of the longest subsequence that can be run-length encoded. Args: arr (List[int]): A list of integers representing the array elements. Returns: int: The length of the longest subsequence that can be run-length encoded. Examples: >>> longest_rle_subsequence_length([1, 1, 2, 2, 1]) 2 >>> longest_rle_subsequence_length([1, 3, 3, 3, 2, 2, 4]) 3 >>> longest_rle_subsequence_length([1, 2, 3, 4, 5]) 1 >>> longest_rle_subsequence_length([2, 2, 2, 2, 2]) 5 >>> longest_rle_subsequence_length([]) 0","solution":"def longest_rle_subsequence_length(arr): Returns the length of the longest subsequence that can be run-length encoded. n = len(arr) if n == 0: return 0 max_length = 1 current_length = 1 for i in range(1, n): if arr[i] == arr[i - 1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 # Final check in case longest sequence ends at the last position max_length = max(max_length, current_length) return max_length"},{"question":"def can_register(new_username: str, existing_usernames: List[str]) -> str: Determines if the new username can be registered, based on similarity rules. >>> can_register(\\"coder!name\\", [\\"Coder1name\\", \\"codER&name\\", \\"CoderName!\\"]) 'No' >>> can_register(\\"secure7code\\", [\\"secure&code\\", \\"SECUre7CoDE\\"]) 'No' >>> can_register(\\"exampleUser2\\", [\\"exampleUser3\\", \\"examplEUsEr\\", \\"eXamplEuSer!\\", \\"hisampleUSER2\\"]) 'Yes' >>> can_register(\\"uniqueId1\\", [\\"uniQue@id1\\", \\"uniQUEid1\\", \\"uniqu&e-id1\\"]) 'No'","solution":"def transform_char(c): Transform a character based on the explained rules. if c == '1': return ['1', '!'] elif c == '!': return ['!', '1'] elif c == '7': return ['7', '&'] elif c == '&': return ['&', '7'] elif c.isalpha(): return [c.lower(), c.upper()] elif c in 'abcdefghijklmnopqrstuvwxyz': return [chr(((ord(c) - ord('a') + 2) % 26) + ord('a'))] elif c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ': return [chr(((ord(c) - ord('A') + 2) % 26) + ord('A'))] else: return [c] def transform_username(username): Generate all possible transformations of a username. transformed = [[]] for char in username: new_transformed = [] for variant in transform_char(char): for seq in transformed: new_transformed.append(seq + [variant]) transformed = new_transformed return {''.join(seq) for seq in transformed} def can_register(new_username, existing_usernames): Check if the new_username can be registered (i.e., not similar to any existing usernames). new_transformations = transform_username(new_username) for existing_username in existing_usernames: existing_transformations = transform_username(existing_username) if new_transformations & existing_transformations: return \\"No\\" return \\"Yes\\""},{"question":"def coin_change(coins: List[int], amount: int) -> int: Calculate the minimum number of coins needed to make up the given amount. If it is not possible to make the amount with the given coins, return -1. >>> coin_change([1, 2, 5], 11) 3 >>> coin_change([2], 3) -1 >>> coin_change([1, 2, 5], 0) 0 >>> coin_change([1], 100) 100 >>> coin_change([1, 2, 5], 7) 2 >>> coin_change([2, 4], 7) -1 >>> coin_change([1, 2, 5], 100) 20 >>> coin_change([10], 10) 1 >>> coin_change([1, 3, 4, 5], 23) 5","solution":"def coin_change(coins, amount): Calculate the minimum number of coins needed to make the given amount. If it is not possible to make the amount with the given coins, return -1. :param coins: List[int] - the list of coin denominations :param amount: int - the target amount :return: int - the minimum number of coins or -1 if not possible # Edge case: if amount is 0, no coins are required if amount == 0: return 0 # Initialize the array for dynamic programming # dp[i] will hold the minimum number of coins required for amount i dp = [float('inf')] * (amount + 1) # Base case: zero amount requires zero coins dp[0] = 0 # Build the dp array for coin in coins: for x in range(coin, amount + 1): if dp[x - coin] != float('inf'): dp[x] = min(dp[x], dp[x - coin] + 1) # If the value at dp[amount] is still float('inf'), it means amount # cannot be made up by given coins return dp[amount] if dp[amount] != float('inf') else -1"},{"question":"def rearrange(nums: List[int]) -> List[int]: Rearrange the array where every second element is greater than its previous and next element. >>> rearrange([4, 1, 7, 2, 6]) [1, 7, 2, 6, 4] or [2, 7, 1, 6, 3] >>> rearrange([1, 5, 3, 7]) [1, 7, 3, 5] or [3, 7, 1, 5] >>> rearrange([1, 2, 1]) [1, 2, 1] >>> rearrange([3, 3, 5, 2, 3, 6]) [2, 6, 3, 5, 3, 3] or [3, 6, 2, 5, 3, 3] >>> rearrange([5, 5, 5, 5, 5]) [5, 5, 5, 5, 5] >>> rearrange([-1, -2, -3, -4, -5]) [-5, -1, -4, -2, -3] or [-4, -1, -3, -2, -5]","solution":"def rearrange(nums): nums.sort() result = [] for i in range(len(nums)): if i % 2 == 0: result.append(nums[i // 2]) else: result.append(nums[len(nums) - (i // 2) - 1]) return result"},{"question":"def min_steps(s: str, t: str) -> int: Calculate the minimum number of steps required to convert string s into string t using the following operations: 1. Insert a character 2. Delete a character 3. Replace a character Args: s (str): The initial string. t (str): The target string to be achieved from s. Returns: int: The minimum number of steps to transform s into t. Examples: >>> min_steps(\\"horse\\", \\"ros\\") 3 >>> min_steps(\\"intention\\", \\"execution\\") 5 >>> min_steps(\\"abc\\", \\"abc\\") 0 >>> min_steps(\\"abc\\", \\"abcd\\") 1 >>> min_steps(\\"abcd\\", \\"abc\\") 1 >>> min_steps(\\"abc\\", \\"axc\\") 1 >>> min_steps(\\"abcdef\\", \\"azced\\") 3 >>> min_steps(\\"\\", \\"abc\\") 3 >>> min_steps(\\"abc\\", \\"\\") 3 >>> min_steps(\\"\\", \\"\\") 0","solution":"def min_steps(s, t): Returns the minimum number of steps required to transform string s into string t. m, n = len(s), len(t) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # If s is empty, insert all characters of t elif j == 0: dp[i][j] = i # If t is empty, remove all characters of s elif s[i - 1] == t[j - 1]: dp[i][j] = dp[i - 1][j - 1] # Characters are the same, no operation needed else: dp[i][j] = 1 + min(dp[i - 1][j], # Remove dp[i][j - 1], # Insert dp[i - 1][j - 1])# Replace return dp[m][n]"},{"question":"def messaging_system(n: int, k: int) -> str: Determine if it's possible for a message to travel from employee 1 to employee n within k steps. Args: n (int): Number of employees. k (int): Maximum number of steps. Returns: str: \\"YES\\" and the communication network or \\"NO\\". Example: >>> messaging_system(4, 3) \\"YESn3n1 2n2 3n3 4\\" >>> messaging_system(3, 5) \\"NO\\"","solution":"def messaging_system(n, k): Determine if a message starting from employee 1 can reach employee n within k steps. Args: n (int): Number of employees. k (int): Maximum number of steps. Returns: str: \\"YES\\" and the communication network or \\"NO\\". # If the number of employees is n and k is sufficiently large, we can always find a configuration # since we can structure a network with n-1 steps in the worst case scenario. if k >= n - 1: communication_lines = [] for i in range(1, n): communication_lines.append((i, i + 1)) m = len(communication_lines) result = \\"YESn\\" result += f\\"{m}n\\" for line in communication_lines: result += f\\"{line[0]} {line[1]}n\\" return result.strip() else: return \\"NO\\""},{"question":"def reverse_segments(int_list: List[int], K: int) -> List[int]: Reverses every segment of length K in the given integer list. Args: int_list (list of int): The list to be transformed. K (int): The length of segments to reverse. Returns: list of int: The transformed list with each segment of length K reversed. >>> reverse_segments([1, 2, 3, 4, 5, 6, 7, 8, 9], 3) [3, 2, 1, 6, 5, 4, 9, 8, 7] >>> reverse_segments([1, 2, 3], 3) [3, 2, 1] >>> reverse_segments([1, 2, 3, 4], 1) [1, 2, 3, 4] >>> reverse_segments([1, 2, 3, 4, 5], 2) [2, 1, 4, 3, 5] >>> reverse_segments([1, 2, 3, 4, 5, 6], 6) [6, 5, 4, 3, 2, 1] >>> reverse_segments([7, 7, 7, 7], 2) [7, 7, 7, 7]","solution":"def reverse_segments(int_list, K): Reverses every segment of length K in the given integer list. Args: int_list (list of int): The list to be transformed. K (int): The length of segments to reverse. Returns: list of int: The transformed list with each segment of length K reversed. for i in range(0, len(int_list), K): int_list[i:i+K] = reversed(int_list[i:i+K]) return int_list"},{"question":"def is_possible_to_merge(n, A, B): Determines if it's possible to merge sequences A and B into a strictly increasing sequence. Args: n (int): The length of sequences A and B. A (List[int]): The first sequence of integers. B (List[int]): The second sequence of integers. Returns: str: \\"YES\\" if it's possible to merge the sequences, otherwise \\"NO\\". Examples: >>> is_possible_to_merge(4, [1, 3, 5, 7], [2, 4, 6, 8]) \\"YES\\" >>> is_possible_to_merge(3, [1, 3, 5], [2, 5, 6]) \\"NO\\"","solution":"def is_possible_to_merge(n, A, B): Determines if it's possible to merge sequences A and B into a strictly increasing sequence. A.sort() B.sort() for i in range(n): if i > 0 and (A[i] <= B[i-1] or B[i] <= A[i-1]): return \\"NO\\" return \\"YES\\" # Example usage: # n = 4 # A = [1, 3, 5, 7] # B = [2, 4, 6, 8] # print(is_possible_to_merge(n, A, B)) # Should print \\"YES\\""},{"question":"def process_queries(n, weights, edges, queries): You are given a tree with n nodes, rooted at node 1. Each node i has a weight wi associated with it. You need to perform q queries on this tree. Each query can be of two types: 1. \`1 x y\`: Change the weight of node x to y. 2. \`2 x\`: Compute and return the sum of the weights of all nodes in the subtree rooted at node x. >>> n = 5 >>> weights = [ 1, 2, 3, 4, 5 ] >>> edges = [(1, 2), (1, 3), (2, 4), (2, 5)] >>> queries = [\\"2 1\\", \\"1 3 10\\", \\"2 3\\"] >>> process_queries(n, weights, edges, queries) [15, 10] >>> n = 1 >>> weights = [ 5 ] >>> edges = [] >>> queries = [\\"2 1\\"] >>> process_queries(n, weights, edges, queries) [5]","solution":"class Tree: def __init__(self, n, weights): self.n = n self.weights = weights self.adjacency_list = [[] for _ in range(n + 1)] self.subtree_sum = [0] * (n + 1) self.parent = [-1] * (n + 1) def add_edge(self, u, v): self.adjacency_list[u].append(v) self.adjacency_list[v].append(u) def dfs(self, node, parent): self.subtree_sum[node] = self.weights[node - 1] self.parent[node] = parent for neighbor in self.adjacency_list[node]: if neighbor == parent: continue self.dfs(neighbor, node) self.subtree_sum[node] += self.subtree_sum[neighbor] def update_weight(self, x, y): diff = y - self.weights[x - 1] self.weights[x - 1] = y self._update_subtree_sum(x, diff) def _update_subtree_sum(self, node, diff): if node == -1: return self.subtree_sum[node] += diff self._update_subtree_sum(self.parent[node], diff) def get_subtree_sum(self, x): return self.subtree_sum[x] def process_queries(n, weights, edges, queries): tree = Tree(n, weights) for u, v in edges: tree.add_edge(u, v) tree.dfs(1, -1) result = [] for query in queries: parts = query.split() if parts[0] == '1': x, y = int(parts[1]), int(parts[2]) tree.update_weight(x, y) elif parts[0] == '2': x = int(parts[1]) result.append(tree.get_subtree_sum(x)) return result"},{"question":"def can_rearrange_no_adjacent_same(n: int, arr: List[int]) -> str: Determine if an array can be rearranged such that no two adjacent elements are the same. Parameters: - n (int): The number of integers in the array. - arr (list of int): The elements of the array. Returns: - str: \\"YES\\" if it is possible to rearrange the elements as required, otherwise \\"NO\\". Examples: >>> can_rearrange_no_adjacent_same(5, [1, 2, 2, 3, 3]) \\"YES\\" >>> can_rearrange_no_adjacent_same(4, [1, 1, 1, 1]) \\"NO\\" from solution import can_rearrange_no_adjacent_same def test_one_element(): assert can_rearrange_no_adjacent_same(1, [1]) == \\"YES\\" def test_no_adjacent_same_possible(): assert can_rearrange_no_adjacent_same(5, [1, 2, 2, 3, 3]) == \\"YES\\" def test_all_elements_same(): assert can_rearrange_no_adjacent_same(4, [1, 1, 1, 1]) == \\"NO\\" assert can_rearrange_no_adjacent_same(3, [1, 1, 1]) == \\"NO\\" def test_large_variety_elements(): assert can_rearrange_no_adjacent_same(7, [1, 2, 3, 3, 4, 4, 5]) == \\"YES\\" def test_edge_case_max_frequency(): assert can_rearrange_no_adjacent_same(6, [1, 1, 1, 2, 2, 3]) == \\"YES\\" assert can_rearrange_no_adjacent_same(6, [1, 1, 1, 1, 2, 2]) == \\"NO\\" def test_alternating_elements(): assert can_rearrange_no_adjacent_same(4, [1, 2, 1, 2]) == \\"YES\\" def test_edge_case_min_elements(): assert can_rearrange_no_adjacent_same(2, [1, 1]) == \\"NO\\" assert can_rearrange_no_adjacent_same(2, [1, 2]) == \\"YES\\" def test_complex_case(): assert can_rearrange_no_adjacent_same(10, [1, 1, 1, 2, 2, 3, 3, 4, 4, 5]) == \\"YES\\"","solution":"def can_rearrange_no_adjacent_same(n, arr): Determine if an array can be rearranged such that no two adjacent elements are the same. Parameters: - n (int): The number of integers in the array. - arr (list of int): The elements of the array. Returns: - str: \\"YES\\" if it is possible to rearrange the elements as required, otherwise \\"NO\\". from collections import Counter if n == 1: return \\"YES\\" # A single element array trivially satisfies the condition. count = Counter(arr) max_occur = max(count.values()) # The condition to return \\"NO\\" is when the most frequent element occurs more than (n + 1) // 2 times. if max_occur > (n + 1) // 2: return \\"NO\\" else: return \\"YES\\""},{"question":"def can_schedule_advertisements(P: int, A: int, b: List[int], c: List[int]) -> str: Determines if it is possible to schedule advertisements according to the given constraints. Parameters: - P (int): Number of billboards. - A (int): Number of advertisements. - b (list): List containing the max number of unique advertisements each billboard can display. - c (list): List containing the minimum number of billboards each advertisement must be displayed on. Returns: - str: \\"YES\\" if scheduling is possible, \\"NO\\" otherwise. >>> can_schedule_advertisements(3, 2, [2, 3, 1], [1, 2]) \\"YES\\" >>> can_schedule_advertisements(2, 3, [2, 2], [1, 2, 2]) \\"NO\\" >>> can_schedule_advertisements(4, 3, [3, 3, 2, 1], [2, 2, 1]) \\"YES\\" >>> can_schedule_advertisements(1, 1, [1], [1]) \\"YES\\" >>> can_schedule_advertisements(100, 100, [100] * 100, [1] * 100) \\"YES\\" >>> can_schedule_advertisements(3, 3, [1, 1, 1], [2, 2, 2]) \\"NO\\" >>> can_schedule_advertisements(3, 3, [2, 2, 2], [2, 2, 2]) \\"YES\\" >>> can_schedule_advertisements(3, 2, [3, 3, 3], [1, 1]) \\"YES\\"","solution":"def can_schedule_advertisements(P, A, b, c): Determines if it is possible to schedule advertisements according to the given constraints. Parameters: P (int): Number of billboards. A (int): Number of advertisements. b (list): List containing the max number of unique advertisements each billboard can display. c (list): List containing the minimum number of billboards each advertisement must be displayed on. Returns: str: \\"YES\\" if scheduling is possible, \\"NO\\" otherwise. # Total available slots on all billboards total_slots = sum(b) # Total required slots for all advertisements total_requirements = sum(c) if total_requirements <= total_slots: return \\"YES\\" else: return \\"NO\\""},{"question":"def find_distinct_palindromic_substrings(t: int, test_cases: list) -> list: Given a list of test cases, find the number of distinct palindromic substrings in each 2D grid. A palindromic substring is a string that reads the same forward and backward. Args: t (int): Number of test cases. test_cases (list): List of test cases. Each test case consists of dimensions n and m, and a grid of n rows each containing m lowercase alphabets. Returns: list: List of integers, where each integer is the number of distinct palindromic substrings for the corresponding test case. Example: >>> find_distinct_palindromic_substrings(2, [(2, 3, ['aba', 'cac']), (3, 2, ['xy', 'yx', 'zx'])]) [6, 5] >>> find_distinct_palindromic_substrings(1, [(1, 1, ['a'])]) [1]","solution":"def find_distinct_palindromic_substrings(t: int, test_cases: list) -> list: def is_palindrome(s): return s == s[::-1] def substrings_from_line(line): substrings = set() for start in range(len(line)): for end in range(start + 1, len(line) + 1): substr = line[start:end] if is_palindrome(substr): substrings.add(substr) return substrings results = [] for case in test_cases: n, m, grid = case all_substrings = set() # Check horizontally for row in grid: all_substrings.update(substrings_from_line(row)) # Check vertically for col in range(m): column_str = ''.join(grid[row][col] for row in range(n)) all_substrings.update(substrings_from_line(column_str)) # Check diagonally ( direction) for start in range(n + m - 1): diag_str = '' for i in range(max(start - m + 1, 0), min(start + 1, n)): diag_str += grid[i][start - i] all_substrings.update(substrings_from_line(diag_str)) # Check anti-diagonally (/ direction) for start in range(n + m - 1): anti_diag_str = '' for i in range(max(start - m + 1, 0), min(start + 1, n)): anti_diag_str += grid[n - i - 1][start - i] all_substrings.update(substrings_from_line(anti_diag_str)) results.append(len(all_substrings)) return results # Parse input and call the function def main(): import sys input = sys.stdin.read data = input().split() index = 0 t = int(data[index]) index += 1 test_cases = [] for _ in range(t): n = int(data[index]) m = int(data[index + 1]) index += 2 grid = [] for _ in range(n): grid.append(data[index]) index += 1 test_cases.append((n, m, grid)) results = find_distinct_palindromic_substrings(t, test_cases) for result in results: print(result) if __name__ == \\"__main__\\": main()"},{"question":"def count_distinct_characters(s: str) -> int: Determine the number of distinct characters in the string 's'. Constraints: * 1 <= |S| <= 100 >>> count_distinct_characters(\\"hello\\") 4 >>> count_distinct_characters(\\"abcd\\") 4 >>> count_distinct_characters(\\"aabbccdd\\") 4","solution":"def count_distinct_characters(s): Returns the number of distinct characters in the string 's'. return len(set(s))"},{"question":"def find_common_words(num_texts: int, texts: List[str]) -> str: Find and return the words that appear an equal number of times in every pair of adjacent texts. The words in the output should be sorted lexicographically. If no such word exists, output an empty string. Arguments: num_texts -- An integer N, the number of ancient texts. texts -- A list of N strings, each containing words separated by spaces. Returns: A single string with words separated by spaces that appear exactly the same number of times in every pair of adjacent texts. >>> find_common_words(4, [\\"this is a test text\\", \\"analyzing ancient text is important\\", \\"text analysis is crucial for discovery\\", \\"is text crucial for the analysis\\"]) \\"is text\\" >>> find_common_words(3, [\\"the quick brown fox\\", \\"jumps over the lazy dog\\", \\"only certain words appear\\"]) \\"\\" >>> find_common_words(3, [\\"alpha beta gamma\\", \\"gamma beta alpha\\", \\"beta gamma alpha\\"]) \\"alpha beta gamma\\" >>> find_common_words(3, [\\"one fish two fish\\", \\"blue fish one fish\\", \\"one fish red fish\\"]) \\"fish one\\" >>> find_common_words(3, [\\"word1 word2 word3\\", \\"word4 word2 word1\\", \\"word1 word5 word2\\"]) \\"word1 word2\\"","solution":"from collections import Counter from string import whitespace def find_common_words(num_texts, texts): Find words that appear an equal number of times in every pair of adjacent texts and return them sorted lexicographically. def words_count(text): return Counter(text.split()) # Step 1: Get word counts for each text word_counts = [words_count(text) for text in texts] # Step 2: Check for words that have the same count in every adjacent text common_words = set(word_counts[0].keys()) for i in range(num_texts): next_index = (i + 1) % num_texts cur_counts, next_counts = word_counts[i], word_counts[next_index] common_in_pair = {} for word in cur_counts: if word in next_counts and cur_counts[word] == next_counts[word]: common_in_pair[word] = cur_counts[word] common_words = common_words.intersection(common_in_pair.keys()) # Step 3: Sort and return the result return \\" \\".join(sorted(common_words)) # user input simulation def get_input(): num_texts = int(input().strip()) texts = [input().strip() for _ in range(num_texts)] return num_texts, texts if __name__ == \\"__main__\\": num_texts, texts = get_input() print(find_common_words(num_texts, texts))"},{"question":"def find_subarray_with_sum(N: int, S: int, A: List[int]) -> Tuple[int, int]: Finds the subarray whose sum is equal to the given integer S. Args: N : int : size of the array S : int : target sum A : list : list of integers representing the array Returns: tuple : a tuple (start_index, end_index) of the subarray (1-based index) Examples: >>> find_subarray_with_sum(5, 9, [1, 2, 3, 4, 5]) (2, 4) >>> find_subarray_with_sum(4, 6, [3, 2, 1, 5]) (1, 3)","solution":"def find_subarray_with_sum(N, S, A): Finds the subarray whose sum is equal to the given integer S. Args: N : int : size of the array S : int : target sum A : list : list of integers representing the array Returns: tuple : a tuple (start_index, end_index) of the subarray (1-based index) current_sum = 0 start = 0 sum_map = {} for end in range(N): current_sum += A[end] if current_sum == S: return (start + 1, end + 1) if (current_sum - S) in sum_map: return (sum_map[current_sum - S] + 2, end + 1) sum_map[current_sum] = end return (-1, -1)"},{"question":"from typing import List def numDistinctIslands(m: int, n: int, grid: List[List[int]]) -> int: Returns the number of distinct islands in the given m x n grid. An island is made of connected land cells (1) and is distinct if it cannot be translated to match another. >>> numDistinctIslands(4, 5, [[1,1,0,0,0],[1,1,0,0,0],[0,0,0,1,1],[0,0,0,1,1]]) 1 >>> numDistinctIslands(4, 5, [[1,1,0,0,0],[1,0,0,0,0],[0,0,0,1,1],[0,0,0,1,1]]) 2 >>> numDistinctIslands(3, 3, [[0,0,0],[0,0,0],[0,0,0]]) 0 >>> numDistinctIslands(3, 3, [[1,0,1],[0,0,0],[1,0,1]]) 1 >>> numDistinctIslands(4, 5, [[1,1,0,1,1],[1,0,0,1,0],[0,0,0,0,1],[1,1,1,1,0]]) 3","solution":"def numDistinctIslands(m, n, grid): Returns the number of distinct islands in the given m x n grid. An island is made of connected land cells (1) and is distinct if it cannot be translated to match another. from collections import deque def bfs(r, c, seen): relative_positions = [] queue = deque([(r, c)]) seen.add((r, c)) origin = (r, c) while queue: x, y = queue.popleft() relative_positions.append((x - origin[0], y - origin[1])) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 1 and (nx, ny) not in seen: seen.add((nx, ny)) queue.append((nx, ny)) return tuple(sorted(relative_positions)) seen = set() distinct_islands = set() for i in range(m): for j in range(n): if grid[i][j] == 1 and (i, j) not in seen: island_shape = bfs(i, j, seen) distinct_islands.add(island_shape) return len(distinct_islands)"},{"question":"import math from typing import List def lcm(a: int, b: int) -> int: Calculate the least common multiple of two integers. pass def min_total_check_time(n: int, k: int) -> int: Calculate the minimum total time required to check all the robots at least once. Each robot's maintenance check recurs every k hours. This function determines the minimum time needed to check all robots in a round-robin sequence. Args: n (int): The number of robots. k (int): The period (in hours) each robot needs a maintenance check. Returns: int: The minimum total time required to check all robots at least once. Examples: >>> min_total_check_time(5, 3) 15 >>> min_total_check_time(4, 4) 4 >>> min_total_check_time(6, 3) 6 >>> min_total_check_time(3, 7) 21 pass def test_basic_case(): assert min_total_check_time(5, 3) == 15 def test_equal_n_and_k(): assert min_total_check_time(4, 4) == 4 def test_n_greater_than_k(): assert min_total_check_time(6, 3) == 6 def test_k_greater_than_n(): assert min_total_check_time(3, 7) == 21 def test_large_numbers(): assert min_total_check_time(1000, 1000) == 1000 assert min_total_check_time(1000, 999) == 999000 def test_prime_numbers(): assert min_total_check_time(7, 3) == 21 assert min_total_check_time(11, 13) == 143","solution":"import math def lcm(a, b): return a * b // math.gcd(a, b) def min_total_check_time(n, k): return lcm(n, k)"},{"question":"def total_strokes(wall_codes: List[str]) -> List[int]: Calculates the total number of strokes required for each wall based on the codes. >>> total_strokes([\\"AABBCC\\", \\"CCC\\", \\"ABA\\"]) [6, 3, 3] >>> total_strokes([\\"C\\", \\"AA\\", \\"BBB\\", \\"CCCC\\"]) [1, 2, 3, 4]","solution":"def total_strokes(wall_codes): Calculates the total number of strokes required for each wall based on the codes. Parameters: wall_codes (list of str): A list of wall codes, each string containing only 'A', 'B', and 'C'. Returns: list of int: A list of total strokes for each wall code. results = [] for code in wall_codes: results.append(len(code)) return results # Example usage: # wall_codes = [\\"AABBCC\\", \\"CCC\\", \\"ABA\\"] # print(total_strokes(wall_codes)) # Output: [6, 3, 3]"},{"question":"def longest_unique_path(grid): Find the length of the longest path in the grid such that all the letters in the path are unique. The path can only move between adjacent cells (horizontally or vertically, but not diagonally) and cannot visit any cell more than once. >>> longest_unique_path([ ... \\"abcd\\", ... \\"efgh\\", ... \\"ijkl\\" ... ]) 12 >>> longest_unique_path([ ... \\"abcde\\", ... \\"fghij\\", ... \\"klmno\\", ... \\"pqrst\\", ... \\"uvwxy\\" ... ]) 25 pass def test_small_grid(): grid = [ \\"abcd\\", \\"efgh\\", \\"ijkl\\" ] assert longest_unique_path(grid) == 12 def test_full_grid(): grid = [ \\"abcde\\", \\"fghij\\", \\"klmno\\", \\"pqrst\\", \\"uvwxy\\" ] assert longest_unique_path(grid) == 25 def test_single_column(): grid = [ \\"a\\", \\"b\\", \\"c\\", \\"d\\" ] assert longest_unique_path(grid) == 4 def test_single_row(): grid = [ \\"abcdefgh\\" ] assert longest_unique_path(grid) == 8 def test_grid_with_duplicates(): grid = [ \\"abca\\", \\"bcdb\\", \\"cdca\\", \\"dbca\\" ] assert longest_unique_path(grid) == 4 def test_single_element(): grid = [ \\"a\\" ] assert longest_unique_path(grid) == 1","solution":"def longest_unique_path(grid): def dfs(x, y, visited): nonlocal max_length max_length = max(max_length, len(visited)) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] not in visited: visited.add(grid[nx][ny]) dfs(nx, ny, visited) visited.remove(grid[nx][ny]) # backtrack n = len(grid) m = len(grid[0]) max_length = 0 for i in range(n): for j in range(m): dfs(i, j, set(grid[i][j])) return max_length"},{"question":"from typing import List def max_load(weights: List[int], W: int) -> int: Function to return the maximum load that can be achieved without exceeding the weight limit. >>> max_load([1, 3, 5, 7, 9], 10) 9 >>> max_load([4, 2, 7, 1, 3], 10) 10 pass # Unit tests def test_max_load_no_packages(): assert max_load([], 10) == 0 def test_max_load_single_package_under_limit(): assert max_load([5], 10) == 5 def test_max_load_single_package_over_limit(): assert max_load([15], 10) == 0 def test_max_load_exact_limit(): assert max_load([2, 3, 5], 10) == 10 def test_max_load_within_limit(): assert max_load([1, 3, 5, 7, 9], 10) == 9 def test_max_load_multiple_packages(): assert max_load([4, 2, 7, 1, 3], 10) == 10 def test_max_load_edge_case(): assert max_load([1]*1000, 500) == 500 def test_max_load_all_large_packages(): assert max_load([7, 8, 9], 5) == 0 def test_max_load_with_repeating_packages(): assert max_load([2, 2, 2, 2, 2], 8) == 8","solution":"def max_load(weights, W): Function to return the maximum load that can be achieved without exceeding the weight limit. Args: weights (List[int]): A list of integers representing the weights of the packages. W (int): The maximum allowable weight for the truck. Returns: int: The maximum load that the truck can carry without exceeding the weight limit. weights.sort() current_load = 0 for weight in weights: if current_load + weight <= W: current_load += weight else: break return current_load"},{"question":"def min_cost_to_palindrome(n: int, s: str) -> int: Returns the minimum cost to transform the string s into a palindrome. Args: n (int): The length of the string. s (str): The original string. Returns: int: The minimum cost to transform the string into a palindrome. Examples: >>> min_cost_to_palindrome(5, \\"abaca\\") 1 >>> min_cost_to_palindrome(4, \\"abcd\\") 2 from solution import min_cost_to_palindrome def test_example_1(): assert min_cost_to_palindrome(5, \\"abaca\\") == 1 def test_example_2(): assert min_cost_to_palindrome(4, \\"abcd\\") == 2 def test_single_character(): assert min_cost_to_palindrome(1, \\"a\\") == 0 def test_already_palindrome(): assert min_cost_to_palindrome(3, \\"aba\\") == 0 def test_even_length_palindrome(): assert min_cost_to_palindrome(6, \\"abccba\\") == 0 def test_non_palindrome(): assert min_cost_to_palindrome(3, \\"abc\\") == 1 def test_complex_case(): assert min_cost_to_palindrome(7, \\"racecar\\") == 0 assert min_cost_to_palindrome(7, \\"racecat\\") == 1 assert min_cost_to_palindrome(8, \\"aacdcefg\\") == 4","solution":"def min_cost_to_palindrome(n, s): Returns the minimum cost to transform the string s into a palindrome. l, r = 0, n - 1 cost = 0 while l < r: if s[l] != s[r]: cost += 1 l += 1 r -= 1 return cost"},{"question":"def generate_alternating_string(N: int) -> str: Generate a string of length N consisting of alternating 1s and 0s, starting with 1. >>> generate_alternating_string(5) '10101' >>> generate_alternating_string(8) '10101010'","solution":"def generate_alternating_string(N): Generate a string of length N consisting of alternating 1s and 0s, starting with 1. Args: N (int): The length of the desired string. Returns: str: The generated string. return ''.join('1' if i % 2 == 0 else '0' for i in range(N))"},{"question":"def fizzbuzz(n: int) -> List[str]: Prints numbers from 1 to n with the following conditions: - If the number is divisible by 2, prints \\"Fizz\\". - If the number is divisible by 3, prints \\"Buzz\\". - If the number is divisible by both 2 and 3, prints \\"FizzBuzz\\". - Otherwise, prints the number itself. Args: n (int): The upper limit of the range (inclusive). Returns: List[str]: List of strings with numbers and words according to the rules Examples: >>> fizzbuzz(6) ['1', 'Fizz', 'Buzz', 'Fizz', '5', 'FizzBuzz'] >>> fizzbuzz(1) ['1']","solution":"def fizzbuzz(n): Prints numbers from 1 to n with the following conditions: - If the number is divisible by 2, prints \\"Fizz\\". - If the number is divisible by 3, prints \\"Buzz\\". - If the number is divisible by both 2 and 3, prints \\"FizzBuzz\\". - Otherwise, prints the number itself. Args: n (int): The upper limit of the range (inclusive). result = [] for i in range(1, n + 1): if i % 6 == 0: result.append(\\"FizzBuzz\\") elif i % 2 == 0: result.append(\\"Fizz\\") elif i % 3 == 0: result.append(\\"Buzz\\") else: result.append(str(i)) return result"},{"question":"def count_distinct_pairs(n: int, k: int, arr: List[int]) -> int: Count the number of distinct pairs (i, j) such that i < j and the absolute difference between the elements at these positions is equal to a given integer k, modulo 1000000007. >>> count_distinct_pairs(5, 2, [1, 5, 3, 4, 2]) 3 >>> count_distinct_pairs(6, 1, [1, 2, 3, 4, 5, 6]) 5 >>> count_distinct_pairs(4, 10, [1, 2, 3, 4]) 0 >>> count_distinct_pairs(5, 0, [1, 1, 1, 1, 1]) 10 >>> count_distinct_pairs(5, 100, [1, 101, 201, 301, 401]) 4 >>> arr = [i for i in range(1000)] >>> count_distinct_pairs(1000, 1, arr) 999 >>> arr = [1] * 1000 >>> count_distinct_pairs(1000, 0, arr) 499500 MOD = 1000000007 count = 0 for i in range(n): for j in range(i + 1, n): if abs(arr[i] - arr[j]) == k: count = (count + 1) % MOD return count","solution":"def count_distinct_pairs(n, k, arr): MOD = 1000000007 count = 0 for i in range(n): for j in range(i + 1, n): if abs(arr[i] - arr[j]) == k: count = (count + 1) % MOD return count"},{"question":"from typing import List, Tuple def most_frequent_element(arr: List[int], queries: List[Tuple[int, int]]) -> List[int]: For each query, find the most frequent element in the specified subarray. Args: arr: List[int] - The input array of integers. queries: List[Tuple[int, int]] - The list of queries where each query is a tuple (L, R). Returns: List[int] - The list of results for each query. >>> most_frequent_element([1, 2, 2, 3, 1, 2, 1, 1], [(1, 3), (4, 8), (1, 8)]) [2, 1, 1] >>> most_frequent_element([1, 3, 3, 3, 2, 2, 2, 2], [(1, 4), (5, 8), (1, 8)]) [3, 2, 2] >>> most_frequent_element([7, 5, 3, 9, 2], [(3, 3), (5, 5)]) [3, 2] >>> most_frequent_element([5, 5, 6, 6], [(1, 4), (2, 3)]) [5, 5] >>> most_frequent_element([4, 4, 4, 4], [(1, 2), (1, 4)]) [4, 4] >>> most_frequent_element([-1, -1, 2, -1, 2, 3], [(1, 3), (2, 5)]) [-1, -1] >>> most_frequent_element([10, 20, 20, 10, 30, 20], [(1, 6)]) [20] pass","solution":"from collections import defaultdict def most_frequent_element(arr, queries): For each query, find the most frequent element in the specified subarray. Args: arr: List[int] - The input array of integers. queries: List[Tuple[int, int]] - The list of queries where each query is a tuple (L, R). Returns: List[int] - The list of results for each query. result = [] for L, R in queries: subarray = arr[L-1:R] frequency = defaultdict(int) for num in subarray: frequency[num] += 1 # Find the most frequent element with the smallest value in case of ties max_freq = 0 candidate = float('inf') for num, freq in frequency.items(): if freq > max_freq or (freq == max_freq and num < candidate): max_freq = freq candidate = num result.append(candidate) return result"},{"question":"from typing import List, Tuple def num_flowerbeds(T: int, test_cases: List[Tuple[int, int, List[List[str]]]]) -> List[int]: Calculate the number of distinct flowerbeds for each garden arrangement. Args: T (int): The number of test cases. test_cases (List[Tuple[int, int, List[List[str]]]]): Each test case includes the dimensions of the garden grid and the grid itself as a list of strings. Returns: List[int]: The number of distinct flowerbeds for each test case. >>> num_flowerbeds(2, [(4, 5, [ ... list(\\"11100\\"), ... list(\\"11000\\"), ... list(\\"00100\\"), ... list(\\"00011\\") ... ]), (3, 3, [ ... list(\\"111\\"), ... list(\\"010\\"), ... list(\\"111\\") ... ])]) [3, 1] >>> num_flowerbeds(2, [(1, 1, [list(\\"1\\")]), (1, 1, [list(\\"0\\")])]) [1, 0] >>> num_flowerbeds(2, [(3, 3, [ ... list(\\"000\\"), ... list(\\"000\\"), ... list(\\"000\\") ... ]), (4, 5, [ ... list(\\"00000\\"), ... list(\\"00000\\"), ... list(\\"00000\\"), ... list(\\"00000\\") ... ])]) [0, 0] >>> num_flowerbeds(1, [(3, 4, [ ... list(\\"1111\\"), ... list(\\"1111\\"), ... list(\\"1111\\") ... ])]) [1]","solution":"def num_flowerbeds(T, test_cases): def dfs(grid, x, y, M, N): if x < 0 or x >= M or y < 0 or y >= N or grid[x][y] == '0': return grid[x][y] = '0' # Mark the cell as visited dfs(grid, x-1, y, M, N) dfs(grid, x+1, y, M, N) dfs(grid, x, y-1, M, N) dfs(grid, x, y+1, M, N) results = [] for test_case in test_cases: M, N, grid = test_case count = 0 for i in range(M): for j in range(N): if grid[i][j] == '1': # Start a new flowerbed dfs(grid, i, j, M, N) count += 1 results.append(count) return results"},{"question":"def check_workload(T: int, test_cases: List[Tuple[int, int, List[Tuple[str, int]]]]) -> List[str]: Determine if any employee has been overloaded with tasks. Args: T: Number of test cases. test_cases: Each test case is a tuple containing the number of tasks (N), maximum tasks per employee (M), and a list of task details where each task detail is a tuple with employee_id and difficulty_level. Returns: A list of strings where each string is either \\"OVERLOADED\\" if any employee has more than M tasks, otherwise \\"BALANCED\\". Example Usage: >>> check_workload(2, [(3, 2, [(\\"alice\\", 3), (\\"bob\\", 5), (\\"alice\\", 2)]), (4, 1, [(\\"tom\\", 4), (\\"jerry\\", 2), (\\"jerry\\", 1), (\\"tom\\", 3)])]) [\\"BALANCED\\", \\"OVERLOADED\\"] >>> check_workload(1, [(1, 1, [(\\"a\\", 1)])]) [\\"BALANCED\\"]","solution":"def check_workload(T, test_cases): results = [] for i in range(T): N, M, tasks = test_cases[i] employee_task_count = {} for task in tasks: employee_id, difficulty_level = task if employee_id in employee_task_count: employee_task_count[employee_id] += 1 else: employee_task_count[employee_id] = 1 overloaded = any(count > M for count in employee_task_count.values()) results.append(\\"OVERLOADED\\" if overloaded else \\"BALANCED\\") return results"},{"question":"def categorize_expenses(expense_str: str) -> tuple: Categorizes expenses based on given expense strings. Parameters: expense_str (str): A string containing the expenses in the format \\"amount category\\". Returns: tuple: A tuple of four integers representing the total expenses in the Food, Transport, Entertainment, and Others categories, respectively. >>> categorize_expenses(\\"100 food 200 transport 150 food 50 entertainment 30 others 20 others 300 food 40 transport\\") (550, 240, 50, 50) >>> categorize_expenses(\\"200 food 150 food 300 food\\") (650, 0, 0, 0) from solution import categorize_expenses def test_single_expense_each_category(): assert categorize_expenses(\\"100 food 200 transport 50 entertainment 30 others\\") == (100, 200, 50, 30) def test_multiple_expenses_each_category(): assert categorize_expenses(\\"100 food 150 food 200 transport 40 transport 50 entertainment 30 others 20 others\\") == (250, 240, 50, 50) def test_no_expense(): assert categorize_expenses(\\"\\") == (0, 0, 0, 0) def test_only_food_expenses(): assert categorize_expenses(\\"200 food 150 food 300 food\\") == (650, 0, 0, 0) def test_mixed_expenses(): assert categorize_expenses(\\"100 food 200 transport 150 food 50 entertainment 30 others 20 others 300 food 40 transport\\") == (550, 240, 50, 50) def test_large_number_expenses(): assert categorize_expenses(\\"10000 others 5000 food 3000 transport 2000 entertainment\\") == (5000, 3000, 2000, 10000)","solution":"def categorize_expenses(expense_str): Categorizes expenses based on given expense strings. Parameters: expense_str (str): A string containing the expenses in the format \\"amount category\\". Returns: tuple: A tuple of four integers representing the total expenses in the Food, Transport, Entertainment, and Others categories, respectively. # Initialize category totals categories = {'food': 0, 'transport': 0, 'entertainment': 0, 'others': 0} # Split the input string to get individual expense items expenses = expense_str.split() # Process each expense item for i in range(0, len(expenses), 2): amount = int(expenses[i]) category = expenses[i + 1] categories[category] += amount return (categories['food'], categories['transport'], categories['entertainment'], categories['others'])"},{"question":"from typing import List def sum_of_digits(n: int) -> int: Calculate the sum of the digits of a number. >>> sum_of_digits(123) 6 >>> sum_of_digits(4567) 22 >>> sum_of_digits(0) 0 >>> sum_of_digits(987654321) 45 def nth_fibonacci(n: int) -> int: Calculate the N-th Fibonacci number. >>> nth_fibonacci(1) 1 >>> nth_fibonacci(2) 1 >>> nth_fibonacci(3) 2 >>> nth_fibonacci(7) 13 >>> nth_fibonacci(12) 144 >>> nth_fibonacci(20) 6765 def sum_of_digits_in_nth_fibonacci(n: int) -> int: Calculate the sum of the digits of the N-th Fibonacci number. >>> sum_of_digits_in_nth_fibonacci(1) 1 >>> sum_of_digits_in_nth_fibonacci(7) 4 >>> sum_of_digits_in_nth_fibonacci(12) 9 >>> sum_of_digits_in_nth_fibonacci(20) 24 def sum_of_digits_of_nth_fibonacci_for_multiple_cases(test_cases: List[int]) -> List[int]: Calculate the sum of the digits of the N-th Fibonacci number for multiple test cases. >>> test_cases = [1, 7, 12, 20] >>> sum_of_digits_of_nth_fibonacci_for_multiple_cases(test_cases) [1, 4, 9, 24]","solution":"def sum_of_digits(n): return sum(int(digit) for digit in str(n)) def nth_fibonacci(n): if n == 1: return 1 elif n == 2: return 1 a, b = 1, 1 for _ in range(3, n + 1): a, b = b, a + b return b def sum_of_digits_in_nth_fibonacci(n): fib_number = nth_fibonacci(n) return sum_of_digits(fib_number) def sum_of_digits_of_nth_fibonacci_for_multiple_cases(test_cases): results = [] for n in test_cases: results.append(sum_of_digits_in_nth_fibonacci(n)) return results"},{"question":"def generate_matches(N: int): Generates all possible matches in lexicographical order for N participants. :param N: int - number of participants :return: list - list of matches in the format (P, Q) >>> generate_matches(2) [(1, 2)] >>> generate_matches(3) [(1, 2), (1, 3), (2, 3)] >>> generate_matches(4) [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]","solution":"def generate_matches(N): Generates all possible matches in lexicographical order for N participants. :param N: int - number of participants :return: list - list of matches in the format (P, Q) matches = [] for P in range(1, N): for Q in range(P + 1, N + 1): matches.append((P, Q)) return matches"},{"question":"def max_taste_sum(n: int, ratings: List[int]) -> int: Returns the maximum sum of taste ratings that can be achieved by any combination of toppings. >>> max_taste_sum(3, [-1, 2, 3]) 5 >>> max_taste_sum(4, [-5, -3, 4, 9]) 13","solution":"def max_taste_sum(n, ratings): Returns the maximum sum of taste ratings that can be achieved by any combination of toppings. max_sum = 0 # Start with 0 sum because we can choose not to include any toppings for i in range(1, 1 << n): # Loop through all combinations except the empty set current_sum = 0 for j in range(n): if i & (1 << j): # Check if j-th topping is included in the combination current_sum += ratings[j] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def distribute_snacks(n: int, m: int, preference_lists: List[List[int]]) -> Tuple[List[int], List[int]]: A company is organizing a hackathon and wants to provide snacks to its participants. The participants are divided into two groups  coders and designers. Each group has n participants. The company has a list of the preferred snack for each participant for each group, but they wish to distribute the maximum number of distinct snacks without anyone having their least preferred option. Let's say there are m distinct snacks available. Each participant in both groups has a ranked preference list. The company wants to choose a snack for each coder and each designer while ensuring that no one gets their least preferred snack. Additionally, they want to maximize the distinct snacks distributed if possible. Args: n (int): The number of participants in each group. m (int): The number of distinct snacks. preference_lists (List[List[int]]): The list of snack preference lists for each participant. Returns: Tuple[List[int], List[int]]: A tuple containing the list of chosen snacks for coders and designers respectively. Example: >>> distribute_snacks(3, 5, [ [3, 1, 4, 5, 2], [2, 3, 4, 5, 1], [5, 4, 3, 1, 2], [1, 2, 5, 3, 4], [5, 4, 3, 2, 1], [3, 4, 5, 2, 1] ]) ([3, 2, 5], [1, 4, 3]) >>> distribute_snacks(2, 3, [ [1, 3, 2], [3, 1, 2], [2, 1, 3], [3, 1, 2] ]) ([1, 3], [2, 1])","solution":"def distribute_snacks(n, m, preference_lists): import numpy as np from scipy.optimize import linear_sum_assignment def convert_preferences_to_cost_matrix(preferences): matrix = [] for pref in preferences: cost = [m - r for r in pref] matrix.append(cost) return np.array(matrix) coder_prefs = preference_lists[:n] designer_prefs = preference_lists[n:] coder_cost_matrix = convert_preferences_to_cost_matrix(coder_prefs) designer_cost_matrix = convert_preferences_to_cost_matrix(designer_prefs) row_ind, col_ind = linear_sum_assignment(coder_cost_matrix) coders_choice = col_ind + 1 # snacks are 1-indexed row_ind, col_ind = linear_sum_assignment(designer_cost_matrix) designers_choice = col_ind + 1 # Ensure no one gets their least preferred option coders_result = [] for i in range(n): if coder_prefs[i][-1] == coders_choice[i]: coders_choice[i] = np.setdiff1d(range(1, m + 1), coders_choice)[0] coders_result.append(coders_choice[i]) designers_result = [] for i in range(n): if designer_prefs[i][-1] == designers_choice[i]: designers_choice[i] = np.setdiff1d(range(1, m + 1), designers_choice)[0] designers_result.append(designers_choice[i]) return coders_result, designers_result"},{"question":"def min_distinct_bonus_amounts(n: int, ratings: List[int]) -> int: Determine the minimum number of distinct bonus amounts required to satisfy the constraints. >>> min_distinct_bonus_amounts(6, [4, 3, 3, 1, 2, 5]) 4 >>> min_distinct_bonus_amounts(5, [1, 1, 1, 1, 1]) 1 >>> min_distinct_bonus_amounts(6, [4, 4, 4, 3, 3, 2]) 3 >>> min_distinct_bonus_amounts(5, [1, 2, 3, 4, 5]) 5 >>> min_distinct_bonus_amounts(0, []) 0 >>> min_distinct_bonus_amounts(7, [2, 2, 3, 3, 3, 4, 4]) 3","solution":"def min_distinct_bonus_amounts(n, ratings): Returns the minimum number of distinct bonus amounts required to satisfy the constraints. unique_ratings = set(ratings) return len(unique_ratings)"},{"question":"def minimal_non_lucky_string(n: int) -> str: Returns the lexicographically minimal non-lucky string of length n. >>> minimal_non_lucky_string(1) '1' >>> minimal_non_lucky_string(2) '00' >>> minimal_non_lucky_string(3) '000' >>> minimal_non_lucky_string(4) '0000' >>> minimal_non_lucky_string(100000) '0' * 100000","solution":"def minimal_non_lucky_string(n): Returns the lexicographically minimal non-lucky string of length n. if n == 1: return '1' return '0' * n"},{"question":"import math from functools import reduce from typing import List, Tuple def minimum_seconds(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given a number of test cases, determines the minimum number of seconds after which all runners will be back at their starting checkpoints simultaneously. Parameters: T (int): Number of test cases. test_cases (list of tuples): Each tuple contains an integer N and a list of integers S representing the number of steps. Returns: list of int: Minimum number of seconds for each test case. pass # Unit Tests def test_case_1(): T = 2 test_cases = [(3, [2, 3, 2]), (4, [1, 3, 4, 6])] assert minimum_seconds(T, test_cases) == [6, 12] def test_case_2(): T = 1 test_cases = [(5, [1, 2, 3, 4, 5])] assert minimum_seconds(T, test_cases) == [60] def test_case_3(): T = 1 test_cases = [(1, [7])] assert minimum_seconds(T, test_cases) == [7] def test_case_4(): T = 1 test_cases = [(6, [1, 2, 6, 24, 120, 720])] assert minimum_seconds(T, test_cases) == [720] def test_case_5(): T = 1 test_cases = [(3, [5, 25, 35])] assert minimum_seconds(T, test_cases) == [175] def test_case_6(): T = 1 test_cases = [(2, [4, 5])] assert minimum_seconds(T, test_cases) == [20]","solution":"import math from functools import reduce def lcm(a, b): Helper function to compute the Least Common Multiple (LCM) of two integers. return abs(a*b) // math.gcd(a, b) def lcm_multiple(nums): Helper function to compute the LCM of a list of integers. return reduce(lcm, nums) def minimum_seconds(T, test_cases): Given a number of test cases, determines the minimum number of seconds after which all runners will be back at their starting checkpoints simultaneously. Parameters: T (int): Number of test cases. test_cases (list of tuples): Each tuple contains an integer N and a list of integers S representing the number of steps. Returns: list of int: Minimum number of seconds for each test case. results = [] for case in test_cases: N, steps = case results.append(lcm_multiple(steps)) return results"},{"question":"def max_pairs(n: int, k: int, skills: List[int]) -> int: Returns the maximum number of pairs that can be created with the given constraints. Params: n (int): Number of participants. k (int): Maximum acceptable skill level difference. skills (list of int): Skill levels of the participants. Returns: int: Maximum number of pairs that can be created. Examples: >>> max_pairs(5, 3, [1, 2, 3, 5, 7]) 2 >>> max_pairs(4, 0, [1, 1, 1, 1]) 2 >>> max_pairs(3, 1, [10, 20, 30]) 0 >>> max_pairs(6, 10, [5, 15, 25, 35, 45, 55]) 3 >>> max_pairs(1, 5, [10]) 0 >>> max_pairs(5, 1000, [100, 200, 300, 400, 500]) 2 >>> max_pairs(5, 1, [1, 2, 3, 4, 5]) 2 >>> max_pairs(6, 0, [5, 5, 5, 5, 5, 5]) 3","solution":"def max_pairs(n, k, skills): Returns the maximum number of pairs that can be created with the given constraints. Params: n (int): Number of participants. k (int): Maximum acceptable skill level difference. skills (list of int): Skill levels of the participants. Returns: int: Maximum number of pairs that can be created. skills.sort() count = 0 i = 0 while i < n - 1: if abs(skills[i + 1] - skills[i]) <= k: count += 1 i += 2 # Move to the next pair of dancers else: i += 1 # Move to the next participant and try again return count"},{"question":"def euler_totient(n: int) -> int: Philip is interested in learning about number theory and he came across the concept of Euler's Totient Function (n). The Euler's Totient Function (n) for an integer n is defined as the number of integers k in the range 1  k  n such that gcd(n, k) = 1. Given an integer n, Philip wants to compute the value of (n) to further explore its properties. Parameters: n (int): An integer n (1  n  10^9) Returns: int: A single integer which is the value of (n) Examples: >>> euler_totient(9) 6 >>> euler_totient(10) 4 from solution import euler_totient def test_euler_totient_small_numbers(): assert euler_totient(1) == 1 assert euler_totient(2) == 1 assert euler_totient(3) == 2 assert euler_totient(4) == 2 assert euler_totient(5) == 4 def test_euler_totient_medium_numbers(): assert euler_totient(9) == 6 assert euler_totient(10) == 4 assert euler_totient(15) == 8 assert euler_totient(21) == 12 def test_euler_totient_large_prime(): assert euler_totient(10000019) == 10000018 # prime number test def test_euler_totient_large_composite(): assert euler_totient(1000000007) == 1000000006 # prime number test assert euler_totient(999999937) == 999999936 # large prime number test def test_euler_totient_edge_case(): assert euler_totient(1) == 1 # smallest possible value def test_euler_totient_factors(): assert euler_totient(12) == 4 # factors 1, 5, 7, 11 assert euler_totient(16) == 8 # factors 1, 3, 5, 7, 9, 11, 13, 15","solution":"def euler_totient(n): Computes Euler's Totient Function (n). if n == 1: return 1 result = n p = 2 while p * p <= n: if n % p == 0: while n % p == 0: n //= p result -= result // p p += 1 if n > 1: result -= result // n return result"},{"question":"from typing import List def max_employees_on_same_projects(n: int, projects: List[str]) -> int: Returns the maximum number of employees who are working exclusively on the same set of projects regardless of the order of the projects in their lists. >>> max_employees_on_same_projects(5, [\\"abc\\", \\"bca\\", \\"cab\\", \\"de\\", \\"ed\\"]) 3 >>> max_employees_on_same_projects(4, [\\"abc\\", \\"def\\", \\"ghi\\", \\"jkl\\"]) 1","solution":"from collections import Counter def max_employees_on_same_projects(n, projects): Returns the maximum number of employees who are working exclusively on the same set of projects regardless of the order of the projects in their lists. # Normalize the project lists by sorting each string normalized_projects = [''.join(sorted(project)) for project in projects] # Count the number of occurrences of each normalized project list project_count = Counter(normalized_projects) # Return the maximum number of employees working on the same set of projects return max(project_count.values())"},{"question":"def max_sum_of_squares(T: int, integers: List[int]) -> int: Find the maximum sum of squares of a subset from the list of integers such that the sum is as close as possible to the target value T without exceeding it. :param T: An integer, the target value (1  T  10^4) :param integers: A list of integers (1  N_i  100) :return: The maximum sum of squares of a subset that is <= T Examples: >>> max_sum_of_squares(20, [4, 5, 6]) 16 >>> max_sum_of_squares(50, [7, 11, 3, 9]) 49","solution":"def max_sum_of_squares(T, integers): This function finds the maximum sum of the squares of a subset from the provided list of integers such that the sum is as close as possible to T without exceeding it. k = len(integers) # Initialize dp array where dp[i] will be true if some subset of integers up to i achieves that sum dp = [0] * (T + 1) dp[0] = 1 for num in integers: square = num * num for i in range(T, square - 1, -1): if dp[i - square]: dp[i] = 1 # Find the maximum value where dp[value] is true for i in range(T, -1, -1): if dp[i]: return i # If no solution found which should not be the case by problem constraints return 0"},{"question":"import sys from heapq import heappop, heappush def min_threshold(matrix, N, M): Given a matrix representing the terrain heights, determine the minimum threshold value T needed to move from the top-left to the bottom-right corner. >>> min_threshold([[1, 3, 5], [2, 8, 4], [3, 7, 6]], 3, 3) 2 >>> min_threshold([[0]], 1, 1) 0 >>> min_threshold([[0, 100], [100, 200]], 2, 2) 100 def valid(x, y): return 0 <= x < N and 0 <= y < M def can_reach_with_threshold(T): min_heap = [(0, 0, 0)] # (distance, row, col) visited = set((0, 0)) while min_heap: diff, x, y = heappop(min_heap) if (x, y) == (N-1, M-1): return True for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if valid(nx, ny) and (nx, ny) not in visited: ndiff = abs(matrix[nx][ny] - matrix[x][y]) if ndiff <= T: visited.add((nx, ny)) heappush(min_heap, (ndiff, nx, ny)) return False left, right = 0, 10000 result = right while left <= right: mid = (left + right) // 2 if can_reach_with_threshold(mid): result = mid right = mid - 1 else: left = mid + 1 return result def main(): input = sys.stdin.read data = input().split() N = int(data[0]) M = int(data[1]) matrix = [] idx = 2 for i in range(N): row = list(map(int, data[idx:idx+M])) matrix.append(row) idx += M print(min_threshold(matrix, N, M)) if __name__ == \\"__main__\\": main()","solution":"from heapq import heappop, heappush import sys def min_threshold(matrix, N, M): def valid(x, y): return 0 <= x < N and 0 <= y < M def can_reach_with_threshold(T): min_heap = [(0, 0, 0)] # (distance, row, col) visited = set((0, 0)) while min_heap: diff, x, y = heappop(min_heap) if (x, y) == (N-1, M-1): return True for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if valid(nx, ny) and (nx, ny) not in visited: ndiff = abs(matrix[nx][ny] - matrix[x][y]) if ndiff <= T: visited.add((nx, ny)) heappush(min_heap, (ndiff, nx, ny)) return False left, right = 0, 10000 result = right while left <= right: mid = (left + right) // 2 if can_reach_with_threshold(mid): result = mid right = mid - 1 else: left = mid + 1 return result def main(): input = sys.stdin.read data = input().split() N = int(data[0]) M = int(data[1]) matrix = [] idx = 2 for i in range(N): row = list(map(int, data[idx:idx+M])) matrix.append(row) idx += M print(min_threshold(matrix, N, M)) if __name__ == \\"__main__\\": main()"},{"question":"def library_status(n: int, books: List[str], m: int, operations: List[str]) -> Dict[str, str]: Simulate the borrowing and returning process for a set of books in a library. Parameters: n (int): Number of books. books (list): List of book titles. m (int): Number of operations. operations (list): List of operations in the format \\"BORROW book_name person_name\\" or \\"RETURN book_name\\". Returns: dict: A dictionary with book titles as keys and their status as values, either \\"available\\" or \\"borrowed by person_name\\". >>> library_status(4, [\\"HarryPotter\\", \\"LOTR\\", \\"1984\\", \\"AnimalFarm\\"], 6, [ \\"BORROW HarryPotter Alice\\", \\"BORROW 1984 Bob\\", \\"RETURN HarryPotter\\", \\"BORROW LOTR Charlie\\", \\"BORROW 1984 David\\", \\"RETURN 1984\\" ]) { \\"HarryPotter\\": \\"available\\", \\"LOTR\\": \\"borrowed by Charlie\\", \\"1984\\": \\"available\\", \\"AnimalFarm\\": \\"available\\" }","solution":"def library_status(n, books, m, operations): Returns the final status of all books in the library after the series of borrow/return operations. Parameters: n (int): Number of books. books (list): List of book titles. m (int): Number of operations. operations (list): List of operations in the format \\"BORROW book_name person_name\\" or \\"RETURN book_name\\". Returns: dict: A dictionary with book titles as keys and their status as values. book_status = {book: \\"available\\" for book in books} for operation in operations: parts = operation.split() if parts[0] == \\"BORROW\\": book_name = parts[1] person_name = parts[2] if book_status[book_name] == \\"available\\": book_status[book_name] = f\\"borrowed by {person_name}\\" elif parts[0] == \\"RETURN\\": book_name = parts[1] if book_status[book_name].startswith(\\"borrowed\\"): book_status[book_name] = \\"available\\" return book_status"},{"question":"def minimal_total_distance(n: int, distances: List[int]) -> int: Calculates the minimal total distance travel required to visit all delivery locations exactly once and return back to the depot. Parameters: n : int : the number of delivery locations. distances : List[int] : a list of integers where each integer is the distance from the depot to the delivery location. Returns: int : the minimal total distance to travel. Examples: >>> minimal_total_distance(3, [1, 2, 3]) 12 >>> minimal_total_distance(5, [10, 20, 30, 40, 50]) 300 pass","solution":"def minimal_total_distance(n, distances): Calculates the minimal total distance travel required to visit all delivery locations exactly once and return back to the depot. Parameters: n : int : the number of delivery locations. distances : List[int] : a list of integers where each integer is the distance from the depot to the delivery location. Returns: int : the minimal total distance to travel. return 2 * sum(distances)"},{"question":"from typing import List, Tuple def find_maximum_submatrix_sum(matrix: List[List[int]]) -> int: Finds the maximum sum of any sub-matrix within a given matrix. Parameters: matrix (list of list of int): A 2D list representing the matrix. Returns: int: The maximum sum of any sub-matrix. pass def process_input(input_string: str) -> Tuple[int, int, List[List[int]]]: Processes the input string into matrix dimensions and the actual matrix. Parameters: input_string (str): The input string containing matrix dimensions and matrix values. Returns: Tuple[int, int, List[List[int]]]: A tuple containing the number of rows, number of columns, and the matrix. pass def test_find_maximum_submatrix_sum(): input_string = \\"3 3n1 2 3n4 5 6n7 8 9\\" n, m, matrix = process_input(input_string) assert find_maximum_submatrix_sum(matrix) == 45 input_string = \\"4 4n-1 -2 -3 -4n-5 -6 -7 -8n-9 -10 -11 -12n-13 -14 -15 -16\\" n, m, matrix = process_input(input_string) assert find_maximum_submatrix_sum(matrix) == -1 input_string = \\"2 2n1 2n3 4\\" n, m, matrix = process_input(input_string) assert find_maximum_submatrix_sum(matrix) == 10 input_string = \\"2 3n-1 2 3n-4 5 6\\" n, m, matrix = process_input(input_string) assert find_maximum_submatrix_sum(matrix) == 16 input_string = \\"1 4n1 2 3 4\\" n, m, matrix = process_input(input_string) assert find_maximum_submatrix_sum(matrix) == 10 input_string = \\"2 2n-1 -2n-3 -4\\" n, m, matrix = process_input(input_string) assert find_maximum_submatrix_sum(matrix) == -1","solution":"def find_maximum_submatrix_sum(matrix): Finds the maximum sum of any sub-matrix within a given matrix. Parameters: matrix (list of list of int): A 2D list representing the matrix. Returns: int: The maximum sum of any sub-matrix. def kadane(arr): max_sum = float('-inf') current_sum = 0 for x in arr: current_sum = max(x, current_sum + x) max_sum = max(max_sum, current_sum) return max_sum def max_sum_subarray(matrix): row_count, col_count = len(matrix), len(matrix[0]) max_sum = float('-inf') for left in range(col_count): temp = [0] * row_count for right in range(left, col_count): for row in range(row_count): temp[row] += matrix[row][right] max_sum = max(max_sum, kadane(temp)) return max_sum return max_sum_subarray(matrix) def process_input(input_string): lines = input_string.strip().split('n') n, m = map(int, lines[0].split()) matrix = [list(map(int, line.split())) for line in lines[1:]] return n, m, matrix"},{"question":"def count_rectangles(n: int, m: int) -> int: Calculate the number of different rectangular sections in an n x m grid. Parameters: n (int): Number of rows in the grid. m (int): Number of columns in the grid. Returns: int: Number of different rectangular sections. Examples: >>> count_rectangles(3, 3) 36 >>> count_rectangles(2, 2) 9","solution":"def count_rectangles(n, m): Returns the number of different rectangular sections from an n x m grid. # Number of ways to select 2 rows from n+1 rows: (n+1)C2 = (n+1)*n / 2 # Number of ways to select 2 columns from m+1 columns: (m+1)*m / 2 return (n * (n + 1) // 2) * (m * (m + 1) // 2)"},{"question":"def lexicographically_smallest_permutation(n, p): Returns the lexicographically smallest permutation after one reverse operation >>> lexicographically_smallest_permutation(5, [4, 3, 2, 1, 5]) [1, 2, 3, 4, 5] >>> lexicographically_smallest_permutation(3, [2, 3, 1]) [1, 3, 2]","solution":"def lexicographically_smallest_permutation(n, p): Returns the lexicographically smallest permutation after one reverse operation smallest_p = p[:] for i in range(n): for j in range(i + 1, n): p_reversed = p[:i] + p[i:j+1][::-1] + p[j+1:] if p_reversed < smallest_p: smallest_p = p_reversed return smallest_p"},{"question":"def longest_subsequence_length(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Find the longest subsequence where the absolute difference between any two consecutive elements is less than or equal to a given integer \`k\`. >>> longest_subsequence_length(2, [(5, 3, [1, 5, 3, 8, 9]), (4, 2, [1, 3, 2, 5])]) [2, 3] >>> longest_subsequence_length(1, [(4, 10, [1, 2, 3, 4])]) [4] >>> longest_subsequence_length(1, [(3, 1, [1, 10, 20])]) [1]","solution":"def longest_subsequence_length(t, test_cases): results = [] for case in test_cases: n, k, arr = case max_length = 1 current_length = 1 for i in range(1, n): if abs(arr[i] - arr[i - 1]) <= k: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 results.append(max_length) return results"},{"question":"def is_possible_single_path(n: int, m: int, maze: List[str]) -> str: Determine if it is possible to create a single uninterrupted path from top-left to bottom-right cell that only passes through empty cells ('.') once. Args: n (int): Number of rows in the maze. m (int): Number of columns in the maze. maze (List[str]): The representation of the maze where '.' is an empty cell and '#' is a hedge. Returns: str: \\"YES\\" if such a path exists, otherwise \\"NO\\". Example: >>> is_possible_single_path(3, 4, [\\".#..\\", \\"..#.\\", \\"#..#\\"]) \\"NO\\" >>> is_possible_single_path(2, 2, [\\".#\\", \\"#.\\"]) \\"NO\\" >>> is_possible_single_path(3, 3, [\\"...\\", \\".#.\\", \\"...\\"]) \\"YES\\" # Function implementation here # Unit tests def test_case_1(): n, m = 3, 4 maze = [ \\".#..\\", \\"..#.\\", \\"#..#\\" ] assert is_possible_single_path(n, m, maze) == \\"NO\\" def test_case_2(): n, m = 2, 2 maze = [ \\".#\\", \\"#.\\" ] assert is_possible_single_path(n, m, maze) == \\"NO\\" def test_case_3(): n, m = 3, 3 maze = [ \\"...\\", \\".#.\\", \\"...\\" ] assert is_possible_single_path(n, m, maze) == \\"YES\\" def test_case_4(): n, m = 1, 1 maze = [ \\".\\" ] assert is_possible_single_path(n, m, maze) == \\"YES\\" def test_case_5(): n, m = 3, 3 maze = [ \\"#\\", \\"#.#\\", \\"#\\" ] assert is_possible_single_path(n, m, maze) == \\"NO\\" def test_case_6(): n, m = 4, 4 maze = [ \\"..#.\\", \\"#.\\", \\"..#.\\", \\"....\\" ] assert is_possible_single_path(n, m, maze) == \\"NO\\" # Running the tests def test_run_all(): test_case_1() test_case_2() test_case_3() test_case_4() test_case_5() test_case_6() test_run_all()","solution":"def is_possible_single_path(n, m, maze): from collections import deque # Valid move directions (up, down, left, right) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] def is_valid(x, y): return 0 <= x < n and 0 <= y < m and maze[x][y] == '.' def bfs_and_count_empty_cells(start_x, start_y): queue = deque([(start_x, start_y)]) visited = set([(start_x, start_y)]) empty_cells_count = 1 while queue: x, y = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) empty_cells_count += 1 return empty_cells_count, visited def count_total_empty_cells(): empty_count = sum(row.count('.') for row in maze) return empty_count # Check start and end cells if maze[0][0] == '#' or maze[n-1][m-1] == '#': return \\"NO\\" total_empty_cells = count_total_empty_cells() if total_empty_cells == 0: return \\"NO\\" cells_counted, visited_cells = bfs_and_count_empty_cells(0, 0) if cells_counted == total_empty_cells and (n-1, m-1) in visited_cells: return \\"YES\\" else: return \\"NO\\""},{"question":"import heapq from typing import List def min_effort_path(matrix: List[List[int]]) -> int: Returns the minimum effort required to travel from the top-left corner to the bottom-right corner of a matrix. >>> min_effort_path([[1, 2, 2], [3, 8, 2], [5, 3, 5]]) == 2 >>> min_effort_path([[1, 2], [2, 3]]) == 1 >>> min_effort_path([[42]]) == 0 >>> min_effort_path([[1, 10000], [10000, 1]]) == 9999 >>> min_effort_path([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) == 0","solution":"import heapq def min_effort_path(matrix): Returns the minimum effort required to travel from the top-left corner to the bottom-right corner of a matrix. n = len(matrix) if n == 1: return 0 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] effort = [[float('inf')] * n for _ in range(n)] effort[0][0] = 0 min_heap = [(0, 0, 0)] # (effort, x, y) while min_heap: current_effort, x, y = heapq.heappop(min_heap) if x == n - 1 and y == n - 1: return current_effort for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n: new_effort = max(current_effort, abs(matrix[nx][ny] - matrix[x][y])) if new_effort < effort[nx][ny]: effort[nx][ny] = new_effort heapq.heappush(min_heap, (new_effort, nx, ny)) return -1 # If there is no path, which is actually not possible in this problem constraints."},{"question":"def minimum_total_time(n: int, times: List[int]) -> int: Calculate the minimum total time required to complete all stages one after the other. Parameters: n (int): Number of stages in the process. times (list of int): Time taken to complete each stage. Returns: int: Minimum total time required to complete all stages. pass def test_minimum_total_time_example1(): assert minimum_total_time(5, [3, 1, 2, 5, 4]) == 15 def test_minimum_total_time_example2(): assert minimum_total_time(3, [7, 8, 3]) == 18 def test_minimum_total_time_example3(): assert minimum_total_time(1, [10]) == 10 def test_minimum_total_time_single_stage(): assert minimum_total_time(1, [1]) == 1 def test_minimum_total_time_same_stage_times(): assert minimum_total_time(4, [2, 2, 2, 2]) == 8 def test_minimum_total_time_varied_stage_times(): assert minimum_total_time(5, [1, 2, 3, 4, 5]) == 15 def test_minimum_total_time_large_stage_times(): assert minimum_total_time(3, [100, 200, 300]) == 600","solution":"def minimum_total_time(n, times): Calculate the minimum total time required to complete all stages one after the other. Parameters: n (int): Number of stages in the process. times (list of int): Time taken to complete each stage. Returns: int: Minimum total time required to complete all stages. return sum(times)"},{"question":"def inside_rectangle(x1, y1, x2, y2, points): Determines if the points lie inside the rectangle defined by (x1, y1) and (x2, y2). Args: x1, y1 : Coordinates of one vertex of the rectangle x2, y2 : Coordinates of the opposite vertex of the rectangle points : List of tuples representing the points to check Returns: List of strings \\"Yes\\" or \\"No\\" for each point. def delivery_zones(t, test_cases): Determines if the points lie inside the delivery zones for each test case. Args: t : Number of test cases test_cases : List of test cases with coordinates of two vertices of the rectangle and points to check Returns: List of lists of strings \\"Yes\\" or \\"No\\" for each point in each test case.","solution":"def inside_rectangle(x1, y1, x2, y2, points): Determines if the points lie inside the rectangle defined by (x1, y1) and (x2, y2). Args: x1, y1 : Coordinates of one vertex of the rectangle x2, y2 : Coordinates of the opposite vertex of the rectangle points : List of tuples representing the points to check Returns: List of strings \\"Yes\\" or \\"No\\" for each point. # Determine the bounding coordinates of the rectangle left = min(x1, x2) right = max(x1, x2) bottom = min(y1, y2) top = max(y1, y2) result = [] for x, y in points: if left <= x <= right and bottom <= y <= top: result.append(\\"Yes\\") else: result.append(\\"No\\") return result def delivery_zones(t, test_cases): results = [] for i in range(t): x1, y1 = test_cases[i][0] x2, y2 = test_cases[i][1] points = test_cases[i][2] results.append(inside_rectangle(x1, y1, x2, y2, points)) return results"},{"question":"def max_sum_excluding_one(grades: List[int]) -> int: Returns the maximum sum of grades obtainable by excluding exactly one student's grade. If the class has only one student, returns 0. :param grades: List[int] - A list of integers representing the grades of students :return: int - The maximum sum of grades excluding exactly one student's grade >>> max_sum_excluding_one([95, 80, 70, 100, 85]) 360 >>> max_sum_excluding_one([50]) 0 >>> max_sum_excluding_one([55, 60, 65, 70]) 195","solution":"def max_sum_excluding_one(grades): Returns the maximum sum of grades obtainable by excluding exactly one student's grade. If the class has only one student, returns 0. :param grades: List[int] - A list of integers representing the grades of students :return: int - The maximum sum of grades excluding exactly one student's grade if len(grades) <= 1: return 0 total_sum = sum(grades) return total_sum - min(grades)"},{"question":"def min_z_value(n, arr): Given an array of n integers, return the minimum possible value of max((a_i + a_j) & Z) where 1  i, j  n and Z is an integer. >>> min_z_value(4, [2, 4, 6, 8]) 0 >>> min_z_value(3, [5, 9, 14]) 0","solution":"def min_z_value(n, arr): Given an array of n integers, return the minimum possible value of max((a_i + a_j) & Z) where 1  i, j  n and Z is an integer. # The minimum value of (a_i + a_j) & Z can be minimized by choosing Z = 0 return 0"},{"question":"def gcd(a: int, b: int) -> int: Returns the greatest common divisor (GCD) of a and b. pass def lcm(a: int, b: int) -> int: Returns the least common multiple (LCM) of a and b. pass def find_min_stability(arr: List[int]) -> int: Determines the minimum possible difference between the maximum and minimum integers in the array after performing the specified operations any number of times. Args: arr : List[int] - List of integers Returns: int - Minimum difference between maximum and minimum integers >>> find_min_stability([2, 4, 6, 8]) 0 >>> find_min_stability([5, 10, 15, 20, 25]) 0 pass import math from functools import reduce def test_find_min_stability_single_element(): assert find_min_stability([7]) == 0 def test_find_min_stability_example1(): assert find_min_stability([2, 4, 6, 8]) == 0 def test_find_min_stability_example2(): assert find_min_stability([5, 10, 15, 20, 25]) == 0 def test_find_min_stability_all_same_elements(): assert find_min_stability([3, 3, 3, 3]) == 0 def test_find_min_stability_large_range(): assert find_min_stability([1000000000, 2000000000, 3000000000, 4000000000]) == 0","solution":"import math from functools import reduce def gcd(a, b): Returns the greatest common divisor (GCD) of a and b. return math.gcd(a, b) def lcm(a, b): Returns the least common multiple (LCM) of a and b. return a * b // gcd(a, b) def find_min_stability(arr): Determines the minimum possible difference between the maximum and minimum integers in the array after performing the specified operations any number of times. overall_gcd = reduce(gcd, arr) # The array can be transformed to all elements being the overall_gcd # Therefore, the minimum difference will be 0 if there are more than one elements. return 0 if len(arr) > 1 else max(arr) - min(arr)"},{"question":"from typing import List, Tuple def process_input_and_solve(n: int, m: int, roads: List[Tuple[int, int, int, int]]) -> Tuple[int, int]: Determine the shortest possible distance and the longest possible distance between town 1 and town n. Arguments: n -- the number of towns m -- the number of roads roads -- a list of tuples (u, v, min_d, max_d) representing bidirectional roads Returns: A tuple containing two integers: - the shortest possible distance - the longest possible distance If there is no path between town 1 and town n, return (-1, -1)","solution":"import heapq def dijkstra(n, graph, is_min): distances = [float('inf')] * (n + 1) distances[1] = 0 pq = [(0, 1)] # (distance, node) while pq: current_distance, u = heapq.heappop(pq) if current_distance > distances[u]: continue for v, min_d, max_d in graph[u]: distance = min_d if is_min else max_d if current_distance + distance < distances[v]: distances[v] = current_distance + distance heapq.heappush(pq, (distances[v], v)) return distances[n] if distances[n] != float('inf') else -1 def shortest_and_longest_path(n, m, roads): graph = [[] for _ in range(n + 1)] for u, v, min_d, max_d in roads: graph[u].append((v, min_d, max_d)) graph[v].append((u, min_d, max_d)) shortest = dijkstra(n, graph, True) longest = dijkstra(n, graph, False) return shortest, longest def process_input_and_solve(n, m, roads): shortest, longest = shortest_and_longest_path(n, m, roads) return shortest, longest"},{"question":"def max_profit(prices: List[int]) -> int: Returns the maximum profit that could be achieved by buying stock on one day and selling it on another later day. >>> max_profit([7, 1, 5, 3, 6, 4]) == 5 >>> max_profit([7, 6, 4, 3, 1]) == 0 >>> max_profit([1, 2, 3, 4, 5, 6, 7, 8]) == 7 def stock_analysis(test_cases: List[List[int]]) -> List[int]: Given multiple test cases represented as a list, returns a list of maximum profits for each test case. >>> stock_analysis([[7, 1, 5, 3, 6, 4], [7, 6, 4, 3, 1], [1, 2, 3, 4, 5, 6, 7, 8]]) == [5, 0, 7]","solution":"def max_profit(prices): Returns the maximum profit that could be achieved by buying stock on one day and selling it on another later day. if not prices or len(prices) < 2: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit def stock_analysis(test_cases): Given multiple test cases represented as a list, returns a list of maximum profits for each test case. results = [] for prices in test_cases: results.append(max_profit(prices)) return results"},{"question":"def is_possible_to_seat(n: int, m: int, restrictions: List[Tuple[int, int]]) -> str: Determine whether it is possible to arrange all guests in a circle such that no pair of guests who should not sit next to each other are seated next to each other. >>> is_possible_to_seat(4, 2, [(1, 2), (3, 4)]) 'POSSIBLE' >>> is_possible_to_seat(4, 5, [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4)]) 'IMPOSSIBLE' >>> is_possible_to_seat(3, 0, []) 'POSSIBLE' >>> is_possible_to_seat(5, 3, [(1, 2), (2, 3), (4, 5)]) 'POSSIBLE' >>> is_possible_to_seat(6, 8, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (1, 3), (2, 4)]) 'IMPOSSIBLE'","solution":"from itertools import permutations def is_possible_to_seat(n, m, restrictions): all_guests = list(range(1, n + 1)) for perm in permutations(all_guests): valid = True for i in range(n): if (perm[i], perm[(i+1) % n]) in restrictions or (perm[(i+1) % n], perm[i]) in restrictions: valid = False break if valid: return \\"POSSIBLE\\" return \\"IMPOSSIBLE\\" def main(): import sys input = sys.stdin.read data = input().strip().split() n = int(data[0]) m = int(data[1]) restrictions = [] for i in range(m): a = int(data[2 + 2 * i]) b = int(data[3 + 2 * i]) restrictions.append((a, b)) print(is_possible_to_seat(n, m, restrictions)) if __name__ == \\"__main__\\": main()"},{"question":"def count_unique_integers(n: int, q: int, array: List[int], queries: List[Tuple[int, int]]) -> List[int]: Given a list of integers and a list of range queries, return the number of unique integers in each query range. Parameters: n (int): number of elements in the array q (int): number of queries array (list of int): list of integers queries (list of tuple): list of query ranges (l, r) Returns: list of int: list of number of unique integers for each query >>> n, q = 5, 3 >>> array = [1, 2, 1, 3, 2] >>> queries = [(1, 3), (2, 4), (1, 5)] >>> count_unique_integers(n, q, array, queries) [2, 3, 3] >>> n, q = 6, 2 >>> array = [4, 4, 4, 4, 4, 4] >>> queries = [(1, 6), (2, 5)] >>> count_unique_integers(n, q, array, queries) [1, 1]","solution":"def count_unique_integers(n, q, array, queries): Given a list of integers and a list of range queries, return the number of unique integers in each query range. Parameters: n (int): number of elements in the array q (int): number of queries array (list of int): list of integers queries (list of tuple): list of query ranges (l, r) Returns: list of int: list of number of unique integers for each query result = [] for l, r in queries: unique_elements = set(array[l-1:r]) # convert to 0-based index result.append(len(unique_elements)) return result"},{"question":"import math from typing import List, Tuple def compute_task_distribution(t: int, test_cases: List[Tuple[int, int, int]]) -> List[int]: Computes the number of ways to assign exactly 'b' tasks out of 'a' available tasks to a team of 'n' employees such that no single employee is assigned more than one task. >>> compute_task_distribution(3, [(5, 3, 4), (7, 4, 5), (6, 2, 3)]) [10, 35, 15] >>> compute_task_distribution(2, [(5, 6, 4), (7, 4, 2)]) [0, 0] results = [] for case in test_cases: a, b, n = case if b > a or n < b: results.append(0) else: # Calculate combination C(a, b) comb = math.comb(a, b) results.append(comb) return results # Unit tests def test_compute_task_distribution(): assert compute_task_distribution(3, [(5, 3, 4), (7, 4, 5), (6, 2, 3)]) == [10, 35, 15] assert compute_task_distribution(2, [(5, 6, 4), (7, 4, 2)]) == [0, 0] assert compute_task_distribution(1, [(6, 6, 6)]) == [1] assert compute_task_distribution(1, [(6, 1, 1)]) == [6] assert compute_task_distribution(1, [(4, 2, 4)]) == [6] def test_invalid_cases(): assert compute_task_distribution(2, [(5, 3, 2), (7, 8, 5)]) == [0, 0] assert compute_task_distribution(1, [(0, 0, 0)]) == [1] assert compute_task_distribution(1, [(3, 5, 4)]) == [0] def test_edge_cases(): assert compute_task_distribution(1, [(100, 50, 50)]) == [100891344545564193334812497256] assert compute_task_distribution(1, [(10, 0, 5)]) == [1] def test_more_cases(): assert compute_task_distribution(3, [(5, 5, 5), (10, 5, 5), (10, 5, 10)]) == [1, 252, 252]","solution":"import math def compute_task_distribution(t, test_cases): results = [] for case in test_cases: a, b, n = case if b > a or n < b: results.append(0) else: # Calculate combination C(a, b) comb = math.comb(a, b) results.append(comb) return results"},{"question":"import heapq def dijkstra(n, edges, start): Helper function using Dijkstra's algorithm to find the shortest paths from \`start\` to all other nodes in the graph. distances = {node: float('inf') for node in range(1, n + 1)} distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in edges[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances def find_optimal_post_office(n, m, connections): This function finds the optimal neighborhood to establish the central post office such that the maximum distance to any other neighborhood is minimized. # Build the adjacency list edges = {i: [] for i in range(1, n + 1)} for u, v, d in connections: edges[u].append((v, d)) edges[v].append((u, d)) # Perform Dijkstra from every node to every other node min_max_distance = float('inf') for i in range(1, n + 1): distances = dijkstra(n, edges, i) max_distance = max(distances.values()) if max_distance < min_max_distance: min_max_distance = max_distance return min_max_distance def test_find_optimal_post_office_example_1(): n = 4 m = 4 connections = [(1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 1, 1)] result = find_optimal_post_office(n, m, connections) assert result == 2 def test_find_optimal_post_office_example_2(): n = 5 m = 6 connections = [ (1, 2, 2), (2, 3, 3), (3, 4, 4), (4, 5, 2), (5, 1, 3), (3, 5, 5) ] result = find_optimal_post_office(n, m, connections) assert result == 5 def test_find_optimal_post_office_single_node(): n = 1 m = 0 connections = [] result = find_optimal_post_office(n, m, connections) assert result == 0 def test_find_optimal_post_office_chain_graph(): n = 5 m = 4 connections = [(1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 5, 1)] result = find_optimal_post_office(n, m, connections) assert result == 2","solution":"import heapq def dijkstra(n, edges, start): Helper function using Dijkstra's algorithm to find the shortest paths from \`start\` to all other nodes in the graph. distances = {node: float('inf') for node in range(1, n + 1)} distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in edges[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances def find_optimal_post_office(n, m, connections): This function finds the optimal neighborhood to establish the central post office such that the maximum distance to any other neighborhood is minimized. # Build the adjacency list edges = {i: [] for i in range(1, n + 1)} for u, v, d in connections: edges[u].append((v, d)) edges[v].append((u, d)) # Perform Dijkstra from every node to every other node min_max_distance = float('inf') for i in range(1, n + 1): distances = dijkstra(n, edges, i) max_distance = max(distances.values()) if max_distance < min_max_distance: min_max_distance = max_distance return min_max_distance"},{"question":"from typing import List def largest_plateau(grid: List[List[int]]) -> int: Finds the size of the largest elevation plateau in the grid. >>> grid1 = [ ... [1, 2, 3], ... [4, 1, 1], ... [4, 4, 5] ... ] >>> largest_plateau(grid1) 3 >>> grid2 = [ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ] >>> largest_plateau(grid2) 9 >>> grid3 = [ ... [1, 2, 2], ... [3, 3, 2], ... [3, 3, 2] ... ] >>> largest_plateau(grid3) 4 >>> grid4 = [ ... [1] ... ] >>> largest_plateau(grid4) 1 >>> grid5 = [ ... [4, 4], ... [4, 4] ... ] >>> largest_plateau(grid5) 4 >>> grid6 = [ ... [1, 2], ... [3, 4] ... ] >>> largest_plateau(grid6) 1","solution":"def largest_plateau(grid): Finds the size of the largest elevation plateau in the grid. if not grid: return 0 N = len(grid) M = len(grid[0]) def bfs(x, y, height): queue = [(x, y)] visited.add((x, y)) size = 0 while queue: cx, cy = queue.pop(0) size += 1 for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = cx + dx, cy + dy if 0 <= nx < N and 0 <= ny < M and (nx, ny) not in visited and grid[nx][ny] == height: visited.add((nx, ny)) queue.append((nx, ny)) return size visited = set() max_plateau_size = 0 for i in range(N): for j in range(M): if (i, j) not in visited: plateau_size = bfs(i, j, grid[i][j]) max_plateau_size = max(max_plateau_size, plateau_size) return max_plateau_size # Example usage: # grid = [ # [1, 2, 3], # [4, 1, 1], # [4, 4, 5] # ] # print(largest_plateau(grid)) # Output: 3"},{"question":"def days_to_same_height(n: int, heights: List[int]) -> int: Determine how many days it will take for all flower beds to reach the same height. >>> days_to_same_height(3, [4, 2, 4]) 2 >>> days_to_same_height(5, [1, 2, 3, 4, 5]) 4","solution":"def days_to_same_height(n, heights): max_height = max(heights) days = 0 for height in heights: if height < max_height: days = max(days, max_height - height) return days"},{"question":"def min_sweetness_difference(N: int, sweetness_levels: List[int]) -> int: Determines the minimum possible absolute difference in sweetness levels between two boxes of candies. Parameters: N (int): The number of candies. sweetness_levels (list): A list of integers representing the sweetness levels of the candies. Returns: int: The minimum possible absolute difference in sweetness levels. pass # Example Unit Tests def test_min_sweetness_difference(): assert min_sweetness_difference(4, [1, 2, 3, 4]) == 0 assert min_sweetness_difference(6, [1, 2, 3, 4, 5, 6]) == 1 assert min_sweetness_difference(2, [1, 1]) == 0 assert min_sweetness_difference(4, [5, 5, 5, 5]) == 0 assert min_sweetness_difference(5, [99, 1, 50, 2, 48]) == 0 assert min_sweetness_difference(100, [1]*100) == 0","solution":"def min_sweetness_difference(N, sweetness_levels): Determines the minimum possible absolute difference in sweetness levels between two boxes of candies. Parameters: N (int): The number of candies. sweetness_levels (list): A list of integers representing the sweetness levels of the candies. Returns: int: The minimum possible absolute difference in sweetness levels. total_sweetness = sum(sweetness_levels) # Initialize a DP array dp = [False] * (total_sweetness // 2 + 1) dp[0] = True for sweet in sweetness_levels: for j in range(total_sweetness // 2, sweet - 1, -1): dp[j] = dp[j] or dp[j - sweet] # Find the maximum possible sweetness level for the first box that is less than or equal to total_sweetness // 2 for i in range(total_sweetness // 2, -1, -1): if dp[i]: return total_sweetness - 2 * i return total_sweetness # Example usage: # min_sweetness_difference(4, [1, 2, 3, 4]) # Output: 0"},{"question":"MOD = 10**9 + 7 def fib_mod(n): Compute the value of F(n) modulo 10^9 + 7. F(0) = 0, F(1) = 1 F(n) = F(n-1) + F(n-2) for n  2 :param n: the index of the Fibonacci sequence :type n: int :return: the value of F(n) modulo 10^9 + 7 :rtype: int","solution":"MOD = 10**9 + 7 def fib_mod(n): Compute the value of F(n) modulo 10^9 + 7. F(0) = 0, F(1) = 1 F(n) = F(n-1) + F(n-2) for n  2 :param n: the index of the Fibonacci sequence :type n: int :return: the value of F(n) modulo 10^9 + 7 :rtype: int if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for i in range(2, n + 1): a, b = b, (a + b) % MOD return b"},{"question":"def count_paths(n: int, m: int, grid: List[List[int]]) -> int: Given a room represented by a n x m grid of 0's (free space) and 1's (obstacles), count the number of distinct paths from the top-left corner to the bottom-right corner. Paths can only move right (R) or down (D) and must avoid obstacles. Examples: >>> count_paths(3, 3, [ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) 2 >>> count_paths(3, 3, [ ... [0, 1, 0], ... [1, 0, 0], ... [0, 0, 0] ... ]) 0","solution":"def count_paths(n, m, grid): # If the start or end point is blocked, return 0 if grid[0][0] == 1 or grid[n-1][m-1] == 1: return 0 # Create a dp array initialized to 0 dp = [[0] * m for _ in range(n)] # Initialize the starting point dp[0][0] = 1 for i in range(n): for j in range(m): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[n-1][m-1]"},{"question":"def can_find_universal_winner(n: int, m: int, matches: List[Tuple[int, int]]) -> str: Determine if there exists a player who has won against every other player either directly or indirectly through a sequence of wins. >>> can_find_universal_winner(3, 3, [(1, 2), (2, 3), (1, 3)]) 'Yes' >>> can_find_universal_winner(3, 3, [(1, 2), (2, 3), (3, 1)]) 'No' >>> can_find_universal_winner(4, 4, [(1, 2), (2, 3), (3, 4), (1, 4)]) 'Yes' >>> can_find_universal_winner(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) 'No'","solution":"def can_find_universal_winner(n, m, matches): from collections import defaultdict, deque adj = defaultdict(list) reverse_adj = defaultdict(list) # Build graph and reverse graph for a, b in matches: adj[a].append(b) reverse_adj[b].append(a) def bfs(start, adj_list): visited = set() queue = deque([start]) while queue: node = queue.popleft() for neighbor in adj_list[node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) return visited for player in range(1, n + 1): won_set = bfs(player, adj) reverse_won_set = bfs(player, reverse_adj) if len(won_set) + len(reverse_won_set) == n - 1: return \\"Yes\\" return \\"No\\""},{"question":"def rotate_matrix_90_degrees(matrix): Rotates a given n x n matrix 90 degrees clockwise in place. >>> rotate_matrix_90_degrees([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == [ ... [7, 4, 1], ... [8, 5, 2], ... [9, 6, 3] ... ] >>> rotate_matrix_90_degrees([ ... [1, 2], ... [3, 4] ... ]) == [ ... [3, 1], ... [4, 2] ... ]","solution":"def rotate_matrix_90_degrees(matrix): Rotates a given n x n matrix 90 degrees clockwise in place. n = len(matrix) for i in range(n // 2): for j in range(i, n - i - 1): temp = matrix[i][j] matrix[i][j] = matrix[n - j - 1][i] matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1] matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1] matrix[j][n - i - 1] = temp return matrix"},{"question":"def can_be_palindrome_by_removing_one_char(s: str) -> str: Returns \\"YES\\" if it is possible to make the string a palindrome by removing at most one character, otherwise returns \\"NO\\". >>> can_be_palindrome_by_removing_one_char(\\"abca\\") \\"YESn\\" >>> can_be_palindrome_by_removing_one_char(\\"racecar\\") \\"YESn\\" >>> can_be_palindrome_by_removing_one_char(\\"abc\\") \\"NOn\\" >>> can_be_palindrome_by_removing_one_char(\\"a\\") \\"YESn\\" >>> can_be_palindrome_by_removing_one_char(\\"aa\\") \\"YESn\\" >>> can_be_palindrome_by_removing_one_char(\\"ab\\") \\"YESn\\" >>> can_be_palindrome_by_removing_one_char(\\"cbbcc\\") \\"YESn\\" >>> can_be_palindrome_by_removing_one_char(\\"abcdcba\\") \\"YESn\\" >>> can_be_palindrome_by_removing_one_char(\\"abccba\\") \\"YESn\\" >>> can_be_palindrome_by_removing_one_char(\\"abcddcba\\") \\"YESn\\" pass","solution":"def can_be_palindrome_by_removing_one_char(s): Returns \\"YES\\" if it is possible to make the string a palindrome by removing at most one character, otherwise returns \\"NO\\". def is_palindrome_range(s, left, right): while left < right: if s[left] != s[right]: return False left += 1 right -= 1 return True left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: # We can either remove the left character or the right character return \\"YESn\\" if (is_palindrome_range(s, left + 1, right) or is_palindrome_range(s, left, right - 1)) else \\"NOn\\" left += 1 right -= 1 return \\"YESn\\" # The string is already a palindrome # Sample input print(can_be_palindrome_by_removing_one_char(\\"abca\\")) # Expected output: \\"YESn\\""},{"question":"def add_item(inventory, item, quantity): Adds a specified quantity of the item to the inventory. :param inventory: dict, the current inventory. :param item: str, the item to add. :param quantity: int, the quantity to add. def remove_item(inventory, item, quantity): Removes a specified quantity of the item from the inventory. :param inventory: dict, the current inventory. :param item: str, the item to remove. :param quantity: int, the quantity to remove. def check_inventory(inventory, item): Checks the quantity of a specified item in the inventory. :param inventory: dict, the current inventory. :param item: str, the item to check. :return: int, the quantity of the item. def print_inventory(inventory): Prints all items and their quantities in the inventory. :param inventory: dict, the current inventory. import pytest from solution import add_item, remove_item, check_inventory, print_inventory def test_add_item(): inventory = {} add_item(inventory, \\"apple\\", 10) assert inventory[\\"apple\\"] == 10 add_item(inventory, \\"apple\\", 5) assert inventory[\\"apple\\"] == 15 add_item(inventory, \\"banana\\", 7) assert inventory[\\"banana\\"] == 7 def test_remove_item(): inventory = {\\"apple\\": 10, \\"banana\\": 5} remove_item(inventory, \\"apple\\", 3) assert inventory[\\"apple\\"] == 7 remove_item(inventory, \\"apple\\", 10) assert inventory[\\"apple\\"] == 0 remove_item(inventory, \\"banana\\", 1) assert inventory[\\"banana\\"] == 4 remove_item(inventory, \\"orange\\", 2) def test_check_inventory(): inventory = {\\"apple\\": 10, \\"banana\\": 5} assert check_inventory(inventory, \\"apple\\") == 10 assert check_inventory(inventory, \\"banana\\") == 5 assert check_inventory(inventory, \\"orange\\") == 0 def test_print_inventory(capsys): inventory = {\\"apple\\": 10, \\"banana\\": 5} print_inventory(inventory) captured = capsys.readouterr() assert captured.out == \\"apple: 10nbanana: 5n\\"","solution":"def add_item(inventory, item, quantity): Adds a specified quantity of the item to the inventory. :param inventory: dict, the current inventory. :param item: str, the item to add. :param quantity: int, the quantity to add. if item in inventory: inventory[item] += quantity else: inventory[item] = quantity def remove_item(inventory, item, quantity): Removes a specified quantity of the item from the inventory. :param inventory: dict, the current inventory. :param item: str, the item to remove. :param quantity: int, the quantity to remove. if item in inventory: if inventory[item] > quantity: inventory[item] -= quantity else: inventory[item] = 0 else: print(f\\"Error: {item} does not exist in the inventory.\\") def check_inventory(inventory, item): Checks the quantity of a specified item in the inventory. :param inventory: dict, the current inventory. :param item: str, the item to check. :return: int, the quantity of the item. return inventory.get(item, 0) def print_inventory(inventory): Prints all items and their quantities in the inventory. :param inventory: dict, the current inventory. for item, quantity in inventory.items(): print(f\\"{item}: {quantity}\\")"},{"question":"import heapq from typing import List def minimum_spanning_tree(n: int, W: List[List[int]]) -> int: Computes the total weight of the minimum spanning tree (MST) for a given complete graph represented by an adjacency matrix W using Prim's algorithm. :param n: The number of nodes in the graph :param W: A 2D list representing the weight matrix, where W[i][j] is the weight of the edge between nodes i and j :return: The total weight of the minimum spanning tree pass def test_example_case(): n = 4 W = [ [0, 2, 3, 1], [2, 0, 4, 3], [3, 4, 0, 5], [1, 3, 5, 0] ] assert minimum_spanning_tree(n, W) == 6 def test_small_case(): n = 2 W = [ [0, 1], [1, 0] ] assert minimum_spanning_tree(n, W) == 1 def test_large_case(): n = 5 W = [ [0, 2, 3, 1, 4], [2, 0, 4, 3, 1], [3, 4, 0, 5, 1], [1, 3, 5, 0, 2], [4, 1, 1, 2, 0] ] assert minimum_spanning_tree(n, W) == 5 def test_already_mst_case(): n = 3 W = [ [0, 1, 1], [1, 0, 1], [1, 1, 0] ] assert minimum_spanning_tree(n, W) == 2","solution":"import heapq def minimum_spanning_tree(n, W): Computes the total weight of the minimum spanning tree (MST) for a given complete graph represented by an adjacency matrix W using Prim's algorithm. :param n: The number of nodes in the graph :param W: A 2D list representing the weight matrix, where W[i][j] is the weight of the edge between nodes i and j :return: The total weight of the minimum spanning tree # Array to store the minimum edge weight to include each node in the MST min_edge = [float('inf')] * n # Array to track if a node is included in the MST in_mst = [False] * n # Min-heap to select the edge with the minimum weight heap = [(0, 0)] # (weight, node) min_edge[0] = 0 total_weight = 0 while heap: weight, u = heapq.heappop(heap) # If the node is already included in the MST, continue if in_mst[u]: continue # Mark node u as included in the MST in_mst[u] = True total_weight += weight # Loop over all adjacent nodes v of node u for v in range(n): if not in_mst[v] and W[u][v] < min_edge[v]: min_edge[v] = W[u][v] heapq.heappush(heap, (W[u][v], v)) return total_weight"},{"question":"def min_deletions_to_alternate(s: str) -> int: Returns the minimum number of deletions required to make the string alternate. Args: s (str): Input string composed only of 'X' and 'Y' Returns: int: Minimum number of deletions needed Example: >>> min_deletions_to_alternate(\\"XXYX\\") 1 >>> min_deletions_to_alternate(\\"YYYXXXYXY\\") 4","solution":"def min_deletions_to_alternate(s): Returns the minimum number of deletions required to make the string alternate. Args: s (str): Input string composed only of 'X' and 'Y' Returns: int: Minimum number of deletions needed deletions = 0 for i in range(1, len(s)): if s[i] == s[i - 1]: deletions += 1 return deletions"},{"question":"def largest_square_subgrid(n: int, m: int, grid: List[List[int]]) -> int: Find the size of the largest square subgrid that contains only 1s. >>> largest_square_subgrid(5, 6, [ [1, 0, 1, 0, 0, 1], [1, 0, 1, 1, 1, 1], [1, 1, 1, 1, 1, 0], [1, 0, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1]]) 3 >>> largest_square_subgrid(4, 5, [ [0, 1, 0, 0, 1], [1, 1, 1, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0]]) 2 def test_largest_square_subgrid1(): n = 5 m = 6 grid = [ [1, 0, 1, 0, 0, 1], [1, 0, 1, 1, 1, 1], [1, 1, 1, 1, 1, 0], [1, 0, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1] ] assert largest_square_subgrid(n, m, grid) == 3 def test_largest_square_subgrid2(): n = 4 m = 5 grid = [ [0, 1, 0, 0, 1], [1, 1, 1, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0] ] assert largest_square_subgrid(n, m, grid) == 2 def test_largest_square_subgrid_all_zeros(): n = 3 m = 3 grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert largest_square_subgrid(n, m, grid) == 0 def test_largest_square_subgrid_single_one(): n = 3 m = 3 grid = [ [1, 0, 0], [0, 0, 0], [0, 0, 0] ] assert largest_square_subgrid(n, m, grid) == 1 def test_largest_square_subgrid_full_grid(): n = 2 m = 2 grid = [ [1, 1], [1, 1] ] assert largest_square_subgrid(n, m, grid) == 2 def test_largest_square_subgrid_mixed(): n = 4 m = 4 grid = [ [0, 1, 1, 0], [1, 1, 1, 1], [0, 1, 1, 1], [1, 1, 1, 0] ] assert largest_square_subgrid(n, m, grid) == 2","solution":"def largest_square_subgrid(n, m, grid): if not grid or not n or not m: return 0 dp = [[0] * m for _ in range(n)] max_side = 0 for i in range(n): for j in range(m): if i == 0 or j == 0: dp[i][j] = grid[i][j] elif grid[i][j] == 1: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 else: dp[i][j] = 0 if dp[i][j] > max_side: max_side = dp[i][j] return max_side"},{"question":"def minimum_distinct_temperatures(n: int, temperatures: List[int]) -> int: Returns the minimum number of distinct temperature settings needed to accommodate all preferences. Parameters: n (int): The number of residents. temperatures (list): List of integers representing the temperature preferences of each resident. Returns: int: The minimum number of distinct temperature settings needed. pass from typing import List def test_example_1(): assert minimum_distinct_temperatures(5, [15, 16, 16, 17, 18]) == 4 def test_example_2(): assert minimum_distinct_temperatures(7, [22, 22, 22, 23, 24, 25, 26]) == 5 def test_single_resident(): assert minimum_distinct_temperatures(1, [20]) == 1 def test_all_unique_preferences(): assert minimum_distinct_temperatures(5, [15, 16, 17, 18, 19]) == 5 def test_all_same_preferences(): assert minimum_distinct_temperatures(4, [22, 22, 22, 22]) == 1 def test_large_input(): assert minimum_distinct_temperatures(100000, [15] * 50000 + [30] * 50000) == 2","solution":"def minimum_distinct_temperatures(n, temperatures): Returns the minimum number of distinct temperature settings needed to accommodate all preferences. Parameters: n (int): The number of residents. temperatures (list): List of integers representing the temperature preferences of each resident. Returns: int: The minimum number of distinct temperature settings needed. return len(set(temperatures))"},{"question":"def shortest_path(t: int, test_cases: List[Dict[str, Any]]) -> List[int]: Determine the shortest time required to travel from vertex 0 to vertex n-1. >>> t = 2 >>> test_cases = [{'n': 5, 'm': 6, 'edges': [(0, 1, 1), (1, 2, 2), (2, 4, 3), (0, 3, 4), (3, 4, 2), (1, 3, 7)]}, {'n': 4, 'm': 4, 'edges': [(0, 1, 4), (0, 2, 1), (1, 3, 3), (2, 3, 1)]}] >>> shortest_path(t, test_cases) [6, 2]","solution":"import heapq from collections import defaultdict def dijkstra(n, graph, source, target): Implements Dijkstra's algorithm to find the shortest path in a graph. :param n: Number of vertices :param graph: Graph represented as an adjacency list with weights :param source: Source vertex :param target: Target vertex :return: Shortest path from source to target distances = {i: float('inf') for i in range(n)} distances[source] = 0 priority_queue = [(0, source)] while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) if current_distance > distances[current_vertex]: continue for neighbor, weight in graph[current_vertex]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances[target] def shortest_path(t, test_cases): results = [] for case in test_cases: n, m = case['n'], case['m'] edges = case['edges'] graph = defaultdict(list) for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) shortest_time = dijkstra(n, graph, 0, n-1) results.append(shortest_time) return results"},{"question":"def is_valid_password(password: str) -> str: Determines if the given password string is valid based on the specified criteria. The password must be: 1. Between 8 and 16 characters inclusive. 2. Contain at least one digit. 3. Contain at least one lowercase letter. 4. Contain no spaces. Args: password (str): The password string to validate. Returns: str: \\"VALID\\" if the password meets all the criteria, otherwise \\"INVALID\\". Examples: >>> is_valid_password(\\"password123\\") 'VALID' >>> is_valid_password(\\"12345678\\") 'INVALID' >>> is_valid_password(\\"goodpass123\\") 'VALID' >>> is_valid_password(\\"pass word2\\") 'INVALID'","solution":"def is_valid_password(password): Determines if the given password string is valid based on the specified criteria. if len(password) < 8 or len(password) > 16: return \\"INVALID\\" has_digit = any(char.isdigit() for char in password) has_lower = any(char.islower() for char in password) has_no_space = all(char != ' ' for char in password) if has_digit and has_lower and has_no_space: return \\"VALID\\" else: return \\"INVALID\\""},{"question":"def is_arithmetic_progression_possible(n, a0, d): Determine if it is possible to form a sequence such that the final resulting number is an element of the arithmetic progression with the first term \`a0\` and common difference \`d\`. >>> is_arithmetic_progression_possible(3, 5, 3) YES 1 + 2 = 3 3 + 3 = 6 >>> is_arithmetic_progression_possible(4, 10, 2) NO from typing import List if __name__ == \\"__main__\\": def test_case_1(): # Example 1 n = 3 a0 = 5 d = 3 is_arithmetic_progression_possible(n, a0, d) def test_case_2(): # Example 2 n = 4 a0 = 10 d = 2 is_arithmetic_progression_possible(n, a0, d) def test_case_3(): # Test case with n = 1 and a0 is in AP n = 1 a0 = 1 d = 5 is_arithmetic_progression_possible(n, a0, d) def test_case_4(): # Test case with n = 1 and a0 is not in AP n = 1 a0 = 2 d = 0 is_arithmetic_progression_possible(n, a0, d) def test_case_5(): # Test case with a sequence sum that is not an element of AP n = 5 a0 = 23 d = 5 is_arithmetic_progression_possible(n, a0, d) def test_case_6(): # Test case with d = 0 and a0 in the natural range of numbers n = 5 a0 = 3 d = 0 is_arithmetic_progression_possible(n, a0, d) def test_case_7(): # Test case with d = 0 and a0 outside the natural range of numbers n = 5 a0 = 6 d = 0 is_arithmetic_progression_possible(n, a0, d) test_case_1() test_case_2() test_case_3() test_case_4() test_case_5() test_case_6() test_case_7()","solution":"def is_arithmetic_progression_possible(n, a0, d): # If n is 1 and a0 is in the arithmetic progression, print it if n == 1: if a0 == 1: print(\\"YES\\") return else: print(\\"NO\\") return if d == 0: required_number = a0 if required_number in range(1, n + 1): print(\\"YES\\") for i in range(1, n): print(f\\"{i} + {i + 1} = {i + i + 1}\\") return sequence_sum = (1 + n) * n // 2 # Calculate the first few terms of the arithmetic progression found = False target = None for i in range(n): if sequence_sum == a0 + i * d: found = True target = sequence_sum break if not found: print(\\"NO\\") return print(\\"YES\\") arr = list(range(1, n + 1)) while len(arr) > 1: a = arr.pop(0) b = arr.pop(0) result = a + b print(f\\"{a} + {b} = {result}\\") arr.insert(0, result)"},{"question":"import math from heapq import heappop, heappush from typing import List, Tuple def calculate_minimum_road_construction_cost(N: int, coordinates: List[Tuple[int, int]]) -> float: Calculates the minimum total road construction cost required to connect all the warehouses. Parameters: N (int): The number of warehouses. coordinates (List[Tuple[int, int]]): The list of coordinates of the warehouses. Returns: float: The minimum total road construction cost rounded to 4 decimal places. >>> calculate_minimum_road_construction_cost(4, [(0, 0), (0, 2), (2, 2), (2, 0)]) 6.0 >>> calculate_minimum_road_construction_cost(3, [(1, 1), (4, 5), (7, 8)]) 9.2426 pass def test_example_1(): N = 4 coordinates = [ (0, 0), (0, 2), (2, 2), (2, 0) ] expected_output = 6 assert math.isclose(calculate_minimum_road_construction_cost(N, coordinates), expected_output, abs_tol=1e-4) def test_example_2(): N = 3 coordinates = [ (1, 1), (4, 5), (7, 8) ] expected_output = 9.2426 assert math.isclose(calculate_minimum_road_construction_cost(N, coordinates), expected_output, abs_tol=1e-4) def test_example_3(): N = 2 coordinates = [ (0, 0), (3, 4) ] expected_output = 5 # distance between (0,0) and (3,4) assert math.isclose(calculate_minimum_road_construction_cost(N, coordinates), expected_output, abs_tol=1e-4) def test_long_horizontal_distance(): N = 2 coordinates = [ (-1000000, -1000000), (1000000, -1000000) ] expected_output = 2000000 # The distance between two points assert math.isclose(calculate_minimum_road_construction_cost(N, coordinates), expected_output, abs_tol=1e-4) def test_identical_points(): N = 5 coordinates = [ (1, 1), (1, 1), (1, 1), (1, 1), (1, 1) ] expected_output = 0 # All points are identical assert math.isclose(calculate_minimum_road_construction_cost(N, coordinates), expected_output, abs_tol=1e-4)","solution":"import math from heapq import heappop, heappush def calculate_minimum_road_construction_cost(N, coordinates): def euclidean_distance(p1, p2): return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) adj = [[] for _ in range(N)] for i in range(N): for j in range(i + 1, N): distance = euclidean_distance(coordinates[i], coordinates[j]) adj[i].append((distance, j)) adj[j].append((distance, i)) visited = [False] * N min_heap = [(0, 0)] total_cost = 0 while min_heap: cost, u = heappop(min_heap) if visited[u]: continue visited[u] = True total_cost += cost for next_cost, v in adj[u]: if not visited[v]: heappush(min_heap, (next_cost, v)) return round(total_cost, 4)"},{"question":"from typing import List def min_removals_to_make_good(s: str) -> int: Calculate the minimum number of characters that need to be removed from the string to make it 'good'. >>> min_removals_to_make_good(\\"aab\\") 1 >>> min_removals_to_make_good(\\"abc\\") 0 >>> min_removals_to_make_good(\\"abbcc\\") 2 def process_test_cases(t: int, test_cases: List[str]) -> List[int]: Process multiple test cases. >>> process_test_cases(3, [\\"aab\\", \\"abc\\", \\"abbcc\\"]) [1, 0, 2] >>> process_test_cases(2, [\\"aa\\", \\"bb\\"]) [1, 1] >>> process_test_cases(1, [\\"abcd\\"]) [0] # Unit Tests def test_min_removals_to_make_good(): assert min_removals_to_make_good(\\"aab\\") == 1 assert min_removals_to_make_good(\\"abc\\") == 0 assert min_removals_to_make_good(\\"abbcc\\") == 2 assert min_removals_to_make_good(\\"aaaaa\\") == 4 assert min_removals_to_make_good(\\"ababab\\") == 0 assert min_removals_to_make_good(\\"a\\") == 0 def test_process_test_cases(): assert process_test_cases(3, [\\"aab\\", \\"abc\\", \\"abbcc\\"]) == [1, 0, 2] assert process_test_cases(2, [\\"aa\\", \\"bb\\"]) == [1, 1] assert process_test_cases(1, [\\"abcd\\"]) == [0] def test_edge_cases(): # test the smallest possible input assert min_removals_to_make_good(\\"a\\") == 0 # test identical characters assert min_removals_to_make_good(\\"aaaaa\\") == 4 # test no repeated characters assert min_removals_to_make_good(\\"abcdefgh\\") == 0 # test alternating characters assert min_removals_to_make_good(\\"ababababa\\") == 0 # test the largest possible input (dummy data) assert min_removals_to_make_good(\\"a\\" * 50000) == 49999","solution":"def min_removals_to_make_good(s): Calculate the minimum number of characters that need to be removed from the string to make it 'good'. removals = 0 for i in range(1, len(s)): if s[i] == s[i-1]: removals += 1 return removals def process_test_cases(t, test_cases): Process multiple test cases. results = [] for s in test_cases: results.append(min_removals_to_make_good(s)) return results"},{"question":"def split_array_sums(n: int, m: int, array: List[int]) -> Tuple[int, int]: Returns two integers: the sum of the first m elements and the sum of the remaining n-m elements. >>> split_array_sums(5, 2, [1, 2, 3, 4, 5]) (3, 12) >>> split_array_sums(6, 3, [10, 20, 30, 40, 50, 60]) (60, 150)","solution":"def split_array_sums(n, m, array): Returns two integers: the sum of the first m elements and the sum of the remaining n-m elements. sum_first_m = sum(array[:m]) sum_remaining = sum(array[m:]) return sum_first_m, sum_remaining"},{"question":"def can_delete_all_characters(n: int, s: str) -> str: Determines if it is possible to delete all characters from the string s. Args: n (int): The length of the string. s (str): The string consisting of lowercase English letters. Returns: str: \\"YES\\" if it is possible to delete all characters, otherwise \\"NO\\". >>> can_delete_all_characters(6, 'abccba') 'YES' >>> can_delete_all_characters(5, 'abcde') 'NO' >>> can_delete_all_characters(4, 'aabb') 'YES' >>> can_delete_all_characters(1, 'a') 'NO' >>> can_delete_all_characters(7, 'aaabbbc') 'NO' >>> can_delete_all_characters(0, '') 'YES'","solution":"def can_delete_all_characters(n, s): Determines if it is possible to delete all characters from the string s. Args: n (int): The length of the string. s (str): The string consisting of lowercase English letters. Returns: str: \\"YES\\" if it is possible to delete all characters, otherwise \\"NO\\". from collections import Counter char_count = Counter(s) for count in char_count.values(): if count % 2 != 0: return \\"NO\\" return \\"YES\\""},{"question":"def count_solution(m: int) -> int: Calculate the number of distinct ways to place magical flowers in an M x M grid such that each row and each column contains exactly one flower. >>> count_solution(1) 1 >>> count_solution(2) 2 >>> count_solution(3) 6 >>> count_solution(4) 24 >>> count_solution(5) 120 >>> count_solution(6) 720","solution":"import itertools def count_distinct_arrangements(m): def is_valid(permutation): return len(set(permutation)) == len(permutation) count = 0 for perm in itertools.permutations(range(m)): if is_valid(perm): count += 1 return count def count_solution(m): return count_distinct_arrangements(m) # Example usage: # print(count_solution(4)) # Should output the number of distinct ways"},{"question":"def has_pair_with_sum(N: int, k: int, sequence: list) -> str: Determines if there are two distinct integers in the sequence that sum up to k. Args: N (int): Length of the sequence. k (int): Target sum. sequence (list of int): The sequence of integers. Returns: str: \\"Yes\\" if such a pair exists, otherwise \\"No\\". Examples: >>> has_pair_with_sum(5, 9, [2, 7, 11, 15, 1]) \\"Yes\\" >>> has_pair_with_sum(4, 8, [1, 2, 3, 4]) \\"No\\" >>> has_pair_with_sum(3, -1, [-1, 0, 1]) \\"Yes\\" >>> has_pair_with_sum(5, 100, [10, 20, 30, 40, 50]) \\"No\\"","solution":"def has_pair_with_sum(N, k, sequence): Determines if there are two distinct integers in the sequence that sum up to k. Args: N (int): Length of the sequence. k (int): Target sum. sequence (list of int): The sequence of integers. Returns: str: \\"Yes\\" if such a pair exists, otherwise \\"No\\". seen = set() for num in sequence: if k - num in seen: return \\"Yes\\" seen.add(num) return \\"No\\""},{"question":"def can_rearrange_no_adjacent(s: str) -> str: Determines if a string can be rearranged such that no two adjacent characters are the same. Args: s (str): The input string. Returns: str: \\"YES\\" if possible to rearrange, otherwise \\"NO\\". >>> can_rearrange_no_adjacent(\\"aabbcc\\") \\"YES\\" >>> can_rearrange_no_adjacent(\\"aaab\\") \\"NO\\" >>> can_rearrange_no_adjacent(\\"a\\") \\"YES\\" >>> can_rearrange_no_adjacent(\\"ab\\") \\"YES\\" >>> can_rearrange_no_adjacent(\\"abc\\") \\"YES\\" >>> can_rearrange_no_adjacent(\\"aaaaa\\") \\"NO\\" >>> can_rearrange_no_adjacent(\\"a\\"*500 + \\"b\\"*500) \\"YES\\" >>> can_rearrange_no_adjacent(\\"a\\"*501 + \\"b\\"*499) \\"NO\\"","solution":"from collections import Counter def can_rearrange_no_adjacent(s): Determines if a string can be rearranged such that no two adjacent characters are the same. Args: s (str): The input string. Returns: str: \\"YES\\" if possible to rearrange, otherwise \\"NO\\". if not s: return \\"YES\\" # Count the frequency of each character char_count = Counter(s) # Find the maximum frequency max_freq = max(char_count.values()) # Maximum allowed frequency to be able to rearrange without adjacent same characters max_allowed = (len(s) + 1) // 2 # If the most frequent character exceeds the max allowed, answer is \\"NO\\". if max_freq > max_allowed: return \\"NO\\" return \\"YES\\""},{"question":"def min_subarrays_to_partition(arr, N, K): Determine the minimum number of subarrays required to partition the array such that the sum of each subarray is less than or equal to K. Returns -1 if it is not possible. >>> min_subarrays_to_partition([1, 2, 3, 4, 5, 6], 6, 10) == 3 >>> min_subarrays_to_partition([11, 12, 13], 3, 10) == -1 >>> min_subarrays_to_partition([10, 10, 10], 3, 10) == 3 >>> min_subarrays_to_partition([1, 2, 3, 4, 5, 8], 6, 10) == 3 >>> min_subarrays_to_partition([1, 2, 3], 3, 10**15) == 1 >>> min_subarrays_to_partition([5, 2, 3, 1, 4, 2, 1], 7, 6) == 4 >>> min_subarrays_to_partition([3, 3, 3, 3, 3, 3], 6, 9) == 2","solution":"def min_subarrays_to_partition(arr, N, K): Determine the minimum number of subarrays required to partition the array such that the sum of each subarray is less than or equal to K. Returns -1 if it is not possible. if any(element > K for element in arr): return -1 current_subarray_sum = 0 subarray_count = 1 for element in arr: if current_subarray_sum + element > K: subarray_count += 1 current_subarray_sum = element else: current_subarray_sum += element return subarray_count"},{"question":"class TextEditor: def __init__(self): self.content = \\"\\" self.history = [] self.command_history = [] def type(self, text): self.history.append(self.content) self.content += text self.command_history.append(\\"type\\") def backspace(self, n): self.history.append(self.content) self.content = self.content[:-n] if n <= len(self.content) else \\"\\" self.command_history.append(\\"backspace\\") def undo(self): if self.history: self.content = self.history.pop() self.command_history.pop() def process_text_editor_commands(T, test_cases): Implement a text editor with support for undo operations. The text editor initially contains an empty string. You need to write a program to process a series of commands that modify the text editor's content or perform an undo operation. >>> process_text_editor_commands(1, [[\\"type hello\\", \\"type world\\", \\"backspace 5\\", \\"type new\\", \\"undo\\"]]) == [\\"hello\\"] >>> process_text_editor_commands(1, [[\\"type abc\\", \\"backspace 2\\", \\"undo\\"]]) == [\\"abc\\"] results = [] for commands in test_cases: editor = TextEditor() for command in commands: parts = command.split() action = parts[0] if action == \\"type\\": x = \\" \\".join(parts[1:]) editor.type(x) elif action == \\"backspace\\": n = int(parts[1]) editor.backspace(n) elif action == \\"undo\\": editor.undo() results.append(editor.content) return results def main(): import sys input = sys.stdin.read data = input().splitlines() T = int(data[0]) index = 1 test_cases = [] for _ in range(T): N = int(data[index]) commands = [] for j in range(N): commands.append(data[index + 1 + j]) test_cases.append(commands) index += 1 + N results = process_text_editor_commands(T, test_cases) for result in results: print(result)","solution":"class TextEditor: def __init__(self): self.content = \\"\\" self.history = [] self.command_history = [] def type(self, text): self.history.append(self.content) self.content += text self.command_history.append(\\"type\\") def backspace(self, n): self.history.append(self.content) self.content = self.content[:-n] if n <= len(self.content) else \\"\\" self.command_history.append(\\"backspace\\") def undo(self): if self.history: self.content = self.history.pop() self.command_history.pop() def process_text_editor_commands(T, test_cases): results = [] for commands in test_cases: editor = TextEditor() for command in commands: parts = command.split() action = parts[0] if action == \\"type\\": x = \\" \\".join(parts[1:]) editor.type(x) elif action == \\"backspace\\": n = int(parts[1]) editor.backspace(n) elif action == \\"undo\\": editor.undo() results.append(editor.content) return results def main(): import sys input = sys.stdin.read data = input().splitlines() T = int(data[0]) index = 1 test_cases = [] for _ in range(T): N = int(data[index]) commands = [] for j in range(N): commands.append(data[index + 1 + j]) test_cases.append(commands) index += 1 + N results = process_text_editor_commands(T, test_cases) for result in results: print(result)"},{"question":"def largest_square(n: int, grid: List[str]) -> int: Find the size of the largest square sub-grid that consists of only empty cells. :param n: int, the size of the grid (n x n) :param grid: list of str, each string represents a row of the grid :return: int, the side length of the largest square of empty cells >>> largest_square(5, [\\".....\\", \\".#.\\", \\".....\\", \\".#...\\", \\".....\\"]) 3 >>> largest_square(4, [\\"#..#\\", \\"....\\", \\"....\\", \\"....\\"]) 3 pass # Implementation goes here","solution":"def largest_square(n, grid): Find the size of the largest square sub-grid that consists of only empty cells. :param n: int, the size of the grid (n x n) :param grid: list of str, each string represents a row of the grid :return: int, the side length of the largest square of empty cells if n == 0: return 0 dp = [[0] * n for _ in range(n)] max_side = 0 # Populate the DP table for i in range(n): for j in range(n): if grid[i][j] == '.': if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) else: dp[i][j] = 0 return max_side"},{"question":"def calculate_midpoints(n, paths): Calculate the exact midpoint of each walking path. Args: n (int): The number of walking paths. paths (List[Tuple[int, int, int, int]]): The list of endpoints for each path. Returns: List[Tuple[float, float]]: A list of midpoints for each path, with coordinates rounded to one decimal place. >>> calculate_midpoints(3, [(0, 0, 2, 2), (-1, -1, 1, 1), (4, 5, 7, 8)]) [(1.0, 1.0), (0.0, 0.0), (5.5, 6.5)] >>> calculate_midpoints(2, [(2, 3, 4, 3), (1, 1, 5, 5)]) [(3.0, 3.0), (3.0, 3.0)] # Your code here","solution":"def calculate_midpoints(n, paths): midpoints = [] for x1, y1, x2, y2 in paths: mx = (x1 + x2) / 2 my = (y1 + y2) / 2 midpoints.append((round(mx, 1), round(my, 1))) return midpoints # Example usage: # paths = [(0, 0, 2, 2), (-1, -1, 1, 1), (4, 5, 7, 8)] # n = len(paths) # print(calculate_midpoints(n, paths)) # Expected output: # [(1.0, 1.0), (0.0, 0.0), (5.5, 6.5)]"},{"question":"def min_cost_subgrid(m: int, n: int, cost: List[List[int]]) -> int: Calculate the minimum cost of planting crops in any rectangular subgrid of the given land. >>> min_cost_subgrid(4, 5, [ [1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20] ]) 1 >>> min_cost_subgrid(3, 3, [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ]) 0 >>> min_cost_subgrid(3, 3, [ [1, 2, 1], [2, 100, 2], [1, 2, 1] ]) 1 >>> min_cost_subgrid(2, 2, [ [1000, 1000], [1000, 1000] ]) 1000 >>> min_cost_subgrid(3, 4, [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12] ]) 1 >>> min_cost_subgrid(1, 1, [ [42] ]) 42","solution":"def min_cost_subgrid(m, n, cost): # Compute the cumulative sum cum_sum = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): cum_sum[i][j] = cost[i-1][j-1] + cum_sum[i-1][j] + cum_sum[i][j-1] - cum_sum[i-1][j-1] min_cost = float('inf') # Loop through all possible subgrids for start_row in range(1, m + 1): for end_row in range(start_row, m + 1): for start_col in range(1, n + 1): for end_col in range(start_col, n + 1): subgrid_sum = (cum_sum[end_row][end_col] - cum_sum[start_row-1][end_col] - cum_sum[end_row][start_col-1] + cum_sum[start_row-1][start_col-1]) min_cost = min(min_cost, subgrid_sum) return min_cost"},{"question":"def classify_number(n: int) -> str: Classify the number as POSITIVE, NEGATIVE, or ZERO. >>> classify_number(5) \\"POSITIVE\\" >>> classify_number(-3) \\"NEGATIVE\\" >>> classify_number(0) \\"ZERO\\" ...","solution":"def classify_number(n): Classify the number as POSITIVE, NEGATIVE, or ZERO. :param n: An integer number :return: A string classification (\\"POSITIVE\\", \\"NEGATIVE\\", \\"ZERO\\") if n > 0: return \\"POSITIVE\\" elif n < 0: return \\"NEGATIVE\\" else: return \\"ZERO\\""},{"question":"from typing import List, Tuple def max_coins(N: int, M: int, tunnels: List[Tuple[int, int]], coins: List[int]) -> int: Determine the maximum number of coins you can collect on a single trip through the caves. >>> max_coins(3, 2, [(1, 2), (2, 3)], [10, 5, 15]) 30 >>> max_coins(4, 3, [(1, 2), (2, 3), (3, 4)], [1, 2, 3, 4]) 10","solution":"def max_coins(N, M, tunnels, coins): from collections import defaultdict # Build the graph graph = defaultdict(list) for a, b in tunnels: graph[a].append(b) graph[b].append(a) # DFS to explore each component and calculate its total coins def dfs(cave, visited): stack = [cave] total_coins = 0 while stack: v = stack.pop() if not visited[v]: visited[v] = True total_coins += coins[v-1] for neighbor in graph[v]: if not visited[neighbor]: stack.append(neighbor) return total_coins max_coins_collected = 0 visited = [False] * (N + 1) # Traverse all caves using DFS for i in range(1, N + 1): if not visited[i]: max_coins_collected = max(max_coins_collected, dfs(i, visited)) return max_coins_collected"},{"question":"from typing import List def min_removals_to_avoid_repeats(s: str, k: int) -> int: Calculate the minimum number of characters that need to be removed from the string so that every substring of length k has no repeating characters. >>> min_removals_to_avoid_repeats(3, \\"abcabc\\") == 0 >>> min_removals_to_avoid_repeats(2, \\"abab\\") == 0 >>> min_removals_to_avoid_repeats(4, \\"aabbcc\\") == 2","solution":"def min_removals_to_avoid_repeats(s, k): Calculate the minimum number of characters that need to be removed from the string so that every substring of length k has no repeating characters. n = len(s) min_removals = 0 for i in range(n - k + 1): substring = s[i:i+k] unique_chars = set(substring) removals_needed = len(substring) - len(unique_chars) min_removals = max(min_removals, removals_needed) return min_removals"},{"question":"def shortest_path(n, m, edges, start, end): Determine the shortest path from the start point to the end point in a cave system. Args: n (int): Number of points of interest. m (int): Number of bidirectional paths. edges (list of tuples): Each tuple contains three integers representing a path between two points and the length of that path. start (int): Starting point. end (int): Ending point. Returns: int: The minimum distance required to travel from the start point to the end point. Examples: >>> shortest_path(5, 6, [(1, 2, 4), (1, 3, 2), (2, 3, 5), (2, 4, 10), (3, 4, 3), (3, 5, 7)], 1, 4) 5 >>> shortest_path(3, 3, [(1, 2, 1), (2, 3, 2), (1, 3, 5)], 1, 3) 3 >>> shortest_path(4, 5, [(1, 2, 3), (1, 4, 10), (2, 3, 2), (3, 4, 5), (2, 4, 7)], 1, 3) 5","solution":"import heapq def shortest_path(n, m, edges, start, end): graph = {i: [] for i in range(1, n + 1)} for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) # Dijkstra's algorithm pq = [(0, start)] dist = {i: float('inf') for i in range(1, n + 1)} dist[start] = 0 while pq: current_dist, current_point = heapq.heappop(pq) if current_dist > dist[current_point]: continue for neighbor, weight in graph[current_point]: distance = current_dist + weight if distance < dist[neighbor]: dist[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return dist[end] # Example usage: # n = 5 # m = 6 # edges = [(1, 2, 4), (1, 3, 2), (2, 3, 5), (2, 4, 10), (3, 4, 3), (3, 5, 7)] # start = 1 # end = 4 # print(shortest_path(n, m, edges, start, end)) # Output: 5"},{"question":"from typing import List, Tuple def can_increase_amount(n: int, m: int, conversions: List[Tuple[int, int, float]]) -> str: Determines if there exists a sequence of conversions starting and ending with the same currency that results in a higher amount of the initial currency. Args: n : int : number of different currencies m : int : number of direct conversion rates conversions : List[Tuple[int, int, float]] : list of conversion rates (a, b, w) which denote that 1 unit of currency a can be converted into w units of currency b. Returns: str : \\"Yes\\" if there is a sequence of conversions that result in more units of the initial currency, otherwise \\"No\\". Examples: >>> can_increase_amount(3, 3, [(1, 2, 1.2), (2, 3, 0.8), (3, 1, 1.1)]) \\"Yes\\" >>> can_increase_amount(3, 3, [(1, 2, 0.9), (2, 3, 0.9), (3, 1, 0.9)]) \\"No\\"","solution":"def can_increase_amount(n, m, conversions): Determines if there exists a sequence of conversions starting and ending with the same currency that results in a higher amount of the initial currency. Uses Bellman-Ford algorithm to detect positive weight cycles in the graph. # Creating a list of edges with their weights from conversions edges = [] for a, b, w in conversions: edges.append((a-1, b-1, w)) # Initialize distances with negative infinity for each node except the source distances = [float('-inf')] * n for src in range(n): distances[src] = 1.0 # Set starting point currency to 1 unit # Relaxing edges up to n-1 times for _ in range(n - 1): for u, v, w in edges: if distances[u] < float('-inf') / w: continue # If this path can increase the existing path, update it if distances[u] * w > distances[v]: distances[v] = distances[u] * w # Checking for cycles for u, v, w in edges: if distances[u] < float('-inf') / w: continue if distances[u] * w > distances[v]: return \\"Yes\\" # Reset distances for the next source vertex distances = [float('-inf')] * n return \\"No\\""},{"question":"class KingQuery: def __init__(self, n, values, roads): Initialize the KingQuery class with cities, their initial values, and bidirectional roads. Args: n (int): Number of cities. values (List[int]): Initial values of the cities. roads (List[Tuple[int, int]]): List of tuples indicating the roads between cities. def update_value(self, city, value): Update the value of a specific city. Args: city (int): The city to update. value (int): The new value of the city. def query_total_value(self, city): Query the total value of a specific city and all cities directly connected to it. Args: city (int): The city to query. Returns: int: The total value of the city and its directly connected cities. if __name__ == '__main__': # Example usage n = 5 values = [10, 20, 30, 40, 50] roads = [(1, 2), (1, 3), (3, 4), (3, 5)] king_query = KingQuery(n, values, roads) # Example operations print(king_query.query_total_value(3)) # Output should be 130 king_query.update_value(3, 100) print(king_query.query_total_value(3)) # Output should be 200 king_query.update_value(2, 200) print(king_query.query_total_value(2)) # Output should be 210","solution":"class KingQuery: def __init__(self, n, values, roads): self.n = n self.values = values self.adj = [[] for _ in range(n + 1)] for u, v in roads: self.adj[u].append(v) self.adj[v].append(u) def update_value(self, city, value): self.values[city - 1] = value def query_total_value(self, city): total_value = self.values[city - 1] for neighbor in self.adj[city]: total_value += self.values[neighbor - 1] return total_value"},{"question":"def min_operations_to_all_zeros(s: str) -> int: Returns the minimum number of operations required to make the binary string consist of all '0's. >>> min_operations_to_all_zeros(\\"1101\\") 2 >>> min_operations_to_all_zeros(\\"0000\\") 0","solution":"def min_operations_to_all_zeros(s): Returns the minimum number of operations required to make the binary string consist of all '0's. if '1' not in s: return 0 # Count contiguous segments of '1's count_ones = 0 in_one_segment = False for char in s: if char == '1': if not in_one_segment: count_ones += 1 in_one_segment = True else: in_one_segment = False return count_ones"},{"question":"def count_turned_on_bulbs(n: int, m: int, operations: List[Tuple[int, int, str]]) -> int: Determine the number of bulbs that are turned on after performing all the operations. Args: n : int : the total number of bulbs m : int : the number of operations operations : List[Tuple[int, int, str]] : list of operations where each operation consists of start, end and direction Returns: int : the number of bulbs that are turned on Example: >>> count_turned_on_bulbs(10, 3, [(1, 5, \\"right\\"), (3, 7, \\"left\\"), (6, 10, \\"right\\")]) 10 >>> count_turned_on_bulbs(8, 2, [(1, 4, \\"right\\"), (5, 8, \\"left\\")]) 8 from typing import List, Tuple def test_case_1(): n = 10 m = 3 operations = [ (1, 5, \\"right\\"), (3, 7, \\"left\\"), (6, 10, \\"right\\") ] assert count_turned_on_bulbs(n, m, operations) == 10 def test_case_2(): n = 8 m = 2 operations = [ (1, 4, \\"right\\"), (5, 8, \\"left\\") ] assert count_turned_on_bulbs(n, m, operations) == 8 def test_case_3(): n = 5 m = 1 operations = [ (1, 5, \\"right\\") ] assert count_turned_on_bulbs(n, m, operations) == 5 def test_case_4(): n = 10 m = 4 operations = [ (1, 2, \\"right\\"), (3, 4, \\"right\\"), (5, 6, \\"right\\"), (7, 8, \\"right\\") ] assert count_turned_on_bulbs(n, m, operations) == 8 def test_case_5(): n = 7 m = 2 operations = [ (2, 5, \\"right\\"), (4, 6, \\"left\\") ] assert count_turned_on_bulbs(n, m, operations) == 5","solution":"def count_turned_on_bulbs(n, m, operations): bulbs = [False] * n for op in operations: start, end, direction = op if direction == \\"right\\": for i in range(start - 1, end): bulbs[i] = True elif direction == \\"left\\": for i in range(end - 1, start - 2, -1): bulbs[i] = True return sum(bulbs)"},{"question":"from typing import List, Tuple def shortest_distance_to_land(grid: List[List[int]], start_x: int, start_y: int) -> int: Find the shortest distance from a given cell to any land. :param grid: List[List[int]]: m x n grid of land and water cells :param start_x: int: starting cell's x coordinate :param start_y: int: starting cell's y coordinate :return: int: shortest distance to any land or -1 if not reachable >>> shortest_distance_to_land([[0, 0, 0], [0, 1, 0], [0, 0, 1]], 0, 0) 1 >>> shortest_distance_to_land([[0, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, 0], [0, 0, 0, 1]], 2, 2) 1 >>> shortest_distance_to_land([[1]], 0, 0) 0 >>> shortest_distance_to_land([[0, 0, 0], [0, 0, 0], [0, 0, 0]], 1, 1) -1 pass def process_test_cases(test_cases: List[Tuple[List[List[int]], Tuple[int, int]]]) -> List[int]: Process multiple test cases to find the shortest distance to any land for each starting cell. :param test_cases: List[Tuple[List[List[int]], Tuple[int, int]]]: list of test cases, each containing a grid and a starting cell :return: List[int]: shortest distances or -1 for each test case >>> process_test_cases([([[0, 0, 0], [0, 1, 0], [0, 0, 1]], (0, 0)), ([[0, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, 0], [0, 0, 0, 1]], (2, 2)), ([[1]], (0, 0)), ([[0, 0, 0], [0, 0, 0], [0, 0, 0]], (1, 1))]) [1, 1, 0, -1] pass","solution":"from collections import deque def shortest_distance_to_land(grid, start_x, start_y): m = len(grid) n = len(grid[0]) if grid[start_x][start_y] == 1: return 0 directions = [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)] queue = deque([(start_x, start_y, 0)]) visited = set((start_x, start_y)) while queue: x, y, dist = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited: visited.add((nx, ny)) if grid[nx][ny] == 1: return dist + 1 queue.append((nx, ny, dist + 1)) return -1 def process_test_cases(test_cases): results = [] for grid, (x, y) in test_cases: result = shortest_distance_to_land(grid, x, y) results.append(result) return results"},{"question":"from typing import List, Tuple def check_reservations_for_book(existing_reservations: List[Tuple[int, int]], queries: List[Tuple[int, int]]) -> List[str]: Check whether a requested reservation overlaps with any existing reservations for the same book. Args: existing_reservations: A list of tuples, where each tuple contains two integers representing the start and end date of an existing reservation. queries: A list of tuples, where each tuple contains two integers representing the start and end dates of a requested reservation. Returns: A list of strings \\"yes\\" or \\"no\\" indicating if there is an overlap for each query. >>> check_reservations_for_book([(1, 5), (10, 15), (20, 25)], [(2, 6), (15, 20)]) [\\"yes\\", \\"yes\\"] >>> check_reservations_for_book([], [(2, 6), (15, 20)]) [\\"no\\", \\"no\\"] pass def manage_library_reservations(input_data: List[int]) -> List[str]: Manage library reservations and determine if requested reservations overlap with existing ones. Args: input_data: A list of integers representing multiple test cases and their corresponding reservation data. Returns: A list of strings \\"yes\\" or \\"no\\" indicating the result of each reservation query. >>> manage_library_reservations([1, 3, 1, 5, 10, 15, 20, 25, 2, 2, 6, 15, 20, -1]) [\\"yes\\", \\"yes\\"] >>> manage_library_reservations([1, 0, 2, 1, 2, 3, 4, -1]) [\\"no\\", \\"no\\"] pass","solution":"def check_reservations_for_book(existing_reservations, queries): results = [] sorted_reservations = sorted(existing_reservations) for rstart, rend in queries: overlap_found = False for estart, eend in sorted_reservations: if not (rend < estart or rstart > eend): overlap_found = True break if overlap_found: results.append(\\"yes\\") else: results.append(\\"no\\") return results def manage_library_reservations(input_data): output = [] i = 0 while i < len(input_data): b = input_data[i] if b == -1: break i += 1 for _ in range(b): n = input_data[i] i += 1 existing_reservations = [] for _ in range(n): start, end = input_data[i], input_data[i+1] existing_reservations.append((start, end)) i += 2 q = input_data[i] i += 1 queries = [] for _ in range(q): rstart, rend = input_data[i], input_data[i+1] queries.append((rstart, rend)) i += 2 results = check_reservations_for_book(existing_reservations, queries) output.extend(results) return output"},{"question":"def find_kth_ranked_key(t, test_cases): Find the ranking of a particular key by computing the sum of the tons of gold stored in each gate, multiplied by their individual magical intensity factors, and then sorting these keys from highest to lowest. :param t: Integer representing the number of test cases. :param test_cases: List of tuples, each containing: - n: Integer, the number of gates. - golds: List of integers, representing the tons of gold stored in each gate. - intensities: List of integers, representing the magical intensity factor of each gate. - k: Integer, the ranking position to determine. :return: List of integers, each representing the key at the k-th position in the sorted list of computed keys for each test case. Examples: >>> find_kth_ranked_key(2, [(3, [7, 1, 3], [2, 3, 4], 2), (4, [1, 2, 3, 4], [4, 3, 2, 1], 3)]) [12, 4] >>> find_kth_ranked_key(1, [(3, [9, 5, 6], [7, 2, 3], 1)]) [63] >>> find_kth_ranked_key(1, [(5, [8, 5, 3, 2, 1], [3, 2, 4, 5, 6], 4)]) [10]","solution":"def find_kth_ranked_key(t, test_cases): results = [] for case in test_cases: n, golds, intensities, k = case keys = [golds[i] * intensities[i] for i in range(n)] keys.sort(reverse=True) results.append(keys[k-1]) return results"},{"question":"from typing import List, Tuple def count_ways_to_select_nodes(n: int, k: int, edges: List[Tuple[int, int]]) -> int: Determine the number of ways to select \`k\` nodes in a tree such that the distance between any two selected nodes is at least 2. Args: n (int): Number of nodes in the tree. k (int): Number of nodes to select. edges (List[Tuple[int, int]]): List of edges describing the tree. Returns: int: Number of ways to select \`k\` nodes with the required distance condition. Example: >>> count_ways_to_select_nodes(5, 2, [(1, 2), (1, 3), (3, 4), (3, 5)]) 6","solution":"import itertools def count_ways_to_select_nodes(n, k, edges): from collections import defaultdict, deque def bfs(graph, start): distances = [-1] * (n + 1) queue = deque([start]) distances[start] = 0 while queue: node = queue.popleft() for neighbor in graph[node]: if distances[neighbor] == -1: distances[neighbor] = distances[node] + 1 queue.append(neighbor) return distances graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) all_nodes = list(range(1, n + 1)) valid_combinations = 0 for combination in itertools.combinations(all_nodes, k): for i in range(k): valid = True distances = bfs(graph, combination[i]) for j in range(i + 1, k): if distances[combination[j]] < 2: valid = False break if not valid: break if valid: valid_combinations += 1 return valid_combinations"},{"question":"def is_palindrome(s: str) -> str: Determines if the given string s is a palindrome. Args: s (str): The input string consisting of lowercase English letters. Returns: str: \\"YES\\" if s is a palindrome, \\"NO\\" otherwise. >>> is_palindrome(\\"level\\") \\"YES\\" >>> is_palindrome(\\"hello\\") \\"NO\\"","solution":"def is_palindrome(s): Determines if the given string s is a palindrome. Args: s (str): The input string consisting of lowercase English letters. Returns: str: \\"YES\\" if s is a palindrome, \\"NO\\" otherwise. if s == s[::-1]: return \\"YES\\" else: return \\"NO\\""},{"question":"def count_ways_to_reach_end(n: int, m: int, grid: List[List[str]]) -> int: Returns the number of ways to reach from the top-left corner to the bottom-right corner of the grid. >>> count_ways_to_reach_end(3, 3, [['.', '.', '.'], ['.', '*', '.'], ['.', '.', '.']]) 2 >>> count_ways_to_reach_end(2, 2, [['.', '*'], ['.', '.']]) 0","solution":"def count_ways_to_reach_end(n, m, grid): Returns the number of ways to reach from the top-left corner to the bottom-right corner of the grid. if grid[0][0] == '*' or grid[n-1][m-1] == '*': return 0 dp = [[0] * m for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(m): if grid[i][j] == '*': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[n-1][m-1] # Sample usage n, m = 3, 3 grid = [ ['.', '.', '.'], ['.', '*', '.'], ['.', '.', '.'] ] print(count_ways_to_reach_end(n, m, grid)) # Output: 2 n, m = 2, 2 grid = [ ['.', '*'], ['.', '.'] ] print(count_ways_to_reach_end(n, m, grid)) # Output: 0 n, m = 3, 3 grid = [ ['*', '.', '.'], ['.', '*', '.'], ['.', '.', '.'] ] print(count_ways_to_reach_end(n, m, grid)) # Output: 0"},{"question":"import heapq import sys from typing import List, Tuple, Dict def dijkstra(n: int, adj_list: List[List[Tuple[int, int]]], start: int, end: int) -> Tuple[int, List[int]]: Find the shortest path in a graph using Dijkstra's algorithm. Args: n: Number of vertices adj_list: Adjacency list of the graph where adj_list[i] is a list of (neighbor, weight) tuples start: Start vertex end: End vertex Returns: A tuple containing the length of the shortest path and a list of vertices in one of the shortest paths. If there is no path, returns -1 and an empty list. pass def shortest_paths(datasets: List[Dict[str, any]]) -> List[Tuple[int, List[int]]]: Process multiple datasets of graph information and find the shortest paths for each. Args: datasets: A list of dictionaries, each containing: 'n': number of vertices 'm': number of edges 'edges': list of edges in (u, v, w) format 's': start vertex 't': end vertex Returns: A list of tuples, where each tuple contains the length of the shortest path and the path itself. pass def process_input(input_string: str) -> List[Dict[str, any]]: Process input string to extract datasets. Args: input_string: A string containing the graph data for multiple datasets. Returns: A list of dictionaries, each representing a dataset. pass def generate_output(results: List[Tuple[int, List[int]]]) -> str: Generate output string from the results of shortest_paths function. Args: results: A list of tuples, each containing the length of the shortest path and the path itself. Returns: A string representing the output for the given results. pass def main(): import sys input_string = sys.stdin.read() datasets = process_input(input_string) results = shortest_paths(datasets) output = generate_output(results) print(output) # Test cases def test_process_input(): input_string = 5 6 0 1 2 1 2 4 2 3 1 3 0 7 3 4 3 1 4 5 0 4 3 3 0 1 1 1 2 1 0 2 5 0 2 # expected_output = [ { 'n': 5, 'm': 6, 'edges': [(0, 1, 2), (1, 2, 4), (2, 3, 1), (3, 0, 7), (3, 4, 3), (1, 4, 5)], 's': 0, 't': 4 }, { 'n': 3, 'm': 3, 'edges': [(0, 1, 1), (1, 2, 1), (0, 2, 5)], 's': 0, 't': 2 } ] datasets = process_input(input_string) assert datasets == expected_output def test_dijkstra(): n = 5 adj_list = [ [(1, 2), (3, 7)], [(0, 2), (2, 4), (4, 5)], [(1, 4), (3, 1)], [(0, 7), (2, 1), (4, 3)], [(1, 5), (3, 3)] ] start, end = 0, 4 expected_length = 7 expected_path = [0, 1, 4] length, path = dijkstra(n, adj_list, start, end) assert length == expected_length assert path == expected_path def test_shortest_paths(): datasets = [ { 'n': 5, 'm': 6, 'edges': [(0, 1, 2), (1, 2, 4), (2, 3, 1), (3, 0, 7), (3, 4, 3), (1, 4, 5)], 's': 0, 't': 4 }, { 'n': 3, 'm': 3, 'edges': [(0, 1, 1), (1, 2, 1), (0, 2, 5)], 's': 0, 't': 2 } ] expected_output = [(7, [0, 1, 4]), (2, [0, 1, 2])] results = shortest_paths(datasets) assert results == expected_output def test_generate_output(): results = [(7, [0, 1, 4]), (2, [0, 1, 2])] expected_output = \\"7n0 1 4n2n0 1 2\\" output = generate_output(results) assert output == expected_output","solution":"import heapq import sys def dijkstra(n, adj_list, start, end): dist = [sys.maxsize] * n dist[start] = 0 prev = [-1] * n pq = [(0, start)] while pq: current_dist, u = heapq.heappop(pq) if current_dist > dist[u]: continue for v, weight in adj_list[u]: distance = current_dist + weight if distance < dist[v]: dist[v] = distance prev[v] = u heapq.heappush(pq, (distance, v)) if dist[end] == sys.maxsize: return -1, [] # Reconstruct the path path = [] u = end while u != -1: path.append(u) u = prev[u] path.reverse() return dist[end], path def shortest_paths(datasets): results = [] for dataset in datasets: n, m = dataset['n'], dataset['m'] adj_list = [[] for _ in range(n)] for u, v, w in dataset['edges']: adj_list[u].append((v, w)) adj_list[v].append((u, w)) s, t = dataset['s'], dataset['t'] length, path = dijkstra(n, adj_list, s, t) results.append((length, path)) return results def process_input(input_string): datasets = [] lines = input_string.strip().split('n') i = 0 while i < len(lines): if lines[i] == '#': break n, m = map(int, lines[i].split()) i += 1 edges = [] for _ in range(m): u, v, w = map(int, lines[i].split()) edges.append((u, v, w)) i += 1 s, t = map(int, lines[i].split()) i += 1 datasets.append({'n': n, 'm': m, 'edges': edges, 's': s, 't': t}) return datasets def generate_output(results): output = [] for length, path in results: if length == -1: output.append(\\"-1\\") else: output.append(str(length)) output.append(\\" \\".join(map(str, path))) return \\"n\\".join(output) def main(): import sys input_string = sys.stdin.read() datasets = process_input(input_string) results = shortest_paths(datasets) output = generate_output(results) print(output)"},{"question":"from typing import List, Tuple def minimum_distance_to_travel(N: int, M: int, roads: List[Tuple[int, int, int]]) -> int: Find the minimum total distance the mailman has to travel to deliver letters to all houses. Args: N (int): the number of houses M (int): the number of roads roads (List[Tuple[int, int, int]]): each tuple contains three integers u, v, d, representing a road between houses u and v with distance d. Returns: int: the minimum distance the mailman has to travel to deliver letters to all houses Example: >>> minimum_distance_to_travel(4, 5, [(1, 2, 5), (1, 3, 10), (1, 4, 9), (2, 3, 8), (3, 4, 6)]) 19 >>> minimum_distance_to_travel(1, 0, []) 0 >>> minimum_distance_to_travel(2, 1, [(1, 2, 4)]) 4 >>> minimum_distance_to_travel(3, 3, [(1, 2, 1), (2, 3, 1), (1, 3, 2)]) 2 >>> minimum_distance_to_travel(3, 3, [(1, 2, 9999), (2, 3, 9999), (1, 3, 9998)]) 19997 pass def test_sample_input(): N, M = 4, 5 roads = [(1, 2, 5), (1, 3, 10), (1, 4, 9), (2, 3, 8), (3, 4, 6)] assert minimum_distance_to_travel(N, M, roads) == 19 def test_single_house(): N, M = 1, 0 roads = [] assert minimum_distance_to_travel(N, M, roads) == 0 def test_two_houses(): N, M = 2, 1 roads = [(1, 2, 4)] assert minimum_distance_to_travel(N, M, roads) == 4 def test_disconnected_graph(): N, M = 3, 3 roads = [(1, 2, 1), (2, 3, 1), (1, 3, 2)] assert minimum_distance_to_travel(N, M, roads) == 2 def test_large_numbers(): N, M = 3, 3 roads = [(1, 2, 9999), (2, 3, 9999), (1, 3, 9998)] assert minimum_distance_to_travel(N, M, roads) == 19997","solution":"def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) def union(parent, rank, x, y): rootX = find(parent, x) rootY = find(parent, y) if rank[rootX] < rank[rootY]: parent[rootX] = rootY elif rank[rootX] > rank[rootY]: parent[rootY] = rootX else: parent[rootY] = rootX rank[rootX] += 1 def kruskal(n, edges): parent = [] rank = [] for node in range(n): parent.append(node) rank.append(0) edges = sorted(edges, key=lambda edge: edge[2]) mst_weight = 0 mst_edges = 0 for edge in edges: u, v, weight = edge if find(parent, u) != find(parent, v): union(parent, rank, u, v) mst_weight += weight mst_edges += 1 if mst_edges == n - 1: break return mst_weight def minimum_distance_to_travel(N, M, roads): edges = [(u-1, v-1, d) for u, v, d in roads] return kruskal(N, edges) # Example usage N, M = 4, 5 roads = [(1, 2, 5), (1, 3, 10), (1, 4, 9), (2, 3, 8), (3, 4, 6)] print(minimum_distance_to_travel(N, M, roads))"},{"question":"def max_subarray_sum(arr: List[int], queries: List[Tuple[int, int]]) -> List[int]: Compute the maximum subarray sum for the specified range of the array for each query. Args: arr (List[int]): Array of positive integers. queries (List[Tuple[int, int]]): List of tuples where each tuple contains two integers l and r. Returns: List[int]: List of maximum subarray sums for each query. >>> arr = [1, 2, -3, 4, 5, -6, 7, 8, -9, 10] >>> queries = [(0, 4), (2, 6), (3, 9)] >>> max_subarray_sum(arr, queries) [9, 10, 19]","solution":"def max_subarray_sum(arr, queries): def kadane(array): max_sum = current_sum = array[0] for num in array[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum results = [] for l, r in queries: subarray = arr[l:r+1] max_sum = kadane(subarray) results.append(max_sum) return results"},{"question":"def max_possible_integer_after_operation(n: int, array: List[int]) -> int: Returns the maximum possible integer in the modified array after performing the operation of summing a contiguous subarray exactly once. :param n: int - the initial length of the array :param array: list of int - the array of integers :return: int - the maximum possible integer in the modified array Examples: >>> max_possible_integer_after_operation(5, [1, 2, 3, 4, 5]) 15 >>> max_possible_integer_after_operation(4, [4, 3, 2, 1]) 10 >>> max_possible_integer_after_operation(6, [10, 20, 30, 40, 50, 60]) 210 >>> max_possible_integer_after_operation(1, [500]) 500 >>> max_possible_integer_after_operation(2, [100, 200]) 300 >>> max_possible_integer_after_operation(3, [1000, 1000, 1000]) 3000 >>> max_possible_integer_after_operation(10, [1]*10) 10 >>> max_possible_integer_after_operation(5, [5, 4, 3, 2, 1]) 15 pass","solution":"def max_possible_integer_after_operation(n, array): Returns the maximum possible integer in the modified array after performing the operation of summing a contiguous subarray exactly once. :param n: int - the initial length of the array :param array: list of int - the array of integers :return: int - the maximum possible integer in the modified array return sum(array)"},{"question":"def findQuadruples(nums: List[int], target: int) -> List[List[int]]: Returns a list of unique quadruples [a, b, c, d] such that a + b + c + d = target. Parameters: nums (List[int]): List of integers. target (int): Target sum for the quadruples. Returns: List[List[int]]: List of lists containing unique quadruples that sum to the target. Example: >>> sorted(findQuadruples([1, 0, -1, 0, -2, 2], 0)) [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]] >>> findQuadruples([2, 2, 2, 2, 2], 8) [[2, 2, 2, 2]] pass from typing import List def test_findQuadruples_example1(): assert sorted(findQuadruples([1, 0, -1, 0, -2, 2], 0)) == sorted([[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]]) def test_findQuadruples_example2(): assert sorted(findQuadruples([2, 2, 2, 2, 2], 8)) == [[2, 2, 2, 2]] def test_findQuadruples_no_solution(): assert findQuadruples([3, 8, -6, 1, 5], 100) == [] def test_findQuadruples_all_negatives(): assert sorted(findQuadruples([-3, -2, -1, -1, -1, -2, -3], -8)) == sorted([[-3, -3, -1, -1], [-3, -2, -2, -1]]) def test_findQuadruples_mixed(): assert sorted(findQuadruples([0, 0, 0, 0], 0)) == [[0, 0, 0, 0]]","solution":"def findQuadruples(nums, target): Returns a list of unique quadruples [a, b, c, d] such that a + b + c + d = target. nums.sort() n = len(nums) quadruples = [] for i in range(n - 3): if i > 0 and nums[i] == nums[i - 1]: continue for j in range(i + 1, n - 2): if j > i + 1 and nums[j] == nums[j - 1]: continue left, right = j + 1, n - 1 while left < right: quadruple_sum = nums[i] + nums[j] + nums[left] + nums[right] if quadruple_sum == target: quadruples.append([nums[i], nums[j], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif quadruple_sum < target: left += 1 else: right -= 1 return quadruples"},{"question":"def longest_palindrome(s: str) -> int: Given a string consisting of lowercase English letters, determine the longest palindrome that can be made by deleting or rearranging some characters. A palindrome is a string that reads the same backward as forward. Examples: >>> longest_palindrome(\\"abccccdd\\") 7 >>> longest_palindrome(\\"abcdef\\") 1 >>> longest_palindrome(\\"aaaa\\") 4 >>> longest_palindrome(\\"aabbccc\\") 7 >>> longest_palindrome(\\"a\\") 1 >>> longest_palindrome(\\"\\") 0","solution":"def longest_palindrome(s: str) -> int: from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) length = 0 odd_found = False for count in char_count.values(): if count % 2 == 0: length += count else: length += count - 1 odd_found = True # Add one if there was any character with odd count if odd_found: length += 1 return length"},{"question":"from collections import deque from typing import List def manage_queue(operations: List[str]) -> List[str]: Implement a queue management system with operations ENQUEUE x and DEQUEUE. >>> manage_queue([\\"ENQUEUE 3\\", \\"ENQUEUE 5\\", \\"DEQUEUE\\", \\"DEQUEUE\\", \\"DEQUEUE\\"]) [\\"3\\", \\"5\\", \\"EMPTY\\"] >>> manage_queue([\\"ENQUEUE 10\\", \\"DEQUEUE\\", \\"DEQUEUE\\"]) [\\"10\\", \\"EMPTY\\"] >>> manage_queue([\\"ENQUEUE -5\\", \\"ENQUEUE 30\\", \\"DEQUEUE\\", \\"DEQUEUE\\"]) [\\"-5\\", \\"30\\"] pass def test_case_1(): input_operations = [\\"ENQUEUE 3\\", \\"ENQUEUE 5\\", \\"DEQUEUE\\", \\"DEQUEUE\\", \\"DEQUEUE\\"] expected_output = [\\"3\\", \\"5\\", \\"EMPTY\\"] assert manage_queue(input_operations) == expected_output def test_case_2(): input_operations = [\\"ENQUEUE 10\\", \\"DEQUEUE\\", \\"DEQUEUE\\"] expected_output = [\\"10\\", \\"EMPTY\\"] assert manage_queue(input_operations) == expected_output def test_case_3(): input_operations = [\\"ENQUEUE -5\\", \\"ENQUEUE 30\\", \\"DEQUEUE\\", \\"DEQUEUE\\"] expected_output = [\\"-5\\", \\"30\\"] assert manage_queue(input_operations) == expected_output def test_enqueue_dequeue_sequence(): input_operations = [\\"ENQUEUE 1\\", \\"ENQUEUE 2\\", \\"ENQUEUE 3\\", \\"DEQUEUE\\", \\"DEQUEUE\\", \\"ENQUEUE 4\\", \\"DEQUEUE\\", \\"DEQUEUE\\"] expected_output = [\\"1\\", \\"2\\", \\"3\\", \\"4\\"] assert manage_queue(input_operations) == expected_output def test_no_dequeue_operations(): input_operations = [\\"ENQUEUE 5\\", \\"ENQUEUE 10\\", \\"ENQUEUE 15\\"] expected_output = [] # No DEQUEUE operations assert manage_queue(input_operations) == expected_output def test_only_dequeue_operations(): input_operations = [\\"DEQUEUE\\", \\"DEQUEUE\\", \\"DEQUEUE\\"] expected_output = [\\"EMPTY\\", \\"EMPTY\\", \\"EMPTY\\"] assert manage_queue(input_operations) == expected_output","solution":"from collections import deque import sys def manage_queue(operations): queue = deque() results = [] for operation in operations: if operation.startswith(\\"ENQUEUE\\"): _, value = operation.split() queue.append(int(value)) elif operation == \\"DEQUEUE\\": if queue: results.append(str(queue.popleft())) else: results.append(\\"EMPTY\\") return results if __name__ == \\"__main__\\": input = sys.stdin.read data = input().split(\\"n\\") N = int(data[0]) operations = data[1:N + 1] results = manage_queue(operations) for result in results: print(result)"},{"question":"def find_second_largest(arr: List[int]) -> int: Develop a function that takes an array of integers as input and returns the second largest unique integer in the array. >>> find_second_largest([10, 20, 30, 40, 50]) 40 >>> find_second_largest([4, 4, 4, 1]) 1 >>> find_second_largest([-1, -2, -3, -1, -2]) -2","solution":"def find_second_largest(arr): Returns the second largest unique integer in the array. unique_values = list(set(arr)) unique_values.sort(reverse=True) return unique_values[1] if len(unique_values) > 1 else None"},{"question":"def max_consecutive_ones(bin_list: list) -> str: Find the binary number that has the maximum number of consecutive 1s in a list. Args: bin_list (list): A list of binary number strings. Returns: str: The binary number with the maximum number of consecutive 1s. If there is a tie, the first such binary number in the list is returned. Examples: >>> max_consecutive_ones([\\"1101\\", \\"11110000\\", \\"10011\\", \\"1111\\"]) \\"11110000\\" >>> max_consecutive_ones([\\"0000\\", \\"00\\", \\"0\\"]) \\"0000\\" >>> max_consecutive_ones([\\"11\\", \\"111\\", \\"1111\\"]) \\"1111\\"","solution":"def max_consecutive_ones(bin_list: list) -> str: def consecutive_ones(s): max_count = 0 count = 0 for char in s: if char == '1': count += 1 if count > max_count: max_count = count else: count = 0 return max_count max_string = bin_list[0] max_ones = consecutive_ones(bin_list[0]) for binary in bin_list[1:]: current_ones = consecutive_ones(binary) if current_ones > max_ones: max_string = binary max_ones = current_ones return max_string"},{"question":"def knight_moves(R: int, C: int) -> int: Returns the number of valid moves a knight can make from position (R, C) on an 8x8 chessboard. >>> knight_moves(3, 3) 8 >>> knight_moves(1, 1) 2 >>> knight_moves(8, 8) 2 >>> knight_moves(4, 5) 8 >>> knight_moves(2, 2) 4 def process_input(input_data: str) -> list[int]: Processes the input data and returns the number of valid knight moves for each test case. >>> process_input(\\"3 3n1 1n8 8n0 0n\\") [8, 2, 2] >>> process_input(\\"4 5n6 6n3 8n0 0n\\") [8, 8, 4]","solution":"def knight_moves(R, C): Returns the number of valid moves a knight can make from position (R, C) on an 8x8 chessboard. knight_moves = [ (2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2) ] valid_moves = 0 for dr, dc in knight_moves: new_r = R + dr new_c = C + dc if 1 <= new_r <= 8 and 1 <= new_c <= 8: valid_moves += 1 return valid_moves def process_input(input_data): Processes the input data and prints the number of valid knight moves for each test case. lines = input_data.strip().split('n') results = [] for line in lines: R, C = map(int, line.split()) if R == 0 and C == 0: break results.append(knight_moves(R, C)) return results"},{"question":"def minimum_time_slots(N: int) -> int: Determines the minimum number of time slots required for a round robin tournament for N employees where each employee plays exactly one game with every other employee. If N is not within the range 2  N  100, return \\"Invalid Input\\". >>> minimum_time_slots(4) 3 >>> minimum_time_slots(1) \\"Invalid Input\\"","solution":"def minimum_time_slots(N): Determines the minimum number of time slots required for a round robin tournament for N employees where each employee plays exactly one game with every other employee. if N < 2 or N > 100: return \\"Invalid Input\\" # The minimum number of time slots required for a round robin tournament return (N - 1) if N % 2 == 0 else N"},{"question":"from typing import List, Tuple def can_fulfill_orders(toys: List[Tuple[str, int]], purchases: List[Tuple[str, int]]) -> bool: Simulate toy store inventory and allow purchases. Args: toys (List[Tuple[str, int]]): List of toy names and their corresponding quantities. purchases (List[Tuple[str, int]]): List of purchase requests with toy name and desired quantity. Returns: bool: True if all purchase requests are fulfilled, otherwise False. Examples: >>> can_fulfill_orders([(\\"car\\", 10), (\\"doll\\", 5), (\\"ball\\", 20), (\\"puzzle\\", 8)], [(\\"car\\", 2), (\\"doll\\", 4), (\\"ball\\", 1)]) True >>> can_fulfill_orders([(\\"car\\", 10), (\\"doll\\", 5), (\\"ball\\", 20), (\\"puzzle\\", 8)], [(\\"car\\", 2), (\\"doll\\", 6), (\\"ball\\", 1)]) False","solution":"from typing import List, Tuple def can_fulfill_orders(toys: List[Tuple[str, int]], purchases: List[Tuple[str, int]]) -> bool: # Convert list of toys to a dictionary for easier access and update inventory = {toy: quantity for toy, quantity in toys} for toy, requested_quantity in purchases: if toy not in inventory or inventory[toy] < requested_quantity: return False # Update the inventory after fulfilling the request inventory[toy] -= requested_quantity return True"},{"question":"def longest_palindromic_subsequence(S: str) -> int: Returns the length of the longest palindromic subsequence in string S. >>> longest_palindromic_subsequence(\\"bbabcbcab\\") 7 >>> longest_palindromic_subsequence(\\"abcd\\") 1 def process_test_cases(T: int, test_cases: List[str]) -> List[int]: Process multiple test cases. >>> process_test_cases(2, [\\"bbabcbcab\\", \\"abcd\\"]) [7, 1]","solution":"def longest_palindromic_subsequence(S): Returns the length of the longest palindromic subsequence in string S. n = len(S) dp = [[0] * n for _ in range(n)] # Base case: Single letters are palindromes of length 1 for i in range(n): dp[i][i] = 1 # Fill the table for cl in range(2, n + 1): for i in range(n - cl + 1): j = i + cl - 1 if S[i] == S[j] and cl == 2: dp[i][j] = 2 elif S[i] == S[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) return dp[0][n - 1] def process_test_cases(T, test_cases): Process multiple test cases. results = [] for S in test_cases: results.append(longest_palindromic_subsequence(S)) return results"},{"question":"from typing import List def can_arrange_cattle(cattle_strengths: List[int]) -> str: Determines if the given list of cattle strengths can be arranged such that no two adjacent cattle have GCD greater than 1. >>> can_arrange_cattle([7, 3, 5]) \\"YES\\" >>> can_arrange_cattle([2, 4, 6, 8]) \\"NO\\" pass def process_input_output(input_data: str) -> List[str]: Processes the input data and returns the list of results for each test case. >>> input_data = \\"2n3n7 3 5n4n2 4 6 8n\\" >>> process_input_output(input_data) [\\"YES\\", \\"NO\\"] pass def test_can_arrange_cattle(): assert can_arrange_cattle([5]) == \\"YES\\" assert can_arrange_cattle([1]) == \\"YES\\" assert can_arrange_cattle([4, 2]) == \\"NO\\" assert can_arrange_cattle([6, 3, 9]) == \\"NO\\" assert can_arrange_cattle([8, 1, 7]) == \\"YES\\" assert can_arrange_cattle([7, 3, 5]) == \\"YES\\" assert can_arrange_cattle([10**6, 1]) == \\"YES\\" assert can_arrange_cattle([2, 4, 6, 8, 10]) == \\"NO\\" assert can_arrange_cattle([9, 2, 7, 15]) == \\"YES\\" def test_process_input_output(): input_data = \\"2n3n7 3 5n4n2 4 6 8n\\" assert process_input_output(input_data) == [\\"YES\\", \\"NO\\"]","solution":"import math import itertools def can_arrange_cattle(cattle_strengths): Determines if the given list of cattle strengths can be arranged such that no two adjacent cattle have GCD greater than 1. n = len(cattle_strengths) if n == 1: return \\"YES\\" for perm in itertools.permutations(cattle_strengths): valid = True for i in range(n-1): if math.gcd(perm[i], perm[i+1]) > 1: valid = False break if valid: return \\"YES\\" return \\"NO\\" def process_input_output(input_data): lines = input_data.strip().split('n') T = int(lines[0]) results = [] index = 1 for _ in range(T): N = int(lines[index]) strengths = list(map(int, lines[index+1].split())) result = can_arrange_cattle(strengths) results.append(result) index += 2 return results"},{"question":"from typing import List def partition(s: str) -> List[List[str]]: Partition a string into substrings such that each substring is a palindrome. >>> partition(\\"aab\\") [['a', 'a', 'b'], ['aa', 'b']] >>> partition(\\"a\\") [['a']] >>> partition(\\"ab\\") [['a', 'b']] >>> partition(\\"aa\\") [['a', 'a'], ['aa']] >>> partition(\\"aba\\") [['a', 'b', 'a'], ['aba']] >>> partition(\\"abc\\") [['a', 'b', 'c']] >>> partition(\\"aaaa\\") [['a', 'a', 'a', 'a'], ['a', 'a', 'aa'], ['a', 'aa', 'a'], ['a', 'aaa'], ['aa', 'a', 'a'], ['aa', 'aa'], ['aaa', 'a'], ['aaaa']] >>> partition(\\"aabb\\") [['a', 'a', 'b', 'b'], ['a', 'a', 'bb'], ['aa', 'b', 'b'], ['aa', 'bb']]","solution":"def is_palindrome(s): return s == s[::-1] def partition(s): def dfs(start, path): if start == len(s): result.append(path[:]) return for end in range(start + 1, len(s) + 1): if is_palindrome(s[start:end]): dfs(end, path + [s[start:end]]) result = [] dfs(0, []) return result"},{"question":"from math import comb def count_coin_combinations(n: int, k: int) -> int: Returns the number of ways to choose k distinct coins from n distinct coins. >>> count_coin_combinations(5, 3) 10 >>> count_coin_combinations(6, 2) 15 >>> count_coin_combinations(10, 10) 1 >>> count_coin_combinations(7, 4) 35","solution":"from math import comb def count_coin_combinations(n, k): Returns the number of ways to choose k distinct coins from n distinct coins. return comb(n, k)"},{"question":"def max_trapped_water(n, heights): Returns the maximum amount of water that can be trapped between the buildings. >>> max_trapped_water(12, [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 >>> max_trapped_water(6, [4, 2, 0, 3, 2, 5]) == 9 >>> max_trapped_water(0, []) == 0 >>> max_trapped_water(1, [4]) == 0 >>> max_trapped_water(2, [4, 2]) == 0 >>> max_trapped_water(4, [1, 2, 3, 4]) == 0 >>> max_trapped_water(4, [4, 3, 2, 1]) == 0 >>> max_trapped_water(3, [3, 0, 3]) == 3 >>> max_trapped_water(5, [0, 2, 0, 2, 0]) == 2 # Your code goes here","solution":"def max_trapped_water(n, heights): Returns the maximum amount of water that can be trapped between the buildings. if n < 3: return 0 left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"def max_sum_of_candies(n: int, k: int, candies: List[int]) -> int: Returns the maximum sum of the subarray where the sum does not exceed k. >>> max_sum_of_candies(5, 9, [2, 1, 3, 2, 1]) 9 >>> max_sum_of_candies(4, 5, [4, 3, 2, 1]) 5 >>> max_sum_of_candies(3, 6, [5, 1, 2]) 6 >>> max_sum_of_candies(1, 5, [4]) 4 >>> max_sum_of_candies(3, 2, [3, 4, 5]) 0 >>> max_sum_of_candies(4, 10, [1, 2, 3, 4]) 10 >>> max_sum_of_candies(4, 100, [10, 20, 30, 40]) 100 >>> max_sum_of_candies(6, 1, [1, 2, 3, 4, 5, 6]) 1","solution":"def max_sum_of_candies(n, k, candies): Returns the maximum sum of the subarray where the sum does not exceed k. max_sum = 0 current_sum = 0 start = 0 for end in range(n): current_sum += candies[end] while current_sum > k and start <= end: current_sum -= candies[start] start += 1 if current_sum <= k: max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def min_total_with_discount(n1, n2, n3, prices1, prices2, prices3, d): Function to calculate the minimum total amount a customer needs to spend to buy one dessert from each type with the discount applied. :param n1: Number of desserts in type 1 :param n2: Number of desserts in type 2 :param n3: Number of desserts in type 3 :param prices1: List of prices for desserts in type 1 :param prices2: List of prices for desserts in type 2 :param prices3: List of prices for desserts in type 3 :param d: Discount amount :return: Minimum total amount after applying the discount # Your code here def test_min_total_with_discount(): assert min_total_with_discount(3, 2, 4, [10, 20, 30], [15, 25], [5, 10, 15, 20], 5) == 25 assert min_total_with_discount(2, 2, 2, [5, 7], [3, 8], [1, 4], 2) == 7 assert min_total_with_discount(3, 3, 3, [10, 20, 30], [5, 15, 25], [15, 25, 35], 10) == 20 assert min_total_with_discount(1, 1, 1, [1], [2], [3], 1) == 5 assert min_total_with_discount(5, 4, 3, [100, 200, 300, 400, 500], [50, 60, 70, 80], [10, 20, 30], 15) == 145","solution":"def min_total_with_discount(n1, n2, n3, prices1, prices2, prices3, d): Function to calculate the minimum total amount a customer needs to spend to buy one dessert from each type with the discount applied. :param n1: Number of desserts in type 1 :param n2: Number of desserts in type 2 :param n3: Number of desserts in type 3 :param prices1: List of prices for desserts in type 1 :param prices2: List of prices for desserts in type 2 :param prices3: List of prices for desserts in type 3 :param d: Discount amount :return: Minimum total amount after applying the discount # Find the minimum price for each type min_price1 = min(prices1) min_price2 = min(prices2) min_price3 = min(prices3) # Calculate the total cost before discount total_cost = min_price1 + min_price2 + min_price3 # Apply the discount total_cost_with_discount = total_cost - d return total_cost_with_discount"},{"question":"def minimized_max_skill_difference(n: int, k: int, skills: List[int]) -> int: This function calculates the minimized maximum skill difference of any team of 'k' engineers. :param n: int, number of engineers :param k: int, number of engineers per team :param skills: list of int, skill levels of each engineer :return: int, minimized maximum skill difference of any team of 'k' engineers >>> minimized_max_skill_difference(5, 3, [10, 20, 30, 40, 50]) 20 >>> minimized_max_skill_difference(6, 2, [5, 7, 9, 14, 20, 25]) 2 from typing import List def test_minimized_max_skill_difference(): assert minimized_max_skill_difference(5, 3, [10, 20, 30, 40, 50]) == 20 assert minimized_max_skill_difference(6, 2, [5, 7, 9, 14, 20, 25]) == 2 assert minimized_max_skill_difference(7, 3, [1, 3, 6, 19, 29, 90, 100]) == 5 assert minimized_max_skill_difference(8, 4, [12, 34, 23, 45, 56, 78, 89, 99]) == 33 assert minimized_max_skill_difference(3, 1, [20, 50, 80]) == 0 if __name__ == \\"__main__\\": test_minimized_max_skill_difference()","solution":"def minimized_max_skill_difference(n, k, skills): This function calculates the minimized maximum skill difference of any team of 'k' engineers. :param n: int, number of engineers :param k: int, number of engineers per team :param skills: list of int, skill levels of each engineer :return: int, minimized maximum skill difference of any team of 'k' engineers # We first sort the list of skills skills.sort() # Initialize the minimal difference to a large value that will be minimized min_diff = float('inf') # We iterate over the sorted skills list with a sliding window of size 'k' for i in range(n - k + 1): current_diff = skills[i + k - 1] - skills[i] min_diff = min(min_diff, current_diff) return min_diff"},{"question":"def shortest_path(n: int, m: int, grid: List[List[int]], start: Tuple[int, int], target: Tuple[int, int]) -> int: Find the shortest path from the starting to the target position in a 2D grid. The grid can contain walkable cells (0) and obstacles (1). The robot can move up, down, left, or right. If there's no path, return -1. >>> n = 5 >>> m = 6 >>> grid = [[0, 0, 0, 0, 1, 0], >>> [1, 1, 0, 1, 1, 0], >>> [0, 0, 0, 0, 0, 0], >>> [0, 1, 1, 1, 1, 0], >>> [0, 0, 0, 0, 0, 0]] >>> start = (0, 0) >>> target = (4, 5) >>> shortest_path(n, m, grid, start, target) 9 >>> n = 3 >>> m = 3 >>> grid = [[0, 1, 0], >>> [0, 1, 0], >>> [0, 1, 0]] >>> start = (0, 0) >>> target = (2, 2) >>> shortest_path(n, m, grid, start, target) -1","solution":"from collections import deque def shortest_path(n, m, grid, start, target): def is_valid(x, y): return 0 <= x < n and 0 <= y < m and grid[x][y] == 0 if not is_valid(start[0], start[1]) or not is_valid(target[0], target[1]): return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(start[0], start[1], 0)]) visited = set() visited.add(start) while queue: x, y, dist = queue.popleft() if (x, y) == target: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"def find_paths(n: int, m: int, k: int, forbidden: List[Tuple[int, int]]) -> int: There is a rectangular grid of size n x m. You start at the top left corner (1, 1) and want to reach the bottom right corner (n, m). You can move either right or down from any cell, and you can only visit a specific cell once. Additionally, there are certain cells that are forbidden, meaning you cannot move to or through them. Your task is to find the number of different paths from the top left corner to the bottom right corner that do not pass through any forbidden cells. >>> find_paths(3, 3, 1, [(2, 2)]) 2 >>> find_paths(3, 3, 2, [(2, 2), (2, 3)]) 1 >>> find_paths(2, 2, 4, [(1, 1), (1, 2), (2, 1), (2, 2)]) 0 >>> find_paths(3, 3, 0, []) 6 >>> find_paths(4, 4, 3, [(2, 2), (3, 3), (1, 4)]) 3 >>> find_paths(3, 3, 1, [(1, 1)]) 0 >>> find_paths(3, 3, 1, [(3, 3)]) 0","solution":"def find_paths(n, m, k, forbidden): forbidden_cells = set(forbidden) if (1, 1) in forbidden_cells or (n, m) in forbidden_cells: return 0 dp = [[0 for _ in range(m+1)] for _ in range(n+1)] dp[1][1] = 1 for i in range(1, n+1): for j in range(1, m+1): if (i, j) in forbidden_cells or (i, j) == (1, 1): continue if i > 1: dp[i][j] += dp[i - 1][j] if j > 1: dp[i][j] += dp[i][j - 1] return dp[n][m]"},{"question":"def can_rearrange_heights(n: int, heights: List[int]) -> str: Determine if it is possible to adjust the line such that no two people of the same height are standing next to each other. >>> can_rearrange_heights(5, [3, 3, 3, 3, 3]) \\"No\\" >>> can_rearrange_heights(6, [1, 1, 1, 2, 2, 3]) \\"Yes\\" >>> can_rearrange_heights(4, [4, 4, 4, 4]) \\"No\\" >>> can_rearrange_heights(1, [5]) \\"Yes\\" >>> can_rearrange_heights(7, [1, 2, 3, 4, 1, 2, 3]) \\"Yes\\" >>> can_rearrange_heights(10, [1, 1, 2, 2, 3, 3, 4, 4, 5, 5]) \\"Yes\\" >>> can_rearrange_heights(5, [1, 1, 1, 2, 2]) \\"Yes\\"","solution":"def can_rearrange_heights(n, heights): from collections import Counter if n == 1: return \\"Yes\\" height_frequency = Counter(heights) max_count = max(height_frequency.values()) # Check if the most frequent height can fit with space between others if max_count > (n + 1) // 2: return \\"No\\" else: return \\"Yes\\""},{"question":"def can_fulfill_orders(vehicle_capacities, orders): Determine if every shipping order can be satisfied by any of the available vehicles. >>> can_fulfill_orders([100, 200, 150], [90, 110, 130, 160]) \\"YES\\" >>> can_fulfill_orders([100, 50], [120, 70, 40]) \\"NO\\" def transportation_company(input_data): Read fleet and orders data, and determine if the shipping orders can be fulfilled. >>> input_data1 = \\"3n100n200n150n4n90n110n130n160\\" >>> transportation_company(input_data1) \\"YES\\" >>> input_data2 = \\"2n100n50n3n120n70n40\\" >>> transportation_company(input_data2) \\"NO\\"","solution":"def can_fulfill_orders(vehicle_capacities, orders): max_capacity = max(vehicle_capacities) for order in orders: if order > max_capacity: return \\"NO\\" return \\"YES\\" def transportation_company(input_data): lines = input_data.strip().split('n') V = int(lines[0]) vehicle_capacities = [] for i in range(1, V + 1): vehicle_capacities.append(int(lines[i])) O = int(lines[V + 1]) orders = [] for i in range(V + 2, V + 2 + O): orders.append(int(lines[i])) return can_fulfill_orders(vehicle_capacities, orders)"},{"question":"from typing import List def count_paths(grid: List[str]) -> int: Returns the number of distinct paths in the grid from the top-left corner to the bottom-right corner. A person can move up, down, left, or right, but cannot enter a blocked cell ('#'). A cell with '.' is open for movement. Args: grid: List of strings representing the grid Returns: int: Number of distinct paths from (0, 0) to (m-1, n-1). If no path exists, return 0. >>> count_paths([\\"...\\", \\".#.\\", \\"...\\"]) 2 >>> count_paths([\\".#\\", \\"#.\\"]) 0 >>> count_paths([\\"...\\", \\"...\\", \\"...\\"]) 6 >>> count_paths([\\"....\\", \\"..#.\\", \\"....\\"]) 4 pass # Replace this with your implementation def test_count_paths_example_1(): grid = [ \\"...\\", \\".#.\\", \\"...\\" ] assert count_paths(grid) == 2 def test_count_paths_example_2(): grid = [ \\".#\\", \\"#.\\" ] assert count_paths(grid) == 0 def test_count_paths_example_3(): grid = [ \\"..#\\", \\"#\\", \\"..#\\" ] assert count_paths(grid) == 0 def test_count_paths_example_4(): grid = [ \\"....\\", \\"..#.\\", \\"....\\" ] assert count_paths(grid) == 4 def test_count_paths_single_cell_open(): grid = [ \\".\\" ] assert count_paths(grid) == 1 def test_count_paths_single_cell_blocked(): grid = [ \\"#\\" ] assert count_paths(grid) == 0 def test_count_paths_only_one_row(): grid = [ \\"...#..\\"] assert count_paths(grid) == 0 def test_count_paths_only_one_column(): grid = [ \\".\\", \\".\\", \\"#\\" ] assert count_paths(grid) == 0 def test_count_paths_without_blocked_cells(): grid = [ \\"...\\", \\"...\\", \\"...\\" ] assert count_paths(grid) == 6 def test_count_paths_with_all_blocked_cells(): grid = [ \\"#\\", \\"#\\", \\"#\\" ] assert count_paths(grid) == 0","solution":"def count_paths(grid): Returns the number of distinct paths in the grid from the top-left corner to the bottom-right corner. A person can move up, down, left, or right, but cannot enter a blocked cell ('#'). if grid[0][0] == '#' or grid[-1][-1] == '#': return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i - 1][j] if j > 0: dp[i][j] += dp[i][j - 1] return dp[m - 1][n - 1]"},{"question":"from typing import List def largest_rectangle_area(heights: List[int]) -> int: Computes the area of the largest rectangle that can be formed in a histogram made up of given building heights. :param heights: List of integers representing the heights of buildings. :return: Area of the largest rectangle. >>> largest_rectangle_area([6, 2, 5, 4, 5, 1, 6]) 12 >>> largest_rectangle_area([5, 5, 5, 5, 5]) 25 >>> largest_rectangle_area([1, 2, 3, 4, 5]) 9 >>> largest_rectangle_area([5, 4, 3, 2, 1]) 9 >>> largest_rectangle_area([7]) 7 >>> largest_rectangle_area([4, 4]) 8 >>> largest_rectangle_area([2, 1, 5, 6, 2, 3]) 10 >>> largest_rectangle_area([2, 4, 2, 1, 10, 6, 10]) 18","solution":"def largest_rectangle_area(heights): Computes the area of the largest rectangle that can be formed in a histogram made up of given building heights. :param heights: List of integers representing the heights of buildings. :return: Area of the largest rectangle. max_area = 0 stack = [] # This stack stores the indices of the histogram bars index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def find_kth_smallest(n: int, k: int, arr1: List[int], arr2: List[int]) -> int: Returns the kth smallest element in the merged array formed by merging arr1 and arr2. >>> find_kth_smallest(5, 3, [1, 3, 5, 7, 9], [2, 4, 6, 8, 10]) 3 >>> find_kth_smallest(4, 5, [1, 2, 3, 4], [5, 6, 7, 8]) 5","solution":"def find_kth_smallest(n, k, arr1, arr2): Returns the kth smallest element in the merged array formed by merging arr1 and arr2. # Two pointer technique i, j, count = 0, 0, 0 while i < n and j < n: if arr1[i] < arr2[j]: count += 1 if count == k: return arr1[i] i += 1 else: count += 1 if count == k: return arr2[j] j += 1 # If one of the arrays is exhausted while i < n: count += 1 if count == k: return arr1[i] i += 1 while j < n: count += 1 if count == k: return arr2[j] j += 1 # Example usage # n, k = 5, 3 # arr1 = [1, 3, 5, 7, 9] # arr2 = [2, 4, 6, 8, 10] # print(find_kth_smallest(n, k, arr1, arr2)) # Output: 3"},{"question":"def min_length_after_removal(S: str, K: int) -> int: Determines the minimum possible length of the string after removing exactly K characters. Parameters: S (str): A string consisting of lower-case English letters. K (int): An integer representing the number of characters to remove. Returns: int: Minimum possible length of the string after removing K characters. Examples: >>> min_length_after_removal(\\"abcdabcd\\", 3) 5 >>> min_length_after_removal(\\"aabbc\\", 1) 4 >>> min_length_after_removal(\\"a\\", 1) 0","solution":"def min_length_after_removal(S, K): Determines the minimum possible length of the string after removing exactly K characters. :param S: A string consisting of lower-case English letters. :param K: An integer representing the number of characters to remove. :return: Minimum possible length of the string after removing K characters. return len(S) - K"},{"question":"def min_changes_to_unify(kid_preferences, queries): Returns the minimum number of changes to make all kids in the specified range prefer the same game, for each query. :param kid_preferences: List of integers where each value is either 1 or 2 indicating the kid's game preference. :param queries: List of tuples where each tuple contains two integers (l, r) representing the inclusive range for the query. :return: List of integers where each integer is the minimum number of changes for the corresponding query. >>> min_changes_to_unify([1, 2, 1, 1, 2, 2, 1], [(1, 7), (2, 5), (3, 6)]) [3, 2, 2] >>> min_changes_to_unify([1, 1, 1, 1, 1], [(1, 5), (2, 4), (1, 3)]) [0, 0, 0] >>> min_changes_to_unify([1, 2, 1, 2, 1, 2, 1, 2], [(1, 8), (1, 4), (5, 8)]) [4, 2, 2] >>> min_changes_to_unify([1], [(1, 1)]) [0] >>> min_changes_to_unify([2, 1, 2, 1, 2, 1, 2], [(1, 3), (2, 5), (4, 7)]) [1, 2, 2]","solution":"def min_changes_to_unify(kid_preferences, queries): Returns the minimum number of changes to make all kids in the specified range prefer the same game, for each query. :param kid_preferences: List of integers where each value is either 1 or 2 :param queries: List of tuples where each tuple contains two integers (l, r) representing the inclusive range for the query :return: List of integers where each integer is the minimum number of changes for the corresponding query # Precompute prefix sums for both games 1 and 2 n = len(kid_preferences) prefix_1 = [0] * (n + 1) prefix_2 = [0] * (n + 1) for i in range(1, n + 1): prefix_1[i] = prefix_1[i - 1] + (1 if kid_preferences[i - 1] == 1 else 0) prefix_2[i] = prefix_2[i - 1] + (1 if kid_preferences[i - 1] == 2 else 0) results = [] for l, r in queries: count_1 = prefix_1[r] - prefix_1[l - 1] count_2 = prefix_2[r] - prefix_2[l - 1] min_changes = min(count_1, count_2) results.append(min_changes) return results"},{"question":"from typing import List def min_path_length(M: int, N: int, grid: List[List[int]]) -> int: Computes the minimum number of moves to go from the top-left corner to the bottom-right corner of the grid. Returns -1 if there's no valid path. >>> min_path_length(3, 3, [ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) == 4 >>> min_path_length(3, 3, [ ... [0, 1, 0], ... [1, 1, 0], ... [0, 0, 0] ... ]) == -1 pass if __name__ == \\"__main__\\": import pytest pytest.main()","solution":"from collections import deque def min_path_length(M, N, grid): if grid[0][0] == 1 or grid[M-1][N-1] == 1: return -1 directions = [(0, 1), (1, 0)] queue = deque([(0, 0, 0)]) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if (x, y) == (M-1, N-1): return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < M and 0 <= ny < N and (nx, ny) not in visited and grid[nx][ny] == 0: queue.append((nx, ny, dist + 1)) visited.add((nx, ny)) return -1"},{"question":"def is_anagram_of_palindrome(s: str) -> str: Determines if the string s is an anagram of a palindrome. >>> is_anagram_of_palindrome(\\"carrace\\") 'Yes' >>> is_anagram_of_palindrome(\\"doodle\\") 'No' >>> is_anagram_of_palindrome(\\"aabbcc\\") 'Yes' >>> is_anagram_of_palindrome(\\"palindrome\\") 'No'","solution":"def is_anagram_of_palindrome(s): Determines if the string s is an anagram of a palindrome. An anagram of a palindrome must have at most one character with an odd frequency count. from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # Count how many characters have an odd frequency odd_count = sum(1 for count in char_count.values() if count % 2 == 1) # If the odd_count is more than 1, it can't be an anagram of a palindrome return 'Yes' if odd_count <= 1 else 'No'"},{"question":"def largest_square_bed(w: int, h: int, positions: List[Tuple[int, int]]) -> List[int]: Determines the largest possible square flower bed that fits within the garden boundaries at each starting position. Args: w (int): Width of the garden. h (int): Height of the garden. positions (list of tuples): List of starting positions (x, y). Returns: list of int: Maximum side length of square bed for each starting position. Examples: >>> largest_square_bed(6, 4, [(0, 0), (5, 3), (2, 2)]) [4, 1, 2] >>> largest_square_bed(10, 10, [(3, 3)]) [7] >>> largest_square_bed(8, 8, [(7, 7)]) [1] >>> largest_square_bed(5, 5, [(0, 0), (1, 1), (2, 2), (4, 4)]) [5, 4, 3, 1] >>> largest_square_bed(1000, 1000, [(500, 500), (999, 999), (0, 0)]) [500, 1, 1000]","solution":"def largest_square_bed(w, h, positions): Finds the largest square bed that fits within the garden at each starting position. Args: w (int): Width of the garden. h (int): Height of the garden. positions (list of tuples): List of starting positions (x, y). Returns: list of int: Maximum side length of square bed for each starting position. max_squares = [] for (x, y) in positions: max_side_length = min(w - x, h - y) max_squares.append(max_side_length) return max_squares"},{"question":"from typing import List, Tuple from collections import Counter def most_frequent_and_smallest_element(arr: List[int]) -> Tuple[int, int]: Returns the most frequently occurring element and the smallest element in the array. If multiple elements occur most frequently, the smallest one is chosen. if not arr: raise ValueError(\\"The array should have at least one element\\") def process_input(input_str: str) -> Tuple[int, int]: Parses the input string and returns the most frequent and smallest element. Args: input_str: a string of integers separated by spaces. Returns: A tuple containing the most frequently occurring element and the smallest element. >>> process_input(\\"1 2 2 3 3 3 4 5\\") (3, 1) >>> process_input(\\"4 4 4 1 1 3 3 3 9 9 9\\") (3, 1) # Test cases def test_case_1(): assert process_input(\\"1 2 2 3 3 3 4 5\\") == (3, 1) def test_case_2(): assert process_input(\\"4 4 4 1 1 3 3 3 9 9 9\\") == (3, 1) def test_case_3(): assert process_input(\\"0 0 0 0 -1 -1\\") == (0, -1) def test_case_4(): assert process_input(\\"1000 1000 1000 -1000 -1000 -500\\") == (1000, -1000) def test_case_5(): assert process_input(\\"3 2 1\\") == (1, 1) def test_empty_input(): try: process_input(\\"\\") except ValueError as e: assert str(e) == \\"The array should have at least one element\\"","solution":"from collections import Counter def most_frequent_and_smallest_element(arr): Returns the most frequently occurring element and the smallest element in the array. If multiple elements occur most frequently, the smallest one is chosen. if not arr: raise ValueError(\\"The array should have at least one element\\") frequency = Counter(arr) most_frequent = min([key for key, count in frequency.items() if count == max(frequency.values())]) smallest_element = min(arr) return most_frequent, smallest_element def process_input(input_str): Parses the input string and return the processed array. arr = list(map(int, input_str.split())) return most_frequent_and_smallest_element(arr)"},{"question":"def notify_and_predict_expiry(n: int, expiry_dates: List[int]) -> Tuple[Union[List[int], str], int]: Removes expired products and returns the days until the next product expires. Parameters: n (int): Number of products. expiry_dates (list of int): Days remaining for each product to expire. Returns: tuple: Updated list of days remaining and days until the next product expires. Examples: >>> notify_and_predict_expiry(5, [10, 0, -2, 5, 3]) ([10, 5, 3], 3) >>> notify_and_predict_expiry(3, [-1, -2, 0]) (\\"No products\\", -1)","solution":"def notify_and_predict_expiry(n, expiry_dates): Removes expired products and returns the days until the next product expires. Parameters: n (int): Number of products. expiry_dates (list of int): Days remaining for each product to expire. Returns: tuple: Updated list of days remaining and days until the next product expires. non_expired = [days for days in expiry_dates if days > 0] if not non_expired: return \\"No products\\", -1 min_days = min(non_expired) return non_expired, min_days"},{"question":"def count_paths(grid): Given a grid of size n x m, where some cells are empty (0) and some cells are obstacles (1), returns the number of distinct paths from the top-left corner to the bottom-right corner, moving only right or down at each step. Args: grid (List[List[int]]): A 2D list representing the grid. Returns: int: The number of distinct paths. Examples: >>> count_paths([ [0, 0, 0], [0, 1, 0], [0, 0, 0] ]) 2 >>> count_paths([ [0, 1, 0], [1, 0, 1], [0, 0, 0] ]) 0","solution":"def count_paths(grid): Given a grid of size n x m, where some cells are empty (0) and some cells are obstacles (1), returns the number of distinct paths from the top-left corner to the bottom-right corner, moving only right or down at each step. n = len(grid) m = len(grid[0]) # If the starting or ending cell is an obstacle, return 0 if grid[0][0] == 1 or grid[n-1][m-1] == 1: return 0 dp = [[0] * m for _ in range(n)] dp[0][0] = 1 # Starting point for i in range(n): for j in range(m): if grid[i][j] == 1: dp[i][j] = 0 # Obstacle else: if i > 0: dp[i][j] += dp[i-1][j] # From top cell if j > 0: dp[i][j] += dp[i][j-1] # From left cell return dp[-1][-1]"},{"question":"def find_best_day(preferences): Given a list of preferred days for each player, determines the best day that maximizes the number of participants. If there are multiple best days, returns the smallest day number. :param preferences: List of lists, where each sublist contains the preferred days for each player. :return: The best day number that maximizes the number of participants. # Your code here def process_input(input_data): Processes the input data and determines the best day for each test case. :param input_data: String, raw input data containing multiple test cases. :return: List of integers, each representing the best day for corresponding test case. # Your code here # Example usage and test cases if __name__ == \\"__main__\\": import pytest def test_find_best_day(): assert find_best_day([[1, 2, 5], [2, 3], [1, 3, 5, 7]]) == 1 assert find_best_day([[1, 4], [1, 3, 4], [2]]) == 1 assert find_best_day([[2], [2], [2]]) == 2 assert find_best_day([[1, 7], [1], [7]]) == 1 def test_process_input(): input_data = \\"3n3 1 2 5n2 2 3n4 1 3 5 7n4n2 1 4n3 1 3 4n1 2n0n\\" expected_output = [1, 1] assert process_input(input_data) == expected_output input_data = \\"4n1 1n1 2n1 3n1 4n0n\\" expected_output = [1] assert process_input(input_data) == expected_output input_data = \\"2n3 1 2 3n3 3 4 5n0n\\" expected_output = [3] assert process_input(input_data) == expected_output input_data = \\"2n4 1 2 3 4n4 4 5 6 7n0n\\" expected_output = [4] assert process_input(input_data) == expected_output pytest.main()","solution":"def find_best_day(preferences): Given a list of preferred days for each player, determines the best day that maximizes the number of participants. If there are multiple best days, returns the smallest day number. :param preferences: List of lists, where each sublist contains the preferred days for each player. :return: The best day number that maximizes the number of participants. day_counts = [0] * 7 # counts for each day from Monday (1) to Sunday (7) for player_prefs in preferences: for day in player_prefs: day_counts[day - 1] += 1 max_participants_day = max(range(7), key=lambda x: (day_counts[x], -x)) return max_participants_day + 1 def process_input(input_data): Processes the input data and determines the best day for each test case. :param input_data: String, raw input data containing multiple test cases. :return: List of integers, each representing the best day for corresponding test case. input_lines = input_data.strip().split(\\"n\\") result = [] i = 0 while i < len(input_lines): n = int(input_lines[i]) if n == 0: break i += 1 preferences = [] for _ in range(n): player_prefs = list(map(int, input_lines[i].split()))[1:] preferences.append(player_prefs) i += 1 best_day = find_best_day(preferences) result.append(best_day) return result"},{"question":"def closest_larger(numbers: List[int]) -> List[int]: For each integer in the list, determine the closest integer in the list that is larger than the current integer. If no such integer exists, return -1 for that integer. Args: numbers (list of int): list of integers. Returns: list of int: list where each index has the closest larger element or -1 if no larger element exists. >>> closest_larger([4, 7, 2, 3, 8, 6]) [6, 8, 3, 4, -1, 7] >>> closest_larger([1, 2, 3, 4, 5]) [2, 3, 4, 5, -1] >>> closest_larger([5, 4, 3, 2, 1]) [-1, 5, 4, 3, 2] >>> closest_larger([8, 6, 4, 2]) [-1, 8, 6, 4] >>> closest_larger([1, 3, 3, 3, 2]) [2, -1, -1, -1, 3] >>> closest_larger([5, 1, 1, 5]) [-1, 5, 5, -1]","solution":"def closest_larger(numbers): For each integer in the list, determine the closest integer in the list that is larger than the current integer. If no such integer exists, return -1 for that integer. Args: numbers (list of int): list of integers. Returns: list of int: list where each index has the closest larger element or -1 if no larger element exists. from bisect import bisect_right sorted_numbers = sorted(set(numbers)) result = [] for num in numbers: index = bisect_right(sorted_numbers, num) if index < len(sorted_numbers): result.append(sorted_numbers[index]) else: result.append(-1) return result"},{"question":"from typing import List def sum_of_unique_elements(n: int, elements: List[int]) -> int: Removes elements with frequency greater than 1 and returns the sum of remaining elements. Parameters: n (int): number of elements in the list elements (list of int): the list of elements Returns: int: sum of remaining elements after removing duplicates >>> sum_of_unique_elements(6, [2, 3, 2, 4, 3, 5]) 9 >>> sum_of_unique_elements(5, [1, 2, 3, 4, 5]) 15 >>> sum_of_unique_elements(4, [1, 1, 2, 2]) 0","solution":"def sum_of_unique_elements(n, elements): Removes elements with frequency greater than 1 and returns the sum of remaining elements. Parameters: n (int): number of elements in the list elements (list of int): the list of elements Returns: int: sum of remaining elements after removing duplicates from collections import Counter # Count the frequency of each element in the list freq = Counter(elements) # Keep elements that appear exactly once unique_elements = [el for el in elements if freq[el] == 1] # Return the sum of the remaining unique elements return sum(unique_elements)"},{"question":"def can_split_into_equal_sum_subsets(n: int, array: List[int]) -> str: Determines if an array can be split into two non-empty subsets with equal sums. Parameters: n (int): the number of elements in the array. array (list of int): the elements of the array. Returns: str: \\"YES\\" if possible, otherwise \\"NO\\". pass # Example usage: # >>> can_split_into_equal_sum_subsets(6, [3, 1, 1, 2, 2, 1]) # 'YES' # >>> can_split_into_equal_sum_subsets(5, [1, 2, 3, 5, 6]) # 'NO' from typing import List def test_can_split_into_equal_sum_subsets_example_1(): assert can_split_into_equal_sum_subsets(6, [3, 1, 1, 2, 2, 1]) == \\"YES\\" def test_can_split_into_equal_sum_subsets_example_2(): assert can_split_into_equal_sum_subsets(5, [1, 2, 3, 5, 6]) == \\"NO\\" def test_can_split_into_equal_sum_subsets_even_sum(): assert can_split_into_equal_sum_subsets(4, [1, 5, 11, 5]) == \\"YES\\" def test_can_split_into_equal_sum_subsets_odd_sum(): assert can_split_into_equal_sum_subsets(4, [1, 2, 3, 8]) == \\"NO\\" def test_can_split_into_equal_sum_subsets_single_odd_element(): assert can_split_into_equal_sum_subsets(3, [10, 6, 9]) == \\"NO\\" def test_can_split_into_equal_sum_subsets_single_even_element(): assert can_split_into_equal_sum_subsets(3, [2, 2, 2]) == \\"NO\\"","solution":"def can_split_into_equal_sum_subsets(n, array): Determines if an array can be split into two non-empty subsets with equal sums. Parameters: n (int): the number of elements in the array. array (list of int): the elements of the array. Returns: str: \\"YES\\" if possible, otherwise \\"NO\\". total_sum = sum(array) # Early exit if total sum is odd if total_sum % 2 != 0: return \\"NO\\" target = total_sum // 2 dp = [False] * (target + 1) dp[0] = True for num in array: for j in range(target, num - 1, -1): dp[j] = dp[j] or dp[j - num] return \\"YES\\" if dp[target] else \\"NO\\""},{"question":"def min_time_to_reach(x1: int, y1: int, x2: int, y2: int, E: int) -> Union[int, str]: Determines if the robot can reach from (x1, y1) to (x2, y2) within given energy E. Returns the minimum time required if possible, otherwise \\"NO\\". >>> min_time_to_reach(0, 0, 3, 4, 10) == 7 >>> min_time_to_reach(1, 2, 3, 4, 1) == \\"NO\\"","solution":"def min_time_to_reach(x1, y1, x2, y2, E): Determines if the robot can reach from (x1, y1) to (x2, y2) within given energy E. Returns the minimum time required if possible, otherwise \\"NO\\". # Calculate the Manhattan Distance min_time_required = abs(x2 - x1) + abs(y2 - y1) # Check if the energy is sufficient if min_time_required <= E: return min_time_required else: return \\"NO\\""},{"question":"def count_dependencies(n: int, k: int, tasks: List[int], conflicts: List[Tuple[int, int]]) -> List[int]: For each employee, find the number of other employees whose tasks can be depended upon by the task assigned to the employee. Args: n : int : total number of employees k : int : number of pairs of tasks which are in a dependency conflict tasks : List[int] : ids of the tasks assigned to the employees conflicts : List[Tuple[int, int]] : pairs of tasks in conflict Returns: List[int] : number of employees whose tasks can be depended upon by each employee's task pass from typing import List, Tuple def test_example_1(): n = 4 k = 2 tasks = [10, 4, 10, 15] conflicts = [(1, 2), (4, 3)] expected = [0, 0, 1, 2] assert count_dependencies(n, k, tasks, conflicts) == expected def test_example_2(): n = 10 k = 4 tasks = [5, 4, 1, 5, 4, 3, 7, 1, 2, 5] conflicts = [(4, 6), (2, 1), (10, 8), (3, 5)] expected = [5, 4, 0, 5, 3, 3, 9, 0, 2, 5] assert count_dependencies(n, k, tasks, conflicts) == expected def test_no_conflicts(): n = 5 k = 0 tasks = [1, 2, 3, 4, 5] conflicts = [] expected = [0, 1, 2, 3, 4] assert count_dependencies(n, k, tasks, conflicts) == expected def test_all_conflicts(): n = 3 k = 3 tasks = [3, 2, 1] conflicts = [(1, 2), (2, 3), (3, 1)] expected = [0, 0, 0] assert count_dependencies(n, k, tasks, conflicts) == expected","solution":"from collections import defaultdict def count_dependencies(n, k, tasks, conflicts): # Convert task IDs to employee indexing starting from 0 conflicts_set = set() for x, y in conflicts: conflicts_set.add((x - 1, y - 1)) conflicts_set.add((y - 1, x - 1)) result = [0] * n for i in range(n): for j in range(n): if i != j and tasks[i] > tasks[j] and (i, j) not in conflicts_set: result[i] += 1 return result def solve(n, k, task_ids, conflict_pairs): result = count_dependencies(n, k, task_ids, conflict_pairs) print(\\" \\".join(map(str, result)))"},{"question":"def largestRectangleArea(grid: List[List[int]]) -> int: Given an NxN grid where 0 represents empty cells and 1 represents treasure, find the area of the largest rectangle filled entirely with 1s. >>> largestRectangleArea([ ... [1, 0, 1, 0], ... [1, 0, 1, 1], ... [1, 1, 1, 1], ... [1, 0, 0, 1] ... ]) 4 >>> largestRectangleArea([ ... [1, 1, 0, 1] ... ]) 2 >>> largestRectangleArea([ ... [1], ... [1], ... [0], ... [1] ... ]) 2 >>> largestRectangleArea([ ... [0, 0, 0, 0], ... [0, 0, 0, 0], ... [0, 0, 0, 0], ... [0, 0, 0, 0] ... ]) 0 >>> largestRectangleArea([ ... [1, 1, 1, 1], ... [1, 1, 1, 1], ... [1, 1, 1, 1], ... [1, 1, 1, 1] ... ]) 16","solution":"def maximalRectangle(matrix): if not matrix: return 0 n = len(matrix) m = len(matrix[0]) max_area = 0 # create a dp array to store the height of 1's ending at each cell dp = [0] * m for i in range(n): for j in range(m): # update the dp array if matrix[i][j] == 1: dp[j] = dp[j] + 1 else: dp[j] = 0 # calculate the max area for the histogram formed by dp array max_area = max(max_area, calculateHistogramArea(dp)) return max_area def calculateHistogramArea(heights): stack = [] max_area = 0 heights.append(0) # Add a zero height to pop all elements from the stack at the end n = len(heights) for i in range(n): while stack and heights[i] < heights[stack[-1]]: h = heights[stack.pop()] w = i if not stack else i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) heights.pop() # Restore the heights array by removing the added zero return max_area def largestRectangleArea(grid): return maximalRectangle(grid)"},{"question":"def longest_consecutive_sequence(nums: List[int]) -> int: Find the length of the longest consecutive elements sequence from an unsorted array of integers. The time complexity should be O(n). >>> longest_consecutive_sequence([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive_sequence([0, 1, -1, 5, 2, 3]) 6 >>> longest_consecutive_sequence([10, 20, 30, 40]) 1 >>> longest_consecutive_sequence([1, 2, 3, 4, 5]) 5 >>> longest_consecutive_sequence([1]) 1 >>> longest_consecutive_sequence([]) 0 >>> longest_consecutive_sequence([1, 1, 1, 1]) 1","solution":"def longest_consecutive_sequence(nums): Find the length of the longest consecutive elements sequence from an unsorted array of integers. The time complexity should be O(n). if not nums: return 0 num_set = set(nums) max_length = 0 for num in nums: if num - 1 not in num_set: # only start counting if \`num\` is the start of a sequence current_num = num current_length = 1 while current_num + 1 in num_set: current_num += 1 current_length += 1 max_length = max(max_length, current_length) return max_length"},{"question":"from typing import List def manage_warehouse(commands: List[str]) -> str: A function that processes a series of commands to manage the queue in a warehouse and checks if the queue is in a strict increasing order at the end of operations. Args: commands (List[str]): A list of commands containing either \\"ADD x\\" or \\"REMOVE\\". Returns: str: \\"YES\\" if the queue is in a strict increasing order, \\"NO\\" otherwise. Examples: >>> manage_warehouse([\\"ADD 10\\", \\"ADD 15\\", \\"ADD 20\\"]) \\"YES\\" >>> manage_warehouse([\\"ADD 10\\", \\"ADD 5\\", \\"ADD 15\\"]) \\"NO\\" >>> manage_warehouse([\\"ADD 10\\", \\"ADD 15\\", \\"REMOVE\\", \\"ADD 20\\"]) \\"YES\\" >>> manage_warehouse([\\"REMOVE\\", \\"ADD 10\\", \\"ADD 20\\"]) \\"YES\\" >>> manage_warehouse([\\"ADD 10\\", \\"ADD 15\\", \\"REMOVE\\", \\"ADD 5\\"]) \\"NO\\" >>> manage_warehouse([\\"REMOVE\\", \\"REMOVE\\", \\"ADD 10\\", \\"ADD 20\\"]) \\"YES\\" >>> manage_warehouse([]) \\"YES\\"","solution":"from collections import deque def manage_warehouse(commands): queue = deque() for command in commands: if command.startswith(\\"ADD\\"): _, x = command.split() queue.append(int(x)) elif command == \\"REMOVE\\": if queue: queue.popleft() # Check if the queue is in strict increasing order for i in range(len(queue) - 1): if queue[i] >= queue[i + 1]: return \\"NO\\" return \\"YES\\""},{"question":"def create_garden(n: int) -> (int, List[str]): Creates the maximum number of distinct rows of length n. Each row can have 'P' (plant) or '.' (empty position). Args: n (int): Number of positions per row. Returns: int: Maximum diversity (number of distinct rows). List[str]: A list of strings representing the rows of the garden. pass def max_diverse_garden(T: int, ns: List[int]) -> List[Tuple[int, List[str]]]: Processes multiple test cases to output the maximum diverse garden layout for each given number of positions per row n. Args: T (int): Number of test cases. ns (List[int]): List of integers representing the number of positions per row for each test case. Returns: List[Tuple[int, List[str]]]: [(max_diversity, List of rows for garden)] pass from solution import create_garden, max_diverse_garden def test_create_garden_n_3(): max_diversity, garden_rows = create_garden(3) assert max_diversity == 8 expected_rows = [ '...', '..P', '.P.', '.PP', 'P..', 'P.P', 'PP.', 'PPP' ] assert garden_rows == expected_rows def test_create_garden_n_4(): max_diversity, garden_rows = create_garden(4) assert max_diversity == 16 expected_rows = [ '....', '...P', '..P.', '..PP', '.P..', '.P.P', '.PP.', '.PPP', 'P...', 'P..P', 'P.P.', 'P.PP', 'PP..', 'PP.P', 'PPP.', 'PPPP' ] assert garden_rows == expected_rows def test_max_diverse_garden(): results = max_diverse_garden(2, [3, 4]) assert results[0][0] == 8 assert results[1][0] == 16 assert results[0][1] == [ '...', '..P', '.P.', '.PP', 'P..', 'P.P', 'PP.', 'PPP' ] assert results[1][1] == [ '....', '...P', '..P.', '..PP', '.P..', '.P.P', '.PP.', '.PPP', 'P...', 'P..P', 'P.P.', 'P.PP', 'PP..', 'PP.P', 'PPP.', 'PPPP' ]","solution":"def create_garden(n): Creates the maximum number of distinct rows of length n. Each row can have 'P' (plant) or '.' (empty position). Args: n (int): Number of positions per row. Returns: List[str]: A list of strings representing the rows of the garden. max_diversity = 2**n garden_rows = [] for i in range(max_diversity): row = bin(i)[2:].zfill(n).replace('1', 'P').replace('0', '.') garden_rows.append(row) return max_diversity, garden_rows def max_diverse_garden(T, ns): Processes multiple test cases to output the maximum diverse garden layout for each given number of positions per row n. Args: T (int): Number of test cases. ns (List[int]): List of integers representing the number of positions per row for each test case. Returns: List[Tuple[int, List[str]]]: [(max_diversity, List of rows for garden)] results = [] for n in ns: max_diversity, garden_rows = create_garden(n) results.append((max_diversity, garden_rows)) return results"},{"question":"def apply_operations(n, m, array, operations): Applies a series of range update operations to an array. :param n: Length of the array :param m: Number of operations :param array: Initial state of the array :param operations: List of operations, each represented as a tuple (l, r, k) :return: The array after all operations have been applied >>> apply_operations(5, 3, [1, 2, 3, 4, 5], [(1, 3, 10), (2, 4, 5), (1, 5, 2)]) [13, 19, 20, 11, 7] >>> apply_operations(4, 2, [100, 200, 300, 400], [(2, 3, 50), (1, 4, 100)]) [200, 350, 450, 500]","solution":"def apply_operations(n, m, array, operations): Applies a series of range update operations to an array. :param n: Length of the array :param m: Number of operations :param array: Initial state of the array :param operations: List of operations, each represented as a tuple (l, r, k) :return: The array after all operations have been applied prefix_sum = [0] * (n + 1) # Apply operations using a difference array approach for l, r, k in operations: prefix_sum[l - 1] += k if r < n: prefix_sum[r] -= k # Update the array current_addition = 0 for i in range(n): current_addition += prefix_sum[i] array[i] += current_addition return array # Example usage: # apply_operations(5, 3, [1, 2, 3, 4, 5], [(1, 3, 10), (2, 4, 5), (1, 5, 2)]) -> [13, 19, 20, 11, 7]"},{"question":"def boost_power_level(y: int) -> (int, str): Determines the minimum increment to shift the creature's power level to the highest possible class and returns the increment along with the new class. Parameters: y (int): Current power level of the creature. Returns: int, str: Minimum increment in power level and the resulting class. >>> boost_power_level(85) (15, 'Y') >>> boost_power_level(450) (550, 'Z')","solution":"def boost_power_level(y): Determines the minimum increment to shift the creature's power level to the highest possible class and returns the increment along with the new class. Parameters: y (int): Current power level of the creature. Returns: int, str: Minimum increment in power level and the resulting class. if 1 <= y <= 9: # Current Class is W. if y + 91 <= 100: return (100 - y, 'Y') elif y + 999 <= 1000: return (1000 - y, 'Z') return (0, 'W') elif 10 <= y <= 99: # Current Class is X. if y + (100 - y) <= 100: return (100 - y, 'Y') elif y + (1000 - y) <= 1000: return (1000 - y, 'Z') return (0, 'X') elif 100 <= y <= 999: # Current Class is Y. if y + (1000 - y) <= 1000: return (1000 - y, 'Z') return (0, 'Y') elif 1000 <= y <= 9999: # Current Class is already the highest, Class Z. return (0, 'Z') return (0, 'W')"},{"question":"def is_path_exists(grid: List[str]) -> str: Checks if there is at least one path from the top-left corner of the grid to the bottom-right corner, moving only right or down. >>> is_path_exists([ ... \\"..#\\", ... \\".#.\\", ... \\"...\\" ... ]) 'YES' >>> is_path_exists([ ... \\"..#.\\", ... \\"#.\\", ... \\".#..\\", ... \\"....\\" ... ]) 'NO' >>> is_path_exists([ ... \\".#\\", ... \\"\\" ... ]) 'NO'","solution":"def is_path_exists(grid): from collections import deque n = len(grid) m = len(grid[0]) if grid[0][0] == '#' or grid[n-1][m-1] == '#': return \\"NO\\" directions = [(0, 1), (1, 0)] # Right and Down movements queue = deque([(0, 0)]) visited = set((0, 0)) while queue: x, y = queue.popleft() if (x, y) == (n-1, m-1): return \\"YES\\" for dx, dy in directions: new_x, new_y = x + dx, y + dy if 0 <= new_x < n and 0 <= new_y < m and (new_x, new_y) not in visited and grid[new_x][new_y] == '.': queue.append((new_x, new_y)) visited.add((new_x, new_y)) return \\"NO\\" def parse_input(): import sys input = sys.stdin.read data = input().split() n, m = int(data[0]), int(data[1]) grid = [data[i+2] for i in range(n)] return grid if __name__ == \\"__main__\\": grid = parse_input() print(is_path_exists(grid))"},{"question":"def sort_poke_balls(p: int, scores: List[int]) -> List[int]: Sorts Poke Balls in non-decreasing order of their scores, maintaining the relative order of Poke Balls with the same scores. Parameters: p (int): The number of Poke Balls. scores (list): A list of integers representing the scores of each Poke Ball. Returns: list: A list of sorted scores. Example: >>> sort_poke_balls(5, [6, 8, 5, 6, 9]) [5, 6, 6, 8, 9] >>> sort_poke_balls(4, [3, 3, 3, 3]) [3, 3, 3, 3]","solution":"def sort_poke_balls(p, scores): Sorts Poke Balls in non-decreasing order of their scores, maintaining the relative order of Poke Balls with the same scores. Parameters: p (int): The number of Poke Balls. scores (list): A list of integers representing the scores of each Poke Ball. Returns: list: A list of sorted scores. return sorted(scores, key=lambda x: x) # Example usage: # p = 5 # scores = [6, 8, 5, 6, 9] # Output should be [5, 6, 6, 8, 9]"},{"question":"def three_sum(nums: List[int]) -> List[List[int]]: Given an integer array nums, return all unique triplets [nums[i], nums[j], nums[k]] such that they sum up to zero >>> three_sum([-1, 0, 1, 2, -1, -4]) [[-1, -1, 2], [-1, 0, 1]] >>> three_sum([0, 1, 1]) [] >>> three_sum([0, 0, 0, 0]) [[0, 0, 0]]","solution":"def three_sum(nums): Return all unique triplets [nums[i], nums[j], nums[k]] such that they sum up to zero. nums.sort() result = [] n = len(nums) for i in range(n): if i > 0 and nums[i] == nums[i-1]: continue left, right = i + 1, n - 1 while left < right: total = nums[i] + nums[left] + nums[right] if total == 0: result.append([nums[i], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif total < 0: left += 1 else: right -= 1 return result"},{"question":"def isValidNumberString(s: str) -> bool: Checks if the string is valid according to the following rules: 1. Each digit from '0' to '9' must appear in consecutive pairs. 2. A digit can only appear in an even number of times in total. >>> isValidNumberString(\\"112233\\") True >>> isValidNumberString(\\"22335566\\") True >>> isValidNumberString(\\"123344\\") False >>> isValidNumberString(\\"1212\\") False from typing import List def test_valid_number_strings(): assert isValidNumberString(\\"112233\\") == True assert isValidNumberString(\\"22335566\\") == True assert isValidNumberString(\\"66778899\\") == True def test_invalid_number_strings(): assert isValidNumberString(\\"123344\\") == False assert isValidNumberString(\\"11223\\") == False assert isValidNumberString(\\"1233432\\") == False assert isValidNumberString(\\"121212\\") == False assert isValidNumberString(\\"111222\\") == False def test_edge_cases(): assert isValidNumberString(\\"11\\") == True assert isValidNumberString(\\"1234\\") == False assert isValidNumberString(\\"1212\\") == False def test_single_pair(): assert isValidNumberString(\\"11\\") == True assert isValidNumberString(\\"22\\") == True assert isValidNumberString(\\"33\\") == True def test_empty_and_min_length(): assert isValidNumberString(\\"\\") == False assert isValidNumberString(\\"1\\") == False","solution":"def isValidNumberString(s: str) -> bool: if len(s) < 2 or len(s) % 2 != 0: return False count = {} i = 0 while i < len(s): if i + 1 < len(s) and s[i] == s[i + 1]: count[s[i]] = count.get(s[i], 0) + 2 i += 2 else: return False for value in count.values(): if value % 2 != 0: return False return True"},{"question":"def longest_repeating_substring(S: str) -> int: Returns the length of the longest substring consisting of consecutive repeating characters. >>> longest_repeating_substring('aaabbccaa') 3 >>> longest_repeating_substring('ababab') 1","solution":"def longest_repeating_substring(S): Returns the length of the longest substring consisting of consecutive repeating characters. if not S: return 0 max_length = current_length = 1 prev_char = S[0] for char in S[1:]: if char == prev_char: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 prev_char = char max_length = max(max_length, current_length) return max_length"},{"question":"def second_highest_students(records: List[Dict[str, Union[str, int]]]) -> List[str]: Finds the names of the students with the second highest score. Parameters: records: List[Dict[str, Union[str, int]]] - List of dictionaries representing students' names and scores Returns: List[str] - List of names with the second highest score, sorted lexicographically >>> second_highest_students([{'name': 'John', 'score': 82}]) [] >>> second_highest_students([{'name': 'John', 'score': 82}, {'name': 'Emma', 'score': 82}]) [] >>> second_highest_students([{'name': 'John', 'score': 82}, {'name': 'Emma', 'score': 79}, {'name': 'Liam', 'score': 82}, {'name': 'Olivia', 'score': 95}, {'name': 'Noah', 'score': 79}]) ['John', 'Liam'] >>> second_highest_students([{'name': 'Alice', 'score': 70}, {'name': 'Bob', 'score': 80}, {'name': 'Charlie', 'score': 70}]) ['Alice', 'Charlie']","solution":"def second_highest_students(records): Finds the names of the students with the second highest score. Parameters: records: List[Dict[str, Union[str, int]]] - List of dictionaries representing students' names and scores Returns: List[str] - List of names with the second highest score, sorted lexicographically if not records or len(records) < 2: return [] scores = [record['score'] for record in records] unique_scores = sorted(set(scores), reverse=True) if len(unique_scores) < 2: return [] second_highest_score = unique_scores[1] second_highest_students = [record['name'] for record in records if record['score'] == second_highest_score] return sorted(second_highest_students)"},{"question":"def find_min_excluding_indices(test_cases: List[List[int]]) -> List[List[int]]: For each test case, find the minimum value in the array after removing each element in turn. >>> find_min_excluding_indices([[3, 1, 4, 2]]) [[1, 2, 1, 1]] >>> find_min_excluding_indices([[2, 7, 3]]) [[3, 2, 2]] >>> find_min_excluding_indices([[5, 6, 2, 8, 10]]) [[2, 2, 5, 2, 2]] pass def test_find_min_excluding_indices(): # Test case 1 input_data = [[3, 1, 4, 2]] expected_output = [[1, 2, 1, 1]] assert find_min_excluding_indices(input_data) == expected_output # Test case 2 input_data = [[2, 7, 3]] expected_output = [[3, 2, 2]] assert find_min_excluding_indices(input_data) == expected_output # Test case 3 input_data = [[5, 6, 2, 8, 10]] expected_output = [[2, 2, 5, 2, 2]] assert find_min_excluding_indices(input_data) == expected_output # Test case 4 input_data = [[1, 2, 3, 4, 5, 6, 7, 8]] expected_output = [[2, 1, 1, 1, 1, 1, 1, 1]] assert find_min_excluding_indices(input_data) == expected_output # Test case 5 input_data = [[4, 4, 4, 4]] expected_output = [[4, 4, 4, 4]] assert find_min_excluding_indices(input_data) == expected_output # Running the test test_find_min_excluding_indices()","solution":"def find_min_excluding_indices(test_cases): results = [] for arr in test_cases: n = len(arr) result = [] min_left = [float('inf')] * n min_right = [float('inf')] * n # Build the min_left array min_left[0] = arr[0] for i in range(1, n): min_left[i] = min(min_left[i-1], arr[i]) # Build the min_right array min_right[n-1] = arr[n-1] for i in range(n-2, -1, -1): min_right[i] = min(min_right[i+1], arr[i]) # Construct the result array for i in range(n): if i == 0: result.append(min_right[i+1]) elif i == n-1: result.append(min_left[i-1]) else: result.append(min(min_left[i-1], min_right[i+1])) results.append(result) return results def process_input_and_output(): import sys input = sys.stdin.read data = input().strip().split() t = int(data[0]) index = 1 test_cases = [] for _ in range(t): n = int(data[index]) arr = list(map(int, data[index+1 : index+1+n])) test_cases.append(arr) index += n + 1 results = find_min_excluding_indices(test_cases) for result in results: print(' '.join(map(str, result)))"},{"question":"def determine_winner(n: int, a: List[int]) -> str: Determines the winner of the game based on the array configuration. Parameters: n (int): Length of the array a (list of int): The elements of the array Returns: str: \\"Alice\\" or \\"Bob\\" Examples: >>> determine_winner(3, [1, 2, 3]) 'Alice' >>> determine_winner(4, [4, 4, 4, 4]) 'Bob' >>> determine_winner(2, [1, 1]) 'Bob' >>> determine_winner(5, [1, 1, 1, 1, 1]) 'Alice' >>> determine_winner(100000, [i for i in range(100000)]) 'Bob' >>> determine_winner(99999, [i for i in range(99999)]) 'Alice' >>> determine_winner(2, [1, 2]) 'Bob' >>> determine_winner(2, [100000, 100000]) 'Bob'","solution":"def determine_winner(n, a): Determines the winner of the game based on the array configuration. Parameters: n (int): Length of the array a (list of int): The elements of the array Returns: str: \\"Alice\\" or \\"Bob\\" # If the length of the array is odd, Alice wins if n % 2 == 1: return \\"Alice\\" else: return \\"Bob\\""},{"question":"def sum_below_threshold(n: int, elements: List[int], k: int) -> int: Given a list of integers and a threshold, return the sum of integers in the list that are below the threshold. :param n: Integer representing the number of elements in the list. :param elements: List of integers. :param k: Integer representing the threshold value. :return: Integer sum of elements below the threshold. >>> sum_below_threshold(5, [1, 2, 3, 4, 5], 3) 3 >>> sum_below_threshold(6, [-1, 0, 5, 10, -10, 3], 0) -11","solution":"def sum_below_threshold(n, elements, k): Given a list of integers and a threshold, return the sum of integers in the list that are below the threshold. :param n: Integer representing the number of elements in the list. :param elements: List of integers. :param k: Integer representing the threshold value. :return: Integer sum of elements below the threshold. return sum(x for x in elements if x < k) # Example Usage: # n = 5 # elements = [1, 2, 3, 4, 5] # k = 3 # print(sum_below_threshold(n, elements, k)) # Output: 3"},{"question":"def min_weight_difference(m, weights): Returns the minimum possible difference between the sum of the weights of the two groups. >>> min_weight_difference(5, [3, 1, 4, 2, 2]) 0 >>> min_weight_difference(4, [8, 8, 8, 8]) 0 >>> min_weight_difference(3, [1, 5, 3]) 1 >>> min_weight_difference(1, [100000]) 100000 >>> min_weight_difference(4, [6, 6, 6, 6]) 0 >>> min_weight_difference(3, [1, 1, 9]) 7 >>> min_weight_difference(2, [7, 5]) 2","solution":"def min_weight_difference(m, weights): Returns the minimum possible difference between the sum of the weights of the two groups. total_weight = sum(weights) possible_sums = {0} for weight in weights: new_sums = possible_sums.copy() for psum in possible_sums: new_sums.add(psum + weight) possible_sums = new_sums min_diff = float('inf') for psum in possible_sums: diff = abs(total_weight - 2 * psum) if diff < min_diff: min_diff = diff return min_diff"},{"question":"def max_activities(n: int, intervals: List[Tuple[int, int]]) -> int: Determines the maximum number of non-overlapping activities that can be attended. :param n: Number of activities :param intervals: List of tuples, each with start and end time of an activity :return: Maximum number of non-overlapping activities >>> max_activities(3, [(1, 4), (2, 3), (3, 5)]) 2 >>> max_activities(4, [(1, 2), (3, 4), (0, 6), (5, 7)]) 3 >>> max_activities(0, []) 0 >>> max_activities(1, [(1, 2)]) 1 >>> max_activities(3, [(1, 3), (2, 3), (3, 3)]) 2 >>> max_activities(3, [(1, 5), (2, 6), (3, 7)]) 1 >>> max_activities(3, [(1, 2), (2, 3), (3, 4)]) 3","solution":"def max_activities(n, intervals): Determines the maximum number of non-overlapping activities that can be attended. :param n: Number of activities :param intervals: List of tuples, each with start and end time of an activity :return: Maximum number of non-overlapping activities # Sort activities by their end time intervals.sort(key=lambda x: x[1]) count = 0 last_end_time = 0 for start, end in intervals: if start >= last_end_time: count += 1 last_end_time = end return count"},{"question":"def max_nutritional_value(n: int, m: int, caterpillars: List[int], leaves: List[int]) -> int: Determines the maximum total nutritional value that can be consumed by caterpillars without exceeding their individual capacities. Arguments: n -- int, number of caterpillars m -- int, number of leaves caterpillars -- list of ints, eating capacities of the caterpillars leaves -- list of ints, nutritional values of the leaves Returns: int -- maximum total nutritional value that can be consumed Examples: >>> max_nutritional_value(3, 5, [10, 20, 30], [5, 10, 15, 25, 30]) 60 >>> max_nutritional_value(2, 3, [5, 10], [3, 6, 8]) 11 pass","solution":"def max_nutritional_value(n, m, caterpillars, leaves): Determines the maximum total nutritional value that can be consumed by caterpillars without exceeding their individual capacities. Arguments: n -- int, number of caterpillars m -- int, number of leaves caterpillars -- list of ints, eating capacities of the caterpillars leaves -- list of ints, nutritional values of the leaves Returns: int -- maximum total nutritional value that can be consumed # Sort caterpillars by their eating capacities caterpillars.sort() # Sort leaves by their nutritional values in descending order to use high nutritional leaves first leaves.sort(reverse=True) max_value = 0 for capacity in caterpillars: total = 0 for i in range(len(leaves)): if total + leaves[i] <= capacity: total += leaves[i] leaves[i] = -1 # Mark leaf as eaten max_value += total # Remove the eaten leaves leaves = [leaf for leaf in leaves if leaf != -1] return max_value"},{"question":"from typing import List, Tuple def is_match(s: str, p: str) -> bool: Returns True if the entire string s matches the pattern p, which includes the special wildcard characters '?' and '*'. >>> is_match(\\"abc\\", \\"a?c\\") True >>> is_match(\\"abc\\", \\"a*\\") True >>> is_match(\\"acdcb\\", \\"a*c?b\\") False def match_patterns(test_cases: List[Tuple[str, str]]) -> List[bool]: Processes multiple test cases and determines if each string matches its pattern. >>> test_cases = [(\\"abc\\", \\"a?c\\"), (\\"abc\\", \\"a*\\"), (\\"acdcb\\", \\"a*c?b\\")] >>> match_patterns(test_cases) [True, True, False] >>> test_cases = [(\\"mississippi\\", \\"m??*ss*?i*pi\\"), (\\"adceb\\", \\"*a*b\\"), (\\"abcdef\\", \\"a*c?e\\")] >>> match_patterns(test_cases) [False, True, False]","solution":"def is_match(s, p): Returns True if the entire string s matches the pattern p, which includes the special wildcard characters '?' and '*'. len_s = len(s) len_p = len(p) dp = [[False] * (len_p + 1) for _ in range(len_s + 1)] dp[0][0] = True for i in range(1, len_p + 1): if p[i - 1] == '*': dp[0][i] = dp[0][i - 1] for i in range(1, len_s + 1): for j in range(1, len_p + 1): if p[j - 1] == '*': dp[i][j] = dp[i][j - 1] or dp[i - 1][j] elif p[j - 1] == '?' or s[i - 1] == p[j - 1]: dp[i][j] = dp[i - 1][j - 1] return dp[len_s][len_p] def match_patterns(test_cases): Processes multiple test cases and determines if each string matches its pattern. results = [] for s, p in test_cases: results.append(is_match(s, p)) return results"},{"question":"import heapq from typing import List def min_shipment_cost(n: int, weights: List[int]) -> int: Function to compute the minimum total cost required to reduce \`n\` boxes into one box. Parameters: n (int): Number of boxes weights (List[int]): List of initial weights of the boxes Returns: int: Minimum total cost required to reduce the boxes into one def test_min_shipment_cost_example1(): assert min_shipment_cost(4, [4, 3, 2, 6]) == 29 def test_min_shipment_cost_example2(): assert min_shipment_cost(3, [10, 20, 30]) == 90 def test_min_shipment_cost_single_merge(): assert min_shipment_cost(2, [1, 100]) == 101 def test_min_shipment_cost_multiple_merges(): assert min_shipment_cost(5, [1, 2, 3, 4, 5]) == 33 def test_min_shipment_cost_identical_weights(): assert min_shipment_cost(4, [5, 5, 5, 5]) == 40","solution":"import heapq def min_shipment_cost(n, weights): Function to compute the minimum total cost required to reduce \`n\` boxes into one box. Parameters: n (int): Number of boxes weights (List[int]): List of initial weights of the boxes Returns: int: Minimum total cost required to reduce the boxes into one # Create a priority queue (min-heap) from the weights list heapq.heapify(weights) total_cost = 0 while len(weights) > 1: # Extract the two lightest boxes first = heapq.heappop(weights) second = heapq.heappop(weights) # Merge them merged_weight = first + second # Add the cost of merging total_cost += merged_weight # Push the new box back into the heap heapq.heappush(weights, merged_weight) return total_cost"},{"question":"def process_operations(n: int, operations: List[str]) -> List[str]: Process a sequence of operations to determine the final stack of bricks. Args: n (int): The number of operations. operations (List[str]): A list of operations as described in the task. Returns: List[str]: The final stack of bricks from bottom to top, or [\\"empty\\"] if the stack is empty. >>> process_operations(8, [\\"add a 10\\", \\"add b 20\\", \\"add c 5\\", \\"remove\\", \\"add d 10\\", \\"add e 5\\", \\"remove\\", \\"remove\\"]) ['a'] >>> process_operations(5, [\\"add x 100\\", \\"add y 80\\", \\"add z 120\\", \\"remove\\", \\"add w 90\\"]) ['x', 'w']","solution":"def process_operations(n, operations): stack = [] for op in operations: parts = op.split() if parts[0] == \\"add\\": id = parts[1] strength = int(parts[2]) if not stack or stack[-1][1] >= strength: stack.append((id, strength)) elif parts[0] == \\"remove\\": if stack: stack.pop() if not stack: return [\\"empty\\"] else: return [brick[0] for brick in stack]"},{"question":"def spell_checker(dictionary: List[str], words: List[str]) -> List[str]: Given a list of words (\`dictionary\`) and a list of words to check (\`words\`), outputs \\"YES\\" if the word exists in the dictionary and \\"NO\\" otherwise. Parameters: dictionary (list of str): The list of words representing the dictionary. words (list of str): The list of words to check against the dictionary. Returns: list of str: \\"YES\\" or \\"NO\\" for each word in \`words\`. >>> spell_checker([\\"apple\\", \\"banana\\", \\"peach\\", \\"grape\\", \\"berry\\"], [\\"apple\\", \\"orange\\", \\"peach\\"]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> spell_checker([\\"cat\\", \\"dog\\", \\"mouse\\"], [\\"horse\\", \\"cat\\", \\"mouse\\", \\"kitten\\"]) [\\"NO\\", \\"YES\\", \\"YES\\", \\"NO\\"] from typing import List def test_spell_checker(): dictionary = [\\"apple\\", \\"banana\\", \\"peach\\", \\"grape\\", \\"berry\\"] words_to_check = [\\"apple\\", \\"orange\\", \\"peach\\"] expected_output = [\\"YES\\", \\"NO\\", \\"YES\\"] assert spell_checker(dictionary, words_to_check) == expected_output def test_spell_checker_with_unique_words(): dictionary = [\\"cat\\", \\"dog\\", \\"mouse\\"] words_to_check = [\\"horse\\", \\"cat\\", \\"mouse\\", \\"kitten\\"] expected_output = [\\"NO\\", \\"YES\\", \\"YES\\", \\"NO\\"] assert spell_checker(dictionary, words_to_check) == expected_output def test_spell_checker_all_no(): dictionary = [\\"carrot\\", \\"lettuce\\", \\"cabbage\\"] words_to_check = [\\"tomato\\", \\"potato\\", \\"onion\\"] expected_output = [\\"NO\\", \\"NO\\", \\"NO\\"] assert spell_checker(dictionary, words_to_check) == expected_output def test_spell_checker_all_yes(): dictionary = [\\"rock\\", \\"stone\\", \\"boulder\\"] words_to_check = [\\"rock\\", \\"stone\\", \\"boulder\\"] expected_output = [\\"YES\\", \\"YES\\", \\"YES\\"] assert spell_checker(dictionary, words_to_check) == expected_output def test_spell_checker_empty_check_list(): dictionary = [\\"alpha\\", \\"bravo\\", \\"charlie\\"] words_to_check = [] expected_output = [] assert spell_checker(dictionary, words_to_check) == expected_output def test_spell_checker_empty_dictionary(): dictionary = [] words_to_check = [\\"delta\\", \\"echo\\", \\"foxtrot\\"] expected_output = [\\"NO\\", \\"NO\\", \\"NO\\"] assert spell_checker(dictionary, words_to_check) == expected_output","solution":"def spell_checker(dictionary, words): Given a list of words (\`dictionary\`) and a list of words to check (\`words\`), outputs \\"YES\\" if the word exists in the dictionary and \\"NO\\" otherwise. Parameters: dictionary (list of str): The list of words representing the dictionary. words (list of str): The list of words to check against the dictionary. Returns: list of str: \\"YES\\" or \\"NO\\" for each word in \`words\`. dictionary_set = set(dictionary) result = [] for word in words: if word in dictionary_set: result.append(\\"YES\\") else: result.append(\\"NO\\") return result"},{"question":"def smallest_non_repeating_string(s: str) -> str: Given a string consisting of lowercase letters and a single occurrence of the wildcard character '*', replace the wildcard with a valid lowercase letter such that the resulting string is lexicographically the smallest possible valid string that does not contain any repeating consecutive characters. >>> smallest_non_repeating_string('a*c') == 'abc' >>> smallest_non_repeating_string('ab*cd') == 'abacd' >>> smallest_non_repeating_string('z*z') == 'zaz' >>> smallest_non_repeating_string('*yz') == 'ayz' >>> smallest_non_repeating_string('xy*') == 'xya' >>> smallest_non_repeating_string('a*a') == 'aba' >>> smallest_non_repeating_string('b*b') == 'bab' >>> smallest_non_repeating_string('c*c') == 'cac' >>> smallest_non_repeating_string('*b') == 'ab' >>> smallest_non_repeating_string('a*') == 'ab' >>> smallest_non_repeating_string('*') == 'a' pass","solution":"def smallest_non_repeating_string(s): import string # Convert the string to a list to allow modification s_list = list(s) # Define the alphabet alphabet = string.ascii_lowercase # Find the position of the wildcard character '*' wildcard_index = s_list.index('*') # Iterate through the alphabet and find the smallest valid character for char in alphabet: if (wildcard_index > 0 and s_list[wildcard_index - 1] == char) or (wildcard_index < len(s_list) - 1 and s_list[wildcard_index + 1] == char): continue # If the character is the same as the previous or next, skip it s_list[wildcard_index] = char break return ''.join(s_list)"},{"question":"from typing import List def has_pair_with_sum(arr: List[int], target: int) -> bool: Determines whether there is a pair of elements in the array that adds up to the target sum. :param arr: A list of integers. :param target: An integer representing the target sum. :return: True if there exists a pair of elements that adds up to the target sum, otherwise False. pass def test_has_pair_with_sum_example1(): assert has_pair_with_sum([2, 7, 11, 15], 9) == True def test_has_pair_with_sum_example2(): assert has_pair_with_sum([1, 2, 3, 4], 8) == False def test_has_pair_with_sum_empty(): assert has_pair_with_sum([], 5) == False def test_has_pair_with_sum_single_element(): assert has_pair_with_sum([10], 10) == False def test_has_pair_with_sum_duplicate_elements(): assert has_pair_with_sum([5, 5, 5, 5], 10) == True def test_has_pair_with_sum_large_numbers(): assert has_pair_with_sum([10**9, -10**9], 0) == True def test_has_pair_with_sum_negatives(): assert has_pair_with_sum([5, -5, 7, -3, 2, 0], 2) == True assert has_pair_with_sum([1, -2, 4, -1, 3], 5) == True assert has_pair_with_sum([1, -2, 4, 6, 3], -1) == True def test_has_pair_with_sum_mixed_sign_pairs(): assert has_pair_with_sum([1, 2, 3, -3, -2, -1], 0) == True def test_has_pair_with_sum_no_pair(): assert has_pair_with_sum([10, 20, 30, 40], 100) == False def test_has_pair_with_sum_same_element_twice(): assert has_pair_with_sum([3, 3, 5, 6], 6) == True","solution":"from typing import List def has_pair_with_sum(arr: List[int], target: int) -> bool: Determines whether there is a pair of elements in the array that adds up to the target sum. :param arr: A list of integers. :param target: An integer representing the target sum. :return: True if there exists a pair of elements that adds up to the target sum, otherwise False. seen = set() for num in arr: if (target - num) in seen: return True seen.add(num) return False"},{"question":"def is_complete_set(t: int, test_cases: list) -> list: Determine whether the given sequence is a complete set or not. >>> is_complete_set(3, [(4, [1, 2, 3, 4]), (5, [1, 2, 3, 3, 5]), (6, [1, 6, 5, 3, 2, 4])]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> is_complete_set(1, [(5, [1, 2, 3, 4, 5])]) [\\"YES\\"] >>> is_complete_set(1, [(5, [1, 2, 2, 4, 5])]) [\\"NO\\"] >>> is_complete_set(2, [(6, [6, 5, 4, 3, 2, 1]), (6, [6, 5, 4, 3, 2, 6])]) [\\"YES\\", \\"NO\\"] >>> is_complete_set(1, [(3, [3, 2, 1])]) [\\"YES\\"] Parameters: - t: int - The number of test cases. - test_cases: list of tuples - Each tuple contains an integer n (length of the sequence) and a list of n integers. Returns: - list of str - \\"YES\\" if the sequence is a complete set, otherwise \\"NO\\".","solution":"def is_complete_set(t, test_cases): results = [] for i in range(t): n, sequence = test_cases[i] unique_numbers = set(sequence) if len(unique_numbers) == n and all(1 <= num <= n for num in sequence): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def display_message(message: str, N: int): Prints the message in parts, each of length N characters. If the message length is less than or equal to N, it should print the entire message. >>> display_message(\\"HELLOTHERE\\", 5) HELLO THERE >>> display_message(\\"CODECHALLENGES\\", 4) CODE CHAL LENG ES >>> display_message(\\"SHORT\\", 10) SHORT >>> display_message(\\"SINGLE\\", 1) S I N G L E >>> display_message(\\"\\", 5)","solution":"def display_message(message, N): Prints the message in parts, each of length N characters. If the message length is less than or equal to N, it should print the entire message. for i in range(0, len(message), N): print(message[i:i + N])"},{"question":"def is_valid_equation(s: str) -> str: Given a string s, determine if it can be considered a valid equation in the form X=Y+Z, where X, Y, and Z are integers. The equation must meet the following criteria: 1. X should always be to the left of the equal sign '=' and should be either positive or negative integer. 2. Y and Z should always be to the right of the equal sign '=' and separated by a plus sign '+'. Y and Z should be either positive or negative integers. 3. At least one space should be present around the equal sign '=' and the plus sign '+'. 4. Both Y and Z can include leading zeros, but X should not have a leading zero unless it's zero itself. Args: s (str): The input string which may contain any characters with ASCII codes from 32 to 127, inclusive. Returns: str: \\"VALID\\" if the input is a valid equation, otherwise \\"INVALID\\". >>> is_valid_equation(\\"1 = 2 + 3\\") 'VALID' >>> is_valid_equation(\\"-10 = -2 + -8\\") 'VALID' >>> is_valid_equation(\\"12= 5+ 7\\") 'INVALID' >>> is_valid_equation(\\"1 =2 + 3\\") 'INVALID' >>> is_valid_equation(\\"-012 = -1 + 11\\") 'INVALID' >>> is_valid_equation(\\"1= 1 +1\\") 'INVALID' # Your code goes here","solution":"def is_valid_equation(s): This function checks if a given string s represents a valid equation in the form X=Y+Z. Args: s (str): The input string. Returns: str: \\"VALID\\" if the input is a valid equation, otherwise \\"INVALID\\". import re # Pattern for matching the valid equation pattern = r\\"^-?d+ = -?d+ + -?d+\\" if re.match(pattern, s): parts = s.split(\\"=\\") x = parts[0].strip() right_side = parts[1].strip().split(\\"+\\") y = right_side[0].strip() z = right_side[1].strip() if not x.lstrip(\\"-\\").startswith(\\"0\\") or x == \\"0\\": return \\"VALID\\" return \\"INVALID\\""},{"question":"def solve_sudoku(board: List[List[int]]) -> List[List[int]]: Solve the Sudoku puzzle by filling the empty cells. Args: board (List[List[int]]): A 9x9 grid representing a partially filled Sudoku. Returns: List[List[int]]: A solved 9x9 Sudoku grid. Example: >>> board = [ ... [5, 3, 0, 0, 7, 0, 0, 0, 0], ... [6, 0, 0, 1, 9, 5, 0, 0, 0], ... [0, 9, 8, 0, 0, 0, 0, 6, 0], ... [8, 0, 0, 0, 6, 0, 0, 0, 3], ... [4, 0, 0, 8, 0, 3, 0, 0, 1], ... [7, 0, 0, 0, 2, 0, 0, 0, 6], ... [0, 6, 0, 0, 0, 0, 2, 8, 0], ... [0, 0, 0, 4, 1, 9, 0, 0, 5], ... [0, 0, 0, 0, 8, 0, 0, 7, 9] ... ] >>> solve_sudoku(board) [[5, 3, 4, 6, 7, 8, 9, 1, 2], [6, 7, 2, 1, 9, 5, 3, 4, 8], [1, 9, 8, 3, 4, 2, 5, 6, 7], [8, 5, 9, 7, 6, 1, 4, 2, 3], [4, 2, 6, 8, 5, 3, 7, 9, 1], [7, 1, 3, 9, 2, 4, 8, 5, 6], [9, 6, 1, 5, 3, 7, 2, 8, 4], [2, 8, 7, 4, 1, 9, 6, 3, 5], [3, 4, 5, 2, 8, 6, 1, 7, 9]]","solution":"def solve_sudoku(board): if not board: return False def is_valid(board, row, col, num): for i in range(9): if board[row][i] == num or board[i][col] == num: return False box_r, box_c = row // 3 * 3, col // 3 * 3 for i in range(3): for j in range(3): if board[box_r + i][box_c + j] == num: return False return True def backtrack(board): for row in range(9): for col in range(9): if board[row][col] == 0: for num in range(1, 10): if is_valid(board, row, col, num): board[row][col] = num if backtrack(board): return True board[row][col] = 0 return False return True backtrack(board) return board"},{"question":"from typing import List, Tuple def can_reduce_to_zero_length(t: int, test_cases: List[Tuple[int, str]]) -> List[str]: Determines if it is possible to reduce the string to zero length using the operation that removes adjacent characters '01' or '10'. Args: t : int : The number of test cases. test_cases : List[Tuple[int, str]] : A list of test cases, each containing the length of the string and the string itself. Returns: List[str] : A list containing \\"YES\\" or \\"NO\\" for each test case. >>> can_reduce_to_zero_length(4, [(4, \\"1100\\"), (3, \\"101\\"), (5, \\"11111\\"), (6, \\"100101\\")]) [\\"YES\\", \\"NO\\", \\"NO\\", \\"YES\\"] >>> can_reduce_to_zero_length(1, [(4, \\"0000\\")]) [\\"NO\\"] >>> can_reduce_to_zero_length(1, [(4, \\"1111\\")]) [\\"NO\\"] >>> can_reduce_to_zero_length(1, [(2, \\"01\\")]) [\\"YES\\"] >>> can_reduce_to_zero_length(1, [(3, \\"001\\")]) [\\"NO\\"] >>> can_reduce_to_zero_length(1, [(100000, \\"01\\" * 50000)]) [\\"YES\\"]","solution":"def can_reduce_to_zero_length(t, test_cases): results = [] for i in range(t): n, s = test_cases[i] # The key observation is that any \\"01\\" or \\"10\\" can be removed, # making the length of the string decrease by 2. # This implies that if the final length of the transformed string # is possible to be zero, it indicates that the initial number of 1s # and 0s are the same. count_1 = s.count('1') count_0 = s.count('0') if count_1 == count_0: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def find_files(file_paths: List[str], filename: str) -> Union[str, List[str]]: Returns a list of absolute file paths that match the given filename. If no such file exists, returns \\"No files found\\". >>> find_files( ... [ ... \\"/home/user/documents/file.txt\\", ... \\"/home/user/music/track.mp3\\", ... \\"/home/user/documents/notes.txt\\", ... \\"/home/user/file.txt\\", ... \\"/music/track.mp3\\", ... \\"/var/log/syslog\\", ... \\"/home/user/documents/book.pdf\\", ... \\"/home/user/documents/archive/file.txt\\" ... ], \\"file.txt\\") [\\"/home/user/documents/archive/file.txt\\", \\"/home/user/documents/file.txt\\", \\"/home/user/file.txt\\"] >>> find_files( ... [ ... \\"/usr/bin/gcc\\", ... \\"/usr/local/bin/gcc\\", ... \\"/home/user/programs/somefile.c\\", ... \\"/usr/bin/python\\", ... \\"/usr/local/bin/python\\" ... ], \\"clang\\") \\"No files found\\"","solution":"def find_files(file_paths, filename): Returns a list of absolute file paths that match the given filename. If no such file exists, returns \\"No files found\\". matching_paths = [path for path in file_paths if path.endswith(f'/{filename}')] if not matching_paths: return \\"No files found\\" return sorted(matching_paths) # Example usage: # file_paths = [ # \\"/home/user/documents/file.txt\\", # \\"/home/user/music/track.mp3\\", # \\"/home/user/documents/notes.txt\\", # \\"/home/user/file.txt\\", # \\"/music/track.mp3\\", # \\"/var/log/syslog\\", # \\"/home/user/documents/book.pdf\\", # \\"/home/user/documents/archive/file.txt\\" # ] # filename = \\"file.txt\\" # print(find_files(file_paths, filename))"},{"question":"from typing import List def minimum_blocks(k: int, blocks: List[int]) -> int: Find the minimum number of blocks needed to redeem exactly k points, or return -1 if it is not possible. Args: k (int): an integer representing the exact points a customer needs to redeem. blocks (List[int]): a list of integers representing the available block values. Returns: int: the minimum number of blocks required to redeem exactly \`k\` points. If it is not possible, return -1. Examples: >>> minimum_blocks(25, [1, 5, 10]) 3 >>> minimum_blocks(7, [3, 4]) 2 >>> minimum_blocks(8, [5, 9]) -1 def test_example1(): assert minimum_blocks(25, [1, 5, 10]) == 3 def test_example2(): assert minimum_blocks(7, [3, 4]) == 2 def test_example3(): assert minimum_blocks(8, [5, 9]) == -1 def test_single_block(): assert minimum_blocks(10, [10]) == 1 def test_multiple_species_blocks(): assert minimum_blocks(11, [1, 2, 5]) == 3 # Best combo: 5, 5, 1 def test_no_possible_combinations(): assert minimum_blocks(7, [2, 4]) == -1 # No combination of 2 and 4 gives 7 def test_large_k_and_blocks(): assert minimum_blocks(100, [1, 2, 5, 10]) == 10 # Best combo: ten 10s def test_minimum_k(): assert minimum_blocks(1, [1, 5, 10]) == 1 def test_large_single_block(): assert minimum_blocks(99999, [1, 99999]) == 1 # Only one block of 99999 is needed def test_large_plus_small_blocks(): assert minimum_blocks(100000, [1, 99999, 100000]) == 1 # Only one block of 100000 is needed","solution":"from typing import List def minimum_blocks(k: int, blocks: List[int]) -> int: # Initialize the DP array with infinite values dp = [float('inf')] * (k + 1) dp[0] = 0 # It takes 0 blocks to achieve 0 points # Process each amount from 1 to k for i in range(1, k + 1): for block in blocks: if i >= block: dp[i] = min(dp[i], dp[i - block] + 1) # If dp[k] is still infinity, it means we can't form k points return dp[k] if dp[k] != float('inf') else -1"},{"question":"def longest_special_sequence(n: int, notes: List[int]) -> int: Determine the length of the longest special sequence (either rising or falling) from the given sequence of notes. >>> longest_special_sequence(7, [1, 2, 3, 4, 5, 3, 2]) 5 >>> longest_special_sequence(10, [1, 4, 5, 6, 3, 2, 1, 1, 2, 3]) 4 >>> longest_special_sequence(5, [5, 4, 3, 2, 1]) 5 import pytest from solution import longest_special_sequence def test_longest_special_sequence_case1(): assert longest_special_sequence(7, [1, 2, 3, 4, 5, 3, 2]) == 5 def test_longest_special_sequence_case2(): assert longest_special_sequence(10, [1, 4, 5, 6, 3, 2, 1, 1, 2, 3]) == 4 def test_longest_special_sequence_case3(): assert longest_special_sequence(5, [5, 4, 3, 2, 1]) == 5 def test_longest_special_sequence_single_note(): assert longest_special_sequence(1, [42]) == 1 def test_longest_special_sequence_all_equal_notes(): assert longest_special_sequence(5, [5, 5, 5, 5, 5]) == 1 def test_longest_special_sequence_alternating(): assert longest_special_sequence(5, [1, 3, 2, 4, 3]) == 2 def test_longest_special_sequence_rising_and_falling(): assert longest_special_sequence(6, [1, 2, 3, 2, 1, 2]) == 3","solution":"def longest_special_sequence(n, notes): if n == 0: return 0 max_len = 1 # to store the length of the longest special sequence current_len = 1 # Check for the longest rising sequence for i in range(1, n): if notes[i] > notes[i - 1]: current_len += 1 else: max_len = max(max_len, current_len) current_len = 1 max_len = max(max_len, current_len) current_len = 1 # Check for the longest falling sequence for i in range(1, n): if notes[i] < notes[i - 1]: current_len += 1 else: max_len = max(max_len, current_len) current_len = 1 max_len = max(max_len, current_len) return max_len"},{"question":"def sort_words_by_length(n: int, words: str) -> str: Given a sequence of words, sort them according to their length in ascending order. If two words have the same length, preserve their original order in the input. >>> sort_words_by_length(7, 'word sorting is a fun coding challenge') 'a is fun word coding sorting challenge' >>> sort_words_by_length(3, 'cat mat fat') 'cat mat fat'","solution":"def sort_words_by_length(n, words): Given a list of words, sort them according to their length in ascending order. If two words have the same length, preserve their original order. words_list = words.split() sorted_words = sorted(words_list, key=len) return ' '.join(sorted_words)"},{"question":"def max_submatrix_sum(matrix: List[List[int]], N: int, M: int) -> int: Calculate the maximum sum of elements in any submatrix. The function takes as input a matrix of size N x M filled with integers and returns the maximum sum of elements that can be found in any submatrix. Args: matrix (List[List[int]]): The input matrix containing integers. N (int): Number of rows in the matrix. M (int): Number of columns in the matrix. Returns: int: The maximum sum of elements of any submatrix. Example: >>> max_submatrix_sum([[1, -2, 3], [-4, 5, -6], [7, -8, 9]], 3, 3) 9 >>> max_submatrix_sum([[-1, -2], [-3, -4]], 2, 2) -1 import pytest from solution import max_submatrix_sum def test_single_element_positive(): matrix = [[5]] assert max_submatrix_sum(matrix, 1, 1) == 5 def test_single_element_negative(): matrix = [[-5]] assert max_submatrix_sum(matrix, 1, 1) == -5 def test_all_positive(): matrix = [ [1, 2], [3, 4] ] assert max_submatrix_sum(matrix, 2, 2) == 10 def test_all_negative(): matrix = [ [-1, -2], [-3, -4] ] assert max_submatrix_sum(matrix, 2, 2) == -1 def test_mixed(): matrix = [ [1, -2, 3], [-4, 5, -6], [7, -8, 9] ] assert max_submatrix_sum(matrix, 3, 3) == 9 def test_large_matrix(): matrix = [ [1, 2, -1, -4, -20], [-8, -3, 4, 2, 1], [3, 8, 10, 1, 3], [-4, -1, 1, 7, -6] ] assert max_submatrix_sum(matrix, 4, 5) == 29 def test_another_matrix(): matrix = [ [2, 1, -3, -4, 5], [0, 6, 3, 4, 1], [2, -2, -1, 4, -5], [-3, 3, 1, 0, 3] ] assert max_submatrix_sum(matrix, 4, 5) == 18","solution":"def max_submatrix_sum(matrix, N, M): # Helper function to calculate maximum subarray sum for a given 1D array def max_subarray_sum(arr): max_ending_here = max_so_far = arr[0] for x in arr[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far max_sum = float('-inf') # Traverse all possible pairs of starting and ending rows for start_row in range(N): # Temporary array to store cumulative sums for subarrays temp = [0] * M for end_row in range(start_row, N): for col in range(M): temp[col] += matrix[end_row][col] # Find maximum subarray sum in this 1D array max_sum = max(max_sum, max_subarray_sum(temp)) return max_sum"},{"question":"def highest_scorers(n: int, scores: List[Tuple[str, int]]) -> List[str]: Finds the student(s) with the highest score and returns their names in lexicographical order. :param n: The number of students :param scores: A list of tuples containing student names and their scores :return: A list of student names with the highest score, sorted lexicographically >>> highest_scorers(4, [(\\"alice\\", 90), (\\"bob\\", 95), (\\"charlie\\", 95), (\\"dave\\", 85)]) == [\\"bob\\", \\"charlie\\"] >>> highest_scorers(3, [(\\"eve\\", 78), (\\"john\\", 88), (\\"jack\\", 84)]) == [\\"john\\"] >>> highest_scorers(5, [(\\"rachel\\", 77), (\\"monica\\", 85), (\\"phoebe\\", 77), (\\"ross\\", 85), (\\"jerry\\", 77)]) == [\\"monica\\", \\"ross\\"] >>> highest_scorers(0, []) == [] >>> highest_scorers(2, [(\\"anna\\", 50), (\\"emma\\", 50)]) == [\\"anna\\", \\"emma\\"] >>> highest_scorers(3, [(\\"zack\\", 100), (\\"yule\\", 50), (\\"xander\\", 100)]) == [\\"xander\\", \\"zack\\"]","solution":"def highest_scorers(n, scores): Finds the student(s) with the highest score and returns their names in lexicographical order. :param n: The number of students :param scores: A list of tuples containing student names and their scores :return: A list of student names with the highest score, sorted lexicographically if not scores or n == 0: return [] # Find the highest score highest_score = max(score for _, score in scores) # Collect names of students with the highest score highest_scorers = [name for name, score in scores if score == highest_score] # Sort the names lexicographically highest_scorers.sort() return highest_scorers"},{"question":"def run_length_encode(rows): Compress each row of the grid using run-length encoding. Arguments: rows (List[str]): A list of strings representing each row of the grid. Returns: List[str]: A list of run-length encoded strings for each row. Example: >>> run_length_encode([\\"WWWBB\\"]) [\\"3W2B\\"] >>> run_length_encode([\\"WWWBB\\", \\"BBBWW\\"]) [\\"3W2B\\", \\"3B2W\\"]","solution":"def run_length_encode(rows): result = [] for row in rows: encoded_row = \\"\\" i = 0 while i < len(row): count = 1 while i + 1 < len(row) and row[i] == row[i + 1]: count += 1 i += 1 encoded_row += str(count) + row[i] i += 1 result.append(encoded_row) return result if __name__ == \\"__main__\\": r, c = map(int, input().split()) rows = [input().strip() for _ in range(r)] encoded_rows = run_length_encode(rows) for encoded_row in encoded_rows: print(encoded_row)"},{"question":"def longest_path(grid): Finds the length of the longest path of consecutive distinct characters in a grid. Args: grid (List[List[str]]): A 2D grid of characters. Returns: int: Length of the longest path. Example usage: >>> longest_path([\\"abc\\", \\"def\\", \\"ghi\\"]) 9 >>> longest_path([\\"aabc\\", \\"defg\\", \\"hijk\\", \\"lmno\\"]) 16 >>> longest_path([\\"ab\\", \\"ba\\"]) 4 def get_longest_paths(test_cases): Compute longest paths for multiple test cases. Args: test_cases (List[List[List[str]]]): List of test cases, each containing a grid. Returns: List[int]: List of longest path lengths for each test case. def parse_input(input_data): Parse the input data. Args: input_data (str): The input data as a string. Returns: List[List[List[str]]]: Parsed test cases. from solution import get_longest_paths, parse_input def test_longest_path_case_1(): input_data = \\"3n3 3nabcndefnghin4 4naabcndefgnhijknlmnon2 2nabnba\\" expected_output = [9, 16, 4] test_cases = parse_input(input_data) assert get_longest_paths(test_cases) == expected_output def test_longest_path_case_2(): input_data = \\"1n3 3nabcndefnghi\\" expected_output = [9] test_cases = parse_input(input_data) assert get_longest_paths(test_cases) == expected_output def test_longest_path_case_3(): input_data = \\"1n4 4naabcndefgnhijknlmno\\" expected_output = [16] test_cases = parse_input(input_data) assert get_longest_paths(test_cases) == expected_output def test_longest_path_case_4(): input_data = \\"1n2 2nabnba\\" expected_output = [4] test_cases = parse_input(input_data) assert get_longest_paths(test_cases) == expected_output def test_longest_path_case_5(): input_data = \\"1n1 1na\\" expected_output = [1] test_cases = parse_input(input_data) assert get_longest_paths(test_cases) == expected_output","solution":"def longest_path(grid): n = len(grid) m = len(grid[0]) def dfs(x, y, visited): max_length = 1 # The starting point itself is countable. visited.add((x, y)) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # up, down, left, right for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] not in visited: max_length = max(max_length, 1 + dfs(nx, ny, visited)) visited.remove((x, y)) return max_length max_result = 0 for i in range(n): for j in range(m): max_result = max(max_result, dfs(i, j, set())) return max_result def get_longest_paths(test_cases): results = [] for grid in test_cases: results.append(longest_path(grid)) return results def parse_input(input_data): lines = input_data.strip().split('n') t = int(lines[0]) index = 1 test_cases = [] for _ in range(t): n, m = map(int, lines[index].split()) grid = [lines[index + i + 1] for i in range(n)] test_cases.append(grid) index += n + 1 return test_cases"},{"question":"import random from typing import List def generate_maze(n: int, m: int) -> List[List[str]]: Generates a random maze of dimensions n x m. The maze is represented using '#' for walls and '.' for open spaces. pass def solve_maze(maze: List[List[str]]) -> List[List[str]]: Finds a path in the maze from the top-left corner to the bottom-right corner using DFS. The path is marked with '*' characters. pass def print_maze(maze: List[List[str]]) -> None: Prints the maze grid. pass def generate_and_solve_maze(n: int, m: int) -> None: Generates a random maze and then solves it using Depth-First Search (DFS) algorithm. Prints the original and solved maze. pass # Unit Tests def test_generate_maze_dimensions(): for n in range(2, 6): for m in range(2, 6): maze = generate_maze(n, m) assert len(maze) == n assert all(len(row) == m for row in maze) def test_generate_maze_paths(): maze = generate_maze(5, 5) assert maze[0][0] == '.' assert maze[4][4] == '.' def test_solve_maze_complete_path(): maze = [ ['.', '.', '#', '#', '#'], ['#', '.', '#', '#', '#'], ['#', '.', '.', '.', '#'], ['#', '#', '#', '.', '#'], ['#', '#', '#', '.', '.'] ] solved_maze = solve_maze(maze) expected_path = [ ['*', '*', '#', '#', '#'], ['#', '*', '#', '#', '#'], ['#', '*', '*', '*', '#'], ['#', '#', '#', '*', '#'], ['#', '#', '#', '*', '*'] ] for i in range(5): for j in range(5): assert solved_maze[i][j] == expected_path[i][j]","solution":"import random def generate_maze(n, m): Generates a random maze of dimensions n x m. The maze is represented using '#' for walls and '.' for open spaces. # Initialize the maze with walls maze = [['#'] * m for _ in range(n)] # DFS to carve out a random path def carve_passages(cx, cy): directions = [(0,1), (1,0), (0,-1), (-1,0)] random.shuffle(directions) for dx, dy in directions: nx, ny = cx + dx, cy + dy if 0 < nx < n-1 and 0 < ny < m-1 and maze[nx][ny] == '#': # Check if the next cell is surrounded by walls if ((nx == 1 and maze[nx+1][ny] == '#') or (ny == 1 and maze[nx][ny+1] == '#') or maze[nx-1][ny] == '#' and maze[nx+1][ny] == '#' and maze[nx][ny-1] == '#' and maze[nx][ny+1] == '#'): maze[nx][ny] = '.' carve_passages(nx, ny) maze[1][1] = '.' carve_passages(1, 1) # Ensure start (0,0) and goal (n-1,m-1) are open spaces maze[0][0] = '.' maze[n-1][m-1] = '.' return maze def solve_maze(maze): Finds a path in the maze from the top-left corner to the bottom-right corner using DFS. The path is marked with '*' characters. n = len(maze) m = len(maze[0]) path = [] visited = [[False] * m for _ in range(n)] def dfs(x, y): if x == n-1 and y == m-1: path.append((x, y)) return True if not (0 <= x < n and 0 <= y < m) or maze[x][y] == '#' or visited[x][y]: return False visited[x][y] = True path.append((x, y)) for dx, dy in [(0,1), (1,0), (0,-1), (-1,0)]: if dfs(x + dx, y + dy): return True path.pop() return False dfs(0, 0) for x, y in path: maze[x][y] = '*' return maze def print_maze(maze): for row in maze: print(''.join(row)) def generate_and_solve_maze(n, m): maze = generate_maze(n, m) print_maze(maze) print('n') solved_maze = solve_maze(maze) print_maze(solved_maze)"},{"question":"def max_subarray_sum(nums: List[int]) -> Tuple[int, List[int]]: Given a list of integers, find the sublist with the maximum sum. The sublist must consist of contiguous elements, and you are required to return both the sum and the sublist itself. >>> max_subarray_sum([1]) (1, [1]) >>> max_subarray_sum([1, 2, 3, 4]) (10, [1, 2, 3, 4]) >>> max_subarray_sum([-1, -2, -3, -4]) (-1, [-1]) >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) (6, [4, -1, 2, 1]) >>> max_subarray_sum([-1]*100000) (-1, [-1]) >>> max_subarray_sum([-1, 2, -3, 4, -5, 6]) (6, [6]) >>> max_subarray_sum([1, 2, -1, 2, 3, -4, 5, 0]) (8, [1, 2, -1, 2, 3, -4, 5]) >>> max_subarray_sum([]) (0, [])","solution":"def max_subarray_sum(nums): Returns the sum and the sublist with the maximum sum from the input list of integers. n = len(nums) if n == 0: return 0, [] # Initialize variables for Kadane's algorithm max_sum = nums[0] current_sum = nums[0] start, end, temp_start = 0, 0, 0 for i in range(1, n): if current_sum < 0: current_sum = nums[i] temp_start = i else: current_sum += nums[i] if current_sum > max_sum: max_sum = current_sum start = temp_start end = i return max_sum, nums[start:end+1]"},{"question":"def max_items_within_budget(n: int, b: int, costs: List[int]) -> int: Returns the maximum number of items that can be purchased without exceeding the budget b. Args: n (int): The number of items. b (int): The budget. costs (List[int]): A list of costs for each item. Returns: int: The maximum number of items that can be purchased within the budget. >>> max_items_within_budget(5, 20, [4, 8, 6, 2, 10]) 4 >>> max_items_within_budget(4, 50, [10, 20, 30, 40]) 2 >>> max_items_within_budget(6, 100, [1, 2, 2, 2, 5, 8]) 6 >>> max_items_within_budget(3, 5, [7, 3, 4]) 1 from typing import List def test_max_items_within_budget_example1(): assert max_items_within_budget(5, 20, [4, 8, 6, 2, 10]) == 4 def test_max_items_within_budget_example2(): assert max_items_within_budget(4, 50, [10, 20, 30, 40]) == 2 def test_max_items_within_budget_example3(): assert max_items_within_budget(6, 100, [1, 2, 2, 2, 5, 8]) == 6 def test_max_items_within_budget_example4(): assert max_items_within_budget(3, 5, [7, 3, 4]) == 1 def test_max_items_within_budget_all_same_cost(): assert max_items_within_budget(4, 8, [2, 2, 2, 2]) == 4 def test_max_items_within_budget_large_budget(): assert max_items_within_budget(3, 1000, [100, 200, 300]) == 3 def test_max_items_within_budget_large_inputs(): n = 10**6 b = 10**18 costs = [10**9] * n assert max_items_within_budget(n, b, costs) == n","solution":"def max_items_within_budget(n, b, costs): Returns the maximum number of items that can be purchased within budget b. Args: n (int): The number of items. b (int): The budget. costs (List[int]): A list of costs for each item. Returns: int: The maximum number of items that can be purchased. # Sort the item costs in ascending order costs.sort() # Initialize the count of items and the current total cost count = 0 total_cost = 0 # Iterate over the sorted costs and accumulate the total cost for cost in costs: if total_cost + cost <= b: total_cost += cost count += 1 else: break # If we exceed the budget, stop purchasing further items return count"},{"question":"class ArrayManipulator: def __init__(self, array): Initialize with the given array. Arguments: array -- list of integers self.array = array def add_to_subarray(self, l, r, v): Add the value v to each element in the subarray A[l], A[l+1], ..., A[r]. Arguments: l -- starting index of the subarray (0-based indexing) r -- ending index of the subarray (0-based indexing) v -- value to add to each element in the subarray pass def query_max_in_subarray(self, l, r): Query the maximum value in the subarray A[l], A[l+1], ..., A[r]. Arguments: l -- starting index of the subarray (0-based indexing) r -- ending index of the subarray (0-based indexing) Returns: The maximum value in the specified subarray. pass def perform_operations(array, operations): Perform a sequence of operations on the array. Arguments: array -- the initial array of integers. operations -- list of operations to perform on the array, where each operation is a tuple. The first element of the tuple determines the type of the operation: (1, l, r, v) -- add the value v to the subarray A[l], ..., A[r] (2, l, r) -- query the maximum value in the subarray A[l], ..., A[r] Returns: List of results for the query operations. manipulator = ArrayManipulator(array) results = [] for op in operations: if op[0] == 1: # Add to subarray _, l, r, v = op manipulator.add_to_subarray(l - 1, r - 1, v) elif op[0] == 2: # Query max in subarray _, l, r = op results.append(manipulator.query_max_in_subarray(l - 1, r - 1)) return results import pytest def test_example(): array = [1, 3, 5, 7, 9, 11] operations = [ (1, 2, 4, 5), (2, 1, 5), (2, 2, 6), (1, 3, 5, 10), (2, 4, 6) ] assert perform_operations(array, operations) == [12, 12, 22] def test_single_element_addition(): array = [0] operations = [ (1, 1, 1, 10), (2, 1, 1) ] assert perform_operations(array, operations) == [10] def test_multiple_operations(): array = [0, 0, 0, 0, 0] operations = [ (1, 1, 3, 1), (2, 1, 5), (1, 4, 5, 2), (2, 3, 5) ] assert perform_operations(array, operations) == [1, 2] def test_no_operations(): array = [1, 2, 3, 4, 5] operations = [] assert perform_operations(array, operations) == [] def test_large_values(): array = [10**9] * 5 operations = [ (1, 1, 5, 1), (2, 1, 5) ] assert perform_operations(array, operations) == [10**9 + 1]","solution":"class ArrayManipulator: def __init__(self, array): self.array = array def add_to_subarray(self, l, r, v): for i in range(l, r + 1): self.array[i] += v def query_max_in_subarray(self, l, r): return max(self.array[l:r + 1]) def perform_operations(array, operations): manipulator = ArrayManipulator(array) results = [] for op in operations: if op[0] == 1: # Add to subarray _, l, r, v = op manipulator.add_to_subarray(l - 1, r - 1, v) elif op[0] == 2: # Query max in subarray _, l, r = op results.append(manipulator.query_max_in_subarray(l - 1, r - 1)) return results"},{"question":"def longest_arithmetic_subsequence_length(positions: List[int]) -> int: Determine the length of the longest subsequence of positions that form an arithmetic progression. Args: positions (List[int]): A list of integers representing the positions at each snapshot. Returns: int: The length of the longest subsequence forming an arithmetic progression. Examples: >>> longest_arithmetic_subsequence_length([1, 7, 10, 13, 14, 19, 20, 33, 36, 2]) 4 >>> longest_arithmetic_subsequence_length([10]) 1 >>> longest_arithmetic_subsequence_length([]) 0 >>> longest_arithmetic_subsequence_length([5, 5, 5, 5, 5]) 5 >>> longest_arithmetic_subsequence_length([1, 2, 4, 8, 16]) 2 from typing import List def test_sample_input(): positions = [1, 7, 10, 13, 14, 19, 20, 33, 36, 2] assert longest_arithmetic_subsequence_length(positions) == 4 def test_single_element(): positions = [10] assert longest_arithmetic_subsequence_length(positions) == 1 def test_no_elements(): positions = [] assert longest_arithmetic_subsequence_length(positions) == 0 def test_all_same_elements(): positions = [5, 5, 5, 5, 5] assert longest_arithmetic_subsequence_length(positions) == 5 def test_no_arithmetic_subsequences(): positions = [1, 2, 4, 8, 16] assert longest_arithmetic_subsequence_length(positions) == 2 def test_longest_found_in_beginning(): positions = [1, 2, 3, 4, 10, 15, 20, 25] assert longest_arithmetic_subsequence_length(positions) == 4 def test_longest_found_in_middle(): positions = [10, 1, 2, 3, 4, 15, 20, 25] assert longest_arithmetic_subsequence_length(positions) == 4 def test_longest_found_in_end(): positions = [10, 1, 2, 15, 20, 25, 3, 4] assert longest_arithmetic_subsequence_length(positions) == 4","solution":"def longest_arithmetic_subsequence_length(positions): N = len(positions) if N == 0: return 0 if N == 1: return 1 positions.sort() longest = 1 dp = [{} for _ in range(N)] for i in range(N): for j in range(i): diff = positions[i] - positions[j] if diff in dp[j]: dp[i][diff] = dp[j][diff] + 1 else: dp[i][diff] = 2 longest = max(longest, dp[i][diff]) return longest"},{"question":"def max_buildings_in_increasing_order(n: int, heights: List[int]) -> int: Finds the maximum number of buildings that can be joined together to form a single contiguous block with strictly increasing heights. Parameters: n (int): The number of buildings. heights (list): The heights of the buildings. Returns: int: The maximum number of buildings in strictly increasing order. Examples: >>> max_buildings_in_increasing_order(6, [2, 6, 4, 5, 1, 3]) 3 >>> max_buildings_in_increasing_order(4, [5, 5, 5, 5]) 1 >>> max_buildings_in_increasing_order(8, [1, 2, 1, 2, 3, 4, 1, 2]) 4 >>> max_buildings_in_increasing_order(1, [1]) 1 >>> max_buildings_in_increasing_order(5, [1, 2, 3, 4, 5]) 5 >>> max_buildings_in_increasing_order(5, [2, 2, 2, 2, 2]) 1 >>> max_buildings_in_increasing_order(5, [5, 4, 3, 2, 1]) 1 >>> max_buildings_in_increasing_order(7, [3, 10, 2, 1, 20, 4, 5]) 3 pass","solution":"def max_buildings_in_increasing_order(n, heights): Finds the maximum number of buildings that can be joined together to form a single contiguous block with strictly increasing heights. Parameters: n (int): The number of buildings. heights (list): The heights of the buildings. Returns: int: The maximum number of buildings in strictly increasing order. if n == 0: return 0 from bisect import bisect_left # This will store the increasing subsequence subsequence = [] for height in heights: pos = bisect_left(subsequence, height) if pos == len(subsequence): subsequence.append(height) else: subsequence[pos] = height return len(subsequence)"},{"question":"def keyboard_layout(n: int, k: int) -> tuple: Determines if it is possible to arrange k keys in n rows such that the difference in the number of keys between any two consecutive rows does not exceed 1. Args: n (int): the number of rows. k (int): the total number of keys. Returns: tuple: (\\"YES\\", layout) if possible, where layout is a list of integers representing the number of keys in each row, (\\"NO\\",) if not possible. Examples: >>> keyboard_layout(5, 15) (\\"YES\\", [3, 3, 3, 3, 3]) >>> keyboard_layout(4, 10) (\\"YES\\", [2, 3, 2, 3]) >>> keyboard_layout(3, 8) (\\"NO\\",)","solution":"def keyboard_layout(n, k): Determines if it is possible to arrange k keys in n rows such that the difference in the number of keys between any two consecutive rows does not exceed 1. Args: n (int): the number of rows. k (int): the total number of keys. Returns: tuple: (\\"YES\\", layout) if possible, where layout is a list of integers representing the number of keys in each row, (\\"NO\\",) if not possible. # Base calculation base_keys_per_row = k // n remainder_keys = k % n if remainder_keys > n // 2: return (\\"NO\\", ) layout = [base_keys_per_row] * n for i in range(remainder_keys): layout[i] += 1 layout.sort() return (\\"YES\\", layout)"},{"question":"def has_zero_sum_subarray(n: int, arr: List[int]) -> str: Determines if there exists a continuous subarray that sums to zero. Args: n: int - Number of elements in the array arr: List[int] - The array of integers Returns: str: \\"Yes\\" if such a subarray exists, otherwise \\"No\\" # Unit tests def test_example_1(): assert has_zero_sum_subarray(5, [1, 2, -3, 4, 5]) == \\"Yes\\" def test_example_2(): assert has_zero_sum_subarray(4, [1, 2, 3, 4]) == \\"No\\" def test_single_zero_element(): assert has_zero_sum_subarray(1, [0]) == \\"Yes\\" def test_multiple_elements_with_zero_sum_subarray(): assert has_zero_sum_subarray(8, [3, 4, -7, 1, 2, -6, 3, 1]) == \\"Yes\\" def test_no_zero_sum_subarray(): assert has_zero_sum_subarray(5, [1, 2, 3, 4, 5]) == \\"No\\" def test_all_negative_numbers(): assert has_zero_sum_subarray(5, [-1, -2, -3, -4, -5]) == \\"No\\" def test_prefix_sum_zero(): assert has_zero_sum_subarray(4, [4, -4, 2, -2]) == \\"Yes\\"","solution":"def has_zero_sum_subarray(n, arr): Determines if there exists a continuous subarray that sums to zero. Args: n : int : number of elements in the array arr : list of int : the array of integers Returns: str : \\"Yes\\" if such a subarray exists, otherwise \\"No\\" prefix_sum = 0 prefix_sums_set = set() for num in arr: prefix_sum += num if prefix_sum == 0 or prefix_sum in prefix_sums_set: return \\"Yes\\" prefix_sums_set.add(prefix_sum) return \\"No\\""},{"question":"def subarray_with_sum(a: List[int], k: int, s: int) -> str: Determine if there exists a subarray of \`a\` with at least \`k\` elements and sum equal to \`s\`. Parameters: a (list of int): The list of integers. k (int): The minimum number of elements in the subarray. s (int): The required sum. Returns: str: \\"YES\\" if such a subarray exists, otherwise \\"NO\\". >>> subarray_with_sum([1, 2, 3, 4, 2, 1], 3, 6) \\"YES\\" >>> subarray_with_sum([5, 3, 1, 2, 1], 2, 10) \\"NO\\"","solution":"def subarray_with_sum(a, k, s): Determine if there exists a subarray of \`a\` with at least \`k\` elements and sum equal to \`s\`. Parameters: a (list of int): The list of integers. k (int): The minimum number of elements in the subarray. s (int): The required sum. Returns: str: \\"YES\\" if such a subarray exists, otherwise \\"NO\\". n = len(a) # Compute prefix sums prefix_sum = [0] * (n + 1) for i in range(n): prefix_sum[i + 1] = prefix_sum[i] + a[i] # Check for a subarray with the required length and sum for start in range(n - k + 1): for end in range(start + k, n + 1): if prefix_sum[end] - prefix_sum[start] == s: return \\"YES\\" return \\"NO\\""},{"question":"from typing import List, Tuple def min_operations_to_ones(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the minimum number of operations required to transform the sequence into a sequence of ones, or -1 if it is not possible. >>> min_operations_to_ones(3, [(4, [3, 3, 2, 2]), (5, [5, 5, 5, 5, 5]), (3, [4, 2, 3])]) [2, 4, -1] >>> min_operations_to_ones(1, [(5, [1, 1, 1, 1, 1])]) [0] >>> min_operations_to_ones(1, [(3, [2, 3, 4])]) [-1] >>> min_operations_to_ones(1, [(8, [100, 100, 100, 99, 99, 99, 99, 99])]) [99] >>> min_operations_to_ones(1, [(1, [2])]) [-1] pass def convert_input_to_cases(input_string: str) -> Tuple[int, List[Tuple[int, List[int]]]]: Convert the input string to the format (t, test_cases). >>> convert_input_to_cases(\\"3n4n3 3 2 2n5n5 5 5 5 5n3n4 2 3\\") (3, [(4, [3, 3, 2, 2]), (5, [5, 5, 5, 5, 5]), (3, [4, 2, 3])]) >>> convert_input_to_cases(\\"1n5n1 1 1 1 1\\") (1, [(5, [1, 1, 1, 1, 1])]) >>> convert_input_to_cases(\\"1n3n2 3 4\\") (1, [(3, [2, 3, 4])]) >>> convert_input_to_cases(\\"1n8n100 100 100 99 99 99 99 99\\") (1, [(8, [100, 100, 100, 99, 99, 99, 99, 99])]) >>> convert_input_to_cases(\\"1n1n2\\") (1, [(1, [2])]) pass","solution":"from collections import Counter def min_operations_to_ones(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] sequence = test_cases[i][1] freq = Counter(sequence) operations = 0 while sum(seq > 1 for seq in sequence) > 0: new_sequence = [] performed_operation = False for num in sequence: if num > 1 and freq[num] > 1: new_sequence.append(num - 1) performed_operation = True else: new_sequence.append(num) if not performed_operation: results.append(-1) break sequence = new_sequence freq = Counter(sequence) operations += 1 else: results.append(operations) return results def convert_input_to_cases(input_string): data = input_string.split() t = int(data[0]) test_cases = [] index = 1 for i in range(t): n = int(data[index]) sequence = list(map(int, data[index + 1:index + 1 + n])) test_cases.append((n, sequence)) index += n + 1 return t, test_cases"},{"question":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotates the given NxN matrix by 90 degrees clockwise. Args: matrix (List[List[int]]): A 2D list of integers representing the image matrix. Returns: List[List[int]]: The rotated matrix. pass def process_input(input_lines: List[str]) -> List[List[List[int]]]: Processes the input lines and rotates each input matrix by 90 degrees. Args: input_lines (List[str]): A list of strings representing multiple test cases. Returns: List[List[List[int]]]: A list of rotated matrices. pass import pytest def test_rotate_matrix_3x3(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] expected_output = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] assert rotate_matrix(matrix) == expected_output def test_rotate_matrix_4x4(): matrix = [ [2, 29, 20, 26], [12, 27, 9, 25], [32, 33, 32, 8], [13, 41, 60, 41] ] expected_output = [ [13, 32, 12, 2], [41, 33, 27, 29], [60, 32, 9, 20], [41, 8, 25, 26] ] assert rotate_matrix(matrix) == expected_output def test_process_input(): input_data = [ \\"3\\", \\"1 2 3\\", \\"4 5 6\\", \\"7 8 9\\", \\"4\\", \\"2 29 20 26\\", \\"12 27 9 25\\", \\"32 33 32 8\\", \\"13 41 60 41\\", \\"0\\" ] expected_output = [ [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ], [ [13, 32, 12, 2], [41, 33, 27, 29], [60, 32, 9, 20], [41, 8, 25, 26] ] ] assert process_input(input_data) == expected_output if __name__ == '__main__': pytest.main()","solution":"def rotate_matrix(matrix): Rotates the given NxN matrix by 90 degrees clockwise. N = len(matrix) # Create a new matrix for the rotated result rotated_matrix = [[0]*N for _ in range(N)] for i in range(N): for j in range(N): rotated_matrix[j][N-1-i] = matrix[i][j] return rotated_matrix def process_input(input_lines): result = [] index = 0 while index < len(input_lines): N = int(input_lines[index]) if N == 0: break matrix = [] for i in range(1, N+1): matrix.append(list(map(int, input_lines[index+i].split()))) rotated_matrix = rotate_matrix(matrix) result.append(rotated_matrix) index += N + 1 return result"},{"question":"def count_paths(N: int, M: int, grid: List[str]) -> int: Given a grid of cells with rows N and columns M, find the total number of paths from the top-left corner to the bottom-right corner moving only right or down without passing through any mountains ('#'), modulo 10^9 + 7. >>> count_paths(3, 3, [\\"...\\", \\"...\\", \\"...\\"]) == 6 >>> count_paths(3, 3, [\\"..#\\", \\".#.\\", \\"...\\"]) == 1 >>> count_paths(3, 3, [\\"#\\", \\"..#\\", \\"..#\\"]) == 0 >>> count_paths(1, 3, [\\"...\\"]) == 1 >>> count_paths(3, 1, [\\".\\", \\".\\", \\".\\"]) == 1 >>> count_paths(1, 1, [\\".\\"]) == 1 >>> count_paths(1, 1, [\\"#\\"]) == 0","solution":"MOD = 10**9 + 7 def count_paths(N, M, grid): # Create a 2D dp array initialized to 0 dp = [[0] * M for _ in range(N)] # Start at the top-left corner if grid[0][0] == '.': dp[0][0] = 1 # Fill the dp array for i in range(N): for j in range(M): if grid[i][j] == '#': dp[i][j] = 0 # No path can go through a mountain else: if i > 0: dp[i][j] += dp[i-1][j] # Paths from the top if j > 0: dp[i][j] += dp[i][j-1] # Paths from the left dp[i][j] %= MOD return dp[N-1][M-1] # Example usage if __name__ == \\"__main__\\": N, M = map(int, input().split()) grid = [input().strip() for _ in range(N)] result = count_paths(N, M, grid) print(result)"},{"question":"def max_contiguous_coins(N: int, K: int, coin_values: List[int]) -> int: John loves collecting rare coins. He has a collection of N coins, each with a unique value. He places the coins in a row by their values in non-decreasing order. John likes to calculate the maximum number of contiguous coins in his collection whose values have a maximum difference of K. This function returns the maximum number of contiguous coins that have a value difference of at most K. >>> max_contiguous_coins(6, 3, [1, 2, 3, 5, 7, 10]) == 3 >>> max_contiguous_coins(5, 2, [1, 3, 4, 7, 9]) == 2 >>> max_contiguous_coins(5, 5, [1, 3, 6, 7, 8]) == 4 >>> max_contiguous_coins(1, 1, [1]) == 1 >>> max_contiguous_coins(0, 0, []) == 0 >>> max_contiguous_coins(5, 0, [1, 2, 3, 4, 5]) == 1 >>> max_contiguous_coins(6, 3, [4, 4, 4, 4, 4, 4]) == 6 >>> max_contiguous_coins(5, 2, [1, 1, 3, 3, 5]) == 4","solution":"def max_contiguous_coins(N, K, coin_values): This function returns the maximum number of contiguous coins that have a value difference of at most K. max_count = 0 start = 0 for end in range(N): while coin_values[end] - coin_values[start] > K: start += 1 max_count = max(max_count, end - start + 1) return max_count"},{"question":"def word_deletion_tool(document: str, M: int, targets: List[str]) -> str: Removes all occurrences of target words from the document. Args: document (str): The text of the document. M (int): The number of target words. targets (list of str): A list of words to be deleted. Returns: str: The document with all target words removed. pass # Test cases def test_word_deletion_tool_example(): document = \\"Today is a beautiful day and it is sunny\\" M = 2 targets = [\\"is\\", \\"sunny\\"] assert word_deletion_tool(document, M, targets) == \\"Today a beautiful day and it\\" def test_word_deletion_tool_no_targets(): document = \\"Today is a beautiful day and it is sunny\\" M = 0 targets = [] assert word_deletion_tool(document, M, targets) == \\"Today is a beautiful day and it is sunny\\" def test_word_deletion_tool_all_targets(): document = \\"Today is a beautiful day and it is sunny\\" M = 7 targets = [\\"Today\\", \\"is\\", \\"a\\", \\"beautiful\\", \\"day\\", \\"and\\", \\"it\\", \\"sunny\\"] assert word_deletion_tool(document, M, targets) == \\"\\" def test_word_deletion_tool_with_redundant_target_words(): document = \\"Redundant words redundant in a sentence\\" M = 1 targets = [\\"redundant\\"] assert word_deletion_tool(document, M, targets) == \\"Redundant words in a sentence\\" def test_word_deletion_tool_case_sensitive(): document = \\"Case sensitivity should keep CASE intact\\" M = 1 targets = [\\"CASE\\"] assert word_deletion_tool(document, M, targets) == \\"Case sensitivity should keep intact\\" if __name__ == \\"__main__\\": test_word_deletion_tool_example() test_word_deletion_tool_no_targets() test_word_deletion_tool_all_targets() test_word_deletion_tool_with_redundant_target_words() test_word_deletion_tool_case_sensitive() print(\\"All tests passed.\\")","solution":"def word_deletion_tool(document, M, targets): Removes all occurrences of target words from the document. Args: document (str): The text of the document. M (int): The number of target words. targets (list of str): A list of words to be deleted. Returns: str: The document with all target words removed. # Split the document into words words = document.split() # Create a set of target words for faster lookup target_set = set(targets) # Filter out the target words filtered_words = [word for word in words if word not in target_set] # Join the filtered words to form the new document return ' '.join(filtered_words)"},{"question":"from datetime import datetime from typing import List def earliest_log_entry(logs: List[str]) -> str: Find the log entry with the earliest timestamp. >>> earliest_log_entry([ ... \\"2023-01-28 14:22:01 Server rebooted\\", ... \\"2022-12-25 06:11:00 Application started\\", ... \\"2023-01-12 08:19:22 User login\\" ... ]) \\"2022-12-25 06:11:00 Application started\\" >>> earliest_log_entry([ ... \\"2023-05-01 02:00:00 Data backup completed\\", ... \\"2023-05-01 02:00:00 Scheduled maintenance started\\" ... ]) in [ \\"2023-05-01 02:00:00 Data backup completed\\", \\"2023-05-01 02:00:00 Scheduled maintenance started\\" ] >>> earliest_log_entry([ ... \\"2023-10-05 15:45:30 Single log entry\\" ... ]) \\"2023-10-05 15:45:30 Single log entry\\"","solution":"from datetime import datetime def earliest_log_entry(logs): Returns the log entry with the earliest timestamp. if not logs: return \\"\\" earliest_log = logs[0] earliest_timestamp = datetime.strptime(earliest_log[:19], '%Y-%m-%d %H:%M:%S') for log in logs[1:]: timestamp = datetime.strptime(log[:19], '%Y-%m-%d %H:%M:%S') if timestamp < earliest_timestamp: earliest_log = log earliest_timestamp = timestamp return earliest_log"},{"question":"def can_swap_to_make_lex_smaller(N: int, A: str, B: str) -> str: Determine if it is possible to make A lexicographically smaller than B by performing at most one swap operation on A. Args: N (int): The length of the strings A (str): The first string B (str): The second string Returns: str: \\"YES\\" if it is possible to achieve A < B by at most one swap, otherwise \\"NO\\" Examples: >>> can_swap_to_make_lex_smaller(3, \\"cba\\", \\"bca\\") 'YES' >>> can_swap_to_make_lex_smaller(4, \\"abcd\\", \\"abce\\") 'YES' >>> can_swap_to_make_lex_smaller(3, \\"abc\\", \\"abc\\") 'NO'","solution":"def can_swap_to_make_lex_smaller(N, A, B): Determine if it is possible to make A lexicographically smaller than B by performing at most one swap operation on A. Args: N (int): The length of the strings A (str): The first string B (str): The second string Returns: str: \\"YES\\" if it is possible to achieve A < B by at most one swap, otherwise \\"NO\\" if A < B: return \\"YES\\" def is_swappable(smaller, larger): for i in range(len(smaller)): for j in range(i + 1, len(smaller)): new_smaller = list(smaller) new_smaller[i], new_smaller[j] = new_smaller[j], new_smaller[i] if \\"\\".join(new_smaller) < larger: return True return False if is_swappable(A, B): return \\"YES\\" return \\"NO\\""},{"question":"from typing import List def compare(x: str, y: str) -> int: Comparator function for determining order for concatenation. return (int(y + x) - int(x + y)) def largest_number(numbers: List[str]) -> str: Returns the largest number that can be formed by concatenating the input integers. >>> largest_number(['50', '2', '1', '9']) '95021' >>> largest_number(['5', '56', '50']) '56550' >>> largest_number(['1', '34', '3', '98', '9', '76', '45', '4']) '998764543431' >>> largest_number(['12', '121']) '12121' # Implementation here def process_test_cases(test_cases: List[str]) -> List[str]: Processes multiple test cases and returns the results. results = [] for case in test_cases: numbers = case.split() results.append(largest_number(numbers)) return results import pytest def test_largest_number(): assert largest_number(['50', '2', '1', '9']) == '95021' assert largest_number(['5', '56', '50']) == '56550' assert largest_number(['1', '34', '3', '98', '9', '76', '45', '4']) == '998764543431' assert largest_number(['12', '121']) == '12121' def test_process_test_cases(): test_cases = [ \\"50 2 1 9\\", \\"5 56 50\\", \\"1 34 3 98 9 76 45 4\\" ] assert process_test_cases(test_cases) == ['95021', '56550', '998764543431'] if __name__ == \\"__main__\\": pytest.main()","solution":"from functools import cmp_to_key def compare(x, y): return (int(y + x) - int(x + y)) def largest_number(numbers): Returns the largest number that can be formed by concatenating the input integers. # Convert numbers to string to prepare for concatenation comparisons numbers_str = list(map(str, numbers)) # Sort numbers based on custom comparator numbers_str.sort(key=cmp_to_key(compare)) # Join the sorted numbers into the largest number largest_num = ''.join(numbers_str) # Return the result return largest_num def process_test_cases(test_cases): results = [] for case in test_cases: numbers = case.split() results.append(largest_number(numbers)) return results"},{"question":"def can_pair_stones(n: int, numbers: List[int]) -> str: Determines if it's possible to pair all stones such that each pair of stones have identical magical numbers. >>> can_pair_stones(4, [1, 2, 2, 1]) 'YES' >>> can_pair_stones(6, [3, 3, 4, 4, 5, 5]) 'YES' >>> can_pair_stones(5, [1, 2, 3, 4, 5]) 'NO' >>> can_pair_stones(4, [1, 1, 2, 3]) 'NO'","solution":"def can_pair_stones(n, numbers): Determines if it's possible to pair all stones such that each pair of stones have identical magical numbers. from collections import Counter count = Counter(numbers) for value in count.values(): if value % 2 != 0: return \\"NO\\" return \\"YES\\""},{"question":"def max_increase_in_bacteria(n: int, b: List[int]) -> int: Finds the maximum increase in the number of bacteria over any continuous period of time. Parameters: n (int): the number of hours. b (list of int): the number of bacteria at the end of each hour. Returns: int: the maximum increase in the number of bacteria over any continuous period of time. >>> max_increase_in_bacteria(6, [3, 3, 6, 4, 8, 12]) == 9 >>> max_increase_in_bacteria(5, [5, 4, 3, 2, 1]) == 0 >>> max_increase_in_bacteria(1, [7]) == 0 >>> max_increase_in_bacteria(2, [4, 7]) == 3 >>> max_increase_in_bacteria(4, [1, 2, 1, 2]) == 1 >>> max_increase_in_bacteria(7, [1, 2, 3, 4, 2, 3, 10]) == 9","solution":"def max_increase_in_bacteria(n, b): Finds the maximum increase in the number of bacteria over any continuous period of time. Parameters: n (int): the number of hours. b (list of int): the number of bacteria at the end of each hour. Returns: int: the maximum increase in the number of bacteria over any continuous period of time. min_bacteria = float('inf') max_increase = 0 for bacteria in b: if bacteria < min_bacteria: min_bacteria = bacteria else: max_increase = max(max_increase, bacteria - min_bacteria) return max_increase # Example usage: # n = 6 # b = [3, 3, 6, 4, 8, 12] # print(max_increase_in_bacteria(n, b)) # Output: 9"},{"question":"def is_valid_palindrome(s: str) -> bool: Check if the string \`s\` forms a valid palindrome when numbers are ignored. >>> is_valid_palindrome(\\"a1b2c3ba\\") True >>> is_valid_palindrome(\\"ab12ba\\") True >>> is_valid_palindrome(\\"ab1cd2ba\\") False def process_test_cases(T: int, test_cases: List[str]) -> List[str]: Process T test cases given a list of test_cases. Returns a list of results for each test case. >>> process_test_cases(3, [\\"a1b2c3ba\\", \\"ab12ba\\", \\"ab1cd2ba\\"]) [\\"Yes\\", \\"Yes\\", \\"No\\"] >>> process_test_cases(2, [\\"12321a\\", \\"a1b2c\\"]) [\\"Yes\\", \\"No\\"] from typing import List def test_is_valid_palindrome(): assert is_valid_palindrome(\\"a1b2c3ba\\") == True assert is_valid_palindrome(\\"ab12ba\\") == True assert is_valid_palindrome(\\"ab1cd2ba\\") == False assert is_valid_palindrome(\\"12321a\\") == True assert is_valid_palindrome(\\"a1b2c\\") == False assert is_valid_palindrome(\\"ab1b2a\\") == True assert is_valid_palindrome(\\"1\\") == True assert is_valid_palindrome(\\"a\\") == True assert is_valid_palindrome(\\"\\") == True assert is_valid_palindrome(\\"12345\\") == True def test_process_test_cases(): T = 3 test_cases = [\\"a1b2c3ba\\", \\"ab12ba\\", \\"ab1cd2ba\\"] results = process_test_cases(T, test_cases) assert results == [\\"Yes\\", \\"Yes\\", \\"No\\"] T = 2 test_cases = [\\"12321a\\", \\"a1b2c\\"] results = process_test_cases(T, test_cases) assert results == [\\"Yes\\", \\"No\\"] T = 4 test_cases = [\\"ab1b2a\\", \\"1\\", \\"a\\", \\"12345\\"] results = process_test_cases(T, test_cases) assert results == [\\"Yes\\", \\"Yes\\", \\"Yes\\", \\"Yes\\"]","solution":"def is_valid_palindrome(s): Checks if the string \`s\` forms a valid palindrome when numbers are ignored. # Filter out characters that are not digits filtered_chars = [ch for ch in s if ch.isalpha()] # Check if the filtered list forms a palindrome return filtered_chars == filtered_chars[::-1] def process_test_cases(T, test_cases): Processes T test cases given a list of test_cases. Returns a list of results for each test case. results = [] for case in test_cases: if is_valid_palindrome(case): results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"def min_operations(s1: str, s2: str) -> int: Determine the minimum number of operations required to transform one string into another. The allowed operations are insertion, deletion, and replacement of a character. Args: s1 (str): The first string. s2 (str): The second string. Returns: int: The minimum number of operations required to transform s1 into s2. Examples: >>> min_operations(\\"horse\\", \\"ros\\") 3 >>> min_operations(\\"intention\\", \\"execution\\") 5 from solution import min_operations def test_min_operations_example1(): assert min_operations(\\"horse\\", \\"ros\\") == 3 def test_min_operations_example2(): assert min_operations(\\"intention\\", \\"execution\\") == 5 def test_min_operations_same_strings(): assert min_operations(\\"abc\\", \\"abc\\") == 0 def test_min_operations_one_empty_string(): assert min_operations(\\"abc\\", \\"\\") == 3 assert min_operations(\\"\\", \\"abc\\") == 3 def test_min_operations_different_lengths(): assert min_operations(\\"abcd\\", \\"abc\\") == 1 assert min_operations(\\"abcdef\\", \\"azced\\") == 3 def test_min_operations_entirely_different(): assert min_operations(\\"kitten\\", \\"sitting\\") == 3 def test_min_operations_reversed_strings(): assert min_operations(\\"abc\\", \\"cba\\") == 2","solution":"def min_operations(s1: str, s2: str) -> int: n, m = len(s1), len(s2) # Create a DP table to memoize results dp = [[0] * (m + 1) for _ in range(n + 1)] # Initialize base cases for i in range(1, n + 1): dp[i][0] = i # deletion case for j in range(1, m + 1): dp[0][j] = j # insertion case # Fill dp array for i in range(1, n + 1): for j in range(1, m + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] # no operation needed else: dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1 return dp[n][m]"},{"question":"def minimum_bus_routes(n: int, stops: List[Tuple[int, int]]) -> int: Returns the minimum number of bus routes required to cover all bus stops. Parameters: n (int): Number of bus stops. stops (list of tuples): List of tuples where each tuple contains the coordinates (xi, yi) of the bus stops. Returns: int: Minimum number of bus routes required. >>> minimum_bus_routes(5, [(0, 0), (0, 2), (2, 0), (2, 2), (1, 1)]) 3 >>> minimum_bus_routes(4, [(0, 0), (0, 1), (1, 0), (1, 1)]) 2 >>> minimum_bus_routes(3, [(1, 2), (3, 3), (1, 3)]) 2 >>> minimum_bus_routes(1, [(0, 0)]) 1 >>> minimum_bus_routes(4, [(0, 0), (0, 1), (0, 2), (0, 3)]) 1 >>> minimum_bus_routes(4, [(0, 0), (1, 0), (2, 0), (3, 0)]) 1 >>> minimum_bus_routes(4, [(0, 0), (1, 1), (2, 2), (3, 3)]) 4 pass","solution":"def minimum_bus_routes(n, stops): Returns the minimum number of bus routes required to cover all bus stops. Parameters: n (int): Number of bus stops. stops (list of tuples): List of tuples where each tuple contains the coordinates (xi, yi) of the bus stops. Returns: int: Minimum number of bus routes required. x_coordinates = set() y_coordinates = set() for x, y in stops: x_coordinates.add(x) y_coordinates.add(y) return min(len(x_coordinates), len(y_coordinates))"},{"question":"def is_pangram(s: str) -> bool: Determines if the input string s is a pangram. A pangram is a string that contains every letter of the alphabet at least once. The function ignores case and non-alphabet characters. >>> is_pangram(\\"The quick brown fox jumps over the lazy dog\\") True >>> is_pangram(\\"Hello, World!\\") False def test_pangram(): assert is_pangram(\\"The quick brown fox jumps over the lazy dog\\") == True def test_non_pangram(): assert is_pangram(\\"Hello, World!\\") == False def test_empty_string(): assert is_pangram(\\"\\") == False def test_uppercase_only(): assert is_pangram(\\"THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\\") == True def test_mixed_case(): assert is_pangram(\\"ThE qUiCk BrOwN fOx JuMpS oVeR tHe LaZy DoG\\") == True def test_missing_letters(): assert is_pangram(\\"The quick brown fox jumps over the dog\\") == False def test_non_alphabetic_characters(): assert is_pangram(\\"1234567890!@#%^&*()_+=-\`~[]{}|;:'\\",.<>?/\\") == False def test_minimum_pangram(): assert is_pangram(\\"abcdefghijklmnopqrstuvwxyz\\") == True def test_redundant_string(): assert is_pangram(\\"aaabbbcccdddeeefffggghhhiiijjjkkklllmmmnnnooopppqqqrrrssstttuuuvvvwwwxxxyyyzzz\\") == True","solution":"import string def is_pangram(s): Determines if the input string s is a pangram. A pangram is a string that contains every letter of the alphabet at least once. The function ignores case and non-alphabet characters. Parameters: s (str): The input string to check. Returns: bool: True if the input string is a pangram, False otherwise. # Create a set of all the alphabets alphabet = set(string.ascii_lowercase) # Convert input string to lowercase and create a set from its alphabets s = set(s.lower()) # Check if the alphabet set is a subset of the characters in the string return alphabet.issubset(s)"},{"question":"from typing import List, Tuple def find_shortest_path(M: int, N: int, Ex: int, Ey: int, Dx: int, Dy: int, K: int, blocked: List[Tuple[int, int]]) -> int: Determine the shortest path from the entrance to the exit in the warehouse grid, avoiding blocked sections. :param M: int - number of rows in the warehouse grid :param N: int - number of columns in the warehouse grid :param Ex: int - x-coordinate of the entrance :param Ey: int - y-coordinate of the entrance :param Dx: int - x-coordinate of the exit :param Dy: int - y-coordinate of the exit :param K: int - number of blocked sections :param blocked: List[Tuple[int, int]] - list of coordinates of blocked sections :return: int - the length of the shortest path from entrance to exit, or -1 if no path exists Example: >>> find_shortest_path(5, 7, 0, 0, 4, 6, 3, [(1, 2), (2, 3), (3, 4)]) 10 >>> find_shortest_path(5, 7, 0, 0, 4, 6, 2, [(1, 0), (0, 1)]) -1","solution":"from collections import deque def shortest_path(warehouse, entrance, exit, blocked_sections): M, N = warehouse (Ex, Ey) = entrance (Dx, Dy) = exit # Initialize grid and mark blocked sections grid = [[0] * N for _ in range(M)] for bx, by in blocked_sections: grid[bx][by] = -1 # Movement directions: up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # BFS queue queue = deque([(Ex, Ey, 0)]) # (x, y, distance) grid[Ex][Ey] = 1 # mark entrance as visited while queue: x, y, dist = queue.popleft() if (x, y) == (Dx, Dy): return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < M and 0 <= ny < N and grid[nx][ny] == 0: grid[nx][ny] = 1 # mark as visited queue.append((nx, ny, dist + 1)) return -1 # Example usage: def find_shortest_path(M, N, Ex, Ey, Dx, Dy, K, blocked): return shortest_path((M, N), (Ex, Ey), (Dx, Dy), blocked) # Testing the example: print(find_shortest_path(5, 7, 0, 0, 4, 6, 3, [(1, 2), (2, 3), (3, 4)])) # Output should be 10"},{"question":"def max_hops(n: int, k: int) -> int: Determine the maximum possible number of hops required between any two intersections in the optimal layout, given n intersections and k shortcuts. Parameters: n (int): The number of intersections. k (int): The number of shortcuts. Returns: int: The maximum possible number of hops required. Examples: >>> max_hops(6, 0) 3 >>> max_hops(6, 1) 2 >>> max_hops(8, 2) 2","solution":"def max_hops(n, k): Determine the maximum possible number of hops required between any two intersections in the optimal layout, given n intersections and k shortcuts. Parameters: n (int): The number of intersections. k (int): The number of shortcuts. Returns: int: The maximum possible number of hops required. if k >= (n // 2) - 1: return 1 else: return (n // 2) - k # Examples used in the problem statement print(max_hops(6, 0)) # Output: 3 print(max_hops(6, 1)) # Output: 2 print(max_hops(8, 2)) # Output: 2"},{"question":"def can_empty_jars(n: int, jars: List[int]) -> str: Determines if it's possible to empty all jars. Args: n : int : number of jars jars : list of int : number of candies in each jar Returns: str : \\"YES\\" if it's possible to empty all jars, else \\"NO\\" >>> can_empty_jars(3, [1, 2, 3]) 'YES' >>> can_empty_jars(4, [0, 0, 0, 0]) 'YES' >>> can_empty_jars(2, [0, 1]) 'NO'","solution":"def can_empty_jars(n, jars): Determines if it's possible to empty all jars. Args: n : int : number of jars jars : list of int : number of candies in each jar Returns: str : \\"YES\\" if it's possible to empty all jars, else \\"NO\\" return \\"YES\\" if sum(jars) % 2 == 0 else \\"NO\\""},{"question":"def decode_string(s: str) -> str: Decode the given encoded string by following the specified format. >>> decode_string(\\"3(ab2(c))\\") 'abccabccabcc' >>> decode_string(\\"2(a3(b))\\") 'abbbabbb' >>> decode_string(\\"2(3(a)2(bc))\\") 'aaabcbcaaabcbc' >>> decode_string(\\"2(a3(b)c)\\") 'abbbcabbbc' >>> decode_string(\\"3(a2(bc)d)\\") 'abcbcdabcbcdabcbcd' >>> decode_string(\\"abc\\") 'abc' >>> decode_string(\\"a\\") 'a' >>> decode_string(\\"10(a)\\") 'aaaaaaaaaa' >>> decode_string(\\"2(abc3(cd))\\") 'abccdcdcdabccdcdcd' pass def test_single_level_encoding(): assert decode_string(\\"3(ab)\\") == \\"ababab\\" assert decode_string(\\"2(a)\\") == \\"aa\\" def test_nested_encoding(): assert decode_string(\\"3(ab2(c))\\") == \\"abccabccabcc\\" assert decode_string(\\"2(a3(b))\\") == \\"abbbabbb\\" assert decode_string(\\"2(3(a)2(bc))\\") == \\"aaabcbcaaabcbc\\" def test_mixed_content(): assert decode_string(\\"2(a3(b)c)\\") == \\"abbbcabbbc\\" assert decode_string(\\"3(a2(bc)d)\\") == \\"abcbcdabcbcdabcbcd\\" def test_no_encoding(): assert decode_string(\\"abc\\") == \\"abc\\" assert decode_string(\\"a\\") == \\"a\\" def test_large_numbers(): assert decode_string(\\"10(a)\\") == \\"aaaaaaaaaa\\" assert decode_string(\\"2(abc3(cd))\\") == \\"abccdcdcdabccdcdcd\\"","solution":"def decode_string(s: str) -> str: stack = [] current_num = 0 current_string = '' for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == '(': stack.append((current_string, current_num)) current_string = '' current_num = 0 elif char == ')': prev_string, repeat = stack.pop() current_string = prev_string + current_string * repeat else: current_string += char return current_string"},{"question":"def count_book_pairs(N: int, K: int, years: List[int]) -> int: Returns the number of distinct pairs of books with publication years such that the absolute difference between the years is at least K. Args: N : int : the number of books K : int : the minimum absolute difference between the publication years of a pair of books years : List[int] : a list of N integers where each integer represents the publication year of a book Returns: int : The number of distinct pairs of books that meet the criteria. Example: >>> count_book_pairs(5, 3, [1, 5, 3, 9, 2]) 6 >>> count_book_pairs(4, 1, [7, 7, 7, 7]) 0 >>> count_book_pairs(4, 10, [1, 2, 5, 7]) 0 >>> count_book_pairs(1, 1, [3]) 0 >>> count_book_pairs(6, 2, [-1, 0, 2, 3, 4, 5]) 11","solution":"def count_book_pairs(N, K, years): Returns the number of distinct pairs of books with publication years such that the absolute difference between the years is at least K. years.sort() count = 0 j = 1 for i in range(N): while j < N and years[j] - years[i] < K: j += 1 count += N - j return count"},{"question":"def max_tasks_completed(N: int, M: int, tasks: List[int], workers: List[int]) -> int: Find the maximum number of tasks that can be completed given the constraints of task difficulty and worker capacity. Parameters: N (int): The number of tasks. M (int): The number of workers. tasks (List[int]): A list containing the difficulty levels of the tasks. workers (List[int]): A list containing the maximum difficulty levels that the workers can handle. Returns: int: The maximum number of tasks that can be completed. Examples: >>> max_tasks_completed(5, 3, [4, 8, 15, 16, 23], [10, 16, 14]) 3 >>> max_tasks_completed(0, 3, [], [10, 16, 14]) 0 >>> max_tasks_completed(5, 0, [4, 8, 15, 16, 23], []) 0 >>> max_tasks_completed(7, 3, [2, 4, 6, 8, 10, 12, 14], [8, 10, 12]) 3 >>> max_tasks_completed(3, 7, [4, 8, 12], [2, 4, 6, 8, 10, 12, 14]) 3 >>> max_tasks_completed(3, 3, [5, 10, 15], [5, 10, 15]) 3 >>> max_tasks_completed(3, 3, [10, 20, 30], [1, 2, 3]) 0","solution":"def max_tasks_completed(N, M, tasks, workers): tasks.sort() workers.sort() task_pointer, worker_pointer = 0, 0 completed_tasks = 0 while task_pointer < N and worker_pointer < M: if tasks[task_pointer] <= workers[worker_pointer]: completed_tasks += 1 task_pointer += 1 worker_pointer += 1 return completed_tasks"},{"question":"def swap_in_a_row(M, N): Determine the number of valid ways the people can reorder themselves to their starting positions, modulo 1000000007. Args: M (int): The total number of distinct items placed in a row. N (int): The number of people. Returns: int: The count of valid ways the people can reorder themselves, modulo 1000000007. Examples: >>> swap_in_a_row(3, 2) 2 >>> swap_in_a_row(5, 3) 6 >>> swap_in_a_row(4, 4) 24 pass # Unit tests def test_example_1(): assert swap_in_a_row(3, 2) == 2 def test_example_2(): assert swap_in_a_row(5, 3) == 6 def test_example_3(): assert swap_in_a_row(4, 4) == 24 def test_single_person(): assert swap_in_a_row(1, 1) == 1 def test_all_people_to_max(): assert swap_in_a_row(50, 50) == 318608048 def test_more_items_than_people(): assert swap_in_a_row(50, 25) == 440732388 def test_m_equals_n(): assert swap_in_a_row(10, 10) == 3628800","solution":"def factorial_mod(n, mod=1000000007): res = 1 for i in range(2, n + 1): res = (res * i) % mod return res def swap_in_a_row(M, N): return factorial_mod(N)"},{"question":"def find_winner(n: int) -> str: Simulate a modified version of the popular game Tic-Tac-Toe in a dynamic programming context. The variant is played on an n x n grid, with both players, X and O, taking turns. X always goes first. The twist is, if a player blocks their opponent's winning move in their turn, they get an extra turn immediately. You have to determine who will win the game if both players play optimally, starting with an empty grid. Input: n: The size of the grid (3  n  10) Output: \\"X\\" if X wins, \\"O\\" if O wins, or \\"Draw\\" if the game ends in a draw with both players playing optimally. Unit Test: >>> find_winner(3) 'X' >>> find_winner(4) 'O'","solution":"def find_winner(n): # If the board size is an odd number, X wins because X goes first and can always win in optimal play # for symmetric reasons. # If the board size is an even number, O wins because O can always play optimally # and take advantage of symmetry in its favor. if n % 2 == 1: return \\"X\\" else: return \\"O\\""},{"question":"def find_project_order(N: int, dependencies: List[List[int]]) -> str: Produce a valid order for projects such that each project appears after all of its dependencies. If no such order is possible due to a circular dependency, return \\"IMPOSSIBLE\\". >>> find_project_order(5, [[], [1], [2], [1, 2], []]) in {\\"1 2 3 4 5\\", \\"1 2 4 3 5\\", \\"1 5 2 3 4\\", \\"1 5 2 4 3\\"} True >>> find_project_order(4, [[2], [3], [4], [2]]) == \\"IMPOSSIBLE\\" True","solution":"def find_project_order(N, dependencies): from collections import defaultdict, deque # Build graph and in-degree counter graph = defaultdict(list) in_degree = [0] * (N + 1) for project in range(1, N + 1): deps = dependencies[project - 1] for dep in deps: graph[dep].append(project) in_degree[project] += 1 # Kahn's algorithm for topological sorting queue = deque([i for i in range(1, N + 1) if in_degree[i] == 0]) topo_order = [] while queue: current = queue.popleft() topo_order.append(current) for neighbor in graph[current]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) if len(topo_order) == N: return ' '.join(map(str, topo_order)) else: return \\"IMPOSSIBLE\\" def parse_input(input_str): lines = input_str.strip().split('n') N = int(lines[0]) dependencies = [list(map(int, line.split()[1:])) for line in lines[1:]] return N, dependencies def solution(input_str): N, dependencies = parse_input(input_str) return find_project_order(N, dependencies)"},{"question":"def swap(S: str, i: int, j: int) -> str: Swap characters at indices i and j in the string S. >>> swap(\\"abc\\", 0, 2) \\"cba\\" pass def rotate_left(S: str, k: int) -> str: Rotate the string S to the left by k positions. >>> rotate_left(\\"abcdef\\", 2) \\"cdefab\\" pass def min_operations_to_transform(S1: str, S2: str) -> int: Determine if it is possible to obtain S2 from S1 by performing zero or more swap or rotate_left operations in any order. Find the minimum number of operations required. >>> min_operations_to_transform(\\"abcd\\", \\"acbd\\") 1 >>> min_operations_to_transform(\\"abcd\\", \\"abcd\\") 0 >>> min_operations_to_transform(\\"abcd\\", \\"dcba\\") 2 >>> min_operations_to_transform(\\"abcd\\", \\"abdc\\") 1 >>> min_operations_to_transform(\\"abc\\", \\"def\\") -1 >>> min_operations_to_transform(\\"abcdef\\", \\"abcfde\\") 2 pass","solution":"def swap(S, i, j): S = list(S) S[i], S[j] = S[j], S[i] return \\"\\".join(S) def rotate_left(S, k): return S[k:] + S[:k] def min_operations_to_transform(S1, S2): if len(S1) != len(S2): return -1 from collections import Counter if Counter(S1) != Counter(S2): return -1 def bfs(start, target): from collections import deque queue = deque([(start, 0)]) visited = set() visited.add(start) while queue: current, ops = queue.popleft() if current == target: return ops for i in range(len(current)): for j in range(i + 1, len(current)): swapped = swap(current, i, j) if swapped not in visited: visited.add(swapped) queue.append((swapped, ops + 1)) return -1 return bfs(S1, S2)"},{"question":"from typing import List def tsp_min_distance(n: int, distances: List[List[int]]) -> int: Returns the minimum distance the traveling salesman must travel to visit all cities and return to the starting city. :param n: int - number of cities :param distances: list of list of int - distance matrix :return: int - minimum distance >>> tsp_min_distance(4, [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]) == 80 >>> tsp_min_distance(2, [[0, 5], [5, 0]]) == 10 >>> tsp_min_distance(3, [[0, 1, 2], [1, 0, 3], [2, 3, 0]]) == 6 >>> tsp_min_distance(4, [[0, 2, 9, 10], [1, 0, 6, 4], [15, 7, 0, 8], [6, 3, 12, 0]]) == 21 >>> tsp_min_distance(3, [[0, 1000, 2000], [1000, 0, 3000], [2000, 3000, 0]]) == 6000 # Your code here","solution":"from itertools import permutations def tsp_min_distance(n, distances): Returns the minimum distance the traveling salesman must travel to visit all cities and return to the starting city. :param n: int - number of cities :param distances: list of list of int - distance matrix :return: int - minimum distance cities = range(n) min_distance = float('inf') for perm in permutations(cities): current_distance = sum(distances[perm[i]][perm[i + 1]] for i in range(n - 1)) current_distance += distances[perm[-1]][perm[0]] # Add distance to return to starting city min_distance = min(min_distance, current_distance) return min_distance"},{"question":"def prime_numbers(N: int) -> list: Returns a list of prime numbers between 1 and N (inclusive). >>> prime_numbers(10) [2, 3, 5, 7] >>> prime_numbers(1) []","solution":"def prime_numbers(N): Returns a list of prime numbers between 1 and N (inclusive). if N < 2: return [] is_prime = [True] * (N + 1) is_prime[0] = is_prime[1] = False for i in range(2, int(N**0.5) + 1): if is_prime[i]: for j in range(i * i, N + 1, i): is_prime[j] = False primes = [] for i in range(2, N + 1): if is_prime[i]: primes.append(i) return primes"},{"question":"def rank_teams_by_average_score(teams_data: str) -> List[str]: Calculate the average score of each team from a given list of scores, and rank the teams based on their average score. >>> rank_teams_by_average_score(\\"3nAlpha 100 90 80nBravo 95 90 85nCharlie 80 85 90 95\\") ['Alpha', 'Bravo', 'Charlie'] >>> rank_teams_by_average_score(\\"2nAlpha 100nBeta 100\\") ['Alpha', 'Beta']","solution":"def rank_teams_by_average_score(teams_data): from statistics import mean teams_scores = [] for line in teams_data.split('n')[1:]: parts = line.split() team_name = parts[0] scores = list(map(int, parts[1:])) avg_score = mean(scores) teams_scores.append((team_name, avg_score)) ranked_teams = sorted(teams_scores, key=lambda x: (-x[1], x[0])) return [team_name for team_name, _ in ranked_teams]"},{"question":"from typing import List def max_subarray_sum(arr: List[int]) -> int: Given a list of integers, this function finds the maximum sum of any contiguous subarray. >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) # 6 >>> max_subarray_sum([1]) # 1 >>> max_subarray_sum([-1]) # -1 >>> max_subarray_sum([1, 2, 3, 4, 5]) # 15 >>> max_subarray_sum([-1, -2, -3, -4, -5]) # -1 >>> max_subarray_sum([-1, 2, 3, -4, 5, -2]) # 6 >>> max_subarray_sum([0, -1, 2, 3, -2, 0]) # 5 >>> max_subarray_sum([-1000] * 500 + [1000] * 500) # 500000 pass","solution":"def max_subarray_sum(arr): Given a list of integers, this function finds the maximum sum of any contiguous subarray. # Initialize variables to store the maximum sum found so far max_sum = -float('inf') current_sum = 0 for number in arr: current_sum += number if current_sum > max_sum: max_sum = current_sum if current_sum < 0: current_sum = 0 return max_sum"},{"question":"def min_operations_to_subsequence(S: str, T: str) -> int: Returns the minimum number of operations needed to transform S into a subsequence of T. Parameters: S (str): The source string. T (str): The target string. Returns: int: The minimum number of operations needed. Examples: >>> min_operations_to_subsequence(\\"abcde\\", \\"ace\\") 2 >>> min_operations_to_subsequence(\\"abcd\\", \\"efgh\\") 4 >>> min_operations_to_subsequence(\\"axbycz\\", \\"abc\\") 3 >>> min_operations_to_subsequence(\\"xyz\\", \\"abc\\") 3 >>> min_operations_to_subsequence(\\"samestring\\", \\"samestring\\") 0 >>> min_operations_to_subsequence(\\"abc\\", \\"abcdef\\") 0","solution":"def min_operations_to_subsequence(S, T): Returns the minimum number of operations needed to transform S into a subsequence of T. # We will use Longest Common Subsequence algorithm for this purpose. def longest_common_subsequence(X, Y): m = len(X) n = len(Y) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if X[i - 1] == Y[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n] lcs_length = longest_common_subsequence(S, T) return len(S) - lcs_length"},{"question":"def min_swaps_to_special_sequence(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given the number of test cases and a list of test cases, where each test case consists of an integer n and a list of n integers, determine the minimum number of swaps required to rearrange the list into a special sequence. A sequence is special if every element (except the first one) is a multiple of its predecessor. If it's impossible to rearrange, return -1. >>> min_swaps_to_special_sequence(2, [(5, [3, 6, 12, 24, 48]), (4, [5, 10, 15, 20])]) [0, -1] >>> min_swaps_to_special_sequence(1, [(3, [2, 4, 8])]) [0] >>> min_swaps_to_special_sequence(1, [(3, [2, 5, 8])]) [-1]","solution":"def min_swaps_to_special_sequence(t, test_cases): def helper(n, arr): # Corner case when n is 1 if n == 1: return 0 # Sort the array and try to arrange it into a special sequence arr.sort() swaps = 0 for i in range(1, n): if arr[i] % arr[i-1] != 0: return -1 # It's impossible to make the sequence # Since the array is already sorted and doesn't need swaps after sorted. return swaps results = [] for i in range(t): n, arr = test_cases[i] results.append(helper(n, arr)) return results"},{"question":"from typing import List def can_remove_all_palindromes(s: str) -> str: Determine if it is possible to remove all characters from the string using the described operations. >>> can_remove_all_palindromes(\\"a\\") \\"YES\\" >>> can_remove_all_palindromes(\\"ab\\") \\"NO\\" >>> can_remove_all_palindromes(\\"aba\\") \\"YES\\" >>> can_remove_all_palindromes(\\"abcba\\") \\"YES\\" >>> can_remove_all_palindromes(\\"abcd\\") \\"NO\\" pass def process_test_cases(t: int, test_cases: List[str]) -> List[str]: Process multiple test cases to determine if each can be made empty using the described operations. >>> process_test_cases(5, [\\"a\\", \\"ab\\", \\"aba\\", \\"abcba\\", \\"abcd\\"]) [\\"YES\\", \\"NO\\", \\"YES\\", \\"YES\\", \\"NO\\"] pass","solution":"def can_remove_all_palindromes(s): if s == s[::-1]: return \\"YES\\" else: return \\"NO\\" def process_test_cases(t, test_cases): results = [] for test_case in test_cases: results.append(can_remove_all_palindromes(test_case)) return results"},{"question":"def find_smallest_sum(test_cases): Find the smallest sum of each test case, where the sum is the addition of two distinct integers from the list. >>> find_smallest_sum([\\"4 7 1 3\\"]) [4] >>> find_smallest_sum([\\"-10 5 2 1\\"]) [-9] >>> find_smallest_sum([\\"8 8 8 8\\"]) [16] def parse_input(input_string): Parse the input string into a list of test cases where each test case is a space-separated list of integers. >>> parse_input(\\"3n4 7 1 3n-10 5 2 1n8 8 8 8\\") [4, -9, 16] def format_output(output_list): Format the output list into a newline-separated string of results. >>> format_output([4, -9, 16]) \\"4n-9n16\\"","solution":"def find_smallest_sum(test_cases): results = [] for case in test_cases: numbers = list(map(int, case.split())) numbers.sort() smallest_sum = numbers[0] + numbers[1] results.append(smallest_sum) return results def parse_input(input_string): lines = input_string.strip().split('n') T = int(lines[0]) test_cases = lines[1:T+1] return find_smallest_sum(test_cases) def format_output(output_list): return \\"n\\".join(map(str, output_list))"},{"question":"def can_defeat_monsters(n: int, monster_health: List[int], weapon_damage: List[int]) -> str: Determines if Jon can defeat all monsters using all weapons exactly once. Parameters: n (int): Number of monsters and weapons. monster_health (list): Health values for each monster. weapon_damage (list): Damage values for each weapon. Returns: str: \\"YES\\" if Jon can defeat all monsters, otherwise \\"NO\\". Examples: >>> can_defeat_monsters(4, [10, 20, 30, 40], [40, 30, 20, 10]) \\"YES\\" >>> can_defeat_monsters(3, [15, 25, 35], [20, 20, 30]) \\"NO\\"","solution":"def can_defeat_monsters(n, monster_health, weapon_damage): Determines if Jon can defeat all monsters using all weapons exactly once. Parameters: n (int): Number of monsters and weapons. monster_health (list): Health values for each monster. weapon_damage (list): Damage values for each weapon. Returns: str: \\"YES\\" if Jon can defeat all monsters, otherwise \\"NO\\". monster_health.sort() weapon_damage.sort() for i in range(n): if weapon_damage[i] < monster_health[i]: return \\"NO\\" return \\"YES\\""},{"question":"def count_rectangles(n: int, m: int, grid: List[str]) -> int: Determine the number of distinct, non-overlapping rectangles that can be formed using only the empty spaces ('.') such that all four corners of the rectangle are empty. >>> count_rectangles(4, 4, [\\"..#.\\", \\"....\\", \\".#\\", \\"..#.\\"]) == 9 >>> count_rectangles(4, 4, [\\"\\", \\"\\", \\"\\", \\"\\"]) == 0 >>> count_rectangles(1, 5, [\\".....\\"]) == 0 >>> count_rectangles(5, 1, [\\".\\", \\".\\", \\".\\", \\".\\", \\".\\"]) == 0 >>> count_rectangles(3, 3, [\\"...\\", \\"...\\", \\"...\\"]) == 9","solution":"def count_rectangles(n, m, grid): def is_empty(a, b): return grid[a][b] == '.' def count_rectangles_in_row(row): count = 0 for i in range(m): if is_empty(row, i): for j in range(i + 1, m): if is_empty(row, j): for row2 in range(row + 1, n): if is_empty(row2, i) and is_empty(row2, j): count += 1 return count total_count = 0 for row in range(n): total_count += count_rectangles_in_row(row) return total_count"},{"question":"import heapq def shortest_paths_from_capital(N: int, M: int, roads: List[Tuple[int, int, int]]) -> List[int]: Calculate the minimum distance required to travel from the capital city (city 1) to all other cities. If a city is not reachable from the capital, the distance should be represented by -1. Args: N (int): The number of cities. M (int): The number of roads. roads (List[Tuple[int, int, int]]): List of tuples where each tuple contains three integers u, v, w, denoting there is a road between cities u and v with length w. Returns: List[int]: A list of N-1 integers representing the minimum distance from the capital city to each city from 2 to N in order. Example: >>> shortest_paths_from_capital(5, 6, [(1, 2, 2), (1, 3, 4), (2, 3, 1), (3, 4, 2), (3, 5, 3), (4, 5, 2)]) [2, 3, 5, 6] >>> shortest_paths_from_capital(4, 2, [(1, 2, 5), (2, 3, 2)]) [5, 7, -1] pass def minimum_distances_from_input(input_string: str) -> List[int]: Parse input string and calculate the minimum distances from capital. Args: input_string (str): Input string containing the number of cities, number of roads, and the roads information. Returns: List[int]: A list of N-1 integers representing the minimum distance from the capital city to each city from 2 to N in order. Example: >>> input_string = \\"5 6n1 2 2n1 3 4n2 3 1n3 4 2n3 5 3n4 5 2\\" >>> minimum_distances_from_input(input_string) [2, 3, 5, 6] pass","solution":"import heapq def shortest_paths_from_capital(N, M, roads): graph = {i: [] for i in range(1, N+1)} for road in roads: u, v, w = road graph[u].append((w, v)) graph[v].append((w, u)) distances = {i: float('inf') for i in range(1, N+1)} distances[1] = 0 priority_queue = [(0, 1)] # (distance, node) while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for weight, adjacent in graph[current_node]: distance = current_distance + weight if distance < distances[adjacent]: distances[adjacent] = distance heapq.heappush(priority_queue, (distance, adjacent)) result = [] for i in range(2, N+1): if distances[i] == float('inf'): result.append(-1) else: result.append(distances[i]) return result # Function to parse input and call the solving function def minimum_distances_from_input(input_string): input_lines = input_string.strip().split(\\"n\\") N, M = map(int, input_lines[0].split()) roads = [tuple(map(int, line.split())) for line in input_lines[1:1+M]] return shortest_paths_from_capital(N, M, roads)"},{"question":"def top_projects(T, K, experience, P, projects): Identifies the top K projects by the cumulative experience of the developers working on them. Parameters: T (int): Number of developers K (int): Number of top projects to identify experience (list): List of integers representing years of experience of developers P (int): Number of projects projects (list): List of projects, where each project is described by the project ID, number of developers, and developer IDs Returns: list: List of project IDs sorted by cumulative experience in descending order >>> top_projects(5, 3, [10, 20, 15, 5, 10], 4, [\\"1 3 1 2 3\\", \\"2 2 0 4\\", \\"3 1 1\\", \\"4 4 0 1 2 3\\"]) == [4, 1, 2] >>> top_projects(3, 5, [5, 10, 15], 2, [\\"1 2 0 1\\", \\"2 1 2\\"]) == [1, 2] >>> top_projects(4, 1, [10, 20, 15, 5], 1, [\\"1 4 0 1 2 3\\"]) == [1] >>> top_projects(3, 2, [10, 20, 30], 3, [\\"1 1 0\\", \\"2 1 1\\", \\"3 1 2\\"]) == [3, 2] >>> top_projects(1, 2, [50], 2, [\\"1 1 0\\", \\"2 1 0\\"]) == [1, 2]","solution":"def top_projects(T, K, experience, P, projects): Identifies the top K projects by the cumulative experience of the developers working on them. Parameters: T (int): Number of developers K (int): Number of top projects to identify experience (list): List of integers representing years of experience of developers P (int): Number of projects projects (list): List of projects, where each project is described by the project ID, number of developers, and developer IDs Returns: list: List of project IDs sorted by cumulative experience in descending order project_experience = {} for project in projects: project_info = project.split() project_id = int(project_info[0]) num_developers = int(project_info[1]) developer_ids = list(map(int, project_info[2:])) cumulative_experience = sum(experience[dev_id] for dev_id in developer_ids) project_experience[project_id] = cumulative_experience sorted_projects = sorted(project_experience.items(), key=lambda x: x[1], reverse=True) top_k_projects = [project[0] for project in sorted_projects[:K]] return top_k_projects"},{"question":"def longest_consecutive_subsequence(arr: List[int]) -> int: Returns the length of the longest subsequence such that every element in the subsequence is consecutive and distinct. >>> longest_consecutive_subsequence([1, 9, 3, 10, 4, 20, 2]) 4 >>> longest_consecutive_subsequence([2, 1, 4, 3, 5]) 5 >>> longest_consecutive_subsequence([100]) 1 >>> longest_consecutive_subsequence([7, 7, 7, 7, 7]) 1 >>> longest_consecutive_subsequence([10, 20, 30, 40, 50]) 1 >>> longest_consecutive_subsequence(list(range(1000000, 900000, -1))) 100000 >>> longest_consecutive_subsequence([]) 0 >>> longest_consecutive_subsequence([3, -2, -1, 0, 2, 1, 4]) 7","solution":"def longest_consecutive_subsequence(arr): Returns the length of the longest subsequence such that every element in the subsequence is consecutive and distinct. if not arr: return 0 # Convert the array to a set for O(1) look-ups num_set = set(arr) longest_streak = 0 for num in num_set: # Only start a new sequence if \`num-1\` is not in the set if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def determine_winner(votes: str) -> str: Determines which language received more votes or if it's a tie. Args: votes (str): A string representing the votes cast, consisting of 'A' and 'B' characters. Returns: str: The result of the voting process. \\"LangA Wins!\\" if LangA received more votes, \\"LangB Wins!\\" if LangB received more votes, \\"It's a Tie!\\" if both received the same number of votes. def test_determine_winner_langA_wins(): assert determine_winner(\\"AAAABB\\") == \\"LangA Wins!\\" def test_determine_winner_langB_wins(): assert determine_winner(\\"AABBABB\\") == \\"LangB Wins!\\" def test_determine_winner_tie(): assert determine_winner(\\"ABBA\\") == \\"It's a Tie!\\" def test_determine_winner_all_A(): assert determine_winner(\\"AAAAA\\") == \\"LangA Wins!\\" def test_determine_winner_all_B(): assert determine_winner(\\"BBBBB\\") == \\"LangB Wins!\\" def test_determine_winner_equal_votes(): assert determine_winner(\\"AABBBBAA\\") == \\"It's a Tie!\\"","solution":"def determine_winner(votes): Determines which language received more votes or if it's a tie Args: votes (str): A string representing the votes cast, consisting of 'A' and 'B' characters Returns: str: The result of the voting process. \\"LangA Wins!\\" if LangA received more votes, \\"LangB Wins!\\" if LangB received more votes, \\"It's a Tie!\\" if both received the same number of votes. count_A = votes.count('A') count_B = votes.count('B') if count_A > count_B: return \\"LangA Wins!\\" elif count_B > count_A: return \\"LangB Wins!\\" else: return \\"It's a Tie!\\""},{"question":"def longest_successful_subsequence(n: int, logs: List[str]) -> int: Determine the length of the longest subsequence of consecutive \\"success\\" logs. Parameters: n (int): Number of logs logs (List[str]): List of log strings, each either \\"success\\" or \\"fail\\" Returns: int: Length of the longest subsequence of consecutive \\"success\\" logs. >>> longest_successful_subsequence(7, [\\"success\\", \\"fail\\", \\"success\\", \\"success\\", \\"fail\\", \\"success\\", \\"success\\", \\"success\\"]) 3 >>> longest_successful_subsequence(5, [\\"fail\\", \\"fail\\", \\"success\\", \\"success\\", \\"fail\\"]) 2 >>> longest_successful_subsequence(3, [\\"fail\\", \\"fail\\", \\"fail\\"]) 0","solution":"def longest_successful_subsequence(n, logs): Returns the length of the longest subsequence of consecutive \\"success\\" logs. Parameters: n (int): Number of logs logs (List[str]): List of log strings, each either \\"success\\" or \\"fail\\" Returns: int: Length of the longest subsequence of consecutive \\"success\\" logs max_count = 0 current_count = 0 for log in logs: if log == \\"success\\": current_count += 1 max_count = max(max_count, current_count) else: current_count = 0 return max_count"},{"question":"def minimize_sum_after_game(arr: List[int]) -> int: Alice and Bob are playing a game with an array. Alice can remove any element from the array, but each time she removes an element, Bob doubles one of the remaining elements of his choice. They alternate turns starting with Alice. Alice wants to minimize the sum of the array, and Bob wants to maximize it. Given the initial state of the array, determine the minimum possible sum after both have played optimally until there are no more elements left. >>> minimize_sum_after_game([1, 3, 2]) 0 >>> minimize_sum_after_game([1, 2, 4, 8]) 0","solution":"def minimize_sum_after_game(arr): arr.sort(reverse=True) is_alice_turn = True while arr: if is_alice_turn: arr.pop() # Alice removes the smallest element which is at the end else: arr[0] *= 2 # Bob doubles the largest element which is at the start is_alice_turn = not is_alice_turn arr.sort(reverse=True) return 0"},{"question":"from typing import List def maxGold(M: List[List[int]], n: int, m: int) -> int: Calculate the maximum amount of gold that can be collected by starting at the top-left corner of the grid and moving only to the right or down at each step. Params: - M (list of list of int): The gold grid. - n (int): The number of rows in the grid. - m (int): The number of columns in the grid. Returns: - int: The maximum amount of gold that can be collected. pass def test_example_case(): grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] assert maxGold(grid, 3, 3) == 12 def test_small_grid(): grid = [ [1] ] assert maxGold(grid, 1, 1) == 1 def test_single_row(): grid = [ [1, 2, 3, 4] ] assert maxGold(grid, 1, 4) == 10 def test_single_column(): grid = [ [1], [2], [3], [4] ] assert maxGold(grid, 4, 1) == 10 def test_all_zeros(): grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert maxGold(grid, 3, 3) == 0 def test_all_max_values(): grid = [ [100, 100, 100], [100, 100, 100], [100, 100, 100] ] assert maxGold(grid, 3, 3) == 500","solution":"def maxGold(M, n, m): Calculate the maximum amount of gold that can be collected by starting at the top-left corner of the grid and moving only to the right or down at each step. Params: - M (list of list of int): The gold grid. - n (int): The number of rows in the grid. - m (int): The number of columns in the grid. Returns: - int: The maximum amount of gold that can be collected. # Create a DP table to store the maximum gold that can be collected up to each cell dp = [[0 for _ in range(m)] for _ in range(n)] # Initialize the first cell with the amount of gold in the grid dp[0][0] = M[0][0] # Fill the first row (can only come from the left) for j in range(1, m): dp[0][j] = dp[0][j-1] + M[0][j] # Fill the first column (can only come from above) for i in range(1, n): dp[i][0] = dp[i-1][0] + M[i][0] # Fill the rest of the dp table for i in range(1, n): for j in range(1, m): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + M[i][j] # The answer will be in the bottom-right corner of the dp table return dp[n-1][m-1]"},{"question":"from typing import List def transform_list(input_list: List[int]) -> List[int]: Transforms the given list according to the rule: For each element in the input list, the corresponding element in the output list should be the product of the element itself and the next element in the list. For the last element in the input list, consider the next element to be the first element in the list. >>> transform_list([4, 1, 2, 3, 4]) == [2, 6, 12, 4] >>> transform_list([5, 3, 5, 7, 11, 13]) == [15, 35, 77, 143, 39] >>> transform_list([3, 1, 1, 1]) == [1, 1, 1] >>> transform_list([4, 9, 8, 7, 6]) == [72, 56, 42, 54] >>> transform_list([5, 2, 2, 2, 2, 2]) == [4, 4, 4, 4, 4] >>> transform_list([4, 1000, 1000, 1000, 1000]) == [1000000, 1000000, 1000000, 1000000] pass","solution":"def transform_list(input_list): Transforms the given list according to the rule: For each element in the input list, the corresponding element in the output list should be the product of the element itself and the next element in the list. For the last element in the input list, consider the next element to be the first element in the list. :param input_list: List of integers where the first element is the size n and the following n elements are the array. :return: Transformed list of integers. n = input_list[0] arr = input_list[1:] result = [] for i in range(n): next_element = arr[(i + 1) % n] # Wrap around for the last element result.append(arr[i] * next_element) return result"},{"question":"def remaining_elements_after_queries(values: str, first_queries: List[str], second_queries: List[str]) -> Tuple[List[int], int]: Apply two sets of queries to a list of integers and return the list after the queries along with the count of non-zero elements remaining. >>> remaining_elements_after_queries(\\"100 200 300 400\\", [\\"50 100\\", \\"150 200\\", \\"250 300\\", \\"350 400\\"], [\\"100 50\\", \\"200 150\\", \\"300 250\\", \\"400 350\\"]) ([0, 0, 0, 0], 0) >>> remaining_elements_after_queries(\\"100 200 300 400\\", [\\"50 150\\", \\"300 400\\"], [\\"200 250\\"]) ([0, 0, 0, 0], 0) >>> remaining_elements_after_queries(\\"100 200 300 400\\", [\\"50 99\\", \\"150 199\\", \\"250 299\\", \\"350 399\\"], [\\"100 150\\", \\"200 250\\", \\"300 350\\", \\"400 450\\"]) ([0, 0, 0, 0], 0) >>> remaining_elements_after_queries(\\"101 201 301 401\\", [\\"50 100\\", \\"150 200\\", \\"250 300\\", \\"350 400\\"], [\\"50 100\\", \\"150 200\\", \\"250 300\\", \\"350 400\\"]) ([101, 201, 301, 401], 4)","solution":"def remaining_elements_after_queries(values, first_queries, second_queries): # convert the values string into a list of integers elements = [int(x) for x in values.split()] # Function to apply the queries def apply_queries(elements, queries): for q in queries: l, r = map(int, q.split()) for i in range(len(elements)): if l <= elements[i] <= r: elements[i] = 0 return elements # Apply first set of queries elements = apply_queries(elements, first_queries) # Apply second set of queries elements = apply_queries(elements, second_queries) # Count the remaining elements which are non-zero in the list remaining_count = len([x for x in elements if x != 0]) return elements, remaining_count"},{"question":"class Sequence: def __init__(self): self.seq = [] self.prefix_sums = [0] # maintains prefix sums for optimization def append(self, x): Add integer x to the end of the sequence. # Your code here def prefix_sum(self, k): Report the sum of the first k elements of the sequence. # Your code here def remove_last(self): Remove the last element of the sequence. # Your code here def get(self, i): Report the i-th element of the sequence (1-indexed). # Your code here def process_queries(n, queries): Process a series of operations to manipulate and query the sequence. Args: n (int): The number of queries. queries (List[str]): A list of query strings. Returns: List[int]: The results of the queries that require output. Queries can be: 0 x - append x to the sequence 1 k - return the sum of the first k elements 2 - remove the last element of the sequence 3 i - return the i-th element of the sequence Examples: >>> queries = [\\"0 10\\", \\"0 20\\", \\"0 30\\", \\"1 2\\", \\"3 1\\", \\"2\\", \\"3 2\\", \\"1 2\\"] >>> process_queries(8, queries) [30, 10, 20, 30] >>> queries = [\\"0 5\\", \\"0 15\\", \\"0 25\\", \\"3 2\\"] >>> process_queries(4, queries) [15] sequence = Sequence() result = [] for query in queries: parts = query.split() command = int(parts[0]) if command == 0: x = int(parts[1]) sequence.append(x) elif command == 1: k = int(parts[1]) result.append(sequence.prefix_sum(k)) elif command == 2: sequence.remove_last() elif command == 3: i = int(parts[1]) result.append(sequence.get(i)) return result","solution":"class Sequence: def __init__(self): self.seq = [] self.prefix_sums = [0] # maintains prefix sums for optimization def append(self, x): self.seq.append(x) self.prefix_sums.append(self.prefix_sums[-1] + x) def prefix_sum(self, k): return self.prefix_sums[k] def remove_last(self): if self.seq: self.seq.pop() self.prefix_sums.pop() def get(self, i): return self.seq[i - 1] def process_queries(n, queries): sequence = Sequence() result = [] for query in queries: parts = query.split() command = int(parts[0]) if command == 0: x = int(parts[1]) sequence.append(x) elif command == 1: k = int(parts[1]) result.append(sequence.prefix_sum(k)) elif command == 2: sequence.remove_last() elif command == 3: i = int(parts[1]) result.append(sequence.get(i)) return result"},{"question":"from typing import List def tsp(fuel_matrix: List[List[int]]) -> int: Calculate the minimum fuel required for Voyager to visit all planets exactly once starting and ending at planet 1. >>> tsp([ [0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0] ]) 80 >>> tsp([ [0, 5, 9], [5, 0, 10], [9, 10, 0] ]) 24 from itertools import permutations def test_example_1(): fuel_matrix = [ [0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0] ] assert tsp(fuel_matrix) == 80 def test_example_2(): fuel_matrix = [ [0, 5, 9], [5, 0, 10], [9, 10, 0] ] assert tsp(fuel_matrix) == 24 def test_three_planets(): fuel_matrix = [ [0, 1, 2], [1, 0, 1], [2, 1, 0] ] assert tsp(fuel_matrix) == 4 def test_four_planets(): fuel_matrix = [ [0, 20, 42, 35], [20, 0, 30, 34], [42, 30, 0, 12], [35, 34, 12, 0] ] assert tsp(fuel_matrix) == 97 def test_max_values(): fuel_matrix = [ [0, 1000, 1000], [1000, 0, 1000], [1000, 1000, 0] ] assert tsp(fuel_matrix) == 3000","solution":"def tsp(fuel_matrix): from itertools import permutations n = len(fuel_matrix) total_planets = range(1, n) min_fuel = float('inf') # Generate all permutations of the planets excluding the starting planet (planet 1) for perm in permutations(total_planets): current_path_fuel = 0 # Starting from planet 1 current_planet = 0 for next_planet in perm: current_path_fuel += fuel_matrix[current_planet][next_planet] current_planet = next_planet # Return to planet 1 current_path_fuel += fuel_matrix[current_planet][0] if current_path_fuel < min_fuel: min_fuel = current_path_fuel return min_fuel"},{"question":"def is_balanced_parentheses(expression: str) -> bool: Checks if the given expression has balanced parentheses. Args: expression (str): A string consisting of '(', ')', '{', '}', '[' and ']' characters. Returns: bool: True if every opening parenthesis has a corresponding closing parenthesis in the correct order, otherwise False. >>> is_balanced_parentheses(\\"()\\") == True >>> is_balanced_parentheses(\\"()[]{}\\") == True >>> is_balanced_parentheses(\\"(]\\") == False >>> is_balanced_parentheses(\\"([)]\\") == False >>> is_balanced_parentheses(\\"{[]}\\") == True def test_is_balanced_parentheses(): assert is_balanced_parentheses(\\"()\\") == True assert is_balanced_parentheses(\\"()[]{}\\") == True assert is_balanced_parentheses(\\"(]\\") == False assert is_balanced_parentheses(\\"([)]\\") == False assert is_balanced_parentheses(\\"{[]}\\") == True assert is_balanced_parentheses(\\"{[()]}\\") == True assert is_balanced_parentheses(\\"{[(])}\\") == False assert is_balanced_parentheses(\\"(((((((((())))))))))\\") == True assert is_balanced_parentheses(\\"(((((((((()))))))))\\") == False assert is_balanced_parentheses(\\"[]{}()\\") == True assert is_balanced_parentheses(\\"[\\") == False assert is_balanced_parentheses(\\"[{}\\") == False assert is_balanced_parentheses(\\"[{}]\\") == True if __name__ == '__main__': test_is_balanced_parentheses()","solution":"def is_balanced_parentheses(expression): Checks if the given expression has balanced parentheses. Args: expression (str): A string consisting of '(', ')', '{', '}', '[' and ']' characters. Returns: bool: True if every opening parenthesis has a corresponding closing parenthesis in the correct order, otherwise False. stack = [] # Dictionary to maintain the mapping of closing and opening brackets parentheses = {')':'(', '}':'{', ']':'['} for char in expression: # If the character is one of the opening brackets if char in parentheses.values(): stack.append(char) # If the character is one of the closing brackets elif char in parentheses.keys(): # If the stack is empty or top of the stack does not match the corresponding opening bracket if not stack or stack.pop() != parentheses[char]: return False # If the stack is empty, parentheses are balanced, else they are not return not stack"},{"question":"def generate_permutation(n): Generates a permutation of numbers [1, 2, ..., n] such that the absolute difference between any two consecutive elements is at most 2. >>> generate_permutation(1) [1] >>> generate_permutation(2) [1, 2] >>> generate_permutation(3) [1, 2, 3] >>> generate_permutation(4) [1, 2, 3, 4] pass def solve_permutations(T, cases): Given a number of test cases T and a list of integers cases, generates a permutation of numbers [1, 2, ..., n] for each integer n in cases. >>> solve_permutations(4, [1, 2, 3, 4]) [[1], [1, 2], [1, 2, 3], [1, 2, 3, 4]] >>> solve_permutations(3, [5, 6, 7]) [[1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6, 7]] pass","solution":"def generate_permutation(n): Generates a permutation of numbers [1, 2, ..., n] such that the absolute difference between any two consecutive elements is at most 2. If no such permutation exists, return an empty list. if n == 1: return [1] elif n == 2: return [1, 2] elif n == 3: return [1, 2, 3] else: permutation = [] for i in range(1, n + 1): permutation.append(i) return permutation def solve_permutations(T, cases): results = [] for n in cases: results.append(generate_permutation(n)) return results"},{"question":"def process_input(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[List[int]]: You are given a list of \`n\` integers representing the daily temperatures for the next \`n\` days. Write a program to find out how many days you would have to wait until a warmer temperature for each day. If there is no future day with a warmer temperature, put \`0\` for that day. Args: t : int : number of test cases test_cases : List[Tuple[int, List[int]]] : list of tuples containing number of days and temperatures Returns: List[List[int]] : for each test case, a list of integers representing the number of days to wait until a warmer temperature Example: >>> process_input(3, [(5, [73, 74, 75, 71, 69]), (8, [30, 40, 50, 60, 50, 40, 30, 20]), (4, [10, 15, 20, 25])]) [[1, 1, 0, 0, 0], [1, 1, 1, 0, 0, 0, 0, 0], [1, 1, 1, 0]] >>> process_input(1, [(4, [73, 74, 75, 76])]) [[1, 1, 1, 0]] >>> process_input(2, [(2, [25, 30]), (5, [1, 1, 1, 1, 1])]) [[1, 0], [0, 0, 0, 0, 0]] >>> process_input(1, [(7, [50, 55, 50, 60, 70, 65, 68])]) [[1, 2, 1, 1, 0, 1, 0]]","solution":"def daily_temperatures(cases): result = [] for i in range(len(cases)): days = cases[i] n = len(days) res = [0] * n stack = [] for j in range(n-1, -1, -1): while stack and days[j] >= days[stack[-1]]: stack.pop() if stack: res[j] = stack[-1] - j stack.append(j) result.append(res) return result def process_input(t, test_cases): cases = [] for i in range(t): n = test_cases[i][0] days = test_cases[i][1] cases.append(days) return daily_temperatures(cases)"},{"question":"def find_min_abs_difference(n: int, weights: List[int]) -> int: Determine the minimum possible absolute difference between the sums of the weights of two groups. >>> find_min_abs_difference(4, [1, 2, 3, 4]) 0 >>> find_min_abs_difference(3, [1, 4, 7]) 2","solution":"def find_min_abs_difference(n, weights): Determine the minimum possible absolute difference between the sums of the weights of two groups. def find_ways(weights, idx, sum1, sum2): if idx < 0: return abs(sum1 - sum2) take_sum1 = find_ways(weights, idx - 1, sum1 + weights[idx], sum2) take_sum2 = find_ways(weights, idx - 1, sum1, sum2 + weights[idx]) return min(take_sum1, take_sum2) return find_ways(weights, n - 1, 0, 0)"},{"question":"def min_length_after_removals(s: str) -> int: Return the minimum length of the string after both players have removed one character each. Parameters: s (str): The input string. Returns: int: The minimum length of the string after both removals. >>> min_length_after_removals(\\"abcdef\\") 4 >>> min_length_after_removals(\\"hello\\") 3 >>> min_length_after_removals(\\"x\\") 0","solution":"def min_length_after_removals(s): Return the minimum length of the string after both players have removed one character each. Parameters: s (str): The input string. Returns: int: The minimum length of the string after both removals. # The game constraint is that Taro and Jiro each remove one character. # Thus the remaining length will be the original length minus 2. return max(len(s) - 2, 0)"},{"question":"def lexicographically_smallest_string(s: str) -> str: This function takes a string as input and returns the lexicographically smallest string possible by removing exactly one character. >>> lexicographically_smallest_string(\\"abcdef\\") \\"abcde\\" >>> lexicographically_smallest_string(\\"abacaba\\") \\"aacaba\\"","solution":"def lexicographically_smallest_string(s): This function takes a string as input and returns the lexicographically smallest string possible by removing exactly one character. n = len(s) # We want to find the first character which is greater than its next character for i in range(n - 1): if s[i] > s[i + 1]: return s[:i] + s[i + 1:] # If no such character is found, remove the last character return s[:-1]"},{"question":"def find_trailing_zeroes(n): Returns the number of trailing zeroes in the factorial of n. >>> find_trailing_zeroes(6) == 1 >>> find_trailing_zeroes(12) == 2 >>> find_trailing_zeroes(20) == 4 def solve_trailing_zeroes(test_cases): Given a list of test cases, returns a list of results for each test case. >>> solve_trailing_zeroes([6, 12, 20]) == [1, 2, 4] >>> solve_trailing_zeroes([0, 5, 100]) == [0, 1, 24]","solution":"def find_trailing_zeroes(n): Returns the number of trailing zeroes in the factorial of n. count = 0 i = 5 while n >= i: count += n // i i *= 5 return count def solve_trailing_zeroes(test_cases): Given a list of test cases, returns a list of results for each test case results = [] for n in test_cases: results.append(find_trailing_zeroes(n)) return results"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree(node_list): Build a binary tree from a list of tuples where each tuple contains the value of a node and the values of its left and right children. >>> node_list = [(3, 9, 20), (9, -1, -1), (20, 15, 7), (15, -1, -1), (7, -1, -1)] >>> root = build_tree(node_list) >>> root.val == 3 and root.left.val == 9 and root.right.val == 20 and root.right.left.val == 15 and root.right.right.val == 7 True pass def sum_of_left_leaves(root): Computes the sum of the values of all left leaves in a binary tree. >>> node_list = [(3, 9, 20), (9, -1, -1), (20, 15, 7), (15, -1, -1), (7, -1, -1)] >>> root = build_tree(node_list) >>> sum_of_left_leaves(root) 24 >>> node_list = [(1, 2, 3), (2, -1, -1), (3, -1, -1)] >>> root = build_tree(node_list) >>> sum_of_left_leaves(root) 2 pass def left_leaves_sum_multiple_cases(test_cases): For multiple test cases, compute the sum of all left leaves in each binary tree. >>> test_cases = [ ... (5, [(3, 9, 20), (9, -1, -1), (20, 15, 7), (15, -1, -1), (7, -1, -1)]), ... (3, [(1, 2, 3), (2, -1, -1), (3, -1, -1)]) ... ] >>> left_leaves_sum_multiple_cases(test_cases) [24, 2] pass","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree(node_list): if not node_list: return None nodes = {} for value, left, right in node_list: if value not in nodes: nodes[value] = TreeNode(value) node = nodes[value] if left != -1: if left not in nodes: nodes[left] = TreeNode(left) node.left = nodes[left] if right != -1: if right not in nodes: nodes[right] = TreeNode(right) node.right = nodes[right] return nodes[node_list[0][0]] def sum_of_left_leaves(root): if not root: return 0 def is_leaf(node): return node and not node.left and not node.right def dfs(node, is_left): if not node: return 0 if is_leaf(node) and is_left: return node.val return dfs(node.left, True) + dfs(node.right, False) return dfs(root, False) def left_leaves_sum_multiple_cases(test_cases): results = [] for case in test_cases: n, nodes_info = case root = build_tree(nodes_info) result = sum_of_left_leaves(root) results.append(result) return results"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree(values): Build a binary tree from a list of values. if not values: return None nodes = [TreeNode(val) if val is not None else None for val in values] kids = nodes[::-1] root = kids.pop() for node in nodes: if node: if kids: node.left = kids.pop() if kids: node.right = kids.pop() return root def max_path_sum(root): Compute the maximum path sum of a binary tree. def helper(node): nonlocal max_sum if not node: return 0 left = max(helper(node.left), 0) right = max(helper(node.right), 0) current_sum = node.val + left + right max_sum = max(max_sum, current_sum) return node.val + max(left, right) max_sum = float('-inf') helper(root) return max_sum def find_max_path_sums(trees): Given multiple test cases of binary trees, return the maximum path sums. >>> find_max_path_sums([[1, 2, 3]]) == [6] >>> find_max_path_sums([[-10, 9, 20, None, None, 15, 7]]) == [42] >>> find_max_path_sums([[5, 4, 8, 11, None, 13, 4, 7, 2, None, None, None, 1]]) == [48] results = [] for tree in trees: root = build_tree(tree) results.append(max_path_sum(root)) return results","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree(values): if not values: return None nodes = [TreeNode(val) if val is not None else None for val in values] kids = nodes[::-1] root = kids.pop() for node in nodes: if node: if kids: node.left = kids.pop() if kids: node.right = kids.pop() return root def max_path_sum(root): def helper(node): nonlocal max_sum if not node: return 0 left = max(helper(node.left), 0) right = max(helper(node.right), 0) current_sum = node.val + left + right max_sum = max(max_sum, current_sum) return node.val + max(left, right) max_sum = float('-inf') helper(root) return max_sum def find_max_path_sums(trees): results = [] for tree in trees: root = build_tree(tree) results.append(max_path_sum(root)) return results"},{"question":"def longest_non_decreasing_subsequence(n: int, gold_amounts: List[int]) -> int: Find the length of the longest subsequence of villages where the gold amounts are in non-decreasing order as you move right. >>> longest_non_decreasing_subsequence(5, [1, 2, 2, 1, 3]) 3 >>> longest_non_decreasing_subsequence(6, [1, 3, 2, 2, 4, 5]) 4","solution":"def longest_non_decreasing_subsequence(n, gold_amounts): if n == 0: return 0 dp = [1] * n # Initialize the dp array to 1 for i in range(1, n): if gold_amounts[i] >= gold_amounts[i - 1]: dp[i] = dp[i - 1] + 1 return max(dp)"},{"question":"def can_reach_end(n: int, m: int, k: int, grid: List[List[int]]) -> str: Determine whether it is possible to reach the bottom-right corner of the grid from the top-left corner under the condition that you can only move to an adjacent cell if the absolute difference in elevation between your current cell and the adjacent cell is at most k. >>> can_reach_end(3, 3, 2, [[1, 3, 5], [2, 8, 7], [1, 4, 6]]) \\"Yes\\" >>> can_reach_end(2, 2, 1, [[1, 2], [3, 4]]) \\"No\\"","solution":"def can_reach_end(n, m, k, grid): from collections import deque # Directions for moving right, left, down, up directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # BFS Initialization queue = deque([(0, 0)]) visited = set((0, 0)) while queue: x, y = queue.popleft() # Check if we've reached the bottom-right corner if x == n - 1 and y == m - 1: return \\"Yes\\" for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited: if abs(grid[nx][ny] - grid[x][y]) <= k: queue.append((nx, ny)) visited.add((nx, ny)) return \\"No\\" # Example usage: # n, m, k = 3, 3, 2 # grid = [ # [1, 3, 5], # [2, 8, 7], # [1, 4, 6] # ] # print(can_reach_end(n, m, k, grid))"},{"question":"def highest_diversity(n: int, m: int, k: int, grid: List[List[int]]) -> int: Find the highest diversity subgrid in an n x m grid of k colors. Parameters: n (int): Number of rows. m (int): Number of columns. k (int): Number of colors. grid (List[List[int]]): The grid containing color values for each cell. Returns: int: The highest diversity in any subgrid within the given grid. Examples: >>> highest_diversity(3, 3, 2, [ ... [1, 2, 1], ... [2, 1, 2], ... [1, 2, 1]]) 2 >>> highest_diversity(4, 4, 3, [ ... [1, 2, 3, 1], ... [3, 2, 2, 1], ... [1, 3, 1, 3], ... [2, 3, 1, 2]]) 3","solution":"def highest_diversity(n, m, k, grid): max_diversity = 0 for top in range(n): for left in range(m): unique_colors = set() for bottom in range(top, n): for right in range(left, m): for i in range(top, bottom+1): for j in range(left, right+1): unique_colors.add(grid[i][j]) max_diversity = max(max_diversity, len(unique_colors)) return max_diversity"},{"question":"def max_observation_cells(grid, k): Given a grid with 'O' and 'X', and the size of the square observation platform k, returns the maximum number of 'O' cells that can be covered by the platform. >>> grid = [ ... \\"OOOOX\\", ... \\"OOOOX\\", ... \\"XXOOX\\", ... \\"XOXXO\\" ... ] >>> max_observation_cells(grid, 2) 4 >>> grid = [ ... \\"OXOXO\\", ... \\"XOXOX\\", ... \\"OXOXO\\", ... \\"XOXOX\\" ... ] >>> max_observation_cells(grid, 3) 5 >>> grid = [ ... \\"XXXXX\\", ... \\"XXXXX\\", ... \\"XXXXX\\", ... \\"XXXXX\\" ... ] >>> max_observation_cells(grid, 3) 0 >>> grid = [ ... \\"OXOXOXO\\", ... \\"XOXOXOX\\", ... \\"OXOXOXO\\", ... \\"XOXOXOX\\", ... \\"OXOXOXO\\" ... ] >>> max_observation_cells(grid, 2) 2 # Function implementation goes here","solution":"def max_observation_cells(grid, k): Given a grid with 'O' and 'X', and size of the square observation platform k, returns the maximum number of 'O' cells that can be covered by the platform. N = len(grid) M = len(grid[0]) max_count = 0 for i in range(N - k + 1): for j in range(M - k + 1): count = 0 for x in range(i, i + k): for y in range(j, j + k): if grid[x][y] == 'O': count += 1 max_count = max(max_count, count) return max_count # Function to use for reading inputs and executing the solution def read_and_solve(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) M = int(data[1]) grid = [data[2 + i] for i in range(N)] k = int(data[2 + N]) return max_observation_cells(grid, k)"},{"question":"import math from functools import reduce from typing import List def gcd_of_intervals(intervals: List[int]) -> int: Returns the greatest common divisor (GCD) of a set of task intervals. >>> gcd_of_intervals([12, 15, 21]) 3 >>> gcd_of_intervals([24, 36, 48, 60]) 12 >>> gcd_of_intervals([5, 5, 5, 5]) 5 >>> gcd_of_intervals([3, 5, 7, 11]) 1 >>> gcd_of_intervals([100, 75]) 25","solution":"import math from functools import reduce def gcd_of_intervals(intervals): Returns the greatest common divisor (GCD) of a set of task intervals. return reduce(math.gcd, intervals)"},{"question":"def update_warehouse_inventory(M: int, warehouse_inventory: List[int], N: int, restock_requests: List[List[int]]) -> Tuple[List[int], List[bool]]: Update the warehouse inventory based on the restock requests from multiple bookstores. Args: M: int - The number of different books in the warehouse. warehouse_inventory: List[int] - List of integers representing the number of copies of each book in the warehouse. N: int - The number of bookstores making restock requests. restock_requests: List[List[int]] - List of lists, each containing integers representing the requests from each bookstore. Returns: Tuple[List[int], List[bool]] - The updated inventory of the warehouse and a boolean list indicating whether each corresponding restock request was fulfilled successfully. Examples: >>> update_warehouse_inventory(3, [100, 150, 200], 2, [[30, 20, 50], [100, 200, 10]]) ([0, 0, 140], [True, False])","solution":"def update_warehouse_inventory(M, warehouse_inventory, N, restock_requests): # Result setup for remaining inventory and fulfilment status updated_inventory = warehouse_inventory[:] fulfilment_status = [] for request in restock_requests: can_fulfil_request = True # Check if all requested books can be fulfilled for i in range(M): if request[i] > updated_inventory[i]: can_fulfil_request = False break # If we can fulfil the request then update the inventory if can_fulfil_request: for i in range(M): updated_inventory[i] -= request[i] fulfilment_status.append(can_fulfil_request) return updated_inventory, fulfilment_status"},{"question":"def can_form_teams(n: int, preferences: List[List[int]]) -> str: You have been tasked with organizing a company's charity run. Each participant is given a unique ID and is required to form a team. A team consists of exactly 3 members. However, there are some constraints on how the teams can be formed: - Each participant can join at most one team. - The participants are allowed to choose their teammates based on their preferences. - To make the event fair, no two teams should share more than one participant in any pairing formed before. Your goal is to assign exactly one team for each participant, which satisfies the constraints mentioned above. >>> can_form_teams(6, [[2, 3, -1], [1, 3, -1], [1, 2, -1], [5, 6, -1], [4, 6, -1], [4, 5, -1]]) \\"YESn1 2 3n4 5 6\\" >>> can_form_teams(6, [[2, -1], [1, 3, -1], [2, 5, -1], [2, 3, -1], [3, 2, -1], [2, 1, -1]]) \\"NO\\" >>> can_form_teams(3, [[2, 3, -1], [1, 3, -1], [1, 2, -1]]) \\"YESn1 2 3\\"","solution":"def can_form_teams(n, preferences): from collections import defaultdict, deque if n % 3 != 0: return \\"NO\\" # Create a dictionary to store the preferences list for each participant preference_map = {} for i in range(n): preference_map[i + 1] = preferences[i] teams = [] used = set() def find_team(member, visited, forming_team): visited.add(member) forming_team.append(member) if len(forming_team) == 3: return forming_team for mate in preference_map[member]: if mate != -1 and mate not in visited and mate not in used: result = find_team(mate, visited, forming_team) if result: return result forming_team.pop() visited.remove(member) return None for i in range(1, n+1): if i not in used: team = find_team(i, set(), []) if team: teams.append(team) for member in team: used.add(member) else: return \\"NO\\" if len(teams) == n // 3: result = [\\"YES\\"] for team in teams: result.append(\\" \\".join(map(str, team))) return \\"n\\".join(result) else: return \\"NO\\""},{"question":"from typing import List, Tuple def longestCommonSubsequence(x: str, y: str, z: str) -> int: Returns the length of the longest common subsequence among three strings x, y and z. >>> longestCommonSubsequence(\\"abc\\", \\"abc\\", \\"abc\\") 3 >>> longestCommonSubsequence(\\"abc\\", \\"def\\", \\"ghi\\") 0 pass def main(t: int, test_cases: List[Tuple[str, str, str]]) -> List[int]: For each test case, find the length of the longest common subsequence of the given three strings. >>> main(2, [(\\"abc\\", \\"abc\\", \\"abc\\"), (\\"abc\\", \\"def\\", \\"ghi\\")]) [3, 0] >>> main(1, [(\\"a\\", \\"b\\", \\"c\\")]) [0] pass","solution":"def longestCommonSubsequence(x, y, z): Returns the length of the longest common subsequence among three strings x, y and z. l = len(x) m = len(y) n = len(z) # Create a 3D DP array to store lengths of LCS. dp = [[[0] * (n + 1) for _ in range(m + 1)] for __ in range(l + 1)] for i in range(1, l + 1): for j in range(1, m + 1): for k in range(1, n + 1): if x[i - 1] == y[j - 1] == z[k - 1]: dp[i][j][k] = dp[i - 1][j - 1][k - 1] + 1 else: dp[i][j][k] = max( dp[i - 1][j][k], dp[i][j - 1][k], dp[i][j][k - 1] ) return dp[l][m][n] def main(t, test_cases): results = [] for i in range(t): x, y, z = test_cases[i] results.append(longestCommonSubsequence(x, y, z)) return results"},{"question":"def final_coordinates(move_sequence: str) -> tuple: Given a sequence of moves, calculate the final coordinates of the robot. Args: move_sequence (str): a string representing the sequence of moves ('U', 'D', 'L', 'R') Returns: tuple: a tuple (x, y) representing the final coordinates of the robot Examples: >>> final_coordinates(\\"UUDDLRLR\\") (0, 0) >>> final_coordinates(\\"UUUUURRRRR\\") (5, 5)","solution":"def final_coordinates(move_sequence): Given a sequence of moves, calculate the final coordinates of the robot. Args: move_sequence (str): a string representing the sequence of moves ('U', 'D', 'L', 'R') Returns: tuple: a tuple (x, y) representing the final coordinates of the robot x, y = 0, 0 for move in move_sequence: if move == 'U': y += 1 elif move == 'D': y -= 1 elif move == 'L': x -= 1 elif move == 'R': x += 1 return (x, y)"},{"question":"from typing import List def min_abs_diff_partition(n: int, arr: List[int]) -> int: Partition the list into two non-empty subsets such that the absolute difference between the sum of the elements in the two subsets is minimized. >>> min_abs_diff_partition(4, [1, 2, 3, 4]) == 0 >>> min_abs_diff_partition(3, [1, 6, 11]) == 4 >>> min_abs_diff_partition(6, [3, 1, 4, 2, 2, 1]) == 1 >>> min_abs_diff_partition(2, [1, 2]) == 1 >>> min_abs_diff_partition(4, [1, 1, 1, 1]) == 0 >>> min_abs_diff_partition(3, [-1, -2, -3]) == 0 >>> min_abs_diff_partition(4, [-1, -2, 3, 8]) == 2","solution":"from itertools import combinations def min_abs_diff_partition(n, arr): total_sum = sum(arr) min_diff = float('inf') # Evaluate all possible subsets and their complements for r in range(1, n//2 + 1): for comb in combinations(arr, r): subset_sum = sum(comb) other_subset_sum = total_sum - subset_sum min_diff = min(min_diff, abs(subset_sum - other_subset_sum)) return min_diff"},{"question":"def min_removals_for_increasing_order(n: int, a: List[int]) -> int: Returns the minimum number of elements to be removed so that the remaining elements are in increasing order. Parameters: n (int): the length of the list. a (list of int): the elements of the list. Returns: int: the minimum number of elements to be removed. Example: >>> min_removals_for_increasing_order(7, [4, 2, 3, 6, 10, 1, 12]) 2 >>> min_removals_for_increasing_order(5, [5, 4, 3, 2, 1]) 4","solution":"def min_removals_for_increasing_order(n, a): Returns the minimum number of elements to be removed so that the remaining elements are in increasing order. Parameters: n (int): the length of the list. a (list of int): the elements of the list. Returns: int: the minimum number of elements to be removed. if n <= 1: return 0 # dp[i] will store the length of the Longest Increasing Subsequence that ends with a[i] dp = [1] * n for i in range(1, n): for j in range(i): if a[i] > a[j]: dp[i] = max(dp[i], dp[j] + 1) longest_increasing_subsequence = max(dp) # Elements to remove are total elements minus the length of the longest increasing subsequence return n - longest_increasing_subsequence"},{"question":"def min_routers(M: int, N: int, grid: List[List[str]], R: int) -> int: Determine the minimum number of routers required so that every building is within R steps of at least one router. >>> M = 4 >>> N = 4 >>> grid = [ ... ['B', 'E', 'E', 'B'], ... ['E', 'E', 'E', 'E'], ... ['E', 'B', 'E', 'E'], ... ['E', 'E', 'E', 'B'] ... ] >>> R = 2 >>> min_routers(M, N, grid, R) 2 >>> M = 3 >>> N = 3 >>> grid = [ ... ['E', 'E', 'E'], ... ['E', 'E', 'E'], ... ['E', 'E', 'E'] ... ] >>> R = 1 >>> min_routers(M, N, grid, R) 0 >>> M = 3 >>> N = 3 >>> grid = [ ... ['E', 'E', 'E'], ... ['E', 'B', 'E'], ... ['E', 'E', 'E'] ... ] >>> R = 1 >>> min_routers(M, N, grid, R) 1 >>> M = 3 >>> N = 3 >>> grid = [ ... ['B', 'E', 'E'], ... ['E', 'E', 'E'], ... ['E', 'E', 'B'] ... ] >>> R = 1 >>> min_routers(M, N, grid, R) 2 >>> M = 5 >>> N = 5 >>> grid = [ ... ['B', 'E', 'E', 'E', 'B'], ... ['E', 'E', 'E', 'E', 'E'], ... ['E', 'E', 'B', 'E', 'E'], ... ['E', 'E', 'E', 'E', 'E'], ... ['B', 'E', 'E', 'E', 'B'] ... ] >>> R = 2 >>> min_routers(M, N, grid, R) 2 pass","solution":"from typing import List, Tuple from collections import deque def min_routers(M: int, N: int, grid: List[List[str]], R: int) -> int: def in_bounds(x, y): return 0 <= x < M and 0 <= y < N def bfs(start_x, start_y, steps, covered): q = deque([(start_x, start_y, 0)]) while q: x, y, d = q.popleft() if d > steps: break if (x, y) in covered: continue covered.add((x, y)) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if in_bounds(nx, ny) and (nx, ny) not in covered: q.append((nx, ny, d + 1)) def can_cover_all(routers): covered = set() for x, y in routers: bfs(x, y, R, covered) for i in range(M): for j in range(N): if grid[i][j] == 'B' and (i, j) not in covered: return False return True buildings = [(i, j) for i in range(M) for j in range(N) if grid[i][j] == 'B'] empty_spaces = [(i, j) for i in range(M) for j in range(N) if grid[i][j] == 'E'] def possible(router_count): if router_count == 0: return can_cover_all([]) from itertools import combinations for combo in combinations(empty_spaces, router_count): if can_cover_all(combo): return True return False left, right = 0, len(buildings) while left < right: mid = (left + right) // 2 if possible(mid): right = mid else: left = mid + 1 return left"},{"question":"from typing import List, Tuple def solve_book_of_spells(n: int, m: int, powers: List[int], edges: List[Tuple[int, int]], queries: List[Tuple[int, int]]) -> List[List[int]]: Find the k highest power values among the vertices reachable from u in an undirected graph. Arguments: n -- the number of vertices in the graph m -- the number of edges in the graph powers -- a list of integers representing the power values of the vertices edges -- a list of tuples where each tuple represents an edge between two vertices queries -- a list of tuples where each tuple consists of a starting vertex and the number of highest power values to find Returns: A list of lists where each list contains the k highest power values for the corresponding query Example: >>> solve_book_of_spells(5, 4, [10, 20, 30, 40, 50], [(1, 2), (2, 3), (3, 4), (4, 5)], [(1, 3), (2, 4)]) [[50, 40, 30], [50, 40, 30, 20]] >>> solve_book_of_spells(4, 2, [8, 16, 24, 32], [(1, 2), (3, 4)], [(2, 2), (4, 3)]) [[16, 8], [32, 24]]","solution":"from heapq import nlargest from collections import defaultdict, deque def bfs(graph, start, n): visited = [False] * n queue = deque([start]) visited[start] = True reachable = [] while queue: node = queue.popleft() reachable.append(node) for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return reachable def solve_book_of_spells(n, m, powers, edges, queries): graph = defaultdict(list) # Building the graph for u, v in edges: graph[u - 1].append(v - 1) graph[v - 1].append(u - 1) results = [] for u, k in queries: reachable_nodes = bfs(graph, u - 1, n) reachable_powers = [powers[node] for node in reachable_nodes] highest_powers = nlargest(k, reachable_powers) results.append(highest_powers) return results # Example usage: n = 5 m = 4 powers = [10, 20, 30, 40, 50] edges = [(1, 2), (2, 3), (3, 4), (4, 5)] queries = [(1, 3), (2, 4)] print(solve_book_of_spells(n, m, powers, edges, queries))"},{"question":"def min_removals_to_unique(string: str) -> int: Returns the minimum number of characters to remove from the string to make all characters unique. >>> min_removals_to_unique(\\"abac\\") 1 >>> min_removals_to_unique(\\"aabb\\") 2 >>> min_removals_to_unique(\\"abcd\\") 0 >>> min_removals_to_unique(\\"aa\\") 1 >>> min_removals_to_unique(\\"a\\") 0 def process_test_cases(test_cases: List[str]) -> List[int]: Process multiple test cases to find the minimum number of gemstones Sarah needs to remove to ensure all the remaining gemstones are unique. >>> process_test_cases([\\"abac\\", \\"aabb\\"]) [1, 2] >>> process_test_cases([\\"abcd\\", \\"aa\\"]) [0, 1] >>> process_test_cases([\\"a\\"]) [0] >>> process_test_cases([]) [] def main(T: int, test_cases: List[str]) -> None: Main function to read input test cases and output the necessary removal count for uniqueness. >>> main(2, [\\"abac\\", \\"aabb\\"]) 1 2 >>> main(2, [\\"abcd\\", \\"aa\\"]) 0 1","solution":"def min_removals_to_unique(string): Returns the minimum number of characters to remove from the string to make all characters unique. seen = set() removals = 0 for char in string: if char in seen: removals += 1 else: seen.add(char) return removals def process_test_cases(test_cases): results = [] for string in test_cases: results.append(min_removals_to_unique(string)) return results def main(T, test_cases): results = process_test_cases(test_cases) for result in results: print(result)"},{"question":"def minimize_max_sum(n: int, arr: List[int]) -> int: You are given an array \`arr\` with \`n\` integers. You need to determine the smallest possible \`k\` such that the following constraints are met: 1. You can divide \`arr\` into \`k\` contiguous subarrays. 2. The sum of the maximum element in each subarray should be minimized. Write a function \`minimize_max_sum(n, arr)\` that returns the minimum possible sum of the maximum elements of the subarrays. >>> minimize_max_sum(5, [1, 2, 3, 4, 5]) 5 >>> minimize_max_sum(6, [2, 1, 4, 1, 2, 3]) 4 >>> minimize_max_sum(1, [10]) 10 >>> minimize_max_sum(3, [5, 5, 5]) 5 >>> minimize_max_sum(5, [5, 4, 3, 2, 1]) 5 >>> minimize_max_sum(5, [1, 2, 3, 4, 5]) 5 >>> minimize_max_sum(5, [1000000, 1000000, 1000000, 1000000, 1000000]) 1000000 >>> minimize_max_sum(10, [2, 3, 1, 2, 4, 3, 5, 1, 2, 2]) 5","solution":"def minimize_max_sum(n, arr): def can_split(mid): # check if we can split the array such that no segment sum exceeds mid current_sum = 0 splits_required = 1 for num in arr: if current_sum + num <= mid: current_sum += num else: splits_required += 1 current_sum = num return splits_required left, right = max(arr), sum(arr) while left < right: mid = (left + right) // 2 if can_split(mid) > n: left = mid + 1 else: right = mid return left"},{"question":"class EventScheduler: Manages and schedules events. Each event has a name and occurs at a specific time, represented as a tuple (name, time). The class supports: - scheduling a new event - removing an existing event - listing all scheduled events in a sorted order according to time. Time is given in minutes from the start of the scheduling period. Example usage: >>> scheduler = EventScheduler() >>> scheduler.schedule_event((\\"Meeting\\", 30)) >>> scheduler.schedule_event((\\"Workshop\\", 60)) >>> scheduler.schedule_event((\\"Lunch\\", 45)) >>> scheduler.schedule_event((\\"Meeting\\", 50)) # Update the time for 'Meeting' >>> scheduler.remove_event(\\"Lunch\\") >>> events = scheduler.list_events() >>> print(events) [('Meeting', 50), ('Workshop', 60)] def __init__(self): pass def schedule_event(self, event): Schedules a new event or updates the time of an existing event. :param event: Tuple of (name, time). If event with the same name exists, updates the time. pass def remove_event(self, name): Removes an event by its name. :param name: Name of the event to remove. Does nothing if the event does not exist. pass def list_events(self): Lists all scheduled events, sorted by time. If events have the same time, they are sorted by name. :return: List of tuples (name, time) sorted by time and name. pass # Test cases def test_schedule_event(): scheduler = EventScheduler() scheduler.schedule_event((\\"Meeting\\", 30)) scheduler.schedule_event((\\"Workshop\\", 60)) assert scheduler.list_events() == [(\\"Meeting\\", 30), (\\"Workshop\\", 60)] def test_update_event(): scheduler = EventScheduler() scheduler.schedule_event((\\"Meeting\\", 30)) scheduler.schedule_event((\\"Meeting\\", 50)) # Update the time for 'Meeting' assert scheduler.list_events() == [(\\"Meeting\\", 50)] def test_remove_event(): scheduler = EventScheduler() scheduler.schedule_event((\\"Meeting\\", 30)) scheduler.schedule_event((\\"Lunch\\", 45)) scheduler.remove_event(\\"Lunch\\") assert scheduler.list_events() == [(\\"Meeting\\", 30)] def test_events_sorted_by_time(): scheduler = EventScheduler() scheduler.schedule_event((\\"Meeting\\", 30)) scheduler.schedule_event((\\"Workshop\\", 20)) assert scheduler.list_events() == [(\\"Workshop\\", 20), (\\"Meeting\\", 30)] def test_events_sorted_by_name_if_same_time(): scheduler = EventScheduler() scheduler.schedule_event((\\"Meeting\\", 30)) scheduler.schedule_event((\\"Lunch\\", 30)) assert scheduler.list_events() == [(\\"Lunch\\", 30), (\\"Meeting\\", 30)] def test_list_events_empty(): scheduler = EventScheduler() assert scheduler.list_events() == [] def test_multiple_operations(): scheduler = EventScheduler() scheduler.schedule_event((\\"Meeting\\", 50)) scheduler.schedule_event((\\"Workshop\\", 60)) scheduler.schedule_event((\\"Lunch\\", 45)) scheduler.schedule_event((\\"Meeting\\", 55)) # Update the time for 'Meeting' scheduler.remove_event(\\"Lunch\\") assert scheduler.list_events() == [(\\"Meeting\\", 55), (\\"Workshop\\", 60)]","solution":"class EventScheduler: def __init__(self): self.events = {} def schedule_event(self, event): name, time = event self.events[name] = time def remove_event(self, name): if name in self.events: del self.events[name] def list_events(self): return sorted(self.events.items(), key=lambda event: (event[1], event[0]))"},{"question":"def peak_heights(n: int, m: int, grid: List[List[int]]) -> List[int]: Identify all peak cells in the grid and output their heights in non-increasing order. An off-grid cell is treated as having a height of negative infinity. >>> peak_heights(3, 3, [[3, 4, 5], [2, 6, 1], [1, 2, 3]]) [6, 5, 3] >>> peak_heights(1, 1, [[7]]) [7] >>> peak_heights(3, 3, [[1, 1, 1], [1, 1, 1], [1, 1, 1]]) []","solution":"def find_peaks(grid): def is_peak(i, j): current = grid[i][j] for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]: ni, nj = i + di, j + dj if 0 <= ni < len(grid) and 0 <= nj < len(grid[0]): if current <= grid[ni][nj]: return False return True peaks = [] for i in range(len(grid)): for j in range(len(grid[0])): if is_peak(i, j): peaks.append(grid[i][j]) return sorted(peaks, reverse=True) def peak_heights(n, m, grid): return find_peaks(grid)"},{"question":"from typing import List, Tuple def are_equivalent(s1: str, s2: str) -> str: Determines if string s1 can be transformed into string s2 using ZLang concatenation and rotation rules. >>> are_equivalent(\\"abc\\", \\"cab\\") \\"YES\\" >>> are_equivalent(\\"abc\\", \\"def\\") \\"NO\\" def process_test_cases(test_cases: List[Tuple[str, str]]) -> List[str]: Processes each test case and generates results. >>> process_test_cases([(\\"abc\\", \\"cab\\"), (\\"abcd\\", \\"cdab\\"), (\\"abc\\", \\"def\\")]) [\\"YES\\", \\"YES\\", \\"NO\\"] # Example Unit Test def test_example_cases(): input_cases = [(\\"abc\\", \\"cab\\"), (\\"abcd\\", \\"cdab\\"), (\\"abc\\", \\"def\\")] expected_output = [\\"YES\\", \\"YES\\", \\"NO\\"] assert process_test_cases(input_cases) == expected_output def test_same_string(): assert are_equivalent(\\"abc\\", \\"abc\\") == \\"YES\\" def test_different_lengths(): assert are_equivalent(\\"abc\\", \\"abcd\\") == \\"NO\\" def test_simple_rotation(): assert are_equivalent(\\"abc\\", \\"bca\\") == \\"YES\\" assert are_equivalent(\\"abc\\", \\"cab\\") == \\"YES\\" def test_longer_strings(): assert are_equivalent(\\"helloworld\\", \\"oworldhell\\") == \\"YES\\" assert are_equivalent(\\"rotation\\", \\"ationrot\\") == \\"YES\\" def test_no_possible_rotation(): assert are_equivalent(\\"abcdefg\\", \\"gfedcba\\") == \\"NO\\" def test_multiple_test_cases(): input_cases = [(\\"abcde\\", \\"deabc\\"), (\\"xxyz\\", \\"xyzx\\"), (\\"rotation\\", \\"ortionra\\")] expected_output = [\\"YES\\", \\"YES\\", \\"NO\\"] assert process_test_cases(input_cases) == expected_output","solution":"def are_equivalent(s1, s2): Determines if string s1 can be transformed into string s2 using ZLang concatenation and rotation rules. # Check if the strings are of the same length if len(s1) != len(s2): return \\"NO\\" # Concatenate s1 with itself doubled_s1 = s1 + s1 # Check if s2 is a substring of doubled_s1 if s2 in doubled_s1: return \\"YES\\" else: return \\"NO\\" def process_test_cases(test_cases): Processes each test case and generates results. results = [] for s1, s2 in test_cases: results.append(are_equivalent(s1, s2)) return results"},{"question":"def max_overlapping_events(start_times: List[int], end_times: List[int]) -> int: Determines the maximum number of overlapping events at any given time. Arguments: start_times : list of int : List of start times of the events. end_times : list of int : List of end times of the events. Returns: int : Maximum number of overlapping events. Examples: >>> max_overlapping_events([1, 3, 5], [2, 4, 6]) 1 >>> max_overlapping_events([1, 2, 3], [4, 5, 6]) 3 >>> max_overlapping_events([1, 3, 5, 6, 8, 10], [4, 7, 6, 9, 11, 12]) 2 >>> max_overlapping_events([1, 1, 1], [2, 2, 2]) 3","solution":"def max_overlapping_events(start_times, end_times): Determines the maximum number of overlapping events at any given time. Arguments: start_times : list of int : List of start times of the events. end_times : list of int : List of end times of the events. Returns: int : Maximum number of overlapping events. events = [] for start in start_times: events.append((start, 'start')) for end in end_times: events.append((end, 'end')) # Sort events: first by time, second by type ('end' before 'start' if times are equal) events.sort(key=lambda x: (x[0], x[1] == 'start')) current_overlap = 0 max_overlap = 0 for event in events: if event[1] == 'start': current_overlap += 1 max_overlap = max(max_overlap, current_overlap) else: current_overlap -= 1 return max_overlap"},{"question":"def minimum_spanning_tree(n: int, m: int, edge_list: str) -> int: Given an undirected weighted graph with n nodes and m edges, determine the weight of the minimum spanning tree of the graph. If the graph is disconnected, return -1. Parameters: n (int): Number of nodes in the graph. m (int): Number of edges in the graph. edge_list (str): A string where each line contains three integers u, v, and w - representing an edge between nodes u and v with a weight of w. Returns: int: Weight of the minimum spanning tree of the given graph, or -1 if the graph is disconnected. >>> minimum_spanning_tree(4, 5, '1 2 3n1 3 1n2 3 3n3 4 6n2 4 5') 9 >>> minimum_spanning_tree(3, 1, '1 2 4') -1 >>> >>> test_example_1() >>> test_example_2() >>>","solution":"def find(parent, i): if parent[i] == i: return i else: parent[i] = find(parent, parent[i]) return parent[i] def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 def kruskal(n, edges): edges.sort(key=lambda x: x[2]) # Sort edges based on weight parent = list(range(n)) rank = [0] * n mst_weight = 0 mst_edges = 0 for edge in edges: u, v, weight = edge root_u = find(parent, u - 1) root_v = find(parent, v - 1) if root_u != root_v: union(parent, rank, root_u, root_v) mst_weight += weight mst_edges += 1 if mst_edges == n - 1: return mst_weight return -1 if mst_edges < n - 1 else mst_weight def minimum_spanning_tree(n, m, edge_list): edges = [tuple(map(int, edge.split())) for edge in edge_list.split(\\"n\\") if edge.strip()] return kruskal(n, edges)"},{"question":"def is_well_formed(html: str) -> bool: Determine whether a provided HTML-like string is well-formed. Args: html (str): A string containing lowercase alphabetical characters and angle brackets. Returns: bool: True if the string is well-formed, otherwise False. Examples: >>> is_well_formed(\\"<div><p></p></div>\\") True >>> is_well_formed(\\"<div><p></div></p>\\") False >>> is_well_formed(\\"<div><p><a></a></p></div>\\") True >>> is_well_formed(\\"<div><p></a></p></div>\\") False # Unit tests def test_well_formed_1(): assert is_well_formed(\\"<div><p></p></div>\\") == True def test_well_formed_2(): assert is_well_formed(\\"<div><p></div></p>\\") == False def test_well_formed_3(): assert is_well_formed(\\"<div><p><a></a></p></div>\\") == True def test_well_formed_4(): assert is_well_formed(\\"<div><p></a></p></div>\\") == False def test_well_formed_5(): assert is_well_formed(\\"<a><b><c></c></b></a>\\") == True def test_well_formed_6(): assert is_well_formed(\\"<a><b></a></b>\\") == False def test_well_formed_7(): assert is_well_formed(\\"<a>text<b></b></a>\\") == True def test_well_formed_8(): assert is_well_formed(\\"<a><a></a></a>\\") == True def test_well_formed_9(): assert is_well_formed(\\"<a><b><c></c></b><d></d></a>\\") == True def test_well_formed_10(): assert is_well_formed(\\"<a><b></c></b></a>\\") == False","solution":"def is_well_formed(html: str) -> bool: import re tag_pattern = re.compile(r'</?([a-z]+)>') tags = tag_pattern.findall(html) stack = [] for tag in tag_pattern.finditer(html): tag_content = tag.group(0) if tag_content.startswith('</'): if not stack or stack[-1] != tag.group(1): return False stack.pop() else: stack.append(tag.group(1)) return len(stack) == 0"},{"question":"def solve_treasure_hunt(n: int, ranges: List[Tuple[int, int]]) -> List[int]: Find the appropriate answers for the treasure hunt clues. >>> solve_treasure_hunt(3, [(5, 10), (7, 15), (6, 12)]) [5, 7, 6] >>> solve_treasure_hunt(4, [(1, 5), (2, 6), (3, 7), (4, 8)]) [1, 2, 3, 4] pass # Example Unit Tests def test_example_1(): n = 3 ranges = [ (5, 10), (7, 15), (6, 12) ] result = solve_treasure_hunt(n, ranges) assert result == [5, 7, 6] def test_example_2(): n = 4 ranges = [ (1, 5), (2, 6), (3, 7), (4, 8) ] result = solve_treasure_hunt(n, ranges) assert result == [1, 2, 3, 4] def test_non_overlapping_ranges(): n = 3 ranges = [ (10, 20), (21, 30), (31, 40) ] result = solve_treasure_hunt(n, ranges) assert result == [10, 21, 31] def test_overlapping_but_non_conflicting_ranges(): n = 3 ranges = [ (1, 3), (2, 4), (3, 5) ] result = solve_treasure_hunt(n, ranges) assert result == [1, 2, 3] def test_fully_overlapping_ranges(): n = 3 ranges = [ (1, 5), (1, 5), (1, 5) ] result = solve_treasure_hunt(n, ranges) assert result == [1, 2, 3]","solution":"def find_answers(n, ranges): previous_answers = set() answers = [] for l, r in ranges: for number in range(l, r + 1): if number not in previous_answers: previous_answers.add(number) answers.append(number) break return answers # Helper method to parse the input and call the main function def solve_treasure_hunt(n, ranges): return find_answers(n, ranges)"},{"question":"def max_perimeter(arr: List[int]) -> int: Finds the maximum perimeter of a triangle that can be formed with any three sides from the given array. Args: arr (list): A list of unique integers. Returns: int: Maximum perimeter of the triangle or 0 if no valid triangle can be formed. pass # replace this with your implementation # Unit Test def test_max_perimeter(): assert max_perimeter([2, 3, 4, 5, 10]) == 12 assert max_perimeter([1, 1, 1, 1, 1, 1]) == 3 assert max_perimeter([1, 2, 3]) == 0 assert max_perimeter([10, 15, 20, 25]) == 60 assert max_perimeter([5, 10, 15]) == 0 assert max_perimeter([5, 12, 13, 9]) == 34 def test_max_perimeter_edge_cases(): # Test with minimum length array which forms a triangle assert max_perimeter([3, 4, 5]) == 12 # Test with minimum length array which does not form a triangle assert max_perimeter([1, 2, 3]) == 0 # Additional edge case of large values assert max_perimeter([10**6, 10**6 - 1, 10**6 - 2]) == 3 * (10**6 - 1) # Another edge case with elements not forming a triangle assert max_perimeter([100, 200, 300]) == 0","solution":"def max_perimeter(arr): Finds the maximum perimeter of a triangle that can be formed with any three sides from the given array. Args: arr (list): A list of unique integers. Returns: int: Maximum perimeter of the triangle or 0 if no valid triangle can be formed. # Sort the array in non-decreasing order arr.sort() max_perimeter = 0 # Iterate over the sorted array to find the maximum perimeter for i in range(len(arr) - 2): a = arr[i] b = arr[i+1] c = arr[i+2] # Check if a, b, and c can form a triangle if a + b > c: perimeter = a + b + c max_perimeter = max(max_perimeter, perimeter) return max_perimeter"},{"question":"def calculate_total_height_diff(T, test_cases): Calculate the total height difference covered on a journey from the starting tile to the last tile for each test case. Args: T (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): List of test cases, each containing the number of tiles and a list of function numbers. Returns: List[int]: The total height difference for each test case. >>> calculate_total_height_diff(1, [(3, [1, 1, 1])]) [9] >>> calculate_total_height_diff(1, [(4, [2, 2, 2, 2])]) [10] >>> calculate_total_height_diff(1, [(3, [1, 2, 1])]) [9]","solution":"def calculate_total_height_diff(T, test_cases): results = [] for case in test_cases: M, B = case H = [0] * (M + 1) for i in range(1, M + 1): if B[i - 1] == 1: H[i] = i * i elif B[i - 1] == 2: H[i] = H[i - 1] + i results.append(H[M]) return results # Example usage: # T = 3 # test_cases = [(3, [1, 1, 1]), (4, [2, 2, 2, 2]), (3, [1, 2, 1])] # print(calculate_total_height_diff(T, test_cases)) # Output: [9, 10, 9]"},{"question":"def plant_with_highest_avg_growth_rate(T, test_cases): Calculate the plant with the highest average growth rate. Args: T (int): The number of test cases. test_cases (list): A list of dictionaries containing the N (number of plants), M (number of days), and growth_data (list of lists with growth rates). Returns: list: A list of tuples, each containing the 1-based index of the plant with the highest average growth rate and the highest average growth rate rounded to two decimal places. pass def parse_and_calculate(input_text): Parse the input text and return the formatted output. Args: input_text (str): The input containing the number of test cases, and for each test case the number of plants, number of days, and the growth data. Returns: str: The formatted output containing the 1-based index of the plant with the highest average growth rate and the highest average growth rate rounded to two decimal places. >>> input_text = 2 3 3 1 2 3 3 2 1 2 3 1 4 2 5 6 7 8 8 7 6 5 >>> print(parse_and_calculate(input_text)) 2 2.33 1 6.50 >>> input_text = 1 1 3 10 20 30 >>> print(parse_and_calculate(input_text)) 1 20.00 pass","solution":"def plant_with_highest_avg_growth_rate(T, test_cases): results = [] for case in test_cases: N, M, growth_data = case['N'], case['M'], case['growth_data'] # Initialize total growth for each plant total_growth = [0] * N # Accumulate growth data for day in range(M): for plant in range(N): total_growth[plant] += growth_data[day][plant] # Calculate average growth rate and find the plant with the highest average growth rate highest_avg_growth_rate = -1 plant_index = -1 for plant in range(N): avg_growth_rate = total_growth[plant] / M if avg_growth_rate > highest_avg_growth_rate or (avg_growth_rate == highest_avg_growth_rate and plant < plant_index): highest_avg_growth_rate = avg_growth_rate plant_index = plant results.append((plant_index + 1, round(highest_avg_growth_rate, 2))) return results # Sample function for parsing input and returning formatted output def parse_and_calculate(input_text): input_lines = input_text.strip().split('n') T = int(input_lines[0]) test_cases = [] index = 1 for _ in range(T): N, M = map(int, input_lines[index].split()) growth_data = [list(map(int, input_lines[index + 1 + j].split())) for j in range(M)] test_cases.append({'N': N, 'M': M, 'growth_data': growth_data}) index += M + 1 results = plant_with_highest_avg_growth_rate(T, test_cases) output_lines = [] for res in results: output_lines.append(f\\"{res[0]} {res[1]:.2f}\\") return 'n'.join(output_lines)"},{"question":"def min_operations_to_palindrome(s: str) -> int: Returns the minimum number of operations required to make the string a palindrome. >>> min_operations_to_palindrome(\\"abca\\") 1 >>> min_operations_to_palindrome(\\"racecar\\") 0 >>> min_operations_to_palindrome(\\"abcdef\\") 5 def test_min_operations_to_palindrome_example1(): assert min_operations_to_palindrome(\\"abca\\") == 1 def test_min_operations_to_palindrome_example2(): assert min_operations_to_palindrome(\\"racecar\\") == 0 def test_min_operations_to_palindrome_example3(): assert min_operations_to_palindrome(\\"abcdef\\") == 5 def test_min_operations_to_palindrome_single_character(): assert min_operations_to_palindrome(\\"a\\") == 0 def test_min_operations_to_palindrome_already_palindrome(): assert min_operations_to_palindrome(\\"aa\\") == 0 assert min_operations_to_palindrome(\\"aaa\\") == 0 def test_min_operations_to_palindrome_no_possible_palindrome(): assert min_operations_to_palindrome(\\"abc\\") == 2 def test_min_operations_to_palindrome_non_repeating(): assert min_operations_to_palindrome(\\"abcdefgh\\") == 7","solution":"def min_operations_to_palindrome(s): Returns the minimum number of operations required to make the string a palindrome. def lcs(x , y): m = len(x) n = len(y) L = [[None]*(n+1) for i in range(m+1)] for i in range(m+1): for j in range(n+1): if i == 0 or j == 0 : L[i][j] = 0 elif x[i-1] == y[j-1]: L[i][j] = L[i-1][j-1] + 1 else: L[i][j] = max(L[i-1][j] , L[i][j-1]) return L[m][n] rev_s = s[::-1] lcs_length = lcs(s, rev_s) return len(s) - lcs_length"},{"question":"class MovieRentalService: def __init__(self, available_movies): self.available_movies = available_movies self.user_rentals = {} def rent(self, user, movie, genre): Tracks that a user has rented a specific movie of a given genre. If the user has already rented a movie, this operation should not allow them to rent another one. pass def return_movie(self, user, movie): Updates that the user has returned the movie they previously rented. pass def recommend(self, user, genre): Recommends a random movie (that is available) from the specified genre to the user. If the user currently has rented a movie or if there are no available movies in the specified genre, return \\"No recommendation available\\". pass def execute_operations(operations, available_movies): Execute a list of operations on the movie rental service. Args: operations: A list of operations to be executed representing the different API calls. available_movies: A dictionary where the keys are genres and the values are lists of movies available in those genres. Returns: List of results for recommend operations. >>> execute_operations([[\\"rent\\", \\"Alice\\", \\"MovieA\\", \\"Comedy\\"], [\\"recommend\\", \\"Alice\\", \\"Action\\"]], {\\"Comedy\\": [\\"MovieA\\", \\"MovieC\\"], \\"Action\\": [\\"MovieB\\", \\"MovieD\\"]}) [\\"No recommendation available\\"] >>> execute_operations([[\\"recommend\\", \\"Bob\\", \\"Action\\"]], {\\"Comedy\\": [\\"MovieA\\", \\"MovieC\\"], \\"Action\\": [\\"MovieB\\", \\"MovieD\\"]}) [\\"MovieB\\"] service = MovieRentalService(available_movies) output = [] for operation in operations: if operation[0] == \\"rent\\": service.rent(operation[1], operation[2], operation[3]) elif operation[0] == \\"return\\": service.return_movie(operation[1], operation[2]) elif operation[0] == \\"recommend\\": response = service.recommend(operation[1], operation[2]) output.append(response) return output","solution":"import random class MovieRentalService: def __init__(self, available_movies): self.available_movies = available_movies self.user_rentals = {} def rent(self, user, movie, genre): if user in self.user_rentals: return if movie in self.available_movies.get(genre, []): self.user_rentals[user] = (movie, genre) self.available_movies[genre].remove(movie) def return_movie(self, user, movie): rental = self.user_rentals.pop(user, None) if rental: rented_movie, genre = rental self.available_movies[genre].append(rented_movie) def recommend(self, user, genre): if user in self.user_rentals: return \\"No recommendation available\\" available_genre_movies = self.available_movies.get(genre, []) if not available_genre_movies: return \\"No recommendation available\\" return random.choice(available_genre_movies) def execute_operations(operations, available_movies): service = MovieRentalService(available_movies) output = [] for operation in operations: if operation[0] == \\"rent\\": service.rent(operation[1], operation[2], operation[3]) elif operation[0] == \\"return\\": service.return_movie(operation[1], operation[2]) elif operation[0] == \\"recommend\\": response = service.recommend(operation[1], operation[2]) output.append(response) return output"},{"question":"def max_spell_power(N: int, spell_powers: List[int], M: int) -> Union[int, str]: Determine the maximum power level of a combined spell that does not exceed the given power limit. Args: N (int): The number of spells spell_powers (List[int]): A list of integers representing the power levels of the spells M (int): The maximum power limit for a combined spell Returns: int or str: The maximum possible power level of a combined spell that does not exceed the power limit M, or \\"No valid spell\\" if no valid spell can be formed. Examples: >>> max_spell_power(5, [10, 20, 30, 40, 50], 60) 60 >>> max_spell_power(3, [10, 20, 5], 15) 15 >>> max_spell_power(4, [25, 30, 35, 40], 20) \\"No valid spell\\"","solution":"from itertools import combinations def max_spell_power(N, spell_powers, M): max_power = 0 for r in range(1, N+1): for combo in combinations(spell_powers, r): combo_power = sum(combo) if combo_power <= M and combo_power > max_power: max_power = combo_power return max_power if max_power > 0 else \\"No valid spell\\""},{"question":"def calculate_final_grades(T: int, student_grades: List[List[int]]) -> List[Union[int, str]]: Calculate the final grades for each student, ignoring the subjects with missing grades. If no valid grades are present, output \\"No valid grades\\". Args: T : int : number of students student_grades : List[List[int]] : list of student grades where each sublist contains the number of subjects followed by grades for those subjects >>> calculate_final_grades(4, [[3, 70, 80, 90], [4, 85, 90, -1, 80], [2, -1, -1], [5, 50, 60, 70, 80, 90]]) [80, 85, \\"No valid grades\\", 70] >>> calculate_final_grades(2, [[3, -1, -1, -1], [4, -1, -1, -1, -1]]) [\\"No valid grades\\", \\"No valid grades\\"] >>> calculate_final_grades(3, [[4, 0, 50, -1, 100], [4, -1, 30, -1, -1], [3, 80, 90, 100]]) [50, 30, 90]","solution":"def calculate_final_grades(T, student_grades): results = [] for i in range(T): grades = student_grades[i][1:] valid_grades = [grade for grade in grades if grade != -1] if valid_grades: average_grade = round(sum(valid_grades) / len(valid_grades)) results.append(average_grade) else: results.append(\\"No valid grades\\") return results"},{"question":"def max_coin_value(n: int, m: int, k: int, grid: List[List[int]]) -> int: Find the maximum coin value Alice can achieve on her path, where the path length is at most k. Args: n : int : number of rows in the grid m : int : number of columns in the grid k : int : maximum number of coins Alice can collect grid : List[List[int]] : the grid containing coin values Returns: int : the maximum coin value Alice can achieve Example: >>> max_coin_value(4, 4, 5, [ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16] ... ]) 16 >>> max_coin_value(1, 5, 3, [[3, 8, 2, 6, 9]]) 9","solution":"def max_coin_value(n, m, k, grid): max_value = float('-inf') for i in range(n): for j in range(m): if grid[i][j] > max_value: max_value = grid[i][j] return max_value # Test example input n, m, k = 4, 4, 5 grid = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] print(max_coin_value(n, m, k, grid)) # Should output 16"},{"question":"def derangement_count(s: str) -> int: Given a string \`s\`, compute the number of derangements. A derangement of a string is a permutation where no character appears in its original position. Examples: >>> derangement_count(\\"A\\") 0 >>> derangement_count(\\"AB\\") 1 >>> derangement_count(\\"ABCDE\\") 44 >>> derangement_count(\\"ABCDEFG\\") 1854 >>> derangement_count(\\"ABCDEFGHIJ\\") 1334961","solution":"from math import factorial def count_derangements(n): Calculate the number of derangements for a sequence of length n using the formula: !n = (n-1) * (!(n-1) + !(n-2)) if n == 0: return 1 elif n == 1: return 0 elif n == 2: return 1 derangements = [0] * (n + 1) derangements[0] = 1 derangements[1] = 0 derangements[2] = 1 for i in range(3, n + 1): derangements[i] = (i - 1) * (derangements[i - 1] + derangements[i - 2]) return derangements[n] def derangement_count(s): Given a string \`s\`, compute the number of derangements. return count_derangements(len(s))"},{"question":"def is_subsequence(s: str, num: str) -> bool: it = iter(s) return all(char in it for char in num) def smallest_missing_integer(input_str: str) -> str: Find the smallest positive integer that is not a subsequence of the given input string. :param input_str: The input string consisting of digits (0-9) :return: The smallest positive integer that is not a subsequence of input_str >>> smallest_missing_integer(\\"0123456789\\") '10' >>> smallest_missing_integer(\\"111\\") '2' >>> smallest_missing_integer(\\"2210100\\") '3' >>> smallest_missing_integer(\\"\\") '1' pass def process_test_cases(test_cases: List[str]) -> List[str]: Process a list of test cases to find the smallest missing positive integer for each. :param test_cases: List of input strings each consisting of digits (0-9) :return: List of results for each test case pass def find_smallest_missing_positive_integer(test_case_count: int, test_cases: List[str]) -> List[str]: Find the smallest missing positive integer for each of the provided test cases. :param test_case_count: The number of test cases :param test_cases: List of input strings each consisting of digits (0-9) :return: List of results for each test case >>> find_smallest_missing_positive_integer(1, [\\"0123456789\\"]) ['10'] >>> find_smallest_missing_positive_integer(1, [\\"111\\"]) ['2'] >>> find_smallest_missing_positive_integer(1, [\\"2210100\\"]) ['3'] >>> find_smallest_missing_positive_integer(1, [\\"123456789\\"]) ['10'] >>> find_smallest_missing_positive_integer(1, [\\"\\"]) ['1'] >>> find_smallest_missing_positive_integer(1, [\\"827364958273\\"]) ['1'] pass","solution":"def is_subsequence(s, num): it = iter(s) return all(char in it for char in num) def smallest_missing_integer(input_str): i = 1 while True: if not is_subsequence(input_str, str(i)): return str(i) i += 1 def process_test_cases(test_cases): return [smallest_missing_integer(tc) for tc in test_cases] def find_smallest_missing_positive_integer(test_case_count, test_cases): results = process_test_cases(test_cases) return results"},{"question":"def calculate_worked_hours(log_records): Calculates the number of hours and minutes worked based on the log-in and log-out times. Parameters: log_records (list): A list of strings where each string is in the format \\"HH:MM-HH:MM\\". Returns: list: A list of strings where each string denotes the total hours and minutes worked. pass # Test cases def test_calculate_worked_hours(): assert calculate_worked_hours([\\"09:30-17:45\\"]) == [\\"8 hours and 15 minutes\\"] assert calculate_worked_hours([\\"10:15-14:30\\"]) == [\\"4 hours and 15 minutes\\"] assert calculate_worked_hours([\\"08:00-18:00\\"]) == [\\"10 hours and 0 minutes\\"] assert calculate_worked_hours([\\"00:00-00:00\\"]) == [\\"0 hours and 0 minutes\\"] assert calculate_worked_hours([ \\"09:00-12:00\\", \\"13:00-17:00\\", \\"08:30-15:45\\", \\"11:00-18:30\\" ]) == [ \\"3 hours and 0 minutes\\", \\"4 hours and 0 minutes\\", \\"7 hours and 15 minutes\\", \\"7 hours and 30 minutes\\" ]","solution":"def calculate_worked_hours(log_records): Calculates the number of hours and minutes worked based on the log-in and log-out times. Parameters: log_records (list): A list of strings where each string is in the format \\"HH:MM-HH:MM\\". Returns: list: A list of strings where each string denotes the total hours and minutes worked. results = [] for record in log_records: login_time, logout_time = record.split('-') login_hour, login_minute = map(int, login_time.split(':')) logout_hour, logout_minute = map(int, logout_time.split(':')) # Calculate the total minutes worked total_login_minutes = login_hour * 60 + login_minute total_logout_minutes = logout_hour * 60 + logout_minute worked_minutes = total_logout_minutes - total_login_minutes # Calculate hours and minutes worked worked_hours = worked_minutes // 60 remaining_minutes = worked_minutes % 60 results.append(f\\"{worked_hours} hours and {remaining_minutes} minutes\\") return results"},{"question":"from collections import deque from typing import Tuple def knight_moves(start: Tuple[int, int], end: Tuple[int, int]) -> int: Returns the minimum number of moves a knight needs to get from start to end position on an 8x8 chessboard. If the knight cannot reach the destination, returns -1. Parameters: start (Tuple[int, int]): The starting position (rs, cs) on the chessboard. end (Tuple[int, int]): The ending position (re, ce) on the chessboard. Returns: int: The minimum number of moves to reach the end position, or -1 if it's not possible. Examples: >>> knight_moves((1, 1), (8, 8)) 6 >>> knight_moves((1, 1), (1, 1)) 0 >>> knight_moves((2, 3), (8, 8)) 5 pass def test_knight_moves(): assert knight_moves((1, 1), (8, 8)) == 6 assert knight_moves((1, 1), (1, 1)) == 0 assert knight_moves((2, 3), (8, 8)) == 5 assert knight_moves((4, 4), (4, 4)) == 0 assert knight_moves((3, 3), (4, 3)) == 3 assert knight_moves((1, 8), (8, 1)) == 6 def test_knight_moves_impossible(): assert knight_moves((8, 8), (10, 10)) == -1 if __name__ == \\"__main__\\": test_knight_moves() test_knight_moves_impossible() print(\\"All tests passed.\\")","solution":"from collections import deque def knight_moves(start, end): Returns the minimum number of moves a knight needs to get from start to end position on a 8x8 chessboard. If the knight cannot reach the destination, returns -1. directions = [ (2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2) ] def is_valid(x, y): return 1 <= x <= 8 and 1 <= y <= 8 if start == end: return 0 queue = deque([(*start, 0)]) visited = set() visited.add(start) while queue: x, y, dist = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if (nx, ny) == end: return dist + 1 if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"from typing import List, Tuple def shortest_path_length(T: int, test_cases: List[Tuple[int, int, List[str]]]) -> List[int]: Determines the shortest path from the start cell (S) to the end cell (E) in a given maze. Args: T: Number of test cases test_cases: A list of tuples where each tuple consists of: - n: Number of rows in the maze - m: Number of columns in the maze - maze: A list of strings representing the rows of the maze Returns: A list of integers where each integer represents the length of the shortest path from 'S' to 'E' for each corresponding test case. If no such path exists, the corresponding integer is -1. Example: >>> shortest_path_length(2, [ (5, 5, [ 'S.#..', '..#..', '..#..', '..#E.', '.....' ]), (5, 5, [ 'S...#', '.', '.....', '....#', '..E' ]) ]) [8, 7] >>> shortest_path_length(1, [ (5, 5, [ 'S...#', '.', '.....', '....#', '..E' ]) ]) [7]","solution":"from collections import deque def shortest_path_length(T, test_cases): directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] result = [] for t in range(T): n, m, maze = test_cases[t] start = None end = None # Locate 'S' and 'E' for i in range(n): for j in range(m): if maze[i][j] == 'S': start = (i, j) if maze[i][j] == 'E': end = (i, j) if not start or not end: result.append(-1) continue # BFS to find the shortest path queue = deque([(start, 0)]) visited = set() visited.add(start) found = False while queue: (x, y), dist = queue.popleft() if (x, y) == end: result.append(dist) found = True break for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and maze[nx][ny] != '#': visited.add((nx, ny)) queue.append(((nx, ny), dist + 1)) if not found: result.append(-1) return result"},{"question":"from typing import List def has_pair_with_sum(arr: List[int], k: int) -> str: Check if there is a pair of distinct indices in the array whose values add up to k. Return 'YES' if such a pair exists, otherwise return 'NO'. >>> has_pair_with_sum([1, 2, 3, 4], 5) == \\"YES\\" >>> has_pair_with_sum([1, 2, 3, 4], 8) == \\"NO\\" >>> has_pair_with_sum([10, 20, 10, 40, 50], 60) == \\"YES\\" >>> has_pair_with_sum([-1, -2, -3, -4], -8) == \\"NO\\" >>> has_pair_with_sum([-10, -20, -10, -40, 50], 10) == \\"YES\\"","solution":"from typing import List def has_pair_with_sum(arr: List[int], k: int) -> str: seen = set() for number in arr: if k - number in seen: return \\"YES\\" seen.add(number) return \\"NO\\""},{"question":"def min_cost_to_paint_houses(costs): Calculate the minimum cost to paint all houses such that no two adjacent houses have the same color. :param costs: List of tuples, where each tuple contains three integers (r_i, b_i, g_i) representing the cost of painting the i-th house in Red, Blue, and Green, respectively. :return: Integer representing the minimum cost. >>> min_cost_to_paint_houses([(17, 2, 17), (16, 16, 5), (14, 3, 19)]) 10 >>> min_cost_to_paint_houses([(10, 15, 20)]) 10 >>> min_cost_to_paint_houses([(1, 2, 3), (1, 2, 3)]) 3 >>> min_cost_to_paint_houses([(10, 10, 10), (10, 10, 10), (10, 10, 10)]) 30 >>> min_cost_to_paint_houses([(1, 1000, 1000), (1000, 1, 1000), (1000, 1000, 1)]) 3","solution":"def min_cost_to_paint_houses(costs): Calculate the minimum cost to paint all houses such that no two adjacent houses have the same color. :param costs: List of tuples, where each tuple contains three integers (r_i, b_i, g_i) representing the cost of painting the i-th house in Red, Blue, and Green, respectively. :return: Integer representing the minimum cost. if not costs: return 0 N = len(costs) # Initialize the DP table with the first house costs dp = [costs[0]] for i in range(1, N): current_costs = costs[i] prev_costs = dp[i-1] # Calculate the minimal costs for each color current_r_cost = current_costs[0] + min(prev_costs[1], prev_costs[2]) current_b_cost = current_costs[1] + min(prev_costs[0], prev_costs[2]) current_g_cost = current_costs[2] + min(prev_costs[0], prev_costs[1]) # Append the current costs to DP table dp.append((current_r_cost, current_b_cost, current_g_cost)) # The minimum cost to paint all houses return min(dp[-1])"},{"question":"def is_balanced(s: str) -> bool: Determines if a string of parentheses is balanced. Args: s (str): A string consisting of characters '(' and ')'. Returns: bool: True if the string is balanced, otherwise False. >>> is_balanced(\\"(()())\\") True >>> is_balanced(\\"((())\\") False","solution":"def is_balanced(s: str) -> bool: Determines if a string of parentheses is balanced. Args: s (str): A string consisting of characters '(' and ')'. Returns: bool: True if the string is balanced, otherwise False. # This counter will keep track of the balance state balance = 0 for char in s: if char == '(': balance += 1 elif char == ')': balance -= 1 # If balance goes negative, we have more closing parentheses if balance < 0: return False # If balance is not zero, then it's not balanced return balance == 0 # Example usage: # print(is_balanced(\\"(()())\\")) # Should output: True # print(is_balanced(\\"((())\\")) # Should output: False"},{"question":"from typing import List def longest_subarray(nums: List[int], k: int) -> int: Finds the length of the longest subarray where the absolute difference between any two elements is at most \`k\`. >>> longest_subarray([10, 1, 2, 4, 7, 2], 5) 4 >>> longest_subarray([4, 8, 5, 1, 7, 9], 6) 3 >>> longest_subarray([1, 1, 1, 1], 0) 4","solution":"from typing import List def longest_subarray(nums: List[int], k: int) -> int: Finds the length of the longest subarray where the absolute difference between any two elements is at most \`k\`. from collections import deque min_deque = deque() max_deque = deque() left = 0 result = 0 for right in range(len(nums)): while min_deque and nums[min_deque[-1]] >= nums[right]: min_deque.pop() while max_deque and nums[max_deque[-1]] <= nums[right]: max_deque.pop() min_deque.append(right) max_deque.append(right) while nums[max_deque[0]] - nums[min_deque[0]] > k: left += 1 if min_deque[0] < left: min_deque.popleft() if max_deque[0] < left: max_deque.popleft() result = max(result, right - left + 1) return result"},{"question":"def min_abs_difference(n: int, cards: List[int]) -> int: Determines the minimal absolute difference between the sums of two sub-collections of cards. >>> min_abs_difference(4, [7, 6, 2, 3]) 0 >>> min_abs_difference(5, [1, 2, 3, 4, 5]) 1","solution":"def min_abs_difference(n, cards): total_sum = sum(cards) dp = [False] * (total_sum // 2 + 1) dp[0] = True for card in cards: for j in range(total_sum // 2, card - 1, -1): dp[j] = dp[j] or dp[j - card] for j in range(total_sum // 2, -1, -1): if dp[j]: return total_sum - 2 * j # Example input n = 4 cards = [7, 6, 2, 3] print(min_abs_difference(n, cards)) # Output should be 0"},{"question":"def max_profit(prices): Returns the maximum profit that can be achieved from the given list of prices, where we can only buy and sell the stock once, and must buy before selling. If no profit can be achieved, returns 0. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 >>> max_profit([2, 4, 1, 7, 6, 5, 8]) 7 >>> max_profit([5]) 0 >>> max_profit([7, 2]) 0 >>> max_profit([2, 7]) 5 >>> max_profit([3, 8, 2, 5, 7, 1, 5]) 5 >>> max_profit([5, 5, 5, 5, 5]) 0 >>> max_profit([1, 2, 3, 4, 5, 6, 7, 8, 9]) 8","solution":"def max_profit(prices): Returns the maximum profit that can be achieved from the given list of prices, where we can only buy and sell the stock once, and must buy before selling. If no profit can be achieved, returns 0. if not prices or len(prices) < 2: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price current_profit = price - min_price if current_profit > max_profit: max_profit = current_profit return max_profit"},{"question":"def minimum_distance_between_warehouses(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Calculate the minimum distance between any two warehouses for T test cases. T : int - number of test cases test_cases : List of tuples where each tuple contains an integer N (number of warehouses) and a list of integers indicating the positions of the warehouses. Returns a list of minimum distances for each test case. Example: >>> minimum_distance_between_warehouses(2, [(3, [1, 3, 7]), (4, [5, 8, 12, 17])]) [2, 3] from typing import List, Tuple def test_example_cases(): assert minimum_distance_between_warehouses(2, [(3, [1, 3, 7]), (4, [5, 8, 12, 17])]) == [2, 3] def test_single_difference(): assert minimum_distance_between_warehouses(1, [(2, [0, 1000000000])]) == [1000000000] def test_negative_and_positive_positions(): assert minimum_distance_between_warehouses(1, [(3, [-1000000000, 0, 1000000000])]) == [1000000000] def test_repeated_positions(): assert minimum_distance_between_warehouses(1, [(4, [5, 5, 5, 5])]) == [0] def test_large_number_of_positions(): assert minimum_distance_between_warehouses(1, [(5, [1, 2, 3, 4, 5])]) == [1] def test_unsorted_positions(): assert minimum_distance_between_warehouses(1, [(5, [10, 1, 3, 7, 2])]) == [1]","solution":"def minimum_distance_between_warehouses(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] positions = test_cases[i][1] positions.sort() min_distance = float('inf') for j in range(1, N): min_distance = min(min_distance, positions[j] - positions[j - 1]) results.append(min_distance) return results"},{"question":"from datetime import datetime from typing import List, Tuple def can_accommodate_vehicles(n_spots: int, vehicles: List[Tuple[str, str]]) -> bool: Determine if all vehicles can park without conflict given the number of spots and their arrival and departure times. Args: n_spots (int): The number of parking spots available. vehicles (List[Tuple[str, str]]): A list of tuples where each tuple contains two strings: the arrival and departure times in \\"HH:MM\\" format. Returns: bool: True if all vehicles can be accommodated, otherwise False. pass def process_input(input_data: str) -> List[str]: Process input data and determine if parking is possible for each dataset. Args: input_data (str): Multiline string input representing parking lot configurations. Returns: List[str]: A list of strings, \\"Possible\\" or \\"Not possible\\", for each dataset. pass import pytest def test_can_accommodate_all_vehicles_possible(): assert can_accommodate_vehicles(2, [[\\"06:30\\", \\"07:00\\"], [\\"07:00\\", \\"07:30\\"], [\\"07:30\\", \\"08:00\\"]]) == True def test_can_accommodate_all_vehicles_not_possible(): assert can_accommodate_vehicles(1, [[\\"09:00\\", \\"10:00\\"], [\\"09:30\\", \\"10:30\\"]]) == False def test_process_input_all_possible(): input_data = '2n3n06:30 07:00n07:00 07:30n07:30 08:00n1n2n09:00 10:00n10:00 11:00n0n' expected_output = [\\"Possible\\", \\"Possible\\"] assert process_input(input_data) == expected_output def test_process_input_one_not_possible(): input_data = '1n2n09:00 10:00n10:00 11:00n1n2n09:00 10:00n09:30 10:30n0n' expected_output = [\\"Possible\\", \\"Not possible\\"] assert process_input(input_data) == expected_output","solution":"from datetime import datetime def can_accommodate_vehicles(n_spots, vehicles): # Create a list to track usage of each parking spot parking_spots = [None] * n_spots for vehicle in vehicles: arrival, departure = vehicle arrival = datetime.strptime(arrival, \\"%H:%M\\") departure = datetime.strptime(departure, \\"%H:%M\\") # Find the first available spot available_spot = next((i for i, spot in enumerate(parking_spots) if spot is None or spot <= arrival), None) if available_spot is None: return False else: parking_spots[available_spot] = departure return True def process_input(input_data): input_lines = input_data.strip().split('n') results = [] i = 0 while i < len(input_lines): s = int(input_lines[i].strip()) if s == 0: break n = int(input_lines[i + 1].strip()) vehicles = [line.strip().split() for line in input_lines[i + 2:i + 2 + n]] if can_accommodate_vehicles(s, vehicles): results.append(\\"Possible\\") else: results.append(\\"Not possible\\") i += 2 + n return results"},{"question":"def max_path_sum(R: int, C: int, grid: List[List[int]]) -> int: Function to determine the maximum sum path from top-left to bottom-right in the given grid. Parameters: R (int): number of rows. C (int): number of columns. grid (list of list of ints): The grid containing the integer values. Returns: int: The maximum sum path value. Example: >>> R = 3 >>> C = 3 >>> grid = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> max_path_sum(R, C, grid) 29 >>> R = 2 >>> C = 2 >>> grid = [ ... [-1, -2], ... [-3, -4] ... ] >>> max_path_sum(R, C, grid) -7","solution":"def max_path_sum(R, C, grid): Function to determine the maximum sum path from top-left to bottom-right in the given grid. Parameters: R (int): number of rows. C (int): number of columns. grid (list of list of ints): The grid containing the integer values. Returns: int: The maximum sum path value. # Create a DP table to store the maximum path sum for each cell dp = [[0] * C for _ in range(R)] # Initialize the starting point dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for j in range(1, C): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill the first column (can only come from above) for i in range(1, R): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, R): for j in range(1, C): dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] # The bottom-right corner will have the maximum path sum return dp[R - 1][C - 1]"},{"question":"def guess_hidden_number(interact): This function guesses the hidden integer \`x\` by making a series of queries. The \`interact\` parameter is a function that takes a bitmask and returns the bitwise AND result with the hidden number. def test_guess_hidden_number_case1(): def interact(bitmask): hidden_number = 10 # binary 1010 return bitmask & hidden_number assert guess_hidden_number(interact) == 10 def test_guess_hidden_number_case2(): def interact(bitmask): hidden_number = 0 # binary 0000 return bitmask & hidden_number assert guess_hidden_number(interact) == 0 def test_guess_hidden_number_case3(): def interact(bitmask): hidden_number = (1 << 30) - 1 # binary 111...111 (30 ones) return bitmask & hidden_number assert guess_hidden_number(interact) == (1 << 30) - 1 def test_guess_hidden_number_case4(): def interact(bitmask): hidden_number = 12345678 # some arbitrary number return bitmask & hidden_number assert guess_hidden_number(interact) == 12345678 def test_guess_hidden_number_case5(): def interact(bitmask): hidden_number = 1024 # binary 10000000000 return bitmask & hidden_number assert guess_hidden_number(interact) == 1024","solution":"def guess_hidden_number(interact): This function guesses the hidden integer \`x\` by making a series of queries. The \`interact\` parameter is a function that takes a bitmask and returns the bitwise AND result with the hidden number. x = 0 for i in range(30): m = 1 << i response = interact(m) if response != 0: x |= m return x"},{"question":"def contains_nearby_duplicate(nums, k): Determines if there are two distinct indices i and j in the array such that nums[i] == nums[j] and the absolute difference between i and j is at most k. Parameters: nums (List[int]): The list of integers. k (int): The maximum allowed difference between duplicate indices. Returns: str: \\"Yes\\" if there are such indices, otherwise \\"No\\". >>> contains_nearby_duplicate([1, 2, 3, 1, 2, 3], 3) \\"Yes\\" >>> contains_nearby_duplicate([1, 2, 3, 1, 2, 3], 2) \\"No\\"","solution":"def contains_nearby_duplicate(nums, k): Determines if there are two distinct indices i and j in the array such that nums[i] == nums[j] and the absolute difference between i and j is at most k. index_dict = {} for i, num in enumerate(nums): if num in index_dict and i - index_dict[num] <= k: return \\"Yes\\" index_dict[num] = i return \\"No\\""},{"question":"def min_jumps_on_circular_track(n: int, a: int, b: int) -> int: Calculate the minimum number of jumps required for a frog to reach from point a to point b on a circular track. Parameters: n (int): Number of points on the circular track. a (int): Starting point on the track. b (int): Ending point on the track. Returns: int: Minimum number of jumps required. Examples: >>> min_jumps_on_circular_track(6, 2, 5) 3 >>> min_jumps_on_circular_track(10, 7, 3) 4","solution":"def min_jumps_on_circular_track(n, a, b): Calculate the minimum number of jumps required for a frog to reach from point a to point b on a circular track. Parameters: n (int): Number of points on the circular track. a (int): Starting point on the track. b (int): Ending point on the track. Returns: int: Minimum number of jumps required. # Calculate clockwise and counter-clockwise distances clockwise_distance = (b - a) % n counter_clockwise_distance = (a - b) % n # Minimum of both distances will be the answer return min(clockwise_distance, counter_clockwise_distance)"},{"question":"def longest_decreasing_subsequence(A: List[int]) -> int: Returns the length of the longest subsequence of strictly decreasing elements in the array A. >>> longest_decreasing_subsequence([5, 4, 3, 2, 1]) 5 >>> longest_decreasing_subsequence([1, 2, 3, 4, 5]) 1 pass def longest_decreasing_subsequence_for_cases(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Process multiple test cases and return the results in a list. Each test case contains an integer N and an array A of size N. >>> longest_decreasing_subsequence_for_cases([(5, [5, 4, 3, 2, 1]), (5, [1, 2, 3, 4, 5])]) [5, 1] pass","solution":"def longest_decreasing_subsequence(A): Returns the length of the longest subsequence of strictly decreasing elements in the array A. n = len(A) if n == 0: return 0 # dp array to store the length of the longest decreasing subsequence ending at each index dp = [1] * n for i in range(1, n): for j in range(i): if A[i] < A[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) def longest_decreasing_subsequence_for_cases(test_cases): Process multiple test cases and return the results in a list. Each test case contains an integer N and an array A of size N. results = [] for case in test_cases: N, A = case results.append(longest_decreasing_subsequence(A)) return results"},{"question":"import heapq from typing import List, Tuple, Union class MedianFinder: def __init__(self): self.min_heap = [] self.max_heap = [] def add(self, num: int) -> None: Add an integer to the data structure. pass def remove(self, num: int) -> None: Remove an integer from the data structure. It is guaranteed that the integer x is present in the structure when this operation is performed. pass def find_median(self) -> float: Find the median of the current integers in the data structure. If there are an even number of integers, the median is the average of the two middle elements. pass def process_operations(operations: List[Tuple[int, Union[int, None]]]) -> List[float]: Process a list of operations on the data structure and return the result for each median query. Args: operations (List[Tuple[int, Union[int, None]]]): The list of operations to be performed. Returns: List[float]: The result of each median query. >>> process_operations([(1, 10), (3,)]) [10] >>> process_operations([(1, 10), (1, 4), (3,)]) [7.0] >>> process_operations([(1, 10), (1, 4), (1, 5), (3,), (2, 4), (3,)]) [5, 7.5] >>> process_operations([(1, 10), (1, 4), (3,), (1, 5), (3,), (2, 4), (3,)]) [7.0, 5, 7.5] >>> process_operations([]) [] mf = MedianFinder() result = [] for op in operations: if op[0] == 1: mf.add(op[1]) elif op[0] == 2: mf.remove(op[1]) elif op[0] == 3: result.append(mf.find_median()) return result","solution":"import heapq class MedianFinder: def __init__(self): self.min_heap = [] self.max_heap = [] def add(self, num: int) -> None: heapq.heappush(self.max_heap, -num) heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap)) if len(self.min_heap) > len(self.max_heap) + 1: heapq.heappush(self.max_heap, -heapq.heappop(self.min_heap)) def remove(self, num: int) -> None: if num > self.find_median(): self.min_heap.remove(num) heapq.heapify(self.min_heap) else: self.max_heap.remove(-num) heapq.heapify(self.max_heap) # Rebalance the heaps if len(self.min_heap) > len(self.max_heap) + 1: heapq.heappush(self.max_heap, -heapq.heappop(self.min_heap)) elif len(self.max_heap) > len(self.min_heap): heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap)) def find_median(self) -> float: if len(self.min_heap) > len(self.max_heap): return self.min_heap[0] else: return (-self.max_heap[0] + self.min_heap[0]) / 2 def process_operations(operations): mf = MedianFinder() result = [] for op in operations: if op[0] == 1: mf.add(op[1]) elif op[0] == 2: mf.remove(op[1]) elif op[0] == 3: result.append(mf.find_median()) return result"},{"question":"def min_coins(n: int, m: int, v: int, coin_values: List[int], coin_types: List[int]) -> int: Determine the minimum number of coins Alice needs to display the total value v or determine if it is not possible. >>> min_coins(7, 3, 20, [5, 10, 15, 5, 10, 20, 5], [1, 2, 3, 1, 2, 3, 1]) 3 >>> min_coins(5, 2, 12, [1, 2, 3, 4, 5], [1, 1, 2, 2, 2]) -1 from typing import List import itertools def test_example_1(): n = 7 m = 3 v = 20 coin_values = [5, 10, 15, 5, 10, 20, 5] coin_types = [1, 2, 3, 1, 2, 3, 1] assert min_coins(n, m, v, coin_values, coin_types) == 3 def test_example_2(): n = 5 m = 2 v = 12 coin_values = [1, 2, 3, 4, 5] coin_types = [1, 1, 2, 2, 2] assert min_coins(n, m, v, coin_values, coin_types) == -1 def test_minimal_input(): n = 1 m = 1 v = 1 coin_values = [1] coin_types = [1] assert min_coins(n, m, v, coin_values, coin_types) == 1 def test_insufficient_types(): n = 5 m = 3 v = 10 coin_values = [1, 2, 3, 4, 5] coin_types = [1, 1, 1, 2, 2] assert min_coins(n, m, v, coin_values, coin_types) == -1 def test_exact_value(): n = 4 m = 2 v = 7 coin_values = [1, 2, 4, 5] coin_types = [1, 1, 2, 2] assert min_coins(n, m, v, coin_values, coin_types) == 2 def test_large_input(): n = 10 m = 5 v = 30 coin_values = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] coin_types = [1, 2, 3, 4, 5, 1, 2, 3, 4, 5] assert min_coins(n, m, v, coin_values, coin_types) == 5","solution":"def min_coins(n, m, v, coin_values, coin_types): from itertools import combinations # Group coins by their type coins_by_type = {} for value, coin_type in zip(coin_values, coin_types): if coin_type not in coins_by_type: coins_by_type[coin_type] = [] coins_by_type[coin_type].append(value) # If there are not enough types available, it's impossible if len(coins_by_type) < m: return -1 # Generate all combinations by picking at least one coin from each type all_combinations = [[]] for type_coins in coins_by_type.values(): new_combinations = [] for comb in all_combinations: for coin in type_coins: new_combinations.append(comb + [coin]) all_combinations = new_combinations min_coins = float('inf') # Check all combinations to see if we can sum up to at least v for comb in all_combinations: if sum(comb) >= v: min_coins = min(min_coins, len(comb)) return min_coins if min_coins != float('inf') else -1"},{"question":"def longest_subsegment(n: int, k: int, s: str) -> int: Calculate the maximal value of f(s) after no more than k changes of characters. >>> longest_subsegment(6, 1, 'aabbab') 4 >>> longest_subsegment(8, 2, 'abababab') 5","solution":"def longest_subsegment(n, k, s): def max_segment_length(char): left = 0 max_len = 0 changes = 0 for right in range(n): if s[right] != char: changes += 1 while changes > k: if s[left] != char: changes -= 1 left += 1 max_len = max(max_len, right - left + 1) return max_len return max(max_segment_length('a'), max_segment_length('b'))"},{"question":"def longest_substring_after_k_deletions(k: int, s: str) -> int: Determine the length of the longest substring that can be obtained by deleting at most k characters from s. >>> longest_substring_after_k_deletions(1, \\"abacab\\") 3 >>> longest_substring_after_k_deletions(2, \\"abcde\\") 3 >>> longest_substring_after_k_deletions(0, \\"aaaa\\") 4 >>> longest_substring_after_k_deletions(0, \\"abcde\\") 1 >>> longest_substring_after_k_deletions(0, \\"aabbcc\\") 2 >>> longest_substring_after_k_deletions(50, \\"abcdeabcdeabcde\\") 15 def process_input(t: int, test_cases: list) -> list: Process the input and return the list of results for each test case. >>> process_input(3, [(1, \\"abacab\\"), (2, \\"abcde\\"), (0, \\"aaaa\\")]) [3, 3, 4]","solution":"def longest_substring_after_k_deletions(k, s): Returns the length of the longest substring that can be obtained by deleting at most k characters from s. n = len(s) max_len = 0 # Create a dictionary to keep track of the frequency of each character in the current window count = {} left = 0 max_freq = 0 for right in range(n): count[s[right]] = count.get(s[right], 0) + 1 max_freq = max(max_freq, count[s[right]]) # If we need to delete more than k characters, shrink the window while (right - left + 1) - max_freq > k: count[s[left]] -= 1 left += 1 max_len = max(max_len, right - left + 1) return max_len def process_input(t, test_cases): results = [] for i in range(t): k, s = test_cases[i] results.append(longest_substring_after_k_deletions(k, s)) return results"},{"question":"def are_anagrams(str1: str, str2: str) -> str: Returns 'YES' if str1 and str2 are anagrams of each other ignoring spaces and case, otherwise 'NO'. >>> are_anagrams(\\"listen\\", \\"silent\\") \\"YES\\" >>> are_anagrams(\\"triangle\\", \\"integral\\") \\"YES\\" >>> are_anagrams(\\"apple\\", \\"papel\\") \\"YES\\" >>> are_anagrams(\\"apple\\", \\"pale\\") \\"NO\\" >>> are_anagrams(\\"Apple\\", \\"Papel\\") \\"YES\\" def check_anagrams(T: int, cases: List[Tuple[str, str]]) -> List[str]: Processes T test cases and returns the results as a list of 'YES' or 'NO'. >>> check_anagrams(3, [(\\"listen\\", \\"silent\\"), (\\"triangle\\", \\"integral\\"), (\\"apple\\", \\"papel\\")]) [\\"YES\\", \\"YES\\", \\"YES\\"] >>> check_anagrams(3, [(\\"listen\\", \\"silent\\"), (\\"triangle\\", \\"integral\\"), (\\"apple\\", \\"pale\\")]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> check_anagrams(2, [(\\"William Shakespeare\\", \\"I am a weakish speller\\"), (\\"Apple\\", \\"Papel\\")]) [\\"YES\\", \\"YES\\"] >>> check_anagrams(2, [(\\"12345\\", \\"54321\\"), (\\"12345\\", \\"543 2\\")]) [\\"YES\\", \\"NO\\"] >>> check_anagrams(3, [(\\"\\", \\"\\"), (\\"a\\", \\"a\\"), (\\"a\\", \\"b\\")]) [\\"YES\\", \\"YES\\", \\"NO\\"]","solution":"def are_anagrams(str1, str2): Returns 'YES' if str1 and str2 are anagrams of each other ignoring spaces and case, otherwise 'NO'. # Remove spaces and convert to lowercase formatted_str1 = ''.join(str1.split()).lower() formatted_str2 = ''.join(str2.split()).lower() # Check if sorted characters are the same if sorted(formatted_str1) == sorted(formatted_str2): return \\"YES\\" else: return \\"NO\\" def check_anagrams(T, cases): Processes T test cases and returns the results as a list of 'YES' or 'NO'. results = [] for i in range(T): str1, str2 = cases[i] results.append(are_anagrams(str1, str2)) return results"},{"question":"def determine_S_k(N: int, K: int, A: List[int], B: List[int]) -> List[int]: Determines the K-th sequence based on given arrays A and B. Args: N: int - Length of arrays A and B K: int - The sequence number to determine A: List[int] - The first array B: List[int] - The second array Returns: List[int] - The K-th sequence as a list of integers Examples: >>> determine_S_k(3, 3, [1, 2, 3], [3, 2, 1]) [1, 2, 3] >>> determine_S_k(4, 5, [0, 1, 3, 7], [7, 3, 1, 0]) [0, 1, 3, 7] >>> determine_S_k(2, 1000000000, [123456789, 987654321], [555555555, 444444444]) [555555555, 444444444] >>> determine_S_k(6, 1, [5, 6, 7, 8, 9, 10], [10, 9, 8, 7, 6, 5]) [5, 6, 7, 8, 9, 10] >>> determine_S_k(1, 2, [0], [1]) [1] from typing import List def test_determine_S_k_case1(): assert determine_S_k(3, 3, [1, 2, 3], [3, 2, 1]) == [1, 2, 3] def test_determine_S_k_case2(): assert determine_S_k(4, 5, [0, 1, 3, 7], [7, 3, 1, 0]) == [0, 1, 3, 7] def test_determine_S_k_case3(): assert determine_S_k(2, 1000000000, [123456789, 987654321], [555555555, 444444444]) == [555555555, 444444444] def test_determine_S_k_case4(): assert determine_S_k(6, 1, [5, 6, 7, 8, 9, 10], [10, 9, 8, 7, 6, 5]) == [5, 6, 7, 8, 9, 10] def test_determine_S_k_case5(): assert determine_S_k(1, 2, [0], [1]) == [1]","solution":"def determine_S_k(N, K, A, B): Determines the K-th sequence based on given arrays A and B. return A if K % 2 == 1 else B"},{"question":"def can_rearrange_to_adjacent_diff_one(n: int, arr: List[int]) -> str: Determines if it's possible to rearrange the array such that the absolute difference between any two adjacent elements is exactly 1. Parameters: n (int): The length of the array. arr (list): The list of integers representing the array. Returns: str: \\"YES\\" if possible, otherwise \\"NO\\" pass import pytest def test_example_1(): assert can_rearrange_to_adjacent_diff_one(5, [1, 2, 3, 4, 5]) == \\"YES\\" def test_example_2(): assert can_rearrange_to_adjacent_diff_one(3, [1, 3, 5]) == \\"NO\\" def test_single_element(): assert can_rearrange_to_adjacent_diff_one(1, [1]) == \\"YES\\" def test_already_sorted(): assert can_rearrange_to_adjacent_diff_one(4, [2, 3, 4, 5]) == \\"YES\\" def test_unsorted_without_diff_one(): assert can_rearrange_to_adjacent_diff_one(4, [1, 4, 3, 5]) == \\"NO\\" def test_unsorted_with_diff_one(): assert can_rearrange_to_adjacent_diff_one(4, [4, 3, 2, 1]) == \\"YES\\" def test_all_same_elements(): assert can_rearrange_to_adjacent_diff_one(5, [2, 2, 2, 2, 2]) == \\"NO\\" def test_larger_input(): assert can_rearrange_to_adjacent_diff_one(6, [10, 11, 12, 13, 14, 15]) == \\"YES\\" def test_mixed_elements(): assert can_rearrange_to_adjacent_diff_one(6, [3, 1, 4, 2, 6, 5]) == \\"YES\\"","solution":"def can_rearrange_to_adjacent_diff_one(n, arr): Determines if it's possible to rearrange the array such that the absolute difference between any two adjacent elements is exactly 1. Parameters: n (int): The length of the array. arr (list): The list of integers representing the array. Returns: str: \\"YES\\" if possible, otherwise \\"NO\\" arr.sort() for i in range(1, n): if arr[i] - arr[i-1] != 1: return \\"NO\\" return \\"YES\\""},{"question":"def find_magical_sequence(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Find a sequence of trees with either all even or all odd sums of mystical energy. >>> find_magical_sequence(3, [(3, [8, 4, 9]), (4, [2, 3, 5, 6]), (2, [5, 5])]) [\\"1 1\\", \\"4 1 2 3 4\\", \\"2 1 2\\"] >>> find_magical_sequence(1, [(1, [2])]) [\\"1 1\\"] >>> find_magical_sequence(1, [(1, [5])]) [\\"-1\\"] >>> find_magical_sequence(1, [(3, [1, 3, 5])]) [\\"3 1 2 3\\"]","solution":"def find_magical_sequence(T, test_cases): results = [] for case in test_cases: N, A = case even_indices = [i + 1 for i, num in enumerate(A) if num % 2 == 0] odd_indices = [i + 1 for i, num in enumerate(A) if num % 2 != 0] if even_indices: results.append(f\\"1 {even_indices[0]}\\") elif len(odd_indices) > 1: results.append(f\\"{len(odd_indices)} \\" + \\" \\".join(map(str, odd_indices))) else: results.append(\\"-1\\") return results"},{"question":"def minimum_bitterness(n: int, bitterness_levels: List[int]) -> int: Returns the minimum possible bitterness level by selecting two different ingredients. Parameters: n: Integer, the number of ingredients. bitterness_levels: List of integers representing the bitterness levels of the ingredients. Returns: Integer, the minimum possible bitterness level. # Your code here from solution import minimum_bitterness def test_minimum_bitterness_example1(): assert minimum_bitterness(4, [3, 8, 15, 1]) == 2 def test_minimum_bitterness_example2(): assert minimum_bitterness(3, [5, 19, 12]) == 7 def test_minimum_bitterness_identical_elements(): assert minimum_bitterness(5, [5, 5, 5, 5, 5]) == 0 def test_minimum_bitterness_with_minimum_elements(): assert minimum_bitterness(2, [10, 20]) == 10 def test_minimum_bitterness_large_list(): assert minimum_bitterness(1000, list(range(1000, 0, -1))) == 1 def test_minimum_bitterness_all_distinct(): assert minimum_bitterness(4, [1, 3, 6, 10]) == 2 def test_minimum_bitterness_random_values(): assert minimum_bitterness(5, [10, 3, 5, 6, 8]) == 1","solution":"def minimum_bitterness(n, bitterness_levels): Returns the minimum possible bitterness level by selecting two different ingredients. Parameters: n: Integer, the number of ingredients. bitterness_levels: List of integers representing the bitterness levels of the ingredients. Returns: Integer, the minimum possible bitterness level. # Sort the bitterness levels bitterness_levels.sort() # Initialize minimum difference with a large value min_diff = float('inf') # Iterate through successive pairs to find the minimum difference for i in range(n - 1): min_diff = min(min_diff, abs(bitterness_levels[i] - bitterness_levels[i + 1])) return min_diff"},{"question":"def count_paths(n: int, m: int, grid: List[List[str]]) -> int: Alice has a rectangular grid of size n x m where each cell is initially either blocked or free. Alice starts at the top-left corner (1, 1) which is always free, and her goal is to reach the bottom-right corner (n, m) which is also always free. She can only move either down or right from a cell. Find the number of distinct paths she can take to reach the bottom-right corner from the top-left corner while only moving through free cells. >>> count_paths(3, 3, [ ... ['.', '.', '.'], ... ['.', '#', '.'], ... ['.', '.', '.'] ... ]) 2 >>> count_paths(2, 2, [ ... ['.', '#'], ... ['.', '.'] ... ]) 1 >>> count_paths(3, 3, [ ... ['.', '#', '.'], ... ['.', '#', '.'], ... ['.', '.', '.'] ... ]) 1 >>> count_paths(4, 4, [ ... ['.', '.', '.', '.'], ... ['#', '#', '#', '.'], ... ['.', '.', '.', '.'], ... ['#', '#', '#', '.'] ... ]) 1 >>> count_paths(1, 1, [['.']]) 1 >>> count_paths(2, 2, [ ... ['.', '.'], ... ['.', '.'] ... ]) 2","solution":"def count_paths(n, m, grid): MOD = 10**9 + 7 # Create a 2D list to store the number of ways to reach each cell dp = [[0] * m for _ in range(n)] # Initialize the starting point dp[0][0] = 1 for i in range(n): for j in range(m): if grid[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] dp[i][j] %= MOD return dp[n-1][m-1]"},{"question":"def is_near_palindrome(n: int) -> str: Determines if a number is a near-palindrome. A near-palindrome is defined as a number that becomes a palindrome after changing at most one digit. :param n: A positive integer :return: \\"YES\\" if n is a near-palindrome, \\"NO\\" otherwise. Examples: >>> is_near_palindrome(12321) \\"YES\\" >>> is_near_palindrome(12345) \\"NO\\"","solution":"def is_near_palindrome(n): Determines if a number is a near-palindrome. A near-palindrome is defined as a number that becomes a palindrome after changing at most one digit. :param n: A positive integer :return: \\"YES\\" if n is a near-palindrome, \\"NO\\" otherwise s = str(n) length = len(s) # Function to check if a string is a palindrome def is_palindrome(s): return s == s[::-1] # If the original number is already a palindrome, return YES if is_palindrome(s): return \\"YES\\" # Increment the count for each difference between corresponding digits diff_count = 0 for i in range(length // 2): if s[i] != s[length - 1 - i]: diff_count += 1 # If there's at most one difference, it's a near-palindrome if diff_count <= 1: return \\"YES\\" return \\"NO\\""},{"question":"def can_be_divided(pattern: str) -> str: Determines if the input pattern can be represented as repetitions of a smaller sequence. Args: pattern (str): The string representing the pattern on the carousel. Returns: str: \\"YES\\" if the pattern can be represented as repetitions of a smaller sequence, otherwise \\"NO\\". Examples: >>> can_be_divided(\\"ababab\\") \\"YES\\" >>> can_be_divided(\\"xxxx\\") \\"YES\\" >>> can_be_divided(\\"abac\\") \\"NO\\" >>> can_be_divided(\\"hellohellohello\\") \\"YES\\" def pattern_carousel(test_cases: List[str]) -> List[str]: Processes multiple test cases to determine if each pattern can be represented as repetitions of a smaller sequence. Args: test_cases (List[str]): List of patterns to be tested. Returns: List[str]: List of results for each pattern, \\"YES\\" or \\"NO\\". Examples: >>> pattern_carousel([\\"ababab\\", \\"xxxx\\", \\"abac\\", \\"hellohellohello\\"]) [\\"YES\\", \\"YES\\", \\"NO\\", \\"YES\\"] from typing import List def test_can_be_divided(): assert can_be_divided(\\"ababab\\") == \\"YES\\" assert can_be_divided(\\"xxxx\\") == \\"YES\\" assert can_be_divided(\\"abac\\") == \\"NO\\" assert can_be_divided(\\"hellohellohello\\") == \\"YES\\" assert can_be_divided(\\"abcabcabc\\") == \\"YES\\" assert can_be_divided(\\"a\\") == \\"NO\\" assert can_be_divided(\\"aaa\\") == \\"YES\\" assert can_be_divided(\\"abcd\\") == \\"NO\\" def test_pattern_carousel(): assert pattern_carousel([\\"ababab\\", \\"xxxx\\", \\"abac\\", \\"hellohellohello\\"]) == [\\"YES\\", \\"YES\\", \\"NO\\", \\"YES\\"] assert pattern_carousel([\\"a\\", \\"xyzxyz\\", \\"abcabcabcabcd\\", \\"pppppppp\\"]) == [\\"NO\\", \\"YES\\", \\"NO\\", \\"YES\\"]","solution":"def can_be_divided(pattern): Determines if the input pattern can be represented as repetitions of a smaller sequence. n = len(pattern) for i in range(1, n // 2 + 1): if n % i == 0: if pattern[:i] * (n // i) == pattern: return \\"YES\\" return \\"NO\\" def pattern_carousel(test_cases): Processes multiple test cases to determine if each pattern can be represented as repetitions of a smaller sequence. results = [] for pattern in test_cases: results.append(can_be_divided(pattern)) return results"},{"question":"def contains_pair_with_difference(arr, target): Determines if there exist two distinct indices i and j in the array such that the absolute difference between the values at these indices is equal to the given target. :param arr: List of integers :param target: The target absolute difference :return: \\"Yes\\" if such a pair exists, otherwise \\"No\\" >>> contains_pair_with_difference([1, 5, 3, 4, 2], 3) \\"Yes\\" >>> contains_pair_with_difference([1, 5, 3, 4, 2], 6) \\"No\\" >>> contains_pair_with_difference([1], 0) \\"No\\" >>> contains_pair_with_difference([1, 1, 3], 0) \\"Yes\\" >>> contains_pair_with_difference([1, 2, 3], 0) \\"No\\"","solution":"def contains_pair_with_difference(arr, target): Determines if there exist two distinct indices i and j in the array such that the absolute difference between the values at these indices is equal to the given target. :param arr: List of integers :param target: The target absolute difference :return: \\"Yes\\" if such a pair exists, otherwise \\"No\\" values = set() for number in arr: if number + target in values or number - target in values: return \\"Yes\\" values.add(number) return \\"No\\""},{"question":"def generate_new_sequence(N: int, arr: List[int]) -> List[int]: Generate a new sequence where each element is the product of all elements in the original sequence divided by the value of the element in the original sequence at that position, modulo \`10^9 + 7\`. >>> generate_new_sequence(3, [1, 2, 3]) [6, 3, 2] >>> generate_new_sequence(4, [2, 4, 8, 16]) [512, 256, 128, 64] >>> generate_new_sequence(1, [7]) [1] >>> generate_new_sequence(2, [1000000, 1000000]) [1000000, 1000000] >>> generate_new_sequence(100000, [1]*100000) [1, 1, 1, ..., 1]","solution":"def generate_new_sequence(N, arr): MOD = 10**9 + 7 # Compute the product of all elements in the array total_product = 1 for num in arr: total_product = (total_product * num) % MOD # Compute the modular inverse of each element in arr def mod_inverse(x, mod): return pow(x, mod - 2, mod) new_sequence = [] for num in arr: new_sequence.append((total_product * mod_inverse(num, MOD)) % MOD) return new_sequence"},{"question":"from typing import List, Tuple def process_in_game_mechanics(input_str: str) -> str: Process player commands and evaluate expressions involving in-game variables according to operator precedence and associativity rules. Args: input_str (str): Input string containing operator definitions and expressions. Returns: str: Evaluated results for each expression or \\"ERROR\\" if evaluation fails. Test cases: >>> input_data = \\"1n5n+ L 1n- L 1n* L 2n/ L 2n^ R 3n4na+b*cnd-e^fng+h-i*j/knm^n^o\\" >>> process_in_game_mechanics(input_data) 'ERRORnERRORnERRORnERROR' >>> input_data = \\"1n3n& L 1n| L 0n! R 2n3na&b|cn!a&!bna&!b|c\\" >>> process_in_game_mechanics(input_data) 'ERRORnERRORnERROR' >>> input_data = \\"1n4n+ L 1n- L 1n* L 2n/ L 2n2na+5n5*b\\" >>> process_in_game_mechanics(input_data) 'ERRORnERROR'","solution":"import re def evaluate_expression(expression, variables, operators): def apply_operator(op, left, right): try: if op == '+': return left + right elif op == '-': return left - right elif op == '*': return left * right elif op == '/': if right == 0: return \\"ERROR\\" return left / right elif op == '^': return left ** right except: return \\"ERROR\\" return \\"ERROR\\" # Convert the expression to postfix notation using the Shunting Yard algorithm precedence = {op: p for op, a, p in operators} associativity = {op: a for op, a, p in operators} output = [] operators_stack = [] i = 0 while i < len(expression): token = expression[i] if token.isalpha(): # Variable output.append(token) elif token.isdigit(): # Number num = token while i + 1 < len(expression) and expression[i + 1].isdigit(): i += 1 num += expression[i] output.append(num) elif token in precedence: # Operator while (operators_stack and operators_stack[-1] in precedence and ((associativity[token] == 'L' and precedence[token] <= precedence[operators_stack[-1]]) or (associativity[token] == 'R' and precedence[token] < precedence[operators_stack[-1]]))): output.append(operators_stack.pop()) operators_stack.append(token) elif token == '(': operators_stack.append(token) elif token == ')': while operators_stack and operators_stack[-1] != '(': output.append(operators_stack.pop()) operators_stack.pop() # Remove the '(' i += 1 while operators_stack: output.append(operators_stack.pop()) # Evaluate the postfix expression stack = [] for token in output: if token.isdigit(): stack.append(int(token)) elif token.isalpha(): if token in variables: stack.append(variables[token]) else: return \\"ERROR\\" elif token in precedence: if len(stack) < 2: return \\"ERROR\\" right = stack.pop() left = stack.pop() result = apply_operator(token, left, right) if result == \\"ERROR\\": return \\"ERROR\\" stack.append(result) if len(stack) != 1: return \\"ERROR\\" return stack[0] def evaluate_dataset(O, operators, E, expressions): results = [] variables = {} # Assume for now variables is empty for expression in expressions: result = evaluate_expression(expression, variables, operators) results.append(result) return results def parse_input(input_str): input_lines = input_str.strip().split('n') T = int(input_lines[0]) index = 1 datasets = [] for _ in range(T): O = int(input_lines[index]) operators = [] for i in range(O): op, assoc, prec = input_lines[index + 1 + i].split() operators.append((op, assoc, int(prec))) index += 1 + O E = int(input_lines[index]) expressions = [] for i in range(E): expressions.append(input_lines[index + 1 + i]) datasets.append((O, operators, E, expressions)) index += 1 + E return datasets def process_in_game_mechanics(input_str): datasets = parse_input(input_str) final_results = [] for O, operators, E, expressions in datasets: results = evaluate_dataset(O, operators, E, expressions) for result in results: final_results.append(result) final_results.append('') # For the blank line between datasets return 'n'.join(map(str, final_results)).strip() # Example call input_data = 2 5 + L 1 - L 1 * L 2 / L 2 ^ R 3 4 a+b*c d-e^f g+h-i*j/k m^n^o 3 & L 1 | L 0 ! R 2 3 a&b|c !a&!b a&!b|c print(process_in_game_mechanics(input_data))"},{"question":"from math import comb def choose_ingredients(n: int, m: int) -> int: Returns the number of ways to choose m ingredients from n ingredients. >>> choose_ingredients(5, 3) 10 >>> choose_ingredients(6, 2) 15 return comb(n, m)","solution":"from math import comb def choose_ingredients(n, m): Returns the number of ways to choose m ingredients from n ingredients. return comb(n, m)"},{"question":"from typing import List, Tuple from collections import deque, defaultdict def bfs(n: int, m: int, edges: List[Tuple[int, int]], start: int) -> Tuple[List[int], List[int]]: Perform a breadth-first search on a graph and return the order of nodes visited and the distances from the start node. Args: n (int): Number of nodes. m (int): Number of edges. edges (List[Tuple[int, int]]): List of edges represented as tuples. start (int): The starting node for BFS. Returns: Tuple[List[int], List[int]]: - List[int]: The order in which nodes are visited. - List[int]: The distances from the start node to each node. >>> n, m = 6, 7 >>> edges = [(1, 2), (1, 3), (2, 4), (2, 5), (3, 5), (4, 6), (5, 6)] >>> start = 1 >>> bfs(n, m, edges, start) ([1, 2, 3, 4, 5, 6], [0, 1, 1, 2, 2, 3]) pass def process_input(input_str: str) -> Tuple[int, int, List[Tuple[int, int]], int]: Process the input string and transform it into components for BFS. Args: input_str (str): Input string containing the graph information. Returns: Tuple[int, int, List[Tuple[int, int]], int]: - n (int): Number of nodes. - m (int): Number of edges. - edges (List[Tuple[int, int]]): List of edges. - start (int): The starting node for BFS. >>> input_str = \\"6 7n1 2n1 3n2 4n2 5n3 5n4 6n5 6n1\\" >>> process_input(input_str) (6, 7, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 5), (4, 6), (5, 6)], 1) pass","solution":"from collections import deque, defaultdict def bfs(n, m, edges, start): # Create a dictionary to store adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # Create a queue for BFS queue = deque([start]) visited = [False] * (n + 1) distances = [-1] * (n + 1) # Mark the start node as visited and distance to itself as 0 visited[start] = True distances[start] = 0 result = [] while queue: current = queue.popleft() result.append(current) for neighbor in graph[current]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) distances[neighbor] = distances[current] + 1 # Returning the order of nodes visited and the distances return result, distances[1:] def process_input(input_str): lines = input_str.strip().split('n') n, m = map(int, lines[0].split()) edges = [tuple(map(int, line.split())) for line in lines[1:m + 1]] start = int(lines[m + 1]) return n, m, edges, start"},{"question":"def sum_sequence(inputs): Returns the sum of a sequence of positive integers which ends with 0. The 0 is not included in the sum. >>> sum_sequence([5, 10, 15, 0]) 30 >>> sum_sequence([1, 2, 3, 0]) 6 >>> sum_sequence([10, 0]) 10 >>> sum_sequence([0]) 0 >>> sum_sequence([100, 200, 300, 0]) 600","solution":"def sum_sequence(inputs): Returns the sum of a sequence of positive integers which ends with 0. The 0 is not included in the sum. total = 0 for num in inputs: if num == 0: break total += num return total"},{"question":"def can_transform_by_one_swap(s: str, t: str) -> str: Determine if you can make string s equal to string t by performing exactly one swap of two characters (not necessarily distinct) in s. >>> can_transform_by_one_swap(\\"ab\\", \\"ba\\") 'YES' >>> can_transform_by_one_swap(\\"abc\\", \\"bca\\") 'NO' >>> can_transform_by_one_swap(\\"xyz\\", \\"xzy\\") 'YES' >>> can_transform_by_one_swap(\\"aabb\\", \\"bbaa\\") 'NO' >>> can_transform_by_one_swap(\\"a\\", \\"a\\") 'NO' def run_tests(queries: List[Tuple[str, str]]) -> List[str]: Run tests for the can_transform_by_one_swap function for multiple queries. >>> run_tests([(\\"ab\\", \\"ba\\"), (\\"abc\\", \\"bca\\"), (\\"xyz\\", \\"xzy\\")]) ['YES', 'NO', 'YES']","solution":"def can_transform_by_one_swap(s, t): Determine if you can make string s equal to string t by performing exactly one swap of two characters (not necessarily distinct) in s. if s == t: return \\"NO\\" diff_indices = [] for i in range(len(s)): if s[i] != t[i]: diff_indices.append(i) if len(diff_indices) != 2: return \\"NO\\" i, j = diff_indices if s[i] == t[j] and s[j] == t[i]: return \\"YES\\" return \\"NO\\" def run_tests(queries): results = [] for s, t in queries: results.append(can_transform_by_one_swap(s, t)) return results"},{"question":"def process_operations(Q: int, operations: List[str]) -> List[int]: Process a series of Q operations on an initially zero-filled 2D grid. Each operation can either update a grid cell or calculate the sum of a sub-matrix. Parameters: Q (int): The number of operations to process. operations (List[str]): List of operations in the form of strings. Returns: List[int]: The results after processing each sum query. >>> process_operations(5, [\\"1 1 2 5\\", \\"1 3 4 -3\\", \\"2 1 1 3 4\\", \\"1 2 2 2\\", \\"2 2 2 3 4\\"]) [2, -1] >>> process_operations(1, [\\"1 1 1 100\\"]) [] >>> process_operations(1, [\\"2 1 1 1 1\\"]) [0] >>> process_operations(3, [\\"1 1000 1000 5\\", \\"1 999 999 3\\", \\"2 999 999 1000 1000\\"]) [8] >>> process_operations(4, [\\"1 500 500 10\\", \\"1 500 500 -5\\", \\"1 500 501 7\\", \\"2 499 499 501 501\\"]) [12]","solution":"def update_grid(grid, x, y, v): Update the grid at position (x, y) by adding value v. grid[x-1][y-1] += v def sum_rectangle(grid, x1, y1, x2, y2): Calculate the sum of the rectangle defined by (x1, y1) as top-left and (x2, y2) as bottom-right. sum_val = 0 for i in range(x1-1, x2): for j in range(y1-1, y2): sum_val += grid[i][j] return sum_val def process_operations(Q, operations): # Assuming the grid's dimensions based on the constraints (1 <= n, m <= 1000) n, m = 1000, 1000 grid = [[0] * m for _ in range(n)] result = [] for operation in operations: op = operation.split() if op[0] == '1': # Update operation x, y, v = int(op[1]), int(op[2]), int(op[3]) update_grid(grid, x, y, v) elif op[0] == '2': # Sum operation x1, y1, x2, y2 = int(op[1]), int(op[2]), int(op[3]), int(op[4]) result.append(sum_rectangle(grid, x1, y1, x2, y2)) return result # Example usage: # Q = 5 # operations = [\\"1 1 2 5\\", \\"1 3 4 -3\\", \\"2 1 1 3 4\\", \\"1 2 2 2\\", \\"2 2 2 3 4\\"] # print(process_operations(Q, operations)) # Should output [2, -1]"},{"question":"def generateParenthesis(n: int) -> List[str]: Generate all possible combinations of balanced parentheses pairs for n pairs. >>> generateParenthesis(2) ['(())', '()()'] >>> generateParenthesis(3) ['((()))', '(()())', '(())()', '()(())', '()()()']","solution":"def generateParenthesis(n): Generates all combinations of balanced parentheses for n pairs. def backtrack(s='', left=0, right=0): if len(s) == 2 * n: res.append(s) return if left < n: backtrack(s + '(', left + 1, right) if right < left: backtrack(s + ')', left, right + 1) res = [] backtrack() return res"},{"question":"from typing import List def minimum_transpose_operations(N: int, matrix: List[List[int]]) -> int: This function returns the minimum number of transposing operations needed to make the matrix symmetrical along its main diagonal. Examples: >>> minimum_transpose_operations(3, [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9]]) 3 >>> minimum_transpose_operations(4, [ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16]]) 6 >>> minimum_transpose_operations(2, [ ... [1, 2], ... [2, 1]]) 0 >>> minimum_transpose_operations(3, [ ... [1, 0, 0], ... [0, 1, 0], ... [0, 0, 1]]) 0","solution":"def minimum_transpose_operations(N, matrix): This function returns the minimum number of transposing operations needed to make the matrix symmetrical along its main diagonal. transpose_count = 0 for i in range(N): for j in range(i + 1, N): if matrix[i][j] != matrix[j][i]: transpose_count += 1 return transpose_count # Helper print_matrix function to print the matrix def print_matrix(matrix): for line in matrix: print(\\" \\".join(map(str, line))) # Example Test cases N = 3 matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] print(minimum_transpose_operations(N, matrix)) # Output: 3 N = 4 matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] print(minimum_transpose_operations(N, matrix)) # Output: 6 N = 2 matrix = [ [1, 2], [2, 1] ] print(minimum_transpose_operations(N, matrix)) # Output: 0 N = 3 matrix = [ [1, 0, 0], [0, 1, 0], [0, 0, 1] ] print(minimum_transpose_operations(N, matrix)) # Output: 0"},{"question":"def can_be_strictly_increasing(arr: List[int]) -> str: Determine whether the array can be made strictly increasing by changing at most one element. >>> can_be_strictly_increasing([1]) \\"YES\\" >>> can_be_strictly_increasing([1, 2, 3, 4, 5]) \\"YES\\" >>> can_be_strictly_increasing([1, 5, 3, 4, 6]) \\"YES\\" >>> can_be_strictly_increasing([10, 1, 2, 3]) \\"YES\\" >>> can_be_strictly_increasing([1, 2, 10, 5, 6]) \\"YES\\" >>> can_be_strictly_increasing([1, 5, 3, 2]) \\"NO\\" >>> can_be_strictly_increasing([3, 3, 3]) \\"NO\\" >>> can_be_strictly_increasing([4, 5, 6, 1, 2]) \\"NO\\" >>> can_be_strictly_increasing([1, 5, 3, 4, 6]) \\"YES\\" >>> can_be_strictly_increasing([1, 5, 3, 2]) \\"NO\\" >>> can_be_strictly_increasing([3, 3, 3]) \\"NO\\"","solution":"def can_be_strictly_increasing(arr): This function checks if it is possible to make the array strictly increasing by changing at most one element. n = len(arr) count = 0 # counts the number of modifications needed for i in range(1, n): if arr[i] <= arr[i - 1]: count += 1 if count > 1: return \\"NO\\" if i > 1 and arr[i] <= arr[i - 2] and (i == n-1 or arr[i + 1] <= arr[i - 1]): return \\"NO\\" return \\"YES\\""},{"question":"def max_path_sum(n: int, m: int, grid: List[List[int]]) -> int: Find the highest sum of any path from the top-left to the bottom-right corner of the grid consisting of only right or down movements. >>> max_path_sum(3, 3, [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == 29 >>> max_path_sum(3, 3, [ ... [-1, -2, -3], ... [-4, -5, -6], ... [-7, -8, -9] ... ]) == -21 >>> max_path_sum(1, 1, [ ... [1] ... ]) == 1 >>> max_path_sum(2, 2, [ ... [1, -1], ... [-1, 1] ... ]) == 1 >>> max_path_sum(3, 3, [ ... [1, 2, 3], ... [1, 2, 3], ... [1, 2, 3] ... ]) == 12","solution":"def max_path_sum(n, m, grid): # Initialize dp array dp = [[0] * m for _ in range(n)] dp[0][0] = grid[0][0] # Fill the first row for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of dp array for i in range(1, n): for j in range(1, m): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[n-1][m-1]"},{"question":"def unused_bottles_per_test_case(P: int, K: int, packs: List[int]) -> int: Calculate the number of unused water bottles after distributing them to the participants. >>> unused_bottles_per_test_case(10, 3, [3, 5, 6]) 4 >>> unused_bottles_per_test_case(15, 2, [5, 5]) 5 >>> unused_bottles_per_test_case(8, 4, [2, 2, 2, 3]) 1 def main(T: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Execute multiple test cases and return the results >>> main(3, [(10, 3, [3, 5, 6]), (15, 2, [5, 5]), (8, 4, [2, 2, 2, 3])]) [4, 5, 1] from solution import unused_bottles_per_test_case, main def test_unused_bottles_example_case_1(): P = 10 K = 3 packs = [3, 5, 6] assert unused_bottles_per_test_case(P, K, packs) == 4 def test_unused_bottles_example_case_2(): P = 15 K = 2 packs = [5, 5] assert unused_bottles_per_test_case(P, K, packs) == 5 def test_unused_bottles_example_case_3(): P = 8 K = 4 packs = [2, 2, 2, 3] assert unused_bottles_per_test_case(P, K, packs) == 1 def test_main_function(): T = 3 test_cases = [ (10, 3, [3, 5, 6]), (15, 2, [5, 5]), (8, 4, [2, 2, 2, 3]) ] assert main(T, test_cases) == [4, 5, 1] def test_more_bottles_than_participants(): P = 20 K = 4 packs = [10, 10, 10, 5] assert unused_bottles_per_test_case(P, K, packs) == 15 def test_less_bottles_than_participants(): P = 25 K = 3 packs = [6, 8, 7] assert unused_bottles_per_test_case(P, K, packs) == 4 def test_equal_bottles_and_participants(): P = 20 K = 3 packs = [10, 5, 5] assert unused_bottles_per_test_case(P, K, packs) == 0","solution":"def unused_bottles_per_test_case(P, K, packs): Calculate the number of unused water bottles after distributing them to the participants. total_bottles = sum(packs) unused_bottles = total_bottles - P if total_bottles >= P else P - total_bottles return unused_bottles def main(T, test_cases): results = [] for case in test_cases: P, K, packs = case results.append(unused_bottles_per_test_case(P, K, packs)) return results"},{"question":"from typing import List, Tuple def max_meetings(N: int, meetings: List[Tuple[int, int]]) -> int: Returns the maximum number of meetings Alice can attend without any overlaps. Parameters: N (int): Number of meetings. meetings (list of tuples): List of (start, end) times for each meeting. Returns: int: Maximum number of non-overlapping meetings Alice can attend. pass # Unit Tests import pytest def test_max_meetings_example1(): N = 3 meetings = [(1, 2), (2, 3), (3, 4)] assert max_meetings(N, meetings) == 3 def test_max_meetings_example2(): N = 4 meetings = [(1, 3), (2, 4), (3, 5), (6, 7)] assert max_meetings(N, meetings) == 3 def test_max_meetings_example3(): N = 2 meetings = [(1, 5), (2, 6)] assert max_meetings(N, meetings) == 1 def test_max_meetings_no_overlap(): N = 3 meetings = [(1, 2), (3, 4), (5, 6)] assert max_meetings(N, meetings) == 3 def test_max_meetings_all_overlap(): N = 3 meetings = [(1, 4), (2, 5), (3, 6)] assert max_meetings(N, meetings) == 1 def test_max_meetings_single_meeting(): N = 1 meetings = [(1, 2)] assert max_meetings(N, meetings) == 1 def test_max_meetings_multiple_meetings_with_some_overlaps(): N = 5 meetings = [(1, 4), (4, 5), (2, 3), (5, 7), (6, 8)] assert max_meetings(N, meetings) == 3 def test_max_meetings_meetings_at_maximum_boundary(): N = 3 meetings = [(0, 1_000_000_000), (0, 1), (1, 1_000_000_000)] assert max_meetings(N, meetings) == 2 @pytest.fixture def large_meetings(): import random return 100000, [(i, i + 1) for i in range(100000)] def test_max_meetings_large_input(large_meetings): N, meetings = large_meetings assert max_meetings(N, meetings) == 100000","solution":"def max_meetings(N, meetings): Returns the maximum number of meetings Alice can attend without any overlaps. Parameters: N (int): Number of meetings. meetings (list of tuples): List of (start, end) times for each meeting. Returns: int: Maximum number of non-overlapping meetings Alice can attend. # Sort meetings based on their end times meetings.sort(key=lambda x: x[1]) max_meetings_count = 0 last_end_time = 0 for start, end in meetings: if start >= last_end_time: max_meetings_count += 1 last_end_time = end return max_meetings_count"},{"question":"def maximum_increasing_subsequence(n: int, a: List[int]) -> int: Determine the maximum length of the strictly increasing subsequence that Bob can achieve if both players play optimally. >>> maximum_increasing_subsequence(6, [1, 3, 2, 5, 4, 7]) 4 >>> maximum_increasing_subsequence(1, [10]) 1 >>> maximum_increasing_subsequence(7, [10, 9, 8, 7, 6, 5, 4]) 4 >>> maximum_increasing_subsequence(5, [1, 2, 3, 4, 5]) 3 >>> maximum_increasing_subsequence(4, [10, 20, 30, 40]) 2 # Implement the function here","solution":"def maximum_increasing_subsequence(n, a): # Sort the array to find the longest increasing subsequence easily a.sort() bob_count = 0 for i in range(n): # Bob picks the number if it can extend his increasing subsequence if i % 2 == 0: bob_count += 1 return bob_count"},{"question":"def final_number(n: int, numbers: List[int]) -> int: Returns the last remaining number after performing n-1 operations of replacing two numbers with their sum. Parameters: n (int): number of elements in the list. numbers (list of int): the list of n positive integers. Returns: int: the last remaining number.","solution":"def final_number(n, numbers): Returns the last remaining number after performing n-1 operations of replacing two numbers with their sum. Parameters: n (int): number of elements in the list. numbers (list of int): the list of n positive integers. Returns: int: the last remaining number. return sum(numbers)"},{"question":"from typing import List, Tuple def remove_majority_element(arr: List[int]) -> List[int]: Removes all integers from the array that are equal to the majority element. >>> remove_majority_element([3, 3, 3, 3, 5]) [5] >>> remove_majority_element([7, 7, 8, 8, 8, 8]) [7, 7] >>> remove_majority_element([2, 2, 2, 2]) [] def process_test_cases(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[List[int]]: Processes multiple test cases and returns the results. >>> process_test_cases(3, [(5, [3, 3, 3, 3, 5]), (6, [7, 7, 8, 8, 8, 8]), (4, [2, 2, 2, 2])]) [[5], [7, 7], []] if __name__ == \\"__main__\\": from solution import remove_majority_element, process_test_cases def test_remove_majority_element(): assert remove_majority_element([3, 3, 3, 3, 5]) == [5] assert remove_majority_element([7, 7, 8, 8, 8, 8]) == [7, 7] assert remove_majority_element([2, 2, 2, 2]) == [] assert remove_majority_element([1, 1, 1, 2, 2, 3, 3, 3, 3, 3]) == [1, 1, 1, 2, 2] def test_process_test_cases(): test_cases = [ (5, [3, 3, 3, 3, 5]), (6, [7, 7, 8, 8, 8, 8]), (4, [2, 2, 2, 2]) ] expected_output = [ [5], [7, 7], [] ] assert process_test_cases(3, test_cases) == expected_output test_cases = [ (10, [1, 1, 1, 2, 2, 3, 3, 3, 3, 3]), (3, [1, 1, 2]), (4, [4, 4, 4, 4]) ] expected_output = [ [1, 1, 1, 2, 2], [2], [] ] assert process_test_cases(3, test_cases) == expected_output","solution":"def remove_majority_element(arr): Removes all integers from the array that are equal to the majority element. from collections import Counter # Calculate majority element n = len(arr) counter = Counter(arr) majority_element = max(counter, key=counter.get) # Remove majority element result = [x for x in arr if x != majority_element] return result def process_test_cases(t, test_cases): Processes multiple test cases and returns the results. results = [] for i in range(t): n, arr = test_cases[i] modified_array = remove_majority_element(arr) results.append(modified_array) return results"},{"question":"def two_sum_exists(arr: List[int], target: int) -> bool: Determines if there are two distinct indices in the array such that the sum of the elements at those indices equals the target sum. Parameters: arr (list of int): The array of integers. target (int): The target sum. Returns: bool: True if such indices exist, False otherwise. >>> two_sum_exists([1, 2, 3, 4, 5], 5) True >>> two_sum_exists([1, 2, 3, 4, 5], 10) False >>> two_sum_exists([-1, -2, -3, -4, -5], -8) True >>> two_sum_exists([-1, 2, 3, -4, 5], 1) True >>> two_sum_exists([1], 2) False >>> two_sum_exists([], 0) False","solution":"def two_sum_exists(arr, target): Determines if there are two distinct indices in the array such that the sum of the elements at those indices equals the target sum. Parameters: arr (list of int): The array of integers. target (int): The target sum. Returns: bool: True if such indices exist, False otherwise. seen = {} for num in arr: complement = target - num if complement in seen: return True seen[num] = True return False # Example use case def main(): # Reading the input n = int(input().strip()) arr = list(map(int, input().strip().split())) target = int(input().strip()) if two_sum_exists(arr, target): print(\\"YES\\") else: print(\\"NO\\") if __name__ == \\"__main__\\": main()"},{"question":"def harmonic_score(s: str) -> int: Calculate the harmonic score of the given music sequence string. The harmonic score is calculated by summing the squares of the frequencies of each character in the sequence. >>> harmonic_score(\\"abacaba\\") 21 >>> harmonic_score(\\"music\\") 5 >>> harmonic_score(\\"aaabbc\\") 14 >>> harmonic_score(\\"\\") 0 >>> harmonic_score(\\"a\\") 1 Parameters: s (str): The music sequence string. Returns: int: The harmonic score of the string.","solution":"def harmonic_score(s): Calculate the harmonic score of the given music sequence string. Parameters: s (str): The music sequence string. Returns: int: The harmonic score of the string. from collections import Counter freq = Counter(s) return sum(f * f for f in freq.values())"},{"question":"def max_sum_subarray(n: int, arr: List[int], k: int) -> int: Return the maximum sum of a subarray of length k. Parameters: n (int): number of elements in array arr (list): list of integers k (int): length of the subarray Returns: int: maximum sum of a subarray of length k >>> max_sum_subarray(8, [1, 2, 5, 2, 8, 1, 5, 0], 3) 15 >>> max_sum_subarray(1, [5], 1) 5 >>> max_sum_subarray(5, [-1, -2, -3, -4, -5], 2) -3 >>> max_sum_subarray(5, [1, 2, 3, 4, 5], 2) 9 >>> max_sum_subarray(6, [1, -2, 3, 4, -1, 2], 3) 6 >>> max_sum_subarray(3, [3, 4, 5], 3) 12","solution":"def max_sum_subarray(n, arr, k): Returns the maximum sum of a subarray of length k. Parameters: n (int): number of elements in array arr (list): list of integers k (int): length of the subarray Returns: int: maximum sum of a subarray of length k max_sum = current_sum = sum(arr[:k]) for i in range(k, n): current_sum = current_sum - arr[i - k] + arr[i] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def max_tasks_assigned(T, test_cases): Assign as many tasks as possible to the employees based on their skill levels. Args: T : int : Number of test cases test_cases : list of dict : A list where each entry is a dictionary containing number of employees, their skill levels, number of tasks, and their required skill levels. Returns: list : A list of integers where each integer is the maximum number of tasks that can be assigned for the corresponding test case. >>> T = 2 >>> test_cases = [ ... { ... 'n': 5, ... 'employees_skills': [4, 3, 1, 2, 5], ... 'm': 3, ... 'tasks_required_skills': [6, 2, 3] ... }, ... { ... 'n': 4, ... 'employees_skills': [2, 8, 4, 3], ... 'm': 4, ... 'tasks_required_skills': [2, 3, 7, 6] ... } ... ] >>> max_tasks_assigned(T, test_cases) [2, 3] >>> T = 1 >>> test_cases = [ ... { ... 'n': 3, ... 'employees_skills': [1, 1, 1], ... 'm': 3, ... 'tasks_required_skills': [2, 2, 2] ... } ... ] >>> max_tasks_assigned(T, test_cases) [0]","solution":"def max_tasks_assigned(T, test_cases): results = [] for i in range(T): employees_n = test_cases[i]['n'] employees_skills = sorted(test_cases[i]['employees_skills']) tasks_m = test_cases[i]['m'] tasks_required_skills = sorted(test_cases[i]['tasks_required_skills']) task_index = 0 employee_index = 0 tasks_assigned = 0 while task_index < tasks_m and employee_index < employees_n: if employees_skills[employee_index] >= tasks_required_skills[task_index]: tasks_assigned += 1 task_index += 1 employee_index += 1 results.append(tasks_assigned) return results"},{"question":"def solve_game(n: int, m: int, grid: List[str]) -> int: Determine the minimum number of moves required for Lina to reach the goal cell from the start cell. If it is impossible, return -1. >>> solve_game(5, 5, [\\"S...#\\", \\".#..#\\", \\"..#.#\\", \\"#...#\\", \\"#..G.\\"]) 7 >>> solve_game(3, 4, [\\"S..#\\", \\"#.\\", \\"...G\\"]) -1 >>> solve_game(3, 3, [\\"S\\", \\"#\\", \\"G\\"]) -1 >>> solve_game(1, 2, [\\"SG\\"]) 1 >>> solve_game(3, 3, [\\"S..\\", \\"...\\", \\"..G\\"]) 4 >>> solve_game(4, 4, [\\"S...\\", \\".#.#\\", \\".#.#\\", \\"...G\\"]) 6","solution":"from collections import deque def min_moves(grid, n, m): # Find start and goal positions start = None goal = None for i in range(n): for j in range(m): if grid[i][j] == 'S': start = (i, j) elif grid[i][j] == 'G': goal = (i, j) if not start or not goal: return -1 # BFS to find the shortest path def is_valid(x, y): return 0 <= x < n and 0 <= y < m and grid[x][y] != '#' queue = deque([(start[0], start[1], 0)]) visited = set() visited.add(start) while queue: x, y, dist = queue.popleft() if (x, y) == goal: return dist for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: # up, down, left, right nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1 def solve_game(n, m, lines): grid = [list(line) for line in lines] return min_moves(grid, n, m)"},{"question":"def is_divisible(x: int, y: int) -> str: Determines if x is divisible by y. Parameters: x (int): An integer, 1  x  10000 y (int): An integer, 1  y  10000 Returns: str: \\"Divisible\\" if x is divisible by y, otherwise \\"Not Divisible\\" # Example test cases to validate the solution def test_divisible_cases(): assert is_divisible(10, 2) == \\"Divisible\\" assert is_divisible(10000, 1) == \\"Divisible\\" assert is_divisible(15, 15) == \\"Divisible\\" assert is_divisible(50, 5) == \\"Divisible\\" def test_not_divisible_cases(): assert is_divisible(7, 3) == \\"Not Divisible\\" assert is_divisible(23, 6) == \\"Not Divisible\\" assert is_divisible(19, 4) == \\"Not Divisible\\" assert is_divisible(100, 3) == \\"Not Divisible\\"","solution":"def is_divisible(x, y): Determines if x is divisible by y. Parameters: x (int): An integer, 1  x  10000 y (int): An integer, 1  y  10000 Returns: str: \\"Divisible\\" if x is divisible by y, otherwise \\"Not Divisible\\" if x % y == 0: return \\"Divisible\\" else: return \\"Not Divisible\\""},{"question":"def isMatch(s: str, p: str) -> bool: Determine if an input string matches a simple pattern. The pattern can include characters in the string and special wildcard characters: '?' and '*'. The '?' character matches any single character while the '*' character matches any sequence of characters. >>> isMatch(\\"aa\\", \\"a\\") False >>> isMatch(\\"aa\\", \\"*\\") True >>> isMatch(\\"cb\\", \\"?a\\") False >>> isMatch(\\"adceb\\", \\"*a*b\\") True >>> isMatch(\\"acdcb\\", \\"a*c?b\\") False","solution":"def isMatch(s, p): m, n = len(s), len(p) dp = [[False] * (n + 1) for _ in range(m + 1)] dp[0][0] = True for j in range(1, n + 1): if p[j - 1] == '*': dp[0][j] = dp[0][j - 1] for i in range(1, m + 1): for j in range(1, n + 1): if p[j - 1] == '*': dp[i][j] = dp[i][j - 1] or dp[i - 1][j] elif p[j - 1] == '?' or p[j - 1] == s[i - 1]: dp[i][j] = dp[i - 1][j - 1] return dp[m][n]"},{"question":"def min_operations_to_make_equal(arrays: List[List[int]]) -> List[int]: Determine the minimum number of operations needed to make all elements of each subarray equal. Parameters: arrays (List[List[int]]): A list of arrays containing integers. Returns: List[int]: A list of integers where each integer represents the minimum number of operations needed for the corresponding array to make all elements equal. Examples: >>> min_operations_to_make_equal([[3, 3, 2, 1, 4], [1, 2, 3], [7, 9, 5, 7]]) [4, 3, 3] >>> min_operations_to_make_equal([[1, 1, 1], [2, 2, 2], [3, 3, 3]]) [1, 1, 1] >>> min_operations_to_make_equal([[1, 2, 2, 1], [4, 5, 4, 6]]) [2, 3] >>> min_operations_to_make_equal([[1000, 999, 998, 1000], [1, 1000, 500, 500]]) [3, 3]","solution":"def min_operations_to_make_equal(arrays): Given a list of arrays, computes the minimum number of operations needed to make all elements of each array equal. def count_distinct_elements(arr): return len(set(arr)) result = [] for array in arrays: result.append(count_distinct_elements(array)) return result"},{"question":"def find_unit_squares(n: int, m: int, d: int) -> Union[List[Tuple[int, int]], int]: Find all the unit squares that fall on either of the painted lines. >>> find_unit_squares(5, 5, 3) [(1, 1), (1, 4), (2, 1), (2, 4), (3, 1), (3, 4), (4, 1), (4, 4), (5, 1), (5, 4)] >>> find_unit_squares(6, 6, 2) [(1, 1), (1, 3), (2, 1), (2, 3), (3, 1), (3, 3), (4, 1), (4, 3), (5, 1), (5, 3), (6, 1), (6, 3)] >>> find_unit_squares(4, 4, 5) -1","solution":"def find_unit_squares(n, m, d): # Check for feasible vertical lines if d < m: for col1 in range(1, m-d+1): col2 = col1 + d if col2 <= m: return sorted([(row, col1) for row in range(1, n+1)] + [(row, col2) for row in range(1, n+1)]) # Check for feasible horizontal lines if d < n: for row1 in range(1, n-d+1): row2 = row1 + d if row2 <= n: return sorted([(row1, col) for col in range(1, m+1)] + [(row2, col) for col in range(1, m+1)]) return -1"},{"question":"def keys_for_doors(n: int, m: int, keys: List[str], doors: List[str]) -> List[str]: Identify which keys can open which doors. n: number of keys m: number of doors keys: list of keys' teeth patterns doors: list of doors' lock patterns Returns a list of strings where each string contains the 1-based indices of keys that can open the corresponding door. >>> keys_for_doors(3, 2, [\\"abc\\", \\"bca\\", \\"cab\\"], [\\"cab\\", \\"abc\\"]) [\\"3\\", \\"1\\"] >>> keys_for_doors(4, 3, [\\"abcd\\", \\"efgh\\", \\"ijkl\\", \\"mnop\\"], [\\"mnop\\", \\"abcd\\", \\"efgh\\"]) [\\"4\\", \\"1\\", \\"2\\"] >>> keys_for_doors(2, 2, [\\"1234\\", \\"5678\\"], [\\"4321\\", \\"8765\\"]) [\\"-1\\", \\"-1\\"] from typing import List def test_case_1(): n, m = 3, 2 keys = [\\"abc\\", \\"bca\\", \\"cab\\"] doors = [\\"cab\\", \\"abc\\"] result = keys_for_doors(n, m, keys, doors) assert result == [\\"3\\", \\"1\\"] def test_case_2(): n, m = 4, 3 keys = [\\"abcd\\", \\"efgh\\", \\"ijkl\\", \\"mnop\\"] doors = [\\"mnop\\", \\"abcd\\", \\"efgh\\"] result = keys_for_doors(n, m, keys, doors) assert result == [\\"4\\", \\"1\\", \\"2\\"] def test_case_3(): n, m = 2, 2 keys = [\\"1234\\", \\"5678\\"] doors = [\\"4321\\", \\"8765\\"] result = keys_for_doors(n, m, keys, doors) assert result == [\\"-1\\", \\"-1\\"] def test_case_4(): n, m = 5, 3 keys = [\\"aaaa\\", \\"bbbb\\", \\"cccc\\", \\"dddd\\", \\"eeee\\"] doors = [\\"bbbb\\", \\"dddd\\", \\"ffff\\"] result = keys_for_doors(n, m, keys, doors) assert result == [\\"2\\", \\"4\\", \\"-1\\"] def test_case_5(): n, m = 1, 1 keys = [\\"key1\\"] doors = [\\"key2\\"] result = keys_for_doors(n, m, keys, doors) assert result == [\\"-1\\"]","solution":"def keys_for_doors(n, m, keys, doors): results = [] for door in doors: matching_keys = [str(i + 1) for i, key in enumerate(keys) if key == door] if matching_keys: results.append(\\" \\".join(matching_keys)) else: results.append(\\"-1\\") return results"},{"question":"def list_operations(n: int, elements: List[int], m: int, commands: List[str]) -> List[int]: Executes a series of commands on a list of integers and returns a list of results for \\"find\\" commands. >>> list_operations(10, [5, 2, 9, 1, 5, 6, 8, 3, 7, 4], 5, [\\"find 5\\", \\"sort asc\\", \\"find 5\\", \\"sort desc\\", \\"find 10\\"]) [0, 4, -1] >>> list_operations(4, [4, 3, 2, 1], 2, [\\"sort asc\\", \\"sort desc\\"]) [] >>> list_operations(6, [5, 2, 9, 1, 5, 6], 3, [\\"sort asc\\", \\"find 5\\", \\"find 6\\"]) [2, 4] >>> list_operations(3, [1, 7, 3], 2, [\\"find 2\\", \\"find 3\\"]) [-1, 2] >>> list_operations(5, [2, 3, 2, 2, 4], 3, [\\"find 2\\", \\"sort asc\\", \\"find 2\\"]) [0, 0] >>> list_operations(1000, list(range(1000, 0, -1)), 2, [\\"sort asc\\", \\"find 500\\"]) [499]","solution":"def list_operations(n, elements, m, commands): Executes a series of commands on a list of integers and returns a list of results for \\"find\\" commands. results = [] # Commands processing for command in commands: if command.startswith(\\"sort asc\\"): elements.sort() elif command.startswith(\\"sort desc\\"): elements.sort(reverse=True) elif command.startswith(\\"find\\"): _, x = command.split() x = int(x) try: index = elements.index(x) except ValueError: index = -1 results.append(index) return results"},{"question":"def can_rearrange_coins(n, m, target_bins, coin_counts): Determines if the coins can be rearranged such that each bin has the exact target number of coins specified. Parameters: n (int): Number of bins m (int): Number of coin types target_bins (list): List containing the target number of coins for each bin coin_counts (list): List containing the count of coins of each type Returns: str: \\"YES\\" if it is possible to rearrange the coins to meet the target, otherwise \\"NO\\" Example: >>> can_rearrange_coins(3, 2, [4, 5, 6], [8, 7]) \\"YES\\" >>> can_rearrange_coins(2, 3, [5, 5], [4, 6, 1]) \\"YES\\" >>> can_rearrange_coins(3, 2, [3, 2, 4], [2, 4]) \\"NO\\"","solution":"def can_rearrange_coins(n, m, target_bins, coin_counts): Determines if the coins can be rearranged such that each bin has the exact target number of coins specified. Parameters: n (int): Number of bins m (int): Number of coin types target_bins (list): List containing the target number of coins for each bin coin_counts (list): List containing the count of coins of each type Returns: str: \\"YES\\" if it is possible to rearrange the coins to meet the target, otherwise \\"NO\\" if sum(coin_counts) >= sum(target_bins): return \\"YES\\" else: return \\"NO\\""},{"question":"def max_glass_panes(n: int, panes: List[Tuple[int, int, int, int]]) -> int: Given n glass panes with bottom-left and top-right coordinates, find the maximum number of panes that can form a contiguous rectangular wall. >>> max_glass_panes(4, [(1, 1, 2, 3), (2, 1, 3, 2), (3, 1, 4, 2), (4, 1, 5, 3)]) 4 >>> max_glass_panes(5, [(1, 1, 2, 2), (3, 1, 4, 2), (1, 3, 2, 4), (3, 3, 4, 4), (2, 2, 3, 3)]) 5 >>> max_glass_panes(1, [(1, 1, 2, 2)]) 1 >>> max_glass_panes(0, []) 0 >>> max_glass_panes(5, [(1, 1, 4, 6), (1, 1, 4, 6), (1, 1, 2, 4), (1, 1, 6, 8), (1, 1, 8, 10)]) 5","solution":"def max_glass_panes(n, panes): Given n glass panes with bottom-left and top-right coordinates, find the maximum number of panes that can form a contiguous rectangular wall. def normalize_pane(pane): x1, y1, x2, y2 = pane w = x2 - x1 h = y2 - y1 if w > h: w, h = h, w return (w, h) from collections import defaultdict normalized_panes = defaultdict(int) for pane in panes: normalized_pane = normalize_pane(pane) normalized_panes[normalized_pane] += 1 max_count = 0 for (w, h), count in normalized_panes.items(): max_count += count return max_count"},{"question":"def find_jumping_numbers(n: int) -> List[int]: Returns a list of all Jumping Numbers less than or equal to n. >>> find_jumping_numbers(10) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10] >>> find_jumping_numbers(50) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21, 23, 32, 34, 43, 45] # Your code here def jumping_numbers(t: int, test_cases: List[int]) -> List[List[int]]: Returns the Jumping Numbers for multiple test cases. >>> jumping_numbers(2, [10, 50]) [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21, 23, 32, 34, 43, 45]] >>> jumping_numbers(1, [15]) [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12]] # Your code here","solution":"def find_jumping_numbers(n): Returns a list of all Jumping Numbers less than or equal to n. if n < 10: return list(range(n + 1)) result = list(range(10)) from collections import deque queue = deque(range(1, 10)) while queue: current = queue.popleft() last_digit = current % 10 if last_digit > 0: next_number = current * 10 + (last_digit - 1) if next_number <= n: queue.append(next_number) result.append(next_number) if last_digit < 9: next_number = current * 10 + (last_digit + 1) if next_number <= n: queue.append(next_number) result.append(next_number) return sorted(result) def jumping_numbers(t, test_cases): results = [] for n in test_cases: results.append(find_jumping_numbers(n)) return results"},{"question":"def is_tree(N: int, M: int, edges: List[Tuple[int, int]]) -> str: Determine if the given undirected graph is a tree. Parameters: N (int): Number of nodes. M (int): Number of edges. edges (List[Tuple[int, int]]): List of edges. Returns: str: \\"YES\\" if the graph is a tree, otherwise \\"NO\\". >>> is_tree(4, 3, [(1, 2), (2, 3), (3, 4)]) == \\"YES\\" >>> is_tree(4, 3, [(1, 2), (2, 3), (3, 1)]) == \\"NO\\" # Write your code here. from solution import is_tree def test_is_tree_case1(): N = 4 M = 3 edges = [(1, 2), (2, 3), (3, 4)] assert is_tree(N, M, edges) == \\"YES\\" def test_is_tree_case2(): N = 4 M = 3 edges = [(1, 2), (2, 3), (3, 1)] assert is_tree(N, M, edges) == \\"NO\\" def test_is_tree_case3(): N = 3 M = 2 edges = [(1, 2), (1, 3)] assert is_tree(N, M, edges) == \\"YES\\" def test_is_tree_case4(): N = 5 M = 4 edges = [(1, 2), (2, 3), (3, 4), (4, 5)] assert is_tree(N, M, edges) == \\"YES\\" def test_is_tree_case5(): N = 5 M = 3 edges = [(1, 2), (2, 4), (4, 5)] assert is_tree(N, M, edges) == \\"NO\\" def test_is_tree_case6(): N = 6 M = 5 edges = [(1, 2), (1, 3), (1, 4), (4, 5), (4, 6)] assert is_tree(N, M, edges) == \\"YES\\" def test_is_tree_case7(): N = 3 M = 3 edges = [(1, 2), (2, 3), (3, 1)] assert is_tree(N, M, edges) == \\"NO\\"","solution":"def is_tree(N, M, edges): if M != N - 1: return \\"NO\\" from collections import defaultdict, deque graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = set() def bfs(start): queue = deque([start]) visited.add(start) while queue: node = queue.popleft() for neighbor in graph[node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) bfs(1) return \\"YES\\" if len(visited) == N else \\"NO\\""},{"question":"def count_paths(board: List[List[int]]) -> int: Determine the number of distinct paths to reach the bottom-right corner of the board without hitting an obstacle. >>> count_paths([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) 2 >>> count_paths([ ... [0, 1], ... [0, 0] ... ]) 1 from typing import List def test_case_1(): board = [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ] assert count_paths(board) == 2 def test_case_2(): board = [ [0, 1], [0, 0] ] assert count_paths(board) == 1 def test_case_3(): board = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert count_paths(board) == 6 def test_case_4(): board = [ [0, 0], [1, 0] ] assert count_paths(board) == 1 def test_case_5(): board = [ [0, 0, 1], [0, 1, 0], [0, 0, 0] ] assert count_paths(board) == 1 def test_case_6(): board = [ [0, 0, 0], [1, 1, 0], [0, 0, 0] ] assert count_paths(board) == 1","solution":"def count_paths(board): N = len(board) M = len(board[0]) if board[0][0] == 1 or board[N-1][M-1] == 1: return 0 dp = [[0] * M for _ in range(N)] dp[0][0] = 1 for i in range(N): for j in range(M): if board[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[N-1][M-1]"},{"question":"def min_cars_needed(N: int, C: int, group_sizes: List[int]) -> int: Returns the minimum number of cars needed to accommodate all groups given the car capacity. >>> min_cars_needed(5, 4, [2, 3, 3, 4, 1]) 4 >>> min_cars_needed(1, 4, [2]) 1 pass from typing import List def test_example(): assert min_cars_needed(5, 4, [2, 3, 3, 4, 1]) == 4 def test_single_group(): assert min_cars_needed(1, 4, [2]) == 1 assert min_cars_needed(1, 4, [5]) == 1 def test_all_groups_fit_perfectly(): assert min_cars_needed(4, 4, [1, 1, 1, 1]) == 2 assert min_cars_needed(3, 6, [2, 2, 2]) == 2 def test_groups_with_large_capacity(): assert min_cars_needed(3, 10, [5, 4, 1]) == 2 def test_maximum_capacity_single_car(): assert min_cars_needed(5, 7, [2, 2, 2, 2, 2]) == 3 def test_large_group(): assert min_cars_needed(6, 8, [4, 3, 3, 2, 2, 1]) == 3 def test_all_large_groups(): assert min_cars_needed(3, 3, [4, 5, 6]) == 3 def test_any_two_groups(): assert min_cars_needed(4, 10, [6, 6, 6, 6]) == 4","solution":"def min_cars_needed(N, C, group_sizes): Returns the minimum number of cars needed to accommodate all groups given the car capacity. group_sizes.sort(reverse=True) cars = 0 i = 0 j = N - 1 while i <= j: if group_sizes[i] + group_sizes[j] <= C: j -= 1 i += 1 cars += 1 return cars"},{"question":"def perform_operations(operations: List[str], M: int) -> List[int]: Perform Q operations on an initially empty array based on given instructions. Each operation can be Add, Remove, Reverse, or Sum. The result of Sum is returned as a list of results for each SUM operation. Args: operations (List[str]): List of operations to perform on the array. M (int): The modulo value. Returns: List[int]: Results of SUM operations. >>> perform_operations([\\"ADD 10\\", \\"ADD 20\\", \\"SUM\\"], 100) [30] >>> perform_operations([\\"ADD 10\\", \\"ADD 20\\", \\"SUM\\", \\"REVERSE\\", \\"SUM\\"], 100) [30, 30] >>> perform_operations([\\"ADD 10\\", \\"ADD 20\\", \\"REMOVE\\", \\"SUM\\"], 100) [10] >>> perform_operations([\\"ADD 3\\", \\"ADD 5\\", \\"SUM\\"], 2) [0] >>> perform_operations([\\"REMOVE\\", \\"SUM\\"], 100) [0] >>> perform_operations([\\"ADD 10\\", \\"ADD 20\\", \\"ADD 30\\", \\"REMOVE\\", \\"REVERSE\\", \\"SUM\\"], 1000000000) [30]","solution":"def perform_operations(operations, M): array = [] results = [] for operation in operations: if operation.startswith(\\"ADD\\"): _, x = operation.split() array.append(int(x)) elif operation == \\"REMOVE\\" and array: array.pop() elif operation == \\"REVERSE\\": array.reverse() elif operation == \\"SUM\\": results.append(sum(array) % M) return results def main(): import sys input = sys.stdin.read data = input().strip().split('n') first_line = data[0].split() Q = int(first_line[0]) M = int(first_line[1]) operations = data[1:] results = perform_operations(operations, M) for result in results: print(result) if __name__ == \\"__main__\\": main()"},{"question":"def min_cost_to_make_pillars_non_decreasing(n: int, heights: List[int]) -> int: Returns the minimum cost to make the heights of all the pillars non-decreasing. Parameters: n (int): Number of pillars. heights (List[int]): List of heights of the pillars. Returns: int: Minimum cost required. >>> min_cost_to_make_pillars_non_decreasing(4, [1, 5, 3, 2]) 5 >>> min_cost_to_make_pillars_non_decreasing(5, [2, 2, 3, 4, 5]) 0 >>> min_cost_to_make_pillars_non_decreasing(3, [3, 3, 3]) 0 >>> min_cost_to_make_pillars_non_decreasing(4, [1, 2, 3, 4]) 0 >>> min_cost_to_make_pillars_non_decreasing(4, [4, 3, 2, 1]) 6 >>> min_cost_to_make_pillars_non_decreasing(1, [10]) 0 >>> min_cost_to_make_pillars_non_decreasing(3, [1, 1000000000, 1]) 999999999","solution":"def min_cost_to_make_pillars_non_decreasing(n, heights): Returns the minimum cost to make the heights of all the pillars non-decreasing. Parameters: n (int): Number of pillars. heights (List[int]): List of heights of the pillars. Returns: int: Minimum cost required. cost = 0 for i in range(1, n): if heights[i] < heights[i - 1]: cost += heights[i - 1] - heights[i] heights[i] = heights[i - 1] return cost"},{"question":"def sort_months(t, month_lists): Sorts the months for each test case to be in the order from January to December. :param t: Integer, number of test cases :param month_lists: List of strings, each representing the submitted months in random order :return: List of strings, each representing the sorted months for each test case >>> t = 2 >>> month_lists = [ ... \\"March January February December November October September August July June May April\\", ... \\"July April December November May March February June September January October August\\" ... ] >>> sort_months(t, month_lists) [ \\"January February March April May June July August September October November December\\", \\"January February March April May June July August September October November December\\" ] >>> t = 1 >>> month_lists = [ ... \\"March January February December November October September August July June May April\\" ... ] >>> sort_months(t, month_lists) [ \\"January February March April May June July August September October November December\\" ] >>> t = 1 >>> month_lists = [ ... \\"January February March April May June July August September October November December\\" ... ] >>> sort_months(t, month_lists) [ \\"January February March April May June July August September October November December\\" ] >>> t = 1 >>> month_lists = [ ... \\"December November October September August July June May April March February January\\" ... ] >>> sort_months(t, month_lists) [ \\"January February March April May June July August September October November December\\" ] >>> t = 1 >>> month_lists = [ ... \\"May December April July January June October September February March August November\\" ... ] >>> sort_months(t, month_lists) [ \\"January February March April May June July August September October November December\\" ]","solution":"def sort_months(t, month_lists): Sorts the months for each test case to be in the order from January to December. :param t: Integer, number of test cases :param month_lists: List of strings, each representing the submitted months in random order :return: List of strings, each representing the sorted months for each test case correct_order = [ \\"January\\", \\"February\\", \\"March\\", \\"April\\", \\"May\\", \\"June\\", \\"July\\", \\"August\\", \\"September\\", \\"October\\", \\"November\\", \\"December\\" ] month_order = {month: i for i, month in enumerate(correct_order)} results = [] for months in month_lists: sorted_months = sorted(months.split(), key=lambda month: month_order[month]) results.append(' '.join(sorted_months)) return results"},{"question":"def cumulative_cost(prices: List[int], queries: List[Tuple[int, int]]) -> List[int]: This function returns the cumulative cost for each query specified. :param prices: List of item prices. :param queries: List of queries with each query as a tuple (L, R) :return: List of sums for each query >>> cumulative_cost([10, 20, 30, 40, 50], [(1, 3), (2, 4), (1, 5)]) [60, 90, 150] >>> cumulative_cost([100], [(1, 1)]) [100] >>> cumulative_cost([5, 15, 25, 35, 45], [(1, 5)]) [125] >>> cumulative_cost([1, 2, 3, 4, 5], [(1, 3), (2, 4), (3, 5), (1, 5)]) [6, 9, 12, 15] >>> cumulative_cost([1] * 100000, [(1, 100000)]) [100000]","solution":"def cumulative_cost(prices, queries): This function returns the cumulative cost for each query specified. :param prices: List of item prices. :param queries: List of queries with each query as a tuple (L, R) :return: List of sums for each query # Convert prices array to prefix sums for fast range sum queries prefix_sums = [0] * (len(prices) + 1) for i in range(1, len(prices) + 1): prefix_sums[i] = prefix_sums[i-1] + prices[i-1] results = [] for L, R in queries: results.append(prefix_sums[R] - prefix_sums[L-1]) return results"},{"question":"def total_steps(n: int, k: int, steps: List[int]) -> int: Returns the total number of steps the tracker shows at the end of the period. Parameters: n (int): The number of days. k (int): The number of last days the tracker can store. steps (list): A list containing the number of steps walked each day. Returns: int: The total number of steps for the last k days. >>> total_steps(5, 3, [1, 2, 3, 4, 5]) 12 >>> total_steps(4, 5, [10, 20, 30, 40]) 100 >>> total_steps(3, 3, [1, 2, 3]) 6 >>> total_steps(6, 4, [1, 1, 1, 1, 2, 2]) 6 >>> total_steps(1, 1, [5]) 5","solution":"def total_steps(n, k, steps): Returns the total number of steps the tracker shows at the end of the period. Parameters: n (int): The number of days. k (int): The number of last days the tracker can store. steps (list): A list containing the number of steps walked each day. Returns: int: The total number of steps for the last k days. if n <= k: return sum(steps) else: return sum(steps[-k:])"},{"question":"def max_ships(n: int, k: int, weights: List[int]) -> int: Determines the maximum number of ships that can be loaded with weights in strictly increasing order. A ship can carry at most k containers. Parameters: n (int): The number of containers k (int): The maximum number of containers each ship can carry weights (list of int): The weights of the containers Returns: int: The maximum number of ships. Examples: >>> max_ships(5, 3, [1, 2, 3, 4, 5]) 2 >>> max_ships(6, 2, [5, 1, 2, 4, 3, 6]) 3 >>> max_ships(1, 1, [10]) 1 >>> max_ships(7, 3, [8, 5, 1, 6, 2, 7, 3]) 3 >>> max_ships(8, 4, [1, 2, 3, 4, 5, 6, 7, 8]) 2 >>> max_ships(4, 1, [3, 1, 4, 2]) 4","solution":"def max_ships(n, k, weights): Determines the maximum number of ships that can be loaded with weights in strictly increasing order. A ship can carry at most k containers. Parameters: n (int): The number of containers k (int): The maximum number of containers each ship can carry weights (list of int): The weights of the containers Returns: int: The maximum number of ships weights.sort() ships = 0 i = 0 while i < n: # Each new ship can take at most k containers but they must be in increasing order ships += 1 i += k return ships"},{"question":"def process_input(group: int, value1: int, value2: int = None) -> int: Processes the input based on group number to either calculate the area of a rectangle or factorial of a number. Parameters: group (int): Group number (1 or 2). value1 (int): Length of the rectangle or the number to calculate factorial. value2 (int, optional): Width of the rectangle. Returns: int: Result of the calculation (area of the rectangle or factorial of the number). pass # Unit test def test_group_1_area(): assert process_input(1, 3, 4) == 12 assert process_input(1, 1, 1) == 1 assert process_input(1, 10, 10) == 100 def test_group_2_factorial(): assert process_input(2, 1) == 1 assert process_input(2, 5) == 120 assert process_input(2, 10) == 3628800 def test_invalid_group(): try: process_input(3, 5) except ValueError as e: assert str(e) == \\"Invalid group number. Group number should be 1 or 2.\\" try: process_input(0, 5) except ValueError as e: assert str(e) == \\"Invalid group number. Group number should be 1 or 2.\\"","solution":"def process_input(group, value1, value2=None): Processes the input based on group number to either calculate the area of a rectangle or factorial of a number. Parameters: group (int): Group number (1 or 2). value1 (int): Length of the rectangle or the number to calculate factorial. value2 (int, optional): Width of the rectangle. Returns: int: Result of the calculation (area of the rectangle or factorial of the number). if group == 1: # Group 1: Calculate the area of a rectangle L * W L = value1 W = value2 return L * W elif group == 2: # Group 2: Calculate the factorial of X X = value1 factorial = 1 for i in range(1, X + 1): factorial *= i return factorial else: raise ValueError(\\"Invalid group number. Group number should be 1 or 2.\\")"},{"question":"def max_subgrid_sum(grid, n, k): Given a grid of size n x n, find the maximum sum of a k x k subgrid. Parameters: grid: list of list of integers - 2D list representing the power levels in the grid. n: int - size of the grid. k: int - size of the subgrid. Returns: int - the maximum sum of any k x k subgrid. Examples: >>> max_subgrid_sum([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 2, 2], [1, 1, 2, 2]], 4, 2) 8 >>> max_subgrid_sum([[5]], 1, 1) 5 >>> max_subgrid_sum([[1, 2], [3, 4]], 2, 2) 10 >>> max_subgrid_sum([[0, 0, 0, 1], [0, 5, 5, 0], [0, 5, 5, 0], [1, 0, 0, 0]], 4, 2) 20 >>> max_subgrid_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3, 3) 45","solution":"def max_subgrid_sum(grid, n, k): Given a grid of size n x n, find the maximum sum of a k x k subgrid. Parameters: grid: list of list of integers - 2D list representing the power levels in the grid. n: int - size of the grid. k: int - size of the subgrid. Returns: int - the maximum sum of any k x k subgrid. max_sum = 0 for i in range(n - k + 1): for j in range(n - k + 1): current_sum = 0 for l in range(i, i + k): for m in range(j, j + k): current_sum += grid[l][m] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def is_valid_palindrome(s: str) -> bool: Check if the given string is a valid palindrome after removing all non-alphanumeric characters and converting to lowercase. >>> is_valid_palindrome(\\"A man, a plan, a canal, Panama!\\") True >>> is_valid_palindrome(\\"race a car\\") False >>> is_valid_palindrome(\\"no lemon, no melon\\") True >>> is_valid_palindrome(\\"12321\\") True >>> is_valid_palindrome(\\"Was it a car or a cat I saw\\") True >>> is_valid_palindrome(\\"!!x!!\\") True >>> is_valid_palindrome(\\"hello\\") False >>> is_valid_palindrome(\\" \\") True pass def process_test_cases(T: int, test_cases: List[str]) -> List[bool]: Process T test cases and determine if each string is a valid palindrome. >>> process_test_cases(3, [\\"A man, a plan, a canal, Panama!\\", \\"race a car\\", \\"no lemon, no melon\\"]) [True, False, True] >>> process_test_cases(2, [\\"Able, was I ere I saw Elba\\", \\"Madam In Eden, I'm Adam\\"]) [True, True] pass","solution":"def is_valid_palindrome(s): Check if the given string is a valid palindrome after removing all non-alphanumeric characters and converting to lowercase. # Remove non-alphanumeric characters and convert to lowercase cleaned_s = ''.join(ch.lower() for ch in s if ch.isalnum()) # Check if cleaned string is a palindrome return cleaned_s == cleaned_s[::-1] def process_test_cases(T, test_cases): Process T test cases and determine if each string is a valid palindrome. results = [] for s in test_cases: results.append(is_valid_palindrome(s)) return results"},{"question":"def kth_highest_score(N: int, K: int, scores: List[int]) -> int: Returns the Kth highest score from the given list of scores. >>> kth_highest_score(5, 2, [100, 90, 80, 70, 60]) 90 >>> kth_highest_score(4, 1, [50, 30, 40, 20]) 50 >>> kth_highest_score(6, 4, [10, 20, 50, 40, 30, 60]) 30","solution":"def kth_highest_score(N, K, scores): Returns the Kth highest score from the given list of scores. # Sort the scores in descending order sorted_scores = sorted(scores, reverse=True) # Return the score that ranks Kth return sorted_scores[K-1]"},{"question":"def count_trees(n: int, edges: List[Tuple[int, int]]) -> int: Counts the number of distinct labeled trees (using Cayley's formula) after connecting a forest into a single tree. Params: n (int): Number of vertices edges (list): List of tuples representing edges of the initial trees Returns: int: The number of distinct labeled trees Examples: >>> count_trees(5, [(1, 2), (3, 4)]) 60 >>> count_trees(6, [(1, 2), (3, 4), (5, 6)]) 1296 >>> count_trees(4, [(1, 2), (1, 3)]) 16 >>> count_trees(3, [(1, 2)]) 1 >>> count_trees(2, [(1, 1)]) 1","solution":"def count_trees(n, edges): Counts the number of distinct labeled trees (using Cayley's formula) after connecting a forest into a single tree. Params: n (int): Number of vertices edges (list): List of tuples representing edges of the initial trees Returns: int: The number of distinct labeled trees from math import pow # According to Cayley's formula, the number of labeled trees with n vertices is n^(n-2) distinct_trees = pow(n, n - 2) return int(distinct_trees)"},{"question":"def min_unique_participants(T: int, test_cases: List[tuple]) -> List[int]: Determine the minimum number of unique participants needed to ensure all available cookie types are represented. Parameters: - T (int): Number of test cases. - test_cases (list of tuples): Each tuple contains: - N (int): Number of participants. - cookies (list of int): The type of cookies each participant will bring. Returns: - list of int: The minimum number of unique participants needed for each test case. >>> min_unique_participants(2, [(5, [1, 2, 3, 3, 2]), (3, [2, 2, 2])]) [3, 1] >>> min_unique_participants(1, [(4, [1, 1, 1, 1])]) [1] from typing import List def test_min_unique_participants(): assert min_unique_participants(2, [(5, [1, 2, 3, 3, 2]), (3, [2, 2, 2])]) == [3, 1] assert min_unique_participants(1, [(4, [1, 1, 1, 1])]) == [1] assert min_unique_participants(3, [(5, [1, 2, 2, 2, 4]), (6, [6, 5, 6, 1, 5, 1]), (7, [3, 3, 3, 2, 2, 3, 2])]) == [3, 3, 2] assert min_unique_participants(2, [(0, []), (1, [5])]) == [0, 1] # Run tests test_min_unique_participants()","solution":"def min_unique_participants(T, test_cases): Determine the minimum number of unique participants needed to ensure all available cookie types are represented. Parameters: - T (int): Number of test cases. - test_cases (list of tuples): Each tuple contains: - N (int): Number of participants. - cookies (list of int): The type of cookies each participant will bring. Returns: - list of int: The minimum number of unique participants needed for each test case. results = [] for N, cookies in test_cases: unique_cookie_types = len(set(cookies)) results.append(unique_cookie_types) return results"},{"question":"def union_of_intervals(intervals): Returns the length of the union of intervals. Args: intervals (list): List of tuples, each containing two real numbers representing the intervals. Returns: float: Length of the union of intervals. pass # Unit tests def test_union_of_intervals_single_interval(): assert union_of_intervals([(1, 3)]) == 2 def test_union_of_intervals_disjoint_intervals(): assert union_of_intervals([(1, 2), (3, 4)]) == 2 def test_union_of_intervals_overlapping_intervals(): assert union_of_intervals([(1, 3), (2, 4)]) == 3 def test_union_of_intervals_multiple_intervals(): assert union_of_intervals([(1, 3), (2, 4), (5, 6)]) == 4 def test_union_of_intervals_touching_intervals(): assert union_of_intervals([(-1, 0), (0, 1), (1, 2)]) == 3 def test_union_of_intervals_complex_case(): assert union_of_intervals([(0, 1), (2, 6), (3, 4), (7, 8)]) == 6 def test_union_of_intervals_no_intervals(): assert union_of_intervals([]) == 0","solution":"def union_of_intervals(intervals): Returns the length of the union of intervals. Args: intervals (list): List of tuples, each containing two real numbers representing the intervals. Returns: float: Length of the union of intervals. if not intervals: return 0 intervals.sort() merged_intervals = [] current_start, current_end = intervals[0] for start, end in intervals[1:]: if start <= current_end: current_end = max(current_end, end) else: merged_intervals.append((current_start, current_end)) current_start, current_end = start, end merged_intervals.append((current_start, current_end)) union_len = sum(end - start for start, end in merged_intervals) return union_len"},{"question":"class ListNode: def __init__(self, x): self.val = x self.next = None def hasCycle(head): Detects if there is a cycle in the linked list. Parameters: head (ListNode): The head node of the linked list. Returns: bool: True if there is a cycle, False otherwise. >>> head = ListNode(3) >>> second = ListNode(2) >>> third = ListNode(0) >>> fourth = ListNode(-4) >>> head.next = second >>> second.next = third >>> third.next = fourth >>> fourth.next = second >>> hasCycle(head) True >>> head = ListNode(1) >>> second = ListNode(2) >>> head.next = second >>> second.next = head >>> hasCycle(head) True >>> head = ListNode(1) >>> hasCycle(head) False >>> hasCycle(None) False","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def hasCycle(head): Detects if there is a cycle in the linked list. Parameters: head (ListNode): The head node of the linked list. Returns: bool: True if there is a cycle, False otherwise. if not head or not head.next: return False slow = head fast = head.next while slow != fast: if fast is None or fast.next is None: return False slow = slow.next fast = fast.next.next return True"},{"question":"from collections import deque from typing import List def shortest_path_in_maze(N: int, grid: List[List[int]]) -> int: Finds the shortest path in a maze from the top-left to bottom-right corner. Parameters: N (int): Size of the grid (N x N) grid (list of list of int): The grid representation with 0 as empty and 1 as wall Returns: int: The length of the shortest path, or -1 if no such path exists. >>> shortest_path_in_maze(4, [[0, 1, 1, 0], [0, 0, 0, 1], [1, 1, 0, 1], [1, 1, 0, 0]]) 7 >>> shortest_path_in_maze(3, [[0, 1, 0], [1, 1, 0], [0, 0, 0]]) -1","solution":"from collections import deque def shortest_path_in_maze(N, grid): Finds the shortest path in a maze from the top-left to bottom-right corner. Parameters: N (int): Size of the grid (N x N) grid (list of list of int): The grid representation with 0 as empty and 1 as wall Returns: int: The length of the shortest path, or -1 if no such path exists. if grid[0][0] == 1 or grid[N-1][N-1] == 1: return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 1)]) # (row, col, distance) visited = set((0, 0)) while queue: row, col, dist = queue.popleft() if row == N-1 and col == N-1: return dist for d in directions: new_row, new_col = row + d[0], col + d[1] if 0 <= new_row < N and 0 <= new_col < N and (new_row, new_col) not in visited and grid[new_row][new_col] == 0: queue.append((new_row, new_col, dist + 1)) visited.add((new_row, new_col)) return -1"},{"question":"def find_corrupted_or_missing_files(n: int, source_files: List[Tuple[str, str]], m: int, target_files: List[Tuple[str, str]]) -> List[str]: Identify files that are either corrupted or missing on the target device. Args: n (int): Number of files on the source device. source_files (List[Tuple[str, str]]): List of tuples containing filename and hash of source files. m (int): Number of files on the target device. target_files (List[Tuple[str, str]]): List of tuples containing filename and hash of target files. Returns: List[str]: List of filenames that are either corrupted or missing on the target device, sorted lexicographically. Example: >>> find_corrupted_or_missing_files(3, [(\\"file1.txt\\", \\"abc123\\"), (\\"file2.txt\\", \\"def456\\"), (\\"file3.txt\\", \\"ghi789\\")], 2, [(\\"file1.txt\\", \\"abc124\\"), (\\"file2.txt\\", \\"def456\\")]) [\\"file1.txt\\", \\"file3.txt\\"]","solution":"def find_corrupted_or_missing_files(n, source_files, m, target_files): source_dict = {filename: hash_value for filename, hash_value in source_files} target_dict = {filename: hash_value for filename, hash_value in target_files} problematic_files = [] for filename in source_dict: if filename not in target_dict or source_dict[filename] != target_dict[filename]: problematic_files.append(filename) return sorted(problematic_files)"},{"question":"def min_operations(n: int, S: str, T: str) -> int: Determine the minimum number of operations required to transform the binary string S into the binary string T. You can perform the following operations: 1. Flip any single bit (i.e., change a '0' to '1' or a '1' to '0'). 2. Swap any two bits (i.e., exchange the positions of two bits). Args: n (int): The length of the strings S and T. S (str): The initial binary string. T (str): The target binary string. Returns: int: The minimum number of operations required to transform S into T. Examples: >>> min_operations(4, \\"1100\\", \\"1001\\") 2 >>> min_operations(5, \\"10101\\", \\"01010\\") 3 from solution import min_operations def test_min_operations_example_1(): assert min_operations(4, \\"1100\\", \\"1001\\") == 2 def test_min_operations_example_2(): assert min_operations(5, \\"10101\\", \\"01010\\") == 3 def test_min_operations_all_same(): assert min_operations(3, \\"111\\", \\"111\\") == 0 def test_min_operations_all_flips(): assert min_operations(3, \\"000\\", \\"111\\") == 3 def test_min_operations_mixed(): assert min_operations(5, \\"11010\\", \\"00101\\") == 3 def test_min_operations_single_bit(): assert min_operations(1, \\"0\\", \\"1\\") == 1 def test_min_operations_no_flips(): assert min_operations(4, \\"1010\\", \\"1010\\") == 0","solution":"def min_operations(n, S, T): flip_count = 0 swap_count = 0 i = 0 while i < n: if S[i] != T[i]: if i + 1 < n and S[i] != S[i + 1] and T[i] != T[i + 1]: swap_count += 1 i += 1 else: flip_count += 1 i += 1 return flip_count + swap_count"},{"question":"def is_path_possible(N: int, M: int, K: int, restricted_cells: List[Tuple[int, int]]) -> str: Determine if there is a valid path for an observer to move from the top-left corner of the grid (1,1) to the bottom-right corner (N,M). Parameters: N (int): The number of rows in the grid. M (int): The number of columns in the grid. K (int): The number of restricted cells. restricted_cells (List[Tuple[int, int]]): A list of tuples representing the restricted cells. Returns: str: \\"YES\\" if there is a valid path from (1, 1) to (N, M), \\"NO\\" otherwise. Example: >>> is_path_possible(5, 5, 3, [(1, 2), (3, 3), (4, 4)]) 'YES' >>> is_path_possible(3, 3, 4, [(1, 2), (2, 1), (2, 3), (3, 2)]) 'NO' pass # Unit tests def test_is_path_possible(): assert is_path_possible(5, 5, 3, [(1, 2), (3, 3), (4, 4)]) == \\"YES\\" assert is_path_possible(3, 3, 4, [(1, 2), (2, 1), (2, 3), (3, 2)]) == \\"NO\\" assert is_path_possible(1, 1, 0, []) == \\"YES\\" assert is_path_possible(5, 5, 1, [(1, 1)]) == \\"NO\\" assert is_path_possible(2, 2, 1, [(1, 2)]) == \\"YES\\" assert is_path_possible(2, 2, 2, [(1, 2), (2, 1)]) == \\"NO\\" assert is_path_possible(5, 5, 5, [(1, 5), (2, 5), (3, 5), (4, 5), (5, 5)]) == \\"NO\\" if __name__ == \\"__main__\\": test_is_path_possible() print(\\"All tests passed!\\")","solution":"from collections import deque def is_path_possible(N, M, K, restricted_cells): grid = [[0] * M for _ in range(N)] for r, c in restricted_cells: grid[r - 1][c - 1] = 1 if grid[0][0] == 1 or grid[N-1][M-1] == 1: return \\"NO\\" directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0)]) visited = set((0, 0)) while queue: x, y = queue.popleft() if x == N-1 and y == M-1: return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and (nx, ny) not in visited and grid[nx][ny] == 0: visited.add((nx, ny)) queue.append((nx, ny)) return \\"NO\\""},{"question":"def can_assign_all_attendees(n: int, m: int, attendees: List[int], capacities: List[int]) -> str: Determine if it is possible to assign all attendees to the rooms according to their preferences and capacities. >>> can_assign_all_attendees(6, 3, [1, 2, 2, 3, 1, 3], [3, 3, 3]) 'YES' >>> can_assign_all_attendees(5, 2, [1, 1, 2, 2, 1], [2, 2]) 'NO' # Unit Tests from solution import can_assign_all_attendees def test_can_assign_all_attendees_yes_example_1(): assert can_assign_all_attendees(6, 3, [1, 2, 2, 3, 1, 3], [3, 3, 3]) == \\"YES\\" def test_can_assign_all_attendees_no_example_2(): assert can_assign_all_attendees(5, 2, [1, 1, 2, 2, 1], [2, 2]) == \\"NO\\" def test_can_assign_all_attendees_yes_small(): assert can_assign_all_attendees(1, 1, [1], [1]) == \\"YES\\" def test_can_assign_all_attendees_no_small(): assert can_assign_all_attendees(2, 1, [1, 1], [1]) == \\"NO\\" def test_can_assign_all_attendees_yes_large(): assert can_assign_all_attendees( 7, 4, [1, 2, 3, 4, 1, 2, 3], [2, 2, 2, 1] ) == \\"YES\\" def test_can_assign_all_attendees_no_large(): assert can_assign_all_attendees( 7, 3, [1, 1, 2, 2, 3, 3, 1], [2, 2, 3] ) == \\"NO\\"","solution":"def can_assign_all_attendees(n, m, attendees, capacities): # Dictionary to count attendees per room room_attendees = {i: 0 for i in range(1, m + 1)} # Count attendees for each room based on their preferences for attendee in attendees: room_attendees[attendee] += 1 # Check if any room exceeds its maximum capacity for room in range(1, m + 1): if room_attendees[room] > capacities[room - 1]: return \\"NO\\" return \\"YES\\""},{"question":"from collections import defaultdict from typing import List, Tuple def min_edges_to_connect_graph(N: int, M: int, edges: List[Tuple[int, int, int]]) -> int: Calculate the number of ways to add the minimum number of edges to make the graph connected. Parameters: N (int): Number of vertices M (int): Number of edges edges (List[Tuple[int, int, int]]): List of edges, where each edge is represented by a tuple (a, b, W) Returns: int: Number of ways to add the minimum number of edges to make the graph connected Examples: >>> min_edges_to_connect_graph(4, 2, [(1, 2, 1), (3, 4, 1)]) 1 >>> min_edges_to_connect_graph(3, 0, []) 2 >>> min_edges_to_connect_graph(6, 2, [(1, 2, 1), (3, 4, 1)]) 3 >>> min_edges_to_connect_graph(1, 0, []) 0 >>> min_edges_to_connect_graph(3, 3, [(1, 2, 1), (2, 3, 1), (3, 1, 1)]) 0 import sys input = sys.stdin.read def main(): data = input().strip().split() N = int(data[0]) M = int(data[1]) edges = [] if M > 0: index = 2 for _ in range(M): a = int(data[index]) b = int(data[index + 1]) W = int(data[index + 2]) edges.append((a, b, W)) index += 3 print(min_edges_to_connect_graph(N, M, edges)) if __name__ == \\"__main__\\": main()","solution":"from collections import defaultdict def find_connected_components(adj_list, N): visited = [False] * N components = 0 def dfs(node): stack = [node] while stack: v = stack.pop() for neighbor in adj_list[v]: if not visited[neighbor]: visited[neighbor] = True stack.append(neighbor) for i in range(N): if not visited[i]: components += 1 visited[i] = True dfs(i) return components def min_edges_to_connect_graph(N, M, edges): if N == 1: return 0 # Convert to 0-index for easier list manipulation adj_list = defaultdict(list) for a, b, _ in edges: adj_list[a-1].append(b-1) adj_list[b-1].append(a-1) num_components = find_connected_components(adj_list, N) if num_components == 1: return 0 return num_components - 1 import sys input = sys.stdin.read def main(): data = input().strip().split() N = int(data[0]) M = int(data[1]) edges = [] if M > 0: index = 2 for _ in range(M): a = int(data[index]) b = int(data[index + 1]) W = int(data[index + 2]) edges.append((a, b, W)) index += 3 print(min_edges_to_connect_graph(N, M, edges)) if __name__ == \\"__main__\\": main()"},{"question":"def max_candies(n: int, candies: List[int]) -> int: Finds the maximum amount of candies that can be collected starting from any house u to any house v. >>> max_candies(5, [2, 1, 3, 4, 2]) 12 >>> max_candies(3, [0, 2, 9]) 11 >>> max_candies(6, [5, 1, 2, 3, 4, 6]) 21 >>> max_candies(1, [0]) 0 >>> max_candies(1, [10]) 10 >>> max_candies(3, [-2, -3, -1]) -1 >>> max_candies(5, [0, 0, 0, 0, 0]) 0","solution":"def max_candies(n, candies): Finds the maximum amount of candies that can be collected starting from any house u to any house v. max_sum = curr_sum = candies[0] for i in range(1, n): if curr_sum <= 0: curr_sum = candies[i] else: curr_sum += candies[i] max_sum = max(max_sum, curr_sum) return max_sum"},{"question":"def min_blocks_needed(T: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Determine the minimum number of blocks needed to reach or exceed a certain target height H. Args: T (int): The number of test cases. test_cases (List[Tuple[int, int, List[int]]]): A list where each element is a tuple containing - N (int): The number of blocks. - H (int): The target height. - heights (List[int]): The heights of the blocks. Returns: List[int]: A list of integers where each element is the minimum number of blocks needed to reach or exceed the target height for each test case or -1 if it is not possible. Example: >>> min_blocks_needed(3, [(5, 29, [2, 3, 7, 10, 14]), (4, 15, [1, 5, 5, 5]), (3, 20, [8, 4, 7])]) [3, 3, -1] from solution import min_blocks_needed def test_example_cases(): cases = [ (3, [ (5, 29, [2, 3, 7, 10, 14]), (4, 15, [1, 5, 5, 5]), (3, 20, [8, 4, 7]) ]), ] expected = [ [3, 3, -1] ] for i, (T, test_cases) in enumerate(cases): assert min_blocks_needed(T, test_cases) == expected[i] def test_reach_exact_height(): T = 1 test_cases = [ (5, 15, [1, 2, 3, 4, 5]) ] expected = [5] assert min_blocks_needed(T, test_cases) == expected def test_all_blocks_needed(): T = 1 test_cases = [ (5, 15, [3, 3, 3, 3, 3]) ] expected = [5] assert min_blocks_needed(T, test_cases) == expected def test_large_blocks(): T = 1 test_cases = [ (4, 20, [10, 10, 1, 1]) ] expected = [2] assert min_blocks_needed(T, test_cases) == expected def test_insufficient_blocks(): T = 1 test_cases = [ (3, 100, [10, 20, 30]) ] expected = [-1] assert min_blocks_needed(T, test_cases) == expected def test_single_block_enough(): T = 1 test_cases = [ (1, 7, [10]) ] expected = [1] assert min_blocks_needed(T, test_cases) == expected","solution":"def min_blocks_needed(T, test_cases): results = [] for i in range(T): N, H, heights = test_cases[i] heights.sort(reverse=True) total_height = 0 num_blocks = 0 for height in heights: total_height += height num_blocks += 1 if total_height >= H: break if total_height >= H: results.append(num_blocks) else: results.append(-1) return results"},{"question":"from typing import List, Dict def shortest_path(graph: Dict[int, List[int]], start: int, end: int) -> List[int]: Find the shortest path between two nodes in an undirected graph represented as an adjacency list. >>> shortest_path({0: [1, 2], 1: [0, 3], 2: [0, 3], 3: [1, 2]}, 0, 3) in [[0, 1, 3], [0, 2, 3]] True >>> shortest_path({0: [1], 1: [0, 2], 2: [1, 3], 3: [2]}, 0, 3) [0, 1, 2, 3] >>> shortest_path({0: [1], 1: [0], 2: [3], 3: [2]}, 0, 3) [] >>> shortest_path({0: [1, 2], 1: [0, 3], 2: [0, 3], 3: [1, 2]}, 0, 0) [0]","solution":"from collections import deque from typing import List, Dict def shortest_path(graph: Dict[int, List[int]], start: int, end: int) -> List[int]: if start == end: return [start] # Using a queue for BFS queue = deque([[start]]) visited = set() visited.add(start) while queue: path = queue.popleft() node = path[-1] if node == end: return path for neighbor in graph.get(node, []): if neighbor not in visited: visited.add(neighbor) new_path = list(path) new_path.append(neighbor) queue.append(new_path) return []"},{"question":"def max_stones(m, n, grid): Returns the maximum number of magical stones that can be collected from the top-left corner to the bottom-right corner of the grid. def process_input(input_str): Processes the input string and returns the results for each test case. from solution import max_stones, process_input def test_max_stones(): grid1 = [ [1, 3], [2, 4] ] assert max_stones(2, 2, grid1) == 8 grid2 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert max_stones(3, 3, grid2) == 29 grid3 = [ [0, 0], [0, 0] ] assert max_stones(2, 2, grid3) == 0 def test_process_input(): input_str = \\"2nn2 2n1 3n2 4nn3 3n1 2 3n4 5 6n7 8 9n\\" assert process_input(input_str) == [8, 29] input_str = \\"1nn2 2n0 0n0 0n\\" assert process_input(input_str) == [0]","solution":"def max_stones(m, n, grid): Returns the maximum number of magical stones that can be collected from the top-left corner to the bottom-right corner of the grid. # Create a DP table to store the max stones collectible at each cell dp = [[0] * n for _ in range(m)] # Initialize the top-left cell with the number of stones it has dp[0][0] = grid[0][0] # Fill the dp table for i in range(m): for j in range(n): if i > 0: dp[i][j] = max(dp[i][j], dp[i-1][j] + grid[i][j]) if j > 0: dp[i][j] = max(dp[i][j], dp[i][j-1] + grid[i][j]) # The value at the bottom-right corner is the maximum stones collectible return dp[m-1][n-1] def process_input(input_str): Processes the input string and returns the results for each test case. lines = input_str.strip().split('n') T = int(lines[0]) results = [] index = 1 for _ in range(T): if lines[index] == '': index += 1 m, n = map(int, lines[index].split()) index += 1 grid = [] for _ in range(m): row = list(map(int, lines[index].split())) index += 1 grid.append(row) results.append(max_stones(m, n, grid)) return results"},{"question":"def longest_palindromic_subsequence(s: str) -> int: Returns the length of the longest palindromic subsequence in the given string s. >>> longest_palindromic_subsequence(\\"bbbab\\") 4 >>> longest_palindromic_subsequence(\\"cbbd\\") 2 def solve(test_cases: List[str]) -> List[int]: Takes a list of test case strings and returns a list of integers representing the length of the longest palindromic subsequence for each string. >>> solve([\\"bbbab\\", \\"cbbd\\"]) [4, 2]","solution":"def longest_palindromic_subsequence(s): Returns the length of the longest palindromic subsequence in the given string s. n = len(s) dp = [[0] * n for _ in range(n)] for i in range(n-1, -1, -1): dp[i][i] = 1 for j in range(i+1, n): if s[i] == s[j]: dp[i][j] = dp[i+1][j-1] + 2 else: dp[i][j] = max(dp[i+1][j], dp[i][j-1]) return dp[0][n-1] def solve(test_cases): results = [] for s in test_cases: results.append(longest_palindromic_subsequence(s)) return results"},{"question":"def min_platforms(n: int, schedule: List[Tuple[int, int]]) -> int: Calculate the minimum number of platforms required at a railway station. Args: n (int): Number of trains. schedule (List[Tuple[int, int]]): A list of tuples where each tuple contains two time values representing the arrival and departure time of a train. Returns: int: Minimum number of platforms required. Examples: >>> min_platforms(3, [(900, 930), (940, 950), (920, 935)]) 2 >>> min_platforms(4, [(1000, 1030), (1015, 1040), (1020, 1045), (1035, 1100)]) 3","solution":"def min_platforms(n, schedule): # Convert schedule into sorted arrival and departure lists arrivals = sorted([train[0] for train in schedule]) departures = sorted([train[1] for train in schedule]) platforms_needed = 0 max_platforms = 0 i = 0 j = 0 # Traverse the arrival and departure events while i < n and j < n: if arrivals[i] < departures[j]: platforms_needed += 1 max_platforms = max(max_platforms, platforms_needed) i += 1 else: platforms_needed -= 1 j += 1 return max_platforms"},{"question":"def can_rearrange(S: str, K: int) -> str: Determine if it is possible to rearrange S such that there are at least K unique characters in each contiguous substring of length K. >>> can_rearrange(\\"aabbcc\\", 3) 'YES' >>> can_rearrange(\\"aaabbcc\\", 4) 'NO' from solution import can_rearrange def test_1(): assert can_rearrange(\\"aabbcc\\", 3) == \\"YES\\" def test_2(): assert can_rearrange(\\"aaabbcc\\", 4) == \\"NO\\" def test_3(): assert can_rearrange(\\"abcde\\", 5) == \\"YES\\" def test_4(): assert can_rearrange(\\"abcde\\", 6) == \\"NO\\" def test_5(): assert can_rearrange(\\"ab\\", 1) == \\"YES\\" assert can_rearrange(\\"ab\\", 2) == \\"YES\\" def test_6(): assert can_rearrange(\\"a\\" * 100000, 1) == \\"YES\\" assert can_rearrange(\\"a\\" * 100000, 2) == \\"NO\\" def test_7(): assert can_rearrange(\\"abcdefghijkl\\", 12) == \\"YES\\" def test_8(): assert can_rearrange(\\"zzzzzzzzzz\\", 1) == \\"YES\\" assert can_rearrange(\\"zzzzzzzzzz\\", 2) == \\"NO\\"","solution":"def can_rearrange(S, K): Determine if it is possible to rearrange S such that there are at least K unique characters in each contiguous substring of length K. from collections import Counter if len(S) < K: return \\"NO\\" freq = Counter(S) # The number of distinct characters in the string distinct_char_count = len(freq) # If there are not enough distinct characters to satisfy any substring of length K, return NO if distinct_char_count < K: return \\"NO\\" return \\"YES\\""},{"question":"import math def largest_tile_size(n: int, m: int) -> int: Return the side length a of the largest possible square tile that can be used to completely cover the rectangle of size n x m without any gaps or overlapping. >>> largest_tile_size(10, 15) 5 >>> largest_tile_size(24, 18) 6 >>> largest_tile_size(7, 5) 1","solution":"import math def largest_tile_size(n, m): Return the side length a of the largest possible square tile that can be used to completely cover the rectangle of size n x m without any gaps or overlapping. return math.gcd(n, m)"},{"question":"def generate_spiral_matrix(n: int) -> List[List[int]]: Generates an n x n matrix filled with elements from 1 to n^2 in a spiral order (clockwise). >>> generate_spiral_matrix(1) == [[1]] >>> generate_spiral_matrix(2) == [ [1, 2], [4, 3] ] >>> generate_spiral_matrix(3) == [ [1, 2, 3], [8, 9, 4], [7, 6, 5] ] >>> generate_spiral_matrix(4) == [ [1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7] ] >>> generate_spiral_matrix(5) == [ [1, 2, 3, 4, 5], [16, 17, 18, 19, 6], [15, 24, 25, 20, 7], [14, 23, 22, 21, 8], [13, 12, 11, 10, 9] ]","solution":"def generate_spiral_matrix(n): Generates an n x n matrix filled with elements from 1 to n^2 in a spiral order (clockwise). if n < 1 or n > 9: raise ValueError(\\"n must be between 1 and 9 inclusive.\\") matrix = [[0] * n for _ in range(n)] num = 1 left, right, top, bottom = 0, n - 1, 0, n - 1 while left <= right and top <= bottom: # Top row for i in range(left, right + 1): matrix[top][i] = num num += 1 top += 1 # Right column for i in range(top, bottom + 1): matrix[i][right] = num num += 1 right -= 1 # Bottom row if top <= bottom: for i in range(right, left - 1, -1): matrix[bottom][i] = num num += 1 bottom -= 1 # Left column if left <= right: for i in range(bottom, top - 1, -1): matrix[i][left] = num num += 1 left += 1 return matrix"}]`),S={name:"App",components:{PoemCard:R},data(){return{searchQuery:"",visibleCount:4,poemsData:A,isLoading:!1}},computed:{filteredPoems(){const i=this.searchQuery.trim().toLowerCase();return i?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(i)||e.solution&&e.solution.toLowerCase().includes(i)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(i=>setTimeout(i,1e3)),this.visibleCount+=4,this.isLoading=!1}}},j={class:"search-container"},P={class:"card-container"},D={key:0,class:"empty-state"},z=["disabled"],O={key:0},C={key:1};function M(i,e,u,c,r,a){const p=h("PoemCard");return s(),n("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"prompts chat")])],-1)),t("div",j,[e[3]||(e[3]=t("span",{class:"search-icon"},"",-1)),g(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>r.searchQuery=o),placeholder:"Search..."},null,512),[[b,r.searchQuery]]),r.searchQuery?(s(),n("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>r.searchQuery="")},"  ")):l("",!0)]),t("div",P,[(s(!0),n(y,null,x(a.displayedPoems,(o,f)=>(s(),v(p,{key:f,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(s(),n("div",D,' No results found for "'+m(r.searchQuery)+'". ',1)):l("",!0)]),a.hasMorePoems?(s(),n("button",{key:0,class:"load-more-button",disabled:r.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[r.isLoading?(s(),n("span",C,"Loading...")):(s(),n("span",O,"See more"))],8,z)):l("",!0)])}const Y=d(S,[["render",M],["__scopeId","data-v-25882f1a"]]),B=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"guide/12.md","filePath":"guide/12.md"}'),F={name:"guide/12.md"},U=Object.assign(F,{setup(i){return(e,u)=>(s(),n("div",null,[w(Y)]))}});export{B as __pageData,U as default};
