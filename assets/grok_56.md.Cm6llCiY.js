import{_ as c,o as s,c as r,a as t,m,t as d,C as p,M as g,U as b,f as u,F as w,p as v,e as x,q as y}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},q={class:"poem-container"},T={class:"review"},L={class:"review-title"},R={class:"review-content"};function A(n,e,l,_,i,a){return s(),r("div",q,[t("div",T,[t("div",L,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),m(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",R,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),m(d(l.poem.solution),1)])])])}const N=c(k,[["render",A],["__scopeId","data-v-cd41531c"]]),j=JSON.parse(`[{"question":"cpp class ListNode { public: int val; ListNode* next; ListNode(int x) : val(x), next(nullptr) {} }; ListNode* reverseSecondHalf(ListNode* head); /** * Given a linked list, reverse the second half of the list and return the head of the updated list. * * @param head the head of the input linked list * @return the head of the modified linked list * * Example: * Input: 1 -> 2 -> 3 -> 4 -> 5 -> 6 * Output: 1 -> 2 -> 3 -> 6 -> 5 -> 4 * * Input: 1 -> 2 -> 3 -> 4 -> 5 * Output: 1 -> 2 -> 3 -> 5 -> 4 */","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def reverseSecondHalf(head): # Find the middle of the list using the slow and fast pointers. slow, fast = head, head prev = None while fast and fast.next: prev = slow slow = slow.next fast = fast.next.next # If the list has odd number of nodes, move slow one step further. if fast: prev = slow slow = slow.next # Start reversing from slow. prev.next = None # break the list into two parts prev = None curr = slow while curr: next_node = curr.next curr.next = prev prev = curr curr = next_node # Link the first half with the reversed second half. tail = head while tail.next: tail = tail.next tail.next = prev return head"},{"question":"def longest_substring_with_k_distinct(s: str, k: int) -> int: Find the length of the longest substring with exactly k distinct characters. >>> longest_substring_with_k_distinct(\\"eceba\\", 2) 3 >>> longest_substring_with_k_distinct(\\"aa\\", 1) 2 # Your implementation here pass Example Usage: print(longest_substring_with_k_distinct(\\"eceba\\", 2)) # Output: 3 print(longest_substring_with_k_distinct(\\"aa\\", 1)) # Output: 2 Unit Test: from solution import longest_substring_with_k_distinct def test_example_cases(): assert longest_substring_with_k_distinct(\\"eceba\\", 2) == 3 assert longest_substring_with_k_distinct(\\"aa\\", 1) == 2 def test_edge_cases(): assert longest_substring_with_k_distinct(\\"\\", 1) == 0 assert longest_substring_with_k_distinct(\\"a\\", 0) == 0 def test_general_cases(): assert longest_substring_with_k_distinct(\\"abcba\\", 2) == 3 assert longest_substring_with_k_distinct(\\"aabbcc\\", 2) == 4 assert longest_substring_with_k_distinct(\\"aabbcc\\", 1) == 2 assert longest_substring_with_k_distinct(\\"aabacbebebe\\", 3) == 7 def test_large_k_value(): assert longest_substring_with_k_distinct(\\"abracadabra\\", 5) == 11 def test_all_same_characters(): assert longest_substring_with_k_distinct(\\"aaaaaa\\", 1) == 6 def test_distinct_chars(): assert longest_substring_with_k_distinct(\\"abcdef\\", 6) == 6 assert longest_substring_with_k_distinct(\\"abcdef\\", 3) == 3 assert longest_substring_with_k_distinct(\\"abcdef\\", 1) == 1","solution":"def longest_substring_with_k_distinct(s: str, k: int) -> int: from collections import defaultdict if k == 0: return 0 window_start = 0 max_length = 0 char_frequency = defaultdict(int) for window_end in range(len(s)): right_char = s[window_end] char_frequency[right_char] += 1 while len(char_frequency) > k: left_char = s[window_start] char_frequency[left_char] -= 1 if char_frequency[left_char] == 0: del char_frequency[left_char] window_start += 1 max_length = max(max_length, window_end - window_start + 1) return max_length"},{"question":"def decodeString(s: str) -> str: Decodes the given encoded string according to the rule k[encoded_string], where the encoded_string inside the square brackets is repeated exactly k times. >>> decodeString(\\"3[a]\\") == \\"aaa\\" >>> decodeString(\\"3[a]2[bc]\\") == \\"aaabcbc\\" >>> decodeString(\\"3[a2[c]]\\") == \\"accaccacc\\" >>> decodeString(\\"2[abc]3[cd]ef\\") == \\"abcabccdcdcdef\\"","solution":"def decodeString(s: str) -> str: Decodes the given encoded string according to the rule k[encoded_string], where the encoded_string inside the square brackets is repeated exactly k times. stack = [] current_num = 0 current_string = '' for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == '[': stack.append((current_string, current_num)) current_string = '' current_num = 0 elif char == ']': prev_string, num = stack.pop() current_string = prev_string + num * current_string else: current_string += char return current_string"},{"question":"def find_nth_in_sequence(n: int) -> int: Returns the value at the nth position in the sequence defined as: 1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5, ... where the integer m occurs m times consecutively. Args: n (int): The position in the sequence (1 <= n <= 10^9) Returns: int: The value at the nth position Examples: >>> find_nth_in_sequence(1) 1 >>> find_nth_in_sequence(3) 2 >>> find_nth_in_sequence(10) 4 >>> find_nth_in_sequence(15) 5 # Your implementation here def test_find_nth_in_sequence(): assert find_nth_in_sequence(1) == 1 assert find_nth_in_sequence(2) == 2 assert find_nth_in_sequence(3) == 2 assert find_nth_in_sequence(4) == 3 assert find_nth_in_sequence(10) == 4 assert find_nth_in_sequence(15) == 5 assert find_nth_in_sequence(21) == 6 assert find_nth_in_sequence(28) == 7 assert find_nth_in_sequence(36) == 8 assert find_nth_in_sequence(5050) == 100 assert find_nth_in_sequence(5000000) == 3162","solution":"def find_nth_in_sequence(n): Returns the value at the nth position in the sequence defined as: 1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5, ... where the integer m occurs m times consecutively. k = 1 # current integer in the sequence total_numbers = 0 # total numbers counted so far while True: total_numbers += k if n <= total_numbers: return k k += 1"},{"question":"def count_max_cells(m: int, n: int, k: int, updates: List[Tuple[int, int]]) -> int: Construct the m x n grid and perform the k updates, then find and return the number of cells containing the maximum value. >>> count_max_cells(3, 3, 4, [(0, 0), (1, 1), (2, 2), (1, 2)]) == 1 >>> count_max_cells(3, 3, 0, []) == 9 >>> count_max_cells(3, 3, 1, [(1, 1)]) == 1 >>> count_max_cells(3, 3, 3, [(1, 1), (1, 1), (1, 1)]) == 1 >>> count_max_cells(3, 4, 4, [(0, 0), (0, 1), (1, 0), (1, 1)]) == 4 >>> count_max_cells(2, 2, 4, [(0, 0), (1, 1), (0, 1), (1, 0)]) == 4","solution":"def count_max_cells(m, n, k, updates): Constructs the m x n grid and performs the k updates, then finds and returns the number of cells containing the maximum value. # Initialize row and column counters row_increments = [0] * m column_increments = [0] * n # Apply each update for (i, j) in updates: row_increments[i] += 1 column_increments[j] += 1 # Find the maximum values in row and column increments max_row_inc = max(row_increments) max_col_inc = max(column_increments) # Count the number of rows and columns with the maximum increments max_rows = sum(1 for r in row_increments if r == max_row_inc) max_cols = sum(1 for c in column_increments if c == max_col_inc) # The number of cells with the maximum value is the product of these counts return max_rows * max_cols"},{"question":"def divide_list(lst: list[int], divisor: int) -> list[float] or None: Divides each element in the \`lst\` by \`divisor\` and returns the resultant list. If division by zero is encountered, return None. Args: lst (list of int): The list of integers to be divided. divisor (int): The divisor to divide each element by. Returns: list of float or None: A new list with each element divided by the divisor, or None if division by zero. Examples: >>> divide_list([4, 8, 12, 16], 2) [2, 4, 6, 8] >>> divide_list([-6, -12, -18], -3) [2, 4, 6] >>> divide_list([1, 2, 3], 0) None","solution":"def divide_list(lst, divisor): Divides each element in lst by divisor and returns the resultant list. If division by zero is encountered, return None. Args: lst (list of int): The list of integers to be divided. divisor (int): The divisor to divide each element by. Returns: list of float or None: A new list with each element divided by the divisor, or None if division by zero. if divisor == 0: return None return [x / divisor for x in lst]"},{"question":"def construct_number(n: int) -> str: Given an integer n, construct an n-digit number such that the sum of its digits is exactly n and no digit is zero. Determine the lexicographically smallest n-digit number with this property. Parameters: n (int): The number of digits and the wanted sum of the digits (1 ≤ n ≤ 10^6). Returns: str: The smallest n-digit number where the sum of its digits is exactly n and no digit is zero. If no such number exists, return '-1'. Examples: >>> construct_number(5) '11111' >>> construct_number(15) '111111111111111' >>> construct_number(3) '111' >>> construct_number(0) '-1' >>> construct_number(-5) '-1'","solution":"def construct_number(n): Returns the smallest n-digit number where the sum of its digits is exactly n and no digit is zero. If no such number exists, return -1. if n < 1: return -1 return '1' * n"},{"question":"def material_usage(surfboards: List[dict], material: str) -> int: Calculates the total usage of a specific material given a list of surfboards. Args: surfboards (list of dict): List of dictionaries, each representing a surfboard and its materials. material (str): The material name for which the usage needs to be calculated. Returns: int: The total quantity of the specified material used across all surfboards. >>> surfboards = [ ... {\\"fiberglass\\": 10, \\"resin\\": 5, \\"foam\\": 20}, ... {\\"fiberglass\\": 12, \\"resin\\": 7, \\"foam\\": 22}, ... {\\"fiberglass\\": 8, \\"resin\\": 6, \\"foam\\": 18}, ... ] >>> material_usage(surfboards, \\"fiberglass\\") 30 >>> material_usage(surfboards, \\"stringer\\") 0","solution":"def material_usage(surfboards, material): Calculates the total usage of a specific material given a list of surfboards. Args: surfboards (list of dict): List of dictionaries, each representing a surfboard and its materials. material (str): The material name for which the usage needs to be calculated. Returns: int: The total quantity of the specified material used across all surfboards. return sum(surfboard.get(material, 0) for surfboard in surfboards)"},{"question":"def findLongestPalindrome(s: str) -> str: Find the longest palindromic substring within a given string. >>> findLongestPalindrome(\\"babad\\") in {\\"bab\\", \\"aba\\"} True >>> findLongestPalindrome(\\"cbbc\\") == \\"cbbc\\" True >>> findLongestPalindrome(\\"\\") == \\"\\" True >>> findLongestPalindrome(\\"a\\") == \\"a\\" True >>> findLongestPalindrome(\\"bb\\") == \\"bb\\" True >>> findLongestPalindrome(\\"abc\\") == \\"a\\" True >>> findLongestPalindrome(\\"abacdfgdcabad\\") == \\"aba\\" True >>> findLongestPalindrome(\\"madam\\") == \\"madam\\" True","solution":"def findLongestPalindrome(s): if not s: return \\"\\" start, end = 0, 0 def expandAroundCenter(s, left, right): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return left + 1, right - 1 for i in range(len(s)): l1, r1 = expandAroundCenter(s, i, i) # odd length palindrome l2, r2 = expandAroundCenter(s, i, i + 1) # even length palindrome if r1 - l1 > end - start: start, end = l1, r1 if r2 - l2 > end - start: start, end = l2, r2 return s[start:end + 1]"},{"question":"def squares_of_positive_integers(integers_list): Returns a list containing squares of all positive integers from the original list. Args: integers_list (list): The list of integers. Returns: list: A list containing the squares of positive integers. Examples: >>> squares_of_positive_integers([1, 2, 3, 4, 5]) [1, 4, 9, 16, 25] >>> squares_of_positive_integers([1, -2, 3, -4, 5]) [1, 9, 25] >>> squares_of_positive_integers([-1, -2, -3, -4, -5]) [] >>> squares_of_positive_integers([0, 1, 0, 2, 0]) [1, 4] >>> squares_of_positive_integers([0, -2, 0, -4, 0]) [] >>> squares_of_positive_integers([]) []","solution":"def squares_of_positive_integers(integers_list): Returns a list containing squares of all positive integers from the original list. Args: integers_list (list): The list of integers. Returns: list: A list containing the squares of positive integers. return [x**2 for x in integers_list if x > 0]"},{"question":"from typing import List def maxProfit(prices: List[int]) -> int: Given an array of integers where each integer represents the price of a stock on a given day, you want to maximize your profit by choosing a single day to buy one stock and a different day in the future to sell that stock. Write a function that takes in the array of stock prices and returns the maximum profit you can achieve from this transaction. If there is no possible way to achieve profit, return 0. >>> maxProfit([7, 1, 5, 3, 6, 4]) 5 >>> maxProfit([7, 6, 4, 3, 1]) 0 >>> maxProfit([1, 2]) 1 >>> maxProfit([-1, -5, -10, -15, 100]) 115 >>> maxProfit([10**5, 10**6, 10**7, 10**8, 10**9]) 999900000","solution":"from typing import List def maxProfit(prices: List[int]) -> int: This function calculates the maximum profit you can achieve by buying and selling one share of the stock. if not prices or len(prices) < 2: return 0 min_price = prices[0] max_profit = 0 for price in prices[1:]: # Update the min_price to the lowest price encountered so far if price < min_price: min_price = price else: # Calculate the profit if sold at the current price profit = price - min_price # Update the max_profit if the current profit is higher than the max_profit so far if profit > max_profit: max_profit = profit return max_profit"},{"question":"def countVowels(s: str) -> int: Returns the number of vowels (a, e, i, o, u) in the given string. >>> countVowels('hello world') 3 >>> countVowels('aeiouAEIOU') 10 >>> countVowels('bcdfg') 0 >>> countVowels('HeLLo WoRLD') 3 >>> countVowels('') 0 >>> countVowels('12345!@#%') 0 >>> countVowels('a1e2i3o4u!') 5 # Your code here","solution":"def countVowels(s): Returns the number of vowels in the given string. vowels = 'aeiouAEIOU' return sum(1 for char in s if char in vowels)"},{"question":"from typing import List def evaluate_expression(expression: str) -> str: Evaluates a simple arithmetic expression and returns the result as a string rounded to two decimal places. The input string will only contain digits (0-9), arithmetic operators (+, -, *, /), and possibly whitespace characters. >>> evaluate_expression(\\"3 + 5 / 2\\") '5.5' >>> evaluate_expression(\\"10 - 6 * 0.5\\") '7' >>> evaluate_expression(\\"15 + 3 * 6 / 2 - 4\\") '20.0'","solution":"def evaluate_expression(expression): Evaluates a simple arithmetic expression and returns the result as a string rounded to two decimal places. # Remove whitespace expression = expression.replace(\\" \\", \\"\\") try: # Calculate the result using eval result = eval(expression) # Round the result to 2 decimal places and remove any trailing .0 result = round(result, 2) result_str = f\\"{result:.2f}\\".rstrip('0').rstrip('.') return result_str except Exception as e: return str(e)"},{"question":"def check_inclusion(s1: str, s2: str) -> bool: Check if any permutation of s1 is a substring of s2. >>> check_inclusion(\\"ab\\", \\"eidbaooo\\") True >>> check_inclusion(\\"ab\\", \\"eidboaoo\\") False >>> check_inclusion(\\"adc\\", \\"dcda\\") True >>> check_inclusion(\\"ab\\", \\"a\\") False from collections import Counter def test_check_inclusion_example1(): assert check_inclusion(\\"ab\\", \\"eidbaooo\\") == True def test_check_inclusion_example2(): assert check_inclusion(\\"ab\\", \\"eidboaoo\\") == False def test_check_inclusion_example3(): assert check_inclusion(\\"adc\\", \\"dcda\\") == True def test_check_inclusion_example4(): assert check_inclusion(\\"ab\\", \\"a\\") == False def test_check_inclusion_identical(): assert check_inclusion(\\"hello\\", \\"hello\\") == True def test_check_inclusion_non_matching_length(): assert check_inclusion(\\"longerstring\\", \\"short\\") == False def test_check_inclusion_empty_s1(): assert check_inclusion(\\"\\", \\"anystring\\") == True def test_check_inclusion_empty_s2(): assert check_inclusion(\\"anystring\\", \\"\\") == False def test_check_inclusion_single_character(): assert check_inclusion(\\"a\\", \\"a\\") == True assert check_inclusion(\\"a\\", \\"b\\") == False assert check_inclusion(\\"a\\", \\"aa\\") == True assert check_inclusion(\\"a\\", \\"ab\\") == True assert check_inclusion(\\"a\\", \\"ba\\") == True","solution":"def check_inclusion(s1, s2): Returns true if any permutation of s1 is a substring of s2. from collections import Counter len_s1, len_s2 = len(s1), len(s2) if len_s1 > len_s2: return False s1_counter = Counter(s1) window_counter = Counter(s2[:len_s1]) if s1_counter == window_counter: return True for i in range(len_s1, len_s2): window_counter[s2[i]] += 1 window_counter[s2[i - len_s1]] -= 1 if window_counter[s2[i - len_s1]] == 0: del window_counter[s2[i - len_s1]] if s1_counter == window_counter: return True return False"},{"question":"from typing import List, Tuple def min_cost_of_three_items(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Finds the minimum cost of buying exactly three items from the shop for each test case. >>> min_cost_of_three_items([(5, [1, 2, 3, 4, 5]), (3, [10, 20, 30])]) [6, 60] >>> min_cost_of_three_items([(4, [4, 2, 1, 3])]) [6] >>> min_cost_of_three_items([(6, [1, 1, 1, 1, 1, 1])]) [3] >>> min_cost_of_three_items([(5, [1000000000, 1000000000, 1000000000, 1000000000, 1000000000])]) [3000000000] >>> min_cost_of_three_items([(5, [5, 3, 2, 8, 7])]) [10] def parse_input(input_string: str) -> List[Tuple[int, List[int]]]: Parses the input string containing multiple test cases. >>> parse_input(\\"2n5n1 2 3 4 5n3n10 20 30\\") [(5, [1, 2, 3, 4, 5]), (3, [10, 20, 30])] >>> parse_input(\\"1n4n4 2 1 3\\") [(4, [4, 2, 1, 3])] >>> parse_input(\\"1n6n1 1 1 1 1 1\\") [(6, [1, 1, 1, 1, 1, 1])] >>> parse_input(\\"1n5n1000000000 1000000000 1000000000 1000000000 1000000000\\") [(5, [1000000000, 1000000000, 1000000000, 1000000000, 1000000000])] >>> parse_input(\\"1n5n5 3 2 8 7\\") [(5, [5, 3, 2, 8, 7])]","solution":"def min_cost_of_three_items(test_cases): result = [] for n, prices in test_cases: prices.sort() result.append(sum(prices[:3])) return result def parse_input(input_string): lines = input_string.strip().split('n') t = int(lines[0]) test_cases = [] index = 1 for _ in range(t): n = int(lines[index]) prices = list(map(int, lines[index + 1].split())) test_cases.append((n, prices)) index += 2 return test_cases"},{"question":"def transform_sequence(S: str) -> str: Transforms the sequence based on the given operations, replacing 'AB' with 'AA' and 'BA' with 'BB', until no more replacements can be made. >>> transform_sequence(\\"AAB\\") == \\"AAA\\" >>> transform_sequence(\\"BABA\\") == \\"BBBB\\" >>> transform_sequence(\\"ABAB\\") == \\"AAAA\\"","solution":"def transform_sequence(S: str) -> str: Transforms the sequence based on the given operations, replacing 'AB' with 'AA' and 'BA' with 'BB', until no more replacements can be made. # Continue until no more changes can be performed while True: new_S = S.replace('AB', 'AA').replace('BA', 'BB') if new_S == S: # If no further changes, break the loop break S = new_S return S"},{"question":"def can_schedule_judges(n, m, availability): Determine if it is possible to assign judges such that no judge oversees two consecutive matches. Args: n (int): The number of matches. m (int): The number of judges. availability (List[Tuple[int, int]]): Each pair (a_i, b_i) representing that the i-th judge is available from match a_i to match b_i (inclusive). Returns: str: \\"YES\\" if it is possible to assign judges such that no judge oversees two consecutive matches, otherwise \\"NO\\". Example: >>> can_schedule_judges(4, 3, [(1, 2), (2, 3), (3, 4)]) 'YES' >>> can_schedule_judges(4, 2, [(1, 2), (3, 4)]) 'NO' pass def test_example_case(): assert can_schedule_judges(4, 3, [(1, 2), (2, 3), (3, 4)]) == \\"YES\\" def test_no_overlap(): assert can_schedule_judges(4, 2, [(1, 2), (3, 4)]) == \\"NO\\" def test_single_judge_enough(): assert can_schedule_judges(4, 1, [(1, 4)]) == \\"YES\\" def test_minimum_input(): assert can_schedule_judges(1, 1, [(1, 1)]) == \\"YES\\" def test_unavailable_judge(): assert can_schedule_judges(3, 2, [(1, 1), (3, 3)]) == \\"NO\\"","solution":"def can_schedule_judges(n, m, availability): from collections import defaultdict # Create a dictionary of availability match_judges = defaultdict(list) for i, (start, end) in enumerate(availability): for match in range(start, end + 1): match_judges[match].append(i) # Check each match and its consecutive for i in range(1, n): if not set(match_judges[i]) & set(match_judges[i + 1]): return \\"NO\\" return \\"YES\\" # Example input n = 4 m = 3 availability = [(1, 2), (2, 3), (3, 4)] print(can_schedule_judges(n, m, availability)) # Output should be \\"YES\\""},{"question":"def has_duplicates_within_range(timestamps: List[int], k: int) -> bool: Checks if there are duplicate timestamps within the given range k. Args: timestamps: List[int] - A list of timestamps in non-decreasing order. k: int - The specified time range. Returns: bool - True if there are duplicates within range k, else False. def process_photo_timestamps(T: int, cases: List[Tuple[int, List[int], int]]) -> List[str]: Processes multiple test cases to determine if there are duplicates within the given time range k. Args: T: int - Number of test cases. cases: List[Tuple[int, List[int], int]] - List of test cases where each test case is a tuple of the number of photos, the timestamps list, and the time range k. Returns: List[str] - A list of results for each test case, each being either \\"YES\\" or \\"NO\\".","solution":"def has_duplicates_within_range(timestamps, k): Checks if there are duplicate timestamps within the given range k. Args: timestamps: List[int] - A list of timestamps in non-decreasing order. k: int - The specified time range. Returns: bool - True if there are duplicates within range k, else False. n = len(timestamps) for i in range(n - 1): if timestamps[i] != timestamps[i + 1]: continue if timestamps[i + 1] - timestamps[i] <= k: return True return False def process_photo_timestamps(T, cases): Processes multiple test cases to determine if there are duplicates within the given time range k. Args: T: int - Number of test cases. cases: List[Tuple[int, List[int], int]] - List of test cases where each test case is a tuple of the number of photos, the timestamps list, and the time range k. Returns: List[str] - A list of results for each test case, each being either \\"YES\\" or \\"NO\\". results = [] for case in cases: n, timestamps, k = case if has_duplicates_within_range(timestamps, k): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def most_frequent_smallest_element(arr: List[int]) -> int: Given an array of integers, find the most frequent element. If there are multiple elements with the same highest frequency, return the smallest one. >>> most_frequent_smallest_element([1, 3, 2, 3, 3, 1, 2, 2, 2, 4]) 2 >>> most_frequent_smallest_element([5, 5, 4, 6, 6, 6, 4, 5, 4]) 4 >>> most_frequent_smallest_element([7]) 7 >>> most_frequent_smallest_element([]) None >>> most_frequent_smallest_element([1, 2, 2, 3, 3, 3]) 3 >>> most_frequent_smallest_element([10**6, -10**6, 10**6, -10**6, 10**6]) 1000000 >>> most_frequent_smallest_element([1, -1, -1, 1, 0]) -1","solution":"from collections import Counter def most_frequent_smallest_element(arr): if not arr: return None # Edge case handling when the array is empty. frequency = Counter(arr) max_frequency = max(frequency.values()) most_frequent_elements = [num for num, freq in frequency.items() if freq == max_frequency] return min(most_frequent_elements)"},{"question":"def find_two_sum_indices(nums: List[int], target: int) -> Tuple[int, int]: Finds the two elements in the list which sum to the target value and returns their 1-based indices. :param nums: List[int] - The list of integers. :param target: int - The target sum. :return: Tuple[int, int] - The 1-based indices of the two elements. >>> find_two_sum_indices([2, 7, 11, 15], 9) (1, 2) >>> find_two_sum_indices([3, 2, 4], 6) (2, 3) from typing import List, Tuple def test_find_two_sum_indices_basic(): assert find_two_sum_indices([2, 7, 11, 15], 9) == (1, 2) def test_find_two_sum_indices_another_case(): assert find_two_sum_indices([3, 2, 4], 6) == (2, 3) def test_find_two_sum_indices_large_numbers(): assert find_two_sum_indices([1, 2, 3, 1000000, 1000001], 2000001) == (4, 5) def test_find_two_sum_indices_negatives(): assert find_two_sum_indices([-10, 10, 20, -20], 0) == (1, 2) def test_find_two_sum_indices_mixed_signs(): assert find_two_sum_indices([10, -1, 4, 7], 3) == (2, 3) def test_find_two_sum_indices_single_pair(): assert find_two_sum_indices([1, 5, 3, 7], 8) == (2, 3)","solution":"def find_two_sum_indices(nums, target): Finds the two elements in the list which sum to the target value and returns their 1-based indices. :param nums: List[int] - The list of integers. :param target: int - The target sum. :return: Tuple[int, int] - The 1-based indices of the two elements. num_map = {} for idx, num in enumerate(nums): complement = target - num if complement in num_map: return (num_map[complement] + 1, idx + 1) num_map[num] = idx"},{"question":"from typing import List def calculateSpan(prices: List[int]) -> List[int]: Calculate the stock span for each day given a list of stock prices. For example, if prices are [100, 80, 60, 70, 60, 75, 85], the function should return [1, 1, 1, 2, 1, 4, 6]. Args: prices (List[int]): List of daily stock prices. Returns: List[int]: List of stock span values for each day. Examples: >>> calculateSpan([100, 80, 60, 70, 60, 75, 85]) [1, 1, 1, 2, 1, 4, 6] >>> calculateSpan([10, 20, 30, 40, 50]) [1, 2, 3, 4, 5] >>> calculateSpan([50, 40, 30, 20, 10]) [1, 1, 1, 1, 1] >>> calculateSpan([10, 4, 5, 90, 120, 80]) [1, 1, 2, 4, 5, 1]","solution":"from typing import List def calculateSpan(prices: List[int]) -> List[int]: span = [0] * len(prices) stack = [] for i in range(len(prices)): while stack and prices[stack[-1]] <= prices[i]: stack.pop() if not stack: span[i] = i + 1 else: span[i] = i - stack[-1] stack.append(i) return span"},{"question":"def findLongestRainyPeriod(rainyDays: List[int]) -> int: Given a list of integers representing the days it rained, find the length of the longest consecutive rainy period. >>> findLongestRainyPeriod([3, 5, 6, 8, 9, 10, 12, 13, 14]) 3 >>> findLongestRainyPeriod([1, 2, 4, 5, 7]) 2 >>> findLongestRainyPeriod([2, 3, 4, 5, 6, 7, 8]) 7 >>> findLongestRainyPeriod([10, 12, 14, 17]) 1","solution":"def findLongestRainyPeriod(rainyDays): if not rainyDays: return 0 rainyDays.sort() max_count = 1 current_count = 1 for i in range(1, len(rainyDays)): if rainyDays[i] == rainyDays[i - 1] + 1: current_count += 1 else: max_count = max(max_count, current_count) current_count = 1 max_count = max(max_count, current_count) return max_count"},{"question":"def firstNonRepeatingCharacter(s: str) -> str: Returns the first non-repeating character in the string s. If there is no non-repeating character, returns '_'. >>> firstNonRepeatingCharacter(\\"stress\\") == \\"t\\" >>> firstNonRepeatingCharacter(\\"teeter\\") == \\"r\\" >>> firstNonRepeatingCharacter(\\"aabbcc\\") == \\"_\\" >>> firstNonRepeatingCharacter(\\"success\\") == \\"u\\"","solution":"def firstNonRepeatingCharacter(s): Returns the first non-repeating character in the string s. If there is no non-repeating character, returns '_'. # Dictionary to store character counts char_count = {} # Count characters in the string for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find the first non-repeating character for char in s: if char_count[char] == 1: return char # If no non-repeating character is found return '_'"},{"question":"def count_palindromic_substrings(s: str) -> int: Returns the number of distinct palindromic substrings in the input string s. Parameters: s (str): The input string containing lowercase English letters. Returns: int: Number of distinct palindromic substrings. Examples: >>> count_palindromic_substrings('a') 1 >>> count_palindromic_substrings('abcd') 4 >>> count_palindromic_substrings('aaaa') 4 >>> count_palindromic_substrings('abaaa') 5 >>> count_palindromic_substrings('abacdfgdcaba') 7 >>> count_palindromic_substrings('ab') 2 >>> count_palindromic_substrings('a' * 1000) 1000","solution":"def count_palindromic_substrings(s): Returns the number of distinct palindromic substrings in the input string s. def is_palindrome(sub): return sub == sub[::-1] n = len(s) palindromes = set() for i in range(n): for j in range(i+1, n+1): substring = s[i:j] if is_palindrome(substring): palindromes.add(substring) return len(palindromes)"},{"question":"def longest_consecutive_sequence(nums: List[int]) -> int: Returns the length of the longest consecutive elements sequence in an array. >>> longest_consecutive_sequence([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive_sequence([]) 0 >>> longest_consecutive_sequence([10]) 1 >>> longest_consecutive_sequence([5, 5, 5, 5]) 1 >>> longest_consecutive_sequence([10, 9, 1, 4, 2, 3, 20, 21, 22, 23]) 4 >>> longest_consecutive_sequence([10, 5, 6, 15, 20, 7, 25, 8]) 4","solution":"def longest_consecutive_sequence(nums): Returns the length of the longest consecutive elements sequence in an array. Parameters: nums (list of int): A list of integers. Returns: int: The length of the longest consecutive elements sequence. if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in nums: if num - 1 not in num_set: # Only start counting for the beginning of a sequence current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def encode(s: str) -> str: Encodes the input string using Run Length Encoding. Parameters: s (str): Input string consisting of lowercase English letters. Returns: str: Encoded string. Example: >>> encode(\\"aaabccddddd\\") 'a3b1c2d5' >>> encode(\\"abcd\\") 'a1b1c1d1' # Your code goes here def decode(s: str) -> str: Decodes the encoded string back to its original form. Parameters: s (str): Encoded string. Returns: str: Decoded (original) string. Example: >>> decode(\\"a3b1c2d5\\") 'aaabccddddd' >>> decode(\\"a1b1c1d1\\") 'abcd' # Your code goes here # Unit tests def test_encode_simple(): assert encode(\\"aaabccddddd\\") == \\"a3b1c2d5\\" def test_encode_single_character_repetitions(): assert encode(\\"abcd\\") == \\"a1b1c1d1\\" def test_encode_repeated_characters(): assert encode(\\"aabbcc\\") == \\"a2b2c2\\" def test_encode_mixed_repetitions(): assert encode(\\"aabcccdd\\") == \\"a2b1c3d2\\" def test_decode_simple(): assert decode(\\"a3b1c2d5\\") == \\"aaabccddddd\\" def test_decode_single_character_repetitions(): assert decode(\\"a1b1c1d1\\") == \\"abcd\\" def test_decode_repeated_characters(): assert decode(\\"a2b2c2\\") == \\"aabbcc\\" def test_decode_mixed_repetitions(): assert decode(\\"a2b1c3d2\\") == \\"aabcccdd\\" def test_encode_decode_combination(): original_str = \\"aabcccdd\\" encoded_str = encode(original_str) decoded_str = decode(encoded_str) assert decoded_str == original_str def test_empty_string(): assert encode(\\"\\") == \\"\\" assert decode(\\"\\") == \\"\\"","solution":"def encode(s: str) -> str: Encodes the input string using Run Length Encoding. Parameters: s (str): Input string consisting of lowercase English letters. Returns: str: Encoded string. if not s: return \\"\\" result = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: result.append(s[i - 1] + str(count)) count = 1 result.append(s[-1] + str(count)) return ''.join(result) def decode(s: str) -> str: Decodes the encoded string back to its original form. Parameters: s (str): Encoded string. Returns: str: Decoded (original) string. if not s: return \\"\\" result = [] for i in range(0, len(s), 2): char = s[i] count = int(s[i + 1]) result.append(char * count) return ''.join(result)"},{"question":"def max_profit(prices: List[int]) -> int: Calculate the maximum profit you can achieve by buying and selling the stock. :param prices: List[int] - List of stock prices :return: int - Maximum profit >>> max_profit([7, 1, 5, 3, 6, 4]) == 7 >>> max_profit([1, 2, 3, 4, 5]) == 4 >>> max_profit([7, 6, 4, 3, 1]) == 0","solution":"def max_profit(prices): Calculate the maximum profit you can achieve by buying and selling the stock. :param prices: List[int] - List of stock prices :return: int - Maximum profit max_profit = 0 for i in range(1, len(prices)): if prices[i] > prices[i - 1]: max_profit += prices[i] - prices[i - 1] return max_profit"},{"question":"def generate_spiral_matrix(n): Generate a square matrix filled with elements from 1 to n^2 in spiral order. :param n: An integer determining the size of the matrix (1 <= n <= 20) :return: A 2D list representing the n x n spiral matrix >>> generate_spiral_matrix(3) [[1, 2, 3], [8, 9, 4], [7, 6, 5]] >>> generate_spiral_matrix(4) [[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]] from solution import generate_spiral_matrix def test_spiral_matrix_1(): expected_result = [[1]] assert generate_spiral_matrix(1) == expected_result def test_spiral_matrix_2(): expected_result = [ [1, 2], [4, 3] ] assert generate_spiral_matrix(2) == expected_result def test_spiral_matrix_3(): expected_result = [ [1, 2, 3], [8, 9, 4], [7, 6, 5] ] assert generate_spiral_matrix(3) == expected_result def test_spiral_matrix_4(): expected_result = [ [1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7] ] assert generate_spiral_matrix(4) == expected_result def test_spiral_matrix_5(): expected_result = [ [1, 2, 3, 4, 5], [16, 17, 18, 19, 6], [15, 24, 25, 20, 7], [14, 23, 22, 21, 8], [13, 12, 11, 10, 9] ] assert generate_spiral_matrix(5) == expected_result def test_invalid_input(): try: generate_spiral_matrix(0) except ValueError as ve: assert str(ve) == \\"n must be between 1 and 20 inclusive\\" try: generate_spiral_matrix(21) except ValueError as ve: assert str(ve) == \\"n must be between 1 and 20 inclusive\\" def test_large_n(): result = generate_spiral_matrix(20) # This should not raise any error and should complete correctly","solution":"def generate_spiral_matrix(n): Generate a square matrix filled with elements from 1 to n^2 in spiral order. :param n: An integer determining the size of the matrix (1 <= n <= 20) :return: A 2D list representing the n x n spiral matrix if n < 1 or n > 20: raise ValueError(\\"n must be between 1 and 20 inclusive\\") # Initialize the n x n matrix with zeroes matrix = [[0] * n for _ in range(n)] # Define the initial boundaries of the spiral top, left = 0, 0 bottom, right = n - 1, n - 1 current_num = 1 while top <= bottom and left <= right: # Traverse from left to right along the top row for col in range(left, right + 1): matrix[top][col] = current_num current_num += 1 top += 1 # Traverse from top to bottom along the right column for row in range(top, bottom + 1): matrix[row][right] = current_num current_num += 1 right -= 1 if top <= bottom: # Traverse from right to left along the bottom row for col in range(right, left - 1, -1): matrix[bottom][col] = current_num current_num += 1 bottom -= 1 if left <= right: # Traverse from bottom to top along the left column for row in range(bottom, top - 1, -1): matrix[row][left] = current_num current_num += 1 left += 1 return matrix"},{"question":"def max_participants_present(test_cases): Given a list of test cases containing number of participants and their respective start and end times, return a list of maximum number of participants present at any time during each seminar. Args: test_cases (List[Tuple[int, List[Tuple[int, int]]]]): A list of tuples where each tuple represents a test case. The first element of the tuple is an integer representing the number of participants, and the second element is a list of tuples with start and end times of the participants. Returns: List[int]: A list where each element is the maximum number of participants present at any time during each seminar. Examples: >>> test_cases = [ ... (3, [(1, 3), (2, 5), (4, 6)]), ... (4, [(1, 3), (2, 4), (3, 5), (5, 6)]) ... ] >>> max_participants_present(test_cases) [2, 3] >>> test_cases = [ ... (3, [(1, 2), (3, 4), (5, 6)]) ... ] >>> max_participants_present(test_cases) [1]","solution":"def max_participants_present(test_cases): results = [] for n, intervals in test_cases: times = [] for start, end in intervals: times.append((start, 1)) # Participant joins times.append((end + 1, -1)) # Participant leaves times.sort() current_participants = 0 max_participants = 0 for time, change in times: current_participants += change if current_participants > max_participants: max_participants = current_participants results.append(max_participants) return results"},{"question":"def minimize_max_skill_difference(T, test_cases): Organize relay teams such that the maximum skill difference between any two paired participants is minimized. Arguments: T -- number of test cases test_cases -- a list of tuples where each tuple contains an integer N (number of relay legs) and a list of 2N integers representing skill levels of participants. Returns: A list of integers, each representing the minimized maximum skill difference for the respective test case. Example: >>> minimize_max_skill_difference(2, [(2, [1, 8, 4, 7]), (3, [3, 5, 1, 7, 2, 6])]) [3, 2] >>> minimize_max_skill_difference(1, [(1, [1, 2])]) [1]","solution":"def minimize_max_skill_difference(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] skill_levels = test_cases[i][1] skill_levels.sort() max_diff = float('-inf') for j in range(N): diff = abs(skill_levels[2*j] - skill_levels[2*j + 1]) if diff > max_diff: max_diff = diff results.append(max_diff) return results"},{"question":"def findMajorityElement(arr: List[int]) -> int: Finds the majority element in the array, which appears more than n/2 times. If no majority element exists, returns -1. >>> findMajorityElement([3, 3, 4, 2, 4, 4, 2, 4, 4]) 4 >>> findMajorityElement([3, 3, 4, 2, 4, 4, 2, 4]) -1 >>> findMajorityElement([1, 2, 3, 3, 3, 3, 3]) 3","solution":"def findMajorityElement(arr): Finds the majority element in the array, which appears more than n/2 times. If no majority element exists, returns -1. n = len(arr) candidate = None count = 0 # Phase 1: Finding the candidate using Boyer-Moore Voting Algorithm for num in arr: if count == 0: candidate = num count += (1 if num == candidate else -1) # Phase 2: Verifying the candidate if candidate is not None and arr.count(candidate) > n // 2: return candidate else: return -1"},{"question":"def sieve_of_eratosthenes(n: int) -> List[int]: Write a function that takes an integer n and returns a list of all prime numbers less than n. A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. The function should use the Sieve of Eratosthenes algorithm for efficient computation. >>> sieve_of_eratosthenes(10) [2, 3, 5, 7] >>> sieve_of_eratosthenes(20) [2, 3, 5, 7, 11, 13, 17, 19]","solution":"def sieve_of_eratosthenes(n): Returns a list of all prime numbers less than n using the Sieve of Eratosthenes algorithm. if n <= 2: return [] is_prime = [True] * n is_prime[0] = is_prime[1] = False for base in range(2, int(n**0.5) + 1): if is_prime[base]: for multiple in range(base * base, n, base): is_prime[multiple] = False return [num for num, prime in enumerate(is_prime) if prime]"},{"question":"def numTrees(n: int) -> int: Returns the number of unique binary search trees (BST) that can be created using all the integers from 1 to n. >>> numTrees(0) 1 >>> numTrees(1) 1 >>> numTrees(2) 2 >>> numTrees(3) 5 >>> numTrees(4) 14 >>> numTrees(5) 42 >>> numTrees(6) 132 >>> numTrees(19) 1767263190","solution":"def numTrees(n): Returns the number of unique BSTs that can be created using all the integers from 1 to n. if n == 0: return 1 # Initialize the dp array with zeros. dp = [0] * (n + 1) # There is exactly one empty tree. dp[0] = 1 for nodes in range(1, n + 1): for root in range(1, nodes + 1): left = dp[root - 1] right = dp[nodes - root] dp[nodes] += left * right return dp[n]"},{"question":"def min_vehicles(C_A, C_B, M, N_A, N_B): Determine the minimum number of vehicles needed to deliver exactly M units of goods. Args: C_A (int): Capacity of a Type A vehicle. C_B (int): Capacity of a Type B vehicle. M (int): Total amount of goods to be delivered. N_A (int): Number of Type A vehicles available. N_B (int): Number of Type B vehicles available. Returns: int: Minimum number of vehicles required to deliver exactly M units of goods, or -1 if it is impossible. Examples: >>> min_vehicles(3, 5, 11, 4, 2) 3 >>> min_vehicles(2, 6, 15, 1, 1) -1 pass def process_input(input_data): Processes the input data and returns the results for each test case. Args: input_data (str): The input data as a string. Returns: List[int]: The results for each test case. Examples: >>> input_data = \\"2n3 5 11n4 2n2 6 15n1 1\\" >>> process_input(input_data) [3, -1] pass","solution":"def min_vehicles(C_A, C_B, M, N_A, N_B): Determine the minimum number of vehicles needed to deliver exactly M units of goods. # Initialize the table for DP with infinity (M+1 is used assuming no more than M vehicles needed) dp = [float('inf')] * (M + 1) dp[0] = 0 # Iterate over each vehicle type for _ in range(N_A): for j in range(M, C_A - 1, -1): if dp[j - C_A] != float('inf'): dp[j] = min(dp[j], dp[j - C_A] + 1) for _ in range(N_B): for j in range(M, C_B - 1, -1): if dp[j - C_B] != float('inf'): dp[j] = min(dp[j], dp[j - C_B] + 1) return dp[M] if dp[M] != float('inf') else -1 def process_input(input_data): Processes the input data and returns the results for each test case. input_lines = input_data.strip().split(\\"n\\") T = int(input_lines[0]) results = [] line_index = 1 for _ in range(T): C_A, C_B, M = map(int, input_lines[line_index].split()) N_A, N_B = map(int, input_lines[line_index + 1].split()) results.append(min_vehicles(C_A, C_B, M, N_A, N_B)) line_index += 2 return results"},{"question":"def tribonacci(a, b, c, n): Generates the first n numbers of the Tribonacci sequence given initial numbers a, b, and c. >>> tribonacci(1, 1, 1, 1) [1] >>> tribonacci(1, 1, 1, 2) [1, 1] >>> tribonacci(1, 1, 1, 3) [1, 1, 1] >>> tribonacci(0, 0, 1, 10) [0, 0, 1, 1, 2, 4, 7, 13, 24, 44] >>> tribonacci(1, 2, 3, 10) [1, 2, 3, 6, 11, 20, 37, 68, 125, 230] >>> tribonacci(2, 1, 0, 4) [2, 1, 0, 3] >>> tribonacci(2, 1, 0, 5) [2, 1, 0, 3, 4] >>> tribonacci(1, 1, 1, 15) [1, 1, 1, 3, 5, 9, 17, 31, 57, 105, 193, 355, 653, 1201, 2209]","solution":"def tribonacci(a, b, c, n): Generates the first n numbers of the Tribonacci sequence given initial numbers a, b, and c. if n == 1: return [a] elif n == 2: return [a, b] elif n == 3: return [a, b, c] # Initialize the sequence with the first three numbers sequence = [a, b, c] # Generate the rest of the sequence for _ in range(n - 3): next_val = sequence[-1] + sequence[-2] + sequence[-3] sequence.append(next_val) return sequence"},{"question":"def rearrange_by_sign(arr): Rearrange the elements of an integer array so that all negative numbers appear before all positive numbers. The relative order of the negative numbers and positive numbers should be preserved. :param arr: List of integers pass # Unit Tests def test_all_negative(): arr = [-1, -3, -5, -2, -4] rearrange_by_sign(arr) assert arr == [-1, -3, -5, -2, -4] def test_all_positive(): arr = [1, 2, 3, 4, 5] rearrange_by_sign(arr) assert arr == [1, 2, 3, 4, 5] def test_mixed_signs(): arr = [1, -2, 3, -4, 5, -6] rearrange_by_sign(arr) assert arr == [-2, -4, -6, 1, 3, 5] def test_mixed_signs_with_zero(): arr = [0, 1, -2, 3, -4, 5, -6] rearrange_by_sign(arr) assert arr == [-2, -4, -6, 0, 1, 3, 5] def test_single_element_positive(): arr = [1] rearrange_by_sign(arr) assert arr == [1] def test_single_element_negative(): arr = [-1] rearrange_by_sign(arr) assert arr == [-1] def test_empty_array(): arr = [] rearrange_by_sign(arr) assert arr == [] def test_no_negatives(): arr = [1, 2, 3, 4, 5] rearrange_by_sign(arr) assert arr == [1, 2, 3, 4, 5] def test_no_positives(): arr = [-1, -2, -3, -4, -5] rearrange_by_sign(arr) assert arr == [-1, -2, -3, -4, -5] def test_positive_followed_by_negatives(): arr = [3, 1, -2, -5, 6, -7] rearrange_by_sign(arr) assert arr == [-2, -5, -7, 3, 1, 6] def test_negatives_followed_by_positive(): arr = [-1, -2, 7, 8, 3, 4] rearrange_by_sign(arr) assert arr == [-1, -2, 7, 8, 3, 4]","solution":"def rearrange_by_sign(arr): Rearrange the elements of an integer array so that all negative numbers appear before all positive numbers. The relative order of the negative numbers and positive numbers should be preserved. :param arr: List of integers if not arr: return n = len(arr) j = 0 # index to place the next negative number # Use two-pointer technique to rearrange array for i in range(n): if arr[i] < 0: # If the element is negative, move to the front maintaining the order of appearance item = arr[i] arr.pop(i) arr.insert(j, item) j += 1"},{"question":"from typing import List def unique_permutations(nums: List[int]) -> List[List[int]]: Given a list of integers, return a list of lists containing all unique permutations of the elements. Examples: >>> sorted(unique_permutations([1, 2, 3])) [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] >>> sorted(unique_permutations([0, 1])) [[0, 1], [1, 0]] >>> unique_permutations([1]) [[1]] >>> sorted(unique_permutations([1, 1, 2])) [[1, 1, 2], [1, 2, 1], [2, 1, 1]] >>> unique_permutations([2, 2, 2]) [[2, 2, 2]] >>> unique_permutations([]) [[]]","solution":"from itertools import permutations def unique_permutations(nums): Returns all unique permutations of the input list of integers. # Generate all permutations using itertools.permutations perms = set(permutations(nums)) # Convert each tuple to a list and return the list of lists return [list(perm) for perm in perms]"},{"question":"def shift_string(s: str, n: int) -> str: Shifts each character in the string s forward by n positions in the alphabet. Characters wrap around if they go past 'z'. >>> shift_string(\\"abc\\", 1) 'bcd' >>> shift_string(\\"xyz\\", 3) 'abc'","solution":"def shift_string(s, n): Shifts each character in the string s forward by n positions in the alphabet. Characters wrap around if they go past 'z'. shifted_string = \\"\\" for char in s: # Calculate the new character with the shift applied new_char = chr((ord(char) - 97 + n) % 26 + 97) shifted_string += new_char return shifted_string"},{"question":"def count_frequencies(lst): Returns a dictionary with the frequency count of all elements in the list. The function ignores case for any string elements. >>> count_frequencies(['a', 'A', 'B', 'b', 'a', 'C', 'c']) {'a': 3, 'b': 2, 'c': 2} >>> count_frequencies([3, 'apple', 'banana', 'Apple', 3, 2, 'banana', 'APPLE', 2, 2, 'Banana']) {3: 2, 'apple': 3, 'banana': 3, 2: 3}","solution":"def count_frequencies(lst): Returns a dictionary with the frequency count of all elements in the list. The function ignores case for any string elements. freq_dict = {} for element in lst: if isinstance(element, str): element = element.lower() if element in freq_dict: freq_dict[element] += 1 else: freq_dict[element] = 1 return freq_dict"},{"question":"def product_of_digits(n: int) -> int: Returns the product of all non-zero digits of the non-negative integer n. If n contains only zeros, return 0. >>> product_of_digits(123405) 120 >>> product_of_digits(560) 30 >>> product_of_digits(204) 8 >>> product_of_digits(0) 0","solution":"def product_of_digits(n): Returns the product of all non-zero digits of the non-negative integer n. If n contains only zeros, return 0. product = 1 has_non_zero_digit = False while n > 0: digit = n % 10 if digit != 0: product *= digit has_non_zero_digit = True n //= 10 if not has_non_zero_digit: return 0 return product"},{"question":"from typing import List def filter_primes(lst: List[int]) -> List[int]: Takes a list of integers and returns a list containing only the prime numbers from the input list. >>> filter_primes([10, 15, 3, 7, 8, 19, 23, 6]) [3, 7, 19, 23] >>> filter_primes([4, 6, 8, 9, 10]) [] >>> filter_primes([2, 3, 5, 7, 11, 13]) [2, 3, 5, 7, 11, 13] >>> filter_primes([]) [] >>> filter_primes([1, 4, 6]) [] >>> filter_primes([29, 55, 60, 97, 100]) [29, 97]","solution":"def is_prime(n): Helper function to check if the given number n is a prime number. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def filter_primes(lst): Returns a list containing only the prime numbers from the input list. return [num for num in lst if is_prime(num)]"},{"question":"def poly_scalar_multiply(p, k): Multiply a polynomial by a scalar. Args: p (list): List of coefficients of the polynomial. k (int/float): Scalar to multiply by. Returns: list: New list of coefficients after multiplying by k. >>> poly_scalar_multiply([1, 2], 3) [3, 6] >>> poly_scalar_multiply([0, 4, 2], -1) [0, -4, -2]","solution":"def poly_scalar_multiply(p, k): Multiply a polynomial by a scalar. Args: p (list): List of coefficients of the polynomial. k (int/float): Scalar to multiply by. Returns: list: New list of coefficients after multiplying by k. return [coefficient * k for coefficient in p]"},{"question":"def reverse_string(s: str) -> str: Returns a new string with the characters in reverse order, preserving the case of each character. >>> reverse_string(\\"Hello, World!\\") \\"!dlroW ,olleH\\" >>> reverse_string(\\"\\") \\"\\" >>> reverse_string(\\"a\\") \\"a\\" >>> reverse_string(\\"A\\") \\"A\\" >>> reverse_string(\\"123!@#\\") \\"#@!321\\" >>> reverse_string(\\"madam\\") \\"madam\\" >>> reverse_string(\\" \\") \\" \\" >>> reverse_string(\\" abc \\") \\" cba \\"","solution":"def reverse_string(s): Returns a new string with the characters in reverse order, preserving the case of each character. Parameters: s (str): Input string Returns: str: Reversed string with case preserved return s[::-1]"},{"question":"def traffic_light_simulation(current_time: int) -> str: Simulate a traffic light system for a single lane road. Given the current time in seconds since the start of the simulation, return the state of the traffic light at that specific time. The traffic light cycle is as follows: - Green for 60 seconds. - Yellow for 5 seconds. - Red for 55 seconds. >>> traffic_light_simulation(59) == \\"Green\\" >>> traffic_light_simulation(60) == \\"Yellow\\" >>> traffic_light_simulation(65) == \\"Red\\" >>> traffic_light_simulation(115) == \\"Green\\"","solution":"def traffic_light_simulation(current_time: int) -> str: Returns the state of the traffic light given the current time in seconds since the start of the simulation. The traffic light cycle is as follows: - Green for 60 seconds. - Yellow for 5 seconds. - Red for 55 seconds. cycle_time = 120 # Total duration of one complete cycle. time_in_cycle = current_time % cycle_time if time_in_cycle < 60: return \\"Green\\" elif time_in_cycle < 65: return \\"Yellow\\" else: return \\"Red\\""},{"question":"def min_operations_to_median(t, test_cases): Calculate the minimum number of operations to make all elements in each prefix equal to its median. Args: t (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): The list of test cases, where each test case is a tuple containing an integer n and a list of n integers. Returns: List[List[int]]: A list of results for each test case, where each result is a list of integers representing the minimum number of operations for each prefix length. Example: >>> min_operations_to_median(2, [(3, [5, 3, 1]), (4, [1, 7, 5, 2])]) [[0, 2, 4], [0, 6, 6, 9]]","solution":"def min_operations_to_median(t, test_cases): results = [] for case in test_cases: n, array = case operations = [] for i in range(1, n + 1): prefix = array[:i] prefix.sort() median = prefix[(i - 1) // 2] total_operations = sum(abs(x - median) for x in prefix) operations.append(total_operations) results.append(operations) return results # Example usage: t = 2 test_cases = [ (3, [5, 3, 1]), (4, [1, 7, 5, 2]) ] print(min_operations_to_median(t, test_cases))"},{"question":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None def is_balanced(n, nodes_info): Determines if a binary tree is balanced. A binary tree is \\"balanced\\" if for every node in the tree, the heights of its left and right subtrees differ by at most 1. Args: n : int The number of nodes in the tree. nodes_info : List[Tuple[int, int, int]] List of tuples where each tuple contains the node value, and values of its left and right children. Returns: str : \\"YES\\" if the tree is balanced, otherwise \\"NO\\" Examples: >>> is_balanced(6, [(1, 2, 3), (2, 4, 5), (3, 0, 6), (4, 0, 0), (5, 0, 0), (6, 0, 0)]) \\"YES\\" >>> is_balanced(3, [(1, 2, 0), (2, 3, 0), (3, 0, 0)]) \\"NO\\" pass from solution import is_balanced def test_balanced_tree(): n = 6 nodes_info = [ (1, 2, 3), (2, 4, 5), (3, 0, 6), (4, 0, 0), (5, 0, 0), (6, 0, 0)] assert is_balanced(n, nodes_info) == \\"YES\\" def test_unbalanced_tree(): n = 3 nodes_info = [ (1, 2, 0), (2, 3, 0), (3, 0, 0)] assert is_balanced(n, nodes_info) == \\"NO\\" def test_single_node_tree(): n = 1 nodes_info = [ (1, 0, 0)] assert is_balanced(n, nodes_info) == \\"YES\\" def test_right_heavy_tree(): n = 3 nodes_info = [ (1, 0, 2), (2, 0, 3), (3, 0, 0)] assert is_balanced(n, nodes_info) == \\"NO\\" def test_empty_tree(): n = 0 nodes_info = [] assert is_balanced(n, nodes_info) == \\"YES\\"","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None def is_balanced(n, nodes_info): if n == 0: return \\"YES\\" nodes = {i: TreeNode(i) for i in range(1, n + 1)} for v, l, r in nodes_info: if l != 0: nodes[v].left = nodes[l] if r != 0: nodes[v].right = nodes[r] def check_balance(node): if node is None: return 0, True left_height, left_balanced = check_balance(node.left) right_height, right_balanced = check_balance(node.right) current_height = max(left_height, right_height) + 1 if abs(left_height - right_height) > 1: return current_height, False return current_height, left_balanced and right_balanced root = nodes[1] _, balanced = check_balance(root) return \\"YES\\" if balanced else \\"NO\\""},{"question":"def has_priority(ticketNumber: int) -> bool: Returns True if the customer with the given ticket number has priority, False otherwise. Parameters: - ticketNumber (int): The ticket number of the customer. Returns: - bool: True if the customer has priority, False otherwise. >>> has_priority(9) False >>> has_priority(15) True","solution":"def has_priority(ticketNumber): Returns True if the customer with the given ticket number has priority, False otherwise. Parameters: - ticketNumber (int): The ticket number of the customer. Returns: - bool: True if the customer has priority, False otherwise. return ticketNumber % 5 == 0"},{"question":"from typing import List def calculate_expressions(expressions: List[str]) -> List[float]: Process each string in a list of expressions and compute the result of the calculation. The calculations involve addition (+), subtraction (-), multiplication (*), and division (/). >>> calculate_expressions([\\"3 + 5\\", \\"10 - 2 * 3\\", \\"8 / 2 + 5\\", \\"14 / 2 * 3\\"]) [8.0, 4.0, 9.0, 21.0] >>> calculate_expressions([\\"2 * 3 + 4\\", \\"20 / 4 - 1\\", \\"6 + 4 * 2\\", \\"18 / 2 + 3 * 3\\"]) [10.0, 4.0, 14.0, 21.0]","solution":"from typing import List def calculate_expressions(expressions: List[str]) -> List[float]: def evaluate(expression: str) -> float: try: return eval(expression) except ZeroDivisionError: return float('inf') return [evaluate(expression) for expression in expressions]"},{"question":"def rearrange_string(s: str) -> str: Rearrange the letters of the string so that no two adjacent characters are the same. If such an arrangement is not possible, return an empty string. >>> rearrange_string(\\"aab\\") \\"aba\\" >>> rearrange_string(\\"aaab\\") \\"\\"","solution":"import heapq from collections import Counter def rearrange_string(s): # Count the frequency of each character freq_counter = Counter(s) max_heap = [(-freq, char) for char, freq in freq_counter.items()] heapq.heapify(max_heap) # Create a max heap based on frequency # Previous character initialization prev_freq = 0 prev_char = '' result = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) # If previous character frequency is not zero, push it back to max heap if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) # Update the frequency and previous character prev_freq = freq + 1 prev_char = char rearranged = ''.join(result) # If resulting string length doesn't match original string length, return empty string if len(rearranged) != len(s): return '' return rearranged"},{"question":"def longest_even_subsequence(nums: List[int]) -> int: Write a function that takes a list of integers as input and returns the length of the longest contiguous subsequence where all numbers are even. If there are no even numbers, the function should return 0. Parameters: nums (List[int]): List of integers Returns: int: Length of the longest contiguous even subsequence Examples: >>> longest_even_subsequence([1, 2, 4, 6, 1, 4, 6, 8, 1]) 3 >>> longest_even_subsequence([1, 3, 5, 7]) 0 >>> longest_even_subsequence([2, 4, 6, 8, 10]) 5 >>> longest_even_subsequence([7, 10, 12, 14, 1, 2, 4, 16]) 3","solution":"def longest_even_subsequence(nums): Returns the length of the longest contiguous subsequence where all numbers are even. Parameters: nums (list): List of integers Returns: int: Length of the longest contiguous even subsequence max_length = 0 current_length = 0 for num in nums: if num % 2 == 0: current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 return max_length"},{"question":"def max_non_overlapping_cars(n, schedules): Determine the maximum number of cars that can be charged without overlapping schedules. Args: - n (int): The number of cars. - schedules (list[tuple[int, int]]): A list of tuples, each containing the start and end time of a car's charging schedule. Returns: - int: The maximum number of non-overlapping cars. >>> max_non_overlapping_cars(4, [(1, 4), (2, 6), (4, 7), (5, 9)]) == 2 >>> max_non_overlapping_cars(1, [(0, 5)]) == 1 >>> max_non_overlapping_cars(3, [(1, 3), (3, 5), (5, 7)]) == 3 >>> max_non_overlapping_cars(3, [(1, 4), (2, 5), (3, 6)]) == 1 >>> max_non_overlapping_cars(33334, [(i, i + 2) for i in range(0, 100000, 3)]) == 33334 pass","solution":"def max_non_overlapping_cars(n, schedules): Determine the maximum number of cars that can be charged without overlapping schedules. Args: - n (int): The number of cars. - schedules (list[tuple[int, int]]): A list of tuples, each containing the start and end time of a car's charging schedule. Returns: - int: The maximum number of non-overlapping cars. # Sort the schedules based on the end time schedules.sort(key=lambda x: x[1]) # Initialize variables to keep track of the end time of the last included schedule last_end_time = 0 max_cars = 0 for start, end in schedules: if start >= last_end_time: max_cars += 1 last_end_time = end return max_cars"},{"question":"def two_sum(nums: List[int], target: int) -> List[int]: Given a list of integers and a target value, return the indices of the two numbers such that they add up to the target value. Args: nums: List of integers target: Target value to find Returns: List of two indices >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([3, 2, 4], 6) [1, 2] >>> two_sum([3, 3], 6) [0, 1]","solution":"def two_sum(nums, target): Given a list of integers and a target value, return the indices of the two numbers such that they add up to the target value. :param nums: List of integers :param target: Target value to find :return: List of two indices num_map = {} for i, num in enumerate(nums): complement = target - num if complement in num_map: return [num_map[complement], i] num_map[num] = i return []"},{"question":"def can_make_unique_sums(matrix: List[List[int]]) -> str: Determines if the matrix can be rearranged so that the sum of each row is unique. >>> can_make_unique_sums([[1, 2, 3], [3, 2, 1], [2, 1, 3]]) 'NO' >>> can_make_unique_sums([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 'YES' >>> can_make_unique_sums([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) 'NO' >>> can_make_unique_sums([[10000]]) 'YES'","solution":"def can_make_unique_sums(matrix): Determines if the matrix can be rearranged so that the sum of each row is unique. N = len(matrix) M = len(matrix[0]) # Calculate the sum of each row in the matrix row_sums = [sum(row) for row in matrix] # Check if all row sums are unique if len(row_sums) == len(set(row_sums)): return \\"YES\\" else: return \\"NO\\""},{"question":"def calculate_risk_score(temperature: float, cough: bool, sore_throat: bool, close_contact: bool) -> int: Calculates the risk score for Covid-19 based on user inputs. Parameters: temperature (float): Body temperature in Celsius. cough (bool): Whether the user has a cough. sore_throat (bool): Whether the user has a sore throat. close_contact (bool): Whether the user had close contact with a confirmed Covid-19 case in the last 14 days. Returns: int: The calculated risk score. >>> calculate_risk_score(38.5, True, False, True) 6 >>> calculate_risk_score(37.0, False, True, False) 1 >>> calculate_risk_score(36.5, False, False, False) 0 >>> calculate_risk_score(39.0, True, True, True) 7","solution":"def calculate_risk_score(temperature: float, cough: bool, sore_throat: bool, close_contact: bool) -> int: Calculates the risk score for Covid-19 based on user inputs. Parameters: temperature (float): Body temperature in Celsius. cough (bool): Whether the user has a cough. sore_throat (bool): Whether the user has a sore throat. close_contact (bool): Whether the user had close contact with a confirmed Covid-19 case in the last 14 days. Returns: int: The calculated risk score. score = 0 if temperature >= 38.0: score += 2 if cough: score += 1 if sore_throat: score += 1 if close_contact: score += 3 return score"},{"question":"def longest_same_char_substring(s: str) -> int: Determines the length of the longest substring where all the characters are the same. Args: s (str): Input string consisting only of characters 'a', 'b', and 'c'. Returns: int: Length of the longest substring where all characters are the same. Examples: >>> longest_same_char_substring(\\"abcdddeeeeaabbbcd\\") 4 >>> longest_same_char_substring(\\"abcabcabc\\") 1 >>> longest_same_char_substring(\\"aaabbbbccccc\\") 5","solution":"def longest_same_char_substring(s): Returns the length of the longest substring where all characters are the same. if not s: return 0 max_length = 1 current_length = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: current_length += 1 else: if current_length > max_length: max_length = current_length current_length = 1 if current_length > max_length: max_length = current_length return max_length"},{"question":"def kth_smallest(mat: List[List[int]], k: int) -> int: Given a matrix mat where each row is sorted in ascending order, find the kth smallest element in the matrix. >>> kth_smallest( ... [ ... [1, 5, 9], ... [10, 11, 13], ... [12, 13, 15] ... ], 8) 13 >>> kth_smallest( ... [ ... [1, 2], ... [3, 3] ... ], 2) 2","solution":"def kth_smallest(mat, k): This function returns the kth smallest element in a sorted matrix where each row of the matrix is sorted in ascending order. # Flatten the matrix into a single list elements = [element for row in mat for element in row] # Sort the elements in ascending order elements.sort() # Return the kth smallest element (index k-1 because k is 1-indexed) return elements[k-1]"},{"question":"def find_minimum_platforms(arrival: List[int], departure: List[int]) -> int: Returns the minimum number of platforms required at the station so that no train has to wait. >>> find_minimum_platforms([900, 940, 950, 1100, 1500, 1800], [910, 1200, 1120, 1130, 1900, 2000]) 3 >>> find_minimum_platforms([900, 940, 1200], [910, 950, 1230]) 1 >>> find_minimum_platforms([900, 940, 950], [1000, 1050, 1100]) 3 >>> find_minimum_platforms([900], [910]) 1 >>> find_minimum_platforms([900, 901, 902, 903, 904], [930, 931, 932, 933, 934]) 5 >>> find_minimum_platforms([100, 200, 300, 400, 500], [1100, 1200, 1300, 1400, 1500]) 5 pass","solution":"def find_minimum_platforms(arrival, departure): Returns the minimum number of platforms required at the station so that no train has to wait. :param arrival: List[int], arrival times of trains :param departure: List[int], departure times of trains :return: int, minimum number of platforms needed # Sort the arrival and departure times arrival.sort() departure.sort() # Initialize platform_needed and result platform_needed = 1 result = 1 i = 1 j = 0 while (i < len(arrival) and j < len(departure)): # If next train's arrival before the last vs next train's departure before any arrival if arrival[i] <= departure[j]: platform_needed += 1 i += 1 if platform_needed > result: result = platform_needed else: platform_needed -= 1 j += 1 return result"},{"question":"def mergeAlternately(list1: list, list2: list) -> list: Merges two lists by taking elements alternately from each list. If one list is longer than the other, append the remaining elements of the longer list to the merged result. >>> mergeAlternately([1, 2, 3], ['a', 'b', 'c']) == [1, 'a', 2, 'b', 3, 'c'] >>> mergeAlternately([1, 2, 3, 4], ['a', 'b']) == [1, 'a', 2, 'b', 3, 4] >>> mergeAlternately([1, 2], ['a', 'b', 'c', 'd']) == [1, 'a', 2, 'b', 'c', 'd'] >>> mergeAlternately([], ['a', 'b', 'c']) == ['a', 'b', 'c'] >>> mergeAlternately([1, 2, 3], []) == [1, 2, 3] >>> mergeAlternately([], []) == [] >>> mergeAlternately([None, 2, None], ['a', None, 'c']) == [None, 'a', 2, None, None, 'c'] >>> mergeAlternately([1, True, None], ['a', False, 'c']) == [1, 'a', True, False, None, 'c']","solution":"def mergeAlternately(list1, list2): Merges two lists by taking elements alternately from each list. If one list is longer than the other, append the remaining elements of the longer list to the merged result. merged_list = [] len1, len2 = len(list1), len(list2) min_len = min(len1, len2) for i in range(min_len): merged_list.append(list1[i]) merged_list.append(list2[i]) if len1 > min_len: merged_list.extend(list1[min_len:]) elif len2 > min_len: merged_list.extend(list2[min_len:]) return merged_list"},{"question":"def reverse_words(s: str) -> str: Returns a string with the words rearranged in reverse order. >>> reverse_words(\\"the sky is blue\\") \\"blue is sky the\\" >>> reverse_words(\\" hello world \\") \\"world hello\\" >>> reverse_words(\\"a good example\\") \\"example good a\\" >>> reverse_words(\\"hello\\") \\"hello\\" >>> reverse_words(\\"\\") \\"\\"","solution":"def reverse_words(s: str) -> str: Returns a string with the words rearranged in reverse order. words = s.strip().split() return ' '.join(words[::-1])"},{"question":"def fibonacci_product(n: int) -> int: Returns the product of the first positive n Fibonacci numbers. If n is negative, return 0. >>> fibonacci_product(4) 6 >>> fibonacci_product(6) 240 >>> fibonacci_product(-5) 0","solution":"def fibonacci_product(n): Returns the product of the first positive n Fibonacci numbers. If n is negative, return 0. if n <= 0: return 0 # Starting Fibonacci sequence from 1th element as 1, 2th element as 1 fib_sequence = [1, 1] for i in range(2, n): fib_sequence.append(fib_sequence[-1] + fib_sequence[-2]) # Calculate product of the first n positive Fibonacci numbers product = 1 for num in fib_sequence[:n]: product *= num return product"},{"question":"def compute_gross_weight(M, N, package_weights): Compute the gross weight of a warehouse given the dimensions and weights of the packages. Args: M (int): Number of rows in the grid. N (int): Number of columns in the grid. package_weights (list of int): Weights of the packages. Returns: int: The gross weight (sum) of the packages arranged in the grid. pass def test_basic_case(): M = 3 N = 3 package_weights = [4, 7, 2, 8, 5, 3, 1, 6, 9] assert compute_gross_weight(M, N, package_weights) == 45 def test_single_cell(): M = 1 N = 1 package_weights = [10] assert compute_gross_weight(M, N, package_weights) == 10 def test_row_grid(): M = 1 N = 5 package_weights = [1, 2, 3, 4, 5] assert compute_gross_weight(M, N, package_weights) == 15 def test_column_grid(): M = 5 N = 1 package_weights = [1, 2, 3, 4, 5] assert compute_gross_weight(M, N, package_weights) == 15 def test_large_numbers(): M = 2 N = 2 package_weights = [10000, 10000, 10000, 10000] assert compute_gross_weight(M, N, package_weights) == 40000 def test_zeros(): M = 2 N = 3 package_weights = [0, 0, 0, 0, 0, 0] assert compute_gross_weight(M, N, package_weights) == 0 def test_varied_weights(): M = 2 N = 3 package_weights = [7, 3, 1, 9, 6, 12] assert compute_gross_weight(M, N, package_weights) == 38","solution":"def compute_gross_weight(M, N, package_weights): Compute the gross weight of a warehouse given the dimensions and weights of the packages. Args: M (int): Number of rows in the grid. N (int): Number of columns in the grid. package_weights (list of int): Weights of the packages. Returns: int: The gross weight (sum) of the packages arranged in the grid. return sum(package_weights)"},{"question":"def can_complete_tasks_within_time(tasks: List[int], total_time: int) -> bool: Determines if it's possible to complete all tasks within the given time limit. :param tasks: List[int] - List of task durations in minutes. :param total_time: int - Total available time in minutes. :return: bool - True if it's possible to complete all tasks, otherwise False. >>> can_complete_tasks_within_time([3, 1, 2, 1], 7) True >>> can_complete_tasks_within_time([5, 2, 3], 8) False","solution":"def can_complete_tasks_within_time(tasks, total_time): Determines if it's possible to complete all tasks within the given time limit. :param tasks: List[int] - List of task durations in minutes. :param total_time: int - Total available time in minutes. :return: bool - True if it's possible to complete all tasks, otherwise False. return sum(tasks) <= total_time"},{"question":"def temperature_trend(temperatures): Returns a list where each element represents the number of days one has to wait until a warmer temperature. If there is no such day, return 0 for that day. Parameters: temperatures (list): List of daily temperatures. Returns: list: List of days to wait until a warmer temperature. >>> temperature_trend([73, 74, 75, 71, 69, 72, 76, 73]) [1, 1, 4, 2, 1, 1, 0, 0] >>> temperature_trend([70, 70, 70, 70]) [0, 0, 0, 0]","solution":"def temperature_trend(temperatures): Returns a list where each element represents the number of days one has to wait until a warmer temperature. If there is no such day, return 0 for that day. Parameters: temperatures (list): List of daily temperatures. Returns: list: List of days to wait until a warmer temperature. n = len(temperatures) result = [0] * n stack = [] for i in range(n): while stack and temperatures[i] > temperatures[stack[-1]]: prev_day = stack.pop() result[prev_day] = i - prev_day stack.append(i) return result"},{"question":"def max_subarray_sum(nums: List[int]) -> Tuple[int, List[int]]: Given a list of integers, find the maximum sum of a subarray (a contiguous part) with at least one element. Return both the maximum sum and the subarray itself. >>> max_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]) (7, [4, -1, -2, 1, 5]) >>> max_subarray_sum([-2, -3, -1, -4]) (-1, [-1]) >>> max_subarray_sum([1, 2, 3, 4]) (10, [1, 2, 3, 4]) >>> max_subarray_sum([5]) (5, [5]) >>> max_subarray_sum([-5]) (-5, [-5]) from typing import List, Tuple def test_max_subarray_sum(): assert max_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]) == (7, [4, -1, -2, 1, 5]) assert max_subarray_sum([-2, -3, -1, -4]) == (-1, [-1]) assert max_subarray_sum([1, 2, 3, 4]) == (10, [1, 2, 3, 4]) assert max_subarray_sum([5]) == (5, [5]) assert max_subarray_sum([-5]) == (-5, [-5]) assert max_subarray_sum([]) == (0, []) assert max_subarray_sum([3, -2, 5, -1]) == (6, [3, -2, 5]) assert max_subarray_sum([-1, 2, -1, 2, -1]) == (3, [2, -1, 2])","solution":"def max_subarray_sum(nums): Function to find the maximum sum of a subarray and return the subarray itself. if not nums: return (0, []) max_sum = nums[0] current_sum = nums[0] start = 0 end = 0 temp_start = 0 for i in range(1, len(nums)): if nums[i] > current_sum + nums[i]: current_sum = nums[i] temp_start = i else: current_sum += nums[i] if current_sum > max_sum: max_sum = current_sum start = temp_start end = i return max_sum, nums[start:end+1]"},{"question":"def check_sum(arr: List[int], target: int) -> bool: Check if there are two distinct elements in the array whose sum equals the target number. Args: arr (list of int): The list of integers. target (int): The target sum. Returns: bool: True if there are two distinct elements whose sum equals the target, False otherwise. Example: >>> check_sum([1, 2, 3, 4], 5) True >>> check_sum([1, 2, 3, 4], 8) False >>> check_sum([2, 2, 3, 3], 4) True >>> check_sum([7, 1, 5, 3, 9], 8) True # Implement the function here","solution":"def check_sum(arr, target): Check if there are two distinct elements in the array whose sum equals the target number. Args: arr (list of int): The list of integers. target (int): The target sum. Returns: bool: True if there are two distinct elements whose sum equals the target, False otherwise. seen = set() for num in arr: if target - num in seen: return True seen.add(num) return False"},{"question":"def min_operations_to_unify(binary_str: str) -> int: Determine the minimum number of operations required to make all the characters in the binary string the same. Args: binary_str (str): Input binary string consisting of '0' and '1'. Returns: int: Minimum number of operations required. >>> min_operations_to_unify(\\"1101\\") 2 >>> min_operations_to_unify(\\"0000\\") 0 >>> min_operations_to_unify(\\"010101\\") 3","solution":"def min_operations_to_unify(binary_str): Returns the minimum number of operations required to make all characters the same ('0' or '1') in the given binary string. Args: binary_str (str): Input binary string consisting of '0' and '1'. Returns: int: Minimum number of operations required. count_0 = binary_str.count('0') count_1 = binary_str.count('1') return min(count_0, count_1)"},{"question":"from typing import List def max_subarray_sum(arr: List[int]) -> int: Function to find the maximum sum of a contiguous subarray within a one-dimensional array of numbers which has at least one positive integer using Kadane's algorithm. Parameters: arr (List[int]): A list of integers. Returns: int: The maximum sum of a contiguous subarray. Examples: >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([1]) 1 >>> max_subarray_sum([5, 4, -1, 7, 8]) 23 def test_example_1(): assert max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 def test_example_2(): assert max_subarray_sum([1]) == 1 def test_example_3(): assert max_subarray_sum([5, 4, -1, 7, 8]) == 23 def test_all_negative(): # All elements are negative assert max_subarray_sum([-1, -2, -3, -4]) == -1 def test_mixed_numbers(): # Mixed positive and negative numbers assert max_subarray_sum([-7, 4, -1, 5, 7, -8]) == 15 def test_all_positive(): # All elements are positive assert max_subarray_sum([1, 2, 3, 4, 5]) == 15 def test_single_element(): # Single element array assert max_subarray_sum([5]) == 5 assert max_subarray_sum([-5]) == -5 def test_large_input(): # Stress test with large input large_input = [1] * 100000 assert max_subarray_sum(large_input) == 100000","solution":"from typing import List def max_subarray_sum(arr: List[int]) -> int: Function to find the maximum sum of a contiguous subarray within a one-dimensional array of numbers which has at least one positive integer using Kadane's algorithm. # Initialize our variables max_current = max_global = arr[0] for num in arr[1:]: # Update max_current to the greater of current element or sum of max_current and current element max_current = max(num, max_current + num) # Update max_global if max_current is greater if max_current > max_global: max_global = max_current return max_global"},{"question":"def minEmployees(tasks): Returns the minimum number of employees required to complete all tasks without any overlap. >>> minEmployees([]) == 0 >>> minEmployees([(1, 2)]) == 1 >>> minEmployees([(1, 2), (3, 4)]) == 1 >>> minEmployees([(1, 5), (2, 6), (3, 7), (4, 8)]) == 4 >>> minEmployees([(1, 4), (2, 6), (4, 7)]) == 2 >>> minEmployees([(1, 4), (2, 6), (4, 7), (5, 8), (8, 9)]) == 3 >>> minEmployees([(1, 3), (2, 3), (3, 4)]) == 2 >>> minEmployees([(1, 5), (6, 10), (11, 15)]) == 1 >>> minEmployees([(1, 1000000), (2, 999999), (500000, 1000000)]) == 3 >>> minEmployees([(1, 3), (2, 3), (3, 4), (4, 5), (5, 6), (6, 8), (7, 9)]) == 2 pass","solution":"def minEmployees(tasks): Returns the minimum number of employees required to complete all tasks without any overlap. if not tasks: return 0 # Create two separate lists of start and end times start_times = sorted(task[0] for task in tasks) end_times = sorted(task[1] for task in tasks) start_pointer = end_pointer = 0 max_overlap = current_overlap = 0 # Compare start and end times to determine concurrent tasks while start_pointer < len(tasks): if start_times[start_pointer] < end_times[end_pointer]: current_overlap += 1 max_overlap = max(max_overlap, current_overlap) start_pointer += 1 else: current_overlap -= 1 end_pointer += 1 return max_overlap"},{"question":"def replace_words_with_lengths(s: str) -> str: Takes a string consisting of words and digits separated by spaces, and returns the string with all words replaced by their lengths and the digits unchanged. >>> replace_words_with_lengths(\\"hello 123 world 456\\") '5 123 5 456' >>> replace_words_with_lengths(\\"code 42 everyday\\") '4 42 8'","solution":"def replace_words_with_lengths(s): Takes a string consisting of words and digits separated by spaces, and returns the string with all words replaced by their lengths and the digits unchanged. # Split the string by spaces parts = s.split() # Process each part result = [] for part in parts: if part.isdigit(): result.append(part) else: result.append(str(len(part))) # Join the parts back with spaces return ' '.join(result)"},{"question":"def max_watering_segment(test_cases): Calculate the maximum length of a segment where the robot can water the trees with strictly increasing intensity. :param test_cases: List of tuples, where each tuple contains an integer N and a list of integers representing the heights of the trees. :return: List of integers representing the maximum segment length for each test case. Examples: >>> max_watering_segment([(5, [1, 2, 2, 3, 4])]) [3] >>> max_watering_segment([(6, [5, 1, 2, 3, 2, 4])]) [3] def process_input(input_str): Parse the input string to produce test cases in the required format. :param input_str: Multiline string representing the input. :return: List of tuples, where each tuple contains an integer N and a list of integers representing the heights of the trees. Examples: >>> process_input('2n5n1 2 2 3 4n6n5 1 2 3 2 4n') [(5, [1, 2, 2, 3, 4]), (6, [5, 1, 2, 3, 2, 4])]","solution":"def max_watering_segment(test_cases): results = [] for case in test_cases: N, heights = case max_len = 1 current_len = 1 for i in range(1, N): if heights[i] > heights[i - 1]: current_len += 1 max_len = max(max_len, current_len) else: current_len = 1 results.append(max_len) return results # Implementation for parsing input and producing output def process_input(input_str): lines = input_str.strip().split('n') T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): N = int(lines[index]) heights = list(map(int, lines[index + 1].split())) test_cases.append((N, heights)) index += 2 return test_cases"},{"question":"def max_profit_with_k_transactions(arr, k): Function to calculate the maximum profit with at most k transactions. >>> max_profit_with_k_transactions([3, 2, 6, 5, 0, 3], 2) 7 >>> max_profit_with_k_transactions([2, 4, 1], 2) 2 >>> max_profit_with_k_transactions([1, 2, 3, 4, 5], 3) 4 >>> max_profit_with_k_transactions([7, 6, 4, 3, 1], 1) 0","solution":"def max_profit_with_k_transactions(arr, k): Function to calculate the maximum profit with at most k transactions. if not arr or k == 0: return 0 n = len(arr) # If k >= n // 2, then it is same as unlimited transactions. if k >= n // 2: return sum(max(arr[i] - arr[i - 1], 0) for i in range(1, n)) # dp[i][j] represents the maximum profit up to day j with at most i transactions dp = [[0] * n for _ in range(k + 1)] for i in range(1, k + 1): max_diff = -arr[0] for j in range(1, n): dp[i][j] = max(dp[i][j - 1], arr[j] + max_diff) max_diff = max(max_diff, dp[i - 1][j] - arr[j]) return dp[k][n - 1]"},{"question":"def slice_string(input_string: str, commands: str) -> str: Slice the input_string based on the slicing commands and return the concatenated result. Args: - input_string (str): The string to be sliced. - commands (str): The slicing commands. Returns: - str: The concatenated result of the slices. # Your code here # Example 1 assert slice_string(\\"HelloWorld\\", \\"0:4,5:9\\") == \\"HelloWorld\\" # Explanation: The slices are \\"Hello\\" and \\"World\\", concatenated to form \\"HelloWorld\\". # Example 2 assert slice_string(\\"abcde\\", \\"1:3,0:0\\") == \\"bcda\\" # Explanation: The slices are \\"bcd\\" and \\"a\\", concatenated to form \\"bcda\\". # Example 3 assert slice_string(\\"CodeWars\\", \\"1:3,0:0,4:7\\") == \\"odeCWars\\" # Explanation: The slices are \\"ode\\", \\"C\\", and \\"Wars\\", concatenated to form \\"odeCWars\\". # Example 4 assert slice_string(\\"abcdef\\", \\"1:2,3:3,5:5\\") == \\"bcdf\\" # Explanation: The slices are \\"bc\\", \\"d\\", and \\"f\\", concatenated to form \\"bcdf\\". def test_slice_string_example_1(): assert slice_string(\\"HelloWorld\\", \\"0:4,5:9\\") == \\"HelloWorld\\" def test_slice_string_example_2(): assert slice_string(\\"abcde\\", \\"1:3,0:0\\") == \\"bcda\\" def test_slice_string_example_3(): assert slice_string(\\"CodeWars\\", \\"1:3,0:0,4:7\\") == \\"odeCWars\\" def test_slice_string_example_4(): assert slice_string(\\"abcdef\\", \\"1:2,3:3,5:5\\") == \\"bcdf\\" def test_slice_string_empty_commands(): assert slice_string(\\"abcdef\\", \\"\\") == \\"\\" def test_slice_string_single_command(): assert slice_string(\\"abcdef\\", \\"0:2\\") == \\"abc\\" def test_slice_string_full_string(): assert slice_string(\\"abcdef\\", \\"0:5\\") == \\"abcdef\\" def test_slice_string_reverse_order(): assert slice_string(\\"abcdef\\", \\"4:5,2:3\\") == \\"efcd\\"","solution":"def slice_string(input_string: str, commands: str) -> str: Slice the input_string based on the slicing commands and return the concatenated result. Args: - input_string (str): The string to be sliced. - commands (str): The slicing commands. Returns: - str: The concatenated result of the slices. if not commands: return \\"\\" result = [] commands_list = commands.split(',') for command in commands_list: start, end = map(int, command.split(':')) result.append(input_string[start:end+1]) return ''.join(result)"},{"question":"def max_weight_with_two_trucks(n: int, total_weight: int, capacities: List[int]) -> int: Determines the maximum weight that can be delivered using exactly two trucks without exceeding their individual capacities. :param n: Number of trucks :param total_weight: Total weight of goods to be delivered :param capacities: List of truck capacities :return: The maximum weight that can be delivered using exactly two trucks >>> max_weight_with_two_trucks(5, 50, [10, 20, 30, 40, 25]) == 50 >>> max_weight_with_two_trucks(3, 10, [5, 15, 20]) == 0 >>> max_weight_with_two_trucks(4, 35, [10, 20, 15, 25]) == 35 >>> max_weight_with_two_trucks(10000, 19998, list(range(1, 10001))) == 19998 >>> max_weight_with_two_trucks(4, 100, [10, 20, 30, 40]) == 70","solution":"def max_weight_with_two_trucks(n, total_weight, capacities): Determines the maximum weight that can be delivered using exactly two trucks without exceeding their capacities. :param n: Number of trucks :param total_weight: Total weight of goods to be delivered :param capacities: List of truck capacities :return: The maximum weight that can be delivered using exactly two trucks max_weight = 0 capacities.sort() left, right = 0, n - 1 while left < right: current_weight = capacities[left] + capacities[right] if current_weight <= total_weight: max_weight = max(max_weight, current_weight) left += 1 else: right -= 1 return max_weight"},{"question":"def countPaths(grid: List[List[int]]) -> int: Return the number of distinct paths from the top-left corner to the bottom-right corner in a grid. >>> countPaths([[0, 0, 0], ... [0, 1, 0], ... [0, 0, 0]]) 2 >>> countPaths([[0, 1], ... [0, 0]]) 1 >>> countPaths([[0, 0], ... [1, 0]]) 1 >>> countPaths([[0, 1], ... [1, 0]]) 0","solution":"def countPaths(grid): n = len(grid) if grid[0][0] == 1 or grid[n-1][n-1] == 1: return 0 dp = [[0] * n for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[n-1][n-1]"},{"question":"def diag_mirror(s: str) -> str: Returns the diagonal mirror of the input square string. >>> diag_mirror(\\"abcdnefghnijklnmnop\\") 'aeimnbfjnncgkondhlp' >>> diag_mirror(\\"a\\") 'a' >>> diag_mirror(\\"abncd\\") 'acnbd' >>> diag_mirror(\\"aAnBb\\") 'aBnAb' pass def oper(fct, s: str) -> str: Applies the function (fct) to the string (s). >>> oper(diag_mirror, \\"abcdnefghnijklnmnop\\") 'aeimnbfjnncgkondhlp' pass","solution":"def diag_mirror(s): Returns the diagonal mirror of the input square string. n = s.split('n') length = len(n) result = [''.join([n[i][j] for i in range(length)]) for j in range(length)] return 'n'.join(result) def oper(fct, s): Applies the function (fct) to the string (s). return fct(s)"},{"question":"def can_complete_circuit(petrol: List[int], cost: List[int]) -> int: Determine the starting petrol station index from which a truck can complete the entire route. Return -1 if it's not possible to complete the route. >>> can_complete_circuit([4, 6, 7, 4], [6, 5, 3, 5]) 1 >>> can_complete_circuit([1, 2, 3, 4], [4, 4, 4, 2]) -1","solution":"def can_complete_circuit(petrol, cost): n = len(petrol) total_petrol = total_cost = 0 tank = start_index = 0 for i in range(n): total_petrol += petrol[i] total_cost += cost[i] tank += petrol[i] - cost[i] if tank < 0: start_index = i + 1 tank = 0 if total_petrol < total_cost: return -1 return start_index"},{"question":"def compute_weekly_growth(N, heights): Computes the weekly growth of the plant for each complete week. Parameters: N (int): The number of days the experiment was conducted. heights (list of int): The daily heights of the plant. Returns: list of int: The weekly growth for each complete week.","solution":"def compute_weekly_growth(N, heights): Computes the weekly growth of the plant for each complete week. Parameters: N (int): The number of days the experiment was conducted. heights (list of int): The daily heights of the plant. Returns: list of int: The weekly growth for each complete week. weekly_growth = [] # Iterate over the days, considering only complete weeks for week_start in range(0, N - N % 7, 7): # Calculate the height difference between start and end of the week growth = heights[week_start + 6] - heights[week_start] weekly_growth.append(growth) return weekly_growth"},{"question":"def min_changes_to_make_identical(sequence1: str, sequence2: str) -> int: Returns the minimum number of single-character changes required to make the two sequences identical. >>> min_changes_to_make_identical(\\"ACGT\\", \\"TGCA\\") 4 >>> min_changes_to_make_identical(\\"GATTACA\\", \\"GACTATA\\") 2","solution":"def min_changes_to_make_identical(sequence1, sequence2): Returns the minimum number of single-character changes required to make the two sequences identical. if len(sequence1) != len(sequence2): raise ValueError(\\"Sequences must be of equal length\\") changes = 0 for char1, char2 in zip(sequence1, sequence2): if char1 != char2: changes += 1 return changes"},{"question":"def nth_prime(n: int) -> int: Returns the Nth prime number. >>> nth_prime(1) 2 >>> nth_prime(6) 13 >>> nth_prime(10) 29 >>> nth_prime(100) 541 >>> nth_prime(1000) 7919 >>> nth_prime(10000) 104729","solution":"def nth_prime(n): Returns the Nth prime number. if n == 1: return 2 primes = [2] candidate = 3 while len(primes) < n: is_prime = True for prime in primes: if prime * prime > candidate: break if candidate % prime == 0: is_prime = False break if is_prime: primes.append(candidate) candidate += 2 return primes[-1]"},{"question":"def check_duplicate_coupons(N: int, coupons: List[str]) -> str: Checks if there are any duplicate coupon codes. Parameters: N (int): The number of coupon codes. coupons (list of str): List containing N coupon codes. Returns: str: \\"YES\\" if there are duplicates, otherwise \\"NO\\". Examples: >>> check_duplicate_coupons(5, [\\"ABC\\", \\"XYZ\\", \\"BAC\\", \\"ABC\\", \\"YZX\\"]) 'YES' >>> check_duplicate_coupons(4, [\\"HELLO\\", \\"WORLD\\", \\"FOOBAR\\", \\"CODE\\"]) 'NO' # Your code here","solution":"def check_duplicate_coupons(N, coupons): Checks if there are any duplicate coupon codes. Parameters: N (int): The number of coupon codes. coupons (list of str): List containing N coupon codes. Returns: str: \\"YES\\" if there are duplicates, otherwise \\"NO\\". code_set = set() for code in coupons: if code in code_set: return \\"YES\\" code_set.add(code) return \\"NO\\""},{"question":"def highest_average_stock_price(stock_data, start_date, end_date): Returns the name of the company with the highest average stock price over the specified date range. Args: stock_data (dict): A dictionary where keys are company names and values are lists of tuples, each tuple containing a date (formatted as 'YYYY-MM-DD') and the closing stock price on that date. start_date (str): The start date of the range formatted as 'YYYY-MM-DD'. end_date (str): The end date of the range formatted as 'YYYY-MM-DD'. Returns: str: The name of the company with the highest average stock price over the specified date range. Examples: >>> stock_data = { ... 'CompanyA': [('2023-01-01', 150), ('2023-01-02', 155), ('2023-01-03', 152)], ... 'CompanyB': [('2023-01-01', 200), ('2023-01-02', 210), ('2023-01-03', 215)], ... 'CompanyC': [('2023-01-01', 50), ('2023-01-02', 55), ('2023-01-03', 53)] ... } >>> start_date = '2023-01-01' >>> end_date = '2023-01-03' >>> highest_average_stock_price(stock_data, start_date, end_date) 'CompanyB'","solution":"def highest_average_stock_price(stock_data, start_date, end_date): Returns the name of the company with the highest average stock price over the specified date range. max_avg_price = -1 max_company = None for company, prices in stock_data.items(): date_filtered_prices = [price for date, price in prices if start_date <= date <= end_date] if date_filtered_prices: avg_price = sum(date_filtered_prices) / len(date_filtered_prices) if avg_price > max_avg_price: max_avg_price = avg_price max_company = company return max_company"},{"question":"def check_plan(plan: str, num_streams: int) -> bool: Checks if the given plan supports the required number of concurrent streams. :param plan: The subscription plan (Basic, Standard, Premium). :param num_streams: The number of concurrent streams the user wants. :return: True if the plan supports the number of concurrent streams, False otherwise. >>> check_plan(\\"Standard\\", 2) True >>> check_plan(\\"Basic\\", 2) False >>> check_plan(\\"Premium\\", 3) True >>> check_plan(\\"Standard\\", 1) True def test_check_plan(): assert check_plan(\\"Basic\\", 1) == True assert check_plan(\\"Basic\\", 2) == False assert check_plan(\\"Standard\\", 1) == True assert check_plan(\\"Standard\\", 2) == True assert check_plan(\\"Standard\\", 3) == False assert check_plan(\\"Premium\\", 1) == True assert check_plan(\\"Premium\\", 2) == True assert check_plan(\\"Premium\\", 3) == True assert check_plan(\\"Premium\\", 4) == True assert check_plan(\\"Premium\\", 5) == False assert check_plan(\\"Ultra\\", 1) == False assert check_plan(\\"\\", 1) == False assert check_plan(\\"Standard\\", 0) == True # edge case: 0 is treated as within the limit","solution":"def check_plan(plan: str, num_streams: int) -> bool: Checks if the given plan supports the required number of concurrent streams. :param plan: The subscription plan (Basic, Standard, Premium). :param num_streams: The number of concurrent streams the user wants. :return: True if the plan supports the number of concurrent streams, False otherwise. plans = { \\"Basic\\": 1, \\"Standard\\": 2, \\"Premium\\": 4 } if plan in plans: return num_streams <= plans[plan] return False"},{"question":"class SimpleCalendarScheduler: A Simple Calendar Scheduler that supports adding, removing, and querying events. Examples: >>> scheduler = SimpleCalendarScheduler() >>> scheduler.add_event(\\"2023-10-12\\", \\"Morning Jog\\", \\"06:00\\", \\"07:00\\") # returns: True >>> scheduler.add_event(\\"2023-10-12\\", \\"Team Meeting\\", \\"09:00\\", \\"10:00\\") # returns: True >>> scheduler.add_event(\\"2023-10-12\\", \\"Lunch with Sarah\\", \\"12:00\\", \\"13:00\\") # returns: True >>> scheduler.add_event(\\"2023-10-12\\", \\"Morning Jog\\", \\"08:00\\", \\"09:00\\") # returns: False >>> scheduler.get_events(\\"2023-10-12\\") # returns: [(\\"Morning Jog\\", \\"06:00\\", \\"07:00\\"), (\\"Team Meeting\\", \\"09:00\\", \\"10:00\\"), (\\"Lunch with Sarah\\", \\"12:00\\", \\"13:00\\")] >>> scheduler.remove_event(\\"2023-10-12\\", \\"Team Meeting\\") # returns: True >>> scheduler.remove_event(\\"2023-10-12\\", \\"Evening Jog\\") # returns: False >>> scheduler.get_events(\\"2023-10-12\\") # returns: [(\\"Morning Jog\\", \\"06:00\\", \\"07:00\\"), (\\"Lunch with Sarah\\", \\"12:00\\", \\"13:00\\")] def __init__(self): pass def add_event(self, date, title, start_time, end_time): Adds a new event to the specified date. If an event with the same title exists, returns False. Otherwise, returns True. def remove_event(self, date, title): Removes an event with the given title from the specified date. Returns True if the event was successfully removed, otherwise returns False. def get_events(self, date): Returns a list of events for the specified date, sorted by start time. If no events exist for the given date, returns an empty list.","solution":"class SimpleCalendarScheduler: def __init__(self): self.schedule = {} def add_event(self, date, title, start_time, end_time): if date not in self.schedule: self.schedule[date] = [] for event in self.schedule[date]: if event[0] == title: return False self.schedule[date].append((title, start_time, end_time)) self.schedule[date].sort(key=lambda event: event[1]) return True def remove_event(self, date, title): if date not in self.schedule: return False for event in self.schedule[date]: if event[0] == title: self.schedule[date].remove(event) return True return False def get_events(self, date): if date not in self.schedule: return [] return sorted(self.schedule[date], key=lambda event: event[1])"},{"question":"def longest_even_subarray(nums: List[int]) -> int: Write a function that takes an array of integers and returns the length of the longest subarray that contains only even numbers. >>> longest_even_subarray([1, 2, 4, 6, 5, 8]) 3 >>> longest_even_subarray([2, 4, 6, 8, 10]) 5 >>> longest_even_subarray([1, 3, 5, 7, 9]) 0 >>> longest_even_subarray([1, 3, 5, 2, 7]) 1 >>> longest_even_subarray([]) 0 >>> longest_even_subarray([2, 1, 4, 1, 6, 1, 8]) 1","solution":"def longest_even_subarray(nums): Returns the length of the longest subarray that contains only even numbers. max_length = 0 current_length = 0 for num in nums: if num % 2 == 0: current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 return max_length"},{"question":"def sort_numbers(lst: List[int]) -> List[int]: Sorts the input list with negative numbers at the beginning and positive numbers including zero at the end, both in ascending order. >>> sort_numbers([-3, -1, -2, 4, 3, 0]) [-3, -2, -1, 0, 3, 4] >>> sort_numbers([1, 2, -3, -4]) [-4, -3, 1, 2]","solution":"def sort_numbers(lst): Sorts the input list with negative numbers at the beginning and positive numbers including zero at the end, both in ascending order. negative_numbers = sorted([x for x in lst if x < 0]) non_negative_numbers = sorted([x for x in lst if x >= 0]) return negative_numbers + non_negative_numbers"},{"question":"def first_non_repeating_character(s: str) -> str: Returns the first non-repeating character in the string \`s\`. If all characters repeat, returns '_' (underscore). >>> first_non_repeating_character(\\"abacabad\\") == 'c' >>> first_non_repeating_character(\\"abacabaabacaba\\") == '_'","solution":"def first_non_repeating_character(s: str) -> str: Returns the first non-repeating character in the string \`s\`. If all characters repeat, returns '_' (underscore). # Step 1: Create a character count dictionary char_count = {} # Step 2: Populate the character count dictionary for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Step 3: Iterate through the string to find the first non-repeating character for char in s: if char_count[char] == 1: return char # If no non-repeating character is found, return '_' return '_'"},{"question":"def palindromeCheck(s: str) -> str: This function checks if the given string is a palindrome, ignoring spaces, punctuation, and capitalization. Parameters: s (str): Input string to check. Returns: str: 'palindrome' if the string is a palindrome, 'not palindrome' otherwise. >>> palindromeCheck(\\"racecar\\") == 'palindrome' >>> palindromeCheck(\\"hello\\") == 'not palindrome' >>> palindromeCheck(\\"RaceCar\\") == 'palindrome' >>> palindromeCheck(\\"A man a plan a canal Panama\\") == 'palindrome' >>> palindromeCheck(\\"Madam, in Eden, I'm Adam.\\") == 'palindrome' >>> palindromeCheck(\\"12321\\") == 'palindrome' >>> palindromeCheck(\\"123456\\") == 'not palindrome'","solution":"def palindromeCheck(s): This function checks if the given string is a palindrome, ignoring spaces, punctuation, and capitalization. Parameters: s (str): Input string to check. Returns: str: 'palindrome' if the string is a palindrome, 'not palindrome' otherwise. # Remove non-alphanumeric characters and convert to lowercase cleaned_s = ''.join(c.lower() for c in s if c.isalnum()) # Check if the cleaned string is a palindrome if cleaned_s == cleaned_s[::-1]: return 'palindrome' else: return 'not palindrome'"},{"question":"def highest_affordable_product(prices: List[int], budget: int) -> int: Returns the highest possible value of a product you can buy without exceeding the budget. >>> highest_affordable_product([90, 100, 85, 130, 70], 100) 100 >>> highest_affordable_product([90, 100, 85, 130, 70], 85) 85 >>> highest_affordable_product([90, 100, 85, 130, 70], 89) 85 >>> highest_affordable_product([30, 60, 20, 10, 50], 40) 30 >>> highest_affordable_product([10, 5, 1], 1) 1 >>> highest_affordable_product([10, 20, 30], 5) -1 >>> highest_affordable_product([], 100) -1 pass","solution":"def highest_affordable_product(prices, budget): Returns the highest possible value of a product you can buy without exceeding the budget. Parameters: prices (list of int): List of product prices. budget (int): The maximum available budget. Returns: int: The highest product price within the budget, or -1 if no such product exists. affordable_prices = [price for price in prices if price <= budget] return max(affordable_prices, default=-1)"},{"question":"from typing import List def find_perfect_numbers(n: int) -> List[int]: Find and return all perfect numbers less than or equal to n. >>> find_perfect_numbers(10) [6] >>> find_perfect_numbers(30) [6, 28] >>> find_perfect_numbers(1000) [6, 28, 496] >>> find_perfect_numbers(5000) [6, 28, 496] >>> find_perfect_numbers(1) [] >>> find_perfect_numbers(10000) [6, 28, 496, 8128]","solution":"from typing import List def find_perfect_numbers(n: int) -> List[int]: def is_perfect(number: int) -> bool: if number < 2: return False divisors_sum = 1 # Start with 1 because 1 is a divisor of every number sqrt_n = int(number**0.5) for i in range(2, sqrt_n + 1): if number % i == 0: divisors_sum += i if i != number // i: divisors_sum += number // i return divisors_sum == number perfect_numbers = [] for i in range(2, n + 1): if is_perfect(i): perfect_numbers.append(i) return perfect_numbers"},{"question":"from typing import List def max_profit(prices: List[int]) -> int: Returns the maximum profit obtainable from a single buy and sell operation. If no profit can be made, returns 0. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 >>> max_profit([1, 2, 3, 4, 5, 6, 7]) 6 >>> max_profit([2, 4, 1]) 2","solution":"from typing import List def max_profit(prices: List[int]) -> int: Returns the maximum profit obtainable from a single buy and sell operation. If no profit can be made, returns 0. min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"def is_valid_IPv4(ip: str) -> bool: Determines if the given string is a valid IPv4 address. An IPv4 address consists of four octets (numbers) separated by dots (.). Each octet must be a number between 0 and 255, and must not contain leading zeros. >>> is_valid_IPv4(\\"192.168.1.1\\") True >>> is_valid_IPv4(\\"0.0.0.0\\") True >>> is_valid_IPv4(\\"255.255.255.255\\") True >>> is_valid_IPv4(\\"192.168.001.1\\") False >>> is_valid_IPv4(\\"192.168.1.256\\") False >>> is_valid_IPv4(\\"192.168.1.-1\\") False >>> is_valid_IPv4(\\"192.168.1\\") False >>> is_valid_IPv4(\\"192.168.1.1.1\\") False >>> is_valid_IPv4(\\"192.168.1.a\\") False >>> is_valid_IPv4(\\"192.168.1.01\\") False >>> is_valid_IPv4(\\"01.02.03.04\\") False","solution":"def is_valid_IPv4(ip): Returns True if the string is a valid IPv4 address, False otherwise. parts = ip.split('.') # An IPv4 address must contain exactly four parts if len(parts) != 4: return False for part in parts: # Each part must be numeric and should not contain leading zeros unless it is \\"0\\" if not part.isdigit() or (part[0] == '0' and len(part) > 1): return False number = int(part) # Each part must be in the range 0-255 if number < 0 or number > 255: return False return True"},{"question":"def arithmetic_operations(operations: List[str]) -> int: Process a list of operations for an arithmetic expression builder. Returns the final element on the stack. If the stack is empty when an \\"ADD\\" or \\"MULTIPLY\\" operation is attempted, returns -1 for an invalid operation sequence. Examples: >>> arithmetic_operations([\\"PUSH 3\\", \\"PUSH 4\\", \\"ADD\\", \\"PUSH 2\\", \\"MULTIPLY\\"]) 14 >>> arithmetic_operations([\\"PUSH 5\\", \\"PUSH 3\\", \\"MULTIPLY\\", \\"PUSH 2\\", \\"ADD\\"]) 17 >>> arithmetic_operations([\\"ADD\\"]) -1 from arithmetic_operations import arithmetic_operations def test_arithmetic_operations_add_case(): assert arithmetic_operations([\\"PUSH 3\\", \\"PUSH 4\\", \\"ADD\\", \\"PUSH 2\\", \\"MULTIPLY\\"]) == 14 def test_arithmetic_operations_multiply_case(): assert arithmetic_operations([\\"PUSH 5\\", \\"PUSH 3\\", \\"MULTIPLY\\", \\"PUSH 2\\", \\"ADD\\"]) == 17 def test_arithmetic_operations_empty_stack(): assert arithmetic_operations([\\"ADD\\"]) == -1 def test_arithmetic_operations_insufficient_stack_for_add(): assert arithmetic_operations([\\"PUSH 2\\", \\"ADD\\"]) == -1 def test_arithmetic_operations_insufficient_stack_for_multiply(): assert arithmetic_operations([\\"PUSH 2\\", \\"MULTIPLY\\"]) == -1 def test_arithmetic_operations_complex_case(): assert arithmetic_operations([\\"PUSH 2\\", \\"PUSH 3\\", \\"MULTIPLY\\", \\"PUSH 4\\", \\"ADD\\"]) == 10 def test_arithmetic_operations_single_push(): assert arithmetic_operations([\\"PUSH 5\\"]) == 5 def test_arithmetic_operations_all_push(): assert arithmetic_operations([\\"PUSH 5\\", \\"PUSH 10\\", \\"PUSH 20\\"]) == 20 def test_arithmetic_operations_invalid_operation(): assert arithmetic_operations([\\"INVALID\\"]) == -1 def test_arithmetic_operations_mixed(): assert arithmetic_operations([\\"PUSH 1\\", \\"PUSH 2\\", \\"PUSH 3\\", \\"ADD\\", \\"MULTIPLY\\"]) == 5","solution":"def arithmetic_operations(operations): stack = [] for operation in operations: if operation.startswith(\\"PUSH\\"): _, value = operation.split() stack.append(int(value)) elif operation == \\"ADD\\": if len(stack) < 2: return -1 b = stack.pop() a = stack.pop() stack.append(a + b) elif operation == \\"MULTIPLY\\": if len(stack) < 2: return -1 b = stack.pop() a = stack.pop() stack.append(a * b) else: return -1 return stack[-1] if stack else -1"},{"question":"def toCamelCase(s: str) -> str: Converts the given string to camel case. >>> toCamelCase(\\"hello world\\") == \\"helloWorld\\" >>> toCamelCase(\\"user-name\\") == \\"userName\\" >>> toCamelCase(\\"convert_to_camel_case\\") == \\"convertToCamelCase\\" >>> toCamelCase(\\"hello-world_test\\") == \\"helloWorldTest\\" >>> toCamelCase(\\"test\\") == \\"test\\" >>> toCamelCase(\\"\\") == \\"\\" >>> toCamelCase(\\"-_-\\") == \\"\\" >>> toCamelCase(\\"___\\") == \\"\\" >>> toCamelCase(\\"-hello-world\\") == \\"helloWorld\\" >>> toCamelCase(\\"_convert_to_camel_case\\") == \\"convertToCamelCase\\" >>> toCamelCase(\\"hello-world-\\") == \\"helloWorld\\" >>> toCamelCase(\\"convert-to_camel_case_\\") == \\"convertToCamelCase\\"","solution":"def toCamelCase(s): Converts the given string to camel case. if not s: return \\"\\" words = s.replace(\\"-\\", \\" \\").replace(\\"_\\", \\" \\").split() if not words: return \\"\\" camel_case = words[0].lower() for word in words[1:]: camel_case += word.capitalize() return camel_case"},{"question":"def first_missing_positive(nums): Finds the first missing positive integer from the given list. >>> first_missing_positive([3, 4, -1, 1]) 2 >>> first_missing_positive([1, 2, 0]) 3 >>> first_missing_positive([7, 8, 9, 11, 12]) 1 >>> first_missing_positive([-5, -1, -3]) 1 >>> first_missing_positive([1, 2, 3, 4, 5]) 6 >>> first_missing_positive([1]) 2 >>> first_missing_positive([2]) 1 >>> first_missing_positive([1, 1, 2, 2]) 3 >>> first_missing_positive([1000, 999, 998]) 1 >>> first_missing_positive([]) 1","solution":"def first_missing_positive(nums): Finds the first missing positive integer from the given list. n = len(nums) for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: # Swap nums[i] with nums[nums[i] - 1] correct_pos = nums[i] - 1 nums[i], nums[correct_pos] = nums[correct_pos], nums[i] for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"def count_pairs_with_difference_k(test_cases: List[Tuple[int, List[int], int]]) -> List[int]: For each test case, count the number of pairs of integers in the array whose absolute difference is equal to a given value K. >>> test_cases = [(5, [1, 5, 3, 4, 2], 3), (4, [8, 12, 16, 4], 4)] >>> count_pairs_with_difference_k(test_cases) [2, 3] >>> test_cases = [(3, [1, 7, 9], 10), (4, [5, 9, 12, 15], 2)] >>> count_pairs_with_difference_k(test_cases) [0, 0] >>> test_cases = [(6, [1, 3, 5, 7, 9, 11], 2), (5, [1, 2, 3, 4, 5], 1)] >>> count_pairs_with_difference_k(test_cases) [5, 4] >>> test_cases = [(3, [1000000000, -1000000000, 0], 2000000000)] >>> count_pairs_with_difference_k(test_cases) [1] >>> test_cases = [(100000, list(range(100000)), 1)] >>> count_pairs_with_difference_k(test_cases) [99999] >>> test_cases = [(5, [1, 1, 2, 3, 3], 0)] >>> count_pairs_with_difference_k(test_cases) [2]","solution":"def count_pairs_with_difference_k(test_cases): results = [] for N, arr, K in test_cases: num_pairs = 0 arr_set = set(arr) for num in arr: if num + K in arr_set: num_pairs += 1 if num - K in arr_set and K != 0: num_pairs += 1 results.append(num_pairs // 2) # Each pair is counted twice return results"},{"question":"def factorial(n: int) -> int: Returns the factorial of a non-negative integer n. The factorial of n is defined as the product of all positive integers less than or equal to n. >>> factorial(0) == 1 >>> factorial(1) == 1 >>> factorial(2) == 2 >>> factorial(3) == 6 >>> factorial(4) == 24 >>> factorial(5) == 120 >>> factorial(10) == 3628800 >>> factorial(20) == 2432902008176640000","solution":"def factorial(n): Returns the factorial of a non-negative integer n. The factorial of n is defined as the product of all positive integers less than or equal to n. if n == 0: return 1 elif n < 0: raise ValueError(\\"Input must be a non-negative integer\\") result = 1 for i in range(1, n + 1): result *= i return result"},{"question":"def sieve_of_eratosthenes(n): Write a function that takes an integer \`n\` and returns a list of all prime numbers up to \`n\` (inclusive) using the Sieve of Eratosthenes algorithm. The Sieve of Eratosthenes is an efficient algorithm to find all primes smaller than \`n\`. It works by iteratively marking the multiples of each prime number starting from 2. >>> sieve_of_eratosthenes(10) [2, 3, 5, 7] >>> sieve_of_eratosthenes(20) [2, 3, 5, 7, 11, 13, 17, 19] from solution import sieve_of_eratosthenes def test_primes_up_to_10(): assert sieve_of_eratosthenes(10) == [2, 3, 5, 7] def test_primes_up_to_1(): assert sieve_of_eratosthenes(1) == [] def test_primes_up_to_2(): assert sieve_of_eratosthenes(2) == [2] def test_primes_up_to_20(): assert sieve_of_eratosthenes(20) == [2, 3, 5, 7, 11, 13, 17, 19] def test_primes_up_to_50(): assert sieve_of_eratosthenes(50) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47] def test_primes_up_to_0(): assert sieve_of_eratosthenes(0) == [] def test_primes_up_to_negative(): assert sieve_of_eratosthenes(-10) == []","solution":"def sieve_of_eratosthenes(n): Returns a list of all prime numbers up to n (inclusive) using the Sieve of Eratosthenes algorithm. if n < 2: return [] is_prime = [True] * (n + 1) is_prime[0] = is_prime[1] = False for start in range(2, int(n**0.5) + 1): if is_prime[start]: for multiple in range(start*start, n + 1, start): is_prime[multiple] = False return [num for num in range(2, n + 1) if is_prime[num]]"},{"question":"import re from typing import List def remove_consecutive_duplicates(s: str) -> str: Removes consecutive duplicate characters from the string. >>> remove_consecutive_duplicates(\\"aabbcc\\") 'abc' >>> remove_consecutive_duplicates(\\"aabbaa\\") 'aba' >>> remove_consecutive_duplicates(\\"abc\\") 'abc' >>> remove_consecutive_duplicates(\\"a\\") 'a' >>> remove_consecutive_duplicates(\\"\\") '' >>> remove_consecutive_duplicates(\\"aabbccddeeff\\") 'abcdef' >>> remove_consecutive_duplicates(\\"aaabbbcccddd\\") 'abcd' >>> remove_consecutive_duplicates(\\"xxyyz\\") 'xyz' pass","solution":"import re def remove_consecutive_duplicates(s): Removes consecutive duplicate characters from the string. return re.sub(r'(.)1+', r'1', s)"},{"question":"def decompress_string(compressed: str) -> str: Takes a compressed string of format character followed by a number and returns the decompressed form of the string. :param compressed: str - The compressed string :return: str - The decompressed string >>> decompress_string(\\"a2b3c4\\") == \\"aabbbcccc\\" >>> decompress_string(\\"x5y3z2\\") == \\"xxxxxyyyzz\\" >>> decompress_string(\\"p1q9r1\\") == \\"pqqqqqqqqqr\\" >>> decompress_string(\\"a1b1c1\\") == \\"abc\\" >>> decompress_string(\\"g3h4\\") == \\"ggghhhh\\" >>> decompress_string(\\"\\") == \\"\\" >>> decompress_string(\\"z9\\") == \\"zzzzzzzzz\\"","solution":"def decompress_string(compressed): Takes a compressed string of format character followed by a number and returns the decompressed form of the string. :param compressed: str - The compressed string :return: str - The decompressed string decompressed = [] i = 0 while i < len(compressed): char = compressed[i] count = int(compressed[i + 1]) decompressed.append(char * count) i += 2 return ''.join(decompressed)"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rotateRight(head: ListNode, k: int) -> ListNode: Write a function that takes a linked list and an integer k as input and rotates the linked list to the right by k places. >>> head = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))) >>> k = 2 >>> result = rotateRight(head, k) >>> values = [] >>> while result: ... values.append(result.val) ... result = result.next >>> values [4, 5, 1, 2, 3] >>> head = ListNode(0, ListNode(1, ListNode(2))) >>> k = 4 >>> result = rotateRight(head, k) >>> values = [] >>> while result: ... values.append(result.val) ... result = result.next >>> values [2, 0, 1] >>> head = None >>> k = 3 >>> result = rotateRight(head, k) >>> values = [] >>> while result: ... values.append(result.val) ... result = result.next >>> values [] >>> head = ListNode(1) >>> k = 5 >>> result = rotateRight(head, k) >>> values = [] >>> while result: ... values.append(result.val) ... result = result.next >>> values [1] >>> head = ListNode(1, ListNode(2, ListNode(3))) >>> k = 2000000000 >>> result = rotateRight(head, k) >>> values = [] >>> while result: ... values.append(result.val) ... result = result.next >>> values [2, 3, 1] >>> head = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))) >>> k = 0 >>> result = rotateRight(head, k) >>> values = [] >>> while result: ... values.append(result.val) ... result = result.next >>> values [1, 2, 3, 4, 5]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rotateRight(head: ListNode, k: int) -> ListNode: if not head or not head.next or k == 0: return head # Determine the length of the linked list length = 1 current = head while current.next: current = current.next length += 1 # Make the linked list circular current.next = head # Find the new head (after the k-th rotation) k %= length steps_to_new_head = length - k new_tail = head for _ in range(steps_to_new_head - 1): new_tail = new_tail.next new_head = new_tail.next new_tail.next = None return new_head"},{"question":"def shortest_common_supersequence_length(s1: str, s2: str) -> int: Given two strings s1 and s2, return the length of the shortest string that has both s1 and s2 as subsequences. The string is called the Shortest Common Supersequence (SCS). >>> shortest_common_supersequence_length(\\"abac\\", \\"cab\\") 5 >>> shortest_common_supersequence_length(\\"geek\\", \\"eke\\") 5 >>> shortest_common_supersequence_length(\\"abc\\", \\"def\\") 6 from solution import shortest_common_supersequence_length def test_example_1(): assert shortest_common_supersequence_length(\\"abac\\", \\"cab\\") == 5 def test_example_2(): assert shortest_common_supersequence_length(\\"geek\\", \\"eke\\") == 5 def test_example_3(): assert shortest_common_supersequence_length(\\"abc\\", \\"def\\") == 6 def test_identical_strings(): assert shortest_common_supersequence_length(\\"abc\\", \\"abc\\") == 3 def test_empty_string(): assert shortest_common_supersequence_length(\\"\\", \\"abc\\") == 3 assert shortest_common_supersequence_length(\\"abc\\", \\"\\") == 3 def test_single_char_same(): assert shortest_common_supersequence_length(\\"a\\", \\"a\\") == 1 def test_single_char_diff(): assert shortest_common_supersequence_length(\\"a\\", \\"b\\") == 2 def test_long_strings(): s1 = \\"a\\" * 1000 s2 = \\"b\\" * 1000 assert shortest_common_supersequence_length(s1, s2) == 2000 s1 = \\"a\\" * 999 + \\"b\\" s2 = \\"b\\" + \\"a\\" * 999 assert shortest_common_supersequence_length(s1, s2) == 1001","solution":"def shortest_common_supersequence_length(s1, s2): Returns the length of the shortest common supersequence of s1 and s2. m, n = len(s1), len(s2) # Create a DP table to store the length of the longest common subsequence (LCS) dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill the DP table for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # Length of the shortest common supersequence lcs = dp[m][n] return m + n - lcs"},{"question":"def count_unique_pairs(arr: List[int], k: int) -> int: Returns the count of unique pairs (i, j) where i < j and abs(arr[i] - arr[j]) == k. Args: arr : List[int] : List of unique integers k : int : The absolute difference target Returns: int : Count of such unique pairs Examples: >>> count_unique_pairs([1, 5, 3, 4, 2], 3) 2 >>> count_unique_pairs([1, 2, 3, 4, 5], 10) 0 >>> count_unique_pairs([1, 3, 5, 7, 9], 2) 4 >>> count_unique_pairs([9, 7, 5, 3, 1], 2) 4 >>> count_unique_pairs([1, 6, 11, 16], 5) 3 >>> count_unique_pairs([1, 2, 3, 4, 5], 4) 1","solution":"def count_unique_pairs(arr, k): Returns the count of unique pairs (i, j) where i < j and abs(arr[i] - arr[j]) == k. Args: arr : List[int] : List of unique integers k : int : The absolute difference target Returns: int : Count of such unique pairs count = 0 n = len(arr) for i in range(n): for j in range(i+1, n): if abs(arr[i] - arr[j]) == k: count += 1 return count"},{"question":"def returns_to_origin(moves: str) -> bool: Returns True if the sequence of moves leads back to the origin (0,0), False otherwise. :param moves: String, sequence of moves separated by spaces ('up', 'down', 'left', 'right') >>> returns_to_origin(\\"up down left right\\") True >>> returns_to_origin(\\"up up down down left right left right\\") True >>> returns_to_origin(\\"up right right down\\") False","solution":"def returns_to_origin(moves): Returns True if the sequence of moves leads back to the origin (0,0), False otherwise. :param moves: String, sequence of moves separated by spaces ('up', 'down', 'left', 'right') x, y = 0, 0 move_list = moves.split() for move in move_list: if move == 'up': y += 1 elif move == 'down': y -= 1 elif move == 'left': x -= 1 elif move == 'right': x += 1 return x == 0 and y == 0"},{"question":"from typing import List def min_cost_path(cost: List[List[int]]) -> int: Computes the minimum cost path from the top-left to the bottom-right of the grid. Parameters: cost (list of list of int): A 2D list representing the cost to step into each cell. Returns: int: The minimum cost to reach the bottom-right corner of the grid. >>> min_cost_path([ ... [1,3,1], ... [1,5,1], ... [4,2,1] ... ]) 7 >>> min_cost_path([ ... [1,2,5], ... [3,2,1] ... ]) 6 pass # your code here def test_min_cost_path_example1(): cost = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] assert min_cost_path(cost) == 7 def test_min_cost_path_example2(): cost = [ [1, 2, 5], [3, 2, 1] ] assert min_cost_path(cost) == 6 def test_min_cost_path_single_cell(): cost = [[5]] assert min_cost_path(cost) == 5 def test_min_cost_path_row(): cost = [ [1, 2, 3] ] assert min_cost_path(cost) == 6 def test_min_cost_path_column(): cost = [ [1], [2], [3] ] assert min_cost_path(cost) == 6 def test_min_cost_path_empty_grid(): cost = [] assert min_cost_path(cost) == 0 def test_min_cost_path_empty_row(): cost = [[]] assert min_cost_path(cost) == 0","solution":"def min_cost_path(cost): Computes the minimum cost path from the top-left to the bottom-right of the grid. Parameters: cost (list of list of int): A 2D list representing the cost to step into each cell. Returns: int: The minimum cost to reach the bottom-right corner of the grid. if not cost or not cost[0]: return 0 rows = len(cost) cols = len(cost[0]) # Create a 2D array to store the minimum cost to reach each cell dp = [[0 for _ in range(cols)] for _ in range(rows)] # Initialize the first cell with its own cost dp[0][0] = cost[0][0] # Initialize the first column for i in range(1, rows): dp[i][0] = dp[i-1][0] + cost[i][0] # Initialize the first row for j in range(1, cols): dp[0][j] = dp[0][j-1] + cost[0][j] # Fill the rest of the dp array for i in range(1, rows): for j in range(1, cols): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + cost[i][j] # The minimum cost to reach the bottom-right corner return dp[rows-1][cols-1]"},{"question":"def rearrange_list(arr): Rearranges the list such that all positive integers come before negative integers while maintaining their original relative order within each group. Parameters: arr (list of int): The list of integers to rearrange. Returns: list of int: The rearranged list with positives first and negatives after. >>> rearrange_list([1, -2, 3, -4, 5]) == [1, 3, 5, -2, -4] >>> rearrange_list([-1, -3, 4, 2, -5]) == [4, 2, -1, -3, -5] >>> rearrange_list([3, -1, -4, 2, -8, 6]) == [3, 2, 6, -1, -4, -8] >>> rearrange_list([]) == [] >>> rearrange_list([-3, -5, -1]) == [-3, -5, -1] >>> rearrange_list([2, 4, 6]) == [2, 4, 6]","solution":"def rearrange_list(arr): Rearranges the list such that all positive integers come before negative integers while maintaining their original relative order within each group. Parameters: arr (list of int): The list of integers to rearrange. Returns: list of int: The rearranged list with positives first and negatives after. positives = [x for x in arr if x > 0] negatives = [x for x in arr if x < 0] return positives + negatives"},{"question":"def traffic_lights(lights: str) -> int: This function takes a string input representing the state of traffic lights in four directions (north, east, south, west) and returns the maximum number of directions that can move simultaneously. Parameters: lights (str): A four-character string where each character can be 'R', 'Y', or 'G' representing the state of the traffic lights for north, east, south, and west directions respectively. Returns: int: The maximum number of directions that can move simultaneously. Examples: >>> traffic_lights(\\"GRGR\\") 2 >>> traffic_lights(\\"YYYY\\") 0 >>> traffic_lights(\\"GYGY\\") 2","solution":"def traffic_lights(lights): This function takes a string input representing the state of traffic lights in four directions (north, east, south, west) and returns the maximum number of directions that can move simultaneously (i.e., the number of 'G' in the input). Parameters: lights (str): A four-character string where each character can be 'R', 'Y', or 'G' representing the state of the traffic lights for north, east, south, and west directions respectively. Returns: int: The maximum number of directions that can move simultaneously. return lights.count('G')"},{"question":"def chunkArray(array: list, size: int) -> list: Splits an array into chunks of specified size. Parameters: array (list): The array to be chunked. size (int): The size of each chunk. Returns: list: A list of chunks. >>> chunkArray([1, 2, 3, 4, 5, 6, 7, 8, 9], 3) [[1, 2, 3], [4, 5, 6], [7, 8, 9]] >>> chunkArray([1, 2, 3, 4, 5], 2) [[1, 2], [3, 4], [5]] >>> chunkArray([1, 2, 3], 1) [[1], [2], [3]] >>> chunkArray([], 3) [] >>> chunkArray([1, \\"two\\", 3.0, [4], {5: 'five'}], 2) [[1, \\"two\\"], [3.0, [4]], [{5: 'five'}]] >>> chunkArray([1, 2, 3], 5) [[1, 2, 3]]","solution":"def chunkArray(array, size): Splits an array into chunks of specified size. Parameters: array (list): The array to be chunked. size (int): The size of each chunk. Returns: list: A list of chunks. if size <= 0: raise ValueError(\\"Chunk size must be greater than zero\\") return [array[i:i + size] for i in range(0, len(array), size)]"},{"question":"def min_actions(A: int, B: int, heal_amt: int, hurt_amt: int) -> int: Determine the minimum number of actions required to make the character's HP equal to B. >>> min_actions(3, 8, 3, 1) 2 >>> min_actions(5, 10, 2, 3) 3 >>> min_actions(10, 6, 4, 2) 2 >>> min_actions(50, 100, 25, 5) 2 pass","solution":"def min_actions(A: int, B: int, heal_amt: int, hurt_amt: int) -> int: if A == B: return 0 elif A < B: # Need to heal return (B - A + heal_amt - 1) // heal_amt else: # Need to hurt return (A - B + hurt_amt - 1) // hurt_amt"},{"question":"from typing import List, Tuple def manage_bookshelf(commands: List[Tuple[str, str]]) -> List[str]: You are managing a bookshelf where you can add and remove books. Each book has a unique title, and your task is to keep the bookshelf in alphabetical order when books are added or removed. You will be given a series of commands in the form of a list of tuples, where each tuple contains a command ('ADD' or 'REMOVE') and a book title. Your task is to process these commands and return a list of book titles in alphabetical order after all commands have been processed. >>> manage_bookshelf([(\\"ADD\\", \\"The Catcher in the Rye\\"), (\\"ADD\\", \\"Pride and Prejudice\\"), (\\"REMOVE\\", \\"The Catcher in the Rye\\"), (\\"ADD\\", \\"Brave New World\\")]) [\\"Brave New World\\", \\"Pride and Prejudice\\"] >>> manage_bookshelf([(\\"ADD\\", \\"1984\\"), (\\"ADD\\", \\"To Kill a Mockingbird\\"), (\\"REMOVE\\", \\"1984\\"), (\\"ADD\\", \\"The Great Gatsby\\")]) [\\"The Great Gatsby\\", \\"To Kill a Mockingbird\\"] >>> manage_bookshelf([(\\"ADD\\", \\"The Catcher in the Rye\\"), (\\"ADD\\", \\"Pride and Prejudice\\"), (\\"ADD\\", \\"Brave New World\\")]) [\\"Brave New World\\", \\"Pride and Prejudice\\", \\"The Catcher in the Rye\\"] >>> manage_bookshelf([(\\"ADD\\", \\"1984\\"), (\\"REMOVE\\", \\"The Great Gatsby\\"), (\\"ADD\\", \\"Brave New World\\")]) [\\"1984\\", \\"Brave New World\\"] >>> manage_bookshelf([]) [] >>> manage_bookshelf([ (\\"ADD\\", \\"harry potter\\"), (\\"ADD\\", \\"alice in wonderland\\"), (\\"REMOVE\\", \\"harry potter\\"), (\\"ADD\\", \\"the lord of the rings\\"), (\\"ADD\\", \\"harry potter\\"), (\\"REMOVE\\", \\"alice in wonderland\\"), (\\"REMOVE\\", \\"the lord of the rings\\"), ]) [\\"harry potter\\"]","solution":"from typing import List, Tuple def manage_bookshelf(commands: List[Tuple[str, str]]) -> List[str]: bookshelf = [] for command, book in commands: if command == \\"ADD\\": bookshelf.append(book) bookshelf.sort() elif command == \\"REMOVE\\": if book in bookshelf: bookshelf.remove(book) return bookshelf"},{"question":"def length_of_shortest_word(sentence: str) -> int: Returns the length of the shortest word in the given sentence. :param sentence: str - A sentence containing words separated by spaces. :return: int - The length of the shortest word in the sentence. >>> length_of_shortest_word(\\"The quick brown fox jumps over the lazy dog\\") 3 >>> length_of_shortest_word(\\"Hello\\") 5 >>> length_of_shortest_word(\\"dog cat rat bat mat\\") 3","solution":"def length_of_shortest_word(sentence): Returns the length of the shortest word in the given sentence. :param sentence: str - A sentence containing words separated by spaces. :return: int - The length of the shortest word in the sentence. words = sentence.split() shortest_length = min(len(word) for word in words) return shortest_length"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def isPalindrome(head: ListNode) -> bool: Determine if a linked list forms a palindrome. >>> isPalindrome(list_to_linkedlist([1, 2, 3, 2, 1])) True >>> isPalindrome(list_to_linkedlist([1, 2, 3, 4, 2, 1])) False >>> isPalindrome(list_to_linkedlist([1, 2, 2, 1])) True def list_to_linkedlist(lst): head = ListNode(lst[0]) current = head for val in lst[1:]: current.next = ListNode(val) current = current.next return head def test_palindrome_odd_length(): head = list_to_linkedlist([1, 2, 3, 2, 1]) assert isPalindrome(head) == True def test_not_palindrome(): head = list_to_linkedlist([1, 2, 3, 4, 2, 1]) assert isPalindrome(head) == False def test_palindrome_even_length(): head = list_to_linkedlist([1, 2, 2, 1]) assert isPalindrome(head) == True def test_single_element(): head = list_to_linkedlist([1]) assert isPalindrome(head) == True def test_two_elements_palindrome(): head = list_to_linkedlist([1, 1]) assert isPalindrome(head) == True def test_two_elements_not_palindrome(): head = list_to_linkedlist([1, 2]) assert isPalindrome(head) == False def test_empty_list(): # An empty list should be considered a palindrome (edge case) assert isPalindrome(None) == True","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def isPalindrome(head: ListNode) -> bool: # First find the middle of the linked list slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next # Reverse the second half of the linked list prev = None while slow: next_node = slow.next slow.next = prev prev = slow slow = next_node # Compare the first half with the reversed second half left, right = head, prev while right: # Only need to check until the end of the shorter half if left.val != right.val: return False left = left.next right = right.next return True"},{"question":"def find_smallest_missing_positive(nums: List[int]) -> int: Given a list of integers, find the smallest missing positive integer (greater than 0) that is not present in the list. The function should run in O(n) time and use O(1) space (excluding the input list). >>> find_smallest_missing_positive([3, 4, -1, 1]) 2 >>> find_smallest_missing_positive([1, 2, 0]) 3 >>> find_smallest_missing_positive([7, 8, 9, 11, 12]) 1 >>> find_smallest_missing_positive([1, 2, 3, 4, 5]) 6","solution":"def find_smallest_missing_positive(nums): n = len(nums) for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"def additional_hours_needed(T: int, test_cases) -> List[int]: Determine the additional hours an employee needs to work to meet the weekly working hours requirement. Args: T: Number of test cases. test_cases: A list of tuples, where each tuple consists of: - A tuple (N, M) where N is the required working hours per week, and M is the maximum leave hours allowed. - A string of N length representing the working hours log. Returns: A list of integers representing the additional hours needed for each test case. Examples: >>> additional_hours_needed(3, [((7, 2), \\"5123456\\"), ((5, 1), \\"00001\\"), ((8, 4), \\"22222222\\")]) [0, 3, 0] >>> additional_hours_needed(2, [((5, 0), \\"11111\\"), ((6, 3), \\"555400\\")]) [0, 0] pass from solution import additional_hours_needed def test_additional_hours_needed(): test_cases = [ ((3, [ ((7, 2), \\"5123456\\"), ((5, 1), \\"00001\\"), ((8, 4), \\"22222222\\") ]), [0, 3, 0]), ((2, [ ((5, 0), \\"11111\\"), ((6, 3), \\"555400\\") ]), [0, 0]) ] for input_data, expected in test_cases: assert additional_hours_needed(*input_data) == expected def test_single_case_needed(): assert additional_hours_needed(1, [((5, 1), \\"00001\\")]) == [3] def test_single_case_not_needed(): assert additional_hours_needed(1, [((7, 2), \\"5123456\\")]) == [0]","solution":"def additional_hours_needed(T, test_cases): results = [] for i in range(T): N, M = test_cases[i][0] work_log = test_cases[i][1] total_hours = sum(int(hour) for hour in work_log) if total_hours >= N: results.append(0) else: deficit = N - total_hours additional_hours = max(0, deficit - M) results.append(additional_hours) return results"},{"question":"def min_effort_to_equalize_heights(heights: List[int]) -> int: Returns the minimum effort required to make all climbers' heights equal. >>> min_effort_to_equalize_heights([1, 2, 3]) 2 >>> min_effort_to_equalize_heights([5, 10, 15]) 10 >>> min_effort_to_equalize_heights([1, 10, 2, 9]) 16 >>> min_effort_to_equalize_heights([2, 2, 2]) 0","solution":"def min_effort_to_equalize_heights(heights): Returns the minimum effort required to make all climbers' heights equal. n = len(heights) heights.sort() median = heights[n//2] effort = sum(abs(height - median) for height in heights) return effort"},{"question":"def find_router_with_max_load(router_data): Given a list of tuples with router identifiers and the number of users connected, return the identifier of the router with the maximum number of users. If multiple routers have the same maximum number of users, return the one with the highest identifier. :param router_data: list of tuples with each tuple in the form (router_identifier, users_connected) :return: identifier of the router with the maximum load >>> find_router_with_max_load([(1, 50)]) 1 >>> find_router_with_max_load([(1, 50), (2, 40), (3, 60), (4, 30)]) 3 >>> find_router_with_max_load([(1, 50), (2, 60), (3, 60), (4, 40)]) 3 >>> find_router_with_max_load([(1, 50), (2, 70), (3, 70), (4, 70)]) 4 >>> find_router_with_max_load([]) -1 >>> find_router_with_max_load([(1, 0), (2, 0), (3, 0)]) 3 >>> find_router_with_max_load([(10, 100), (3, 200), (15, 200), (5, 150)]) 15","solution":"def find_router_with_max_load(router_data): Given a list of tuples with router identifiers and the number of users connected, return the identifier of the router with the maximum number of users. If multiple routers have the same maximum number of users, return the one with the highest identifier. :param router_data: list of tuples with each tuple in the form (router_identifier, users_connected) :return: identifier of the router with the maximum load max_users = -1 max_router_id = -1 for router_id, user_count in router_data: if user_count > max_users or (user_count == max_users and router_id > max_router_id): max_users = user_count max_router_id = router_id return max_router_id"},{"question":"def outpost_finder(input_string: str) -> List[int]: Determines the minimum number of outposts needed to monitor all houses in each test case. Args: input_string (str): A string representation of the input Returns: List[int]: A list of integers representing the minimum number of outposts needed for each test case Example: >>> outpost_finder(\\"2n5 2n1 2 5 6 7n3 1n3 5 6n\\") [2, 2] >>> outpost_finder(\\"1n1 1n1n\\") [1]","solution":"def min_outposts(test_cases): results = [] for case in test_cases: N, r, houses = case houses.sort() outposts = 0 i = 0 while i < N: outposts += 1 loc = houses[i] + r while i < N and houses[i] <= loc: i += 1 loc = houses[i - 1] + r while i < N and houses[i] <= loc: i += 1 results.append(outposts) return results def parse_input(input_string): lines = input_string.strip().split(\\"n\\") T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): N, r = map(int, lines[index].split()) houses = list(map(int, lines[index + 1].split())) test_cases.append((N, r, houses)) index += 2 return test_cases def outpost_finder(input_string): test_cases = parse_input(input_string) return min_outposts(test_cases)"},{"question":"def count_unique_spells(potion_spell_dict, potion_pairs): Given a dictionary of potions and their corresponding spell types, and a list of potion pairs, determine the number of unique spells that can be created. Parameters: potion_spell_dict (dict): A dictionary where keys are potion names and values are spell types. potion_pairs (list of tuples): A list of tuples where each tuple consists of two potion names. Returns: int: The number of unique spells created. >>> potion_spell_dict = { ... \\"Red\\": \\"Fire\\", ... \\"Blue\\": \\"Water\\", ... \\"Green\\": \\"Earth\\", ... \\"Yellow\\": \\"Air\\" ... } >>> potion_pairs = [(\\"Red\\", \\"Blue\\"), (\\"Green\\", \\"Yellow\\"), (\\"Red\\", \\"Green\\")] >>> count_unique_spells(potion_spell_dict, potion_pairs) 3 >>> potion_pairs = [(\\"Red\\", \\"Blue\\"), (\\"Blue\\", \\"Red\\"), (\\"Green\\", \\"Yellow\\"), (\\"Yellow\\", \\"Green\\")] >>> count_unique_spells(potion_spell_dict, potion_pairs) 2 >>> potion_pairs = [(\\"Red\\", \\"Blue\\"), (\\"Red\\", \\"Blue\\"), (\\"Green\\", \\"Yellow\\")] >>> count_unique_spells(potion_spell_dict, potion_pairs) 2 >>> potion_pairs = [(\\"Red\\", \\"Red\\"), (\\"Blue\\", \\"Blue\\")] >>> count_unique_spells(potion_spell_dict, potion_pairs) 2 >>> potion_pairs = [] >>> count_unique_spells(potion_spell_dict, potion_pairs) 0 >>> potion_spell_dict = { ... \\"Red\\": \\"Fire\\", ... \\"Blue\\": \\"Water\\", ... } >>> potion_pairs = [(\\"Red\\", \\"Blue\\")] >>> count_unique_spells(potion_spell_dict, potion_pairs) 1 >>> potion_spell_dict = { ... \\"Red\\": \\"Fire\\", ... } >>> potion_pairs = [(\\"Red\\", \\"Red\\")] >>> count_unique_spells(potion_spell_dict, potion_pairs) 1","solution":"def count_unique_spells(potion_spell_dict, potion_pairs): Given a dictionary of potions and their corresponding spell types, and a list of potion pairs, determine the number of unique spells that can be created. Parameters: potion_spell_dict (dict): A dictionary where keys are potion names and values are spell types. potion_pairs (list of tuples): A list of tuples where each tuple consists of two potion names. Returns: int: The number of unique spells created. unique_spells = set() for potion1, potion2 in potion_pairs: spell1 = potion_spell_dict[potion1] spell2 = potion_spell_dict[potion2] combined_spell = (spell1, spell2) if spell1 <= spell2 else (spell2, spell1) unique_spells.add(combined_spell) return len(unique_spells)"},{"question":"def autocomplete(prefix: str, phrases: list) -> list: Implement a text autocomplete feature similar to those found in search engines. Your task is to build a model that will suggest up to three possible phrase completions when provided with a prefix during testing. Args: prefix: A string representing the beginning of a phrase. phrases: A list of strings that have been provided for training the model. Returns: A list of up to three strings that best complete the given prefix. >>> autocomplete(\\"apple\\", [\\"apple pie\\", \\"apple tart\\", \\"apple cider\\", \\"banana split\\", \\"carrot cake\\"]) [\\"apple pie\\", \\"apple tart\\", \\"apple cider\\"] >>> autocomplete(\\"orange\\", [\\"apple pie\\", \\"apple tart\\", \\"apple cider\\", \\"banana split\\", \\"carrot cake\\"]) [] >>> autocomplete(\\"banana split\\", [\\"apple pie\\", \\"apple tart\\", \\"apple cider\\", \\"banana split\\", \\"carrot cake\\"]) [\\"banana split\\"] >>> autocomplete(\\"apple\\", [\\"apple pie\\", \\"apple tart\\", \\"Apple cider\\", \\"banana split\\", \\"carrot cake\\"]) [\\"apple pie\\", \\"apple tart\\", \\"Apple cider\\"] >>> autocomplete(\\"apple\\", [\\"apple pie\\", \\"apple tart\\", \\"apple cider\\", \\"apple turnover\\", \\"apple crumble\\", \\"banana split\\", \\"carrot cake\\"]) [\\"apple pie\\", \\"apple tart\\", \\"apple cider\\"] pass # Your implementation here","solution":"def autocomplete(prefix: str, phrases: list) -> list: Args: prefix: A string representing the beginning of a phrase. phrases: A list of strings that have been provided for training the model. Returns: A list of up to three strings that best complete the given prefix. # Filter phrases that start with the given prefix (case-insensitive) matches = [phrase for phrase in phrases if phrase.lower().startswith(prefix.lower())] # Return at most three matches return matches[:3]"},{"question":"def shift_letters(input_string: str) -> str: Shift each letter in the input string forward by one in the alphabet. Wraps around 'z' to 'a' and 'Z' to 'A'. Non-alphabetic characters remain unchanged. >>> shift_letters(\\"abc\\") == \\"bcd\\" >>> shift_letters(\\"XYZ\\") == \\"YZA\\" >>> shift_letters(\\"aBcXyZ\\") == \\"bCdYzA\\" >>> shift_letters(\\"abc XYZ!\\") == \\"bcd YZA!\\" >>> shift_letters(\\"xyz\\") == \\"yza\\" >>> shift_letters(\\"ZAB\\") == \\"ABC\\" >>> shift_letters(\\"a b c#1!\\") == \\"b c d#1!\\"","solution":"def shift_letters(input_string): Shifts each letter in the input string forward by one in the alphabet. Wraps around 'z' to 'a' and 'Z' to 'A'. Non-alphabetic characters remain unchanged. shifted_string = [] for char in input_string: if 'a' <= char <= 'z': shifted_string.append(chr((ord(char) - ord('a') + 1) % 26 + ord('a'))) elif 'A' <= char <= 'Z': shifted_string.append(chr((ord(char) - ord('A') + 1) % 26 + ord('A'))) else: shifted_string.append(char) return ''.join(shifted_string)"},{"question":"def max_fish(events: List[str]) -> int: Determines the maximum number of fish in a single tank at any given day, given a series of daily events. Args: events (list of str): List of events in the format described in the problem. Returns: int: The maximum number of fish in a single tank at any point throughout the events. >>> max_fish(['+1 5', '+2 8', '+1 3', '-1', '+2 2']) 10 >>> max_fish(['+1 4', '+2 2', '-2', '+1 5', '+3 7']) 9 >>> max_fish(['+1 10', '+2 15', '+1 5', '+3 7']) 15 >>> max_fish(['+1 10', '+2 15', '-1', '-2']) 15 >>> max_fish([]) 0 >>> max_fish(['+1 7', '-1', '+1 5', '+2 3']) 7","solution":"def max_fish(events): Determines the maximum number of fish in a single tank at any given day, given a series of daily events. Args: events (list of str): List of events in the format described in the problem. Returns: int: The maximum number of fish in a single tank at any point throughout the events. tanks = {} max_fish_in_tank = 0 for event in events: parts = event.split() action = parts[0] tank_number = int(parts[0][1:]) if action[0] == '+': fish_count = int(parts[1]) if tank_number in tanks: tanks[tank_number] += fish_count else: tanks[tank_number] = fish_count max_fish_in_tank = max(max_fish_in_tank, tanks[tank_number]) elif action[0] == '-': if tank_number in tanks: tanks[tank_number] = 0 return max_fish_in_tank"},{"question":"from typing import List def most_frequent_string(lst: List[str]) -> str: Given a list of strings, find the string which appears most frequently. If there are multiple such strings, return the one that comes first lexicographically. Parameters: lst (List[str]): List of strings where each string contains only lowercase alphabets. Returns: str: The most frequent string in the list. If there are multiple strings with the highest frequency, return the lexicographically smallest one. Examples: >>> most_frequent_string([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"apple\\"]) 'apple' >>> most_frequent_string([\\"apple\\", \\"banana\\", \\"orange\\", \\"banana\\", \\"apple\\"]) 'apple' >>> most_frequent_string([\\"zebra\\", \\"apple\\", \\"zebra\\", \\"apple\\"]) 'apple'","solution":"from collections import Counter def most_frequent_string(lst): Returns the most frequent string in the list. If there are multiple strings with the highest frequency, return the lexicographically smallest one. if not lst: return \\"\\" count = Counter(lst) max_freq = max(count.values()) # Get all strings that have this frequency candidates = [k for k, v in count.items() if v == max_freq] # Return the lexicographically smallest one return min(candidates)"},{"question":"def can_assign_games_to_participants(n: int, participants: List[int], games: List[int]) -> str: Determines if it is possible to assign each game to a participant without exceeding the maximum participation time. Parameters: n (int): Number of participants and games. participants (list of int): The maximum participation times of the participants. games (list of int): The required times for the games. Returns: str: \\"Yes\\" if it is possible to assign each game to a participant without exceeding their maximum participation time, otherwise \\"No\\". pass # Test cases def test_example_case(): assert can_assign_games_to_participants(3, [5, 7, 9], [3, 8, 6]) == \\"Yes\\" def test_all_participants_max_exact(): assert can_assign_games_to_participants(3, [5, 7, 9], [5, 7, 9]) == \\"Yes\\" def test_some_games_too_difficult(): assert can_assign_games_to_participants(3, [5, 6, 6], [5, 7, 6]) == \\"No\\" def test_single_participant_single_game_possible(): assert can_assign_games_to_participants(1, [10], [10]) == \\"Yes\\" def test_single_participant_single_game_not_possible(): assert can_assign_games_to_participants(1, [10], [11]) == \\"No\\" def test_random_case(): assert can_assign_games_to_participants(5, [23, 54, 32, 12, 76], [23, 12, 32, 76, 54]) == \\"Yes\\" def test_edge_case_minimum_values(): assert can_assign_games_to_participants(1, [1], [1]) == \\"Yes\\" def test_edge_case_large_values(): n = 200000 participants = [100000] * n games = [99999] * n assert can_assign_games_to_participants(n, participants, games) == \\"Yes\\"","solution":"def can_assign_games_to_participants(n, participants, games): Determines if it is possible to assign each game to a participant without exceeding the maximum participation time. Parameters: n (int): Number of participants and games. participants (list of int): The maximum participation times of the participants. games (list of int): The required times for the games. Returns: str: \\"Yes\\" if it is possible to assign each game to a participant without exceeding their maximum participation time, otherwise \\"No\\". # Sort both participants' max times and games' required times participants.sort() games.sort() # Check if each participant can handle their corresponding game for i in range(n): if participants[i] < games[i]: return \\"No\\" return \\"Yes\\""},{"question":"def longest_consecutive_sequence(nums): Finds the length of the longest consecutive elements sequence in the list. >>> longest_consecutive_sequence([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive_sequence([9, 1, 4, 7, 3, -1, 0, 5, 8, -1, 6]) 7 >>> longest_consecutive_sequence([]) 0 >>> longest_consecutive_sequence([1]) 1 >>> longest_consecutive_sequence([1, 2, 2, 3, 4, 4, 5]) 5 >>> longest_consecutive_sequence([10, 20, 30, 40]) 1 >>> longest_consecutive_sequence([-3, -2, -1, 0, 1, 2]) 6","solution":"def longest_consecutive_sequence(nums): Finds the length of the longest consecutive elements sequence in the list. if not nums: return 0 nums_set = set(nums) longest_streak = 0 for num in nums_set: # Only start a new streak if num is the start of a sequence if num - 1 not in nums_set: current_num = num current_streak = 1 while current_num + 1 in nums_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def number_of_regions(R, C, horizontal_fences, vertical_fences): Calculates the number of regions created by placing the fences. Args: R: int - number of rows in the grid. C: int - number of columns in the grid. horizontal_fences: list of int - list of row indices where horizontal fences are placed. vertical_fences: list of int - list of column indices where vertical fences are placed. Returns: int - number of distinct regions created. pass def test_no_fences(): assert number_of_regions(5, 5, [], []) == 1 def test_one_horizontal_fence(): assert number_of_regions(5, 5, [2], []) == 2 def test_one_vertical_fence(): assert number_of_regions(5, 5, [], [3]) == 2 def test_horizontal_and_vertical_fence(): assert number_of_regions(5, 5, [2], [3]) == 4 def test_double_horizontal_fence(): assert number_of_regions(6, 5, [2, 4], []) == 3 def test_double_vertical_fence(): assert number_of_regions(6, 5, [], [2, 4]) == 3 def test_multiple_fences(): assert number_of_regions(6, 4, [1, 4], [2]) == 6 def test_large_grid(): assert number_of_regions(1000000000, 1000000000, [500000000], [500000000]) == 4 assert number_of_regions(1000000000, 1000000000, [100000], [100000, 200000, 300000]) == 8","solution":"def number_of_regions(R, C, horizontal_fences, vertical_fences): Calculates the number of regions created by placing the fences. Args: R: int - number of rows in the grid. C: int - number of columns in the grid. horizontal_fences: list of int - list of row indices where horizontal fences are placed. vertical_fences: list of int - list of column indices where vertical fences are placed. Returns: int - number of distinct regions created. # The number of regions will be the number of rows segments times the number of column segments. row_segments = len(horizontal_fences) + 1 column_segments = len(vertical_fences) + 1 return row_segments * column_segments"},{"question":"def stack_calculator(commands: List[str]) -> List[int]: Simulates a basic stack-based calculator. Parameters: commands (list of str): List of commands to be executed in the form of strings. Returns: list: The final state of the stack after processing all commands. pass # Example test cases def test_stack_calculator_example(): assert stack_calculator([\\"PUSH 5\\", \\"PUSH 3\\", \\"ADD\\", \\"PUSH 2\\", \\"SUB\\"]) == [6] def test_push_only(): assert stack_calculator([\\"PUSH 1\\", \\"PUSH 2\\", \\"PUSH 3\\"]) == [1, 2, 3] def test_pop_only(): assert stack_calculator([\\"PUSH 1\\", \\"PUSH 2\\", \\"POP\\", \\"POP\\"]) == [] def test_add_operation(): assert stack_calculator([\\"PUSH 4\\", \\"PUSH 5\\", \\"ADD\\"]) == [9] def test_sub_operation(): assert stack_calculator([\\"PUSH 4\\", \\"PUSH 5\\", \\"SUB\\"]) == [-1] def test_mixed_operations(): assert stack_calculator([\\"PUSH 10\\", \\"PUSH 20\\", \\"ADD\\", \\"PUSH 5\\", \\"SUB\\", \\"PUSH 15\\", \\"ADD\\"]) == [40] def test_invalid_commands(): assert stack_calculator([\\"PUSH 10\\", \\"INVALID\\", \\"PUSH\\", \\"POP\\", \\"PUSH 5\\", \\"ADD\\"]) == [5] def test_insufficient_elements_for_add(): assert stack_calculator([\\"PUSH 10\\", \\"ADD\\"]) == [10] def test_insufficient_elements_for_sub(): assert stack_calculator([\\"PUSH 10\\", \\"SUB\\"]) == [10]","solution":"def stack_calculator(commands): Simulates a basic stack-based calculator. Parameters: commands (list of str): List of commands to be executed in the form of strings. Returns: list: The final state of the stack after processing all commands. stack = [] for command in commands: parts = command.split() if parts[0] == \\"PUSH\\" and len(parts) == 2 and parts[1].isdigit(): stack.append(int(parts[1])) elif parts[0] == \\"POP\\" and stack: stack.pop() elif parts[0] == \\"ADD\\" and len(stack) >= 2: a = stack.pop() b = stack.pop() stack.append(a + b) elif parts[0] == \\"SUB\\" and len(stack) >= 2: a = stack.pop() b = stack.pop() stack.append(b - a) return stack"},{"question":"def can_attend_all_meetings(intervals: List[List[int]]) -> bool: Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] where si < ei, determine if a person could attend all meetings. Parameters: intervals (list of list of int): List of meeting intervals where each interval is [start, end]. Returns: bool: True if a person can attend all meetings, False otherwise. Example: >>> can_attend_all_meetings([[0,30],[5,10],[15,20]]) False >>> can_attend_all_meetings([[7,10],[2,4]]) True","solution":"def can_attend_all_meetings(intervals): Determines if a person can attend all meetings represented by the intervals. Parameters: intervals (list of list of int): List of meeting intervals where each interval is [start, end]. Returns: bool: True if a person can attend all meetings, False otherwise. if not intervals: return True intervals.sort(key=lambda x: x[0]) for i in range(len(intervals) - 1): if intervals[i][1] > intervals[i + 1][0]: return False return True"},{"question":"from typing import List import heapq from collections import Counter def rearrange_string(s: str) -> str: Rearrange the string s such that no two adjacent characters are the same. If it's not possible, return an empty string. :param s: str :return: str >>> rearrange_string(\\"aabbcc\\") in [\\"abcabc\\", \\"acbacb\\", \\"bacbac\\", \\"bcbaca\\", \\"cabacb\\", \\"cbabac\\"] True >>> rearrange_string(\\"aaab\\") '' >>> rearrange_string(\\"a\\") 'a' >>> rearrange_string(\\"ab\\") in [\\"ab\\", \\"ba\\"] True >>> rearrange_string(\\"aaaa\\") '' >>> rearrange_string(\\"aaabbc\\") in [\\"ababac\\", \\"abacab\\", \\"acabab\\", \\"bacabc\\", \\"bcaaba\\", \\"cabaca\\", \\"cabcab\\"] True >>> rearrange_string(\\"\\") ''","solution":"from collections import Counter import heapq def rearrange_string(s): Rearrange the string s such that no two adjacent characters are the same. If it's not possible, return an empty string. :param s: str :return: str if not s: return \\"\\" # Count frequency of each character char_count = Counter(s) max_heap = [(-count, char) for char, count in char_count.items()] heapq.heapify(max_heap) previous_char = None previous_count = 0 result = [] while max_heap or previous_count < 0: if max_heap: count, char = heapq.heappop(max_heap) else: return \\"\\" result.append(char) if previous_count < 0: heapq.heappush(max_heap, (previous_count, previous_char)) previous_char = char previous_count = count + 1 # Decrease count since the char was used return ''.join(result)"},{"question":"from typing import List def shortest_path(grid: List[List[int]]) -> int: Find the shortest path in a grid with obstacles from top-left to bottom-right. Parameters: grid (List[List[int]]): 2D grid with 0 representing open cells and 1 representing obstacles. Returns: int: The length of the shortest path or -1 if no path exists. Example: >>> shortest_path([[0, 0, 1], [0, 1, 0], [0, 0, 0]]) 4 >>> shortest_path([[0, 1, 1], [1, 1, 1], [1, 1, 0]]) -1","solution":"from collections import deque def shortest_path(grid): Find the shortest path in a grid with obstacles from top-left to bottom-right. Parameters: grid (List[List[int]]): 2D grid with 0 representing open cells and 1 representing obstacles. Returns: int: The length of the shortest path or -1 if no path exists. if not grid or not grid[0]: return -1 rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # right, down, left, up queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set((0, 0)) while queue: r, c, dist = queue.popleft() if r == rows - 1 and c == cols - 1: return dist for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) not in visited and grid[nr][nc] == 0: visited.add((nr, nc)) queue.append((nr, nc, dist + 1)) return -1"},{"question":"from typing import List def can_form_palindrome(s: str) -> str: Check if the string can be rearranged to form a palindrome. If it can, return any one possible palindromic permutation of the string. If it cannot, return the string \\"IMPOSSIBLE\\". >>> can_form_palindrome(\\"civic\\") 'civic' >>> can_form_palindrome(\\"ivicc\\") 'icvci' >>> can_form_palindrome(\\"hello\\") 'IMPOSSIBLE' >>> can_form_palindrome(\\"aaaaaaaaaa\\") 'aaaaaaaaaa' pass def process_test_cases(T: int, test_cases: List[str]) -> List[str]: For each test case, determine a possible palindromic permutation or \\"IMPOSSIBLE\\" if it doesn't exist. >>> process_test_cases(4, [\\"civic\\", \\"ivicc\\", \\"hello\\", \\"aaaaaaaaaa\\"]) ['civic', 'icvci', 'IMPOSSIBLE', 'aaaaaaaaaa'] >>> process_test_cases(2, [\\"aab\\", \\"aaabb\\"]) ['aba', 'ababa'] >>> process_test_cases(3, [\\"abc\\", \\"abcd\\", \\"aabb\\"]) ['IMPOSSIBLE', 'IMPOSSIBLE', 'abba'] >>> process_test_cases(1, [\\"a\\"]) ['a'] pass","solution":"from collections import Counter def can_form_palindrome(s): count = Counter(s) odd_count = 0 for freq in count.values(): if freq % 2 != 0: odd_count += 1 if odd_count > 1: return \\"IMPOSSIBLE\\" half_palindrome = [] middle_char = [] for char, freq in count.items(): if freq % 2 != 0: middle_char.append(char) half_palindrome.append(char * (freq // 2)) first_half = ''.join(half_palindrome) palindromic_permutation = first_half + ''.join(middle_char) + first_half[::-1] return palindromic_permutation def process_test_cases(T, test_cases): results = [] for s in test_cases: results.append(can_form_palindrome(s)) return results"},{"question":"def generate_pattern(n: int) -> List[str]: Generate a diamond shape pattern with n lines in the upper half of the diamond. :param n: int - An odd positive integer :return: list of strings - Each string represents a line in the diamond pattern >>> generate_pattern(3) [ \\" * \\", \\" *** \\", \\"*****\\", \\" *** \\", \\" * \\" ] >>> generate_pattern(5) [ \\" * \\", \\" *** \\", \\" ***** \\", \\" ******* \\", \\"*********\\", \\" ******* \\", \\" ***** \\", \\" *** \\", \\" * \\" ]","solution":"def generate_pattern(n): Generate a diamond shape pattern with n lines in the upper half of the diamond. :param n: int - An odd positive integer :return: list of strings - Each string represents a line in the diamond pattern pattern = [] for i in range(n): line = ' ' * (n - i - 1) + '*' * (2 * i + 1) + ' ' * (n - i - 1) pattern.append(line) for i in range(n-2, -1, -1): line = ' ' * (n - i - 1) + '*' * (2 * i + 1) + ' ' * (n - i - 1) pattern.append(line) return pattern"},{"question":"from collections import Counter def can_rearrange(s: str) -> bool: Determines if a string can be rearranged such that no two adjacent characters are the same. Returns True if it is possible, otherwise returns False. >>> can_rearrange(\\"aab\\") True >>> can_rearrange(\\"aaab\\") False >>> can_rearrange(\\"\\") True","solution":"from collections import Counter def can_rearrange(s): Determines if a string can be rearranged such that no two adjacent characters are the same. Returns True if it is possible, otherwise returns False. :param s: The input string consisting of lowercase letters :return: True if the string can be rearranged as per the condition, else False if not s: return True frequency = Counter(s) max_freq = max(frequency.values()) # The condition to check is if the most frequent character is more than half + 1 if max_freq > (len(s) + 1) // 2: return False return True"},{"question":"def smallest_string_length(s: str) -> int: Given a string s consisting of letters 'a' and 'b' only. We can delete any two adjacent letters if they are different. After repeated performance of this operation, return the length of the smallest string that we can get. Args: s (str): The input string consisting of 'a' and 'b'. Returns: int: The length of the smallest string that can be obtained. Examples: >>> smallest_string_length(\\"abb\\") 1 >>> smallest_string_length(\\"abab\\") 0 >>> smallest_string_length(\\"aab\\") 1 from solution import smallest_string_length def test_example_1(): assert smallest_string_length(\\"abb\\") == 1 def test_example_2(): assert smallest_string_length(\\"abab\\") == 0 def test_example_3(): assert smallest_string_length(\\"aab\\") == 1 def test_multiple_reductions(): assert smallest_string_length(\\"ababa\\") == 1 def test_all_same_characters(): assert smallest_string_length(\\"aaaa\\") == 4 def test_empty_string(): assert smallest_string_length(\\"\\") == 0 def test_one_character_string(): assert smallest_string_length(\\"a\\") == 1 assert smallest_string_length(\\"b\\") == 1 def test_alternating_characters(): assert smallest_string_length(\\"ababababab\\") == 0 def test_two_adjacent_different_characters(): assert smallest_string_length(\\"ab\\") == 0 def test_two_adjacent_same_characters(): assert smallest_string_length(\\"aa\\") == 2","solution":"def smallest_string_length(s): Returns the length of the smallest string that can be obtained by repeatedly deleting any two adjacent letters if they are different ('ab' or 'ba'). stack = [] for char in s: if stack and stack[-1] != char: stack.pop() else: stack.append(char) return len(stack)"},{"question":"def check_politeness(T: int, strings: List[str]) -> List[str]: Determine if a string is a polite, almost polite, or impolite greeting. >>> check_politeness(4, [\\"radar\\", \\"radbr\\", \\"hello\\", \\"madcm\\"]) [\\"polite\\", \\"almost polite\\", \\"impolite\\", \\"almost polite\\"] >>> check_politeness(3, [\\"level\\", \\"deified\\", \\"civic\\"]) [\\"polite\\", \\"polite\\", \\"polite\\"] >>> check_politeness(3, [\\"abca\\", \\"racecar\\", \\"radbr\\"]) [\\"almost polite\\", \\"polite\\", \\"almost polite\\"] >>> check_politeness(3, [\\"hello\\", \\"world\\", \\"program\\"]) [\\"impolite\\", \\"impolite\\", \\"impolite\\"]","solution":"def check_politeness(T, strings): def is_palindrome(s): return s == s[::-1] def is_almost_polite(s): left, right = 0, len(s) - 1 changes = 0 while left < right: if s[left] != s[right]: changes += 1 if changes > 1: return False left += 1 right -= 1 return True results = [] for s in strings: if is_palindrome(s): results.append(\\"polite\\") elif is_almost_polite(s): results.append(\\"almost polite\\") else: results.append(\\"impolite\\") return results"},{"question":"def firstDuplicate(a: List[int]) -> int: Returns the first duplicated number for which the second occurrence has the minimal index. If there are no such elements, returns -1. >>> firstDuplicate([2, 3, 3, 1, 5, 2]) 3 >>> firstDuplicate([1, 2, 3, 4, 5]) -1","solution":"def firstDuplicate(a): Returns the first duplicated number for which the second occurrence has the minimal index. If there are no such elements, returns -1. :param a: List[int], a list of integers. :return: int, the first duplicate number with minimal index of second occurrence. seen = set() for number in a: if number in seen: return number seen.add(number) return -1"},{"question":"from typing import List, Tuple def solve(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Help Dr. Chan determine the largest number of experiments he can run simultaneously such that all the chosen numbers are pairwise coprime. Args: T (int): Number of test cases test_cases (List[Tuple[int, List[int]]]): List of tuples where the first element is the number of distinct numbers and the second is the list of distinct integers. Returns: List[int]: List of maximum number of pairwise coprime numbers that can be chosen for each test case. Example: >>> solve(2, [(5, [3, 5, 7, 11, 13]), (4, [6, 10, 15, 21])]) [5, 2] >>> solve(1, [(1, [10])]) [1] >>> solve(1, [(3, [1, 1, 1])]) [3] >>> solve(1, [(4, [4, 6, 8, 10])]) [1] >>> solve(1, [(3, [999999937, 999999883, 999999893])]) [3]","solution":"from math import gcd from functools import reduce from itertools import combinations def gcd_pairs(numbers): Calculate the gcd of each pair in list of numbers. return all(gcd(a, b) == 1 for a, b in combinations(numbers, 2)) def max_pairwise_coprime_subset(a): Return the size of largest subset of a such that all elements are pairwise coprime. n = len(a) subsets = [] # Iterate over all possible subsets for i in range(1, 1 << n): subset = [a[j] for j in range(n) if i & (1 << j)] if gcd_pairs(subset): subsets.append(subset) return max(len(subset) for subset in subsets) if subsets else 0 def solve(T, test_cases): results = [] for i in range(T): n, a = test_cases[i] result = max_pairwise_coprime_subset(a) results.append(result) return results"},{"question":"def increment_string(s: str) -> str: Takes an input string that consists of letters followed by digits, and returns the string with the digits incremented by 1. If the string does not end with digits, the function appends the digit '1' to the string. >>> increment_string(\\"foo\\") 'foo1' >>> increment_string(\\"foobar23\\") 'foobar24' >>> increment_string(\\"foo0042\\") 'foo0043' >>> increment_string(\\"foo9\\") 'foo10' >>> increment_string(\\"foo099\\") 'foo100' from solution import increment_string def test_increment_string_no_digits(): assert increment_string(\\"foo\\") == \\"foo1\\" def test_increment_string_with_digits(): assert increment_string(\\"foobar23\\") == \\"foobar24\\" def test_increment_string_with_leading_zero_digits(): assert increment_string(\\"foo0042\\") == \\"foo0043\\" def test_increment_string_single_digit(): assert increment_string(\\"foo9\\") == \\"foo10\\" def test_increment_string_double_digit_wrap(): assert increment_string(\\"foo099\\") == \\"foo100\\" def test_increment_string_empty_string(): assert increment_string(\\"\\") == \\"1\\" def test_increment_string_only_digits(): assert increment_string(\\"123\\") == \\"124\\" def test_increment_string_only_digits_with_leading_zeros(): assert increment_string(\\"001\\") == \\"002\\"","solution":"import re def increment_string(s): Takes an input string that consists of letters followed by digits, and returns the string with the digits incremented by 1. If the string does not end with digits, the function appends the digit '1' to the string. match = re.search(r'(d+)', s) if match: number_str = match.group(0) new_number = str(int(number_str) + 1).zfill(len(number_str)) return s[:match.start()] + new_number else: return s + '1'"},{"question":"def min_moves(start, destination): Calculates the minimum number of moves required for the truck to travel from the start location to the destination on a grid. Parameters: start (list): A list containing the x and y coordinates of the start location. destination (list): A list containing the x and y coordinates of the destination. Returns: int: The minimum number of moves required. pass","solution":"def min_moves(start, destination): Calculates the minimum number of moves required for the truck to travel from the start location to the destination on a grid. Parameters: start (list): A list containing the x and y coordinates of the start location. destination (list): A list containing the x and y coordinates of the destination. Returns: int: The minimum number of moves required. x1, y1 = start x2, y2 = destination return abs(x2 - x1) + abs(y2 - y1)"},{"question":"def multiply_strings(x: str, y: str) -> str: Multiplies two non-negative integers represented as strings, and returns the product as a string. >>> multiply_strings(\\"123\\", \\"456\\") \\"56088\\" >>> multiply_strings(\\"25\\", \\"4\\") \\"100\\"","solution":"def multiply_strings(x, y): Multiplies two non-negative integers represented as strings, and returns the product as a string. if x == \\"0\\" or y == \\"0\\": return \\"0\\" x_len = len(x) y_len = len(y) result = [0] * (x_len + y_len) for i in range(x_len - 1, -1, -1): for j in range(y_len - 1, -1, -1): product = int(x[i]) * int(y[j]) p1 = i + j p2 = i + j + 1 sum = product + result[p2] result[p2] = sum % 10 result[p1] += sum // 10 # Skip leading zeros start = 0 while start < len(result) - 1 and result[start] == 0: start += 1 return ''.join(map(str, result[start:]))"},{"question":"def unique_paths(m: int, n: int) -> int: Returns the number of unique paths from the top-left corner to the bottom-right corner of an m x n grid. >>> unique_paths(3, 7) 28 >>> unique_paths(3, 2) 3 >>> unique_paths(2, 2) 2 >>> unique_paths(1, 1) 1 >>> unique_paths(1, 100) 1 >>> unique_paths(100, 1) 1 >>> unique_paths(10, 10) 48620 >>> unique_paths(20, 20) 35345263800","solution":"def unique_paths(m, n): Returns the number of unique paths from the top-left corner to the bottom-right corner of an m x n grid. # Initialize a 2D array with 1s since there's only one way to move either right or down dp = [[1] * n for _ in range(m)] # Fill the dp array with the number of unique paths to each cell for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1]"},{"question":"def arrayManipulator(array: List[int], instructions: List[str]) -> List[int]: Manipulates the given array based on the list of instructions. Parameters: array (list of int): The list of integers to be manipulated. instructions (list of str): The list of instructions to manipulate the array. Returns: list of int: The manipulated array. >>> arrayManipulator([1, 2, 3], [\\"add 4\\", \\"double\\", \\"remove\\", \\"reverse\\"]) [6, 4, 2] >>> arrayManipulator([], [\\"add 1\\", \\"add 2\\", \\"add 3\\"]) [1, 2, 3] >>> arrayManipulator([1, 2, 3], [\\"remove\\"]) [1, 2] >>> arrayManipulator([1, 2, 3], [\\"reverse\\"]) [3, 2, 1] >>> arrayManipulator([1, 2, 3], [\\"double\\"]) [2, 4, 6] >>> arrayManipulator([], [\\"remove\\"]) [] >>> arrayManipulator([], [\\"reverse\\"]) [] >>> arrayManipulator([1], [\\"reverse\\"]) [1] >>> arrayManipulator([0, -1, 1], [\\"double\\"]) [0, -2, 2] >>> arrayManipulator([100], [\\"remove\\", \\"remove\\", \\"remove\\"]) [] >>> arrayManipulator([10], [\\"double\\", \\"double\\", \\"double\\"]) [80]","solution":"def arrayManipulator(array, instructions): Manipulates the given array based on the list of instructions. Parameters: array (list of int): The list of integers to be manipulated. instructions (list of str): The list of instructions to manipulate the array. Returns: list of int: The manipulated array. for instruction in instructions: if instruction.startswith(\\"add\\"): # Extract the number to be added _, num_str = instruction.split() array.append(int(num_str)) elif instruction == \\"remove\\": if array: array.pop() elif instruction == \\"reverse\\": array.reverse() elif instruction == \\"double\\": array = [x * 2 for x in array] return array"},{"question":"def is_beautiful_number(num: int) -> bool: Determines if the given number is a beautiful number. A number is considered beautiful if the sum of its digits, each raised to the power of the number of digits, is equal to the number itself. Args: num (int): The number to be checked. Returns: bool: True if the number is beautiful, False otherwise. Example usage: >>> is_beautiful_number(153) True >>> is_beautiful_number(9474) True >>> is_beautiful_number(9475) False # Write your code here","solution":"def is_beautiful_number(num: int) -> bool: Determines if the given number is a beautiful number. A number is considered beautiful if the sum of its digits, each raised to the power of the number of digits, is equal to the number itself. Args: num (int): The number to be checked. Returns: bool: True if the number is beautiful, False otherwise. if num < 0: return False str_num = str(num) num_digits = len(str_num) sum_of_powers = sum(int(digit) ** num_digits for digit in str_num) return sum_of_powers == num"},{"question":"from typing import List, Tuple, Optional def find_min_max(numbers: List[int]) -> Tuple[Optional[int], Optional[int]]: Returns a tuple containing the minimum and maximum elements in a list of integers. If the list is empty, returns (None, None). >>> find_min_max([3, 5, 1, 2, 4]) (1, 5) >>> find_min_max([-10, 0, 10, 5]) (-10, 10) >>> find_min_max([]) (None, None) >>> find_min_max([7]) (7, 7) >>> find_min_max([-3, -1, -7, -4]) (-7, -1) >>> find_min_max([0, 0, 0, 0]) (0, 0) >>> find_min_max([3, 3, 3, 3, 3]) (3, 3) >>> find_min_max([1000000, 500000, 1000001, -100000]) (-100000, 1000001)","solution":"from typing import List, Tuple, Optional def find_min_max(numbers: List[int]) -> Tuple[Optional[int], Optional[int]]: Returns a tuple containing the minimum and maximum elements in a list of integers. If the list is empty, returns (None, None). if not numbers: return (None, None) return (min(numbers), max(numbers))"},{"question":"def decrypt_string(s: str) -> str: Decrypts the encrypted string where: - all alphabetical characters are shifted by 1 position in the alphabet. - all digits are reversed (0 becomes 9, 1 becomes 8, ..., 9 becomes 0). - spaces and special characters remain unchanged. :param s: encrypted string :return: decrypted string >>> decrypt_string(\\"Ifmmp, Xpsme! 123\\") == \\"Hello, World! 876\\" >>> decrypt_string(\\"Uijt jt b uftu!\\") == \\"This is a test!\\" >>> decrypt_string(\\"bcd\\") == \\"abc\\" >>> decrypt_string(\\"BCD\\") == \\"ABC\\" >>> decrypt_string(\\"9876543210\\") == \\"0123456789\\" >>> decrypt_string(\\",.!?\\") == \\",.!?\\" >>> decrypt_string(\\"\\") == \\"\\" >>> decrypt_string(\\"a\\") == \\"z\\" >>> decrypt_string(\\"A\\") == \\"Z\\" >>> decrypt_string(\\"0\\") == \\"9\\" >>> decrypt_string(\\"9\\") == \\"0\\"","solution":"def decrypt_string(s): Decrypts the encrypted string where: - all alphabetical characters are shifted by 1 position in the alphabet. - all digits are reversed (0 becomes 9, 1 becomes 8, ..., 9 becomes 0). - spaces and special characters remain unchanged. :param s: encrypted string :return: decrypted string decrypted = [] for char in s: if 'a' <= char <= 'z': decrypted.append(chr((ord(char) - ord('a') - 1) % 26 + ord('a'))) elif 'A' <= char <= 'Z': decrypted.append(chr((ord(char) - ord('A') - 1) % 26 + ord('A'))) elif '0' <= char <= '9': decrypted.append(str(9 - int(char))) else: decrypted.append(char) return ''.join(decrypted)"},{"question":"def find_pairs_with_sum(arr: List[int], target: int) -> List[Tuple[int, int]]: Write a function that takes an array of integers and a target integer. The function should return a list of all unique pairs of integers from the array that sum up to the target integer. The pairs should be sorted in ascending order. Each pair should also be in ascending order. The function should return an empty array if no such pairs exist. >>> find_pairs_with_sum([1, 2, 3, 4], 5) [(1, 4), (2, 3)] >>> find_pairs_with_sum([1, 5, 3, 6, 7, 2, 8], 9) [(1, 8), (2, 7), (3, 6)] >>> find_pairs_with_sum([], 5) []","solution":"def find_pairs_with_sum(arr, target): Returns a list of all unique pairs of integers from the array that sum up to the target integer. The pairs are sorted in ascending order. Each pair is also in ascending order. arr.sort() pairs = set() seen = set() for num in arr: complement = target - num if complement in seen: pairs.add((min(num, complement), max(num, complement))) seen.add(num) return sorted(list(pairs))"},{"question":"def decode_clue(clue: str) -> int: Decode the clue by summing the position values of letters and numeric values of digits. >>> decode_clue(\\"AaZ1\\") 29 >>> decode_clue(\\"hello123\\") 58 >>> decode_clue(\\"HELLO\\") 52 >>> decode_clue(\\"world\\") 72 >>> decode_clue(\\"12345\\") 15 >>> decode_clue(\\"\\") 0 >>> decode_clue(\\"xyz\\") 75 >>> decode_clue(\\"hello!123\\") 58","solution":"def decode_clue(clue): Decode the clue by summing the position values of letters and numeric values of digits. Parameters: clue (str): The input clue string containing uppercase letters, lowercase letters, and digits. Returns: int: The sum of the position values of the letters and the numeric values of the digits. total_sum = 0 for char in clue: if char.isdigit(): total_sum += int(char) elif char.isalpha(): total_sum += ord(char.lower()) - ord('a') + 1 return total_sum"},{"question":"def check_sequence(lst: List[int]) -> str: Determines whether the sequence of numbers is strictly increasing, strictly decreasing, or neither. Parameters: lst (list of integers): The list of integers. Returns: str: \\"increasing\\", \\"decreasing\\", or \\"neither\\". Examples: >>> check_sequence([1, 2, 3, 4, 5]) \\"increasing\\" >>> check_sequence([5, 4, 3, 2, 1]) \\"decreasing\\" >>> check_sequence([1, 3, 2, 4, 5]) \\"neither\\" from solution import check_sequence def test_check_sequence_increasing(): assert check_sequence([1, 2, 3, 4, 5]) == \\"increasing\\" def test_check_sequence_decreasing(): assert check_sequence([5, 4, 3, 2, 1]) == \\"decreasing\\" def test_check_sequence_neither(): assert check_sequence([1, 3, 2, 4, 5]) == \\"neither\\" def test_check_sequence_single_element(): assert check_sequence([1]) == \\"neither\\" def test_check_sequence_two_elements_increasing(): assert check_sequence([1, 2]) == \\"increasing\\" def test_check_sequence_two_elements_decreasing(): assert check_sequence([2, 1]) == \\"decreasing\\" def test_check_sequence_two_elements_neither(): assert check_sequence([1, 1]) == \\"neither\\" def test_check_sequence_empty_list(): assert check_sequence([]) == \\"neither\\" def test_check_sequence_all_elements_same(): assert check_sequence([3, 3, 3]) == \\"neither\\" def test_check_sequence_increasing_with_negative_numbers(): assert check_sequence([-3, -2, -1, 0, 1]) == \\"increasing\\" def test_check_sequence_decreasing_with_negative_numbers(): assert check_sequence([0, -1, -2, -3, -4]) == \\"decreasing\\"","solution":"def check_sequence(lst): Determines whether the sequence of numbers is strictly increasing, strictly decreasing, or neither. Parameters: lst (list of integers): The list of integers. Returns: str: \\"increasing\\", \\"decreasing\\", or \\"neither\\". if len(lst) < 2: return \\"neither\\" increasing = all(x < y for x, y in zip(lst, lst[1:])) decreasing = all(x > y for x, y in zip(lst, lst[1:])) if increasing: return \\"increasing\\" elif decreasing: return \\"decreasing\\" else: return \\"neither\\""},{"question":"def min_transforms(s: str) -> int: Returns the minimum number of transformations needed to make the string alternate between 'a' and 'b'. >>> min_transforms(\\"abab\\") 0 >>> min_transforms(\\"aaaa\\") 2 >>> min_transforms(\\"bbaa\\") 2","solution":"def min_transforms(s): Returns the minimum number of transformations needed to make the string alternate between 'a' and 'b'. # Expected patterns pattern1 = 'ab' * ((len(s) + 1) // 2) pattern2 = 'ba' * ((len(s) + 1) // 2) # Trim patterns to match the length of s pattern1 = pattern1[:len(s)] pattern2 = pattern2[:len(s)] # Calculate the number of changes needed for both patterns changes_for_pattern1 = sum(1 for c1, c2 in zip(s, pattern1) if c1 != c2) changes_for_pattern2 = sum(1 for c1, c2 in zip(s, pattern2) if c1 != c2) # Return the minimum of changes needed for both patterns return min(changes_for_pattern1, changes_for_pattern2)"},{"question":"def are_anagrams(str1: str, str2: str) -> bool: Returns True if str2 is an anagram of str1, False otherwise. >>> are_anagrams(\\"listen\\", \\"silent\\") True >>> are_anagrams(\\"hello\\", \\"world\\") False >>> are_anagrams(\\"test\\", \\"testt\\") False >>> are_anagrams(\\"aabb\\", \\"ab\\") False >>> are_anagrams(\\"\\", \\"\\") True >>> are_anagrams(\\"Listen\\", \\"Silent\\") False >>> are_anagrams(\\"a!b@c#\\", \\"#c@b!a\\") True","solution":"def are_anagrams(str1, str2): Returns True if str2 is an anagram of str1, False otherwise. return sorted(str1) == sorted(str2)"},{"question":"class Node: def __init__(self, value): self.value = value self.left = None self.right = None def sumOfLeafNodes(root: Node) -> int: Calculate the sum of all leaf nodes in a binary tree. Given the binary tree: 1 / 2 3 / 4 5 The function should return 11, because the leaf nodes are 2, 4, and 5, and their sum is 2 + 4 + 5 = 11. >>> root = Node(1) >>> root.left = Node(2) >>> root.right = Node(3) >>> root.right.left = Node(4) >>> root.right.right = Node(5) >>> sumOfLeafNodes(root) 11 >>> root = Node(7) >>> root.left = Node(3) >>> root.left.left = Node(1) >>> root.left.right = Node(6) >>> sumOfLeafNodes(root) 7 >>> root = Node(10) >>> sumOfLeafNodes(root) 10 >>> root = Node(3) >>> root.left = Node(2) >>> root.left.left = Node(1) >>> sumOfLeafNodes(root) 1 >>> root = Node(4) >>> root.right = Node(5) >>> root.right.right = Node(6) >>> sumOfLeafNodes(root) 6","solution":"class Node: def __init__(self, value): self.value = value self.left = None self.right = None def sumOfLeafNodes(root: Node) -> int: Returns the sum of all leaf nodes. if not root: return 0 if not root.left and not root.right: return root.value sum_left = sumOfLeafNodes(root.left) sum_right = sumOfLeafNodes(root.right) return sum_left + sum_right"},{"question":"def is_prime(num: int) -> bool: Check if a number is a prime number. >>> is_prime(2) True >>> is_prime(4) False >>> is_prime(11) True # Implement the function to check if num is a prime number def smallest_prime_greater_than(N: int) -> int: Find the smallest prime number greater than N. >>> smallest_prime_greater_than(5) 7 >>> smallest_prime_greater_than(10) 11 >>> smallest_prime_greater_than(15) 17 # Implement the function to find the smallest prime number greater than N def process_test_cases(input_data: str) -> list: Processes multiple test cases and returns their results. >>> input_data = \\"3n5n10n15\\" >>> process_test_cases(input_data) [7, 11, 17] >>> input_data = \\"2n1n1000\\" >>> process_test_cases(input_data) [2, 1009] # Implement the function to process the input test cases","solution":"def is_prime(num): Returns True if num is a prime number, otherwise False. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def smallest_prime_greater_than(N): Returns the smallest prime number greater than N. candidate = N + 1 while not is_prime(candidate): candidate += 1 return candidate def process_test_cases(input_data): Processes multiple test cases and returns their results. T, *cases = map(int, input_data.strip().split()) results = [] for N in cases: results.append(smallest_prime_greater_than(N)) return results"},{"question":"def min_operations_to_transform(words: List[str], target: str) -> int: Determines the minimum number of operations required to transform the target word into one of the words from the list. An operation is defined as changing a single character in the target word to any other character. If it's not possible to transform the target word into any word in the list, returns -1. >>> min_operations_to_transform([\\"hello\\", \\"world\\", \\"apple\\"], \\"hella\\") == 1 >>> min_operations_to_transform([\\"abc\\", \\"def\\", \\"ghi\\"], \\"xyz\\") == -1 >>> min_operations_to_transform([\\"hello\\", \\"world\\", \\"apple\\"], \\"hello\\") == 0 >>> min_operations_to_transform([\\"foo\\", \\"bar\\", \\"baz\\"], \\"boo\\") == 1 >>> min_operations_to_transform([\\"aaa\\", \\"bbb\\", \\"ccc\\"], \\"zzz\\") == 3 import sys # Implement function here","solution":"def min_operations_to_transform(words, target): Determines the minimum number of operations required to transform the target word into one of the words from the list. An operation is defined as changing a single character in the target word to any other character. If it's not possible to transform the target word into any word in the list, returns -1. min_operations = float('inf') for word in words: operations = sum(1 for a, b in zip(word, target) if a != b) min_operations = min(min_operations, operations) return min_operations if min_operations != float('inf') else -1"},{"question":"from typing import List, Tuple def min_stops(flights: List[Tuple[str, str]], start: str, destination: str) -> int: Determine the minimum number of stops required for a passenger to travel from a start city to a destination city using a series of direct flights. Return -1 if the destination is not reachable. >>> flights = [(\\"A\\", \\"B\\"), (\\"B\\", \\"C\\"), (\\"A\\", \\"C\\"), (\\"C\\", \\"D\\")] >>> min_stops(flights, \\"A\\", \\"D\\") 2 >>> flights = [(\\"A\\", \\"B\\"), (\\"B\\", \\"C\\"), (\\"C\\", \\"D\\")] >>> min_stops(flights, \\"A\\", \\"E\\") -1","solution":"from collections import deque from typing import List, Tuple def min_stops(flights: List[Tuple[str, str]], start: str, destination: str) -> int: if start == destination: return 0 # Create adjacency list to represent the flight connections graph = {} for source, dest in flights: if source not in graph: graph[source] = [] if dest not in graph: graph[dest] = [] graph[source].append(dest) graph[dest].append(source) # since flights can be used in either direction # Perform BFS to find the shortest path queue = deque([(start, 0)]) # (current_city, stops) visited = set() visited.add(start) while queue: current_city, stops = queue.popleft() for neighbor in graph.get(current_city, []): if neighbor == destination: return stops + 1 if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, stops + 1)) return -1"},{"question":"def score_word(word: str, values: dict) -> int: Calculate the total score of a word based on the values of the letters and the rules given. Parameters: word (str): The word to be scored. values (dict): A dictionary where keys are lowercase letters and values are integer points. Returns: int: The total score of the word. Examples: >>> score_word(\\"apple\\", {'a': 1, 'p': 3, 'l': 2, 'e': 4}) 13 >>> score_word(\\"bob\\", {'b': 2, 'o': 3}) 7 >>> score_word(\\"world\\", {'w': 4, 'o': 3, 'r': 2, 'l': 1, 'd': 5}) 15 >>> score_word(\\"\\", {'a': 1, 'b': 2}) 0 >>> score_word(\\"aaaaa\\", {'a': 2}) 10 >>> score_word(\\"zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\\", {'z': 3}) 150","solution":"def score_word(word, values): Calculate the total score of a word based on the values of the letters and the rules given. Parameters: word (str): The word to be scored. values (dict): A dictionary where keys are lowercase letters and values are integer points. Returns: int: The total score of the word. from collections import Counter letter_counts = Counter(word) total_score = 0 for letter, count in letter_counts.items(): total_score += values[letter] * count return total_score"},{"question":"def most_frequent_letter(s: str) -> str: Returns the most frequently occurring letter in the string. In case of a tie, the letter that comes first alphabetically is returned. Spaces are ignored. >>> most_frequent_letter(\\"hello world\\") 'l' >>> most_frequent_letter(\\"a\\") 'a' >>> most_frequent_letter(\\"abcdefghij\\") 'a' >>> most_frequent_letter(\\"abcdeaaaaabbbbcccdde\\") 'a' >>> most_frequent_letter(\\"a a a b b c\\") 'a' >>> most_frequent_letter(\\" ab a\\") 'a' >>> most_frequent_letter(\\"azbycxdwevfugthsirjqkplonm\\") 'a'","solution":"def most_frequent_letter(s: str) -> str: Returns the most frequently occurring letter in the string. In case of a tie, the letter that comes first alphabetically is returned. Spaces are ignored. from collections import Counter # Filter out spaces and count frequency of each letter filtered_chars = [char for char in s if char.isalpha()] frequency = Counter(filtered_chars) # Find the letter with highest frequency most_frequent = max(frequency, key=lambda x: (frequency[x], -ord(x))) return most_frequent"},{"question":"def calculate_mode(numbers: List[int]) -> int: Given a list of integers, find the mode of the list. The mode is the number that appears most frequently in the list. If there are multiple such numbers, return the smallest one. >>> calculate_mode([1, 2, 3, 3, 4, 4, 4, 2, 2, 2]) == 2 >>> calculate_mode([1, 1, 2, 2, 3, 3]) == 1 >>> calculate_mode([5]) == 5 >>> calculate_mode([7, 7, 7, 7]) == 7 >>> calculate_mode([100, 200, 100, 300, 200, 100]) == 100 >>> calculate_mode([10, 10, 20, 20, 30, 30, 40]) == 10 >>> calculate_mode([6, 7, 8, 9, 10, 11]) == 6","solution":"def calculate_mode(numbers): Returns the mode of the list. If multiple numbers appear most frequently, it returns the smallest one. count_dict = {} for number in numbers: if number in count_dict: count_dict[number] += 1 else: count_dict[number] = 1 max_count = 0 mode = float('inf') for number, count in count_dict.items(): if count > max_count or (count == max_count and number < mode): max_count = count mode = number return mode"},{"question":"def isBalanced(s: str) -> bool: Returns whether the given string s has properly nested and balanced brackets. >>> isBalanced(\\"()\\") True >>> isBalanced(\\"[{()}]\\") True >>> isBalanced(\\"{[}]\\") False >>> isBalanced(\\"((()))\\") True >>> isBalanced(\\"({[)})\\") False","solution":"def isBalanced(s): Returns whether the given string s has properly nested and balanced brackets. stack = [] bracket_map = {')': '(', '}': '{', ']': '['} for char in s: if char in bracket_map.values(): stack.append(char) elif char in bracket_map.keys(): if stack == [] or bracket_map[char] != stack.pop(): return False else: # If there is any other character in the string, we just ignore continue return stack == []"},{"question":"def find_anagrams(word: str, word_list: list) -> list: Given a word and a list of words, return a list of words from the provided list that are anagrams of the given word. >>> find_anagrams(\\"listen\\", [\\"enlists\\", \\"google\\", \\"inlets\\", \\"banana\\"]) [\\"inlets\\"] >>> find_anagrams(\\"race\\", [\\"care\\", \\"acre\\", \\"race\\", \\"races\\"]) [\\"care\\", \\"acre\\", \\"race\\"] >>> find_anagrams(\\"hello\\", [\\"hello\\", \\"olelh\\", \\"world\\", \\"loleh\\"]) [\\"hello\\", \\"olelh\\", \\"loleh\\"] >>> find_anagrams(\\"a\\", [\\"a\\", \\"b\\", \\"aa\\", \\"a\\"]) [\\"a\\", \\"a\\"]","solution":"def find_anagrams(word, word_list): Returns a list of words from the provided word_list that are anagrams of the given word. sorted_word = ''.join(sorted(word)) return [w for w in word_list if ''.join(sorted(w)) == sorted_word]"},{"question":"def find_kth_largest(k: int, nums: List[int]) -> int: Returns the kth largest element in the list 'nums'. >>> find_kth_largest(2, [3, 2, 1, 5, 6, 4]) == 5 >>> find_kth_largest(4, [3, 2, 3, 1, 2, 4, 5, 5, 6]) == 4 >>> find_kth_largest(1, [1]) == 1 >>> find_kth_largest(2, [3, 3, 3, 3, 3]) == 3 >>> find_kth_largest(3, [-1, -2, -3, -4, -5]) == -3 >>> find_kth_largest(6, [3, 2, 1, 5, 6, 4]) == 1","solution":"def find_kth_largest(k, nums): Returns the kth largest element in the list 'nums'. nums.sort(reverse=True) return nums[k-1]"},{"question":"def fizz_buzz(n: int) -> List[str]: Generates a string array with n elements following the FizzBuzz rules. >>> fizz_buzz(15) [\\"1\\", \\"2\\", \\"Fizz\\", \\"4\\", \\"Buzz\\", \\"Fizz\\", \\"7\\", \\"8\\", \\"Fizz\\", \\"Buzz\\", \\"11\\", \\"Fizz\\", \\"13\\", \\"14\\", \\"FizzBuzz\\"] >>> fizz_buzz(5) [\\"1\\", \\"2\\", \\"Fizz\\", \\"4\\", \\"Buzz\\"]","solution":"def fizz_buzz(n): Generates a string array with n elements following the FizzBuzz rules. result = [] for i in range(1, n + 1): if i % 3 == 0 and i % 5 == 0: result.append(\\"FizzBuzz\\") elif i % 3 == 0: result.append(\\"Fizz\\") elif i % 5 == 0: result.append(\\"Buzz\\") else: result.append(str(i)) return result"},{"question":"def find_min_max_pages(n: int, pages: List[int], k: int) -> int: You are given an array of integers representing the number of pages in n books. You need to distribute these books among k students in such a way that each student gets a contiguous segment of the books. The goal is to minimize the maximum number of pages that a student can receive. >>> find_min_max_pages(4, [10, 20, 30, 40], 2) 60 >>> find_min_max_pages(1, [100], 1) 100 >>> find_min_max_pages(4, [10, 10, 10, 10], 4) 10 >>> find_min_max_pages(5, [100, 200, 300, 400, 500], 2) 900 >>> find_min_max_pages(3, [10, 20, 30], 5) 30 >>> find_min_max_pages(6, [100, 100, 100, 100, 100, 100], 3) 200 >>> find_min_max_pages(5, [40, 20, 30, 10, 50], 1) 150 pass","solution":"def is_possible(pages, n, k, max_pages): student_count = 1 current_sum = 0 for page in pages: current_sum += page if current_sum > max_pages: student_count += 1 current_sum = page if student_count > k: return False return True def find_min_max_pages(n, pages, k): low, high = max(pages), sum(pages) result = high while low <= high: mid = (low + high) // 2 if is_possible(pages, n, k, mid): result = mid high = mid - 1 else: low = mid + 1 return result"},{"question":"def rotate_string(s: str, n: int) -> str: Rotates the string s to the right by n positions. >>> rotate_string(\\"abcdef\\", 2) 'efabcd' >>> rotate_string(\\"hello\\", 1) 'ohell' >>> rotate_string(\\"rotate\\", 3) 'aterot' >>> rotate_string(\\"example\\", 7) 'example' >>> rotate_string(\\"python\\", 0) 'python' >>> rotate_string(\\"shift\\", 10) 'shift'","solution":"def rotate_string(s, n): Rotates the string s to the right by n positions. length = len(s) n = n % length # Ensure n is within the bounds of the string length return s[-n:] + s[:-n]"},{"question":"def contains_all_alphabet(string: str) -> bool: Checks if the given string contains every letter of the alphabet at least once. Ignores case and non-alphabet characters. >>> contains_all_alphabet(\\"The quick brown fox jumps over a lazy dog\\") == True >>> contains_all_alphabet(\\"Hello, World!\\") == False >>> contains_all_alphabet(\\"Cwm fjord bank glyphs vext quiz\\") == True >>> contains_all_alphabet(\\"Pack my box with five dozen liquor jugs\\") == True >>> contains_all_alphabet(\\"A wizard’s job is to vex chumps quickly in fog.\\") == True","solution":"def contains_all_alphabet(string): Checks if the given string contains every letter of the alphabet at least once. Ignores case and non-alphabet characters. alphabet_set = set(\\"abcdefghijklmnopqrstuvwxyz\\") string_set = set(c.lower() for c in string if c.isalpha()) return alphabet_set <= string_set"},{"question":"def patternMatch(pattern: str, string: str) -> bool: Determine whether a given string follows a specific pattern. >>> patternMatch(\\"abab\\", \\"redblueredblue\\") True >>> patternMatch(\\"aaaa\\", \\"asdasdasdasd\\") True >>> patternMatch(\\"aabb\\", \\"xyzabcxyabc\\") False","solution":"def patternMatch(pattern, string): def backtrack(pattern, string, pat_map, str_set): if not pattern: return not string pat_char = pattern[0] if pat_char in pat_map: word = pat_map[pat_char] if not string.startswith(word): return False return backtrack(pattern[1:], string[len(word):], pat_map, str_set) for i in range(1, len(string) - len(pattern) + 2): word = string[:i] if word in str_set: continue pat_map[pat_char] = word str_set.add(word) if backtrack(pattern[1:], string[i:], pat_map, str_set): return True del pat_map[pat_char] str_set.remove(word) return False return backtrack(pattern, string, {}, set())"},{"question":"def find_connected_components(graph): Returns a list of sets, each set containing nodes of a connected component in the graph. >>> find_connected_components({0: [1, 2], 1: [0, 3], 2: [0], 3: [1], 4: [5], 5: [4]}) == [{0, 1, 2, 3}, {4, 5}] >>> find_connected_components({0: [2], 1: [], 2: [0], 3: []}) == [{0, 2}, {1}, {3}] >>> find_connected_components({}) == [] >>> find_connected_components({0: [], 1: [], 2: []}) == [{0}, {1}, {2}] >>> find_connected_components({0: [1, 2, 3], 1: [0, 2, 3], 2: [0, 1, 3], 3: [0, 1, 2]}) == [{0, 1, 2, 3}]","solution":"def find_connected_components(graph): Returns a list of sets, each set containing nodes of a connected component in the graph. def dfs(node, visited, component): visited.add(node) component.add(node) for neighbor in graph.get(node, []): if neighbor not in visited: dfs(neighbor, visited, component) visited = set() components = [] for node in graph: if node not in visited: component = set() dfs(node, visited, component) components.append(component) return components"},{"question":"import random from typing import List def poker_chip_tournament(players: List[int], games_per_round: int) -> List[int]: Simulate an elimination-style poker chip tournament. Each player starts with a set number of poker chips, and players take rounds to play against each other. Each round consists of a predetermined number of games, and depending on the outcome of each game, poker chips are transferred between players according to the tournament rules. By the end of a match, some players may be eliminated if their chip count drops to zero. Parameters: players (List[int]): A list of integers where each element represents the number of chips a player has at the beginning of the tournament. games_per_round (int): An integer indicating the number of games played per round between each pair of players. Returns: List[int]: A list of integers representing the number of chips each player has at the end of the tournament. If a player has been eliminated (by reaching zero chips), they should not appear in the final list. >>> random.seed(0) >>> poker_chip_tournament([7, 3, 5, 2], 3) [11] >>> poker_chip_tournament([5, 5, 5], 3) [5] >>> poker_chip_tournament([2, 1, 2, 2], 3) [3] >>> poker_chip_tournament([0, 0, 0, 0], 3) []","solution":"import random def poker_chip_tournament(players, games_per_round): while len(players) > 1: next_round = [] for i in range(0, len(players) - 1, 2): player1_chips = players[i] player2_chips = players[i + 1] for _ in range(games_per_round): if player1_chips > 0 and player2_chips > 0: if random.choice([True, False]): # player 1 wins player1_chips += 1 player2_chips -= 1 else: # player 2 wins player1_chips -= 1 player2_chips += 1 if player1_chips > 0: next_round.append(player1_chips) if player2_chips > 0: next_round.append(player2_chips) if len(players) % 2 == 1 and players[-1] > 0: next_round.append(players[-1]) players = next_round return players"},{"question":"def is_circular_prime(n: int) -> bool: Determine if a number is a circular prime. Circular prime is a prime number that, in any cyclic permutation of its digits, results in a prime number. >>> is_circular_prime(197) True >>> is_circular_prime(1193) True >>> is_circular_prime(101) False","solution":"def is_prime(n): Check if a number is a prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def rotate_number(n): Generate all rotations of a number. s = str(n) rotations = [] for i in range(len(s)): rotated = int(s[i:] + s[:i]) rotations.append(rotated) return rotations def is_circular_prime(n): Determine if a number is a circular prime. if not is_prime(n): return False rotations = rotate_number(n) for rotation in rotations: if not is_prime(rotation): return False return True"},{"question":"def inverted_numerical_triangle(N: int): Prints an inverted numerical triangle with a height of N. Each line contains decreasing numbers starting from N. >>> inverted_numerical_triangle(3) 3 2 1 3 2 3 >>> inverted_numerical_triangle(4) 4 3 2 1 4 3 2 4 3 4","solution":"def inverted_numerical_triangle(N): Prints an inverted numerical triangle with a height of N. Each line contains decreasing numbers starting from N. for i in range(N): for j in range(N, i, -1): print(j, end=' ') print()"},{"question":"def canFormPalindrome(s: str) -> bool: Determines whether it is possible to rearrange the letters in s to form a palindrome. >>> canFormPalindrome(\\"civic\\") True >>> canFormPalindrome(\\"ivicc\\") True >>> canFormPalindrome(\\"hello\\") False >>> canFormPalindrome(\\"aabbcc\\") True","solution":"def canFormPalindrome(s): Determines whether it is possible to rearrange the letters in s to form a palindrome. :param s: A string of lowercase English letters. :return: True if it is possible to rearrange s to form a palindrome, False otherwise. from collections import Counter count = Counter(s) # A string can be rearranged to form a palindrome if at most one character has an odd count. odd_count = sum(1 for c in count if count[c] % 2 != 0) return odd_count <= 1"},{"question":"def is_anagram(str1: str, str2: str) -> bool: Check if two given strings are anagrams of each other. >>> is_anagram(\\"listen\\", \\"silent\\") True >>> is_anagram(\\"triangle\\", \\"integral\\") True >>> is_anagram(\\"apple\\", \\"pale\\") False >>> is_anagram(\\"Listen\\", \\"Silent\\") True >>> is_anagram(\\"Conversation\\", \\"Voices rant on\\") True >>> is_anagram(\\"A gentleman!\\", \\"Elegant man\\") True","solution":"def is_anagram(str1, str2): Check if two given strings are anagrams of each other. from collections import Counter # Remove spaces and punctuation, and convert to lower case str1_clean = ''.join(e for e in str1 if e.isalnum()).lower() str2_clean = ''.join(e for e in str2 if e.isalnum()).lower() # Compare character counts return Counter(str1_clean) == Counter(str2_clean)"},{"question":"def merge_and_sort(list1: List[int], list2: List[int]) -> List[int]: Merges two lists into a single list, removes duplicates, and sorts in descending order. >>> merge_and_sort([1, 3, 5, 7], [2, 4, 6, 8]) [8, 7, 6, 5, 4, 3, 2, 1] >>> merge_and_sort([4, 1, 4, 2], [3, 6, 1]) [6, 4, 3, 2, 1] >>> merge_and_sort([16, 4, 7, 14], [12, 8, 7, 3, 14]) [16, 14, 12, 8, 7, 4, 3] >>> merge_and_sort([], []) [] >>> merge_and_sort([1, 2, 3], []) [3, 2, 1] >>> merge_and_sort([], [4, 5, 6]) [6, 5, 4] >>> merge_and_sort([1, 2, 3], [1, 2, 3]) [3, 2, 1]","solution":"def merge_and_sort(list1, list2): Merges two lists into a single list, removes duplicates, and sorts in descending order. Args: list1 (list): The first list of integers. list2 (list): The second list of integers. Returns: list: The merged, deduplicated, and sorted list in descending order. merged_list = list1 + list2 unique_list = list(set(merged_list)) sorted_list = sorted(unique_list, reverse=True) return sorted_list"},{"question":"def compress_string(s: str) -> str: Compresses the string using the counts of repeated characters. If the compressed string is not smaller, returns the original string. >>> compress_string(\\"aabcccccaaa\\") \\"a2b1c5a3\\" >>> compress_string(\\"abc\\") \\"abc\\" >>> compress_string(\\"abbbbbbbbbbbb\\") \\"a1b12\\"","solution":"def compress_string(s: str) -> str: Compresses the string using the counts of repeated characters. If the compressed string is not smaller, returns the original string. if not s: return s compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1]) compressed.append(str(count)) count = 1 # Adding the last repeated sequence compressed.append(s[-1]) compressed.append(str(count)) compressed_string = ''.join(compressed) return compressed_string if len(compressed_string) < len(s) else s"},{"question":"def navigate_to_corner(n: int) -> str: Returns a valid sequence of moves to guide the robot from the center of the grid to the upper-left corner. >>> navigate_to_corner(3) 'UL' >>> navigate_to_corner(5) 'UULL' >>> navigate_to_corner(7) 'UUULLL' >>> navigate_to_corner(9) 'UUUULLLL' >>> navigate_to_corner(11) 'UUUUULLLLL' >>> navigate_to_corner(13) 'UUUUUULLLLLL' >>> navigate_to_corner(15) 'UUUUUUULLLLLLL'","solution":"def navigate_to_corner(n: int) -> str: Returns a valid sequence of moves to guide the robot from the center of the grid to the upper-left corner. center = n // 2 moves = 'U' * center + 'L' * center return moves"},{"question":"def valid_palindrome(s: str) -> bool: Determines if the given string can be made into a palindrome by deleting at most one character. Parameters: s (str): The input string. Returns: bool: True if the string can be made into a palindrome by deleting one character, False otherwise. >>> valid_palindrome(\\"aba\\") True >>> valid_palindrome(\\"abca\\") True >>> valid_palindrome(\\"abc\\") False >>> valid_palindrome(\\"a\\") True >>> valid_palindrome(\\"racecar\\") True >>> valid_palindrome(\\"deified\\") True >>> valid_palindrome(\\"abccba\\") True >>> valid_palindrome(\\"abccbda\\") True >>> valid_palindrome(\\"abcdef\\") False >>> valid_palindrome(\\"tacocat\\") True >>> valid_palindrome(\\"\\") True >>> valid_palindrome(\\"aa\\") True >>> valid_palindrome(\\"ab\\") True >>> valid_palindrome(\\"abc\\") False >>> valid_palindrome(\\"aba\\") True","solution":"def valid_palindrome(s): Determines if the given string can be made into a palindrome by deleting at most one character. Parameters: s (str): The input string. Returns: bool: True if the string can be made into a palindrome by deleting one character, False otherwise. def is_palindrome_range(i, j): Helper function to check if the substring s[i:j+1] is a palindrome. return all(s[k] == s[j-k+i] for k in range(i, (j+i)//2+1)) left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: return is_palindrome_range(left+1, right) or is_palindrome_range(left, right-1) left += 1 right -= 1 return True"},{"question":"def unique_chars(s: str) -> str: Returns a string with unique characters preserved in the order of their first appearance. :param s: Input string containing alphanumeric characters and punctuation marks. :return: String containing unique characters from the input string. >>> unique_chars('programming is fun!') 'progamin sfu!' >>> unique_chars('hello world') 'helo wrd'","solution":"def unique_chars(s): Returns a string with unique characters preserved in the order of their first appearance. :param s: Input string containing alphanumeric characters and punctuation marks. :return: String containing unique characters from the input string. seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) return ''.join(result) # Example usage print(unique_chars('programming is fun!')) # should return 'progamin sfu!' print(unique_chars('hello world')) # should return 'helo wrd'"},{"question":"def fibonacci(n: int) -> List[int]: Returns the first n elements of the Fibonacci sequence. >>> fibonacci(5) == [0, 1, 1, 2, 3] >>> fibonacci(7) == [0, 1, 1, 2, 3, 5, 8] >>> fibonacci(1) == [0] >>> fibonacci(2) == [0, 1]","solution":"def fibonacci(n): Returns the first n elements of the Fibonacci sequence. if n <= 0: return [] if n == 1: return [0] sequence = [0, 1] while len(sequence) < n: sequence.append(sequence[-1] + sequence[-2]) return sequence"},{"question":"import math from typing import List, Tuple def min_distance(points: List[Tuple[int, int]]) -> float: Returns the minimum distance between any two distinct points in the list. :param points: List of tuples representing points in 2D space. :return: Minimum distance between any two points. Examples: >>> min_distance([(0,0), (3,4), (6,8)]) 5.0 >>> min_distance([(1,1), (-1,-1), (1,-1), (-1,1)]) 2.0 >>> min_distance([(0,0), (0,1), (1,0), (1,1)]) 1.0 pass","solution":"import math def min_distance(points): Returns the minimum distance between any two distinct points in the list. :param points: List of tuples representing points in 2D space. :return: Minimum distance between any two points. min_dist = float('inf') n = len(points) for i in range(n): for j in range(i + 1, n): dist = math.sqrt((points[j][0] - points[i][0])**2 + (points[j][1] - points[i][1])**2) if dist < min_dist: min_dist = dist return min_dist"},{"question":"def assign_tasks(tasks, hours): This function takes a list of tasks and available hours, and assigns the most prioritized tasks that can be done within those hours. tasks: list of tuples, where each tuple (priority, time). hours: int, total number of hours available in the sprint. Returns a list of tasks (the same tuple format) that can be completed within the given hours, ordered by priority and time estimate. >>> assign_tasks([], 10) [] >>> assign_tasks([(3, 2)], 0) [] >>> assign_tasks([(3, 2)], 10) [(3, 2)] >>> assign_tasks([(3, 2)], 1) [] >>> assign_tasks([(3, 2), (5, 4), (2, 2)], 6) [(5, 4), (3, 2)] >>> assign_tasks([(3, 2), (5, 4), (2, 2)], 3) [(3, 2)] >>> assign_tasks([(3, 2), (3, 1), (2, 2)], 3) [(3, 1), (3, 2)] >>> assign_tasks([(3, 2), (3, 1), (5, 4), (2, 2)], 7) [(5, 4), (3, 1), (3, 2)]","solution":"def assign_tasks(tasks, hours): This function takes a list of tasks and available hours, and assigns the most prioritized tasks that can be done within those hours. tasks: list of tuples, where each tuple (priority, time). hours: int, total number of hours available in the sprint. Returns a list of tasks (the same tuple format) that can be completed within the given hours, ordered by priority and time estimate. if not tasks or hours < 1: return [] # Sort tasks by priority (descending) and time estimate (ascending) sorted_tasks = sorted(tasks, key=lambda x: (-x[0], x[1])) assigned_tasks = [] remaining_hours = hours for task in sorted_tasks: if task[1] <= remaining_hours: assigned_tasks.append(task) remaining_hours -= task[1] return assigned_tasks"},{"question":"def check_palindrome_permutation(s: str) -> bool: Determines if any permutation of the string \`s\` is a palindrome. >>> check_palindrome_permutation('civic') == True >>> check_palindrome_permutation('ivicc') == True >>> check_palindrome_permutation('hello') == False >>> check_palindrome_permutation('aabb') == True >>> check_palindrome_permutation('a') == True >>> check_palindrome_permutation('ab') == False >>> check_palindrome_permutation('') == True","solution":"def check_palindrome_permutation(s): Determines if any permutation of the string \`s\` is a palindrome. from collections import Counter # Count the occurrences of each character char_count = Counter(s) # Palindrome condition: at most one character with an odd count odd_count = 0 for count in char_count.values(): if count % 2 != 0: odd_count += 1 if odd_count > 1: return False return True"},{"question":"def find_missing(nums: List[int]) -> int: Returns the smallest positive integer missing from the list of integers. >>> find_missing([1, 2, 0]) == 3 >>> find_missing([3, 4, -1, 1]) == 2 >>> find_missing([1, 2, 3]) == 4","solution":"def find_missing(nums): Returns the smallest positive integer missing from the list of integers. n = len(nums) # Step 1: Place each number in its right place if possible for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] # Step 2: Find the first number which is not in the right place for i in range(n): if nums[i] != i + 1: return i + 1 # If all numbers are in the right place, return next positive integer return n + 1"},{"question":"import re from typing import List def word_count(input_string: str) -> int: Design a function that counts the number of words in a given String. The function should ignore punctuation and return the total word count. A word is defined as any sequence of non-punctuation characters separated by spaces. >>> word_count(\\"Hello, world!\\") 2 >>> word_count(\\"This is a sample text.\\") 5","solution":"import re def word_count(input_string): Counts the number of words in a given string. The function ignores punctuation and returns the total word count. # Use regex to replace punctuations with empty string cleaned_string = re.sub(r'[^ws]', '', input_string) # Split the string by whitespace to get the words words = cleaned_string.split() # Return the number of words return len(words)"},{"question":"def maximize_sum(arr: list, k: int) -> int: Return the maximum possible sum that can be achieved by adding exactly k elements from the array of unique positive integers. Parameters: arr (list): A list of unique positive integers. k (int): The number of elements to add. Returns: int: The maximum sum of k elements. Examples: >>> maximize_sum([4, 2, 5, 1, 6], 3) 15 >>> maximize_sum([10, 20, 30, 40, 50], 2) 90","solution":"def maximize_sum(arr, k): This function returns the maximum possible sum by adding exactly k elements from the array. Parameters: arr (list): A list of unique positive integers. k (int): The number of elements to add. Returns: int: The maximum sum of k elements. # Sort the array in descending order to get the largest elements first arr.sort(reverse=True) # Take the first k elements from the sorted array max_elements = arr[:k] # Return the sum of these k elements return sum(max_elements)"},{"question":"import heapq class MedianFinder: A data structure that supports the dynamic insertion of integers and finding the median of all current elements. Example: >>> medianFinder = MedianFinder(); >>> medianFinder.addNum(1) # arr = [1] >>> medianFinder.addNum(2) # arr = [1, 2] >>> medianFinder.findMedian() # returns 1.5 >>> medianFinder.addNum(3) # arr = [1, 2, 3] >>> medianFinder.findMedian() # returns 2 def __init__(self): Initialize your data structure here. def addNum(self, num: int) -> None: Add a new integer to the data structure. def findMedian(self) -> float: Return the median of all elements so far. # Unit Tests def test_median_finder_single_element(): mf = MedianFinder() mf.addNum(1) assert mf.findMedian() == 1 def test_median_finder_two_elements(): mf = MedianFinder() mf.addNum(1) mf.addNum(2) assert mf.findMedian() == 1.5 def test_median_finder_three_elements(): mf = MedianFinder() mf.addNum(1) mf.addNum(2) mf.addNum(3) assert mf.findMedian() == 2 def test_median_finder_even_elements(): mf = MedianFinder() mf.addNum(1) mf.addNum(2) mf.addNum(3) mf.addNum(4) assert mf.findMedian() == 2.5 def test_median_finder_varied_elements(): mf = MedianFinder() mf.addNum(10) mf.addNum(20) mf.addNum(30) mf.addNum(40) mf.addNum(50) assert mf.findMedian() == 30 mf.addNum(60) assert mf.findMedian() == 35 mf.addNum(70) mf.addNum(80) assert mf.findMedian() == 45","solution":"import heapq class MedianFinder: def __init__(self): Initialize your data structure here. self.min_heap = [] # Min-heap for the larger half self.max_heap = [] # Max-heap for the smaller half def addNum(self, num: int) -> None: Add a new integer to the data structure. # Push the new number to max-heap (invert the number for max-heap behavior using min-heap) heapq.heappush(self.max_heap, -num) # Balance the heaps if necessary if self.max_heap and self.min_heap and (-self.max_heap[0]) > self.min_heap[0]: heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap)) # Always ensure min_heap has the larger half and max_heap has the smaller half if len(self.min_heap) > len(self.max_heap): heapq.heappush(self.max_heap, -heapq.heappop(self.min_heap)) elif len(self.max_heap) > len(self.min_heap) + 1: heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap)) def findMedian(self) -> float: Return the median of all elements so far. if len(self.max_heap) > len(self.min_heap): return -self.max_heap[0] return (-self.max_heap[0] + self.min_heap[0]) / 2.0"},{"question":"def roman_to_integer(roman: str) -> int: Converts a Roman numeral to an integer. :param roman: str: The Roman numeral to convert. :return: int: The integer representation of the Roman numeral. >>> roman_to_integer(\\"I\\") == 1 >>> roman_to_integer(\\"IV\\") == 4 >>> roman_to_integer(\\"VI\\") == 6 >>> roman_to_integer(\\"IX\\") == 9 >>> roman_to_integer(\\"MCMXCIV\\") == 1994 >>> roman_to_integer(\\"III\\") == 3 >>> roman_to_integer(\\"LVIII\\") == 58 >>> roman_to_integer(\\"MMMCMXCIX\\") == 3999 >>> roman_to_integer(\\"DCCCXLV\\") == 845 >>> roman_to_integer(\\"CCVII\\") == 207","solution":"def roman_to_integer(roman): Converts a Roman numeral to an integer. :param roman: str: The Roman numeral to convert. :return: int: The integer representation of the Roman numeral. roman_values = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 } total = 0 prev_value = 0 for char in roman[::-1]: current_value = roman_values[char] if current_value >= prev_value: total += current_value else: total -= current_value prev_value = current_value return total"},{"question":"def longest_substring_with_two_distinct_characters(s: str) -> int: Given a string, returns the length of the longest substring that contains no more than two distinct characters. Args: s (str): the input string. Returns: int: the length of the longest substring that contains no more than two distinct characters. Examples: >>> longest_substring_with_two_distinct_characters(\\"eceba\\") 3 >>> longest_substring_with_two_distinct_characters(\\"ccaabbb\\") 5","solution":"def longest_substring_with_two_distinct_characters(s): Returns the length of the longest substring that contains no more than two distinct characters. if len(s) == 0: return 0 max_length = 0 start = 0 char_count = {} for end in range(len(s)): char_count[s[end]] = char_count.get(s[end], 0) + 1 while len(char_count) > 2: char_count[s[start]] -= 1 if char_count[s[start]] == 0: del char_count[s[start]] start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"def find_playlist(song_lengths: List[int], desired_duration: int) -> List[int]: Determines if there exists a combination of songs from the list that exactly matches the desired playlist duration. If such a combination exists, return one of the possible combinations as a list of song lengths. If no such combination exists, return an empty list. >>> find_playlist([120, 150, 200, 180, 150], 450) [120, 150, 180] >>> find_playlist([120, 150, 200, 180, 150], 1000) []","solution":"from typing import List def find_playlist(song_lengths: List[int], desired_duration: int) -> List[int]: Returns a combination of song lengths that add up to the desired duration. If no such combination exists, returns an empty list. def helper(index, remaining_duration, path): if remaining_duration == 0: return path if index >= len(song_lengths) or remaining_duration < 0: return None # Include the current song include_current = helper(index + 1, remaining_duration - song_lengths[index], path + [song_lengths[index]]) if include_current: return include_current # Skip the current song return helper(index + 1, remaining_duration, path) result = helper(0, desired_duration, []) return result if result is not None else []"},{"question":"def generateRomanNumerals(num: int) -> str: Converts an integer to its corresponding Roman numeral representation. >>> generateRomanNumerals(1) \\"I\\" >>> generateRomanNumerals(14) \\"XIV\\" >>> generateRomanNumerals(3999) \\"MMMCMXCIX\\"","solution":"def generateRomanNumerals(num): Converts an integer to its corresponding Roman numeral representation. :param num: Integer from 1 to 3999. :return: Roman numeral string. value_pairs = [ (1000, \\"M\\"), (900, \\"CM\\"), (500, \\"D\\"), (400, \\"CD\\"), (100, \\"C\\"), (90, \\"XC\\"), (50, \\"L\\"), (40, \\"XL\\"), (10, \\"X\\"), (9, \\"IX\\"), (5, \\"V\\"), (4, \\"IV\\"), (1, \\"I\\") ] result = [] for value, roman in value_pairs: while num >= value: result.append(roman) num -= value return \\"\\".join(result)"},{"question":"def stack_operations(operations: List[str]) -> List[Union[int, str]]: Simulate stack operations and return the top element of the stack after each operation. >>> stack_operations([\\"push 4\\"]) [4] >>> stack_operations([\\"pop\\"]) [\\"EMPTY\\"] >>> stack_operations([\\"push 4\\", \\"pop\\"]) [4, \\"EMPTY\\"] >>> stack_operations([\\"push 4\\", \\"push 8\\", \\"inc 2 3\\"]) [4, 8, 11] >>> stack_operations([\\"push 4\\", \\"push 8\\", \\"pop\\", \\"inc 2 3\\", \\"push 6\\", \\"inc 3 1\\"]) [4, 8, 4, 7, 6, 7]","solution":"def stack_operations(operations): stack = [] result = [] for operation in operations: if operation.startswith(\\"push\\"): _, x = operation.split() stack.append(int(x)) elif operation == \\"pop\\": if stack: stack.pop() elif operation.startswith(\\"inc\\"): _, k, x = operation.split() k, x = int(k), int(x) for i in range(min(k, len(stack))): stack[i] += x if stack: result.append(stack[-1]) else: result.append(\\"EMPTY\\") return result"},{"question":"from typing import List, Tuple def min_waterings(t: int, test_cases: List[Tuple[int, str]]) -> List[int]: Determine the minimum number of watering actions needed to water all the flowers in the row. Parameters: t (int): Number of test cases test_cases (List[Tuple[int, str]]): List of tuples of the range of each watering action and the string representing the pots Returns: List[int]: List of minimum number of watering actions for each test case Example: >>> min_waterings(3, [(2, \\"11001\\"), (3, \\"100100\\"), (4, \\"1111\\")]) [2, 2, 1] >>> min_waterings(2, [(1, \\"010101\\"), (5, \\"00000\\")]) [3, 0]","solution":"def min_waterings(t, test_cases): results = [] for k, pots in test_cases: n = len(pots) actions = 0 i = 0 while i < n: if pots[i] == '1': actions += 1 i += k else: i += 1 results.append(actions) return results"},{"question":"def max_sum_subsequence(arr: List[int], k: int) -> int: Returns the maximum sum of a subsequence with exactly k elements. Example: >>> max_sum_subsequence([5, 2, 3, 1, 9], 3) 17 >>> max_sum_subsequence([8, 4, 7, 2, 1, 10], 2) 18 >>> max_sum_subsequence([1, 2, 3, 4, 5], 5) 15","solution":"def max_sum_subsequence(arr, k): Returns the maximum sum of a subsequence with exactly k elements. # Sort the array in descending order sorted_arr = sorted(arr, reverse=True) # Sum the first k elements of the sorted array max_sum = sum(sorted_arr[:k]) return max_sum"},{"question":"def kth_smallest_element(array: List[int], k: int) -> int: Finds the k-th smallest element in an unsorted array of integers. :param array: List of unsorted integers :param k: The position (1-based) of the smallest element to find :return: The k-th smallest element in the array >>> kth_smallest_element([7, 10, 4, 3, 20, 15], 3) 7 >>> kth_smallest_element([7, 10, 4, 3, 20, 15], 4) 10 pass","solution":"def kth_smallest_element(array, k): Finds the k-th smallest element in the array. :param array: List of integers :param k: The position (1-based) of the smallest element to find :return: The k-th smallest element in the array array.sort() return array[k-1]"},{"question":"def knapsack(items, max_weight): Determines the maximum value a player can carry without exceeding the weight limit. Parameters: - items: List of tuples, where each tuple consists of (weight, value) - max_weight: Integer representing the maximum weight limit Returns: - Integer representing the maximum value that can be carried. >>> items = [(2, 3), (3, 4), (4, 5), (5, 6)] >>> max_weight = 5 >>> knapsack(items, max_weight) 7","solution":"def knapsack(items, max_weight): Determines the maximum value a player can carry without exceeding the weight limit. Parameters: - items: List of tuples, where each tuple consists of (weight, value) - max_weight: Integer representing the maximum weight limit Returns: - Integer representing the maximum value that can be carried. n = len(items) # Initialize the DP table with 0s for each [item + 1][weight limit + 1] dp = [[0 for _ in range(max_weight + 1)] for _ in range(n + 1)] for i in range(1, n + 1): for w in range(max_weight + 1): weight, value = items[i - 1] if weight <= w: dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weight] + value) else: dp[i][w] = dp[i - 1][w] return dp[n][max_weight]"},{"question":"def is_palindromic(n): Check if the number n is a palindromic number. pass def sum_palindromic_numbers_in_range(A, B): Calculate the sum of all palindromic numbers within the inclusive range [A, B]. pass def process_test_cases(test_cases): Process multiple test cases and return the results as a list. pass from solution import is_palindromic, sum_palindromic_numbers_in_range, process_test_cases def test_is_palindromic(): assert is_palindromic(121) assert is_palindromic(12321) assert not is_palindromic(123) assert not is_palindromic(12345) def test_sum_palindromic_numbers_in_range(): assert sum_palindromic_numbers_in_range(1, 10) == 45 # from problem statement example assert sum_palindromic_numbers_in_range(100, 150) == 605 # from problem statement example assert sum_palindromic_numbers_in_range(1, 1) == 1 assert sum_palindromic_numbers_in_range(10, 10) == 0 assert sum_palindromic_numbers_in_range(11, 11) == 11 def test_process_test_cases(): assert process_test_cases([(1, 10), (100, 150)]) == [45, 605] assert process_test_cases([(1, 1), (10, 10), (11, 11)]) == [1, 0, 11] test_is_palindromic() test_sum_palindromic_numbers_in_range() test_process_test_cases()","solution":"def is_palindromic(n): Check if the number n is a palindromic number. s = str(n) return s == s[::-1] def sum_palindromic_numbers_in_range(A, B): Calculate the sum of all palindromic numbers within the inclusive range [A, B]. return sum(n for n in range(A, B+1) if is_palindromic(n)) def process_test_cases(test_cases): Process multiple test cases and return the results as a list. results = [] for A, B in test_cases: results.append(sum_palindromic_numbers_in_range(A, B)) return results"},{"question":"def mergeSort(arr): Sorts an array of integers using the merge sort algorithm. Merge sort is a divide-and-conquer algorithm that splits the array into two halves, calls itself for the two halves, and then merges the two sorted halves. This ensures the array is sorted in O(n log n) time complexity. >>> arr1 = [5, 2, 9, 1, 5, 6] >>> mergeSort(arr1) >>> arr1 [1, 2, 5, 5, 6, 9] >>> arr2 = [12, 11, 13, 5, 6, 7] >>> mergeSort(arr2) >>> arr2 [5, 6, 7, 11, 12, 13] >>> arr3 = [1] >>> mergeSort(arr3) >>> arr3 [1] >>> arr4 = [2, 3, 5, 7, 11] >>> mergeSort(arr4) >>> arr4 [2, 3, 5, 7, 11]","solution":"def mergeSort(arr): if len(arr) > 1: mid = len(arr) // 2 left_half = arr[:mid] right_half = arr[mid:] mergeSort(left_half) mergeSort(right_half) i = j = k = 0 while i < len(left_half) and j < len(right_half): if left_half[i] < right_half[j]: arr[k] = left_half[i] i += 1 else: arr[k] = right_half[j] j += 1 k += 1 while i < len(left_half): arr[k] = left_half[i] i += 1 k += 1 while j < len(right_half): arr[k] = right_half[j] j += 1 k += 1"},{"question":"def balanceChecker(expression: str) -> bool: Returns True if the input string contains balanced brackets, otherwise False. >>> balanceChecker(\\"{[()]}\\") True >>> balanceChecker(\\"{[(])}\\") False >>> balanceChecker(\\"{{[[(())]]}}\\") True >>> balanceChecker(\\"()\\") True >>> balanceChecker(\\"()[]{}\\") True >>> balanceChecker(\\"(]\\") False >>> balanceChecker(\\"([)]\\") False >>> balanceChecker(\\"{[]}\\") True >>> balanceChecker(\\"{{([][])}()}\\") True >>> balanceChecker(\\"{{([][]))}()}\\") False >>> balanceChecker(\\"[\\") False >>> balanceChecker(\\"]\\") False >>> balanceChecker(\\"[{}]\\") True","solution":"def balanceChecker(expression): Returns True if the input string contains balanced brackets, otherwise False. # Stack to keep track of opening brackets stack = [] # Mapping of closing to opening brackets bracket_map = {')': '(', '}': '{', ']': '['} # Iterate through each character in the expression for char in expression: # If the character is a closing bracket if char in bracket_map: # Pop an element from stack if available, else use a dummy value top_element = stack.pop() if stack else '#' # Check if the mapping for the closing bracket matches the top element of the stack if bracket_map[char] != top_element: return False else: # If it's an opening bracket, push to stack stack.append(char) # Check if stack is empty (all opening brackets have been matched) return not stack"},{"question":"def can_form_palindrome(s: str) -> str: Determines if the string can be rearranged to form a palindrome. A palindrome is a string that reads the same forward and backward. Args: s (str): A string consisting of alphanumeric characters and special characters. Returns: str: \\"YES\\" if the string can be rearranged to form a palindrome, otherwise \\"NO\\". Examples: >>> can_form_palindrome(\\"aabb\\") \\"YES\\" >>> can_form_palindrome(\\"abc\\") \\"NO\\"","solution":"def can_form_palindrome(s): Determines if the string can be rearranged to form a palindrome. from collections import Counter count = Counter(s) odd_count = sum(1 for char, cnt in count.items() if cnt % 2 != 0) # For a string to be rearranged into a palindrome, # there can be at most one character with an odd count. if odd_count > 1: return \\"NO\\" return \\"YES\\""},{"question":"def total_service_time(n: int, p: int, arrival_times: List[int]) -> int: Calculate the total time taken by the machine to service all passengers' payments. Parameters: n (int): Number of passengers. p (int): Processing time for each payment in seconds. arrival_times (list): List of arrival times of passengers in non-decreasing order. Returns: int: The total time taken to service all payments. Examples: >>> total_service_time(3, 2, [1, 3, 6]) 8 >>> total_service_time(4, 5, [2, 2, 3, 8]) 22 >>> total_service_time(0, 5, []) 0 >>> total_service_time(2, 3, [1, 1]) 7 >>> total_service_time(2, 5, [1000000000, 1000000000]) 1000000010 >>> total_service_time(1, 1, [1]) 2 >>> total_service_time(1, 0, [100]) 100","solution":"def total_service_time(n, p, arrival_times): Calculate the total time taken by the machine to service all passengers' payments. Parameters: n (int): Number of passengers. p (int): Processing time for each payment in seconds. arrival_times (list): List of arrival times of passengers in non-decreasing order. Returns: int: The total time taken to service all payments. if n == 0: return 0 # Initialize the current time to when the first passenger arrives current_time = 0 for time in arrival_times: if time >= current_time: # If the machine is idle (arrival time is greater than or equal to current_time), # The machine starts processing at the arrival time current_time = time + p else: # If the machine is busy (arrival time is less than current_time), # The passenger waits until the machine is free current_time += p return current_time"},{"question":"def repeat_words(sentence: str, n: int) -> str: Returns a modified string where each word in the sentence appears \`n\` times consecutively. Parameters: - sentence: str : input string containing words separated by spaces - n: int : number of times each word should be repeated Returns: - str : a modified string with each word appearing \`n\` times consecutively Examples: >>> repeat_words(\\"hello world\\", 2) \\"hello hello world world\\" >>> repeat_words(\\"python\\", 3) \\"python python python\\" >>> repeat_words(\\"open ai\\", 1) \\"open ai\\" >>> repeat_words(\\"\\", 4) \\"\\" >>> repeat_words(\\"code\\", 0) \\"\\" from solution import repeat_words def test_repeat_words_basic(): assert repeat_words(\\"hello world\\", 2) == \\"hello hello world world\\" def test_repeat_words_single_word_multiple_repeats(): assert repeat_words(\\"python\\", 3) == \\"python python python\\" def test_repeat_words_single_repeats(): assert repeat_words(\\"open ai\\", 1) == \\"open ai\\" def test_repeat_words_empty_string(): assert repeat_words(\\"\\", 4) == \\"\\" def test_repeat_words_n_zero(): assert repeat_words(\\"code\\", 0) == \\"\\" def test_repeat_words_multiple_spaces(): assert repeat_words(\\"a b c\\", 2) == \\"a a b b c c\\" def test_repeat_words_long_input(): assert repeat_words(\\"repeat this sentence\\", 2) == \\"repeat repeat this this sentence sentence\\"","solution":"def repeat_words(sentence: str, n: int) -> str: Returns a modified string where each word in the sentence appears \`n\` times consecutively. Parameters: - sentence: str : input string containing words separated by spaces - n: int : number of times each word should be repeated Returns: - str : a modified string with each word appearing \`n\` times consecutively if not sentence or n < 1: return \\"\\" words = sentence.split() repeated_words = [word for word in words for _ in range(n)] return ' '.join(repeated_words)"},{"question":"def find_friends_of_friends(network: Dict[str, List[str]], user: str) -> List[str]: Returns a list of friends-of-friends for the specified user, excluding their direct friends and the user themselves. Args: network (Dict[str, List[str]]): A dictionary where keys are user names and values are lists of friends. user (str): The user for whom we want to find friends-of-friends. Returns: List[str]: A list of unique friends-of-friends for the specified user.","solution":"def find_friends_of_friends(network, user): Returns a list of friends-of-friends for the specified user, excluding their direct friends and the user themselves. direct_friends = set(network.get(user, [])) fof = set() for friend in direct_friends: if friend in network: for fof_candidate in network[friend]: if fof_candidate != user and fof_candidate not in direct_friends: fof.add(fof_candidate) return list(fof)"},{"question":"def find_ranges(nums): Returns a string representing all the ranges of consecutive integers within the list of nums. >>> find_ranges([1, 2, 3, 5, 7, 8, 9, 11]) '1-3,5,7-9,11' >>> find_ranges([4, 5, 6, 10, 12, 13, 14, 15, 20]) '4-6,10,12-15,20' >>> find_ranges([1, 2, 4, 6, 7, 9]) '1-2,4,6-7,9'","solution":"def find_ranges(nums): Returns a string representing all the ranges of consecutive integers within the list of nums. if not nums: return \\"\\" ranges = [] start = nums[0] end = nums[0] for n in nums[1:]: if n == end + 1: end = n else: if start == end: ranges.append(f\\"{start}\\") else: ranges.append(f\\"{start}-{end}\\") start = n end = n if start == end: ranges.append(f\\"{start}\\") else: ranges.append(f\\"{start}-{end}\\") return \\",\\".join(ranges)"},{"question":"def three_sum(nums): Given an array of integers nums, a feasible triplet is defined as three indices (i, j, k) such that 0 <= i < j < k < nums.length and nums[i] + nums[j] + nums[k] == 0. Return all unique feasible triplets from the array. Note: The solution set must not contain duplicate triplets. >>> three_sum([-1, 0, 1, 2, -1, -4]) [[-1, -1, 2], [-1, 0, 1]] >>> three_sum([]) [] >>> three_sum([0]) []","solution":"def three_sum(nums): Returns all unique triplets in the array which gives the sum of zero. nums.sort() result = [] for i in range(len(nums) - 2): if i > 0 and nums[i] == nums[i-1]: continue left, right = i + 1, len(nums) - 1 while left < right: s = nums[i] + nums[left] + nums[right] if s < 0: left += 1 elif s > 0: right -= 1 else: result.append([nums[i], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 return result"},{"question":"def min_additions_to_palindrome(s: str) -> int: Returns the minimum number of characters needed to be added to the string to make it a palindrome. >>> min_additions_to_palindrome(\\"abcd\\") 3 >>> min_additions_to_palindrome(\\"race\\") 3","solution":"def min_additions_to_palindrome(s): Returns the minimum number of characters needed to be added to the string to make it a palindrome. def is_palindrome(s): return s == s[::-1] for i in range(len(s)): if is_palindrome(s[i:]): return i return len(s) # should never reach here"},{"question":"def canBePalindrome(s: str) -> bool: Given a string s, return True if it can become a palindrome by removing at most one character, otherwise return False. Args: s (str): The input string containing a mixture of uppercase and lowercase letters. Returns: bool: True if the string can become a palindrome by removing at most one character, otherwise False. Examples: >>> canBePalindrome(\\"racecar\\") True >>> canBePalindrome(\\"raccecar\\") True >>> canBePalindrome(\\"abc\\") False","solution":"def canBePalindrome(s: str) -> bool: Given a string s, return True if it can become a palindrome by removing at most one character, otherwise return False. Args: s (str): The input string containing a mixture of uppercase and lowercase letters. Returns: bool: True if the string can become a palindrome by removing at most one character, otherwise False. def is_palindrome_range(start, end): return all(s[i] == s[end - i + start] for i in range(start, (end + start) // 2 + 1)) start, end = 0, len(s) - 1 while start < end: if s[start] != s[end]: # Try removing character at start or character at end return is_palindrome_range(start + 1, end) or is_palindrome_range(start, end - 1) start += 1 end -= 1 return True"},{"question":"def spiralOrder(matrix): Returns the elements of the given matrix in spiral order. >>> spiralOrder([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [1, 2, 3, 6, 9, 8, 7, 4, 5] >>> spiralOrder([ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12] ... ]) [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7] >>> spiralOrder([ ... [1], ... [2], ... [3], ... [4] ... ]) [1, 2, 3, 4] >>> spiralOrder([[1, 2, 3, 4]]) [1, 2, 3, 4] >>> spiralOrder([]) [] >>> spiralOrder([[1]]) [1]","solution":"def spiralOrder(matrix): Returns the elements of the given matrix in spiral order. if not matrix or not matrix[0]: return [] spiral_order = [] top, bottom = 0, len(matrix) - 1 left, right = 0, len(matrix[0]) - 1 while top <= bottom and left <= right: # Traverse from left to right for i in range(left, right + 1): spiral_order.append(matrix[top][i]) top += 1 # Traverse from top to bottom for i in range(top, bottom + 1): spiral_order.append(matrix[i][right]) right -= 1 if top <= bottom: # Traverse from right to left for i in range(right, left - 1, -1): spiral_order.append(matrix[bottom][i]) bottom -= 1 if left <= right: # Traverse from bottom to top for i in range(bottom, top - 1, -1): spiral_order.append(matrix[i][left]) left += 1 return spiral_order"},{"question":"def reverse_words(text: str) -> str: Takes a string of mixed messages and returns the string with each word's characters reversed, but the word order remains unchanged. Args: text (str): Input string with words. Returns: str: A string where each word's characters are reversed, but the word order is maintained. Examples: >>> reverse_words(\\"Hello World\\") 'olleH dlroW' >>> reverse_words(\\"\\") '' >>> reverse_words(\\"Python\\") 'nohtyP' >>> reverse_words(\\"Python is fun\\") 'nohtyP si nuf' >>> reverse_words(None) None","solution":"def reverse_words(text: str) -> str: Takes a string of mixed messages and returns the string with each word's characters reversed, but the word order remains unchanged. Args: text (str): Input string with words. Returns: str: A string where each word's characters are reversed, but the word order is maintained. if text is None or text == '': return text return ' '.join(word[::-1] for word in text.split())"},{"question":"def min_operations(initial: List[int], target: List[int]) -> int: Returns the minimum number of operations required to transform the initial sequence into the target sequence. >>> min_operations([1, 2, 3], [3, 2, 1]) == 4 >>> min_operations([-1, 4], [1, 0]) == 6 >>> min_operations([0], [0]) == 0 >>> min_operations([1], [-1]) == 2 >>> min_operations([5, 5, 5], [5, 5, 5]) == 0 >>> min_operations([-10000, 10000], [10000, -10000]) == 40000 >>> min_operations([-5, 0, 5], [5, 0, -5]) == 20","solution":"def min_operations(initial, target): Returns the minimum number of operations required to transform the initial sequence into the target sequence. n = len(initial) operations = 0 for i in range(n): operations += abs(target[i] - initial[i]) return operations"},{"question":"def rob(nums: List[int]) -> int: Calculate the maximum amount of money that can be robbed without robbing two consecutive houses. :param nums: List[int], representing the amount of money available in each house :return: maximum amount of money that can be robbed >>> rob([2, 7, 9, 3, 1]) 12 >>> rob([2, 1, 1, 2]) 4 >>> rob([1, 2, 3, 1]) 4 >>> rob([2, 1, 1, 3]) 5 >>> rob([2, 1]) 2 >>> rob([2]) 2 >>> rob([]) 0 >>> rob([1, 2, 9, 4, 5, 0, 4, 11, 6]) 26 >>> rob([0, 0, 0, 0, 0]) 0","solution":"def rob(nums): Calculate the maximum amount of money that can be robbed without robbing two consecutive houses. :param nums: List[int], representing the amount of money available in each house :return: maximum amount of money that can be robbed if not nums: return 0 if len(nums) == 1: return nums[0] prev1, prev2 = 0, 0 for num in nums: temp = max(prev1, prev2 + num) prev2 = prev1 prev1 = temp return prev1"},{"question":"def longest_group_length(s: str) -> int: Given a string consisting of lowercase English letters, this function finds the length of the longest group of the same characters. >>> longest_group_length(\\"abbcccddddeee\\") 4 >>> longest_group_length(\\"a\\") 1 >>> longest_group_length(\\"abcde\\") 1","solution":"def longest_group_length(s): Given a string, finds the length of the longest group of the same characters. Args: s: str - Input string consisting of lowercase English letters. Returns: int - Length of the longest group of the same character. if not s: return 0 max_length = 1 current_length = 1 for i in range(1, len(s)): if s[i] == s[i-1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 return max(max_length, current_length)"},{"question":"def longest_word(sentence: str) -> str: Returns the longest word in a given sentence. If there are multiple words with the same maximum length, it returns the one which appears first. >>> longest_word(\\"word\\") == \\"word\\" >>> longest_word(\\"this is a test sentence\\") == \\"sentence\\" >>> longest_word(\\"cat bat hat\\") == \\"cat\\" >>> longest_word(\\"\\") == \\"\\" >>> longest_word(\\" \\") == \\"\\" >>> longest_word(\\"This is A TEST Sentence\\") == \\"Sentence\\"","solution":"def longest_word(sentence): Returns the longest word in a given sentence. If there are multiple words with the same maximum length, it returns the one which appears first. words = sentence.split() max_length = 0 longest = \\"\\" for word in words: if len(word) > max_length: max_length = len(word) longest = word return longest"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Given a list of integers, return a new list such that each element at index i of the new list is the product of all the numbers in the original list except nums[i]. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([-1, 1, 0, -3, 3]) [0, 0, 9, 0, 0]","solution":"def product_except_self(nums): Given a list of integers, returns a new list such that each element at index i of the new list is the product of all the numbers in the original list except nums[i]. length = len(nums) result = [1] * length # Initialize the result array with 1 # Calculate products of all elements to the left of each index left_product = 1 for i in range(length): result[i] = left_product left_product *= nums[i] # Calculate products of all elements to the right of each index right_product = 1 for i in range(length - 1, -1, -1): result[i] *= right_product right_product *= nums[i] return result"},{"question":"from typing import List def highest_product_of_three(lst: List[int]) -> int: Given an array of integers, find the highest product you can get from three of the integers in the array. Args: lst (List[int]): List of integers Returns: int: The highest product of three integers Examples: >>> highest_product_of_three([1, 10, 2, 6, 5, 3]) 300 >>> highest_product_of_three([-10, -10, 5, 2]) 500 >>> highest_product_of_three([1, 2, 3, 4]) 24 pass def test_highest_product_of_three(): assert highest_product_of_three([1, 10, 2, 6, 5, 3]) == 300 def test_highest_product_of_three_with_negatives(): assert highest_product_of_three([-10, -10, 5, 2]) == 500 def test_highest_product_of_three_all_positives(): assert highest_product_of_three([1, 2, 3, 4]) == 24 def test_highest_product_of_three_mixed(): assert highest_product_of_three([-10, 1, 3, 2, -10]) == 300 def test_highest_product_of_three_large_numbers(): assert highest_product_of_three([1000, 10000, 100]) == 1000000000 def test_highest_product_of_three_minimum(): assert highest_product_of_three([-1, -2, -3]) == -6","solution":"from typing import List def highest_product_of_three(lst: List[int]) -> int: # Initialize the highest and lowest values as the first two values of the list highest = max(lst[0], lst[1]) lowest = min(lst[0], lst[1]) # Initialize the max product of two lowest and two highest numbers highest_product_of_2 = lst[0] * lst[1] lowest_product_of_2 = lst[0] * lst[1] # Initialize the max product of three numbers highest_product_of_3 = lst[0] * lst[1] * lst[2] # Traverse the list, starting from the third element for i in range(2, len(lst)): current = lst[i] # Update the highest product of three highest_product_of_3 = max( highest_product_of_3, current * highest_product_of_2, current * lowest_product_of_2 ) # Update the highest and lowest products of two values highest_product_of_2 = max( highest_product_of_2, current * highest, current * lowest ) lowest_product_of_2 = min( lowest_product_of_2, current * highest, current * lowest ) # Update the highest and lowest values highest = max(highest, current) lowest = min(lowest, current) return highest_product_of_3"},{"question":"def are_anagrams(str1: str, str2: str) -> bool: Determines if two strings are anagrams of each other. An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. The function should ignore spaces, punctuation, and should treat uppercase and lowercase letters as equivalent. >>> are_anagrams(\\"Listen\\", \\"Silent\\") True >>> are_anagrams(\\"A gentleman\\", \\"Elegant man\\") True >>> are_anagrams(\\"Clint Eastwood\\", \\"Old West Action\\") True >>> are_anagrams(\\"Hello\\", \\"Olelh\\") True >>> are_anagrams(\\"Programming\\", \\"Gram Ring Mop\\") True >>> are_anagrams(\\"Hello\\", \\"World\\") False >>> are_anagrams(\\"\\", \\"\\") True >>> are_anagrams(\\"abc\\", \\"\\") False >>> are_anagrams(\\"abc\\", \\"abcd\\") False >>> are_anagrams(\\"12345\\", \\"54321\\") True >>> are_anagrams(\\"a1b2c3\\", \\"3c2b1a\\") True from solution import are_anagrams def test_anagrams_ignore_case(): assert are_anagrams(\\"Listen\\", \\"Silent\\") == True def test_anagrams_with_spaces(): assert are_anagrams(\\"A gentleman\\", \\"Elegant man\\") == True def test_anagrams_with_punctuation(): assert are_anagrams(\\"Clint Eastwood\\", \\"Old West Action\\") == True def test_anagrams_simple_case(): assert are_anagrams(\\"Hello\\", \\"Olelh\\") == True def test_anagrams_with_mixed_characters(): assert are_anagrams(\\"Programming\\", \\"Gram Ring Mop\\") == True def test_not_anagrams(): assert are_anagrams(\\"Hello\\", \\"World\\") == False def test_empty_strings(): assert are_anagrams(\\"\\", \\"\\") == True def test_one_empty_string(): assert are_anagrams(\\"abc\\", \\"\\") == False def test_different_lengths(): assert are_anagrams(\\"abc\\", \\"abcd\\") == False def test_anagrams_with_numbers(): assert are_anagrams(\\"12345\\", \\"54321\\") == True def test_anagrams_with_mixed_numbers_and_letters(): assert are_anagrams(\\"a1b2c3\\", \\"3c2b1a\\") == True","solution":"def are_anagrams(str1: str, str2: str) -> bool: Determines if two strings are anagrams of each other, ignoring spaces, punctuation, and considering uppercase and lowercase as equivalent. # Remove spaces and convert to lowercase cleaned_str1 = ''.join(e for e in str1 if e.isalnum()).lower() cleaned_str2 = ''.join(e for e in str2 if e.isalnum()).lower() # Compare sorted versions of the cleaned strings return sorted(cleaned_str1) == sorted(cleaned_str2)"},{"question":"from typing import List def max_difference(nums: List[int]) -> int: Given an integer array nums, find the maximum value of nums[i] - nums[j] such that i < j. If no valid pair (i, j) exists, return -1. >>> max_difference([7, 1, 5, 4]) == 4 >>> max_difference([9, 4, 3, 2]) == -1 >>> max_difference([1, 5, 2, 10]) == 9 # Implement the function here # Unit test def test_max_difference_example1(): assert max_difference([7, 1, 5, 4]) == 4 def test_max_difference_example2(): assert max_difference([9, 4, 3, 2]) == -1 def test_max_difference_example3(): assert max_difference([1, 5, 2, 10]) == 9 def test_max_difference_single_element(): assert max_difference([1]) == -1 def test_max_difference_increasing_order(): assert max_difference([1, 2, 3, 4, 5]) == 4 def test_max_difference_decreasing_order(): assert max_difference([5, 4, 3, 2, 1]) == -1 def test_max_difference_mixed_values(): assert max_difference([-10, 5, -2, 8, -1]) == 18","solution":"def max_difference(nums): Returns the maximum value of nums[i] - nums[j] such that i < j. If no valid pair (i, j) exists, return -1. if len(nums) < 2: return -1 min_value = nums[0] max_diff = -1 for i in range(1, len(nums)): if nums[i] > min_value: max_diff = max(max_diff, nums[i] - min_value) min_value = min(min_value, nums[i]) return max_diff"},{"question":"def twoSum(nums: List[int], target: int) -> Tuple[int, int]: Given an array of integers, find two numbers such that they add up to a specific target. The function should return the indices of the two numbers as a tuple. Parameters: nums (List[int]): List of integers. target (int): The target sum. Returns: Tuple[int, int]: Indices of the two numbers that add up to the target. >>> twoSum([2, 7, 11, 15], 9) (0, 1) >>> twoSum([3, 3], 6) (0, 1) >>> twoSum([3, 2, 4], 6) (1, 2)","solution":"def twoSum(nums, target): Given an array of integers, find two numbers such that they add up to a specific target. The function should return the indices of the two numbers as a tuple. Parameters: nums (List[int]): List of integers. target (int): The target sum. Returns: Tuple[int, int]: Indices of the two numbers that add up to the target. nums_map = {} for i, num in enumerate(nums): complement = target - num if complement in nums_map: return (nums_map[complement], i) nums_map[num] = i"},{"question":"def add_commas(number: int) -> str: Adds commas as thousand separators in a given non-negative integer. >>> add_commas(1234) # returns \\"1,234\\" >>> add_commas(1000000) # returns \\"1,000,000\\"","solution":"def add_commas(number): Adds commas as thousand separators in a given non-negative integer. :param number: non-negative integer :return: string representation of the number with commas return f\\"{number:,}\\""},{"question":"def min_absolute_difference(n, a): This function finds the minimum possible absolute difference of the sums of two groups that can be formed from the array \`a\` with \`n\` integers. >>> min_absolute_difference(4, [1, 6, 11, 5]) 1 >>> min_absolute_difference(3, [1, 4, 9]) 4","solution":"def min_absolute_difference(n, a): This function finds the minimum possible absolute difference of the sums of two groups that can be formed from the array \`a\` with \`n\` integers. total_sum = sum(a) target = total_sum // 2 dp = [False] * (target + 1) dp[0] = True for num in a: for j in range(target, num - 1, -1): dp[j] = dp[j] or dp[j - num] for i in range(target, -1, -1): if dp[i]: group1_sum = i break return abs(total_sum - 2 * group1_sum)"},{"question":"def find_peak_element(arr: List[int]) -> int: Returns the index of a peak element in the list. A peak element is one that is greater than its neighbors. If the list has multiple peaks, return the index of any one of them. If there are no peaks, return -1. :param arr: List of integers representing the heights of a mountain. :return: Index of any peak element or -1 if there are no peaks. pass def test_peak_in_middle(): assert find_peak_element([1, 3, 20, 4, 1, 0]) == 2 def test_multiple_peaks(): result = find_peak_element([10, 20, 15, 2, 23, 90, 67]) assert result == 1 or result == 5 def test_increasing_sequence(): assert find_peak_element([10, 20, 30, 40, 50]) == 4 def test_single_element(): assert find_peak_element([42]) == 0 def test_first_element_peak(): assert find_peak_element([5, 1, 2]) == 0 def test_last_element_peak(): assert find_peak_element([1, 2, 3, 4, 5]) == 4 def test_all_elements_same(): assert find_peak_element([2, 2, 2, 2, 2]) == -1","solution":"def find_peak_element(arr): Returns the index of a peak element in the list. A peak element is one that is greater than its neighbors. If the list has multiple peaks, return the index of any one of them. If there are no peaks, return -1. :param arr: List of integers representing the heights of a mountain. :return: Index of any peak element or -1 if there are no peaks. n = len(arr) if n == 1: return 0 for i in range(n): if (i == 0 and arr[i] > arr[i + 1]) or (i == n - 1 and arr[i] > arr[i - 1]) or (0 < i < n - 1 and arr[i] > arr[i - 1] and arr[i] > arr[i + 1]): return i return -1"},{"question":"from collections import deque from typing import List, Tuple, Union def shortest_path_maze(t: int, test_cases: List[Tuple[int, int, List[str]]]) -> List[Union[int, str]]: Solves the maze problem finding the shortest path from (0,0) to (n-1,m-1). Parameters: t (int): number of test cases test_cases (list): list of tuples where each tuple is (n, m, grid) n (int): number of rows in the grid m (int): number of columns in the grid grid (list): n x m grid representation of the maze where 'X' is an obstacle and '.' is a free space Returns: list: list of results for each test case, where the result is either length of the shortest path or \\"IMPOSSIBLE\\" if no path exists >>> shortest_path_maze(2, [(5, 5, [\\".....\\", \\".X.X.\\", \\".....\\", \\".X.X.\\", \\".....\\"]), (3, 3, [\\".X.\\", \\"XXX\\", \\".X.\\"])]) [8, \\"IMPOSSIBLE\\"] >>> shortest_path_maze(1, [(3, 3, [\\"...\\", \\".X.\\", \\"...\\"])]) [4] >>> shortest_path_maze(1, [(3, 3, [\\"...\\", \\"XXX\\", \\"..X\\"])]) [\\"IMPOSSIBLE\\"] >>> shortest_path_maze(1, [(4, 4, [\\"....\\", \\"X.X.\\", \\"X.X.\\", \\"....\\"])]) [6] >>> shortest_path_maze(1, [(1, 1, [\\".\\"])]) [0]","solution":"from collections import deque def shortest_path_maze(t, test_cases): Solves the maze problem finding the shortest path from (0,0) to (n-1,m-1). Parameters: t (int): number of test cases test_cases (list): list of tuples where each tuple is (n, m, grid) n (int): number of rows in the grid m (int): number of columns in the grid grid (list): n x m grid representation of the maze where 'X' is an obstacle and '.' is a free space Returns: list: list of results for each test case, where the result is either length of the shortest path or \\"IMPOSSIBLE\\" if no path exists results = [] for case in test_cases: n, m, grid = case queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set((0, 0)) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, down, left, right def is_valid(x, y): return 0 <= x < n and 0 <= y < m and grid[x][y] == '.' and (x, y) not in visited found = False while queue and not found: x, y, dist = queue.popleft() if (x, y) == (n-1, m-1): results.append(dist) found = True break for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny): visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) if not found: results.append(\\"IMPOSSIBLE\\") return results # Example usage: # t = 2 # test_cases = [ # (5, 5, [\\".....\\", \\".X.X.\\", \\".....\\", \\".X.X.\\", \\".....\\"]), # (3, 3, [\\".X.\\", \\"XXX\\", \\".X.\\"]) # ] # print(shortest_path_maze(t, test_cases)) # Output: [8, \\"IMPOSSIBLE\\"]"},{"question":"from typing import List def shortest_path_with_treasures(n: int, m: int, grid: List[str]) -> str: Find the shortest path from the top-left to the bottom-right corner of the grid, collecting as many treasures as possible. >>> shortest_path_with_treasures(5, 5, [\\"T...T\\", \\".#.#.\\", \\"T.....\\", \\".#.#.\\", \\"T...T\\"]) '8 3' >>> shortest_path_with_treasures(3, 3, [\\"T.#\\", \\".#.\\", \\"#.T\\"]) '-1' >>> shortest_path_with_treasures(1, 5, [\\"T.T.T\\"]) '4 2' >>> shortest_path_with_treasures(5, 1, [\\"T\\", \\".\\", \\"T\\", \\".\\", \\"T\\"]) '4 2' >>> shortest_path_with_treasures(2, 2, [\\"..\\", \\"..\\"]) '2 0' >>> shortest_path_with_treasures(2, 2, [\\"T.\\", \\"\\"]) '-1'","solution":"from collections import deque def find_shortest_path(n, m, grid): # Directions for moving up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] def is_valid(x, y): return 0 <= x < n and 0 <= y < m and grid[x][y] != '#' visited = [[[False, 0] for _ in range(m)] for _ in range(n)] queue = deque([(0, 0, 0, 0)]) # (row, col, distance, treasures) while queue: x, y, dist, treasures = queue.popleft() if not is_valid(x, y) or visited[x][y][0]: continue visited[x][y] = [True, treasures] if (x, y) == (n-1, m-1): return dist, treasures for dx, dy in directions: new_x, new_y = x + dx, y + dy if is_valid(new_x, new_y): extra_treasure = 1 if grid[new_x][new_y] == 'T' else 0 queue.append((new_x, new_y, dist + 1, treasures + extra_treasure)) return -1 def shortest_path_with_treasures(n, m, grid): result = find_shortest_path(n, m, grid) if result == -1: return \\"-1\\" else: dist, treasures = result return f\\"{dist} {treasures}\\""},{"question":"def min_days_to_complete(tasks: List[int], k: int) -> int: Given an array of integers tasks and an integer k, determine the minimum number of days required to complete all tasks using exactly k workers. If it is impossible to complete all the tasks, return -1. Example: >>> min_days_to_complete([1, 2, 3, 4, 5], 2) 3 >>> min_days_to_complete([7, 7, 7], 3) 1 >>> min_days_to_complete([1, 1, 1, 1, 1, 1], 1) 6 >>> min_days_to_complete([5, 5, 5, 5], 2) 2","solution":"def min_days_to_complete(tasks, k): Returns the minimum number of days required to finish all tasks. if k <= 0: return -1 # Calculate the length and number of batches needed n = len(tasks) # If we have more workers than tasks, 1 day is needed if k >= n: return 1 # Otherwise, calculate the minimum days needed days_needed = (n + k - 1) // k return days_needed"},{"question":"def operational_sequence(n: int) -> int: Write a function that accepts an integer \`n\` representing the number of operations. The function calculates the sum of a sequence derived as follows: 1. The sequence starts with the number 1. 2. On each odd operation (1st, 3rd, 5th, etc.), the next number in the sequence is the previous number multiplied by 2. 3. On each even operation (2nd, 4th, 6th, etc.), the next number in the sequence is the previous number plus 3. Given \`n\`, the function returns the sum of the first \`n\` numbers in this sequence. Example: >>> operational_sequence(5) 31 >>> operational_sequence(3) 8","solution":"def operational_sequence(n): Returns the sum of the first n numbers in a sequence where: - Start with 1 - Odd operations: multiply by 2 - Even operations: add 3 if n <= 0: return 0 sequence = [1] for i in range(1, n): if i % 2 != 0: # odd index in the context of 0-based indexing next_number = sequence[-1] * 2 else: # even index in the context of 0-based indexing next_number = sequence[-1] + 3 sequence.append(next_number) return sum(sequence)"},{"question":"def most_frequent(arr: List[int]) -> int: Returns the most frequent integer in the array. If there is a tie for the most frequent integer, returns the smallest one. >>> most_frequent([1, 2, 3, 1, 2, 1]) == 1 >>> most_frequent([4, 2, 4, 2, 3, 3]) == 2 >>> most_frequent([10]) == 10 >>> most_frequent([1, 1, 1, 1, 1]) == 1 >>> most_frequent([5, 5, 4, 6, 6, 6, 5]) == 5 >>> most_frequent([5, 1, 2, 2, 3, 3, 4, 4, 5, 5]) == 5 >>> most_frequent([-1, -2, -3, -1, -2, -1]) == -1 >>> most_frequent([0, -1, -1, 0, 0]) == 0","solution":"def most_frequent(arr): Returns the most frequent integer in the array. If there is a tie for the most frequent integer, returns the smallest one. from collections import Counter # Create a frequency dictionary freq = Counter(arr) # Sort items by frequency (descending) and by number (ascending) sorted_items = sorted(freq.items(), key=lambda x: (-x[1], x[0])) # The most frequent (smallest in case of tie) is the first element of sorted list return sorted_items[0][0]"},{"question":"from collections import defaultdict def most_frequent_word(strings): Returns the most frequently occurring word across all input strings. If there are multiple words with the same highest frequency, return the word that appears first in the list based on their first occurrence. >>> most_frequent_word([\\"hello world\\", \\"world is great\\", \\"hello everyone\\"]) \\"hello\\" >>> most_frequent_word([\\"one two three\\", \\"two three four\\", \\"five six seven\\"]) \\"two\\"","solution":"from collections import defaultdict def most_frequent_word(strings): Returns the most frequently occurring word across all input strings. If there are multiple words with the same highest frequency, return the word that appears first in the list based on their first occurrence. word_count = defaultdict(int) first_occurrence = {} max_count = 0 most_frequent = None for string in strings: words = string.split() for word in words: word_count[word] += 1 if word not in first_occurrence: first_occurrence[word] = len(first_occurrence) if (word_count[word] > max_count) or ( word_count[word] == max_count and first_occurrence[word] < first_occurrence[most_frequent] ): max_count = word_count[word] most_frequent = word return most_frequent"},{"question":"def has_triplet_with_sum_zero(arr: List[int]) -> bool: Checks if there exists a triplet in the array such that the sum of the triplet is zero. Args: arr (list of int): List of integers to check. Returns: bool: True if such a triplet exists, False otherwise. >>> has_triplet_with_sum_zero([-1, 0, 1, 2, -1, -4]) True >>> has_triplet_with_sum_zero([1, 2, 3, 4, 5]) False >>> has_triplet_with_sum_zero([1, 2]) False >>> has_triplet_with_sum_zero([0, 0, 0, 0]) True","solution":"def has_triplet_with_sum_zero(arr): Checks if there exists a triplet in the array such that the sum of the triplet is zero. Args: arr (list of int): List of integers to check. Returns: bool: True if such a triplet exists, False otherwise. arr.sort() n = len(arr) for i in range(n - 2): if i > 0 and arr[i] == arr[i - 1]: continue left, right = i + 1, n - 1 while left < right: total = arr[i] + arr[left] + arr[right] if total == 0: return True elif total < 0: left += 1 else: right -= 1 return False"},{"question":"from typing import List, Tuple def remove_k_digits(num: str, k: int) -> str: Find the smallest number possible by removing exactly k digits from the given number. The result should not contain any leading zeros unless the number itself is zero. >>> remove_k_digits(\\"1432219\\", 3) \\"1219\\" >>> remove_k_digits(\\"10200\\", 1) \\"200\\" >>> remove_k_digits(\\"10\\", 2) \\"0\\" def process_test_cases(test_cases: List[Tuple[str, int]]) -> List[str]: Process multiple test cases of removing k digits from given numbers. >>> process_test_cases([(\\"1432219\\", 3), (\\"10200\\", 1), (\\"10\\", 2)]) [\\"1219\\", \\"200\\", \\"0\\"]","solution":"def remove_k_digits(num, k): stack = [] for digit in num: while k > 0 and stack and stack[-1] > digit: stack.pop() k -= 1 stack.append(digit) # If k is still greater than 0, remove the remaining digits from the end while k > 0: stack.pop() k -= 1 # Remove leading zeros result = ''.join(stack).lstrip('0') return result if result else \\"0\\" def process_test_cases(test_cases): results = [] for num, k in test_cases: result = remove_k_digits(num, k) results.append(result) return results"},{"question":"def maximum_robbery(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: In a small town, there are N houses arranged in a straight line. Each house has a certain amount of wealth, represented by an integer value w(i) where i is the house number (1 ≤ i ≤ N). A thief is planning to rob houses, but due to security systems in place, they cannot rob two adjacent houses. Given the wealth values of the houses, find the maximum amount of wealth the thief can rob without triggering the alarms. Args: T (int): Number of test cases. test_cases (List[Tuple[int, List[int]]]): Each test case is represented by a tuple where the first element is the integer N (number of houses) and the second element is a list of integers representing the wealth of each house. Returns: List[int]: A list of integers where each integer represents the maximum amount of wealth that can be robbed for the corresponding test case. >>> maximum_robbery(2, [(4, [1, 2, 3, 4]), (3, [2, 1, 2])]) [6, 4] >>> maximum_robbery(1, [(1, [10])]) [10] import pytest from solution import maximum_robbery def test_single_case(): T = 1 test_cases = [(4, [1, 2, 3, 4])] assert maximum_robbery(T, test_cases) == [6] def test_multiple_cases(): T = 2 test_cases = [(4, [1, 2, 3, 4]), (3, [2, 1, 2])] assert maximum_robbery(T, test_cases) == [6, 4] def test_empty_house(): T = 1 test_cases = [(0, [])] assert maximum_robbery(T, test_cases) == [0] def test_single_house(): T = 1 test_cases = [(1, [10])] assert maximum_robbery(T, test_cases) == [10] def test_all_zero_wealth(): T = 1 test_cases = [(4, [0, 0, 0, 0])] assert maximum_robbery(T, test_cases) == [0] def test_large_wealth_values(): T = 1 test_cases = [(5, [10000, 1, 10000, 1, 10000])] assert maximum_robbery(T, test_cases) == [30000]","solution":"def maximum_robbery(T, test_cases): def rob_house(houses): n = len(houses) if n == 0: return 0 if n == 1: return houses[0] dp = [0] * n dp[0] = houses[0] dp[1] = max(houses[0], houses[1]) for i in range(2, n): dp[i] = max(dp[i-1], houses[i] + dp[i-2]) return dp[-1] results = [] for i in range(T): N, houses = test_cases[i] results.append(rob_house(houses)) return results"},{"question":"def longest_subarray_with_sum_at_most(arr: List[int], target_sum: int) -> int: Finds the length of the longest subarray with a sum less than or equal to a specified value. Args: arr (List[int]): The list of integers. target_sum (int): The target sum. Returns: int: The length of the longest subarray with sum <= target_sum. Examples: >>> longest_subarray_with_sum_at_most([1, 2, 3, 4, 5], 7) 3 >>> longest_subarray_with_sum_at_most([1, 1, 1, 1, 1], 5) 5 >>> longest_subarray_with_sum_at_most([5], 5) 1 >>> longest_subarray_with_sum_at_most([10], 5) 0 >>> longest_subarray_with_sum_at_most([4, 2, 2, 1, 1], 5) 3 >>> longest_subarray_with_sum_at_most([10, 20, 30, 40], 5) 0","solution":"def longest_subarray_with_sum_at_most(arr, target_sum): Finds the length of the longest subarray with a sum less than or equal to the specified target_sum. Parameters: arr (list of int): The list of integers. target_sum (int): The target sum. Returns: int: Length of the longest subarray with sum <= target_sum. max_length = 0 current_sum = 0 start = 0 for end in range(len(arr)): current_sum += arr[end] while current_sum > target_sum and start <= end: current_sum -= arr[start] start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"def category_summary(products, category): Returns the total number of products and the average price of the products in the specified category. If the category is not found, returns count as 0 and average price as 0.0. Args: products (list of dict): List of dictionaries with product details. category (str): The category for which to summarize products. Returns: dict: Dictionary containing 'count' and 'average_price' for the specified category. Examples: >>> products = [ ... {'name': 'Laptop', 'price': 1000, 'category': 'Electronics'}, ... {'name': 'Headphones', 'price': 100, 'category': 'Electronics'}, ... {'name': 'Pizza', 'price': 10, 'category': 'Food'}, ... {'name': 'Burger', 'price': 8, 'category': 'Food'} ... ] >>> category_summary(products, 'Electronics') {'count': 2, 'average_price': 550.0} >>> category_summary(products, 'Food') {'count': 2, 'average_price': 9.0} >>> category_summary(products, 'Clothing') {'count': 0, 'average_price': 0.0}","solution":"def category_summary(products, category): Returns the total number of products and the average price of the products in the specified category. If the category is not found, returns count as 0 and average price as 0.0. Args: products (list of dict): List of dictionaries with product details. category (str): The category for which to summarize products. Returns: dict: Dictionary containing 'count' and 'average_price' for the specified category. total_price = 0 count = 0 for product in products: if product['category'] == category: count += 1 total_price += product['price'] average_price = (total_price / count) if count > 0 else 0.0 return {'count': count, 'average_price': average_price}"},{"question":"def min_removals_to_palindrome(n: int, s: str) -> int: Determine the smallest integer k (1 ≤ k ≤ n), such that you can remove exactly k characters from s to make the string a palindrome. Args: n -- the length of the string. s -- a string of length n consisting of lowercase English letters. Returns: The smallest k for which it is possible to remove exactly k characters from s to make the string a palindrome. Examples: >>> min_removals_to_palindrome(4, 'abca') 1 >>> min_removals_to_palindrome(6, 'abbcaa') 2 >>> min_removals_to_palindrome(1, 'a') 0 >>> min_removals_to_palindrome(5, 'radar') 0 >>> min_removals_to_palindrome(3, 'abc') 2","solution":"def min_removals_to_palindrome(n, s): Returns the smallest k for which it is possible to remove exactly k characters from s to make it a palindrome. def min_deletions(i, j): if i >= j: return 0 if dp[i][j] != -1: return dp[i][j] if s[i] == s[j]: dp[i][j] = min_deletions(i + 1, j - 1) else: dp[i][j] = 1 + min(min_deletions(i + 1, j), min_deletions(i, j - 1)) return dp[i][j] dp = [[-1] * n for _ in range(n)] return min_deletions(0, n - 1)"},{"question":"def rearrange_list(lst: list) -> list: Rearranges the list so that all negative numbers come before all non-negative numbers, maintaining the original relative order of both groups. Parameters: lst (list): A list of integers. Returns: list: A new list with all the negative numbers before all the non-negative numbers. Examples: >>> rearrange_list([-1, 2, -3, 4, -5, 6, 0]) [-1, -3, -5, 2, 4, 6, 0] >>> rearrange_list([4, -2, -9, 0, 5, 1]) [-2, -9, 4, 0, 5, 1] from solution import rearrange_list def test_rearrange_with_neg_and_pos(): assert rearrange_list([-1, 2, -3, 4, -5, 6, 0]) == [-1, -3, -5, 2, 4, 6, 0] def test_rearrange_with_pos_and_zero_first(): assert rearrange_list([4, -2, -9, 0, 5, 1]) == [-2, -9, 4, 0, 5, 1] def test_rearrange_all_negative(): assert rearrange_list([-1, -2, -3]) == [-1, -2, -3] def test_rearrange_all_non_negative(): assert rearrange_list([1, 2, 3, 0]) == [1, 2, 3, 0] def test_rearrange_empty_list(): assert rearrange_list([]) == [] def test_rearrange_single_negative(): assert rearrange_list([-1]) == [-1] def test_rearrange_single_non_negative(): assert rearrange_list([0]) == [0] assert rearrange_list([1]) == [1]","solution":"def rearrange_list(lst): Rearranges the list so that all negative numbers come before all non-negative numbers, maintaining the original relative order of both groups. Parameters: lst (list): A list of integers. Returns: list: A new list with all the negative numbers before all the non-negative numbers. negative = [x for x in lst if x < 0] non_negative = [x for x in lst if x >= 0] return negative + non_negative"},{"question":"def rearrange_string(s: str) -> str: Rearranges the string such that no two adjacent characters are the same. If such an arrangement is not possible, returns an empty string. >>> rearrange_string(\\"aab\\") in [\\"aba\\", \\"baa\\"] True >>> rearrange_string(\\"aaab\\") \\"\\"","solution":"from collections import Counter import heapq def rearrange_string(s): Rearranges the string such that no two adjacent characters are the same. If such an arrangement is not possible, returns an empty string. if not s: return \\"\\" # Count the frequency of each character freq = Counter(s) # Use a max-heap to store characters with their frequencies max_heap = [(-cnt, char) for char, cnt in freq.items()] heapq.heapify(max_heap) result = [] prev_count, prev_char = 0, \\"\\" while max_heap: count, char = heapq.heappop(max_heap) result.append(char) if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) prev_count, prev_char = count + 1, char # decrement the count (because it's stored as negative) rearranged_string = \\"\\".join(result) if len(rearranged_string) == len(s): return rearranged_string else: return \\"\\""},{"question":"def max_same_value_subarray_sum(arr): Returns the maximum sum of any non-empty subarray such that all elements in the subarray have the same value. >>> max_same_value_subarray_sum([4, 4, 4, 5, 5, 6, 6, 6, 6]) 24 >>> max_same_value_subarray_sum([1, 2, 2, 3, 3, 3, 3, 4, 4]) 12 >>> max_same_value_subarray_sum([7, 7, 8, 8, 8, 9]) 24 >>> max_same_value_subarray_sum([5]) 5 >>> max_same_value_subarray_sum([]) 0","solution":"def max_same_value_subarray_sum(arr): Returns the maximum sum of any non-empty subarray such that all elements in the subarray have the same value. if not arr: return 0 max_sum = current_sum = arr[0] current_value = arr[0] for num in arr[1:]: if num == current_value: current_sum += num else: current_value = num current_sum = num max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def alternate_sort(lst): Create a function called \`alternate_sort\` that takes a list of integers and strings. Your task is to return a new list where: - All integers come before all strings, - Integers are sorted in ascending order, - Strings are sorted in alphabetical order. Example: >>> alternate_sort([3, 'apple', 5, 'banana', 1, 'cherry']) [1, 3, 5, 'apple', 'banana', 'cherry'] >>> alternate_sort([10, 'orange', 2, 'grape', 'peach', 4]) [2, 4, 10, 'grape', 'orange', 'peach']","solution":"def alternate_sort(lst): Returns a new list where all integers come before all strings, integers are sorted in ascending order, and strings are sorted in alphabetical order. integers = sorted([x for x in lst if isinstance(x, int)]) strings = sorted([x for x in lst if isinstance(x, str)]) return integers + strings # Example usage: # print(alternate_sort([3, 'apple', 5, 'banana', 1, 'cherry'])) # Output: [1, 3, 5, 'apple', 'banana', 'cherry']"},{"question":"def calculate_team_scores(teams): Calculate the overall ranking scores for each team by summing up their top three scores. If a team has less than three scores, sum all of their scores. :param teams: List of lists, where each sublist represents the scores of a team :return: List of overall ranking scores for each team Example: >>> calculate_team_scores([[50, 60, 70, 80], [55, 65], [95, 90, 85]]) [210, 120, 270] >>> calculate_team_scores([[80, 50], [30, 40, 50], [60, 100, 80, 90]]) [130, 120, 270] # Unit tests from solution import calculate_team_scores def test_team_with_more_than_three_scores(): assert calculate_team_scores([[50, 60, 70, 80]]) == [210] def test_team_with_less_than_three_scores(): assert calculate_team_scores([[55, 65]]) == [120] def test_multiple_teams(): input_data = [[50, 60, 70, 80], [55, 65], [95, 90, 85]] expected_output = [210, 120, 270] assert calculate_team_scores(input_data) == expected_output def test_teams_with_varied_number_of_scores(): input_data = [[80, 50], [30, 40, 50], [60, 100, 80, 90]] expected_output = [130, 120, 270] assert calculate_team_scores(input_data) == expected_output def test_empty_team(): assert calculate_team_scores([[]]) == [0] assert calculate_team_scores([[], [50], [80, 70, 60]]) == [0, 50, 210] def test_single_score_teams(): input_data = [[40], [90], [100]] expected_output = [40, 90, 100] assert calculate_team_scores(input_data) == expected_output def test_all_teams_have_one_score(): input_data = [[10], [20], [30]] expected_output = [10, 20, 30] assert calculate_team_scores(input_data) == expected_output def test_all_teams_have_empty_scores(): input_data = [[], [], []] expected_output = [0, 0, 0] assert calculate_team_scores(input_data) == expected_output","solution":"def calculate_team_scores(teams): Calculate the overall ranking scores for each team by summing up their top three scores. If a team has less than three scores, sum all of their scores. :param teams: List of lists, where each sublist represents the scores of a team :return: List of overall ranking scores for each team result = [] for team in teams: top_scores = sorted(team, reverse=True)[:3] result.append(sum(top_scores)) return result"},{"question":"def roman_to_integer(s: str) -> int: Convert a Roman numeral string to an integer. >>> roman_to_integer(\\"III\\") 3 >>> roman_to_integer(\\"IV\\") 4 >>> roman_to_integer(\\"IX\\") 9 >>> roman_to_integer(\\"LVIII\\") 58 >>> roman_to_integer(\\"MCMXCIV\\") 1994","solution":"def roman_to_integer(s: str) -> int: Convert a Roman numeral string to an integer. :param s: Roman numeral string :return: Integer value of the Roman numeral roman_to_int_map = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 } total = 0 prev_value = 0 for char in reversed(s): value = roman_to_int_map[char] if value < prev_value: total -= value else: total += value prev_value = value return total"},{"question":"def rotate_matrix_90_deg_clockwise(matrix): Rotates an NxN matrix 90 degrees clockwise. Args: matrix: List of List of integers representing the NxN matrix Returns: A new matrix which is the 90-degree clockwise rotation of the input matrix >>> rotate_matrix_90_deg_clockwise([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix_90_deg_clockwise([ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16]]) [[13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4]]","solution":"def rotate_matrix_90_deg_clockwise(matrix): Rotates an NxN matrix 90 degrees clockwise. Args: matrix: List of List of integers representing the NxN matrix Returns: A new matrix which is the 90-degree clockwise rotation of the input matrix n = len(matrix) result = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): result[j][n - 1 - i] = matrix[i][j] return result"},{"question":"def is_palindrome(s: str) -> bool: Determines whether a string is a valid palindrome, considering only alphanumeric characters and ignoring cases. >>> is_palindrome('A man, a plan, a canal: Panama') True >>> is_palindrome('race a car') False >>> is_palindrome('Able was I, ere I saw Elba') True >>> is_palindrome(' ') True","solution":"def is_palindrome(s): Determines whether a string is a valid palindrome, considering only alphanumeric characters and ignoring cases. filtered_chars = [char.lower() for char in s if char.isalnum()] return filtered_chars == filtered_chars[::-1]"},{"question":"def compute_lps_array(string: str) -> list: Computes the Longest Prefix Suffix (LPS) array for a given string. Args: string (str): The input string for which the LPS array will be computed. Returns: list: The LPS array. Examples: >>> compute_lps_array(\\"\\") [] >>> compute_lps_array(\\"a\\") [0] >>> compute_lps_array(\\"abababca\\") [0, 0, 1, 2, 3, 4, 0, 1]","solution":"def compute_lps_array(string): Computes the Longest Prefix Suffix (LPS) array for a given string. Args: string (str): The input string for which the LPS array will be computed. Returns: list: The LPS array. lps = [0] * len(string) length = 0 # length of the previous longest prefix suffix i = 1 # start from the second character while i < len(string): if string[i] == string[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps"},{"question":"from typing import List def min_steps(n: int, m: int, grid: List[str], sx: int, sy: int, ex: int, ey: int) -> int: Returns the minimum number of steps required to move from the start (sx, sy) to end (ex, ey). If there is no valid path, return -1. >>> grid = [ ... \\".....\\", ... \\".#.\\", ... \\".#.#.\\", ... \\".#.\\", ... \\".....\\" ... ] >>> min_steps(5, 5, grid, 1, 1, 5, 5) 8 >>> grid = [ ... \\"#\\", ... \\"#\\", ... \\"#\\", ... \\"#\\", ... \\"#\\" ... ] >>> min_steps(5, 5, grid, 1, 1, 5, 5) -1 >>> grid = [ ... \\"...\\", ... \\"...\\", ... \\"...\\" ... ] >>> min_steps(3, 3, grid, 1, 1, 1, 1) 0 >>> grid = [ ... \\"...\\", ... \\"...\\", ... \\"...\\" ... ] >>> min_steps(3, 3, grid, 1, 1, 1, 2) 1 >>> grid = [ ... \\"...\\", ... \\"...\\", ... \\"...\\" ... ] >>> min_steps(3, 3, grid, 1, 1, 2, 1) 1 >>> grid = [ ... \\".....\\", ... \\".#.\\", ... \\".#.#.\\", ... \\".#.\\", ... \\".....\\" ... ] >>> min_steps(5, 5, grid, 1, 1, 3, 2) -1","solution":"from collections import deque def min_steps(n, m, grid, sx, sy, ex, ey): Returns the minimum number of steps required to move from the start (sx, sy) to end (ex, ey). If there is no valid path, return -1. # Convert to zero-indexed sx, sy, ex, ey = sx-1, sy-1, ex-1, ey-1 directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] # BFS queue and visited set queue = deque([(sx, sy, 0)]) # (current_x, current_y, current_steps) visited = set((sx, sy)) while queue: x, y, steps = queue.popleft() if (x, y) == (ex, ey): return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] == '.': visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return -1"},{"question":"import re def sanitize_emails(log: str) -> str: Replaces all occurrences of email addresses in the log with the string \\"[EMAIL REDACTED]\\". >>> sanitize_emails(\\"Please contact jane.doe@example.com for any questions.\\") 'Please contact [EMAIL REDACTED] for any questions.' >>> sanitize_emails(\\"alice@example.com Here is the message. bob@example.org\\") '[EMAIL REDACTED] Here is the message. [EMAIL REDACTED]' >>> sanitize_emails(\\"Contact email_support@example-service.info for support.\\") 'Contact [EMAIL REDACTED] for support.' >>> sanitize_emails(\\"This is a log without any email addresses.\\") 'This is a log without any email addresses.' >>> sanitize_emails(Here are the new instructions for today. Please contact jane.doe@example.com for any questions. Additionally, reach out to john20_doe@company.co.uk about the project update. Thank you!) Here are the new instructions for today. Please contact [EMAIL REDACTED] for any questions. Additionally, reach out to [EMAIL REDACTED] about the project update. Thank you!","solution":"import re def sanitize_emails(log: str) -> str: Replaces all occurrences of email addresses in the log with the string \\"[EMAIL REDACTED]\\". email_pattern = re.compile(r'b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+.[A-Z|a-z]{2,}b') sanitized_log = email_pattern.sub(\\"[EMAIL REDACTED]\\", log) return sanitized_log"},{"question":"def sieve_of_eratosthenes(n: int) -> List[int]: Returns a list of all prime numbers less than or equal to the given number \`n\`. Implements the Sieve of Eratosthenes algorithm. >>> sieve_of_eratosthenes(10) [2, 3, 5, 7] >>> sieve_of_eratosthenes(1) [] >>> sieve_of_eratosthenes(2) [2] >>> sieve_of_eratosthenes(20) [2, 3, 5, 7, 11, 13, 17, 19]","solution":"def sieve_of_eratosthenes(n): Returns a list of all prime numbers less than or equal to n. Implements the Sieve of Eratosthenes algorithm. if n < 2: return [] primes = [True] * (n + 1) primes[0] = primes[1] = False p = 2 while p * p <= n: if primes[p]: for i in range(p * p, n + 1, p): primes[i] = False p += 1 prime_list = [num for num, is_prime in enumerate(primes) if is_prime] return prime_list"},{"question":"def process_books(T, test_cases): Processes the list of books, removes duplicates, and counts the total number of copies for each unique book title. Args: T (int): The number of test cases. test_cases (List[Tuple[int, List[str]]]): A list of tuples where each tuple contains an integer N (number of book entries) and a list of strings representing book titles. Returns: List[str]: A list of strings where each string contains the book title and its count, separated by a space. The titles are sorted in alphabetical order. >>> T = 2 >>> test_cases = [ ... (3, [\\"Harry_Potter\\", \\"The_Hobbit\\", \\"Harry_Potter\\"]), ... (4, [\\"War_and_Peace\\", \\"Anna_Karenina\\", \\"War_and_Peace\\", \\"The_Hobbit\\"]) ... ] >>> process_books(T, test_cases) [\\"Harry_Potter 2\\", \\"The_Hobbit 1\\", \\"Anna_Karenina 1\\", \\"The_Hobbit 1\\", \\"War_and_Peace 2\\"] pass","solution":"def process_books(T, test_cases): result = [] for i in range(T): N = test_cases[i][0] books = test_cases[i][1] book_count = {} for title in books: if title in book_count: book_count[title] += 1 else: book_count[title] = 1 sorted_books = sorted(book_count.items()) for title, count in sorted_books: result.append(f\\"{title} {count}\\") return result # Example usage T = 2 test_cases = [ (3, [\\"Harry_Potter\\", \\"The_Hobbit\\", \\"Harry_Potter\\"]), (4, [\\"War_and_Peace\\", \\"Anna_Karenina\\", \\"War_and_Peace\\", \\"The_Hobbit\\"]) ] for line in process_books(T, test_cases): print(line)"},{"question":"def find_pair_with_target(array, target): Returns indices of the two distinct numbers that add up to the target. If no such pair exists, returns an empty list. >>> find_pair_with_target([2, 7, 11, 15], 9) [0, 1] >>> find_pair_with_target([3, 2, 4], 6) [1, 2] >>> find_pair_with_target([3, 3], 6) [0, 1] >>> find_pair_with_target([1, 2, 3, 4], 8) [] >>> find_pair_with_target([1000000, 2000000, 3000000], 5000000) [1, 2] >>> find_pair_with_target([-1, -2, -3, -4], -6) [1, 3] >>> find_pair_with_target([-1, 1, 2, -2], 0) [0, 1] >>> find_pair_with_target([4, 4], 8) [0, 1]","solution":"def find_pair_with_target(array, target): Returns indices of the two numbers that add up to the target. If no such pair exists, returns an empty list. seen = {} for idx, num in enumerate(array): complement = target - num if complement in seen: return [seen[complement], idx] seen[num] = idx return []"},{"question":"def has_pair_with_sum(numbers: List[int], target: int) -> bool: Given a list of integers \`numbers\`, return a boolean indicating whether there exists a pair of numbers in the list whose sum is equal to a given target value. >>> has_pair_with_sum([3, 5, -4, 8, 11], 7) True >>> has_pair_with_sum([1, 2, 3, 4, 5], 10) False pass from solution import has_pair_with_sum def test_has_pair_with_sum_true(): assert has_pair_with_sum([3, 5, -4, 8, 11], 7) == True assert has_pair_with_sum([1, 2, 3, 4, 5], 6) == True assert has_pair_with_sum([-3, 4, 1, 6, 9], 3) == True assert has_pair_with_sum([0, -1, 2, -3, 5], 2) == True def test_has_pair_with_sum_false(): assert has_pair_with_sum([1, 2, 3, 4, 5], 10) == False assert has_pair_with_sum([-1, -2, -3, -4, -5], -10) == False assert has_pair_with_sum([7, 14, 21, 28, 35], 50) == False assert has_pair_with_sum([], 5) == False def test_has_pair_with_sum_edge_cases(): assert has_pair_with_sum([1], 2) == False # Only one element in the list assert has_pair_with_sum([0, 0], 0) == True # Pair of zeros assert has_pair_with_sum([-10, 20], 10) == True # Negative and positive assert has_pair_with_sum([5, 5], 10) == True # pair with same elements that sum up to target","solution":"def has_pair_with_sum(numbers, target): Returns True if there exist two distinct elements in 'numbers' that add up to 'target', otherwise False. seen_numbers = set() for num in numbers: complement = target - num if complement in seen_numbers: return True seen_numbers.add(num) return False"},{"question":"def longestIncreasingSequence(nums: List[int]) -> List[int]: Write a function that takes an integer array as input and returns the longest sequence of increasing numbers. If there are multiple sequences with the same length, return the first one encountered. >>> longestIncreasingSequence([1, 2, 1, 2, 3, 4, 1]) == [1, 2, 3, 4] >>> longestIncreasingSequence([5, 1, 2, 3, 4, 5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] pass # Unit tests from solution import longestIncreasingSequence def test_single_element(): assert longestIncreasingSequence([1]) == [1] def test_two_same_elements(): assert longestIncreasingSequence([2, 2]) == [2] def test_empty_list(): assert longestIncreasingSequence([]) == [] def test_multiple_increasing_sequences(): assert longestIncreasingSequence([1, 2, 1, 2, 3, 4, 1]) == [1, 2, 3, 4] def test_longest_at_beginning(): assert longestIncreasingSequence([5, 1, 2, 3, 4, 5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] def test_all_elements_increasing(): assert longestIncreasingSequence([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] def test_all_elements_decreasing(): assert longestIncreasingSequence([5, 4, 3, 2, 1]) == [5] def test_mixed_increasing_decreasing(): assert longestIncreasingSequence([3, 3, 4, 5, 1, 2, 3, 0, -1]) == [3, 4, 5] def test_longest_at_end(): assert longestIncreasingSequence([3, 2, 1, 1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]","solution":"def longestIncreasingSequence(nums): if not nums: return [] max_len = 0 current_len = 1 longest_seq_start = 0 current_start = 0 for i in range(1, len(nums)): if nums[i] > nums[i - 1]: current_len += 1 else: if current_len > max_len: max_len = current_len longest_seq_start = current_start current_len = 1 current_start = i if current_len > max_len: max_len = current_len longest_seq_start = current_start return nums[longest_seq_start:longest_seq_start + max_len]"},{"question":"def transform_string(s: str) -> str: Transform the string into another string where any consecutive sequence of the same character is replaced by a count of those consecutive characters followed by the character itself. >>> transform_string(\\"aaabccc\\") == \\"3a1b3c\\" >>> transform_string(\\"abbcccaa\\") == \\"1a2b3c2a\\"","solution":"def transform_string(s: str) -> str: if not s: return \\"\\" result = [] current_char = s[0] count = 1 for char in s[1:]: if char == current_char: count += 1 else: result.append(f\\"{count}{current_char}\\") current_char = char count = 1 result.append(f\\"{count}{current_char}\\") return ''.join(result)"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Given a list of integers, returns a new list where each element is the product of all the elements in the original list except the element at the same index. Note: The solution should be O(n) and division should not be used. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([0, 1, 2, 3]) [6, 0, 0, 0]","solution":"def product_except_self(nums): Returns a list where each element is the product of all the elements in the original list except the element at the same index. length = len(nums) left, right, result = [1] * length, [1] * length, [1] * length # Calculate left products for i in range(1, length): left[i] = left[i - 1] * nums[i - 1] # Calculate right products for i in range(length - 2, -1, -1): right[i] = right[i + 1] * nums[i + 1] # Calculate result for i in range(length): result[i] = left[i] * right[i] return result"},{"question":"from collections import Counter import heapq from typing import List def rearrange_string(s: str) -> str: Given a string s, rearrange the characters such that no two adjacent characters are the same. If it's possible, return the rearranged string. Otherwise, return an empty string. >>> rearrange_string(\\"aab\\") 'aba' >>> rearrange_string(\\"aaab\\") '' >>> rearrange_string(\\"a\\") 'a' >>> rearrange_string(\\"aa\\") '' >>> rearrange_string(\\"ab\\") 'ab' >>> rearrange_string(\\"aabb\\") 'abab' or 'baba' >>> rearrange_string(\\"aaabb\\") 'ababa' or 'abbaa' >>> rearrange_string(\\"aaaabbcc\\") 'abacabac' or 'acababac' or 'ababacab' or 'acbabaca'","solution":"from collections import Counter import heapq def rearrange_string(s): Given a string s, rearrange the characters such that no two adjacent characters are the same. If it's possible, return the rearranged string. Otherwise, return an empty string. count = Counter(s) max_heap = [(-freq, char) for char, freq in count.items()] heapq.heapify(max_heap) prev_char = None prev_freq = 0 result = [] while max_heap or prev_freq < 0: if max_heap: freq, char = heapq.heappop(max_heap) result.append(char) freq += 1 # since it's a max heap with negative frequencies, we increment to reduce the frequency else: return \\"\\" if prev_char and prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) prev_char = char prev_freq = freq return ''.join(result)"},{"question":"def find_kth_largest(nums: list, k: int) -> int: Find the k-th largest element in the list. The function should use the Quickselect algorithm for an average time complexity of O(n). >>> find_kth_largest([3, 2, 1, 5, 6, 4], 2) 5 >>> find_kth_largest([3, 2, 3, 1, 2, 4, 5, 5, 6], 4) 4 from solution import find_kth_largest def test_find_kth_largest(): assert find_kth_largest([3, 2, 1, 5, 6, 4], 2) == 5 assert find_kth_largest([3, 2, 3, 1, 2, 4, 5, 5, 6], 4) == 4 assert find_kth_largest([1, 2, 3, 4, 5, 6], 1) == 6 assert find_kth_largest([1, 2, 3, 4, 5, 6], 6) == 1 assert find_kth_largest([5, 5, 5], 1) == 5 assert find_kth_largest([21, 30, 18, 9, 12, 11], 3) == 18 def test_find_kth_largest_edge_cases(): try: find_kth_largest([], 1) except ValueError as e: assert str(e) == \\"Invalid input parameters.\\" try: find_kth_largest([1], 0) except ValueError as e: assert str(e) == \\"Invalid input parameters.\\" try: find_kth_largest([1], 2) except ValueError as e: assert str(e) == \\"Invalid input parameters.\\"","solution":"def find_kth_largest(nums: list, k: int) -> int: Finds the k-th largest element in the list nums. The function uses the Quickselect algorithm, which has an average time complexity of O(n). if not nums or k < 1 or k > len(nums): raise ValueError(\\"Invalid input parameters.\\") def partition(left, right, pivot_index): pivot_value = nums[pivot_index] nums[pivot_index], nums[right] = nums[right], nums[pivot_index] store_index = left for i in range(left, right): if nums[i] < pivot_value: nums[store_index], nums[i] = nums[i], nums[store_index] store_index += 1 nums[right], nums[store_index] = nums[store_index], nums[right] return store_index def quickselect(left, right, k_smallest): if left == right: return nums[left] pivot_index = left + (right - left) // 2 pivot_index = partition(left, right, pivot_index) if k_smallest == pivot_index: return nums[k_smallest] elif k_smallest < pivot_index: return quickselect(left, pivot_index - 1, k_smallest) else: return quickselect(pivot_index + 1, right, k_smallest) # k-th largest is (len(nums) - k)-th smallest in zero-indexed return quickselect(0, len(nums) - 1, len(nums) - k)"},{"question":"def sum_of_digits(s: str) -> int: Given a string of digits, extract all the individual digits, sum them together, and return the resulting sum. >>> sum_of_digits(\\"1234\\") 10 >>> sum_of_digits(\\"0000\\") 0 >>> sum_of_digits(\\"987\\") 24","solution":"def sum_of_digits(s: str) -> int: Returns the sum of all digits in the input string. Parameters: s (str): A string of digits (0-9). Returns: int: Sum of all digits in the string. return sum(int(char) for char in s)"},{"question":"import re from typing import List def longest_word(sentence: str) -> str: Finds the longest word in a given sentence. If there are two or more words with the same maximum length, returns the first one that appears in the sentence. Ignores punctuation and considers only alphanumeric characters as part of words. >>> longest_word(\\"A quick brown fox.\\") 'quick' >>> longest_word(\\"The rain in Spain stays mainly in the plain.\\") 'mainly'","solution":"import re def longest_word(sentence): Finds the longest word in a given sentence. If there are two or more words with the same maximum length, returns the first one that appears in the sentence. Ignores punctuation and considers only alphanumeric characters as part of words. # Remove punctuation and split the sentence into words words = re.findall(r'bw+b', sentence) # Find the longest word longest = \\"\\" for word in words: if len(word) > len(longest): longest = word return longest"},{"question":"from typing import List def max_transportable_cars(tracks: List[int]) -> int: Returns the maximum points that can be achieved from the sequence of cars. >>> max_transportable_cars([1, 1, 0, 1]) 3 >>> max_transportable_cars([1, 0, 0, 1, 1, 0, 1]) 4 >>> max_transportable_cars([]) 0 >>> max_transportable_cars([0, 0, 0, 0]) 0 >>> max_transportable_cars([1, 1, 1, 1]) 4 >>> max_transportable_cars([1]) 1 >>> max_transportable_cars([0]) 0 >>> max_transportable_cars([1, 0, 1, 0, 1]) 3 pass","solution":"def max_transportable_cars(tracks): Returns the maximum points that can be achieved from the sequence of cars. count = 0 merged_group_found = False for track in tracks: if track == 1: count += 1 merged_group_found = True else: merged_group_found = False if not merged_group_found: # Only reset the count for the first break in cars merged_group_found = True return count"},{"question":"def count_connected_components(n, edges): Returns the number of connected components in the graph. Parameters: n (int): Number of vertices edges (List[Tuple[int, int]]): List of edges Returns: int: Number of connected components >>> count_connected_components(6, [(1, 2), (2, 3), (4, 5)]) 3 >>> count_connected_components(4, []) 4 >>> count_connected_components(5, [(1, 2), (2, 3), (3, 4), (4, 5)]) 1","solution":"def count_connected_components(n, edges): Returns the number of connected components in the graph. Parameters: n (int): Number of vertices edges (List[Tuple[int, int]]): List of edges Returns: int: Number of connected components from collections import defaultdict, deque def bfs(start, visited, adj_list): queue = deque([start]) while queue: node = queue.popleft() for neighbor in adj_list[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) adj_list = defaultdict(list) for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) visited = [False] * (n + 1) # 1-indexed vertices count = 0 for vertex in range(1, n + 1): if not visited[vertex]: count += 1 visited[vertex] = True bfs(vertex, visited, adj_list) return count"},{"question":"def alphabet_position(s: str) -> str: Replaces each letter in the string with its corresponding position in the alphabet. Args: s (str): Input string consisting of lowercase English letters. Returns: str: A string of numbers where each number corresponds to the position of each letter in the input string. >>> alphabet_position(\\"abc\\") == \\"1 2 3\\" >>> alphabet_position(\\"hello\\") == \\"8 5 12 12 15\\" >>> alphabet_position(\\"123!@#\\") == \\"\\" >>> alphabet_position(\\"thequickbrownfox\\") == \\"20 8 5 17 21 9 3 11 2 18 15 23 14 6 15 24\\" >>> alphabet_position(\\"\\") == \\"\\" from solution import alphabet_position def test_alphabet_position_simple(): assert alphabet_position(\\"abc\\") == \\"1 2 3\\" def test_alphabet_position_hello(): assert alphabet_position(\\"hello\\") == \\"8 5 12 12 15\\" def test_alphabet_position_mixed(): assert alphabet_position(\\"thequickbrownfox\\") == \\"20 8 5 17 21 9 3 11 2 18 15 23 14 6 15 24\\" def test_alphabet_position_ransomtxt(): assert alphabet_position(\\"ransomtxt\\") == \\"18 1 14 19 15 13 20 24 20\\" def test_alphabet_position_empty(): assert alphabet_position(\\"\\") == \\"\\" def test_alphabet_position_nonalpha(): assert alphabet_position(\\"123!@#\\") == \\"\\" def test_alphabet_position_mixed_letters_and_nonalpha(): assert alphabet_position(\\"a1b2c3!\\") == \\"1 2 3\\"","solution":"def alphabet_position(s): Replaces each letter in the string with its corresponding position in the alphabet. Args: s (str): Input string consisting of lowercase English letters. Returns: str: A string of numbers where each number corresponds to the position of each letter in the input string. return ' '.join(str(ord(char) - ord('a') + 1) for char in s if char.isalpha())"},{"question":"def count_less_equal_elements(A): Returns an array B such that for each element B[i], the value is equal to the number of elements in A that are less than or equal to A[i]. >>> count_less_equal_elements([4, 2, 9, 1, 7]) == [3, 2, 5, 1, 4] >>> count_less_equal_elements([3, 3, 3]) == [3, 3, 3] >>> count_less_equal_elements([5]) == [1] >>> count_less_equal_elements([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] >>> count_less_equal_elements([5, 4, 3, 2, 1]) == [5, 4, 3, 2, 1] >>> count_less_equal_elements([10, 10, 10, 10]) == [4, 4, 4, 4] >>> count_less_equal_elements([8, 2, 6, 3]) == [4, 1, 3, 2] >>> count_less_equal_elements([1000000000, 999999999, 999999998]) == [3, 2, 1]","solution":"def count_less_equal_elements(A): Returns an array B such that for each element B[i], the value is equal to the number of elements in A that are less than or equal to A[i]. sorted_A = sorted(A) B = [] for num in A: count = binary_search_find_count(sorted_A, num) B.append(count) return B def binary_search_find_count(sorted_A, target): Uses binary search to find the number of elements in sorted_A that are less than or equal to target. left, right = 0, len(sorted_A) while left < right: mid = (left + right) // 2 if sorted_A[mid] <= target: left = mid + 1 else: right = mid return left"},{"question":"def first_non_repeating_character(s: str) -> str: Returns the first non-repeating character from the input string. If there is no non-repeating character, returns an empty string. >>> first_non_repeating_character('abacabad') == 'c' >>> first_non_repeating_character('abcdef') == 'a' >>> first_non_repeating_character('aabbcc') == '' >>> first_non_repeating_character('a') == 'a' >>> first_non_repeating_character('') == '' >>> first_non_repeating_character('aab') == 'b' >>> first_non_repeating_character('abcabc') == '' >>> first_non_repeating_character('aabbccd') == 'd' >>> first_non_repeating_character('abacbcde') == 'd'","solution":"def first_non_repeating_character(s): Returns the first non-repeating character from the input string. If there is no non-repeating character, returns an empty string. char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 for char in s: if char_count[char] == 1: return char return \\"\\""},{"question":"def reverse_number(n): Reverses the digits of an integer. If the number is negative, the negative sign remains at the front. Parameters: n (int): The integer to be reversed. Returns: int: The integer with its digits reversed. >>> reverse_number(123) == 321 >>> reverse_number(-456) == -654 >>> reverse_number(1000) == 1 >>> reverse_number(0) == 0 >>> reverse_number(789) == 987 >>> reverse_number(-200) == -2","solution":"def reverse_number(n): Reverses the digits of an integer. If the number is negative, the negative sign remains at the front. Parameters: n (int): The integer to be reversed. Returns: int: The integer with its digits reversed. sign = -1 if n < 0 else 1 reversed_n = int(str(abs(n))[::-1]) return sign * reversed_n"},{"question":"def is_valid(s: str) -> bool: Determines if the input string containing only \\"{\\", \\"}\\", \\"(\\", \\")\\", \\"[\\" and \\"]\\" is valid. A string is valid if: 1. Open brackets are closed by the same type of brackets. 2. Open brackets are closed in the correct order. 3. Every close bracket has a corresponding open bracket of the same type. >>> is_valid(\\"()\\") == True >>> is_valid(\\"()[]{}\\") == True >>> is_valid(\\"(]\\") == False >>> is_valid(\\"([)]\\") == False >>> is_valid(\\"{[]}\\") == True >>> is_valid(\\"\\") == True >>> is_valid(\\"((()))\\") == True >>> is_valid(\\"(((\\") == False >>> is_valid(\\")))\\") == False >>> is_valid(\\"(()]\\") == False","solution":"def is_valid(s): Determines if the input string containing only \\"{\\", \\"}\\", \\"(\\", \\")\\", \\"[\\" and \\"]\\" is valid. A string is valid if: 1. Open brackets are closed by the same type of brackets. 2. Open brackets are closed in the correct order. 3. Every close bracket has a corresponding open bracket of the same type. bracket_map = {\\")\\": \\"(\\", \\"}\\": \\"{\\", \\"]\\": \\"[\\"} stack = [] for char in s: if char in bracket_map: top_element = stack.pop() if stack else '#' if bracket_map[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"def knapsack(W: int, items: List[Tuple[int, int]]) -> int: Solves the 0/1 Knapsack problem for a given capacity W and a list of items. Each item is represented by a tuple (weight, value). Returns the maximum total value that can be achieved with a weight <= W. >>> knapsack(50, [(10, 60), (20, 100), (30, 120)]) == 220 >>> knapsack(10, [(10, 500)]) == 500 pass def solve_knapsack_problems(test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]: Solves multiple test cases of the knapsack problem. test_cases is a list of tuples, each containing: - maximum weight capacity W - a list of items, where each item is a tuple (weight, value) Returns a list of results, each being the maximum total value for the test case. >>> solve_knapsack_problems([(50, [(10, 60), (20, 100), (30, 120)]), (10, [(10, 500)])]) == [220, 500] pass","solution":"def knapsack(W, items): Solves the 0/1 Knapsack problem for a given capacity W and a list of items. Each item is represented by a tuple (weight, value). Returns the maximum total value that can be achieved with a weight <= W. n = len(items) dp = [[0 for _ in range(W + 1)] for _ in range(n + 1)] for i in range(1, n + 1): weight, value = items[i - 1] for w in range(W + 1): if weight <= w: dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weight] + value) else: dp[i][w] = dp[i - 1][w] return dp[n][W] def solve_knapsack_problems(test_cases): Solves multiple test cases of the knapsack problem. test_cases is a list of tuples, each containing: - maximum weight capacity W - a list of items, where each item is a tuple (weight, value) Returns a list of results, each being the maximum total value for the test case. results = [] for W, items in test_cases: result = knapsack(W, items) results.append(result) return results"},{"question":"def is_valid_pattern(pattern, string): Checks if the string follows the given pattern. Each character in the pattern maps to a distinct word in the string. :param pattern: A string of alphabetic characters representing the pattern. :param string: A string of words separated by spaces to be checked against the pattern. :return: True if the string follows the pattern, False otherwise. >>> is_valid_pattern(\\"abba\\", \\"dog cat cat dog\\") True >>> is_valid_pattern(\\"abba\\", \\"dog cat cat fish\\") False >>> is_valid_pattern(\\"aaaa\\", \\"dog dog dog dog\\") True >>> is_valid_pattern(\\"abba\\", \\"dog dog dog dog\\") False >>> is_valid_pattern(\\"a\\", \\"dog\\") True >>> is_valid_pattern(\\"a\\", \\"dog dog\\") False >>> is_valid_pattern(\\"abc\\", \\"dog cat bird cat\\") False >>> is_valid_pattern(\\"abcd\\", \\"dog cat\\") False >>> is_valid_pattern(\\"abc\\", \\"dog cat bird\\") True >>> is_valid_pattern(\\"aaaa\\", \\"dog cat cat dog\\") False","solution":"def is_valid_pattern(pattern, string): Checks if the string follows the given pattern. Each character in the pattern maps to a distinct word in the string. :param pattern: A string of alphabetic characters representing the pattern. :param string: A string of words separated by spaces to be checked against the pattern. :return: True if the string follows the pattern, False otherwise. pattern_to_word = {} word_to_pattern = {} words = string.split() if len(pattern) != len(words): return False for char, word in zip(pattern, words): if char in pattern_to_word: if pattern_to_word[char] != word: return False else: if word in word_to_pattern: return False pattern_to_word[char] = word word_to_pattern[word] = char return True"},{"question":"def has_unique_characters(s: str) -> bool: Determines if the string \`s\` has all unique characters. >>> has_unique_characters(\\"abcdef\\") == True >>> has_unique_characters(\\"hello\\") == False >>> has_unique_characters(\\"\\") == True >>> has_unique_characters(\\"a\\") == True >>> has_unique_characters(\\"abc!@#\\") == True >>> has_unique_characters(\\"AbCdeF\\") == True >>> has_unique_characters(\\"aAbBcC\\") == True >>> has_unique_characters(\\"a bcdef\\") == True >>> has_unique_characters(\\"a bcdefa\\") == False","solution":"def has_unique_characters(s): Determines if the string \`s\` has all unique characters. seen_characters = set() for char in s: if char in seen_characters: return False seen_characters.add(char) return True"},{"question":"def sum_of_ap(n: int) -> int: Returns the sum of the first n terms of an arithmetic progression starting with 1 and having a common difference of 2. >>> sum_of_ap(5) 25 >>> sum_of_ap(1) 1","solution":"def sum_of_ap(n: int) -> int: Returns the sum of the first n terms of an arithmetic progression starting with 1 and having a common difference of 2. # Formula to find the nth term of an AP: a_n = a + (n - 1) * d # For our AP: a = 1, d = 2 # The nth term is: 1 + (n - 1) * 2 = 2n - 1 # Sum of first n terms of AP: n/2 * (first_term + nth_term) # First term (a) = 1 # nth term (a_n) = 2n - 1 return n * (1 + (2 * n - 1)) // 2"},{"question":"def remove_adjacent_duplicates(s: str) -> str: Given a string s, remove the adjacent duplicate characters recursively. The final output should not have any adjacent duplicates. Args: s (str): Input string consisting of lowercase letters. Returns: str: Final string after removing all adjacent duplicates. Example: >>> remove_adjacent_duplicates(\\"abbaca\\") \\"ca\\" >>> remove_adjacent_duplicates(\\"azxxzy\\") \\"ay\\"","solution":"def remove_adjacent_duplicates(s): stack = [] for char in s: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return ''.join(stack)"},{"question":"from functools import reduce def multiply_elements(int_list): Calculates the product of all elements in the list using the reduce() function. >>> multiply_elements([2, 3, 4]) 24 >>> multiply_elements([-2, 3, 4]) -24 >>> multiply_elements([0, 1, 2, 3]) 0 >>> multiply_elements([5]) 5 >>> multiply_elements([-10, -10, -10, -10, 10, 10, 10, 10]) 100000000","solution":"from functools import reduce def multiply_elements(int_list): Calculates the product of all elements in the list using the reduce() function. return reduce(lambda x, y: x * y, int_list)"},{"question":"import re def validate_transaction_record(record: str) -> bool: Validates a transaction record based on specific rules. Parameters: record (str): The transaction record as a string. Returns: bool: True if the record is valid, False otherwise. >>> validate_transaction_record('2023-01-15 Grocery shopping 123.45') True >>> validate_transaction_record('2023-01-15 Dinner -50.99') True >>> validate_transaction_record('2023-01-15 12345.67') False >>> validate_transaction_record('2023/01/15 Grocery shopping 123.45') False >>> validate_transaction_record('2023-01-15Biking100.00') False","solution":"import re def validate_transaction_record(record): Validates a transaction record based on the specified rules. Parameters: record (str): The transaction record as a string. Returns: bool: True if the record is valid, False otherwise. pattern = ( r'^d{4}-d{2}-d{2} ' # Date in format YYYY-MM-DD r'[A-Za-z0-9 ]+ ' # Description with alphanumeric characters and spaces r'-?d+(.d{1,2})?' # Amount which is a valid floating-point number up to 2 decimal places ) match = re.match(pattern, record) return match is not None"},{"question":"def happy_number(n: int) -> bool: Given a positive integer \`n\`, return \`true\` if \`n\` is a happy number, and \`false\` if it is not. >>> happy_number(19) True >>> happy_number(2) False","solution":"def happy_number(n): Returns True if n is a happy number, otherwise False. def sum_of_squares(num): return sum(int(digit) ** 2 for digit in str(num)) seen = set() while n != 1 and n not in seen: seen.add(n) n = sum_of_squares(n) return n == 1"},{"question":"def max_subarray_sum(nums: List[int]) -> int: This function takes an integer array nums and returns the sum of the maximum subarray. Example: -------- >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([1]) 1 >>> max_subarray_sum([5, 4, -1, 7, 8]) 23","solution":"def max_subarray_sum(nums): This function takes an integer array nums and returns the sum of the maximum subarray. if not nums: return 0 current_sum = max_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def can_arrange_flowers(F: int, C: int) -> str: Determines if it is possible to arrange F different types of flowers given C of each type such that no more than two flowers of the same type appear consecutively. Parameters: F (int): number of different types of flowers C (int): count of each type of flower Returns: str: \\"YES\\" if arrangement is possible, \\"NO\\" otherwise >>> can_arrange_flowers(4, 3) \\"YES\\" >>> can_arrange_flowers(1, 3) \\"NO\\" >>> can_arrange_flowers(3, 1) \\"YES\\" >>> can_arrange_flowers(2, 2) \\"YES\\" >>> can_arrange_flowers(2, 3) \\"NO\\"","solution":"def can_arrange_flowers(F, C): Determines if it is possible to arrange F different types of flowers given C of each type such that no more than two flowers of the same type appear consecutively. Parameters: F (int): number of different types of flowers C (int): count of each type of flower Returns: str: \\"YES\\" if arrangement is possible, \\"NO\\" otherwise # If there are enough flower types to distribute flowers without consecutive repetition if C <= 2: return \\"YES\\" # if there are more than 2 flowers of any type if C > 2: # we need at least ceil(C / 2) + 1 flower types to distribute them without repeatition min_required_types = (C + 1) // 2 + 1 if F >= min_required_types: return \\"YES\\" return \\"NO\\""},{"question":"from typing import List def count_wins(skills: List[int]) -> List[int]: Given an array of integers representing the skill levels of participants, this function returns the number of wins for each participant in the order they were input. >>> count_wins([5, 3, 9, 1]) [2, 1, 3, 0] >>> count_wins([5, 5, 5, 5]) [0, 0, 0, 0]","solution":"def count_wins(skills): This function receives a list of skill levels of participants and returns a list of integers representing the number of wins for each participant in the order they were input. :param skills: List[int], a list of skill levels for participants :return: List[int], a list of win counts for each participant n = len(skills) wins = [0] * n for i in range(n): for j in range(n): if i != j and skills[i] > skills[j]: wins[i] += 1 return wins"},{"question":"def min_operations_to_palindrome(s: str) -> int: Returns the minimum number of operations required to convert the string \`s\` into a palindrome. >>> min_operations_to_palindrome('abca') 1 >>> min_operations_to_palindrome('race') 2 >>> min_operations_to_palindrome('a') 0 >>> min_operations_to_palindrome('aa') 0 >>> min_operations_to_palindrome('abba') 0 >>> min_operations_to_palindrome('madam') 0 >>> min_operations_to_palindrome('abcdef') 3 >>> min_operations_to_palindrome('abcdedcba') 0 >>> min_operations_to_palindrome('abcddcba') 0 >>> min_operations_to_palindrome('abccba') 0 >>> min_operations_to_palindrome('abcxceba') 2 >>> min_operations_to_palindrome('') 0 >>> min_operations_to_palindrome('z') 0","solution":"def min_operations_to_palindrome(s): Returns the minimum number of operations required to convert the string \`s\` into a palindrome. n = len(s) count = 0 # Compare characters from start and end for i in range(n // 2): if s[i] != s[n - i - 1]: count += 1 return count"},{"question":"from typing import List, Tuple def min_meeting_rooms(intervals: List[Tuple[int, int]]) -> int: Returns the minimum number of meeting rooms required to accommodate all the meetings without overlap. >>> min_meeting_rooms([(0, 30), (5, 10), (15, 20)]) # 2 >>> min_meeting_rooms([(7, 10), (2, 4)]) # 1 def test_no_meetings(): assert min_meeting_rooms([]) == 0 def test_one_meeting(): assert min_meeting_rooms([(5, 10)]) == 1 def test_non_overlapping_meetings(): assert min_meeting_rooms([(7, 10), (2, 4)]) == 1 def test_overlapping_meetings(): assert min_meeting_rooms([(0, 30), (5, 10), (15, 20)]) == 2 assert min_meeting_rooms([(1, 4), (2, 6), (8, 9), (3, 5)]) == 3 def test_complex_schedule(): assert min_meeting_rooms([(9, 10), (4, 9), (4, 17)]) == 2 assert min_meeting_rooms([(1, 5), (8, 9), (2, 6), (5, 8)]) == 2 assert min_meeting_rooms([(5, 8), (6, 8), (1, 9), (2, 6)]) == 3 assert min_meeting_rooms([(15, 30), (5, 10), (10, 15), (0, 5)]) == 1","solution":"import heapq def min_meeting_rooms(intervals): Returns the minimum number of meeting rooms required to accommodate all the meetings without overlap. if not intervals: return 0 # Sort the meetings by start time intervals.sort(key=lambda x: x[0]) # Use a min heap to track the end times of meetings end_times = [] # Add the first meeting's end time to the heap heapq.heappush(end_times, intervals[0][1]) for interval in intervals[1:]: # If the room due to free up the earliest is free, reuse it. if interval[0] >= end_times[0]: heapq.heappop(end_times) # Allocate a new room (or reuse an existing one) and add the end time to the heap heapq.heappush(end_times, interval[1]) # The size of the heap tells us the minimum rooms required for all the meetings. return len(end_times)"},{"question":"def count_subarrays_with_k_odds(arr: List[int], k: int) -> int: Given an array of integers \`arr\` and an integer \`k\`, return the number of subarrays of \`arr\` that contain exactly \`k\` odd numbers. >>> count_subarrays_with_k_odds([1,1,2,1,1], 3) 2 >>> count_subarrays_with_k_odds([2,4,6], 1) 0 >>> count_subarrays_with_k_odds([2,2,2,1,2,2,1,2,2,2], 2) 16","solution":"def count_subarrays_with_k_odds(arr, k): def at_most_k_odds(arr, k): count = 0 left = 0 odds = 0 for right, num in enumerate(arr): if num % 2 != 0: odds += 1 while odds > k: if arr[left] % 2 != 0: odds -= 1 left += 1 count += right - left + 1 return count return at_most_k_odds(arr, k) - at_most_k_odds(arr, k-1)"},{"question":"def findPairWithSum(arr: List[int], target_sum: int) -> Optional[Tuple[int, int]]: This function accepts an array of integers and a target sum. It returns a tuple of two integers from the array that add up to the target sum. If no such pair exists, it returns None. >>> findPairWithSum([1, 2, 3, 4, 5], 8) (3, 5) >>> findPairWithSum([1, 2, 3, 4, 5], 10) None >>> findPairWithSum([0, -1, 2, -3, 1], -2) (-3, 1) Args: arr (List[int]): An array of integers. target_sum (int): The target sum to find in the array. Returns: Optional[Tuple[int, int]]: A tuple of two integers if a pair is found, None otherwise. pass # Unit Test from solution import findPairWithSum def test_pair_exists(): assert findPairWithSum([1, 2, 3, 4, 5], 8) == (3, 5) or findPairWithSum([1, 2, 3, 4, 5], 8) == (5, 3) def test_no_pair_exists(): assert findPairWithSum([1, 2, 3, 4, 5], 10) == None def test_negative_numbers(): assert findPairWithSum([0, -1, 2, -3, 1], -2) in [(-3, 1), (1, -3)] def test_mixed_sign_numbers(): assert findPairWithSum([-10, 10, 20, -20, 0], 0) in [(10, -10), (-10, 10)] def test_single_element(): assert findPairWithSum([1], 1) == None def test_repeated_elements(): assert findPairWithSum([1, 2, 2, 3], 4) in [(2, 2)]","solution":"def findPairWithSum(arr, target_sum): Returns a tuple of two integers from the array that add up to the target sum. If no such pair exists, returns None. seen_numbers = {} for number in arr: complement = target_sum - number if complement in seen_numbers: return (complement, number) seen_numbers[number] = True return None"},{"question":"def flip_and_find_extremes(binary_numbers: List[str]) -> Tuple[int, int]: Given a list of binary numbers as strings, find the smallest and largest number in decimal format after flipping exactly one bit (0 to 1 or 1 to 0) in each string. >>> flip_and_find_extremes([\\"1010\\"]) (2, 14) >>> flip_and_find_extremes([\\"1010\\", \\"1100\\", \\"0001\\"]) (0, 14) >>> flip_and_find_extremes([\\"0000\\", \\"0000\\", \\"0000\\"]) (1, 8) >>> flip_and_find_extremes([\\"1111\\"]) (7, 14) >>> flip_and_find_extremes([\\"0\\", \\"1\\"]) (0, 1) >>> flip_and_find_extremes([\\"1111111111\\"]) (511, 1022)","solution":"def flip_and_find_extremes(binary_numbers): def decimal_after_flip(binary_str): nums = [] for i in range(len(binary_str)): flipped = list(binary_str) flipped[i] = '1' if binary_str[i] == '0' else '0' nums.append(int(''.join(flipped), 2)) return min(nums), max(nums) smallest = float('inf') largest = float('-inf') for binary in binary_numbers: local_min, local_max = decimal_after_flip(binary) smallest = min(smallest, local_min) largest = max(largest, local_max) return smallest, largest"},{"question":"def rgb_to_hex(r, g, b): Converts RGB values to a hex string in the format '#RRGGBB'. Each component (r, g, b) ranges from 0 to 255. >>> rgb_to_hex(255, 99, 71) '#FF6347' >>> rgb_to_hex(0, 0, 0) '#000000' >>> rgb_to_hex(255, 255, 255) '#FFFFFF' >>> rgb_to_hex(128, 128, 128) '#808080' >>> rgb_to_hex(0, 0, 255) '#0000FF' >>> rgb_to_hex(0, 255, 255) '#00FFFF' >>> rgb_to_hex(255, 0, 255) '#FF00FF' >>> rgb_to_hex(255, 255, 0) '#FFFF00' # Your implementation here","solution":"def rgb_to_hex(r, g, b): Converts RGB values to a hex string in the format '#RRGGBB'. Each component (r, g, b) ranges from 0 to 255. # Ensure the values are within the range 0-255 if not (0 <= r <= 255 and 0 <= g <= 255 and 0 <= b <= 255): raise ValueError(\\"RGB values must be in the range 0-255\\") return '#{0:02X}{1:02X}{2:02X}'.format(r, g, b)"},{"question":"def longestEvenSubarray(arr: List[int]) -> int: Returns the length of the longest contiguous subarray containing only even numbers. >>> longestEvenSubarray([1, 2, 4, 6, 3, 8, 10, 12]) 3 >>> longestEvenSubarray([7, 5, 9, 2, 4, 6, 1]) 3 >>> longestEvenSubarray([5, 7, 9, 11]) 0 >>> longestEvenSubarray([2, 4, 6, 8, 10]) 5 >>> longestEvenSubarray([1, 3, 5, 7, 9]) 0 >>> longestEvenSubarray([]) 0 >>> longestEvenSubarray([2]) 1 >>> longestEvenSubarray([1]) 0","solution":"def longestEvenSubarray(arr): Returns the length of the longest contiguous subarray containing only even numbers. max_length = 0 current_length = 0 for num in arr: if num % 2 == 0: current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 return max_length"},{"question":"def first_non_repeating(s: str) -> str: Returns the first non-repeating character in the string. If there is no non-repeating character, returns '_'. >>> first_non_repeating('stress') 't' >>> first_non_repeating('moonmen') 'e' >>> first_non_repeating('aabbcc') '_' >>> first_non_repeating('aA') 'a' >>> first_non_repeating('Aa') 'A' >>> first_non_repeating('x') 'x' >>> first_non_repeating('') '_'","solution":"def first_non_repeating(s): Returns the first non-repeating character in the string. If there is no non-repeating character, returns '_'. char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 for char in s: if char_count[char] == 1: return char return '_'"},{"question":"def unique_cards(alice_cards, bob_cards): Identifies the unique cards in Alice's hand and Bob's hand. :param alice_cards: List of integers representing Alice's cards :param bob_cards: List of integers representing Bob's cards :return: Two lists: one for Alice's unique cards sorted in ascending order, and another for Bob's unique cards sorted in ascending order. pass # Example usage # alice_cards = [1, 2, 3, 4] # bob_cards = [3, 4, 5, 6, 7] # print(unique_cards(alice_cards, bob_cards)) # Output: ([1, 2], [5, 6, 7])","solution":"def unique_cards(alice_cards, bob_cards): Identifies the unique cards in Alice's hand and Bob's hand. :param alice_cards: List of integers representing Alice's cards :param bob_cards: List of integers representing Bob's cards :return: Two lists: one for Alice's unique cards sorted in ascending order, and another for Bob's unique cards sorted in ascending order. alice_set = set(alice_cards) bob_set = set(bob_cards) unique_alice = sorted(alice_set - bob_set) unique_bob = sorted(bob_set - alice_set) return unique_alice, unique_bob # Example usage # alice_cards = [1, 2, 3, 4] # bob_cards = [3, 4, 5, 6, 7] # print(unique_cards(alice_cards, bob_cards)) # Output: ([1, 2], [5, 6, 7])"},{"question":"def is_valid_integer(s: str) -> bool: Checks if the input string is a valid integer representation. A valid integer can optionally start with a '+' or '-' sign, followed by one or more digits. The string can also include leading zeros, but no other characters, spaces, or punctuation marks are allowed. The string should be non-empty. >>> is_valid_integer(\\"123\\") True >>> is_valid_integer(\\"+007\\") True >>> is_valid_integer(\\"-89\\") True >>> is_valid_integer(\\"12a3\\") False def validate_integers(test_cases: List[str]) -> List[str]: Takes a list of test cases and returns a list of \\"YES\\" or \\"NO\\" depending on whether the strings are valid integer representations. >>> validate_integers([\\"123\\", \\"+007\\", \\"-89\\", \\"12a3\\"]) [\\"YES\\", \\"YES\\", \\"YES\\", \\"NO\\"] >>> validate_integers([\\"0\\", \\"+0\\", \\"-0\\"]) [\\"YES\\", \\"YES\\", \\"YES\\"]","solution":"def is_valid_integer(s): Checks if the input string s is a valid integer representation. if not s: return False # Check if the string starts with optional '+' or '-' and followed by digits if s[0] in ('+', '-'): s = s[1:] # Ensure the remaining characters are digits and non-empty return s.isdigit() and len(s) > 0 def validate_integers(test_cases): Takes a list of test cases and returns a list of \\"YES\\" or \\"NO\\" depending on whether the strings are valid integer representations. results = [] for s in test_cases: if is_valid_integer(s): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"import re from typing import List def is_palindrome(S: str) -> bool: Determines if the given string S is a palindrome, ignoring case and non-alphanumeric characters. >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") True >>> is_palindrome(\\"race a car\\") False >>> is_palindrome(\\"No lemon, no melon\\") True def check_palindromes(T: int, strings: List[str]) -> List[str]: Given T strings, determines for each if it is a palindrome and returns a list of \\"yes\\" or \\"no\\". >>> check_palindromes(3, [\\"A man, a plan, a canal: Panama\\", \\"race a car\\", \\"No lemon, no melon\\"]) [\\"yes\\", \\"no\\", \\"yes\\"] >>> check_palindromes(2, [\\"Hello, World!\\", \\"Madam In Eden, I’m Adam\\"]) [\\"no\\", \\"yes\\"]","solution":"import re def is_palindrome(S): Determines if the given string S is a palindrome, ignoring case and non-alphanumeric characters. # Clean the string, keep only alphanumeric characters and convert to lowercase clean_s = re.sub(r'[^A-Za-z0-9]', '', S).lower() # Check if the cleaned string is a palindrome return clean_s == clean_s[::-1] def check_palindromes(T, strings): Given T strings, determines for each if it is a palindrome and returns a list of \\"yes\\" or \\"no\\". results = [] for s in strings: if is_palindrome(s): results.append(\\"yes\\") else: results.append(\\"no\\") return results"},{"question":"class Rectangle: def __init__(self, length: int, width: int): Initializes the rectangle with length and width. :param length: The length of the rectangle. :param width: The width of the rectangle. self.length = length self.width = width def area(self) -> int: Calculate and return the area of the rectangle. :return: The area of the rectangle. def perimeter(self) -> int: Calculate and return the perimeter of the rectangle. :return: The perimeter of the rectangle. def set_dimensions(self, length: int, width: int): Sets new dimensions (length and width) for the rectangle. :param length: The new length of the rectangle. :param width: The new width of the rectangle. # Unit Tests: def test_initial_area(): rect = Rectangle(4, 8) assert rect.area() == 32 def test_initial_perimeter(): rect = Rectangle(4, 8) assert rect.perimeter() == 24 def test_set_dimensions_area(): rect = Rectangle(4, 8) rect.set_dimensions(5, 10) assert rect.area() == 50 def test_set_dimensions_perimeter(): rect = Rectangle(4, 8) rect.set_dimensions(5, 10) assert rect.perimeter() == 30 def test_set_dimensions_edge_case(): rect = Rectangle(1, 1) rect.set_dimensions(0, 0) assert rect.area() == 0 assert rect.perimeter() == 0","solution":"class Rectangle: def __init__(self, length, width): self.length = length self.width = width def area(self): Returns the area of the rectangle. return self.length * self.width def perimeter(self): Returns the perimeter of the rectangle. return 2 * (self.length + self.width) def set_dimensions(self, length, width): Sets new dimensions (length and width) for the rectangle. self.length = length self.width = width"},{"question":"def is_palindrome(x: int) -> bool: Determines if a given integer x is a palindrome. >>> is_palindrome(121) True >>> is_palindrome(123) False def check_palindromes(test_cases: List[int]) -> List[str]: Given a list of integers, check each for palindrome property and return results. >>> check_palindromes([121, 123, 44444]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> check_palindromes([1, 22, 333, 12321, 12345]) [\\"YES\\", \\"YES\\", \\"YES\\", \\"YES\\", \\"NO\\"]","solution":"def is_palindrome(x): Determines if a given integer x is a palindrome. str_x = str(x) return str_x == str_x[::-1] def check_palindromes(test_cases): Given a list of integers, check each for palindrome property and return results. results = [] for x in test_cases: if is_palindrome(x): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def min_coins(coins: List[int], amount: int) -> int: Calculate the minimum number of coins needed to make a specific amount of change using given denominations of coins. >>> min_coins([1, 2, 5], 11) 3 >>> min_coins([2], 3) -1 >>> min_coins([1], 2) 2","solution":"def min_coins(coins, amount): max_amount = amount + 1 dp = [max_amount] * (amount + 1) dp[0] = 0 for coin in coins: for x in range(coin, amount + 1): dp[x] = min(dp[x], dp[x - coin] + 1) return dp[amount] if dp[amount] != max_amount else -1"},{"question":"def first_non_repeated_character(s: str) -> str: Returns the first character in the string that is not repeated anywhere in the string. If all characters are repeated, returns an empty string. >>> first_non_repeated_character(\\"stress\\") == \\"t\\" >>> first_non_repeated_character(\\"aabbcc\\") == \\"\\" >>> first_non_repeated_character(\\"abcdef\\") == \\"a\\" >>> first_non_repeated_character(\\"\\") == \\"\\" pass def test_example_cases(): assert first_non_repeated_character(\\"stress\\") == \\"t\\" assert first_non_repeated_character(\\"aabbcc\\") == \\"\\" assert first_non_repeated_character(\\"abcdef\\") == \\"a\\" assert first_non_repeated_character(\\"\\") == \\"\\" def test_additional_cases(): assert first_non_repeated_character(\\"swiss\\") == \\"w\\" assert first_non_repeated_character(\\"repeated\\") == \\"r\\" assert first_non_repeated_character(\\"Mississippi\\") == \\"M\\" assert first_non_repeated_character(\\"alphabet\\") == \\"l\\" assert first_non_repeated_character(\\"abcdefgzhijklmnopqrstuvwxyz\\") == \\"a\\" # Case with all characters having different counts assert first_non_repeated_character(\\"aabbcceeffgghhii\\") == \\"\\"","solution":"def first_non_repeated_character(s): Returns the first character in the string that is not repeated anywhere in the string. If all characters are repeated, returns an empty string. # Create a dictionary to count the occurrences of each character char_count = {} # Count each character in the string for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find the first character with a count of 1 for char in s: if char_count[char] == 1: return char # If no such character exists, return an empty string return \\"\\""},{"question":"from typing import List def longest_subarray(arr: List[int], k: int) -> int: Given an array of integers, return the length of the longest subarray where the absolute difference between any two elements is less than or equal to a specified threshold \`k\`. Examples: >>> longest_subarray([1, 3, 4, 9, 10], 3) 3 >>> longest_subarray([1, 2, 3, 4, 5], 1) 2 >>> longest_subarray([10, 1, 2, 3, 4], 2) 3","solution":"from typing import List def longest_subarray(arr: List[int], k: int) -> int: if not arr: return 0 max_length = 0 start = 0 for end in range(len(arr)): while max(arr[start:end+1]) - min(arr[start:end+1]) > k: start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"from typing import List, Tuple def sum_order_prices(n: int, q: int, prices: List[int], queries: List[Tuple[int, int]]) -> List[int]: Given the number of orders \`n\`, the number of queries \`q\`, the list of order prices \`prices\`, and the list of queries \`queries\` (each a tuple of start and end indices), return the sum of the prices of orders within each segment defined by the queries. >>> sum_order_prices(5, 3, [10, 20, 30, 40, 50], [(1, 3), (2, 4), (1, 5)]) == [60, 90, 150] >>> sum_order_prices(4, 1, [100, 200, 300, 400], [(1, 2)]) == [300] >>> sum_order_prices(6, 1, [10, 20, 30, 40, 50, 60], [(1, 6)]) == [210] >>> sum_order_prices(3, 2, [15, 25, 35], [(1, 2), (2, 3)]) == [40, 60] >>> sum_order_prices(1, 1, [50], [(1, 1)]) == [50] >>> sum_order_prices(6, 2, [5, 10, 15, 20, 25, 30], [(1, 3), (2, 5)]) == [30, 70]","solution":"def sum_order_prices(n, q, prices, queries): Given the number of orders \`n\`, the number of queries \`q\`, the list of order prices \`prices\`, and the list of queries \`queries\` (each a tuple of start and end indices), return the sum of the prices of orders within each segment defined by the queries. result = [] for l, r in queries: # Convert 1-based index to 0-based index and calculate the sum result.append(sum(prices[l-1:r])) return result"},{"question":"from typing import List def contains_duplicate(nums: List[int]) -> bool: Given an integer array \`nums\`, return \`True\` if any value appears at least twice in the array, and return \`False\` if every element is distinct. >>> contains_duplicate([1, 2, 3, 1]) True >>> contains_duplicate([1, 2, 3, 4]) False >>> contains_duplicate([1, 1, 1, 3, 3, 4, 3, 2, 4, 2]) True >>> contains_duplicate([]) False >>> contains_duplicate([1]) False pass def test_contains_duplicate(): assert contains_duplicate([1, 2, 3, 1]) == True assert contains_duplicate([1, 2, 3, 4]) == False assert contains_duplicate([1, 1, 1, 3, 3, 4, 3, 2, 4, 2]) == True assert contains_duplicate([]) == False assert contains_duplicate([1]) == False assert contains_duplicate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == False assert contains_duplicate([10, 20, 20, 30, 40]) == True assert contains_duplicate([1, 2, 3, 4, 5, 5]) == True","solution":"def contains_duplicate(nums): Returns True if any value appears at least twice in the array, and returns False if every element is distinct. return len(nums) != len(set(nums))"},{"question":"def wordWrap(text: str, limit: int) -> str: Write a function \`wordWrap\` that takes a string \`text\` and an integer \`limit\` as its parameters. The function should return a new string where the original text is broken into lines of a maximum length specified by \`limit\`. Words should not be split between lines; if a word would exceed the limit, it should be moved to the next line. If \`limit\` is less than the length of the longest word in \`text\`, the function should raise an error. Properly handle multiple spaces between words in \`text\`. Take care of corner cases where \`text\` could be an empty string or consist entirely of spaces. >>> wordWrap(\\"The quick brown fox jumps over the lazy dog\\", 10) \\"The quicknbrown foxnjumps overnthe lazyndog\\" >>> wordWrap(\\"\\", 10) \\"\\" >>> wordWrap(\\" \\", 10) \\"\\" >>> wordWrap(\\"supercalifragilisticexpialidocious\\", 10) Traceback (most recent call last): ... ValueError: The limit is less than the length of the longest word in the text. >>> wordWrap(\\"The quick brown fox\\", 10) \\"The quicknbrown fox\\" >>> wordWrap(\\"The quick brown\\", 15) \\"The quick brown\\" >>> wordWrap(\\"The quick brown fox jumps\\", 15) \\"The quick brownnfox jumps\\"","solution":"def wordWrap(text, limit): if not text.strip(): return \\"\\" words = text.split() if any(len(word) > limit for word in words): raise ValueError(\\"The limit is less than the length of the longest word in the text.\\") wrapped_text = [] current_line = [] current_length = 0 for word in words: if current_length + len(word) + len(current_line) > limit: wrapped_text.append(\\" \\".join(current_line)) current_line = [word] current_length = len(word) else: current_line.append(word) current_length += len(word) if current_line: wrapped_text.append(\\" \\".join(current_line)) return \\"n\\".join(wrapped_text)"},{"question":"def segregate_even_odd(numbers: list) -> None: Segregates even and odd numbers such that all even numbers come before odd numbers while preserving the relative order. Args: numbers (list): List of integers. Returns: None: The list is modified in place. Examples: >>> numbers = [12, 34, 45, 9, 8, 90, 3] >>> segregate_even_odd(numbers) >>> numbers [12, 34, 8, 90, 45, 9, 3]","solution":"def segregate_even_odd(numbers): Segregates even and odd numbers such that all even numbers come before odd numbers while preserving the relative order. Args: numbers (list): List of integers. Returns: None: The list is modified in place. even_index = 0 for current in range(len(numbers)): if numbers[current] % 2 == 0: # Check if the number is even # If it is even then we move it to the 'even_index' position numbers.insert(even_index, numbers.pop(current)) even_index += 1"},{"question":"from typing import List from collections import defaultdict def longest_substring(s: str, k: int) -> int: You are given a string \`s\` consisting of lowercase letters, and an integer \`k\`. You can select any substring of \`s\` and change all of its characters to any other single lowercase letter. Your goal is to find the length of the longest possible substring that can be achieved by performing at most \`k\` operations. >>> longest_substring(\\"abaccc\\", 1) 4 >>> longest_substring(\\"aaabbc\\", 2) 5","solution":"from collections import defaultdict def longest_substring(s, k): def is_valid(count, max_count, k): return (sum(count.values()) - max_count) <= k left, max_length, max_count = 0, 0, 0 count = defaultdict(int) for right in range(len(s)): count[s[right]] += 1 max_count = max(max_count, count[s[right]]) while not is_valid(count, max_count, k): count[s[left]] -= 1 left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"def can_partition(nums: List[int]) -> bool: Determine if it is possible to partition the list into two subsets with equal sum. >>> can_partition([1, 5, 11, 5]) True >>> can_partition([1, 2, 3, 5]) False","solution":"def can_partition(nums): total_sum = sum(nums) # If total_sum is odd, it's not possible to partition it into two equal sums if total_sum % 2 != 0: return False target = total_sum // 2 # Initialize a DP array where dp[i] will be True if a subset with sum i can be achieved dp = [False] * (target + 1) dp[0] = True # There's always a subset with sum 0 (the empty subset) for num in nums: # Traverse from target to num to avoid using the same num more than once for i in range(target, num - 1, -1): dp[i] = dp[i] or dp[i - num] return dp[target]"},{"question":"def middle_me(text: str, word: str) -> str: Inserts the word into the middle of text. If text has an odd length, insert word immediately after the middle character. >>> middle_me(\\"abc\\", \\"word\\") == \\"abwordc\\" >>> middle_me(\\"abcd\\", \\"word\\") == \\"abwordcd\\" >>> middle_me(\\"a\\", \\"word\\") == \\"aword\\" >>> middle_me(\\"\\", \\"word\\") == \\"word\\" >>> middle_me(\\"abcdefgh\\", \\"xyz\\") == \\"abcdxyzefgh\\" >>> middle_me(\\"abcdefghij\\", \\"xyz\\") == \\"abcdexyzfghij\\"","solution":"def middle_me(text, word): Inserts the word into the middle of text. If text has an odd length, insert word immediately after the middle character. Parameters: text (str): The original string. word (str): The string to be inserted into the middle of text. Returns: str: The new string with word inserted in the middle of text. mid_index = len(text) // 2 if len(text) % 2 == 0: # text length is even return text[:mid_index] + word + text[mid_index:] else: # text length is odd return text[:mid_index + 1] + word + text[mid_index + 1:]"},{"question":"def assign_projects_to_servers(servers, projects): Assigns projects to servers such that no server's resources are exceeded. :param servers: List[Dict[str, int]], a list of servers with 'cpu' and 'memory' keys :param projects: List[Dict[str, int]], a list of projects with 'cpu' and 'memory' keys :return: List[Dict[str, int]], a list of assignments with 'server' and 'project' keys If assignment is not possible for any project, raises ValueError. >>> servers = [ ... {\\"cpu\\": 8, \\"memory\\": 32}, ... {\\"cpu\\": 16, \\"memory\\": 64}, ... {\\"cpu\\": 4, \\"memory\\": 16} ... ] >>> projects = [ ... {\\"cpu\\": 2, \\"memory\\": 8}, ... {\\"cpu\\": 4, \\"memory\\": 16}, ... {\\"cpu\\": 10, \\"memory\\": 32} ... ] >>> assign_projects_to_servers(servers, projects) [{'server': 0, 'project': 0}, {'server': 0, 'project': 1}, {'server': 1, 'project': 2}] >>> servers = [ ... {\\"cpu\\": 8, \\"memory\\": 32}, ... {\\"cpu\\": 16, \\"memory\\": 64}, ... {\\"cpu\\": 4, \\"memory\\": 16} ... ] >>> projects = [ ... {\\"cpu\\": 8, \\"memory\\": 8}, ... {\\"cpu\\": 8, \\"memory\\": 16}, ... {\\"cpu\\": 10, \\"memory\\": 32} ... ] >>> try: ... assign_projects_to_servers(servers, projects) ... except ValueError as e: ... print(str(e)) Insufficient resources for projects >>> servers = [ ... {\\"cpu\\": 10, \\"memory\\": 40} ... ] >>> projects = [ ... {\\"cpu\\": 4, \\"memory\\": 16}, ... {\\"cpu\\": 6, \\"memory\\": 24} ... ] >>> assign_projects_to_servers(servers, projects) [{'server': 0, 'project': 0}, {'server': 0, 'project': 1}] >>> servers = [ ... {\\"cpu\\": 10, \\"memory\\": 40} ... ] >>> projects = [] >>> assign_projects_to_servers(servers, projects) [] >>> servers = [] >>> projects = [ ... {\\"cpu\\": 10, \\"memory\\": 40} ... ] >>> try: ... assign_projects_to_servers(servers, projects) ... except ValueError as e: ... print(str(e)) Insufficient resources for projects","solution":"def assign_projects_to_servers(servers, projects): Assigns projects to servers such that no server's resources are exceeded. :param servers: List[Dict[str, int]], a list of servers with 'cpu' and 'memory' keys :param projects: List[Dict[str, int]], a list of projects with 'cpu' and 'memory' keys :return: List[Dict[str, int]], a list of assignments with 'server' and 'project' keys If assignment is not possible for any project, raises ValueError. assignments = [] for proj_index, project in enumerate(projects): assigned = False for serv_index, server in enumerate(servers): if server['cpu'] >= project['cpu'] and server['memory'] >= project['memory']: # Assign project to this server assignments.append({\\"server\\": serv_index, \\"project\\": proj_index}) # Deduct server resources server['cpu'] -= project['cpu'] server['memory'] -= project['memory'] assigned = True break if not assigned: raise ValueError(\\"Insufficient resources for projects\\") return assignments"},{"question":"def trap_rain_water(heights: List[int]) -> int: Calculate the amount of water that can be trapped between the buildings. :param heights: List[int] - List of integers representing the height of each building. :return: int - The total amount of water trapped. >>> trap_rain_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 >>> trap_rain_water([0]) == 0 >>> trap_rain_water([]) == 0 from solution import trap_rain_water def test_single_building(): assert trap_rain_water([0]) == 0 def test_no_buildings(): assert trap_rain_water([]) == 0 def test_two_buildings(): assert trap_rain_water([0, 1]) == 0 assert trap_rain_water([1, 0]) == 0 def test_sample_input(): assert trap_rain_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 def test_flat_buildings(): assert trap_rain_water([3, 3, 3, 3]) == 0 def test_descending_buildings(): assert trap_rain_water([5, 4, 3, 2, 1]) == 0 def test_ascending_buildings(): assert trap_rain_water([1, 2, 3, 4, 5]) == 0 def test_multiple_trapping(): assert trap_rain_water([0, 2, 0, 2, 0, 2, 0, 2]) == 6 def test_large_input(): assert trap_rain_water([0] * 100000) == 0","solution":"def trap_rain_water(heights): Calculate the amount of water that can be trapped between the buildings. :param heights: List[int] - List of integers representing the height of each building. :return: int - The total amount of water trapped. if not heights or len(heights) < 3: return 0 n = len(heights) left = [0] * n right = [0] * n # Fill left max height for each building left[0] = heights[0] for i in range(1, n): left[i] = max(left[i - 1], heights[i]) # Fill right max height for each building right[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right[i] = max(right[i + 1], heights[i]) # Calculate the water trapped at each building water_trapped = 0 for i in range(n): water_trapped += min(left[i], right[i]) - heights[i] return water_trapped"},{"question":"def rob(nums): Returns the maximum amount of money you can steal without triggering the alarm. >>> rob([2, 3, 2]) 3 >>> rob([1, 2, 3, 1]) 4 >>> rob([2, 7, 9, 3, 1]) 11 >>> rob([0]) 0","solution":"def rob(nums): Returns the maximum amount of money you can steal without triggering the alarm. # Helper function def rob_line(houses): prev = curr = 0 for money in houses: prev, curr = curr, max(curr, prev + money) return curr if len(nums) == 1: return nums[0] return max(rob_line(nums[:-1]), rob_line(nums[1:]))"},{"question":"def min_flips_to_black(board: List[List[int]]) -> int: Determine the minimum number of sequences of flips required to make the entire board black. :param board: A list of list of integers where 0 denotes a white cell and 1 denotes a black cell :return: The minimum number of flips required to turn all cells black >>> min_flips_to_black([[0,0,0],[0,0,0],[0,0,0]]) == 1 >>> min_flips_to_black([[1,0,1],[0,0,0],[1,0,1]]) == 2 >>> min_flips_to_black([[0,1,0],[1,0,1],[0,1,0]]) == 3 >>> min_flips_to_black([[1,1,1],[1,1,1],[1,1,1]]) == 0 >>> min_flips_to_black([[0]]) == 1 >>> min_flips_to_black([[1]]) == 0","solution":"def min_flips_to_black(board): Returns the minimum number of sequences of flips required to make the entire board black. n = len(board) # Count the number of 0's on the board num_zeros = sum(board[i][j] == 0 for i in range(n) for j in range(n)) # If there are no zeros, then no flips are needed. if num_zeros == 0: return 0 # Only one flip is needed to flip the entire grid to black return 1"},{"question":"def adjust_stock_levels(initial_stock: dict, transactions: list) -> dict: Adjust the stock levels of products in a store. Parameters: initial_stock (dict): Dictionary representing the initial stock levels. transactions (list): List of transactions, each represented as a tuple (product_name, quantity_change). Returns: dict: Dictionary with the final stock levels of the products. Example: >>> adjust_stock_levels({'Apples': 10, 'Bananas': 5, 'Oranges': 8}, [('Apples', -3), ('Bananas', 10), ('Oranges', -9)]) {'Apples': 7, 'Bananas': 15, 'Oranges': 0} >>> adjust_stock_levels({'Apples': 10, 'Bananas': 5}, [('Apples', -15), ('Bananas', -10)]) {'Apples': 0, 'Bananas': 0}","solution":"def adjust_stock_levels(initial_stock, transactions): Adjusts the stock levels based on transactions. Parameters: initial_stock (dict): Dictionary representing the initial stock levels. transactions (list): List of transactions, each represented as a tuple (product_name, quantity_change). Returns: dict: Dictionary with the final stock levels of the products. final_stock = initial_stock.copy() for product, change in transactions: new_quantity = final_stock[product] + change final_stock[product] = max(new_quantity, 0) return final_stock"},{"question":"def product_except_self(nums): This function returns a list such that each element at index i of the output list is the product of all the numbers in the input list except the one at i. Example usage: >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([2, 3, 4]) [12, 8, 6] >>> product_except_self([4, 5, 6]) [30, 24, 20] >>> product_except_self([1, 1, 1, 1]) [1, 1, 1, 1] >>> product_except_self([-1, 2, -3, 4]) [-24, 12, -8, 6] You may not use division and your algorithm should run in O(n) time complexity. # Your code here","solution":"def product_except_self(nums): This function returns a list such that each element at index i of the output list is the product of all the numbers in the input list except the one at i. length = len(nums) # Step 1: Create an output array and initialize with 1s output = [1] * length # Step 2: Calculate the prefix products prefix = 1 for i in range(length): output[i] = prefix prefix *= nums[i] # Step 3: Calculate the postfix products postfix = 1 for i in range(length - 1, -1, -1): output[i] *= postfix postfix *= nums[i] return output"},{"question":"def char_frequencies(t: int, strings: List[str]) -> str: Determine the frequency of each character in the string and print in alphabetical order. Parameters: t (int): The number of test cases. strings (list of str): The strings for which to determine the frequencies. Returns: str: The frequencies of the characters in alphabetical order for each string, each test case separated by a blank line. >>> char_frequencies(1, [\\"apple\\"]) \\"a: 1ne: 1nl: 1np: 2\\" >>> char_frequencies(1, [\\"banana\\"]) \\"a: 3nb: 1nn: 2\\" >>> char_frequencies(2, [\\"apple\\", \\"banana\\"]) \\"a: 1ne: 1nl: 1np: 2nna: 3nb: 1nn: 2\\" >>> char_frequencies(2, [\\"aaa\\", \\"bbb\\"]) \\"a: 3nnb: 3\\" >>> char_frequencies(3, [\\"a\\", \\"b\\", \\"c\\"]) \\"a: 1nnb: 1nnc: 1\\"","solution":"def char_frequencies(t, strings): Returns the frequency of each character in the strings. Parameters: t (int): The number of test cases. strings (list of str): The strings for which to determine the frequencies. Returns: list of str: The frequencies of the characters in alphabetical order for each string. results = [] for s in strings: frequency = {} for char in s: if char in frequency: frequency[char] += 1 else: frequency[char] = 1 sorted_chars = sorted(frequency.items()) result = \\"n\\".join(f\\"{char}: {count}\\" for char, count in sorted_chars) results.append(result) return \\"nn\\".join(results)"},{"question":"def maxDifference(arr: List[int]) -> int: Returns the maximum difference between any two elements in the array such that the larger element comes after the smaller one. Example: >>> maxDifference([2, 3, 10, 6, 4, 8, 1]) 8 >>> maxDifference([7, 9, 5, 6, 3, 2]) 2 >>> maxDifference([5]) 0 >>> maxDifference([]) 0 >>> maxDifference([10, 9, 8, 7, 6, 5]) -1 >>> maxDifference([3, 3, 3, 3, 3]) 0 >>> maxDifference([1, 1000, -1, 500, -500, 2000, -1000]) 2500 pass","solution":"def maxDifference(arr): Returns the maximum difference between any two elements in the array such that the larger element comes after the smaller one. if len(arr) < 2: return 0 min_element = arr[0] max_diff = arr[1] - arr[0] for i in range(1, len(arr)): max_diff = max(max_diff, arr[i] - min_element) min_element = min(min_element, arr[i]) return max_diff"},{"question":"from typing import List def can_form_palindrome(s: str) -> str: Determines if a given string can be rearranged to form a palindrome. >>> can_form_palindrome(\\"civic\\") \\"YES\\" >>> can_form_palindrome(\\"ivicc\\") \\"YES\\" >>> can_form_palindrome(\\"civil\\") \\"NO\\" >>> can_form_palindrome(\\"aabbcc\\") \\"YES\\" def process_inputs(T: int, test_cases: List[str]) -> List[str]: Processes the inputs for multiple test cases and returns the results. >>> process_inputs(3, [\\"civic\\", \\"ivicc\\", \\"civil\\"]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> process_inputs(2, [\\"aabb\\", \\"abc\\"]) [\\"YES\\", \\"NO\\"]","solution":"def can_form_palindrome(s): Determines if a given string can be rearranged to form a palindrome. from collections import Counter count = Counter(s) odd_count = sum(1 for v in count.values() if v % 2 != 0) # A string can be rearranged to form a palindrome if at most one character has an odd count. if odd_count <= 1: return \\"YES\\" else: return \\"NO\\" def process_inputs(T, test_cases): results = [] for case in test_cases: results.append(can_form_palindrome(case)) return results"},{"question":"from typing import List import re from collections import Counter def is_scrambled_palindrome(s: str) -> bool: Determines if a given string is a scrambled palindrome. Only considers alphabetical characters, case insensitive. Args: s (str): The input string to check. Returns: bool: True if the string is a scrambled palindrome, False otherwise. Examples: >>> is_scrambled_palindrome(\\"Tact Coa\\") True >>> is_scrambled_palindrome(\\"abcabc\\") True >>> is_scrambled_palindrome(\\"hello\\") False","solution":"from collections import Counter import re def is_scrambled_palindrome(s): Determines if the given string is a scrambled palindrome. Only considers alphabetical characters, case insensitive. # Remove non-alphabetical characters and convert to lowercase cleaned_str = re.sub(r'[^a-zA-Z]', '', s).lower() # Count the frequency of each character char_count = Counter(cleaned_str) # Count the number of characters with an odd frequency odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can be rearranged to a palindrome if it has at most one character with an odd frequency return odd_count <= 1"},{"question":"from typing import List def longest_consecutive(nums: List[int]) -> int: Given an unsorted integer array, finds the length of the longest consecutive elements sequence. Your algorithm should run in O(n) complexity. >>> longest_consecutive([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive([]) 0 >>> longest_consecutive([1]) 1 >>> longest_consecutive([10, 5, 20]) 1 >>> longest_consecutive([-1, -2, -3, -4, -5]) 5 >>> longest_consecutive([1, 2, 2, 3, 4]) 4 >>> longest_consecutive([10, 2, 3, 7, 4, 6, 5]) 6","solution":"def longest_consecutive(nums): Finds the length of the longest consecutive elements sequence. if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in num_set: # Only check if it's the start of a sequence if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def max_packages(max_weight: int, weights: List[int]) -> int: Returns the maximum number of packages that can be delivered in a single trip without exceeding the weight limit of the vehicle. >>> max_packages(10, [2, 3, 4, 5]) 3 >>> max_packages(7, [2, 2, 3, 3, 4]) 3 >>> max_packages(5, [5]) 1 >>> max_packages(5, [6, 2, 1]) 2 >>> max_packages(10, [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) 10 >>> max_packages(10, []) 0 >>> max_packages(1, [2, 1, 3]) 1 >>> max_packages(9, [3, 3, 3]) 3 >>> max_packages(5, [6, 7, 8, 9]) 0","solution":"def max_packages(max_weight, weights): Returns the maximum number of packages that can be delivered in a single trip without exceeding the weight limit of the vehicle. weights.sort() current_weight = 0 count = 0 for weight in weights: if current_weight + weight <= max_weight: current_weight += weight count += 1 else: break return count"},{"question":"def min_sugar_modifications(N: int, sugar_levels: List[int]) -> int: Returns the minimum number of sugar modifications required to equalize the sugar in all cupcakes. Parameters: N (int): Number of cupcakes sugar_levels (list): List containing the amount of sugar in each cupcake Returns: int: Minimum number of sugar modifications required >>> min_sugar_modifications(4, [4, 5, 6, 7]) 4 >>> min_sugar_modifications(3, [5, 5, 5]) 0","solution":"def min_sugar_modifications(N, sugar_levels): Returns the minimum number of sugar modifications required to equalize the sugar in all cupcakes. Parameters: N (int): Number of cupcakes sugar_levels (list): List containing the amount of sugar in each cupcake Returns: int: Minimum number of sugar modifications required median = sorted(sugar_levels)[N // 2] return sum(abs(sugar_level - median) for sugar_level in sugar_levels)"},{"question":"def is_balanced(S: str) -> str: Determine if the string is balanced. A string is considered balanced if the number of occurrences of each character in the string is the same. Parameters: S (str): The string to be checked. Returns: str: \\"YES\\" if the string is balanced, \\"NO\\" otherwise. >>> is_balanced(\\"aabb\\") \\"YES\\" >>> is_balanced(\\"abcabc\\") \\"YES\\" >>> is_balanced(\\"aabbccd\\") \\"NO\\" def process_test_cases(T: int, test_cases: list) -> list: Process multiple test cases to determine if strings are balanced. Parameters: T (int): The number of test cases. test_cases (list): List of strings to be checked. Returns: list: List of results for each test case, \\"YES\\" or \\"NO\\". >>> process_test_cases(3, [\\"aabb\\", \\"abcabc\\", \\"aabbccd\\"]) [\\"YES\\", \\"YES\\", \\"NO\\"]","solution":"def is_balanced(S): Returns \\"YES\\" if the string S is balanced, otherwise returns \\"NO\\". from collections import Counter char_counts = Counter(S) all_counts = list(char_counts.values()) if len(set(all_counts)) == 1: return \\"YES\\" else: return \\"NO\\" def process_test_cases(T, test_cases): results = [] for S in test_cases: results.append(is_balanced(S)) return results"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def is_valid_bst(root: TreeNode) -> bool: Checks if a binary tree is a valid binary search tree (BST). >>> root = TreeNode(2, TreeNode(1), TreeNode(3)) >>> is_valid_bst(root) True >>> root = TreeNode(5, TreeNode(1), TreeNode(4, TreeNode(3), TreeNode(6))) >>> is_valid_bst(root) False","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def is_valid_bst(root: TreeNode) -> bool: def validate(node, low=float('-inf'), high=float('inf')): if not node: return True if not (low <= node.value <= high): return False return validate(node.left, low, node.value) and validate(node.right, node.value, high) return validate(root)"},{"question":"def find_anagrams(words: List[str]) -> List[str]: Returns a list of strings that are anagrams of any other string in the list. The result list is sorted in ascending order and does not contain duplicates. >>> find_anagrams([\\"listen\\", \\"silent\\", \\"enlist\\", \\"hello\\", \\"world\\"]) == [\\"enlist\\", \\"listen\\", \\"silent\\"] >>> find_anagrams([\\"bat\\", \\"tab\\", \\"cat\\"]) == [\\"bat\\", \\"tab\\"] >>> find_anagrams([\\"one\\", \\"two\\", \\"three\\"]) == []","solution":"def find_anagrams(words): Returns a list of strings that are anagrams of any other string in the list. The result list is sorted in ascending order and does not contain duplicates. from collections import defaultdict def sort_word(word): return ''.join(sorted(word)) anagram_groups = defaultdict(list) for word in words: sorted_word = sort_word(word) anagram_groups[sorted_word].append(word) anagram_list = [] for group in anagram_groups.values(): if len(group) > 1: anagram_list.extend(group) return sorted(set(anagram_list))"},{"question":"from typing import List def is_undirected_graph(matrix: List[List[int]]) -> str: Checks if the given matrix represents an undirected graph. >>> is_undirected_graph([ ... [0, 1, 0], ... [1, 0, 1], ... [0, 1, 0] ... ]) \\"Yes\\" >>> is_undirected_graph([ ... [0, 1, 1], ... [1, 0, 1], ... [0, 1, 0] ... ]) \\"No\\" pass def process_test_cases(t: int, test_cases: List[List[List[int]]]) -> List[str]: Processes multiple test cases to determine if each represents an undirected graph. >>> process_test_cases(2, [ ... [ ... [0, 1, 0], ... [1, 0, 1], ... [0, 1, 0] ... ], ... [ ... [0, 1, 1], ... [1, 0, 1], ... [0, 1, 0] ... ] ... ]) [\\"Yes\\", \\"No\\"] pass","solution":"def is_undirected_graph(matrix): Checks if the given matrix represents an undirected graph. n = len(matrix) for i in range(n): if matrix[i][i] != 0: return \\"No\\" for j in range(i + 1, n): if matrix[i][j] != matrix[j][i]: return \\"No\\" return \\"Yes\\" def process_test_cases(t, test_cases): results = [] for case in test_cases: results.append(is_undirected_graph(case)) return results"},{"question":"def intersection(arr1: List[int], arr2: List[int]) -> List[int]: Returns the intersection of two arrays as a sorted list of unique elements. >>> intersection([1, 2, 2, 1], [2, 2]) [2] >>> intersection([4, 9, 5], [9, 4, 9, 8, 4]) [4, 9]","solution":"def intersection(arr1, arr2): Returns the intersection of two arrays as a sorted list of unique elements. # Convert both lists to sets to get unique elements set1 = set(arr1) set2 = set(arr2) # Find the intersection of both sets intersected_set = set1 & set2 # Convert the set to a sorted list and return return sorted(list(intersected_set))"},{"question":"def rotate_right(lst: List[int], n: int) -> List[int]: Rotates the list to the right by n positions. Parameters: lst (list of int): The list to rotate. n (int): The number of positions to rotate the list. Returns: list of int: The rotated list. >>> rotate_right([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_right([0, 1, 2], 4) [2, 0, 1] >>> rotate_right([], 3) [] >>> rotate_right([1, 2, 3], 0) [1, 2, 3] >>> rotate_right([1, 2, 3], 5) [2, 3, 1] >>> rotate_right([1, 2, 3, 4], 6) [3, 4, 1, 2] >>> rotate_right([1], 3) [1] >>> rotate_right([1], 1) [1] # Your solution here","solution":"def rotate_right(lst, n): Rotates the list to the right by n positions. Parameters: lst (list of int): The list to rotate. n (int): The number of positions to rotate the list. Returns: list of int: The rotated list. if not lst: return lst n = n % len(lst) return lst[-n:] + lst[:-n]"},{"question":"def max_structures(n: int, heights: List[int]) -> int: Given an array of n integers, where each integer represents the height of a block, this function determines the maximum number of structures that can be formed, where each structure must have at least one block. A block can only be placed on top of another block if its height is less than or equal to the block below it. >>> max_structures(5, [5, 3, 2, 1, 4]) 5 >>> max_structures(7, [4, 3, 7, 2, 3, 1, 5]) 2","solution":"def max_structures(n, heights): Returns the maximum number of structures that can be formed with given blocks heights. from collections import Counter # Count the frequency of each height height_counts = Counter(heights) # Since a block can only be placed on top of another block if its height is less than or equal, # the maximum number of structures is determined by the most frequent height. max_structures = max(height_counts.values()) return max_structures"},{"question":"def run_length_encoding(s: str) -> str: Performs run-length encoding on the given string. Run-length encoding is a basic compression algorithm that converts consecutive identical elements into a single element and a count representing the number of occurrences of that element. The function returns the encoded string. :param s: The input string consisting of lowercase alphabetic characters. :return: The run-length encoded string. >>> run_length_encoding(\\"aabbbcdeee\\") 'a2b3c1d1e3' >>> run_length_encoding(\\"wwwaaadexxxxxx\\") 'w3a3d1e1x6' >>> run_length_encoding(\\"a\\") 'a1' >>> run_length_encoding(\\"\\") '' >>> run_length_encoding(\\"abcde\\") 'a1b1c1d1e1' >>> run_length_encoding(\\"aaaa\\") 'a4' >>> run_length_encoding(\\"aabcccccaaa\\") 'a2b1c5a3'","solution":"def run_length_encoding(s): Performs run-length encoding on the given string. :param s: The input string consisting of lowercase alphabetic characters. :return: The run-length encoded string. if not s: return \\"\\" encoded_str = [] current_char = s[0] count = 1 for char in s[1:]: if char == current_char: count += 1 else: encoded_str.append(f\\"{current_char}{count}\\") current_char = char count = 1 encoded_str.append(f\\"{current_char}{count}\\") return ''.join(encoded_str)"},{"question":"def arctic_explorer(t: int, cases: list) -> List[str]: Determine if there is a valid path from the top-left to the bottom-right of the grid, given the altitude constraints. >>> test_case_1() >>> test_case_2() >>> test_case_3() >>> test_case_4() >>> test_case_5() def test_case_1(): t = 2 cases = [ [(3, 3, 1), [[1, 2, 3], [2, 3, 4], [3, 4, 5]]], [(3, 3, 1), [[1, 3, 5], [2, 4, 6], [1, 5, 7]]] ] results = arctic_explorer(t, cases) assert results == [\\"YES\\", \\"NO\\"] def test_case_2(): t = 1 cases = [ [(4, 4, 2), [[1, 3, 2, 4], [2, 4, 3, 5], [4, 2, 0, 3], [6, 1, 2, 7]]] ] results = arctic_explorer(t, cases) assert results == [\\"NO\\"] def test_case_3(): t = 1 cases = [ [(2, 2, 1), [[1, 2], [2, 1]]] ] results = arctic_explorer(t, cases) assert results == [\\"YES\\"] def test_case_4(): t = 1 cases = [ [(1, 1, 0), [[0]]] ] results = arctic_explorer(t, cases) assert results == [\\"YES\\"] def test_case_5(): t = 1 cases = [ [(3, 3, 2), [[1, 4, 7], [3, 5, 8], [2, 6, 9]]] ] results = arctic_explorer(t, cases) assert results == [\\"NO\\"]","solution":"def can_reach_end(grid, n, m, d): from collections import deque # Direction vectors for right and down movements directions = [(0, 1), (1, 0)] # Initialize visited matrix visited = [[False for _ in range(m)] for _ in range(n)] # Initialize queue for BFS queue = deque([(0, 0)]) visited[0][0] = True while queue: x, y = queue.popleft() # If we reached the bottom-right cell if x == n - 1 and y == m - 1: return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny]: if abs(grid[x][y] - grid[nx][ny]) <= d: visited[nx][ny] = True queue.append((nx, ny)) return \\"NO\\" def arctic_explorer(t, cases): results = [] for case in cases: n, m, d = case[0] grid = case[1] results.append(can_reach_end(grid, n, m, d)) return results"},{"question":"def min_bit_flips(bits: List[int]) -> int: Returns the minimum number of bit flips required to make all bits in the list either all 0s or all 1s. >>> min_bit_flips([0, 1, 0, 1, 1, 0]) 3 >>> min_bit_flips([1, 1, 0, 0, 1]) 2 >>> min_bit_flips([0, 0, 0, 0]) 0 >>> min_bit_flips([1, 1, 1, 1, 1]) 0","solution":"from typing import List def min_bit_flips(bits: List[int]) -> int: Returns the minimum number of bit flips required to make all bits in the list either all 0s or all 1s. # Calculate number of 0s and number of 1s count_0 = bits.count(0) count_1 = len(bits) - count_0 # The minimum flips required will be the minimum of the counts return min(count_0, count_1)"},{"question":"def max_subarray_sum(arr: List[int]) -> int: Finds the maximum sum of any subarray using Kadane's Algorithm. >>> max_subarray_sum([1, 2, 3, -2, 5]) 9 >>> max_subarray_sum([-1, -2, -3, -4]) -1 def max_subarray_sums(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Processes multiple test cases and returns the results for each. >>> max_subarray_sums([(5, [1, 2, 3, -2, 5]), (4, [-1, -2, -3, -4])]) [9, -1] >>> max_subarray_sums([(3, [1, -1, 1])]) [1] >>> max_subarray_sums([(6, [1, 2, 3, 4, 5, -15])]) [15] >>> max_subarray_sums([(6, [-2, -3, 4, -1, -2, 1, 5, -3])]) [7]","solution":"def max_subarray_sum(arr): Finds the maximum sum of any subarray using Kadane's Algorithm. max_sum = current_sum = arr[0] for num in arr[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum def max_subarray_sums(test_cases): Processes multiple test cases and returns the results for each. results = [] for case in test_cases: n, arr = case results.append(max_subarray_sum(arr)) return results"},{"question":"def all_unique(arr: List[int]) -> bool: Create a function that takes an array of integers and returns \`True\` if all elements in the array are unique, and \`False\` otherwise. >>> all_unique([1, 2, 3, 4, 5]) True >>> all_unique([1, 2, 2, 3, 4]) False >>> all_unique([1]) True >>> all_unique([]) True >>> all_unique([-1, -2, -3, -4, -5]) True >>> all_unique([1, -1, 2, -2, -3, 3]) True >>> all_unique([1, -1, 2, 2, 3, 3]) False >>> all_unique([1000000, 2000000, 3000000]) True >>> all_unique([1000000, 2000000, 1000000]) False","solution":"def all_unique(arr): Returns True if all elements in the array are unique, False otherwise. return len(arr) == len(set(arr))"},{"question":"def rotate_array(arr, steps): Rotates the array to the left by the given number of steps. Parameters: arr (list): The array to be rotated. steps (int): The number of steps to rotate the array. Returns: list: The rotated array. Example: >>> rotate_array([1, 2, 3, 4, 5], 2) [3, 4, 5, 1, 2] >>> rotate_array([6, 7, 8, 9, 10], 4) [10, 6, 7, 8, 9] >>> rotate_array([1, 2, 3], 0) [1, 2, 3]","solution":"def rotate_array(arr, steps): Rotates the array to the left by the given number of steps. Parameters: arr (list): The array to be rotated. steps (int): The number of steps to rotate the array. Returns: list: The rotated array. n = len(arr) steps = steps % n # To handle cases where steps > len(arr) return arr[steps:] + arr[:steps]"},{"question":"def has_pair_with_sum(nums, target): Returns True if there exists a pair of elements in nums whose sum is equal to target, otherwise False. >>> has_pair_with_sum([2, 7, 11, 15], 9) True >>> has_pair_with_sum([1, 2, 3, 4, 5], 10) False >>> has_pair_with_sum([], 5) False >>> has_pair_with_sum([10], 20) False >>> has_pair_with_sum([1, 2, 3, 4, 4, 5], 8) True >>> has_pair_with_sum([-1, -2, -3, -4, -5], -8) True >>> has_pair_with_sum([-1, 2, -3, 4, -5, 6], 1) True >>> has_pair_with_sum([1000000, 2000000, -1000000], 0) True >>> has_pair_with_sum([2, -2, 3, -3], 0) True","solution":"def has_pair_with_sum(nums, target): Returns True if there exists a pair of elements in nums whose sum is equal to target, otherwise False. complements = set() for num in nums: if target - num in complements: return True complements.add(num) return False"},{"question":"def traffic_light_color(minute: int) -> str: Returns the color of the traffic light based on the given minute. Green: 0-4 minutes Yellow: 5-6 minutes Red: 7-9 minutes The cycle repeats every 10 minutes. >>> traffic_light_color(0) == \\"Green\\" >>> traffic_light_color(10) == \\"Green\\" >>> traffic_light_color(6) == \\"Yellow\\" >>> traffic_light_color(15) == \\"Yellow\\" >>> traffic_light_color(7) == \\"Red\\"","solution":"def traffic_light_color(minute): Returns the color of the traffic light based on the given minute. Green: 0-4 minutes Yellow: 5-6 minutes Red: 7-9 minutes The cycle repeats every 10 minutes. total_cycle_duration = 10 # Find the minute within the current cycle effective_minute = minute % total_cycle_duration if 0 <= effective_minute <= 4: return \\"Green\\" elif 5 <= effective_minute <= 6: return \\"Yellow\\" elif 7 <= effective_minute <= 9: return \\"Red\\""},{"question":"def mirror_string(s: str) -> str: Mirror each character in the input string where 'a' is replaced by 'z', 'b' by 'y', etc. Non-letter characters remain unchanged. >>> mirror_string(\\"abcd\\") == \\"zyxw\\" >>> mirror_string(\\"hello\\") == \\"svool\\" >>> mirror_string(\\"world\\") == \\"dliow\\" >>> mirror_string(\\"hello world\\") == \\"svool dliow\\" >>> mirror_string(\\"hello world!\\") == \\"svool dliow!\\" >>> mirror_string(\\"a.b,c-d\\") == \\"z.y,x-w\\" >>> mirror_string(\\"!@#%^&*()\\") == \\"!@#%^&*()\\" >>> mirror_string(\\"a b c\\") == \\"z y x\\" >>> mirror_string(\\"xyz abc\\") == \\"cba zyx\\"","solution":"def mirror_string(s): Mirror each character in the input string where 'a' is replaced by 'z', 'b' by 'y', etc. Non-letter characters remain unchanged. mirrored_string = \\"\\" for char in s: if char.isalpha() and char.islower(): mirrored_char = chr(ord('a') + (ord('z') - ord(char))) mirrored_string += mirrored_char else: mirrored_string += char return mirrored_string"},{"question":"def intersection(list1, list2): Returns a list of unique elements that are common to both list1 and list2. >>> intersection([1, 2, 2, 1], [2, 2]) [2] >>> intersection([4, 9, 5], [9, 4, 9, 8, 4]) [4, 9] pass","solution":"def intersection(list1, list2): Returns a list of unique elements that are common to both list1 and list2. # Convert both lists to sets to remove duplicates and find intersection set1 = set(list1) set2 = set(list2) # Find intersection of both sets intersected_set = set1.intersection(set2) # Convert the intersected set back to a list and return return list(intersected_set)"},{"question":"def roman_to_int(s: str) -> int: Convert a Roman numeral to an integer. Roman numerals are represented by seven different symbols: I, V, X, L, C, D, and M. Each of these symbols represents a specific integer value. For example, I = 1, V = 5, X = 10, L = 50, C = 100, D = 500, M = 1000. The Roman numeral system typically writes numerals from largest to smallest from left to right. However, there are exceptions, such as IV (4) and IX (9), where a smaller numeral appears before a larger one and is meant to be subtracted. This function takes a string representing a valid Roman numeral and returns its corresponding integer value. Examples: >>> roman_to_int(\\"III\\") 3 >>> roman_to_int(\\"IV\\") 4 >>> roman_to_int(\\"IX\\") 9 >>> roman_to_int(\\"LVIII\\") 58 >>> roman_to_int(\\"MCMXCIV\\") 1994","solution":"def roman_to_int(s): Convert a Roman numeral to an integer. roman_numerals = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 } total = 0 prev_value = 0 for char in reversed(s): value = roman_numerals[char] if value >= prev_value: total += value else: total -= value prev_value = value return total"},{"question":"from typing import List def can_reach_target_sum(nums: List[int], target: int) -> bool: Determines if a subset of the given list of integers sums up to the target sum. >>> can_reach_target_sum([1, 2, 3, 7], 6) True >>> can_reach_target_sum([3, 34, 4, 12, 5, 2], 9) True >>> can_reach_target_sum([1, -1, 2, 3, 5], 4) True >>> can_reach_target_sum([2, 4, 6], 5) False pass def test_example1(): nums = [1, 2, 3, 7] target = 6 assert can_reach_target_sum(nums, target) == True def test_example2(): nums = [3, 34, 4, 12, 5, 2] target = 9 assert can_reach_target_sum(nums, target) == True def test_example3(): nums = [1, -1, 2, 3, 5] target = 4 assert can_reach_target_sum(nums, target) == True def test_example4(): nums = [2, 4, 6] target = 5 assert can_reach_target_sum(nums, target) == False def test_single_element_equal_to_target(): nums = [5] target = 5 assert can_reach_target_sum(nums, target) == True def test_single_element_not_equal_to_target(): nums = [1] target = 5 assert can_reach_target_sum(nums, target) == False def test_empty_list(): nums = [] target = 0 assert can_reach_target_sum(nums, target) == True def test_all_zeros(): nums = [0, 0, 0, 0] target = 0 assert can_reach_target_sum(nums, target) == True def test_large_positive_values(): nums = [1000, 2000, 3000, 4000, 5000] target = 15000 assert can_reach_target_sum(nums, target) == True def test_large_negative_values(): nums = [-1000, -2000, -3000, -4000, -5000] target = -10000 assert can_reach_target_sum(nums, target) == True def test_mixed_positive_and_negative_values(): nums = [-1, 2, 3, -4, 5] target = 0 assert can_reach_target_sum(nums, target) == True def test_no_possible_subset(): nums = [1, 2, 3, 8] target = 7 assert can_reach_target_sum(nums, target) == False def test_subset_sums_to_zero(): nums = [-1, -2, -3, 6] target = 0 assert can_reach_target_sum(nums, target) == True","solution":"def can_reach_target_sum(nums, target): Determines if a subset of the given list of integers sums up to the target. Uses dynamic programming to solve the subset sum problem. n = len(nums) # We use a set to keep track of the possible sums we can get with the subsets. possible_sums = set() possible_sums.add(0) for num in nums: # We need to iterate over a copy of the current possible sums to avoid modifying it during iteration. current_sums = list(possible_sums) for s in current_sums: new_sum = s + num if new_sum == target: return True possible_sums.add(new_sum) return target in possible_sums"},{"question":"def alien_to_our_language(number: str) -> int: Converts a number from the alien language to our language. Each digit in the alien language is shifted by one compared to ours: 1 means 0, 2 means 1, 3 means 2, ..., 9 means 8, 0 means 9. Parameters: number (str): The number in the alien language as a string. Returns: int: The number translated into our language. >>> alien_to_our_language(\\"123\\") == 12 >>> alien_to_our_language(\\"890\\") == 789 >>> alien_to_our_language(\\"456\\") == 345 pass def test_alien_to_our_language(): assert alien_to_our_language(\\"123\\") == 12 assert alien_to_our_language(\\"890\\") == 789 assert alien_to_our_language(\\"456\\") == 345 assert alien_to_our_language(\\"017\\") == 906 assert alien_to_our_language(\\"000\\") == 999 assert alien_to_our_language(\\"999\\") == 888 assert alien_to_our_language(\\"593\\") == 482 assert alien_to_our_language(\\"1\\") == 0 assert alien_to_our_language(\\"0\\") == 9 def test_edge_cases(): assert alien_to_our_language(\\"2\\") == 1 assert alien_to_our_language(\\"8\\") == 7 assert alien_to_our_language(\\"9\\") == 8","solution":"def alien_to_our_language(number: str) -> int: Converts a number from the alien language to our language. Each digit in the alien language is shifted by one compared to ours: 1 means 0, 2 means 1, 3 means 2, ..., 9 means 8, 0 means 9. Parameters: number (str): The number in the alien language as a string. Returns: int: The number translated into our language. translated_number = ''.join(str((int(digit) - 1) % 10) for digit in number) return int(translated_number)"},{"question":"def find_pair_with_sum(arr: List[int], target: int) -> bool: Determines if there exists a pair of distinct elements in the array that add up to the target sum. >>> find_pair_with_sum([2, 4, 6, 8], 10) True >>> find_pair_with_sum([1, 2, 3, 4], 8) False >>> find_pair_with_sum([0, -1, 2, -3, 1], -2) True","solution":"def find_pair_with_sum(arr, target): Determines if there exists a pair of distinct elements in the array that add up to the target sum. :param arr: List of integers :param target: Integer target sum :return: Boolean indicating if such a pair exists seen = set() for number in arr: if target - number in seen: return True seen.add(number) return False"},{"question":"def common_elements(list1: List[int], list2: List[int]) -> List[int]: This function takes two lists of integers and returns a list of the elements that are present in both lists, without duplicates. The order of elements in the output follows their first appearance in the combined lists. >>> common_elements([1, 3, 4, 6, 7, 8], [2, 4, 6, 7, 8, 8, 8]) [4, 6, 7, 8] >>> common_elements([10, 11, 12], [13, 14, 15]) [] # Implement the function here","solution":"def common_elements(list1, list2): This function takes two lists of integers and returns a list of the elements that are present in both lists, without duplicates. The order of elements in the output follows their first appearance in the combined lists. set_list1 = set(list1) set_list2 = set(list2) common_set = set_list1 & set_list2 result = [] for item in list1 + list2: if item in common_set and item not in result: result.append(item) return result"},{"question":"def minimize_largest_sum(n: int, k: int, arr: List[int]) -> int: Function to minimize the largest sum among k subarrays. Arguments: n - The number of elements in the array. k - The number of subarrays. arr - List of integers representing the array. Returns: The minimized largest sum among the k subarrays. >>> minimize_largest_sum(8, 3, [10, 20, 30, 40, 50, 60, 70, 80]) 150 >>> minimize_largest_sum(1, 1, [5]) 5 >>> minimize_largest_sum(5, 2, [10, 10, 10, 10, 10]) 30 >>> minimize_largest_sum(5, 5, [10, 20, 30, 40, 50]) 50 >>> minimize_largest_sum(5, 2, [100, 80, 60, 40, 20]) 180 >>> minimize_largest_sum(5, 3, [10, 20, 30, 40, 50]) 60","solution":"def minimize_largest_sum(n, k, arr): Function to minimize the largest sum among k subarrays. Arguments: n - The number of elements in the array. k - The number of subarrays. arr - List of integers representing the array. Returns: The minimized largest sum among the k subarrays. def is_valid(mid): count_subarrays = 1 current_sum = 0 for num in arr: if current_sum + num > mid: count_subarrays += 1 current_sum = num if count_subarrays > k: return False else: current_sum += num return True low = max(arr) high = sum(arr) while low < high: mid = (low + high) // 2 if is_valid(mid): high = mid else: low = mid + 1 return low"},{"question":"from typing import List def is_prime(n: int) -> bool: Checks if a given number is a prime number. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(17) True >>> is_prime(18) False def filter_primes(numbers: List[int]) -> List[int]: Returns a list of prime numbers from the given list of integers. >>> filter_primes([2, 3, 4, 5, 6, 7, 8, 9, 10]) [2, 3, 5, 7] >>> filter_primes([11, 13, 17, 19, 23, 29, 31]) [11, 13, 17, 19, 23, 29, 31] >>> filter_primes([0, 1, 4, 6, 8, 10, 12]) [] >>> filter_primes([2, 3, 5, 7, 11, 13, 17, 19]) [2, 3, 5, 7, 11, 13, 17, 19] >>> filter_primes([]) []","solution":"def is_prime(n): Checks if a number is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def filter_primes(numbers): Returns a list of prime numbers from the given list of integers. return [num for num in numbers if is_prime(num)]"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def findMax(root): Find the maximum value in a binary tree. If the tree is empty, raise a ValueError with the message \\"Tree is empty\\". pass import pytest def test_findMax_with_positive_values(): root = TreeNode(3, TreeNode(2, TreeNode(1), TreeNode(4)), TreeNode(5)) assert findMax(root) == 5 def test_findMax_with_negative_values(): root = TreeNode(-3, TreeNode(-2, TreeNode(-1), TreeNode(-4)), TreeNode(-5)) assert findMax(root) == -1 def test_findMax_with_mixed_values(): root = TreeNode(3, TreeNode(-2, TreeNode(-1), TreeNode(4)), TreeNode(5)) assert findMax(root) == 5 def test_findMax_with_single_node(): root = TreeNode(42) assert findMax(root) == 42 def test_findMax_with_empty_tree(): with pytest.raises(ValueError, match=\\"Tree is empty\\"): findMax(None)","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def findMax(root): Find the maximum value in a binary tree. if root is None: raise ValueError(\\"Tree is empty\\") max_value = root.value if root.left: max_value = max(max_value, findMax(root.left)) if root.right: max_value = max(max_value, findMax(root.right)) return max_value"},{"question":"def filter_dict(d: dict, keys: list) -> dict: Create a function that takes two arguments: a dictionary \`d\` and a list \`keys\`. The function should return a new dictionary containing only the key-value pairs from \`d\` whose keys are present in the \`keys\` list. Keys in \`keys\` which are not in the dictionary should be ignored. >>> filter_dict({\\"a\\": 1, \\"b\\": 2, \\"c\\": 3}, [\\"a\\", \\"c\\"]) == {\\"a\\": 1, \\"c\\": 3} >>> filter_dict({\\"x\\": 5, \\"y\\": 6}, [\\"y\\", \\"z\\"]) == {\\"y\\": 6} >>> filter_dict({\\"k1\\": 10, \\"k2\\": 20, \\"k3\\": 30}, [\\"k4\\", \\"k5\\"]) == {} >>> filter_dict({}, [\\"a\\", \\"b\\"]) == {}","solution":"def filter_dict(d, keys): Returns a new dictionary containing only the key-value pairs from d whose keys are present in the keys list. Keys in keys which are not in the dictionary should be ignored. Parameters: d (dict): The original dictionary. keys (list): The list of keys to filter by. Returns: dict: A new dictionary containing only the filtered key-value pairs. return {k: d[k] for k in keys if k in d}"},{"question":"class LRUCache: Implement a Least Recently Used (LRU) Cache with get and put operations. The cache should operate in O(1) time for both operations. Example: >>> cache = LRUCache(2) >>> cache.put(1, 1) >>> cache.put(2, 2) >>> cache.get(1) 1 >>> cache.put(3, 3) >>> cache.get(2) -1 >>> cache.put(4, 4) >>> cache.get(1) -1 >>> cache.get(3) 3 >>> cache.get(4) 4 def __init__(self, capacity: int): pass def get(self, key: int) -> int: pass def put(self, key: int, value: int) -> None: pass from solution import LRUCache def test_lru_cache_basic_operations(): cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) assert cache.get(1) == 1 # returns 1 cache.put(3, 3) # evicts key 2 assert cache.get(2) == -1 # returns -1 (not found) cache.put(4, 4) # evicts key 1 assert cache.get(1) == -1 # returns -1 (not found) assert cache.get(3) == 3 # returns 3 assert cache.get(4) == 4 # returns 4 def test_lru_cache_with_single_capacity(): cache = LRUCache(1) cache.put(1, 1) assert cache.get(1) == 1 # returns 1 cache.put(2, 2) # evicts key 1 assert cache.get(1) == -1 # returns -1 (not found) assert cache.get(2) == 2 # returns 2 def test_lru_cache_overwriting_value(): cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) cache.put(1, 10) assert cache.get(1) == 10 # returns 10 as the value for key 1 is overwritten assert cache.get(2) == 2 # returns 2 def test_lru_cache_capacity_limit(): cache = LRUCache(3) cache.put(1, 1) cache.put(2, 2) cache.put(3, 3) assert cache.get(1) == 1 # returns 1 cache.put(4, 4) # evicts key 2 (least recently used key) assert cache.get(2) == -1 # returns -1 (not found) assert cache.get(3) == 3 # returns 3 assert cache.get(4) == 4 # returns 4","solution":"class LRUCache: def __init__(self, capacity: int): self.cache = {} self.capacity = capacity self.order = [] def get(self, key: int) -> int: if key in self.cache: self.order.remove(key) self.order.append(key) return self.cache[key] return -1 def put(self, key: int, value: int) -> None: if key in self.cache: self.order.remove(key) elif len(self.cache) >= self.capacity: lru = self.order.pop(0) del self.cache[lru] self.cache[key] = value self.order.append(key)"},{"question":"def can_attend_all_events(events: List[List[int]]) -> bool: Determine whether a person could attend all events without any overlaps. >>> can_attend_all_events([[5, 10], [15, 20], [10, 15]]) == True >>> can_attend_all_events([[5, 10], [6, 12], [15, 20]]) == False >>> can_attend_all_events([[1, 5], [5, 10], [10, 15]]) == True >>> can_attend_all_events([[1, 2]]) == True >>> can_attend_all_events([[1, 3], [3, 5], [5, 7], [2, 4]]) == False","solution":"def can_attend_all_events(events): Determine whether a person could attend all events without any overlaps. Args: events: List of intervals where each interval is represented as [start, end] Returns: bool: True if a person can attend all events, False otherwise. # Sort the events based on their start times events.sort(key=lambda x: x[0]) # Compare the end time of each event with the start time of the next one for i in range(1, len(events)): if events[i][0] < events[i-1][1]: return False return True"},{"question":"def decrypt_sentence(sentence: str) -> str: Decrypts a sentence where each word is encrypted by reversing the order of its characters. Args: sentence (str): The encrypted sentence. Returns: str: The decrypted sentence with the words in their original order. >>> decrypt_sentence(\\"sihT si na elpmaxe\\") \\"This is an example\\" >>> decrypt_sentence(\\"esreveR gnirts\\") \\"Reverse string\\" >>> decrypt_sentence(\\"I evol gnimmargorp\\") \\"I love programming\\" >>> decrypt_sentence(\\"htgnel fo enil\\") \\"length of line\\" >>> decrypt_sentence(\\"gnidoc si nuf\\") \\"coding is fun\\"","solution":"def decrypt_sentence(sentence: str) -> str: Decrypts a sentence where each word is encrypted by reversing the order of its characters. Args: sentence (str): The encrypted sentence. Returns: str: The decrypted sentence with the words in their original order. decrypted_words = [word[::-1] for word in sentence.split()] return ' '.join(decrypted_words)"},{"question":"def longest_unique_substring(s: str) -> str: Find the longest substring without repeating characters. >>> longest_unique_substring(\\"abcabcbb\\") \\"abc\\" >>> longest_unique_substring(\\"bbbbb\\") \\"b\\" >>> longest_unique_substring(\\"pwwkew\\") \\"wke\\"","solution":"def longest_unique_substring(s): start = 0 max_length = 0 max_substr = \\"\\" used_chars = {} for i, char in enumerate(s): if char in used_chars and start <= used_chars[char]: start = used_chars[char] + 1 else: if i - start + 1 > max_length: max_length = i - start + 1 max_substr = s[start:i+1] used_chars[char] = i return max_substr"},{"question":"def min_path_sum(matrix): Returns the minimum path sum in a matrix from the top-left to the bottom-right corner only moving right or down.","solution":"def min_path_sum(matrix): Returns the minimum path sum in a matrix from the top-left to the bottom-right corner only moving right or down. n = len(matrix) # Create a DP table for memoization dp = [[0]*n for _ in range(n)] dp[0][0] = matrix[0][0] # Initialize the first row for i in range(1, n): dp[0][i] = dp[0][i-1] + matrix[0][i] # Initialize the first column for i in range(1, n): dp[i][0] = dp[i-1][0] + matrix[i][0] # Fill the rest of the DP table for i in range(1, n): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + matrix[i][j] return dp[-1][-1]"},{"question":"def maxAltitudeDiff(grid): Returns the maximum possible difference in altitude between any two adjacent cells in the grid. >>> grid = [ ... [1, 2, 1], ... [3, 8, 4], ... [2, 9, 6] ... ] >>> maxAltitudeDiff(grid) 7 >>> grid = [ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ] >>> maxAltitudeDiff(grid) 0 >>> grid = [ ... [0, 0, 0], ... [0, 1000, 0], ... [0, 0, 0] ... ] >>> maxAltitudeDiff(grid) 1000 >>> grid = [ ... [1, 1000], ... [1000, 1] ... ] >>> maxAltitudeDiff(grid) 999 >>> grid = [ ... [1, 5], ... [6, 2] ... ] >>> maxAltitudeDiff(grid) 5","solution":"def maxAltitudeDiff(grid): Returns the maximum possible difference in altitude between any two adjacent cells in the grid. def get_neighbors(i, j): neighbors = [] if i > 0: neighbors.append((i-1, j)) # up if i < len(grid) - 1: neighbors.append((i+1, j)) # down if j > 0: neighbors.append((i, j-1)) # left if j < len(grid[0]) - 1: neighbors.append((i, j+1)) # right return neighbors max_diff = 0 for i in range(len(grid)): for j in range(len(grid[0])): current = grid[i][j] for ni, nj in get_neighbors(i, j): neighbor = grid[ni][nj] diff = abs(current - neighbor) if diff > max_diff: max_diff = diff return max_diff"},{"question":"def all_unique_characters(s: str) -> bool: Checks if all characters in the string s are unique. Args: s (str): the input string. Returns: bool: True if all characters are unique, False otherwise. >>> all_unique_characters(\\"abc\\") True >>> all_unique_characters(\\"12345\\") True >>> all_unique_characters(\\"aabc\\") False >>> all_unique_characters(\\"\\") True >>> all_unique_characters(\\"AaBbCc\\") True >>> all_unique_characters(\\"AaBbCcAa\\") False","solution":"def all_unique_characters(s): Checks if all characters in the string s are unique. Args: s (str): the input string. Returns: bool: True if all characters are unique, False otherwise. n = len(s) for i in range(n): for j in range(i + 1, n): if s[i] == s[j]: return False return True"},{"question":"from typing import List, Tuple def largest_subset_with_max_diff_k(arr: List[int], k: int) -> int: Given an array of integers and an integer k, determine if there exists a subset of the array such that the difference between the maximum and minimum elements in the subset is less than or equal to k. If such a subset exists, return the size of the largest possible subset. If no such subset exists, return -1. >>> largest_subset_with_max_diff_k([1, 5, 9, 12, 14], 3) 2 >>> largest_subset_with_max_diff_k([3, 6, 8, 10], 2) 2 >>> largest_subset_with_max_diff_k([1, 1, 1, 1], 0) 4 >>> largest_subset_with_max_diff_k([10, 20, 30, 40], 5) 1 >>> largest_subset_with_max_diff_k([5, 5, 7, 7], 2) 4 pass def process_test_cases(T: int, test_cases: List[Tuple[List[int], List[int]]]) -> List[int]: Process multiple test cases and output the size of the largest possible subset for each case. >>> process_test_cases(2, [([5, 3], [1, 5, 9, 12, 14]), ([4, 2], [3, 6, 8, 10])]) [2, 2] >>> process_test_cases(2, [([4, 0], [1, 1, 1, 1]), ([4, 5], [10, 20, 30, 40])]) [4, 1] pass if __name__ == \\"__main__\\": test_cases = [ ([5, 3], [1, 5, 9, 12, 14]), ([4, 2], [3, 6, 8, 10]) ] print(process_test_cases(2, test_cases))","solution":"def largest_subset_with_max_diff_k(arr, k): arr.sort() n = len(arr) max_size = 0 j = 0 for i in range(n): while j < n and arr[j] - arr[i] <= k: j += 1 max_size = max(max_size, j - i) return max_size if max_size > 0 else -1 def process_test_cases(T, test_cases): results = [] for i in range(T): n, k = test_cases[i][0] arr = test_cases[i][1] result = largest_subset_with_max_diff_k(arr, k) results.append(result) return results"},{"question":"def countPaths(n: int, m: int, k: int, traps: List[Tuple[int, int]]) -> int: Calculate the number of distinct paths from the top-left corner to the bottom-right corner without passing through any traps. >>> countPaths(3, 3, 0, []) 6 >>> countPaths(3, 3, 1, [(2, 2)]) 2 >>> countPaths(2, 2, 1, [(1, 2)]) 1 >>> countPaths(3, 3, 3, [(1, 3), (2, 2), (3, 1)]) 0","solution":"def countPaths(n, m, k, traps): MOD = 1000000007 trap_set = {(r, c) for r, c in traps} if (n, m) in trap_set or (1, 1) in trap_set: return 0 dp = [[0] * (m + 1) for _ in range(n + 1)] dp[1][1] = 1 for i in range(1, n + 1): for j in range(1, m + 1): if (i, j) in trap_set: dp[i][j] = 0 else: if i > 1: dp[i][j] = (dp[i][j] + dp[i - 1][j]) % MOD if j > 1: dp[i][j] = (dp[i][j] + dp[i][j - 1]) % MOD return dp[n][m]"},{"question":"def is_prime(n: int) -> bool: Helper function to check if a number n is prime. >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(5) True >>> is_prime(1) False >>> is_prime(2) True >>> is_prime(29) True >>> is_prime(0) False >>> is_prime(-3) False def filter_primes(lst: List[int]) -> List[int]: Filters the prime numbers from the given list lst. >>> filter_primes([10, 15, 3, 7, 9]) [3, 7] >>> filter_primes([4, 6, 8, 10, 12]) [] >>> filter_primes([2, 5, 11, 13, 17]) [2, 5, 11, 13, 17] >>> filter_primes([1, 1, 1, 1]) [] >>> filter_primes([]) [] >>> filter_primes([19, 23, 29, 31]) [19, 23, 29, 31] >>> filter_primes([20, 25, 30, 35]) []","solution":"def is_prime(n): Helper function to check if a number n is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def filter_primes(lst): Filters the prime numbers from the given list lst. return [num for num in lst if is_prime(num)]"},{"question":"def kelvin_to_celsius(kelvin: float) -> float: Converts a temperature from degrees Kelvin to degrees Celsius. Formula: Celsius = Kelvin - 273.15 Parameters: kelvin (float): Temperature in degrees Kelvin. Returns: float: Temperature in degrees Celsius. >>> kelvin_to_celsius(0) == -273.15 True >>> abs(kelvin_to_celsius(373.15) - 100) < 0.001 True >>> abs(kelvin_to_celsius(273.15) - 0) < 0.001 True >>> abs(kelvin_to_celsius(300) - 26.85) < 0.01 True","solution":"def kelvin_to_celsius(kelvin): Converts a temperature from degrees Kelvin to degrees Celsius. Formula: Celsius = Kelvin - 273.15 Parameters: kelvin (float): Temperature in degrees Kelvin. Returns: float: Temperature in degrees Celsius. return kelvin - 273.15"},{"question":"def caesar_cipher(text: str, shift: int) -> str: Encode the given text using a Caesar Cipher with the specified shift. Args: text (str): The plaintext that needs to be encoded. shift (int): The number of positions to shift each alphabetic character. Returns: str: The encoded text. >>> caesar_cipher(\\"Hello, World!\\", 3) 'Khoor, Zruog!' >>> caesar_cipher(\\"Python\\", 5) 'Udymts' >>> caesar_cipher(\\"abcXYZ\\", 2) 'cdeZAB'","solution":"def caesar_cipher(text: str, shift: int) -> str: def shift_char(c, shift_amount): if c.isalpha(): base = ord('A') if c.isupper() else ord('a') return chr((ord(c) - base + shift_amount) % 26 + base) return c return ''.join(shift_char(c, shift) for c in text)"},{"question":"class GameObject: def __init__(self, name: str, position: tuple, size: int, properties: dict): self.name = name self.position = position # A tuple (x, y) self.size = size # Integer representing size self.properties = properties # Dictionary of properties class Environment: def __init__(self): self.objects = [] def add_object(self, obj: GameObject): self.objects.append(obj) def filter_objects(self, predicate): return [obj for obj in self.objects if predicate(obj)] def update_object(self, name: str, updates: dict): for obj in self.objects: if obj.name == name: for key, value in updates.items(): if hasattr(obj, key): setattr(obj, key, value) break def find_nearest_object(self, position): Find the nearest object in the environment to the given position. :param position: A tuple (x, y) representing the position to check against :return: The GameObject nearest to the given position pass def filter_by_property(self, property_name, value): Filter and return objects that match the given property name and value. :param property_name: The name of the property to filter by :param value: The value that the property should have :return: A list of GameObjects that have the given property name and value pass # Example and test cases env = Environment() obj1 = GameObject(\\"tree\\", (1, 2), 10, {\\"type\\": \\"plant\\", \\"is_collidable\\": True}) obj2 = GameObject(\\"rock\\", (3, 4), 5, {\\"type\\": \\"mineral\\", \\"is_collidable\\": True}) obj3 = GameObject(\\"water\\", (0, 1), 20, {\\"type\\": \\"liquid\\", \\"is_collidable\\": False}) env.add_object(obj1) env.add_object(obj2) env.add_object(obj3) # Find nearest object to position (2, 3) nearest = env.find_nearest_object((2, 3)) print(nearest.name) # Outputs: either \\"tree\\" or \\"rock\\" # Filter objects by property collidables = env.filter_by_property(\\"is_collidable\\", True) print([obj.name for obj in collidables]) # Outputs: [\\"tree\\", \\"rock\\"]","solution":"class GameObject: def __init__(self, name: str, position: tuple, size: int, properties: dict): self.name = name self.position = position # A tuple (x, y) self.size = size # Integer representing size self.properties = properties # Dictionary of properties class Environment: def __init__(self): self.objects = [] def add_object(self, obj: GameObject): self.objects.append(obj) def filter_objects(self, predicate): return [obj for obj in self.objects if predicate(obj)] def update_object(self, name: str, updates: dict): for obj in self.objects: if obj.name == name: for key, value in updates.items(): if hasattr(obj, key): setattr(obj, key, value) break def find_nearest_object(self, position): def distance(pos1, pos2): return ((pos1[0] - pos2[0]) ** 2 + (pos1[1] - pos2[1]) ** 2) ** 0.5 nearest_obj = min(self.objects, key=lambda obj: distance(position, obj.position)) return nearest_obj def filter_by_property(self, property_name, value): return [obj for obj in self.objects if obj.properties.get(property_name) == value]"},{"question":"def count_paths(grid: List[List[str]], N: int) -> int: Calculate the number of different paths from the top-left corner to the bottom-right corner of the grid. >>> count_paths([['.', '#', '#'], ['.', '#', '.'], ['.', '.', '.']], 3) 1 >>> count_paths([['#', '#', '#'], ['#', '#', '#'], ['#', '#', '#']], 3) 0 def solve_multiple_cases(test_cases: List[Dict[str, Any]]) -> List[int]: Solve multiple test cases for the treasure hunt problem. >>> solve_multiple_cases([{'N': 3, 'grid': [['.', '#', '#'], ['.', '#', '.'], ['.', '.', '.']]}]) [1] >>> solve_multiple_cases([{'N': 3, 'grid': [['#', '#', '#'], ['#', '#', '#'], ['#', '#', '#']]}]) [0] def parse_input(input_text: str) -> List[Dict[str, Any]]: Parse input text into a list of test case dictionaries. >>> parse_input(\\"1n3n.n.#.n...n\\") [{'N': 3, 'grid': [['.', '#', '#'], ['.', '#', '.'], ['.', '.', '.']]}] import pytest def test_single_case(): input_text = \\"1n3n.n.#.n...n\\" expected_output = [1] test_cases = parse_input(input_text) assert solve_multiple_cases(test_cases) == expected_output def test_no_paths(): input_text = \\"1n3n#n#n#n\\" expected_output = [0] test_cases = parse_input(input_text) assert solve_multiple_cases(test_cases) == expected_output def test_blocked_end(): input_text = \\"1n3n...n...n..#n\\" expected_output = [0] test_cases = parse_input(input_text) assert solve_multiple_cases(test_cases) == expected_output def test_large_grid(): input_text = \\"1n4n....n....n....n....n\\" expected_output = [20] test_cases = parse_input(input_text) assert solve_multiple_cases(test_cases) == expected_output def test_multiple_cases(): input_text = \\"2n3n.n.#.n...n3n#n.#.n...n\\" expected_output = [1, 0] test_cases = parse_input(input_text) assert solve_multiple_cases(test_cases) == expected_output","solution":"def count_paths(grid, N): # Check if start or end are blocked if grid[0][0] == '#' or grid[N-1][N-1] == '#': return 0 # Create a dp table initialized to 0 dp = [[0] * N for _ in range(N)] # Starting position dp[0][0] = 1 # Fill the dp table for i in range(N): for j in range(N): if grid[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[N-1][N-1] def solve_multiple_cases(test_cases): results = [] for case in test_cases: N = case[\\"N\\"] grid = case[\\"grid\\"] results.append(count_paths(grid, N)) return results def parse_input(input_text): data = input_text.strip().split(\\"n\\") T = int(data[0]) index = 1 test_cases = [] for _ in range(T): N = int(data[index]) grid = [list(data[index + i + 1]) for i in range(N)] test_cases.append({\\"N\\": N, \\"grid\\": grid}) index += N + 1 return test_cases"},{"question":"def total_minimum_skill_difference(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determines the total minimum skill difference possible when the players are paired optimally. Args: t (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): Each tuple consists of an integer n and a list of integers representing skill levels of the players. Returns: List[int]: Returns a list of integers where each integer is the total minimum skill difference for each test case. >>> total_minimum_skill_difference(3, [(4, [1, 5, 3, 19]), (5, [10, 10, 10, 10, 10]), (3, [8, 5, 6])]) [16, 0, 1] >>> total_minimum_skill_difference(1, [(4, [7, 7, 7, 7])]) [0] # Your code here","solution":"def total_minimum_skill_difference(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] skill_levels = sorted(test_cases[i][1]) total_difference = 0 for j in range(0, n - 1, 2): total_difference += abs(skill_levels[j] - skill_levels[j + 1]) results.append(total_difference) return results # Example usage: # t = 3 # test_cases = [ # (4, [1, 5, 3, 19]), # (5, [10, 10, 10, 10, 10]), # (3, [8, 5, 6]) # ] # print(total_minimum_skill_difference(t, test_cases)) # Output: [16, 0, 1]"},{"question":"def filter_log_entries(log_entries, start_time, end_time): Filters log entries between the given start and end timestamps. Parameters: log_entries (list of str): List of log entries, each a string in the format \\"YYYY-MM-DD HH:MM:SS message\\". start_time (str): The start of the time range, inclusive, in the format \\"YYYY-MM-DD HH:MM:SS\\". end_time (str): The end of the time range, inclusive, in the format \\"YYYY-MM-DD HH:MM:SS\\". Returns: list of str: List of filtered log messages. >>> filter_log_entries([\\"2023-01-01 00:00:01 System start\\", \\"2023-01-01 00:00:02 User login\\", \\"2023-01-01 00:00:03 Error occurred\\"], \\"2023-01-01 00:00:02\\", \\"2023-01-01 00:00:03\\") [\\"User login\\", \\"Error occurred\\"] >>> filter_log_entries([\\"2023-01-01 00:00:01 System start\\", \\"2023-01-01 00:00:02 User login\\"], \\"2023-01-01 00:00:03\\", \\"2023-01-01 00:00:04\\") [] pass","solution":"def filter_log_entries(log_entries, start_time, end_time): Filters log entries between the given start and end timestamps. Parameters: log_entries (list of str): List of log entries, each a string in the format \\"YYYY-MM-DD HH:MM:SS message\\". start_time (str): The start of the time range, inclusive, in the format \\"YYYY-MM-DD HH:MM:SS\\". end_time (str): The end of the time range, inclusive, in the format \\"YYYY-MM-DD HH:MM:SS\\". Returns: list of str: List of filtered log messages. filtered_log_messages = [] for entry in log_entries: timestamp, message = entry[:19], entry[20:] if start_time <= timestamp <= end_time: filtered_log_messages.append(message) return filtered_log_messages"},{"question":"def reverse_and_join(sentence: str) -> str: Reverses the order of words in the input sentence and joins them with a dash ('-') as the separator. Parameters: sentence (str): A string containing a sequence of words separated by spaces. Returns: str: A string with words in reverse order joined by a dash. >>> reverse_and_join(\\"hello there world\\") 'world-there-hello' >>> reverse_and_join(\\"hello world\\") 'world-hello' >>> reverse_and_join(\\"a b c d e\\") 'e-d-c-b-a' >>> reverse_and_join(\\"\\") ''","solution":"def reverse_and_join(sentence): Reverses the order of words in the input sentence and joins them with a dash ('-') as the separator. Parameters: sentence (str): A string containing a sequence of words separated by spaces. Returns: str: A string with words in reverse order joined by a dash. words = sentence.split() reversed_words = words[::-1] result = '-'.join(reversed_words) return result"},{"question":"def normalize(phone_number): Normalizes the phone number to the format 123-456-7890. >>> normalize(\\"(123) 456-7890\\") == \\"123-456-7890\\" >>> normalize(\\"123.456.7890\\") == \\"123-456-7890\\" >>> normalize(\\"1234567890\\") == \\"123-456-7890\\" >>> normalize(\\" 123 . 456 . 789 0 \\") == \\"123-456-7890\\"","solution":"def normalize(phone_number): Normalizes the phone number to the format 123-456-7890. digits = ''.join(filter(str.isdigit, phone_number)) formatted_phone_number = f\\"{digits[:3]}-{digits[3:6]}-{digits[6:]}\\" return formatted_phone_number"},{"question":"def move_zeroes(nums): Move all zeroes in the list to the end while maintaining the relative order of non-zero elements. Args: nums (List[int]): The list of integers. Returns: None: The function modifies nums in-place. Example: >>> nums = [0, 1, 0, 3, 12] >>> move_zeroes(nums) >>> nums [1, 3, 12, 0, 0] >>> nums = [0, 0, 1] >>> move_zeroes(nums) >>> nums [1, 0, 0]","solution":"def move_zeroes(nums): Move all zeroes in the list to the end while maintaining the relative order of non-zero elements. Args: nums (List[int]): The list of integers. Returns: None: The function modifies nums in-place. # Position to place the next non-zero element last_non_zero_found_at = 0 # Move all the non-zero elements to the beginning for i in range(len(nums)): if nums[i] != 0: nums[last_non_zero_found_at] = nums[i] last_non_zero_found_at += 1 # Fill the remaining positions with zeroes for i in range(last_non_zero_found_at, len(nums)): nums[i] = 0"},{"question":"from typing import List def basic_calculator(expression: str) -> int: Evaluates a basic arithmetic expression containing non-negative integers and the operators '+', '-', '*'. >>> basic_calculator(\\"3+5\\") 8 >>> basic_calculator(\\"10-2\\") 8 >>> basic_calculator(\\"4*2\\") 8 >>> basic_calculator(\\"3+5*2-8\\") 5 >>> basic_calculator(\\"10*2-3+4\\") 21 >>> basic_calculator(\\"1+2-3*4\\") -9 >>> basic_calculator(\\"0\\") 0 >>> basic_calculator(\\"12\\") 12 >>> basic_calculator(\\"2*3*4\\") 24 >>> basic_calculator(\\"10+20*3-5\\") 65","solution":"def basic_calculator(expression): Evaluates a basic arithmetic expression containing non-negative integers and the operators '+', '-', '*'. def evaluate(tokens): total, current_value = 0, 0 operator = '+' for token in tokens: if token in '+-*': operator = token else: num = int(token) if operator == '+': total += current_value current_value = num elif operator == '-': total += current_value current_value = -num elif operator == '*': current_value *= num return total + current_value # Split the expression into parts tokens = [] num = '' for char in expression: if char in '+-*': tokens.append(num) tokens.append(char) num = '' else: num += char tokens.append(num) return evaluate(tokens)"},{"question":"import re from collections import Counter from typing import List def most_frequent_word(text: str) -> str: Returns the most frequently appearing word in the text. If multiple words have the same highest frequency, returns the one that appears first. >>> most_frequent_word(\\"To be or not to be, that is the question.\\") 'to' >>> most_frequent_word(\\"Hello world! It's a pleasant day in the world of programming.\\") 'world' # Your implementation here","solution":"import re from collections import Counter def most_frequent_word(text: str) -> str: Returns the most frequently appearing word in the text. If multiple words have the same highest frequency, returns the one that appears first. # Convert text to lowercase and find all words using regex words = re.findall(r'b[a-zA-Z]+b', text.lower()) # Use Counter to count the frequency of each word word_counts = Counter(words) # Find the max frequency max_frequency = max(word_counts.values()) # Iterate over words in original order and return the first with max frequency for word in words: if word_counts[word] == max_frequency: return word"},{"question":"def min_insertions_to_palindrome(s: str) -> int: Determine the minimum number of characters you need to insert into a string to make it a palindrome. >>> min_insertions_to_palindrome(\\"a\\") 0 >>> min_insertions_to_palindrome(\\"ab\\") 1 >>> min_insertions_to_palindrome(\\"racecar\\") 0 >>> min_insertions_to_palindrome(\\"race\\") 3 >>> min_insertions_to_palindrome(\\"google\\") 2 >>> min_insertions_to_palindrome(\\"Able\\") 3 >>> min_insertions_to_palindrome(\\"Evelyn\\") 5 >>> min_insertions_to_palindrome(\\"a,b a\\") 2 >>> min_insertions_to_palindrome(\\"a b a\\") 0","solution":"def min_insertions_to_palindrome(s): n = len(s) dp = [[0] * n for _ in range(n)] for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] else: dp[i][j] = min(dp[i + 1][j], dp[i][j - 1]) + 1 return dp[0][n - 1]"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a string representing an arithmetic expression involving addition and subtraction of integers, and returns the resulting integer. >>> evaluate_expression(\\"10+5-3\\") 12 >>> evaluate_expression(\\"1+2-3+4-5\\") -1 >>> evaluate_expression(\\"7-2+3+10-5\\") 13","solution":"def evaluate_expression(expression): Evaluates a string representing an arithmetic expression involving addition and subtraction of integers, and returns the resulting integer. # Initialize variables current_number = 0 result = 0 current_sign = 1 # 1 for positive, -1 for negative index = 0 n = len(expression) while index < n: char = expression[index] if char.isdigit(): # Build the full number current_number = current_number * 10 + int(char) if char == '+' or char == '-' or index == n - 1: # Add/subtract the last number obtained result += current_sign * current_number current_number = 0 # Update the sign current_sign = 1 if char == '+' else -1 index += 1 return result"},{"question":"from typing import List def setZeroes(matrix: List[List[int]]) -> None: Given a matrix of integers, if an element is zero, set the entire row and column containing that element to zero. The function modifies the matrix in-place. Examples: >>> matrix1 = [ ... [1, 2, 3], ... [4, 0, 6], ... [7, 8, 9] ... ] >>> setZeroes(matrix1) >>> assert matrix1 == [ ... [1, 0, 3], ... [0, 0, 0], ... [7, 0, 9] ... ] >>> matrix2 = [ ... [0, 1, 2, 0], ... [3, 4, 5, 2], ... [1, 3, 1, 5] ... ] >>> setZeroes(matrix2) >>> assert matrix2 == [ ... [0, 0, 0, 0], ... [0, 4, 5, 0], ... [0, 3, 1, 0] ... ]","solution":"def setZeroes(matrix): if not matrix: return rows, cols = len(matrix), len(matrix[0]) first_row_has_zero = any(matrix[0][j] == 0 for j in range(cols)) first_col_has_zero = any(matrix[i][0] == 0 for i in range(rows)) for i in range(1, rows): for j in range(1, cols): if matrix[i][j] == 0: matrix[i][0] = 0 matrix[0][j] = 0 for i in range(1, rows): if matrix[i][0] == 0: for j in range(1, cols): matrix[i][j] = 0 for j in range(1, cols): if matrix[0][j] == 0: for i in range(1, rows): matrix[i][j] = 0 if first_row_has_zero: for j in range(cols): matrix[0][j] = 0 if first_col_has_zero: for i in range(rows): matrix[i][0] = 0"},{"question":"def min_sprays(field: List[List[str]]) -> int: Returns the minimum number of sprays required to water all crop cells. >>> field = [ ... ['C', 'P', 'P'], ... ['P', 'C', 'P'], ... ['C', 'P', 'C'] ... ] >>> min_sprays(field) 3 >>> field = [ ... ['C', 'P'], ... ['P', 'C'] ... ] >>> min_sprays(field) 2","solution":"def min_sprays(field): Returns the minimum number of sprays required to water all crop cells. rows, cols = len(field), len(field[0]) row_has_crop = [any(cell == 'C' for cell in row) for row in field] col_has_crop = [any(field[r][c] == 'C' for r in range(rows)) for c in range(cols)] row_activations = sum(row_has_crop) col_activations = sum(col_has_crop) return min(row_activations, col_activations)"},{"question":"from typing import List, Tuple, Optional def find_pair_with_sum(input_list: List[int], target_sum: int) -> Optional[Tuple[int, int]]: Find a pair of integers in 'input_list' that add up to 'target_sum'. :param input_list: List of positive integers :param target_sum: The target sum to find in the list :return: A tuple of two integers that add up to the target_sum, or None if no such pair exists Examples: >>> find_pair_with_sum([1, 2, 3, 4, 5], 9) == (4, 5) >>> find_pair_with_sum([1, 2, 3, 4, 5], 8) == (3, 5) >>> find_pair_with_sum([1, 2, 3, 4, 5], 10) is None","solution":"from typing import List, Tuple, Optional def find_pair_with_sum(input_list: List[int], target_sum: int) -> Optional[Tuple[int, int]]: Find a pair of integers in 'input_list' that add up to 'target_sum'. :param input_list: List of positive integers :param target_sum: The target sum to find in the list :return: A tuple of two integers that add up to the target_sum, or None if no such pair exists seen = {} # Dictionary to store numbers and their indices for index, number in enumerate(input_list): complement = target_sum - number if complement in seen: return (complement, number) seen[number] = index return None"},{"question":"def reverse_and_add_palindrome(n: int) -> int: Returns the number of reverse-and-add steps required to reach a palindrome. If a palindrome is not reached within 100 steps, return -1. >>> reverse_and_add_palindrome(87) == 4 >>> reverse_and_add_palindrome(196) == -1 >>> reverse_and_add_palindrome(89) == 24 >>> reverse_and_add_palindrome(11) == 0 >>> reverse_and_add_palindrome(1) == 0 >>> reverse_and_add_palindrome(9) == 0 >>> reverse_and_add_palindrome(12345) == 1 pass","solution":"def reverse_and_add_palindrome(n): Returns the number of reverse-and-add steps required to reach a palindrome. If a palindrome is not reached within 100 steps, return -1. def is_palindrome(x): s = str(x) return s == s[::-1] def reverse_number(x): return int(str(x)[::-1]) steps = 0 while steps < 100: if is_palindrome(n): return steps reversed_n = reverse_number(n) n += reversed_n steps += 1 return -1"},{"question":"def determine_triangle_type(angle1, angle2, angle3): Returns the type of triangle based on its angles. Possible return values: - \\"Acute\\" if all three angles are less than 90 degrees. - \\"Right\\" if exactly one angle is equal to 90 degrees. - \\"Obtuse\\" if one angle is greater than 90 degrees. - \\"Invalid\\" if the provided angles do not form a triangle. >>> determine_triangle_type(60, 60, 60) 'Acute' >>> determine_triangle_type(90, 45, 45) 'Right' >>> determine_triangle_type(120, 30, 30) 'Obtuse' >>> determine_triangle_type(90, 90, 90) 'Invalid' >>> determine_triangle_type(90, 45, 50) 'Invalid'","solution":"def determine_triangle_type(angle1, angle2, angle3): Returns the type of triangle based on its angles. Possible return values: - \\"Acute\\" if all three angles are less than 90 degrees. - \\"Right\\" if exactly one angle is equal to 90 degrees. - \\"Obtuse\\" if one angle is greater than 90 degrees. - \\"Invalid\\" if the provided angles do not form a triangle. if angle1 + angle2 + angle3 != 180: return \\"Invalid\\" if any(angle <= 0 for angle in [angle1, angle2, angle3]): return \\"Invalid\\" if any(angle > 90 for angle in [angle1, angle2, angle3]): return \\"Obtuse\\" if any(angle == 90 for angle in [angle1, angle2, angle3]): return \\"Right\\" return \\"Acute\\""},{"question":"def max_sum_of_subarray_k_elements(n, k, a): Returns the maximum sum of any contiguous subarray of length k. >>> max_sum_of_subarray_k_elements(6, 3, [2, 1, 5, 1, 3, 2]) 9 >>> max_sum_of_subarray_k_elements(1, 1, [5]) 5 >>> max_sum_of_subarray_k_elements(5, 2, [3, 3, 3, 3, 3]) 6 >>> max_sum_of_subarray_k_elements(5, 2, [10000, 9999, 9998, 9997, 9996]) 19999 >>> max_sum_of_subarray_k_elements(6, 6, [1, 2, 3, 4, 5, 6]) 21 >>> max_sum_of_subarray_k_elements(5, 1, [1, 3, 2, 5, 4]) 5","solution":"def max_sum_of_subarray_k_elements(n, k, a): Returns the maximum sum of any contiguous subarray of length k. # Initialize the sum of the first subarray of length k max_sum = current_sum = sum(a[:k]) # Slide the window of length k across the array for i in range(k, n): # Add the next element and remove the first element of the previous window current_sum = current_sum + a[i] - a[i - k] # Update max_sum if current_sum is larger if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def exist(board, word): Check if the word exists in the board by conducting a depth-first search (DFS) on each cell. :param board: List[List[str]] - The board of characters. :param word: str - The word to be searched. :return: bool - True if the word exists in the board, and False otherwise. pass def test_exist_case1(): board = [ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E'] ] word = \\"ABCCED\\" assert exist(board, word) == True def test_exist_case2(): board = [ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E'] ] word = \\"SEE\\" assert exist(board, word) == True def test_exist_case3(): board = [ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E'] ] word = \\"ABCB\\" assert exist(board, word) == False def test_exist_case4(): board = [ ['a','b'], ['c','d'] ] word = \\"abcd\\" assert exist(board, word) == False def test_exist_case5(): board = [ ['a'] ] word = \\"a\\" assert exist(board, word) == True","solution":"def exist(board, word): Check if the word exists in the board by conducting a depth-first search (DFS) on each cell. def dfs(board, word, index, x, y): if index == len(word): return True if x < 0 or x >= len(board) or y < 0 or y >= len(board[0]) or board[x][y] != word[index]: return False temp = board[x][y] board[x][y] = \\"#\\" found = (dfs(board, word, index + 1, x + 1, y) or dfs(board, word, index + 1, x - 1, y) or dfs(board, word, index + 1, x, y + 1) or dfs(board, word, index + 1, x, y - 1)) board[x][y] = temp return found for i in range(len(board)): for j in range(len(board[0])): if board[i][j] == word[0] and dfs(board, word, 0, i, j): return True return False"},{"question":"def min_operations(branches: List[int], k: int) -> int: Calculates the minimum number of operations needed for the caterpillar to eat all the leaves from all branches. Each operation allows the caterpillar to eat \`k\` leaves. Args: branches (List[int]): A list where each element represents the number of leaves on a branch. k (int): The number of leaves the caterpillar can eat in one operation. Returns: int: The minimum number of operations needed. Examples: >>> min_operations([10, 15, 25], 5) 10 >>> min_operations([7, 3, 21], 4) 9","solution":"def min_operations(branches, k): Calculates the minimum number of operations needed for the caterpillar to eat all the leaves from all branches. Parameters: branches (list of int): A list where each element represents the number of leaves on a branch. k (int): The number of leaves the caterpillar can eat in one operation. Returns: int: The minimum number of operations needed. operations = 0 for leaves in branches: operations += (leaves + k - 1) // k # Ceiling division to determine operations per branch return operations"},{"question":"def rotate_list(lst, n): Rotates the list \`lst\` to the right by \`n\` positions. >>> rotate_list([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_list([1, 2, 3, 4, 5], 7) [4, 5, 1, 2, 3]","solution":"def rotate_list(lst, n): Rotates the list \`lst\` to the right by \`n\` positions. if not lst: return lst n = n % len(lst) # Handle cases where n is larger than the list length return lst[-n:] + lst[:-n]"},{"question":"from datetime import datetime def calculate_seconds_diff(timestamp1: str, timestamp2: str) -> int: Returns the absolute difference between two timestamps in seconds. Parameters: - timestamp1 (str): The first timestamp in 'YYYY-MM-DD HH:MM:SS' format. - timestamp2 (str): The second timestamp in 'YYYY-MM-DD HH:MM:SS' format. Returns: int: The absolute difference between the two timestamps in seconds. Examples: >>> calculate_seconds_diff('2023-03-01 01:15:30', '2023-03-01 02:45:30') 5400 >>> calculate_seconds_diff('2023-10-15 12:00:00', '2023-10-16 12:00:00') 86400","solution":"from datetime import datetime def calculate_seconds_diff(timestamp1: str, timestamp2: str) -> int: Returns the absolute difference between two timestamps in seconds. Parameters: timestamp1 (str): The first timestamp in 'YYYY-MM-DD HH:MM:SS' format. timestamp2 (str): The second timestamp in 'YYYY-MM-DD HH:MM:SS' format. Returns: int: The absolute difference between the two timestamps in seconds. t1 = datetime.strptime(timestamp1, '%Y-%m-%d %H:%M:%S') t2 = datetime.strptime(timestamp2, '%Y-%m-%d %H:%M:%S') delta = t2 - t1 return delta.total_seconds()"},{"question":"from typing import List, Tuple def tsp_solver(input_str: str) -> List[int]: Solve the Traveling Salesman Problem (TSP) for the given input string. The function takes an input string containing multiple test cases, where each test case consists of a number of cities and a matrix of distances between each pair of cities. The function returns a list of minimum total distances for each test case. Args: input_str (str): Input string including the number of test cases, the number of cities for each test case, and the distance matrices. Returns: List[int]: A list of integers where each integer is the minimum total distance Richard needs to travel to visit all cities exactly once and return to the starting city. >>> tsp_solver(\\"2n4n0 10 15 20n10 0 35 25n15 35 0 30n20 25 30 0n3n0 5 9n5 0 10n9 10 0n\\") [80, 24] >>> tsp_solver(\\"1n3n0 1 2n1 0 3n2 3 0n\\") [6] >>> tsp_solver(\\"1n4n0 1 1 1n1 0 1 1n1 1 0 1n1 1 1 0n\\") [4] >>> tsp_solver(\\"1n3n0 500 400n500 0 300n400 300 0n\\") [1200] >>> tsp_solver(\\"1n2n0 1n1 0n\\") [2]","solution":"from itertools import permutations def calculate_tsp(n, matrix): def calculate_path_length(path): total_length = 0 for i in range(len(path) - 1): total_length += matrix[path[i]][path[i+1]] total_length += matrix[path[-1]][path[0]] return total_length cities = list(range(n)) min_path_length = float('inf') for perm in permutations(cities): path_length = calculate_path_length(perm) if path_length < min_path_length: min_path_length = path_length return min_path_length def find_min_tsp_distances(T, test_cases): results = [] for i in range(T): n, matrix = test_cases[i] min_distance = calculate_tsp(n, matrix) results.append(min_distance) return results def parse_input(input_str): input_lines = input_str.strip().split('n') T = int(input_lines[0]) test_cases = [] index = 1 for _ in range(T): n = int(input_lines[index]) index += 1 matrix = [] for _ in range(n): row = list(map(int, input_lines[index].split())) index += 1 matrix.append(row) test_cases.append((n, matrix)) return T, test_cases def tsp_solver(input_str): T, test_cases = parse_input(input_str) results = find_min_tsp_distances(T, test_cases) return results"},{"question":"def can_transform(s: str, t: str) -> str: Returns \\"YES\\" if string s can be transformed into string t by applying the given transformations, otherwise returns \\"NO\\". >>> can_transform(\\"abc\\", \\"cba\\") \\"YES\\" >>> can_transform(\\"ab\\", \\"ab\\") \\"YES\\" >>> can_transform(\\"abc\\", \\"def\\") \\"NO\\" def process_test_cases(test_cases: List[Tuple[str, str]]) -> List[str]: Returns a list of results for each test case, determining if \`s\` can be transformed into \`t\`. >>> process_test_cases([(\\"abc\\", \\"cba\\"), (\\"ab\\", \\"ab\\"), (\\"abc\\", \\"def\\")]) [\\"YES\\", \\"YES\\", \\"NO\\"] def test_can_transform(): assert can_transform(\\"abc\\", \\"cba\\") == \\"YES\\" assert can_transform(\\"ab\\", \\"ab\\") == \\"YES\\" assert can_transform(\\"abc\\", \\"def\\") == \\"NO\\" assert can_transform(\\"aabbcc\\", \\"ccbbaa\\") == \\"YES\\" assert can_transform(\\"a\\", \\"a\\") == \\"YES\\" assert can_transform(\\"abcd\\", \\"abcd\\") == \\"YES\\" assert can_transform(\\"abcd\\", \\"abce\\") == \\"NO\\" assert can_transform(\\"abcd\\", \\"dcab\\") == \\"YES\\" assert can_transform(\\"xyz\\", \\"zyx\\") == \\"YES\\" assert can_transform(\\"hello\\", \\"olleh\\") == \\"YES\\" def test_process_test_cases(): test_cases = [(\\"abc\\", \\"cba\\"), (\\"ab\\", \\"ab\\"), (\\"abc\\", \\"def\\")] results = process_test_cases(test_cases) assert results == [\\"YES\\", \\"YES\\", \\"NO\\"] test_cases = [(\\"abcd\\", \\"dcba\\"), (\\"xyz\\", \\"zyx\\"), (\\"abcd\\", \\"abce\\")] results = process_test_cases(test_cases) assert results == [\\"YES\\", \\"YES\\", \\"NO\\"] test_cases = [(\\"aabbcc\\", \\"ccbbaa\\"), (\\"a\\", \\"a\\"), (\\"hello\\", \\"olleh\\")] results == [\\"YES\\", \\"YES\\", \\"YES\\"]","solution":"def can_transform(s, t): Returns \\"YES\\" if string s can be transformed into string t by applying the given transformations, otherwise returns \\"NO\\". # Check if the sorted characters of both strings are equal. sorted_s = sorted(s) sorted_t = sorted(t) if sorted_s == sorted_t: return \\"YES\\" else: return \\"NO\\" def process_test_cases(test_cases): results = [] for s, t in test_cases: results.append(can_transform(s, t)) return results"},{"question":"def count_distinct_palindromic_substrings(n: int, s: str) -> int: Count the number of distinct palindromic substrings of the given string. >>> count_distinct_palindromic_substrings(5, \\"ababa\\") 5 >>> count_distinct_palindromic_substrings(1, \\"a\\") 1 >>> count_distinct_palindromic_substrings(3, \\"abc\\") 3 >>> count_distinct_palindromic_substrings(4, \\"aaaa\\") 4 >>> count_distinct_palindromic_substrings(7, \\"racecar\\") 7","solution":"def count_distinct_palindromic_substrings(n, s): palindromic_substrings = set() def is_palindrome(sub): return sub == sub[::-1] for start in range(n): for end in range(start, n): substring = s[start:end + 1] if is_palindrome(substring): palindromic_substrings.add(substring) return len(palindromic_substrings)"},{"question":"def longest_consecutive_sequence(numbers: List[int]) -> int: Returns the length of the longest sequence of consecutive numbers in the list. >>> longest_consecutive_sequence([100, 4, 200, 1, 3, 2]) == 4 >>> longest_consecutive_sequence([0, -1, 2, -2, -3, 1]) == 6 >>> longest_consecutive_sequence([9, 1, 4, 7, 3, 2, 6, 8, 0]) == 5 >>> longest_consecutive_sequence([5]) == 1 >>> longest_consecutive_sequence([1, 2, 2, 3, 4]) == 4 >>> longest_consecutive_sequence([1, 1, 1, 1, 1]) == 1 >>> longest_consecutive_sequence([]) == 0 >>> longest_consecutive_sequence([10, 5, 100]) == 1 pass","solution":"def longest_consecutive_sequence(numbers): Returns the length of the longest sequence of consecutive numbers in the list. if not numbers: return 0 number_set = set(numbers) longest_streak = 0 for number in number_set: if number - 1 not in number_set: # check if it's the start of a sequence current_number = number current_streak = 1 while current_number + 1 in number_set: current_number += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def sortNames(names: List[str]) -> List[str]: Sort a list of names in alphabetical order without using built-in sort functions. :param names: List of names (strings) :return: New list with names sorted Example Usage: >>> sortNames(['Kirk', 'Spock', 'McCoy', 'Sulu', 'Scotty']) ['Kirk', 'McCoy', 'Scotty', 'Spock', 'Sulu'] >>> sortNames(['Gamma', 'Beta', 'Alpha']) ['Alpha', 'Beta', 'Gamma'] >>> sortNames(['Zeta']) ['Zeta'] >>> sortNames([]) [] >>> sortNames(['Kirk', 'Spock', 'Kirk', 'Sulu', 'Spock']) ['Kirk', 'Kirk', 'Spock', 'Spock', 'Sulu']","solution":"def sortNames(names): Sorts a list of names in alphabetical order using selection sort. :param names: List of names (strings) :return: New list with names sorted sorted_names = names[:] n = len(sorted_names) for i in range(n): min_idx = i for j in range(i + 1, n): if sorted_names[j] < sorted_names[min_idx]: min_idx = j sorted_names[i], sorted_names[min_idx] = sorted_names[min_idx], sorted_names[i] return sorted_names # Example usage: names_list = [\\"Kirk\\", \\"Spock\\", \\"McCoy\\", \\"Sulu\\", \\"Scotty\\"] print(sortNames(names_list))"},{"question":"def longest_consecutive_sequence(nums: List[int]) -> int: Determines the length of the longest consecutive elements sequence. Args: nums: List[int] - a list of integers. Returns: int - the length of the longest consecutive elements sequence. Examples: >>> longest_consecutive_sequence([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive_sequence([0, 3, 7, 2, 5, 8, 4, 6, 0, 1]) 9 >>> longest_consecutive_sequence([1, 2, 0, 1]) 3 >>> longest_consecutive_sequence([-1, 1, 0, -2, 2]) 5 >>> longest_consecutive_sequence([10, 5, 15, 12, 14, 13]) 4 >>> longest_consecutive_sequence([5, 5, 5, 5, 5]) 1 >>> longest_consecutive_sequence([1, 9, 3, 10, 2, 20]) 3 >>> longest_consecutive_sequence([42]) 1 >>> longest_consecutive_sequence([0]) 1 >>> longest_consecutive_sequence([-5]) 1","solution":"def longest_consecutive_sequence(nums): Determines the length of the longest consecutive elements sequence. Args: nums: List[int] - a list of integers. Returns: int - the length of the longest consecutive elements sequence. if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in num_set: if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def longest_word(s: str) -> str: Write a function that accepts a string containing multiple words, and returns the longest word in the string. If there are multiple words with the same longest length, return the first one that appears in the string. >>> longest_word(\\"I love programming\\") 'programming' >>> longest_word(\\"The quick brown fox jumps over the lazy dog\\") 'quick' >>> longest_word(\\"To be or not to be that is the question\\") 'question'","solution":"def longest_word(s): Returns the longest word in the input string. If there are multiple words with the same longest length, returns the first one that appears in the string. words = s.split() longest = \\"\\" for word in words: if len(word) > len(longest): longest = word return longest"},{"question":"def isLeapYear(year: int) -> bool: Determines if the given year is a leap year. A leap year is defined as follows: - A year that is divisible by 400 is a leap year. - If it is not divisible by 400, but divisible by 100, it is not a leap year. - If it is not divisible by 100, but divisible by 4, it is a leap year. - All other years are not leap years. >>> isLeapYear(2000) True >>> isLeapYear(1900) False >>> isLeapYear(2004) True >>> isLeapYear(2001) False","solution":"def isLeapYear(year): Determines if the given year is a leap year. Parameters: year (int): The year to check. Returns: bool: True if the year is a leap year, False otherwise. if year % 400 == 0: return True elif year % 100 == 0: return False elif year % 4 == 0: return True else: return False"},{"question":"def remove_vowels(sentences: List[str]) -> List[str]: Given a list of 'n' sentences, remove all the vowels from each sentence and output the modified sentences. >>> remove_vowels([\\"Hello World\\"]) [\\"Hll Wrld\\"] >>> remove_vowels([\\"Programming is fun\\"]) [\\"Prgrmmng s fn\\"] >>> remove_vowels([\\"I am a student\\"]) [\\" m stdnt\\"] def process_input(n: int, sentences: List[str]) -> List[str]: Processes input by calling the remove_vowels function. >>> process_input(1, [\\"Hello World\\"]) [\\"Hll Wrld\\"] >>> process_input(1, [\\"Programming is fun\\"]) [\\"Prgrmmng s fn\\"] >>> process_input(1, [\\"I am a student\\"]) [\\" m stdnt\\"] >>> process_input(3, [\\"Hello World\\", \\"Programming is fun\\", \\"I am a student\\"]) [\\"Hll Wrld\\", \\"Prgrmmng s fn\\", \\" m stdnt\\"]","solution":"def remove_vowels(sentences): vowels = 'aeiouAEIOU' result = [] for sentence in sentences: modified_sentence = ''.join([char for char in sentence if char not in vowels]) result.append(modified_sentence) return result def process_input(n, sentences): return remove_vowels(sentences)"},{"question":"def find_longest_unimodal_subarray(arr: List[int]) -> int: Find the length of the longest unimodal subarray. A unimodal subarray is one that increases up to a certain point and then decreases. >>> find_longest_unimodal_subarray([1, 3, 5, 7, 6, 4, 2]) == 7 >>> find_longest_unimodal_subarray([2, 1, 4, 7, 3, 2, 5, 4, 3]) == 5 >>> find_longest_unimodal_subarray([5, 4, 3, 2, 1]) == 0","solution":"def find_longest_unimodal_subarray(arr): n = len(arr) if n < 3: return 0 longest = 0 i = 1 while i < n - 1: # Check if it is a peak if arr[i-1] < arr[i] > arr[i+1]: left = i - 1 right = i + 1 # Move left pointer to the beginning of the increasing part while left > 0 and arr[left-1] < arr[left]: left -= 1 # Move right pointer to the end of the decreasing part while right < n - 1 and arr[right] > arr[right+1]: right += 1 # Update the longest length current_length = right - left + 1 longest = max(longest, current_length) # Move i to the end of the current unimodal subarray i = right else: i += 1 return longest"},{"question":"class MatrixQueries: Class to represent a 2D matrix of integers and supports various operations. Methods ------- initializeMatrix(rows, cols, initialValue) Initializes the matrix with the given rows and columns, setting all values to initialValue. setRow(row, value) Sets all elements in the given row to the specific value. setCol(col, value) Sets all elements in the given column to the specific value. getElement(row, col) Returns the current value of the element at the specified row and column. def initializeMatrix(self, rows, cols, initialValue): Initializes the matrix with the given rows and columns, setting all values to initialValue. pass def setRow(self, row, value): Sets all elements in the given row to the specific value. pass def setCol(self, col, value): Sets all elements in the given column to the specific value. pass def getElement(self, row, col): Returns the current value of the element at the specified row and column. pass import pytest def test_initialize_matrix(): mq = MatrixQueries() mq.initializeMatrix(3, 3, 0) assert mq.getElement(0, 0) == 0 assert mq.getElement(1, 1) == 0 assert mq.getElement(2, 2) == 0 def test_set_row(): mq = MatrixQueries() mq.initializeMatrix(3, 3, 0) mq.setRow(1, 5) assert mq.getElement(1, 0) == 5 assert mq.getElement(1, 1) == 5 assert mq.getElement(1, 2) == 5 assert mq.getElement(0, 0) == 0 assert mq.getElement(2, 2) == 0 def test_set_col(): mq = MatrixQueries() mq.initializeMatrix(3, 3, 0) mq.setCol(2, 7) assert mq.getElement(0, 2) == 7 assert mq.getElement(1, 2) == 7 assert mq.getElement(2, 2) == 7 assert mq.getElement(0, 0) == 0 assert mq.getElement(2, 1) == 0 def test_get_element(): mq = MatrixQueries() mq.initializeMatrix(3, 3, 0) assert mq.getElement(0, 0) == 0 assert mq.getElement(2, 2) == 0 mq.setRow(0, 8) assert mq.getElement(0, 0) == 8 assert mq.getElement(0, 2) == 8 mq.setCol(1, 3) assert mq.getElement(0, 1) == 3 assert mq.getElement(2, 1) == 3 def test_index_out_of_bounds(): mq = MatrixQueries() mq.initializeMatrix(3, 3, 0) with pytest.raises(IndexError): mq.getElement(3, 3) with pytest.raises(IndexError): mq.getElement(-1, 0) with pytest.raises(IndexError): mq.getElement(0, 3)","solution":"class MatrixQueries: def initializeMatrix(self, rows, cols, initialValue): Initializes the matrix with the given rows and columns, setting all values to initialValue. self.matrix = [[initialValue for _ in range(cols)] for _ in range(rows)] self.rows = rows self.cols = cols def setRow(self, row, value): Sets all elements in the given row to the specific value. if 0 <= row < self.rows: for col in range(self.cols): self.matrix[row][col] = value def setCol(self, col, value): Sets all elements in the given column to the specific value. if 0 <= col < self.cols: for row in range(self.rows): self.matrix[row][col] = value def getElement(self, row, col): Returns the current value of the element at the specified row and column. if 0 <= row < self.rows and 0 <= col < self.cols: return self.matrix[row][col] else: # Typically, you might want to raise an error here for invalid indices. raise IndexError(\\"Row or column index out of bounds\\")"},{"question":"def evaluate_expression(expression: str) -> float: Evaluates a mathematical expression and returns the result as a floating-point number. Parameters: expression (str): The string containing the mathematical expression. Returns: float: The result of the evaluated expression. Raises: ZeroDivisionError: If there is a division by zero in the expression. Examples: >>> evaluate_expression(\\"2 + 2\\") 4.0 >>> evaluate_expression(\\"10 / 2 - 3\\") 2.0 >>> evaluate_expression(\\"1 + (2 - 3) * 4 + 6 / 3\\") 3.0 pass def test_simple_addition(): assert evaluate_expression(\\"2 + 2\\") == 4.0 def test_simple_subtraction(): assert evaluate_expression(\\"5 - 2\\") == 3.0 def test_simple_multiplication(): assert evaluate_expression(\\"3 * 4\\") == 12.0 def test_simple_division(): assert evaluate_expression(\\"10 / 2\\") == 5.0 def test_combined_operations(): assert evaluate_expression(\\"2 + 3 * 4\\") == 14.0 def test_expression_with_parentheses(): assert evaluate_expression(\\"(2 + 3) * 4\\") == 20.0 def test_expression_with_whitespace(): assert evaluate_expression(\\" 2 + 3 * ( 2 - 8 ) / 4 \\") == -2.5 def test_division_by_zero(): try: evaluate_expression(\\"1 / 0\\") except ZeroDivisionError: assert True else: assert False def test_invalid_expression(): try: evaluate_expression(\\"2 + abc\\") except ValueError: assert True else: assert False","solution":"def evaluate_expression(expression): Evaluates a mathematical expression and returns the result as a floating-point number. Parameters: expression (str): The string containing the mathematical expression. Returns: float: The result of the evaluated expression. Raises: ZeroDivisionError: If there is a division by zero in the expression. try: # Use eval to evaluate the expression result = eval(expression) # Check if the result is a floating-point number return float(result) except ZeroDivisionError: raise ZeroDivisionError(\\"Division by zero is not allowed.\\") except Exception as e: raise ValueError(f\\"Invalid expression. Error: {e}\\")"},{"question":"def find_record_with_max_sum(records): Given a list of records, return the identifier of the record with the highest sum of numerical values. :param records: List of tuples, each containing an identifier (string) and a list of integers. :return: Identifier of the record with the highest sum of numerical values. >>> find_record_with_max_sum([(\\"rec1\\", [1, 2, 3]), (\\"rec2\\", [2, 3, 4]), (\\"rec3\\", [3, 3, 3])]) == \\"rec2\\" >>> find_record_with_max_sum([(\\"rec1\\", [1, 2, 3])]) == \\"rec1\\" >>> find_record_with_max_sum([(\\"rec1\\", [1, 2, 3]), (\\"rec2\\", [3, 3]), (\\"rec3\\", [1, 2, 3])]) == \\"rec1\\" >>> find_record_with_max_sum([(\\"rec1\\", [-1, -2, -3]), (\\"rec2\\", [-2, -2, -2]), (\\"rec3\\", [-1, -1, -1])]) == \\"rec3\\" >>> find_record_with_max_sum([(\\"rec1\\", [0, 0, 0]), (\\"rec2\\", [0]), (\\"rec3\\", [0, 0])]) == \\"rec1\\" >>> find_record_with_max_sum([(\\"rec1\\", [10**6, 10**7]), (\\"rec2\\", [10**8]), (\\"rec3\\", [9*10**7, 10**6])]) == \\"rec2\\"","solution":"def find_record_with_max_sum(records): Given a list of records, return the identifier of the record with the highest sum of numerical values. :param records: List of tuples, each containing an identifier (string) and a list of integers. :return: Identifier of the record with the highest sum of numerical values. return max(records, key=lambda record: sum(record[1]))[0]"},{"question":"from typing import List def unique_paths_with_obstacles(grid: List[List[int]]) -> int: Given a 2D grid of integers, each cell represents a city block. Some blocks are marked as obstacles (represented by -1), which you cannot pass through. Your goal is to find the number of unique paths from the top-left corner to the bottom-right corner of the grid, moving only right or down, without passing through the obstacles. >>> unique_paths_with_obstacles([[0,0,0],[0,-1,0],[0,0,0]]) 2 >>> unique_paths_with_obstacles([[0,-1],[0,0]]) 1 >>> unique_paths_with_obstacles([[0,0,0,-1,0]]) 0 >>> unique_paths_with_obstacles([[0],[0],[0]]) 1 >>> unique_paths_with_obstacles([[0,0,0],[0,0,0],[0,0,0]]) 6 >>> unique_paths_with_obstacles([[-1,0],[0,0]]) 0 >>> unique_paths_with_obstacles([[0,0],[0,-1]]) 0 >>> unique_paths_with_obstacles([[-1]]) 0 >>> unique_paths_with_obstacles([[0]]) 1","solution":"def unique_paths_with_obstacles(grid): Returns the number of unique paths from the top-left to the bottom-right corner of the grid, while avoiding obstacles (represented by -1). if not grid or grid[0][0] == -1 or grid[-1][-1] == -1: return 0 m, n = len(grid), len(grid[0]) # Initialize a 2D dp array with all zeros dp = [[0 for _ in range(n)] for _ in range(m)] dp[0][0] = 1 # Fill the first column for i in range(1, m): dp[i][0] = dp[i-1][0] if grid[i][0] == 0 else 0 # Fill the first row for j in range(1, n): dp[0][j] = dp[0][j-1] if grid[0][j] == 0 else 0 # Fill the rest of the dp array for i in range(1, m): for j in range(1, n): if grid[i][j] == 0: dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1]"},{"question":"def is_prime(x): Helper function that determines if a number is prime. >>> is_prime(2) == True >>> is_prime(3) == True >>> is_prime(4) == False >>> is_prime(29) == True >>> is_prime(1) == False >>> is_prime(-3) == False pass def has_prime_in_parts(n, k): Determine if there is at least one part containing a prime number when the cards numbered 1 to n are divided into k parts. Args: n: int - Total number of cards. k: int - Number of parts to divide the cards into. Returns: bool - True if at least one part contains a prime number, otherwise False. >>> has_prime_in_parts(9, 3) == True >>> has_prime_in_parts(10, 2) == True >>> has_prime_in_parts(4, 4) == True >>> has_prime_in_parts(4, 2) == True >>> has_prime_in_parts(4, 1) == True >>> has_prime_in_parts(1, 1) == False >>> has_prime_in_parts(25, 5) == True >>> has_prime_in_parts(100, 10) == True >>> has_prime_in_parts(50, 10) == True pass","solution":"def is_prime(x): Helper function that determines if a number is prime. if x <= 1: return False if x <= 3: return True if x % 2 == 0 or x % 3 == 0: return False i = 5 while i * i <= x: if x % i == 0 or x % (i + 2) == 0: return False i += 6 return True def has_prime_in_parts(n, k): Determine if there is at least one part containing a prime number when the cards numbered 1 to n are divided into k parts. Args: n : int - Total number of cards. k : int - Number of parts to divide the cards into. Returns: bool - True if at least one part contains a prime number, otherwise False. part_size = n // k has_prime = False for i in range(k): start = i * part_size + 1 end = start + part_size for num in range(start, end): if is_prime(num): has_prime = True break if has_prime: break return has_prime"},{"question":"from datetime import datetime from typing import List, Dict, Tuple def process_transactions(transactions: List[Tuple[str, str, float]], start_date: str, end_date: str) -> Dict[str, float]: Processes a list of transactions and returns a summary report for a specified date range. Args: transactions (List[Tuple[str, str, float]]): A list of tuples representing transactions. start_date (str): The start date in YYYY-MM-DD format. end_date (str): The end date in YYYY-MM-DD format. Returns: Dict[str, float]: A dictionary containing the total number of transactions, total amount, and average transaction amount. Raises: ValueError: If the start date is later than the end date or if a date is not in the format YYYY-MM-DD. >>> transactions = [ ... (\\"2023-01-01\\", \\"T1001\\", 150.0), ... (\\"2023-01-02\\", \\"T1002\\", 200.0), ... (\\"2023-01-03\\", \\"T1003\\", 50.0), ... (\\"2023-01-04\\", \\"T1004\\", 300.0), ... (\\"2023-01-05\\", \\"T1005\\", 100.0) ... ] >>> start_date = \\"2023-01-02\\" >>> end_date = \\"2023-01-04\\" >>> process_transactions(transactions, start_date, end_date) {'total_transactions': 3, 'total_amount': 550.0, 'average_amount': 183.33} # Unit tests def test_process_transactions_normal_case(): transactions = [ (\\"2023-01-01\\", \\"T1001\\", 150.0), (\\"2023-01-02\\", \\"T1002\\", 200.0), (\\"2023-01-03\\", \\"T1003\\", 50.0), (\\"2023-01-04\\", \\"T1004\\", 300.0), (\\"2023-01-05\\", \\"T1005\\", 100.0) ] start_date = \\"2023-01-02\\" end_date = \\"2023-01-04\\" result = process_transactions(transactions, start_date, end_date) expected = { 'total_transactions': 3, 'total_amount': 550.0, 'average_amount': 183.33 } assert result == expected def test_process_transactions_no_transactions_in_range(): transactions = [ (\\"2023-01-01\\", \\"T1001\\", 150.0), (\\"2023-01-02\\", \\"T1002\\", 200.0), ] start_date = \\"2023-01-03\\" end_date = \\"2023-01-04\\" result = process_transactions(transactions, start_date, end_date) expected = { 'total_transactions': 0, 'total_amount': 0.0, 'average_amount': 0.0 } assert result == expected def test_process_transactions_single_transaction(): transactions = [ (\\"2023-01-01\\", \\"T1001\\", 150.0), ] start_date = \\"2023-01-01\\" end_date = \\"2023-01-01\\" result = process_transactions(transactions, start_date, end_date) expected = { 'total_transactions': 1, 'total_amount': 150.0, 'average_amount': 150.0 } assert result == expected def test_process_transactions_invalid_date_format(): transactions = [ (\\"2023-01-01\\", \\"T1001\\", 150.0), ] start_date = \\"2023-01-01\\" end_date = \\"20230101\\" try: result = process_transactions(transactions, start_date, end_date) except ValueError as e: assert str(e) == \\"Invalid date format. Please use YYYY-MM-DD format.\\" def test_process_transactions_start_date_after_end_date(): transactions = [ (\\"2023-01-01\\", \\"T1001\\", 150.0), ] start_date = \\"2023-01-02\\" end_date = \\"2023-01-01\\" try: result = process_transactions(transactions, start_date, end_date) except ValueError as e: assert str(e) == \\"Start date cannot be later than end date.\\"","solution":"from datetime import datetime from typing import List, Dict, Tuple def process_transactions(transactions: List[Tuple[str, str, float]], start_date: str, end_date: str) -> Dict[str, float]: Processes a list of transactions and returns a summary report for a specified date range. Args: transactions (List[Tuple[str, str, float]]): A list of tuples representing transactions. start_date (str): The start date in YYYY-MM-DD format. end_date (str): The end date in YYYY-MM-DD format. Returns: Dict[str, float]: A dictionary containing the total number of transactions, total amount, and average transaction amount. try: start_date_obj = datetime.strptime(start_date, \\"%Y-%m-%d\\") end_date_obj = datetime.strptime(end_date, \\"%Y-%m-%d\\") except ValueError: raise ValueError(\\"Invalid date format. Please use YYYY-MM-DD format.\\") if start_date_obj > end_date_obj: raise ValueError(\\"Start date cannot be later than end date.\\") total_transactions = 0 total_amount = 0.0 for transaction in transactions: transaction_date, transaction_id, amount = transaction transaction_date_obj = datetime.strptime(transaction_date, \\"%Y-%m-%d\\") if start_date_obj <= transaction_date_obj <= end_date_obj: total_transactions += 1 total_amount += amount if total_transactions == 0: average_amount = 0.0 else: average_amount = total_amount / total_transactions return { \\"total_transactions\\": total_transactions, \\"total_amount\\": round(total_amount, 2), \\"average_amount\\": round(average_amount, 2) }"},{"question":"def longestLetterSubstring(s: str) -> int: Given a string containing a mix of letters and numbers, find the longest substring that consists of only letters and return its length. If there are multiple substrings with the same length, return the length of the first one found. >>> longestLetterSubstring(\\"abc123def45gh\\") 3 >>> longestLetterSubstring(\\"abc123abcd\\") 4 >>> longestLetterSubstring(\\"123abcdefg45hij\\") 7","solution":"def longestLetterSubstring(s): Given a string containing a mix of letters and numbers, find the longest substring that consists of only letters and return its length. If there are multiple substrings with the same length, return the length of the first one found. max_length = 0 current_length = 0 for char in s: if char.isalpha(): current_length += 1 if current_length > max_length: max_length = current_length else: current_length = 0 return max_length"},{"question":"from typing import List def is_subsequence_present(spellbook: List[str]) -> bool: Determines if there exists any pair of spells such that one spell is a subsequence of another spell in the same book. :param spellbook: List of strings representing the spells in the spellbook. :return: True if there is a pair of spells where one is a subsequence of another, otherwise False. Examples: >>> is_subsequence_present([\\"abc\\", \\"ac\\", \\"bca\\", \\"def\\"]) True >>> is_subsequence_present([\\"abc\\", \\"def\\", \\"ghi\\"]) False","solution":"def is_subsequence_present(spellbook): Determines if there exists any pair of spells such that one spell is a subsequence of another spell in the same book. :param spellbook: List of strings representing the spells in the spellbook. :return: True if there is a pair of spells where one is a subsequence of another, otherwise False. def is_subsequence(s1, s2): Helper function to check if s1 is a subsequence of s2. iter_s2 = iter(s2) return all(char in iter_s2 for char in s1) n = len(spellbook) for i in range(n): for j in range(n): if i != j: if is_subsequence(spellbook[i], spellbook[j]) or is_subsequence(spellbook[j], spellbook[i]): return True return False"},{"question":"def findLongestWord(words: List[str]) -> str: Write a function named \`findLongestWord\` that takes a list of strings as a parameter. Your function should return the longest string in the list. If there are multiple strings with the same longest length, return the first one found. :param words: List of strings :return: Longest string in the list >>> findLongestWord([\\"apple\\", \\"banana\\", \\"pear\\", \\"grapefruit\\", \\"kiwi\\"]) == \\"grapefruit\\" >>> findLongestWord([\\"grapefruit\\", \\"apple\\", \\"pear\\"]) == \\"grapefruit\\" >>> findLongestWord([\\"apple\\", \\"banana\\", \\"peach\\", \\"grapefruit\\"]) == \\"grapefruit\\" >>> findLongestWord([]) == \\"\\" >>> findLongestWord([\\"kiwi\\", \\"banana\\", \\"apple\\"]) == \\"banana\\"","solution":"def findLongestWord(words): Returns the longest string in the list. If there are multiple strings with the same longest length, returns the first one found. :param words: List of strings :return: Longest string in the list if not words: return \\"\\" longest_word = words[0] for word in words: if len(word) > len(longest_word): longest_word = word return longest_word"},{"question":"from typing import Dict, List from urllib.parse import urlparse, parse_qs def parse_url_params(url: str) -> Dict[str, List[str]]: Parses the query parameters from a URL and returns them as a dictionary. Each key in the dictionary corresponds to a parameter name, and the value is a list of values associated with that parameter. >>> parse_url_params(\\"https://example.com/page?name=John&age=25&name=Doe&city=NewYork&city=LosAngeles\\") {'name': ['John', 'Doe'], 'age': ['25'], 'city': ['NewYork', 'LosAngeles']} >>> parse_url_params(\\"https://example.com/page?name=John\\") {'name': ['John']} >>> parse_url_params(\\"https://example.com/page?name=John&age=25\\") {'name': ['John'], 'age': ['25']} >>> parse_url_params(\\"https://example.com/page?name=John&name=Doe\\") {'name': ['John', 'Doe']} >>> parse_url_params(\\"https://example.com/page\\") {}","solution":"from urllib.parse import urlparse, parse_qs def parse_url_params(url): Parses the query parameters from a URL and returns them as a dictionary. Each key in the dictionary corresponds to a parameter name, and the value is a list of values associated with that parameter. Args: url (str): The URL containing the query parameters. Returns: dict: A dictionary with parameter names as keys and lists of parameter values as values. parsed_url = urlparse(url) return parse_qs(parsed_url.query)"},{"question":"def total_food_supplies(test_cases: list) -> list: Calculates total food supplies required for each test case. Args: test_cases (list): List of tuples with (D, consumption_rates) Returns: list: List of total food supplies required for each test case. # Test cases for total_food_supplies function def test_sample_input(): test_cases = [ (3, [2, 3, 4]), (5, [1, 2, 3, 4, 5]) ] assert total_food_supplies(test_cases) == [27, 75] def test_single_day(): test_cases = [ (1, [1, 1, 1]), (1, [10, 10, 10]) ] assert total_food_supplies(test_cases) == [3, 30] def test_single_member(): test_cases = [ (5, [1]), (10, [5]) ] assert total_food_supplies(test_cases) == [5, 50] def test_multiple_members_same_consumption(): test_cases = [ (2, [3, 3, 3]), (4, [2, 2, 2, 2]) ] assert total_food_supplies(test_cases) == [18, 32] def test_varied_days_consumption(): test_cases = [ (3, [6, 2, 1]), (7, [1, 1, 1, 1, 1, 1, 1, 1]) ] assert total_food_supplies(test_cases) == [27, 56]","solution":"def total_food_supplies(test_cases): Calculates total food supplies required for each test case. Args: test_cases (list): List of tuples with (D, consumption_rates) Returns: list: List of total food supplies required for each test case. results = [] for D, consumption_rates in test_cases: total_food = D * sum(consumption_rates) results.append(total_food) return results"},{"question":"def combine_strings_alternatingly(str1: str, str2: str) -> str: Combines two strings by alternatingly taking characters from each string. If one string is longer than the other, append the remaining characters of the longer string to the result. >>> combine_strings_alternatingly('abcdef', '123') == 'a1b2c3def' >>> combine_strings_alternatingly('abc', '123456') == 'a1b2c3456' >>> combine_strings_alternatingly('abc', 'xyz') == 'axbycz' >>> combine_strings_alternatingly('', '') == '' >>> combine_strings_alternatingly('', 'abc') == 'abc' >>> combine_strings_alternatingly('abc', '') == 'abc'","solution":"def combine_strings_alternatingly(str1, str2): Combines two strings by alternatingly taking characters from each string. If one string is longer than the other, append the remaining characters of the longer string to the result. combined = [] len1, len2 = len(str1), len(str2) # Iterate through the characters of both strings for i in range(max(len1, len2)): if i < len1: combined.append(str1[i]) if i < len2: combined.append(str2[i]) return ''.join(combined)"},{"question":"def is_rearrangement_possible(ids: List[int]) -> bool: Determines if it's possible to rearrange IDs to follow either ascending or descending order. >>> is_rearrangement_possible([4, 3, 1, 2]) True >>> is_rearrangement_possible([10, 12, 11, 14]) False >>> is_rearrangement_possible([3, 2, 1]) True","solution":"def is_rearrangement_possible(ids): Determines if it's possible to rearrange IDs to follow either ascending or descending order. n = len(ids) sorted_ids = sorted(ids) # Check for ascending order ascending_possible = all(sorted_ids[i] + 1 == sorted_ids[i+1] for i in range(n-1)) # Check for descending order descending_possible = all(sorted_ids[i] - 1 == sorted_ids[i+1] for i in range(n-1)) return ascending_possible or descending_possible"},{"question":"def is_palindrome(input_string: str) -> bool: Determines whether a given string, which only contains lowercase letters and spaces, is a palindrome. Args: input_string (str): The input string containing lowercase letters and spaces. Returns: bool: True if the input string is a palindrome, False otherwise. Examples: >>> is_palindrome(\\"racecar\\") True >>> is_palindrome(\\"hello\\") False >>> is_palindrome(\\"madam\\") True >>> is_palindrome(\\"step on no pets\\") True","solution":"def is_palindrome(input_string: str) -> bool: Determines whether the given string is a palindrome. Args: input_string (str): The input string containing lowercase letters and spaces. Returns: bool: True if the input string is a palindrome, False otherwise. # Remove spaces from the input string clean_string = ''.join(input_string.split()) # Check if the cleaned string reads the same forward and backward return clean_string == clean_string[::-1]"},{"question":"from typing import List def subarray_sum(nums: List[int], k: int) -> int: Returns the total number of subarrays whose sum equals to k. >>> subarray_sum([1, 1, 1], 2) 2 >>> subarray_sum([1, 2, 3], 3) 2 >>> subarray_sum([1, 2, 3], 7) 0 >>> subarray_sum([1, -1, 1, -1], 0) 4 >>> subarray_sum([3], 3) 1 >>> subarray_sum([3], 2) 0","solution":"from typing import List def subarray_sum(nums: List[int], k: int) -> int: Returns the total number of subarrays whose sum equals to k. count = 0 current_sum = 0 prefix_sums = {0: 1} for num in nums: current_sum += num if (current_sum - k) in prefix_sums: count += prefix_sums[current_sum - k] if current_sum in prefix_sums: prefix_sums[current_sum] += 1 else: prefix_sums[current_sum] = 1 return count"},{"question":"def most_frequent_word(s: str) -> str: Given a string containing words separated by single spaces, find the word that appears the most frequently. If there are multiple such words with the same highest frequency, return the lexicographically smallest one. >>> most_frequent_word(\\"apple banana apple apple banana banana orange apple\\") 'apple' >>> most_frequent_word(\\"cat dog cat elephant dog dog\\") 'dog' >>> most_frequent_word(\\"zebra apple apple banana zebra zebra\\") 'apple'","solution":"def most_frequent_word(s): Returns the most frequent word in the string s. If there is a tie, returns the lexicographically smallest word. words = s.split() word_count = {} for word in words: if word in word_count: word_count[word] += 1 else: word_count[word] = 1 max_count = max(word_count.values()) most_frequent_words = [word for word, count in word_count.items() if count == max_count] return min(most_frequent_words)"},{"question":"def generate_rug(n): Generates an n x n grid where the numbers in the cells represent the Manhattan distance of that cell from the center. Assumes that n is always an odd number. >>> generate_rug(1) [[0]] >>> generate_rug(3) [[2, 1, 2], [1, 0, 1], [2, 1, 2]] >>> generate_rug(5) [[4, 3, 2, 3, 4], [3, 2, 1, 2, 3], [2, 1, 0, 1, 2], [3, 2, 1, 2, 3], [4, 3, 2, 3, 4]] >>> generate_rug(4) [[3, 3, 3, 3], [3, 2, 2, 3], [3, 2, 2, 3], [3, 3, 3, 3]]","solution":"def generate_rug(n): Generates an n x n grid where the numbers in the cells represent the Manhattan distance of that cell from the center. Assumes that n is always an odd number. center = n // 2 # Find the center of the rug rug = [] for i in range(n): row = [] for j in range(n): distance = abs(i - center) + abs(j - center) row.append(distance) rug.append(row) return rug"},{"question":"def compare_dicts(dict1: dict, dict2: dict) -> dict: Takes in two dictionaries and returns a new dictionary with the combined keys from both dictionaries. If key exists in both dictionaries, values from dict2 take precedence. Each value in the output dictionary is a list in the format [value_from_dict1, value_from_dict2], with missing values denoted as None. The output dictionary is sorted by keys in ascending order. >>> compare_dicts({\\"a\\": 1, \\"b\\": 2, \\"d\\": 4}, {\\"b\\": 3, \\"c\\": 5, \\"d\\": 6}) {\\"a\\": [1, None], \\"b\\": [2, 3], \\"c\\": [None, 5], \\"d\\": [4, 6]} >>> compare_dicts({\\"x\\": 10, \\"y\\": 9}, {\\"y\\": 20, \\"z\\": 30}) {\\"x\\": [10, None], \\"y\\": [9, 20], \\"z\\": [None, 30]} >>> compare_dicts({\\"a\\": 1, \\"b\\": 2}, {\\"c\\": 3, \\"d\\": 4}) {\\"a\\": [1, None], \\"b\\": [2, None], \\"c\\": [None, 3], \\"d\\": [None, 4]} >>> compare_dicts({}, {\\"a\\": 1}) {\\"a\\": [None, 1]} >>> compare_dicts({\\"a\\": 1}, {}) {\\"a\\": [1, None]}","solution":"def compare_dicts(dict1, dict2): Combine two dictionaries, preserving the order of keys, and return a dictionary with values from both dictionaries in lists. combined_keys = sorted(set(dict1.keys()).union(dict2.keys())) result = {} for key in combined_keys: value1 = dict1.get(key) value2 = dict2.get(key) result[key] = [value1, value2] return result"},{"question":"class Calculator: Simulates a basic calculator with memory operations. The calculator can perform addition, subtraction, multiplication, and division. It also supports memory functions like store, recall, and reset. Methods: add(x, y) subtract(x, y) multiply(x, y) divide(x, y) store(value) recall() reset() >>> calc = Calculator() >>> calc.add(5, 3) 8 >>> calc.subtract(5, 3) 2 >>> calc.multiply(5, 3) 15 >>> calc.divide(6, 3) 2.0 >>> calc.divide(6, 0) \\"Error! Division by zero.\\" >>> calc.store(100) >>> calc.recall() 100 >>> calc.reset() >>> calc.recall() 0","solution":"class Calculator: def __init__(self): self.memory = 0 def add(self, x, y): return x + y def subtract(self, x, y): return x - y def multiply(self, x, y): return x * y def divide(self, x, y): if y == 0: return \\"Error! Division by zero.\\" return x / y def store(self, value): self.memory = value def recall(self): return self.memory def reset(self): self.memory = 0"},{"question":"def is_palindrome(s: str) -> bool: Determines if a given string is a palindrome. A palindrome is a word, phrase, or sequence that reads the same backward as forward, disregarding spaces and case sensitivity. Args: s (str): the string to check. Returns: bool: True if the string is a palindrome, otherwise False. >>> is_palindrome('A man a plan a canal Panama') True >>> is_palindrome('racecar') True >>> is_palindrome('hello') False >>> is_palindrome('') True >>> is_palindrome('Madam') True >>> is_palindrome('No lemon, no melon!') False","solution":"def is_palindrome(s): Determines if a given string is a palindrome. A palindrome is a word, phrase, or sequence that reads the same backward as forward, disregarding spaces and case sensitivity. Args: s (str): the string to check. Returns: bool: True if the string is a palindrome, otherwise False. s = s.lower().replace(' ', '') return s == s[::-1]"},{"question":"from typing import List def has_pair_with_sum(lst: List[int], target: int) -> bool: Returns True if there are two distinct numbers in the list that add up to the target. Returns False otherwise. Examples: >>> has_pair_with_sum([1, 2, 4, 4], 8) True >>> has_pair_with_sum([1, 2, 3, 9], 8) False Unit Test: def test_has_pair_with_sum_positive_case(): assert has_pair_with_sum([1, 2, 4, 4], 8) == True def test_has_pair_with_sum_negative_case(): assert has_pair_with_sum([1, 2, 3, 9], 8) == False def test_has_pair_with_sum_empty_list(): assert has_pair_with_sum([], 8) == False def test_has_pair_with_sum_single_element_list(): assert has_pair_with_sum([4], 8) == False def test_has_pair_with_sum_with_negative_numbers(): assert has_pair_with_sum([-1, 2, -4, 5], 1) == True def test_has_pair_with_sum_mixed_sign_numbers(): assert has_pair_with_sum([-1, -2, 3, 4], 2) == True def test_has_pair_with_sum_no_pair(): assert has_pair_with_sum([1, 2, 3, 4, 5, 6], 20) == False","solution":"def has_pair_with_sum(lst, target): Returns True if there are two distinct numbers in lst that add up to target. Returns False otherwise. seen = set() for number in lst: if target - number in seen: return True seen.add(number) return False"},{"question":"def is_anagram_of_palindrome(s): Check if a given string is an anagram of a palindrome. :param s: Input string :return: True if the string is an anagram of a palindrome, otherwise False. If the input is not a valid string, return \\"Not valid\\". >>> is_anagram_of_palindrome(\\"civic\\") True >>> is_anagram_of_palindrome(\\"ivicc\\") True >>> is_anagram_of_palindrome(\\"racecar\\") True >>> is_anagram_of_palindrome(\\"racerac\\") True >>> is_anagram_of_palindrome(\\"hello\\") False >>> is_anagram_of_palindrome(12345) \\"Not valid\\" >>> is_anagram_of_palindrome(\\"\\") \\"Not valid\\" >>> is_anagram_of_palindrome(None) \\"Not valid\\" >>> is_anagram_of_palindrome([]) \\"Not valid\\" >>> is_anagram_of_palindrome({}) \\"Not valid\\" >>> is_anagram_of_palindrome(True) \\"Not valid\\" >>> is_anagram_of_palindrome(12.34) \\"Not valid\\"","solution":"def is_anagram_of_palindrome(s): Check if a given string is an anagram of a palindrome. :param s: Input string :return: True if the string is an anagram of a palindrome, otherwise False. If the input is not a valid string, return \\"Not valid\\". if not isinstance(s, str) or not s: return \\"Not valid\\" from collections import Counter count = Counter(s) odd_count = sum(1 for value in count.values() if value % 2 != 0) return odd_count <= 1"},{"question":"import heapq from typing import List def min_cost_path(n: int, m: int, k: int, grid: List[List[str]], cost: List[List[int]], sx: int, sy: int, dx: int, dy: int) -> int: Compute the minimum cost to reach the destination cell from the starting cell. :param n: Number of rows in the grid :param m: Number of columns in the grid :param k: Number of obstacles in the grid :param grid: A grid representation with walkable cells ('.') and obstacles ('#') :param cost: A grid representation of the cost of stepping into each cell :param sx: Starting cell row index (1-based) :param sy: Starting cell column index (1-based) :param dx: Destination cell row index (1-based) :param dy: Destination cell column index (1-based) :return: Minimum cost to reach destination or -1 if impossible >>> n = 3 >>> m = 3 >>> k = 2 >>> grid = [['.', '.', '.'], ['.', '#', '.'], ['#', '.', '.']] >>> cost = [[1, 1, 1], [2, 0, 2], [3, 3, 3]] >>> sx, sy, dx, dy = 1, 1, 3, 3 >>> min_cost_path(n, m, k, grid, cost, sx, sy, dx, dy) 7 >>> n = 2 >>> m = 2 >>> k = 1 >>> grid = [['.', '#'], ['.', '.']] >>> cost = [[1, 1], [2, 1]] >>> sx, sy, dx, dy = 1, 1, 2, 2 >>> min_cost_path(n, m, k, grid, cost, sx, sy, dx, dy) 3 >>> n = 2 >>> m = 2 >>> k = 1 >>> grid = [['.', '#'], ['#', '.']] >>> cost = [[1, 1], [1, 1]] >>> sx, sy, dx, dy = 1, 1, 2, 2 >>> min_cost_path(n, m, k, grid, cost, sx, sy, dx, dy) -1","solution":"import heapq def min_cost_path(n, m, k, grid, cost, sx, sy, dx, dy): # Coordinate transformation to 0-based indexing sx, sy, dx, dy = sx - 1, sy - 1, dx - 1, dy - 1 # Priority queue for Dijkstra's algorithm pq = [(0, sx, sy)] # Distance matrix initialized to infinity dist = [[float('inf')] * m for _ in range(n)] dist[sx][sy] = 0 # Directions for moving up, down, left, and right directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] while pq: current_cost, x, y = heapq.heappop(pq) # If reached destination cell if x == dx and y == dy: return current_cost # Explore neighbors for direction in directions: nx, ny = x + direction[0], y + direction[1] if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == '.': new_cost = current_cost + cost[nx][ny] if new_cost < dist[nx][ny]: dist[nx][ny] = new_cost heapq.heappush(pq, (new_cost, nx, ny)) return -1 if dist[dx][dy] == float('inf') else dist[dx][dy]"},{"question":"def melodic_sequences(n: int, frequencies: List[int]) -> Tuple[int, int]: This function calculates the total number of melodic sequences and the maximum value among all possible combinations of the notes. :param n: An integer representing the number of unique notes. :param frequencies: A list of integers representing the frequencies of the notes. :return: A tuple containing the total number of melodic sequences and the maximum value. >>> melodic_sequences(3, [1, 2, 3]) (7, 6) >>> melodic_sequences(4, [2, 3, 5, 7]) (15, 17)","solution":"from itertools import chain, combinations def melodic_sequences(n, frequencies): This function calculates the total number of melodic sequences and the maximum value among all possible combinations of the notes. :param n: An integer representing the number of unique notes. :param frequencies: A list of integers representing the frequencies of the notes. :return: A tuple containing the total number of melodic sequences and the maximum value. # Helper function to get all non-empty subsets of a list def all_subsets(lst): # chain.from_iterable(combinations(lst, r) for r in range(1, len(lst) + 1)) subsets = chain.from_iterable(combinations(lst, r) for r in range(1, len(lst) + 1)) return subsets # Get all non-empty subsets of frequencies subsets = all_subsets(frequencies) # Compute the number of subsets (melodic sequences) total_sequences = 2**n - 1 # Compute the maximum value by summing all the frequencies max_value = sum(frequencies) return total_sequences, max_value"},{"question":"def evaluate_expression(expression: str) -> float: Evaluates a mathematical expression containing +, -, *, / operators and parentheses. Parameters: expression (str): The mathematical expression as a string. Returns: float: The result of the expression. >>> evaluate_expression(\\"2 + (3 * 4) - 6 / (1 + 1)\\") 12.0 >>> evaluate_expression(\\"2 + 3 * 4\\") 14.0 >>> evaluate_expression(\\"2 + (3 * (4 - 1))\\") 11.0 >>> evaluate_expression(\\"0.1 + 0.2 * 3\\") 0.7000000000000001","solution":"def evaluate_expression(expression): Evaluates a mathematical expression containing +, -, *, / operators and parentheses. Parameters: expression (str): The mathematical expression as a string. Returns: float: The result of the expression. try: # We can use the eval function in a controlled manner result = eval(expression, {\\"__builtins__\\": None}, {}) return float(result) except (SyntaxError, NameError, ZeroDivisionError) as e: raise ValueError(f\\"Invalid expression: {str(e)}\\")"},{"question":"from typing import List def multiples_of_3_or_5(n: int) -> List[int]: Returns a list of all positive integers less than n that are multiples of either 3 or 5. >>> multiples_of_3_or_5(10) [3, 5, 6, 9] >>> multiples_of_3_or_5(20) [3, 5, 6, 9, 10, 12, 15, 18] >>> multiples_of_3_or_5(5) [3] >>> multiples_of_3_or_5(15) [3, 5, 6, 9, 10, 12]","solution":"def multiples_of_3_or_5(n): Returns a list of all positive integers less than n that are multiples of either 3 or 5. return [i for i in range(1, n) if i % 3 == 0 or i % 5 == 0]"},{"question":"def min_sum_after_reversals(arr: List[int], k: int) -> int: Returns the minimum sum of the array after performing at most \`k\` reversals. Parameters: arr (list): List of integers, containing unique integers from 1 to n. k (int): Maximum number of reversals that can be performed. Returns: int: The minimum possible sum of the array after performing at most \`k\` reversals. >>> min_sum_after_reversals([4, 3, 1, 2, 5], 2) 15 >>> min_sum_after_reversals([1, 2, 3, 4, 5], 1) 15 from solution import min_sum_after_reversals def test_example_1(): assert min_sum_after_reversals([4, 3, 1, 2, 5], 2) == 15 def test_example_2(): assert min_sum_after_reversals([1, 2, 3, 4, 5], 1) == 15 def test_single_element(): assert min_sum_after_reversals([1], 1) == 1 def test_already_sorted(): assert min_sum_after_reversals([1, 2, 3, 4, 5], 3) == 15 def test_reverse_whole_array(): assert min_sum_after_reversals([5, 4, 3, 2, 1], 1) == 15 def test_reverse_part_of_array(): assert min_sum_after_reversals([2, 3, 1, 5, 4], 2) == 15 def test_partial_reversals(): assert min_sum_after_reversals([4, 3, 2, 1, 5], 1) == 15 def test_zero_reversals(): assert min_sum_after_reversals([4, 3, 2, 1, 5], 0) == 15","solution":"def min_sum_after_reversals(arr, k): Returns the minimum sum of the array after performing at most \`k\` reversals. Parameters: arr (list): List of integers, containing unique integers from 1 to n. k (int): Maximum number of reversals that can be performed. Returns: int: The minimum possible sum of the array after performing at most \`k\` reversals. # The minimum sum of the array occurs when the array is sorted in ascending order. n = len(arr) sorted_arr = sorted(arr) # If we can sort the array by using k reversals, return the sum of the sorted array. if k >= n: return sum(sorted_arr) # Try to sort parts of the array using the reversals allowed. for _ in range(k): # Find the first position where the current array differs from the sorted array i = 0 while i < n and arr[i] == sorted_arr[i]: i += 1 # If the array is already sorted, we are done if i == n: break # Find the position where the current array matches the sorted array again j = i while j < n and arr[j] != sorted_arr[i]: j += 1 # Reverse the subarray to make the first part of the array sorted arr[i:j+1] = reversed(arr[i:j+1]) return sum(arr)"},{"question":"def min_operations_to_transform(A: str, B: str) -> int: Compute the minimum number of operations required to transform string A into string B. The allowed operations are insert, delete, and replace a character. >>> min_operations_to_transform(\\"abc\\", \\"abcd\\") 1 >>> min_operations_to_transform(\\"abcdef\\", \\"abc\\") 3 >>> min_operations_to_transform(\\"abcdef\\", \\"fedcba\\") 6 >>> min_operations_to_transform(\\"\\", \\"a\\") 1 >>> min_operations_to_transform(\\"a\\", \\"\\") 1 >>> min_operations_to_transform(\\"same\\", \\"same\\") 0 def process_test_cases(T: int, cases: [(str, str)]) -> [int]: Process multiple test cases to compute the minimum number of operations for each case. >>> process_test_cases(3, [(\\"abc\\", \\"abcd\\"), (\\"abcdef\\", \\"abc\\"), (\\"abcdef\\", \\"fedcba\\")]) [1, 3, 6] >>> process_test_cases(2, [(\\"\\", \\"a\\"), (\\"\\", \\"hello\\")]) [1, 5] >>> process_test_cases(2, [(\\"a\\", \\"\\"), (\\"hello\\", \\"\\")]) [1, 5] >>> process_test_cases(2, [(\\"same\\", \\"same\\"), (\\"python\\", \\"python\\")]) [0, 0] >>> process_test_cases(1, [(\\"delete\\", \\"\\")]) [6] >>> process_test_cases(1, [(\\"\\", \\"insert\\")]) [6]","solution":"def min_operations_to_transform(A, B): Compute the minimum number of operations required to transform string A into string B. The allowed operations are insert, delete, and replace a character. This is essentially the Edit Distance (Levenshtein distance) problem. len_a, len_b = len(A), len(B) # Create a (len_a+1) x (len_b+1) DP table dp = [[0] * (len_b + 1) for _ in range(len_a + 1)] # Initialize the table for i in range(len_a + 1): dp[i][0] = i # Cost of deleting all characters in A to get an empty string for j in range(len_b + 1): dp[0][j] = j # Cost of inserting all characters of B into an empty string # Fill the DP table for i in range(1, len_a + 1): for j in range(1, len_b + 1): if A[i - 1] == B[j - 1]: dp[i][j] = dp[i - 1][j - 1] # No operation needed else: dp[i][j] = min( dp[i - 1][j] + 1, # Deletion dp[i][j - 1] + 1, # Insertion dp[i - 1][j - 1] + 1 # Replacement ) return dp[len_a][len_b] def process_test_cases(T, cases): results = [] for A, B in cases: results.append(min_operations_to_transform(A, B)) return results"},{"question":"from typing import List def length_of_longest_AP(arr: List[int]) -> int: Given an array of integers, find the length of the longest subsequence such that all elements of the subsequence are in an arithmetic progression. Parameters: arr (List[int]): The input list of integers Returns: int: The length of the longest arithmetic progression subsequence >>> length_of_longest_AP([1, 7, 10, 15, 27, 29]) 3 >>> length_of_longest_AP([1, 3, 5, 7, 9]) 5 pass def test_case_1(): arr = [1, 7, 10, 15, 27, 29] assert length_of_longest_AP(arr) == 3 def test_case_2(): arr = [1, 3, 5, 7, 9] assert length_of_longest_AP(arr) == 5 def test_case_3(): arr = [5, 10, 15, 20, 25, 30] assert length_of_longest_AP(arr) == 6 def test_case_4(): arr = [9, 4, 7, 2, 10] assert length_of_longest_AP(arr) == 3 def test_case_5(): arr = [3, 6, 9, 12] assert length_of_longest_AP(arr) == 4 def test_case_6(): arr = [1, 5] assert length_of_longest_AP(arr) == 2 def test_case_7(): arr = [1] assert length_of_longest_AP(arr) == 1","solution":"def length_of_longest_AP(arr): Returns the length of the longest arithmetic progression subsequence in the array. N = len(arr) if N <= 2: return N arr.sort() L = [[2 for _ in range(N)] for _ in range(N)] llap = 2 # Longest Length of AP; minimum is 2 (first two numbers) for j in range(N-2, 0, -1): i = j-1 k = j+1 while i >= 0 and k <= N-1: if arr[i] + arr[k] < 2 * arr[j]: k += 1 elif arr[i] + arr[k] > 2 * arr[j]: L[i][j] = 2 i -= 1 else: L[i][j] = L[j][k] + 1 llap = max(llap, L[i][j]) i -= 1 k += 1 while i >= 0: L[i][j] = 2 i -= 1 return llap"},{"question":"from typing import List def rotate_clockwise(matrix: List[List[int]]) -> List[List[int]]: Rotates a square matrix 90 degrees clockwise. Example: >>> rotate_clockwise([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_clockwise([ ... [1, 2], ... [3, 4] ... ]) [[3, 1], [4, 2]] >>> rotate_clockwise([ ... [1] ... ]) [[1]] >>> rotate_clockwise([ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16] ... ]) [[13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4]] >>> rotate_clockwise([]) []","solution":"def rotate_clockwise(matrix): Rotates a square matrix 90 degrees clockwise. :param matrix: List[List[int]], the input square matrix :return: List[List[int]], the rotated matrix n = len(matrix) rotated_matrix = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated_matrix[j][n - 1 - i] = matrix[i][j] return rotated_matrix"},{"question":"def length_of_longest_substring_two_distinct(s: str) -> int: Returns the length of the longest substring with at most two distinct characters. >>> length_of_longest_substring_two_distinct(\\"eceba\\") 3 >>> length_of_longest_substring_two_distinct(\\"ccaabbb\\") 5 >>> length_of_longest_substring_two_distinct(\\"abcabcabc\\") 2 pass def process_test_cases(t: int, test_cases: List[str]) -> List[int]: For multiple test cases, returns a list of lengths of the longest substring that contains at most two distinct characters for each string in the test cases. >>> process_test_cases(3, [\\"eceba\\", \\"ccaabbb\\", \\"abcabcabc\\"]) [3, 5, 2] pass","solution":"def length_of_longest_substring_two_distinct(s): Returns the length of the longest substring with at most two distinct characters. if len(s) < 3: return len(s) left, right = 0, 0 hashmap = {} max_len = 2 while right < len(s): hashmap[s[right]] = right right += 1 if len(hashmap) == 3: del_idx = min(hashmap.values()) del hashmap[s[del_idx]] left = del_idx + 1 max_len = max(max_len, right - left) return max_len def process_test_cases(t, test_cases): results = [] for s in test_cases: results.append(length_of_longest_substring_two_distinct(s)) return results"},{"question":"def contains_all_vowels(s: str) -> bool: Returns True if the input string contains every vowel (a, e, i, o, u) at least once, ignoring case. Returns False if the input is not a string or is an empty string. Example: >>> contains_all_vowels(\\"Education\\") == True >>> contains_all_vowels(\\"Programming\\") == False","solution":"def contains_all_vowels(s): Returns True if the input string contains every vowel (a, e, i, o, u) at least once, ignoring case. Returns False if the input is not a string or is an empty string. if not isinstance(s, str) or not s: return False vowels = set('aeiou') return vowels.issubset(set(s.lower()))"},{"question":"def is_balanced_parentheses(s: str) -> bool: Checks whether the given string of parentheses is balanced. Ignores all characters other than parentheses. :param s: A string containing parentheses and other characters. :return: True if the parentheses are balanced, False otherwise. Examples: >>> is_balanced_parentheses(\\"((()))\\") True >>> is_balanced_parentheses(\\"(()\\") False >>> is_balanced_parentheses(\\"(a+b) * (c+d)\\") True >>> is_balanced_parentheses(\\")((\\") False","solution":"def is_balanced_parentheses(s: str) -> bool: Checks whether the given string of parentheses is balanced. Ignores all characters other than parentheses. :param s: A string containing parentheses and other characters. :return: True if the parentheses are balanced, False otherwise. stack = [] for char in s: if char == '(': stack.append(char) elif char == ')': if not stack: return False stack.pop() return not stack"},{"question":"from typing import List, Tuple def encode(message: str) -> List[Tuple[int, int]]: Encode a message into a unique sequence of domino tiles. Args: message (str): The message to encode. Returns: List[Tuple[int, int]]: The list of domino tiles encoding the message or None if invalid. Examples: >>> encode(\\"HELLO\\") [(0, 0), (0, 1), ..., (6, 6)] # Placeholder example >>> encode(\\"A9\\") [(0, 0), (0, 1), ..., (6, 6)] # Placeholder example >>> encode(\\"INVALID!\\") is None True >>> encode(\\"A\\" * 100) is None True def decode(dominoes: List[Tuple[int, int]]) -> str: Decode a unique sequence of domino tiles to get the hidden message. Args: dominoes (List[Tuple[int, int]]): The list of domino tiles to decode. Returns: str: The hidden message or None if invalid. Examples: >>> decode([(0, 0), (0, 1), ..., (6, 6)]) \\"HELLO\\" # Placeholder example >>> decode([(0, 0), (0, 1), ..., (6, 6)][:-1]) is None True >>> decode([(0, 0), (0, 0), ..., (6, 6)]) is None True","solution":"import math from functools import reduce def message_to_number(message): Convert message to a number base 36 base_36 = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" number = 0 for char in message: number = number * 36 + base_36.index(char) return number def number_to_message(number): Convert a number to a message base 36 base_36 = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" message = [] while number > 0: number, remainder = divmod(number, 36) message.append(base_36[remainder]) return ''.join(reversed(message)) def factorial(n): return reduce(lambda x, y: x * y, range(1, n + 1), 1) def encode(message): Encode a message into a sequence of domino tiles base_36 = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" set_of_tiles = [(i, j) for i in range(7) for j in range(i, 7)] # Check for invalid characters if any(char not in base_36 for char in message): return None # Convert message to numerical value msg_value = message_to_number(message) # Check if value exceeds 28! if msg_value >= factorial(len(set_of_tiles)): return None # Generate the permutation of tiles at the given index tiles = list(set_of_tiles) permutation = [] for i in range(len(tiles) - 1, -1, -1): j = msg_value // math.factorial(i) msg_value %= math.factorial(i) permutation.append(tiles.pop(j)) return permutation def decode(dominoes): Decode a sequence of domino tiles into the hidden message set_of_tiles = [(i, j) for i in range(7) for j in range(i, 7)] # Check for invalid tiles and duplicates if len(dominoes) != 28 or any(tile not in set_of_tiles for tile in dominoes) or len(set(dominoes)) != 28: return None # Calculate the index of the permutation tiles = list(set_of_tiles) permutation_index = 0 for i, tile in enumerate(dominoes): j = tiles.index(tile) permutation_index += j * math.factorial(len(tiles) - 1) tiles.pop(j) return number_to_message(permutation_index)"},{"question":"from typing import List def filter_primes(numbers: List[int]) -> List[int]: Create a function that takes a list of integers and returns a new list containing only the prime numbers from the original list. If the original list contains no prime numbers, the function should return an empty list. >>> filter_primes([2, 3, 5, 7, 11]) [2, 3, 5, 7, 11] >>> filter_primes([4, 6, 8, 10, 12]) [] >>> filter_primes([4, 5, 6, 7, 8, 9, 10, 11]) [5, 7, 11] >>> filter_primes([]) [] >>> filter_primes([-10, -7, 0, 1, 4, 6, 8]) [] >>> filter_primes([13, 17, 19, 23, 29, 31]) [13, 17, 19, 23, 29, 31]","solution":"def is_prime(n): Determines if a given number n is a prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def filter_primes(numbers): Takes a list of integers and returns a new list containing only the prime numbers from the original list. return [num for num in numbers if is_prime(num)]"},{"question":"def factorial_zeros(n: int) -> int: Returns the number of trailing zeros in the factorial of n. >>> factorial_zeros(5) 1 >>> factorial_zeros(10) 2 >>> factorial_zeros(30) 7 >>> factorial_zeros(50) 12 # Your code here pass def test_factorial_zeros_zero(): assert factorial_zeros(0) == 0 def test_factorial_zeros_single_digit(): assert factorial_zeros(5) == 1 assert factorial_zeros(9) == 1 def test_factorial_zeros_double_digits(): assert factorial_zeros(10) == 2 assert factorial_zeros(25) == 6 assert factorial_zeros(30) == 7 def test_factorial_zeros_large_numbers(): assert factorial_zeros(100) == 24 assert factorial_zeros(500) == 124 assert factorial_zeros(1000) == 249 assert factorial_zeros(10000) == 2499 def test_factorial_zeros_no_trailing_zero(): assert factorial_zeros(4) == 0 assert factorial_zeros(3) == 0","solution":"def factorial_zeros(n: int) -> int: Returns the number of trailing zeros in the factorial of n. count = 0 while n >= 5: n //= 5 count += n return count"},{"question":"def flatten_dictionary(d, parent_key='', sep='.'): Flattens a nested dictionary. Args: d (dict): The dictionary to flatten. parent_key (str): The base key to use when flattening (for recursive calls). sep (str): The separator to use between keys. Returns: dict: The flattened dictionary. def test_flatten_dictionary_simple(): input_dict = { 'key1': '1', 'key2': { 'key3': '3', 'key4': { 'key5': '5' } } } expected_output = { 'key1': '1', 'key2.key3': '3', 'key2.key4.key5': '5' } assert flatten_dictionary(input_dict) == expected_output def test_flatten_dictionary_empty(): input_dict = {} expected_output = {} assert flatten_dictionary(input_dict) == expected_output def test_flatten_dictionary_single_level(): input_dict = { 'a': '1', 'b': '2', 'c': '3' } expected_output = { 'a': '1', 'b': '2', 'c': '3' } assert flatten_dictionary(input_dict) == expected_output def test_flatten_dictionary_nested_empty_dict(): input_dict = { 'key1': {}, 'key2': { 'key3': {} } } expected_output = {} assert flatten_dictionary(input_dict) == expected_output def test_flatten_dictionary_multiple_levels(): input_dict = { 'a': { 'b': { 'c': { 'd': 'e' } } } } expected_output = { 'a.b.c.d': 'e' } assert flatten_dictionary(input_dict) == expected_output def test_flatten_dictionary_mixed_values(): input_dict = { 'a': '1', 'b': { 'c': '2', 'd': { 'e': '3', 'f': { 'g': '4' } } }, 'h': { 'i': '5' } } expected_output = { 'a': '1', 'b.c': '2', 'b.d.e': '3', 'b.d.f.g': '4', 'h.i': '5' } assert flatten_dictionary(input_dict) == expected_output","solution":"def flatten_dictionary(d, parent_key='', sep='.'): Flattens a nested dictionary. Args: d (dict): The dictionary to flatten. parent_key (str): The base key to use when flattening (for recursive calls). sep (str): The separator to use between keys. Returns: dict: The flattened dictionary. items = [] for k, v in d.items(): new_key = f\\"{parent_key}{sep}{k}\\" if parent_key else k if isinstance(v, dict): items.extend(flatten_dictionary(v, new_key, sep=sep).items()) else: items.append((new_key, v)) return dict(items)"},{"question":"def is_prime(n: int) -> bool: Helper function that checks if a number n is prime. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(5) True >>> is_prime(10) False >>> is_prime(0) False >>> is_prime(1) False >>> is_prime(17) True def is_prime_list(numbers: List[int]) -> List[bool]: Returns a list of booleans where each boolean indicates if the corresponding number in the input list is prime. >>> is_prime_list([2, 3, 4, 5, 10]) [True, True, False, True, False] >>> is_prime_list([11, 13, 17, 19, 23]) [True, True, True, True, True] >>> is_prime_list([1, 4, 6, 8, 9]) [False, False, False, False, False] >>> is_prime_list([29, 31, 37, 41, 43]) [True, True, True, True, True] >>> is_prime_list([]) [] >>> is_prime_list([1]) [False] >>> is_prime_list([2]) [True]","solution":"def is_prime(n): Helper function that checks if a number n is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def is_prime_list(numbers): Returns a list of booleans where each boolean indicates if the corresponding number in the input list is prime. return [is_prime(num) for num in numbers]"},{"question":"def check_power_outage(power_states: str) -> str: This function takes a string representing the power states where \\"1\\" indicates an outage and \\"0\\" indicates stability. It returns \\"Emergency!\\" if there are more than 5 consecutive \\"1\\"s, otherwise returns \\"Stable\\". >>> check_power_outage(\\"00011100111110\\") \\"Stable\\" >>> check_power_outage(\\"11111100000000\\") \\"Emergency!\\"","solution":"def check_power_outage(power_states: str) -> str: This function takes a string representing the power states where \\"1\\" indicates an outage and \\"0\\" indicates stability. It returns \\"Emergency!\\" if there are more than 5 consecutive \\"1\\"s, otherwise returns \\"Stable\\". if '111111' in power_states: return \\"Emergency!\\" return \\"Stable\\""},{"question":"def uniquePaths(m: int, n: int) -> int: Calculate the number of unique paths from the top-left corner to the bottom-right corner of an m x n grid. >>> uniquePaths(3, 2) 3 >>> uniquePaths(7, 3) 28 # Write your code here: # Unit Tests def test_uniquePaths_case1(): assert uniquePaths(3, 2) == 3 def test_uniquePaths_case2(): assert uniquePaths(7, 3) == 28 def test_uniquePaths_minimum_grid(): assert uniquePaths(1, 1) == 1 def test_uniquePaths_single_row(): assert uniquePaths(1, 5) == 1 def test_uniquePaths_single_column(): assert uniquePaths(5, 1) == 1 def test_uniquePaths_square_grid(): assert uniquePaths(3, 3) == 6 def test_uniquePaths_large_grid(): assert uniquePaths(10, 10) == 48620","solution":"def uniquePaths(m, n): Returns the number of unique paths from the top-left corner to the bottom-right corner of an m x n grid. # Create a 2D array for storing the number of paths to each cell dp = [[1] * n for _ in range(m)] # Start filling the dp array from cell (1,1) for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[-1][-1]"},{"question":"def is_bipartite_bfs(adj_list, n): Check if a graph is bipartite using BFS. :param adj_list: List[List[int]], adjacency list of the graph :param n: int, number of nodes :return: str, \\"YES\\" if the graph is bipartite, \\"NO\\" otherwise Example: >>> is_bipartite_bfs([[], [2], [1, 3], [2, 4], [3, 1]], 4) \\"YES\\" >>> is_bipartite_bfs([[1], [0, 2], [1, 3], [2, 0]], 4) \\"NO\\" pass def solve(t, test_cases): Determine if each of the given graphs in the test cases is bipartite. :param t: int, number of test cases :param test_cases: List[Tuple[int, int, List[Tuple[int, int]]]], list of test cases :return: List[str], results for each test case Example: >>> solve(2, [ ... (4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]), ... (3, 3, [(1, 2), (2, 3), (3, 1)]) ... ]) [\\"YES\\", \\"NO\\"] >>> solve(1, [ ... (5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) ... ]) [\\"YES\\"] pass","solution":"def is_bipartite_bfs(adj_list, n): color = [-1] * n for start in range(n): if color[start] == -1: queue = [start] color[start] = 1 while queue: node = queue.pop(0) for neighbor in adj_list[node]: if color[neighbor] == -1: color[neighbor] = 1 - color[node] queue.append(neighbor) elif color[neighbor] == color[node]: return \\"NO\\" return \\"YES\\" def solve(t, test_cases): results = [] for i in range(t): n, m, edges = test_cases[i] adj_list = [[] for _ in range(n)] for u, v in edges: adj_list[u-1].append(v-1) adj_list[v-1].append(u-1) result = is_bipartite_bfs(adj_list, n) results.append(result) return results"},{"question":"def min_operations_to_convert(A: List[int], B: List[int]) -> int: Find the minimum number of operations to convert sequence A into sequence B or report that it is impossible to do so. A and B are sequences of equal length N. >>> min_operations_to_convert([1, 2, 3, 4], [4, 5, 6, 7]) 3 >>> min_operations_to_convert([1, 2, 3], [3, 2, 1]) -1 pass def solve(test_cases: List[Tuple[int, List[int], List[int]]]) -> List[int]: pass def test_example_1(): test_cases = [ (4, [1, 2, 3, 4], [4, 5, 6, 7]), (3, [1, 2, 3], [3, 2, 1]) ] assert solve(test_cases) == [3, -1] def test_already_equal(): test_cases = [ (3, [1, 1, 1], [1, 1, 1]) ] assert solve(test_cases) == [0] def test_impossible_case(): test_cases = [ (3, [5, 5, 5], [4, 4, 4]) ] assert solve(test_cases) == [-1] def test_large_difference(): test_cases = [ (4, [1, 1, 1, 1], [10, 10, 10, 10]), (5, [5, 5, 5, 5, 5], [5, 6, 7, 8, 9]) ] assert solve(test_cases) == [9, 4] def test_mixed_differences(): test_cases = [ (5, [1, 2, 3, 4, 5], [1, 3, 3, 5, 7]) ] assert solve(test_cases) == [2]","solution":"def min_operations_to_convert(A, B): N = len(A) # Find the maximum difference needed max_diff = 0 for a, b in zip(A, B): if b < a: return -1 max_diff = max(max_diff, b - a) if max_diff == 0: return 0 return max_diff def solve(test_cases): results = [] for N, A, B in test_cases: results.append(min_operations_to_convert(A, B)) return results"},{"question":"def evaluate_expression(expression: str) -> float: Evaluate a string containing a mathematical expression and return the result as a float. The expression contains only non-negative integers and the operators '+', '-', '*', and '/'. The operators are evaluated in the usual order of precedence. Division results should be treated as floating point numbers. Return 0.0 for empty expressions. Examples: >>> evaluate_expression(\\"3+5*2\\") 13.0 >>> evaluate_expression(\\"10+3/2\\") 11.5 from solution import evaluate_expression def test_basic_operations(): assert evaluate_expression(\\"3+5*2\\") == 13.0 assert evaluate_expression(\\"10+3/2\\") == 11.5 assert evaluate_expression(\\"10-3*2\\") == 4.0 assert evaluate_expression(\\"6/2*3\\") == 9.0 def test_empty_expression(): assert evaluate_expression(\\"\\") == 0.0 def test_single_number(): assert evaluate_expression(\\"5\\") == 5.0 assert evaluate_expression(\\"123\\") == 123.0 def test_consecutive_operators(): assert evaluate_expression(\\"5+2*3-4/2\\") == 9.0 assert evaluate_expression(\\"10/5*2+3-1\\") == 6.0 def test_no_multiplication_or_division(): assert evaluate_expression(\\"1+2+3-1\\") == 5.0 def test_no_addition_or_subtraction(): assert evaluate_expression(\\"2*3/1*2\\") == 12.0 assert evaluate_expression(\\"8/2/2*5\\") == 10.0","solution":"def evaluate_expression(expression: str) -> float: if not expression: return 0.0 def compute(operators, values): right = values.pop() left = values.pop() op = operators.pop() if op == '+': values.append(left + right) elif op == '-': values.append(left - right) elif op == '*': values.append(left * right) elif op == '/': values.append(left / right) operators = [] values = [] i = 0 length = len(expression) while i < length: if expression[i].isdigit(): num = 0 while i < length and expression[i].isdigit(): num = num * 10 + int(expression[i]) i += 1 values.append(num) i -= 1 elif expression[i] in '+-': while operators and operators[-1] in '+-*/': compute(operators, values) operators.append(expression[i]) elif expression[i] in '*/': while operators and operators[-1] in '*/': compute(operators, values) operators.append(expression[i]) i += 1 while operators: compute(operators, values) return float(values[0])"},{"question":"from typing import List def min_subarray_length(arr: List[int], S: int) -> int: Returns the length of the smallest contiguous subarray with a sum greater than or equal to S. If no such subarray exists, returns 0. Example: >>> min_subarray_length([2, 3, 1, 2, 4, 3], 7) 2 >>> min_subarray_length([1, 4, 4], 4) 1 >>> min_subarray_length([1, 1, 1, 1, 1, 1, 1], 11) 0 def test_min_subarray_length_example(): assert min_subarray_length([2, 3, 1, 2, 4, 3], 7) == 2 def test_min_subarray_length_single_element(): assert min_subarray_length([1, 4, 4], 4) == 1 def test_min_subarray_length_no_subarray(): assert min_subarray_length([1, 1, 1, 1, 1, 1, 1], 11) == 0 def test_min_subarray_length_entire_array(): assert min_subarray_length([2, 1, 5, 2, 3, 2], 9) == 3 def test_min_subarray_length_component_case(): assert min_subarray_length([4, 2, 2, 7, 8, 1, 2, 8, 10], 8) == 1 def test_min_subarray_length_edge_case(): assert min_subarray_length([1], 2) == 0 assert min_subarray_length([], 1) == 0","solution":"def min_subarray_length(arr, S): Returns the length of the smallest contiguous subarray with a sum greater than or equal to S. If no such subarray exists, returns 0. n = len(arr) min_length = float('inf') current_sum = 0 left = 0 for right in range(n): current_sum += arr[right] while current_sum >= S: min_length = min(min_length, right - left + 1) current_sum -= arr[left] left += 1 return 0 if min_length == float('inf') else min_length"},{"question":"def compute_fencing_cost(N: int, M: int, C: int) -> int: Computes the cost of fencing Farmer John's field. Parameters: N (int): Length of the field. M (int): Width of the field. C (int): Cost per unit length of the fence. Returns: int: Total cost of the fencing. def main(inputs: List[List[int]]) -> List[int]: Processes multiple test cases to determine the fencing cost for each field configuration. Parameters: inputs (List[List[int]]): A list where the first element is the number of test cases (T), followed by T sublists, each containing four integers [N, M, C, G]. Returns: List[int]: A list of total fencing costs for each test case.","solution":"def compute_fencing_cost(N, M, C): Computes the cost of fencing Farmer John's field. Parameters: N (int): Length of the field. M (int): Width of the field. C (int): Cost per unit length of the fence. Returns: int: Total cost of the fencing. perimeter = 2 * (N + M) fencing_cost = perimeter * C return fencing_cost def main(inputs): results = [] for i in range(1, inputs[0] + 1): N, M, C, G = inputs[i] cost = compute_fencing_cost(N, M, C) results.append(cost) return results"},{"question":"def can_form(S: str, T: str) -> bool: Determines if string T can be formed by deleting some (or no) characters from S without reordering. >>> can_form(\\"abcdefg\\", \\"acf\\") True >>> can_form(\\"xyz\\", \\"yx\\") False def process_cases(Q: int, cases: List[Tuple[str, str]]) -> List[str]: Processes multiple test cases to determine if string T can be formed from S. >>> process_cases(2, [(\\"abcdefg\\", \\"acf\\"), (\\"xyz\\", \\"yx\\")]) [\\"YES\\", \\"NO\\"] >>> process_cases(1, [(\\"abc\\", \\"\\")]) [\\"YES\\"] # Unit Testing def test_can_form(): assert can_form(\\"abcdefg\\", \\"acf\\") == True assert can_form(\\"xyz\\", \\"yx\\") == False assert can_form(\\"abcdefghiklm\\", \\"ikm\\") == True assert can_form(\\"abcdefghiklm\\", \\"ixm\\") == False assert can_form(\\"abc\\", \\"\\") == True def test_process_cases(): cases = [ (\\"abcdefg\\", \\"acf\\"), (\\"xyz\\", \\"yx\\"), ] assert process_cases(2, cases) == [\\"YES\\", \\"NO\\"] cases = [ (\\"abcdefghiklm\\", \\"ikm\\"), (\\"abcdefghiklm\\", \\"ixm\\"), ] assert process_cases(2, cases) == [\\"YES\\", \\"NO\\"] cases = [ (\\"abc\\", \\"\\"), ] assert process_cases(1, cases) == [\\"YES\\"]","solution":"def can_form(S, T): Determines if string T can be formed by deleting some (or no) characters from S without reordering. it = iter(S) return all(character in it for character in T) def process_cases(Q, cases): results = [] for S, T in cases: if can_form(S, T): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def sumArray(arr: list[int]) -> list[int]: Given an array of integers, returns a new array where each element is the sum of itself and all previous elements. Parameters: arr (list of int): Input array of integers. Returns: list of int: New array with cumulative sums. pass # Test cases def test_sumArray_with_positive_numbers(): assert sumArray([1, 2, 3, 4]) == [1, 3, 6, 10] def test_sumArray_with_negative_numbers(): assert sumArray([-1, -2, -3, -4]) == [-1, -3, -6, -10] def test_sumArray_with_mixed_sign_numbers(): assert sumArray([-1, 2, -3, 4]) == [-1, 1, -2, 2] def test_sumArray_with_empty_array(): assert sumArray([]) == [] def test_sumArray_with_single_element(): assert sumArray([10]) == [10] def test_sumArray_with_zeros(): assert sumArray([0, 0, 0, 0]) == [0, 0, 0, 0]","solution":"def sumArray(arr): Given an array of integers, returns a new array where each element is the sum of itself and all previous elements. Parameters: arr (list of int): Input array of integers. Returns: list of int: New array with cumulative sums. cumulative_sum = 0 result = [] for num in arr: cumulative_sum += num result.append(cumulative_sum) return result"},{"question":"def search(arr: List[int], target: int) -> int: Returns the index of target in the rotated sorted array arr, or -1 if target is not found. Example: >>> search([4,5,6,7,0,1,2], 0) 4 >>> search([4,5,6,7,0,1,2], 3) -1 >>> search([1], 0) -1","solution":"def search(arr, target): Returns the index of target in the rotated sorted array arr, or -1 if target is not found. left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: return mid if arr[left] <= arr[mid]: # Left part is sorted if arr[left] <= target < arr[mid]: right = mid - 1 else: left = mid + 1 else: # Right part is sorted if arr[mid] < target <= arr[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"from typing import List def filter_strings(arr: List[str], substrings: List[str]) -> List[str]: Returns a list of strings from \`arr\` that contain at least one of the substrings in \`substrings\`. >>> filter_strings([\\"hello world\\", \\"hi there\\", \\"goodbye\\"], [\\"hello\\", \\"good\\"]) [\\"hello world\\", \\"goodbye\\"] >>> filter_strings([\\"apple\\", \\"banana\\", \\"cherry\\"], [\\"ap\\", \\"ch\\"]) [\\"apple\\", \\"cherry\\"]","solution":"from typing import List def filter_strings(arr: List[str], substrings: List[str]) -> List[str]: Returns a list of strings from \`arr\` that contain at least one of the substrings in \`substrings\`. filtered_list = [] for s in arr: if any(sub in s for sub in substrings): filtered_list.append(s) return filtered_list"},{"question":"def unique_paths(M, N, puddles): Calculate the number of unique paths from the top-left corner to the bottom-right corner of an MxN grid, avoiding any puddles. Args: M : int : number of rows in the grid N : int : number of columns in the grid puddles : list : list of tuples representing the coordinates of puddles in the grid Returns: int : number of unique paths modulo 1,000,000,007 >>> unique_paths(3, 3, [(1, 1), (1, 2)]) 1 >>> unique_paths(2, 2, []) 2","solution":"def unique_paths(M, N, puddles): MODULO = 1_000_000_007 # Create a 2D DP array initialized to 0 dp = [[0] * N for _ in range(M)] # Mark puddles in the grid puddles_set = set((r, c) for r, c in puddles) # Initialization: No puddle on starting cell, If so returns 0 paths if (0, 0) in puddles_set: return 0 dp[0][0] = 1 # Fill the DP table for i in range(M): for j in range(N): if (i, j) in puddles_set: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] % MODULO if j > 0: dp[i][j] += dp[i][j-1] % MODULO dp[i][j] %= MODULO return dp[M-1][N-1]"},{"question":"def longest_unique_substring(s: str) -> str: Determine the longest consecutive substring of a given string that contains no repeating characters. >>> longest_unique_substring(\\"abcabcbb\\") \\"abc\\" >>> longest_unique_substring(\\"bbbbb\\") \\"b\\" >>> longest_unique_substring(\\"pwwkew\\") \\"wke\\" >>> longest_unique_substring(\\"aab\\") \\"ab\\" from solution import longest_unique_substring def test_example_case_1(): assert longest_unique_substring(\\"abcabcbb\\") == \\"abc\\" def test_example_case_2(): assert longest_unique_substring(\\"bbbbb\\") == \\"b\\" def test_example_case_3(): assert longest_unique_substring(\\"pwwkew\\") == \\"wke\\" def test_example_case_4(): assert longest_unique_substring(\\"aab\\") == \\"ab\\" def test_empty_string(): assert longest_unique_substring(\\"\\") == \\"\\" def test_single_character_string(): assert longest_unique_substring(\\"a\\") == \\"a\\" def test_all_unique_characters(): assert longest_unique_substring(\\"abcdef\\") == \\"abcdef\\" def test_end_of_string(): assert longest_unique_substring(\\"abcdeacdefg\\") == \\"acdefg\\" def test_long_repeating_string(): assert longest_unique_substring(\\"aaaaaaabcdefaaaaaa\\") == \\"abcdef\\"","solution":"def longest_unique_substring(s: str) -> str: if not s: return \\"\\" start = 0 max_len = 0 max_start = 0 used_chars = {} for i, char in enumerate(s): if char in used_chars and start <= used_chars[char]: start = used_chars[char] + 1 else: current_len = i - start + 1 if current_len > max_len: max_len = current_len max_start = start used_chars[char] = i return s[max_start:max_start + max_len]"},{"question":"def count_palindrome_substrings(S: str) -> int: Returns the number of palindrome substrings in the given string S. >>> count_palindrome_substrings(\\"a\\") 1 >>> count_palindrome_substrings(\\"abc\\") 3 >>> count_palindrome_substrings(\\"ababa\\") 9 >>> count_palindrome_substrings(\\"aaa\\") 6 >>> count_palindrome_substrings(\\"abba\\") 6","solution":"def count_palindrome_substrings(S): Returns the number of palindrome substrings in the given string S. n = len(S) count = 0 # Expand around center approach to identify all palindrome substrings for center in range(2 * n - 1): left = center // 2 right = left + center % 2 while left >= 0 and right < n and S[left] == S[right]: count += 1 left -= 1 right += 1 return count"},{"question":"def can_form_non_decreasing_by_reversing_subarray(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine if it's possible to form a non-decreasing sequence by either removing individuals or by reversing exactly one continuous subarray. >>> can_form_non_decreasing_by_reversing_subarray(3, [(5, [1, 3, 2, 4, 5]), (4, [4, 3, 2, 1]), (6, [1, 5, 3, 3, 4, 2])]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> can_form_non_decreasing_by_reversing_subarray(1, [(6, [1, 2, 3, 4, 5, 6])]) [\\"YES\\"] from solution import can_form_non_decreasing_by_reversing_subarray def test_single_case(): t = 1 test_cases = [ (5, [1, 3, 2, 4, 5]) ] assert can_form_non_decreasing_by_reversing_subarray(t, test_cases) == [\\"YES\\"] def test_all_sorted(): t = 1 test_cases = [ (5, [1, 2, 3, 4, 5]) ] assert can_form_non_decreasing_by_reversing_subarray(t, test_cases) == [\\"YES\\"] def test_all_reverse(): t = 1 test_cases = [ (4, [4, 3, 2, 1]) ] assert can_form_non_decreasing_by_reversing_subarray(t, test_cases) == [\\"YES\\"] def test_no_possible_reversal(): t = 1 test_cases = [ (6, [1, 5, 3, 3, 4, 2]) ] assert can_form_non_decreasing_by_reversing_subarray(t, test_cases) == [\\"NO\\"] def test_multiple_cases(): t = 3 test_cases = [ (5, [1, 3, 2, 4, 5]), (4, [4, 3, 2, 1]), (6, [1, 5, 3, 3, 4, 2]) ] assert can_form_non_decreasing_by_reversing_subarray(t, test_cases) == [\\"YES\\", \\"YES\\", \\"NO\\"]","solution":"def can_form_non_decreasing_by_reversing_subarray(t, test_cases): def is_non_decreasing(arr): return all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1)) results = [] for case in test_cases: n, arr = case if is_non_decreasing(arr): results.append(\\"YES\\") continue reverse_found = False for i in range(n): for j in range(i + 1, n + 1): temp_arr = arr[:i] + arr[i:j][::-1] + arr[j:] if is_non_decreasing(temp_arr): reverse_found = True break if reverse_found: break if reverse_found: results.append(\\"YES\\") else: results.append(\\"NO\\") return results # Examples for testing t = 3 test_cases = [ (5, [1, 3, 2, 4, 5]), (4, [4, 3, 2, 1]), (6, [1, 5, 3, 3, 4, 2]) ] print(can_form_non_decreasing_by_reversing_subarray(t, test_cases))"},{"question":"def final_scores(n: int, scores: List[int], m: int, events: List[str]) -> List[int]: Determine the final scores of all employees after a series of score updates and adjustments. Args: n : int : number of employees scores : List[int] : initial scores of the employees m : int : number of score change events events : List[str] : list of events that change scores Returns: List[int] : final scores of the employees after processing all events Examples: >>> final_scores(3, [10, 20, 30], 3, [\\"1 1 25\\", \\"2 15\\", \\"1 3 35\\"]) [25, 20, 35] >>> final_scores(4, [5, 7, 9, 11], 4, [\\"2 8\\", \\"1 2 10\\", \\"2 12\\", \\"1 1 12\\"]) [12, 12, 12, 12]","solution":"def final_scores(n, scores, m, events): # Initialize the current minimum threshold min_threshold = 0 for event in events: parts = event.split() if parts[0] == '1': e = int(parts[1]) - 1 x = int(parts[2]) scores[e] = x elif parts[0] == '2': x = int(parts[1]) min_threshold = max(min_threshold, x) # Apply minimum threshold to all scores final_scores = [max(score, min_threshold) for score in scores] return final_scores"},{"question":"def minimum_swaps(books: List[int]) -> int: Given a list of integers representing the heights of Lisa's books, determine the minimum number of swaps needed to sort the books in non-decreasing order. books(List[int]): A list of integers where each integer represents the height of a book. Returns an integer that indicates the minimum number of swaps needed to sort the books in non-decreasing order. Examples: >>> minimum_swaps([4, 3, 1, 2]) 3 >>> minimum_swaps([1, 5, 4, 3, 2]) 2","solution":"def minimum_swaps(books): Given a list of integers representing the heights of books, determine the minimum number of swaps needed to sort the books in non-decreasing order. Parameters: books (List[int]): A list of integers representing the heights of books. Returns: int: The minimum number of swaps needed to sort the list. n = len(books) arrpos = [(value, idx) for idx, value in enumerate(books)] arrpos.sort(key=lambda it: it[0]) visited = {k: False for k in range(n)} swaps = 0 for i in range(n): if visited[i] or arrpos[i][1] == i: continue cycle_size = 0 x = i while not visited[x]: visited[x] = True x = arrpos[x][1] cycle_size += 1 if cycle_size > 0: swaps += (cycle_size - 1) return swaps"},{"question":"from typing import List def calculate_trapped_water(heights: List[int]) -> int: Given a list of integers representing the altitude of land at various points along a 1D path, returns the total amount of water that will be trapped after the rain. Examples: >>> calculate_trapped_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> calculate_trapped_water([4, 2, 0, 3, 2, 5]) 9","solution":"def calculate_trapped_water(heights): Given a list of integers representing the altitude of land at various points along a 1D path, returns the total amount of water that will be trapped after the rain. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) trapped_water = 0 for i in range(n): trapped_water += max(0, min(left_max[i], right_max[i]) - heights[i]) return trapped_water"},{"question":"def grade_students(student_scores, cutoff): Returns a dictionary with student names as keys and \\"pass\\" or \\"fail\\" as values based on whether their score meets or exceeds the cutoff. Parameters: student_scores (list of tuples): Each tuple contains a student's name and their score. cutoff (int): The score needed to pass the exam. Returns: dict: A dictionary with student names as keys and their pass/fail status as values. Examples: >>> grade_students([(\\"Alice\\", 85), (\\"Bob\\", 78), (\\"Charlie\\", 90)], 80) {'Alice': 'pass', 'Bob': 'fail', 'Charlie': 'pass'} >>> grade_students([(\\"Alice\\", 70), (\\"Bob\\", 60), (\\"Charlie\\", 75)], 80) {'Alice': 'fail', 'Bob': 'fail', 'Charlie': 'fail'} def test_grade_students_all_pass(): student_scores = [(\\"Alice\\", 85), (\\"Bob\\", 90), (\\"Charlie\\", 80)] cutoff = 80 result = grade_students(student_scores, cutoff) assert result == {\\"Alice\\": \\"pass\\", \\"Bob\\": \\"pass\\", \\"Charlie\\": \\"pass\\"} def test_grade_students_all_fail(): student_scores = [(\\"Alice\\", 70), (\\"Bob\\", 60), (\\"Charlie\\", 75)] cutoff = 80 result = grade_students(student_scores, cutoff) assert result == {\\"Alice\\": \\"fail\\", \\"Bob\\": \\"fail\\", \\"Charlie\\": \\"fail\\"} def test_grade_students_mixed_results(): student_scores = [(\\"Alice\\", 85), (\\"Bob\\", 78), (\\"Charlie\\", 90)] cutoff = 80 result = grade_students(student_scores, cutoff) assert result == {\\"Alice\\": \\"pass\\", \\"Bob\\": \\"fail\\", \\"Charlie\\": \\"pass\\"} def test_grade_students_edge_cases(): student_scores = [(\\"Alice\\", 80), (\\"Bob\\", 79), (\\"Charlie\\", 81)] cutoff = 80 result = grade_students(student_scores, cutoff) assert result == {\\"Alice\\": \\"pass\\", \\"Bob\\": \\"fail\\", \\"Charlie\\": \\"pass\\"} def test_grade_students_empty_list(): student_scores = [] cutoff = 80 result = grade_students(student_scores, cutoff) assert result == {}","solution":"def grade_students(student_scores, cutoff): Returns a dictionary with student names as keys and \\"pass\\" or \\"fail\\" as values based on whether their score meets or exceeds the cutoff. Parameters: student_scores (list of tuples): Each tuple contains a student's name and their score. cutoff (int): The score needed to pass the exam. Returns: dict: A dictionary with student names as keys and their pass/fail status as values. return {name: ('pass' if score >= cutoff else 'fail') for name, score in student_scores}"},{"question":"def maxCoins(grid: List[List[int]]) -> int: Given a grid where each cell contains a certain number of coins, return the maximum number of coins that can be collected by following a path from the top-left to the bottom-right corner only moving right or down. >>> maxCoins([[0, 3, 1, 1], [2, 0, 0, 4], [1, 5, 3, 1]]) 12 >>> maxCoins([[1, 2, 3, 4, 5]]) 15 >>> maxCoins([[1], [2], [3], [4], [5]]) 15 >>> maxCoins([[8]]) 8 >>> maxCoins([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 12 >>> maxCoins([[]]) 0","solution":"def maxCoins(grid): Given a grid where each cell contains a certain number of coins, return the maximum number of coins that can be collected by following a path from the top-left to the bottom-right corner only moving right or down. if not grid or not grid[0]: return 0 rows = len(grid) cols = len(grid[0]) # Create a dp table to store the maximum coins collected up to each cell dp = [[0] * cols for _ in range(rows)] # Initialize the dp table with the coins in the first cell dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for col in range(1, cols): dp[0][col] = dp[0][col - 1] + grid[0][col] # Fill the first column (can only come from above) for row in range(1, rows): dp[row][0] = dp[row - 1][0] + grid[row][0] # Fill the rest of the dp table for row in range(1, rows): for col in range(1, cols): dp[row][col] = max(dp[row - 1][col], dp[row][col - 1]) + grid[row][col] return dp[rows - 1][cols - 1]"},{"question":"def longest_contiguous_subsequence(arr: List[int]) -> int: Given a list of integers, determine the length of the longest contiguous subsequence where each element can be rearranged in non-decreasing order. >>> longest_contiguous_subsequence([10, 12, 11, 14, 23, 10, 11, 21]) 3 >>> longest_contiguous_subsequence([1, 2, 3, 5, 7, 8, 9, 10]) 8 >>> longest_contiguous_subsequence([4, 5, 4, 5, 4, 5]) 2 >>> longest_contiguous_subsequence([]) 0 >>> longest_contiguous_subsequence([5]) 1 >>> longest_contiguous_subsequence([7, 7, 7, 7]) 4 >>> longest_contiguous_subsequence([1, 3, 2, 4, 3, 5, 4, 6]) 2 >>> longest_contiguous_subsequence([6, 5, 4, 3, 2, 1]) 1 >>> longest_contiguous_subsequence([1, 2, 3, 4, 3, 2, 1]) 4","solution":"def longest_contiguous_subsequence(arr): if not arr: return 0 max_len = 1 current_len = 1 for i in range(1, len(arr)): if arr[i] >= arr[i - 1]: current_len += 1 max_len = max(max_len, current_len) else: current_len = 1 return max_len"},{"question":"def skyline_view_width(heights, start, end): Calculate the width of the continuous segment of the skyline defined by buildings from index start to end, inclusive. Parameters: heights (List[int]): List of building heights. start (int): Start index of the buildings to consider. end (int): End index of the buildings to consider. Returns: int: Width of the continuous segment or 0 if there is any zero-height building within the range. def test_skyline_view_width(): # Test example 1: skylines contains zero in the range assert skyline_view_width([1, 2, 3, 0, 2, 2], 1, 4) == 0 # Test example 2: no zero in the range assert skyline_view_width([1, 2, 3, 4, 5], 0, 4) == 5 # Test example 3: no zero in the range assert skyline_view_width([5, 4, 3, 2, 1], 1, 3) == 3 # Test example 4: no zero in the range assert skyline_view_width([1, 2, 0, 4, 5], 0, 1) == 2 # Additional tests # Test with single segment assert skyline_view_width([3, 2, 1, 0, 4], 2, 2) == 1 # Test with zero at the edges assert skyline_view_width([0, 1, 2, 0, 4, 5], 1, 4) == 0 # Test with all zero heights assert skyline_view_width([0, 0, 0, 0, 0], 0, 4) == 0 # Test with large segments assert skyline_view_width([i for i in range(1, 100001)], 100, 1000) == 901 # Test full width with no zeros assert skyline_view_width([1] * 1000000, 0, 999999) == 1000000 # Test edge case with 0 and max range assert skyline_view_width([2, 0, 2], 0, 2) == 0","solution":"def skyline_view_width(heights, start, end): Calculate the width of the continuous segment of the skyline defined by buildings from index start to end, inclusive. Parameters: heights (List[int]): List of building heights. start (int): Start index of the buildings to consider. end (int): End index of the buildings to consider. Returns: int: Width of the continuous segment or 0 if there is any zero-height building within the range. if any(height == 0 for height in heights[start:end+1]): return 0 return end - start + 1"},{"question":"def char_frequency(s: str) -> dict: Write a function that takes a string as input and returns a dictionary with the frequency count of each character in the string. The keys of the dictionary should be the characters, and the values should be the number of times each character appears in the string. The function should be case-sensitive and include spaces, punctuation, and special characters. >>> char_frequency(\\"hello world\\") == {'h': 1, 'e': 1, 'l': 3, 'o': 2, ' ': 1, 'w': 1, 'r': 1, 'd': 1} >>> char_frequency(\\"aaabbbbcc\\") == {'a': 3, 'b': 4, 'c': 2} >>> char_frequency(\\"Python 3.8!\\") == {'P': 1, 'y': 1, 't': 1, 'h': 1, 'o': 1, 'n': 1, ' ': 1, '3': 1, '.': 1, '8': 1, '!': 1} >>> char_frequency(\\"\\") == {} >>> char_frequency(\\"aAaA\\") == {'a': 2, 'A': 2} >>> char_frequency(\\"A B C!D,E.F\\") == {'A': 1, ' ': 2, 'B': 1, 'C': 1, '!': 1, 'D': 1, ',': 1, 'E': 1, '.': 1, 'F': 1} # Your code here","solution":"def char_frequency(s): Returns a dictionary with the frequency count of each character in the input string s. The count is case-sensitive and includes spaces, punctuation, and special characters. frequency = {} for char in s: if char in frequency: frequency[char] += 1 else: frequency[char] = 1 return frequency"},{"question":"def rotate_right(s: str) -> str: Rotates the string \`s\` 90 degrees clockwise. Args: s (str): The input string with multiple lines Returns: str: The rotated string Example: >>> rotate_right(\\"abcdnefghnijklnmnop\\") 'mieannjfbnokgcnplhd' pass def rotate_left(s: str) -> str: Rotates the string \`s\` 90 degrees counterclockwise. Args: s (str): The input string with multiple lines Returns: str: The rotated string Example: >>> rotate_left(\\"abcdnefghnijklnmnop\\") 'dhlpncgkonbfjnnaeim' pass def apply_rotation(fct, s: str) -> str: Applies the rotation function \`fct\` to the string \`s\`. Args: fct (function): The rotation function to apply s (str): The input string with multiple lines Returns: str: The rotated string Example: >>> apply_rotation(rotate_right, \\"abcdnefghnijklnmnop\\") 'mieannjfbnokgcnplhd' >>> apply_rotation(rotate_left, \\"abcdnefghnijklnmnop\\") 'dhlpncgkonbfjnnaeim' pass # Test cases def test_rotate_right(): s = \\"abcdnefghnijklnmnop\\" expected = \\"mieannjfbnokgcnplhd\\" assert rotate_right(s) == expected def test_rotate_left(): s = \\"abcdnefghnijklnmnop\\" expected = \\"dhlpncgkonbfjnnaeim\\" assert rotate_left(s) == expected def test_apply_rotation_right(): s = \\"abcdnefghnijklnmnop\\" expected = \\"mieannjfbnokgcnplhd\\" assert apply_rotation(rotate_right, s) == expected def test_apply_rotation_left(): s = \\"abcdnefghnijklnmnop\\" expected = \\"dhlpncgkonbfjnnaeim\\" assert apply_rotation(rotate_left, s) == expected","solution":"def rotate_right(s): Rotates the string \`s\` 90 degrees clockwise. Args: s (str): The input string with multiple lines Returns: str: The rotated string lines = s.split('n') rotated = [''.join(line[i] for line in reversed(lines)) for i in range(len(lines[0]))] return 'n'.join(rotated) def rotate_left(s): Rotates the string \`s\` 90 degrees counterclockwise. Args: s (str): The input string with multiple lines Returns: str: The rotated string lines = s.split('n') rotated = [''.join(line[len(line)-1-i] for line in lines) for i in range(len(lines[0]))] return 'n'.join(rotated) def apply_rotation(fct, s): Applies the rotation function \`fct\` to the string \`s\`. Args: fct (function): The rotation function to apply s (str): The input string with multiple lines Returns: str: The rotated string return fct(s)"},{"question":"def unique_integers(nums: List[int]) -> List[int]: Returns a new list containing only the unique integers from the original list, preserving their original order. >>> unique_integers([1, 2, 2, 3, 4, 4, 5]) == [1, 2, 3, 4, 5] >>> unique_integers([1]) == [1] >>> unique_integers([5, 6, 7]) == [5, 6, 7] >>> unique_integers([2, 2, 2, 2]) == [2] >>> unique_integers([8, 1, 8, 7, 1, 6, 8, 6, 5]) == [8, 1, 7, 6, 5] >>> unique_integers([]) == [] >>> unique_integers([-1, -2, -2, -3, -1]) == [-1, -2, -3]","solution":"def unique_integers(nums): Returns a new list containing only the unique integers from the original list, preserving their original order. seen = set() unique_nums = [] for num in nums: if num not in seen: unique_nums.append(num) seen.add(num) return unique_nums"},{"question":"from typing import List def rearrange_string(s: str, k: int) -> str: Rearrange the letters in the string such that the same letters are at least 'k' distance apart. >>> rearrange_string(\\"aaadbbcc\\", 2) in [\\"abacabdc\\", \\"abcdabac\\", \\"ababacdc\\"] True >>> rearrange_string(\\"aaabc\\", 3) \\"\\" >>> rearrange_string(\\"abc\\", 1) \\"abc\\" >>> rearrange_string(\\"abcde\\", 0) \\"abcde\\" >>> rearrange_string(\\"a\\", 1) \\"a\\" >>> rearrange_string(\\"aaaabbbbcccdde\\", 2) != \\"\\" True >>> rearrange_string(\\"aaaabbbbcccdde\\", 5) \\"\\" >>> rearrange_string(\\"abcdefghijklmnopqrstuvwxyz\\", 1) \\"abcdefghijklmnopqrstuvwxyz\\"","solution":"import heapq from collections import Counter, deque def rearrange_string(s, k): if k == 0: return s freq_map = Counter(s) max_heap = [(-value, key) for key, value in freq_map.items()] heapq.heapify(max_heap) wait_queue = deque() result = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) wait_queue.append((char, freq+1)) if len(wait_queue) < k: continue front_char, front_freq = wait_queue.popleft() if -front_freq != 0: heapq.heappush(max_heap, (front_freq, front_char)) return ''.join(result) if len(result) == len(s) else ''"},{"question":"def subarray_sum(nums, k): Returns the number of contiguous subarrays that sum up to k. Example 1: Input: nums = [1,1,1], k = 2 Output: 2 Example 2: Input: nums = [1,2,3], k = 3 Output: 2 Example 3: Input: nums = [2,3,1,2,4,3], k = 7 Output: 2 Example 4: Input: nums = [1,2,3,4,5], k = 15 Output: 1 Example 5: Input: nums = [1], k = 5 Output: 0 Constraints: 1 <= nums.length <= 1000 1 <= nums[i] <= 10000 1 <= k <= 10^7","solution":"def subarray_sum(nums, k): Returns the number of contiguous subarrays that sum up to k. count = 0 curr_sum = 0 sum_dict = {0: 1} # Dictionary to store the prefix sums and their counts for num in nums: curr_sum += num if curr_sum - k in sum_dict: count += sum_dict[curr_sum - k] if curr_sum in sum_dict: sum_dict[curr_sum] += 1 else: sum_dict[curr_sum] = 1 return count"},{"question":"def minCut(s: str) -> int: Given a string s, partition it into as few parts as possible so that each part is a palindrome. A palindrome is a string that reads the same forward and backward. Return the minimum number of partitions needed. >>> minCut(\\"aab\\") == 1 >>> minCut(\\"a\\") == 0 >>> minCut(\\"abccba\\") == 0","solution":"def minCut(s): n = len(s) dp = list(range(n)) palindrome = [[False] * n for _ in range(n)] for gap in range(n): for i in range(n - gap): j = i + gap if s[i] == s[j] and (gap <= 1 or palindrome[i+1][j-1]): palindrome[i][j] = True for i in range(n): if palindrome[0][i]: dp[i] = 0 else: for j in range(i): if palindrome[j+1][i]: dp[i] = min(dp[i], dp[j] + 1) return dp[-1]"},{"question":"def encrypt_message(message: str, shift: int) -> str: Encrypts the given message using a shift cipher. Parameters: message (str): The message to be encrypted. It contains only uppercase English letters. shift (int): The shift to be applied. It can be positive or negative. Returns: str: The encrypted message. Examples: >>> encrypt_message(\\"HELLO\\", 3) \\"KHOOR\\" >>> encrypt_message(\\"ABC\\", -1) \\"ZAB\\" >>> encrypt_message(\\"PYTHON\\", 26) \\"PYTHON\\"","solution":"def encrypt_message(message, shift): Encrypts the given message using a shift cipher. Parameters: message (str): The message to be encrypted. It contains only uppercase English letters. shift (int): The shift to be applied. It can be positive or negative. Returns: str: The encrypted message. encrypted_message = [] shift = shift % 26 # Reduce the shift to a range of 0-25 for char in message: new_char = chr((ord(char) - ord('A') + shift) % 26 + ord('A')) encrypted_message.append(new_char) return ''.join(encrypted_message)"},{"question":"def count_segments(bend_sequence: str) -> int: Given a sequence of bends represented by 'L' and 'T', calculate the number of segments of length 1 after the bends. >>> count_segments('L') 2 >>> count_segments('T') 3 >>> count_segments('LT') 6 >>> count_segments('TLL') 12 def process_input(input_lines: List[str]) -> List[int]: Process multiple test cases. >>> process_input([\\"2\\", \\"LT\\", \\"TLL\\"]) [6, 12] >>> process_input([\\"1\\", \\"LTLTLT\\"]) [216]","solution":"def count_segments(bend_sequence): Given a sequence of bends represented by 'L' and 'T', calculate the number of segments of length 1 after the bends. segments = 1 for bend in bend_sequence: if bend == 'L': segments *= 2 elif bend == 'T': segments *= 3 return segments def process_input(input_lines): Process multiple test cases. T = int(input_lines[0]) results = [] for i in range(1, T + 1): bend_sequence = input_lines[i].strip() results.append(count_segments(bend_sequence)) return results"},{"question":"def is_rotated(s1: str, s2: str) -> bool: Determine if s2 is a rotated version of s1. >>> is_rotated(\\"waterbottle\\", \\"erbottlewat\\") True >>> is_rotated(\\"hello\\", \\"lohel\\") True >>> is_rotated(\\"hello\\", \\"ohell\\") True >>> is_rotated(\\"hello\\", \\"world\\") False","solution":"def is_rotated(s1, s2): Determine if s2 is a rotated version of s1. if len(s1) != len(s2): return False combined = s1 + s1 return s2 in combined"},{"question":"def analyze_performance(marathon_times): Analyze the performance of marathon times. Args: marathon_times (list): A list of marathon times in minutes. Returns: tuple: Contains the fastest marathon time and performance category. pass # Unit Tests def test_no_data(): assert analyze_performance([]) == (None, \\"No Data\\") def test_single_marathon_time(): assert analyze_performance([250]) == (250, \\"Average Runner\\") def test_fastest_time_elite_runner(): assert analyze_performance([175, 180, 179]) == (175, \\"Elite Runner\\") def test_fastest_time_good_runner(): assert analyze_performance([200, 210, 220]) == (200, \\"Good Runner\\") def test_fastest_time_average_runner(): assert analyze_performance([250, 260, 270]) == (250, \\"Average Runner\\") def test_fastest_time_needs_improvement(): assert analyze_performance([310, 320, 330]) == (310, \\"Needs Improvement\\")","solution":"def analyze_performance(marathon_times): Analyze the performance of marathon times. Args: marathon_times (list): A list of marathon times in minutes. Returns: tuple: Contains the fastest marathon time and performance category. if not marathon_times: return (None, \\"No Data\\") fastest_time = min(marathon_times) average_time = sum(marathon_times) / len(marathon_times) if average_time <= 180: category = \\"Elite Runner\\" elif average_time <= 240: category = \\"Good Runner\\" elif average_time <= 300: category = \\"Average Runner\\" else: category = \\"Needs Improvement\\" return (fastest_time, category)"},{"question":"from typing import List def searchMatrix(matrix: List[List[int]], target: int) -> bool: Searches for a target value in a matrix where each row and column is sorted. Each row is sorted in ascending order, and each column is sorted in ascending order. :param matrix: List[List[int]] the matrix with the given properties :param target: int the number to search for :return: bool whether the target exists in the matrix >>> searchMatrix([ ... [1, 4, 7, 11, 15], ... [2, 5, 8, 12, 19], ... [3, 6, 9, 16, 22], ... [10, 13, 14, 17, 24], ... [18, 21, 23, 26, 30] ... ], 5) True >>> searchMatrix([ ... [1, 4, 7, 11, 15], ... [2, 5, 8, 12, 19], ... [3, 6, 9, 16, 22], ... [10, 13, 14, 17, 24], ... [18, 21, 23, 26, 30] ... ], 20) False # Function implementation here.","solution":"from typing import List def searchMatrix(matrix: List[List[int]], target: int) -> bool: Searches for a target value in a matrix where each row and column is sorted. :param matrix: List[List[int]] the matrix with the given properties :param target: int the number to search for :return: bool whether the target exists in the matrix if not matrix or not matrix[0]: return False m, n = len(matrix), len(matrix[0]) row, col = 0, n - 1 # start from the top-right corner while row < m and col >= 0: if matrix[row][col] == target: return True elif matrix[row][col] > target: col -= 1 else: row += 1 return False"},{"question":"def can_escape(grid): Determine if there is a path from the starting point (S) to the exit point (E) without stepping on a trap (T). >>> grid = [ ... ['S', '.', '.', '#', 'E'], ... ['#', '#', '.', '#', '.'], ... ['.', '.', '.', '.', '.'], ... ['.', 'T', '.', '#', '.'], ... ['#', '#', '#', '#', '.'] ... ] >>> can_escape(grid) True >>> grid = [ ... ['S', '#', 'E'], ... ['#', '#', '#'], ... ['.', '.', '.'] ... ] >>> can_escape(grid) False >>> grid = [ ... ['S', '.', '.', 'E'], ... ['.', '.', '.', '.'], ... ['.', '.', '.', '.'] ... ] >>> can_escape(grid) True >>> grid = [ ... ['S', 'T', '.', 'E'], ... ['.', '.', 'T', '.'], ... ['.', '.', '.', 'T'] ... ] >>> can_escape(grid) False >>> grid = [ ... ['S', 'E'] ... ] >>> can_escape(grid) True >>> grid = [ ... ['S', '#', 'E'], ... ['#', '#', '#'], ... ['#', '.', '.'] ... ] >>> can_escape(grid) False","solution":"def can_escape(grid): from collections import deque rows = len(grid) cols = len(grid[0]) # Find the starting point (S) start = (-1, -1) for r in range(rows): for c in range(cols): if grid[r][c] == 'S': start = (r, c) break if start != (-1, -1): break # Directions for moving up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # BFS to find the path queue = deque([start]) visited = set() visited.add(start) while queue: r, c = queue.popleft() if grid[r][c] == 'E': return True for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) not in visited: if grid[nr][nc] == '.' or grid[nr][nc] == 'E': queue.append((nr, nc)) visited.add((nr, nc)) return False"},{"question":"import numpy as np def mean_variance(numpy_array): Computes the mean along axis 1 and then finds the variance of that result. Parameters: numpy_array (numpy.ndarray): The input 2-D array with dimensions NXN. Returns: float: The variance of the mean of elements computed along axis 1. Example: >>> mean_variance(np.array([[1, 2], [3, 4]])) 1.0 >>> mean_variance(np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])) 6.0","solution":"import numpy as np def mean_variance(numpy_array): Computes the mean along axis 1 and then finds the variance of that result. Parameters: numpy_array (numpy.ndarray): The input 2-D array with dimensions NXN. Returns: float: The variance of the mean of elements computed along axis 1. mean_axis1 = np.mean(numpy_array, axis=1) variance_of_mean = np.var(mean_axis1) return variance_of_mean"},{"question":"def look_and_say(n: int) -> str: Create a function that takes an integer \`n\` as input and returns the \`n\`th term of the Look-and-say sequence. >>> look_and_say(1) \\"1\\" >>> look_and_say(2) \\"11\\" >>> look_and_say(3) \\"21\\" >>> look_and_say(4) \\"1211\\" >>> look_and_say(5) \\"111221\\" >>> look_and_say(6) \\"312211\\" # Test cases def test_look_and_say_term_1(): assert look_and_say(1) == \\"1\\" def test_look_and_say_term_2(): assert look_and_say(2) == \\"11\\" def test_look_and_say_term_3(): assert look_and_say(3) == \\"21\\" def test_look_and_say_term_4(): assert look_and_say(4) == \\"1211\\" def test_look_and_say_term_5(): assert look_and_say(5) == \\"111221\\" def test_look_and_say_term_6(): assert look_and_say(6) == \\"312211\\" def test_look_and_say_term_7(): assert look_and_say(7) == \\"13112221\\" def test_look_and_say_term_8(): assert look_and_say(8) == \\"1113213211\\" def test_look_and_say_large_term(): # Just a check if a function can handle larger inputs without checking the exact output assert len(look_and_say(20)) > 0 assert len(look_and_say(50)) > 0","solution":"def look_and_say(n): if n == 1: return \\"1\\" def next_term(s): result = [] i = 0 while i < len(s): count = 1 while i + 1 < len(s) and s[i] == s[i + 1]: i += 1 count += 1 result.append(f\\"{count}{s[i]}\\") i += 1 return ''.join(result) term = \\"1\\" for _ in range(n - 1): term = next_term(term) return term"},{"question":"from typing import List def max_visible_buildings(heights: List[int]) -> int: You are given a list of integers representing the heights of buildings along a street. You want to place a camera on top of one of the buildings such that as many buildings as possible can be seen from the camera. A building can be seen if there are no taller buildings blocking the view to that building. A building can be seen if it is equal to the height of the building the camera is on. >>> max_visible_buildings([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) 11 >>> max_visible_buildings([1, 2, 3, 4, 5, 6]) 6 >>> max_visible_buildings([5, 4, 3, 2, 1]) 5 >>> max_visible_buildings([1, 3, 2]) 3 >>> max_visible_buildings([1]) 1 >>> max_visible_buildings([10, 9, 8, 7, 6, 5]) 6","solution":"def max_visible_buildings(heights): def visible_count_from(heights, index): current_height = heights[index] count = 1 # The building itself max_height_seen = current_height # Check buildings to the left for i in range(index - 1, -1, -1): if heights[i] > max_height_seen: max_height_seen = heights[i] if heights[i] <= current_height: count += 1 max_height_seen = current_height # Check buildings to the right for i in range(index + 1, len(heights)): if heights[i] > max_height_seen: max_height_seen = heights[i] if heights[i] <= current_height: count += 1 return count max_visible = 0 for i in range(len(heights)): max_visible = max(max_visible, visible_count_from(heights, i)) return max_visible"},{"question":"def skyline_area(building_heights: List[int]) -> int: Calculate the total area of the skyline when represented as a histogram. Parameters: - building_heights (List[int]): A list of integers representing the heights of buildings. Returns: - int: The total area under the skyline. Examples: >>> skyline_area([2, 1, 5, 6, 2, 3]) 10 >>> skyline_area([2, 4, 2, 1]) 6 >>> skyline_area([3, 3, 3, 3]) 12 >>> skyline_area([6, 2, 5, 4, 5, 1, 6]) 12 pass","solution":"def skyline_area(building_heights): Calculate the total area of the skyline when represented as a histogram. Parameters: - building_heights (List[int]): A list of integers representing the heights of buildings. Returns: - int: The total area under the skyline. # Initialize the maximum area and create an empty stack max_area = 0 stack = [] # Process all buildings in the list for i, height in enumerate(building_heights): start = i # If the current building is lower than the last one in the stack, pop the stack while stack and stack[-1][1] > height: index, h = stack.pop() max_area = max(max_area, h * (i - index)) start = index stack.append((start, height)) # Now process the remaining buildings in the stack for i, height in stack: max_area = max(max_area, height * (len(building_heights) - i)) return max_area"},{"question":"def evaluate_expression(expression: str) -> float: Evaluates a given mathematical expression string involving addition, subtraction, multiplication, division, and parentheses. >>> evaluate_expression(\\"3+2*2\\") 7 >>> evaluate_expression(\\"3/2\\") 1.5 >>> evaluate_expression(\\"(2+6*3+5-(3*14/7+2)*5)+3\\") -12 >>> evaluate_expression(\\"((2+3)*2)\\") 10 >>> evaluate_expression(\\"2+3*4-5/2\\") 11.5 >>> evaluate_expression(\\"5/(2-2+1)\\") 5 >>> evaluate_expression(\\"5\\") 5 >>> evaluate_expression(\\"123\\") 123","solution":"def evaluate_expression(expression): Evaluates a given mathematical expression string involving addition, subtraction, multiplication, division, and parentheses. def calc(expression): stack, num, sign = [], 0, \\"+\\" i = 0 while i < len(expression): char = expression[i] if char.isdigit(): num = num * 10 + int(char) if char == '(': counter, j = 1, i while counter != 0: i += 1 if expression[i] == '(': counter += 1 if expression[i] == ')': counter -= 1 num = calc(expression[j+1:i]) if char in \\"+-*/()\\" or i == len(expression) - 1: if sign == '+': stack.append(num) elif sign == '-': stack.append(-num) elif sign == '*': stack[-1] = stack[-1] * num elif sign == '/': stack[-1] = stack[-1] / num sign = char num = 0 i += 1 return sum(stack) return calc(expression)"},{"question":"def min_path_sum(grid: List[List[int]]) -> int: Determine the minimum sum path from the top-left corner to the bottom-right corner of the grid. Parameters: grid (List[List[int]]): A 2D list representing the grid. Returns: int: The minimum sum path. >>> min_path_sum([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_path_sum([[5]]) 5 >>> min_path_sum([[1, 2, 3, 4]]) 10 >>> min_path_sum([[1], [2], [3], [4]]) 10 >>> min_path_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 21","solution":"def min_path_sum(grid): if not grid or not grid[0]: return 0 M, N = len(grid), len(grid[0]) dp = [[0] * N for _ in range(M)] dp[0][0] = grid[0][0] # Initialize the first column for i in range(1, M): dp[i][0] = dp[i-1][0] + grid[i][0] # Initialize the first row for j in range(1, N): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the DP table for i in range(1, M): for j in range(1, N): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[M-1][N-1]"},{"question":"from typing import Dict def word_count(s: str) -> Dict[str, int]: Write a function that takes a string containing multiple words separated by spaces and returns an object where the keys are the words and the values are the number of occurrences of those words in the string. The function should ignore case and punctuation. >>> word_count(\\"Hello world! Hello, universe.\\") == {'hello': 2, 'world': 1, 'universe': 1} >>> word_count(\\"This is a test. This test is only a test.\\") == {'this': 2, 'is': 2, 'a': 2, 'test': 3, 'only': 1} >>> word_count(\\"Coding is fun! Fun coding.\\") == {'coding': 2, 'is': 1, 'fun': 2} Returns a dictionary with words as keys and their occurrences as values, ignoring case and punctuation.","solution":"import re from collections import Counter def word_count(s): Returns a dictionary with words as keys and their occurrences as values, ignoring case and punctuation. # Remove punctuation using regex and convert to lower case cleaned_str = re.sub(r'[^ws]', '', s).lower() # Split the string into words words = cleaned_str.split() # Use collections.Counter to count occurrences of each word return dict(Counter(words))"},{"question":"def merge_intervals(intervals: List[List[int]]) -> List[List[int]]: Merge all overlapping intervals and return the merged intervals in ascending order. >>> merge_intervals([[1, 4], [2, 5], [7, 9]]) [[1, 5], [7, 9]] >>> merge_intervals([[1, 10], [2, 6], [8, 10], [15, 18]]) [[1, 10], [15, 18]] >>> merge_intervals([[5, 10], [1, 4]]) [[1, 4], [5, 10]]","solution":"def merge_intervals(intervals): Given a list of intervals, merges all overlapping intervals and returns the merged intervals in ascending order. if not intervals: return [] # Sort intervals by the start time intervals.sort(key=lambda x: x[0]) merged = [] for interval in intervals: if not merged or merged[-1][1] < interval[0]: merged.append(interval) else: merged[-1][1] = max(merged[-1][1], interval[1]) return merged"},{"question":"def min_swaps_to_sort(original, shuffled): Returns the minimum number of swaps required to sort the shuffled array back to the original order. >>> original = [1, 2, 3, 4, 5] >>> shuffled = [3, 1, 4, 2, 5] >>> min_swaps_to_sort(original, shuffled) 3","solution":"def min_swaps_to_sort(original, shuffled): Returns the minimum number of swaps required to sort the shuffled array back to the original order. index_map = {value: idx for idx, value in enumerate(original)} shuffled_indices = [index_map[val] for val in shuffled] visited = [False] * len(shuffled_indices) swaps = 0 for i in range(len(shuffled_indices)): if visited[i] or shuffled_indices[i] == i: continue cycle_size = 0 x = i while not visited[x]: visited[x] = True x = shuffled_indices[x] cycle_size += 1 if cycle_size > 1: swaps += cycle_size - 1 return swaps"},{"question":"def roman_to_integer(s: str) -> int: Convert a Roman numeral to an integer. Given a string representing a Roman numeral, convert it to an integer. The input string is guaranteed to be a valid Roman numeral from the set {\\"I\\", \\"V\\", \\"X\\", \\"L\\", \\"C\\", \\"D\\", \\"M\\"}. The Roman numeral system works differently than the usual way of writing numbers in our decimal system. Roman numerals are usually written largest to smallest from left to right. However, a numeral like \\"IV\\" stands for 4, not 6. The rules for converting a Roman numeral to an integer are as follows: 1. If a smaller numeral appears before a larger numeral, subtract the smaller numeral. 2. Otherwise, add all numerals together. Here is the value of each Roman numeral: * I -> 1 * V -> 5 * X -> 10 * L -> 50 * C -> 100 * D -> 500 * M -> 1000 >>> roman_to_integer(\\"III\\") 3 >>> roman_to_integer(\\"IV\\") 4 >>> roman_to_integer(\\"IX\\") 9 >>> roman_to_integer(\\"LVIII\\") 58 >>> roman_to_integer(\\"MCMXCIV\\") 1994","solution":"def roman_to_integer(s: str) -> int: Convert a Roman numeral to an integer. :param s: A string representing the Roman numeral. :return: The integer representation of the Roman numeral. roman_values = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 } total = 0 prev_value = 0 for char in reversed(s): value = roman_values[char] if value < prev_value: total -= value else: total += value prev_value = value return total"},{"question":"def find_min_difference(arr: List[int]) -> int: Find the minimum difference of the sums of two partitions of the given array. >>> find_min_difference([1, 6, 11, 5]) 1 >>> find_min_difference([1, 2, 3, 4, 5]) 1 >>> find_min_difference([3]) 3 >>> find_min_difference([]) 0 >>> find_min_difference([1, 1, 2, 2]) 0 >>> find_min_difference([10, 20, 15, 5, 25]) 5 >>> find_min_difference([8, 3]) 5 >>> find_min_difference([4, 4, 4, 4]) 0 >>> find_min_difference([1, 100, 1, 100, 1, 100]) 97","solution":"def find_min_difference(arr): Find the minimum difference of the sums of two partitions of the given array. total_sum = sum(arr) n = len(arr) # Create a DP table to store results of subproblems dp = [[False] * (total_sum // 2 + 1) for _ in range(n + 1)] # Initialize dp[i][0] as True (0 sum is possible with all elements) for i in range(n + 1): dp[i][0] = True # Fill the partition table in bottom up manner for i in range(1, n + 1): for j in range(1, total_sum // 2 + 1): if arr[i-1] <= j: dp[i][j] = dp[i-1][j] or dp[i-1][j - arr[i-1]] else: dp[i][j] = dp[i-1][j] # Find the maximum value of j such that dp[n][j] # is True where j loops from total_sum//2 to 0 diff = float('inf') for j in range(total_sum // 2, -1, -1): if dp[n][j] == True: diff = total_sum - 2 * j break return diff"},{"question":"def skyscrapers_visibility(heights: List[int]) -> int: Returns the number of skyscrapers that have an unobstructed view of the horizon (i.e., are higher than any skyscraper that came before them as you look from left to right). >>> skyscrapers_visibility([3, 7, 8, 3, 6, 1, 5]) 3 >>> skyscrapers_visibility([1, 2, 3, 4, 5]) 5 >>> skyscrapers_visibility([5, 4, 3, 2, 1]) 1 >>> skyscrapers_visibility([3, 3, 3, 3, 3]) 1","solution":"def skyscrapers_visibility(heights): Returns the number of skyscrapers that have an unobstructed view of the horizon. if not heights: return 0 max_height = heights[0] visible_count = 1 # first skyscraper is always visible for height in heights[1:]: if height > max_height: visible_count += 1 max_height = height return visible_count"},{"question":"def count_outgoing_routes(n: int, matrix: List[List[int]]) -> int: Returns the number of locations with at least one direct outgoing route. Parameters: - n: an integer representing the number of locations. - matrix: a 2D list of size n x n containing binary values (0s and 1s). Returns: - an integer representing the number of locations with at least one direct outgoing route. >>> count_outgoing_routes(3, [ ... [0, 1, 0], ... [0, 0, 1], ... [1, 0, 0] ... ]) == 3 >>> count_outgoing_routes(4, [ ... [0, 0, 0, 0], ... [0, 0, 0, 0], ... [0, 0, 0, 0], ... [0, 0, 0, 0] ... ]) == 0 >>> count_outgoing_routes(3, [ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) == 3 >>> count_outgoing_routes(2, [ ... [0, 0], ... [0, 0] ... ]) == 0 >>> count_outgoing_routes(1, [ ... [0] ... ]) == 0 >>> count_outgoing_routes(1, [ ... [1] ... ]) == 1","solution":"def count_outgoing_routes(n, matrix): Returns the number of locations with at least one direct outgoing route. Parameters: - n: an integer representing the number of locations. - matrix: a 2D list of size n x n containing binary values (0s and 1s). Returns: - an integer representing the number of locations with at least one direct outgoing route. count = 0 for i in range(n): if any(matrix[i][j] == 1 for j in range(n)): count += 1 return count"},{"question":"def two_sum(nums: List[int], target: int) -> List[int]: Returns the indices of the two numbers such that they add up to target. >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([3, 2, 4], 6) [1, 2] >>> two_sum([3, 3], 6) [0, 1] >>> two_sum([1, 2, 3], 7) [] >>> two_sum([-1, -2, -3, -4], -6) [1, 3] >>> two_sum([-1, 2, -3, 4], 1) [0, 1] >>> two_sum([10**9, 2 * 10**9 - 1], 3 * 10**9 - 1) [0, 1]","solution":"def two_sum(nums, target): Returns the indices of the two numbers such that they add up to target. :param nums: List[int] - A list of integers. :param target: int - The target sum. :return: List[int] - The indices of the two numbers that add up to target, or an empty list if no such numbers exist. num_to_index = {} for index, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], index] num_to_index[num] = index return []"},{"question":"def word_break(s: str, words: List[str]) -> bool: Determines if the string s can be segmented into a space-separated sequence of one or more dictionary words from the list words. :param s: Input string :param words: List of words (dictionary) :return: True if s can be segmented, else False Example: >>> word_break(\\"leetcode\\", [\\"leet\\", \\"code\\"]) True >>> word_break(\\"applepenapple\\", [\\"apple\\", \\"pen\\"]) True >>> word_break(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) False","solution":"def word_break(s, words): Determines if the string s can be segmented into a space-separated sequence of one or more dictionary words from the list words. :param s: Input string :param words: List of words (dictionary) :return: True if s can be segmented, else False word_set = set(words) dp = [False] * (len(s) + 1) dp[0] = True for i in range(1, len(s) + 1): for j in range(i): if dp[j] and s[j:i] in word_set: dp[i] = True break return dp[-1]"},{"question":"def check_spelling(document: List[str], dictionary: Set[str]) -> List[Tuple[str, int]]: Checks spelling in the document against the dictionary and returns a list of incorrect words and their indices. Parameters: document (list): A list of words representing the document. dictionary (set): A set of valid words representing the dictionary. Returns: list: A list of tuples containing incorrect words and their indices. >>> document = [\\"This\\", \\"is\\", \\"a\\", \\"simple\\", \\"text\\", \\"document\\"] >>> dictionary = {\\"this\\", \\"is\\", \\"a\\", \\"simple\\", \\"text\\", \\"document\\"} >>> check_spelling(document, dictionary) [] >>> document = [\\"This\\", \\"is\\", \\"a\\", \\"smple\\", \\"txt\\", \\"document\\"] >>> dictionary = {\\"this\\", \\"is\\", \\"a\\", \\"simple\\", \\"text\\", \\"document\\"} >>> check_spelling(document, dictionary) [('smple', 3), ('txt', 4)]","solution":"def check_spelling(document, dictionary): Checks spelling in the document against the dictionary and returns a list of incorrect words and their indices. Parameters: document (list): A list of words representing the document. dictionary (set): A set of valid words representing the dictionary. Returns: list: A list of tuples containing incorrect words and their indices. incorrect_words = [] dictionary_lower = {word.lower() for word in dictionary} for index, word in enumerate(document): if word.lower() not in dictionary_lower: incorrect_words.append((word, index)) return incorrect_words"},{"question":"from typing import List, Tuple def minimum_cost_to_connect_all_cities(n: int, edges: List[Tuple[int, int, int]]) -> int: Determine the minimum total cost required to connect all cities in the kingdom. The function takes the number of cities (n) and a list of possible roads (edges) where each road is a tuple (u, v, c) representing a road between cities u and v with cost c. >>> minimum_cost_to_connect_all_cities(4, [(1, 2, 5), (1, 3, 10), (1, 4, 6), (2, 3, 15), (3, 4, 4)]) 15 >>> minimum_cost_to_connect_all_cities(4, []) -1 >>> minimum_cost_to_connect_all_cities(1, []) 0 >>> minimum_cost_to_connect_all_cities(2, [(1, 2, 7)]) 7 >>> minimum_cost_to_connect_all_cities(3, [(1, 2, 1), (2, 3, 2), (1, 3, 3)]) 3","solution":"def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def kruskal(n, edges): parent = [] rank = [] for node in range(n): parent.append(node) rank.append(0) edges = sorted(edges, key=lambda item: item[2]) result = [] e = 0 i = 0 while e < n - 1: u, v, w = edges[i] i += 1 x = find(parent, u - 1) y = find(parent, v - 1) if x != y: e += 1 result.append([u, v, w]) union(parent, rank, x, y) minimumCost = 0 for u, v, weight in result: minimumCost += weight return minimumCost def minimum_cost_to_connect_all_cities(n, edges): if n == 1: return 0 if len(edges) == 0: return -1 return kruskal(n, edges)"},{"question":"def has_pair_with_difference(nums: List[int], k: int) -> bool: Returns True if there exists two numbers in the array such that their difference is k, otherwise False. >>> has_pair_with_difference([1, 5, 11, 9], 4) True >>> has_pair_with_difference([2, 7, 3, 1], 5) True >>> has_pair_with_difference([1, 2, 3, 4], 10) False >>> has_pair_with_difference([5, 3, 10, 7], 2) True","solution":"def has_pair_with_difference(nums, k): Returns True if there exists two numbers in the array such that their difference is k, otherwise False. nums_set = set(nums) for num in nums: if (num + k) in nums_set or (num - k) in nums_set: return True return False"},{"question":"from typing import List, Tuple def most_frequent_character_frequency(S: str, queries: List[Tuple[int, int]]) -> List[int]: For each query described by two integers L and R, find the frequency of the most frequent character in the substring S[L..R] (inclusive, 1-indexed). >>> most_frequent_character_frequency(\\"abbabab\\", [(1, 3), (4, 6), (1, 7)]) [2, 2, 4] >>> most_frequent_character_frequency(\\"a\\", [(1, 1)]) [1] >>> most_frequent_character_frequency(\\"abcdef\\", [(1, 6), (2, 5)]) [1, 1] >>> most_frequent_character_frequency(\\"aaabbbccc\\", [(1, 3), (1, 6), (4, 9)]) [3, 3, 3] >>> most_frequent_character_frequency(\\"ababc\\", [(1, 5), (1, 2)]) [2, 1] >>> most_frequent_character_frequency(\\"aabbcc\\", [(1, 2), (3, 4), (5, 6), (1, 6)]) [2, 2, 2, 2]","solution":"from collections import Counter def most_frequent_character_frequency(S, queries): results = [] for L, R in queries: substring = S[L-1:R] frequency = Counter(substring) most_frequent = max(frequency.values()) results.append(most_frequent) return results"},{"question":"def largest_consecutive_product(digits: str, k: int) -> int: Returns the largest product of k consecutive digits in the string. :param digits: A string of digits (0-9). :param k: An integer representing the number of consecutive digits to multiply. :return: An integer representing the largest product of k consecutive digits. >>> largest_consecutive_product(\\"123456789\\", 5) == 15120 >>> largest_consecutive_product(\\"0000\\", 2) == 0 >>> largest_consecutive_product(\\"73167176531330624919225119674426574742355349194934\\", 6) == 23520 >>> largest_consecutive_product(\\"12345\\", 0) == 0 >>> largest_consecutive_product(\\"123\\", 4) == 0 >>> largest_consecutive_product(\\"12345\\", 1) == 5 >>> largest_consecutive_product(\\"000000\\", 2) == 0 >>> largest_consecutive_product(\\"3\\" * 1000, 100) == 3**100","solution":"def largest_consecutive_product(digits: str, k: int) -> int: Returns the largest product of k consecutive digits in the string. :param digits: A string of digits (0-9). :param k: An integer representing the number of consecutive digits to multiply. :return: An integer representing the largest product of k consecutive digits. if k == 0 or k > len(digits): return 0 max_product = 0 for i in range(len(digits) - k + 1): product = 1 for j in range(k): product *= int(digits[i + j]) if product > max_product: max_product = product return max_product"},{"question":"def sum_even_indices(nums: List[int]) -> str: Returns the sum of elements at even indices as a string. If the list is empty, returns \\"empty list\\". >>> sum_even_indices([10, 22, 35, 47, 50]) == \\"95\\" >>> sum_even_indices([3, 5, 2, 8, 1]) == \\"6\\" >>> sum_even_indices([]) == \\"empty list\\"","solution":"def sum_even_indices(nums): Returns the sum of elements at even indices as a string. If the list is empty, returns \\"empty list\\". if not nums: return \\"empty list\\" sum_even = sum(nums[i] for i in range(0, len(nums), 2)) return str(sum_even)"},{"question":"def num_islands(grid: List[List[str]]) -> int: Returns the number of islands in the given grid. >>> num_islands([[\\"1\\", \\"1\\", \\"1\\", \\"1\\", \\"0\\"], [\\"1\\", \\"1\\", \\"0\\", \\"1\\", \\"0\\"], [\\"1\\", \\"1\\", \\"0\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"0\\", \\"0\\", \\"0\\"]]) == 1 >>> num_islands([[\\"1\\", \\"1\\", \\"0\\", \\"0\\", \\"0\\"], [\\"1\\", \\"1\\", \\"0\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"1\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"0\\", \\"1\\", \\"1\\"]]) == 3 >>> num_islands([[\\"0\\", \\"0\\", \\"0\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"0\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"0\\", \\"0\\", \\"0\\"]]) == 0 >>> num_islands([[\\"1\\", \\"1\\", \\"1\\", \\"1\\", \\"1\\"], [\\"1\\", \\"1\\", \\"1\\", \\"1\\", \\"1\\"], [\\"1\\", \\"1\\", \\"1\\", \\"1\\", \\"1\\"]]) == 1 >>> num_islands([]) == 0 >>> num_islands([[\\"1\\"]]) == 1 >>> num_islands([[\\"0\\"]]) == 0","solution":"def num_islands(grid): Returns the number of islands in the given grid. if not grid or not grid[0]: return 0 def dfs(x, y): if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]) or grid[x][y] == '0': return grid[x][y] = '0' # Mark visited # Explore the neighbors dfs(x + 1, y) dfs(x - 1, y) dfs(x, y + 1) dfs(x, y - 1) num_islands_count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == '1': num_islands_count += 1 dfs(i, j) return num_islands_count"},{"question":"def longest_unique_substring(s: str) -> int: Returns the length of the longest substring with all unique characters. >>> longest_unique_substring(\\"abcabcbb\\") 3 >>> longest_unique_substring(\\"bbbbb\\") 1 >>> longest_unique_substring(\\"pwwkew\\") 3 >>> longest_unique_substring(\\"\\") 0 >>> longest_unique_substring(\\"abcdefg\\") 7 >>> longest_unique_substring(\\"aab\\") 2 >>> longest_unique_substring(\\"dvdf\\") 3 >>> longest_unique_substring(\\"anviaj\\") 5","solution":"def longest_unique_substring(s): Returns the length of the longest substring with all unique characters. char_index_map = {} longest = 0 start = 0 for end in range(len(s)): if s[end] in char_index_map: start = max(start, char_index_map[s[end]] + 1) char_index_map[s[end]] = end longest = max(longest, end - start + 1) return longest"},{"question":"def intersection_of_arrays(list1, list2): Write a function \`intersection_of_arrays\` that takes two lists of integers as input and returns a new list containing their intersection (i.e., elements that appear in both lists). The resulting list should not contain any duplicates and should preserve the original order of the first list. >>> intersection_of_arrays([1, 2, 2, 1], [2, 2]) [2] >>> intersection_of_arrays([4, 9, 5], [9, 4, 9, 8, 4]) [4, 9] from solution import intersection_of_arrays def test_intersection_with_duplicates(): assert intersection_of_arrays([1, 2, 2, 1], [2, 2]) == [2] def test_intersection_with_non_duplicate_lists(): assert intersection_of_arrays([4, 9, 5], [9, 4, 9, 8, 4]) == [4, 9] def test_intersection_with_no_common_elements(): assert intersection_of_arrays([1, 2, 3], [4, 5, 6]) == [] def test_intersection_with_one_empty_list(): assert intersection_of_arrays([1, 2, 3], []) == [] assert intersection_of_arrays([], [1, 2, 3]) == [] def test_intersection_with_both_empty_lists(): assert intersection_of_arrays([], []) == [] def test_intersection_with_all_elements_common(): assert intersection_of_arrays([1, 2, 3], [3, 2, 1]) == [1, 2, 3] def test_intersection_with_larger_lists(): assert intersection_of_arrays(list(range(1000)), list(range(500, 1500))) == list(range(500, 1000))","solution":"def intersection_of_arrays(list1, list2): Returns a list containing the intersection of list1 and list2, preserving the order of appearance in list1 and without duplicates. Parameters: list1 (list): The first list of integers. list2 (list): The second list of integers. Returns: list: A list containing the intersection elements. set2 = set(list2) seen = set() result = [] for num in list1: if num in set2 and num not in seen: result.append(num) seen.add(num) return result"},{"question":"def length_of_longest_substring(s: str) -> int: Given a string, find the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. n = len(s) if n == 0: return 0 char_index_map = {} max_length, start = 0, 0 for end in range(n): if s[end] in char_index_map: start = max(start, char_index_map[s[end]] + 1) char_index_map[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"def generate_pascals_triangle(n: int) -> list: Generate the first n rows of Pascal's Triangle. >>> generate_pascals_triangle(1) == [[1]] >>> generate_pascals_triangle(2) == [[1], [1, 1]] >>> generate_pascals_triangle(3) == [[1], [1, 1], [1, 2, 1]] >>> generate_pascals_triangle(5) == [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]","solution":"def generate_pascals_triangle(n: int) -> list: Generate the first n rows of Pascal's Triangle. Args: n (int): Number of rows of Pascal's Triangle to generate. Returns: list: A two-dimensional list representing the first n rows of Pascal's Triangle. if n <= 0: return [] triangle = [[1]] for i in range(1, n): row = [1] for j in range(1, i): row.append(triangle[i-1][j-1] + triangle[i-1][j]) row.append(1) triangle.append(row) return triangle"},{"question":"def sumUniqueNumbers(arr): Returns the sum of all unique numbers in the array. Given an array of integers, calculate the sum of all the unique integers within the array. Parameters: arr (list): A list of integer numbers. Returns: int: The sum of unique numbers. Example: >>> sumUniqueNumbers([1, 2, 3, 2, 1]) 3 >>> sumUniqueNumbers([4, 4, 5, 6]) 11 pass # Test cases def test_sum_of_unique_numbers(): assert sumUniqueNumbers([1, 2, 3, 2, 1]) == 3 assert sumUniqueNumbers([4, 4, 5, 6]) == 11 assert sumUniqueNumbers([-1, 2, -1, 3, 4]) == 9 assert sumUniqueNumbers([10, 20, 10, -10, -10]) == 20 assert sumUniqueNumbers([1, 1, 1, 1, 1]) == 0 assert sumUniqueNumbers([1, 2, 3, 4]) == 10 assert sumUniqueNumbers([-1, -2, -2, -3, -1]) == -3 assert sumUniqueNumbers([0, 1, -1, 2, -2]) == 0","solution":"def sumUniqueNumbers(arr): Returns the sum of all unique numbers in the array. Parameters: arr (list): A list of integer numbers. Returns: int: The sum of unique numbers. from collections import Counter # Count occurrences of each number count = Counter(arr) # Calculate sum of numbers with exactly one occurrence unique_sum = sum(num for num, freq in count.items() if freq == 1) return unique_sum"},{"question":"def number_of_characters(n: int) -> int: Returns the number of characters Sarah can fit in her notebook with n units of space. >>> number_of_characters(1) == 1 >>> number_of_characters(3) == 2 >>> number_of_characters(15) == 4 >>> number_of_characters(1000) == 9 >>> number_of_characters(10**9) == 29","solution":"def number_of_characters(n): Returns the number of characters Sarah can fit in her notebook with n units of space. space_used = 0 char_count = 0 unit_size = 1 while space_used + unit_size <= n: space_used += unit_size char_count += 1 unit_size *= 2 return char_count"},{"question":"def lexicographically_smallest_string(S: str) -> str: Returns the lexicographically smallest string by applying the given operations. >>> lexicographically_smallest_string(\\"abcde\\") \\"abcde\\" >>> lexicographically_smallest_string(\\"ABCDE\\") \\"abcde\\" >>> lexicographically_smallest_string(\\"aBcDe\\") \\"abcde\\" >>> lexicographically_smallest_string(\\"AaBbCc\\") \\"aabbcc\\" >>> lexicographically_smallest_string(\\"a\\") \\"a\\" >>> lexicographically_smallest_string(\\"A\\") \\"a\\" >>> lexicographically_smallest_string(\\"\\") \\"\\"","solution":"def lexicographically_smallest_string(S): Returns the lexicographically smallest string by applying the given operations. Converting all characters to uppercase results in the lexicographically smallest string. return S.lower()"},{"question":"def sum_of_squares(n: int) -> int: Write a function named \`sum_of_squares\` that takes an integer \`n\` as input and returns the sum of the squares of the first \`n\` natural numbers. The input \`n\` will be a positive integer. For example: >>> sum_of_squares(3) 14 >>> sum_of_squares(5) 55 >>> sum_of_squares(1) 1","solution":"def sum_of_squares(n): Returns the sum of the squares of the first n natural numbers. Parameters: n (int): The number of terms to consider. Must be a positive integer. Returns: int: The sum of the squares of the first n natural numbers. return sum(i**2 for i in range(1, n+1))"},{"question":"from typing import List def is_mountain_array(arr: List[int]) -> bool: Determine if the given array is a mountain array. An array is considered a mountain array if the following conditions are satisfied: 1. The array has at least 3 elements. 2. There exists some index \`i\` (0 < i < arr.length - 1) such that: - \`arr[0] < arr[1] < ... < arr[i-1] < arr[i]\` - \`arr[i] > arr[i+1] > ... > arr[arr.length - 1]\` Args: arr (List[int]): The input array to be checked. Returns: bool: True if the input array is a mountain array, otherwise False. Examples: >>> is_mountain_array([2, 1]) False >>> is_mountain_array([3, 5, 5]) False >>> is_mountain_array([0, 3, 2, 1]) True # Unit tests def test_is_mountain_array(): assert not is_mountain_array([]) assert not is_mountain_array([1]) assert not is_mountain_array([1, 2]) assert not is_mountain_array([2, 1]) assert not is_mountain_array([3, 5, 5]) assert not is_mountain_array([0, 2, 3, 3, 2, 1]) assert not is_mountain_array([2, 1, 2, 3, 4, 5]) assert not is_mountain_array([0, 1, 2, 3, 4, 5]) assert not is_mountain_array([6, 5, 4, 3, 2, 1]) assert is_mountain_array([0, 3, 2, 1]) assert is_mountain_array([1, 2, 3, 4, 3, 2, 1]) assert is_mountain_array([1, 5, 3]) assert is_mountain_array([0, 3, 5, 2, 1]) assert is_mountain_array([2, 3, 4, 1]) assert is_mountain_array([1, 3, 2]) assert is_mountain_array([1, 2, 1]) assert not is_mountain_array([1, 1, 2, 1]) assert not is_mountain_array([2, 1, 1, 2]) assert not is_mountain_array([3, 4, 2, 2])","solution":"def is_mountain_array(arr): Determine if the given array is a mountain array. :param arr: List[int] - The input array to be checked. :return: bool - True if the input array is a mountain array, otherwise False. n = len(arr) if n < 3: return False i = 1 # Ascend until we find the peak while i < n and arr[i] > arr[i - 1]: i += 1 # Peak can't be first or last element if i == 1 or i == n: return False # Descend from the peak while i < n and arr[i] < arr[i - 1]: i += 1 # If we reached the end, array is valid mountain array return i == n"},{"question":"def sum_of_digits_of_power_of_2(n: int) -> int: Given a positive integer \`n\`, compute the sum of all the digits of \`2^n\`. Return the sum of the digits as an integer. Args: n (int): A positive integer (1 ≤ n ≤ 1000) Returns: int: The sum of the digits of \`2^n\` >>> sum_of_digits_of_power_of_2(15) 26 >>> sum_of_digits_of_power_of_2(100) 115 >>> sum_of_digits_of_power_of_2(1) 2 >>> sum_of_digits_of_power_of_2(10) 7 >>> sum_of_digits_of_power_of_2(0) 1","solution":"def sum_of_digits_of_power_of_2(n): Computes the sum of all the digits of 2 raised to the power of n. Args: n (int): A positive integer (1 ≤ n ≤ 1000). Returns: int: Sum of the digits of 2^n. # Calculate 2 to the power of n power_value = 2 ** n # Convert the power value to a string to iterate through digits power_value_str = str(power_value) # Calculate the sum of the digits digit_sum = sum(int(digit) for digit in power_value_str) return digit_sum"},{"question":"def longest_increasing_subarray_len(sales: List[int]) -> int: Returns the length of the longest subarray where each element is greater than the previous one. Args: sales (List[int]): List of sales records. Returns: int: Length of the longest increasing subarray. >>> longest_increasing_subarray_len([5, 6, 3, 5, 7, 8, 9, 1, 2]) 5 >>> longest_increasing_subarray_len([1, 2, 3, 4, 5]) 5 >>> longest_increasing_subarray_len([10, 9, 8, 7, 6]) 1 >>> longest_increasing_subarray_len([3, 3, 3, 3, 3]) 1 >>> longest_increasing_subarray_len([1, 2, 2, 3, 4, 1, 6, 7]) 3","solution":"def longest_increasing_subarray_len(sales): Returns the length of the longest subarray where each element is greater than the previous one. Args: sales (list of int): List of sales records. Return: int: Length of the longest increasing subarray. if not sales: return 0 max_len = 1 current_len = 1 for i in range(1, len(sales)): if sales[i] > sales[i - 1]: current_len += 1 else: max_len = max(max_len, current_len) current_len = 1 return max(max_len, current_len)"},{"question":"def modify_list(L: int, queries: List[Tuple[str, int]]) -> List[int]: Modify the list of integers based on a series of instructions and return the sums of the elements in the list after each instruction. Parameters: L (int): The length of the list (initially contains integers from 1 to L). queries (list): A list of tuples where each tuple contains a command and a value. Returns: list: A list of sums after applying each instruction. >>> modify_list(5, [(\\"ADD\\", 2), (\\"MUL\\", 3), (\\"SET\\", 4), (\\"ADD\\", 1)]) [25, 75, 20, 25] >>> modify_list(3, [(\\"ADD\\", 5)]) [21] >>> modify_list(3, [(\\"MUL\\", 4)]) [24] >>> modify_list(4, [(\\"SET\\", 2)]) [8] >>> modify_list(4, [(\\"ADD\\", 2), (\\"MUL\\", 2), (\\"SET\\", 3)]) [18, 36, 12] pass def parse_input(input_string: str) -> Tuple[int, int, List[Tuple[str, int]]]: Parse input string into L, Q, and queries Parameters: input_string (str): Multi-line input string Returns: tuple: L, Q, and list of queries pass","solution":"def modify_list(L, queries): Modify the list of integers based on a series of instructions and return the sums of the elements in the list after each instruction. Parameters: L (int): The length of the list (initially contains integers from 1 to L). queries (list): A list of tuples where each tuple contains a command and a value. Returns: list: A list of sums after applying each instruction. # Initial list elements = list(range(1, L + 1)) results = [] for command, value in queries: if command == \\"ADD\\": elements = [x + value for x in elements] elif command == \\"MUL\\": elements = [x * value for x in elements] elif command == \\"SET\\": elements = [value] * L results.append(sum(elements)) return results def parse_input(input_string): Parse input string into L, Q, and queries Parameters: input_string (str): Multi-line input string Returns: tuple: L, Q, and list of queries lines = input_string.strip().split(\\"n\\") L = int(lines[0]) Q = int(lines[1]) queries = [] for i in range(2, 2 + Q): parts = lines[i].split() queries.append((parts[0], int(parts[1]))) return L, Q, queries"},{"question":"def longestUniformSubarray(arr): Returns the length of the longest subarray with all elements the same. If the input is not an array of integers, return None. >>> longestUniformSubarray([1, 1, 0, 1, 1, 1]) == 3 >>> longestUniformSubarray([]) == 0 >>> longestUniformSubarray([5, 5, 5, 5, 5]) == 5 >>> longestUniformSubarray([3, 1, 2, 3]) == 1 >>> longestUniformSubarray(\\"string\\") == None >>> longestUniformSubarray([1, \\"string\\", 3]) == None >>> longestUniformSubarray([7]) == 1 >>> longestUniformSubarray([1, 2, 2, 2, 3, 3, 3, 3, 1, 1]) == 4 >>> longestUniformSubarray([-1, -1, -1, 0, 0, -1, -1, -1, -1]) == 4","solution":"def longestUniformSubarray(arr): Returns the length of the longest subarray with all elements the same. If the input is not an array of integers, return None. if not isinstance(arr, list) or not all(isinstance(x, int) for x in arr): return None if not arr: return 0 max_length = 1 current_length = 1 current_value = arr[0] for value in arr[1:]: if value == current_value: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 current_value = value max_length = max(max_length, current_length) return max_length"},{"question":"from datetime import datetime from typing import List def format_date(date_string: str) -> str: Formats a date string (YYYY-MM-DD) into a more readable format (Month day, Year). Args: date_string (str): The date string in the format 'YYYY-MM-DD'. Returns: str: The formatted date string in the format 'Month day, Year'. Example: >>> format_date(\\"2023-10-25\\") 'October 25, 2023' >>> format_date(\\"1989-07-22\\") 'July 22, 1989' >>> format_date(\\"2000-01-01\\") 'January 1, 2000'","solution":"from datetime import datetime def format_date(date_string): Formats a date string (YYYY-MM-DD) into a more readable format (Month day, Year). Args: date_string (str): The date string in the format 'YYYY-MM-DD'. Returns: str: The formatted date string in the format 'Month day, Year'. date_object = datetime.strptime(date_string, '%Y-%m-%d') formatted_date = date_object.strftime('%B %-d, %Y') return formatted_date"},{"question":"def convertVowels(s: str) -> str: Replaces all vowels in the input string with their respective positions in the alphabet. Maintain the case sensitivity of the original string. >>> convertVowels(\\"hello\\") 'h5ll15' >>> convertVowels(\\"HELLO\\") 'H5LL15' >>> convertVowels(\\"Case\\") 'C1s5' >>> convertVowels(\\"bcdlmn\\") 'bcdlmn' >>> convertVowels(\\"aeiouAEIOU\\") '15915211591521' >>> convertVowels(\\"\\") '' >>> convertVowels(\\"Hello, World!\\") 'H5ll15, W15rld!'","solution":"def convertVowels(s): Replaces all vowels in the input string with their respective positions in the alphabet. Maintain the case sensitivity of the original string. vowel_map = { 'a': '1', 'A': '1', 'e': '5', 'E': '5', 'i': '9', 'I': '9', 'o': '15', 'O': '15', 'u': '21', 'U': '21' } result = [] for char in s: if char in vowel_map: result.append(vowel_map[char]) else: result.append(char) return ''.join(result)"},{"question":"def product_of_digits(n: int) -> int: Returns the product of the digits of a positive integer n. Parameters: n (int): A positive integer up to 10 digits long. Returns: int: The product of the digits of n. >>> product_of_digits(234) 24 >>> product_of_digits(1234567890) 0 >>> product_of_digits(987654321) 362880 >>> product_of_digits(1000000000) 0 >>> product_of_digits(5) 5 >>> product_of_digits(23) 6","solution":"def product_of_digits(n): Returns the product of the digits of a positive integer n. Parameters: n (int): A positive integer up to 10 digits long. Returns: int: The product of the digits of n. product = 1 while n > 0: digit = n % 10 product *= digit n //= 10 return product"},{"question":"from typing import List def subset_sum(nums: List[int], target: int) -> List[int]: Determines if there exists a subset of nums that adds up to target. If such a subset exists, returns the subset, otherwise returns an empty array. >>> subset_sum([3, 34, 4, 12, 5, 2], 9) in [[4, 5], [5, 4]] True >>> subset_sum([1, 2, 3, 7], 6) in [[1, 2, 3], [3, 2, 1]] True >>> subset_sum([2, 3, 7, 8, 10], 11) in [[3, 8], [8, 3]] True >>> subset_sum([1, 2, 3], 7) == [] True","solution":"def subset_sum(nums, target): Determines if there exists a subset of nums that adds up to target. If such a subset exists, returns the subset, otherwise returns an empty array. subset = [] n = len(nums) # Create a 2D dp array where dp[i][j] will be True if there is a subset of nums[0..i-1] with sum j dp = [[False for j in range(target + 1)] for i in range(n + 1)] # If sum is 0, then answer is True for i in range(n + 1): dp[i][0] = True # Fill the dp array for i in range(1, n + 1): for j in range(1, target + 1): if nums[i-1] <= j: dp[i][j] = dp[i-1][j] or dp[i-1][j-nums[i-1]] else: dp[i][j] = dp[i-1][j] # Return empty array if there's no subset found if not dp[n][target]: return [] # Trace the subset i, j = n, target while i > 0 and j > 0: if dp[i][j] and not dp[i-1][j]: subset.append(nums[i-1]) j -= nums[i-1] i -= 1 return subset[::-1]"},{"question":"def colony_growth(init_size: int, max_size: int, hours: int) -> int: Simulates the growth of a bacterial colony. The colony doubles in size every hour. If the colony size after any hour exceeds max_size, it should be capped at max_size. Parameters: - init_size: int, initial size of the colony. - max_size: int, maximum size the colony can reach before it stops growing. - hours: int, number of hours to observe the growth. Returns: - int, size of the colony after the given number of hours. >>> colony_growth(2, 100, 5) 32 >>> colony_growth(5, 100, 4) 80 >>> colony_growth(10, 100, 10) 100","solution":"def colony_growth(init_size, max_size, hours): Simulates the growth of a bacterial colony. Parameters: - init_size: int, initial size of the colony. - max_size: int, maximum size the colony can reach before it stops growing. - hours: int, number of hours to observe the growth. Returns: - int, size of the colony after the given number of hours. size = init_size for _ in range(hours): size *= 2 if size > max_size: size = max_size break return size"},{"question":"from typing import List, Tuple def process_test_cases(test_cases: List[Tuple[int, int, List[str]]]) -> List[int]: For each test case, count the number of islands in the grid. :param test_cases: A list of tuples, where each tuple consists of the number of rows, number of columns, and the grid itself represented as a list of strings. :return: A list of integers representing the number of islands for each test case. Examples: >>> process_test_cases([(4, 5, ['11000', '11000', '00100', '00011'])]) [3] >>> process_test_cases([(4, 4, ['1111', '0000', '0110', '0010'])]) [2] if __name__ == \\"__main__\\": # Unit tests to validate the solution def test_case_1(): test_cases = [ (4, 5, ['11000', '11000', '00100', '00011']), (4, 4, ['1111', '0000', '0110', '0010']), ] expected = [3, 2] assert process_test_cases(test_cases) == expected def test_empty_grid(): test_cases = [ (0, 0, []), ] expected = [0] assert process_test_cases(test_cases) == expected def test_all_water(): test_cases = [ (3, 3, ['000', '000', '000']), ] expected = [0] assert process_test_cases(test_cases) == expected def test_all_land(): test_cases = [ (3, 3, ['111', '111', '111']), ] expected = [1] assert process_test_cases(test_cases) == expected def test_multiple_islands(): test_cases = [ (3, 3, ['101', '000', '101']), ] expected = [4] assert process_test_cases(test_cases) == expected test_case_1() test_empty_grid() test_all_water() test_all_land() test_multiple_islands()","solution":"def island_count(grid): Returns the number of islands in the given grid. if not grid: return 0 rowCount = len(grid) colCount = len(grid[0]) count = 0 def dfs(r, c): if r < 0 or r >= rowCount or c < 0 or c >= colCount or grid[r][c] == '0': return grid[r][c] = '0' # mark as visited dfs(r + 1, c) # check down dfs(r - 1, c) # check up dfs(r, c + 1) # check right dfs(r, c - 1) # check left for r in range(rowCount): for c in range(colCount): if grid[r][c] == '1': count += 1 dfs(r, c) return count def process_test_cases(test_cases): results = [] for (rows, cols, grid) in test_cases: grid_list = [list(row) for row in grid] results.append(island_count(grid_list)) return results"},{"question":"def track_max_coins(m, operations): Returns a list of the maximum number of coins in the stack after each operation. Args: m (int): The number of operations. operations (list of tuples): Each tuple contains the operation code and the corresponding value. Returns: list: A list containing the maximum number of coins in the stack after each operation.","solution":"def track_max_coins(m, operations): Returns a list of the maximum number of coins in the stack after each operation. Args: m (int): The number of operations. operations (list of tuples): Each tuple contains the operation code and the corresponding value. Returns: list: A list containing the maximum number of coins in the stack after each operation. stack = [] max_coins = 0 result = [] for operation in operations: if operation[0] == 1: # Add operation coins = operation[1] stack.append(coins) max_coins += coins elif operation[0] == 2: # Remove operation coins = operation[1] stack[-1] -= coins if stack[-1] == 0: stack.pop() max_coins -= coins elif operation[0] == 3: # Get maximum operation result.append(max_coins) if operation[0] != 3: # For non-max operations, always append the current max_coins result.append(max_coins) return result"},{"question":"def length_of_shortest_word(s: str) -> int: Given a string of words separated by spaces, return the length of the shortest word. >>> length_of_shortest_word(\\"The cow jumped over the moon\\") 3 >>> length_of_shortest_word(\\"A quick brown fox.\\") 1 >>> length_of_shortest_word(\\"Hi there\\") 2 >>> length_of_shortest_word(\\"O'Neill is responsible!\\") 2 >>> length_of_shortest_word(\\" fly me to the moon \\") 2 >>> length_of_shortest_word(\\"It's been a long day!\\") 1 # Your implementation here","solution":"def length_of_shortest_word(s): Returns the length of the shortest word in the string s. words = s.split() shortest_length = min(len(word) for word in words) return shortest_length"},{"question":"from typing import List def min_cost(grid: List[List[int]]) -> int: Calculate the minimum cost required to travel from the top-left cell to the bottom-right cell of a 2D grid. >>> min_cost([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_cost([[1, 2], [1, 1]]) 3 >>> min_cost([[5, 5, 5], [5, 5, 5], [5, 5, 5]]) 25 >>> min_cost([[1000, 1000, 1000], [1000, 1000, 1000], [1000, 1000, 1000]]) 5000 >>> min_cost([[5]]) 5","solution":"import heapq def min_cost(grid): n = len(grid) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # right, down, left, up costs = [[float('inf')]*n for _ in range(n)] costs[0][0] = grid[0][0] priority_queue = [(grid[0][0], 0, 0)] # (cost, x, y) while priority_queue: current_cost, x, y = heapq.heappop(priority_queue) if x == n-1 and y == n-1: return current_cost for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n: new_cost = current_cost + grid[nx][ny] if new_cost < costs[nx][ny]: costs[nx][ny] = new_cost heapq.heappush(priority_queue, (new_cost, nx, ny)) return costs[n-1][n-1] # Input processing not included in the above function to keep it clean for import and testing. if __name__ == '__main__': n = int(input().strip()) grid = [list(map(int, input().strip().split())) for _ in range(n)] print(min_cost(grid))"},{"question":"def query(dataset: list, mini_query: str) -> list: Perform a basic selection from the dataset based on the MiniQuery string and return matching records. >>> dataset = [ ... {\\"id\\": 1, \\"name\\": \\"Alice\\", \\"age\\": 30, \\"location\\": \\"New York\\"}, ... {\\"id\\": 2, \\"name\\": \\"Bob\\", \\"age\\": 25, \\"location\\": \\"San Francisco\\"}, ... {\\"id\\": 3, \\"name\\": \\"Charlie\\", \\"age\\": 35, \\"location\\": \\"Los Angeles\\"}, ... {\\"id\\": 4, \\"name\\": \\"David\\", \\"age\\": 28, \\"location\\": \\"Seattle\\"} ... ] >>> query(dataset, \\"SELECT * WHERE age > 30\\") [{\\"id\\": 3, \\"name\\": \\"Charlie\\", \\"age\\": 35, \\"location\\": \\"Los Angeles\\"}] >>> query(dataset, \\"SELECT * WHERE location = San Francisco\\") [{\\"id\\": 2, \\"name\\": \\"Bob\\", \\"age\\": 25, \\"location\\": \\"San Francisco\\"}] >>> query(dataset, \\"SELECT * WHERE id != 1\\") [ {\\"id\\": 2, \\"name\\": \\"Bob\\", \\"age\\": 25, \\"location\\": \\"San Francisco\\"}, {\\"id\\": 3, \\"name\\": \\"Charlie\\", \\"age\\": 35, \\"location\\": \\"Los Angeles\\"}, {\\"id\\": 4, \\"name\\": \\"David\\", \\"age\\": 28, \\"location\\": \\"Seattle\\"} ] >>> query(dataset, \\"SELECT * WHERE name = Alice\\") [{\\"id\\": 1, \\"name\\": \\"Alice\\", \\"age\\": 30, \\"location\\": \\"New York\\"}]","solution":"def query(dataset: list, mini_query: str) -> list: Performs a basic selection from the dataset based on the MiniQuery string and returns matching records. # Parse the MiniQuery string _, _, where_clause = mini_query.partition(\\"WHERE\\") field, operator, value = where_clause.strip().split(maxsplit=2) # Convert value to the appropriate type if field in [\\"id\\", \\"age\\"]: value = int(value) else: value = value.strip() # Dictionary to map operators to lambda functions for easy use operators = { \\"=\\": lambda x, y: x == y, \\"!=\\": lambda x, y: x != y, \\"<\\": lambda x, y: x < y, \\">\\": lambda x, y: x > y, \\"<=\\": lambda x, y: x <= y, \\">=\\": lambda x, y: x >= y, } # Filter the dataset based on the MiniQuery condition result = [record for record in dataset if operators[operator](record[field], value)] return result"},{"question":"def max_non_overlapping_projects(projects: List[List[int]]) -> int: Finds the maximum number of non-overlapping projects that can be completed. Args: projects (List[List[int]]): A list of projects where each project is represented as [start, duration]. Returns: int: The maximum number of non-overlapping projects. >>> max_non_overlapping_projects([[1, 2], [3, 2], [0, 1], [5, 3], [4, 2]]) 4 >>> max_non_overlapping_projects([[1, 2]]) 1 >>> max_non_overlapping_projects([[1, 2], [4, 1], [6, 2], [10, 1]]) 4 >>> max_non_overlapping_projects([[1, 2], [2, 2], [3, 2], [4, 2]]) 2 >>> max_non_overlapping_projects([[1, 3], [2, 1], [3, 4], [5, 2], [7, 3]]) 3 pass","solution":"def max_non_overlapping_projects(projects): Finds the maximum number of non-overlapping projects that can be completed. Args: projects (List[List[int]]): A list of projects where each project is represented as [start, duration]. Returns: int: The maximum number of non-overlapping projects. # Calculate the end time for each project projects = [(start, start + duration) for start, duration in projects] # Sort the projects by their ending times projects.sort(key=lambda x: x[1]) # Initialize the end time of the last selected project and the count last_end_time = float('-inf') max_projects = 0 for start, end in projects: if start >= last_end_time: # Select the project last_end_time = end max_projects += 1 return max_projects"},{"question":"def generate_pyramid(letter: str, n: int) -> str: Generates a pyramid using a single uppercase letter and a positive integer n. The pyramid will have n rows and the base of the pyramid will be centered. Args: letter (str): an uppercase letter. n (int): a positive integer representing the number of rows. Returns: str: The pyramid as a string or None if the input conditions are not met. Examples: >>> generate_pyramid('A', 3) \\" An AAAnAAAAA\\" >>> generate_pyramid('B', 4) \\" Bn BBBn BBBBBnBBBBBBB\\"","solution":"def generate_pyramid(letter, n): Generates a pyramid using a single uppercase letter and a positive integer n. The pyramid will have n rows and the base of the pyramid will be centered. Args: letter (str): an uppercase letter. n (int): a positive integer representing the number of rows. Returns: str: The pyramid as a string or None if the input conditions are not met. if not (isinstance(letter, str) and len(letter) == 1 and letter.isupper()): return None if not (isinstance(n, int) and n > 0): return None pyramid_rows = [] for i in range(1, n + 1): row = ' ' * (n - i) + letter * (2 * i - 1) pyramid_rows.append(row) return 'n'.join(pyramid_rows)"},{"question":"def evaluate_expression(expression: str) -> float: Evaluates a mathematical expression consisting of numbers and +, -, *, / operators. Spaces in the expression are ignored. >>> evaluate_expression(\\"3 + 5\\") == 8 >>> evaluate_expression(\\"10 - 5\\") == 5 >>> evaluate_expression(\\"4 * 5\\") == 20 >>> evaluate_expression(\\"20 / 4\\") == 5.0 >>> evaluate_expression(\\"3 + 5 * 2\\") == 13 >>> evaluate_expression(\\"10 + 2 * 6 / 3 - 1\\") == 13 >>> evaluate_expression(\\"7 / 2\\") == 3.5 >>> evaluate_expression(\\" (3 + 5) * 2 \\") == 16","solution":"def evaluate_expression(expression): Evaluates a mathematical expression consisting of numbers and +, -, *, / operators. Spaces in the expression are ignored. # Remove any spaces from the expression expression = expression.replace(\\" \\", \\"\\") # Evaluate the expression return eval(expression)"},{"question":"def findLongestSubstring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> findLongestSubstring(\\"abcabcbb\\") 3 >>> findLongestSubstring(\\"bbbbb\\") 1 >>> findLongestSubstring(\\"pwwkew\\") 3 >>> findLongestSubstring(\\"\\") 0 >>> findLongestSubstring(\\"dvdf\\") 3","solution":"def findLongestSubstring(s: str) -> int: Returns the length of the longest substring without repeating characters. char_index_map = {} max_length = 0 start = 0 for index, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = index max_length = max(max_length, index - start + 1) return max_length"},{"question":"from typing import List def digit_Reorder(n: int) -> int: Returns the integer with all its digits rearranged in non-ascending order. If the number is negative, the function rearranges the digits of the absolute value in non-ascending order and returns the negative of the resulting number. >>> digit_Reorder(12345) 54321 >>> digit_Reorder(987263) 987632 >>> digit_Reorder(-4213) -4321 >>> digit_Reorder(-958) -985","solution":"def digit_Reorder(n): Returns the integer with all its digits rearranged in non-ascending order. If the number is negative, the function rearranges the digits of the absolute value in non-ascending order and returns the negative of the resulting number. str_n = str(abs(n)) # Convert the number to string after taking absolute value sorted_digits = sorted(str_n, reverse=True) # Sort digits in non-ascending order sorted_number = int(\\"\\".join(sorted_digits)) # Join sorted digits and convert back to integer return sorted_number if n >= 0 else -sorted_number # Return with appropriate sign"},{"question":"def shiftZeroesToEnd(nums: List[int]) -> List[int]: Shifts all zeros to the end of the list while maintaining the relative order of the other elements. Args: nums (list of int): The list of integers to be modified. Returns: list of int: The modified list with all zeros moved to the end. >>> shiftZeroesToEnd([0, 1, 0, 3, 12]) [1, 3, 12, 0, 0] >>> shiftZeroesToEnd([0, 0, 1]) [1, 0, 0] >>> shiftZeroesToEnd([4, 2, 4, 0, 3, 0, 5, 1, 0]) [4, 2, 4, 3, 5, 1, 0, 0, 0] >>> shiftZeroesToEnd([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> shiftZeroesToEnd([0, 0, 0, 0]) [0, 0, 0, 0] >>> shiftZeroesToEnd([0, 0, 0, 1]) [1, 0, 0, 0] >>> shiftZeroesToEnd([1, 0, 0, 0, 1]) [1, 1, 0, 0, 0]","solution":"def shiftZeroesToEnd(nums): Shifts all zeros to the end of the list while maintaining the relative order of the other elements. Args: nums (list of int): The list of integers to be modified. Returns: list of int: The modified list with all zeros moved to the end. last_non_zero_found_at = 0 # Move all non_zero elements forward for i in range(len(nums)): if nums[i] != 0: nums[last_non_zero_found_at] = nums[i] last_non_zero_found_at += 1 # Fill remaining elements with zeros for i in range(last_non_zero_found_at, len(nums)): nums[i] = 0 return nums"},{"question":"def square_elements(lst: List[int]) -> List[int]: Given a list of integers, return a new list with each element squared. >>> square_elements([1, 2, 3, 4, 5]) [1, 4, 9, 16, 25] >>> square_elements([-1, -2, 3, -4, 5]) [1, 4, 9, 16, 25] >>> square_elements([]) [] from solution import square_elements def test_square_elements_positive_numbers(): assert square_elements([1, 2, 3, 4, 5]) == [1, 4, 9, 16, 25] def test_square_elements_mixed_numbers(): assert square_elements([-1, -2, 3, -4, 5]) == [1, 4, 9, 16, 25] def test_square_elements_empty_list(): assert square_elements([]) == [] def test_square_elements_single_element(): assert square_elements([0]) == [0] assert square_elements([-3]) == [9] assert square_elements([2]) == [4] def test_square_elements_large_numbers(): assert square_elements([1000, 2000, -3000]) == [1000000, 4000000, 9000000]","solution":"def square_elements(lst): Return a new list with each element from the input list squared. return [x * x for x in lst]"},{"question":"from typing import List def maximum_product_of_three(nums: List[int]) -> int: Given an array of integers, find the maximum product of any three numbers in the array. Args: nums: List[int] - A list of integers with length n where 3 <= n <= 10^4 and each integer nums[i] is in the range [-10^3, 10^3]. Returns: int - A single integer representing the maximum product of any three integers in the given list. Examples: >>> maximum_product_of_three([1, 2, 3]) 6 >>> maximum_product_of_three([-10, -10, 5, 2]) 500 pass def test_maximum_product_of_three_with_all_positives(): assert maximum_product_of_three([1, 2, 3]) == 6 assert maximum_product_of_three([1, 2, 3, 4]) == 24 def test_maximum_product_of_three_with_all_negatives(): assert maximum_product_of_three([-1, -2, -3]) == -6 assert maximum_product_of_three([-1, -2, -3, -4]) == -6 def test_maximum_product_of_three_with_mixed_signs(): assert maximum_product_of_three([-10, -10, 5, 2]) == 500 assert maximum_product_of_three([-10, -10, 1, 3, 2]) == 300 def test_maximum_product_of_three_edge_cases(): assert maximum_product_of_three([0, 0, 0]) == 0 assert maximum_product_of_three([1, 1, 1]) == 1 assert maximum_product_of_three([-1, -1, 1]) == 1 def test_maximum_product_of_three_larger_arrays(): assert maximum_product_of_three([1, 2, 3, 4, 5, 6]) == 120 assert maximum_product_of_three([-1, -2, -3, -4, -5, -6]) == -6 assert maximum_product_of_three([-10, 0, 2, 3, 4, 6, 8, 10]) == 480","solution":"from typing import List def maximum_product_of_three(nums: List[int]) -> int: Returns the maximum product of any three numbers in the array \`nums\`. nums.sort() # The maximum product can be either by largest three numbers or two smallest and the largest. return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])"},{"question":"def maximumValue(commands: List[str]) -> int: Given an initially empty stack, implement a series of commands to manipulate the stack and finally return the maximum integer value present in the stack after all operations are completed. >>> maximumValue([\\"PUSH 1\\", \\"PUSH 5\\", \\"MAX\\", \\"PUSH 3\\", \\"POP\\", \\"MAX\\"]) == 5 >>> maximumValue([\\"PUSH 7\\", \\"MAX\\"]) == 7 >>> maximumValue([\\"PUSH 3\\", \\"PUSH 3\\", \\"PUSH 3\\", \\"MAX\\", \\"POP\\", \\"POP\\", \\"MAX\\"]) == 3 >>> maximumValue([\\"PUSH 5\\", \\"PUSH 4\\", \\"PUSH 3\\", \\"PUSH 2\\", \\"PUSH 1\\", \\"MAX\\", \\"POP\\", \\"POP\\", \\"MAX\\"]) == 5 >>> maximumValue([\\"PUSH 1\\", \\"PUSH 2\\", \\"PUSH 3\\", \\"POP\\", \\"PUSH 7\\", \\"PUSH 5\\", \\"MAX\\"]) == 7 >>> maximumValue([\\"PUSH 10\\", \\"PUSH 20\\", \\"POP\\", \\"POP\\", \\"PUSH 5\\", \\"MAX\\"]) == 5","solution":"def maximumValue(commands): stack = [] max_vals = [] for command in commands: parts = command.split() operation = parts[0] if operation == \\"PUSH\\": value = int(parts[1]) stack.append(value) if not max_vals or value >= max_vals[-1]: max_vals.append(value) elif operation == \\"POP\\": value = stack.pop() if value == max_vals[-1]: max_vals.pop() elif operation == \\"TOP\\": continue # We do not need to process this command for our max tracking elif operation == \\"MAX\\": continue # We will compute the final max value at the end return max_vals[-1] if max_vals else None"},{"question":"from typing import List def product_except_self(nums: List[int]) -> List[int]: Returns a list such that each element at index i is the product of all elements of nums except nums[i]. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([5, 1, 4, 2]) [8, 40, 10, 20]","solution":"from typing import List def product_except_self(nums: List[int]) -> List[int]: Returns a list such that each element at index i is the product of all elements of nums except nums[i]. length = len(nums) answer = [1] * length # Calculate left products left_product = 1 for i in range(length): answer[i] = left_product left_product *= nums[i] # Calculate right products and combine with left products right_product = 1 for i in range(length - 1, -1, -1): answer[i] *= right_product right_product *= nums[i] return answer"},{"question":"def longest_word(sentence: str) -> str: Create a function that accepts a string containing words separated by spaces and returns the longest word. If there are multiple words with the same length, return the one that appears first. If the input string is empty, return an empty string. >>> longest_word(\\"Python programming is fun\\") 'programming' >>> longest_word(\\"I love coding\\") 'coding' >>> longest_word(\\"The quick brown fox\\") 'quick' >>> longest_word(\\"\\") '' >>> longest_word(\\"fun run sun\\") 'fun' >>> longest_word(\\"Python programming is fun\\") 'programming'","solution":"def longest_word(sentence): Returns the longest word in a given sentence. If there are multiple words with the same length, returns the one that appears first. If the sentence is empty, returns an empty string. if not sentence: return \\"\\" words = sentence.split() longest = words[0] for word in words: if len(word) > len(longest): longest = word return longest"},{"question":"def unique_palindromes(s: str) -> List[str]: Returns a list of all unique palindrome substrings of length greater than 1 in lexicographical order. >>> unique_palindromes(\\"abccba\\") == [\\"abccba\\", \\"bccb\\", \\"cc\\"] >>> unique_palindromes(\\"racecar\\") == [\\"aceca\\", \\"cec\\", \\"racecar\\"] >>> unique_palindromes(\\"aaabba\\") == [\\"aa\\", \\"aaa\\", \\"abba\\", \\"bb\\"]","solution":"def unique_palindromes(s): Returns a list of all unique palindrome substrings of length greater than 1 in lexicographical order. def is_palindrome(sub): return sub == sub[::-1] found_palindromes = set() for i in range(len(s)): for j in range(i + 2, len(s) + 1): substring = s[i:j] if is_palindrome(substring): found_palindromes.add(substring) return sorted(found_palindromes)"},{"question":"def find_islands(users, follow_relationships): Identify all islands in the given list of users and follower relationships. Each island is a group of users who can reach each other indirectly through follow relationships. Args: users (List[int]): List of users in the social network. follow_relationships (List[Tuple[int, int]]): List of follower relationships where each relationship is a pair (follower, followee). Returns: List[Set[int]]: A list of sets, each representing an island of users. >>> find_islands([0, 1, 2, 3, 4, 5, 6], [(0, 1), (1, 2), (3, 4), (5, 6)]) [{0, 1, 2}, {3, 4}, {5, 6}] >>> find_islands([0, 1, 2, 3], []) [{0}, {1}, {2}, {3}] >>> find_islands([0, 1, 2, 3], [(0, 1), (1, 2), (2, 3)]) [{0, 1, 2, 3}] >>> find_islands([0, 1, 2, 3, 4, 5], [(0, 1), (2, 3), (4, 5)]) [{0, 1}, {2, 3}, {4, 5}] >>> find_islands([0, 1, 2], [(0, 0), (1, 2)]) [{0}, {1, 2}]","solution":"def find_islands(users, follow_relationships): from collections import defaultdict # Building the adjacency list adj_list = defaultdict(set) for follower, followee in follow_relationships: adj_list[follower].add(followee) adj_list[followee].add(follower) # Since we need to consider bi-directional reachability # DFS to find all connected components def dfs(node, visited, island): visited[node] = True island.add(node) for neighbor in adj_list[node]: if not visited[neighbor]: dfs(neighbor, visited, island) visited = {user: False for user in users} islands = [] for user in users: if not visited[user]: island = set() dfs(user, visited, island) islands.append(island) return islands"},{"question":"import random import string def generate_password() -> str: Generates a random password exactly 12 characters long with at least 1 uppercase letter, 1 lowercase letter, 1 digit, and 1 special character from the set: \`!@#%^&*()\`. >>> len(generate_password()) == 12 >>> any(c.isupper() for c in generate_password()) >>> any(c.islower() for c in generate_password()) >>> any(c.isdigit() for c in generate_password()) >>> any(c in \\"!@#%^&*()\\" for c in generate_password())","solution":"import random import string def generate_password() -> str: Generates a random password exactly 12 characters long with at least 1 uppercase letter, 1 lowercase letter, 1 digit, and 1 special character from the set: \`!@#%^&*()\`. # Define character sets upper = string.ascii_uppercase lower = string.ascii_lowercase digits = string.digits special = \\"!@#%^&*()\\" # Ensure to pick at least one character from each required set password = [ random.choice(upper), random.choice(lower), random.choice(digits), random.choice(special) ] # Fill the remaining characters randomly from all the sets combined all_characters = upper + lower + digits + special password.extend(random.choice(all_characters) for _ in range(12 - 4)) # Shuffle to avoid predictable pattern random.shuffle(password) return ''.join(password)"},{"question":"def merge_sorted_arrays(arr1: List[int], arr2: List[int]) -> List[int]: Merges two sorted arrays into a single sorted array without using any built-in sorting functions. >>> merge_sorted_arrays([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_arrays([], [1, 2, 3]) [1, 2, 3] >>> merge_sorted_arrays([1, 1, 1], [1, 1, 1]) [1, 1, 1, 1, 1, 1] >>> merge_sorted_arrays([-5, -3, -1], [-6, -4, -2]) [-6, -5, -4, -3, -2, -1] >>> merge_sorted_arrays([-3, -1, 2], [-2, 0, 3]) [-3, -2, -1, 0, 2, 3] >>> merge_sorted_arrays([1, 2, 4], [2, 3, 5]) [1, 2, 2, 3, 4, 5] >>> merge_sorted_arrays([1], [2]) [1, 2] >>> merge_sorted_arrays([2], [1]) [1, 2]","solution":"def merge_sorted_arrays(arr1, arr2): Merges two sorted arrays into a single sorted array without using any built-in sorting functions. merged_array = [] i, j = 0, 0 # Traverse through both arrays while i < len(arr1) and j < len(arr2): if arr1[i] < arr2[j]: merged_array.append(arr1[i]) i += 1 else: merged_array.append(arr2[j]) j += 1 # If there are remaining elements in arr1 while i < len(arr1): merged_array.append(arr1[i]) i += 1 # If there are remaining elements in arr2 while j < len(arr2): merged_array.append(arr2[j]) j += 1 return merged_array"},{"question":"from typing import List def sum_below_threshold(numbers: List[int], threshold: int) -> int: Calculate the sum of an array of numbers, skipping any numbers that are strictly greater than a given threshold. Args: numbers (List[int]): An array of integers. threshold (int): An integer representing the maximum value to consider in the summation. Returns: int: The sum of the values in the \`numbers\` array that are less than or equal to the \`threshold\`. Examples: >>> sum_below_threshold([3, 10, 5, 7], 6) 8 >>> sum_below_threshold([1, -2, 3, 4, 5], 3) 2 >>> sum_below_threshold([10, 20, 30], 15) 10","solution":"def sum_below_threshold(numbers, threshold): Returns the sum of the values in the \`numbers\` array that are less than or equal to the \`threshold\`. return sum(number for number in numbers if number <= threshold)"},{"question":"def find_element_appears_three_times(nums): Given a list of integers where each integer appears exactly twice except for one element which appears exactly three times, this function returns the element that appears three times. >>> find_element_appears_three_times([2,2,2,3,3,1,1]) 2 >>> find_element_appears_three_times([4,5,5,5,6,6,7,7]) 5 >>> find_element_appears_three_times([11,11,11,12,12,13,13]) 11 # Your code here","solution":"def find_element_appears_three_times(nums): Given a list of integers where each integer appears exactly twice except for one element which appears exactly three times, this function returns the element that appears three times. num_count = {} for num in nums: if num in num_count: num_count[num] += 1 else: num_count[num] = 1 for num, count in num_count.items(): if count == 3: return num"},{"question":"from typing import List, Optional def is_valid_bst(tree: List[Optional[int]]) -> bool: Check if a binary tree represented by a list of integers is a valid binary search tree (BST). >>> is_valid_bst([2, 1, 3]) True >>> is_valid_bst([5, 1, 4, None, None, 3, 6]) False >>> is_valid_bst([10, 5, 15, None, None, 6, 20]) False >>> is_valid_bst([10]) True >>> is_valid_bst([]) True >>> is_valid_bst([10, 5, 15, 3, 7, 12, 17]) True >>> is_valid_bst([10, 5, 15, 3, 5, 12, 20]) False >>> is_valid_bst([3, 2, None, 1, None, None, None]) True >>> is_valid_bst([3, None, 4, None, None, None, 5]) True","solution":"from typing import List, Optional def is_valid_bst(tree: List[Optional[int]]) -> bool: if not tree: return True def helper(index, low, high): if index >= len(tree) or tree[index] is None: return True val = tree[index] if not (low < val < high): return False left_index = 2 * index + 1 right_index = 2 * index + 2 return helper(left_index, low, val) and helper(right_index, val, high) return helper(0, float('-inf'), float('inf'))"},{"question":"def sumSubarrayMins(arr: List[int]) -> int: Calculate the sum of the minimum value in every possible contiguous subarray of arr. The result is returned modulo 10^9 + 7. >>> sumSubarrayMins([3,1,2,4]) 17 >>> sumSubarrayMins([1,2,3]) 10 >>> sumSubarrayMins([11,81,94,43,3]) 444","solution":"def sumSubarrayMins(arr): MOD = 10**9 + 7 n = len(arr) left, right = [0] * n, [0] * n stack = [] # Calculate previous less element distance for i in range(n): count = 1 while stack and stack[-1][0] > arr[i]: count += stack.pop()[1] left[i] = count stack.append((arr[i], count)) stack = [] # Calculate next less element distance for i in range(n)[::-1]: count = 1 while stack and stack[-1][0] >= arr[i]: count += stack.pop()[1] right[i] = count stack.append((arr[i], count)) # Sum of subarray minimums result = 0 for i in range(n): result += arr[i] * left[i] * right[i] result %= MOD return result"},{"question":"def process_instructions(q: int, instructions: List[str]) -> List: Process a sequence of instructions and provide the correct outputs for all the \\"3\\" instructions. Parameters: q (int): the number of instructions. instructions (list of str): each instruction in one of the formats described above. Returns: list: output for each \\"3\\" instruction. pass # Example test cases def test_simple_case(): q = 7 instructions = [\\"1 5\\", \\"1 10\\", \\"3\\", \\"2 10\\", \\"3\\", \\"2 5\\", \\"3\\"] assert process_instructions(q, instructions) == [10, 5, \\"EMPTY\\"] def test_with_all_removals(): q = 5 instructions = [\\"1 1\\", \\"1 2\\", \\"1 3\\", \\"2 1\\", \\"3\\"] assert process_instructions(q, instructions) == [3] def test_interleaved_add_remove(): q = 6 instructions = [\\"1 7\\", \\"1 3\\", \\"2 7\\", \\"1 5\\", \\"3\\", \\"2 5\\"] assert process_instructions(q, instructions) == [5] def test_empty_during_max_query(): q = 4 instructions = [\\"1 4\\", \\"2 4\\", \\"3\\", \\"3\\"] assert process_instructions(q, instructions) == [\\"EMPTY\\", \\"EMPTY\\"] def test_max_edge_cases(): q = 4 instructions = [\\"1 1000000000\\", \\"1 999999999\\", \\"3\\", \\"2 1000000000\\"] assert process_instructions(q, instructions) == [1000000000]","solution":"def process_instructions(q, instructions): Process a sequence of instructions and provide the correct outputs for all the \\"3\\" instructions. Parameters: q (int): the number of instructions. instructions (list of str): each instruction in one of the formats described above. Returns: list: output for each \\"3\\" instruction. result = [] current_set = set() for instruction in instructions: parts = instruction.split() if parts[0] == \\"1\\": current_set.add(int(parts[1])) elif parts[0] == \\"2\\": current_set.discard(int(parts[1])) elif parts[0] == \\"3\\": if current_set: result.append(max(current_set)) else: result.append(\\"EMPTY\\") return result"},{"question":"import re from collections import defaultdict def word_count(sentence: str) -> dict: Returns a dictionary of word counts in a given sentence. Args: sentence (str): A string containing the sentence. Returns: dict: A dictionary where keys are words and values are the number of times each word appears. pass # Unit Tests def test_single_occurrence(): assert word_count(\\"The quick brown fox\\") == { \\"the\\": 1, \\"quick\\": 1, \\"brown\\": 1, \\"fox\\": 1 } def test_multiple_occurrences(): assert word_count(\\"The quick brown fox the brown fox\\") == { \\"the\\": 2, \\"quick\\": 1, \\"brown\\": 2, \\"fox\\": 2 } def test_case_insensitivity(): assert word_count(\\"The Quick Brown fox\\") == { \\"the\\": 1, \\"quick\\": 1, \\"brown\\": 1, \\"fox\\": 1 } def test_with_punctuation(): assert word_count(\\"The quick, brown fox. The lazy dog!\\") == { \\"the\\": 2, \\"quick\\": 1, \\"brown\\": 1, \\"fox\\": 1, \\"lazy\\": 1, \\"dog\\": 1 } def test_empty_string(): assert word_count(\\"\\") == {} def test_repeated_words(): assert word_count(\\"hello hello hello\\") == { \\"hello\\": 3 } def test_punctuation_handling(): assert word_count(\\"Hello! Is this... a test? Yes, it is a test.\\") == { 'hello': 1, 'is': 2, 'this': 1, 'a': 2, 'test': 2, 'yes': 1, 'it': 1 }","solution":"import re from collections import defaultdict def word_count(sentence): Returns a dictionary of word counts in a given sentence. Args: sentence (str): A string containing the sentence. Returns: dict: A dictionary where keys are words and values are the number of times each word appears. # A dictionary to store the word counts count_dict = defaultdict(int) # Normalize the sentence to lowercase and remove punctuation normalized_sentence = re.sub(r'[^a-zA-Zs]', '', sentence).lower() # Split the sentence into words words = normalized_sentence.split() # Count the words for word in words: count_dict[word] += 1 return dict(count_dict)"},{"question":"import re def sum_of_negative_integers(dirty_list: str) -> int: Returns the sum of all negative integers found in the input string \`dirty_list\`. Args: dirty_list (str): A dirty string containing negative integers separated by commas and other non-numeric characters. Returns: int: Sum of all negative integers in the string. Examples: >>> sum_of_negative_integers(\\"neg-12commamess-34here-9problem\\") -55 >>> sum_of_negative_integers(\\"numbers,-1more-st-2uff,-23\\") -26 >>> sum_of_negative_integers(\\"abc-def-10ghi-20jkl-30\\") -60 >>> sum_of_negative_integers(\\"x-1y-2z-3\\") -6 >>> sum_of_negative_integers(\\"only-5here\\") -5","solution":"import re def sum_of_negative_integers(dirty_list): Returns the sum of all negative integers found in the input string \`dirty_list\`. # Find all negative integers in the string negative_integers = re.findall(r\\"-d+\\", dirty_list) # Convert found strings to integers and calculate the sum return sum(map(int, negative_integers))"},{"question":"def compress_string(s: str) -> str: Compress the input string using basic Run-Length Encoding (RLE). The compressed string should only consist of the character followed by the number of times it appears consecutively. Spaces should be treated like any other character and be encoded as well. >>> compress_string(\\"aaabccc\\") 'a3b1c3' >>> compress_string(\\"hello world\\") 'h1e1l2o1 2w1o1r1l1d1' >>> compress_string(\\"a\\") 'a1' >>> compress_string(\\"abcdef\\") 'a1b1c1d1e1f1' >>> compress_string(\\"\\") '' >>> compress_string(\\"aabbbccaaa\\") 'a2b3c2a3' >>> compress_string(\\"aaaaabbbbbcccccdddddeeeee\\") 'a5b5c5d5e5'","solution":"def compress_string(s): Compresses the input string using basic Run-Length Encoding (RLE). Parameters: s (str): The input string to be compressed. Returns: str: The compressed version of the input string. if not s: return \\"\\" compressed = [] count = 1 prev_char = s[0] for char in s[1:]: if char == prev_char: count += 1 else: compressed.append(f\\"{prev_char}{count}\\") prev_char = char count = 1 compressed.append(f\\"{prev_char}{count}\\") return ''.join(compressed)"},{"question":"import heapq from typing import List def find_k_largest_elements(k: int, array: List[int]) -> List[int]: Finds the k largest elements in the given array and returns them in descending order. :param k: The number of largest elements to find. :param array: List of integers to search through. :return: List of k largest elements in descending order. >>> find_k_largest_elements(3, [3, 2, 1, 5, 6, 4]) [6, 5, 4] >>> find_k_largest_elements(2, [3, 2, 3, 1, 2, 4, 5, 5, 6]) [6, 5] >>> find_k_largest_elements(0, [3, 2, 1]) [] >>> find_k_largest_elements(3, [1, 2]) [2, 1] >>> find_k_largest_elements(3, [5, 5, 5]) [5, 5, 5] pass","solution":"import heapq def find_k_largest_elements(k, array): Finds the k largest elements in the given array and returns them in descending order. :param k: The number of largest elements to find. :param array: List of integers to search through. :return: List of k largest elements in descending order. if k <= 0: return [] # Create a min-heap with the first k elements of the array min_heap = array[:k] heapq.heapify(min_heap) # Iterate through the rest of the elements for num in array[k:]: if num > min_heap[0]: heapq.heappop(min_heap) heapq.heappush(min_heap, num) # Extract elements from the heap and sort in descending order result = [heapq.heappop(min_heap) for _ in range(len(min_heap))] return result[::-1] # return in descending order"},{"question":"def areAllCharactersUnique(s: str) -> bool: Determines whether all characters in the given string are unique. Args: s (str): The string to check for unique characters. Returns: bool: True if all characters are unique, False otherwise. Examples: >>> areAllCharactersUnique(\\"abcdef\\") True >>> areAllCharactersUnique(\\"abab\\") False >>> areAllCharactersUnique(\\"1234567\\") True >>> areAllCharactersUnique(\\"aa\\") False","solution":"def areAllCharactersUnique(s): Determines whether all characters in the given string are unique. Args: s (str): The string to check for unique characters. Returns: bool: True if all characters are unique, False otherwise. seen = set() for char in s: if char in seen: return False seen.add(char) return True"},{"question":"def look_and_say(n: int) -> str: Generate the nth member of the look-and-say sequence. >>> look_and_say(1) == \\"1\\" >>> look_and_say(2) == \\"11\\" >>> look_and_say(3) == \\"21\\" >>> look_and_say(4) == \\"1211\\" >>> look_and_say(5) == \\"111221\\" >>> look_and_say(6) == \\"312211\\" >>> look_and_say(7) == \\"13112221\\" >>> look_and_say(8) == \\"1113213211\\" >>> look_and_say(9) == \\"31131211131221\\" >>> look_and_say(10) == \\"13211311123113112211\\"","solution":"def look_and_say(n): Returns the nth member of the look-and-say sequence. if n == 1: return \\"1\\" prev = \\"1\\" for _ in range(1, n): next_seq = \\"\\" count = 1 for j in range(1, len(prev)): if prev[j] == prev[j - 1]: count += 1 else: next_seq += str(count) + prev[j - 1] count = 1 next_seq += str(count) + prev[-1] prev = next_seq return prev"},{"question":"def fetch_packages(required_packages: List[str], available_packages: Dict[str, List[str]]) -> List[str]: Returns a list of all the packages that need to be fetched, including dependencies, in an order that respects the dependencies. >>> available_packages = { >>> 'A': [], >>> 'B': ['D'], >>> 'C': ['E'], >>> 'D': ['F'], >>> 'E': [], >>> 'F': [] >>> } >>> required_packages = ['A', 'B'] >>> fetch_packages(required_packages, available_packages) ['A', 'F', 'D', 'B']","solution":"def fetch_packages(required_packages, available_packages): Returns a list of all the packages that need to be fetched, including dependencies, in an order that respects the dependencies. def dfs(package, visited, result): if package not in visited: visited.add(package) for dependency in available_packages[package]: dfs(dependency, visited, result) result.append(package) visited = set() result = [] for package in required_packages: dfs(package, visited, result) return result"},{"question":"def longest_unique_substring(s: str) -> int: Given a string, find the length of the longest substring without repeating characters. Examples: >>> longest_unique_substring(\\"abcabcbb\\") 3 >>> longest_unique_substring(\\"bbbbb\\") 1 >>> longest_unique_substring(\\"pwwkew\\") 3 >>> longest_unique_substring(\\"abcdef\\") 6 >>> longest_unique_substring(\\"abba\\") 2","solution":"def longestUniqueSubstring(s): Returns the length of the longest substring without repeating characters. char_map = {} left = 0 max_length = 0 for right in range(len(s)): if s[right] in char_map: left = max(left, char_map[s[right]] + 1) char_map[s[right]] = right max_length = max(max_length, right - left + 1) return max_length"},{"question":"def twoSum(nums: List[int], target: int) -> List[int]: Returns the indices of the two numbers that add up to the target sum. >>> twoSum([2, 7, 11, 15], 9) [0, 1] >>> twoSum([3, 2, 4], 6) [1, 2] >>> twoSum([3, 3], 6) [0, 1]","solution":"def twoSum(nums, target): Returns the indices of the two numbers that add up to the target sum. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i"},{"question":"def length_of_longest_AP(arr: List[int]) -> int: Implement a function that accepts a list of integers and returns the length of the longest subsequence that forms a valid arithmetic progression (AP). An arithmetic progression is a sequence of numbers such that the difference between any two consecutive terms is the same. Input - arr (list of integers): The input list of integers, which can be empty or contain up to 10^4 elements. The elements in arr are in the range of [-10^6, 10^6]. Output - Integer: The length of the longest subsequence that forms an arithmetic progression. Examples: >>> length_of_longest_AP([1, 7, 10, 15, 27, 29]) 3 >>> length_of_longest_AP([5, 10, 15, 20, 25]) 5","solution":"def length_of_longest_AP(arr): if not arr: return 0 n = len(arr) if n <= 2: return n # Create a table to store lengths of longest AP. # opt[i][j] will store the length of the longest AP ending with arr[i] and arr[j] opt = [[2 for _ in range(n)] for _ in range(n)] max_length = 2 for j in range(n - 1, 0, -1): i = j - 1 k = j + 1 while i >= 0 and k <= n - 1: if arr[i] + arr[k] < 2 * arr[j]: k += 1 elif arr[i] + arr[k] > 2 * arr[j]: opt[i][j] = 2 i -= 1 else: opt[i][j] = opt[j][k] + 1 max_length = max(max_length, opt[i][j]) i -= 1 k += 1 # If the loop doesn't update opt[i][j], set it to 2 while i >= 0: opt[i][j] = 2 i -= 1 return max_length"},{"question":"def can_divide_fireworks(t: int, m: int, durations: List[int]) -> str: Determine if it is possible to divide the launch list into \`m\` sessions with equal number of launches and duration. Args: t (int): Total number of firework launches. m (int): Number of sessions. durations (List[int]): Durations of each firework launch. Returns: str: \\"Yes\\" and the number of launches and total duration per session if possible, otherwise \\"No\\". Example: >>> can_divide_fireworks(8, 2, [2, 2, 3, 3, 4, 4, 1, 1]) 'Yesn4 10' >>> can_divide_fireworks(5, 5, [1, 1, 1, 1, 1]) 'Yesn1 1' >>> can_divide_fireworks(4, 3, [1, 2, 3, 4]) 'No'","solution":"def can_divide_fireworks(t, m, durations): total_duration = sum(durations) if total_duration % m != 0: return \\"No\\" target_duration = total_duration // m session_duration = 0 session_count = 0 launches_in_session = 0 for duration in durations: session_duration += duration launches_in_session += 1 if session_duration == target_duration: session_duration = 0 session_count += 1 launches_in_session = 0 if session_count == m: individual_session_launches = t // m return f\\"Yesn{individual_session_launches} {target_duration}\\" else: return \\"No\\""},{"question":"def sum_multiples(num1: int, num2: int) -> int: Returns the sum of all the multiples of num1 that are less than num2. Parameters: num1 (int): The multiple number. num2 (int): The upper limit (exclusive). Returns: int: The sum of multiples of num1 below num2. >>> sum_multiples(3, 10) 18 >>> sum_multiples(5, 20) 30 >>> sum_multiples(8, 16) 8 >>> sum_multiples(7, 5) 0 >>> sum_multiples(10, 10) 0 >>> sum_multiples(10, 9) 0 # Implement the function here from solution import sum_multiples def test_sum_multiples_example1(): assert sum_multiples(3, 10) == 18 def test_sum_multiples_example2(): assert sum_multiples(5, 20) == 30 def test_sum_multiples_example3(): assert sum_multiples(8, 16) == 8 def test_sum_multiples_no_multiples(): assert sum_multiples(7, 5) == 0 def test_sum_multiples_large_range(): assert sum_multiples(2, 21) == 110 assert sum_multiples(1, 5) == 10 def test_sum_multiples_zero_result(): assert sum_multiples(10, 10) == 0 assert sum_multiples(10, 9) == 0","solution":"def sum_multiples(num1, num2): Returns the sum of all the multiples of num1 that are less than num2. Parameters: num1 (int): The multiple number. num2 (int): The upper limit (exclusive). Returns: int: The sum of multiples of num1 below num2. sum_of_multiples = 0 for i in range(num1, num2, num1): sum_of_multiples += i return sum_of_multiples"},{"question":"def calculate_total_revenue(transactions: List[str]) -> List[Union[str, float]]: Calculate total revenue generated from each unique product sold. If any transaction contains \\"REFUND\\", return \\"Invalid transactions detected\\". Args: transactions (list of str): List of transactions. Each string contains a product name and a price. Returns: list: Sorted array with unique product names in uppercase and their total revenue. Or [\\"Invalid transactions detected\\"] if any transaction contains \\"REFUND\\". Examples: >>> calculate_total_revenue([\\"Laptop 1200.00\\", \\"Smartphone 800.99\\", \\"Tablet 299.99\\", \\"Laptop 1199.99\\", \\"Smartphone 799.99\\"]) [\\"LAPTOP\\", 2399.99, \\"SMARTPHONE\\", 1600.98, \\"TABLET\\", 299.99] >>> calculate_total_revenue([\\"laptop 1200.00\\", \\"SmartPHONE 800.99\\", \\"TablEt 299.99\\", \\"laptop 1199.99\\", \\"sMARTphone 799.99\\"]) [\\"LAPTOP\\", 2399.99, \\"SMARTPHONE\\", 1600.98, \\"TABLET\\", 299.99] >>> calculate_total_revenue([\\"Laptop 1200.00\\"]) [\\"LAPTOP\\", 1200.00] >>> calculate_total_revenue([\\"Laptop 1200.00\\", \\"REFUND 500.00\\"]) [\\"Invalid transactions detected\\"] >>> calculate_total_revenue([\\"Camera 800.00\\", \\"Monitor 200.00\\", \\"Mouse 25.50\\", \\"Mouse 20.00\\", \\"camera 200.00\\"]) [\\"CAMERA\\", 1000.00, \\"MONITOR\\", 200.00, \\"MOUSE\\", 45.50]","solution":"def calculate_total_revenue(transactions): Calculate total revenue generated from each unique product sold. If any transaction contains \\"REFUND\\", return \\"Invalid transactions detected\\". Args: transactions (list of str): List of transactions. Each string contains a product name and a price. Returns: list: Sorted array with unique product names in uppercase and their total revenue. Or [\\"Invalid transactions detected\\"] if any transaction contains \\"REFUND\\". revenue_dict = {} for transaction in transactions: # Check for \\"REFUND\\" in transaction, if found return invalid transaction message. if \\"REFUND\\" in transaction: return [\\"Invalid transactions detected\\"] # Split the transaction into product name and price transaction_parts = transaction.rsplit(' ', 1) product_name = transaction_parts[0].strip() price = float(transaction_parts[1].strip()) # Convert product name to uppercase product_name_upper = product_name.upper() # Add revenue to product name if product_name_upper in revenue_dict: revenue_dict[product_name_upper] += price else: revenue_dict[product_name_upper] = price # Convert the revenue dictionary to a sorted list sorted_revenue_list = [] for product_name in sorted(revenue_dict.keys()): sorted_revenue_list.append(product_name) sorted_revenue_list.append(revenue_dict[product_name]) return sorted_revenue_list"},{"question":"from typing import List, Tuple def max_simultaneous_requests(intervals: List[Tuple[int, int]]) -> int: Returns the maximum number of simultaneous requests. >>> max_simultaneous_requests([(1, 5), (2, 6), (4, 8), (7, 10), (9, 10)]) 3 >>> max_simultaneous_requests([(1, 3), (2, 5), (6, 8), (7, 10)]) 2 >>> max_simultaneous_requests([(0, 1)]) 1 >>> max_simultaneous_requests([(1, 5), (2, 3), (4, 6)]) 2 >>> max_simultaneous_requests([(1, 2), (3, 4), (5, 6), (7, 8), (9, 10)]) 1 >>> max_simultaneous_requests([(1, 1000000000), (500000000, 1000000000)]) 2 >>> max_simultaneous_requests([ ... (1, 10), (2, 9), (3, 8), (4, 7), (5, 6), ... (11, 20), (11, 30), (15, 25), (21, 22)]) 5","solution":"def max_simultaneous_requests(intervals): Returns the maximum number of simultaneous requests. events = [] for (start, end) in intervals: events.append((start, 1)) # 1 for request start events.append((end + 1, -1)) # -1 for request end (+1 to make the end inclusive) events.sort() max_simultaneous = 0 current_simultaneous = 0 for _, event in events: current_simultaneous += event max_simultaneous = max(max_simultaneous, current_simultaneous) return max_simultaneous def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) intervals = [(int(data[2*i + 1]), int(data[2*i + 2])) for i in range(n)] print(max_simultaneous_requests(intervals)) if __name__ == \\"__main__\\": main()"},{"question":"def unique_pairs(nums: List[int], target: int) -> int: Returns the number of unique pairs in the list that add up to the target sum. >>> unique_pairs([1, 3, 2, 2, 3], 4) 2 >>> unique_pairs([1, 1, 1, 1], 2) 1 from typing import List def test_unique_pairs_example1(): assert unique_pairs([1, 3, 2, 2, 3], 4) == 2 def test_unique_pairs_example2(): assert unique_pairs([1, 1, 1, 1], 2) == 1 def test_unique_pairs_no_pairs(): assert unique_pairs([1, 1, 1, 1], 3) == 0 def test_unique_pairs_negative_numbers(): assert unique_pairs([-1, -2, -3, -4, -2], -5) == 2 def test_unique_pairs_mixed_numbers(): assert unique_pairs([1, -1, 2, -2, 3, -3], 0) == 3 def test_unique_pairs_large_input(): nums = [i for i in range(1000)] + [-i for i in range(1000)] target = 0 assert unique_pairs(nums, target) == 1000 def test_unique_pairs_empty_list(): assert unique_pairs([], 5) == 0 def test_unique_pairs_one_element(): assert unique_pairs([1], 1) == 0 assert unique_pairs([1], 2) == 0","solution":"def unique_pairs(nums, target): Returns the number of unique pairs in the list that add up to the target sum. seen = set() pairs = set() for num in nums: complement = target - num if complement in seen: pairs.add(tuple(sorted((num, complement)))) seen.add(num) return len(pairs)"},{"question":"def is_fibonacci_like(sequence: List[int]) -> bool: Determines if a given sequence of integers is a valid Fibonacci-like sequence. >>> is_fibonacci_like([2, 3, 5, 8, 13]) == True >>> is_fibonacci_like([1, 2, 4, 6, 10]) == False >>> is_fibonacci_like([0, 0, 0, 0, 0, 0]) == True >>> is_fibonacci_like([1, 1, 2, 3, 5, 8]) == True >>> is_fibonacci_like([5, -2, 3, 1, 4, 5]) == True >>> is_fibonacci_like([1, 1, 2, 3, 6]) == False >>> is_fibonacci_like([1, 1, 2]) == True >>> is_fibonacci_like([1, 1, 3]) == False","solution":"def is_fibonacci_like(sequence): Determines if a given sequence of integers is a valid Fibonacci-like sequence. :param sequence: List of integers. :return: True if the sequence is a valid Fibonacci-like sequence, False otherwise. for i in range(2, len(sequence)): if sequence[i] != sequence[i - 1] + sequence[i - 2]: return False return True"},{"question":"from typing import List def word_ladder_length(beginWord: str, endWord: str, wordList: List[str]) -> int: Write a function that computes the length of the shortest transformation sequence from a given \`beginWord\` to an \`endWord\`, using a specified word list. Each word in the transformation sequence must be in the word list, and only one letter can be changed at a time. If no such transformation is possible, the function should return 0. Parameters: - beginWord (str): The starting word. - endWord (str): The target word. - wordList (List[str]): The list of words that can be used in the transformation sequence. Returns: int: Length of the shortest transformation sequence from \`beginWord\` to \`endWord\`, or 0 if it's not possible to transform. Example: >>> word_ladder_length(\\"hit\\", \\"cog\\", [\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\",\\"cog\\"]) 5 >>> word_ladder_length(\\"hit\\", \\"cog\\", [\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\"]) 0 pass","solution":"from collections import deque def word_ladder_length(beginWord, endWord, wordList): if endWord not in wordList: return 0 wordSet = set(wordList) queue = deque([(beginWord, 1)]) visited = set() while queue: current_word, level = queue.popleft() if current_word == endWord: return level for i in range(len(current_word)): for char in 'abcdefghijklmnopqrstuvwxyz': next_word = current_word[:i] + char + current_word[i+1:] if next_word in wordSet and next_word not in visited: visited.add(next_word) queue.append((next_word, level + 1)) return 0"},{"question":"def smallest_missing_positive_integer(arr: List[int]) -> int: Finds the smallest missing positive integer from an array. >>> smallest_missing_positive_integer([1, 2, 0, -1, 3, 4]) 5 >>> smallest_missing_positive_integer([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 11 >>> smallest_missing_positive_integer([2, 3, 7, 6, 8, -1, -10, 15]) 1 >>> smallest_missing_positive_integer([3, 4, -1, 1]) 2 >>> smallest_missing_positive_integer([-1, -2, -3, -4]) 1 >>> smallest_missing_positive_integer([]) 1","solution":"def smallest_missing_positive_integer(arr): Finds the smallest missing positive integer from an array. Parameters: arr (list of int): The input array. Returns: int: The smallest missing positive integer. if not arr: return 1 arr = [x for x in arr if x > 0] if not arr: return 1 arr = set(arr) smallest_missing = 1 while smallest_missing in arr: smallest_missing += 1 return smallest_missing"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def removeNthFromEnd(head, n): Remove the n-th node from the end of list and return its head. >>> head = list_to_linked_list([1, 2, 3, 4, 5]) >>> result = removeNthFromEnd(head, 2) >>> linked_list_to_list(result) [1, 2, 3, 5] >>> head = list_to_linked_list([1, 2]) >>> result = removeNthFromEnd(head, 2) >>> linked_list_to_list(result) [2] >>> head = list_to_linked_list([1, 2, 3]) >>> result = removeNthFromEnd(head, 1) >>> linked_list_to_list(result) [1, 2] >>> head = list_to_linked_list([1]) >>> result = removeNthFromEnd(head, 1) >>> linked_list_to_list(result) [] >>> head = list_to_linked_list([1, 2]) >>> result = removeNthFromEnd(head, 1) >>> linked_list_to_list(result) [1] pass def linked_list_to_list(node): Helper function to convert linked list to Python list for easy comparison result = [] while node: result.append(node.val) node = node.next return result def list_to_linked_list(elements): Helper function to convert Python list to linked list dummy = ListNode() current = dummy for element in elements: current.next = ListNode(element) current = current.next return dummy.next","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def removeNthFromEnd(head, n): Remove the n-th node from the end of list and return its head. # Create a dummy node to handle edge cases such as removing the first node dummy = ListNode(0) dummy.next = head first = dummy second = dummy # Move first pointer so that the gap between first and second is n nodes apart for _ in range(n + 1): first = first.next # Move both pointers at the same pace while first is not None: first = first.next second = second.next # Remove the nth node from the end second.next = second.next.next return dummy.next"},{"question":"def final_heights(N, D, initial_heights, growth_per_day): Calculate the final heights of the plants after a given number of days. Args: N : int : Number of plants D : int : Number of days initial_heights : list of int : Initial heights of the plants growth_per_day : list of int : Daily growth of the plants Returns: list of int : Final heights of the plants after \`D\` days pass # Unit Tests def test_final_heights_example(): assert final_heights(3, 5, [1, 2, 3], [1, 1, 1]) == [6, 7, 8] def test_final_heights_zero_days(): assert final_heights(3, 0, [1, 2, 3], [1, 1, 1]) == [1, 2, 3] def test_final_heights_varied_growth(): assert final_heights(3, 2, [5, 10, 15], [1, 2, 3]) == [7, 14, 21] def test_final_heights_max_values(): assert final_heights(1, 100, [100], [100]) == [10100] def test_final_heights_random_values(): assert final_heights(5, 10, [2, 4, 6, 8, 10], [1, 3, 5, 7, 9]) == [12, 34, 56, 78, 100]","solution":"def final_heights(N, D, initial_heights, growth_per_day): Calculate the final heights of the plants after a given number of days. Args: N : int : Number of plants D : int : Number of days initial_heights : list of int : Initial heights of the plants growth_per_day : list of int : Daily growth of the plants Returns: list of int : Final heights of the plants after \`D\` days # Calculate the final heights final_heights = [initial_heights[i] + growth_per_day[i] * D for i in range(N)] return final_heights"},{"question":"def weekly_running_progress(distances): Calculates total weekly running distance and checks if the goal of 42 kilometers is achieved. Args: - distances (list of int): List of 7 integers representing daily running distances. Returns: - tuple: (total distance (int), goal status (str)) >>> weekly_running_progress([5, 6, 7, 8, 4, 10, 2]) (42, \\"Goal Achieved!\\") >>> weekly_running_progress([3, 4, 5, 3, 4, 2, 1]) (22, \\"Goal Not Achieved!\\") >>> weekly_running_progress([6, 6, 6, 6, 6, 6, 6]) (42, \\"Goal Achieved!\\") >>> weekly_running_progress([10, 5, 5, 6, 7, 5, 4]) (42, \\"Goal Achieved!\\") >>> weekly_running_progress([2, 4, 3, 5, 6, 10, 9]) (39, \\"Goal Not Achieved!\\") >>> weekly_running_progress([0, 0, 0, 0, 0, 0, 0]) (0, \\"Goal Not Achieved!\\") >>> weekly_running_progress([0, 0, 0, 0, 0, 0, 43]) (43, \\"Goal Achieved!\\")","solution":"def weekly_running_progress(distances): Calculates total weekly running distance and checks if the goal of 42 kilometers is achieved. Args: - distances (list of int): List of 7 integers representing daily running distances. Returns: - tuple: (total distance (int), goal status (str)) total_distance = sum(distances) if total_distance >= 42: return total_distance, \\"Goal Achieved!\\" else: return total_distance, \\"Goal Not Achieved!\\""},{"question":"def max_min_distance(N: int) -> int: Given the size of the grid, returns the maximum possible minimum Manhattan distance for Alice's 'A' placements on any NxN grid despite Bob's moves. >>> max_min_distance(1) 0 >>> max_min_distance(2) 1 >>> max_min_distance(3) 1 >>> max_min_distance(4) 2 >>> max_min_distance(5) 2 >>> max_min_distance(1000) 500","solution":"def max_min_distance(N): Given the size of the grid, returns the maximum possible minimum Manhattan distance for Alice's 'A' placements on any NxN grid despite Bob's moves. if N == 1: return 0 # Only one cell, distance is zero. if N % 2 == 0: return N // 2 else: return N // 2"},{"question":"def is_palindrome(string: str) -> bool: Determines if the given string is a palindrome while ignoring any spaces, punctuation, and case sensitivity. Args: string (str): The string to check for palindrome properties. Returns: bool: True if the string is a palindrome, False otherwise. >>> is_palindrome(\\"A man, a plan, a canal, Panama!\\") True >>> is_palindrome(\\"No 'x' in Nixon\\") True >>> is_palindrome(\\"This is not a palindrome.\\") False >>> is_palindrome(\\"\\") True >>> is_palindrome(\\"a\\") True >>> is_palindrome(\\"Z\\") True >>> is_palindrome(\\"12321\\") True >>> is_palindrome(\\"12345\\") False >>> is_palindrome(\\"Able was I ere I saw Elba\\") True >>> is_palindrome(\\"!!!!!\\") True >>> is_palindrome(\\"Eva, can I see bees in a cave?\\") True","solution":"def is_palindrome(string: str) -> bool: Returns True if the given string is a palindrome, ignoring spaces, punctuation, and case. Returns False otherwise. # Filter out non-alphanumeric characters and convert to lowercase filtered_string = ''.join(char.lower() for char in string if char.isalnum()) # Check if the filtered string reads the same forward and backward return filtered_string == filtered_string[::-1]"},{"question":"def most_frequent_integer(n: int, arr: List[int]) -> int: Returns the most frequent integer in the list. If multiple integers have the same frequency, returns the smallest integer among them. Parameters: n (int): The number of elements in the list. arr (List[int]): The list of integers. Returns: int: The most frequent integer in the list, or the smallest integer if there are ties. >>> most_frequent_integer(5, [1, 2, 2, 3, 1]) 1 >>> most_frequent_integer(1, [1]) 1 >>> most_frequent_integer(5, [5, 4, 3, 2, 1]) 1 >>> most_frequent_integer(4, [-1, -1, -2, -2]) -2 >>> most_frequent_integer(6, [-10**9, 10**9, -10**9, 10**9, -10**9, 10**9]) -10**9","solution":"def most_frequent_integer(n, arr): Returns the most frequent integer in the list. If multiple integers have the same frequency, returns the smallest integer among them. from collections import Counter frequency_dict = Counter(arr) max_frequency = max(frequency_dict.values()) most_frequent = min(key for key, value in frequency_dict.items() if value == max_frequency) return most_frequent"},{"question":"def is_valid_token(token: str) -> str: Check if the given string is a valid pascal token. A valid pascal token must: 1. Be exactly 6 characters long. 2. Contain only uppercase alphabets (A-Z) and digits (0-9). 3. Start with an uppercase alphabet. Parameters: token (str): The string to check for validity. Returns: str: \\"YES\\" if the token is valid, \\"NO\\" otherwise. >>> is_valid_token(\\"A12345\\") \\"YES\\" >>> is_valid_token(\\"B6789F\\") \\"YES\\" >>> is_valid_token(\\"123456\\") \\"NO\\" >>> is_valid_token(\\"a12345\\") \\"NO\\" >>> is_valid_token(\\"ABCDE1\\") \\"YES\\" pass def process_tokens(tokens: list) -> list: Processes a list of tokens and returns their validity. Parameters: tokens (list of str): The list of tokens to check. Returns: list of str: List of \\"YES\\" or \\"NO\\" for each token. >>> process_tokens([\\"A12345\\", \\"B6789F\\", \\"123456\\", \\"A1234\\", \\"a12345\\"]) [\\"YES\\", \\"YES\\", \\"NO\\", \\"NO\\", \\"NO\\"] >>> process_tokens([\\"A12345\\", \\"ABCDE1\\", \\"123456\\", \\"A1234\\", \\"ZZZZZZ\\"]) [\\"YES\\", \\"YES\\", \\"NO\\", \\"NO\\", \\"YES\\"] pass","solution":"def is_valid_token(token): Check if the given string is a valid pascal token. A valid pascal token must: 1. Be exactly 6 characters long. 2. Contain only uppercase alphabets (A-Z) and digits (0-9). 3. Start with an uppercase alphabet. Parameters: token (str): The string to check for validity. Returns: str: \\"YES\\" if the token is valid, \\"NO\\" otherwise. if len(token) == 6 and token[0].isalpha() and token[0].isupper() and all(c.isdigit() or c.isupper() for c in token): return \\"YES\\" return \\"NO\\" def process_tokens(tokens): Processes a list of tokens and returns their validity. Parameters: tokens (list of str): The list of tokens to check. Returns: list of str: List of \\"YES\\" or \\"NO\\" for each token. return [is_valid_token(token) for token in tokens]"},{"question":"import re def calculate(expression: str) -> float: Evaluates a mathematical expression given as a string and returns the result as a float. This function follows the order of operations (PEMDAS/BODMAS). >>> calculate(\\"3 + 5\\") 8.0 >>> calculate(\\"10 + 2 * 6\\") 22.0 >>> calculate(\\"100 * 2 + 12\\") 212.0 >>> calculate(\\"100 * ( 2 + 12 )\\") 1400.0 >>> calculate(\\"100 * ( 2 + 12 ) / 14\\") 100.0","solution":"def calculate(expression): Evaluates a mathematical expression given as a string and returns the result as a float. This function follows the order of operations (PEMDAS/BODMAS). def precedence(op): if op in ('+', '-'): return 1 if op in ('*', '/'): return 2 return 0 def apply_op(a, b, op): if op == '+': return a + b if op == '-': return a - b if op == '*': return a * b if op == '/': return a / b def evaluate(tokens): values = [] ops = [] i = 0 while i < len(tokens): if tokens[i] == ' ': i += 1 continue elif tokens[i] == '(': ops.append(tokens[i]) elif tokens[i].isdigit(): val = 0 while (i < len(tokens) and tokens[i].isdigit()): val = (val * 10) + int(tokens[i]) i += 1 values.append(val) i -= 1 elif tokens[i] == ')': while len(ops) != 0 and ops[-1] != '(': val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) ops.pop() else: while (len(ops) != 0 and precedence(ops[-1]) >= precedence(tokens[i])): val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) ops.append(tokens[i]) i += 1 while len(ops) != 0: val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) return values[-1] try: result = evaluate(expression) return float(result) except Exception as e: return str(e)"},{"question":"def minCoins(denominations: List[int], amount: int) -> int: Returns the minimum number of coins required to make up the given amount using the given denominations. If it is not possible to make the target amount, returns -1. >>> minCoins([1, 2, 5], 11) 3 >>> minCoins([2], 3) -1 >>> minCoins([1, 2, 5], 0) 0 >>> minCoins([3], 7) -1 >>> minCoins([3], 6) 2 >>> minCoins([1, 3, 4], 6) 2 >>> minCoins([1, 2, 5], 100) 20 >>> minCoins([], 10) -1","solution":"def minCoins(denominations, amount): Returns the minimum number of coins required to make up the given amount using the given denominations. If it is not possible to make the target amount, returns -1. # Initialize the dp array with inf, because we aim to find the minimum dp = [float('inf')] * (amount + 1) # Base case: 0 amount requires 0 coins dp[0] = 0 # Iterate over each denomination for coin in denominations: for i in range(coin, amount + 1): dp[i] = min(dp[i], dp[i - coin] + 1) # If dp[amount] is still inf, it means it's not possible to form that amount return dp[amount] if dp[amount] != float('inf') else -1"},{"question":"def k_palindrome(s: str, k: int) -> bool: Determine if the string s can be transformed into a palindrome by removing at most k characters. >>> k_palindrome(\\"abca\\", 1) == True >>> k_palindrome(\\"abcdeca\\", 2) == True >>> k_palindrome(\\"abcdef\\", 2) == False >>> k_palindrome(\\"racecar\\", 0) == True >>> k_palindrome(\\"abcde\\", 5) == True >>> k_palindrome(\\"abcdef\\", 1) == False >>> k_palindrome(\\"\\", 0) == True >>> k_palindrome(\\"a\\", 0) == True >>> k_palindrome(\\"a\\", 1) == True >>> k_palindrome(\\"ab\\", 1) == True >>> k_palindrome(\\"ab\\", 0) == False >>> k_palindrome(\\"a\\" * 1000, 500) == True","solution":"def k_palindrome(s, k): Determine if the string s can be transformed into a palindrome by removing at most k characters. def longest_common_subsequence(s1, s2): len1, len2 = len(s1), len(s2) dp = [[0] * (len2 + 1) for _ in range(len1 + 1)] for i in range(1, len1 + 1): for j in range(1, len2 + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[len1][len2] s_reversed = s[::-1] lcs_length = longest_common_subsequence(s, s_reversed) return len(s) - lcs_length <= k"},{"question":"def add_until_single_digit(num: int) -> int: Given a non-negative integer num, repeatedly add all its digits until the result has only one digit. >>> add_until_single_digit(38) 2 >>> add_until_single_digit(123) 6 >>> add_until_single_digit(0) 0","solution":"def add_until_single_digit(num): Given a non-negative integer num, repeatedly add all its digits until the result has only one digit. while num >= 10: num = sum(int(digit) for digit in str(num)) return num"},{"question":"from typing import List def max_energy(n: int, m: int, grid: List[List[int]]) -> int: Determine the maximum amount of energy the traveler can collect when moving optimally. >>> max_energy(3, 3, [ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 12 >>> max_energy(1, 1, [[5]]) 5 >>> max_energy(1, 3, [[1, 2, 3]]) 6 >>> max_energy(3, 1, [[1], [2], [3]]) 6 >>> max_energy(2, 2, [[0, 0], [0, 0]]) 0 >>> max_energy(1000, 1000, [[1] * 1000 for _ in range(1000)]) 1999","solution":"def max_energy(n, m, grid): dp = [[0] * m for _ in range(n)] dp[0][0] = grid[0][0] # Fill the first row for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, n): for j in range(1, m): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[n-1][m-1]"},{"question":"def match_subsequence(target_movies, user_movies): Checks if the user_movies list is a contiguous subsequence within the target_movies list. Parameters: target_movies (list of str): The movies available on Amazon Prime user_movies (list of str): The sequence of movies the user has watched Returns: bool: True if user_movies is a contiguous subsequence within target_movies, False otherwise Examples: >>> match_subsequence([\\"A\\", \\"B\\", \\"C\\", \\"D\\", \\"E\\"], [\\"B\\", \\"C\\", \\"D\\"]) True >>> match_subsequence([\\"A\\", \\"B\\", \\"C\\", \\"D\\", \\"E\\"], [\\"C\\", \\"A\\"]) False >>> match_subsequence([\\"A\\", \\"A\\", \\"B\\", \\"A\\", \\"D\\"], [\\"A\\", \\"B\\", \\"A\\"]) True","solution":"def match_subsequence(target_movies, user_movies): Checks if the user_movies list is a contiguous subsequence within the target_movies list. Parameters: target_movies (list of str): The movies available on Amazon Prime user_movies (list of str): The sequence of movies the user has watched Returns: bool: True if user_movies is a contiguous subsequence within target_movies, False otherwise target_len = len(target_movies) user_len = len(user_movies) # Traverse through the target_movies list to find a matching subsequence for i in range(target_len - user_len + 1): if target_movies[i:i + user_len] == user_movies: return True return False"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a string containing a mathematical expression with non-negative integers, addition (+), and multiplication (*) operations. Args: expression (str): The mathematical expression as a string. Returns: int: The result of the evaluated expression. >>> evaluate_expression(\\"3+2*2\\") 7 >>> evaluate_expression(\\" 3*2 + 1 \\") 7 >>> evaluate_expression(\\"4+2*3+5\\") 15 >>> evaluate_expression(\\"5\\") 5 >>> evaluate_expression(\\"10\\") 10 >>> evaluate_expression(\\"1+2+3+4\\") 10 >>> evaluate_expression(\\"2*3*4\\") 24","solution":"def evaluate_expression(expression): Evaluates a string containing a mathematical expression with non-negative integers, addition (+), and multiplication (*) operations. Args: expression (str): The mathematical expression as a string. Returns: int: The result of the evaluated expression. # Remove whitespace expression = expression.replace(\\" \\", \\"\\") # Initialize two stacks to store numbers and current multiplication results num_stack = [] current_number = 0 current_mult = 1 expect_operand = True # flag indicating next char should be an operand for i, char in enumerate(expression): if char.isdigit(): current_number = current_number * 10 + int(char) expect_operand = True if char == \\"*\\" or char == \\"+\\" or i == len(expression) - 1 or not expect_operand: if char == \\"*\\" or i == len(expression) - 1: if i == len(expression) - 1: current_number = current_number if char.isdigit() else int(char) current_mult *= current_number elif char == \\"+\\": num_stack.append(current_mult * current_number) current_mult = 1 current_number = 0 expect_operand = False num_stack.append(current_mult) return sum(num_stack)"},{"question":"from typing import List def max_product_of_three(arr: List[int]) -> int: Given an integer array \`arr\`, find and return the maximum product that can be obtained by multiplying any three distinct elements of the array. >>> max_product_of_three([1, 2, 3]) 6 >>> max_product_of_three([-10, -10, 5, 2]) 500 >>> max_product_of_three([1, 10, -5, 1, -100]) 5000","solution":"from typing import List def max_product_of_three(arr: List[int]) -> int: Given an integer array \`arr\`, find and return the maximum product that can be obtained by multiplying any three distinct elements of the array. if len(arr) < 3: raise ValueError(\\"Array must contain at least three elements.\\") arr.sort() # The highest product of three integers could be either: # 1. Product of the three largest numbers # 2. Product of the two smallest (most negative) numbers and the largest number return max(arr[-1] * arr[-2] * arr[-3], arr[0] * arr[1] * arr[-1])"},{"question":"def find_first_occurrence(array: List[int], target: int) -> int: Returns the index of the first occurrence of the target value in the array. If the target value does not exist, returns -1. >>> find_first_occurrence([10, 22, 33, 22, 44], 22) 1 >>> find_first_occurrence([10, 22, 33, 22, 44], 55) -1 >>> find_first_occurrence([10, 22, 33, 22, 44], 10) 0 >>> find_first_occurrence([10, 22, 33, 22, 44], 44) 4 >>> find_first_occurrence([], 10) -1 >>> find_first_occurrence([10], 10) 0 >>> find_first_occurrence([10], 5) -1 >>> find_first_occurrence([1, 2, 3, 1, 2, 1], 1) 0 >>> find_first_occurrence([1, 2, 3, 1, 2, 1], 2) 1 >>> find_first_occurrence([1, 2, 3, 1, 2, 1], 3) 2","solution":"def find_first_occurrence(array, target): Returns the index of the first occurrence of the target value in the array. If the target value does not exist, returns -1. for index, value in enumerate(array): if value == target: return index return -1"},{"question":"def predict_tree_height(initial_height, weekly_growth_rate, duration): Predicts the height of a tree after a number of weeks, given its initial height and weekly growth rate. Parameters: - initial_height (float): Initial height of the tree in centimeters. - weekly_growth_rate (float): Weekly growth rate of the tree in centimeters. - duration (int): Number of weeks. Returns: - float: Predicted height of the tree rounded to the nearest tenth. >>> predict_tree_height(100, 2.5, 4) 110.0 >>> predict_tree_height(150.0, 5, 3) 165.0 >>> predict_tree_height(75, 7.5, 2) 90.0 >>> predict_tree_height(50.5, 1.2, 10) 62.5 >>> predict_tree_height(0, 0, 0) 0.0 >>> predict_tree_height(100, 0, 10) 100.0 >>> predict_tree_height(0, 2, 5) 10.0 Raises: - ValueError: If initial_height is not a number. - ValueError: If weekly_growth_rate is not a number. - ValueError: If duration is not an integer.","solution":"def predict_tree_height(initial_height, weekly_growth_rate, duration): Predicts the height of a tree after a number of weeks, given its initial height and weekly growth rate. Parameters: - initial_height (float): Initial height of the tree in centimeters. - weekly_growth_rate (float): Weekly growth rate of the tree in centimeters. - duration (int): Number of weeks. Returns: - float: Predicted height of the tree rounded to the nearest tenth. if not isinstance(initial_height, (int, float)): raise ValueError(\\"Initial height must be a number\\") if not isinstance(weekly_growth_rate, (int, float)): raise ValueError(\\"Weekly growth rate must be a number\\") if not isinstance(duration, int): raise ValueError(\\"Duration must be an integer\\") # Calculate new height new_height = initial_height + (weekly_growth_rate * duration) # Return the height rounded to the nearest tenth return round(new_height, 1)"},{"question":"def find_anagram_substrings(s1: str, s2: str) -> List[int]: Returns all starting indices of s2's anagrams in s1. If either of the input strings is empty, the return value must be an empty list. Example: >>> find_anagram_substrings(\\"cbaebabacd\\", \\"abc\\") == [0, 6] >>> find_anagram_substrings(\\"abab\\", \\"ab\\") == [0, 1, 2] >>> find_anagram_substrings(\\"af\\", \\"be\\") == [] >>> find_anagram_substrings(\\"\\", \\"anagram\\") == [] >>> find_anagram_substrings(\\"abc\\", \\"\\") == [] >>> find_anagram_substrings(\\"a\\", \\"ab\\") == [] >>> find_anagram_substrings(\\"abc\\", \\"cba\\") == [0] >>> find_anagram_substrings(\\"abcdefgabc\\", \\"abc\\") == [0, 7]","solution":"from collections import Counter def find_anagram_substrings(s1, s2): Returns a list of starting indices of s2's anagrams in s1. if not s1 or not s2 or len(s2) > len(s1): return [] result = [] s2_counter = Counter(s2) window_counter = Counter(s1[:len(s2)]) if s2_counter == window_counter: result.append(0) for i in range(len(s2), len(s1)): window_counter[s1[i]] += 1 window_counter[s1[i - len(s2)]] -= 1 if window_counter[s1[i - len(s2)]] == 0: del window_counter[s1[i - len(s2)]] if window_counter == s2_counter: result.append(i - len(s2) + 1) return result"},{"question":"class StockPriceTracker: A class to track stock prices that supports updating prices at given timestamps, and retrieving the latest, maximum, and minimum prices. def __init__(self): Initializes the tracker with no recorded prices. pass def updateStockPrice(self, timestamp: int, price: int): Updates the stock price for the given timestamp. If the timestamp already exists, the previous price is overwritten. pass def getCurrentPrice(self) -> int: Retrieves the latest stock price based on the highest timestamp. pass def getMaxPrice(self) -> int: Retrieves the maximum stock price recorded so far. pass def getMinPrice(self) -> int: Retrieves the minimum stock price recorded so far. pass # Unit tests def test_update_and_getCurrentPrice(): tracker = StockPriceTracker() tracker.updateStockPrice(1, 100) tracker.updateStockPrice(2, 200) tracker.updateStockPrice(1, 150) assert tracker.getCurrentPrice() == 200 def test_getMaxPrice(): tracker = StockPriceTracker() tracker.updateStockPrice(1, 100) tracker.updateStockPrice(2, 200) tracker.updateStockPrice(1, 150) assert tracker.getMaxPrice() == 200 def test_getMinPrice(): tracker = StockPriceTracker() tracker.updateStockPrice(1, 100) tracker.updateStockPrice(2, 200) tracker.updateStockPrice(1, 150) assert tracker.getMinPrice() == 150 def test_multiple_updates_and_queries(): tracker = StockPriceTracker() tracker.updateStockPrice(1, 100) tracker.updateStockPrice(2, 200) tracker.updateStockPrice(3, 50) tracker.updateStockPrice(2, 250) assert tracker.getCurrentPrice() == 50 assert tracker.getMaxPrice() == 250 assert tracker.getMinPrice() == 50","solution":"class StockPriceTracker: def __init__(self): self.prices = {} self.latest_timestamp = -float('inf') self.max_price = -float('inf') self.min_price = float('inf') def updateStockPrice(self, timestamp, price): self.prices[timestamp] = price if timestamp > self.latest_timestamp: self.latest_timestamp = timestamp self.max_price = max(self.prices.values()) self.min_price = min(self.prices.values()) def getCurrentPrice(self): return self.prices[self.latest_timestamp] def getMaxPrice(self): return self.max_price def getMinPrice(self): return self.min_price"},{"question":"def estimate_population(V: int, D: int, data: List[Tuple[str, List[int]]]) -> List[Tuple[str, int]]: Estimate each village's population using multiple days of marmot observation data. >>> estimate_population(1, 3, [(\\"VillageA\\", [10, 12, 11])]) [(\\"VillageA\\", 11)] >>> estimate_population(2, 3, [(\\"VillageA\\", [10, 12, 11]), (\\"VillageB\\", [20, 22, 21])]) [(\\"VillageA\\", 11), (\\"VillageB\\", 21)] from solution import estimate_population def test_estimate_population_single_village(): V, D = 1, 3 data = [ [\\"VillageA\\", [10, 12, 11]] ] assert estimate_population(V, D, data) == [(\\"VillageA\\", 11)] def test_estimate_population_multiple_villages(): V, D = 2, 3 data = [ [\\"VillageA\\", [10, 12, 11]], [\\"VillageB\\", [20, 22, 21]] ] assert estimate_population(V, D, data) == [(\\"VillageA\\", 11), (\\"VillageB\\", 21)] def test_estimate_population_varying_days(): V, D = 2, 4 data = [ [\\"VillageA\\", [10, 12, 12, 11]], [\\"VillageB\\", [20, 22, 21, 20]] ] assert estimate_population(V, D, data) == [(\\"VillageA\\", 11), (\\"VillageB\\", 20)] def test_estimate_population_min_values(): V, D = 1, 1 data = [ [\\"VillageA\\", [5]] ] assert estimate_population(V, D, data) == [(\\"VillageA\\", 5)] def test_estimate_population_large_values(): V, D = 1, 3 data = [ [\\"VillageA\\", [1000, 1500, 1200]] ] assert estimate_population(V, D, data) == [(\\"VillageA\\", 1233)]","solution":"def estimate_population(V, D, data): Estimates each village's population using multiple days of marmot observation data. results = [] for i in range(V): village_name = data[i][0] observations = data[i][1] estimated_population = sum(observations) // D results.append((village_name, estimated_population)) return results"},{"question":"def smallest_positive_integer_not_sum(arr: List[int]) -> int: Given an array of integers, find the smallest positive integer that cannot be represented as the sum of elements of any subset of the array. >>> smallest_positive_integer_not_sum([1, 2, 3, 10]) 7 >>> smallest_positive_integer_not_sum([1, 1, 1, 1]) 5 >>> smallest_positive_integer_not_sum([3, 5, 7]) 1 from solution import smallest_positive_integer_not_sum def test_smallest_positive_integer_not_sum_example_1(): assert smallest_positive_integer_not_sum([1, 2, 3, 10]) == 7 def test_smallest_positive_integer_not_sum_example_2(): assert smallest_positive_integer_not_sum([1, 1, 1, 1]) == 5 def test_smallest_positive_integer_not_sum_example_3(): assert smallest_positive_integer_not_sum([3, 5, 7]) == 1 def test_smallest_positive_integer_not_sum_all_same_elements(): assert smallest_positive_integer_not_sum([2, 2, 2]) == 1 def test_smallest_positive_integer_not_sum_single_element(): assert smallest_positive_integer_not_sum([2]) == 1 def test_smallest_positive_integer_not_sum_no_gaps(): assert smallest_positive_integer_not_sum([1, 2, 3, 4, 5]) == 16 def test_smallest_positive_integer_not_sum_largers_elements(): assert smallest_positive_integer_not_sum([10, 20, 30]) == 1 def test_smallest_positive_integer_not_sum_unsorted_input(): assert smallest_positive_integer_not_sum([4, 2, 1, 3]) == 11 def test_smallest_positive_integer_not_sum_large_variety(): assert smallest_positive_integer_not_sum([1, 2, 2, 5, 10, 20, 40]) == 81","solution":"def smallest_positive_integer_not_sum(arr): Given an array of integers, find the smallest positive integer that cannot be represented as the sum of elements of any subset of the array. arr.sort() res = 1 # Initialize result for num in arr: if num > res: break res += num return res"},{"question":"def validate_transmission(transmission: str) -> bool: Validates the given transmission string based on specified format. Parameters: transmission (str): The transmission string to validate. Returns: bool: True if the transmission is valid, False otherwise. >>> validate_transmission(\\"HQKUD: this is a valid message\\") True >>> validate_transmission(\\"ABCDE: hello world\\") True >>> validate_transmission(\\"ZXCVB: valid sample text\\") True >>> validate_transmission(\\"HQKUD this is missing colon\\") False >>> validate_transmission(\\"ABCDE this is also missing colon\\") False >>> validate_transmission(\\"HQ1KD: valid message with invalid ID\\") False >>> validate_transmission(\\"ABCDEEXTRA: valid message with long ID\\") False >>> validate_transmission(\\"ABCD: short ID\\") False >>> validate_transmission(\\"HQKUD: This Contains Uppercase Letters\\") False >>> validate_transmission(\\"ABCDE: 1234\\") False >>> validate_transmission(\\"ZXCVB: special_characters&*#\\") False >>> validate_transmission(\\"MENTG: mixedCase words and\\") False >>> validate_transmission(\\"ABCDE:\\") False >>> validate_transmission(\\"ABCDE: \\") False >>> validate_transmission(\\"\\") False","solution":"import re def validate_transmission(transmission): Validates the given transmission string based on specified format. Parameters: transmission (str): The transmission string to validate. Returns: bool: True if the transmission is valid, False otherwise. pattern = r'^[A-Z]{5}: ([a-z]+( [a-z]+)*)' match = re.match(pattern, transmission) return bool(match)"},{"question":"import re from collections import Counter from typing import List, Tuple def word_frequency(sentence: str) -> List[Tuple[str, int]]: Design a function that receives a string with words separated by single spaces and returns a list of tuples, where each tuple contains a word from the string and its corresponding frequency count. The function should ignore punctuation, and the words should be case-insensitive in the frequency count. >>> word_frequency(\\"Hello world! Hello!\\") [(\\"hello\\", 2), (\\"world\\", 1)] >>> word_frequency(\\"hello hello\\") [(\\"hello\\", 2)] >>> word_frequency(\\"hello, world!\\") [(\\"hello\\", 1), (\\"world\\", 1)] >>> word_frequency(\\"Hello HELLO hello\\") [(\\"hello\\", 3)] >>> word_frequency(\\"Hello world! Hello from the other side.\\") [(\\"hello\\", 2), (\\"world\\", 1), (\\"from\\", 1), (\\"the\\", 1), (\\"other\\", 1), (\\"side\\", 1)] >>> word_frequency(\\"\\") [] >>> word_frequency(\\"one 1 two 2 one 1\\") [(\\"one\\", 2), (\\"1\\", 2), (\\"two\\", 1), (\\"2\\", 1)]","solution":"import re from collections import Counter def word_frequency(sentence): Returns a list of tuples with each word from the sentence and its frequency count. The function ignores punctuation and is case-insensitive. # Convert to lowercase and remove punctuation using regex processed_sentence = re.sub(r'[^ws]', '', sentence.lower()) words = processed_sentence.split() frequency = Counter(words) return list(frequency.items())"},{"question":"def longestRainyStreak(rainfall: List[int]) -> int: Determines the longest duration of continuous rain given an input list of daily rainfall amounts. Continuous rain is defined as consecutive days where rainfall is more than zero. :param rainfall: List of integers representing daily rainfall amounts (0 if no rain, otherwise the amount of rain). :return: Integer representing the longest streak of continuous rainy days. >>> longestRainyStreak([0, 2, 3, 0, 0, 1, 2, 3, 4, 0, 0, 0]) == 4 >>> longestRainyStreak([0, 0, 0, 0, 0]) == 0 >>> longestRainyStreak([1, 1, 1, 1, 1]) == 5 >>> longestRainyStreak([0, 0, 1, 0, 0]) == 1 >>> longestRainyStreak([]) == 0 >>> longestRainyStreak([0, 1, 2, 3, 0, 1]) == 3 >>> longestRainyStreak([1, 0, 1, 0, 1, 1]) == 2 >>> longestRainyStreak([0, 0, 0, 1, 2, 3]) == 3 >>> longestRainyStreak([1, 2, 3, 0, 0, 0]) == 3","solution":"def longestRainyStreak(rainfall): Determines the longest duration of continuous rain. :param rainfall: List of integers representing daily rainfall amounts. :return: Integer representing the longest streak of continuous rainy days. max_streak = 0 current_streak = 0 for rain in rainfall: if rain > 0: current_streak += 1 if current_streak > max_streak: max_streak = current_streak else: current_streak = 0 return max_streak"},{"question":"def min_cost_path(costMatrix): Returns the minimum cost to reach from the top-left cell to the bottom-right cell. You are allowed to move only right or down from a cell. :param costMatrix: A n x m integer array representing the cost of visiting each cell. :return: An integer representing the minimum cost to reach from the top-left cell to the bottom-right cell. >>> min_cost_path([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) == 7 >>> min_cost_path([ ... [1, 2, 3, 4] ... ]) == 10 >>> min_cost_path([ ... [1], ... [2], ... [3], ... [4] ... ]) == 10 >>> min_cost_path([ ... [10000, 20000], ... [30000, 40000] ... ]) == 70000 >>> min_cost_path([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) == 0 >>> min_cost_path([ ... [42] ... ]) == 42","solution":"def min_cost_path(costMatrix): Returns the minimum cost to reach from the top-left cell to the bottom-right cell. You are allowed to move only right or down from a cell. n = len(costMatrix) m = len(costMatrix[0]) # Create a dp table for storing the minimum cost at each cell dp = [[0] * m for _ in range(n)] dp[0][0] = costMatrix[0][0] # Initialize the first row for i in range(1, m): dp[0][i] = dp[0][i-1] + costMatrix[0][i] # Initialize the first column for j in range(1, n): dp[j][0] = dp[j-1][0] + costMatrix[j][0] # Fill in the rest of the dp table for i in range(1, n): for j in range(1, m): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + costMatrix[i][j] return dp[n-1][m-1]"},{"question":"from typing import List def k_most_frequent_elements(arr: List[int], k: int) -> List[int]: Given an array of integers arr and an integer k, find the k most frequent elements. If multiple elements have the same frequency, the smaller element should come first. >>> k_most_frequent_elements([1,1,1,2,2,3], 2) [1, 2] >>> k_most_frequent_elements([1], 1) [1] >>> k_most_frequent_elements([3,3,3,1,1,2], 3) [3, 1, 2] from collections import Counter def test_k_most_frequent_elements_example1(): assert k_most_frequent_elements([1,1,1,2,2,3], 2) == [1, 2] def test_k_most_frequent_elements_example2(): assert k_most_frequent_elements([1], 1) == [1] def test_k_most_frequent_elements_example3(): assert k_most_frequent_elements([3,3,3,1,1,2], 3) == [3, 1, 2] def test_k_most_frequent_elements_single_element(): assert k_most_frequent_elements([4], 1) == [4] def test_k_most_frequent_elements_all_same_frequency(): assert k_most_frequent_elements([1, 2, 3], 2) == [1, 2] assert k_most_frequent_elements([3, 1, 2], 2) == [1, 2] def test_k_most_frequent_elements_mixed_frequencies(): assert k_most_frequent_elements([5,5,4,4,1,1,2], 3) == [1, 4, 5]","solution":"from collections import Counter def k_most_frequent_elements(arr, k): Returns the k most frequent elements in the array \`arr\`. If multiple elements have the same frequency, the smaller element comes first. # Count the frequency of each element in the array freq = Counter(arr) # Sort elements by frequency (highest first) and by value (lower first if frequencies are the same) sorted_elements = sorted(freq.keys(), key=lambda x: (-freq[x], x)) return sorted_elements[:k]"},{"question":"def has_pair_with_sum(nums: List[int], target: int) -> bool: Returns True if there are two distinct indices i and j in the array such that nums[i] + nums[j] == target. Otherwise, returns False. Args: nums : List[int] - List of integers. target : int - The target sum. Returns: bool - Whether there exists a pair with the specified sum. >>> has_pair_with_sum([2, 7, 11, 15], 9) True >>> has_pair_with_sum([1, 2, 3, 4, 5], 10) False >>> has_pair_with_sum([-1, -2, -3, -4], -3) True def solve(t: int, cases: List[Tuple[int, List[int], int]]) -> List[bool]: Process multiple test cases to determine if any pair with the specified sum exists. Args: t : int - Number of test cases. cases : List[Tuple[int, List[int], int]] - Each tuple contains (n, nums, target). Returns: List[bool] - List of results for each test case. >>> t = 2 >>> cases = [ ... (4, [2, 7, 11, 15], 9), ... (5, [1, 2, 3, 4, 5], 10) ... ] >>> solve(t, cases) [True, False]","solution":"def has_pair_with_sum(nums, target): Returns True if there are two distinct indices i and j in the array such that nums[i] + nums[j] == target. Otherwise, returns False. Args: nums : List[int] - List of integers. target : int - The target sum. Returns: bool - Whether there exists a pair with the specified sum. seen = set() for num in nums: if target - num in seen: return True seen.add(num) return False def solve(t, cases): Process multiple test cases to determine if any pair with the specified sum exists. Args: t : int - Number of test cases. cases : List[Tuple[int, List[int], int]] - Each tuple contains (n, nums, target). Returns: List[bool] - List of results for each test case. results = [] for n, nums, target in cases: results.append(has_pair_with_sum(nums, target)) return results"},{"question":"def prepare_books_for_sale(budget: int, books: List[Dict[str, Union[str, int]]]) -> List[str]: Returns a list of book titles that can be bought within the given budget. Titles are sorted in alphabetical order. :param budget: int, the total budget for new book purchases :param books: list of dicts, each dict contains \\"title\\" (str) and \\"price\\" (int) :return: list of str, titles of the books that can be bought within the budget >>> prepare_books_for_sale(50, [ ... {\\"title\\": \\"The Catcher in the Rye\\", \\"price\\": 10}, ... {\\"title\\": \\"To Kill a Mockingbird\\", \\"price\\": 20}, ... {\\"title\\": \\"1984\\", \\"price\\": 15}, ... {\\"title\\": \\"The Great Gatsby\\", \\"price\\": 10}, ... {\\"title\\": \\"Moby Dick\\", \\"price\\": 25} ... ]) ['1984', 'The Catcher in the Rye', 'The Great Gatsby'] >>> prepare_books_for_sale(5, [ ... {\\"title\\": \\"The Catcher in the Rye\\", \\"price\\": 10}, ... {\\"title\\": \\"To Kill a Mockingbird\\", \\"price\\": 20}, ... {\\"title\\": \\"1984\\", \\"price\\": 15} ... ]) [] def test_prepare_books_for_sale(): budget = 10 books = [] assert prepare_books_for_sale(budget, books) == [] budget = 0 books = [ {\\"title\\": \\"The Catcher in the Rye\\", \\"price\\": 10}, {\\"title\\": \\"To Kill a Mockingbird\\", \\"price\\": 20} ] assert prepare_books_for_sale(budget, books) == [] budget = 15 books = [ {\\"title\\": \\"The Catcher in the Rye\\", \\"price\\": 10}, {\\"title\\": \\"To Kill a Mockingbird\\", \\"price\\": 20}, {\\"title\\": \\"1984\\", \\"price\\": 15}, {\\"title\\": \\"The Great Gatsby\\", \\"price\\": 10}, {\\"title\\": \\"Moby Dick\\", \\"price\\": 25} ] expected = ['1984', 'The Catcher in the Rye', 'The Great Gatsby'] assert prepare_books_for_sale(budget, books) == expected budget = 30 books = [ {\\"title\\": \\"The Catcher in the Rye\\", \\"price\\": 10}, {\\"title\\": \\"To Kill a Mockingbird\\", \\"price\\": 20}, {\\"title\\": \\"1984\\", \\"price\\": 15}, {\\"title\\": \\"The Great Gatsby\\", \\"price\\": 10} ] expected = ['1984', 'The Catcher in the Rye', 'The Great Gatsby', 'To Kill a Mockingbird'] assert prepare_books_for_sale(budget, books) == expected budget = 5 books = [ {\\"title\\": \\"The Catcher in the Rye\\", \\"price\\": 10}, {\\"title\\": \\"To Kill a Mockingbird\\", \\"price\\": 20}, {\\"title\\": \\"1984\\", \\"price\\": 15} ] assert prepare_books_for_sale(budget, books) == []","solution":"def prepare_books_for_sale(budget, books): Returns a list of book titles that can be bought within the given budget. Titles are sorted in alphabetical order. :param budget: int, the total budget for new book purchases :param books: list of dicts, each dict contains \\"title\\" (str) and \\"price\\" (int) :return: list of str, titles of the books that can be bought within the budget affordable_books = [book['title'] for book in books if book['price'] <= budget] return sorted(affordable_books)"},{"question":"def first_missing_positive(nums: List[int]) -> int: Given an unsorted integer array, find the smallest missing positive integer. The function must run in O(n) time and use constant extra space. Examples: >>> first_missing_positive([1, 2, 0]) 3 >>> first_missing_positive([3, 4, -1, 1]) 2 >>> first_missing_positive([7, 8, 9, 11, 12]) 1","solution":"def first_missing_positive(nums): Finds the smallest missing positive integer from an unsorted array. This function runs in O(n) time and uses constant extra space. n = len(nums) # Move every positive integer to its correct position for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] # Identify the first position where the index does not match the value for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"import math import heapq from typing import List, Tuple def calc_distance(x1: int, y1: int, x2: int, y2: int) -> float: Calculate the Euclidean distance between two points (x1, y1) and (x2, y2). >>> calc_distance(0, 0, 3, 4) 5.0 >>> calc_distance(1, 1, 1, 1) 0.0 pass def minimum_cable_length(n: int, tower_status: str, cities: List[Tuple[int, int]]) -> int: Calculate the minimum cable length required to cover all cities. >>> n = 3 >>> tower_status = \\"100\\" >>> cities = [(0, 0), (1, 0), (2, 0)] >>> minimum_cable_length(n, tower_status, cities) 2 >>> n = 4 >>> tower_status = \\"0101\\" >>> cities = [(0, 0), (0, 3), (3, 3), (3, 0)] >>> minimum_cable_length(n, tower_status, cities) 6 pass def solve_telecom_coverage(T: int, test_cases: List[Tuple[int, str, List[Tuple[int, int]]]]) -> List[int]: Solve the telecom coverage problem for multiple test cases. >>> T = 2 >>> test_cases = [ ... (3, \\"100\\", [(0, 0), (1, 0), (2, 0)]), ... (4, \\"0101\\", [(0, 0), (0, 3), (3, 3), (3, 0)]) ... ] >>> solve_telecom_coverage(T, test_cases) [2, 6] pass def main(input_text: str): lines = input_text.strip().split('n') T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): n = int(lines[index]) tower_status = lines[index + 1] cities = [] for i in range(n): x, y = map(int, lines[index + 2 + i].split()) cities.append((x, y)) test_cases.append((n, tower_status, cities)) index += 2 + n results = solve_telecom_coverage(T, test_cases) for result in results: print(result) # Example usage if __name__ == \\"__main__\\": input_text = 2 3 100 0 0 1 0 2 0 4 0101 0 0 0 3 3 3 3 0 main(input_text)","solution":"import math import heapq def calc_distance(x1, y1, x2, y2): return math.sqrt((x1 - x2)**2 + (y1 - y2)**2) def minimum_cable_length(n, tower_status, cities): # Using Prim's algorithm to calculate the Minimum Spanning Tree (MST) # List to check if the city is already in the MST or not in_mst = [False] * n # Min heap priority queue for Prim's algorithm min_heap = [] # Initial cost list, initializing with large values (infinity) costs = [float('inf')] * n # Starting with the first city with a telecom tower for i in range(n): if tower_status[i] == '1': heapq.heappush(min_heap, (0, i)) costs[i] = 0 total_length = 0 while min_heap: current_cost, u = heapq.heappop(min_heap) # If the city is already in MST, skip it if in_mst[u]: continue # Include the city in MST total_length += current_cost in_mst[u] = True for v in range(n): if not in_mst[v]: distance = calc_distance(cities[u][0], cities[u][1], cities[v][0], cities[v][1]) if distance < costs[v]: costs[v] = distance heapq.heappush(min_heap, (distance, v)) return int(total_length) def solve_telecom_coverage(T, test_cases): results = [] for i in range(T): n = test_cases[i][0] tower_status = test_cases[i][1] cities = test_cases[i][2] result = minimum_cable_length(n, tower_status, cities) results.append(result) return results # Parsing input and getting results def main(input_text): lines = input_text.strip().split('n') T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): n = int(lines[index]) tower_status = lines[index + 1] cities = [] for i in range(n): x, y = map(int, lines[index + 2 + i].split()) cities.append((x, y)) test_cases.append((n, tower_status, cities)) index += 2 + n results = solve_telecom_coverage(T, test_cases) for result in results: print(result) # Example usage if __name__ == \\"__main__\\": input_text = 2 3 100 0 0 1 0 2 0 4 0101 0 0 0 3 3 3 3 0 main(input_text)"},{"question":"def evaluate_expression(expression: str) -> int: You are given a string that contains a mathematical expression in an infix format. The operators include +, -, *, and /, and the operands are integers only. The expression may contain parentheses to indicate precedence. Your task is to evaluate this expression and return the result as an integer. >>> evaluate_expression(\\"3+2*2\\") -> 7 >>> evaluate_expression(\\" 3/2 \\") -> 1 >>> evaluate_expression(\\"(2+6* 3+5- (3*14/7+2)*5)+3\\") -> -12","solution":"def evaluate_expression(expression: str) -> int: def operate(a, b, op): if op == '+': return a + b elif op == '-': return a - b elif op == '*': return a * b elif op == '/': return int(a / b) # Handle truncation towards zero def precedence(op): if op in ('+', '-'): return 1 if op in ('*', '/'): return 2 return 0 def to_rpn(expression): stack = [] output = [] i = 0 while i < len(expression): if expression[i].isdigit(): num = 0 while i < len(expression) and expression[i].isdigit(): num = num * 10 + int(expression[i]) i += 1 output.append(num) i -= 1 elif expression[i] == '(': stack.append(expression[i]) elif expression[i] == ')': while stack and stack[-1] != '(': output.append(stack.pop()) stack.pop() # Removing '(' else: while (stack and precedence(stack[-1]) >= precedence(expression[i])): output.append(stack.pop()) stack.append(expression[i]) i += 1 while stack: output.append(stack.pop()) return output def evaluate_rpn(tokens): stack = [] for token in tokens: if isinstance(token, int): stack.append(token) else: b = stack.pop() a = stack.pop() stack.append(operate(a, b, token)) return stack[0] rpn = to_rpn(expression) return evaluate_rpn(rpn)"},{"question":"def longest_subarray_with_sum(l, k): Returns the length of the longest contiguous subarray that sums to k. If no such subarray exists, returns 0. >>> longest_subarray_with_sum([1, -1, 5, -2, 3], 3) == 4 >>> longest_subarray_with_sum([-2, -1, 2, 1], 1) == 2 >>> longest_subarray_with_sum([1, 2, 3], 6) == 3 >>> longest_subarray_with_sum([1, 2, 3], 7) == 0","solution":"def longest_subarray_with_sum(l, k): Returns the length of the longest contiguous subarray that sums to k. If no such subarray exists, returns 0. sum_to_index = {0: -1} current_sum = 0 max_length = 0 for i, num in enumerate(l): current_sum += num if current_sum == k: max_length = i + 1 if current_sum - k in sum_to_index: max_length = max(max_length, i - sum_to_index[current_sum - k]) if current_sum not in sum_to_index: sum_to_index[current_sum] = i return max_length"},{"question":"def shuffle_array(nums: List[int], n: int) -> List[int]: Shuffles the given array \`nums\` into the form [x1, y1, x2, y2, ..., xn, yn]. Args: nums: List[int] -- the input list consisting of 2n elements. n: int -- the half-length of the input list. Returns: List[int] -- the shuffled list. Examples: >>> shuffle_array([2, 5, 1, 3, 4, 7], 3) [2, 3, 5, 4, 1, 7] >>> shuffle_array([1, 1, 2, 2], 2) [1, 2, 1, 2] >>> shuffle_array([1, 2, 3, 4, 4, 3, 2, 1], 4) [1, 4, 2, 3, 3, 2, 4, 1]","solution":"def shuffle_array(nums, n): Shuffles the given array \`nums\` into the form [x1, y1, x2, y2, ..., xn, yn]. Args: nums: List[int] -- the input list consisting of 2n elements. n: int -- the half-length of the input list. Returns: List[int] -- the shuffled list. shuffled = [] for i in range(n): shuffled.append(nums[i]) shuffled.append(nums[n + i]) return shuffled"},{"question":"def rainbow_sort(arr): Sorts the given list of integers in a single traversal such that all 0s come before 1s, and 1s come before 2s. >>> arr = [2, 0, 1, 1, 0, 2, 0] >>> rainbow_sort(arr) >>> arr [0, 0, 0, 1, 1, 2, 2] >>> arr = [0, 0, 1, 1, 2, 2] >>> rainbow_sort(arr) >>> arr [0, 0, 1, 1, 2, 2] >>> arr = [1, 1, 1, 1] >>> rainbow_sort(arr) >>> arr [1, 1, 1, 1] >>> arr = [2, 2, 1, 1, 0, 0] >>> rainbow_sort(arr) >>> arr [0, 0, 1, 1, 2, 2] >>> arr = [1, 0, 2, 1, 0, 2, 1, 0] >>> rainbow_sort(arr) >>> arr [0, 0, 0, 1, 1, 1, 2, 2] >>> arr = [] >>> rainbow_sort(arr) >>> arr [] >>> arr = [2, 2, 2, 2] >>> rainbow_sort(arr) >>> arr [2, 2, 2, 2]","solution":"def rainbow_sort(arr): Sorts the given list of integers in a single traversal such that all 0s come before 1s, and 1s come before 2s. low, mid, high = 0, 0, len(arr) - 1 while mid <= high: if arr[mid] == 0: arr[low], arr[mid] = arr[mid], arr[low] low += 1 mid += 1 elif arr[mid] == 1: mid += 1 else: # arr[mid] == 2 arr[high], arr[mid] = arr[mid], arr[high] high -= 1"},{"question":"def single_number(nums: List[int]) -> int: Returns the single integer that appears only once in the array. The function uses XOR to achieve O(n) time complexity and O(1) space complexity. >>> single_number([2, 2, 1]) 1 >>> single_number([4, 1, 2, 1, 2]) 4 >>> single_number([1]) 1","solution":"def single_number(nums): Returns the single integer that appears only once in the array. The function uses XOR to achieve O(n) time complexity and O(1) space complexity. unique_number = 0 for num in nums: unique_number ^= num return unique_number"},{"question":"def partition(nums: List[int]) -> int: Function to partition a list of integers into two subsets such that the absolute difference between the sums of integers in each subset is minimized. >>> partition([1, 6, 11, 5]) 1 >>> partition([1, 2, 3, 9]) 3","solution":"def partition(nums): Function to partition a list of integers into two subsets such that the absolute difference between the sums of integers in each subset is minimized. total_sum = sum(nums) n = len(nums) dp = [False] * (total_sum // 2 + 1) dp[0] = True for num in nums: for j in range(total_sum // 2, num - 1, -1): dp[j] = dp[j] or dp[j - num] for j in range(total_sum // 2, -1, -1): if dp[j]: subset1_sum = j break subset2_sum = total_sum - subset1_sum return abs(subset2_sum - subset1_sum)"},{"question":"from typing import List def find_missing_positive(nums: List[int]) -> int: Finds the smallest positive integer that is not present in the list. >>> find_missing_positive([3, 4, -1, 1]) == 2 >>> find_missing_positive([1, 2, 0]) == 3 >>> find_missing_positive([-1, -2, -3]) == 1 >>> find_missing_positive([2, 4, 6, 8]) == 1 >>> find_missing_positive([]) == 1 >>> find_missing_positive([100, 101, 102]) == 1 >>> find_missing_positive([-10, 3, 7, -3, 5, 1, -1, 4]) == 2 >>> find_missing_positive([1, 1, 2, 2, 3, 3]) == 4 >>> find_missing_positive(list(range(1, 10000))) == 10000 >>> find_missing_positive([1]) == 2 >>> find_missing_positive([-1]) == 1 >>> find_missing_positive([100]) == 1","solution":"from typing import List def find_missing_positive(nums: List[int]) -> int: Finds the smallest positive integer that is not present in the list. nums = [num for num in nums if num > 0] if not nums: return 1 nums.sort() smallest_positive = 1 for num in nums: if num == smallest_positive: smallest_positive += 1 elif num > smallest_positive: break return smallest_positive"},{"question":"from typing import List def is_prime(n: int) -> bool: Helper function to check if a number is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def filter_primes(numbers: List[int]) -> List[int]: Create a function that takes a list of integers and returns a new list containing only the prime numbers from the original list in the same order. >>> filter_primes([2, 3, 5, 7, 11, 13]) [2, 3, 5, 7, 11, 13] >>> filter_primes([1, 4, 6, 8, 10, 12]) [] >>> filter_primes([1, 2, 4, 5, 6, 7, 8, 9, 10, 11]) [2, 5, 7, 11] >>> filter_primes([7]) [7] >>> filter_primes([9]) [] >>> filter_primes([-3, -2, -1, 0, 1, 2, 3, 4]) [2, 3]","solution":"def is_prime(n): Helper function to check if a number is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def filter_primes(numbers): Returns a new list containing only the prime numbers from the original list. return [num for num in numbers if is_prime(num)]"},{"question":"def reverse_words_in_string(s: str) -> str: Given a string consisting of words separated by a single space, write a function that reverses the letters of each word individually, while keeping the words in their original order. If the input string is empty, return an empty string. You may assume that the input string does not contain leading, trailing, or consecutive spaces. Examples: >>> reverse_words_in_string(\\"hello world\\") 'olleh dlrow' >>> reverse_words_in_string(\\"code assessment\\") 'edoc tnemssessa' >>> reverse_words_in_string(\\"\\") ''","solution":"def reverse_words_in_string(s): Given a string consisting of words separated by a single space, reverses the letters of each word individually, while keeping the words in their original order. :param s: Input string :return: String with each word's letters reversed if not s: return \\"\\" words = s.split(' ') reversed_words = [word[::-1] for word in words] return ' '.join(reversed_words)"},{"question":"def separateAndSort(s: str) -> tuple: Separates letters and numbers from the input string, sorts them, and returns as a tuple. >>> separateAndSort(\\"a1b2c3\\") == (['a', 'b', 'c'], [1, 2, 3]) >>> separateAndSort(\\"z9y8x7\\") == (['x', 'y', 'z'], [7, 8, 9]) >>> separateAndSort(\\"hello123\\") == (['e', 'h', 'l', 'l', 'o'], [1, 2, 3])","solution":"def separateAndSort(s): Separates letters and numbers from the input string, sorts them, and returns as a tuple. Parameters: s (str): The input string containing both letters and numbers. Returns: tuple: A tuple where the first element is a sorted list of letters and the second element is a sorted list of numbers. letters = [] numbers = [] for char in s: if char.isdigit(): numbers.append(int(char)) else: letters.append(char) return (sorted(letters), sorted(numbers))"},{"question":"def reverse_each_word(sentence: str) -> str: Reverses each word in a given sentence while keeping the original order of words. >>> reverse_each_word(\\"hello\\") == \\"olleh\\" >>> reverse_each_word(\\"hello world\\") == \\"olleh dlrow\\" >>> reverse_each_word(\\"how are you\\") == \\"woh era uoy\\" >>> reverse_each_word(\\"\\") == \\"\\" >>> reverse_each_word(\\" \\") == \\" \\" >>> reverse_each_word(\\"coding is fun\\") == \\"gnidoc si nuf\\"","solution":"def reverse_each_word(sentence): Reverses each word in a given sentence while keeping the original order of words. Arguments: sentence -- Input sentence string. Returns: A string with each word reversed but the order of words maintained. # Split the sentence on spaces words = sentence.split(' ') # Reverse each word and join them back with a space reversed_words = [word[::-1] for word in words] # Join the list back into a single string return ' '.join(reversed_words)"},{"question":"def most_powerful_word(s: str) -> str: Returns the word with the highest power level. Power level is determined by the sum of ASCII values of the characters. If multiple words have the same highest power level, the first such word is returned. >>> most_powerful_word(\\"hello\\") == \\"hello\\" >>> most_powerful_word(\\"hello world here\\") == \\"world\\" >>> most_powerful_word(\\"racecar ready set go\\") == \\"racecar\\" >>> most_powerful_word(\\"abc bca cab\\") == \\"abc\\" >>> most_powerful_word(\\"a abc abcd\\") == \\"abcd\\" >>> most_powerful_word(\\"a b c d e f z\\") == \\"z\\"","solution":"def most_powerful_word(s): Returns the word with the highest power level. Power level is determined by the sum of ASCII values of the characters. If multiple words have the same highest power level, the first such word is returned. words = s.split() def power_level(word): return sum(ord(char) for char in word) max_power = -1 result = \\"\\" for word in words: power = power_level(word) if power > max_power: max_power = power result = word return result"},{"question":"from typing import List def find_indices(s: str, char: str) -> List[int]: Returns a list of indices where the character char occurs in the string s. >>> find_indices(\\"hello\\", 'e') [1] >>> find_indices(\\"banana\\", 'a') [1, 3, 5] >>> find_indices(\\"test\\", 'x') [] >>> find_indices(\\"aaaa\\", 'a') [0, 1, 2, 3] >>> find_indices(\\"Google\\", 'o') [1, 2]","solution":"def find_indices(s, char): Returns a list of indices where the character char occurs in the string s. return [i for i, c in enumerate(s) if c == char]"},{"question":"def max_rainfall(rainfall): Finds the maximum sum of rainfall over any contiguous subarray. Parameters: rainfall (list of int): List of integers representing daily rainfall. Returns: int: The maximum sum of rainfall over any contiguous subarray. >>> max_rainfall([1, -2, 3, 10, -4, 7, 2, -5]) 18 >>> max_rainfall([1, 2, 3, 4, 5]) 15 >>> max_rainfall([-1, -2, -3]) -1 >>> max_rainfall([5]) 5 >>> max_rainfall([-5]) -5 >>> max_rainfall([]) 0","solution":"def max_rainfall(rainfall): Finds the maximum sum of rainfall over any contiguous subarray. Parameters: rainfall (list of int): List of integers representing daily rainfall. Returns: int: The maximum sum of rainfall over any contiguous subarray. if not rainfall: return 0 max_sum = current_sum = rainfall[0] for value in rainfall[1:]: current_sum = max(value, current_sum + value) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"from typing import List def can_form_palindrome(s: str) -> bool: Determine if a string can be rearranged to form an anagram of a palindrome. :param s: a string consisting of lowercase English letters :return: True if the string can be rearranged to form a palindrome, False otherwise Example: >>> can_form_palindrome(\\"carrace\\") True >>> can_form_palindrome(\\"daily\\") False pass # Unit tests def test_example_1(): assert can_form_palindrome(\\"carrace\\") == True def test_example_2(): assert can_form_palindrome(\\"daily\\") == False def test_single_character(): assert can_form_palindrome(\\"a\\") == True def test_all_same_characters(): assert can_form_palindrome(\\"aaaa\\") == True def test_even_odd_mix(): assert can_form_palindrome(\\"aabbc\\") == True def test_all_unique_characters(): assert can_form_palindrome(\\"abcde\\") == False def test_anagram_not_palindrome(): assert can_form_palindrome(\\"ababac\\") == False","solution":"def can_form_palindrome(s): Determine if a string can be rearranged to form an anagram of a palindrome. A string can be rearranged to form a palindrome if and only if at most one character has an odd count. :param s: string to check :return: True if it can be rearranged, False otherwise from collections import Counter char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return odd_count <= 1"},{"question":"from typing import List def count_distinct_paths(grid: List[List[str]]) -> int: Given a grid with dimensions MxN, each cell can either be walkable (denoted by '.') or blocked (denoted by '#'), determine the number of distinct paths from the top-left to the bottom-right corner of the grid. >>> count_distinct_paths([ ['.', '#', '.'], ['.', '.', '.'], ['#', '.', '.'] ]) 2 >>> count_distinct_paths([ ['.', '#'], ['.', '.'] ]) 1 >>> count_distinct_paths([ ['#', '#'], ['#', '.'] ]) 0 >>> count_distinct_paths([ ['.', '.'], ['.', '.'] ]) 2 >>> count_distinct_paths([ ['.'] ]) 1","solution":"def count_distinct_paths(grid): from functools import lru_cache M = len(grid) N = len(grid[0]) @lru_cache(None) def dfs(x, y): # If we hit an obstacle, return 0 if x < 0 or x >= M or y < 0 or y >= N or grid[x][y] == '#': return 0 # If we reached the bottom-right corner, return 1 if x == M-1 and y == N-1: return 1 # Explore all possible paths return dfs(x+1, y) + dfs(x, y+1) if grid[0][0] == '#' or grid[M-1][N-1] == '#': return 0 return dfs(0, 0)"},{"question":"def largest_rectangle_area(heights): Returns the largest rectangular area that can be formed by contiguous planks. >>> largest_rectangle_area([2, 1, 5, 6, 2, 3]) = 10 >>> largest_rectangle_area([1, 2, 3, 4, 5]) = 9 >>> largest_rectangle_area([2, 1, 2]) = 3 >>> largest_rectangle_area([6]) = 6 >>> largest_rectangle_area([]) = 0 import pytest def test_example_case_1(): assert largest_rectangle_area([2, 1, 5, 6, 2, 3]) == 10 def test_example_case_2(): assert largest_rectangle_area([1, 2, 3, 4, 5]) == 9 def test_example_case_3(): assert largest_rectangle_area([2, 1, 2]) == 3 def test_single_element(): assert largest_rectangle_area([6]) == 6 def test_empty_list(): assert largest_rectangle_area([]) == 0 def test_all_same_height(): assert largest_rectangle_area([2, 2, 2, 2]) == 8 def test_decreasing_heights(): assert largest_rectangle_area([5, 4, 3, 2, 1]) == 9 def test_varying_heights(): assert largest_rectangle_area([3, 2, 7, 6, 3]) == 12 def test_large_heights(): assert largest_rectangle_area([10000] * 100000) == 1000000000","solution":"def largest_rectangle_area(heights): Returns the largest rectangular area that can be formed by contiguous planks. if not heights: return 0 stack = [] max_area = 0 for i, h in enumerate(heights): while stack and heights[stack[-1]] > h: height = heights[stack.pop()] width = i if not stack else i - stack[-1] - 1 max_area = max(max_area, height * width) stack.append(i) while stack: height = heights[stack.pop()] width = len(heights) if not stack else len(heights) - stack[-1] - 1 max_area = max(max_area, height * width) return max_area"},{"question":"from typing import List, Tuple def process_queries(T: int, test_cases: List[Tuple[int, str, List[Tuple[int]]]]) -> List[str]: Process the queries on the strings as described in the problem statement. >>> process_queries(1, [(6, \\"abcdef\\", [(2, 2, 5), (1, 3, 4, 'z'), (3, 2, 5), (2, 1, 6)])]) == ['b', 'a'] >>> process_queries(1, [(5, \\"abcde\\", [(1, 2, 4, 'x'), (2, 1, 5)])]) == ['a'] >>> process_queries(1, [(5, \\"abcde\\", [(3, 2, 4), (2, 1, 5)])]) == ['a'] >>> process_queries(1, [(7, \\"abcdefg\\", [(2, 3, 5), (1, 1, 3, 'y'), (3, 4, 7), (2, 1, 7)])]) == ['c', 'd'] >>> process_queries(2, [(5, \\"aabcd\\", [(2, 1, 5), (1, 2, 4, 'z'), (2, 1, 5)]), (3, \\"xyz\\", [(3, 1, 3), (2, 1, 3)])]) == ['a', 'a', 'x']","solution":"def process_queries(T, test_cases): results = [] for test in test_cases: N, S, queries = test S = list(S) # Convert to list for mutable operations for query in queries: if query[0] == 1: # Change all characters of the substring S[L:R] to character C L, R, C = query[1], query[2], query[3] for i in range(L-1, R): S[i] = C elif query[0] == 2: # Find the lexicographically smallest character in the substring S[L:R] L, R = query[1], query[2] smallest_char = min(S[L-1:R]) results.append(smallest_char) elif query[0] == 3: # Reverse the substring S[L:R] L, R = query[1], query[2] S = S[:L-1] + S[L-1:R][::-1] + S[R:] return results"},{"question":"from typing import List, Tuple def can_arrange_dominoes(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[str]: Determine if it's possible to arrange all the domino tiles in a straight line for each test case. To achieve this, the left side of one tile must match the right side of the previous tile. >>> can_arrange_dominoes(2, [ ... (3, [(1, 2), (2, 3), (3, 4)]), ... (3, [(1, 2), (2, 3), (4, 5)]) ... ]) == [\\"YES\\", \\"NO\\"] >>> can_arrange_dominoes(1, [ ... (2, [(1, 2), (2, 3)]) ... ]) == [\\"YES\\"] >>> can_arrange_dominoes(1, [ ... (2, [(1, 2), (3, 4)]) ... ]) == [\\"NO\\"] pass","solution":"from collections import defaultdict, deque def can_arrange_dominoes(t, test_cases): def check_sequence(dominoes): if not dominoes: return False adj_list = defaultdict(list) degree = defaultdict(int) for a, b in dominoes: adj_list[a].append(b) adj_list[b].append(a) degree[a] += 1 degree[b] += 1 # Checking if the degree of all vertices is even odd_degree_count = sum(1 for v in degree.values() if v % 2 != 0) if odd_degree_count > 2: return False # BFS/DFS to check if all nodes with at least one edge are connected def is_connected(start): visited = set() queue = deque([start]) while queue: node = queue.popleft() if node not in visited: visited.add(node) for neighbor in adj_list[node]: if neighbor not in visited: queue.append(neighbor) return visited # Start BFS/DFS from any node that has edges start_node = next(iter(adj_list)) visited_nodes = is_connected(start_node) # Ensure all nodes with edges are visited total_nodes_with_edges = sum(1 for k in degree if degree[k] > 0) return len(visited_nodes) == total_nodes_with_edges results = [] for t_index in range(t): n = test_cases[t_index][0] dominoes = test_cases[t_index][1] if check_sequence(dominoes): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def allocateActivities(kidsInterests: List[Dict[str, List[str]]], activitySpots: Dict[str, int]) -> Dict[str, List[str]]: Allocate kids into various activity groups based on their interests and available spots. Args: kidsInterests (List[Dict[str, List[str]]]): An array of dictionaries where each dictionary contains the name of a kid and a list of activities they are interested in. activitySpots (Dict[str, int]): A dictionary where each key is the name of an activity and each value is the maximum number of spots available for that activity. Returns: Dict[str, List[str]]: A dictionary where the keys are activity names and the values are lists of kids who are assigned to those activities. >>> kidsInterests = [ ... {'name': 'Alice', 'activities': ['Archery', 'Painting', 'Swimming']}, ... {'name': 'Bob', 'activities': ['Painting', 'Swimming']}, ... {'name': 'Charlie', 'activities': ['Archery', 'Swimming']} ... ] >>> activitySpots = {'Archery': 1, 'Painting': 2, 'Swimming': 1} >>> allocateActivities(kidsInterests, activitySpots) {'Archery': ['Alice'], 'Painting': ['Bob'], 'Swimming': ['Charlie']}","solution":"def allocateActivities(kidsInterests, activitySpots): allocation = {activity: [] for activity in activitySpots} for kid in kidsInterests: for activity in kid['activities']: if activitySpots[activity] > 0: allocation[activity].append(kid['name']) activitySpots[activity] -= 1 break return allocation"},{"question":"def generate_bracket_combinations(n): Generate all combinations of well-formed brackets. :param n: Integer, number of pairs of brackets :return: List of strings, each string represents a valid combination of brackets >>> generate_bracket_combinations(0) [\\"\\"] >>> generate_bracket_combinations(1) [\\"()\\"] >>> generate_bracket_combinations(2) [\\"(())\\", \\"()()\\"] >>> generate_bracket_combinations(3) [\\"((()))\\", \\"(()())\\", \\"(())()\\", \\"()(())\\", \\"()()()\\"] >>> generate_bracket_combinations(4) [\\"(((())))\\", \\"((()()))\\", \\"((())())\\", \\"((()))()\\", \\"(()(()))\\", \\"(()()())\\", \\"(()())()\\", \\"(())(())\\", \\"(())()()\\", \\"()((()))\\", \\"()(()())\\", \\"()(())()\\", \\"()()(())\\", \\"()()()()\\"]","solution":"def generate_bracket_combinations(n): Generate all combinations of well-formed brackets. :param n: Integer, number of pairs of brackets :return: List of strings, each string represents a valid combination of brackets result = [] def backtrack(s='', left=0, right=0): if len(s) == 2 * n: result.append(s) return if left < n: backtrack(s + '(', left + 1, right) if right < left: backtrack(s + ')', left, right + 1) backtrack() return result"},{"question":"def fibonacci_sequence(n: int) -> List[int]: Returns the first n numbers in the Fibonacci sequence. Parameters: n (int): The number of Fibonacci numbers to generate Returns: list: A list containing the first n numbers in the Fibonacci sequence >>> fibonacci_sequence(0) [] >>> fibonacci_sequence(1) [0] >>> fibonacci_sequence(2) [0, 1] >>> fibonacci_sequence(5) [0, 1, 1, 2, 3] >>> fibonacci_sequence(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]","solution":"def fibonacci_sequence(n): Returns the first n numbers in the Fibonacci sequence. Parameters: n (int): The number of Fibonacci numbers to generate Returns: list: A list containing the first n numbers in the Fibonacci sequence if n == 0: return [] elif n == 1: return [0] sequence = [0, 1] for i in range(2, n): next_value = sequence[-1] + sequence[-2] sequence.append(next_value) return sequence"},{"question":"def rotate_string(s: str, n: int) -> str: Rotates the string s by n positions to the left. If n is negative, rotates to the right by the absolute value of n. >>> rotate_string(\\"abcdef\\", 2) \\"cdefab\\" >>> rotate_string(\\"abcdef\\", -2) \\"efabcd\\"","solution":"def rotate_string(s, n): Rotates the string s by n positions to the left. If n is negative, rotates to the right by the absolute value of n. length = len(s) if length == 0: return s n = n % length # Performing the effective rotation return s[n:] + s[:n]"},{"question":"def road_trip_playlist(max_length: int, songs: List[dict]) -> List[str]: Generate a playlist with a total duration not exceeding max_length. Each song object is formatted as follows: {'artist': 'Artist', 'title': 'Title String', 'duration': '3:45'} Parameters: max_length (int): The maximum allowed length of the playlist in minutes. songs (list): A list of dictionaries, each containing 'artist', 'title', and 'duration' keys. Returns: list: A list of song titles that fit within the given max_length. >>> road_trip_playlist(5, [{'artist': 'Artist1', 'title': 'Song1', 'duration': '3:45'}]) ['Song1'] >>> road_trip_playlist(5, [ {'artist': 'Artist1', 'title': 'Song1', 'duration': '3:00'}, {'artist': 'Artist2', 'title': 'Song2', 'duration': '2:00'}]) ['Song1', 'Song2'] >>> road_trip_playlist(5, [ {'artist': 'Artist1', 'title': 'Song1', 'duration': '3:00'}, {'artist': 'Artist2', 'title': 'Song2', 'duration': '4:00'}]) ['Song1'] >>> road_trip_playlist(5, [{'artist': 'Artist1', 'title': 'Song1', 'duration': '6:00'}]) [] >>> road_trip_playlist(4, [ {'artist': 'Artist1', 'title': 'Song1', 'duration': '2:30'}, {'artist': 'Artist2', 'title': 'Song2', 'duration': '3:00'}]) ['Song1']","solution":"def road_trip_playlist(max_length, songs): Generate a playlist with a total duration not exceeding max_length. Parameters: max_length (int): The maximum allowed length of the playlist in minutes. songs (list): A list of dictionaries, each containing 'artist', 'title', and 'duration' keys. Returns: list: A list of song titles that fit within the given max_length. def duration_in_seconds(duration): minutes, seconds = map(int, duration.split(':')) return minutes * 60 + seconds max_length_seconds = max_length * 60 result = [] current_duration = 0 for song in songs: song_duration = duration_in_seconds(song['duration']) if current_duration + song_duration <= max_length_seconds: result.append(song['title']) current_duration += song_duration return result"},{"question":"def can_form_palindrome(s: str) -> bool: Determines if the characters in the string can be rearranged to form a palindrome. A string can be rearranged to form a palindrome if at most one character has an odd count. Args: s (str): The string to check. Returns: bool: True if the string can be rearranged to form a palindrome, False otherwise. >>> can_form_palindrome(\\"civic\\") True >>> can_form_palindrome(\\"ivicc\\") True >>> can_form_palindrome(\\"hello\\") False pass def palindrome_permutations(t: int, cases: list[str]) -> list[str]: Checks multiple strings to determine if they can be rearranged to form palindromes. Args: t (int): The number of test cases. cases (list[str]): The list of strings to check. Returns: list[str]: A list of \\"yes\\" or \\"no\\" indicating whether each string can be rearranged to form a palindrome. >>> palindrome_permutations(3, [\\"civic\\", \\"ivicc\\", \\"hello\\"]) [\\"yes\\", \\"yes\\", \\"no\\"] >>> palindrome_permutations(3, [\\"aabbcc\\", \\"aabbccc\\", \\"aabbcccd\\"]) [\\"yes\\", \\"yes\\", \\"no\\"] >>> palindrome_permutations(2, [\\"aaabbccdd\\", \\"eeffgghhii\\"]) [\\"yes\\", \\"yes\\"] >>> palindrome_permutations(1, [\\"\\"]) [\\"yes\\"] pass","solution":"def can_form_palindrome(s): Determines if the characters in the string can be rearranged to form a palindrome. A string can be rearranged to form a palindrome if at most one character has an odd count. from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # Count how many characters have an odd frequency odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can form a palindrome if it has at most one character with an odd frequency return odd_count <= 1 def palindrome_permutations(t, cases): results = [] for s in cases: if can_form_palindrome(s): results.append(\\"yes\\") else: results.append(\\"no\\") return results"},{"question":"import re from typing import List def findLongestWord(sentence: str) -> str: Returns the longest word in the sentence. If there are two or more words of the same length, the first one that appears in the sentence is returned. If the sentence is empty, returns an empty string. >>> findLongestWord(\\"The quick brown fox\\") == \\"quick\\" >>> findLongestWord(\\"I am very very thrilled\\") == \\"thrilled\\" >>> findLongestWord(\\"Hello! The quick, brown fox; jumps over the lazy dog.\\") == \\"Hello\\" >>> findLongestWord(\\"This is a test. Yes, a test.\\") == \\"This\\" >>> findLongestWord(\\"\\") == \\"\\" >>> findLongestWord(\\"Longevity\\") == \\"Longevity\\" >>> findLongestWord(\\"Cat hat bat mat\\") == \\"Cat\\"","solution":"import re def findLongestWord(sentence): Returns the longest word in the sentence. If there are two or more words of the same length, the first one that appears in the sentence is returned. If the sentence is empty, returns an empty string. # Remove punctuation and split the sentence into words words = re.findall(r'bw+b', sentence) # Find the longest word if not words: return \\"\\" longest_word = max(words, key=len) return longest_word"},{"question":"def closest_to_zero(arr: List[int]) -> int: Returns the number closest to zero in the array. If two numbers are equally close to zero, the positive one is considered closer. >>> closest_to_zero([7, -10, 13, 8, -4, 0, 6]) 0 >>> closest_to_zero([7, -10, 13, 8, -4, -1, 1]) 1 >>> closest_to_zero([7, 3, 13, 8, 4, 6]) 3 >>> closest_to_zero([-7, -3, -13, -8, -4, -6]) -3 >>> closest_to_zero([5]) 5 >>> closest_to_zero([-5]) -5 >>> closest_to_zero([-2, 2, -1, 1]) 1 >>> closest_to_zero([]) ValueError: Array must not be empty","solution":"def closest_to_zero(arr): Returns the number closest to zero in the array. If two numbers are equally close to zero, the positive one is considered closer. if not arr: raise ValueError(\\"Array must not be empty\\") closest = float('inf') for num in arr: if abs(num) < abs(closest) or (abs(num) == abs(closest) and num > closest): closest = num return closest"},{"question":"def can_form_bst(n: int, array: List[int]) -> Tuple[str, List[int]]: Determines if the given array can be reordered to form a binary search tree. Returns \\"YES\\" and one possible permutation if it can, otherwise \\"NO\\". >>> can_form_bst(3, [2, 1, 3]) ('YES', [1, 2, 3]) >>> can_form_bst(4, [8, 5, 7, 4]) ('NO', []) >>>","solution":"def can_form_bst(n, array): Determines if the given array can be reordered to form a binary search tree. Returns \\"YES\\" and one possible permutation if it can, otherwise \\"NO\\". if n == 1: return (\\"YES\\", array) # A single node can always form a BST sorted_array = sorted(array) return (\\"YES\\", sorted_array) # Example usage: # n = 3 # array = [2, 1, 3] # result = can_form_bst(n, array) # print(result)"},{"question":"def flatten_nested_list(nested_list): Flattens a nested list of integers. Args: nested_list (list): A list that can contain other lists, which may be nested arbitrarily. Returns: list: A flattened version of the input list. Examples: >>> flatten_nested_list([1, [2, 3], [4, [5, 6]], 7, [[]], [8, [9, [10]]]]) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] >>> flatten_nested_list([]) [] >>> flatten_nested_list([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> flatten_nested_list([1, [2], 3, [4, 5]]) [1, 2, 3, 4, 5] >>> flatten_nested_list([1, [2, [3, 4]], 5]) [1, 2, 3, 4, 5] >>> flatten_nested_list([[1], [[2]], [[[3]]]]) [1, 2, 3] >>> flatten_nested_list([[], [1, [], [2, [], [3]], []], [], [4], 5, []]) [1, 2, 3, 4, 5] # Your code goes here","solution":"def flatten_nested_list(nested_list): Flattens a nested list of integers. Args: nested_list (list): A list that can contain other lists, which may be nested arbitrarily. Returns: list: A flattened version of the input list. result = [] for item in nested_list: if isinstance(item, list): result.extend(flatten_nested_list(item)) else: result.append(item) return result"},{"question":"import math from typing import List def can_win(number: int) -> str: Determine if a number has a non-trivial divisor. >>> can_win(6) 'WIN' >>> can_win(13) 'LOSE' >>> can_win(25) 'WIN' def dividing_game(T: int, numbers: List[int]) -> List[str]: For each number in the list, determine if there is a non-trivial divisor. >>> dividing_game(3, [6, 13, 25]) ['WIN', 'LOSE', 'WIN'] >>> dividing_game(2, [2, 5]) ['LOSE', 'LOSE']","solution":"import math def can_win(number): if number <= 2: return \\"LOSE\\" for i in range(2, int(math.sqrt(number)) + 1): if number % i == 0: return \\"WIN\\" return \\"LOSE\\" def dividing_game(T, numbers): results = [] for num in numbers: results.append(can_win(num)) return results"},{"question":"def check_years_covered(books: List[str], years: List[int]) -> str: This function checks if all provided years are covered in the list of books. >>> check_years_covered([\\"Moby Dick - 1851\\", \\"To Kill a Mockingbird - 1960\\", \\"1984 - 1949\\", \\"Catcher in the Rye - 1951\\"], [1949, 1951, 1960]) \\"All years covered\\" >>> check_years_covered([\\"War and Peace - 1869\\", \\"Les Misérables - 1862\\", \\"Catch-22 - 1961\\"], [1862, 1869, 1961, 1925]) \\"Missing years\\"","solution":"def check_years_covered(books, years): This function checks if all provided years are covered in the list of books. :param books: List of books with titles and years in the format \\"Title - Year\\". :param years: List of years to check for coverage. :return: \\"All years covered\\" if all years are covered by the books, otherwise \\"Missing years\\". years_covered = set() for book in books: title, year = book.rsplit(\\" - \\", 1) years_covered.add(int(year)) for year in years: if year not in years_covered: return \\"Missing years\\" return \\"All years covered\\""},{"question":"def reverse_words(sentence: str) -> str: This function takes a string which represents a sentence and returns a new string with each word reversed but the word order intact, maintaining the initial capitalization position for each character after reversing the words. >>> reverse_words(\\"Hello World\\") == \\"olleH dlroW\\" >>> reverse_words(\\"Python Programming\\") == \\"nohtyP gnimmargorP\\"","solution":"def reverse_word(word): This helper function takes a single word and returns the word reversed. It maintains the initial capitalization position for each character after reversing the word. n = len(word) new_word = [''] * n for i, ch in enumerate(word): if ch.isupper(): new_word[n-1-i] = ch.lower() else: new_word[n-1-i] = ch.upper() return ''.join(new_word).swapcase() # swapcase is to fix all characters back to original case def reverse_words(sentence): This function takes a string sentence and returns a new string with each word reversed but the word order intact, preserving their respective capitalizations. words = sentence.strip().split() reversed_words = [reverse_word(word) for word in words] return ' '.join(reversed_words)"},{"question":"def cherryPickup(grid: List[List[int]]) -> int: Compute the maximum number of cherries two robots can collect in a grid. >>> cherryPickup([[3,1,1], [2,5,1], [1,5,5], [2,1,1]]) == 24 >>> cherryPickup([[1,0,0,0,0,0,1], [2,0,0,0,0,3,0], [2,0,9,0,0,0,0], [0,3,0,5,4,0,0], [1,0,2,3,0,0,6]]) == 28 >>> cherryPickup([[0,1], [1,0]]) == 2 >>> cherryPickup([[100]*70 for _ in range(70)]) == 2 * sum(row[0] for row in grid) >>> cherryPickup([[0]*5 for _ in range(5)]) == 0","solution":"def cherryPickup(grid): m, n = len(grid), len(grid[0]) dp = [[[0] * n for _ in range(n)] for _ in range(m)] dp[0][0][n-1] = grid[0][0] + (grid[0][n-1] if n > 1 else 0) for r in range(1, m): for c1 in range(min(r+1, n)): for c2 in range(max(0, n-1-r), n): max_cherries = 0 for dc1 in [-1, 0, 1]: for dc2 in [-1, 0, 1]: prev_c1, prev_c2 = c1 + dc1, c2 + dc2 if 0 <= prev_c1 < n and 0 <= prev_c2 < n: max_cherries = max(max_cherries, dp[r-1][prev_c1][prev_c2]) dp[r][c1][c2] = max_cherries + grid[r][c1] + (0 if c1 == c2 else grid[r][c2]) return max(dp[m-1][c1][c2] for c1 in range(n) for c2 in range(n))"},{"question":"def intervalIntersection(a: List[List[int]], b: List[List[int]]) -> List[List[int]]: Find the intersection of two sets of intervals. >>> intervalIntersection([[1, 3], [5, 9]], [[2, 4], [6, 8]]) [[2, 3], [6, 8]] >>> intervalIntersection([[0, 2], [5, 10]], [[1, 5], [8, 12]]) [[1, 2], [5, 5], [8, 10]]","solution":"def intervalIntersection(a, b): Find the intersection of two sets of intervals. :param a: List of intervals [start, end] :param b: List of intervals [start, end] :return: List of intersecting intervals sorted in ascending order i, j = 0, 0 result = [] while i < len(a) and j < len(b): start_a, end_a = a[i] start_b, end_b = b[j] if start_a <= end_b and start_b <= end_a: start_max = max(start_a, start_b) end_min = min(end_a, end_b) result.append([start_max, end_min]) if end_a < end_b: i += 1 else: j += 1 return result"},{"question":"def canBeSplit(nums: List[int]) -> bool: Determines if the array can be split into two subarrays such that the sum of the elements in both subarrays is the same. >>> canBeSplit([1, 5, 11, 5]) True >>> canBeSplit([1, 2, 3, 5]) False >>> canBeSplit([1]) False >>> canBeSplit([5, 5]) True >>> canBeSplit([100, 200, 300, 400, 500, 1000]) False >>> canBeSplit([1, 1, 1, 1]) True >>> canBeSplit([1, 1, 1]) False","solution":"def canBeSplit(nums): Determines if the array can be split into two subarrays such that the sum of the elements in both subarrays is the same. total_sum = sum(nums) # If the total sum is odd, it is not possible to split into two equal sum subarrays if total_sum % 2 != 0: return False target = total_sum // 2 n = len(nums) # Create a DP array to keep track of possible sums dp = [False] * (target + 1) dp[0] = True # There is always a way to get sum 0: with an empty subset for num in nums: for i in range(target, num - 1, -1): dp[i] = dp[i] or dp[i - num] return dp[target]"},{"question":"def two_sum(nums: List[int], target: int) -> bool: Write a function that takes a list of integers and a target integer. The function should return a boolean value indicating whether any two distinct integers in the list sum up to the target integer. If the input list is empty or has only one integer, the function should return \`False\`. >>> two_sum([1, 2, 3, 4, 5], 9) == True >>> two_sum([1, 2], 4) == False >>> two_sum([], 1) == False >>> two_sum([1], 1) == False >>> two_sum([0, 4, 3, 0], 0) == True >>> two_sum([5, -2, -1, -3, 3], 0) == True >>> two_sum([2, 7, 11, 15], 18) == True >>> two_sum([1, 2, 3, 4, 5, 6], 15) == False","solution":"def two_sum(nums, target): Returns True if any two distinct integers in the list sum up to the target, otherwise False. Parameters: nums (list): A list of integers. target (int): The target integer. Returns: bool: True if any two distinct integers sum up to the target, otherwise False. if len(nums) < 2: return False seen = set() for num in nums: if target - num in seen: return True seen.add(num) return False"},{"question":"def merge_sorted_arrays(arr1: List[int], arr2: List[int]) -> List[int]: Merges two sorted arrays into a single sorted array. Parameters: arr1 (list of int): First sorted array. arr2 (list of int): Second sorted array. Returns: list of int: Merged and sorted array. >>> merge_sorted_arrays([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_arrays([0, 2, 4], [1, 5, 7]) [0, 1, 2, 4, 5, 7] >>> merge_sorted_arrays([], [1, 3, 5]) [1, 3, 5] >>> merge_sorted_arrays([2, 2, 2], []) [2, 2, 2]","solution":"def merge_sorted_arrays(arr1, arr2): Merges two sorted arrays into a single sorted array. Parameters: arr1 (list of int): First sorted array. arr2 (list of int): Second sorted array. Returns: list of int: Merged and sorted array. merged = [] i = j = 0 while i < len(arr1) and j < len(arr2): if arr1[i] < arr2[j]: merged.append(arr1[i]) i += 1 else: merged.append(arr2[j]) j += 1 # Append remaining elements of arr1, if any while i < len(arr1): merged.append(arr1[i]) i += 1 # Append remaining elements of arr2, if any while j < len(arr2): merged.append(arr2[j]) j += 1 return merged"},{"question":"def separate_even_odd(lst: List[int]) -> List[int]: Implement a function that takes in a list of integers and returns a new list with the elements sorted in ascending order, but with all the even numbers appearing before the odd numbers in the original relative order. >>> separate_even_odd([7, 2, 5, 3, 6, 4, 9]) == [2, 6, 4, 7, 5, 3, 9] >>> separate_even_odd([1, 4, 6, 9, 3]) == [4, 6, 1, 9, 3] >>> separate_even_odd([8, 12, 4, 9, 15, 3, 2]) == [8, 12, 4, 2, 9, 15, 3] pass from solution import separate_even_odd def test_separate_even_odd_empty_list(): assert separate_even_odd([]) == [] def test_separate_even_odd_single_element(): assert separate_even_odd([1]) == [1] assert separate_even_odd([2]) == [2] def test_separate_even_odd_all_evens(): assert separate_even_odd([2, 4, 6]) == [2, 4, 6] def test_separate_even_odd_all_odds(): assert separate_even_odd([1, 3, 5]) == [1, 3, 5] def test_separate_even_odd_mixed(): assert separate_even_odd([7, 2, 5, 3, 6, 4, 9]) == [2, 6, 4, 7, 5, 3, 9] assert separate_even_odd([1, 4, 6, 9, 3]) == [4, 6, 1, 9, 3] assert separate_even_odd([8, 12, 4, 9, 15, 3, 2]) == [8, 12, 4, 2, 9, 15, 3] def test_separate_even_odd_order_preservation(): assert separate_even_odd([10, 1, 5, 4, 2, 9, 0]) == [10, 4, 2, 0, 1, 5, 9]","solution":"def separate_even_odd(lst): Returns a new list with the elements sorted in ascending order, but with all the even numbers appearing before the odd numbers in their original relative order. evens = [x for x in lst if x % 2 == 0] odds = [x for x in lst if x % 2 != 0] return evens + odds"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def constructMaximumBinaryTree(nums): Constructs the maximum binary tree from the given list of integers. Parameters: nums (list): List of unique integers. Returns: TreeNode: The root node of the constructed maximum binary tree. pass def tree_to_list(root): Converts binary tree to list level by level. Parameters: root (TreeNode): The root node of the binary tree. Returns: list: List representation of the binary tree. pass import pytest from solution import TreeNode, constructMaximumBinaryTree, tree_to_list def test_constructMaximumBinaryTree_case1(): nums = [3,2,1,6,0,5] root = constructMaximumBinaryTree(nums) expected_output = [6,3,5,None,2,0,None,None,1] assert tree_to_list(root) == expected_output def test_constructMaximumBinaryTree_case2(): nums = [3,2,1] root = constructMaximumBinaryTree(nums) expected_output = [3,None,2,None,1] assert tree_to_list(root) == expected_output def test_constructMaximumBinaryTree_single_element(): nums = [1] root = constructMaximumBinaryTree(nums) expected_output = [1] assert tree_to_list(root) == expected_output def test_constructMaximumBinaryTree_descending_order(): nums = [5,4,3,2,1] root = constructMaximumBinaryTree(nums) expected_output = [5,None,4,None,3,None,2,None,1] assert tree_to_list(root) == expected_output def test_constructMaximumBinaryTree_empty(): nums = [] root = constructMaximumBinaryTree(nums) expected_output = [] assert tree_to_list(root) == expected_output","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def constructMaximumBinaryTree(nums): Constructs the maximum binary tree from the given list of integers. Parameters: nums (list): List of unique integers. Returns: TreeNode: The root node of the constructed maximum binary tree. if not nums: return None max_value = max(nums) max_index = nums.index(max_value) root = TreeNode(val=max_value) root.left = constructMaximumBinaryTree(nums[:max_index]) root.right = constructMaximumBinaryTree(nums[max_index + 1:]) return root def tree_to_list(root): Converts binary tree to list level by level. Parameters: root (TreeNode): The root node of the binary tree. Returns: list: List representation of the binary tree. if not root: return [] result = [] queue = [root] while queue: node = queue.pop(0) if node: result.append(node.val) queue.append(node.left) queue.append(node.right) else: result.append(None) # Remove trailing None values while result and result[-1] is None: result.pop() return result"},{"question":"from typing import List, Union def find_majority_element(nums: List[int]) -> Union[int, str]: Returns the majority element in the list if it exists, otherwise returns \\"No Majority Element\\". A majority element is an element that appears more than n/2 times in the list, where n is the length of the list. >>> find_majority_element([3, 3, 4, 2, 4, 4, 2, 4, 4]) 4 >>> find_majority_element([3, 3, 4, 2, 4, 2, 2]) \\"No Majority Element\\" >>> find_majority_element([1, 1, 1, 2, 2]) 1 >>> find_majority_element([2, 1, 1, 1, 1]) 1 >>> find_majority_element([2, 2, 2, 2, 2]) 2 >>> find_majority_element([]) \\"No Majority Element\\" >>> find_majority_element([1]) 1","solution":"from typing import List, Union def find_majority_element(nums: List[int]) -> Union[int, str]: Returns the majority element in the list if it exists, otherwise returns \\"No Majority Element\\". A majority element is an element that appears more than n/2 times in the list, where n is the length of the list. count = {} n = len(nums) for num in nums: if num in count: count[num] += 1 else: count[num] = 1 if count[num] > n // 2: return num return \\"No Majority Element\\""},{"question":"def most_significant_friend(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the most significant friend based on the given criteria. >>> most_significant_friend(2, [(3, [123, 456, 789]), (4, [10, 23, 34, 45])]) == [789, 45] from solution import most_significant_friend def test_single_digit_sum(): T = 1 test_cases = [(3, [2, 4, 3])] assert most_significant_friend(T, test_cases) == [4] def test_multiple_same_digit_sum(): T = 2 test_cases = [ (3, [123, 456, 789]), (4, [10, 23, 34, 45]) ] assert most_significant_friend(T, test_cases) == [789, 45] def test_edge_case_min_max_number(): T = 1 test_cases = [(2, [1, 1000000])] assert most_significant_friend(T, test_cases) == [1] def test_large_tests(): T = 1 large_list = list(range(1, 1001)) test_cases = [(1000, large_list)] assert most_significant_friend(T, test_cases) == [999] def test_large_digit_sum_tie(): T = 1 test_cases = [(3, [59, 95, 14])] assert most_significant_friend(T, test_cases) == [59]","solution":"def most_significant_friend(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] friends_numbers = test_cases[i][1] def digit_sum(number): return sum(int(digit) for digit in str(number)) most_significant = min(friends_numbers, key=lambda x: (-digit_sum(x), x)) results.append(most_significant) return results # Example usage: # T = 2 # test_cases = [ # (3, [123, 456, 789]), # (4, [10, 23, 34, 45]) # ] # print(most_significant_friend(T, test_cases)) # Output: [789, 45]"},{"question":"def extractNthChar(s: str, N: int) -> str: Returns a string consisting of every Nth character from the given string s. >>> extractNthChar(\\"abcdefghijk\\", 3) \\"cfi\\" >>> extractNthChar(\\"abcdefghijk\\", 1) \\"abcdefghijk\\" >>> extractNthChar(\\"abcdefghijk\\", 20) \\"\\" >>> extractNthChar(\\"\\", 3) \\"\\" >>> extractNthChar(\\"abcdef\\", 2) \\"bdf\\" >>> extractNthChar(\\"abcdef\\", 4) \\"d\\" >>> extractNthChar(\\"a\\"*1000, 100) \\"a\\"*10","solution":"def extractNthChar(s, N): Returns a string consisting of every Nth character from the given string s. Parameters: s (str): The original string. N (int): The interval for selecting characters. Returns: str: A new string consisting of every Nth character from s. return s[N-1::N]"},{"question":"def find_primes(start: int, end: int) -> list: Write a function that takes two integers, \`start\` and \`end\`, and returns a list of all prime numbers between \`start\` and \`end\` (inclusive). The function should ensure that both endpoints are included if they are prime. If no prime numbers exist in the range, return an empty list. >>> find_primes(10, 30) [11, 13, 17, 19, 23, 29] >>> find_primes(14, 16) [] from solution import find_primes def test_primes_in_range(): assert find_primes(10, 30) == [11, 13, 17, 19, 23, 29] def test_no_primes(): assert find_primes(14, 16) == [] assert find_primes(0, 1) == [] assert find_primes(4, 4) == [] def test_single_prime_range(): assert find_primes(2, 2) == [2] assert find_primes(13, 13) == [13] def test_primes_in_small_range(): assert find_primes(29, 31) == [29, 31] assert find_primes(1, 10) == [2, 3, 5, 7] def test_primes_in_large_range(): assert find_primes(50, 100) == [53, 59, 61, 67, 71, 73, 79, 83, 89, 97]","solution":"def is_prime(number): Helper function to check if a number is prime. if number <= 1: return False for i in range(2, int(number**0.5) + 1): if number % i == 0: return False return True def find_primes(start, end): Returns a list of all prime numbers between start and end (inclusive). primes = [] for num in range(start, end + 1): if is_prime(num): primes.append(num) return primes"},{"question":"def filter_emails(emails: List[str], domain: str) -> List[str]: Filters and formats email addresses based on a specified domain. Parameters: emails (list of str): The list of email addresses. domain (str): The domain to filter by. Returns: list of str: The filtered and formatted list of email addresses. >>> filter_emails([\\"John.Doe@example.com\\", \\"Jane.Smith@test.com\\", \\"foo@bar.com\\"], \\"example.com\\") [\\"john.doe@example.com\\"] >>> filter_emails([\\"Alice@example.com\\", \\"bob@Example.com\\", \\"charlie@test.com\\"], \\"example.com\\") [\\"alice@example.com\\", \\"bob@example.com\\"] >>> filter_emails([\\"Foo@bar.com\\", \\"Bar@foo.com\\"], \\"baz.com\\") []","solution":"def filter_emails(emails, domain): Filters and formats email addresses based on a specified domain. Parameters: emails (list of str): The list of email addresses. domain (str): The domain to filter by. Returns: list of str: The filtered and formatted list of email addresses. domain = domain.lower() filtered_emails = [email.lower() for email in emails if email.split('@')[1].lower() == domain] return filtered_emails"},{"question":"from typing import List def permutations(s: str) -> List[str]: Returns all permutations of the input string s in lexicographical order. Parameters: s (str): The input string containing unique characters. Returns: List[str]: List of permutations in lexicographical order or an empty list for empty input. Examples: >>> permutations(\\"abc\\") [\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"] >>> permutations(\\"123\\") [\\"123\\", \\"132\\", \\"213\\", \\"231\\", \\"312\\", \\"321\\"] >>> permutations(\\"\\") [] >>> permutations(\\"a1\\") [\\"1a\\", \\"a1\\"] >>> permutations(\\"aA\\") [\\"Aa\\", \\"aA\\"]","solution":"import itertools def permutations(s): Returns all permutations of the input string s in lexicographical order. Parameters: s (str): The input string containing unique characters. Returns: List[str]: List of permutations in lexicographical order or an empty list for empty input. if not s: return [] perm_list = sorted(''.join(p) for p in itertools.permutations(s)) return perm_list"},{"question":"def is_back_to_origin(instructions: str) -> str: Returns 'YES' if the sequence of instructions brings the vacuum cleaner back to (0, 0), otherwise returns 'NO'. >>> is_back_to_origin(\\"LR\\") 'YES' >>> is_back_to_origin(\\"UD\\") 'YES' >>> is_back_to_origin(\\"LLRR\\") 'YES' >>> is_back_to_origin(\\"UUDD\\") 'YES' pass def process_test_cases(test_cases: List[str]) -> List[str]: Processes multiple test cases and returns a list of results for each test case. >>> process_test_cases([\\"LR\\", \\"UD\\", \\"LLRR\\", \\"UUDD\\", \\"L\\", \\"UU\\"]) ['YES', 'YES', 'YES', 'YES', 'NO', 'NO'] pass","solution":"def is_back_to_origin(instructions): Returns 'YES' if the sequence of instructions brings the vacuum cleaner back to (0, 0), otherwise returns 'NO'. x, y = 0, 0 for char in instructions: if char == 'L': x -= 1 elif char == 'R': x += 1 elif char == 'U': y += 1 elif char == 'D': y -= 1 return 'YES' if x == 0 and y == 0 else 'NO' def process_test_cases(test_cases): return [is_back_to_origin(instructions) for instructions in test_cases]"},{"question":"def reverse_words(s: str) -> str: Reverse the words in a given string while preserving the original spacing. Parameters: s (str): The input string Returns: str: A new string with the words in reverse order Examples: >>> reverse_words(\\"Hello world!\\") \\"world! Hello\\" >>> reverse_words(\\"the sky is blue\\") \\"blue is sky the\\" >>> reverse_words(\\" moon the to me fly \\") \\"fly me to the moon\\" >>> reverse_words(\\"word\\") \\"word\\"","solution":"def reverse_words(s): Reverse the words in a given string while preserving the original spacing. Parameters: s (str): The input string Returns: str: A new string with the words in reverse order # Split the input string by spaces words = s.split() # Reverse the list of words reversed_words = words[::-1] # Join the reversed words with a single space between each word reversed_string = ' '.join(reversed_words) return reversed_string"},{"question":"def form_cycle(N: int, lengths: List[int]) -> Union[List[Tuple[int, int]], int]: Determines if it is possible to form a cycle using given segment lengths. If possible, outputs the connections as (x, y) pairs. If not possible, returns -1. Parameters: N (int): Number of segments lengths (list): List of segment lengths Returns: list/str: List of tuples representing connections or -1 if not possible to form a cycle Examples: >>> form_cycle(5, [1, 2, 3, 4, 5]) [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)] >>> form_cycle(3, [1, 2, 3]) [(1, 2), (2, 3), (3, 1)] >>> form_cycle(2, [1, 2]) -1","solution":"def form_cycle(N, lengths): Determines if it is possible to form a cycle using given segment lengths. If possible, outputs the connections as (x, y) pairs. If not possible, returns -1. Parameters: N (int): Number of segments lengths (list): List of segment lengths Returns: list/str: List of tuples representing connections or -1 if not possible to form a cycle if N < 3: return -1 connections = [(i + 1, (i + 1) % N + 1) for i in range(N)] return connections"},{"question":"import re from collections import Counter def are_anagrams(word1: str, word2: str) -> str: Determine if word1 and word2 are anagrams of each other. >>> are_anagrams(\\"listen\\", \\"silent\\") \\"YES\\" >>> are_anagrams(\\"Hello\\", \\"olleh\\") \\"YES\\" >>> are_anagrams(\\"anagram\\", \\"Margana\\") \\"YES\\" >>> are_anagrams(\\"example\\", \\"ampere\\") \\"NO\\" >>> are_anagrams(\\"a.b!c\\", \\"cba\\") \\"YES\\" >>> are_anagrams(\\"123\\", \\"321\\") \\"YES\\" >>> are_anagrams(\\"apple!@#\\", \\"!@@#PpALE\\") \\"YES\\" >>> are_anagrams(\\"he_llo\\", \\"0llE_h\\") \\"NO\\" >>> are_anagrams(\\"kitten!\\", \\"en!ttik!\\") \\"YES\\" >>> are_anagrams(\\"Listen\\", \\"Silent\\") \\"YES\\" >>> are_anagrams(\\"Hello\\", \\"Olelh\\") \\"YES\\" >>> are_anagrams(\\"dog\\", \\"God\\") \\"YES\\"","solution":"import re from collections import Counter def are_anagrams(word1, word2): Determine if word1 and word2 are anagrams of each other. :param word1: First word input :param word2: Second word input :return: \\"YES\\" if word1 and word2 are anagrams, \\"NO\\" otherwise # Remove all non-alphanumeric characters and convert to lower case word1_cleaned = re.sub(r'[^A-Za-z0-9]', '', word1).lower() word2_cleaned = re.sub(r'[^A-Za-z0-9]', '', word2).lower() # Use Counter to count occurrences of each character return \\"YES\\" if Counter(word1_cleaned) == Counter(word2_cleaned) else \\"NO\\""},{"question":"def is_prime(n: int) -> bool: Check if a number is prime. pass def is_palindrome(n: int) -> bool: Check if a number is a palindrome. pass def next_prime_palindrome(n: int) -> int: Write a function that takes an integer as input and returns the next prime palindrome greater than the given integer. >>> next_prime_palindrome(31) == 101 >>> next_prime_palindrome(101) == 131 >>> next_prime_palindrome(131) == 151 >>> next_prime_palindrome(151) == 181 >>> next_prime_palindrome(181) == 191 pass","solution":"def is_prime(n): if n < 2: return False if n in (2, 3): return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def is_palindrome(n): return str(n) == str(n)[::-1] def next_prime_palindrome(n): n += 1 while not (is_prime(n) and is_palindrome(n)): n += 1 return n"},{"question":"def thue_morse_character(n): Returns the n-th (one-indexed) character of the Thue-Morse sequence. If \`n\` is invalid (e.g., 0 or below, or non-integer), return 'NaN'. >>> thue_morse_character(1) '0' >>> thue_morse_character(4) '0' >>> thue_morse_character(7) '1' >>> thue_morse_character(0) 'NaN' >>> thue_morse_character('abc') 'NaN'","solution":"def thue_morse_character(n): Returns the n-th (one-indexed) character of the Thue-Morse sequence. if not isinstance(n, int) or n <= 0: return 'NaN' # Convert to zero-indexed n -= 1 count = 0 while n > 0: count += n & 1 n >>= 1 return '1' if count % 2 == 1 else '0'"},{"question":"from typing import List def protect_pigs(farm: List[List[str]]) -> int: Returns the number of pigs that are protected from being caught by wolves. >>> farm = [ ... ['W', 'P', 'P', 'P'], ... ['P', 'W', 'P', 'P'], ... ['P', 'P', 'W', 'P'], ... ['P', 'P', 'P', 'W'] ... ] >>> protect_pigs(farm) 6 >>> farm = [ ... ['W', 'P'], ... ['P', 'W'] ... ] >>> protect_pigs(farm) 0 >>> farm = [ ... ['P', 'P'], ... ['P', 'P'] ... ] >>> protect_pigs(farm) 4 >>> farm = [ ... ['W', 'W'], ... ['W', 'W'] ... ] >>> protect_pigs(farm) 0 >>> farm = [ ... ['P', 'W', 'P', 'W', 'P'], ... ['W', 'P', 'W', 'P', 'W'], ... ['P', 'W', 'P', 'W', 'P'] ... ] >>> protect_pigs(farm) 0 >>> farm = [ ... ['P', 'P', 'P'], ... ['P', 'P', 'P'], ... ['P', 'P', 'P'] ... ] >>> protect_pigs(farm) 9","solution":"def protect_pigs(farm): Returns the number of pigs that are protected from being caught by wolves. rows = len(farm) cols = len(farm[0]) protected_count = 0 def is_protected(x, y): # Check all 4 directions for adjacent wolf directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and farm[nx][ny] == 'W': return False return True for i in range(rows): for j in range(cols): if farm[i][j] == 'P' and is_protected(i, j): protected_count += 1 return protected_count"},{"question":"from typing import List, Tuple def min_intervals(tasks: List[Tuple[int, int]]) -> int: Calculate the minimum number of non-overlapping time intervals required to complete all tasks. >>> min_intervals([(1, 3), (2, 5), (6, 9), (8, 10)]) 2 >>> min_intervals([(1, 2), (3, 4), (5, 6)]) 3 >>> min_intervals([(1, 4), (2, 5), (3, 6)]) 1 >>> min_intervals([(1, 3), (2, 4), (4, 6)]) 2 >>> min_intervals([(1, 5)]) 1 >>> min_intervals([]) 0","solution":"from typing import List, Tuple def min_intervals(tasks: List[Tuple[int, int]]) -> int: if not tasks: return 0 # Sort tasks by ending time tasks.sort(key=lambda x: x[1]) count = 1 end_time = tasks[0][1] for i in range(1, len(tasks)): if tasks[i][0] >= end_time: count += 1 end_time = tasks[i][1] return count"},{"question":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def hasCycle(head: ListNode) -> bool: Determine if a linked list has a cycle in it. >>> head = ListNode(3) >>> second = ListNode(2) >>> third = ListNode(0) >>> fourth = ListNode(-4) >>> head.next = second >>> second.next = third >>> third.next = fourth >>> fourth.next = second # Cycle here >>> hasCycle(head) True >>> head = ListNode(1) >>> second = ListNode(2) >>> head.next = second >>> second.next = head # Cycle here >>> hasCycle(head) True >>> head = ListNode(1) >>> hasCycle(head) False","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def hasCycle(head): tortoise, hare = head, head while hare is not None and hare.next is not None: tortoise = tortoise.next hare = hare.next.next if tortoise == hare: return True return False"},{"question":"from typing import List def shortest_path(map: List[List[str]]) -> int: Returns the shortest distance from the top-left corner to the bottom-right corner. If there is no valid path, return -1. >>> shortest_path([ ['0', '0', '1', '0'], ['0', '1', '0', '0'], ['0', '0', '0', '1'], ['1', '0', '0', '0'] ]) 7 >>> shortest_path([ ['0', '1', '1', '0'], ['1', '1', '0', '1'], ['0', '1', '1', '1'], ['1', '0', '1', '0'] ]) -1 >>> shortest_path([['0', '0', '0', '0']]) 4 >>> shortest_path([['0'], ['0'], ['0'], ['0']]) 4 >>> shortest_path([ ['0', '0', '1', '0', '0'], ['0', '1', '1', '0', '1'], ['0', '0', '0', '0', '0'], ['1', '1', '1', '1', '0'], ['0', '0', '0', '0', '0'] ]) 9 >>> shortest_path([['0']]) 1 pass","solution":"from collections import deque def shortest_path(map): Returns the shortest distance from the top-left corner to the bottom-right corner. If there is no valid path, return -1. # Directions for moving up, down, left, and right directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] rows = len(map) cols = len(map[0]) # Start BFS from the top-left corner queue = deque([(0, 0)]) distances = {(0, 0): 1} while queue: x, y = queue.popleft() # Check if we reached the bottom-right corner if (x, y) == (rows - 1, cols - 1): return distances[(x, y)] for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and map[nx][ny] == '0' and (nx, ny) not in distances: queue.append((nx, ny)) distances[(nx, ny)] = distances[(x, y)] + 1 return -1"},{"question":"def caesar_cipher(s: str, shift: int) -> str: Encrypts the given plaintext message using the Caesar Cipher with the specified shift. Parameters: s (str): The plaintext message containing only uppercase alphabetic characters (A-Z). shift (int): The number of places to shift each letter (0 ≤ shift ≤ 25). Returns: str: The encrypted message as a string. Examples: >>> caesar_cipher(\\"HELLO\\", 3) 'KHOOR' >>> caesar_cipher(\\"ABCXYZ\\", 4) 'EFGBCD' >>> caesar_cipher(\\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\", 1) 'BCDEFGHIJKLMNOPQRSTUVWXYZA'","solution":"def caesar_cipher(s: str, shift: int) -> str: Encrypts the given plaintext message using the Caesar Cipher with the specified shift. Parameters: s (str): The plaintext message containing only uppercase alphabetic characters (A-Z). shift (int): The number of places to shift each letter (0 ≤ shift ≤ 25). Returns: str: The encrypted message as a string. encrypted_message = [] for char in s: new_char = chr(((ord(char) - ord('A') + shift) % 26) + ord('A')) encrypted_message.append(new_char) return ''.join(encrypted_message)"},{"question":"def rle_encode(s: str) -> str: Implement a text compression algorithm using Run-Length Encoding (RLE). >>> rle_encode(\\"aaabbcc\\") \\"a3b2c2\\" >>> rle_encode(\\"abcd\\") \\"abcd\\" >>> rle_encode(\\"aaa\\") \\"a3\\"","solution":"def rle_encode(s): if not s: return s encoded = [] count = 1 for i in range(1, len(s)): if s[i] == s[i-1]: count += 1 else: encoded.append(s[i-1] + str(count)) count = 1 encoded.append(s[-1] + str(count)) encoded_str = ''.join(encoded) if len(encoded_str) < len(s): return encoded_str else: return s"},{"question":"def top_contributors(contributors, tasks_completed): Returns a list of the top three contributors based on the number of tasks completed. >>> top_contributors([\\"Alice\\", \\"Bob\\", \\"Charlie\\", \\"David\\"], [5, 15, 10, 7]) [\\"Bob\\", \\"Charlie\\", \\"David\\"] >>> top_contributors([\\"Alice\\"], [5]) [\\"Alice\\"]","solution":"def top_contributors(contributors, tasks_completed): Returns a list of the top three contributors based on the number of tasks completed. Args: contributors (list of str): List of contributor names. tasks_completed (list of int): List of tasks completed corresponding to each contributor. Returns: list of str: List of names of the top three contributors. indexed_tasks = list(enumerate(tasks_completed)) sorted_indexed_tasks = sorted(indexed_tasks, key=lambda x: -x[1]) top_indices = [index for index, _ in sorted_indexed_tasks[:3]] return [contributors[i] for i in top_indices]"},{"question":"def count_overlapping_segments(t: int, test_cases: List[Tuple[int, List[Tuple[int, int, int, int]]]]) -> List[int]: Determine the number of segments that overlap with any other segment. Args: t (int): the number of test cases. test_cases (List[Tuple[int, List[Tuple[int, int, int, int]]]]): list of test cases where each test case is a tuple containing an integer \`n\` representing the number of segments, and a list of \`n\` segments represented by their coordinates (x1, y1, x2, y2) as tuples. Returns: List[int]: a list of integers where each integer represents the number of segments that overlap with any other segment in the corresponding test case. >>> count_overlapping_segments(2, [(3, [(1, 2, 1, 4), (1, 3, 1, 5), (2, 2, 2, 4)]), (4, [(0, 0, 0, 2), (1, 1, 1, 3), (2, 2, 2, 4), (3, 0, 3, 2)])]) [2, 0] >>> count_overlapping_segments(1, [(3, [(1, 1, 1, 2), (2, 2, 2, 3), (3, 3, 3, 4)])]) [0]","solution":"def count_overlapping_segments(t, test_cases): results = [] for n, segments in test_cases: overlaps = 0 visited = [False] * n for i in range(n): for j in range(i+1, n): if is_overlapping(segments[i], segments[j]): if not visited[i]: overlaps += 1 visited[i] = True if not visited[j]: overlaps += 1 visited[j] = True results.append(overlaps) return results def is_overlapping(seg1, seg2): x11, y11, x12, y12 = seg1 x21, y21, x22, y22 = seg2 if x11 == x12 and x21 == x22 and x11 == x21: # both vertical return (max(y11, y12) >= min(y21, y22) and max(y21, y22) >= min(y11, y12)) elif y11 == y12 and y21 == y22 and y11 == y21: # both horizontal return (max(x11, x12) >= min(x21, x22) and max(x21, x22) >= min(x11, x12)) return False"},{"question":"from typing import List def is_scalable(elevations: List[int], k: int) -> bool: Returns True if the mountain is scalable, otherwise returns False. Args: - elevations (List[int]): A list of integers representing elevations. - k (int): The maximum allowed step difference. Returns: - bool: True if the mountain is scalable, otherwise False. >>> is_scalable([3, 5, 6, 7, 8], 2) True >>> is_scalable([3, 5, 6, 7, 11], 2) False >>> is_scalable([9, 8, 6, 7, 6], 3) True >>> is_scalable([10], 5) True >>> is_scalable([1, 1, 1, 1], 0) True >>> is_scalable([10, 15, 20, 25], 3) False >>> is_scalable([1, 3, 2, 4, 3, 5], 2) True >>> is_scalable([1, 100, 200, 300], 500) True >>> is_scalable([], 1) True","solution":"from typing import List def is_scalable(elevations: List[int], k: int) -> bool: Returns True if the mountain is scalable, otherwise returns False. Args: - elevations (List[int]): A list of integers representing elevations. - k (int): The maximum allowed step difference. Returns: - bool: True if the mountain is scalable, otherwise False. for i in range(1, len(elevations)): if abs(elevations[i] - elevations[i-1]) > k: return False return True"},{"question":"from typing import List def permute(nums: List[int]) -> List[List[int]]: Given a list of 'n' distinct integers, return all possible permutations of the elements in the list. >>> permute([0, 1]) [[0, 1], [1, 0]] >>> permute([1]) [[1]] >>> permute([]) [[]]","solution":"from typing import List def permute(nums: List[int]) -> List[List[int]]: def backtrack(start=0): if start == len(nums): result.append(nums[:]) for i in range(start, len(nums)): nums[start], nums[i] = nums[i], nums[start] backtrack(start + 1) nums[start], nums[i] = nums[i], nums[start] result = [] backtrack() return result"},{"question":"from typing import List, Tuple def solve(arr: List[int], target: int) -> Tuple[int, int, int]: You are given an array of integers and a target integer. Your task is to determine if there are three distinct elements in the array that sum up to the target integer. If such a combination exists, return the combination as a tuple of three integers in non-decreasing order. If there are multiple combinations, return the first one found in lexicographical order. If no such combination exists, return an empty tuple. >>> solve([1, 2, 3, 4, 6], 10) (1, 3, 6) >>> solve([5, -1, 2, 10, 3], 7) (-1, 3, 5) >>> solve([1, 2, 3], 7) ()","solution":"def solve(arr, target): arr.sort() n = len(arr) for i in range(n): left = i + 1 right = n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == target: return (arr[i], arr[left], arr[right]) elif current_sum < target: left += 1 else: right -= 1 return ()"},{"question":"def max_unique_in_subarrays(nums: List[int], k: int) -> int: Determines the maximum number of unique elements in any contiguous subarray of \`nums\` of length \`k\`. Args: nums (list[int]): A list of integers. k (int): The length of the subarray. Returns: int: The maximum number of unique elements in any contiguous subarray of length \`k\`. Test Examples: >>> max_unique_in_subarrays([1, 2, 2, 3, 4], 3) 3 >>> max_unique_in_subarrays([4, 2, 1, 3, 4, 5], 4) 4","solution":"def max_unique_in_subarrays(nums, k): Determines the maximum number of unique elements in any contiguous subarray of \`nums\` of length \`k\`. max_unique = 0 for i in range(len(nums) - k + 1): unique_elements = set(nums[i:i + k]) max_unique = max(max_unique, len(unique_elements)) return max_unique"},{"question":"def find_longest_word(s: str) -> str: Find the longest word in the given string s. If there are multiple words with the same length, return the first one encountered. >>> find_longest_word(\\"The quick brown fox\\") \\"quick\\" >>> find_longest_word(\\"A journey of a thousand miles begins with a single step\\") \\"thousand\\" >>> find_longest_word(\\"To be or not to be, that is the question\\") \\"question\\" >>> find_longest_word(\\"Hello, world!\\") \\"Hello,\\" >>> find_longest_word(\\"It's a beautiful day\\") \\"beautiful\\" >>> find_longest_word(\\"Don't stop believing\\") \\"believing\\" >>> find_longest_word(\\"I am a cat\\") \\"cat\\" >>> find_longest_word(\\"Tie tie tie\\") \\"Tie\\" >>> find_longest_word(\\"123 456 789\\") \\"123\\" >>> find_longest_word(\\"word\\") \\"word\\" >>> find_longest_word(\\"pneumonoultramicroscopicsilicovolcanoconiosis\\") \\"pneumonoultramicroscopicsilicovolcanoconiosis\\"","solution":"def find_longest_word(s): Returns the longest word in the given string s. If there are multiple words with the same length, the first one encountered is returned. Parameters: s (str): The input string containing words separated by spaces. Returns: str: The longest word in the string. words = s.split() longest_word = max(words, key=len) return longest_word"},{"question":"def numIslands(grid: List[List[int]]) -> int: Count the number of islands in a 2D grid map of 1s (land) and 0s (water). >>> grid = [ ... [1,1,0,0,0], ... [1,1,0,0,0], ... [0,0,1,0,0], ... [0,0,0,1,1] ... ] >>> numIslands(grid) 3 >>> grid = [ ... [1,0], ... [0,0] ... ] >>> numIslands(grid) 1 >>> grid = [ ... [1,1,1,0,0], ... [1,1,1,0,0], ... [1,1,1,0,0], ... [0,0,0,0,0], ... [0,0,0,0,1] ... ] >>> numIslands(grid) 2 >>> grid = [ ... [1,0,0,1], ... [0,0,0,0], ... [0,0,1,0], ... [0,1,0,0] ... ] >>> numIslands(grid) 4 >>> grid = [ ... [0,0], ... [0,0] ... ] >>> numIslands(grid) 0 >>> grid = [] >>> numIslands(grid) 0","solution":"def numIslands(grid): if not grid: return 0 num_rows = len(grid) num_cols = len(grid[0]) visited = [[False for _ in range(num_cols)] for _ in range(num_rows)] def dfs(row, col): if row < 0 or col < 0 or row >= num_rows or col >= num_cols or visited[row][col] or grid[row][col] == 0: return visited[row][col] = True dfs(row - 1, col) dfs(row + 1, col) dfs(row, col - 1) dfs(row, col + 1) num_islands = 0 for row in range(num_rows): for col in range(num_cols): if grid[row][col] == 1 and not visited[row][col]: dfs(row, col) num_islands += 1 return num_islands"},{"question":"def average_price(products: List[str]) -> float: Calculate the average price of products from a list of strings formatted as \\"product:price\\". If the list is empty, return 0.00. Args: products (list): List of strings with each string in the format \\"product:price\\". Returns: float: The average price of the products, rounded to two decimal places. Examples: >>> average_price([\\"apple:1.25\\", \\"banana:0.75\\", \\"milk:3.50\\"]) 1.83 >>> average_price([]) 0.00","solution":"def average_price(products): Calculate the average price of products from a list of strings formatted as \\"product:price\\". If the list is empty, return 0.00. Args: products (list): List of strings with each string in the format \\"product:price\\". Returns: float: The average price of the products, rounded to two decimal places. if not products: return 0.00 total_price = 0 for product in products: name, price = product.split(\\":\\") total_price += float(price) average = total_price / len(products) return round(average, 2)"},{"question":"def edit_distance(s: str, t: str) -> int: Returns the minimum number of edit operations required to convert string s into string t. >>> edit_distance(\\"kitten\\", \\"sitting\\") 3 >>> edit_distance(\\"flaw\\", \\"lawn\\") 2 >>> edit_distance(\\"abc\\", \\"abc\\") 0 >>> edit_distance(\\"abc\\", \\"abcd\\") 1 >>> edit_distance(\\"abcd\\", \\"abc\\") 1 >>> edit_distance(\\"abc\\", \\"abd\\") 1 >>> edit_distance(\\"\\", \\"\\") 0 >>> edit_distance(\\"abc\\", \\"\\") 3 >>> edit_distance(\\"\\", \\"abc\\") 3","solution":"def edit_distance(s, t): Returns the minimum number of edit operations required to convert string s into string t. m, n = len(s), len(t) # Initialize a (m+1) x (n+1) matrix to store results of subproblems dp = [[0] * (n+1) for _ in range(m+1)] # Fill dp array for i in range(m+1): for j in range(n+1): if i == 0: dp[i][j] = j # Min operations = j (insert all characters of t) elif j == 0: dp[i][j] = i # Min operations = i (remove all characters of s) elif s[i-1] == t[j-1]: dp[i][j] = dp[i-1][j-1] # Characters match, no new operations needed else: dp[i][j] = 1 + min(dp[i-1][j], # Delete dp[i][j-1], # Insert dp[i-1][j-1]) # Replace return dp[m][n]"},{"question":"def remove_duplicates(arr): Removes duplicates from the input list while preserving the original order of elements. Parameters: arr (list): List of integers with possible duplicates. Returns: list: A list with duplicates removed and order preserved. Examples: >>> remove_duplicates([4, 5, 2, 4, 5, 1, 2, 4]) [4, 5, 2, 1] >>> remove_duplicates([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> remove_duplicates([1, 1, 1, 1, 1]) [1] >>> remove_duplicates([1, 2, 2, -3, 4, -3, -3, 4, 5]) [1, 2, -3, 4, 5] >>> remove_duplicates([5, 4, 3, 2, 1, 1, 2, 3, 4, 5]) [5, 4, 3, 2, 1] >>> remove_duplicates([]) []","solution":"def remove_duplicates(arr): Removes duplicates from the input list while preserving the original order of elements. Parameters: arr (list): List of integers with possible duplicates. Returns: list: A list with duplicates removed and order preserved. seen = set() result = [] for num in arr: if num not in seen: seen.add(num) result.append(num) return result"},{"question":"from typing import List def longest_palindrome_length(S: str) -> int: Returns the length of the longest palindromic substring that can be formed from any substring of S. >>> longest_palindrome_length(\\"a\\") 1 >>> longest_palindrome_length(\\"aabbcc\\") 6 >>> longest_palindrome_length(\\"aaabbcccc\\") 9 >>> longest_palindrome_length(\\"ababb\\") 5 >>> longest_palindrome_length(\\"civic\\") 5 pass def solution(T: int, cases: List[str]) -> List[int]: Processes the test cases and returns a list with the length of the longest palindromic substring for each input string. >>> solution(2, [\\"ababb\\", \\"civic\\"]) [5, 5] >>> solution(1, [\\"aaaaa\\"]) [5] >>> solution(3, [\\"a\\", \\"abc\\", \\"deed\\"]) [1, 1, 4] pass","solution":"def longest_palindrome_length(S): Returns the length of the longest substring that can be rearranged to form a palindrome. from collections import Counter # Count frequency of each character in the string freq = Counter(S) # Initialize length of the longest palindromic substring that can be formed length = 0 odd_count = 0 # Calculate the length based on character frequencies for count in freq.values(): if count % 2 == 0: length += count else: length += count - 1 odd_count = 1 # If there was an odd count character, add one to length length += odd_count return length def solution(T, cases): Processes the test cases. results = [] for S in cases: results.append(longest_palindrome_length(S)) return results"},{"question":"def max_sum_of_three(nums: List[int]) -> int: Returns the maximum sum obtained by summing exactly three elements from the list. >>> max_sum_of_three([1, 2, 3, 4]) 9 >>> max_sum_of_three([10, 2, 3, 5, 7]) 22 >>> max_sum_of_three([11, 9, 5, 6, 3]) 26 >>> max_sum_of_three([3, 3, 3]) 9 >>> max_sum_of_three([5, 5, 5, 5]) 15 >>> max_sum_of_three([1000, 2000, 3000, 4000]) 9000 >>> max_sum_of_three([123456, 234567, 345678, 456789]) 1037034 >>> max_sum_of_three([8, 13, 21]) 42 >>> max_sum_of_three([4, 4, 4, 4, 4]) 12 pass","solution":"def max_sum_of_three(nums): Returns the maximum sum obtained by summing exactly three elements from the list. nums.sort(reverse=True) return sum(nums[:3])"},{"question":"def can_fairies_meet(n: int, positions_jumps: List[Tuple[int, int]]) -> str: Determines if any two fairies in the garden can meet by jumping exactly once. :param n: Number of fairies :param positions_jumps: List of tuples containing position and jump distance (p, j) :return: 'YES' if any two fairies can meet, 'NO' otherwise >>> can_fairies_meet(3, [(0, 2), (3, -1), (2, 1)]) == 'YES' >>> can_fairies_meet(3, [(0, 2), (5, 1), (10, -1)]) == 'NO'","solution":"def can_fairies_meet(n, positions_jumps): Determines if any two fairies in the garden can meet by jumping exactly once. :param n: Number of fairies :param positions_jumps: List of tuples containing position and jump distance (p, j) :return: 'YES' if any two fairies can meet, 'NO' otherwise reachable_positions = {} for i in range(n): initial_position = positions_jumps[i][0] jump_distance = positions_jumps[i][1] # Calculate forward and backward jumps new_position_forward = initial_position + jump_distance new_position_backward = initial_position - jump_distance # Check if these positions have already been marked as reachable by another fairy if new_position_forward in reachable_positions or new_position_backward in reachable_positions: return 'YES' # Mark the current fairy's achievable new positions reachable_positions[new_position_forward] = True reachable_positions[new_position_backward] = True return 'NO'"},{"question":"def is_rotation(str1: str, str2: str) -> bool: Returns True if str2 is a rotation of str1, otherwise returns False. >>> is_rotation(\\"waterbottle\\", \\"erbottlewat\\") True >>> is_rotation(\\"abcde\\", \\"abced\\") False","solution":"def is_rotation(str1, str2): Returns True if str2 is a rotation of str1, otherwise returns False. if len(str1) != len(str2): return False concatenated = str1 + str1 return str2 in concatenated"},{"question":"from typing import List, Tuple def find_position(m: int, n: int, k: int) -> Tuple[int, int]: Find the position (row, column) of the cell labelled \`k\` in an m x n grid where the robot moves in a zigzag manner. >>> find_position(3, 3, 5) (1, 1) >>> find_position(4, 2, 8) (3, 0) pass def process_test_cases(test_cases: List[Tuple[int, int, int]]) -> List[Tuple[int, int]]: Process a list of test cases to find positions for each set of grid dimensions and label. >>> test_cases = [ ... (3, 3, 5), ... (4, 2, 8), ... (2, 2, 3), ... (3, 1, 2) ... ] >>> process_test_cases(test_cases) [(1, 1), (3, 0), (1, 1), (1, 0)] pass def test_find_position(): assert find_position(3, 3, 5) == (1, 1) assert find_position(4, 2, 8) == (3, 0) assert find_position(2, 2, 3) == (1, 1) assert find_position(3, 1, 2) == (1, 0) assert find_position(1, 1, 1) == (0, 0) assert find_position(3, 3, 1) == (0, 0) assert find_position(3, 3, 9) == (2, 2) def test_process_test_cases(): test_cases = [ (3, 3, 5), (4, 2, 8), (2, 2, 3), (3, 1, 2) ] expected_results = [ (1, 1), (3, 0), (1, 1), (1, 0) ] assert process_test_cases(test_cases) == expected_results","solution":"def find_position(m, n, k): row = (k - 1) // n col = (k - 1) % n if row % 2 == 1: # Odd row, reverse column order col = n - 1 - col return row, col def process_test_cases(test_cases): results = [] for m, n, k in test_cases: row, col = find_position(m, n, k) results.append((row, col)) return results"},{"question":"def highest_product_of_three(nums: List[int]) -> int: Given an array of integers, find the highest product that can be obtained by multiplying any three distinct numbers from the array. >>> highest_product_of_three([1, 10, 2, 6, 5, 3]) 300 >>> highest_product_of_three([10, 3, 5, 6, 20]) 1200 >>> highest_product_of_three([-10, -10, 1, 3, 2]) 300 >>> highest_product_of_three([1, 2, 3, 4]) 24 >>> highest_product_of_three([-1, -2, -3, -4]) -6 >>> highest_product_of_three([0, -1, 3, 100, 70, 50]) 350000 >>> highest_product_of_three([-1, -2, -3, 4]) 24 >>> highest_product_of_three([1, -4, 3, -6, 7, 0]) 168","solution":"def highest_product_of_three(nums): Returns the highest product that can be obtained by multiplying any three distinct numbers from the list nums. if len(nums) < 3: raise ValueError(\\"List must contain at least three numbers\\") nums.sort() # The highest product can be the product of the three largest numbers # or the product of the two smallest numbers (which can be negative) and the largest number return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])"},{"question":"def process_operations(operations: List[str]) -> List[str]: Processes a series of banking operations and returns the corresponding responses. Input ----- operations : List[str] A list of operations, each represented by a string: - \\"CREATE account_number initial_balance\\" - \\"DEPOSIT account_number amount\\" - \\"WITHDRAW account_number amount\\" - \\"TRANSFER from_account_number to_account_number amount\\" Output ------ List[str] A list of responses for each operation. Examples -------- >>> process_operations([\\"CREATE 123456 1000\\", \\"DEPOSIT 123456 200\\"]) ['Account 123456 created with balance 1000', 'Deposited 200 to 123456, new balance is 1200'] >>> process_operations([\\"CREATE 123456 1000\\", \\"WITHDRAW 123456 300\\"]) ['Account 123456 created with balance 1000', 'Withdrew 300 from 123456, new balance is 700'] >>> process_operations([\\"CREATE 123456 1000\\", \\"TRANSFER 123456 789012 400\\"]) ['Account 123456 created with balance 1000', 'One or both accounts do not exist'] from solution import process_operations def test_create_account(): operations = [\\"CREATE 123456 1000\\"] expected = [\\"Account 123456 created with balance 1000\\"] assert process_operations(operations) == expected def test_create_existing_account(): operations = [\\"CREATE 123456 1000\\", \\"CREATE 123456 2000\\"] expected = [\\"Account 123456 created with balance 1000\\", \\"Account 123456 already exists\\"] assert process_operations(operations) == expected def test_deposit_to_existing_account(): operations = [\\"CREATE 123456 1000\\", \\"DEPOSIT 123456 500\\"] expected = [\\"Account 123456 created with balance 1000\\", \\"Deposited 500 to 123456, new balance is 1500\\"] assert process_operations(operations) == expected def test_deposit_to_nonexistent_account(): operations = [\\"DEPOSIT 123456 500\\"] expected = [\\"Account 123456 does not exist\\"] assert process_operations(operations) == expected def test_withdraw_from_existing_account(): operations = [\\"CREATE 123456 1000\\", \\"WITHDRAW 123456 300\\"] expected = [\\"Account 123456 created with balance 1000\\", \\"Withdrew 300 from 123456, new balance is 700\\"] assert process_operations(operations) == expected def test_withdraw_from_nonexistent_account(): operations = [\\"WITHDRAW 123456 300\\"] expected = [\\"Account 123456 does not exist\\"] assert process_operations(operations) == expected def test_withdraw_insufficient_funds(): operations = [\\"CREATE 123456 1000\\", \\"WITHDRAW 123456 2000\\"] expected = [\\"Account 123456 created with balance 1000\\", \\"Insufficient funds in account 123456\\"] assert process_operations(operations) == expected def test_transfer_between_existing_accounts(): operations = [\\"CREATE 123456 1000\\", \\"CREATE 789012 500\\", \\"TRANSFER 123456 789012 400\\"] expected = [ \\"Account 123456 created with balance 1000\\", \\"Account 789012 created with balance 500\\", \\"Transferred 400 from 123456 to 789012, new balance is 600 for 123456 and 900 for 789012\\" ] assert process_operations(operations) == expected def test_transfer_between_nonexistent_account(): operations = [\\"CREATE 123456 1000\\", \\"TRANSFER 123456 789012 400\\"] expected = [\\"Account 123456 created with balance 1000\\", \\"One or both accounts do not exist\\"] assert process_operations(operations) == expected def test_transfer_insufficient_funds(): operations = [\\"CREATE 123456 1000\\", \\"CREATE 789012 500\\", \\"TRANSFER 123456 789012 2000\\"] expected = [ \\"Account 123456 created with balance 1000\\", \\"Account 789012 created with balance 500\\", \\"Insufficient funds in account 123456\\" ] assert process_operations(operations) == expected","solution":"def process_operations(operations): accounts = {} results = [] for operation in operations: parts = operation.split() action = parts[0] if action == \\"CREATE\\": account_number = parts[1] initial_balance = int(parts[2]) if account_number in accounts: result = f\\"Account {account_number} already exists\\" else: accounts[account_number] = initial_balance result = f\\"Account {account_number} created with balance {initial_balance}\\" elif action == \\"DEPOSIT\\": account_number = parts[1] amount = int(parts[2]) if account_number in accounts: accounts[account_number] += amount result = f\\"Deposited {amount} to {account_number}, new balance is {accounts[account_number]}\\" else: result = f\\"Account {account_number} does not exist\\" elif action == \\"WITHDRAW\\": account_number = parts[1] amount = int(parts[2]) if account_number in accounts: if accounts[account_number] >= amount: accounts[account_number] -= amount result = f\\"Withdrew {amount} from {account_number}, new balance is {accounts[account_number]}\\" else: result = f\\"Insufficient funds in account {account_number}\\" else: result = f\\"Account {account_number} does not exist\\" elif action == \\"TRANSFER\\": from_account = parts[1] to_account = parts[2] amount = int(parts[3]) if from_account in accounts and to_account in accounts: if accounts[from_account] >= amount: accounts[from_account] -= amount accounts[to_account] += amount result = f\\"Transferred {amount} from {from_account} to {to_account}, new balance is {accounts[from_account]} for {from_account} and {accounts[to_account]} for {to_account}\\" else: result = f\\"Insufficient funds in account {from_account}\\" else: result = f\\"One or both accounts do not exist\\" results.append(result) return results"},{"question":"from typing import List, Dict def count_frequencies(nums: List[int]) -> Dict[int, int]: Given a list of integers, returns a dictionary where the keys are the integers and the values are their respective counts. >>> count_frequencies([1, 2, 2, 3, 3, 3, 4, 4, 4, 4]) {1: 1, 2: 2, 3: 3, 4: 4} >>> count_frequencies([5]) {5: 1} >>> count_frequencies([1, 2, 3, 4, 5]) {1: 1, 2: 1, 3: 1, 4: 1, 5: 1} >>> count_frequencies([7, 7, 7, 7]) {7: 4} >>> count_frequencies([]) {} >>> count_frequencies([-1, -1, 0, 1, 1, 2, -2, -2, -2, 3]) {-1: 2, 0: 1, 1: 2, 2: 1, -2: 3, 3: 1}","solution":"from typing import List, Dict from collections import Counter def count_frequencies(nums: List[int]) -> Dict[int, int]: Returns a dictionary key is the integer from the input list and the value is the count of its occurrences. return dict(Counter(nums))"},{"question":"def calculate_y_values(data, m, b): Calculate the dependent variable (y-values) given the independent variable (x-values), slope (m), and y-intercept (b). Parameters: data (list of float): The list of independent variable values. m (float): The slope of the linear relationship. b (float): The y-intercept of the linear relationship. Returns: list of float: The calculated dependent variable values. >>> calculate_y_values([0, 1, 2, 3], 2, 1) [1, 3, 5, 7] >>> calculate_y_values([-1, 0, 1, 2], -3, 4) [7, 4, 1, -2] >>> calculate_y_values([10, 20, 30], 0.5, -2) [3, 8, 13]","solution":"def calculate_y_values(data, m, b): Calculate the dependent variable (y-values) given the independent variable (x-values), slope (m), and y-intercept (b). Parameters: data (list of float): The list of independent variable values. m (float): The slope of the linear relationship. b (float): The y-intercept of the linear relationship. Returns: list of float: The calculated dependent variable values. return [m * x + b for x in data]"},{"question":"def calculate_commute_time(distances, speeds, conditions): Calculate the total expected travel time for Casey's commute based on given segments. Parameters: distances (list of int): Distances of the segments in kilometers. speeds (list of int): Average speeds of the segments in kilometers per hour. conditions (list of str): Conditions of the segments, either \\"smooth\\" or \\"congested\\". Returns: int: Total expected travel time rounded to the nearest integer. >>> calculate_commute_time([40, 60, 30], [80, 100, 120], [\\"smooth\\", \\"congested\\", \\"smooth\\"]) 2 >>> calculate_commute_time([50, 70], [100, 140], [\\"smooth\\", \\"smooth\\"]) 1 >>> calculate_commute_time([20, 30], [60, 90], [\\"congested\\", \\"congested\\"]) 1 >>> calculate_commute_time([10, 50, 45], [50, 100, 90], [\\"congested\\", \\"smooth\\", \\"congested\\"]) 2 >>> calculate_commute_time([100], [50], [\\"smooth\\"]) 2 >>> calculate_commute_time([80], [80], [\\"congested\\"]) 2","solution":"def calculate_commute_time(distances, speeds, conditions): Calculate the total expected travel time for Casey's commute based on given segments. Parameters: distances (list of int): Distances of the segments in kilometers. speeds (list of int): Average speeds of the segments in kilometers per hour. conditions (list of str): Conditions of the segments, either \\"smooth\\" or \\"congested\\". Returns: int: Total expected travel time rounded to the nearest integer. total_time = 0 for D, S, condition in zip(distances, speeds, conditions): if condition == \\"congested\\": S = S / 2 total_time += D / S return round(total_time)"},{"question":"def manage_fleet(T: int, test_cases: List[Tuple[int, int, List[int], List[Tuple[int, int]]]]) -> List[str]: Manages the fleet of cars for a rental company based on booking and return requests. Args: T: Number of test cases. test_cases: A list of tuples where each tuple represents a test case containing: - N: Number of cars in the fleet. - Q: Number of requests. - car_status: A list where 0 indicates the car is available and 1 indicates it is rented out. - requests: A list of tuples representing the requests where: - (1, i): Booking request for the i-th car. - (2, i): Return request for the i-th car. Returns: A list of strings representing the outcome of each request, either \\"Booked\\", \\"Already Rented\\", \\"Returned\\", or \\"Already Available\\". >>> T = 1 >>> test_cases = [ ... (5, 6, [0, 1, 0, 1, 0], [ ... (1, 3), ... (1, 2), ... (1, 4), ... (2, 2), ... (2, 5), ... (1, 5) ... ]) ... ] >>> manage_fleet(T, test_cases) ['Booked', 'Already Rented', 'Already Rented', 'Returned', 'Already Available', 'Booked']","solution":"def manage_fleet(T, test_cases): results = [] for case in test_cases: N, Q, car_status, requests = case for req in requests: action, car_id = req if action == 1: # Booking request if car_status[car_id - 1] == 0: results.append(\\"Booked\\") car_status[car_id - 1] = 1 else: results.append(\\"Already Rented\\") elif action == 2: # Return request if car_status[car_id - 1] == 1: results.append(\\"Returned\\") car_status[car_id - 1] = 0 else: results.append(\\"Already Available\\") return results"},{"question":"from typing import List, Tuple def reconcile_products(db1: List[Tuple[int, str]], db2: List[Tuple[int, str]]) -> List[int]: Reconcile discrepancies between two product databases based on product names. For the purpose of this task, two product names are considered a match if their Levenshtein distance is less than or equal to 2. >>> db1 = [(1, \\"apple\\"), (2, \\"banana\\"), (3, \\"orange\\")] >>> db2 = [(4, \\"appl\\"), (5, \\"banan\\"), (6, \\"oraneg\\")] >>> reconcile_products(db1, db2) [1, 2, 3] >>> db1 = [(1, \\"kiwi\\")] >>> db2 = [(4, \\"appl\\"), (5, \\"banan\\"), (6, \\"oraneg\\")] >>> reconcile_products(db1, db2) []","solution":"from typing import List, Tuple import numpy as np def levenshtein_distance(a: str, b: str) -> int: if a == b: return 0 if len(a) < len(b): a, b = b, a previous_row = range(len(b) + 1) for i, ca in enumerate(a): current_row = [i + 1] for j, cb in enumerate(b): insertions = previous_row[j + 1] + 1 deletions = current_row[j] + 1 substitutions = previous_row[j] + (ca != cb) current_row.append(min(insertions, deletions, substitutions)) previous_row = current_row return previous_row[-1] def reconcile_products(db1: List[Tuple[int, str]], db2: List[Tuple[int, str]]) -> List[int]: matching_ids = [] for id1, name1 in db1: for id2, name2 in db2: if levenshtein_distance(name1, name2) <= 2: matching_ids.append(id1) break # no need to continue, we found a match for this id1 return matching_ids"},{"question":"def longest_contiguous_substring(data: str) -> str: Returns the longest contiguous substring containing only letters or only digits. If there are multiple longest substrings of the same length, return the first one. If the input string is empty, return an empty string. >>> longest_contiguous_substring(\\"abc12345xyz678\\") == \\"12345\\" >>> longest_contiguous_substring(\\"ab12c34d5ef\\") == \\"ab\\" >>> longest_contiguous_substring(\\"\\") == \\"\\" >>> longest_contiguous_substring(\\"abcdef\\") == \\"abcdef\\" >>> longest_contiguous_substring(\\"123456\\") == \\"123456\\" >>> longest_contiguous_substring(\\"a123b456\\") == \\"123\\" >>> longest_contiguous_substring(\\"12ab34cd\\") == \\"12\\" >>> longest_contiguous_substring(\\"ab123cd456\\") == \\"123\\" >>> longest_contiguous_substring(\\"a\\") == \\"a\\" >>> longest_contiguous_substring(\\"1\\") == \\"1\\" >>> longest_contiguous_substring(\\"abcde12345678z\\") == \\"12345678\\" pass","solution":"def longest_contiguous_substring(data): Returns the longest contiguous substring containing only letters or only digits. If there are multiple longest substrings of the same length, return the first one. If the input string is empty, return an empty string. if not data: return \\"\\" longest_substring = \\"\\" current_substring = data[0] for char in data[1:]: if char.isdigit() and current_substring[-1].isdigit(): current_substring += char elif char.isalpha() and current_substring[-1].isalpha(): current_substring += char else: if len(current_substring) > len(longest_substring): longest_substring = current_substring current_substring = char if len(current_substring) > len(longest_substring): longest_substring = current_substring return longest_substring"},{"question":"def contains_nearby_almost_duplicate(nums: List[int], k: int, t: int) -> bool: Determines if there are two distinct indices i and j in the array such that: - abs(nums[i] - nums[j]) <= t - abs(i - j) <= k >>> contains_nearby_almost_duplicate([1, 2, 3, 1], 3, 0) True >>> contains_nearby_almost_duplicate([1, 5, 9, 1, 5, 9], 2, 3) False","solution":"def contains_nearby_almost_duplicate(nums, k, t): Determines if there are two distinct indices i and j in the array such that: - abs(nums[i] - nums[j]) <= t - abs(i - j) <= k if t < 0: return False dict = {} for i, num in enumerate(nums): bucket = num // (t + 1) if bucket in dict: return True if bucket - 1 in dict and abs(num - dict[bucket - 1]) <= t: return True if bucket + 1 in dict and abs(num - dict[bucket + 1]) <= t: return True dict[bucket] = num if i >= k: del dict[nums[i - k] // (t + 1)] return False"},{"question":"def spiral_order(matrix: List[List[int]]) -> List[int]: Returns the elements of the matrix in spiral order. Args: matrix: 2D list of integers Returns: list of integers in spiral order Examples: >>> spiral_order([ ... [ 1, 2, 3 ], ... [ 4, 5, 6 ], ... [ 7, 8, 9 ] ... ]) [1, 2, 3, 6, 9, 8, 7, 4, 5] >>> spiral_order([ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12] ... ]) [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7] >>> spiral_order([]) [] >>> spiral_order([[1]]) [1] >>> spiral_order([[1, 2, 3, 4]]) [1, 2, 3, 4] >>> spiral_order([[1], [2], [3], [4]]) [1, 2, 3, 4]","solution":"def spiral_order(matrix): Returns the elements of the matrix in spiral order. Args: matrix: 2D list of integers Returns: list of integers in spiral order if not matrix: return [] spiral = [] while matrix: # Take the first row spiral.extend(matrix.pop(0)) # Take the last element of each remaining row if matrix and matrix[0]: for row in matrix: spiral.append(row.pop()) # Take the last row in reverse order if matrix: spiral.extend(matrix.pop()[::-1]) # Take the first element of each remaining row in reverse order if matrix and matrix[0]: for row in matrix[::-1]: spiral.append(row.pop(0)) return spiral"},{"question":"from typing import List def longest_common_prefix(strs: List[str]) -> str: Find the longest common prefix among a list of strings. >>> longest_common_prefix(['flower', 'flow', 'flight']) 'fl' >>> longest_common_prefix(['dog', 'racecar', 'car']) '' pass def process_test_cases(test_cases: List[List[str]]) -> List[str]: Processes multiple test cases and returns the results as a list of the longest common prefixes. pass def test_longest_common_prefix(): assert longest_common_prefix(['flower', 'flow', 'flight']) == 'fl' assert longest_common_prefix(['dog', 'racecar', 'car']) == '' assert longest_common_prefix(['interview', 'interval', 'integrate']) == 'inte' assert longest_common_prefix(['same', 'same', 'same']) == 'same' assert longest_common_prefix(['a']) == 'a' assert longest_common_prefix(['ab', 'a']) == 'a' assert longest_common_prefix([]) == '' def test_process_test_cases(): test_cases = [ ['flower', 'flow', 'flight'], ['dog', 'racecar', 'car'], ['interview', 'interval', 'integrate'], ['same', 'same', 'same'], ['a'], ['ab', 'a'] ] results = process_test_cases(test_cases) expected_results = ['fl', '', 'inte', 'same', 'a', 'a'] assert results == expected_results test_cases = [ [], [''] ] results = process_test_cases(test_cases) expected_results = ['', ''] assert results == expected_results","solution":"def longest_common_prefix(strs): Function to find the longest common prefix string amongst an array of strings. if not strs: return '' prefix = strs[0] for s in strs[1:]: while s.find(prefix) != 0: prefix = prefix[:-1] if not prefix: return '' return prefix def process_test_cases(test_cases): Processes multiple test cases and returns the results as a list of the longest common prefixes. results = [] for strs in test_cases: results.append(longest_common_prefix(strs)) return results"},{"question":"def find_palindromic_substrings(s: str) -> int: Counts and returns the number of distinct palindromic substrings present in the given string s. >>> find_palindromic_substrings('a') 1 >>> find_palindromic_substrings('z') 1 >>> find_palindromic_substrings('abcd') 4 >>> find_palindromic_substrings('ababa') 5 >>> find_palindromic_substrings('aaa') 3 >>> find_palindromic_substrings('racecar') 7 >>> find_palindromic_substrings('abcdefg') 7 >>> find_palindromic_substrings('aaaa') 4","solution":"def find_palindromic_substrings(s): Counts and returns the number of distinct palindromic substrings in the given string s. palindromes = set() def expand_from_center(left, right): while left >= 0 and right < len(s) and s[left] == s[right]: palindromes.add(s[left:right+1]) left -= 1 right += 1 for i in range(len(s)): expand_from_center(i, i) # Odd length palindromes expand_from_center(i, i + 1) # Even length palindromes return len(palindromes)"},{"question":"class Inventory: Inventory management class to automate the process of keeping track of inventory. Methods: add(item_name: str, quantity: int): Adds quantity of item_name to the inventory. remove(item_name: str, quantity: int): Removes quantity of item_name from the inventory. get(item_name: str): Returns the current quantity of item_name or None if it does not exist. >>> inventory = Inventory() >>> inventory.add(\\"apples\\", 10) >>> inventory.get(\\"apples\\") 10 >>> inventory.add(\\"apples\\", 5) >>> inventory.get(\\"apples\\") 15 >>> inventory.remove(\\"apples\\", 12) >>> inventory.get(\\"apples\\") 3 >>> inventory.remove(\\"bananas\\", 1) >>> inventory.get(\\"bananas\\") None >>> inventory.add(\\"bananas\\", 7) >>> inventory.get(\\"bananas\\") 7 >>> inventory.remove(\\"bananas\\", 10) >>> inventory.get(\\"bananas\\") 0 def __init__(self): pass def add(self, item_name: str, quantity: int): pass def remove(self, item_name: str, quantity: int): pass def get(self, item_name: str): pass","solution":"class Inventory: def __init__(self): self.items = {} def add(self, item_name, quantity): if item_name in self.items: self.items[item_name] += quantity else: self.items[item_name] = quantity def remove(self, item_name, quantity): if item_name in self.items: self.items[item_name] = max(0, self.items[item_name] - quantity) def get(self, item_name): return self.items.get(item_name)"},{"question":"def find_missing_number(arr): Finds the missing number in an array of distinct integers from 1 to n except one missing number. >>> find_missing_number([3, 7, 1, 2, 8, 4, 5]) == 6 >>> find_missing_number([1, 2, 4, 5, 6]) == 3 >>> find_missing_number([2, 3, 4, 5]) == 1 >>> find_missing_number([1, 2, 3, 4, 5]) == 6 >>> find_missing_number([1, 2, 3, 5, 6]) == 4","solution":"def find_missing_number(arr): Finds the missing number in an array of distinct integers from 1 to n except one missing number. n = len(arr) + 1 total_sum = n * (n + 1) / 2 array_sum = sum(arr) return int(total_sum - array_sum)"},{"question":"from typing import List, Tuple def max_messages(start: int, end: int, connections: List[Tuple[int, int]]) -> int: Given a network of servers represented as a directed acyclic graph (DAG), determine the maximum number of messages that can be sent from the start server to the end server, adhering to the constraints of the network. Args: start (int): the start server end (int): the end server connections (List[Tuple[int, int]]): a list of tuples where each tuple (a, b) indicates a directed edge from server a to server b Returns: int: the maximum number of possible messages that can be sent from the start server to the end server Example: >>> max_messages(0, 3, [(0, 1), (1, 2), (2, 3), (0, 2), (1, 3)]) 3 def test_max_messages_single_path(): assert max_messages(0, 3, [(0, 1), (1, 2), (2, 3)]) == 1 def test_max_messages_multiple_paths(): assert max_messages(0, 3, [(0, 1), (1, 2), (2, 3), (0, 2), (1, 3)]) == 3 def test_max_messages_indirect_path(): assert max_messages(0, 4, [(0, 1), (1, 2), (2, 3), (1, 3), (3, 4)]) == 2 def test_max_messages_disjoint_subgraphs(): assert max_messages(0, 3, [(0, 1), (0, 2), (1, 3), (2, 3)]) == 2 def test_max_messages_large_graph(): assert max_messages(0, 5, [(0, 1), (0, 2), (1, 3), (2, 3), (3, 4), (4, 5), (1, 4), (2, 5)]) == 4","solution":"from collections import defaultdict, deque def max_messages(start, end, connections): Given a directed acyclic graph (DAG) of servers and communication links, this function determines the maximum number of messages that can be sent from the start server to the end server, considering all possible unique paths. # Convert connections to adjacency list for easier access graph = defaultdict(list) for a, b in connections: graph[a].append(b) # Create a memoization dictionary to store the number of paths from each node to the end memo = {} def dfs(node): # If we reach the end server, there is one way to reach it if node == end: return 1 # If we have already computed the number of paths from this node, return it if node in memo: return memo[node] # Initialize count of paths count = 0 # Explore all the neighbors for neighbor in graph[node]: count += dfs(neighbor) # Memoize the result memo[node] = count return count return dfs(start)"},{"question":"def is_prime(n: int) -> bool: Check if a number is prime. >>> is_prime(2) True >>> is_prime(4) False pass def get_prime_numbers(lst: List[int]) -> List[int]: Returns a sublist containing only the prime numbers from the original list. >>> get_prime_numbers([]) [] >>> get_prime_numbers([4, 6, 8, 9, 10, 12]) [] >>> get_prime_numbers([2, 3, 5, 7, 11]) [2, 3, 5, 7, 11] >>> get_prime_numbers([10, 2, 3, 4, 5, 6]) [2, 3, 5] >>> get_prime_numbers([13]) [13] >>> get_prime_numbers([14]) [] pass","solution":"def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def get_prime_numbers(lst): Returns a sublist containing only the prime numbers from the original list. return [x for x in lst if is_prime(x)]"},{"question":"from typing import List def spiral_order(matrix: List[List[int]]) -> List[int]: Take an n x n matrix (a list of lists) of integers and return a list of integers representing the spiral order of the matrix. >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> spiral_order(matrix) [1, 2, 3, 6, 9, 8, 7, 4, 5] >>> matrix = [[1]] >>> spiral_order(matrix) [1] >>> matrix = [ ... [1, 2], ... [3, 4] ... ] >>> spiral_order(matrix) [1, 2, 4, 3]","solution":"from typing import List def spiral_order(matrix: List[List[int]]) -> List[int]: result = [] if not matrix or not matrix[0]: return result top, bottom, left, right = 0, len(matrix) - 1, 0, len(matrix[0]) - 1 while top <= bottom and left <= right: # Traverse from left to right for i in range(left, right + 1): result.append(matrix[top][i]) top += 1 # Traverse from top to bottom for i in range(top, bottom + 1): result.append(matrix[i][right]) right -= 1 if top <= bottom: # Traverse from right to left for i in range(right, left - 1, -1): result.append(matrix[bottom][i]) bottom -= 1 if left <= right: # Traverse from bottom to top for i in range(bottom, top - 1, -1): result.append(matrix[i][left]) left += 1 return result"},{"question":"def choose_move(board, player): Given a board state and the current player, returns the index of the best move (1-9). The board is a list of strings, where \\"\\" (empty string) indicates an empty cell. >>> choose_move([\\"X\\", \\"X\\", \\"\\", \\"O\\", \\"O\\", \\"\\", \\"\\", \\"\\", \\"\\"], \\"O\\") 6 >>> choose_move([\\"X\\", \\"\\", \\"O\\", \\"O\\", \\"O\\", \\"X\\", \\"X\\", \\"\\", \\"\\"], \\"O\\") 2 >>> choose_move([\\"X\\", \\"O\\", \\"X\\", \\"X\\", \\"O\\", \\"O\\", \\"\\", \\"\\", \\"\\"], \\"X\\") 7 >>> choose_move([\\"X\\", \\"X\\", \\"O\\", \\"O\\", \\"O\\", \\"X\\", \\"X\\", \\"\\", \\"O\\"], \\"X\\") 8 >>> choose_move([\\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\"], \\"X\\") 1","solution":"def choose_move(board, player): Given a board state and the current player, returns the index of the best move (1-9). The board is a list of strings, where \\"\\" (empty string) indicates an empty cell. # Function to check for a win def is_winner(board, player): win_conditions = [ [0, 1, 2], [3, 4, 5], [6, 7, 8], # horizontal wins [0, 3, 6], [1, 4, 7], [2, 5, 8], # vertical wins [0, 4, 8], [2, 4, 6] # diagonal wins ] for condition in win_conditions: if board[condition[0]] == board[condition[1]] == board[condition[2]] == player: return True return False # Function to find the best move def best_move(board, player): # Make a move and recurse to check the outcome for idx in range(9): if board[idx] == \\"\\": board[idx] = player if is_winner(board, player): return idx + 1 board[idx] = \\"\\" # Block opponent's winning move opponent = \\"O\\" if player == \\"X\\" else \\"X\\" for idx in range(9): if board[idx] == \\"\\": board[idx] = opponent if is_winner(board, opponent): board[idx] = \\"\\" return idx + 1 board[idx] = \\"\\" # Take the first empty cell for idx in range(9): if board[idx] == \\"\\": return idx + 1 return 0 return best_move(board, player)"},{"question":"from typing import List, Tuple def max_tasks_on_time(T: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]: Given a list of tasks with their deadlines and complexities, returns the maximum number of tasks that can be completed on time for each test case. Args: T (int): The number of test cases. test_cases (List[Tuple[int, List[Tuple[int, int]]]]): A list containing T test cases, where each test case is a tuple with the number of tasks (int) and a list of tuples (each tuple containing deadline and complexity of the task). Returns: List[int]: The maximum number of tasks that can be completed on time for each test case. >>> T = 2 >>> test_cases = [ ... (3, [(2, 1), (1, 2), (2, 3)]), ... (4, [(1, 3), (3, 2), (2, 4), (3, 1)]) ... ] >>> max_tasks_on_time(T, test_cases) [2, 3] pass","solution":"def max_tasks_on_time(T, test_cases): results = [] for i in range(T): n, tasks = test_cases[i] # Sort tasks by deadline, and by complexity in case of tie tasks_sorted = sorted(tasks, key=lambda x: (x[0], x[1])) completed_tasks = 0 days = [False] * (n + 1) for d, c in tasks_sorted: for j in range(min(n, d), 0, -1): if not days[j]: days[j] = True completed_tasks += 1 break results.append(completed_tasks) return results"},{"question":"from typing import List def is_anagram(str1: str, str2: str) -> bool: Determines if str1 is an anagram of str2. Ignores case and whitespace. Examples: >>> is_anagram('Listen', 'Silent') True >>> is_anagram('Hello', 'Olelh') True >>> is_anagram('Dormitory', 'Dirty room') True >>> is_anagram('The eyes', 'They see') True >>> is_anagram('Hello', 'World') False from typing import List def test_is_anagram_identical(): assert is_anagram('Listen', 'Silent') == True assert is_anagram('Hello', 'Olelh') == True def test_is_anagram_ignoring_whitespace(): assert is_anagram('Dormitory', 'Dirty room') == True assert is_anagram('The eyes', 'They see') == True def test_is_not_anagram(): assert is_anagram('Hello', 'World') == False def test_is_anagram_case_insensitive(): assert is_anagram('Astronomer', 'Moon starer') == True assert is_anagram('School master', 'The classroom') == True def test_is_anagram_with_varied_characters(): assert is_anagram('a gentleman', 'elegant man') == True assert is_anagram('Clint Eastwood', 'Old West Action') == True","solution":"def is_anagram(str1, str2): Determines if str1 is an anagram of str2. Ignores case and whitespace. # Normalize the strings by removing whitespace and converting to lowercase str1_normalized = ''.join(str1.split()).lower() str2_normalized = ''.join(str2.split()).lower() # Check if sorted versions of the normalized strings are equal return sorted(str1_normalized) == sorted(str2_normalized)"},{"question":"def compress_string(s: str) -> str: Compresses the given string by replacing groups of consecutive identical characters with the character followed by the count if greater than 1. Parameters: s (str): The input string consisting of lowercase alphabetical characters. Returns: str: The compressed version of the input string. Examples: >>> compress_string('aaabbc') 'a3b2c' >>> compress_string('aabbaa') 'a2b2a2' >>> compress_string('abcd') 'abcd' >>> compress_string('zzzz') 'z4'","solution":"def compress_string(s): Compresses the given string by replacing groups of consecutive identical characters with the character followed by the count if greater than 1. Parameters: s (str): The input string consisting of lowercase alphabetical characters. Returns: str: The compressed version of the input string. if not s: return \\"\\" compressed = [] count = 1 last_char = s[0] for char in s[1:]: if char == last_char: count += 1 else: if count > 1: compressed.append(f'{last_char}{count}') else: compressed.append(last_char) last_char = char count = 1 if count > 1: compressed.append(f'{last_char}{count}') else: compressed.append(last_char) return ''.join(compressed)"},{"question":"def find_pair_with_sum(arr: List[int], target: int) -> List[int]: Returns a pair of distinct integers from the array that sum up to the target. If no such pair exists, returns an empty list. >>> find_pair_with_sum([1, 2, 3, 4], 5) in [[1, 4], [4, 1], [2, 3], [3, 2]] True >>> find_pair_with_sum([1, 2, 3, 4], 10) [] >>> find_pair_with_sum([], 5) [] >>> find_pair_with_sum([1], 1) [] >>> find_pair_with_sum([1, 2, 3, 4, 6], 7) in [[1, 6], [6, 1], [3, 4], [4, 3]] True >>> find_pair_with_sum([-1, -2, -3, -4], -5) in [[-1, -4], [-4, -1], [-2, -3], [-3, -2]] True >>> find_pair_with_sum([0, 1, 2, 3], 3) in [[0, 3], [3, 0], [1, 2], [2, 1]] True","solution":"def find_pair_with_sum(arr, target): Returns a pair of distinct integers from the array that sum up to the target. If no such pair exists, returns an empty list. seen = set() for num in arr: complement = target - num if complement in seen: return [complement, num] seen.add(num) return []"},{"question":"def max_rob(nums: List[int]) -> int: Determine the maximum amount of money that can be robbed tonight without triggering the alarm. :param nums: List[int] - The amount of money in each house. :return: int - The maximum amount of money that can be robbed. >>> max_rob([2, 3, 2]) 3 >>> max_rob([1, 2, 3, 1]) 4 >>> max_rob([5]) 5 >>> max_rob([2, 3]) 3 >>> max_rob([3, 2]) 3 >>> max_rob([2, 7, 9, 3, 1]) 11 >>> max_rob([5, 3, 4, 11, 2]) 16 >>> max_rob([]) 0","solution":"def max_rob(nums): Determine the maximum amount of money that can be robbed tonight without triggering the alarm. :param nums: List[int] - The amount of money in each house. :return: int - The maximum amount of money that can be robbed. if not nums: return 0 if len(nums) == 1: return nums[0] if len(nums) == 2: return max(nums[0], nums[1]) def rob_linear(nums): prev1, prev2 = 0, 0 for num in nums: current = max(prev2 + num, prev1) prev2 = prev1 prev1 = current return prev1 return max(rob_linear(nums[:-1]), rob_linear(nums[1:]))"},{"question":"def run_length_encoding(s: str) -> str: Perform run-length encoding for a given string. Parameters: s (str): The input string containing uppercase English letters. Returns: str: The run-length encoded string. Examples: >>> run_length_encoding(\\"AAABBBCCDAA\\") 'A3B3C2DA2' >>> run_length_encoding(\\"XY\\") 'XY' >>> run_length_encoding(\\"AAB\\") 'A2B' pass # Test cases def test_run_length_encoding_basic(): assert run_length_encoding(\\"AAABBBCCDAA\\") == \\"A3B3C2DA2\\" assert run_length_encoding(\\"XY\\") == \\"XY\\" assert run_length_encoding(\\"AAB\\") == \\"A2B\\" def test_run_length_encoding_single_character(): assert run_length_encoding(\\"A\\") == \\"A\\" def test_run_length_encoding_repeated_character(): assert run_length_encoding(\\"AAAA\\") == \\"A4\\" def test_run_length_encoding_alternating_pattern(): assert run_length_encoding(\\"ABABAB\\") == \\"ABABAB\\" def test_run_length_encoding_long_string(): assert run_length_encoding(\\"A\\"*1000) == \\"A1000\\" assert run_length_encoding(\\"AB\\"*500) == \\"AB\\"*500 def test_run_length_encoding_mixed_patterns(): assert run_length_encoding(\\"AAABBCCCCDDDEEEE\\") == \\"A3B2C4D3E4\\" assert run_length_encoding(\\"ABCDE\\") == \\"ABCDE\\" assert run_length_encoding(\\"WWWWWWXXYYZZZZZ\\") == \\"W6X2Y2Z5\\" def test_run_length_encoding_edge_cases(): assert run_length_encoding(\\"\\") == \\"\\" assert run_length_encoding(\\"Z\\") == \\"Z\\" assert run_length_encoding(\\"ZZZZZZZZZZZAA\\") == \\"Z11A2\\"","solution":"def run_length_encoding(s): Perform run-length encoding for a given string. Parameters: s (str): The input string containing uppercase English letters. Returns: str: The run-length encoded string. if not s: return \\"\\" encoded_string = [] count = 1 previous_char = s[0] for char in s[1:]: if char == previous_char: count += 1 else: encoded_string.append(previous_char) if count > 1: encoded_string.append(str(count)) previous_char = char count = 1 encoded_string.append(previous_char) if count > 1: encoded_string.append(str(count)) return \\"\\".join(encoded_string)"},{"question":"def max_profit(prices: List[int]) -> int: Given an array of positive integers representing the prices of a stock on different days, find the maximum profit that can be made by completing at most one transaction (buy one and sell one share of the stock). You cannot sell a stock before you buy one. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 >>> max_profit([5, 5, 5, 5, 5]) 0 >>> max_profit([10]) 0 >>> max_profit([1, 2, 3, 4, 5]) 4 >>> max_profit([10, 9, 8, 7, 6, 10]) 4 >>> max_profit([1, 2, 3, 4, 5, 3, 6]) 5 >>> max_profit([]) 0","solution":"def max_profit(prices): Returns the maximum profit that can be made by completing at most one transaction. if not prices or len(prices) < 2: return 0 min_price = prices[0] max_profit = 0 for price in prices: min_price = min(min_price, price) max_profit = max(max_profit, price - min_price) return max_profit"},{"question":"from collections import Counter from typing import List def perform_operations(M: int, operations: List[str]) -> List[str]: Perform update, subtract, and most_common methods on a Counter c. Args: M: int - the number of operations operations: List[str] - a list of operations to perform Returns: List[str] - results of the most_common method calls Examples: >>> perform_operations(5, [\\"update gallahad\\", \\"update aaaaa\\", \\"subtract aag\\", \\"most_common 3\\", \\"subtract had\\"]) [\\"a 6 l 2 h 1\\"] >>> perform_operations(1, [\\"update abcabc\\"]) [] >>> perform_operations(4, [\\"update gallahad\\", \\"most_common 1\\", \\"update aaaaa\\", \\"most_common 2\\"]) [\\"a 3\\", \\"a 8 l 2\\"]","solution":"from collections import Counter def perform_operations(M, operations): c = Counter() result = [] for operation in operations: op = operation.split() if op[0] == 'update': c.update(op[1]) elif op[0] == 'subtract': c.subtract(op[1]) elif op[0] == 'most_common': most_common_elements = c.most_common(int(op[1])) result.append(' '.join(f\\"{elem} {count}\\" for elem, count in most_common_elements)) return result"},{"question":"def is_valid_ipv4(ip: str) -> bool: Validates if the input string is a valid IPv4 address. Each octet must be between 0 and 255, and not contain leading zeros. >>> is_valid_ipv4(\\"192.168.1.1\\") == True >>> is_valid_ipv4(\\"256.256.256.256\\") == False >>> is_valid_ipv4(\\"192.168.01.1\\") == False >>> is_valid_ipv4(\\"192.168.1\\") == False >>> is_valid_ipv4(\\"192.168.1.abc\\") == False","solution":"def is_valid_ipv4(ip): Validates if the input string is a valid IPv4 address. # Strip any surrounding whitespace ip = ip.strip() # Split the IP address by dot parts = ip.split(\\".\\") # IPv4 must have exactly 4 parts if len(parts) != 4: return False for part in parts: # Each part must be digits only and not empty if not part.isdigit() or not part: return False # Convert part to integer num = int(part) # Each part must be in range [0, 255] if num < 0 or num > 255: return False # No leading zeros allowed in parts, except part == '0' if part != str(num): return False return True"},{"question":"def max_sum_after_one_swap(n: int, array: List[int]) -> int: Given an array of N integers, finds the maximum sum of the array possible after performing exactly one swap of two adjacent elements. Args: n (int): The number of integers in the array. array (List[int]): The list of integers. Returns: int: The maximum sum of the array possible after one swap of adjacent elements. Example: >>> max_sum_after_one_swap(4, [1, 2, 4, 3]) 10 from typing import List def test_basic_case(): assert max_sum_after_one_swap(4, [1, 2, 4, 3]) == 10 def test_sorted_array(): assert max_sum_after_one_swap(5, [1, 2, 3, 4, 5]) == 15 def test_reverse_sorted_array(): assert max_sum_after_one_swap(5, [5, 4, 3, 2, 1]) == 15 def test_all_identical_elements(): assert max_sum_after_one_swap(3, [2, 2, 2]) == 6 def test_mixed_positive_and_negative(): assert max_sum_after_one_swap(4, [1, -2, 3, 4]) == 6 def test_large_range(): assert max_sum_after_one_swap(4, [-1000000000, 1000000000, -1000000000, 1000000000]) == 0 def test_single_swap_case(): assert max_sum_after_one_swap(2, [1, 2]) == 3 def test_with_negatives(): assert max_sum_after_one_swap(4, [-1, -2, -3, -4]) == -10","solution":"def max_sum_after_one_swap(n, array): Given an array of N integers, finds the maximum sum of the array possible after performing exactly one swap of two adjacent elements. total_sum = sum(array) max_sum = total_sum for i in range(n - 1): swapped_array = array[:] # Perform the swap between the elements at positions i and i+1 swapped_array[i], swapped_array[i + 1] = swapped_array[i + 1], swapped_array[i] # Calculate new sum and update max_sum if needed current_sum = sum(swapped_array) if current_sum > max_sum: max_sum = current_sum return max_sum # Example usage: # n = 4 # array = [1, 2, 4, 3] # print(max_sum_after_one_swap(n, array)) # Output : 10"},{"question":"def kth_smallest_in_spygrid(N, M, K): Returns the K-th smallest element in a Spygrid with N rows and M columns. If K is larger than N * M, returns -1. def process_test_cases(test_cases): Given a list of test cases (each test case being a tuple (N, M, K)), returns a list of results for each test case. def test_kth_smallest_in_spygrid(): assert kth_smallest_in_spygrid(3, 3, 4) == 3 assert kth_smallest_in_spygrid(4, 5, 6) == 4 assert kth_smallest_in_spygrid(2, 2, 5) == -1 assert kth_smallest_in_spygrid(3, 3, 9) == 9 assert kth_smallest_in_spygrid(1, 1, 1) == 1 assert kth_smallest_in_spygrid(1, 1, 2) == -1 assert kth_smallest_in_spygrid(10, 10, 1) == 1 assert kth_smallest_in_spygrid(10, 10, 100) == 100 assert kth_smallest_in_spygrid(1000, 1000, 1000000) == 1000000 assert kth_smallest_in_spygrid(1000, 1000, 1) == 1 def test_process_test_cases(): assert process_test_cases([(3, 3, 4), (4, 5, 6), (2, 2, 5)]) == [3, 4, -1] assert process_test_cases([(1, 1, 1), (10, 10, 1), (1000, 1000, 1000000)]) == [1, 1, 1000000] assert process_test_cases([(3, 3, 9)]) == [9]","solution":"def kth_smallest_in_spygrid(N, M, K): Returns the K-th smallest element in a Spygrid with N rows and M columns. If K is larger than N * M, returns -1. if K > N * M: return -1 def count_less_equal(x): # Count the number of elements less than or equal to x in the Spygrid count = 0 for i in range(1, N + 1): count += min(x // i, M) return count left, right = 1, N * M while left < right: mid = (left + right) // 2 if count_less_equal(mid) < K: left = mid + 1 else: right = mid return left def process_test_cases(test_cases): results = [] for N, M, K in test_cases: results.append(kth_smallest_in_spygrid(N, M, K)) return results"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Given an array of integers, return an array containing the product of all elements except the one at each index. You must not use the division operation to solve this problem. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([-1, 1, 0, -3, 3]) [0, 0, 9, 0, 0] from solution import product_except_self def test_product_except_self_with_positive_numbers(): assert product_except_self([1, 2, 3, 4]) == [24, 12, 8, 6] def test_product_except_self_with_negative_and_zero(): assert product_except_self([-1, 1, 0, -3, 3]) == [0, 0, 9, 0, 0] def test_product_except_self_with_single_element(): assert product_except_self([5]) == [1] def test_product_except_self_with_all_zeroes(): assert product_except_self([0, 0, 0, 0]) == [0, 0, 0, 0] def test_product_except_self_with_mixed_sign_numbers(): assert product_except_self([-1, 2, -3, 4]) == [-24, 12, -8, 6] def test_product_except_self_with_large_numbers(): assert product_except_self([10000, 20000, 30000, 40000]) == [24000000000000, 12000000000000, 8000000000000, 6000000000000]","solution":"def product_except_self(nums): Returns an array such that each element at index 'i' is the product of all the elements of nums except nums[i], without using division. length = len(nums) # Initialize the output array with 1s output = [1] * length # Calculate the prefix product for each element prefix = 1 for i in range(length): output[i] = prefix prefix *= nums[i] # Calculate the postfix product for each element postfix = 1 for i in range(length - 1, -1, -1): output[i] *= postfix postfix *= nums[i] return output"},{"question":"def find_median(numbers: List[int]) -> float: Find the median of a list of integers. If the list has an even number of elements, return the average of the two middle numbers. >>> find_median([1, 3, 2]) 2 >>> find_median([1, 2, 3, 4]) 2.5 >>> find_median([1]) 1 >>> find_median([1, 2]) 1.5 >>> find_median([1, 2, 2, 3, 4]) 2 pass","solution":"def find_median(numbers): This function returns the median of a list of integers. If the list length is even, it returns the average of the two middle numbers. numbers_sorted = sorted(numbers) n = len(numbers_sorted) if n % 2 == 1: return numbers_sorted[n // 2] else: mid1 = numbers_sorted[n // 2 - 1] mid2 = numbers_sorted[n // 2] return (mid1 + mid2) / 2.0"},{"question":"def flatten(d: dict) -> dict: Flatten a nested dictionary. The keys of the nested dictionaries will be concatenated with a period. Args: - d (dict): The dictionary to flatten. Returns: - dict: The flattened dictionary. >>> flatten({\\"a\\": 1, \\"b\\": {\\"c\\": 2, \\"d\\": {\\"e\\": 3, \\"f\\": 4}}}) == {\\"a\\": 1, \\"b.c\\": 2, \\"b.d.e\\": 3, \\"b.d.f\\": 4} >>> flatten({\\"key\\": {\\"key\\": {\\"key\\": 5}}}) == {\\"key.key.key\\": 5} >>> flatten({\\"a\\": 1, \\"b\\": 2}) == {\\"a\\": 1, \\"b\\": 2} >>> flatten({\\"nested\\": {\\"dict\\": {\\"is\\": {\\"complex\\": 42}}}}) == {\\"nested.dict.is.complex\\": 42} >>> flatten({}) == {} >>> flatten({\\"a\\": 1, \\"b\\": {\\"c\\": 2, \\"d\\": [3, 4, 5]}, \\"e\\": {\\"f\\": {\\"g\\": \\"h\\"}}}) == {\\"a\\": 1, \\"b.c\\": 2, \\"b.d\\": [3, 4, 5], \\"e.f.g\\": \\"h\\"}","solution":"def flatten(d: dict, parent_key: str = '', sep: str = '.') -> dict: Flattens a nested dictionary. The keys of the nested dictionaries will be concatenated with a period. Args: - d (dict): The dictionary to flatten. - parent_key (str): The base key string for recursion. Defaults to ''. - sep (str): The separator to use between keys. Defaults to '.'. Returns: - dict: The flattened dictionary. items = {} for k, v in d.items(): new_key = f\\"{parent_key}{sep}{k}\\" if parent_key else k if isinstance(v, dict): items.update(flatten(v, new_key, sep=sep)) else: items[new_key] = v return items"},{"question":"from typing import List def merge(arr, left, mid, right): Helper function to merge two sorted halves of an array. Arguments: arr : List[int] -- The input array containing two sorted halves. left : int -- The starting index of the left half. mid : int -- The ending index of the left half. right : int -- The ending index of the right half. pass def iterative_merge_sort(arr: List[int]) -> List[int]: Efficiently sorts an array with length that is a power of 2 in ascending order by implementing an iterative merge sort. Args: arr : List[int] -- The input array to be sorted. Returns: List[int] -- The sorted array. Examples: >>> iterative_merge_sort([4, 3, 2, 1]) [1, 2, 3, 4] >>> iterative_merge_sort([10, -1, 2, 3, 0, 5, 6, -2]) [-2, -1, 0, 2, 3, 5, 6, 10] pass","solution":"from typing import List def merge(arr, left, mid, right): n1 = mid - left + 1 n2 = right - mid # Create temporary arrays L = arr[left:left + n1] R = arr[mid + 1:mid + 1 + n2] i, j, k = 0, 0, left while i < n1 and j < n2: if L[i] <= R[j]: arr[k] = L[i] i += 1 else: arr[k] = R[j] j += 1 k += 1 while i < n1: arr[k] = L[i] i += 1 k += 1 while j < n2: arr[k] = R[j] j += 1 k += 1 def iterative_merge_sort(arr: List[int]) -> List[int]: n = len(arr) curr_size = 1 while curr_size < n: left_start = 0 while left_start < n-1: mid = min((left_start + curr_size - 1), (n-1)) right_end = min((left_start + 2 * curr_size - 1), (n-1)) merge(arr, left_start, mid, right_end) left_start += 2 * curr_size curr_size *= 2 return arr"},{"question":"def longest_common_subsequence(S1: str, S2: str) -> int: Returns the length of the longest common subsequence of S1 and S2. >>> longest_common_subsequence(\\"abcdef\\", \\"acdfgh\\") 4 >>> longest_common_subsequence(\\"abcde\\", \\"ace\\") 3 >>> longest_common_subsequence(\\"abcd\\", \\"efgh\\") 0 >>> longest_common_subsequence(\\"abc\\", \\"abc\\") 3 >>> longest_common_subsequence(\\"a\\", \\"a\\") 1 >>> longest_common_subsequence(\\"\\", \\"abcdef\\") 0 >>> longest_common_subsequence(\\"abcdef\\", \\"\\") 0 >>> longest_common_subsequence(\\"\\", \\"\\") 0","solution":"def longest_common_subsequence(S1, S2): Returns the length of the longest common subsequence of S1 and S2. n = len(S1) m = len(S2) # Create a DP table with (n+1) x (m+1) dimensions dp = [[0] * (m+1) for _ in range(n+1)] # Fill the DP table for i in range(1, n+1): for j in range(1, m+1): if S1[i-1] == S2[j-1]: dp[i][j] = dp[i-1][j-1] + 1 else: dp[i][j] = max(dp[i-1][j], dp[i][j-1]) # The length of the longest common subsequence will be in dp[n][m] return dp[n][m]"},{"question":"def single_number(nums: List[int]) -> int: Find the single element in the array where every element appears twice except for one. Use XOR operation which has a property where a XOR a = 0 and a XOR 0 = a. >>> single_number([4,1,2,1,2]) 4 >>> single_number([1]) 1 >>> single_number([-1, -1, -2]) -2 >>> single_number([1, 2, 3, 4, 1, 2, 3]) 4 >>> single_number([10, 10, 1, 2, 2]) 1 >>> single_number([5, 6, 7, 8, 6, 7, 8]) 5","solution":"def single_number(nums): Find the single element in the array where every element appears twice except for one. Use XOR operation which has a property where a XOR a = 0 and a XOR 0 = a. result = 0 for num in nums: result ^= num return result"},{"question":"def handle_operations(n: int, operations: List[str]) -> List[int]: Perform a series of operations on a list of integers, including adding to sublists and retrieving maximums from sublists. Args: n (int): The number of operations to perform. operations (List[str]): A list of operations in the following format: - '1 x y': Add integer y to each element in the sublist starting from the start up to the xth index (1-indexed). - '2 l r': Retrieve the maximum integer in the sublist from the lth index to the rth index (1-indexed). Returns: List[int]: The results of '2 l r' operations. from typing import List def test_handle_operations_basic(): n = 5 operations = [ \\"1 3 5\\", \\"1 5 10\\", \\"2 1 3\\", \\"2 1 5\\", \\"2 4 5\\" ] result = handle_operations(n, operations) assert result == [15, 15, 10] def test_handle_operations_single_addition(): n = 1 operations = [\\"1 2 4\\"] result = handle_operations(n, operations) assert result == [] def test_handle_operations_single_query(): n = 2 operations = [\\"1 5 3\\", \\"2 1 5\\"] result = handle_operations(n, operations) assert result == [3] def test_handle_operations_no_operations(): n = 0 operations = [] result = handle_operations(n, operations) assert result == [] def test_handle_operations_multiple_add_query(): n = 6 operations = [ \\"1 2 4\\", \\"1 3 2\\", \\"2 1 2\\", \\"2 2 3\\", \\"1 4 1\\", \\"2 1 4\\" ] result = handle_operations(n, operations) assert result == [6, 6, 7] def test_handle_operations_empty_on_query_range(): n = 4 operations = [ \\"1 2 4\\", \\"1 1 3\\", \\"2 3 5\\", \\"2 1 1\\" ] result = handle_operations(n, operations) assert result == [float('-inf'), 7]","solution":"def handle_operations(n, operations): arr = [] results = [] for operation in operations: op = operation.split() type_op = int(op[0]) if type_op == 1: # Addition operation x = int(op[1]) y = int(op[2]) # Extend the list if necessary while len(arr) < x: arr.append(0) for i in range(x): arr[i] += y elif type_op == 2: # Retrieve maximum operation l = int(op[1]) - 1 r = int(op[2]) if l < len(arr): max_val = max(arr[l:r]) else: max_val = float('-inf') results.append(max_val) return results"},{"question":"def products(nums: List[int]) -> List[int]: Returns a new list where each element is the product of all the numbers in the original list except for the number at that position. >>> products([1, 2, 3, 4]) == [24, 12, 8, 6] >>> products([0, 1, 2, 3, 4]) == [24, 0, 0, 0, 0]","solution":"def products(nums): Returns a new list where each element is the product of all the numbers in the original list except for the number at that position. n = len(nums) if n == 0: return [] left_products = [1] * n right_products = [1] * n result = [1] * n for i in range(1, n): left_products[i] = left_products[i - 1] * nums[i - 1] for i in range(n - 2, -1, -1): right_products[i] = right_products[i + 1] * nums[i + 1] for i in range(n): result[i] = left_products[i] * right_products[i] return result"},{"question":"def wordBreakCount(s: str, wordDict: List[str]) -> int: Returns the total number of ways the string \`s\` can be segmented into a space-separated sequence of one or more dictionary words from \`wordDict\`. >>> wordBreakCount(\\"catsanddog\\", [\\"cat\\", \\"cats\\", \\"and\\", \\"sand\\", \\"dog\\"]) == 2 >>> wordBreakCount(\\"pineapplepenapple\\", [\\"apple\\", \\"pen\\", \\"applepen\\", \\"pine\\", \\"pineapple\\"]) == 3 >>> wordBreakCount(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) == 0 >>> wordBreakCount(\\"\\", [\\"a\\", \\"b\\", \\"c\\"]) == 1 >>> wordBreakCount(\\"abcdef\\", [\\"ab\\", \\"cd\\", \\"ef\\"]) == 1 >>> wordBreakCount(\\"a\\" * 100 + \\"b\\", [\\"a\\", \\"aa\\", \\"aaa\\", \\"aaaa\\", \\"a\\" * 100]) == 0","solution":"def wordBreakCount(s, wordDict): Returns the total number of ways the string \`s\` can be segmented into a space-separated sequence of one or more dictionary words from \`wordDict\`. wordSet = set(wordDict) memo = {} def helper(substring): if substring in memo: return memo[substring] if not substring: return 1 ways = 0 for i in range(1, len(substring) + 1): if substring[:i] in wordSet: ways += helper(substring[i:]) memo[substring] = ways return ways return helper(s)"},{"question":"def sort_groceries(groceries: Dict[str, int]) -> List[Tuple[str, int]]: Sorts a dictionary of grocery items by quantity in descending order, and by name in ascending order if quantities are the same. Args: groceries (dict): A dictionary representing the grocery items and their quantities. Returns: list: A list of tuples sorted by quantity (descending) and name (ascending). Example: >>> sort_groceries({'apples': 5, 'bananas': 7, 'oranges': 5}) [('bananas', 7), ('apples', 5), ('oranges', 5)] >>> sort_groceries({'apples': 0, 'bananas': 0, 'oranges': 2}) [('oranges', 2), ('apples', 0), ('bananas', 0)] from typing import Dict, List, Tuple","solution":"def sort_groceries(groceries): Sorts a dictionary of grocery items by quantity in descending order, and by name in ascending order if quantities are the same. Args: groceries (dict): A dictionary representing the grocery items and their quantities. Returns: list: A list of tuples sorted by quantity (descending) and name (ascending). return sorted(groceries.items(), key=lambda item: (-item[1], item[0]))"},{"question":"from typing import List def isToeplitzMatrix(matrix: List[List[int]]) -> bool: Returns True if the given matrix is a Toeplitz matrix, otherwise False. A matrix is a Toeplitz matrix if every diagonal from top-left to bottom-right has the same elements. >>> isToeplitzMatrix([ [1, 2, 3, 4], [5, 1, 2, 3], [9, 5, 1, 2] ]) True >>> isToeplitzMatrix([ [1, 2, 3, 4], [5, 1, 9, 3], [9, 5, 1, 2] ]) False >>> isToeplitzMatrix([ [5] ]) True >>> isToeplitzMatrix([ [1, 2, 3, 4] ]) True >>> isToeplitzMatrix([ [1], [2], [3], [4] ]) True >>> isToeplitzMatrix([]) False >>> isToeplitzMatrix([ [1, 2, 3], [4, 1, 5], [6, 4, 1] ]) False >>> isToeplitzMatrix([ [3, 7, 0, 9, 8], [9, 3, 7, 0, 9], [5, 9, 3, 7, 0], [1, 5, 9, 3, 7], [2, 1, 5, 9, 3] ]) True","solution":"from typing import List def isToeplitzMatrix(matrix: List[List[int]]) -> bool: Returns True if the given matrix is a Toeplitz matrix, otherwise False. A matrix is a Toeplitz matrix if every diagonal from top-left to bottom-right has the same elements. if not matrix or not matrix[0]: return False rows = len(matrix) cols = len(matrix[0]) for row in range(1, rows): for col in range(1, cols): if matrix[row][col] != matrix[row - 1][col - 1]: return False return True"},{"question":"def find_shortest_word_length(s: str) -> int: Returns the length of the shortest word in the string s. A word is defined as a contiguous string of alphabetic characters. >>> find_shortest_word_length(\\"The quick brown fox jumps over the lazy dog\\") 3 >>> find_shortest_word_length(\\"A journey of a thousand miles begins with a single step\\") 1 >>> find_shortest_word_length(\\"Do or do not. There is no try!\\") 2 >>> find_shortest_word_length(\\"ThE QuiCk BRowN FoX\\") 3 >>> find_shortest_word_length(\\"Hello, world! This is a test.\\") 1 >>> find_shortest_word_length(\\"dog cat rat bat\\") 3 >>> find_shortest_word_length(\\"\\") 0 >>> find_shortest_word_length(\\"1234 5678 90!@#\\") 0","solution":"def find_shortest_word_length(s: str) -> int: Returns the length of the shortest word in the string s. A word is defined as a contiguous string of alphabetic characters. import re # Find all words in the string words = re.findall(r'b[a-zA-Z]+b', s.lower()) # If there are words, return the length of the shortest one if words: return min(len(word) for word in words) # In case there are no words, return 0 return 0"},{"question":"def max_difference(arr) -> int: Returns the maximum difference between any two elements in the array such that the larger element comes after the smaller one. If the array contains fewer than two elements, return -1. >>> max_difference([7, 1, 2, 5]) == 4 >>> max_difference([7, 5, 3, 1]) == -1 >>> max_difference([1, 2, 6, 4, 5, 2]) == 5","solution":"def max_difference(arr): Returns the maximum difference between any two elements in the array such that the larger element comes after the smaller one. If the array contains fewer than two elements, return -1. if len(arr) < 2: return -1 min_element = arr[0] max_diff = -1 for i in range(1, len(arr)): if arr[i] > min_element: max_diff = max(max_diff, arr[i] - min_element) min_element = min(min_element, arr[i]) return max_diff"},{"question":"def can_sum(arr: List[int], k: int) -> bool: Given an array of positive integers and a target number \`k\`, determine whether there's a combination of elements in the array that sums up to \`k\`. The same element from the array can be used multiple times. >>> can_sum([2, 3, 5], 8) True >>> can_sum([3, 5, 7], 1) False >>> can_sum([7, 14], 300) False >>> can_sum([5, 3, 4, 7], 7) True >>> can_sum([2, 4], 7) False","solution":"def can_sum(arr, k): Returns True if a combination of elements from the array can sum up to k, otherwise False. Elements can be used multiple times. dp = [False] * (k + 1) dp[0] = True for i in range(k + 1): if dp[i]: for num in arr: if i + num <= k: dp[i + num] = True return dp[k]"},{"question":"def nearest_larger(arr: List[int], n: int) -> int: Returns the smallest integer in arr that is larger than n. If no such integer exists, returns -1. >>> nearest_larger([1, 4, 6, 8, 9], 5) == 6 >>> nearest_larger([3, 10, 2, 8, 15], 10) == 15 >>> nearest_larger([3, 7, 5, 9], 9) == -1 >>> nearest_larger([2, 7, 3, 5], 1) == 2","solution":"def nearest_larger(arr, n): Returns the smallest integer in arr that is larger than n. If no such integer exists, returns -1. larger_elements = [x for x in arr if x > n] return min(larger_elements) if larger_elements else -1"},{"question":"def get_primes_desc(numbers: list) -> list: Takes a list of integers and returns a list of all the prime numbers from the original list, arranged in descending order. If no primes are found, returns an empty list. >>> get_primes_desc([3, 6, 7, 10, 13, 15]) == [13, 7, 3] >>> get_primes_desc([4, 6, 8, 10, 12]) == [] >>> get_primes_desc([5, 11, 2, 19, 17]) == [19, 17, 11, 5, 2] >>> get_primes_desc([31, 23, 29, 37, 3]) == [37, 31, 29, 23, 3]","solution":"def get_primes_desc(numbers: list) -> list: def is_prime(n): if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n ** 0.5) + 1, 2): if n % i == 0: return False return True primes = [num for num in numbers if is_prime(num)] primes.sort(reverse=True) return primes"},{"question":"def max_sum_subarray_k(arr: List[int], k: int) -> int: Write a function that takes a list of integers and an integer \`k\`, and returns the maximum sum of any contiguous subarray of length \`k\`. >>> max_sum_subarray_k([1, 2, 3, 4, 5], 2) == 9 >>> max_sum_subarray_k([2, 1, 5, 1, 3, 2], 3) == 9 >>> max_sum_subarray_k([2, 1, 5, 1, 3, 2], 4) == 11","solution":"def max_sum_subarray_k(arr, k): Returns the maximum sum of any contiguous subarray of length \`k\`. if not arr or k > len(arr): return 0 # Initialize the maximum sum with the first subarray of length k max_sum = sum(arr[:k]) current_sum = max_sum # Use sliding window approach to find the maximum sum for i in range(k, len(arr)): current_sum = current_sum + arr[i] - arr[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def min_operations_to_make_same(T: int, test_cases: List[str]) -> List[int]: You are given a string \`S\` of length \`N\` consisting of characters 'a' and 'b' only. Your task is to make all characters of the string the same, i.e., either all 'a' or all 'b'. The only operation you can perform is to choose any substring of the string and flip all characters within the chosen substring (changing 'a' to 'b' and 'b' to 'a'). Write a function that returns the minimum number of operations required to make all characters of the string the same. -----Input section----- - First line contains an integer \`T\`, denoting the number of test cases. - Each of the next \`T\` lines contains a string \`S\` of length \`N\`. -----Output section----- For each test case, print the minimum number of operations required. -----Input constraints----- 1 ≤ T ≤ 10 1 ≤ N ≤ 1000 S consists of characters 'a' and 'b' only. >>> min_operations_to_make_same(3, ['ab', 'aaab', 'abab']) [1, 1, 2] >>> min_operations_to_make_same(2, ['aaaa', 'bbbb']) [0, 0] >>> min_operations_to_make_same(1, ['abababab']) [4] >>> min_operations_to_make_same(2, ['a', 'b']) [0, 0] >>> min_operations_to_make_same(1, ['aabbaabb']) [2]","solution":"def min_operations_to_make_same(T, test_cases): results = [] for S in test_cases: changes_a = 0 changes_b = 0 current = S[0] if current == 'a': changes_b += 1 else: changes_a += 1 for i in range(1, len(S)): if S[i] != current: current = S[i] if current == 'a': changes_b += 1 else: changes_a += 1 results.append(min(changes_a, changes_b)) return results"},{"question":"def products_above_threshold(test_cases): Given test cases consisting of product quantities and threshold queries, determine the number of products that exceed each threshold. Args: test_cases (List[Tuple[int, List[int], int, List[int]]]): A list of test cases where each test case is a tuple: N (int): Number of products. quantities (List[int]): Quantities of the products. Q (int): Number of queries. queries (List[int]): List of threshold queries. Returns: List[int]: A list of results for each query in all test cases, indicating the count of products with quantities above each threshold. Example: test_cases = [(5, [10, 20, 15, 5, 30], 3, [10, 15, 25])] results = products_above_threshold(test_cases) assert results == [3, 2, 1] pass def binary_search(arr, x): Perform a binary search to find the position where the value x would be inserted to maintain sorted order. Args: arr (List[int]): A sorted list of integers. x (int): The threshold value for which the insert position is being sought. Returns: int: The position where x would be inserted in the sorted list. Example: arr = [5, 10, 15, 20, 30] assert binary_search(arr, 10) == 2 assert binary_search(arr, 15) == 3 assert binary_search(arr, 25) == 4 pass def parse_input(input_string): Parse the input string to extract the structured test cases. Args: input_string (str): Input string in the specified format. Returns: List[Tuple[int, List[int], int, List[int]]]: Parsed list of test cases. Example: input_string = \\"1n5n10 20 15 5 30n3n10 15 25\\" test_cases = parse_input(input_string) assert test_cases == [(5, [10, 20, 15, 5, 30], 3, [10, 15, 25])] pass","solution":"def products_above_threshold(test_cases): results = [] for test_case in test_cases: N, quantities, Q, queries = test_case quantities.sort() for threshold in queries: count = len(quantities) - binary_search(quantities, threshold) results.append(count) return results def binary_search(arr, x): low, high = 0, len(arr) while low < high: mid = (low + high) // 2 if arr[mid] <= x: low = mid + 1 else: high = mid return low def parse_input(input_string): data = input_string.strip().split() index = 0 T = int(data[index]) index += 1 test_cases = [] for _ in range(T): N = int(data[index]) index += 1 quantities = list(map(int, data[index:index+N])) index += N Q = int(data[index]) index += 1 queries = list(map(int, data[index:index+Q])) index += Q test_cases.append((N, quantities, Q, queries)) return test_cases"},{"question":"def matrix_sum_queries(matrix: List[List[int]], queries: List[Tuple[int, int, int, int]]) -> List[int]: This function processes the sum queries for the given matrix. Args: matrix (List[List[int]]): The input rectangular matrix. queries (List[Tuple[int, int, int, int]]): The list of queries where each query is (x1, y1, x2, y2). Returns: List[int]: The list of sums for each query. ... # Example usage matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12] ] queries = [ (1, 1, 2, 2), (2, 3, 3, 4) ] results = matrix_sum_queries(matrix, queries) for res in results: print(res) # Expected output: [14, 36] # Unit Tests def test_single_element_matrix(): matrix = [[5]] queries = [(1, 1, 1, 1)] assert matrix_sum_queries(matrix, queries) == [5] def test_small_matrix(): matrix = [ [1, 2], [3, 4] ] queries = [ (1, 1, 1, 1), (1, 1, 2, 2), (1, 2, 2, 2), (2, 1, 2, 2) ] assert matrix_sum_queries(matrix, queries) == [1, 10, 6, 7] def test_large_query(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] queries = [ (1, 1, 3, 3) ] assert matrix_sum_queries(matrix, queries) == [45] def test_edge_queries(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] queries = [ (1, 1, 2, 2), (2, 2, 3, 3), (3, 1, 3, 3) ] assert matrix_sum_queries(matrix, queries) == [12, 28, 24] def test_negative_numbers(): matrix = [ [-1, -2, -3], [-4, -5, -6], [-7, -8, -9] ] queries = [ (1, 1, 2, 2), (2, 2, 3, 3), (1, 1, 3, 3) ] assert matrix_sum_queries(matrix, queries) == [-12, -28, -45]","solution":"def matrix_sum_queries(matrix, queries): This function processes the sum queries for the given matrix. Args: matrix (List[List[int]]): The input rectangular matrix. queries (List[Tuple[int, int, int, int]]): The list of queries where each query is (x1, y1, x2, y2). Returns: List[int]: The list of sums for each query. N = len(matrix) M = len(matrix[0]) # Precompute the prefix sums prefix_sum = [[0] * (M + 1) for _ in range(N + 1)] for i in range(1, N + 1): for j in range(1, M + 1): prefix_sum[i][j] = (matrix[i-1][j-1] + prefix_sum[i-1][j] + prefix_sum[i][j-1] - prefix_sum[i-1][j-1]) result = [] for x1, y1, x2, y2 in queries: # Calculate the sum for the sub-matrix using prefix sums sub_matrix_sum = (prefix_sum[x2][y2] - prefix_sum[x1-1][y2] - prefix_sum[x2][y1-1] + prefix_sum[x1-1][y1-1]) result.append(sub_matrix_sum) return result # Example usage: # N = 3, M = 4, matrix as provided in the example matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12] ] queries = [ (1, 1, 2, 2), (2, 3, 3, 4) ] results = matrix_sum_queries(matrix, queries) for res in results: print(res) # Expected output: [14, 36]"},{"question":"def find_peak_element(nums: List[int]) -> int: Finds the index of a peak element in an array. A peak element in an array is an element that is greater than its neighbors. Given an array of integers, find the index of any one of its peak elements. The array may contain multiple peaks, and you are required to return the index of any one of such peaks. >>> find_peak_element([1, 3, 20, 4, 1, 0]) in {2, 3} True >>> find_peak_element([10, 20, 15, 2, 23, 90, 67]) in {1, 5} True >>> find_peak_element([1, 2, 3, 4, 5]) 4 >>> find_peak_element([5, 4, 3, 2, 1]) 0 >>> find_peak_element([1]) 0","solution":"def find_peak_element(nums): Finds the index of a peak element in an array. n = len(nums) # If there's only one element, it's a peak if n == 1: return 0 start, end = 0, n - 1 while start < end: mid = (start + end) // 2 if nums[mid] < nums[mid + 1]: start = mid + 1 else: end = mid return start"},{"question":"from typing import List def unique_abs_values(arr: List[int]) -> int: Given a list of integers, returns the number of unique absolute values present in the list. Args: arr (List[int]): A list of integers. Returns: int: The number of unique absolute values. Examples: >>> unique_abs_values([-1, -2, -3, -4]) 4 >>> unique_abs_values([1, 2, 3, 4]) 4 >>> unique_abs_values([1, -1, 2, -2, 3, -3]) 3 >>> unique_abs_values([0, -1, 1, -2, 2]) 3 >>> unique_abs_values([-1000000, 1000000, -999999, 999999]) 2 >>> unique_abs_values([1, -1, 1, -1, 1]) 1 pass","solution":"def unique_abs_values(arr): Given a list of integers, returns the number of unique absolute values present in the list. return len(set(abs(x) for x in arr))"},{"question":"def min_moves_to_collect_treasures(N: int, a: List[int]) -> int: Returns the minimum number of moves required to collect all the treasures on the map. Args: N (int): The number of locations. a (List[int]): The number of treasures at each location. Returns: int: The minimum number of moves required to collect all treasures. Examples: >>> min_moves_to_collect_treasures(5, [1, 2, 0, 3, 4]) 3","solution":"def min_moves_to_collect_treasures(N, a): Returns the minimum number of moves required to collect all the treasures on the map. moves = 0 i = 0 while i < N: if a[i] > 0: moves += 1 while i < N and a[i] > 0: i += 1 else: i += 1 return moves"},{"question":"def min_transformations(S: str, T: str) -> int: Determine the minimum number of transformations needed to convert the string S into the string T. >>> min_transformations(\\"abc\\", \\"bcd\\") 1 >>> min_transformations(\\"xyz\\", \\"abc\\") 3 >>> min_transformations(\\"aaa\\", \\"zzz\\") 25 >>> min_transformations(\\"abc\\", \\"abc\\") 0 def process_test_cases(test_cases: List[Tuple[str, str]]) -> List[int]: Process a list of test cases and return a list of results for each test case. >>> process_test_cases([(\\"abc\\", \\"bcd\\"), (\\"xyz\\", \\"abc\\"), (\\"aaa\\", \\"zzz\\"), (\\"abc\\", \\"abc\\")]) [1, 3, 25, 0]","solution":"def min_transformations(S, T): transformations = 0 length = len(S) for i in range(length): needed_transform = (ord(T[i]) - ord(S[i])) % 26 transformations = max(transformations, needed_transform) return transformations def process_test_cases(test_cases): results = [] for S, T in test_cases: results.append(min_transformations(S, T)) return results"},{"question":"def min_containers(total_food: int, containers: List[int]) -> int: Returns the minimum number of containers required to store the total amount of food, or -1 if it is not possible to store the exact amount of food with the available containers. Parameters: total_food (int): The total amount of food in liters. containers (list of int): List of available container capacities in liters. Returns: int: Minimum number of containers required or -1 if not possible. >>> min_containers(10, [5, 5, 1]) 2 >>> min_containers(12, [5, 3]) -1 >>> min_containers(13, [10, 3, 1, 1, 1]) 2 >>> min_containers(11, [10, 1, 1, 1, 1]) 2 >>> min_containers(5, [5]) 1 >>> min_containers(8, [3, 3, 2, 2]) 3 >>> min_containers(7, [4, 3, 2, 1, 1]) 2 >>> min_containers(6, [1, 1, 1, 1, 1, 1]) 6 >>> min_containers(5, [10, 3, 2]) 2 >>> min_containers(0, [5, 3, 2]) 0 >>> min_containers(1, [1, 1, 1]) 1","solution":"def min_containers(total_food, containers): Returns the minimum number of containers required to store the total amount of food, or -1 if it is not possible to store the exact amount of food with the available containers. Parameters: total_food (int): The total amount of food in liters. containers (list of int): List of available container capacities in liters. Returns: int: Minimum number of containers required or -1 if not possible. containers.sort(reverse=True) # sort containers in decreasing order num_containers = 0 for capacity in containers: if total_food == 0: return num_containers if capacity <= total_food: num_containers += total_food // capacity total_food %= capacity return num_containers if total_food == 0 else -1"},{"question":"def validate_task_order(order: str, constraints: List[Tuple[str, str]]) -> bool: Write a function to determine if a given string is a valid scheduling order of tasks, given in the form: \\"a->b->c\\". The string represents a sequence of tasks where each task should be completed before the subsequent one. You will be given a series of constraints represented as pairs (a, b), which means task a must be done before task b. Your function should return True if the given order satisfies all the constraints, and False otherwise. >>> validate_task_order(\\"a->b->c\\", [(\\"a\\", \\"b\\"), (\\"b\\", \\"c\\")]) True >>> validate_task_order(\\"c->b->a\\", [(\\"a\\", \\"b\\"), (\\"b\\", \\"c\\")]) False >>> validate_task_order(\\"a->c->b\\", [(\\"a\\", \\"c\\"), (\\"c\\", \\"b\\")]) True from typing import List, Tuple def test_valid_task_order(): assert validate_task_order(\\"a->b->c\\", [(\\"a\\", \\"b\\"), (\\"b\\", \\"c\\")]) == True def test_invalid_task_order(): assert validate_task_order(\\"c->b->a\\", [(\\"a\\", \\"b\\"), (\\"b\\", \\"c\\")]) == False def test_single_constraint(): assert validate_task_order(\\"a->c->b\\", [(\\"a\\", \\"c\\"), (\\"c\\", \\"b\\")]) == True def test_multiple_constraints_satisfied(): assert validate_task_order(\\"a->b->c->d\\", [(\\"a\\", \\"b\\"), (\\"b\\", \\"c\\"), (\\"c\\", \\"d\\")]) == True def test_multiple_constraints_unsatisfied(): assert validate_task_order(\\"d->c->b->a\\", [(\\"a\\", \\"b\\"), (\\"b\\", \\"c\\"), (\\"c\\", \\"d\\")]) == False def test_constraints_with_non_continuous_order(): assert validate_task_order(\\"a->c->b->d\\", [(\\"a\\", \\"c\\"), (\\"b\\", \\"d\\"), (\\"a\\", \\"b\\")]) == True def test_empty_order(): assert validate_task_order(\\"\\", []) == True # No constraints to validate def test_no_constraints(): assert validate_task_order(\\"a->b->c\\", []) == True # Any order is valid without constraints","solution":"from typing import List, Tuple def validate_task_order(order: str, constraints: List[Tuple[str, str]]) -> bool: Validates if the given task order satisfies all the given constraints. tasks = order.split(\\"->\\") position = {task: index for index, task in enumerate(tasks)} for a, b in constraints: if position[a] >= position[b]: return False return True"},{"question":"def reverse_segments(inputArray): Reverse the segments of a given array of integers between every pair of zeroes, excluding the zeroes themselves. >>> reverse_segments([1, 2, 0, 3, 4, 0, 5, 0, 6]) [2, 1, 0, 4, 3, 0, 5, 0, 6] >>> reverse_segments([1, 2, 3, 0]) [3, 2, 1, 0] >>> reverse_segments([0, 1, 2, 3]) [0, 3, 2, 1] >>> reverse_segments([0, 0, 0]) [0, 0, 0] >>> reverse_segments([1, 2, 0, 0, 3, 4, 0]) [2, 1, 0, 0, 4, 3, 0] >>> reverse_segments([0, 1, 2, 0, 0, 3, 4, 0, 5]) [0, 2, 1, 0, 0, 4, 3, 0, 5] >>> reverse_segments([1, 2, 3, 4, 5]) [5, 4, 3, 2, 1] >>> reverse_segments([0]) [0] >>> reverse_segments([1]) [1] >>> reverse_segments([1, 0]) [1, 0] >>> reverse_segments([0, 1]) [0, 1] >>> reverse_segments([1, 2, 3, 0, 4, 5]) [3, 2, 1, 0, 5, 4]","solution":"def reverse_segments(inputArray): result = [] start = 0 for i in range(len(inputArray)): if inputArray[i] == 0: if start < i: result.extend(inputArray[start:i][::-1]) result.append(0) start = i + 1 if start < len(inputArray): result.extend(inputArray[start:][::-1]) return result"},{"question":"import math def box_area_diff(n: int) -> int: Calculate the difference between the sums of the surface areas of the largest inscribed sphere and the smallest inscribed sphere in a cube of side length \`n\`. The radius of the largest inscribed sphere is \`n/2\`. The radius of the smallest inscribed sphere is \`n/(2√3)\`. The surface area of a sphere is given by \`4 * π * r^2\`. Args: n (int): The side length of the cubic box. Returns: int: The difference between the sums of the surface areas of the largest and smallest inscribed spheres. Examples: >>> box_area_diff(1) == 4 * 3.14159 - 4 * 3.14159 / 3 >>> box_area_diff(2) == 16 * 3.14159 - 4 * (3 ** 0.5) * 3.14159","solution":"import math def box_area_diff(n: int) -> int: Calculate the difference between the sums of the surface areas of the largest inscribed sphere and the smallest inscribed sphere in a cube of side length \`n\`. The radius of the largest inscribed sphere is \`n/2\`. The radius of the smallest inscribed sphere is \`n/(2√3)\`. The surface area of a sphere is given by \`4 * π * r^2\`. pi = 3.14159 r_largest = n / 2 r_smallest = n / (2 * math.sqrt(3)) area_largest = 4 * pi * (r_largest ** 2) area_smallest = 4 * pi * (r_smallest ** 2) return round(area_largest - area_smallest)"},{"question":"from typing import List def find_anagrams(s: str) -> List[str]: Returns a sorted list of all unique anagrams that can be formed using the characters of the given string. >>> find_anagrams(\\"abc\\") ['abc', 'acb', 'bac', 'bca', 'cab', 'cba'] >>> find_anagrams(\\"aab\\") ['aab', 'aba', 'baa'] >>> find_anagrams(\\"a\\") ['a'] >>> find_anagrams(\\"aa\\") ['aa']","solution":"from itertools import permutations def find_anagrams(s): Returns a sorted list of all unique anagrams that can be formed using the characters of the given string. if not s: return [] perm = permutations(s) unique_anagrams = sorted(set(''.join(p) for p in perm)) return unique_anagrams"},{"question":"def is_prime(num: int) -> bool: Determines if a given number is a prime number. A prime number (other than 1) has exactly two distinct positive divisors: 1 and itself. >>> is_prime(1) == False >>> is_prime(2) == True >>> is_prime(3) == True >>> is_prime(4) == False >>> is_prime(17) == True >>> is_prime(18) == False def filter_primes(numbers: List[int]) -> List[int]: Accepts a list of integers and returns a new list containing only the prime numbers from the original list, in the same order that they appeared. >>> filter_primes([]) == [] >>> filter_primes([2, 3, 5, 7, 11]) == [2, 3, 5, 7, 11] >>> filter_primes([1, 4, 6, 8, 10]) == [] >>> filter_primes([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [2, 3, 5, 7] >>> filter_primes([29, 37, 41, 43, 100, 101]) == [29, 37, 41, 43, 101]","solution":"def is_prime(num): Returns True if num is a prime number, otherwise False. if num < 2: return False for i in range(2, int(num**0.5) + 1): if num % i == 0: return False return True def filter_primes(numbers): Returns a list containing only the prime numbers from the provided list. return [num for num in numbers if is_prime(num)]"},{"question":"def letter_combinations(digits: str) -> List[str]: Implement a function that takes a string containing only the digits 2-9 and returns a string representing all possible letter combinations that the number could represent on a classic phone keypad. >>> letter_combinations(\\"23\\") [\\"ad\\", \\"ae\\", \\"af\\", \\"bd\\", \\"be\\", \\"bf\\", \\"cd\\", \\"ce\\", \\"cf\\"] >>> letter_combinations(\\"9\\") [\\"w\\", \\"x\\", \\"y\\", \\"z\\"] >>> letter_combinations(\\"\\") []","solution":"def letter_combinations(digits): returns all possible letter combinations that the number could represent on a classic phone keypad. if not digits: return [] phone_map = { '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz' } combinations = [] def backtrack(index, current_combination): if index == len(digits): combinations.append(''.join(current_combination)) return possible_letters = phone_map[digits[index]] for letter in possible_letters: current_combination.append(letter) backtrack(index + 1, current_combination) current_combination.pop() backtrack(0, []) return sorted(combinations)"},{"question":"def min_cover_lines(W, H, n, points): Returns the minimum number of horizontal and vertical lines required to cover all the given points. Parameters: W (int): Width of the rectangle H (int): Height of the rectangle n (int): Number of points points (list of tuples): List of tuples where each tuple contains (xi, yi) coordinates of a point Returns: int: Minimum number of lines required to cover all the points","solution":"def min_cover_lines(W, H, n, points): Returns the minimum number of horizontal and vertical lines required to cover all the given points. Parameters: W (int): Width of the rectangle H (int): Height of the rectangle n (int): Number of points points (list of tuples): List of tuples where each tuple contains (xi, yi) coordinates of a point Returns: int: Minimum number of lines required to cover all the points x_coords = set() y_coords = set() for x, y in points: x_coords.add(x) y_coords.add(y) # Minimum lines required to cover all points will be the minimum of # distinct x-coordinates (vertical lines) or distinct y-coordinates (horizontal lines) return min(len(x_coords), len(y_coords))"},{"question":"def max_profit(prices: List[int]) -> int: You are given a list of integers representing the prices of a stock on consecutive days. Determine the maximum profit you can achieve if you are allowed to buy one share of the stock and then sell it at a later date. You can perform at most one transaction. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0","solution":"def max_profit(prices): Returns the maximum profit achievable from buying and selling one share of the stock. if not prices: return 0 min_price = prices[0] max_profit = 0 for price in prices[1:]: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"def is_palindrome(s: str) -> bool: Check if a given string s is a palindrome. >>> is_palindrome(\\"121\\") True >>> is_palindrome(\\"123\\") False pass def count_palindromic_subarrays(arr: List[int]) -> int: Count the number of palindromic subarrays in the given array of integers. >>> count_palindromic_subarrays([1, 2, 1]) 4 >>> count_palindromic_subarrays([1, 2, 2, 1]) 6 pass def solve(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Solve the problem for given test cases. The first argument 't' is the number of test cases. The second argument 'test_cases' is a list of tuples where the first element is the length of the array and the second element is the list of integers. >>> solve(2, [(3, [1, 2, 1]), (4, [1, 2, 2, 1])]) [4, 6] >>> solve(1, [(1, [1])]) [1] pass","solution":"def is_palindrome(s): Check if a given string s is a palindrome. return s == s[::-1] def count_palindromic_subarrays(arr): Count the number of palindromic subarrays in the given array of integers. n = len(arr) count = 0 for i in range(n): for j in range(i, n): if is_palindrome(''.join(map(str, arr[i:j+1]))): count += 1 return count def solve(t, test_cases): results = [] for i in range(t): n, arr = test_cases[i] results.append(count_palindromic_subarrays(arr)) return results"},{"question":"from typing import List from collections import Counter def minWindow(source: str, target: str) -> str: Given a string source and another string target, return the minimum window substring of source such that every character in target (including duplicates) is included in the window. If there is no such substring, return an empty string. >>> minWindow(\\"ADOBECODEBANC\\", \\"ABC\\") \\"BANC\\" >>> minWindow(\\"a\\", \\"a\\") \\"a\\" >>> minWindow(\\"a\\", \\"aa\\") \\"\\" def test_min_window_example_cases(): assert minWindow(\\"ADOBECODEBANC\\", \\"ABC\\") == \\"BANC\\" assert minWindow(\\"a\\", \\"a\\") == \\"a\\" assert minWindow(\\"a\\", \\"aa\\") == \\"\\" def test_min_window_empty_cases(): assert minWindow(\\"\\", \\"A\\") == \\"\\" assert minWindow(\\"ADOBECODEBANC\\", \\"\\") == \\"\\" def test_min_window_no_possible_window(): assert minWindow(\\"abcdef\\", \\"gh\\") == \\"\\" assert minWindow(\\"aab\\", \\"aaab\\") == \\"\\" def test_min_window_identical_source_target(): assert minWindow(\\"abcdef\\", \\"abcdef\\") == \\"abcdef\\" def test_min_window_overlapping_windows(): assert minWindow(\\"aaabbbccc\\", \\"abc\\") == \\"abbbc\\" assert minWindow(\\"abcabdebac\\", \\"cda\\") == \\"cabd\\"","solution":"def minWindow(source, target): from collections import Counter if not source or not target: return \\"\\" target_count = Counter(target) source_count = Counter() start, end = 0, 0 min_len = float('inf') min_start = 0 required = len(target_count) formed = 0 while end < len(source): char = source[end] source_count[char] += 1 if char in target_count and source_count[char] == target_count[char]: formed += 1 while start <= end and formed == required: char = source[start] if end - start + 1 < min_len: min_len = end - start + 1 min_start = start source_count[char] -= 1 if char in target_count and source_count[char] < target_count[char]: formed -= 1 start += 1 end += 1 return \\"\\" if min_len == float('inf') else source[min_start:min_start + min_len]"},{"question":"def sort_by_length(lst: list) -> list: Sort a list of strings by their lengths in descending order. Maintain the original order for strings with the same length. >>> sort_by_length([\\"apple\\", \\"banana\\", \\"kiwi\\", \\"lemon\\"]) [\\"banana\\", \\"apple\\", \\"lemon\\", \\"kiwi\\"] >>> sort_by_length([\\"\\", \\"a\\", \\"bb\\", \\"ccc\\"]) [\\"ccc\\", \\"bb\\", \\"a\\", \\"\\"] >>> sort_by_length([\\"cat\\", \\"bat\\", 123, \\"rat\\"]) [\\"cat\\", \\"bat\\", \\"rat\\"] >>> sort_by_length([]) [] # Your code here","solution":"def sort_by_length(lst): Sort a list of strings by their lengths in descending order. Maintain the original order for strings with the same length. Parameters: lst (list): List of strings to be sorted Returns: list: List of strings sorted by their lengths in descending order # Filter out non-string elements from the input list filtered_list = [s for s in lst if isinstance(s, str)] # Sort the list by length in descending order while maintaining the original order for strings of equal length sorted_list = sorted(filtered_list, key=len, reverse=True) return sorted_list"},{"question":"def can_redistribute(resources: int, players: int) -> bool: Determines if the resources can be equally redistributed among the players. Args: resources (int): A positive integer representing the total number of resources available. players (int): A positive integer representing the number of players. Returns: bool: True if the resources can be equally redistributed among the players, otherwise False. Example: >>> can_redistribute(10, 2) True >>> can_redistribute(10, 3) False >>> can_redistribute(33, 11) True >>> can_redistribute(32, 6) False","solution":"def can_redistribute(resources, players): Determines if the resources can be equally redistributed among the players. Args: resources (int): A positive integer representing the total number of resources available. players (int): A positive integer representing the number of players. Returns: bool: True if the resources can be equally redistributed among the players, otherwise False. return resources % players == 0"},{"question":"def is_toeplitz_matrix(matrix: List[List[int]]) -> bool: Check if a given matrix is a Toeplitz matrix. A Toeplitz matrix is one where each descending diagonal from left to right is constant. >>> is_toeplitz_matrix([[1, 2, 3], [4, 1, 2], [5, 4, 1]]) True >>> is_toeplitz_matrix([[1, 2], [2, 3]]) False >>> is_toeplitz_matrix([[1, 2], [2, 1]]) True >>> is_toeplitz_matrix([[1, 2, 3]]) True >>> is_toeplitz_matrix([[1], [2], [3]]) True >>> is_toeplitz_matrix([[1]]) True >>> is_toeplitz_matrix([]) True >>> is_toeplitz_matrix([[1, 2, 3, 4], [5, 6, 7, 1], [9, 10, 6, 2], [13, 14, 9, 7]]) False >>> is_toeplitz_matrix([[1, 2, 3, 4], [5, 1, 2, 3], [9, 5, 1, 2], [10, 9, 5, 1]]) True","solution":"def is_toeplitz_matrix(matrix): Check if a given matrix is a Toeplitz matrix. A Toeplitz matrix is one where each descending diagonal from left to right is constant. Args: matrix (list of list of int): The matrix to be checked. Returns: bool: True if the matrix is a Toeplitz matrix, otherwise False. if not matrix: return True rows = len(matrix) cols = len(matrix[0]) for row in range(1, rows): for col in range(1, cols): if matrix[row][col] != matrix[row - 1][col - 1]: return False return True"},{"question":"def generate_coprime_list(N): Generate a list of length N such that each pair of adjacent numbers in the list is coprime. >>> generate_coprime_list(4) [2, 3, 4, 5] >>> generate_coprime_list(2) [2, 3] >>> generate_coprime_list(3) [2, 3, 4] >>> generate_coprime_list(5) [2, 3, 4, 5, 6]","solution":"def generate_coprime_list(N): Generate a list of length N such that each pair of adjacent numbers in the list is coprime. # A simple way to ensure consecutive numbers are coprime is by using consecutive integers starting from 2 return list(range(2, 2 + N))"},{"question":"def is_palindrome_permutation(s: str) -> str: Determines if the string s can be rearranged to form a palindrome. :param s: String consisting of lowercase alphabetic characters. :returns: \\"YES\\" if the string can be rearranged to form a palindrome, otherwise \\"NO\\". >>> is_palindrome_permutation(\\"aabb\\") == \\"YES\\" >>> is_palindrome_permutation(\\"aab\\") == \\"YES\\" >>> is_palindrome_permutation(\\"a\\") == \\"YES\\" >>> is_palindrome_permutation(\\"abc\\") == \\"NO\\" >>> is_palindrome_permutation(\\"aaabbbb\\") == \\"YES\\" >>> is_palindrome_permutation(\\"abcdefghijk\\") == \\"NO\\" >>> is_palindrome_permutation(\\"aabbccddeeffgg\\") == \\"YES\\"","solution":"def is_palindrome_permutation(s): Determines if the string s can be rearranged to form a palindrome. :param s: String consisting of lowercase alphabetic characters. :returns: \\"YES\\" if the string can be rearranged to form a palindrome, otherwise \\"NO\\". from collections import Counter char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 == 1) # A string can be rearranged to form a palindrome if at most one character has an odd count if odd_count <= 1: return \\"YES\\" else: return \\"NO\\""},{"question":"def sort_employees_by_score(employees: List[Tuple[str, int]]) -> List[Tuple[str, int]]: Sorts a list of employees based on their scores in descending order. In case of a tie, employees are sorted alphabetically by their names in ascending order. >>> sort_employees_by_score([(\\"Alice\\", 88), (\\"Bob\\", 95), (\\"Charlie\\", 88), (\\"David\\", 85), (\\"Eve\\", 95)]) [('Bob', 95), ('Eve', 95), ('Alice', 88), ('Charlie', 88), ('David', 85)] >>> sort_employees_by_score([(\\"John\\", 70), (\\"Doe\\", 70), (\\"Zack\\", 66), (\\"Ann\\", 100), (\\"Ken\\", 90)]) [('Ann', 100), ('Ken', 90), ('Doe', 70), ('John', 70), ('Zack', 66)] >>> sort_employees_by_score([(\\"Xander\\", 50)]) [('Xander', 50)] >>> sort_employees_by_score([(\\"Alice\\", 80), (\\"alice\\", 80)]) [('Alice', 80), ('alice', 80)] >>> sort_employees_by_score([(\\"Alice\\", 100), (\\"Bob\\", 100), (\\"Charlie\\", 100), (\\"David\\", 100), (\\"Eve\\", 100)]) [('Alice', 100), ('Bob', 100), ('Charlie', 100), ('David', 100), ('Eve', 100)]","solution":"def sort_employees_by_score(employees): Sorts a list of employees based on their scores in descending order. In case of a tie, employees are sorted alphabetically by their names in ascending order. :param employees: List of tuples, where each tuple contains (name, score) :return: List of tuples sorted as per the criteria # Sort primarily by score in descending order and secondarily by name in ascending order return sorted(employees, key=lambda x: (-x[1], x[0])) # Example usage: # employees = [(\\"Alice\\", 88), (\\"Bob\\", 95), (\\"Charlie\\", 88), (\\"David\\", 85), (\\"Eve\\", 95)] # sorted_employees = sort_employees_by_score(employees) # print(sorted_employees) # Output: [('Bob', 95), ('Eve', 95), ('Alice', 88), ('Charlie', 88), ('David', 85)]"},{"question":"class RomanNumeralConverter: A class to convert an integer to a Roman numeral and vice versa. Methods ------- __init__(self): Initializes any required data structures. to_roman(self, number: int) -> str: Converts an integer to a Roman numeral. from_roman(self, roman: str) -> int: Converts a Roman numeral to an integer. def __init__(self): # Initialize the mappings for Roman numeral conversion. pass def to_roman(self, number: int) -> str: Convert an integer to a Roman numeral. >>> converter = RomanNumeralConverter() >>> converter.to_roman(1990) 'MCMXC' >>> converter.to_roman(48) 'XLVIII' pass def from_roman(self, roman: str) -> int: Convert a Roman numeral to an integer. >>> converter = RomanNumeralConverter() >>> converter.from_roman('MCMXC') 1990 >>> converter.from_roman('XLVIII') 48 pass","solution":"class RomanNumeralConverter: def __init__(self): self.roman_to_int_map = { 'M': 1000, 'CM': 900, 'D': 500, 'CD': 400, 'C': 100, 'XC': 90, 'L': 50, 'XL': 40, 'X': 10, 'IX': 9, 'V': 5, 'IV': 4, 'I': 1 } self.int_to_roman_map = {v: k for k, v in self.roman_to_int_map.items()} self.values = sorted(self.int_to_roman_map.keys(), reverse=True) def to_roman(self, number: int) -> str: roman_numeral = [] for value in self.values: while number >= value: roman_numeral.append(self.int_to_roman_map[value]) number -= value return ''.join(roman_numeral) def from_roman(self, roman: str) -> int: i = 0 num = 0 while i < len(roman): if i + 1 < len(roman) and roman[i:i+2] in self.roman_to_int_map: num += self.roman_to_int_map[roman[i:i+2]] i += 2 else: num += self.roman_to_int_map[roman[i]] i += 1 return num"},{"question":"def extract_and_sort_digits(input_string: str) -> str: Extracts the digits from the input string, sorts them in ascending order, and returns the new sorted string of digits. If there are no digits, returns an empty string. >>> extract_and_sort_digits(\\"a1b2c3d4\\") '1234' >>> extract_and_sort_digits(\\"xyz\\") '' >>> extract_and_sort_digits(\\"4321\\") '1234' >>> extract_and_sort_digits(\\"a1b\\") '1' >>> extract_and_sort_digits(\\"a2b2c2\\") '222' >>> input_string = \\"a\\" * 500 + \\"1\\" * 300 + \\"2\\" * 200 >>> expected_output = \\"1\\" * 300 + \\"2\\" * 200 >>> extract_and_sort_digits(input_string) == expected_output True","solution":"def extract_and_sort_digits(input_string): Extracts the digits from the input string, sorts them in ascending order, and returns the new sorted string of digits. If there are no digits, returns an empty string. digits = [char for char in input_string if char.isdigit()] sorted_digits = sorted(digits) return ''.join(sorted_digits)"},{"question":"def integerRange(start: int, end: int) -> List[int]: Implement a function called \`integerRange\` that accepts two integers, \`start\` and \`end\`, and returns an array containing all the integers from \`start\` to \`end\` inclusive. If \`start\` is greater than \`end\`, the function should return an empty array. >>> integerRange(2, 6) [2, 3, 4, 5, 6] >>> integerRange(10, 15) [10, 11, 12, 13, 14, 15] >>> integerRange(5, 5) [5] >>> integerRange(7, 2) []","solution":"def integerRange(start, end): Returns a list of integers from start to end inclusive. If start is greater than end, returns an empty list. if start > end: return [] return list(range(start, end+1))"},{"question":"def can_partition_into_consecutive_sets(n: int, k: int, array: List[int]) -> str: Determines if the array can be partitioned into sets of k consecutive numbers. >>> can_partition_into_consecutive_sets(6, 3, [1, 2, 3, 3, 4, 6]) No >>> can_partition_into_consecutive_sets(5, 2, [1, 2, 3, 4, 5]) No >>> can_partition_into_consecutive_sets(6, 2, [1, 2, 3, 4, 5, 6]) Yes >>> can_partition_into_consecutive_sets(8, 4, [1, 2, 3, 4, 5, 6, 7, 8]) Yes >>> can_partition_into_consecutive_sets(3, 1, [1, 2, 3]) Yes >>> can_partition_into_consecutive_sets(6, 3, [1, 2, 3, 4, 5, 6]) Yes >>> can_partition_into_consecutive_sets(4, 2, [1, 2, 2, 4]) No pass","solution":"def can_partition_into_consecutive_sets(n, k, array): Determines if the array can be partitioned into sets of k consecutive numbers. if n % k != 0: return \\"No\\" from collections import Counter array_counter = Counter(array) unique_elements = sorted(array_counter.keys()) for num in unique_elements: if array_counter[num] > 0: count = array_counter[num] for i in range(num, num + k): if array_counter[i] < count: return \\"No\\" array_counter[i] -= count return \\"Yes\\""},{"question":"from typing import List, Optional def findMostFrequent(nums: List[int]) -> Optional[int]: Write a function called \`findMostFrequent\` that takes a list of integers and returns the integer that appears the most times in the list. If there is a tie for the most frequent element, return any one of the integers that have the highest frequency. If the list is empty, return None. Examples: >>> findMostFrequent([1, 3, 3, 3, 2, 2, 2, 4, 4]) 3 or 2 >>> findMostFrequent([5, 6, 6, 7, 5, 8, 8, 8, 8, 5]) 8 >>> findMostFrequent([]) None >>> findMostFrequent([10]) 10 >>> findMostFrequent([1, 1, 2, 2, 3, 3, 4, 4, 4]) 4 pass","solution":"def findMostFrequent(nums): Returns the integer that appears the most times in the list. If there is a tie for the most frequent element, return any one of them. If the list is empty, return None. if not nums: return None frequency = {} for num in nums: if num in frequency: frequency[num] += 1 else: frequency[num] = 1 most_frequent_num = max(frequency, key=frequency.get) return most_frequent_num"},{"question":"def min_steps_to_one(x: int) -> int: Returns the minimum number of steps required to reduce x to 1 by using the given operations. >>> min_steps_to_one(8) 3 >>> min_steps_to_one(7) 4 >>> min_steps_to_one(15) 5","solution":"def min_steps_to_one(x): Returns the minimum number of steps required to reduce x to 1 by using the given operations. steps = 0 while x != 1: if x % 2 == 0: x //= 2 else: if (x == 3 or x % 4 == 1): x -= 1 else: x += 1 steps += 1 return steps"},{"question":"def maximize_distance_minimize_difficulty(n: int, m: int, tracks: List[Tuple[int, int]]) -> Tuple[int, int]: Saitama wants to minimize his total training difficulty while running each track at least once. However, due to limited stamina and time, he can only run m tracks in a day and wants to maximize the total distance covered in these m tracks. >>> maximize_distance_minimize_difficulty(5, 3, [(10, 3), (20, 5), (30, 1), (40, 2), (50, 4)]) (120, 8) >>> maximize_distance_minimize_difficulty(4, 2, [(5, 2), (15, 4), (25, 1), (35, 3)]) (60, 4)","solution":"def maximize_distance_minimize_difficulty(n, m, tracks): tracks.sort(key=lambda x: (-x[0], x[1])) # Sort by length descending, then by difficulty ascending selected_tracks = tracks[:m] total_distance = sum(track[0] for track in selected_tracks) total_difficulty = sum(track[1] for track in selected_tracks) return total_distance, total_difficulty"},{"question":"from typing import List def array_partition(nums: List[int]) -> int: Given an integer array nums of 2n integers, group these integers into n pairs (a1, b1), (a2, b2), ..., (an, bn) such that the sum of min(ai, bi) for all i is maximized. Return the maximized sum. Examples: >>> array_partition([1, 4, 3, 2]) 4 >>> array_partition([6, 2, 6, 5, 1, 2]) 9 pass def test_single_pair(): assert array_partition([1, 2]) == 1 def test_two_pairs(): assert array_partition([1, 4, 3, 2]) == 4 def test_multiple_pairs(): assert array_partition([6, 2, 6, 5, 1, 2]) == 9 def test_all_equal_elements(): assert array_partition([5, 5, 5, 5]) == 10 def test_negative_elements(): assert array_partition([-1, -2, -3, -4]) == -6 def test_mixed_elements(): assert array_partition([1, -1, 2, -2]) == -1 def test_large_input(): assert array_partition([i for i in range(1, 20001)]) == 100000000","solution":"def array_partition(nums): Given an integer array nums of 2n integers, group these integers into n pairs (a1, b1), (a2, b2), ..., (an, bn) such that the sum of min(ai, bi) for all i is maximized. Return the maximized sum. nums.sort() return sum(nums[::2])"},{"question":"def simplify_expression(expression): Simplify the given mathematical expression by combining like terms. Parameters: expression (str): A string representing the mathematical expression with positive integers, addition (+) and subtraction (-) operators. Returns: str: A string representing the simplified result of the expression. Examples: >>> simplify_expression(\\"2 + 3 + 4\\") '9' >>> simplify_expression(\\"5 + 7 - 2\\") '10' >>> simplify_expression(\\"10 - 3 + 6 - 5\\") '8' >>> simplify_expression(\\"1 + 5 - 10 + 7 - 2 + 3\\") '4'","solution":"def simplify_expression(expression): Simplify the given mathematical expression by combining like terms. Parameters: expression (str): A string representing the mathematical expression with positive integers, addition (+) and subtraction (-) operators. Returns: str: A string representing the simplified result of the expression. # Split the expression into tokens tokens = expression.split() # Initialize the result result = 0 # Initialize a variable to keep track of the current operation current_operation = '+' for token in tokens: if token in '+-': # Update the current operation current_operation = token else: # Convert the token to an integer number = int(token) if current_operation == '+': result += number else: result -= number return str(result)"},{"question":"def count_vowels_consonants(s: str) -> tuple: Count the number of vowels (a, e, i, o, u) and consonants in the given string. Ignores case and non-alphabet characters. >>> count_vowels_consonants(\\"Hello World!\\") == (3, 7) >>> count_vowels_consonants(\\"Python 3.8\\") == (1, 5) >>> count_vowels_consonants(\\"I love coding!\\") == (5, 6) Parameters: s (str): The input string to be evaluated. Returns: tuple: A tuple containing the count of vowels and consonants.","solution":"def count_vowels_consonants(s): Counts the number of vowels and consonants in the given string s. Ignores case and non-alphabet characters. Parameters: s (str): The input string to be evaluated. Returns: tuple: A tuple containing the count of vowels and consonants. s = s.lower() vowels_set = {'a', 'e', 'i', 'o', 'u'} vowels = sum(1 for ch in s if ch in vowels_set) consonants = sum(1 for ch in s if ch.isalpha() and ch not in vowels_set) return (vowels, consonants)"},{"question":"def summarize_music_preferences(pairs: str) -> str: Summarizes music preferences by grouping genres and listing employees liking them. Args: pairs (str): A string of employee-genre pairs separated by commas. Returns: str: A formatted string with genres and their corresponding employees sorted alphabetically. >>> summarize_music_preferences(\\"alice:rock,bob:jazz,charlie:rock,alice:jazz,diana:classical,eliza:rock\\") \\"classical:diananjazz:alice,bobnrock:alice,charlie,eliza\\" >>> summarize_music_preferences(\\"alice:rock,bob:rock,charlie:rock\\") \\"rock:alice,bob,charlie\\" >>> summarize_music_preferences(\\"alice:rock\\") \\"rock:alice\\" >>> summarize_music_preferences(\\"alice:rock,bob:rock,charlie:jazz,alice:jazz,bob:jazz\\") \\"jazz:alice,bob,charlienrock:alice,bob\\" >>> summarize_music_preferences(\\"alice:rock,bob:pop,charlie:jazz,diana:classical\\") \\"classical:diananjazz:charlienpop:bobnrock:alice\\" >>> summarize_music_preferences(\\"a:b\\") \\"b:a\\"","solution":"def summarize_music_preferences(pairs): Summarizes music preferences by grouping genres and listing employees liking them. Args: pairs (str): A string of employee-genre pairs separated by commas. Returns: str: A formatted string with genres and their corresponding employees sorted alphabetically. from collections import defaultdict genre_dict = defaultdict(list) # Split the pairs and fill the dictionary for pair in pairs.split(','): employee_name, genre = pair.split(':') genre_dict[genre].append(employee_name) # Create the summary string with genres sorted output_lines = [] for genre in sorted(genre_dict.keys()): employees_sorted = ','.join(sorted(genre_dict[genre])) output_lines.append(f\\"{genre}:{employees_sorted}\\") return 'n'.join(output_lines)"},{"question":"def generate_primes_up_to(n): Returns a list of boolean values where the index is the number and the value at that index is True if the number is prime. pass def is_cyclic_prime(num, prime_sieve): Checks if num is a cyclic prime by rotating its digits and checking if all rotations are prime. pass def count_super_primes_upto_n(n, prime_sieve): Returns the count of super primes up to and including n. pass def super_primes(T, test_cases): For each integer N in the test cases, calculate the number of super primes between 1 and N inclusive. >>> T = 3 >>> test_cases = [10, 100, 1000] >>> super_primes(T, test_cases) [4, 13, 25] pass","solution":"def generate_primes_up_to(n): Returns a list of boolean values where the index is the number and the value at that index is True if the number is prime. sieve = [True] * (n + 1) sieve[0] = sieve[1] = False # 0 and 1 are not prime numbers for start in range(2, int(n**0.5) + 1): if sieve[start]: for multiple in range(start*start, n + 1, start): sieve[multiple] = False return sieve def is_cyclic_prime(num, prime_sieve): Checks if num is a cyclic prime by rotating its digits and checking if all rotations are prime. digits = str(num) for i in range(len(digits)): rotated = int(digits[i:] + digits[:i]) if not prime_sieve[rotated]: return False return True def count_super_primes_upto_n(n, prime_sieve): Returns the count of super primes up to and including n. count = 0 for i in range(1, n + 1): if prime_sieve[i] and is_cyclic_prime(i, prime_sieve): count += 1 return count def super_primes(T, test_cases): For each integer N in the test cases, calculate the number of super primes between 1 and N inclusive. max_n = max(test_cases) prime_sieve = generate_primes_up_to(max_n) results = [] for n in test_cases: results.append(count_super_primes_upto_n(n, prime_sieve)) return results"},{"question":"from typing import List def isBalanced(s: str) -> bool: Determines if the input string is balanced with respect to brackets '()', '{}', '[]'. Args: s (str): Input string containing the characters '(', ')', '{', '}', '[' and ']' Returns: bool: True if the string is balanced, False otherwise Examples: >>> isBalanced(\\"()\\") True >>> isBalanced(\\"()[]{}\\") True >>> isBalanced(\\"(]\\") False >>> isBalanced(\\"([)]\\") False >>> isBalanced(\\"{[]}\\") True","solution":"def isBalanced(s): Determines if the input string s is balanced with respect to brackets. Args: s (str): Input string containing the characters '(', ')', '{', '}', '[' and ']' Returns: bool: True if the string is balanced, False otherwise stack = [] bracket_map = {')': '(', '}': '{', ']': '['} for char in s: if char in bracket_map.values(): # If the character is an opening bracket stack.append(char) elif char in bracket_map: # If the character is a closing bracket if stack and stack[-1] == bracket_map[char]: # Check for matching opening bracket stack.pop() # Remove the matched opening bracket else: return False # Unmatched closing bracket or stack is empty return not stack # Stack should be empty if all opening brackets are matched"},{"question":"def num_trees(n: int) -> int: Returns the total number of unique binary search trees (BSTs) that can be formed using n distinct values. >>> num_trees(1) == 1 >>> num_trees(2) == 2 >>> num_trees(3) == 5 >>> num_trees(4) == 14 >>> num_trees(5) == 42 >>> num_trees(6) == 132 >>> num_trees(7) == 429 >>> num_trees(8) == 1430 >>> num_trees(9) == 4862 >>> num_trees(10) == 16796","solution":"def num_trees(n): Returns the total number of unique binary search trees (BSTs) that can be formed using n distinct values. # Base case if n == 0 or n == 1: return 1 # Initialize a list to store the number of unique BSTs for each number from 0 to n dp = [0] * (n + 1) dp[0], dp[1] = 1, 1 # Fill the dp array using dynamic programming for i in range(2, n + 1): for j in range(1, i + 1): dp[i] += dp[j - 1] * dp[i - j] return dp[n]"},{"question":"def odd_or_even(lst: List[int]) -> str: Determines whether the sum of elements in the list is odd or even. Args: lst (list): A list of integers. Returns: str: \\"odd\\" if the sum is odd, \\"even\\" if the sum is even. >>> odd_or_even([3, 1, 4, 1, 5]) == \\"even\\" >>> odd_or_even([2, 4, 6, 1]) == \\"odd\\" >>> odd_or_even([]) == \\"even\\" >>> odd_or_even([1]) == \\"odd\\" >>> odd_or_even([2]) == \\"even\\" >>> odd_or_even([1, -1, -1]) == \\"odd\\" >>> odd_or_even([1, -1, -2]) == \\"even\\" >>> odd_or_even([10**6, 10**6 + 1]) == \\"odd\\" >>> odd_or_even([10**6, 10**6]) == \\"even\\"","solution":"def odd_or_even(lst): Determines whether the sum of elements in the list is odd or even. Args: lst (list): A list of integers. Returns: str: \\"odd\\" if the sum is odd, \\"even\\" if the sum is even. total_sum = sum(lst) if total_sum % 2 == 0: return \\"even\\" else: return \\"odd\\""},{"question":"def max_distance_between_guests(N: int, L: int) -> int: Returns the maximum possible distance between any two consecutive guests given the number of guests and the length of the table. >>> max_distance_between_guests(5, 20) 5 >>> max_distance_between_guests(2, 1) 1 >>> max_distance_between_guests(10**9, 10**9) 1 >>> max_distance_between_guests(2, 10**9) 10**9 def process_input(input_lines: List[str]) -> List[int]: Processes input lines to calculate max distances for multiple test cases. >>> process_input([\\"1\\", \\"5 20\\"]) [5] >>> process_input([\\"3\\", \\"5 20\\", \\"2 10\\", \\"3 6\\"]) [5, 10, 3]","solution":"def max_distance_between_guests(N, L): Returns the maximum possible distance between any two consecutive guests given the number of guests N and the length of the table L. return L // (N - 1) def process_input(input_lines): Processes input lines to calculate max distances for multiple test cases. T = int(input_lines[0]) results = [] for i in range(1, T + 1): N, L = map(int, input_lines[i].split()) results.append(max_distance_between_guests(N, L)) return results"},{"question":"def isMagicSquare(matrix): Returns True if the given matrix is a magic square, otherwise False. >>> isMagicSquare([[2, 7, 6], [9, 5, 1], [4, 3, 8]]) == True >>> isMagicSquare([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == False","solution":"def isMagicSquare(matrix): Returns True if the given matrix is a magic square, otherwise False. n = len(matrix) if n == 1: # single element matrix is always a magic square return True sum_set = set() # Sum of the first row target_sum = sum(matrix[0]) sum_set.add(target_sum) # Check sums of all rows for row in matrix: if sum(row) != target_sum: return False # Check sums of all columns for col in range(n): col_sum = sum(matrix[row][col] for row in range(n)) sum_set.add(col_sum) if col_sum != target_sum: return False # Check sum of the main diagonal main_diag_sum = sum(matrix[i][i] for i in range(n)) sum_set.add(main_diag_sum) if main_diag_sum != target_sum: return False # Check sum of the secondary diagonal sec_diag_sum = sum(matrix[i][n-i-1] for i in range(n)) sum_set.add(sec_diag_sum) if sec_diag_sum != target_sum: return False # If all sums are the same, then it's a magic square return len(sum_set) == 1"},{"question":"def capitalizeWords(s: str) -> str: Returns the input string with the first letter of each word capitalized. >>> capitalizeWords('hello world') 'Hello World' >>> capitalizeWords('programming is fun') 'Programming Is Fun' >>> capitalizeWords('this is a test') 'This Is A Test'","solution":"def capitalizeWords(s): Returns the input string with the first letter of each word capitalized. return ' '.join(word.capitalize() for word in s.split(' '))"},{"question":"class Plant: A class to represent a plant. Attributes: species (str): The species of the plant. age (int): The age of the plant in years. height (float): The height of the plant in cm. def __init__(self, species: str, age: int, height: float): self.species = species self.age = age self.height = height def grow(self, years: int): Increase the age of the plant by the specified number of years and its height by 10% of its current height for each year it grows. def report(self) -> str: Return a string containing the species, classification based on its age, and its height formatted to two decimal places. >>> plant = Plant(species=\\"sunflower\\", age=1, height=30.0) >>> plant.grow(1) >>> plant.report() 'The sunflower is a young plant and is 33.00 cm tall.' # Creating instances for Sunflower, Oak, and Cactus sunflower = Plant(species=\\"sunflower\\", age=1, height=30.0) oak = Plant(species=\\"oak\\", age=5, height=150.0) cactus = Plant(species=\\"cactus\\", age=11, height=50.0) # Demonstrating functionality sunflower.grow(1) oak.grow(2) cactus.grow(1) sunflower_report = sunflower.report() oak_report = oak.report() cactus_report = cactus.report()","solution":"class Plant: A class to represent a plant. Attributes: species (str): The species of the plant. age (int): The age of the plant in years. height (float): The height of the plant in cm. def __init__(self, species, age, height): self.species = species self.age = age self.height = height def grow(self, years): Increase the age of the plant by the specified number of years and its height by 10% of its current height for each year it grows. self.age += years for _ in range(years): self.height += self.height * 0.10 def report(self): Return a string containing the species, classification based on its age, and its height formatted to two decimal places. if self.age <= 2: age_classification = \\"young\\" elif self.age <= 10: age_classification = \\"mature\\" else: age_classification = \\"old\\" return f\\"The {self.species} is a {age_classification} plant and is {self.height:.2f} cm tall.\\" # Creating instances for Sunflower, Oak, and Cactus sunflower = Plant(species=\\"sunflower\\", age=1, height=30.0) oak = Plant(species=\\"oak\\", age=5, height=150.0) cactus = Plant(species=\\"cactus\\", age=11, height=50.0) # Demonstrating functionality sunflower.grow(1) oak.grow(2) cactus.grow(1) sunflower_report = sunflower.report() oak_report = oak.report() cactus_report = cactus.report()"},{"question":"def allocate_rooms(room_capacities, presenter_requests): Allocates rooms to presenter requests based on available room capacities. Args: room_capacities (list of int): list of maximum number of attendees each room can hold. presenter_requests (list of tuples): list of tuples, each containing the topic name (str) and maximum attendees (int). Returns: list of int: List of room indices allocated to each topic. If a room cannot be allocated, return -1 for that topic. pass def test_allocate_rooms_normal_case(): room_capacities = [100, 150, 200] presenter_requests = [(\\"AI Trends\\", 120), (\\"Data Science\\", 90), (\\"Cloud Computing\\", 150)] expected = [1, 0, 2] assert allocate_rooms(room_capacities, presenter_requests) == expected def test_allocate_rooms_with_over_capacity_request(): room_capacities = [100, 150] presenter_requests = [(\\"Big Data\\", 200), (\\"Machine Learning\\", 150)] expected = [-1, 1] assert allocate_rooms(room_capacities, presenter_requests) == expected def test_allocate_rooms_with_exact_capacity_match(): room_capacities = [100, 150] presenter_requests = [(\\"Intro to AI\\", 100), (\\"Advanced AI\\", 150)] expected = [0, 1] assert allocate_rooms(room_capacities, presenter_requests) == expected def test_allocate_rooms_with_all_over_capacity_requests(): room_capacities = [50, 60] presenter_requests = [(\\"Session A\\", 70), (\\"Session B\\", 80), (\\"Session C\\", 90)] expected = [-1, -1, -1] assert allocate_rooms(room_capacities, presenter_requests) == expected def test_allocate_rooms_with_multiple_choices(): room_capacities = [100, 150, 200] presenter_requests = [(\\"Workshop 1\\", 100), (\\"Workshop 2\\", 100), (\\"Workshop 3\\", 100)] expected = [0, 1, 2] assert allocate_rooms(room_capacities, presenter_requests) == expected def test_allocate_rooms_with_empty_inputs(): room_capacities = [] presenter_requests = [(\\"Some Topic\\", 50)] expected = [-1] assert allocate_rooms(room_capacities, presenter_requests) == expected","solution":"def allocate_rooms(room_capacities, presenter_requests): Allocates rooms to presenter requests based on available room capacities. Args: room_capacities (list of int): list of maximum number of attendees each room can hold. presenter_requests (list of tuples): list of tuples, each containing the topic name (str) and maximum attendees (int). Returns: list of int: List of room indices allocated to each topic. If a room cannot be allocated, return -1 for that topic. allocation = [-1] * len(presenter_requests) allocated_rooms = set() for i, (_, max_attendees) in enumerate(presenter_requests): for j, capacity in enumerate(room_capacities): if j not in allocated_rooms and max_attendees <= capacity: allocation[i] = j allocated_rooms.add(j) break return allocation"},{"question":"def find_pair_with_sum(nums: List[int], k: int) -> Union[Tuple[int, int], None]: Check if there exists a pair of integers (a, b) from the list such that their sum is equal to a given target value k. If such a pair exists, return the first pair found as a tuple (a, b). If no such pair exists, return None. >>> find_pair_with_sum([10, 15, 3, 7], 17) (10, 7) >>> find_pair_with_sum([1, 2, 3, 4], 8) None def test_find_pair_with_sum_positive_case(): assert find_pair_with_sum([10, 15, 3, 7], 17) == (10, 7) def test_find_pair_with_sum_no_pair(): assert find_pair_with_sum([1, 2, 3, 4], 8) == None def test_find_pair_with_sum_multiple_pairs(): assert find_pair_with_sum([1, 4, 3, 2, 4], 5) == (1, 4) def test_find_pair_with_sum_empty_list(): assert find_pair_with_sum([], 5) == None def test_find_pair_with_sum_single_element_list(): assert find_pair_with_sum([5], 5) == None def test_find_pair_with_sum_multiple_same_element(): assert find_pair_with_sum([5, 5, 5, 5], 10) == (5, 5)","solution":"def find_pair_with_sum(nums, k): Returns the first pair (a, b) found in the list such that a + b = k. If no such pair exists, returns None. seen = set() for num in nums: complement = k - num if complement in seen: return (complement, num) seen.add(num) return None"},{"question":"from itertools import permutations def generate_permutations(s: str, r: int): Generates all ordered permutations of the string s with length r and prints them line by line. >>> generate_permutations(\\"ABC\\", 2) AB AC BA BC CA CB >>> generate_permutations(\\"AB\\", 2) AB BA","solution":"from itertools import permutations def generate_permutations(s, r): Generates all ordered permutations of the string s with length r and prints them line by line. for perm in sorted(permutations(s, r)): print(''.join(perm))"},{"question":"from typing import List def maximum_coins(T: int, test_cases: List[List[List[int]]]) -> List[int]: Find the maximum number of coins that can be collected from the top-left to the bottom-right corner of each grid. :param T: an integer, the number of test cases :param test_cases: a list containing T grids, where each grid is an n x n list of integers :return: a list containing the maximum number of coins that can be collected for each grid >>> T = 2 >>> test_cases = [ ... [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ], ... [ ... [1, 2], ... [3, 4] ... ] ... ] >>> maximum_coins(T, test_cases) [29, 8]","solution":"def maximum_coins(T, test_cases): results = [] for t in range(T): grid = test_cases[t] n = len(grid) # Create a dp array with the same dimensions as grid initialized to zero dp = [[0] * n for _ in range(n)] # Fill in the dp array with the maximum path sums dp[0][0] = grid[0][0] for i in range(1, n): dp[i][0] = dp[i - 1][0] + grid[i][0] dp[0][i] = dp[0][i - 1] + grid[0][i] for i in range(1, n): for j in range(1, n): dp[i][j] = grid[i][j] + max(dp[i - 1][j], dp[i][j - 1]) results.append(dp[-1][-1]) return results"},{"question":"def is_palindromic_number(N: int) -> str: Returns \\"yes\\" if N is a palindromic number, otherwise returns \\"no\\". >>> is_palindromic_number(121) \\"yes\\" >>> is_palindromic_number(-121) \\"no\\" >>> is_palindromic_number(10) \\"no\\" >>> is_palindromic_number(0) \\"yes\\" >>> is_palindromic_number(12321) \\"yes\\" >>> is_palindromic_number(-12321) \\"no\\" >>> is_palindromic_number(7) \\"yes\\" def process_palindromic_numbers(T: int, numbers: list) -> list: Processes a list of numbers to check for palindromic numbers. Parameters: T (int): The number of test cases numbers (list): List of integers to be checked Returns: list: List of results (\\"yes\\" or \\"no\\") for each number >>> process_palindromic_numbers(3, [121, -121, 10]) [\\"yes\\", \\"no\\", \\"no\\"] >>> process_palindromic_numbers(2, [0, 12321]) [\\"yes\\", \\"yes\\"] >>> process_palindromic_numbers(1, [7]) [\\"yes\\"] >>> process_palindromic_numbers(4, [121, 1221, -444, 10]) [\\"yes\\", \\"yes\\", \\"no\\", \\"no\\"] >>> process_palindromic_numbers(5, [1, 1, 2, 2, 3]) [\\"yes\\", \\"yes\\", \\"yes\\", \\"yes\\", \\"yes\\"]","solution":"def is_palindromic_number(N: int) -> str: Returns \\"yes\\" if N is a palindromic number, otherwise returns \\"no\\". str_N = str(N) if str_N == str_N[::-1]: return \\"yes\\" else: return \\"no\\" def process_palindromic_numbers(T: int, numbers: list) -> list: Processes a list of numbers to check for palindromic numbers. Parameters: T (int): The number of test cases numbers (list): List of integers to be checked Returns: list: List of results (\\"yes\\" or \\"no\\") for each number results = [] for number in numbers: results.append(is_palindromic_number(number)) return results"},{"question":"def sum_mul(n, m): Returns the sum of all multiples of \`n\` below \`m\`. If \`m\` or \`n\` is not a positive integer, returns \\"INVALID\\". Examples: >>> sum_mul(2, 9) 20 >>> sum_mul(3, 10) 18 >>> sum_mul(4, -7) \\"INVALID\\" >>> sum_mul(0, 15) \\"INVALID\\"","solution":"def sum_mul(n, m): Returns the sum of all multiples of \`n\` below \`m\`. If \`m\` or \`n\` is not a positive integer, returns \\"INVALID\\". if not (isinstance(n, int) and isinstance(m, int)) or n <= 0 or m <= 0: return \\"INVALID\\" return sum(range(n, m, n))"},{"question":"def max_possible_number(n: int) -> int: Reorder the digits of a non-negative integer to create the largest possible integer. >>> max_possible_number(321) # 321 >>> max_possible_number(2134) # 4321 >>> max_possible_number(0) # 0","solution":"def max_possible_number(n): Returns the largest possible integer formed by rearranging the digits of the input non-negative integer n. # Store the count of each digit (0-9) digit_count = [0] * 10 # Extract digits and update their counts num = n while num > 0: digit = num % 10 digit_count[digit] += 1 num //= 10 # Construct the largest number by combining digits in reverse order max_number = 0 for digit in range(9, -1, -1): while digit_count[digit] > 0: max_number = max_number * 10 + digit digit_count[digit] -= 1 return max_number"},{"question":"def max_items(prices: List[int], k: int) -> int: Returns the maximum number of items that can be bought with exactly k amount of money. Example: >>> max_items([1, 3, 2, 5, 4], 7) 3 >>> max_items([10, 6, 8, 3, 7], 15) 2","solution":"def max_items(prices, k): Returns the maximum number of items that can be bought with exactly k amount of money. prices.sort() count = 0 for price in prices: if k >= price: k -= price count += 1 else: break return count"},{"question":"def arrayAnalysis(arr): Process an array of integers and return an object containing the mean, median, mode, and range. >>> arrayAnalysis([1, 2, 2, 3, 4]) {'mean': 2.4, 'median': 2, 'mode': [2], 'range': 3} >>> arrayAnalysis([1, 1, 2, 2, 3, 3]) {'mean': 2, 'median': 2.0, 'mode': [1, 2, 3], 'range': 2} >>> arrayAnalysis([]) {'mean': None, 'median': None, 'mode': [], 'range': None}","solution":"from collections import Counter import math def arrayAnalysis(arr): if not arr: return {\\"mean\\": None, \\"median\\": None, \\"mode\\": [], \\"range\\": None} n = len(arr) arr_sorted = sorted(arr) # mean mean_value = sum(arr) / n # median if n % 2 == 0: median_value = (arr_sorted[n // 2 - 1] + arr_sorted[n // 2]) / 2 else: median_value = arr_sorted[n // 2] # mode count = Counter(arr) max_freq = max(count.values()) mode_value = sorted([k for k, v in count.items() if v == max_freq]) # range range_value = max(arr) - min(arr) return {\\"mean\\": mean_value, \\"median\\": median_value, \\"mode\\": mode_value, \\"range\\": range_value}"},{"question":"def remove_adjacent_duplicates(s: str) -> str: Given a string s, returns the shortest string that can be obtained by removing characters from s to ensure no two adjacent characters are the same. >>> remove_adjacent_duplicates(\\"abccba\\") \\"abcba\\" >>> remove_adjacent_duplicates(\\"aabbcc\\") \\"abc\\" >>> remove_adjacent_duplicates(\\"aabbaa\\") \\"aba\\"","solution":"def remove_adjacent_duplicates(s): Given a string s, returns the shortest string that can be obtained by removing characters from s to ensure no two adjacent characters are the same. result = [] for char in s: if result and result[-1] == char: continue result.append(char) return ''.join(result)"},{"question":"from typing import List def min_operations_to_palindrome(s: str) -> int: Returns the minimum number of operations required to convert the string 's' into a palindrome. >>> min_operations_to_palindrome(\\"abac\\") 1 >>> min_operations_to_palindrome(\\"racecar\\") 0 def min_operations_for_multiple_cases(test_cases: List[str]) -> List[int]: Returns a list of results representing the minimum number of operations required to convert each string in test_cases into a palindrome. >>> min_operations_for_multiple_cases([\\"abac\\", \\"racecar\\"]) [1, 0] >>> min_operations_for_multiple_cases([\\"abc\\", \\"aabcdcb\\"]) [2, 2]","solution":"def min_operations_to_palindrome(s): Returns the minimum number of operations required to convert the string 's' into a palindrome. def longest_palindromic_subsequence(s): n = len(s) dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = 1 for cl in range(2, n+1): for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j] and cl == 2: dp[i][j] = 2 elif s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) return dp[0][n - 1] longest_palin_subseq_length = longest_palindromic_subsequence(s) return len(s) - longest_palin_subseq_length def min_operations_for_multiple_cases(test_cases): results = [] for case in test_cases: results.append(min_operations_to_palindrome(case)) return results"},{"question":"def rotate_matrix(matrix): Rotate a NxN matrix 90 degrees clockwise in place. Args: matrix (List[List[int]]): The NxN matrix to rotate. Example: >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate_matrix(matrix) >>> matrix [[7, 4, 1], [8, 5, 2], [9, 6, 3]] from solution import rotate_matrix def test_rotate_3x3_matrix(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(matrix) expected = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] assert matrix == expected def test_rotate_4x4_matrix(): matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] rotate_matrix(matrix) expected = [ [13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4] ] assert matrix == expected def test_rotate_2x2_matrix(): matrix = [ [1, 2], [3, 4] ] rotate_matrix(matrix) expected = [ [3, 1], [4, 2] ] assert matrix == expected def test_rotate_1x1_matrix(): matrix = [ [1] ] rotate_matrix(matrix) expected = [ [1] ] assert matrix == expected def test_rotate_5x5_matrix(): matrix = [ [1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25] ] rotate_matrix(matrix) expected = [ [21, 16, 11, 6, 1], [22, 17, 12, 7, 2], [23, 18, 13, 8, 3], [24, 19, 14, 9, 4], [25, 20, 15, 10, 5] ] assert matrix == expected","solution":"def rotate_matrix(matrix): Rotates the given NxN matrix 90 degrees clockwise in place. :param matrix: List[List[int]] - The NxN matrix to rotate n = len(matrix) for i in range(n // 2): for j in range(i, n - i - 1): # save the top element top = matrix[i][j] # move the left element to top matrix[i][j] = matrix[n - j - 1][i] # move the bottom element to left matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1] # move the right element to bottom matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1] # assign the saved top element to right matrix[j][n - i - 1] = top"},{"question":"def parking_lot_manager(N: int, M: int, events: List[str]) -> List[str]: Manage the cars arriving and departing in a parking lot and return the final state of the parking lot. ----Input: - N: Number of parking spots - M: Number of events - events: List of events either parking or departing ----Output: - List of plate numbers in the parking lot, if empty return [\\"Parking Lot Empty\\"] >>> parking_lot_manager(3, 7, [\\"P ABC123\\", \\"P DEF456\\", \\"P GHI789\\", \\"P JKL012\\", \\"D DEF456\\", \\"D XYZ987\\", \\"P ZZZ999\\"]) [\\"ABC123\\", \\"GHI789\\", \\"ZZZ999\\"] >>> parking_lot_manager(2, 4, [\\"P ABC123\\", \\"D ABC123\\", \\"P DEF456\\", \\"D DEF456\\"]) [\\"Parking Lot Empty\\"] parking_lot = [] parking_set = set() for event in events: event_type, plate_number = event.split() if event_type == 'P': if len(parking_lot) < N and plate_number not in parking_set: parking_lot.append(plate_number) parking_set.add(plate_number) elif event_type == 'D': if plate_number in parking_set: parking_lot.remove(plate_number) parking_set.remove(plate_number) return parking_lot if parking_lot else [\\"Parking Lot Empty\\"] from typing import List def test_parking_lot_manager_full_parking(): N = 3 M = 7 events = [ \\"P ABC123\\", \\"P DEF456\\", \\"P GHI789\\", \\"P JKL012\\", \\"D DEF456\\", \\"D XYZ987\\", \\"P ZZZ999\\" ] assert parking_lot_manager(N, M, events) == [\\"ABC123\\", \\"GHI789\\", \\"ZZZ999\\"] def test_parking_lot_manager_empty_lot(): N = 2 M = 4 events = [ \\"P ABC123\\", \\"D ABC123\\", \\"P DEF456\\", \\"D DEF456\\" ] assert parking_lot_manager(N, M, events) == [\\"Parking Lot Empty\\"] def test_parking_lot_manager_departing_non_present_cars(): N = 2 M = 4 events = [ \\"P ABC123\\", \\"D XYZ987\\", \\"P DEF456\\", ] assert parking_lot_manager(N, M, events) == [\\"ABC123\\", \\"DEF456\\"] def test_parking_lot_manager_all_parked(): N = 3 M = 3 events = [ \\"P ABC123\\", \\"P DEF456\\", \\"P GHI789\\", ] assert parking_lot_manager(N, M, events) == [\\"ABC123\\", \\"DEF456\\", \\"GHI789\\"] def test_parking_lot_manager_ignore_full(): N = 2 M = 5 events = [ \\"P ABC123\\", \\"P DEF456\\", \\"P GHI789\\", \\"D ABC123\\", \\"P GHI789\\" ] assert parking_lot_manager(N, M, events) == [\\"DEF456\\", \\"GHI789\\"]","solution":"def parking_lot_manager(N, M, events): Manages the parking events and returns the current state of the parking lot. parking_lot = [] parking_set = set() # To quickly check if a car is currently in the parking lot for event in events: event_type, plate_number = event.split() if event_type == 'P': if len(parking_lot) < N and plate_number not in parking_set: parking_lot.append(plate_number) parking_set.add(plate_number) elif event_type == 'D': if plate_number in parking_set: parking_lot.remove(plate_number) parking_set.remove(plate_number) return parking_lot if parking_lot else [\\"Parking Lot Empty\\"]"},{"question":"def min_insertions_deletions_to_palindrome(n: int, s: str) -> int: Given a string of digits, determine the minimum number of insertions or deletions needed to make the string a palindrome. >>> min_insertions_deletions_to_palindrome(4, '1231') 1 >>> min_insertions_deletions_to_palindrome(3, '121') 0 >>> min_insertions_deletions_to_palindrome(5, '12321') 0 >>> min_insertions_deletions_to_palindrome(6, '123321') 0 >>> min_insertions_deletions_to_palindrome(5, '54321') 4 >>> min_insertions_deletions_to_palindrome(7, '1221321') 2 pass def solve(test_cases: List[Tuple[int, str]]) -> List[int]: Process multiple test cases to determine the minimum number of insertions or deletions needed to make each string a palindrome. >>> solve([(4, '1231'), (3, '121')]) [1, 0] >>> solve([(5, '54321'), (6, '123321')]) [4, 0] pass","solution":"def min_insertions_deletions_to_palindrome(n, s): # Create a table to store results of subproblems L = [[0] * n for _ in range(n)] # Strings of length 1 are palindrome of length 1 for i in range(n): L[i][i] = 1 # Build the table for cl in range(2, n + 1): for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j]: if cl == 2: L[i][j] = 2 else: L[i][j] = L[i + 1][j - 1] + 2 else: L[i][j] = max(L[i][j - 1], L[i + 1][j]) # The minimum number of deletions or insertions needed return n - L[0][n-1] def solve(test_cases): results = [] for n, s in test_cases: results.append(min_insertions_deletions_to_palindrome(n, s)) return results # Sample usage # test_cases format: [(N, S), ...] test_cases = [(4, '1231'), (3, '121')] print(solve(test_cases)) # Output should be [1, 0]"},{"question":"def find_substring_indices(s: str, word_list: List[str]) -> List[int]: Given a string \`s\` and a list of words \`word_list\`, find all starting indices of substring(s) in \`s\` that is a concatenation of each word in \`word_list\` exactly once and without any intervening characters. >>> find_substring_indices(\\"barfoothefoobarman\\", [\\"foo\\",\\"bar\\"]) [0, 9] >>> find_substring_indices(\\"wordgoodgoodgoodbestword\\", [\\"word\\",\\"good\\",\\"best\\",\\"word\\"]) [] >>> find_substring_indices(\\"barfoofoobarthefoobarman\\", [\\"bar\\",\\"foo\\",\\"the\\"]) [6, 9, 12] >>> find_substring_indices(\\"wordwordword\\", [\\"word\\"]) [0, 4, 8] >>> find_substring_indices(\\"abcdefg\\", [\\"hij\\"]) [] >>> find_substring_indices(\\"\\", [\\"foo\\",\\"bar\\"]) [] >>> find_substring_indices(\\"barfoothefoobarman\\", []) [] >>> find_substring_indices(\\"foofoofoofoo\\", [\\"foo\\",\\"foo\\"]) [0, 3, 6]","solution":"def find_substring_indices(s, word_list): if not s or not word_list: return [] word_length = len(word_list[0]) number_of_words = len(word_list) substring_length = word_length * number_of_words word_count = {word: word_list.count(word) for word in word_list} result_indices = [] for i in range(word_length): left = i right = i current_count = {} current_word_count = 0 while right + word_length <= len(s): word = s[right:right + word_length] right += word_length if word in word_count: current_count[word] = current_count.get(word, 0) + 1 current_word_count += 1 while current_count[word] > word_count[word]: left_word = s[left:left + word_length] current_count[left_word] -= 1 current_word_count -= 1 left += word_length if current_word_count == number_of_words: result_indices.append(left) else: current_count = {} current_word_count = 0 left = right return result_indices"},{"question":"def game_of_life(initial_grid: List[str], n: int) -> List[str]: Compute the state of the grid after n generations for Conway's Game of Life. >>> game_of_life([ \\"....\\", \\".**.\\", \\".**.\\", \\"....\\" ], 1) ['....', '.**.', '.**.', '....'] >>> game_of_life([ \\".....\\", \\"..*..\\", \\"..*..\\", \\"..*..\\", \\".....\\" ], 1) ['.....', '.....', '.***.', '.....', '.....'] >>> game_of_life([ \\"....\\", \\"....\\", \\"....\\", \\"....\\" ], 1) ['....', '....', '....', '....'] >>> game_of_life([ \\".....\\", \\"..*..\\", \\"..*..\\", \\"..*..\\", \\".....\\" ], 2) ['.....', '..*..', '..*..', '..*..', '.....'] >>> game_of_life([ \\"......\\", \\"......\\", \\"..***.\\", \\".***..\\", \\"......\\", \\"......\\" ], 1) ['......', '...*..', '.*..*.', '.*..*.', '..*...', '......']","solution":"def game_of_life(initial_grid, n): def get_neighbors(x, y, grid, rows, cols): direction_vectors = [ (-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1) ] neighbors = 0 for dx, dy in direction_vectors: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == '*': neighbors += 1 return neighbors rows, cols = len(initial_grid), len(initial_grid[0]) # Convert the initial grid to a list of lists current_grid = [list(row) for row in initial_grid] for _ in range(n): new_grid = [['.' for _ in range(cols)] for _ in range(rows)] for i in range(rows): for j in range(cols): neighbors = get_neighbors(i, j, current_grid, rows, cols) if current_grid[i][j] == '*' and neighbors in [2, 3]: new_grid[i][j] = '*' elif current_grid[i][j] == '.' and neighbors == 3: new_grid[i][j] = '*' # Convert new_grid back to list of strings current_grid = new_grid return [''.join(row) for row in current_grid]"},{"question":"def insert_spaces(s: str, spaces: List[int]) -> str: Inserts spaces into string \`s\` at the positions specified in \`spaces\`. Parameters: s (str): The input string. spaces (list of int): The list of positions to insert spaces. Returns: str: The resulting string with added spaces. >>> insert_spaces(\\"hellothere\\", [5]) 'hello there' >>> insert_spaces(\\"hellotheremyfriend\\", [5, 10, 12]) 'hello there my friend' >>> insert_spaces(\\"abcdef\\", [2, 4]) 'ab cd ef' >>> insert_spaces(\\"abcdef\\", []) 'abcdef' >>> insert_spaces(\\"abcdef\\", [0, 6]) ' abcdef '","solution":"def insert_spaces(s, spaces): Inserts spaces into string \`s\` at the positions specified in \`spaces\`. Parameters: s (str): The input string. spaces (list of int): The list of positions to insert spaces. Returns: str: The resulting string with added spaces. offset = 0 for pos in spaces: s = s[:pos + offset] + ' ' + s[pos + offset:] offset += 1 return s"},{"question":"def has_three_occurrences(nums: List[int]) -> bool: Returns True if there is an element with at least three occurrences in the array. >>> has_three_occurrences([1, 2, 3, 1, 2, 1]) True >>> has_three_occurrences([1, 2, 3, 4]) False >>> has_three_occurrences([1, 1, 1, 2, 2, 3, 3, 3, 3]) True","solution":"def has_three_occurrences(nums): Returns True if there is an element with at least three occurrences in the array. from collections import Counter counts = Counter(nums) for count in counts.values(): if count >= 3: return True return False"},{"question":"import math from typing import List def format_numbers(nums: List[int]) -> str: Returns a formatted string where: 1. Numbers in the array that are perfect squares are replaced with the string \\"Square\\". 2. Numbers that are perfect cubes are replaced with the string \\"Cube\\". 3. Numbers that are both perfect squares and perfect cubes are replaced with the string \\"Square-Cube\\". Join the resultant strings using a comma and space \\", \\". Examples: >>> format_numbers([1, 3, 4, 8, 9, 16, 27, 64, 81]) 'Square-Cube, 3, Square, Cube, Square, Square, Cube, Square-Cube, Square' >>> format_numbers([4, 9, 16, 25, 36]) 'Square, Square, Square, Square, Square' >>> format_numbers([8, 27, 64, 125, 216]) 'Cube, Cube, Square-Cube, Cube, Cube' >>> format_numbers([2, 3, 5, 7, 10]) '2, 3, 5, 7, 10'","solution":"import math def is_perfect_square(n): return int(math.sqrt(n)) ** 2 == n def is_perfect_cube(n): return int(round(n ** (1/3))) ** 3 == n def format_numbers(nums): results = [] for num in nums: if is_perfect_square(num) and is_perfect_cube(num): results.append(\\"Square-Cube\\") elif is_perfect_square(num): results.append(\\"Square\\") elif is_perfect_cube(num): results.append(\\"Cube\\") else: results.append(str(num)) return \\", \\".join(results) # Example usage: print(format_numbers([1, 3, 4, 8, 9, 16, 27, 64, 81]))"},{"question":"def maxLikeGain(timestamps, likes): Given a list of timestamps and the corresponding number of likes, find the maximum gain in likes for any two valid timestamps such that the first timestamp is strictly less than the second timestamp. Parameters: timestamps (list): A list of integers representing the timestamps in ascending order. likes (list): A list of integers representing the number of likes at each timestamp. Returns: int: The maximum gain in likes between any two timestamps. # Unit tests def test_increasing_likes(): timestamps = [1, 2, 3, 4, 5] likes = [10, 15, 20, 25, 30] assert maxLikeGain(timestamps, likes) == 20 def test_decreasing_likes(): timestamps = [1, 2, 3, 4, 5] likes = [30, 25, 20, 15, 10] assert maxLikeGain(timestamps, likes) == 0 def test_fluctuating_likes(): timestamps = [1, 2, 3, 4, 5] likes = [10, 5, 15, 10, 20] assert maxLikeGain(timestamps, likes) == 15 def test_constant_likes(): timestamps = [1, 2, 3, 4, 5] likes = [10, 10, 10, 10, 10] assert maxLikeGain(timestamps, likes) == 0 def test_single_increase(): timestamps = [1, 2] likes = [5, 10] assert maxLikeGain(timestamps, likes) == 5","solution":"def maxLikeGain(timestamps, likes): Parameters: timestamps (list): A list of integers representing the timestamps in ascending order. likes (list): A list of integers representing the number of likes at each timestamp. Returns: int: The maximum gain in likes between any two timestamps. min_likes = likes[0] max_gain = 0 for i in range(1, len(likes)): # Update the max_gain for the current timestamp gain = likes[i] - min_likes max_gain = max(max_gain, gain) # Update the minimum likes seen so far min_likes = min(min_likes, likes[i]) return max_gain"},{"question":"def reformat_string(s: str) -> str: Reformats the given string by moving all lowercase characters to the beginning, followed by all uppercase characters. The relative order of characters is maintained. Args: s (str): The input string containing lowercase and uppercase alphabetic characters. Returns: str: The reformatted string. Examples: >>> reformat_string(\\"aBcDeF\\") \\"aceBDF\\" >>> reformat_string(\\"HelloWorld\\") \\"elloorldHW\\" >>> reformat_string(\\"Python\\") \\"ythonP\\"","solution":"def reformat_string(s): Reformats the given string by moving all lowercase characters to the beginning, followed by all uppercase characters. The relative order of characters is maintained. Args: s (str): The input string containing lowercase and uppercase alphabetic characters. Returns: str: The reformatted string. lowercase = [char for char in s if char.islower()] uppercase = [char for char in s if char.isupper()] return ''.join(lowercase + uppercase)"},{"question":"from typing import List def sort_odds(lst: List[int]) -> List[int]: Sort the odd numbers in a list in ascending order while keeping the even numbers in their original positions. >>> sort_odds([5, 3, 2, 8, 1, 4]) [1, 3, 2, 8, 5, 4] >>> sort_odds([7, 3, 5, 1]) [1, 3, 5, 7] >>> sort_odds([4, 2, 6, 8]) [4, 2, 6, 8] >>> sort_odds([9, 8, 7, 6, 5]) [5, 8, 7, 6, 9] >>> sort_odds([5, -3, 2, 7, 1, -4]) [-3, 1, 2, 5, 7, -4] >>> sort_odds([1]) [1] >>> sort_odds([2]) [2] >>> sort_odds([]) [] >>> sort_odds([4, 1, 5, 3, 10]) [4, 1, 3, 5, 10]","solution":"from typing import List def sort_odds(lst: List[int]) -> List[int]: # Extracting odd numbers and sorting them sorted_odds = sorted([x for x in lst if x % 2 != 0]) # Index to keep track of position in sorted_odds odd_index = 0 # Result list where sorted odd numbers and original even numbers are kept result = [] for x in lst: if x % 2 == 0: # If the number is even, we keep it in its original position result.append(x) else: # If the number is odd, we take the next sorted odd number result.append(sorted_odds[odd_index]) odd_index += 1 return result"},{"question":"def longest_contiguous_substring(s: str) -> str: Returns the longest contiguous substring that contains the same character. If there are multiple substrings of the same length, returns the one that appears first. >>> longest_contiguous_substring(\\"aaabbbaaaccc\\") == \\"aaa\\" >>> longest_contiguous_substring(\\"abcd\\") == \\"a\\" >>> longest_contiguous_substring(\\"abbbcccd\\") == \\"bbb\\"","solution":"def longest_contiguous_substring(s): Returns the longest contiguous substring that contains the same character. If there are multiple substrings of the same length, returns the one that appears first. if not s: return \\"\\" max_len = 1 current_len = 1 max_substring = s[0] current_char = s[0] for i in range(1, len(s)): if s[i] == s[i-1]: current_len += 1 if current_len > max_len: max_len = current_len max_substring = s[i-current_len+1:i+1] else: current_len = 1 current_char = s[i] return max_substring"},{"question":"def min_adjacent_swaps(n, arr): Returns the minimum number of adjacent swaps required to sort the array. >>> min_adjacent_swaps(3, [3, 1, 2]) 2 >>> min_adjacent_swaps(4, [4, 3, 2, 1]) 6 pass def process_test_cases(T, test_cases): Processes the test cases and returns results of minimum swaps required for each. >>> test_cases = [(3, [3, 1, 2]), (4, [4, 3, 2, 1])] >>> process_test_cases(2, test_cases) [2, 6] pass","solution":"def min_adjacent_swaps(n, arr): Returns the minimum number of adjacent swaps required to sort the array. # Implementation of bubble sort to count number of swaps swaps = 0 for i in range(n): for j in range(n - 1): if arr[j] > arr[j + 1]: # Swap adjacent elements arr[j], arr[j + 1] = arr[j + 1], arr[j] swaps += 1 return swaps def process_test_cases(T, test_cases): Processes the test cases and returns results of minimum swaps required for each. results = [] for case in test_cases: n, arr = case results.append(min_adjacent_swaps(n, arr)) return results"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Create a function that takes an array of integers and returns a new array of integers where each element is the product of all the other elements in the original array, excluding the current element. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([3, 2, 1]) [2, 3, 6]","solution":"def product_except_self(nums): Returns an array where each element is the product of all the elements except the one at the current position in the original array. length = len(nums) if length == 0: return [] # Initialize the result array with ones. result = [1] * length # Compute the prefix product for each element. prefix_product = 1 for i in range(length): result[i] = prefix_product prefix_product *= nums[i] # Compute the postfix product for each element and multiply it to the result. postfix_product = 1 for i in range(length - 1, -1, -1): result[i] *= postfix_product postfix_product *= nums[i] return result"},{"question":"def can_allocate_stages(bands: List[int], capacity: int) -> bool: Determines if all stages can hold the specified number of bands without exceeding capacity. Parameters: bands (list of int): The number of bands for each stage. capacity (int): The maximum capacity of any stage. Returns: bool: True if all stages can hold the bands without exceeding capacity, False otherwise. >>> can_allocate_stages([3, 5, 2, 4], 5) True >>> can_allocate_stages([6, 3, 2, 4], 5) False from solution import can_allocate_stages def test_all_stages_within_capacity(): assert can_allocate_stages([3, 5, 2, 4], 5) == True assert can_allocate_stages([1, 2, 3, 4], 4) == True assert can_allocate_stages([10, 20, 30], 30) == True def test_some_stages_exceed_capacity(): assert can_allocate_stages([6, 3, 2, 4], 5) == False assert can_allocate_stages([5, 5, 5, 6], 5) == False assert can_allocate_stages([10, 10, 10, 11], 10) == False def test_all_stages_exceed_capacity(): assert can_allocate_stages([6, 7, 8], 5) == False assert can_allocate_stages([51, 52], 50) == False def test_minimum_edge_cases(): assert can_allocate_stages([1], 1) == True assert can_allocate_stages([1], 2) == True assert can_allocate_stages([2], 1) == False def test_multiple_edge_cases(): assert can_allocate_stages([50, 49], 50) == True assert can_allocate_stages([50, 51], 50) == False","solution":"def can_allocate_stages(bands, capacity): Determines if all stages can hold the specified number of bands without exceeding capacity. Parameters: bands (list of int): The number of bands for each stage. capacity (int): The maximum capacity of any stage. Returns: bool: True if all stages can hold the bands without exceeding capacity, False otherwise. for band_count in bands: if band_count > capacity: return False return True"},{"question":"from typing import List def mirror_numbers(nums: List[int], start: int, end: int) -> List[int]: Transform each number into its \\"mirror\\" in the specified range. Args: nums (List[int]): A list of integers. start (int): The lower bound of the range. end (int): The upper bound of the range. Returns: List[int]: A new list of integers where each integer from the input list is replaced by its mirror in the given range. >>> mirror_numbers([2, 5, 9], 1, 10) [9, 6, 2] >>> mirror_numbers([1, 4, 7, 10], 1, 5) [5, 2, -1, -4] >>> mirror_numbers([3, 3, 3], 3, 6) [6, 6, 6] >>> mirror_numbers([], 0, 100) []","solution":"from typing import List def mirror_numbers(nums: List[int], start: int, end: int) -> List[int]: Transform each number into its \\"mirror\\" in the specified range. Args: nums (List[int]): A list of integers. start (int): The lower bound of the range. end (int): The upper bound of the range. Returns: List[int]: A new list of integers where each integer from the input list is replaced by its mirror in the given range. return [start + (end - x) for x in nums]"},{"question":"def is_valid_dna_sequence(s: str, k: int) -> str: Determine if the DNA sequence is valid based on the given conditions. A valid DNA sequence does not contain more than \`k\` consecutive identical characters. :param s: str, the DNA sequence :param k: int, the maximum number of consecutive identical characters allowed :return: str, \\"Valid\\" or \\"Invalid\\" >>> is_valid_dna_sequence('ATTGCC', 2) \\"Valid\\" >>> is_valid_dna_sequence('AAAATTTCCCGGG', 3) \\"Invalid\\" >>> is_valid_dna_sequence('GGGGGGG', 1) \\"Invalid\\" >>> is_valid_dna_sequence('A', 1) \\"Valid\\" >>> is_valid_dna_sequence('AA', 1) \\"Invalid\\" >>> is_valid_dna_sequence('AA', 2) \\"Valid\\" def main(): import sys input = sys.stdin.read data = input().split() idx = 0 T = int(data[idx]) idx += 1 results = [] for _ in range(T): S = data[idx] idx += 1 k = int(data[idx]) idx += 1 results.append(is_valid_dna_sequence(S, k)) for result in results: print(result)","solution":"def is_valid_dna_sequence(s, k): Determine if the DNA sequence is valid based on the given conditions. A valid DNA sequence does not contain more than \`k\` consecutive identical characters. :param s: str, the DNA sequence :param k: int, the maximum number of consecutive identical characters allowed :return: str, \\"Valid\\" or \\"Invalid\\" count = 1 for i in range(1, len(s)): if s[i] == s[i-1]: count += 1 if count > k: return \\"Invalid\\" else: count = 1 return \\"Valid\\" def main(): import sys input = sys.stdin.read data = input().split() idx = 0 T = int(data[idx]) idx += 1 results = [] for _ in range(T): S = data[idx] idx += 1 k = int(data[idx]) idx += 1 results.append(is_valid_dna_sequence(S, k)) for result in results: print(result)"},{"question":"def modify_integers(s: str) -> str: Takes a string input containing a list of integers separated by spaces, and returns a new string where all the even integers are doubled and odd integers are left unchanged. >>> modify_integers(\\"3 4 7 8 10 13\\") '3 8 7 16 20 13' >>> modify_integers(\\"2 4 6 8\\") '4 8 12 16'","solution":"def modify_integers(s): Takes a string input containing a list of integers separated by spaces, and returns a new string where all the even integers are doubled and odd integers are left unchanged. ints = map(int, s.split()) modified_ints = [str(x * 2) if x % 2 == 0 else str(x) for x in ints] return ' '.join(modified_ints)"},{"question":"def can_partition_into_three_equal_sums(B: List[int]) -> bool: Determine if the array B can be partitioned into three non-empty parts with equal sums. >>> can_partition_into_three_equal_sums([0,2,1,-6,6,-7,9,1,2,0,1]) True >>> can_partition_into_three_equal_sums([0,2,1,-6,6,7,9,-1,2,0,1]) False >>> can_partition_into_three_equal_sums([3,3,6,5,-2,2,5,1,-9,4]) True from solution import can_partition_into_three_equal_sums def test_partition_example_1(): B = [0,2,1,-6,6,-7,9,1,2,0,1] assert can_partition_into_three_equal_sums(B) == True def test_partition_example_2(): B = [0,2,1,-6,6,7,9,-1,2,0,1] assert can_partition_into_three_equal_sums(B) == False def test_partition_example_3(): B = [3,3,6,5,-2,2,5,1,-9,4] assert can_partition_into_three_equal_sums(B) == True def test_partition_single_element(): B = [6] assert can_partition_into_three_equal_sums(B) == False def test_partition_negative_numbers(): B = [-1, -1, -1, -3, -3] assert can_partition_into_three_equal_sums(B) == True def test_partition_all_zeros(): B = [0, 0, 0, 0] assert can_partition_into_three_equal_sums(B) == True def test_partition_large_array(): B = [1]*150000 assert can_partition_into_three_equal_sums(B) == True def test_partition_not_partitionalbe(): B = [3, 3, 4] assert can_partition_into_three_equal_sums(B) == False","solution":"def can_partition_into_three_equal_sums(B): Determine if the array B can be partitioned into three non-empty parts with equal sums. total_sum = sum(B) if total_sum % 3 != 0: return False target_sum = total_sum // 3 part_sum = 0 count = 0 for num in B: part_sum += num if part_sum == target_sum: count += 1 part_sum = 0 if count == 3: return True return False"},{"question":"def collect_cans(robot, grid): Returns the list of moves the robot makes to collect all the cans. The robot's starting coordinates and the grid will be passed as input. Example: >>> collect_cans([1, 1], [[0, -1, 0], [1, 1, 0], [-1, 1, 1]]) ['D', 'R', 'U', 'R', 'D'] or any valid sequence >>> collect_cans([2, 2], [[0, -1, 0], [1, 0, 1], [0, -1, 1]]) ['U', 'U', 'L', 'R', 'D'] or any valid sequence >>> collect_cans([0, 1], [[1, -1, 0], [0, 0, 0], [-1, 0, 0]]) [\\"NoRobot\\"] >>> collect_cans([0, 0], [[0, -1, 0], [0, 0, 0], [-1, 0, 0]]) [] from solution import collect_cans def test_no_robot(): assert collect_cans([5, 0], [[0, -1, 0], [1, 1, 0], [-1, 1, 1]]) == \\"NoRobot\\" def test_no_cans(): assert collect_cans([0, 0], [[0, -1, 0], [0, 0, 0], [-1, 0, 0]]) == [] def test_collect_cans_1(): robot = [1, 1] grid = [ [0, -1, 0], [1, 1, 0], [-1, 1, 1] ] moves = collect_cans(robot, grid) assert moves == ['D', 'R', 'U', 'R', 'D'] or True # True to handle any valid sequence def test_collect_cans_2(): robot = [2, 2] grid = [ [0, -1, 0], [1, 0, 1], [0, -1, 1] ] moves = collect_cans(robot, grid) assert moves == ['U', 'U', 'L', 'R', 'D'] or True def test_collect_cans_3(): robot = [0, 1] grid = [ [1, -1, 0], [0, 0, 0], [-1, 0, 0] ] moves = collect_cans(robot, grid) assert moves == ['R'] or True def test_collect_cans_4(): robot = [0, 0] grid = [ [1, 0], [0, -1], [1, 1] ] moves = collect_cans(robot, grid) assert moves == ['R', 'D', 'D'] or True","solution":"def collect_cans(robot, grid): Returns the list of moves the robot makes to collect all the cans. rows = len(grid) cols = len(grid[0]) r, c = robot # Check if robot is outside the grid if not (0 <= r < rows and 0 <= c < cols): return \\"NoRobot\\" # Directions: up, down, left, right directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)} def is_valid(x, y): return 0 <= x < rows and 0 <= y < cols and grid[x][y] != -1 moves = [] visited = set() cans = [] def dfs(x, y): if not is_valid(x, y) or (x, y) in visited: return visited.add((x, y)) if grid[x][y] == 1: cans.append((x, y)) for direction, (dx, dy) in directions.items(): nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: moves.append(direction) dfs(nx, ny) # Backtrack move if direction == 'U': moves.append('D') elif direction == 'D': moves.append('U') elif direction == 'L': moves.append('R') elif direction == 'R': moves.append('L') dfs(r, c) # If no cans found, return empty list if not cans: return [] result_moves = [] current_r, current_c = r, c for can_r, can_c in cans: while (current_r, current_c) != (can_r, can_c): if current_r < can_r: result_moves.append('D') current_r += 1 elif current_r > can_r: result_moves.append('U') current_r -= 1 elif current_c < can_c: result_moves.append('R') current_c += 1 elif current_c > can_c: result_moves.append('L') current_c -= 1 return result_moves"},{"question":"def process_operations(n: int, m: int, operations: List[str]) -> List[int]: Process a series of operations on compost bins. :param n: Number of bins :param m: Number of operations :param operations: List of operations, each being either an addition or a query :return: List of query results >>> process_operations(5, 4, [\\"Q 1\\", \\"A 1 3 5\\", \\"Q 3\\", \\"A 2 5 2\\", \\"Q 4\\"]) [0, 5, 2] >>> process_operations(3, 3, [\\"Q 1\\", \\"Q 2\\", \\"Q 3\\"]) [0, 0, 0] >>> process_operations(5, 2, [\\"A 1 5 10\\", \\"Q 3\\"]) [10] >>> process_operations(5, 6, [\\"A 1 2 10\\", \\"A 2 3 5\\", \\"Q 1\\", \\"Q 2\\", \\"Q 3\\", \\"Q 4\\"]) [10, 15, 5, 0] >>> process_operations(5, 5, [\\"A 1 2 10\\", \\"A 3 4 5\\", \\"Q 1\\", \\"Q 3\\", \\"Q 5\\"]) [10, 5, 0]","solution":"def process_operations(n, m, operations): Process a series of operations on compost bins. :param n: Number of bins :param m: Number of operations :param operations: List of operations, each being either an addition or a query :return: List of query results bins = [0] * (n + 1) # Using 1-based indexing def add_waste(u, v, k): bins[u] += k if v + 1 <= n: bins[v + 1] -= k results = [] for operation in operations: parts = operation.split() if parts[0] == 'A': u = int(parts[1]) v = int(parts[2]) k = int(parts[3]) add_waste(u, v, k) elif parts[0] == 'Q': p = int(parts[1]) current_waste = 0 for i in range(1, p + 1): current_waste += bins[i] results.append(current_waste) return results"},{"question":"def most_frequent_char(s: str) -> str: Returns the character that appears the most frequently in the string s. If multiple characters have the same highest frequency, return the one that appears first. >>> most_frequent_char(\\"sample string\\") == \\"s\\" >>> most_frequent_char(\\"aabbcc\\") == \\"a\\" >>> most_frequent_char(\\"abcdef\\") == \\"a\\" >>> most_frequent_char(\\"\\") == \\"\\" >>> most_frequent_char(\\"a b b c\\") == \\" \\" >>> most_frequent_char(\\"123@!@\\") == \\"@\\"","solution":"def most_frequent_char(s): Returns the character that appears the most frequently in the string s. If multiple characters have the same highest frequency, return the one that appears first. char_frequency = {} for char in s: char_frequency[char] = char_frequency.get(char, 0) + 1 max_frequency = 0 most_frequent = '' for char in s: if char_frequency[char] > max_frequency: max_frequency = char_frequency[char] most_frequent = char return most_frequent"},{"question":"def digit_sum(n: int) -> int: Returns the sum of the digits of the integer n. If n is negative, it treats it as if it were positive. >>> digit_sum(1234) 10 >>> digit_sum(-567) 18 >>> digit_sum(0) 0 >>> digit_sum(7) 7 >>> digit_sum(-7) 7 >>> digit_sum(1000) 1 >>> digit_sum(5050) 10 >>> digit_sum(123456789) 45","solution":"def digit_sum(n): Returns the sum of the digits of the integer n. If n is negative, it treats it as if it were positive. n = abs(n) # Ensure n is positive return sum(int(digit) for digit in str(n))"},{"question":"from typing import List def sorted_domains_by_count(urls: List[str]) -> List[str]: Implement a function that takes as input a list of URLs and returns a list of domains sorted by the number of times they appear in the list. If two domains have the same count, they should be sorted lexicographically by the domain name. >>> sorted_domains_by_count([ ... \\"http://example.com/path\\", ... \\"https://example.org/resource\\", ... \\"http://example.com/another/path\\", ... \\"http://example.net\\", ... \\"https://example.org/another/resource\\" ... ]) == ['example.com', 'example.org', 'example.net'] >>> sorted_domains_by_count([\\"http://single.com/path\\"]) == ['single.com'] >>> sorted_domains_by_count([ ... \\"http://example.com/path1\\", ... \\"http://example.com/path2\\", ... \\"http://example.com/path3\\" ... ]) == ['example.com'] >>> sorted_domains_by_count([ ... \\"http://b.com/path\\", ... \\"http://a.com/path\\", ... \\"http://b.com/another/path\\", ... \\"http://a.com/second/path\\" ... ]) == ['a.com', 'b.com'] >>> sorted_domains_by_count([ ... \\"https://sub.example.com/path\\", ... \\"http://example.com\\", ... \\"http://sub.example.com/another/path\\", ... \\"https://example.com/resource\\" ... ]) == ['example.com', 'sub.example.com'] pass","solution":"from collections import Counter from urllib.parse import urlparse def sorted_domains_by_count(urls): Returns a list of domains sorted by the number of times they appear in the input list. If two domains have the same count, they are sorted lexicographically. domains = [urlparse(url).netloc for url in urls] domain_counter = Counter(domains) sorted_domains = sorted(domain_counter.items(), key=lambda x: (-x[1], x[0])) return [domain for domain, count in sorted_domains]"},{"question":"def longest_consecutive_subsequence_length(arr): Find the length of the longest subsequence that contains consecutive integers. >>> longest_consecutive_subsequence_length([1, 9, 3, 10, 4, 20, 2]) 4 >>> longest_consecutive_subsequence_length([]) 0 >>> longest_consecutive_subsequence_length([10, 20, 30, 40, 50]) 1 >>> longest_consecutive_subsequence_length([5, 5, 5, 5]) 1 >>> longest_consecutive_subsequence_length([1, 2, 3, 4, 5]) 5 >>> longest_consecutive_subsequence_length([1, 3, 5, 2, 4]) 5 >>> longest_consecutive_subsequence_length([1]) 1 >>> longest_consecutive_subsequence_length(list(range(1000000, 1000100))) 100 >>> longest_consecutive_subsequence_length(list(range(1000000, 1000100)) + list(range(2000000, 2000010))) 100","solution":"def longest_consecutive_subsequence_length(arr): Find the length of the longest subsequence that contains consecutive integers. if not arr: return 0 num_set = set(arr) longest_length = 0 for num in arr: if num - 1 not in num_set: # Check if it's the start of a sequence current_num = num current_length = 1 while current_num + 1 in num_set: current_num += 1 current_length += 1 longest_length = max(longest_length, current_length) return longest_length"},{"question":"from typing import List def min_unique_elements(arr: List[int]) -> int: This function determines the minimum number of unique elements that the array can contain after performing the specified operations any number of times. Input: arr : List[int] : the array of integers Output: int : the minimum number of unique elements the array can contain >>> min_unique_elements([1, 2, 3, 4]) 1 >>> min_unique_elements([10, 20, 30]) 1 pass def process_test_cases(test_cases: List[List[int]]) -> List[int]: Processes multiple test cases to find the minimum number of unique elements for each. Input: test_cases : List[List[int]] : list of test cases where each test case is a list of integers Output: List[int] : list of results for each test case >>> process_test_cases([[1, 2, 3, 4], [10, 20, 30]]) [1, 1] pass def parse_input(input_lines: List[str]) -> List[List[int]]: Parses input lines to extract test cases. Input: input_lines : List[str] : list of input lines Output: List[List[int]] : list of test cases where each test case is a list of integers >>> parse_input([\\"2\\", \\"4\\", \\"1 2 3 4\\", \\"3\\", \\"10 20 30\\"]) [[1, 2, 3, 4], [10, 20, 30]] pass","solution":"def min_unique_elements(arr): This function determines the minimum number of unique elements that the array can contain after performing the specified operations any number of times. Input: arr : List[int] : the array of integers Output: int : the minimum number of unique elements the array can contain if not arr or len(arr) == 1: return len(arr) # Eventually we can make all elements zero through the given operations return 1 def process_test_cases(test_cases): results = [] for arr in test_cases: results.append(min_unique_elements(arr)) return results def parse_input(input_lines): it = iter(input_lines) T = int(next(it)) test_cases = [] for _ in range(T): N = int(next(it)) array = list(map(int, next(it).split())) test_cases.append(array) return test_cases"},{"question":"def can_assign_tas(T: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[str]: Determines if it is possible to meet the TA needs for all classes and print the result for each case. >>> can_assign_tas(3, [((3, 10), [3, 3, 4]), ((2, 5), [3, 4]), ((4, 10), [3, 3, 3, 1])]) ['Possible', 'Impossible', 'Possible'] >>> can_assign_tas(2, [((2, 6), [1, 2]), ((3, 10), [1, 2, 4])]) ['Possible', 'Possible'] >>> can_assign_tas(2, [((2, 2), [2, 3]), ((3, 7), [3, 3, 3])]) ['Impossible', 'Impossible'] >>> can_assign_tas(1, [((2, 0), [0, 0])]) ['Possible'] >>> can_assign_tas(1, [((2, 10000), [5000, 5000])]) ['Possible']","solution":"def can_assign_tas(T, test_cases): results = [] for i in range(T): N, M = test_cases[i][0] required_tas = test_cases[i][1] if sum(required_tas) <= M: results.append('Possible') else: results.append('Impossible') return results # Example usage for the function (to see how it works): T = 3 test_cases = [ [(3, 10), [3, 3, 4]], [(2, 5), [3, 4]], [(4, 10), [3, 3, 3, 1]] ] print(can_assign_tas(T, test_cases))"},{"question":"def can_form_palindrome(s: str) -> bool: Determines if characters in the string can be rearranged to form a palindrome. :param s: input string consisting of lowercase alphabets :return: True if a palindrome can be formed, False otherwise >>> can_form_palindrome(\\"civic\\") True >>> can_form_palindrome(\\"ivicc\\") True >>> can_form_palindrome(\\"hello\\") False >>> can_form_palindrome(\\"aaabbb\\") False from solution import can_form_palindrome def test_can_form_palindrome_true_cases(): assert can_form_palindrome(\\"civic\\") assert can_form_palindrome(\\"ivicc\\") assert can_form_palindrome(\\"racecar\\") assert can_form_palindrome(\\"aabb\\") assert can_form_palindrome(\\"aaabbbb\\") def test_can_form_palindrome_false_cases(): assert not can_form_palindrome(\\"hello\\") assert not can_form_palindrome(\\"aaabbb\\") assert not can_form_palindrome(\\"abcde\\") assert not can_form_palindrome(\\"abcd\\") def test_can_form_palindrome_empty_string(): assert can_form_palindrome(\\"\\") def test_can_form_palindrome_single_character(): assert can_form_palindrome(\\"a\\") assert can_form_palindrome(\\"z\\") def test_can_form_palindrome_mixed_characters(): assert can_form_palindrome(\\"tacocat\\") assert not can_form_palindrome(\\"carbon\\")","solution":"def can_form_palindrome(s): Determines if characters in the string can be rearranged to form a palindrome. :param s: input string consisting of lowercase alphabets :return: True if a palindrome can be formed, False otherwise from collections import Counter char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return odd_count <= 1"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a given mathematical expression containing non-negative integers and the operators + (addition) and - (subtraction). Args: expression (str): A string representing the mathematical expression. Returns: int: The result of the evaluated expression. >>> evaluate_expression(\\"3+5\\") 8 >>> evaluate_expression(\\"10-2\\") 8 >>> evaluate_expression(\\"3+5-2\\") 6 >>> evaluate_expression(\\"10-3+2\\") 9 >>> evaluate_expression(\\"42\\") 42 >>> evaluate_expression(\\"10-10\\") 0 >>> evaluate_expression(\\"1+2-3+4-5+6-7+8-9+10\\") 7","solution":"def evaluate_expression(expression): Evaluates a given mathematical expression containing non-negative integers and the operators + (addition) and - (subtraction). Args: expression (str): A string representing the mathematical expression. Returns: int: The result of the evaluated expression. # Split the expression into tokens (numbers and operators) tokens = [] num = '' for char in expression: if char.isdigit(): num += char else: tokens.append(int(num)) tokens.append(char) num = '' # Don't forget to add the last number to the tokens list if num: tokens.append(int(num)) # Evaluate the expression by processing tokens result = tokens[0] i = 1 while i < len(tokens): if tokens[i] == '+': result += tokens[i + 1] elif tokens[i] == '-': result -= tokens[i + 1] i += 2 return result"},{"question":"from typing import Optional from collections import Counter class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def pseudoPalindromicPaths(root: Optional[TreeNode]) -> int: Given a binary tree where each node contains an integer value, count the number of pseudo-palindromic paths. A pseudo-palindromic path is a path that can rearrange its node values to form a palindrome. :param root: Root node of the binary tree :type root: Optional[TreeNode] :return: the number of pseudo-palindromic paths in the given binary tree :rtype: int >>> tree = build_tree_from_list([2, 3, 1, 3, 1, None, 1]) >>> pseudoPalindromicPaths(tree) 2 >>> tree = build_tree_from_list([1]) >>> pseudoPalindromicPaths(tree) 1 pass def build_tree_from_list(vals): Helper function to build a binary tree from a list of values. :param vals: List of values :type vals: List[Optional[int]] :return: Root node of the binary tree :rtype: Optional[TreeNode] >>> build_tree_from_list([2, 3, 1, 3, 1, None, 1]) TreeNode with root value 2 if not vals: return None nodes = [None if val is None else TreeNode(val) for val in vals] kids = nodes[1:] root = nodes[0] queue = [root] while queue: node = queue.pop(0) if node: if kids: node.left = kids.pop(0) queue.append(node.left) if kids: node.right = kids.pop(0) queue.append(node.right) return root","solution":"# Definition for a binary tree node. from collections import Counter from typing import Optional class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def pseudoPalindromicPaths(root: Optional[TreeNode]) -> int: def dfs(node, path_counter): if not node: return 0 path_counter[node.val] += 1 if not node.left and not node.right: # If it's a leaf node # Check if the path can form a pseudo-palindrome odd_count = sum(v % 2 for v in path_counter.values()) count = 1 if odd_count <= 1 else 0 else: count = dfs(node.left, path_counter) + dfs(node.right, path_counter) path_counter[node.val] -= 1 return count return dfs(root, Counter()) # Helper functions to build a tree from list input def build_tree_from_list(vals): if not vals: return None nodes = [None if val is None else TreeNode(val) for val in vals] kids = nodes[1:] root = nodes[0] queue = [root] while queue: node = queue.pop(0) if node: if kids: node.left = kids.pop(0) queue.append(node.left) if kids: node.right = kids.pop(0) queue.append(node.right) return root"},{"question":"def generate_unique_codes(input_string: str, shift: int) -> str: Generates unique codes by shifting each character in the input string by a given number of positions. >>> generate_unique_codes(\\"abc123\\", 2) 'cde345' >>> generate_unique_codes(\\"xyz789\\", 5) 'cde234' # your code here # Example usage print(generate_unique_codes(\\"abc123\\", 2)) # Output: 'cde345' print(generate_unique_codes(\\"xyz789\\", 5)) # Output: 'cde234'","solution":"def generate_unique_codes(input_string, shift): Generates unique codes by shifting each character in the input string by a given number of positions. def shift_char(c, shift): if 'a' <= c <= 'z': return chr((ord(c) - ord('a') + shift) % 26 + ord('a')) elif '0' <= c <= '9': return chr((ord(c) - ord('0') + shift) % 10 + ord('0')) else: return c return ''.join(shift_char(c, shift) for c in input_string)"},{"question":"def merge_intervals(intervals): Given a list of intervals, merge all overlapping intervals. :param intervals: List of intervals [start, end] :return: List of merged intervals >>> merge_intervals([[1,3],[2,6],[8,10],[15,18]]) [[1,6],[8,10],[15,18]] >>> merge_intervals([[1,4],[4,5]]) [[1,5]]","solution":"def merge_intervals(intervals): Given a list of intervals, merge all overlapping intervals. :param intervals: List of intervals [start, end] :return: List of merged intervals if not intervals: return [] # Sort intervals by their start times. intervals.sort(key=lambda x: x[0]) merged = [] for interval in intervals: # If the list of merged intervals is empty or if the current # interval does not overlap with the previous, simply append it. if not merged or merged[-1][1] < interval[0]: merged.append(interval) else: # Otherwise, there is overlap, so we merge the current interval # with the previous one. merged[-1][1] = max(merged[-1][1], interval[1]) return merged"},{"question":"def max_non_consecutive_sum(n: int, arr: List[int]) -> int: Returns the maximum sum of a non-consecutive subsequence in the array. >>> max_non_consecutive_sum(5, [3, 2, 7, 10, 12]) 22 >>> max_non_consecutive_sum(4, [3, 2, 5, 10]) 13 # Your implementation here if __name__ == \\"__main__\\": test_cases = [ (1, [5], 5), (2, [3, 7], 7), (5, [3, 2, 7, 10, 12], 22), (5, [-1, -2, -3, -4, -5], 0), (6, [1, 2, 3, 4, 5, 6], 12), (3, [10**9, -10**9, 10**9], 2*10**9), (4, [-10**9, 10**9, -10**9, 10**9], 2*10**9), (2, [0, 0], 0), (3, [7, 0, 5], 12) ] for n, arr, expected in test_cases: assert max_non_consecutive_sum(n, arr) == expected","solution":"def max_non_consecutive_sum(n, arr): Returns the maximum sum of a non-consecutive subsequence in the array. if n == 0: return 0 if n == 1: return max(0, arr[0]) dp = [0] * n dp[0] = max(0, arr[0]) for i in range(1, n): dp[i] = max(dp[i-1], arr[i] + (dp[i-2] if i > 1 else 0)) return dp[-1]"},{"question":"def sorted_squared_array(nums: List[int]) -> List[int]: Returns a new list with the squares of each number in the input list, sorted in non-decreasing order. >>> sorted_squared_array([-4, -1, 0, 3, 10]) [0, 1, 9, 16, 100] >>> sorted_squared_array([-7, -3, 2, 3, 11]) [4, 9, 9, 49, 121]","solution":"def sorted_squared_array(nums): Returns a new list with the squares of each number in the input list, sorted in non-decreasing order. return sorted(x*x for x in nums)"},{"question":"def prime_factors(n: int) -> List[int]: Returns the prime factors of a positive integer n in ascending order. >>> prime_factors(28) [2, 2, 7] >>> prime_factors(15) [3, 5]","solution":"def prime_factors(n): Returns the prime factors of a positive integer n in ascending order. factors = [] # Start with the smallest prime number 2 divisor = 2 while n >= 2: while n % divisor == 0: factors.append(divisor) n //= divisor divisor += 1 return factors"},{"question":"from typing import List def is_path_exists(n: int, m: int, sr: int, sc: int, dr: int, dc: int, grid: List[str]) -> str: Determine if there exists a path from the starting position to the destination on a given 2D grid. You can only move up, down, left, or right, and cannot move through cells with obstacles. >>> grid1 = [ ... \\".#...\\", ... \\".....\\", ... \\".\\", ... \\".....\\", ... \\".....\\" ... ] >>> assert is_path_exists(5, 5, 1, 1, 5, 5, grid1) == \\"YES\\" >>> grid2 = [ ... \\".....\\", ... \\".....\\", ... \\"#\\", ... \\".....\\", ... \\".....\\" ... ] >>> assert is_path_exists(5, 5, 1, 1, 5, 5, grid2) == \\"NO\\" >>> grid3 = [ ... \\".\\" ... ] >>> assert is_path_exists(1, 1, 1, 1, 1, 1, grid3) == \\"YES\\" >>> grid4 = [ ... \\".#\\", ... \\"..\\" ... ] >>> assert is_path_exists(2, 2, 1, 2, 2, 2, grid4) == \\"YES\\" >>> grid5 = [ ... \\"...\\", ... \\"...\\" ... ] >>> assert is_path_exists(2, 3, 1, 1, 2, 3, grid5) == \\"YES\\" >>> grid6 = [ ... \\".\\", ... \\"#..\\", ... \\".\\" ... ] >>> assert is_path_exists(3, 3, 1, 1, 3, 3, grid6) == \\"NO\\"","solution":"def is_path_exists(n, m, sr, sc, dr, dc, grid): from collections import deque def is_valid(x, y): return 0 <= x < n and 0 <= y < m and grid[x][y] == '.' # BFS initialization queue = deque([(sr-1, sc-1)]) visited = set([(sr-1, sc-1)]) # Directions for movements (up, down, left, right) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] while queue: x, y = queue.popleft() if (x, y) == (dr-1, dc-1): return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) return \\"NO\\""},{"question":"def flatten_list(nested_list): Flattens a list of lists into a single list. Parameters: nested_list (List[List[Any]]): A list of lists to be flattened. Returns: List[Any]: A single, flattened list containing all the elements of the nested lists. >>> flatten_list([]) == [] >>> flatten_list([[]]) == [] >>> flatten_list([[1, 2, 3]]) == [1, 2, 3] >>> flatten_list([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 7, 8, 9] >>> flatten_list([[1, 'a', 3.5], ['b', 5, True]]) == [1, 'a', 3.5, 'b', 5, True]","solution":"def flatten_list(nested_list): Flattens a list of lists into a single list. Parameters: nested_list (List[List[Any]]): A list of lists to be flattened. Returns: List[Any]: A single, flattened list containing all the elements of the nested lists. return [item for sublist in nested_list for item in sublist]"},{"question":"def combination_sum(arr, target): Returns all unique combinations in the array \`arr\` where the numbers sum to \`target\`. Each number in the array can only be used once in each combination. >>> combination_sum([10, 1, 2, 7, 6, 1, 5], 8) [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6] ] >>> combination_sum([2, 4, 6, 8], 3) [] >>> combination_sum([1], 1) [[1]] >>> combination_sum([1, 1, 1, 1], 2) [[1, 1]] >>> combination_sum([100, 200, 300, 400], 500) [ [100, 400], [200, 300] ]","solution":"def combination_sum(arr, target): Returns all unique combinations in \`arr\` where the numbers sum to \`target\`. Each number in \`arr\` can only be used once in the combination. def backtrack(start, target, path): if target == 0: result.append(path) return for i in range(start, len(arr)): if i > start and arr[i] == arr[i - 1]: continue if arr[i] > target: break backtrack(i + 1, target - arr[i], path + [arr[i]]) arr.sort() result = [] backtrack(0, target, []) return result"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxDepth(root: TreeNode) -> int: Computes the maximum depth of a binary tree. :param root: TreeNode, the root of the binary tree :return: int, the maximum depth of the tree >>> root = TreeNode(3) >>> root.left = TreeNode(9) >>> root.right = TreeNode(20) >>> root.right.left = TreeNode(15) >>> root.right.right = TreeNode(7) >>> maxDepth(root) 3","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxDepth(root: TreeNode) -> int: Computes the maximum depth of a binary tree. :param root: TreeNode, the root of the binary tree :return: int, the maximum depth of the tree if root is None: return 0 else: left_depth = maxDepth(root.left) right_depth = maxDepth(root.right) return max(left_depth, right_depth) + 1"},{"question":"def most_frequent_chars(s: str) -> List[str]: Returns a list of the characters that appear the most frequently in the string, in the order they first appear in the string. >>> most_frequent_chars('character') ['c', 'a', 'r'] >>> most_frequent_chars('Abba') ['b'] >>> most_frequent_chars('aaa') ['a'] >>> most_frequent_chars('') []","solution":"def most_frequent_chars(s): Returns a list of the characters that appear the most frequently in the string, in the order they first appear in the string. from collections import Counter if not s: return [] # Create a dictionary to count the frequency of each character freq = Counter(s) # Find the highest frequency max_freq = max(freq.values()) # Return characters that have the highest frequency, in the order they first appear in the string result = [] for char in s: if freq[char] == max_freq and char not in result: result.append(char) return result"},{"question":"def min_operations_to_reach_k_flowers(n: int, m: int, k: int, garden: List[List[int]]) -> int: Returns the minimum number of operations required to ensure that every cell in the garden has at least 'k' flowers. >>> min_operations_to_reach_k_flowers(3, 3, 5, [[1, 2, 3], [4, 2, 1], [3, 3, 3]]) == 4 >>> min_operations_to_reach_k_flowers(2, 2, 2, [[1, 1], [1, 1]]) == 1 >>> min_operations_to_reach_k_flowers(2, 3, 2, [[2, 3, 5], [4, 7, 2]]) == 0 >>> min_operations_to_reach_k_flowers(2, 2, 10, [[0, 1], [0, 1]]) == 10 >>> min_operations_to_reach_k_flowers(1, 1, 5, [[3]]) == 2","solution":"def min_operations_to_reach_k_flowers(n, m, k, garden): Returns the minimum number of operations required to ensure that every cell in the garden has at least 'k' flowers. def max_needed_difference(): max_diff = 0 for i in range(n): for j in range(m): if garden[i][j] < k: max_diff = max(max_diff, k - garden[i][j]) return max_diff # Method to count minimal operations based on max needed difference. op_count = max_needed_difference() return op_count"},{"question":"from typing import List def is_ideal_array(arr: List[int]) -> bool: Determines if the given array is 'ideal'. An array is called 'ideal' if: 1. The GCD of all its elements is greater than 1. 2. The sum of the elements is even. Example: >>> is_ideal_array([4, 6, 12, 8, 10]) True >>> is_ideal_array([3, 5, 7, 9]) False >>> is_ideal_array([2, 4, 6, 8]) True","solution":"from math import gcd from functools import reduce def is_ideal_array(arr): Determines if the given array is 'ideal'. An array is called 'ideal' if: 1. The GCD of all its elements is greater than 1. 2. The sum of the elements is even. # Calculate the GCD of all elements in the array array_gcd = reduce(gcd, arr) # Calculate the sum of all elements in the array array_sum = sum(arr) # Check if the GCD is greater than 1 and the sum is even return array_gcd > 1 and array_sum % 2 == 0"},{"question":"from typing import List, Union def most_frequent_color(colors: List[str]) -> Union[str, List[str]]: Returns the color that appears most frequently. If there is a tie, returns a list of colors involved in the tie sorted alphabetically. >>> most_frequent_color([\\"red\\", \\"blue\\", \\"green\\", \\"blue\\", \\"red\\", \\"red\\"]) 'red' >>> most_frequent_color([\\"red\\", \\"blue\\", \\"green\\", \\"blue\\", \\"green\\"]) ['blue', 'green'] >>> most_frequent_color([\\"red\\", \\"blue\\", \\"green\\"]) ['blue', 'green', 'red'] >>> most_frequent_color([\\"red\\"]) 'red' >>> most_frequent_color([\\"red\\", \\"blue\\", \\"blue\\", \\"green\\", \\"green\\", \\"yellow\\", \\"yellow\\"]) ['blue', 'green', 'yellow']","solution":"from collections import Counter def most_frequent_color(colors): Returns the color that appears most frequently. If there is a tie, returns a list of colors involved in the tie sorted alphabetically. color_counts = Counter(colors) max_count = max(color_counts.values()) most_frequent = [color for color in color_counts if color_counts[color] == max_count] if len(most_frequent) == 1: return most_frequent[0] return sorted(most_frequent)"},{"question":"def max_rows(m: int, flowers: List[int]) -> Tuple[int, List[List[int]]]: Determine the maximum number of rows Alice can have in her garden and a valid planting configuration. :param m: Number of different types of flowers :param f: List of integers representing the number of flowers of each type :return: Tuple with the maximum number of rows and the planting configuration >>> max_rows(2, [2, 2]) (2, [[1, 2], [1, 2]]) >>> max_rows(3, [1, 3, 1]) (2, [[1, 2, 3], [2]]) >>> max_rows(1, [1]) (1, [[1]]) >>> max_rows(4, [2, 2, 2, 2]) (2, [[1, 2, 3, 4], [1, 2, 3, 4]]) >>> max_rows(5, [1, 1, 1, 1, 1]) (1, [[1, 2, 3, 4, 5]])","solution":"def max_rows(m, flowers): Determine the maximum number of rows Alice can have in her garden and a valid planting configuration. :param m: Number of different types of flowers :param flowers: List of integers representing the number of flowers of each type :return: Tuple with the maximum number of rows and the planting configuration # Find the maximum number of rows we can have total_flowers = sum(flowers) if total_flowers <= m: max_rows = 1 else: max_rows = total_flowers // m if total_flowers % m > 0: max_rows += 1 # Create the configuration config = [] for i in range(max_rows): row = [] for j in range(m): if flowers[j] > 0: row.append(j + 1) flowers[j] -= 1 config.append(row) return max_rows, config def main(): import sys input = sys.stdin.read data = input().split() m = int(data[0]) flowers = [int(data[i + 1]) for i in range(m)] max_row_count, config = max_rows(m, flowers) print(max_row_count) for row in config: print(' '.join(map(str, row)))"},{"question":"from typing import List def can_form_palindrome(s: str) -> str: Determine if any permutation of the string can form a palindrome. >>> can_form_palindrome(\\"civic\\") 'YES' >>> can_form_palindrome(\\"ivicc\\") 'YES' >>> can_form_palindrome(\\"hello\\") 'NO' pass def process_cases(cases: List[str]) -> List[str]: Process multiple test cases. >>> process_cases([\\"civic\\", \\"ivicc\\", \\"hello\\"]) ['YES', 'YES', 'NO'] >>> process_cases([\\"aabbcc\\", \\"aabbc\\"]) ['YES', 'YES'] >>> process_cases([\\"abcdefg\\"]) ['NO'] pass","solution":"def can_form_palindrome(s): Determine if any permutation of the string can form a palindrome. :param s: String to check :return: 'YES' if a permutation can form a palindrome, otherwise 'NO' from collections import Counter char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can form a palindrome if at most one character has an odd count if odd_count > 1: return \\"NO\\" return \\"YES\\" def process_cases(cases): Process multiple test cases. :param cases: List of strings (test cases) :return: List of results for each test case results = [] for case in cases: results.append(can_form_palindrome(case)) return results"},{"question":"def final_position(commands: str) -> (int, int): Computes the final position of a robot navigating a grid based on a series of commands. Args: commands (str): A string where each character represents a direction: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. Returns: tuple: The final position of the robot as (x, y). Examples: >>> final_position(\\"UDLR\\") (0, 0) >>> final_position(\\"UUUDDD\\") (0, 0) >>> final_position(\\"UUU\\") (0, 3) >>> final_position(\\"LL\\") (-2, 0) >>> final_position(\\"UUDDLLRRR\\") (1, 0)","solution":"def final_position(commands): Returns the final position of the robot after executing the commands. Args: commands (str): A string of commands where each command is one of 'U', 'D', 'L', 'R' representing up, down, left, and right respectively. Returns: tuple: The final position of the robot as (x, y). x, y = 0, 0 for command in commands: if command == 'U': y += 1 elif command == 'D': y -= 1 elif command == 'L': x -= 1 elif command == 'R': x += 1 return (x, y)"},{"question":"def shift_string(s: str, k: int) -> str: Shifts each character in the string \`s\` forward by \`k\` positions in the alphabet. Wraps around if the shift goes past 'z' and returns the transformed string. >>> shift_string(\\"xyz\\", 2) \\"zab\\" >>> shift_string(\\"abc\\", 1) \\"bcd\\"","solution":"def shift_string(s, k): Shifts each character in the string \`s\` forward by \`k\` positions in the alphabet. Wraps around if the shift goes past 'z'. :param s: str, a string of lowercase English letters :param k: int, non-negative integer :return: str, the transformed string shifted_string = \\"\\" for char in s: new_char = chr(((ord(char) - ord('a') + k) % 26) + ord('a')) shifted_string += new_char return shifted_string"},{"question":"from typing import List def combinationSum2(nums: List[int], target: int) -> List[List[int]]: Returns all unique combinations in nums where the numbers sum up to target. Each number in nums may only be used once in the combination. The solution set must not contain duplicate combinations. >>> combinationSum2([10, 1, 2, 7, 6, 1, 5], 8) [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]] >>> combinationSum2([2, 5, 2, 1, 2], 5) [[1, 2, 2], [5]] >>> combinationSum2([2, 3, 5], 1) [] >>> combinationSum2([5], 5) [[5]] >>> combinationSum2([2, 2, 2, 2], 4) [[2, 2]] >>> combinationSum2([10, 20, 30], 40) [[10, 30]]","solution":"def combinationSum2(nums, target): Returns all unique combinations in nums where the numbers sum up to target. Each number in nums may only be used once in the combination. The solution set must not contain duplicate combinations. def backtrack(start, end, path, target): if target == 0: result.append(list(path)) return if target < 0: return for i in range(start, end): if i > start and nums[i] == nums[i - 1]: continue path.append(nums[i]) backtrack(i + 1, end, path, target - nums[i]) path.pop() nums.sort() result = [] backtrack(0, len(nums), [], target) return result"},{"question":"def min_subarray_len(nums: List[int], x: int) -> int: Find the smallest length of a contiguous subarray whose sum is at least x. >>> min_subarray_len([2, 3, 1, 2, 4, 3], 7) 2 >>> min_subarray_len([1, 1, 1, 1, 1, 1, 1, 1], 11) 0","solution":"def min_subarray_len(nums, x): Find the minimal length of a contiguous subarray of which the sum is at least x. If such a subarray doesn't exist, return 0. n = len(nums) min_length = float(\\"inf\\") current_sum = 0 left = 0 for right in range(n): current_sum += nums[right] while current_sum >= x: min_length = min(min_length, right - left + 1) current_sum -= nums[left] left += 1 return min_length if min_length != float(\\"inf\\") else 0"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression containing addition and subtraction. Args: expression (str): The mathematical expression to evaluate. Returns: int: The result of the expression. >>> evaluate_expression(\\"3 + 5\\") == 8 >>> evaluate_expression(\\"10 - 3\\") == 7 >>> evaluate_expression(\\"3 + 5 - 2\\") == 6 >>> evaluate_expression(\\"10 - 3 + 2 - 4\\") == 5 >>> evaluate_expression(\\"2 + 2 + 2\\") == 6 >>> evaluate_expression(\\"10 - 1 - 2 - 3\\") == 4 >>> evaluate_expression(\\"7 + 3 - 2 + 1\\") == 9 >>> evaluate_expression(\\"5 + 5 - 5 + 5\\") == 10","solution":"def evaluate_expression(expression): Evaluates a mathematical expression containing addition and subtraction. Args: expression (str): The mathematical expression to evaluate. Returns: int: The result of the expression. tokens = expression.split() total = 0 current_operator = \\"+\\" for token in tokens: if token in {\\"+\\", \\"-\\"}: current_operator = token else: number = int(token) if current_operator == \\"+\\": total += number elif current_operator == \\"-\\": total -= number return total"},{"question":"def maxSubarraySum(arr: List[int], k: int) -> int: Given an array of integers \`arr\` and an integer \`k\`, find the maximum sum of a subarray of length \`k\`. Example: >>> maxSubarraySum([2, 1, 5, 1, 3, 2], 3) 9 >>> maxSubarraySum([2, 3, 4, 1, 5], 2) 7 >>> maxSubarraySum([1, 2, 3, 4, 5], 1) 5","solution":"def maxSubarraySum(arr, k): Returns the maximum sum of a subarray of length k. if not arr or k <= 0 or k > len(arr): return 0 max_sum = current_sum = sum(arr[:k]) for i in range(k, len(arr)): current_sum += arr[i] - arr[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def rotate(matrix): Rotates the input matrix 90 degrees clockwise in place. :param matrix: List[List[int]], the nxn 2D matrix to be rotated Example: >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate(matrix) >>> print(matrix) [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] >>> matrix = [ ... [5, 1, 9, 11], ... [2, 4, 8, 10], ... [13, 3, 6, 7], ... [15, 14, 12, 16] ... ] >>> rotate(matrix) >>> print(matrix) [ [15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11] ]","solution":"def rotate(matrix): Rotates the input matrix 90 degrees clockwise in place. :param matrix: List[List[int]], the nxn 2D matrix to be rotated n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"from typing import List def winner(votes: List[int]) -> int: Return the candidate who received the most votes. In case of a tie, return the smallest integer among the tied candidates. >>> winner([1, 3, 2, 3, 2, 3]) 3 >>> winner([5, 1, 2, 1, 5]) 1 >>> winner([7, 7, 7, 8]) 7","solution":"from collections import Counter def winner(votes): Returns the candidate with most votes. In case of a tie, returns the smallest candidate number. # Count the number of votes each candidate received vote_count = Counter(votes) # Find the maximum number of votes max_votes = max(vote_count.values()) # Get the list of candidates with max votes candidates_with_max_votes = [candidate for candidate, count in vote_count.items() if count == max_votes] # Return the smallest candidate among those with the max votes return min(candidates_with_max_votes)"},{"question":"def max_subarray_sum(nums): Finds the maximum sum of a contiguous subarray using Kadane's Algorithm. Parameters: nums (list): A list of integers Returns: int: The maximum sum of a contiguous subarray >>> max_subarray_sum([1, 2, 3, 4, 5]) 15 >>> max_subarray_sum([-1, -2, -3, -4, -5]) -1 >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([4]) 4 >>> max_subarray_sum([-4]) -4 >>> max_subarray_sum([]) 0 >>> max_subarray_sum([1000000, -1, 1000000]) 1999999 >>> max_subarray_sum([0, 0, 0, 0]) 0 >>> max_subarray_sum([0, -1, 2, -3, 4, 0]) 4","solution":"def max_subarray_sum(nums): Finds the maximum sum of a contiguous subarray using Kadane's Algorithm. Parameters: nums (list): A list of integers Returns: int: The maximum sum of a contiguous subarray if not nums: return 0 max_current = max_global = nums[0] for num in nums[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"def can_be_more_balanced(s: str) -> bool: Determines if it's possible to make the binary string 's' more balanced by swapping any two characters with the same value. Examples: >>> can_be_more_balanced(\\"110\\") True >>> can_be_more_balanced(\\"1110\\") True >>> can_be_more_balanced(\\"000\\") False >>> can_be_more_balanced(\\"1010\\") True def test_can_be_more_balanced(): # Test case 1 s = \\"110\\" assert can_be_more_balanced(s) == True, \\"Test case 1 failed\\" # Test case 2 s = \\"1110\\" assert can_be_more_balanced(s) == True, \\"Test case 2 failed\\" # Test case 3 s = \\"000\\" assert can_be_more_balanced(s) == False, \\"Test case 3 failed\\" # Test case 4 s = \\"1010\\" assert can_be_more_balanced(s) == True, \\"Test case 4 failed\\" # Edge case: already balanced s = \\"01\\" assert can_be_more_balanced(s) == True, \\"Edge case 01 failed\\" # Edge case: no '1's s = \\"000000\\" assert can_be_more_balanced(s) == False, \\"Edge case no '1's failed\\" # Edge case: no '0's s = \\"111111\\" assert can_be_more_balanced(s) == False, \\"Edge case no '0's failed\\" # Test case with larger input string s = \\"111000\\" assert can_be_more_balanced(s) == True, \\"Large input failed\\" # Test case with equal number of '0's and '1's s = \\"101001\\" assert can_be_more_balanced(s) == True, \\"Equal number test failed\\" # Test case with large unbalanced input s = \\"1111111100000000\\" assert can_be_more_balanced(s) == True, \\"Large unbalanced input failed\\"","solution":"def can_be_more_balanced(s): Determines if it's possible to make the binary string 's' more balanced by swapping any two characters with the same value. count_0 = s.count('0') count_1 = s.count('1') # If the difference between the number of '0's and '1's is less than 2, we can always balance it more. if abs(count_0 - count_1) < 2: return True # If there are no '1's or no '0's, we cannot make it more balanced. if count_0 == 0 or count_1 == 0: return False return True"},{"question":"def is_palindrome(s: str) -> bool: Evaluates if a given string is a palindrome, ignoring non-alphanumeric characters and case. Args: s: str - The string to evaluate. Returns: bool - True if the string is a palindrome, False otherwise. >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") == True >>> is_palindrome(\\"race a car\\") == False >>> is_palindrome(\\"\\") == True >>> is_palindrome(\\"a\\") == True >>> is_palindrome(\\"Z\\") == True >>> is_palindrome(\\"Noon\\") == True >>> is_palindrome(\\"12321\\") == True >>> is_palindrome(\\"1a2\\") == False >>> is_palindrome(\\"Able , was I saw eLba\\") == True >>> is_palindrome(\\"Eva, can I see bees in a cave?\\") == True","solution":"def is_palindrome(s): Evaluates if a given string is a palindrome, ignoring non-alphanumeric characters and case. Args: s: str - The string to evaluate. Returns: bool - True if the string is a palindrome, False otherwise. filtered_chars = [char.lower() for char in s if char.isalnum()] return filtered_chars == filtered_chars[::-1]"},{"question":"def daily_temperatures(temperatures): Returns a list where each element is the number of days until a warmer temperature. If there is no future day (in the array) that's warmer, the value is 0. >>> daily_temperatures([73, 74, 75, 71, 69, 72, 76, 73]) [1, 1, 4, 2, 1, 1, 0, 0] >>> daily_temperatures([80, 90, 100]) [1, 1, 0] >>> daily_temperatures([30]) [0] >>> daily_temperatures([50, 50, 50, 50]) [0, 0, 0, 0] >>> daily_temperatures([100, 90, 80, 70]) [0, 0, 0, 0] >>> daily_temperatures([60, 70, 80, 70, 60, 50]) [1, 1, 0, 0, 0, 0]","solution":"def daily_temperatures(temperatures): Returns a list where each element is the number of days until a warmer temperature. If there is no future day (in the array) that's warmer, the value is 0. result = [0] * len(temperatures) stack = [] # this will store indexes of the temperatures array for curr_day, curr_temp in enumerate(temperatures): # Process stack items that are cooler than the current temperature while stack and temperatures[stack[-1]] < curr_temp: prev_day = stack.pop() result[prev_day] = curr_day - prev_day stack.append(curr_day) return result"},{"question":"def first_non_repeated_char(s: str) -> str: Returns the first non-repeated character in the string s. The function is case-sensitive. If there are no non-repeated characters, returns None. >>> first_non_repeated_char(\\"stress\\") -> 't' >>> first_non_repeated_char(\\"teeter\\") -> 'r' >>> first_non_repeated_char(\\"aabbcc\\") -> None","solution":"def first_non_repeated_char(s): Returns the first non-repeated character in the string s. If there are no non-repeated characters, returns None. The function is case-sensitive. char_count = {} # Count occurrences of each character in the string for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find the first non-repeated character for char in s: if char_count[char] == 1: return char return None"},{"question":"def evaluate_expression(s: str) -> int: Evaluate a string representation of a mathematical expression following the standard order of operations (PEMDAS/BODMAS rules). The expression will consist of non-negative integers and include the operators +, -, *, and /. Parentheses may be used to indicate precedence. Division is treated as integer division. >>> evaluate_expression(\\"3+(2*2)\\") 7 >>> evaluate_expression(\\"3+2*2\\") 7 >>> evaluate_expression(\\"20/(3+2)\\") 4 >>> evaluate_expression(\\"(2+3)*(5-2)\\") 15 >>> evaluate_expression(\\"10+2*6/(4-2)\\") 16 from solution import evaluate_expression def test_simple_addition(): assert evaluate_expression(\\"3+2\\") == 5 def test_addition_and_multiplication(): assert evaluate_expression(\\"3+2*2\\") == 7 def test_nested_parentheses(): assert evaluate_expression(\\"3+(2*2)\\") == 7 def test_division_within_parentheses(): assert evaluate_expression(\\"20/(3+2)\\") == 4 def test_complex_expression(): assert evaluate_expression(\\"(2+3)*(5-2)\\") == 15 def test_expression_with_multiplication_and_division(): assert evaluate_expression(\\"10+2*6/(4-2)\\") == 16 def test_expression_with_multiple_operators(): assert evaluate_expression(\\"3+5 / 2\\") == 5 def test_expression_with_spaces(): assert evaluate_expression(\\" 3 + 5 / 2 \\") == 5","solution":"def evaluate_expression(s: str) -> int: def helper(tokens): stack = [] num = 0 sign = '+' while tokens: token = tokens.pop(0) if token.isdigit(): num = num * 10 + int(token) if token == '(': num = helper(tokens) if (not token.isdigit() and token != ' ') or not tokens: if sign == '+': stack.append(num) elif sign == '-': stack.append(-num) elif sign == '*': stack[-1] *= num elif sign == '/': stack[-1] = int(stack[-1] / num) sign = token num = 0 if token == ')': break return sum(stack) tokens = list(s) return helper(tokens)"},{"question":"def can_buy_k_colors(test_cases): Determines if exactly \`k\` different colors can be bought without exceeding the budget for each test case. results = [] for case in test_cases: n, k, b, colors = case # Sort the colors by price in ascending order colors.sort(key=lambda x: x[1]) # Sum up the prices of the k cheapest paints if sum(color[1] for color in colors[:k]) <= b: results.append(\\"YES\\") else: results.append(\\"NO\\") return results def parse_input(input_lines): Parses the input lines into a list of test cases. lines = iter(input_lines) t = int(next(lines)) test_cases = [] for _ in range(t): n, k, b = map(int, next(lines).split()) colors = [tuple(map(int, next(lines).split())) for _ in range(n)] test_cases.append((n, k, b, colors)) return test_cases def main(input_lines): Main function to execute the functionality. Example: >>> input_lines = [ ... \\"2\\", ... \\"4 3 15\\", ... \\"2 5\\", ... \\"3 4\\", ... \\"1 6\\", ... \\"4 7\\", ... \\"3 2 10\\", ... \\"2 5\\", ... \\"3 6\\", ... \\"1 15\\" ... ] >>> main(input_lines) [\\"YES\\", \\"NO\\"] test_cases = parse_input(input_lines) return can_buy_k_colors(test_cases)","solution":"def can_buy_k_colors(test_cases): Determines if exactly \`k\` different colors can be bought without exceeding the budget for each test case. results = [] for case in test_cases: n, k, b, colors = case # Sort the colors by price in ascending order colors.sort(key=lambda x: x[1]) # Sum up the prices of the k cheapest paints if sum(color[1] for color in colors[:k]) <= b: results.append(\\"YES\\") else: results.append(\\"NO\\") return results def parse_input(input_lines): Parses the input lines into a list of test cases. lines = iter(input_lines) t = int(next(lines)) test_cases = [] for _ in range(t): n, k, b = map(int, next(lines).split()) colors = [tuple(map(int, next(lines).split())) for _ in range(n)] test_cases.append((n, k, b, colors)) return test_cases def main(input_lines): test_cases = parse_input(input_lines) return can_buy_k_colors(test_cases)"},{"question":"def harmonic_subarrays(T, cases): Determine the number of harmonic subarrays in a list of integers. >>> harmonic_subarrays(2, [(3, \\"2 3 1\\"), (4, \\"2 5 4 7\\")]) [2, 3] >>> harmonic_subarrays(1, [(1, \\"1\\")]) [0]","solution":"def is_prime(num): Determine if a number is prime. if num <= 1: return False if num == 2: return True if num % 2 == 0: return False p = 3 while p * p <= num: if num % p == 0: return False p += 2 return True def count_harmonic_subarrays(N, A): Count the number of harmonic subarrays. count = 0 # Check all possible subarrays for start in range(N): subarray_sum = 0 for end in range(start, N): subarray_sum += A[end] subarray_len = end - start + 1 if is_prime(subarray_sum * subarray_len): count += 1 return count def solve(test_cases): results = [] for case in test_cases: N, A = case results.append(count_harmonic_subarrays(N, A)) return results # Wrapper function to parse input and call the solve function def harmonic_subarrays(T, cases): parsed_cases = [(int(cases[i][0]), list(map(int, cases[i][1].split()))) for i in range(T)] return solve(parsed_cases)"},{"question":"from typing import List def minimum_stop_signs(n: int, roads: List[List[int]]) -> int: Given the number of intersections and a list of roads (each represented as a pair [u, v] where u and v are intersections), find the minimum number of intersections where stop signs must be placed so that there are no cycles. Args: n: int - the number of intersections. roads: List[List[int]] - the list of roads, where each road is represented as a list [u, v]. Returns: int - the minimum number of intersections where stop signs need to be placed to prevent cycles. Example: >>> minimum_stop_signs(5, [[1, 2], [2, 3], [3, 1], [4, 5]]) 1 >>> minimum_stop_signs(4, [[1, 2], [2, 3], [3, 4], [4, 2], [4, 1]]) 1 >>> minimum_stop_signs(6, [[1, 2], [2, 3], [3, 1], [3, 4], [4, 5], [5, 3]]) 2 from solution import minimum_stop_signs def test_example_1(): n = 5 roads = [[1, 2], [2, 3], [3, 1], [4, 5]] assert minimum_stop_signs(n, roads) == 1 def test_example_2(): n = 4 roads = [[1, 2], [2, 3], [3, 4], [4, 2], [4, 1]] assert minimum_stop_signs(n, roads) == 1 def test_example_3(): n = 6 roads = [[1, 2], [2, 3], [3, 1], [3, 4], [4, 5], [5, 3]] assert minimum_stop_signs(n, roads) == 2 def test_no_cycles(): n = 3 roads = [[1, 2], [2, 3]] assert minimum_stop_signs(n, roads) == 0 def test_multiple_cycles(): n = 6 roads = [[1, 2], [2, 3], [3, 1], [4, 5], [5, 6], [6, 4]] assert minimum_stop_signs(n, roads) == 2 def test_disconnected_graph(): n = 8 roads = [[1, 2], [2, 3], [3, 1], [4, 6], [6, 5], [5, 4], [7, 8]] assert minimum_stop_signs(n, roads) == 2","solution":"from collections import defaultdict def minimum_stop_signs(n, roads): def dfs(node, visited, on_stack, graph): visited.add(node) on_stack.add(node) for neighbor in graph[node]: if neighbor not in visited: if dfs(neighbor, visited, on_stack, graph): return True elif neighbor in on_stack: return True on_stack.remove(node) return False graph = defaultdict(list) for u, v in roads: graph[u].append(v) stop_signs = set() visited = set() on_stack = set() for node in range(1, n + 1): if node not in visited: if dfs(node, visited, on_stack, graph): stop_signs.add(node) return len(stop_signs)"},{"question":"def is_palindrome(s: str) -> str: Determines if a given string is a valid palindrome considering only alphanumeric characters and ignoring case sensitivity. >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") \\"Valid Palindrome\\" >>> is_palindrome(\\"race a car\\") \\"Not a Palindrome\\"","solution":"def is_palindrome(s): Determines if a given string is a valid palindrome considering only alphanumeric characters and ignoring case sensitivity. :param s: str - input string :return: str - \\"Valid Palindrome\\" or \\"Not a Palindrome\\" # Filter out non-alphanumeric characters and convert to lowercase filtered_chars = [char.lower() for char in s if char.isalnum()] # Check if the filtered characters form a palindrome if filtered_chars == filtered_chars[::-1]: return \\"Valid Palindrome\\" else: return \\"Not a Palindrome\\""},{"question":"def solve(arr, k): Returns the maximum sum of any contiguous subarray of size \`k\`. Parameters: arr (list): An integer array. k (int): A positive integer representing the size of the subarray. Returns: int: The maximum sum of any contiguous subarray of size \`k\`. >>> solve([2, 1, 5, 1, 3, 2], 3) 9 >>> solve([1, 2, 3, 4, 5], 2) 9 >>> solve([-1, -2, -3, -4], 2) -3 >>> solve([-2, 3, 1, -1, 2], 2) 4 >>> solve([1], 1) 1 >>> solve([2, 3, 4], 3) 9 >>> solve([], 3) 0 >>> solve([1, 2, 3], 4) 0 >>> solve([1, 2, 3], 0) 0","solution":"def solve(arr, k): Returns the maximum sum of any contiguous subarray of size \`k\`. Parameters: arr (list): An integer array. k (int): A positive integer representing the size of the subarray. Returns: int: The maximum sum of any contiguous subarray of size \`k\`. if not arr or k <= 0 or k > len(arr): return 0 max_sum = float('-inf') current_sum = 0 for i in range(len(arr)): current_sum += arr[i] if i >= k - 1: max_sum = max(max_sum, current_sum) current_sum -= arr[i - (k - 1)] return max_sum"},{"question":"def find_unique_element(sequence: List[int]) -> int: Finds the element in the sequence that appears only once. :param sequence: List[int] - List of integers where every element appears twice except for one element. :return: int - The element that appears exactly once. >>> find_unique_element([2, 3, 5, 3, 2, 4, 4]) 5 >>> find_unique_element([10, 1, 1, 2, 3, 3, 2]) 10 >>> find_unique_element([7, 9, 7, 9, 6]) 6 >>> find_unique_element([-2, -3, -2, -3, -5]) -5 pass","solution":"def find_unique_element(sequence): Finds the element in the sequence that appears only once. :param sequence: List[int] - List of integers where every element appears twice except for one element. :return: int - The element that appears exactly once. unique_element = 0 for num in sequence: unique_element ^= num return unique_element"},{"question":"def is_balanced(input_string: str) -> bool: Checks if the input string contains balanced parentheses. Args: input_string (str): The string to check for balanced parentheses. Returns: bool: True if the parentheses are balanced, False otherwise. Examples: >>> is_balanced(\\"(a + b) * (c - d)\\") # True >>> is_balanced(\\"((a + b) * (c - d))\\") # True >>> is_balanced(\\"a + b + c - d\\") # True >>> is_balanced(\\"a + (b + c) - d\\") # True >>> is_balanced(\\"a + (b * c + (d - e))\\") # True >>> is_balanced(\\"((a + b) * (c - d)\\") # False >>> is_balanced(\\")a + b(\\") # False >>> is_balanced(\\"(a + b * c\\") # False >>> is_balanced(\\"a + b) * (c - d(\\") # False >>> is_balanced(\\"(a * (b + c)\\") # False >>> is_balanced(\\"\\") # True >>> is_balanced(\\"(((((((\\") # False >>> is_balanced(\\")))))))\\") # False # Your code here pass","solution":"def is_balanced(input_string): Checks if the input string contains balanced parentheses. Args: input_string (str): The string to check for balanced parentheses. Returns: bool: True if the parentheses are balanced, False otherwise. stack = [] for char in input_string: if char == '(': stack.append(char) elif char == ')': if not stack: return False stack.pop() return len(stack) == 0"},{"question":"def count_vowels(s: str) -> int: Returns the number of vowels ('a', 'e', 'i', 'o', 'u') in the input string s. >>> count_vowels('aeiou') == 5 >>> count_vowels('aEiOu') == 5 >>> count_vowels('aBcDeFgHiJk') == 3 >>> count_vowels('bcdfghjklmnpqrstvwxyz') == 0 >>> count_vowels('') == 0 >>> count_vowels('Hello, World!') == 3 >>> count_vowels('123aeiou456') == 5 ...","solution":"def count_vowels(s): Returns the number of vowels ('a', 'e', 'i', 'o', 'u') in the input string s. vowels = 'aeiou' return sum(1 for char in s.lower() if char in vowels)"},{"question":"from typing import List def frequency_count(arr: List[int]) -> List[int]: Returns an array where each element is replaced by the number of times it appears in the original array. >>> frequency_count([4, 4, 4, 3, 3, 2, 1]) [3, 3, 3, 2, 2, 1, 1] >>> frequency_count([1, 2, 2, 3, 3, 3]) [1, 2, 2, 3, 3, 3] pass","solution":"def frequency_count(arr): Returns an array where each element is replaced by the number of times it appears in the original array. from collections import Counter freq = Counter(arr) return [freq[x] for x in arr]"},{"question":"def max_items_within_budget(prices: List[int], budget: int) -> int: Given a list of item prices and a budget, this function returns the maximum number of different items that can be bought without exceeding the budget. >>> max_items_within_budget([1, 12, 5, 111, 200, 1000, 10], 50) == 4 >>> max_items_within_budget([20, 10, 5, 30, 15], 35) == 3 >>> max_items_within_budget([100, 200, 300], 50) == 0","solution":"def max_items_within_budget(prices, budget): Given a list of item prices and a budget, this function returns the maximum number of different items that can be bought without exceeding the budget. :param prices: List[int] - List of item prices :param budget: int - The provided budget :return: int - Maximum number of items that can be bought within the budget if not prices or budget <= 0: return 0 prices.sort() total_spent = 0 items_count = 0 for price in prices: if total_spent + price > budget: break total_spent += price items_count += 1 return items_count"},{"question":"def final_position(commands: List[str]) -> Tuple[int, int]: Determine the final position of a robot given a list of commands. Parameters: commands (list): A list of strings which can be \\"LEFT\\", \\"RIGHT\\", \\"UP\\", \\"DOWN\\". Returns: tuple: A tuple (x, y) representing the final position on the grid. pass def test_final_position_example1(): assert final_position([\\"UP\\", \\"UP\\", \\"LEFT\\", \\"DOWN\\", \\"LEFT\\"]) == (-2, 1) def test_final_position_example2(): assert final_position([\\"RIGHT\\", \\"RIGHT\\", \\"UP\\", \\"UP\\", \\"LEFT\\", \\"DOWN\\"]) == (1, 1) def test_final_position_single_command(): assert final_position([\\"UP\\"]) == (0, 1) assert final_position([\\"DOWN\\"]) == (0, -1) assert final_position([\\"LEFT\\"]) == (-1, 0) assert final_position([\\"RIGHT\\"]) == (1, 0) def test_final_position_no_movement(): assert final_position([]) == (0, 0) def test_final_position_combined_commands(): assert final_position([\\"UP\\", \\"DOWN\\", \\"LEFT\\", \\"RIGHT\\"]) == (0, 0) assert final_position([\\"UP\\", \\"UP\\", \\"DOWN\\", \\"DOWN\\"]) == (0, 0) assert final_position([\\"LEFT\\", \\"LEFT\\", \\"RIGHT\\", \\"RIGHT\\"]) == (0, 0) assert final_position([\\"UP\\", \\"UP\\", \\"LEFT\\", \\"LEFT\\"]) == (-2, 2)","solution":"def final_position(commands): Determine the final position of a robot given a list of commands. Parameters: commands (list): A list of strings which can be \\"LEFT\\", \\"RIGHT\\", \\"UP\\", \\"DOWN\\". Returns: tuple: A tuple (x, y) representing the final position on the grid. x, y = 0, 0 for command in commands: if command == \\"LEFT\\": x -= 1 elif command == \\"RIGHT\\": x += 1 elif command == \\"UP\\": y += 1 elif command == \\"DOWN\\": y -= 1 return (x, y)"},{"question":"def divide(dividend: int, divisor: int) -> int: Perform division without using the division operator. Returns the quotient after dividing \`dividend\` by \`divisor\`. >>> divide(10, 3) 3 >>> divide(7, -3) -2 >>> divide(-10, -2) 5 >>> divide(0, 1) 0 >>> divide(5, -5) -1","solution":"def divide(dividend, divisor): Perform division without using the division operator. Returns the quotient after dividing \`dividend\` by \`divisor\`. if divisor == 0: raise ValueError(\\"Divisor cannot be zero\\") # Determine the sign of the quotient sign = -1 if (dividend < 0) ^ (divisor < 0) else 1 # Work with absolute values to determine the quotient dividend, divisor = abs(dividend), abs(divisor) quotient = 0 while dividend >= divisor: temp, multiple = divisor, 1 while dividend >= (temp << 1): temp <<= 1 multiple <<= 1 dividend -= temp quotient += multiple return sign * quotient"},{"question":"def filter_multiples(arr, n): Create a function that accepts two arguments: an array of integers and a number \`n\`, and returns a new array containing only the integers from the original array that are multiples of \`n\`. If there are no multiples, return an empty array. :param arr: List of integers :param n: Integer :return: List of integers that are multiples of n >>> filter_multiples([2, 3, 4, 5, 6, 7, 8, 9], 2) [2, 4, 6, 8] >>> filter_multiples([10, 15, 20, 25, 30], 5) [10, 15, 20, 25, 30] >>> filter_multiples([1, 2, 3, 4, 5], 7) [] >>> filter_multiples([], 3) [] # Implementation here","solution":"def filter_multiples(arr, n): Returns a new array containing only the integers from the original array that are multiples of n. :param arr: List of integers :param n: Integer :return: List of integers that are multiples of n return [x for x in arr if x % n == 0]"},{"question":"def evaluate_expression(expression: str) -> int: Evaluate a mathematical expression with addition and subtraction. :param expression: A string representing the mathematical expression :return: The result of the expression as an integer >>> evaluate_expression(\\"12 + 23 - 4 + 5\\") == 36 >>> evaluate_expression(\\"100 - 50 + 25 - 5\\") == 70 >>> evaluate_expression(\\"-30 + 10 - 5\\") == -25 >>> evaluate_expression(\\"1 + 2 + 3 + 4 - 10\\") == 0 pass","solution":"def evaluate_expression(expression: str) -> int: Evaluate a mathematical expression with addition and subtraction. :param expression: A string representing the mathematical expression :return: The result of the expression as an integer # Replace any spaces in the input expression expression = expression.replace(\\" \\", \\"\\") # Initialize variables to store current number and result number = 0 result = 0 sign = 1 # To handle positive/negative sign, 1 for positive and -1 for negative # Traverse each character in the expression for char in expression: if char.isdigit(): # If char is digit, build the current number number = number * 10 + int(char) else: # If char is either '+' or '-', complete the previous number result += sign * number # Reset number to 0 number = 0 # Determine the current sign if char == '+': sign = 1 elif char == '-': sign = -1 # Add the last number in the expression result += sign * number return result"},{"question":"def can_fulfill_orders(initial_stock: dict, recipes: dict, orders: list) -> list: Determines whether each order can be fulfilled given the initial stock and recipes. Args: initial_stock (dict): A dictionary of ingredient stocks. recipes (dict): A dictionary of recipes with required ingredients and quantities. orders (list): A list of tuples where each tuple is (baked_item, quantity). Returns: list: A list of strings \\"Fulfilled\\" or \\"Rejected\\" based on the ability to fulfill each order. Examples: >>> initial_stock = { ... \\"flour\\": 1000, ... \\"sugar\\": 500, ... \\"eggs\\": 10, ... \\"butter\\": 200 ... } >>> recipes = { ... \\"cake\\": {\\"flour\\": 200, \\"sugar\\": 100, \\"eggs\\": 2, \\"butter\\": 50}, ... \\"cookie\\": {\\"flour\\": 100, \\"sugar\\": 50, \\"eggs\\": 1, \\"butter\\": 30} ... } >>> orders = [ ... (\\"cake\\", 1), ... (\\"cake\\", 2), ... (\\"cookie\\", 5), ... (\\"cake\\", 1) ... ] >>> can_fulfill_orders(initial_stock, recipes, orders) [\\"Fulfilled\\", \\"Fulfilled\\", \\"Rejected\\", \\"Fulfilled\\"] >>> initial_stock = { ... \\"flour\\": 500, ... \\"sugar\\": 200, ... \\"eggs\\": 5, ... \\"butter\\": 100 ... } >>> recipes = { ... \\"cake\\": {\\"flour\\": 200, \\"sugar\\": 100, \\"eggs\\": 2, \\"butter\\": 50} ... } >>> orders = [ ... (\\"pizza\\", 1) ... ] >>> can_fulfill_orders(initial_stock, recipes, orders) [\\"Rejected\\"]","solution":"def can_fulfill_orders(initial_stock, recipes, orders): Determines whether each order can be fulfilled given the initial stock and recipes. Args: initial_stock (dict): A dictionary of ingredient stocks. recipes (dict): A dictionary of recipes with required ingredients and quantities. orders (list): A list of tuples where each tuple is (baked_item, quantity). Returns: list: A list of strings \\"Fulfilled\\" or \\"Rejected\\" based on the ability to fulfill each order. results = [] current_stock = initial_stock.copy() for order in orders: item, quantity = order if item not in recipes: results.append(\\"Rejected\\") continue needed_ingredients = recipes[item] enough_stock = True for ingredient, required_amount in needed_ingredients.items(): if ingredient not in current_stock or current_stock[ingredient] < required_amount * quantity: enough_stock = False break if enough_stock: for ingredient, required_amount in needed_ingredients.items(): current_stock[ingredient] -= required_amount * quantity results.append(\\"Fulfilled\\") else: results.append(\\"Rejected\\") return results"},{"question":"def min_changes_to_palindrome(s: str) -> int: Returns the minimum number of changes required to make the string \`s\` a palindrome. >>> min_changes_to_palindrome(\\"abca\\") 1 >>> min_changes_to_palindrome(\\"race\\") 2 >>> min_changes_to_palindrome(\\"a\\") 0 >>> min_changes_to_palindrome(\\"ab\\") 1 >>> min_changes_to_palindrome(\\"abcba\\") 0 >>> min_changes_to_palindrome(\\"abcdba\\") 1 pass def process_test_cases(t: int, test_cases: List[str]) -> List[int]: Processes multiple test cases and returns a list of results for each test case. >>> process_test_cases(2, [\\"abca\\", \\"race\\"]) [1, 2] >>> process_test_cases(3, [\\"a\\", \\"ab\\", \\"abcba\\"]) [0, 1, 0] >>> process_test_cases(1, [\\"abcdba\\"]) [1] pass","solution":"def min_changes_to_palindrome(s): Returns the minimum number of changes required to make the string \`s\` a palindrome. n = len(s) changes = 0 for i in range(n // 2): if s[i] != s[n - i - 1]: changes += 1 return changes def process_test_cases(t, test_cases): results = [] for s in test_cases: results.append(min_changes_to_palindrome(s)) return results"},{"question":"def find_combinations(candidates: List[int], target: int) -> List[List[int]]: Find all unique combinations of numbers in the list where the chosen numbers sum to the target. Each number in the list can be used multiple times in the combination. The solution set must not contain duplicate combinations. >>> find_combinations([2, 3, 6, 7], 7) [[2, 2, 3], [7]] >>> find_combinations([2, 3, 5], 8) [[2, 2, 2, 2], [2, 3, 3], [3, 5]]","solution":"def find_combinations(candidates, target): def backtrack(current_combination, current_sum, start_index): if current_sum == target: result.append(list(current_combination)) return if current_sum > target: return for i in range(start_index, len(candidates)): current_combination.append(candidates[i]) backtrack(current_combination, current_sum + candidates[i], i) current_combination.pop() result = [] candidates.sort() backtrack([], 0, 0) return result"},{"question":"def diamond(d: int) -> str: Returns a string representing a diamond shape of width 'd'. :param d: an odd integer representing the widest part of the diamond. :return: A string representing the diamond shape. >>> diamond(1) == \\"*\\" >>> diamond(3) == \\" * n***n * \\" >>> diamond(5) == \\" * n *** n*****n *** n * \\" >>> diamond(7) == \\" * n *** n ***** n*******n ***** n *** n * \\" >>> diamond(9) == \\" * n *** n ***** n ******* n*********n ******* n ***** n *** n * \\" >>> diamond(4) == \\"\\" >>> diamond(-3) == \\"\\" >>> diamond(0) == \\"\\"","solution":"def diamond(d): Returns a string representing a diamond shape of width 'd'. :param d: an odd integer representing the widest part of the diamond. :return: A string representing the diamond shape. if d % 2 == 0 or d <= 0: return \\"\\" diamond_shape = [] for i in range(d): if i <= d // 2: stars = '*' * (2 * i + 1) else: stars = '*' * (2 * (d - i - 1) + 1) spaces = ' ' * ((d - len(stars)) // 2) diamond_shape.append(spaces + stars + spaces) return 'n'.join(diamond_shape)"},{"question":"def has_target_sum(nums: List[int], target: int) -> bool: Returns true if there are two distinct indices i and j in the array such that nums[i] + nums[j] is equal to the target. >>> has_target_sum([2, 7, 11, 15], 9) == True >>> has_target_sum([1, 2, 3, 4], 8) == False >>> has_target_sum([3, 3], 6) == True >>> has_target_sum([0, 4, 3, 0], 0) == True >>> has_target_sum([-1, -2, -3, -4, -5], -8) == True from solution import has_target_sum def test_example_1(): nums = [2, 7, 11, 15] target = 9 assert has_target_sum(nums, target) == True def test_example_2(): nums = [1, 2, 3, 4] target = 8 assert has_target_sum(nums, target) == False def test_example_3(): nums = [3, 3] target = 6 assert has_target_sum(nums, target) == True def test_example_4(): nums = [0, 4, 3, 0] target = 0 assert has_target_sum(nums, target) == True def test_example_5(): nums = [-1, -2, -3, -4, -5] target = -8 assert has_target_sum(nums, target) == True def test_empty_list(): nums = [] target = 0 assert has_target_sum(nums, target) == False def test_single_element_list(): nums = [5] target = 5 assert has_target_sum(nums, target) == False def test_large_numbers(): nums = [1000, 2000, 3000, 4000, 5000] target = 7000 assert has_target_sum(nums, target) == True","solution":"def has_target_sum(nums, target): Returns true if there are two distinct indices i and j in the array such that nums[i] + nums[j] is equal to the target. seen = {} for i, num in enumerate(nums): complementary = target - num if complementary in seen: return True seen[num] = i return False"},{"question":"def is_palindromic_subsequence(s: str, k: int) -> str: Determines if there exists a palindromic subsequence of length k in the given gene sequence. Parameters: s (str): The gene sequence. k (int): The desired length of the palindromic subsequence. Returns: str: \\"YES\\" if there is at least one palindromic subsequence of length k, otherwise \\"NO\\". pass def test_basic_cases(): assert is_palindromic_subsequence(\\"ACGTGTCAAA\\", 4) == \\"YES\\" assert is_palindromic_subsequence(\\"ACGT\\", 2) == \\"NO\\" def test_no_palindromes(): assert is_palindromic_subsequence(\\"ACGTACGT\\", 3) == \\"NO\\" assert is_palindromic_subsequence(\\"AAAA\\", 2) == \\"YES\\" def test_single_char_repeats(): assert is_palindromic_subsequence(\\"AAAAAAA\\", 4) == \\"YES\\" assert is_palindromic_subsequence(\\"CCCC\\", 3) == \\"YES\\" def test_long_sequence(): assert is_palindromic_subsequence(\\"ACGTGTCAAAACGTGTCAAA\\", 4) == \\"YES\\" def test_edge_cases(): assert is_palindromic_subsequence(\\"A\\", 1) == \\"NO\\" assert is_palindromic_subsequence(\\"AA\\", 2) == \\"YES\\" assert is_palindromic_subsequence(\\"AB\\", 2) == \\"NO\\"","solution":"def is_palindromic_subsequence(s, k): Determines if there exists a palindromic subsequence of length k in the given gene sequence. Parameters: s (str): The gene sequence. k (int): The desired length of the palindromic subsequence. Returns: str: \\"YES\\" if there is at least one palindromic subsequence of length k, otherwise \\"NO\\". from collections import defaultdict # Group by positions of each character pos = defaultdict(list) for i, c in enumerate(s): pos[c].append(i) # Check each unique character list to find palindromes for key, indexes in pos.items(): if len(indexes) < 2: continue # Check all pairs in this character list for i in range(len(indexes)): for j in range(i+1, len(indexes)): if indexes[j] - indexes[i] + 1 > k: # Too long break if s[indexes[i]:indexes[j]+1] == s[indexes[i]:indexes[j]+1][::-1]: return \\"YES\\" return \\"NO\\""},{"question":"def sort_generals(generals: List[Tuple[str, int]]) -> List[str]: Sorts generals based on the number of troops they command in descending order. If two or more generals have the same number of troops, they are sorted alphabetically by name. :param generals: List of tuples containing the general's name and the number of troops they command. :return: List of sorted general names. Example: >>> sort_generals([(\\"Alexander\\", 500), (\\"Caesar\\", 800), (\\"Napoleon\\", 500), (\\"Hannibal\\", 600)]) ['Caesar', 'Hannibal', 'Alexander', 'Napoleon'] >>> sort_generals([(\\"Genghis\\", 1000), (\\"Sun Tzu\\", 900), (\\"Zhuge\\", 900), (\\"Attila\\", 800)]) ['Genghis', 'Sun Tzu', 'Zhuge', 'Attila'] >>> sort_generals([(\\"Xerxes\\", 300), (\\"Leonidas\\", 300), (\\"Themistocles\\", 300), (\\"Pericles\\", 300)]) ['Leonidas', 'Pericles', 'Themistocles', 'Xerxes'] pass # your code here","solution":"def sort_generals(generals): Sorts generals based on the number of troops they command in descending order. If two or more generals have the same number of troops, they are sorted alphabetically by name. :param generals: List of tuples containing the general's name and the number of troops they command. :return: List of sorted general names. # Sort primarily by number of troops in descending order and secondarily by name alphabetically sorted_generals = sorted(generals, key=lambda x: (-x[1], x[0])) # Extract only the names of the generals return [general[0] for general in sorted_generals]"},{"question":"def merge_and_query(A: List[int], B: List[int], queries: List[int]) -> List[int]: Merges two sorted lists A and B, and finds the k-th smallest element for each query in queries. Args: A (List[int]): First sorted list of integers. B (List[int]): Second sorted list of integers. queries (List[int]): List of integers representing the queries. Returns: List[int]: List of results for each query. Example: >>> merge_and_query([1, 3, 5, 7, 9], [2, 4, 6, 8, 10], [1, 5, 10]) [1, 5, 10]","solution":"def merge_and_query(A, B, queries): Merges two sorted lists A and B, and finds the k-th smallest element for each query in queries. merged_list = sorted(A + B) results = [merged_list[k - 1] for k in queries] return results # Example usage: N = 5 A = [1, 3, 5, 7, 9] B = [2, 4, 6, 8, 10] Q = 3 queries = [1, 5, 10] print(merge_and_query(A, B, queries)) # Expected: [1, 5, 10]"},{"question":"def is_palindrome(num: int) -> bool: Check if a number is a palindrome. >>> is_palindrome(121) True >>> is_palindrome(123) False >>> is_palindrome(808) True pass def next_palindrome(n: int) -> int: Find the smallest palindromic number greater than or equal to n. >>> next_palindrome(123) 131 >>> next_palindrome(808) 808 >>> next_palindrome(1001) 1001 pass def find_nearest_palindromes(test_cases: List[int]) -> List[int]: Find the nearest palindromic number for each integer in the test cases. >>> find_nearest_palindromes([123, 808, 1001]) [131, 808, 1001] >>> find_nearest_palindromes([9, 10, 20]) [9, 11, 22] pass","solution":"def is_palindrome(num): Check if a number is a palindrome. return str(num) == str(num)[::-1] def next_palindrome(n): Find the smallest palindromic number greater than or equal to n. while True: if is_palindrome(n): return n n += 1 def find_nearest_palindromes(test_cases): Function to process multiple test cases for nearest palindrome number. results = [] for case in test_cases: results.append(next_palindrome(case)) return results"},{"question":"def valid_paths_exist(T: int, test_cases: List[Tuple[int, List[str]]]) -> List[str]: Determine if Alice and Bob can traverse the grid without crossing paths. Alice will start at (0, 0) and attempt to reach (M-1, M-1). Bob will start at (M-1, M-1) and attempt to reach (0, 0). Alice's movements: right (0, 1) or down (1, 0) Bob's movements: up (-1, 0) or left (0, -1) Args: T: Number of test cases test_cases: List of tuples, each containing: M: Size of the grid grid: List of strings representing the grid Returns: List of strings: \\"YES\\" if there exists valid paths for both Alice and Bob without crossing paths, otherwise \\"NO\\" pass def test_valid_paths_exist(): test_cases = [ (2, [ (3, ['OXX', 'OXO', 'XOO']), (4, ['OOOX', 'OXOX', 'OOOX', 'XOOO']) ]), (1, [ (4, ['OOXX', 'OXOX', 'OXOX', 'XOOX']) ]), (1, [ (3, ['OXO', 'OXO', 'OXO']) ]) ] expected_outputs = [ [\\"NO\\", \\"YES\\"], [\\"NO\\"], [\\"NO\\"] ] for test_case, expected_output in zip(test_cases, expected_outputs): T, cases = test_case assert valid_paths_exist(T, cases) == expected_output if __name__ == \\"__main__\\": import pytest pytest.main([\\"-v\\", \\"--tb=line\\", \\"-rN\\"])","solution":"def valid_paths_exist(T, test_cases): results = [] def is_valid_path(grid, start, end, move_options): M = len(grid) stack = [start] visited = set() while stack: current = stack.pop() if current == end: return True if current in visited: continue visited.add(current) x, y = current for dx, dy in move_options: nx, ny = x + dx, y + dy if 0 <= nx < M and 0 <= ny < M and grid[nx][ny] == 'O' and (nx, ny) not in visited: stack.append((nx, ny)) return False for M, grid in test_cases: # Alice moves: right (0, 1), down (1, 0) alice_start, alice_end = (0, 0), (M-1, M-1) alice_moves = [(0, 1), (1, 0)] alice_valid = is_valid_path(grid, alice_start, alice_end, alice_moves) # Bob moves: up (-1, 0), left (0, -1) bob_start, bob_end = (M-1, M-1), (0, 0) bob_moves = [(-1, 0), (0, -1)] bob_valid = is_valid_path(grid, bob_start, bob_end, bob_moves) if alice_valid and bob_valid: results.append(\\"YES\\") else: results.append(\\"NO\\") return results def process_input(): import sys input = sys.stdin.read data = input().split() T = int(data[0]) idx = 1 test_cases = [] for _ in range(T): M = int(data[idx]) idx += 1 grid = [] for i in range(M): grid.append(data[idx]) idx += 1 test_cases.append((M, grid)) results = valid_paths_exist(T, test_cases) for result in results: print(result)"},{"question":"def unique_paths(M, N): Returns the number of unique paths from the top-left corner to the bottom-right corner in a MxN grid. def process_testcases(T, testcases): Processes multiple testcases to find the number of unique paths for each. def parse_input(input_string): Parses the input string and returns the number of testcases and a list of (M, N) tuples. def format_output(results): Formats the results list into a string with each result on a new line.","solution":"def unique_paths(M, N): Returns the number of unique paths from the top-left corner to the bottom-right corner in a MxN grid. dp = [[1] * N for _ in range(M)] for i in range(1, M): for j in range(1, N): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[M-1][N-1] def process_testcases(T, testcases): results = [] for M, N in testcases: results.append(unique_paths(M, N)) return results def parse_input(input_string): lines = input_string.strip().split('n') T = int(lines[0]) testcases = [tuple(map(int, line.split())) for line in lines[1:T+1]] return T, testcases def format_output(results): return 'n'.join(map(str, results))"},{"question":"def is_palindrome(x: int) -> bool: Determine if a given integer is a palindrome without converting the integer to a string. >>> is_palindrome(121) == True >>> is_palindrome(-121) == False >>> is_palindrome(10) == False >>> is_palindrome(7) == True >>> is_palindrome(0) == True >>> is_palindrome(9) == True >>> is_palindrome(123454321) == True >>> is_palindrome(123456789) == False from solution import is_palindrome def test_positive_palindrome(): assert is_palindrome(121) == True def test_negative_not_palindrome(): assert is_palindrome(-121) == False def test_non_palindrome(): assert is_palindrome(10) == False def test_single_digit(): assert is_palindrome(7) == True assert is_palindrome(0) == True assert is_palindrome(9) == True def test_large_palindrome(): assert is_palindrome(123454321) == True def test_large_non_palindrome(): assert is_palindrome(123456789) == False","solution":"def is_palindrome(x): Determine if a given integer is a palindrome without converting it to a string. if x < 0: return False original_x = x reversed_x = 0 while x != 0: reversed_x = reversed_x * 10 + x % 10 x //= 10 return original_x == reversed_x"},{"question":"def minimum_max_time(workers: int, tasks: List[int]) -> int: Given a number of workers and a list of task times, return the minimum possible maximum completion time for any worker. >>> minimum_max_time(3, [10, 20, 30, 40, 50]) 60 >>> minimum_max_time(2, [10, 20, 30]) 30 >>> minimum_max_time(2, [7, 2, 5, 10, 8]) 18 >>> minimum_max_time(3, [1, 2, 3, 4, 5]) 6 >>> minimum_max_time(10, [5]) 5 >>> minimum_max_time(3, []) -1 >>> minimum_max_time(1, [1, 1, 1, 1]) 4 >>> minimum_max_time(5, [1, 1, 1]) 1","solution":"def minimum_max_time(workers, tasks): if len(tasks) < 1 or workers < 1: return -1 def canAllocate(mid): required_workers = 1 current_load = 0 for task in tasks: if current_load + task <= mid: current_load += task else: required_workers += 1 current_load = task if required_workers > workers: return False return True if workers >= len(tasks): return max(tasks) left, right = max(tasks), sum(tasks) answer = right while left <= right: mid = (left + right) // 2 if canAllocate(mid): answer = mid right = mid - 1 else: left = mid + 1 return answer"},{"question":"from typing import List, Tuple def get_connected_components_sizes(N: int, M: int, edges: List[Tuple[int, int]]) -> List[int]: Given an undirected graph with N nodes and M edges, identify all connected components in the graph and calculate the size of each component. Returns a list of sizes of all connected components in non-decreasing order. def parse_input(input_str: str) -> Tuple[int, int, List[Tuple[int, int]]]: Parse the input string and return N, M, and edges. >>> parse_input(\\"6 4n1 2n2 3n4 5n5 6\\") == (6, 4, [(1, 2), (2, 3), (4, 5), (5, 6)]) def format_output(component_sizes: List[int]) -> str: Format the output as a space-separated string of component sizes sorted in non-decreasing order. >>> format_output([3, 3]) == \\"3 3\\" from solution import get_connected_components_sizes, parse_input, format_output def test_sample_input_1(): input_str = \\"6 4n1 2n2 3n4 5n5 6\\" N, M, edges = parse_input(input_str) result = get_connected_components_sizes(N, M, edges) output = format_output(result) assert output == \\"3 3\\" def test_sample_input_2(): input_str = \\"5 3n1 2n3 4n4 5\\" N, M, edges = parse_input(input_str) result = get_connected_components_sizes(N, M, edges) output = format_output(result) assert output == \\"2 3\\" def test_disconnected_single_nodes(): input_str = \\"5 0\\" N, M, edges = parse_input(input_str) result = get_connected_components_sizes(N, M, edges) output = format_output(result) assert output == \\"1 1 1 1 1\\" def test_single_connected_component(): input_str = \\"4 3n1 2n2 3n3 4\\" N, M, edges = parse_input(input_str) result = get_connected_components_sizes(N, M, edges) output = format_output(result) assert output == \\"4\\" def test_complex_graph(): input_str = \\"7 5n1 2n2 3n4 5n5 6n6 7\\" N, M, edges = parse_input(input_str) result = get_connected_components_sizes(N, M, edges) output = format_output(result) assert output == \\"3 4\\"","solution":"def get_connected_components_sizes(N, M, edges): from collections import defaultdict, deque def bfs(node): queue = deque([node]) visited[node] = True size = 0 while queue: current = queue.popleft() size += 1 for neighbor in graph[current]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return size # Creating graph as an adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = [False] * (N + 1) # 1-based indexing component_sizes = [] for node in range(1, N + 1): if not visited[node]: size = bfs(node) component_sizes.append(size) component_sizes.sort() return component_sizes def parse_input(input_str): lines = input_str.strip().split('n') N, M = map(int, lines[0].split()) edges = [tuple(map(int, line.split())) for line in lines[1:]] return N, M, edges def format_output(component_sizes): return \\" \\".join(map(str, component_sizes))"},{"question":"def length_of_lis(nums: List[int]) -> int: Write a function that takes a list of integers and returns the length of the longest subsequence where the elements are in increasing order. >>> length_of_lis([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> length_of_lis([3, 10, 2, 1, 20]) 3 >>> length_of_lis([3, 2]) 1","solution":"def length_of_lis(nums): if not nums: return 0 dp = [1] * len(nums) for i in range(1, len(nums)): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def can_fulfill_demands(n: int, m: int, equipment: List[int], demands: List[int]) -> str: Determines if all departmental demands can be fulfilled with available equipment units. Args: n (int): Number of equipment types. m (int): Number of departmental demands. equipment (List[int]): List of equipment units available for each type. demands (List[int]): List of departmental demands for equipment types. Returns: str: \\"Yes\\" if all demands can be fulfilled, otherwise \\"No\\". >>> can_fulfill_demands(3, 5, [3, 2, 3], [1, 2, 3, 1, 2]) \\"Yes\\" >>> can_fulfill_demands(2, 3, [1, 1], [2, 2, 2]) \\"No\\" >>> can_fulfill_demands(3, 0, [1, 1, 1], []) \\"Yes\\" >>> can_fulfill_demands(3, 4, [1, 0, 2], [1, 2, 3, 3]) \\"No\\" >>> can_fulfill_demands(1, 1, [1], [1]) \\"Yes\\" >>> can_fulfill_demands(100000, 100000, [1] * 100000, list(range(1, 100001))) \\"Yes\\" >>> can_fulfill_demands(3, 5, [1, 2, 2], [1, 1, 2, 3, 3]) \\"No\\"","solution":"def can_fulfill_demands(n, m, equipment, demands): Determines if all departmental demands can be fulfilled with available equipment units. Args: n (int): Number of equipment types. m (int): Number of departmental demands. equipment (List[int]): List of equipment units available for each type. demands (List[int]): List of departmental demands for equipment types. Returns: str: \\"Yes\\" if all demands can be fulfilled, otherwise \\"No\\". available_equipment = equipment[:] for demand in demands: if available_equipment[demand - 1] > 0: available_equipment[demand - 1] -= 1 else: return \\"No\\" return \\"Yes\\""},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def is_symmetric(root): Check if a binary tree is symmetric (mirror image of itself). >>> is_symmetric(TreeNode(1).val == TreeNode(2).val == TreeNode(2).val == TreeNode(3).val == TreeNode(4).val == TreeNode(4).vals == TreeNode(3).val) YES >>> is_symmetric(TreeNode(1).val == TreeNode(2).val == TreeNode(2).val == TreeNode('N').val == TreeNode(3).val == TreeNode('N').vals == TreeNode(3).val) NO def build_tree(nodes): Build a tree from level-order traversal list. def check_symmetric_trees(test_cases): Check if the given trees in test cases are symmetric. def main(input_data): Main function to parse input and return results.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def is_symmetric(root): if not root: return True def is_mirror(t1, t2): if not t1 and not t2: return True if not t1 or not t2: return False return (t1.val == t2.val) and is_mirror(t1.right, t2.left) and is_mirror(t1.left, t2.right) return is_mirror(root.left, root.right) def build_tree(nodes): if not nodes or nodes[0] == 'N': return None root = TreeNode(int(nodes[0])) queue = [root] i = 1 while queue and i < len(nodes): current = queue.pop(0) if nodes[i] != 'N': current.left = TreeNode(int(nodes[i])) queue.append(current.left) i += 1 if i < len(nodes) and nodes[i] != 'N': current.right = TreeNode(int(nodes[i])) queue.append(current.right) i += 1 return root def check_symmetric_trees(test_cases): results = [] for nodes in test_cases: root = build_tree(nodes) if is_symmetric(root): results.append(\\"YES\\") else: results.append(\\"NO\\") return results # Function to parse input and return results def main(input_data): lines = input_data.strip().split('n') T = int(lines[0]) test_cases = [] for i in range(1, T+1): nodes = lines[i].split() test_cases.append(nodes) results = check_symmetric_trees(test_cases) return 'n'.join(results)"},{"question":"def max_gold_coins(n: int, m: int, maze: List[List[int]]) -> int: Calculate the maximum number of gold coins that can be collected in a maze. >>> max_gold_coins(3, 3, [ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1]]) 12 >>> max_gold_coins(1, 1, [[5]]) 5 >>> max_gold_coins(1, 4, [ ... [1, 2, 3, 4]]) 10 >>> max_gold_coins(4, 1, [ ... [1], ... [2], ... [3], ... [4]]) 10 >>> max_gold_coins(2, 2, [ ... [0, 0], ... [0, 0]]) 0","solution":"def max_gold_coins(n, m, maze): # Initialize a 2D dp array with zeros dp = [[0 for _ in range(m)] for _ in range(n)] # Start at the first cell dp[0][0] = maze[0][0] # Fill the first row for j in range(1, m): dp[0][j] = dp[0][j - 1] + maze[0][j] # Fill the first column for i in range(1, n): dp[i][0] = dp[i - 1][0] + maze[i][0] # Fill the rest of the dp array for i in range(1, n): for j in range(1, m): dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + maze[i][j] # The bottom-right cell contains the maximum number of gold coins we can collect return dp[n - 1][m - 1]"},{"question":"def generate_pascals_triangle(n: int) -> List[List[int]]: Generate Pascal's triangle up to the nth row (inclusive). :param n: Integer representing the depth of the Pascal's triangle :return: A list of lists, where each inner list represents a row in Pascal's triangle >>> generate_pascals_triangle(0) [] >>> generate_pascals_triangle(1) [[1]] >>> generate_pascals_triangle(2) [[1], [1, 1]] >>> generate_pascals_triangle(3) [[1], [1, 1], [1, 2, 1]] >>> generate_pascals_triangle(4) [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1]] >>> generate_pascals_triangle(5) [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]","solution":"from typing import List def generate_pascals_triangle(n: int) -> List[List[int]]: Generate Pascal's triangle up to the nth row (inclusive). :param n: Integer representing the depth of the Pascal's triangle :return: A list of lists, where each inner list represents a row in Pascal's triangle if n == 0: return [] triangle = [[1]] for i in range(1, n): row = [1] for j in range(1, i): row.append(triangle[i-1][j-1] + triangle[i-1][j]) row.append(1) triangle.append(row) return triangle"},{"question":"def string_operations(operations: List[str]) -> List[str]: Perform a series of operations on a string and return the results of queries. Args: operations (List[str]): List of operations to be performed on the string. Returns: List[str]: Results of the query operations. >>> string_operations([\\"A a\\", \\"A b\\", \\"A c\\", \\"Q 2\\", \\"R\\", \\"Q 3\\", \\"R\\", \\"Q 1\\"]) [\\"b\\", \\"Invalid\\", \\"a\\"] >>> string_operations([\\"A x\\", \\"A y\\", \\"R\\", \\"A z\\", \\"Q 1\\", \\"Q 2\\"]) [\\"x\\", \\"z\\"]","solution":"def string_operations(operations): result = [] s = [] for operation in operations: parts = operation.split() op = parts[0] if op == 'A': s.append(parts[1]) elif op == 'R': if s: s.pop() elif op == 'Q': p = int(parts[1]) if 1 <= p <= len(s): result.append(s[p-1]) else: result.append('Invalid') return result"},{"question":"def first_repeated_character(s: str) -> str: Returns the first repeated character in the given string (case insensitive). If no characters are repeated, returns an empty string. >>> first_repeated_character(\\"Swiss\\") \\"s\\" >>> first_repeated_character(\\"Programming\\") \\"r\\" >>> first_repeated_character(\\"Effort\\") \\"f\\" >>> first_repeated_character(\\"Python\\") \\"\\" >>> first_repeated_character(\\"abc\\") \\"\\" >>> first_repeated_character(\\"aAbB\\") \\"a\\" >>> first_repeated_character(\\"XyZxxYy\\") \\"x\\" >>> first_repeated_character(\\"aabb!!c\\") \\"a\\" >>> first_repeated_character(\\"!!!\\") \\"!\\" >>> first_repeated_character(\\"test@case.com\\") \\"t\\"","solution":"def first_repeated_character(s): Returns the first repeated character in the given string (case insensitive). If no characters are repeated, returns an empty string. s = s.lower() seen = set() for char in s: if char in seen: return char seen.add(char) return \\"\\""},{"question":"def unique_paths(M: int, N: int) -> int: Calculate the number of unique paths from the top-left corner to the bottom-right corner of a MxN grid. >>> unique_paths(2, 2) 2 >>> unique_paths(3, 3) 6 >>> unique_paths(3, 7) 28 def solve_unique_paths(test_cases: List[Tuple[int, int]]) -> List[int]: Given a list of test cases where each test case is a tuple (M, N) representing the dimensions of the grid, returns a list of integers representing the number of unique paths for each test case. >>> solve_unique_paths([(2, 2), (3, 3), (3, 7)]) [2, 6, 28] # Test cases def test_unique_paths_small_grids(): assert unique_paths(2, 2) == 2 assert unique_paths(3, 3) == 6 assert unique_paths(3, 7) == 28 def test_unique_paths_large_grids(): assert unique_paths(10, 10) == 48620 assert unique_paths(15, 15) == 40116600 assert unique_paths(20, 20) == 35345263800 def test_solve_unique_paths(): test_cases = [(2, 2), (3, 3), (3, 7)] expected_results = [2, 6, 28] assert solve_unique_paths(test_cases) == expected_results def test_edge_cases(): assert unique_paths(1, 1) == 1 assert unique_paths(1, 100) == 1 assert unique_paths(100, 1) == 1","solution":"def unique_paths(M, N): Calculate the number of unique paths from the top-left corner to the bottom-right corner of a MxN grid. This is done using dynamic programming. # Create a 2D array to store the number of paths to each cell dp = [[1] * N for _ in range(M)] # Iterate over the grid starting from cell (1,1) for i in range(1, M): for j in range(1, N): dp[i][j] = dp[i-1][j] + dp[i][j-1] # Return the number of paths to the bottom-right corner return dp[M-1][N-1] def solve_unique_paths(test_cases): results = [] for M, N in test_cases: results.append(unique_paths(M, N)) return results"},{"question":"def rental_cost(days: int) -> int: Calculate the total cost after applying the appropriate discount based on the number of rental days. >>> rental_cost(2) 80 >>> rental_cost(3) 100 >>> rental_cost(7) 230 pass","solution":"def rental_cost(days: int) -> int: Returns the total cost after applying the appropriate discount based on the rental days. base_cost = days * 40 if days >= 7: discount = 50 elif days >= 3: discount = 20 else: discount = 0 total_cost = base_cost - discount return total_cost"},{"question":"def find_pair(numbers: List[int], target: int) -> Union[Tuple[int, int], None]: Finds two distinct numbers in the array that sum up to the target integer. Returns a tuple of these two numbers, or None if no such pair exists. Examples: >>> find_pair([2, 7, 11, 15], 9) (2, 7) >>> find_pair([1, 2, 3, 4, 5, 6], 10) None from typing import List, Tuple, Union def test_find_pair_exists(): assert find_pair([2, 7, 11, 15], 9) in [(2, 7), (7, 2)] assert find_pair([1, 5, 3, 4, 2], 8) in [(3, 5), (5, 3)] def test_find_pair_multiple_exists(): assert find_pair([1, 2, 4, 3, 6], 7) in [(1, 6), (6, 1), (3, 4), (4, 3)] def test_find_pair_no_pair(): assert find_pair([1, 2, 3, 4, 5, 6], 12) is None def test_find_pair_with_negative_numbers(): assert find_pair([-1, 2, 3, -3, 5], 0) in [(-3, 3), (3, -3), (-1, 1), (1, -1)] def test_find_pair_with_repeated_numbers(): assert find_pair([1, 1, 2, 3, 4], 2) in [(1, 1)] def test_find_pair_minimal_input(): assert find_pair([0, 1], 1) in [(0, 1), (1, 0)]","solution":"def find_pair(numbers, target): Finds two distinct numbers in the array that sum up to the target integer. Returns a tuple of these two numbers, or None if no such pair exists. seen = set() for number in numbers: complement = target - number if complement in seen: return (number, complement) seen.add(number) return None"},{"question":"from typing import List def can_partition_into_k_palindromes(s: str, k: int) -> bool: Determine if the string can be decomposed into exactly \`k\` non-empty palindromic substrings. A palindrome is a string that reads the same forward as backward. Examples: >>> can_partition_into_k_palindromes(\\"abacdcaba\\", 3) True >>> can_partition_into_k_palindromes(\\"abc\\", 2) False >>> can_partition_into_k_palindromes(\\"aabb\\", 4) True","solution":"def can_partition_into_k_palindromes(s: str, k: int) -> bool: def is_palindrome(sub): return sub == sub[::-1] n = len(s) if k > n: return False # Minimum \`k\` is at most \`count of characters - 1\` changes are required # because each distinct change can create a new partition. dp = [[False] * (k + 1) for _ in range(n + 1)] dp[0][0] = True for i in range(1, n + 1): for j in range(1, k + 1): for l in range(j-1, i): if dp[l][j-1] and is_palindrome(s[l:i]): dp[i][j] = True break return dp[n][k]"},{"question":"def average_grade(students, subject): Returns the average grade for the given subject across all students. If the subject does not exist for any student, consider their grade as 0 for that subject. Round the average grade to two decimal places. >>> students = [ ... {\\"name\\": \\"Alice\\", \\"Math\\": 95, \\"English\\": 85}, ... {\\"name\\": \\"Bob\\", \\"Math\\": 75, \\"Science\\": 90}, ... {\\"name\\": \\"Clara\\", \\"Math\\": 60}, ... {\\"name\\": \\"David\\", \\"English\\": 92} ... ] >>> average_grade(students, \\"Math\\") 57.5 >>> average_grade(students, \\"English\\") 44.25 >>> average_grade([], \\"Math\\") 0.00 >>> students_no_math = [ ... {\\"name\\": \\"Alice\\"}, ... {\\"name\\": \\"Bob\\"}, ... {\\"name\\": \\"Clara\\"}, ... {\\"name\\": \\"David\\"} ... ] >>> average_grade(students_no_math, \\"Math\\") 0.00 >>> students_mixed = [ ... {\\"name\\": \\"Alice\\", \\"Math\\": 92}, ... {\\"name\\": \\"Bob\\", \\"Math\\": 78}, ... {\\"name\\": \\"Clara\\"} ... ] >>> average_grade(students_mixed, \\"Math\\") 56.67 >>> students_single = [ ... {\\"name\\": \\"Alice\\", \\"Math\\": 88} ... ] >>> average_grade(students_single, \\"Math\\") 88.00","solution":"def average_grade(students, subject): Returns the average grade for the given subject across all students. If the subject does not exist for any student, consider their grade as 0 for that subject. Round the average grade to two decimal places. total = 0 count = len(students) if count == 0: return 0.00 for student in students: total += student.get(subject, 0) average = total / count return round(average, 2)"},{"question":"def elements_greater_than_average(arr: List[int]) -> List[int]: Write a function that takes an array of numbers as input and returns a new array containing only the elements that are strictly greater than the average of the original array. >>> elements_greater_than_average([1, 2, 3, 4, 5]) [4, 5] >>> elements_greater_than_average([10, 20, 30, 40, 50, 60]) [40, 50, 60]","solution":"def elements_greater_than_average(arr): if len(arr) == 0: return [] avg = sum(arr) / len(arr) return [x for x in arr if x > avg]"},{"question":"def strings_with_order(strings: List[str]) -> List[str]: This function takes a list of strings and returns a new list containing only the strings that have their distinct characters sorted in alphabetical order. The function preserves the relative order of the original list. >>> strings_with_order(['abc', 'aab', 'xyz']) ['abc', 'aab', 'xyz'] >>> strings_with_order(['bca', 'cba', 'zyx']) [] >>> strings_with_order(['abc', 'bca', 'aab', 'xyz', 'cba']) ['abc', 'aab', 'xyz'] >>> strings_with_order(['a', 'b', 'c']) ['a', 'b', 'c'] >>> strings_with_order([]) []","solution":"from typing import List def strings_with_order(strings: List[str]) -> List[str]: def is_sorted_string(s: str) -> bool: return list(s) == sorted(s) return [s for s in strings if is_sorted_string(s)]"},{"question":"def max_sum_of_subarray(arr: List[int], k: int) -> int: Find the maximum sum of any contiguous subarray of size k. Args: arr (List[int]): The list of integers. k (int): The size of the contiguous subarray. Returns: int: The maximum sum of any contiguous subarray of size k. Example: >>> max_sum_of_subarray([1, 2, 3, 4, 5], 2) 9 >>> max_sum_of_subarray([-1, -2, -3, -4, -5], 3) -6 pass # Your implementation here def test_max_sum_of_subarray_positive_numbers(): assert max_sum_of_subarray([1, 2, 3, 4, 5], 2) == 9 def test_max_sum_of_subarray_negative_numbers(): assert max_sum_of_subarray([-1, -2, -3, -4, -5], 3) == -6 def test_max_sum_of_subarray_mixed_numbers(): assert max_sum_of_subarray([1, -2, 3, 4, -1, 2, 1, -5, 4], 3) == 6 def test_max_sum_of_subarray_single_element(): assert max_sum_of_subarray([1], 1) == 1 assert max_sum_of_subarray([-1], 1) == -1 def test_max_sum_of_subarray_size_equal_to_array_length(): assert max_sum_of_subarray([1, 2, 3, 4, 5], 5) == 15 def test_max_sum_of_subarray_size_one(): assert max_sum_of_subarray([1, 2, 3, 4, 5], 1) == 5 assert max_sum_of_subarray([-1, -2, -3, -4, -5], 1) == -1 def test_max_sum_of_subarray_large_input(): large_input = [1] * 10**6 assert max_sum_of_subarray(large_input, 10**6) == 10**6 def test_max_sum_of_subarray_k_greater_than_n(): assert max_sum_of_subarray([], 1) == 0 assert max_sum_of_subarray([1, 2, 3], 4) == 0","solution":"def max_sum_of_subarray(arr, k): Returns the maximum sum of any contiguous subarray of size k. n = len(arr) if n < k or k <= 0: return 0 # Calculate the sum of the first window of size k max_sum = sum(arr[:k]) current_sum = max_sum # Slide the window over the array for i in range(k, n): current_sum += arr[i] - arr[i - k] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def min_repeats(a: str, b: str) -> int: Determine the minimum number of times the string \`a\` should be repeated to form a supersequence that contains \`b\` as a subsequence. >>> min_repeats(\\"abc\\", \\"bcac\\") == 2 >>> min_repeats(\\"abc\\", \\"xyz\\") == -1 >>> min_repeats(\\"abc\\", \\"abc\\") == 1 >>> min_repeats(\\"abc\\", \\"abab\\") == 2 >>> min_repeats(\\"abcd\\", \\"cdabcdab\\") == 3 >>> min_repeats(\\"a\\", \\"aaa\\") == 3 >>> min_repeats(\\"a\\", \\"b\\") == -1 >>> min_repeats(\\"xyz\\", \\"xyzyz\\") == 2 pass","solution":"def min_repeats(a: str, b: str) -> int: # Function to check if b is a subsequence of s def is_subsequence(s, b): b_idx = 0 for char in s: if b_idx < len(b) and char == b[b_idx]: b_idx += 1 if b_idx == len(b): return True return b_idx == len(b) # Lengths of the strings len_a = len(a) len_b = len(b) # Maximum number of repetitions needed to cover the length of b max_repeats = (len_b + len_a - 1) // len_a + 1 # one extra to handle boundaries # Check with increasing repetitions of a for repeats in range(1, max_repeats + 1): if is_subsequence(a * repeats, b): return repeats return -1"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_smallest_larger_than_k(root: TreeNode, k: int) -> int: You are given a binary tree where each node has a value as an integer. Your task is to write a function that returns the smallest value in the tree that is larger than a given value k. If no such value exists, return -1. >>> root = TreeNode(5) >>> root.left = TreeNode(3) >>> root.right = TreeNode(7) >>> root.left.left = TreeNode(2) >>> root.left.right = TreeNode(4) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(8) >>> find_smallest_larger_than_k(root, 4) 5 >>> find_smallest_larger_than_k(root, 7) 8 >>> find_smallest_larger_than_k(root, 8) -1","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_smallest_larger_than_k(root: TreeNode, k: int) -> int: def inorder_traversal(node): if node: inorder_traversal(node.left) if node.val > k: larger_values.append(node.val) inorder_traversal(node.right) larger_values = [] inorder_traversal(root) if not larger_values: return -1 return min(larger_values)"},{"question":"class Book: A class to represent a book with attributes: title, author, genre, year_published, and ISBN. Attributes: title (str): Title of the book. Default is \\"Untitled\\". author (str): Author of the book. Default is \\"Unknown\\". genre (str): Genre of the book. Default is \\"General\\". year_published (int): Year the book was published. Default is 0. isbn (str): ISBN of the book. Default is \\"0000000000\\". >>> book = Book() >>> book.title \\"Untitled\\" >>> book = Book(\\"1984\\", \\"George Orwell\\", \\"Dystopian\\", 1949, \\"1234567890\\") >>> book.title \\"1984\\" >>> book = Book(title=\\"Brave New World\\", year_published=1932, isbn=\\"0987654321\\") >>> book.title \\"Brave New World\\"","solution":"class Book: def __init__(self, title=\\"Untitled\\", author=\\"Unknown\\", genre=\\"General\\", year_published=0, isbn=\\"0000000000\\"): self.title = title self.author = author self.genre = genre self.year_published = year_published self.isbn = isbn"},{"question":"def vacuumPath(start, movements): Calculates the final position of the robotic vacuum cleaner after a series of movement instructions. Args: start (tuple): Starting coordinates (x, y) of the vacuum cleaner. movements (list): List of movement commands (\\"UP\\", \\"DOWN\\", \\"LEFT\\", \\"RIGHT\\"). Returns: tuple: Final coordinates (x, y) after executing all movements. >>> vacuumPath((0, 0), []) == (0, 0) >>> vacuumPath((0, 0), [\\"UP\\"]) == (0, 1) >>> vacuumPath((0, 0), [\\"DOWN\\", \\"DOWN\\"]) == (0, -2) >>> vacuumPath((0, 0), [\\"LEFT\\", \\"RIGHT\\", \\"LEFT\\", \\"RIGHT\\"]) == (0, 0)","solution":"def vacuumPath(start, movements): Calculates the final position of the robotic vacuum cleaner after a series of movement instructions. Args: start (tuple): Starting coordinates (x, y) of the vacuum cleaner. movements (list): List of movement commands (\\"UP\\", \\"DOWN\\", \\"LEFT\\", \\"RIGHT\\"). Returns: tuple: Final coordinates (x, y) after executing all movements. x, y = start for move in movements: if move == \\"UP\\": y += 1 elif move == \\"DOWN\\": y -= 1 elif move == \\"LEFT\\": x -= 1 elif move == \\"RIGHT\\": x += 1 return (x, y)"},{"question":"def track_stamps_changes(original: List[int], updated: List[int]) -> List[List[int]]: Returns a list of identifiers added to the collection and a list of identifiers removed from the collection since the original list. :param original: List of integers representing the original collection of stamps. :param updated: List of integers representing the updated collection of stamps. :return: A list containing two lists: - The first list contains identifiers added to the collection. - The second list contains identifiers removed from the collection. >>> track_stamps_changes([3, 5, 6, 9], [4, 5, 6, 10]) [[4, 10], [3, 9]] >>> track_stamps_changes([1, 2, 3], [1, 2, 3]) [[], []] >>> track_stamps_changes([], [7, 8, 9]) [[7, 8, 9], []] >>> track_stamps_changes([10, 11, 12], []) [[], [10, 11, 12]] >>> track_stamps_changes([15, 16, 17, 18], [17, 18, 19, 20]) [[19, 20], [15, 16]]","solution":"def track_stamps_changes(original, updated): Returns a list of identifiers added to the collection and a list of identifiers removed from the collection since the original list. :param original: List of integers representing the original collection of stamps. :param updated: List of integers representing the updated collection of stamps. :return: A list containing two lists: - The first list contains identifiers added to the collection. - The second list contains identifiers removed from the collection. original_set = set(original) updated_set = set(updated) added = list(updated_set - original_set) removed = list(original_set - updated_set) return [added, removed]"},{"question":"from typing import List def four_sum(nums: List[int], target: int) -> List[List[int]]: Determines the number of unique quadruplets (a, b, c, d) in the list such that they add up to the given target. Example 1: >>> four_sum([1, 0, -1, 0, -2, 2], 0) [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]] Example 2: >>> four_sum([2, 2, 2, 2, 2], 8) [[2, 2, 2, 2]] Note: - The solution set must not contain duplicate quadruplets. - You may return the answer in any order. Constraints: - 1 <= nums.length <= 200 - -10**9 <= nums[i] <= 10**9 - -10**9 <= target <= 10**9 pass","solution":"def four_sum(nums, target): Returns unique quadruplets in the list such that they add up to the given target. nums.sort() quadruplets = [] n = len(nums) for a in range(n - 3): if a > 0 and nums[a] == nums[a - 1]: continue for b in range(a + 1, n - 2): if b > a + 1 and nums[b] == nums[b - 1]: continue left, right = b + 1, n - 1 while left < right: total = nums[a] + nums[b] + nums[left] + nums[right] if total == target: quadruplets.append([nums[a], nums[b], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif total < target: left += 1 else: right -= 1 return quadruplets"},{"question":"def text_editor(commands: List[str]) -> str: Returns the final state of the text editor's content after all commands have been processed. >>> text_editor([ ... \\"APPEND Hello\\", ... \\"APPEND World\\", ... \\"DELETE 5\\", ... \\"UNDO\\", ... \\"APPEND !\\", ... \\"UNDO\\", ... \\"UNDO\\", ... \\"REDO\\", ... \\"REDO\\", ... \\"REDO\\" ... ]) == \\"Hello!\\" >>> text_editor([ ... \\"APPEND abc\\", ... \\"DELETE 1\\", ... \\"DELETE 1\\", ... \\"DELETE 1\\", ... \\"UNDO\\", ... \\"UNDO\\", ... \\"UNDO\\" ... ]) == \\"abc\\"","solution":"def text_editor(commands): Returns the final state of the text editor's content after all commands have been processed. content = \\"\\" history = [] # to hold the history of states for UNDO operations redo_stack = [] # to hold the redo history for command in commands: if command.startswith(\\"APPEND\\"): text_to_append = command.split(\\" \\", 1)[1] history.append(content) content += text_to_append redo_stack.clear() # clear redo stack on new action elif command.startswith(\\"DELETE\\"): n = int(command.split(\\" \\", 1)[1]) history.append(content) content = content[:-n] if n <= len(content) else \\"\\" redo_stack.clear() # clear redo stack on new action elif command == \\"UNDO\\": if history: redo_stack.append(content) content = history.pop() elif command == \\"REDO\\": if redo_stack: history.append(content) content = redo_stack.pop() return content"},{"question":"def longest_increasing_subsequence(nums): Given a list of integers, returns the length of the longest increasing subsequence in the list. An increasing subsequence is a subsequence that has all elements sorted in ascending order. >>> longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) == 4 >>> longest_increasing_subsequence([0, 1, 0, 3, 2, 3]) == 4 >>> longest_increasing_subsequence([7, 7, 7, 7, 7, 7, 7]) == 1 >>> longest_increasing_subsequence([]) == 0 >>> longest_increasing_subsequence([5]) == 1 >>> longest_increasing_subsequence([1, 2, 3, 4, 5]) == 5 >>> longest_increasing_subsequence([5, 4, 3, 2, 1]) == 1 >>> longest_increasing_subsequence([3, 4, -1, 0, 6, 2, 3]) == 4","solution":"def longest_increasing_subsequence(nums): Returns the length of the longest increasing subsequence in the list of integers nums. if not nums: return 0 # Initialize the dp array where dp[i] will be the length of the longest increasing # subsequence ending at index i of nums dp = [1] * len(nums) # Build the dp array by comparing each pair of elements in the list for i in range(1, len(nums)): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) # The longest increasing subsequence is the maximum value in the dp array return max(dp)"},{"question":"def calculate_area(length, width): Calculate the area of a rectangle. Args: length (float): The length of the rectangle. width (float): The width of the rectangle. Returns: float: The area of the rectangle. # Implement function here # Example usage: # calculate_area(5, 3) # should return 15 # Unit Tests: def test_calculate_area_positive_numbers(): assert calculate_area(5, 3) == 15 def test_calculate_area_with_zero(): assert calculate_area(0, 5) == 0 assert calculate_area(5, 0) == 0 def test_calculate_area_negative_numbers(): assert calculate_area(-1, 3) == -3 assert calculate_area(3, -1) == -3 assert calculate_area(-4, -5) == 20 def test_calculate_area_positive_floats(): assert calculate_area(2.5, 4.0) == 10.0 def test_calculate_area_large_numbers(): assert calculate_area(1e6, 2e6) == 2e12","solution":"def calculate_area(length, width): Calculate the area of a rectangle. Args: length (float): The length of the rectangle. width (float): The width of the rectangle. Returns: float: The area of the rectangle. return length * width # Example usage: # calculate_area(5, 3) # should return 15"},{"question":"def fibonacci(n: int) -> int: Returns the nth value in the Fibonacci sequence. Args: n (int): Position in the Fibonacci sequence (1 <= n <= 20). Returns: int: The nth Fibonacci number. >>> fibonacci(1) 0 >>> fibonacci(2) 1 >>> fibonacci(3) 1 >>> fibonacci(10) 34 >>> fibonacci(20) 4181 >>> fibonacci(5) 3","solution":"def fibonacci(n): Returns the nth value in the Fibonacci sequence. Args: n (int): Position in the Fibonacci sequence (1 <= n <= 20). Returns: int: The nth Fibonacci number. if n == 1: return 0 elif n == 2: return 1 a, b = 0, 1 for _ in range(2, n): a, b = b, a + b return b"},{"question":"def find_pairs(nums, target): Returns a list of unique pairs of integers from the given list \`nums\` that sum up to \`target\`. The pairs are sorted in ascending order based on their first element, and within each pair, the numbers are in ascending order. Example: -------- >>> find_pairs([1, 3, 2, 2, 4, 3, 5], 5) [[1, 4], [2, 3]] >>> find_pairs([1, 2, 3, 4], 10) [] >>> find_pairs([1, 1, 1, 1, 1], 2) [[1, 1]] >>> find_pairs([2, 2, 2, 2, 3, 3, 4, 4], 6) [[2, 4], [3, 3]] >>> find_pairs([-1, 1, -2, 2, -3, 3], 0) [[-3, 3], [-2, 2], [-1, 1]] >>> find_pairs([1000000, 999999, 1, 0, -1, -999999, -1000000], 0) [[-1000000, 1000000], [-999999, 999999], [-1, 1]] >>> find_pairs([0, 0, 1, 2, -1, 3, -3], 0) [[-3, 3], [-1, 1], [0, 0]]","solution":"def find_pairs(nums, target): Returns a list of unique pairs of integers from the given list \`nums\` that sum up to \`target\`. The pairs are sorted in ascending order based on their first element, and within each pair, the numbers are in ascending order. seen = set() pairs = set() for num in nums: complement = target - num if complement in seen: pair = tuple(sorted((num, complement))) pairs.add(pair) seen.add(num) return sorted([list(pair) for pair in pairs])"},{"question":"def longest_consecutive_sublist(lst: List[int]) -> int: Returns the length of the longest sublist which contains integers in increasing consecutive order. >>> longest_consecutive_sublist([]) == 0 >>> longest_consecutive_sublist([5]) == 1 >>> longest_consecutive_sublist([1, 2]) == 2 >>> longest_consecutive_sublist([1, 3]) == 1 >>> longest_consecutive_sublist([1, 2, 3, 5, 6, 7, 8, 10, 11]) == 4 >>> longest_consecutive_sublist([10, 11, 12, 13, 1, 2, 3, 4, 3, 4, 5, 6]) == 4 >>> longest_consecutive_sublist([1, 2, 3, 4, 5, 1, 2]) == 5 >>> longest_consecutive_sublist([1, 2, 1, 2, 3, 4, 5]) == 5 >>> longest_consecutive_sublist([1, 3, 5, 7, 9]) == 1 pass","solution":"def longest_consecutive_sublist(lst): Returns the length of the longest sublist which contains integers in increasing consecutive order. if not lst: return 0 max_length = 1 current_length = 1 for i in range(1, len(lst)): if lst[i] == lst[i - 1] + 1: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"def min_operations_to_equal_elements(k: int, arr: List[int]) -> int: This function calculates if it is possible to make all elements in the array equal within \`k\` operations, and if possible, returns the number of operations used. Otherwise, it returns -1. >>> min_operations_to_equal_elements(2, [3, 3, 1]) 2 >>> min_operations_to_equal_elements(1, [3, 3, 1]) -1 from typing import List def test_example(): k = 2 arr = [3, 3, 1] assert min_operations_to_equal_elements(k, arr) == 2 def test_exact_match(): k = 3 arr = [3, 3, 1] assert min_operations_to_equal_elements(k, arr) == 2 def test_not_possible(): k = 1 arr = [3, 3, 1] assert min_operations_to_equal_elements(k, arr) == -1 def test_all_elements_equal(): k = 10 arr = [5, 5, 5, 5] assert min_operations_to_equal_elements(k, arr) == 0 def test_large_k_value(): k = 10**9 arr = [1, 2, 3, 4, 5] assert min_operations_to_equal_elements(k, arr) == 10 def test_large_k_value_all_equal(): k = 10**9 arr = [100, 100, 100] assert min_operations_to_equal_elements(k, arr) == 0","solution":"def min_operations_to_equal_elements(k, arr): This function calculates if it is possible to make all elements in the array equal within \`k\` operations, and if possible, returns the number of operations used. Otherwise, it returns -1. # Find the maximum and minimum values in the array max_val = max(arr) min_val = min(arr) # Calculate the total operations needed to make all elements equal to max_val total_operations = sum(max_val - x for x in arr) # If the total operations needed is within k, return the total operations if total_operations <= k: return total_operations else: return -1"},{"question":"def modified_fibonacci(a1, a2, a3, n): Given the first three elements of the modified Fibonacci sequence and the position n, returns the nth element. >>> modified_fibonacci(0, 1, 2, 4) 3 >>> modified_fibonacci(1, 1, 1, 5) 5 >>> modified_fibonacci(2, 3, 5, 6) 33 >>> modified_fibonacci(10, 20, 30, 1) 10 >>> modified_fibonacci(10, 20, 30, 2) 20 >>> modified_fibonacci(10, 20, 30, 3) 30 def process_input(input_data): Processes the input data and produces the results for each test case. >>> input_data = \\"3n0 1 2 4n1 1 1 5n2 3 5 6n\\" >>> process_input(input_data) [3, 5, 33]","solution":"def modified_fibonacci(a1, a2, a3, n): Given the first three elements of the modified Fibonacci sequence and the position n, returns the nth element. if n == 1: return a1 elif n == 2: return a2 elif n == 3: return a3 sequence = [a1, a2, a3] for i in range(3, n): next_element = sequence[-1] + sequence[-2] + sequence[-3] sequence.append(next_element) return sequence[n-1] def process_input(input_data): Processes the input data and produces the results for each test case. results = [] lines = input_data.strip().split(\\"n\\") T = int(lines[0]) for i in range(1, T + 1): a1, a2, a3, n = map(int, lines[i].split()) result = modified_fibonacci(a1, a2, a3, n) results.append(result) return results"},{"question":"def maxConsecutiveOnes(nums): Write a function maxConsecutiveOnes that takes an integer array nums as input and returns an integer representing the length of the longest consecutive sequence of 1s in the array. >>> maxConsecutiveOnes([1, 1, 0, 1, 1, 1]) 3 >>> maxConsecutiveOnes([1, 0, 1, 1, 0, 1]) 2","solution":"def maxConsecutiveOnes(nums): Returns the length of the longest consecutive sequence of 1s in the array. max_count = 0 current_count = 0 for num in nums: if num == 1: current_count += 1 max_count = max(max_count, current_count) else: current_count = 0 return max_count"},{"question":"def longest_nondecreasing_subsequence(arr: List[int]) -> int: Returns the length of the longest non-decreasing subsequence. >>> longest_nondecreasing_subsequence([10, 20, 30, 10, 20, 30, 40]) 5 >>> longest_nondecreasing_subsequence([5, 4, 3, 2, 1]) 1 >>> longest_nondecreasing_subsequence([10, 10, 10, 10, 10]) 5","solution":"def longest_nondecreasing_subsequence(arr): Returns the length of the longest non-decreasing subsequence. if not arr: return 0 n = len(arr) dp = [1] * n # Initialize the dp array with 1's for i in range(1, n): for j in range(i): if arr[i] >= arr[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def min_operations_to_balance_shelf(N: int, compartments: List[int]) -> int: Determine the minimum number of operations required to make all compartments contain an equal number of items, or return -1 if it is not possible. >>> min_operations_to_balance_shelf(5, [3, 5, 3, 5, 3]) -1 >>> min_operations_to_balance_shelf(4, [2, 4, 6, 8]) 4 >>> min_operations_to_balance_shelf(3, [5, 5, 5]) 0 >>> min_operations_to_balance_shelf(4, [0, 0, 0, 0]) 0 >>> min_operations_to_balance_shelf(4, [1, 2, 3, 5]) -1 >>> min_operations_to_balance_shelf(3, [1000000, 1000000, 1000000]) 0 >>> min_operations_to_balance_shelf(2, [1000000, 1000002]) 1 >>> min_operations_to_balance_shelf(1, [999999]) 0 >>> min_operations_to_balance_shelf(3, [3, 3, 3]) 0","solution":"def min_operations_to_balance_shelf(N, compartments): total_items = sum(compartments) # Check if it's possible to balance the compartments if total_items % N != 0: return -1 target_items = total_items // N operations = 0 for compartment in compartments: if compartment > target_items: operations += compartment - target_items return operations"},{"question":"from typing import List, Dict def heaviest_marbles(test_cases: List[Dict]) -> List[int]: Returns a list of the weight of the heaviest marble for each test case. pass def parse_input(input_str: str) -> List[Dict]: Parses the input string and returns the list of test cases. pass def format_output(results: List[int]) -> str: Formats the results for output. pass def main(input_str: str) -> str: Main function to process the input and produce the output. pass # Example usage: # input_str = \\"3n5n1 2 3 4 5n4n10 20 30 40n3n100 200 300\\" # print(main(input_str))","solution":"def heaviest_marbles(test_cases): Returns a list of the weight of the heaviest marble for each test case. result = [] for case in test_cases: max_weight = max(case['marbles']) result.append(max_weight) return result def parse_input(input_str): Parses the input string and returns the list of test cases. input_lines = input_str.strip().split(\\"n\\") T = int(input_lines[0]) test_cases = [] index = 1 for _ in range(T): N = int(input_lines[index]) marbles = list(map(int, input_lines[index + 1].split())) test_cases.append({\\"N\\": N, \\"marbles\\": marbles}) index += 2 return test_cases def format_output(results): Formats the results for output. return \\"n\\".join(map(str, results)) def main(input_str): Main function to process the input and produce the output. test_cases = parse_input(input_str) results = heaviest_marbles(test_cases) return format_output(results)"},{"question":"def occupy_slot(ss: str) -> str: This function takes the current configuration \`ss\` of the parking lot as input. It returns a new configuration where the first available empty slot 'E' is turned into an occupied slot 'X'. If all slots are occupied, the configuration remains unchanged. Args: ss (str): A string representing the initial configuration of the parking lot. Returns: str: A string representing the new configuration of the parking lot. Examples: >>> occupy_slot(\\"EEXXE\\") 'XEXXE' >>> occupy_slot(\\"XXXXX\\") 'XXXXX' pass # Your code here def free_slot(ss: str, idx: int) -> str: This function takes the current configuration \`ss\` of the parking lot and an integer \`idx\` representing a slot index. It returns a new configuration where the slot at the index \`idx\` is emptied (i.e., the slot is marked as 'E'). If the slot at \`idx\` is already empty, the configuration remains unchanged. Args: ss (str): A string representing the initial configuration of the parking lot. idx (int): An integer representing the slot index to be freed. Returns: str: A string representing the new configuration of the parking lot. Examples: >>> free_slot(\\"XEXXE\\", 2) 'XEEXE' >>> free_slot(\\"EEXXE\\", 0) 'EEXXE' pass # Your code here","solution":"def occupy_slot(ss: str) -> str: This function takes the current configuration \`ss\` of the parking lot as input. It returns a new configuration where the first available empty slot 'E' is turned into an occupied slot 'X'. If all slots are occupied, the configuration remains unchanged. slots = list(ss) for i in range(len(slots)): if slots[i] == 'E': slots[i] = 'X' break return ''.join(slots) def free_slot(ss: str, idx: int) -> str: This function takes the current configuration \`ss\` of the parking lot and an integer \`idx\` representing a slot index. It returns a new configuration where the slot at the index \`idx\` is emptied (i.e., the slot is marked as 'E'). If the slot at \`idx\` is already empty, the configuration remains unchanged. slots = list(ss) if slots[idx] == 'X': slots[idx] = 'E' return ''.join(slots)"},{"question":"def cycle_detection(test_cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[bool]: Given an undirected graph with \`n\` vertices and \`m\` edges, check if there is a cycle in the graph. If a cycle exists, return \`True\`. Otherwise, return \`False\`. Parameters: test_cases (List[Tuple[int, int, List[Tuple[int, int]]]]): List containing multiple test cases. Each test case is a tuple (n, m, edges) where n is the number of vertices, m is the number of edges, and edges is a list of tuples representing edges. Returns: List[bool]: List of boolean values indicating whether each graph contains a cycle. Example: >>> cycle_detection([(3, 3, [(1, 2), (2, 3), (3, 1)]), (4, 3, [(1, 2), (2, 3), (3, 4)]), (5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)])]) [True, False, False]","solution":"def is_cyclic_dfs(graph, vertex, visited, parent): visited[vertex] = True for neighbor in graph[vertex]: if not visited[neighbor]: if is_cyclic_dfs(graph, neighbor, visited, vertex): return True elif neighbor != parent: return True return False def has_cycle(n, edges): graph = [[] for _ in range(n)] for u, v in edges: graph[u - 1].append(v - 1) graph[v - 1].append(u - 1) visited = [False] * n for v in range(n): if not visited[v]: if is_cyclic_dfs(graph, v, visited, -1): return True return False def cycle_detection(test_cases): results = [] for n, m, edges in test_cases: results.append(has_cycle(n, edges)) return results"},{"question":"def is_arithmetic_progression(s: str) -> str: Determine if the string of integers represents an arithmetic progression. Parameters: s (str): A string containing integers separated by spaces. Returns: str: The common difference as a string if it is an arithmetic progression, otherwise 'Not an arithmetic progression'. Examples: >>> is_arithmetic_progression(\\"3 5 7 9 11\\") '2' >>> is_arithmetic_progression(\\"1 2 4 8 16\\") 'Not an arithmetic progression'","solution":"def is_arithmetic_progression(s): Evaluates if a string of integers represents an arithmetic progression. Parameters: s (str): a string containing integers separated by spaces Returns: str: the common difference if it is an arithmetic progression, otherwise 'Not an arithmetic progression'. numbers = list(map(int, s.split())) if len(numbers) < 3: return \\"Not an arithmetic progression\\" difference = numbers[1] - numbers[0] for i in range(2, len(numbers)): if numbers[i] - numbers[i-1] != difference: return \\"Not an arithmetic progression\\" return str(difference)"},{"question":"def count_common_volunteers(n, reforestation_volunteers, b, water_cleaning_volunteers): Returns the count of volunteers who are involved in both the reforestation and water cleaning projects. >>> count_common_volunteers(3, [1, 2, 3], 3, [4, 5, 6]) 0 >>> count_common_volunteers(4, [1, 2, 3, 4], 4, [3, 4, 5, 6]) 2 >>> count_common_volunteers(3, [1, 2, 3], 3, [1, 2, 3]) 3 >>> count_common_volunteers(0, [], 3, [1, 2, 3]) 0 >>> count_common_volunteers(3, [1, 2, 3], 0, []) 0 >>> count_common_volunteers(0, [], 0, []) 0 >>> count_common_volunteers(5, [1, 2, 2, 3, 4], 5, [4, 4, 5, 6, 1]) 2 # Your code here","solution":"def count_common_volunteers(n, reforestation_volunteers, b, water_cleaning_volunteers): Returns the count of volunteers who are involved in both the reforestation and water cleaning projects. reforestation_set = set(reforestation_volunteers) water_cleaning_set = set(water_cleaning_volunteers) common_volunteers = reforestation_set.intersection(water_cleaning_set) return len(common_volunteers)"},{"question":"def find_influencer(N: int, F: int, followers: List[Tuple[int, int]]) -> int: Identify the influencer user based on followers information. A user is an influencer if they are followed by all other users and they follow no one. Parameters: N (int): Number of users F (int): Number of follower pairs followers (List[Tuple[int, int]]): List of follower pairs where each pair (a, b) means user a follows user b Returns: int: The influencer user or -1 if there is no influencer. >>> find_influencer(4, 3, [(0, 1), (1, 2), (3, 2)]) 2 >>> find_influencer(4, 3, [(0, 1), (1, 2), (2, 3)]) -1","solution":"def find_influencer(N, F, followers): in_degrees = [0] * N out_degrees = [0] * N for a, b in followers: out_degrees[a] += 1 in_degrees[b] += 1 for i in range(N): if in_degrees[i] == N - 1 and out_degrees[i] == 0: return i return -1"},{"question":"from typing import List def alternate_capitalization(title: str) -> str: Capitalizes alternate words in a given title, starting with the first word. Args: title (str): The book title as a string of words separated by spaces. Returns: str: The title with alternate words capitalized. >>> alternate_capitalization(\\"the great gatsby\\") \\"The great Gatsby\\" >>> alternate_capitalization(\\"to kill a mockingbird\\") \\"To kill A mockingbird\\" pass def format_books(titles: List[str]) -> List[str]: Sorts a list of book titles alphabetically and formats each title with alternate words capitalized. Args: titles (List[str]): List of book titles. Returns: List[str]: New list of sorted and formatted book titles. >>> format_books([\\"the great gatsby\\", \\"to kill a mockingbird\\", \\"pride and prejudice\\"]) [\\"Pride and Prejudice\\", \\"The Great Gatsby\\", \\"To Kill A Mockingbird\\"] >>> format_books([\\"a tale of two cities\\", \\"war and peace\\", \\"the catcher in the rye\\"]) [\\"A Tale Of Two Cities\\", \\"The Catcher In The Rye\\", \\"War And Peace\\"] pass # Unit tests def test_alternate_capitalization(): assert alternate_capitalization(\\"the great gatsby\\") == \\"The great Gatsby\\" assert alternate_capitalization(\\"to kill a mockingbird\\") == \\"To kill A mockingbird\\" assert alternate_capitalization(\\"pride and prejudice\\") == \\"Pride and Prejudice\\" assert alternate_capitalization(\\"B\\") == \\"B\\" assert alternate_capitalization(\\"a tale of two cities\\") == \\"A tale Of two Cities\\" assert alternate_capitalization(\\"war and peace\\") == \\"War and Peace\\" assert alternate_capitalization(\\"the catcher in the rye\\") == \\"The catcher In the Rye\\" def test_format_books(): assert format_books([\\"the great gatsby\\", \\"to kill a mockingbird\\", \\"pride and prejudice\\"]) == [\\"Pride and Prejudice\\", \\"The great Gatsby\\", \\"To kill A mockingbird\\"] assert format_books([\\"a tale of two cities\\", \\"war and peace\\", \\"the catcher in the rye\\"]) == [\\"A tale Of two Cities\\", \\"The catcher In the Rye\\", \\"War and Peace\\"] assert format_books([\\"a\\", \\"b\\"]) == [\\"A\\", \\"B\\"] assert format_books([\\"b\\", \\"a\\"]) == [\\"A\\", \\"B\\"] assert format_books([\\"a quick brown fox\\", \\"jumps over the lazy dog\\"]) == [\\"A quick Brown fox\\", \\"Jumps over The lazy Dog\\"] def test_format_books_single_title(): assert format_books([\\"hello world\\"]) == [\\"Hello world\\"] assert format_books([\\"A\\"]) == [\\"A\\"] def test_format_books_mixed_case(): assert format_books([\\"ThE gReateSt ShOw\\"]) == [\\"The greatest Show\\"] assert format_books([\\"aLiEn InVaSiOn\\"]) == [\\"Alien invasion\\"]","solution":"def alternate_capitalization(title): words = title.split() formatted_words = [word.capitalize() if i % 2 == 0 else word.lower() for i, word in enumerate(words)] return ' '.join(formatted_words) def format_books(titles): sorted_titles = sorted(titles) formatted_titles = [alternate_capitalization(title) for title in sorted_titles] return formatted_titles"},{"question":"def count_words(s: str) -> dict: Counts the frequency of each word in a given string, ignoring case. Args: s: str - The input string. Returns: dict - A dictionary where the keys are words and the values are their counts. Examples: >>> count_words(\\"\\") {} >>> count_words(\\"hello\\") {\\"hello\\": 1} >>> count_words(\\"hello world hello\\") {\\"hello\\": 2, \\"world\\": 1} >>> count_words(\\"Hello hello\\") {\\"hello\\": 2} def most_common_word(s: str) -> str: Finds the most common word in a given string. Args: s: str - The input string. Returns: str - The most common word. Examples: >>> most_common_word(\\"\\") None >>> most_common_word(\\"hello\\") \\"hello\\" >>> most_common_word(\\"hello world hello\\") \\"hello\\" >>> most_common_word(\\"Hello hello world\\") \\"hello\\" >>> most_common_word(\\"hello world\\") \\"hello\\" or \\"world\\" import pytest from solution import count_words, most_common_word def test_count_words_empty_string(): assert count_words(\\"\\") == {} def test_count_words_single_word(): assert count_words(\\"hello\\") == {\\"hello\\": 1} def test_count_words_multiple_words(): assert count_words(\\"hello world hello\\") == {\\"hello\\": 2, \\"world\\": 1} def test_count_words_case_insensitivity(): assert count_words(\\"Hello hello\\") == {\\"hello\\": 2} def test_most_common_word_empty_string(): assert most_common_word(\\"\\") == None def test_most_common_word_single_word(): assert most_common_word(\\"hello\\") == \\"hello\\" def test_most_common_word_multiple_words(): assert most_common_word(\\"hello world hello\\") == \\"hello\\" def test_most_common_word_case_insensitivity(): assert most_common_word(\\"Hello hello world\\") == \\"hello\\" def test_most_common_word_tie(): assert most_common_word(\\"hello world\\") in [\\"hello\\", \\"world\\"]","solution":"def count_words(s): Counts the frequency of each word in a given string, ignoring case. Args: s: str - The input string. Returns: dict - A dictionary where the keys are words and the values are their counts. words = s.lower().split() word_count = {} for word in words: if word in word_count: word_count[word] += 1 else: word_count[word] = 1 return word_count def most_common_word(s): Finds the most common word in a given string. Args: s: str - The input string. Returns: str - The most common word. word_count = count_words(s) max_count = 0 most_common = None for word in s.lower().split(): if word_count[word] > max_count: max_count = word_count[word] most_common = word return most_common"},{"question":"def remove_duplicates(lst: List[int]) -> List[int]: Returns a list with duplicates removed, preserving the order of first occurrences. Parameters: lst (list): A list of integers. Returns: list: A list without duplicates. >>> remove_duplicates([]) == [] >>> remove_duplicates([1, 2, 3]) == [1, 2, 3] >>> remove_duplicates([1, 2, 2, 3, 4, 4, 5, 1]) == [1, 2, 3, 4, 5] >>> remove_duplicates([1, 1, 1, 1]) == [1] >>> remove_duplicates([1, 2, 1, 3, 2, 4, 3]) == [1, 2, 3, 4] >>> remove_duplicates([1, -1, 2, -1, 3, 2, 4, -1]) == [1, -1, 2, 3, 4]","solution":"def remove_duplicates(lst): Returns a list with duplicates removed, preserving the order of first occurrences. Parameters: lst (list): A list of integers. Returns: list: A list without duplicates. seen = set() result = [] for item in lst: if item not in seen: seen.add(item) result.append(item) return result"},{"question":"def min_elevator_trips(n: int, w: int, weights: List[int]) -> int: Returns the minimum number of elevator trips required to transport all the boxes. >>> min_elevator_trips(5, 10, [2, 3, 4, 5, 7]) == 3 >>> min_elevator_trips(1, 10, [7]) == 1 >>> min_elevator_trips(3, 5, [6, 6, 6]) == 3 >>> min_elevator_trips(4, 20, [3, 5, 7, 5]) == 1 >>> min_elevator_trips(6, 10, [8, 1, 7, 3, 4, 2]) == 3","solution":"def min_elevator_trips(n, w, weights): Returns the minimum number of elevator trips required to transport all the boxes. weights.sort(reverse=True) trips = 0 used = [False] * n for i in range(n): if not used[i]: current_weight = weights[i] used[i] = True for j in range(i + 1, n): if not used[j] and current_weight + weights[j] <= w: current_weight += weights[j] used[j] = True trips += 1 return trips"},{"question":"def longest_word_length(s: str) -> int: Returns the length of the longest word in the given string s. >>> longest_word_length(\\"The quick brown fox jumps over the lazy dog\\") == 5 >>> longest_word_length(\\"A journey of a thousand miles begins with a single step\\") == 8 >>> longest_word_length(\\"To be or not to be that is the question\\") == 8 >>> longest_word_length(\\"\\") == 0 >>> longest_word_length(\\"Supercalifragilisticexpialidocious\\") == 34 >>> longest_word_length(\\"pneumonoultramicroscopicsilicovolcanoconiosis\\") == 45 >>> longest_word_length(\\"This is a test\\") == 4 >>> longest_word_length(\\"Word\\") == 4 >>> longest_word_length(\\"This test has multiple spaces\\") == 8 >>> longest_word_length(\\" \\") == 0","solution":"def longest_word_length(s): Returns the length of the longest word in the given string s. :param s: A string representing a phrase :type s: str :return: The length of the longest word in the string :rtype: int words = s.split() if not words: return 0 return max(len(word) for word in words)"},{"question":"from typing import List def can_form_palindrome(s: str) -> bool: Determines if the characters in the string s can be rearranged to form a palindrome. :param s: A string :return: True if the string can be rearranged to form a palindrome, otherwise False >>> can_form_palindrome(\\"civic\\") True >>> can_form_palindrome(\\"ivicc\\") True >>> can_form_palindrome(\\"hello\\") False # Your implementation here # Unit tests def test_can_form_palindrome_civic(): assert can_form_palindrome(\\"civic\\") == True def test_can_form_palindrome_ivicc(): assert can_form_palindrome(\\"ivicc\\") == True def test_can_form_palindrome_hello(): assert can_form_palindrome(\\"hello\\") == False def test_can_form_palindrome_aabb(): assert can_form_palindrome(\\"aabb\\") == True def test_can_form_palindrome_aabbcc(): assert can_form_palindrome(\\"aabbcc\\") == True def test_can_form_palindrome_aabbc(): assert can_form_palindrome(\\"aabbc\\") == True def test_can_form_palindrome_a(): assert can_form_palindrome(\\"a\\") == True def test_can_form_palindrome_empty_string(): assert can_form_palindrome(\\"\\") == True def test_can_form_palindrome_repeated_chars_odd(): assert can_form_palindrome(\\"a\\" * 99999) == True def test_can_form_palindrome_repeated_chars_mixed(): assert can_form_palindrome(\\"a\\" * 50000 + \\"b\\" * 50000 + \\"c\\") == True","solution":"from collections import Counter def can_form_palindrome(s): Determines if the characters in the string s can be rearranged to form a palindrome. :param s: A string :return: True if the string can be rearranged to form a palindrome, otherwise False # Count the frequency of each character in the string char_count = Counter(s) # Count how many characters have an odd frequency odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can form a palindrome if at most one character has an odd frequency return odd_count <= 1"},{"question":"def is_prime(n: int) -> bool: Returns True if n is a prime number, otherwise False. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(5) True def sum_of_primes(numbers: List[int]) -> int: Returns the sum of all prime numbers in the input list \`numbers\`. >>> sum_of_primes([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 17 >>> sum_of_primes([11, 13, 17, 19, 23]) 83 >>> sum_of_primes([4, 6, 8, 10, 12]) 0","solution":"def is_prime(n): Returns True if n is a prime number, otherwise False. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def sum_of_primes(numbers): Returns the sum of all prime numbers in the input list \`numbers\`. return sum(n for n in numbers if is_prime(n))"},{"question":"from typing import List, Tuple def find_pairs(arr: List[int], k: int) -> List[Tuple[int, int]]: Given a unique set of numbers, find pairs of elements that sum to a target value k. Return the pairs as a list of tuples, sorted in increasing order of the first element, and if elements of any tuple match, sort by the second element as well. >>> find_pairs([1, 5, 3, 7, 9, 2], 10) [(1, 9), (3, 7)] >>> find_pairs([11, 2, 8, 4, 5], 9) [(4, 5)]","solution":"def find_pairs(arr, k): Find all unique pairs in the list that sum to k. Parameters: arr (list of int): A list of unique integers. k (int): An integer representing the target sum. Returns: list of tuples: A sorted list of tuples with pairs of elements that sum to k. # Dictionary to keep track of numbers we've seen and their indices seen = {} pairs = [] # Traverse through each number in the list for number in arr: # Calculate the complement that would sum to k complement = k - number # Check if complement exists in the seen dictionary if complement in seen: # If it exists, add the pair sorted in ascending order pairs.append(tuple(sorted((number, complement)))) # Add the number to the dictionary (whether it was part of a pair or not) seen[number] = True # Sort the pairs list by the first element, and then by the second element return sorted(pairs)"},{"question":"def longest_mountain(arr: List[int]) -> int: Returns the length of the longest mountain in the array. A \\"mountain\\" is defined as a subarray that: - Has a length of at least 3. - There exists some index i (0 < i < subarray.length - 1) such that: - arr[0] < arr[1] < ... < arr[i] - arr[i] > arr[i + 1] > ... > arr[subarray.length - 1] Parameters: arr (List[int]): A list of distinct integers. Returns: int: The length of the longest mountain in the array. If there is no mountain, return 0. Examples: >>> longest_mountain([2, 1, 4, 7, 3, 2, 5]) 5 >>> longest_mountain([2, 2, 2]) 0","solution":"def longest_mountain(arr): Returns the length of the longest mountain in the array. n = len(arr) if n < 3: return 0 longest = 0 for i in range(1, n - 1): if arr[i - 1] < arr[i] > arr[i + 1]: left = i - 1 while left > 0 and arr[left - 1] < arr[left]: left -= 1 right = i + 1 while right < n - 1 and arr[right] > arr[right + 1]: right += 1 longest = max(longest, right - left + 1) return longest"},{"question":"def next_greater_number(num_str: str) -> str: Given a string of digits, rearrange the digits to create the smallest possible number that is greater than the original number. If no such number exists (i.e., the digits are in descending order), return the original number. >>> next_greater_number(\\"218765\\") \\"251678\\" >>> next_greater_number(\\"1234\\") \\"1243\\" >>> next_greater_number(\\"4321\\") \\"4321\\" >>> next_greater_number(\\"534976\\") \\"536479\\"","solution":"def next_greater_number(num_str): Returns the smallest possible number that is greater than the original number. If no such number exists, returns the original number. num_list = list(num_str) length = len(num_list) # Step back through the number to find the first digit that can be increased for i in range(length - 2, -1, -1): if num_list[i] < num_list[i + 1]: break else: # If no such digit is found, return the original number return num_str # Find the smallest digit on the right side of the found digit that is larger than it for j in range(length - 1, i, -1): if num_list[j] > num_list[i]: break # Swap the found digits num_list[i], num_list[j] = num_list[j], num_list[i] # Sort the digits to the right of the initial digit in ascending order num_list = num_list[:i + 1] + sorted(num_list[i + 1:]) return ''.join(num_list)"},{"question":"def smallest_odd_subgrid_sum(N: int, M: int, grid: List[List[int]]) -> int: Returns the sum of the integers in the smallest rectangular sub-grid that contains at least one odd number. If there are no odd numbers in the grid, returns -1. >>> smallest_odd_subgrid_sum(3, 4, [[2, 4, 6, 8], [1, 10, 12, 14], [2, 16, 18, 20]]) == 1 >>> smallest_odd_subgrid_sum(4, 4, [[0, 2, 4, 6], [8, 6, 4, 2], [16, 14, 12, 10], [20, 18, 16, 14]]) == -1","solution":"def smallest_odd_subgrid_sum(N, M, grid): Returns the sum of the integers in the smallest rectangular sub-grid that contains at least one odd number. If there are no odd numbers in the grid, returns -1. min_sum = float('inf') has_odd = False for i in range(N): for j in range(M): if grid[i][j] % 2 != 0: has_odd = True min_sum = min(min_sum, grid[i][j]) return min_sum if has_odd else -1"},{"question":"def max_sum_subarray(arr: List[int], k: int) -> int: Calculate the maximum sum of any continuous subarray of size k. >>> max_sum_subarray([1, 4, 2, 10, 23, 3, 1, 0, 20], 4) 39 >>> max_sum_subarray([2, 1, 5, 1, 3, 2], 3) 9 pass def test_max_sum_subarray_example1(): arr = [1, 4, 2, 10, 23, 3, 1, 0, 20] k = 4 assert max_sum_subarray(arr, k) == 39 def test_max_sum_subarray_example2(): arr = [2, 1, 5, 1, 3, 2] k = 3 assert max_sum_subarray(arr, k) == 9 def test_max_sum_subarray_single_element(): arr = [5] k = 1 assert max_sum_subarray(arr, k) == 5 def test_max_sum_subarray_all_equal(): arr = [5, 5, 5, 5, 5] k = 3 assert max_sum_subarray(arr, k) == 15 def test_max_sum_subarray_large_k(): arr = [1, 2, 3, 4, 5] k = 5 assert max_sum_subarray(arr, k) == 15 def test_max_sum_subarray_varied_elements(): arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] k = 4 assert max_sum_subarray(arr, k) == 34 def test_max_sum_subarray_k_greater_than_length(): arr = [1, 2, 3] k = 4 assert max_sum_subarray(arr, k) is None def test_max_sum_subarray_empty(): arr = [] k = 1 assert max_sum_subarray(arr, k) is None","solution":"def max_sum_subarray(arr, k): Returns the maximum sum of any continuous subarray of size k. n = len(arr) if k > n: return None # Calculate the sum of the first subarray of size k max_sum = current_sum = sum(arr[:k]) # Sliding window to find maximum sum subarray of size k for i in range(k, n): current_sum = current_sum - arr[i - k] + arr[i] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"from typing import List, Tuple def separate_even_odd(nums: List[int]) -> Tuple[List[int], List[int]]: Separates the integers in the input list into two lists: one containing even integers and the other containing odd integers. The integers in the resultant lists appear in the same order as they do in the original list. :param nums: List[int] - List of integers :return: Tuple[List[int], List[int]] - A tuple containing two lists: (even integers, odd integers) >>> separate_even_odd([1, 2, 3, 4, 5, 6]) ([2, 4, 6], [1, 3, 5]) >>> separate_even_odd([7, 10, 13, 16, 19, 22]) ([10, 16, 22], [7, 13, 19])","solution":"def separate_even_odd(nums): Separates the integers in the input list into two lists: one containing even integers and the other containing odd integers. The integers in the resultant lists appear in the same order as they do in the original list. :param nums: List[int] - List of integers :return: Tuple[List[int], List[int]] - A tuple containing two lists: (even integers, odd integers) even = [] odd = [] for num in nums: if num % 2 == 0: even.append(num) else: odd.append(num) return (even, odd)"},{"question":"def member_with_max_books(members: List[int], books: List[int]) -> int: Finds the member with the maximum number of distinct books borrowed. Args: members: list of integers representing member IDs. books: list of integers representing book IDs. Returns: int: The member ID that borrowed the maximum number of distinct books. >>> member_with_max_books([1], [1]) 1 >>> member_with_max_books([1, 1, 1], [1, 2, 3]) 1 >>> member_with_max_books([1, 2, 1, 2], [1, 1, 2, 2]) 1 >>> member_with_max_books([1, 2, 3], [1, 2, 3]) 1 >>> member_with_max_books([1, 2], [1, 2]) 1 >>> member_with_max_books([2, 1], [2, 1]) 1 >>> member_with_max_books([member for _ in range(2) for member in range(1, 501)], [book for book in range(1, 501)] + [book for book in range(500, 0, -1)]) 1","solution":"from collections import defaultdict def member_with_max_books(members, books): Finds the member with the maximum number of distinct books borrowed. Args: members: list of integers representing member IDs. books: list of integers representing book IDs. Returns: int: The member ID that borrowed the maximum number of distinct books. borrow_records = defaultdict(set) for member, book in zip(members, books): borrow_records[member].add(book) max_books = 0 max_member = None for member, book_set in borrow_records.items(): if len(book_set) > max_books or (len(book_set) == max_books and member < max_member): max_books = len(book_set) max_member = member return max_member"},{"question":"def update_array(n, arr, q, updates): This function takes in a length of the array, the initial array itself, the number of updates, and a list of updates, then returns the modified array. Parameters: n (int): Length of the array arr (list): Initial state of the array q (int): Number of updates to perform updates (list of tuples): A list containing tuples with three elements (L, R, X) Returns: list: The final state of the array after all updates # Unit Tests from solution import update_array def test_example_case(): assert update_array( 5, [1, 2, 3, 4, 5], 3, [(1, 3, 2), (2, 4, 1), (3, 5, -1)] ) == [3, 5, 5, 4, 4] def test_no_updates(): # If there are no updates, the array should remain unchanged assert update_array(5, [1, 2, 3, 4, 5], 0, []) == [1, 2, 3, 4, 5] def test_single_update(): # Single update to add 10 to all elements assert update_array(3, [1, 2, 3], 1, [(1, 3, 10)]) == [11, 12, 13] def test_updates_with_full_overlap(): # All updates overlapping fully the array assert update_array( 4, [1, 2, 3, 4], 2, [(1, 4, 5), (1, 4, -2)] ) == [4, 5, 6, 7] def test_partial_updates(): # Partial updates affecting different parts of the array assert update_array( 6, [10, 20, 30, 40, 50, 60], 3, [(1, 2, 5), (4, 5, -10), (2, 4, 10)] ) == [15, 35, 40, 40, 40, 60]","solution":"def update_array(n, arr, q, updates): This function takes in a length of the array, the initial array itself, the number of updates, and a list of updates, then returns the modified array. Parameters: n (int): Length of the array arr (list): Initial state of the array q (int): Number of updates to perform updates (list of tuples): A list containing tuples with three elements (L, R, X) Returns: list: The final state of the array after all updates for update in updates: L, R, X = update for i in range(L-1, R): arr[i] += X return arr"},{"question":"def has_cycle(n: int, m: int, edges: List[Tuple[int, int]]) -> str: Determines if the given undirected graph has a cycle. Args: n (int): Number of nodes in the graph m (int): Number of edges in the graph edges (List[Tuple[int, int]]): List of tuples representing the edges (u, v) Returns: str: \\"Yes\\" if the graph contains at least one cycle, otherwise \\"No\\" Test Cases: >>> has_cycle(5, 5, [(1, 2), (1, 3), (2, 3), (3, 4), (4, 5)]) \\"Yes\\" >>> has_cycle(5, 4, [(1, 2), (1, 3), (3, 4), (4, 5)]) \\"No\\" >>> has_cycle(1, 0, []) \\"No\\" >>> has_cycle(2, 1, [(1, 2)]) \\"No\\" >>> has_cycle(6, 5, [(1, 2), (2, 3), (3, 1), (4, 5), (5, 6)]) \\"Yes\\" >>> has_cycle(6, 4, [(1, 2), (3, 4), (4, 5), (5, 6)]) \\"No\\"","solution":"def has_cycle(n, m, edges): Determines if the given undirected graph has a cycle. :param n: Number of nodes in the graph :param m: Number of edges in the graph :param edges: List of tuples representing the edges (u, v) :return: \\"Yes\\" if the graph contains at least one cycle, otherwise \\"No\\" from collections import defaultdict, deque def bfs(start_node): queue = deque([(start_node, -1)]) # Node and its parent visited[start_node] = True while queue: node, parent = queue.popleft() for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append((neighbor, node)) elif parent != neighbor: return True return False graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = [False] * (n + 1) for node in range(1, n + 1): if not visited[node]: if bfs(node): return \\"Yes\\" return \\"No\\""},{"question":"from typing import List, Tuple class SegmentTree: def __init__(self, data: List[int]): self.n = len(data) self.tree = [0] * (2 * self.n) self.build(data) def build(self, data: List[int]): for i in range(self.n): self.tree[self.n + i] = data[i] for i in range(self.n - 1, 0, -1): self.tree[i] = max(self.tree[i * 2], self.tree[i * 2 + 1]) def update(self, index: int, value: int): pos = index + self.n self.tree[pos] = value while pos > 1: pos //= 2 self.tree[pos] = max(self.tree[2 * pos], self.tree[2 * pos + 1]) def range_max(self, left: int, right: int) -> int: res = float('-inf') left += self.n right += self.n + 1 while left < right: if left % 2 == 1: res = max(res, self.tree[left]) left += 1 if right % 2 == 1: right -= 1 res = max(res, self.tree[right]) left //= 2 right //= 2 return res def process_queries(n: int, queries: List[Tuple[int, ...]], data: List[int]) -> List[int]: Process a series of update and range maximum queries on an array. Parameters: n (int): The number of elements in the array. queries (List[Tuple[int, ...]]): A list of queries where each query is a tuple indicating the type of operation and its parameters. data (List[int]): The initial elements of the array. Returns: List[int]: The results of all range maximum queries. >>> process_queries(5, [(2, 1, 3), (1, 2, 6), (2, 1, 3), (1, 4, 0), (2, 0, 4)], [1, 3, 5, 7, 9]) [7, 7, 7] >>> process_queries(6, [(2, 0, 2), (1, 1, 50), (2, 0, 2), (2, 3, 4), (1, 5, 1), (2, 4, 5)], [2, 4, 6, 8, 10, 12]) [6, 50, 10, 10]","solution":"from typing import List, Tuple class SegmentTree: def __init__(self, data: List[int]): self.n = len(data) self.tree = [0] * (2 * self.n) self.build(data) def build(self, data: List[int]): for i in range(self.n): self.tree[self.n + i] = data[i] for i in range(self.n - 1, 0, -1): self.tree[i] = max(self.tree[i * 2], self.tree[i * 2 + 1]) def update(self, index: int, value: int): pos = index + self.n self.tree[pos] = value while pos > 1: pos //= 2 self.tree[pos] = max(self.tree[2 * pos], self.tree[2 * pos + 1]) def range_max(self, left: int, right: int) -> int: res = float('-inf') left += self.n right += self.n + 1 while left < right: if left % 2 == 1: res = max(res, self.tree[left]) left += 1 if right % 2 == 1: right -= 1 res = max(res, self.tree[right]) left //= 2 right //= 2 return res def process_queries(n: int, queries: List[Tuple[int, ...]], data: List[int]) -> List[int]: seg_tree = SegmentTree(data) result = [] for query in queries: if query[0] == 1: _, i, x = query seg_tree.update(i, x) elif query[0] == 2: _, l, r = query result.append(seg_tree.range_max(l, r)) return result"},{"question":"import math def navigate_space(coordinates, target, current_position): Calculates the Euclidean distance from the current position to the target planet. :param coordinates: Dictionary with planet names as keys and (x, y, z) tuples as values. :param target: The name of the target planet. :param current_position: A tuple representing the current (x, y, z) position. :returns: The Euclidean distance to the target planet rounded to two decimal places or 'Planet not found.' pass # Test cases def test_navigate_space_valid_target(): coordinates = { \\"Mars\\": (2, 3, 4), \\"Jupiter\\": (5, 6, 7), \\"Saturn\\": (1, 0, -1) } current_position = (0, 0, 0) assert navigate_space(coordinates, \\"Mars\\", current_position) == 5.39 assert navigate_space(coordinates, \\"Jupiter\\", current_position) == 10.49 assert navigate_space(coordinates, \\"Saturn\\", current_position) == 1.41 def test_navigate_space_invalid_target(): coordinates = { \\"Mars\\": (2, 3, 4), \\"Jupiter\\": (5, 6, 7), \\"Saturn\\": (1, 0, -1) } current_position = (0, 0, 0) assert navigate_space(coordinates, \\"Pluto\\", current_position) == 'Planet not found' def test_navigate_space_edge_cases(): coordinates = { \\"Alpha\\": (0, 0, 0), \\"Beta\\": (1, 1, 1), \\"Gamma\\": (-1, -1, -1) } current_position = (0, 0, 0) assert navigate_space(coordinates, \\"Alpha\\", current_position) == 0.0 assert navigate_space(coordinates, \\"Beta\\", current_position) == 1.73 assert navigate_space(coordinates, \\"Gamma\\", current_position) == 1.73","solution":"import math def navigate_space(coordinates, target, current_position): Calculates the Euclidean distance from the current position to the target planet. :param coordinates: Dictionary with planet names as keys and (x, y, z) tuples as values. :param target: The name of the target planet. :param current_position: A tuple representing the current (x, y, z) position. :returns: The Euclidean distance to the target planet rounded to two decimal places or 'Planet not found.' if target not in coordinates: return 'Planet not found' (x1, y1, z1) = current_position (x2, y2, z2) = coordinates[target] distance = math.sqrt((x2 - x1)**2 + (y2 - y1)**2 + (z2 - z1)**2) return round(distance, 2)"},{"question":"def is_palindrome(n: int) -> bool: Check if a number is a palindrome. >>> is_palindrome(121) True >>> is_palindrome(123) False # your code here def steps_to_palindrome(n: int) -> int: Returns the number of steps required to transform the number into a palindrome, or -1 if it does not become a palindrome within 1000 steps. >>> steps_to_palindrome(87) 4 >>> steps_to_palindrome(56) 1 >>> steps_to_palindrome(123) -1 # your code here def test_palindrome_cases(): assert steps_to_palindrome(87) == 4 assert steps_to_palindrome(56) == 1 assert steps_to_palindrome(11) == 0 def test_no_palindrome_within_1000_steps(): assert steps_to_palindrome(89) == 24 # Known to reach palindrome in 24 steps assert steps_to_palindrome(196) == -1 # Known to not reach palindrome within 1000 steps def test_single_digit_palindrome(): assert steps_to_palindrome(1) == 0 assert steps_to_palindrome(9) == 0 def test_large_number(): assert steps_to_palindrome(12321) == 0 # Already a palindrome assert steps_to_palindrome(12345) == 1 # One step: 12345 + 54321 = 66666 (palindrome)","solution":"def is_palindrome(n): Check if a number is a palindrome. return str(n) == str(n)[::-1] def steps_to_palindrome(n): Returns the number of steps required to transform the number into a palindrome. Returns -1 if it does not become a palindrome within 1000 steps. steps = 0 while steps < 1000: if is_palindrome(n): return steps n = n + int(str(n)[::-1]) steps += 1 return -1"},{"question":"def sortArrayByParity(arr: List[int]) -> List[int]: Sort the array such that all the even numbers appear before the odd numbers, while maintaining the relative order of the even and odd numbers. >>> sortArrayByParity([3, 1, 2, 4]) [2, 4, 3, 1] >>> sortArrayByParity([0, 5, 7, 2, 6]) [0, 2, 6, 5, 7] from solution import sortArrayByParity def test_all_even_numbers(): assert sortArrayByParity([2, 4, 6, 8]) == [2, 4, 6, 8] def test_all_odd_numbers(): assert sortArrayByParity([1, 3, 5, 7]) == [1, 3, 5, 7] def test_mixed_numbers(): assert sortArrayByParity([3, 1, 2, 4]) == [2, 4, 3, 1] assert sortArrayByParity([0, 5, 7, 2, 6]) == [0, 2, 6, 5, 7] def test_single_element(): assert sortArrayByParity([1]) == [1] assert sortArrayByParity([2]) == [2] def test_no_elements(): assert sortArrayByParity([]) == [] def test_mixed_numbers_with_zeros(): assert sortArrayByParity([0, 1, 0, 2, 3]) == [0, 0, 2, 1, 3]","solution":"def sortArrayByParity(arr): Sort the array such that all the even numbers appear before the odd numbers, while maintaining the relative order of the even and odd numbers. even_nums = [num for num in arr if num % 2 == 0] odd_nums = [num for num in arr if num % 2 != 0] return even_nums + odd_nums"},{"question":"from typing import List def is_mountain_array(arr: List[int]) -> bool: Determines if the input list arr is a mountain array. A mountain array has three conditions: 1. The array length must be at least 3. 2. There must be an ascending sequence followed by a peak. 3. After the peak, there must be a strictly descending sequence. :param arr: List[int], the input list of integers. :return: bool, whether the input list is a mountain array or not. >>> is_mountain_array([2, 1]) False >>> is_mountain_array([3, 5, 5]) False >>> is_mountain_array([0, 3, 2, 1]) True >>> is_mountain_array([0, 1, 2, 4, 2, 1]) True","solution":"def is_mountain_array(arr): Determines if the input list arr is a mountain array. A mountain array has three conditions: 1. The array length must be at least 3. 2. There must be an ascending sequence followed by a peak. 3. After the peak, there must be a strictly descending sequence. :param arr: List[int], the input list of integers. :return: bool, whether the input list is a mountain array or not. n = len(arr) # The array must be longer than or equal to 3 elements if n < 3: return False i = 1 # Traverse up the mountain while i < n and arr[i] > arr[i - 1]: i += 1 # Peak can't be the first or the last element if i == 1 or i == n: return False # Traverse down the mountain while i < n and arr[i] < arr[i - 1]: i += 1 # If we reached the end of the array, it is a mountain array return i == n"},{"question":"def reverse_words(s: str) -> str: Return the string with all words reversed individually and the order of words reversed. >>> reverse_words(\\"hello world\\") == \\"dlrow olleh\\" >>> reverse_words(\\"coding is fun\\") == \\"nuf si gnidoc\\" >>> reverse_words(\\"practice makes perfect\\") == \\"tcefrep sekam ecitcarp\\" >>> reverse_words(\\"a b c d\\") == \\"d c b a\\" >>> reverse_words(\\"algorithm\\") == \\"mhtirogla\\" >>> reverse_words(\\"hello, world!\\") == \\"!dlrow ,olleh\\" >>> reverse_words(\\"Hello World\\") == \\"dlroW olleH\\" >>> reverse_words(\\"123 456 789\\") == \\"987 654 321\\"","solution":"def reverse_words(s: str) -> str: Return the string with all words reversed individually and the order of words reversed. words = s.split() reversed_words = [word[::-1] for word in words] reversed_order = list(reversed(reversed_words)) return ' '.join(reversed_order)"},{"question":"def sum_of_primes(N): Returns the sum of all prime numbers less than or equal to N. >>> sum_of_primes(5) 10 >>> sum_of_primes(10) 17 >>> sum_of_primes(20) 77 >>> sum_of_primes(1) 0 >>> sum_of_primes(2) 2 >>> sum_of_primes(3) 5 pass def process_test_cases(test_cases): Given a list of test cases, returns a list of results with the sum of all prime numbers less than or equal to the corresponding N for each test case. >>> process_test_cases([5, 10, 20]) [10, 17, 77] pass","solution":"def sum_of_primes(N): Returns the sum of all prime numbers less than or equal to N. if N < 2: return 0 sieve = [True] * (N + 1) sieve[0] = sieve[1] = False p = 2 while (p * p <= N): if (sieve[p] == True): for i in range(p * p, N + 1, p): sieve[i] = False p += 1 prime_sum = sum([i for i in range(N + 1) if sieve[i]]) return prime_sum def process_test_cases(test_cases): results = [] for N in test_cases: results.append(sum_of_primes(N)) return results"},{"question":"def find_pair(nums: List[int], target: int) -> Optional[Tuple[int, int]]: This function returns a tuple of indices of two numbers in the array \`nums\` that add up to the \`target\` value. If no such pair exists, it returns None. >>> find_pair([2, 7, 11, 15], 9) (0, 1) >>> find_pair([3, 2, 4], 6) (1, 2) >>> find_pair([3, 3], 6) (0, 1) >>> find_pair([1, 2, 3, 4, 5], 10) None >>> find_pair([-1, -2, -3, -4, -5], -8) (2, 4) >>> find_pair([1, 3, 3, 4], 6) (1, 2) >>> find_pair([0, 0, 3, 4], 0) (0, 1)","solution":"def find_pair(nums, target): This function returns a tuple of indices of two numbers in the array \`nums\` that add up to the \`target\` value. If no such pair exists, it returns None. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return (num_to_index[complement], i) num_to_index[num] = i return None"},{"question":"from typing import List, Tuple def find_frequent_users(records: List[Tuple[int, str]]) -> List[int]: Identifies users who accessed the system more than once but less than or equal to 10 times. Returns their user IDs sorted in ascending order. >>> find_frequent_users([(1, \\"2023-10-01 12:00:00\\"), (2, \\"2023-10-01 12:05:00\\"), (1, \\"2023-10-01 12:10:00\\"), >>> (3, \\"2023-10-01 12:15:00\\"), (3, \\"2023-10-01 12:20:00\\"), (3, \\"2023-10-01 12:25:00\\"), >>> (4, \\"2023-10-01 12:30:00\\"), (2, \\"2023-10-01 12:35:00\\"), (2, \\"2023-10-01 12:40:00\\"), >>> (5, \\"2023-10-01 12:45:00\\"), (1, \\"2023-10-01 12:50:00\\"), (2, \\"2023-10-01 12:55:00\\"), >>> (1, \\"2023-10-01 13:00:00\\"), (2, \\"2023-10-01 13:05:00\\"), (2, \\"2023-10-01 13:10:00\\")]) [1, 2, 3] >>> find_frequent_users([(6, \\"2023-10-01 12:00:00\\"), (6, \\"2023-10-01 12:01:00\\"), (6, \\"2023-10-01 12:02:00\\"), >>> (6, \\"2023-10-01 12:03:00\\"), (6, \\"2023-10-01 12:04:00\\"), (6, \\"2023-10-01 12:05:00\\"), >>> (6, \\"2023-10-01 12:06:00\\"), (6, \\"2023-10-01 12:07:00\\"), (6, \\"2023-10-01 12:08:00\\"), >>> (6, \\"2023-10-01 12:09:00\\"), (6, \\"2023-10-01 12:10:00\\")]) [] pass","solution":"from collections import defaultdict from typing import List, Tuple def find_frequent_users(records: List[Tuple[int, str]]) -> List[int]: Identifies users who accessed the system more than once but less than or equal to 10 times. Returns their user IDs sorted in ascending order. user_access_count = defaultdict(int) # Count accesses for each user for user_id, timestamp in records: user_access_count[user_id] += 1 # Filter users based on their access count frequent_users = [user_id for user_id, count in user_access_count.items() if 1 < count <= 10] # Sort user IDs in ascending order return sorted(frequent_users)"},{"question":"def count_machines_for_jobs(queries, A, B): Given a list of job difficulties (queries) and the ranges of difficulty that each machine can handle (A and B lists), return a list of the number of machines that can handle each job. >>> count_machines_for_jobs([2], [1], [5]) [1] >>> count_machines_for_jobs([12], [1, 5, 10], [10, 15, 20]) [2] >>> count_machines_for_jobs([30], [1, 5, 10], [10, 15, 20]) [0] >>> count_machines_for_jobs([2, 12, 20], [1, 5, 10], [10, 15, 20]) [1, 2, 1] >>> count_machines_for_jobs([7], [1, 2, 3], [5, 7, 9]) [2] >>> count_machines_for_jobs([1], [1], [1]) [1] >>> count_machines_for_jobs([10**9], [1], [10**9]) [1] >>> count_machines_for_jobs([10], [], []) [0] >>> count_machines_for_jobs([], [1, 2, 3], [10, 20, 30]) [] >>> count_machines_for_jobs([], [1, 5, 10], [10, 15, 20]) []","solution":"def count_machines_for_jobs(queries, A, B): Given a list of job difficulties (queries) and the ranges of difficulty that each machine can handle (A and B lists), return a list of the number of machines that can handle each job. results = [] for job in queries: count = 0 for a, b in zip(A, B): if a <= job <= b: count += 1 results.append(count) return results def process_input(): import sys input = sys.stdin.read data = input().split() index = 0 M = int(data[index]) index += 1 N = int(data[index]) index += 1 Q = int(data[index]) index += 1 A = [] B = [] for _ in range(M): A.append(int(data[index])) index += 1 B.append(int(data[index])) index += 1 job_difficulties = [] for _ in range(N): job_difficulties.append(int(data[index])) index += 1 queries = [] for _ in range(Q): queries.append(int(data[index])) index += 1 results = count_machines_for_jobs(queries, A, B) for result in results: print(result)"},{"question":"from typing import List def isPerfect(s: str, minLength: int, maxLength: int) -> bool: Determines if there exists a perfect square among the substrings of a given string of digits within the specified range of lengths. Parameters: s (str): The string of digits to examine. minLength (int): The minimum length of the substring to consider. maxLength (int): The maximum length of the substring to consider. Returns: bool: True if there exists a perfect square among the substrings, False otherwise. Example: >>> isPerfect(\\"14432116\\", 2, 3) True >>> isPerfect(\\"123456789\\", 2, 2) False >>> isPerfect(\\"2125263649\\", 1, 2) True pass # Test cases def test_isPerfect(): assert isPerfect(\\"14432116\\", 2, 3) == True assert isPerfect(\\"123456789\\", 2, 2) == False assert isPerfect(\\"2125263649\\", 1, 2) == True assert isPerfect(\\"0000123456765432100987654321\\", 1, 5) == True assert isPerfect(\\"00000449\\", 2, 3) == True assert isPerfect(\\"14416384\\", 2, 4) == True assert isPerfect(\\"\\", 1, 1) == False assert isPerfect(\\"3\\", 1, 1) == False assert isPerfect(\\"9\\", 1, 1) == True assert isPerfect(\\"987654321\\", 10, 15) == False","solution":"def isPerfect(s, minLength, maxLength): Determines if there exists a perfect square among the substrings of a given string of digits within the specified range of lengths. Parameters: s (str): The string of digits to examine. minLength (int): The minimum length of the substring to consider. maxLength (int): The maximum length of the substring to consider. Returns: bool: True if there exists a perfect square among the substrings, False otherwise. def is_perfect_square(n): if n < 0: return False root = int(n ** 0.5) return root * root == n for length in range(minLength, maxLength + 1): for i in range(len(s) - length + 1): sub = s[i:i + length] if sub[0] == '0': continue if is_perfect_square(int(sub)): return True return False"},{"question":"def prime_factors(n: int) -> str: Given an integer n, returns a string containing the innermost prime factors of n in non-decreasing order. >>> prime_factors(28) \\"2 2 7\\" >>> prime_factors(18) \\"2 3 3\\" >>> prime_factors(1) \\"No prime factors\\" >>> prime_factors(45) \\"3 3 5\\" >>> prime_factors(77) \\"7 11\\"","solution":"def prime_factors(n: int) -> str: Returns the prime factors of n in non-decreasing order as a string. if n < 2: return \\"No prime factors\\" factors = [] divisor = 2 while n > 1: while n % divisor == 0: factors.append(str(divisor)) n = n // divisor divisor += 1 return ' '.join(factors)"},{"question":"def add_binary(bin1: str, bin2: str) -> str: Adds two binary strings and returns their sum as a binary string. The result does not contain leading zeros unless the result is \\"0\\". >>> add_binary(\\"110\\", \\"101\\") == \\"1011\\" >>> add_binary(\\"11\\", \\"1\\") == \\"100\\" >>> add_binary(\\"1\\", \\"1\\") == \\"10\\" >>> add_binary(\\"0\\", \\"0\\") == \\"0\\" >>> add_binary(\\"1001\\", \\"0101\\") == \\"1110\\" >>> add_binary(\\"0\\", \\"1\\") == \\"1\\" >>> add_binary(\\"111\\", \\"10\\") == \\"1001\\" >>> add_binary(\\"1010\\", \\"1011\\") == \\"10101\\" # Your code here","solution":"def add_binary(bin1, bin2): Adds two binary strings and returns their sum as a binary string. The result does not contain leading zeros unless the result is '0'. # Convert the binary strings to integers int1 = int(bin1, 2) int2 = int(bin2, 2) # Add the integers sum_int = int1 + int2 # Convert the sum back to binary and remove the '0b' prefix sum_bin = bin(sum_int)[2:] return sum_bin"},{"question":"def unique_bead_colors(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given a list of test cases, find the number of unique colors for each necklace. Parameters: test_cases (List[Tuple[int, List[int]]]): A list of tuples, where each tuple contains the number of beads and a list of integers representing the bead colors. Returns: List[int]: A list containing the number of unique colors for each test case. Examples: >>> unique_bead_colors([(5, [1, 2, 3, 2, 1])]) [3] >>> unique_bead_colors([(4, [4, 4, 4, 4])]) [1] >>> unique_bead_colors([(6, [1, 2, 3, 4, 5, 6])]) [6]","solution":"def unique_bead_colors(test_cases): results = [] for case in test_cases: N, beads = case unique_colors = len(set(beads)) results.append(unique_colors) return results # Example usage: # test_cases = [(5, [1, 2, 3, 2, 1]), (4, [4, 4, 4, 4]), (6, [1, 2, 3, 4, 5, 6])] # print(unique_bead_colors(test_cases))"},{"question":"def parking_lot_final_arrangement(T, test_cases): Given the sequence of preferred parking spots for a series of cars, determine the final arrangement of cars in the lot after all have attempted to park. Parameters: T (int): The number of test cases. test_cases (list): A list containing tuples, each representing a test case with: - An integer N, the total number of parking spaces. - An integer M, the number of cars. - A list of M integers representing the preferred parking spaces of each car, in the order they arrive. Returns: list: A list of lists, each representing the final arrangement of cars in the parking lot for each test case, where the value at each index is the car number that parked in that space, with 0 representing an empty space. >>> parking_lot_final_arrangement(2, [(5, 3, [1, 2, 3]), (5, 5, [1, 2, 3, 4, 5])]) [[1, 2, 3, 0, 0], [1, 2, 3, 4, 5]] >>> parking_lot_final_arrangement(1, [(10, 5, [1, 1, 1, 1, 1])]) [[1, 2, 3, 4, 5, 0, 0, 0, 0, 0]]","solution":"def parking_lot_final_arrangement(T, test_cases): results = [] for case in test_cases: N, M, preferred_spots = case parking_lot = [0] * N for car_number, preferred_spot in enumerate(preferred_spots, 1): # Find the first available spot starting from preferred_spot for spot in range(preferred_spot - 1, N): if parking_lot[spot] == 0: parking_lot[spot] = car_number break results.append(parking_lot) return results"},{"question":"def find_lis(magnitudes: list[int]) -> int: Function to compute the length of the longest increasing subsequence in the \`magnitudes\` list. >>> find_lis([3, 10, 2, 1, 20]) # should return 3, because the longest increasing subsequence is [3, 10, 20] >>> find_lis([3, 2]) # should return 1, because the longest increasing subsequence is either [3] or [2] >>> find_lis([50, 3, 10, 7, 40, 80]) # should return 4, because the longest increasing subsequence is [3, 7, 40, 80] pass # Example test cases assert find_lis([3, 10, 2, 1, 20]) == 3 assert find_lis([3, 2]) == 1 assert find_lis([50, 3, 10, 7, 40, 80]) == 4 assert find_lis([-1, -2, -3, -4, -5]) == 1 assert find_lis([10, -1, 2, -3, 4, -5, 6]) == 4 assert find_lis([5]) == 1 assert find_lis([]) == 0 assert find_lis([1, 2, 3, 4, 5]) == 5 assert find_lis([5, 4, 3, 2, 1]) == 1","solution":"def find_lis(magnitudes: list[int]) -> int: Function to compute the length of the longest increasing subsequence in the \`magnitudes\` list. if not magnitudes: return 0 n = len(magnitudes) lis = [1] * n for i in range(1, n): for j in range(0, i): if magnitudes[i] > magnitudes[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 return max(lis)"},{"question":"def length_of_longest_substring(s: str) -> int: Design an algorithm that takes a string containing only lowercase characters and identifies the longest substring with unique characters. The function should return the length of that longest substring. Example 1: >>> length_of_longest_substring(\\"abcabcbb\\") 3 Example 2: >>> length_of_longest_substring(\\"bbbbb\\") 1 Example 3: >>> length_of_longest_substring(\\"pwwkew\\") 3 Example 4: >>> length_of_longest_substring(\\"dvdf\\") 3","solution":"def length_of_longest_substring(s): Returns the length of the longest substring with unique characters. :param s: input string :return: length of the longest substring with unique characters n = len(s) if n == 0: return 0 char_set = set() left = 0 max_length = 0 for right in range(n): while s[right] in char_set: char_set.remove(s[left]) left += 1 char_set.add(s[right]) max_length = max(max_length, right - left + 1) return max_length"},{"question":"def is_path_possible(forest): Determines if there is a path from the top-left corner (0,0) to the bottom-right corner (n-1, m-1) in a given forest grid. :param forest: List[List[int]], the forest grid where 1 is a passable cell and 0 is a blocked cell. :return: bool, True if a path exists, else False. >>> is_path_possible([ [1, 0, 0, 0], [1, 1, 0, 1], [0, 1, 1, 1], [0, 0, 1, 1] ]) True >>> is_path_possible([ [1, 0, 0, 0], [0, 1, 0, 1], [0, 0, 1, 1], [0, 0, 1, 1] ]) False","solution":"def is_path_possible(forest): Determines if there is a path from the top-left corner (0,0) to the bottom-right corner (n-1, m-1) in a given forest grid. :param forest: List[List[int]], the forest grid where 1 is a passable cell and 0 is a blocked cell. :return: bool, True if a path exists, else False. def dfs(x, y): if x < 0 or y < 0 or x >= len(forest) or y >= len(forest[0]) or forest[x][y] == 0: return False if (x, y) == (len(forest) - 1, len(forest[0]) - 1): return True # Mark the cell as visited forest[x][y] = 0 # Traverse in all 4 possible directions if dfs(x + 1, y) or dfs(x - 1, y) or dfs(x, y + 1) or dfs(x, y - 1): return True return False return dfs(0, 0)"},{"question":"def filter_animals(diet: str, habitat: str, min_limbs: int, excluded_animals: List[str]) -> List[str]: Filters the animals based on the given criteria. Parameters: diet (str): The diet of the animal (\\"herbivore\\", \\"carnivore\\", \\"omnivore\\"). habitat (str): The habitat of the animal (\\"land\\", \\"water\\", \\"air\\"). min_limbs (int): The minimum number of limbs the animal should have. excluded_animals (list of str): List of animal names to exclude from the results. Returns: list of str: Names of the animals that meet the criteria. >>> animal_list = [ {\\"name\\": \\"elephant\\", \\"diet\\": \\"herbivore\\", \\"habitat\\": \\"land\\", \\"limbs\\": 4}, {\\"name\\": \\"shark\\", \\"diet\\": \\"carnivore\\", \\"habitat\\": \\"water\\", \\"limbs\\": 0}, {\\"name\\": \\"sparrow\\", \\"diet\\": \\"omnivore\\", \\"habitat\\": \\"air\\", \\"limbs\\": 2}, {\\"name\\": \\"cow\\", \\"diet\\": \\"herbivore\\", \\"habitat\\": \\"land\\", \\"limbs\\": 4}, {\\"name\\": \\"octopus\\", \\"diet\\": \\"carnivore\\", \\"habitat\\": \\"water\\", \\"limbs\\": 8}, {\\"name\\": \\"frog\\", \\"diet\\": \\"carnivore\\", \\"habitat\\": \\"water\\", \\"limbs\\": 4} ] filter_animals(\\"carnivore\\", \\"water\\", 4, [\\"octopus\\"]) == [\\"frog\\"] filter_animals(\\"herbivore\\", \\"land\\", 4, [\\"elephant\\", \\"cow\\"]) == [] filter_animals(\\"omnivore\\", \\"air\\", 2, []) == [\\"sparrow\\"]","solution":"animal_list = [ {\\"name\\": \\"elephant\\", \\"diet\\": \\"herbivore\\", \\"habitat\\": \\"land\\", \\"limbs\\": 4}, {\\"name\\": \\"shark\\", \\"diet\\": \\"carnivore\\", \\"habitat\\": \\"water\\", \\"limbs\\": 0}, {\\"name\\": \\"sparrow\\", \\"diet\\": \\"omnivore\\", \\"habitat\\": \\"air\\", \\"limbs\\": 2}, {\\"name\\": \\"cow\\", \\"diet\\": \\"herbivore\\", \\"habitat\\": \\"land\\", \\"limbs\\": 4}, {\\"name\\": \\"octopus\\", \\"diet\\": \\"carnivore\\", \\"habitat\\": \\"water\\", \\"limbs\\": 8}, {\\"name\\": \\"frog\\", \\"diet\\": \\"carnivore\\", \\"habitat\\": \\"water\\", \\"limbs\\": 4} ] def filter_animals(diet, habitat, min_limbs, excluded_animals): Filters the animals based on the given criteria. Parameters: diet (str): The diet of the animal (\\"herbivore\\", \\"carnivore\\", \\"omnivore\\"). habitat (str): The habitat of the animal (\\"land\\", \\"water\\", \\"air\\"). min_limbs (int): The minimum number of limbs the animal should have. excluded_animals (list of str): List of animal names to exclude from the results. Returns: list of str: Names of the animals that meet the criteria. result = [] for animal in animal_list: if (animal['diet'] == diet and animal['habitat'] == habitat and animal['limbs'] >= min_limbs and animal['name'] not in excluded_animals): result.append(animal['name']) return result"},{"question":"from typing import List def maxSumWithOneRemoval(A: List[int]) -> int: Given an integer array A, return the maximum possible sum of a non-empty subarray that contains at most one element of the array A that is removed. >>> maxSumWithOneRemoval([1, -2, 0, 3]) 4 >>> maxSumWithOneRemoval([1, -2, -2, 3]) 3 >>> maxSumWithOneRemoval([-1, -1, -1, -1]) -1 # Unit tests def test_example_case_1(): assert maxSumWithOneRemoval([1, -2, 0, 3]) == 4 def test_example_case_2(): assert maxSumWithOneRemoval([1, -2, -2, 3]) == 3 def test_example_case_3(): assert maxSumWithOneRemoval([-1, -1, -1, -1]) == -1 def test_single_element(): assert maxSumWithOneRemoval([5]) == 5 def test_all_negative_elements(): assert maxSumWithOneRemoval([-3, -2, -1, -4]) == -1 def test_no_removal_needed(): assert maxSumWithOneRemoval([1, 2, 3, 4]) == 10 def test_middle_removal(): assert maxSumWithOneRemoval([1, 2, -5, 3, 4]) == 10 def test_removal_at_beginning(): assert maxSumWithOneRemoval([-1, 4, 3, 2]) == 9 def test_removal_at_end(): assert maxSumWithOneRemoval([1, 2, 3, -4]) == 6 def test_mixed_elements(): assert maxSumWithOneRemoval([3, -1, 2, -1, 5]) == 9","solution":"from typing import List def maxSumWithOneRemoval(A: List[int]) -> int: n = len(A) if n == 1: return A[0] # Arrays to keep the maximum sum ending at each index without any removal and with one removal max_end_no_removal = [0]*n max_end_one_removal = [0]*n # Initialization for the first element max_end_no_removal[0] = A[0] max_end_one_removal[0] = float('-inf') # Not possible to have removal at the first element max_so_far = A[0] for i in range(1, n): max_end_no_removal[i] = max(max_end_no_removal[i-1] + A[i], A[i]) max_end_one_removal[i] = max(max_end_one_removal[i-1] + A[i], max_end_no_removal[i-1]) max_so_far = max(max_so_far, max_end_no_removal[i], max_end_one_removal[i]) return max_so_far"},{"question":"def eligible_students(records: List[str]) -> List[str]: Returns the names of students between ages 18 and 25 (inclusive) and with a score of 75 or higher, sorted in ascending order. :param records: List of student records in the format \\"name,age,score\\". :return: List of eligible student names sorted in ascending order. pass # Unit test def test_eligible_students(): assert eligible_students([\\"john,20,80\\", \\"jane,22,60\\", \\"bob,23,90\\", \\"alice,19,75\\"]) == [\\"alice\\", \\"bob\\", \\"john\\"] assert eligible_students([\\"joe,26,85\\", \\"emily,21,65\\", \\"jack,24,80\\"]) == [\\"jack\\"] assert eligible_students([]) == [] assert eligible_students([\\"a,18,75\\", \\"b,25,75\\", \\"c,17,75\\", \\"d,26,75\\"]) == [\\"a\\", \\"b\\"] assert eligible_students([\\"x,18,74\\", \\"y,25,76\\", \\"z,23,75\\"]) == [\\"y\\", \\"z\\"] assert eligible_students([\\"student,25,74\\", \\"learner,24,100\\", \\"pupil,23,60\\"]) == [\\"learner\\"]","solution":"def eligible_students(records): Returns the names of students between ages 18 and 25 (inclusive) and with a score of 75 or higher, sorted in ascending order. :param records: List of student records in the format \\"name,age,score\\". :return: List of eligible student names sorted in ascending order. eligible = [] for record in records: name, age, score = record.split(',') age = int(age) score = int(score) if 18 <= age <= 25 and score >= 75: eligible.append(name) return sorted(eligible)"},{"question":"def can_convert_to_palindrome(s: str) -> bool: Determines if a string can be converted to a palindrome by removing at most one character. >>> can_convert_to_palindrome(\\"abca\\") True >>> can_convert_to_palindrome(\\"racecar\\") True >>> can_convert_to_palindrome(\\"abc\\") False >>> can_convert_to_palindrome(\\"a\\") True >>> can_convert_to_palindrome(\\"abcd\\") False","solution":"def can_convert_to_palindrome(s: str) -> bool: Determines if a string can be converted to a palindrome by removing at most one character. def is_palindrome_range(i, j): Helper function to check if the string s[i:j+1] is a palindrome. return all(s[k] == s[j-k+i] for k in range(i, (j+i)//2 + 1)) for i in range(len(s) // 2): if s[i] != s[~i]: # ~i is equivalent to -(i+1) j = len(s) - 1 - i return is_palindrome_range(i + 1, j) or is_palindrome_range(i, j - 1) return True"},{"question":"from typing import List def longest_subsequence(nums: List[int]) -> int: Given a list of integers, find the longest subsequence where the difference between any two consecutive elements is less than or equal to 1. >>> longest_subsequence([1, 2, 2, 3, 1, 2]) 5 >>> longest_subsequence([4, 6, 5, 5, 3, 3, 1]) 3 >>> longest_subsequence([1, 1, 1, 1]) 4 pass def test_longest_subsequence(): def test_case(input_list, expected): assert longest_subsequence(input_list) == expected test_case([1, 2, 2, 3, 1, 2], 5) test_case([4, 6, 5, 5, 3, 3, 1], 3) test_case([1, 1, 1, 1], 4) test_case([], 0) test_case([5], 1) test_case([10, 10, 10], 3) test_case([1, 3, 5, 7, 9], 1) test_case([9, 8, 9, 8], 4) print(\\"All test cases pass!\\") test_longest_subsequence()","solution":"def longest_subsequence(nums): Given a list of integers, find the longest subsequence where the difference between any two consecutive elements is less than or equal to 1. if not nums: return 0 dp = [1] * len(nums) for i in range(1, len(nums)): for j in range(i): if abs(nums[i] - nums[j]) <= 1: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def count_above_threshold(temperatures: List[int], threshold: int) -> int: Returns the number of days the temperature was above the given threshold. >>> count_above_threshold([65, 70, 75, 80, 85, 90, 95], 80) 3 >>> count_above_threshold([60, 65, 70, 72, 74, 78, 79], 80) 0 >>> count_above_threshold([81, 82, 83, 84, 85, 86, 87], 80) 7 >>> count_above_threshold([80, 80, 80, 80, 80, 80, 80], 80) 0 >>> count_above_threshold([55, 60, 75, 85, 90, 95, 50], 80) 3 >>> count_above_threshold([-10, -20, 0, 20, 30, 40, 50], 0) 4 >>> count_above_threshold([80, 80, 80, 80, 80, 80, 80], 79) 7 pass","solution":"def count_above_threshold(temperatures, threshold): Returns the number of days the temperature was above the given threshold. :param temperatures: List of integers representing temperatures over a week :param threshold: Integer representing the temperature threshold :return: Integer count of days with temperature above the threshold return sum(temp > threshold for temp in temperatures)"},{"question":"def reverse_words(s: str) -> str: Takes a string of one or more words, and returns the same string with each word reversed, but with the words in their original order. Examples: >>> reverse_words(\\"Hello World\\") 'olleH dlroW' >>> reverse_words(\\"The quick brown fox\\") 'ehT kciuq nworb xof'","solution":"def reverse_words(s): Takes a string of one or more words, and returns the same string with each word reversed, but with the words in their original order. Parameters: s (str): The input string of words. Returns: str: The transformed string with each word reversed. return ' '.join(word[::-1] for word in s.split())"},{"question":"def find_longest_subarray(arr) -> int: Returns the length of the longest contiguous subarray containing exactly two different colors. Args: arr (List[int]): List of integers representing the colors of the lights. Returns: int: Length of the longest contiguous subarray with exactly two different colors. Examples: >>> find_longest_subarray([1, 3, 1, 2, 2, 3, 4, 3]) 3 >>> find_longest_subarray([4, 4, 5, 5, 4, 3]) 5 >>> find_longest_subarray([1, 2, 3, 4, 5]) 2 # Implement your code here pass def test_find_longest_subarray_case1(): assert find_longest_subarray([1, 3, 1, 2, 2, 3, 4, 3]) == 3 def test_find_longest_subarray_case2(): assert find_longest_subarray([4, 4, 5, 5, 4, 3]) == 5 def test_find_longest_subarray_case3(): assert find_longest_subarray([1, 2, 3, 4, 5]) == 2 def test_find_longest_subarray_empty(): assert find_longest_subarray([]) == 0 def test_find_longest_subarray_single_element(): assert find_longest_subarray([1]) == 0 def test_find_longest_subarray_two_same_elements(): assert find_longest_subarray([1, 1]) == 0 def test_find_longest_subarray_all_same(): assert find_longest_subarray([2, 2, 2, 2]) == 0 def test_find_longest_subarray_duplicates(): assert find_longest_subarray([1, 1, 2, 2, 1, 1, 2, 2]) == 8 def test_find_longest_subarray_two_colors(): assert find_longest_subarray([7, 7, 8, 8, 9, 8]) == 4","solution":"def find_longest_subarray(arr): Returns the length of the longest contiguous subarray containing exactly two different colors. if len(arr) < 2: return 0 max_len = 0 start = 0 color_count = {} for end in range(len(arr)): if arr[end] in color_count: color_count[arr[end]] += 1 else: color_count[arr[end]] = 1 while len(color_count) > 2: color_count[arr[start]] -= 1 if color_count[arr[start]] == 0: del color_count[arr[start]] start += 1 current_len = end - start + 1 if len(color_count) == 2: max_len = max(max_len, current_len) return max_len"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def partition_linked_list(head: ListNode, x: int) -> ListNode: Partition a singly linked list around a value x. Args: head (ListNode): A singly linked list of integers where each node is represented by a ListNode object. x (int): An integer value around which the linked list needs to be partitioned. Returns: ListNode: The head of the modified linked list after partitioning. Examples: >>> linked_list_to_list(partition_linked_list(list_to_linked_list([1, 4, 3, 2, 5, 2]), 3)) [1, 2, 2, 4, 3, 5] >>> linked_list_to_list(partition_linked_list(list_to_linked_list([2, 1]), 2)) [1, 2] def list_to_linked_list(lst): if not lst: return None head = ListNode(lst[0]) current = head for val in lst[1:]: current.next = ListNode(val) current = current.next return head def linked_list_to_list(head): lst = [] current = head while current: lst.append(current.val) current = current.next return lst def test_partition_linked_list(): assert linked_list_to_list(partition_linked_list(None, 3)) == [] assert linked_list_to_list(partition_linked_list(list_to_linked_list([1]), 3)) == [1] assert linked_list_to_list(partition_linked_list(list_to_linked_list([1, 2, 2]), 3)) == [1, 2, 2] assert linked_list_to_list(partition_linked_list(list_to_linked_list([4, 5, 6]), 3)) == [4, 5, 6] assert linked_list_to_list(partition_linked_list(list_to_linked_list([1, 4, 3, 2, 5, 2]), 3)) == [1, 2, 2, 4, 3, 5] assert linked_list_to_list(partition_linked_list(list_to_linked_list([1, 2, 5, 7]), 4)) == [1, 2, 5, 7] assert linked_list_to_list(partition_linked_list(list_to_linked_list([1, 4, 3, 2, 5, 2, 2]), 3)) == [1, 2, 2, 2, 4, 3, 5]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def partition_linked_list(head: ListNode, x: int) -> ListNode: if head is None: return None # Create two dummy nodes for less and greater or equal partitions less_head = ListNode(0) greater_head = ListNode(0) # Use two pointers to build the two lists less = less_head greater = greater_head current = head while current: if current.val < x: less.next = current less = less.next else: greater.next = current greater = greater.next current = current.next # Combine the two lists less.next = greater_head.next greater.next = None return less_head.next"},{"question":"import string from typing import Dict def count_word_lengths(text: str) -> Dict[int, int]: Counts the occurrences of each word length in a given text string. Parameters: text (str): The input string. Returns: dict: A dictionary where keys are word lengths and values are the counts of words with those lengths. >>> count_word_lengths(\\"Hello world!\\") {5: 2} >>> count_word_lengths(\\"This is a test sentence.\\") {4: 2, 2: 1, 1: 1, 8: 1} >>> count_word_lengths(\\"Python is amazing.\\") {6: 1, 2: 1, 7: 1}","solution":"import string def count_word_lengths(text): Counts the occurrences of each word length in a given text string. Parameters: text (str): The input string. Returns: dict: A dictionary where keys are word lengths and values are the counts of words with those lengths. # Remove punctuation from the text translator = str.maketrans('', '', string.punctuation) cleaned_text = text.translate(translator) # Split the text into words words = cleaned_text.split() # Create a dictionary to store the occurrences of each word length word_length_counts = {} # Iterate over each word in the list for word in words: length = len(word) if length in word_length_counts: word_length_counts[length] += 1 else: word_length_counts[length] = 1 return word_length_counts"},{"question":"def rearrange(arr: List[int]) -> List[int]: Rearrange the elements of the array such that all negative numbers appear before all non-negative numbers without changing the relative order. Args: arr: List[int] - The array of integers to rearrange. Returns: List[int] - The rearranged array. Examples: >>> rearrange([-1, 2, -3, 4, 5, -6, -7]) [-1, -3, -6, -7, 2, 4, 5] >>> rearrange([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> rearrange([-1, -2, -3, -4, -5]) [-1, -2, -3, -4, -5] >>> rearrange([]) [] >>> rearrange([1]) [1] >>> rearrange([-1]) [-1] >>> rearrange([4, 3, 2, 1]) [4, 3, 2, 1] >>> rearrange([-4, -3, -2, -1]) [-4, -3, -2, -1] >>> rearrange([-1, 0, 2, -3, 0, 4, 5]) [-1, -3, 0, 2, 0, 4, 5]","solution":"def rearrange(arr): Rearrange the elements of the array such that all negative numbers appear before all non-negative numbers without changing the relative order. if not arr: return arr n = len(arr) j = 0 for i in range(n): if arr[i] < 0: temp = arr[i] # Shift positive elements forward for k in range(i, j, -1): arr[k] = arr[k - 1] arr[j] = temp j += 1 return arr"},{"question":"def total_quantities(test_cases: List[List[int]]) -> List[int]: Given a list of test cases, where each test case contains a list of ingredient quantities, return a list of total quantities for each test case. >>> total_quantities([[1, 2, 3], [10, 20, 30, 40]]) == [6, 100] >>> total_quantities([[1000, 1000, 1000], [5, 5, 5, 5], [1]]) == [3000, 20, 1] >>> total_quantities([[0, 0, 0, 0, 1], [0, 1, 2, 3], [100, 200]]) == [1, 6, 300] >>> total_quantities([[]]) == [0] >>> total_quantities([[1000] * 100]) == [100000] >>> total_quantities([[1] * 100, [1] * 50]) == [100, 50]","solution":"def total_quantities(test_cases): Given a list of test cases, where each test case contains a list of ingredient quantities, return a list of total quantities for each test case. Parameters: test_cases (list of lists): List of test cases with ingredient quantities. Returns: list: List of total quantities for each test case. results = [] for quantities in test_cases: results.append(sum(quantities)) return results"},{"question":"def max_batches(N: int, L: int, A: List[int]) -> int: Alice works at a perfume factory that produces different scents. There are N batches of perfume, and each batch contains Ai litres of perfume. Alice has L litres of space available in her storage tank, and she wants to maximize the number of different batches she can store without exceeding the capacity of her storage tank. Additionally, if Alice chooses to store a batch, she must store the entire batch (no partial filling is allowed). Given the number of batches, storage capacity, and the litres in each batch, return the maximum number of different batches Alice can store. >>> max_batches(3, 10, [1, 2, 3]) 3 >>> max_batches(4, 5, [5, 4, 3, 2]) 2 >>> max_batches(5, 7, [5, 2, 4, 1, 3]) 3 >>> max_batches(3, 3, [4, 5, 6]) 0 >>> max_batches(4, 6, [1, 2, 2, 1]) 4 def solve(test_cases: List[Dict[str, Union[int, List[int]]]]) -> List[int]: Given a list of test cases where each test case contains the number of batches, storage capacity, and the litres in each batch, return a list of integers where each integer represents the maximum number of different batches Alice can store for the corresponding test case. >>> solve([ {'N': 3, 'L': 10, 'A': [1, 2, 3]}, {'N': 4, 'L': 5, 'A': [5, 4, 3, 2]}, {'N': 5, 'L': 7, 'A': [5, 2, 4, 1, 3]} ]) [3, 2, 3]","solution":"def max_batches(N, L, A): A.sort() current_sum = 0 count = 0 for i in range(N): if current_sum + A[i] <= L: current_sum += A[i] count += 1 else: break return count def solve(test_cases): results = [] for case in test_cases: N, L = case['N'], case['L'] A = case['A'] result = max_batches(N, L, A) results.append(result) return results"},{"question":"from typing import List, Tuple def shortest_route(points: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Return the shortest route that starts from the origin point (0, 0), visits each delivery point exactly once, and then returns to the origin. Example: >>> shortest_route([]) [(0, 0), (0, 0)] >>> shortest_route([(1, 2)]) [(0, 0), (1, 2), (0, 0)] >>> shortest_route([(1, 2), (3, 4)]) [(0, 0), (1, 2), (3, 4), (0, 0)] >>> shortest_route([(1, 2), (4, 6), (3, 7)]) [(0, 0), (1, 2), (3, 7), (4, 6), (0, 0)] >>> shortest_route([(1, 1), (1, 1), (1, 1)]) [(0, 0), (1, 1), (1, 1), (1, 1), (0, 0)] pass","solution":"from itertools import permutations from math import sqrt def euclidean_distance(p1, p2): return sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) def total_distance(route): total = 0 for i in range(len(route) - 1): total += euclidean_distance(route[i], route[i+1]) return total def shortest_route(points): if not points: return [(0, 0), (0, 0)] points_with_origin = [(0, 0)] + points best_route = None min_distance = float('inf') for perm in permutations(points): current_route = [(0, 0)] + list(perm) + [(0, 0)] current_distance = total_distance(current_route) if current_distance < min_distance: min_distance = current_distance best_route = current_route return best_route"},{"question":"def countArrangements(n: int) -> int: Write a function \`countArrangements(n)\` that takes in an integer \`n\` (1 ≤ n ≤ 1000) and returns the number of ways to arrange \`n\` distinct books on shelves, where books on the same shelf are considered to be in the same arrangement regardless of order, but different combinations of shelves count as different arrangements. Return \`-1\` if the input \`n\` is not a valid integer within the inclusive range. >>> countArrangements(1) 1 >>> countArrangements(2) 2 >>> countArrangements(3) 5 >>> countArrangements(4) 15","solution":"def countArrangements(n): if not isinstance(n, int) or n < 1 or n > 1000: return -1 # Use Bell number computation bell = [[0 for i in range(n+1)] for j in range(n+1)] bell[0][0] = 1 for i in range(1, n + 1): bell[i][0] = bell[i-1][i-1] for j in range(1, i + 1): bell[i][j] = bell[i-1][j-1] + bell[i][j-1] return bell[n][0]"},{"question":"def middle_finisher(names: str) -> str: Returns the name(s) of the participant(s) who finished in the middle position(s). If the number of participants is odd, return the name of the middle finisher. If the number of participants is even, return a string with the two middle finishers concatenated together, separated by an ampersand ('&'). >>> middle_finisher(\\"Jake,Katie,Liam,Maya,Nina\\") 'Liam' >>> middle_finisher(\\"Adam,Brian,Chris,Danny\\") 'Brian&Chris' >>> middle_finisher(\\"Emma,Frank,Gerry,Harry,Ivy,Jill\\") 'Gerry&Harry' >>> middle_finisher(\\"Single\\") 'Single' >>> middle_finisher(\\"First,Second\\") 'First&Second' >>> middle_finisher(\\"\\") ''","solution":"def middle_finisher(names: str) -> str: Returns the name(s) of the participant(s) who finished in the middle position(s). If the number of participants is odd, return the name of the middle finisher. If the number of participants is even, return a string with the two middle finishers concatenated together, separated by an ampersand ('&'). participants = names.split(',') n = len(participants) if n % 2 == 1: # Odd number of participants return participants[n // 2] else: # Even number of participants return participants[(n // 2) - 1] + '&' + participants[n // 2]"},{"question":"def digital_to_analog(degrees: str) -> str: Calculates the sum of digital time elements, converts it to an analog time format (in degrees), and validates the correctness of the time. Args: degrees (str): A string representing a time in the format \\"HH:MM\\". Returns: str: The calculated analog time in the format \\"HH:MM\\" in degrees, or an error message if the input is invalid. >>> digital_to_analog(\\"00:00\\") \\"0:0\\" >>> digital_to_analog(\\"12:30\\") \\"0:180\\" >>> digital_to_analog(\\"24:00\\") \\"Invalid time values!\\" >>> digital_to_analog(\\"13:60\\") \\"Invalid time values!\\" >>> digital_to_analog(\\"invalid\\") \\"Incorrect time format!\\" # Test cases print(digital_to_analog(\\"00:00\\")) # Expected output: \\"0:0\\" print(digital_to_analog(\\"12:30\\")) # Expected output: \\"0:180\\" print(digital_to_analog(\\"24:00\\")) # Expected output: \\"Invalid time values!\\" print(digital_to_analog(\\"13:60\\")) # Expected output: \\"Invalid time values!\\" print(digital_to_analog(\\"12:45\\")) # Expected output: \\"0:270\\" print(digital_to_analog(\\"09:15\\")) # Expected output: \\"270:90\\" print(digital_to_analog(\\"invalid\\")) # Expected output: \\"Incorrect time format!\\"","solution":"def digital_to_analog(degrees: str) -> str: try: hrs, mins = map(int, degrees.split(':')) if not(0 <= hrs < 24) or not(0 <= mins < 60): return \\"Invalid time values!\\" hour_degree = (hrs % 12) * 30 min_degree = mins * 6 return f\\"{hour_degree}:{min_degree}\\" except ValueError: return \\"Incorrect time format!\\""},{"question":"from typing import List def dailyTemperatures(temperatures: List[int]) -> List[int]: Returns a list representing the number of days until a warmer temperature for each day. If there is no future day with a warmer temperature, returns 0 for that day. Examples: >>> dailyTemperatures([73, 74, 75, 71, 69, 72, 76, 73]) [1, 1, 4, 2, 1, 1, 0, 0] >>> dailyTemperatures([30, 40, 50, 60]) [1, 1, 1, 0] >>> dailyTemperatures([30, 60, 90]) [1, 1, 0] def test_example_case_1(): temperatures = [73, 74, 75, 71, 69, 72, 76, 73] expected = [1, 1, 4, 2, 1, 1, 0, 0] assert dailyTemperatures(temperatures) == expected def test_example_case_2(): temperatures = [30, 40, 50, 60] expected = [1, 1, 1, 0] assert dailyTemperatures(temperatures) == expected def test_example_case_3(): temperatures = [30, 60, 90] expected = [1, 1, 0] assert dailyTemperatures(temperatures) == expected def test_single_element(): temperatures = [100] expected = [0] assert dailyTemperatures(temperatures) == expected def test_no_warmer_days(): temperatures = [100, 99, 98, 97] expected = [0, 0, 0, 0] assert dailyTemperatures(temperatures) == expected def test_all_same_temperature(): temperatures = [50, 50, 50, 50] expected = [0, 0, 0, 0] assert dailyTemperatures(temperatures) == expected def test_mixed_temperatures(): temperatures = [55, 60, 57, 58, 61, 50, 52] expected = [1, 3, 1, 1, 0, 1, 0] assert dailyTemperatures(temperatures) == expected","solution":"from typing import List def dailyTemperatures(temperatures: List[int]) -> List[int]: Returns a list representing the number of days until a warmer temperature for each day. If there is no future day with a warmer temperature, returns 0 for that day. answer = [0] * len(temperatures) stack = [] # stack of indices for i, temp in enumerate(temperatures): while stack and temperatures[stack[-1]] < temp: prev_index = stack.pop() answer[prev_index] = i - prev_index stack.append(i) return answer"},{"question":"class OnlineLibrary: Simulate a basic online library system where users can borrow and return books. The system handles the following commands: 1. \`borrow(user, book)\`: Records that the user has borrowed the book. 2. \`return_book(user, book)\`: Records that the user has returned the book. 3. \`status(book)\`: Prints the list of users who have borrowed this book in the order of borrowing time. Examples: library = OnlineLibrary() library.borrow(\\"Alice\\", \\"Book1\\") library.borrow(\\"Bob\\", \\"Book1\\") library.borrow(\\"Charlie\\", \\"Book1\\") library.return_book(\\"Alice\\", \\"Book1\\") assert library.status(\\"Book1\\") == \\"BobnCharlie\\" library.borrow(\\"Alice\\", \\"Book1\\") assert library.status(\\"Book1\\") == \\"BobnCharlienAlice\\" def __init__(self): pass def borrow(self, user: str, book: str): pass def return_book(self, user: str, book: str): pass def status(self, book: str) -> str: pass","solution":"class OnlineLibrary: def __init__(self): self.books_borrowed = {} def borrow(self, user, book): if book not in self.books_borrowed: self.books_borrowed[book] = [] if user not in self.books_borrowed[book]: self.books_borrowed[book].append(user) def return_book(self, user, book): if book in self.books_borrowed and user in self.books_borrowed[book]: self.books_borrowed[book].remove(user) def status(self, book): if book in self.books_borrowed and self.books_borrowed[book]: return 'n'.join(self.books_borrowed[book]) else: return 'No one'"},{"question":"from typing import List def subtract_to_zero_operations(arr: List[int]) -> List[int]: Given an array of n integers, perform a series of operations that bring all elements to zero by successively subtracting the minimum non-zero element from all non-zero elements of the array. Count and print the number of non-zero elements subtracted at each step in the order of operation. :param arr: List of integers :return: List of integers representing the number of non-zero elements subtracted at each step >>> subtract_to_zero_operations([6, 7, 2, 0, 5]) [4, 3, 2, 1] >>> subtract_to_zero_operations([10]) [1] >>> subtract_to_zero_operations([0, 0, 0]) [] >>> subtract_to_zero_operations([3, 4, 5, 6]) [4, 3, 2, 1] >>> subtract_to_zero_operations([0, 2, 0, 1]) [2, 1] >>> subtract_to_zero_operations([9, 6, 8, 0, 2, 0]) [4, 3, 2, 1] >>> subtract_to_zero_operations([100, 50, 25, 0, 10]) [4, 3, 2, 1]","solution":"def subtract_to_zero_operations(arr): Given a list of integers, perform operations to make all elements zero. Each operation involves subtracting the minimum non-zero element from all non-zero elements. The function returns the count of non-zero elements subtracted at each step. :param arr: List of integers :return: List of integers representing the number of non-zero elements subtracted at each step operations_count = [] while any(x != 0 for x in arr): # Find the minimum non-zero element min_non_zero = min(x for x in arr if x != 0) # Perform the subtraction operation arr = [x - min_non_zero if x != 0 else x for x in arr] # Count non-zero elements before the operation non_zero_count = sum(x != 0 for x in arr) + 1 # Add the non-zero count to the list of operations count operations_count.append(non_zero_count) return operations_count"},{"question":"def daily_temperatures(temperatures: List[int]) -> List[int]: Takes an integer array representing a series of daily temperatures, and returns a new array where each element at index 'i' indicates the number of days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 in that index. Arguments: temperatures -- List of integers representing daily temperatures. Returns: List -- List of integers indicating the number of days to wait for a warmer temperature at each index. Examples: >>> daily_temperatures([73, 74, 75, 71, 69, 72, 76, 73]) [1, 1, 4, 2, 1, 1, 0, 0] >>> daily_temperatures([75, 75, 75, 75]) [0, 0, 0, 0] pass","solution":"def daily_temperatures(temperatures): Returns an array where each element is the number of days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 at that index. n = len(temperatures) result = [0] * n stack = [] for i in range(n): while stack and temperatures[i] > temperatures[stack[-1]]: index = stack.pop() result[index] = i - index stack.append(i) return result"},{"question":"def evaluate(expression: str) -> int: Given a string representing a mathematical expression that contains only non-negative integers and the operators +, -, *, and /, evaluate the expression and return the result as an integer. The expression is guaranteed to be valid, containing no spaces, and follows standard operator precedence. >>> evaluate(\\"3+2*2\\") 7 >>> evaluate(\\"7-4/2\\") 5 >>> evaluate(\\"5+6*3\\") 23","solution":"def evaluate(expression): Evaluates a mathematical expression containing non-negative integers and the operators +, -, *, and /. def apply_operator(operators, operands): operator = operators.pop() right_operand = operands.pop() left_operand = operands.pop() if operator == '+': operands.append(left_operand + right_operand) elif operator == '-': operands.append(left_operand - right_operand) elif operator == '*': operands.append(left_operand * right_operand) elif operator == '/': operands.append(int(left_operand / right_operand)) def precedence(operator): if operator in ('+', '-'): return 1 if operator in ('*', '/'): return 2 return 0 operators = [] operands = [] i = 0 while i < len(expression): if expression[i].isdigit(): num = 0 while i < len(expression) and expression[i].isdigit(): num = num * 10 + int(expression[i]) i += 1 operands.append(num) i -= 1 elif expression[i] in \\"+-*/\\": while (operators and precedence(operators[-1]) >= precedence(expression[i])): apply_operator(operators, operands) operators.append(expression[i]) i += 1 while operators: apply_operator(operators, operands) return operands[0]"},{"question":"def match_sequence(S: str, T: str) -> bool: Determines if string S can be formed by removing some characters from string T without rearranging the order of the remaining characters. >>> match_sequence(\\"ace\\", \\"abcde\\") True >>> match_sequence(\\"aec\\", \\"abcde\\") False >>> match_sequence(\\"abc\\", \\"aabcd\\") True >>> match_sequence(\\"\\", \\"abcde\\") True >>> match_sequence(\\"acb\\", \\"abcde\\") False >>> match_sequence(\\"abcd\\", \\"abc\\") False >>> match_sequence(\\"\\", \\"\\") True >>> match_sequence(\\"a\\", \\"\\") False >>> match_sequence(\\"\\", \\"a\\") True >>> match_sequence(\\"a\\", \\"a\\") True >>> match_sequence(\\"b\\", \\"a\\") False","solution":"def match_sequence(S, T): Determines if string S can be formed by removing some characters from string T without rearranging the order of the remaining characters. Parameters: - S: string to be formed - T: source string Returns: - True if S can be formed, False otherwise it = iter(T) return all(char in it for char in S)"},{"question":"def word_frequency_counter(T: int, lines: List[str]) -> List[str]: Read multiple lines of text and output the frequency of each word. The output is a list of words and their corresponding frequencies, ordered alphabetically. >>> word_frequency_counter(1, [\\"Hello world\\"]) == [\\"hello: 1\\", \\"world: 1\\"] >>> word_frequency_counter(1, [\\"Hello hello world\\"]) == [\\"hello: 2\\", \\"world: 1\\"] >>> word_frequency_counter(1, [\\"Hello HELLO hello\\"]) == [\\"hello: 3\\"] >>> word_frequency_counter(3, [\\"Hello world\\", \\"hello World\\", \\"HELLO hello hello\\"]) == [\\"hello: 5\\", \\"world: 2\\"] >>> word_frequency_counter(2, [\\"\\", \\"\\"]) == [] >>> word_frequency_counter(1, [\\"Word WORD word\\"]) == [\\"word: 3\\"] >>> word_frequency_counter(1, [\\"123 456 !@#\\"]) == []","solution":"def word_frequency_counter(T, lines): from collections import Counter import re word_counter = Counter() for line in lines: words = re.findall(r'b[a-zA-Z]+b', line.lower()) word_counter.update(words) sorted_word_count = sorted(word_counter.items()) result = [] for word, count in sorted_word_count: result.append(f\\"{word}: {count}\\") return result"},{"question":"def reverse_and_sort_by_length(words: List[str]) -> List[str]: Takes a list of words, reverses each word, and returns a list of reversed words sorted by their original lengths in descending order. In case of ties in length, maintains the original order of appearance. >>> reverse_and_sort_by_length(['apple', 'banana', 'kiwi', 'peach']) ['ananab', 'elppa', 'hcaep', 'iwik'] >>> reverse_and_sort_by_length(['hello', 'world', 'a', 'python']) ['nohtyp', 'olleh', 'dlrow', 'a']","solution":"def reverse_and_sort_by_length(words): Takes a list of words, reverses each word, and returns a list of reversed words sorted by their original lengths in descending order. In case of ties in length, maintains the original order of appearance. # Reverse each word reversed_words = [word[::-1] for word in words] # Sort the reversed words by the original lengths in descending order, preserving the original order in case of ties sorted_words = sorted(reversed_words, key=lambda word: len(word), reverse=True) return sorted_words"},{"question":"def smallest_subarray_with_at_least_sum(N: int, thickness: List[int], T: int) -> int: Returns the length of the smallest contiguous subarray whose total thickness is at least T. If no such subarray is found, returns -1. >>> smallest_subarray_with_at_least_sum(6, [2, 3, 1, 2, 4, 3], 7) 2 >>> smallest_subarray_with_at_least_sum(5, [1, 2, 1, 1, 1], 10) -1 >>> smallest_subarray_with_at_least_sum(4, [2, 4, 7, 1], 7) 1 >>> smallest_subarray_with_at_least_sum(3, [1, 1, 1], 3) 3 >>> smallest_subarray_with_at_least_sum(7, [1, 2, 1, 2, 4, 3, 1], 7) 2 >>> smallest_subarray_with_at_least_sum(10, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 15) 2","solution":"def smallest_subarray_with_at_least_sum(N, thickness, T): Returns the length of the smallest contiguous subarray whose total thickness is at least T. If no such subarray is found, returns -1. left = 0 current_sum = 0 min_length = float('inf') for right in range(N): current_sum += thickness[right] while current_sum >= T: min_length = min(min_length, right - left + 1) current_sum -= thickness[left] left += 1 return min_length if min_length != float('inf') else -1"},{"question":"def filter_primes(lst): Takes a list of integers and returns a new list containing all the prime numbers from the original list, in the order they appeared. # Your code here def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def test_filter_primes(): assert filter_primes([2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [2, 3, 5, 7, 11] assert filter_primes([4, 6, 8, 9, 10]) == [] assert filter_primes([]) == [] assert filter_primes([-10, -5, 0, 1, 19, 23]) == [19, 23] assert filter_primes([11, 18, 19, 21, 23, 29]) == [11, 19, 23, 29] def test_filter_primes_with_only_primes(): assert filter_primes([2, 3, 5, 7, 11, 13, 17]) == [2, 3, 5, 7, 11, 13, 17] def test_filter_primes_with_no_primes(): assert filter_primes([4, 6, 8, 9, 10, 12, 15]) == [] def test_filter_primes_with_mixed_numbers(): assert filter_primes([2, 4, 6, 3, 7, 10, 13, 15]) == [2, 3, 7, 13] def test_filter_primes_large_list(): prime_numbers = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47] mixed_numbers = prime_numbers + [4, 6, 8, 9, 10, 12, 14, 15] assert filter_primes(mixed_numbers) == prime_numbers","solution":"def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def filter_primes(lst): Takes a list of integers and returns a new list containing all the prime numbers from the original list, in the order they appeared. return [x for x in lst if is_prime(x)]"},{"question":"def process_commands(commands: list) -> list: Processes a list of commands to manipulate a list of integers. Args: commands (list of str): List of commands to process. Returns: list of int: Output response for each 'PrintMax' command. >>> process_commands([\\"Insert 3\\", \\"PrintMax\\"]) [3] >>> process_commands([\\"Insert 3\\", \\"Insert 1\\", \\"PrintMax\\", \\"Delete 3\\", \\"PrintMax\\"]) [3, 1] >>> process_commands([\\"Insert 3\\", \\"Insert 1\\", \\"PrintMax\\", \\"Delete 3\\", \\"PrintMax\\", \\"Insert 5\\", \\"PrintMax\\"]) [3, 1, 5] >>> process_commands([\\"Insert 2\\"] * 100000 + [\\"PrintMax\\"]) [2] >>> process_commands([\\"Insert 4\\", \\"Delete 4\\", \\"PrintMax\\"]) [] >>> process_commands([\\"Insert 5\\", \\"Delete 3\\", \\"PrintMax\\"]) [5]","solution":"def process_commands(commands): Processes a list of commands to manipulate a list of integers. Args: commands (list of str): List of commands to process. Returns: list of int: Output response for each 'PrintMax' command. numbers = [] result = [] for command in commands: parts = command.split() if parts[0] == 'Insert': num = int(parts[1]) numbers.append(num) elif parts[0] == 'Delete': num = int(parts[1]) if num in numbers: numbers.remove(num) elif parts[0] == 'PrintMax': if numbers: result.append(max(numbers)) return result"},{"question":"def max_jewels_collected(n: int, m: int, grid: List[List[int]]) -> int: Determine the maximum number of jewels that can be collected in a journey from the top-left to the bottom-right corner of a grid, moving only right or down. >>> max_jewels_collected(3, 3, [ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 12 >>> max_jewels_collected(1, 1, [ ... [7] ... ]) 7 >>> max_jewels_collected(1, 4, [ ... [1, 2, 3, 4] ... ]) 10 >>> max_jewels_collected(4, 1, [ ... [1], ... [2], ... [3], ... [4] ... ]) 10 >>> max_jewels_collected(4, 4, [ ... [1, 2, 3, 4], ... [2, 3, 4, 5], ... [3, 4, 5, 6], ... [4, 5, 6, 7] ... ]) 28","solution":"def max_jewels_collected(n, m, grid): # Create a DP table to store the maximum jewels collected up to each cell. dp = [[0] * m for _ in range(n)] # Initialize the starting point dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for j in range(1, m): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill the first column (can only come from above) for i in range(1, n): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, n): for j in range(1, m): dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] return dp[n - 1][m - 1] # Example usage n = 3 m = 3 grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] print(max_jewels_collected(n, m, grid)) # Output: 12"},{"question":"def double_char(s: str) -> str: Returns a string where each character in the original string is repeated once. Parameters: s (str): The input string Returns: str: The transformed string with each character repeated once >>> double_char('String') 'SSttrriinngg' >>> double_char('Hello World!') 'HHeelllloo WWoorrlldd!!' >>> double_char('1234!_ ') '11223344!!__ '","solution":"def double_char(s): Returns a string where each character in the original string is repeated once. Parameters: s (str): The input string Returns: str: The transformed string with each character repeated once return ''.join([char * 2 for char in s])"},{"question":"from typing import List def longest_consecutive_subsequence(nums: List[int]) -> List[int]: Write a function that takes a list of integers and returns the longest consecutive subsequence. A consecutive subsequence is a sequence in which the elements are consecutive integers. Structure your solution to work efficiently with large arrays. >>> longest_consecutive_subsequence([100, 4, 200, 1, 3, 2]) == [1, 2, 3, 4] >>> longest_consecutive_subsequence([9, 1, 8, 2, 3, 7, 6]) == [1, 2, 3] or [6, 7, 8, 9] >>> longest_consecutive_subsequence([0, -1, -2, 2, 1, 5]) == [-2, -1, 0, 1, 2]","solution":"def longest_consecutive_subsequence(nums): Returns the longest consecutive subsequence from the list of integers. :param nums: List of integers :return: List of integers representing the longest consecutive subsequence if not nums: return [] nums_set = set(nums) longest_sequence = [] for num in nums: if num - 1 not in nums_set: # Start of a new sequence current_num = num current_sequence = [] while current_num in nums_set: current_sequence.append(current_num) current_num += 1 if len(current_sequence) > len(longest_sequence): longest_sequence = current_sequence return longest_sequence"},{"question":"from typing import List def can_form_palindrome(s: str) -> bool: Determine if the characters of the input string can be rearranged to form a palindrome. :param s: str - The input string consisting of lowercase letters :return: bool - True if the string can be rearranged to form a palindrome, False otherwise >>> can_form_palindrome(\\"carrace\\") True >>> can_form_palindrome(\\"daily\\") False def test_palindrome_possible_even_length(): assert can_form_palindrome(\\"carrace\\") == True def test_palindrome_possible_odd_length(): assert can_form_palindrome(\\"aabbccdde\\") == True def test_palindrome_not_possible(): assert can_form_palindrome(\\"daily\\") == False def test_single_character(): assert can_form_palindrome(\\"a\\") == True def test_all_unique_characters(): assert can_form_palindrome(\\"abcdefg\\") == False def test_mixed_counts(): assert can_form_palindrome(\\"aabbc\\") == True def test_empty_string(): assert can_form_palindrome(\\"\\") == True def test_two_characters_same(): assert can_form_palindrome(\\"aa\\") == True def test_two_characters_different(): assert can_form_palindrome(\\"ab\\") == False","solution":"def can_form_palindrome(s): Determine if the characters of the input string can be rearranged to form a palindrome. :param s: str - The input string consisting of lowercase letters :return: bool - True if the string can be rearranged to form a palindrome, False otherwise from collections import Counter # Count occurrences of each character char_count = Counter(s) # Calculate the number of characters with odd counts odd_frequency_count = sum(1 for count in char_count.values() if count % 2 != 0) # At most one character with an odd frequency is allowed return odd_frequency_count <= 1"},{"question":"from typing import List def check_permutation_in_substrings(words: List[str], s: str) -> bool: Given a list of strings words and a target string s, determine whether any permutation of the target s can be found as a substring in any of the strings in the words list. >>> check_permutation_in_substrings([\\"coding\\", \\"assessment\\", \\"example\\"], \\"codi\\") True >>> check_permutation_in_substrings([\\"interview\\", \\"preparation\\", \\"questions\\"], \\"viewint\\") False >>> check_permutation_in_substrings([\\"abc\\", \\"def\\", \\"ghi\\"], \\"cbad\\") False >>> check_permutation_in_substrings([\\"bat\\", \\"tab\\", \\"batman\\"], \\"tab\\") True def test_check_permutation_in_substrings_1(): words = [\\"coding\\", \\"assessment\\", \\"example\\"] s = \\"codi\\" assert check_permutation_in_substrings(words, s) == True def test_check_permutation_in_substrings_2(): words = [\\"interview\\", \\"preparation\\", \\"questions\\"] s = \\"viewint\\" assert check_permutation_in_substrings(words, s) == False def test_check_permutation_in_substrings_3(): words = [\\"abc\\", \\"def\\", \\"ghi\\"] s = \\"cbad\\" assert check_permutation_in_substrings(words, s) == False def test_check_permutation_in_substrings_4(): words = [\\"bat\\", \\"tab\\", \\"batman\\"] s = \\"tab\\" assert check_permutation_in_substrings(words, s) == True def test_check_permutation_in_substrings_multiple_occurrences(): words = [\\"abcabcabc\\", \\"defdef\\", \\"ghighi\\"] s = \\"cab\\" assert check_permutation_in_substrings(words, s) == True def test_check_permutation_in_substrings_no_matching_permutation(): words = [\\"abcdefgh\\", \\"ijklmnop\\", \\"qrstuvwx\\"] s = \\"xyz\\" assert check_permutation_in_substrings(words, s) == False","solution":"from collections import Counter def check_permutation_in_substrings(words, s): s_counter = Counter(s) s_length = len(s) for word in words: for i in range(len(word) - s_length + 1): if Counter(word[i:i + s_length]) == s_counter: return True return False"},{"question":"def describe_box(number_of_oranges: int) -> str: Returns a description of the number of oranges in the box based on the given rules. >>> describe_box(1) \\"Just a few\\" >>> describe_box(4) \\"Just a few\\" >>> describe_box(5) \\"A decent amount\\" >>> describe_box(19) \\"A decent amount\\" >>> describe_box(20) \\"Quite a lot\\" >>> describe_box(49) \\"Quite a lot\\" >>> describe_box(50) \\"A huge amount\\" >>> describe_box(99) \\"A huge amount\\" >>> describe_box(100) \\"An abundance\\"","solution":"def describe_box(number_of_oranges): Returns a description of the number of oranges in the box. if number_of_oranges < 5: return \\"Just a few\\" elif number_of_oranges < 20: return \\"A decent amount\\" elif number_of_oranges < 50: return \\"Quite a lot\\" elif number_of_oranges < 100: return \\"A huge amount\\" else: # number_of_oranges == 100 return \\"An abundance\\""},{"question":"def organize_marathon(runners): Organize runners into distance categories and age brackets. Args: runners (list of tuples): Each tuple contains (name, age, distance). Returns: dict: A dictionary categorizing runners by their distance and age. Example: >>> runners = [ ... ('Alice', 25, '5km'), ... ('Bob', 17, '10km'), ... ('Charlie', 32, 'marathon'), ... ('David', 41, '5km'), ... ('Eve', 39, '10km'), ... ('Frank', 15, 'marathon') ... ] >>> organize_marathon(runners) { '5km': {'total_runners': 2, 'age_brackets': {'under_18': 0, '18_to_40': 1, 'above_40': 1}}, '10km': {'total_runners': 2, 'age_brackets': {'under_18': 1, '18_to_40': 1, 'above_40': 0}}, 'marathon': {'total_runners': 2, 'age_brackets': {'under_18': 1, '18_to_40': 1, 'above_40': 0}} }","solution":"def organize_marathon(runners): Organize runners into distance categories and age brackets. Args: runners (list of tuples): Each tuple contains (name, age, distance). Returns: dict: A dictionary categorizing runners by their distance and age. result = { '5km': {'total_runners': 0, 'age_brackets': {'under_18': 0, '18_to_40': 0, 'above_40': 0}}, '10km': {'total_runners': 0, 'age_brackets': {'under_18': 0, '18_to_40': 0, 'above_40': 0}}, 'marathon': {'total_runners': 0, 'age_brackets': {'under_18': 0, '18_to_40': 0, 'above_40': 0}} } for _, age, distance in runners: if distance in result: result[distance]['total_runners'] += 1 if age < 18: result[distance]['age_brackets']['under_18'] += 1 elif 18 <= age <= 40: result[distance]['age_brackets']['18_to_40'] += 1 else: result[distance]['age_brackets']['above_40'] += 1 return result"},{"question":"def count_subarrays_with_product_less_than_k(arr: List[int], k: int) -> int: Implement a function that calculates the number of contiguous subarrays such that the product of their elements is less than a given integer k. Args: arr (List[int]): A list of positive integers. k (int): The target product threshold. Returns: int: Count of subarrays with product less than k. >>> count_subarrays_with_product_less_than_k([10, 5, 2, 6], 100) 8 >>> count_subarrays_with_product_less_than_k([1, 2, 3], 0) 0 pass","solution":"def count_subarrays_with_product_less_than_k(arr, k): if k <= 1: return 0 left = 0 product = 1 count = 0 for right in range(len(arr)): product *= arr[right] while product >= k and left <= right: product //= arr[left] left += 1 count += right - left + 1 return count"},{"question":"def romanToInt(s: str) -> int: Convert a roman numeral to an integer. >>> romanToInt(\\"III\\") == 3 >>> romanToInt(\\"IV\\") == 4 >>> romanToInt(\\"IX\\") == 9 >>> romanToInt(\\"LVIII\\") == 58 >>> romanToInt(\\"MCMXCIV\\") == 1994","solution":"def romanToInt(s): Convert a roman numeral to an integer. :param s: A string representing roman numeral. :return: An integer representing the numeric value of the roman numeral. roman_to_int = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 } integer_value = 0 i = 0 while i < len(s): # If this is the subtractive combination if i + 1 < len(s) and roman_to_int[s[i]] < roman_to_int[s[i + 1]]: integer_value += roman_to_int[s[i + 1]] - roman_to_int[s[i]] i += 2 else: integer_value += roman_to_int[s[i]] i += 1 return integer_value"},{"question":"def process_bookings(bookings: str) -> str: Given a list of bookings formatted as a string of comma-separated values, where each booking is specified by the passenger's name, departure city, and destination city in the form \\"Name_DepartureCity_DestinationCity\\", process these bookings by removing duplicates and sorting the bookings by the passenger's name. If two bookings have the same passenger name, sort them by the departure city alphabetically. >>> process_bookings(\\"John_Dallas_NewYork, Alice_SF_LA, Bob_Boston_Chicago, John_Dallas_NewYork, Eve_Chicago_Dallas, Alice_SF_LA, Bob_NewYork_LA\\") \\"Alice_SF_LA, Bob_Boston_Chicago, Bob_NewYork_LA, Eve_Chicago_Dallas, John_Dallas_NewYork\\" >>> process_bookings(\\"Carla_LA_NY, Andy_TX_CA, Carla_LA_NY, Andy_NY_TX, Andy_TX_CA, Carla_CA_TX\\") \\"Andy_NY_TX, Andy_TX_CA, Carla_CA_TX, Carla_LA_NY\\"","solution":"def process_bookings(bookings: str) -> str: # Split the input string into individual bookings booking_list = bookings.split(\\", \\") # Remove duplicates by converting to a set first, then back to a list booking_list = list(set(booking_list)) # Sort the bookings first by passenger's name and then by departure city booking_list.sort(key=lambda booking: booking.split(\\"_\\")) # Join the sorted bookings back into a single string return \\", \\".join(booking_list)"},{"question":"def combination_sum(nums: List[int], target: int) -> List[List[int]]: Returns all unique combinations of integers from nums that add up to the target. Each number in nums may only be used once in each combination. The solution set must not contain duplicate combinations. >>> combination_sum([2, 3, 6, 7], 7) [[7]] >>> combination_sum([2, 3, 5], 8) [[3, 5]] >>> combination_sum([2, 3, 6, 7, 10], 10) [[3, 7], [10]] >>> combination_sum([1, 2, 3, 4, 5], 5) [[1, 4], [2, 3], [5]] # Your code here # Example test cases print(combination_sum([2, 3, 6, 7], 7)) # Expected output: [[7]] print(combination_sum([2, 3, 5], 8)) # Expected output: [[3, 5]] print(combination_sum([2, 3, 6, 7, 10], 10)) # Expected output: [[3, 7], [10]] print(combination_sum([1, 2, 3, 4, 5], 5)) # Expected output: [[1, 4], [2, 3], [5]]","solution":"def combination_sum(nums, target): Returns all unique combinations of integers from nums that add up to the target. def backtrack(start, target, path): if target == 0: result.append(path) return if target < 0: return for i in range(start, len(nums)): if i > start and nums[i] == nums[i-1]: # skip duplicates continue backtrack(i + 1, target - nums[i], path + [nums[i]]) nums.sort() # sort to handle duplicates result = [] backtrack(0, target, []) return result"},{"question":"def final_clock_time(operations): Manipulates a digital clock display based on given operations and returns the final time in HH:MM:SS format. >>> final_clock_time([['hours', 2]]) '02:00:00' >>> final_clock_time([['minutes', 90]]) '01:30:00' >>> final_clock_time([['seconds', 3661]]) '01:01:01' >>> final_clock_time([['hours', 1], ['minutes', 120], ['seconds', -7200]]) '01:00:00' >>> final_clock_time([['hours', 23], ['minutes', 59], ['seconds', 60]]) '00:00:00' >>> final_clock_time([['hours', 2], ['minutes', 30], ['seconds', 45]]) '02:30:45' >>> final_clock_time([['hours', 25]]) '01:00:00' >>> final_clock_time([['minutes', 1500]]) '01:00:00' >>> final_clock_time([['seconds', 90000]]) '01:00:00' >>> final_clock_time([['hours', -1]]) '23:00:00' >>> final_clock_time([['minutes', -60]]) '23:00:00' >>> final_clock_time([['seconds', -3600]]) '23:00:00' >>> final_clock_time([['seconds', -86400]]) '00:00:00'","solution":"def final_clock_time(operations): Manipulates a digital clock display based on given operations and returns the final time in HH:MM:SS format. from datetime import timedelta total_seconds = 0 for op, val in operations: if op == \\"hours\\": total_seconds += val * 3600 elif op == \\"minutes\\": total_seconds += val * 60 elif op == \\"seconds\\": total_seconds += val total_seconds %= 86400 # Total seconds in a day (24*60*60) hours = (total_seconds // 3600) % 24 total_seconds %= 3600 minutes = total_seconds // 60 seconds = total_seconds % 60 return f\\"{hours:02}:{minutes:02}:{seconds:02}\\""},{"question":"def restore_season_towers(initial_positions, movements): Restore positions of crystals in Season Towers after applying series of movements. Parameters: initial_positions (list of list of int): List representing the initial (x, y) positions of crystals. movements (list of list of int): List of movements where each movement is represented by [direction, distance]. Directions are mapped to the following values: 0 = North, 1 = East, 2 = South, 3 = West Returns: list: Sorted final positions of crystals primarily by x-coordinate and secondarily by y-coordinate. Example: >>> initial_positions = [[2, 3], [-1, -1], [0, 0]] >>> movements = [[2, 1], [1, 2], [0, 3], [3, 4]] >>> restore_season_towers(initial_positions, movements) [[-3, 1], [-2, 2], [0, 5]] # Your implementation here","solution":"def restore_season_towers(initial_positions, movements): # Define the movement directions directions = { 0: (0, 1), # North 1: (1, 0), # East 2: (0, -1), # South 3: (-1, 0) # West } # Apply all movements to each crystal for movement in movements: direction, distance = movement dx, dy = directions[direction] # Update each crystal's position for i in range(len(initial_positions)): initial_positions[i][0] += dx * distance initial_positions[i][1] += dy * distance # Sort the final positions primarily by x-coordinate, secondarily by y-coordinate final_positions = sorted(initial_positions, key=lambda pos: (pos[0], pos[1])) return final_positions # Example usage: initial_positions = [[2, 3], [-1, -1], [0, 0]] movements = [[2, 1], [1, 2], [0, 3], [3, 4]] print(restore_season_towers(initial_positions, movements)) # Output should be [[-3, 1], [-2, 2], [0, 5]]"},{"question":"from typing import List def findDuplicates(nums: List[int]) -> List[int]: Returns a list of integers that appear more than once in the input list, sorted in ascending order. Args: nums (List[int]): The input list of integers. Returns: List[int]: A list of duplicated integers sorted in ascending order. Examples: >>> findDuplicates([4, 3, 2, 7, 8, 2, 3, 1]) [2, 3] >>> findDuplicates([1, 2, 3, 4, 5]) [] # Example usage: print(findDuplicates([4, 3, 2, 7, 8, 2, 3, 1])) # Output: [2, 3] def test_findDuplicates_example_case(): assert findDuplicates([4, 3, 2, 7, 8, 2, 3, 1]) == [2, 3] def test_findDuplicates_no_duplicates(): assert findDuplicates([1, 2, 3, 4, 5]) == [] def test_findDuplicates_all_duplicates(): assert findDuplicates([2, 2, 2, 2, 2]) == [2] def test_findDuplicates_mixed_with_duplicates(): assert findDuplicates([1, 2, 3, 1, 2, 3, 4, 5, 6, 7, 8, 9, 9, 9]) == [1, 2, 3, 9] def test_findDuplicates_with_negative_numbers(): assert findDuplicates([-1, -2, -2, -3, -1, -4]) == [-2, -1] def test_findDuplicates_single_element(): assert findDuplicates([1]) == [] def test_findDuplicates_empty_list(): assert findDuplicates([]) == []","solution":"def findDuplicates(nums): Returns a list of integers that appear more than once in the input list, sorted in ascending order. Args: nums (List[int]): The input list of integers. Returns: List[int]: A list of duplicated integers sorted in ascending order. from collections import Counter # Count occurrences of each number in the list counts = Counter(nums) # Extract numbers that have a count greater than 1 duplicates = [num for num, count in counts.items() if count > 1] # Return the sorted list of duplicates return sorted(duplicates)"},{"question":"from typing import List def maximum_product_of_three(nums: List[int]) -> int: Given an integer array nums, return the largest product that can be made by multiplying any three integers from the array. >>> maximum_product_of_three([1, 2, 3]) 6 >>> maximum_product_of_three([1, 2, 3, 4]) 24 >>> maximum_product_of_three([-10, -10, 5, 2]) 500 >>> maximum_product_of_three([1, 2, 3, -4, 5]) 30","solution":"def maximum_product_of_three(nums): Returns the largest product that can be made by multiplying any three integers from the array. nums.sort() # The largest product can be one of the following: # 1. Product of the three largest numbers. # 2. Product of the two smallest numbers (which could be negative) and the largest number. return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])"},{"question":"import string def is_pangram(s: str) -> bool: Checks if the string contains all the letters of the English alphabet at least once. The function ignores case and any non-alphabet characters. :param s: The input string to be checked :return: True if the string is a pangram, False otherwise >>> is_pangram('The quick brown fox jumps over the lazy dog') True >>> is_pangram('Hello, World!') False >>> is_pangram('Pack my box with five dozen liquor jugs') True","solution":"import string def is_pangram(s): Checks if the string contains all the letters of the English alphabet at least once. The function ignores case and any non-alphabet characters. :param s: The input string to be checked :return: True if the string is a pangram, False otherwise alphabet = set(string.ascii_lowercase) s = s.lower() return set(filter(lambda x: x in alphabet, s)) == alphabet"},{"question":"from typing import List def is_robot_bounded(instructions: str) -> bool: Determines if the robot returns to the starting point (0, 0) after executing the sequence of commands at least once. Args: instructions (str): A string of commands comprising 'G', 'L', and 'R'. Returns: bool: True if the robot returns to the starting point, False otherwise. Examples: >>> is_robot_bounded(\\"GGLLGG\\") True >>> is_robot_bounded(\\"GG\\") False >>> is_robot_bounded(\\"GL\\") True >>> is_robot_bounded(\\"LLLL\\") True >>> is_robot_bounded(\\"RRRR\\") True >>> is_robot_bounded(\\"GLGLGLG\\") True >>> is_robot_bounded(\\"GRGRGRG\\") True >>> is_robot_bounded(\\"\\") True >>> is_robot_bounded(\\"G\\") False >>> is_robot_bounded(\\"L\\") True >>> is_robot_bounded(\\"R\\") True pass","solution":"def is_robot_bounded(instructions): Determines if the robot returns to the starting point (0, 0) after executing the sequence of commands at least once. # Initial state x, y = 0, 0 # Starting position direction_index = 0 # 0-North, 1-East, 2-South, 3-West # Directions corresponding to right turns directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] for instruction in instructions: if instruction == 'G': # Move forward x += directions[direction_index][0] y += directions[direction_index][1] elif instruction == 'L': # Turn left direction_index = (direction_index - 1) % 4 elif instruction == 'R': # Turn right direction_index = (direction_index + 1) % 4 # After one loop, the robot should be back at (0, 0) or facing in a different direction return (x == 0 and y == 0) or direction_index != 0"},{"question":"def navigate_districts(test_cases): Simulate navigation process in a tree-shaped city and output the sequence of districts visited. >>> navigate_districts([(5, 1, 5, [(1, 2), (1, 3), (2, 4), (2, 5)])]) [[1, 2, 5]] >>> navigate_districts([(2, 1, 2, [(1, 2)])]) [[1, 2]] def parse_input(input_string): Parse input string to extract test cases. >>> parse_input(\\"1n5 1 5n1 2n1 3n2 4n2 5n\\") [(5, 1, 5, [(1, 2), (1, 3), (2, 4), (2, 5)])] def format_output(results): Format the output results as a string. >>> format_output([[1, 2, 5]]) \\"1 2 5\\" def main(input_string): Main function to receive input, perform navigation, and produce output. >>> main(\\"1n5 1 5n1 2n1 3n2 4n2 5n\\") '1 2 5'","solution":"def navigate_districts(test_cases): def dfs(current, target, graph, visited, path): if current == target: return True visited.add(current) for neighbor in sorted(graph[current]): if neighbor not in visited: path.append(neighbor) if dfs(neighbor, target, graph, visited, path): return True path.pop() return False results = [] for test_case in test_cases: M, S, T, roads = test_case graph = {i: [] for i in range(1, M + 1)} for U, V in roads: graph[U].append(V) graph[V].append(U) path = [S] visited = set() dfs(S, T, graph, visited, path) results.append(path) return results def parse_input(input_string): input_lines = input_string.strip().split('n') K = int(input_lines[0]) test_cases = [] line_index = 1 for _ in range(K): M, S, T = map(int, input_lines[line_index].split()) roads = [tuple(map(int, input_lines[line_index + i + 1].split())) for i in range(M - 1)] test_cases.append((M, S, T, roads)) line_index += M return test_cases def format_output(results): return \\"n\\".join(\\" \\".join(map(str, result)) for result in results) # Function to receive input and produce output def main(input_string): test_cases = parse_input(input_string) results = navigate_districts(test_cases) return format_output(results)"},{"question":"def is_toeplitz_matrix(matrix: List[List[int]]) -> bool: Determine if a given matrix is a Toeplitz matrix. A matrix is Toeplitz if every diagonal from top-left to bottom-right has the same elements. >>> is_toeplitz_matrix([ [1, 2, 3, 4], [5, 1, 2, 3], [6, 5, 1, 2], [7, 6, 5, 1] ]) True >>> is_toeplitz_matrix([ [1, 2, 3, 4], [5, 1, 9, 3], [6, 5, 1, 2], [7, 6, 5, 9] ]) False","solution":"def is_toeplitz_matrix(matrix): Determine if a given matrix is a Toeplitz matrix. A matrix is Toeplitz if every diagonal from top-left to bottom-right has the same elements. rows = len(matrix) cols = len(matrix[0]) for row in range(1, rows): for col in range(1, cols): if matrix[row][col] != matrix[row - 1][col - 1]: return False return True"},{"question":"def longest_substring_without_repeating_characters(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> longest_substring_without_repeating_characters(\\"abcabcbb\\") 3 >>> longest_substring_without_repeating_characters(\\"bbbbb\\") 1 >>> longest_substring_without_repeating_characters(\\"pwwkew\\") 3 >>> longest_substring_without_repeating_characters(\\"\\") 0 >>> longest_substring_without_repeating_characters(\\" \\") 1 >>> longest_substring_without_repeating_characters(\\"au\\") 2 >>> longest_substring_without_repeating_characters(\\"aab\\") 2 >>> longest_substring_without_repeating_characters(\\"dvdf\\") 3 >>> longest_substring_without_repeating_characters(\\"aa\\") 1 >>> longest_substring_without_repeating_characters(\\"aaa\\") 1 >>> longest_substring_without_repeating_characters(\\"abcdefg\\") 7 >>> longest_substring_without_repeating_characters(\\"abcdecfgh\\") 6","solution":"def longest_substring_without_repeating_characters(s: str) -> int: Returns the length of the longest substring without repeating characters. char_map = {} left = max_length = 0 for right, char in enumerate(s): if char in char_map and char_map[char] >= left: left = char_map[char] + 1 char_map[char] = right max_length = max(max_length, right - left + 1) return max_length"},{"question":"def parse_sku(sku): Parses a SKU string to extract the main SKU and tags. Parameters: sku (str): The SKU string to parse. Returns: tuple: A tuple where the first element is the main SKU (str), and the second element is a dictionary of tags. Example: >>> parse_sku(\\"ABC123:color-red,size-medium,material-cotton\\") ('ABC123', {'color': 'red', 'size': 'medium', 'material': 'cotton'}) >>> parse_sku(\\"XY120:size-large,discount-20\\") ('XY120', {'size': 'large', 'discount': '20'}) >>> parse_sku(\\"PQ456\\") ('PQ456', {}) >>> parse_sku(\\"DET789:brand-nike,color-black\\") ('DET789', {'brand': 'nike', 'color': 'black'})","solution":"def parse_sku(sku): Parses a SKU string to extract the main SKU and tags. Parameters: sku (str): The SKU string to parse. Returns: tuple: A tuple where the first element is the main SKU (str), and the second element is a dictionary of tags. if ':' in sku: main_sku, tags_str = sku.split(':', 1) tags_list = tags_str.split(',') tags = {tag.split('-')[0]: tag.split('-')[1] for tag in tags_list} else: main_sku = sku tags = {} return main_sku, tags"},{"question":"def total_duration(durations): Takes a list of integers representing durations in minutes and returns the total duration in the format \\"X hours Y minutes\\". >>> total_duration([30, 45, 120, 180, 15]) == \\"6 hours 30 minutes\\" >>> total_duration([60, 75, 80]) == \\"3 hours 55 minutes\\" >>> total_duration([60, 60, 60]) == \\"3 hours 0 minutes\\" >>> total_duration([10, 20, 5]) == \\"0 hours 35 minutes\\" >>> total_duration([30, 30]) == \\"1 hours 0 minutes\\" >>> total_duration([90, 45, 30, 75]) == \\"4 hours 0 minutes\\" >>> total_duration([]) == \\"0 hours 0 minutes\\"","solution":"def total_duration(durations): Takes a list of integers representing durations in minutes and returns the total duration in the format \\"X hours Y minutes\\". total_minutes = sum(durations) hours = total_minutes // 60 minutes = total_minutes % 60 return f\\"{hours} hours {minutes} minutes\\""},{"question":"def are_identifiers_unique(N: int, identifiers: List[str]) -> str: Determines if the given set of book identifiers is unique. Parameters: N (int): the number of book identifiers. identifiers (list of str): the list of book identifier strings. Returns: str: \\"YES\\" if all identifiers are unique, otherwise \\"NO\\". >>> are_identifiers_unique(3, [\\"MA5KDL\\", \\"Y6MN8T\\", \\"D3F4G7\\"]) == \\"YES\\" >>> are_identifiers_unique(4, [\\"B1NJK2\\", \\"A2B3K9\\", \\"B1NJK2\\", \\"Z7Y8X6\\"]) == \\"NO\\"","solution":"def are_identifiers_unique(N, identifiers): Determines if the given set of book identifiers is unique. Parameters: N (int): the number of book identifiers. identifiers (list of str): the list of book identifier strings. Returns: str: \\"YES\\" if all identifiers are unique, otherwise \\"NO\\". unique_identifiers = set(identifiers) if len(unique_identifiers) == N: return \\"YES\\" else: return \\"NO\\""},{"question":"def primes_less_than(n: int) -> List[int]: Returns a list of all prime numbers less than the given integer n. >>> primes_less_than(10) [2, 3, 5, 7] >>> primes_less_than(20) [2, 3, 5, 7, 11, 13, 17, 19] >>> primes_less_than(5) [2, 3] # Complete the function to find all prime numbers less than n","solution":"def primes_less_than(n): Returns a list of all prime numbers less than n. if n <= 2: return [] primes = [] for num in range(2, n): is_prime = True for i in range(2, int(num ** 0.5) + 1): if num % i == 0: is_prime = False break if is_prime: primes.append(num) return primes"},{"question":"def find_repeating_element(arr: List[int]) -> Union[int, None]: Returns the first repeating element in the array. If no element repeats, returns None. Parameters: arr (list of int): The input array. Returns: int or None: The first repeating element or None if no element repeats. Examples: >>> find_repeating_element([3, 5, -2, 3, 7, 1]) 3 >>> find_repeating_element([1, 2, 3, 4, 5]) None >>> find_repeating_element([4, 5, 6, 7, 4, 8, 9]) 4 >>> find_repeating_element([0, -1, 2, -3, 4, -1, 5]) -1","solution":"def find_repeating_element(arr): Returns the first repeating element in the array. If no element repeats, returns None. Parameters: arr (list of int): The input array. Returns: int or None: The first repeating element or None if no element repeats. seen = set() for number in arr: if number in seen: return number seen.add(number) return None"},{"question":"def print_triangle(n: int) -> None: Prints an equilateral triangle with n rows, aligned centrally. Args: n (int): The number of rows in the triangle. Example: >>> print_triangle(3) * *** ***** >>> print_triangle(5) * *** ***** ******* *********","solution":"def print_triangle(n): Prints an equilateral triangle with n rows. for i in range(1, n + 1): spaces = ' ' * (n - i) stars = '*' * (2 * i - 1) print(spaces + stars + spaces)"},{"question":"from typing import List def solve(nums: List[int], target: int) -> bool: Determines if there are two distinct elements in the array that add up to the target sum. >>> solve([2, 7, 11, 15], 9) True >>> solve([3, 2, 4], 6) True >>> solve([1, 2, 3], 7) False >>> solve([1, 2, 3, 4, 5], 10) False >>> solve([], 5) False >>> solve([1], 1) False >>> solve([-1, -2, -3, -4], -6) True >>> solve([-1, -2, -3, -4], -8) False >>> solve([-1, 1, 3, -3], 0) True >>> solve([-1, 1, 3, -3], 5) False","solution":"def solve(nums, target): Determines if there are two distinct elements in the array that add up to the target sum. Args: nums (list): List of integers. target (int): Target sum. Returns: bool: True if there are two distinct elements that add up to target, False otherwise. seen = set() for num in nums: if (target - num) in seen: return True seen.add(num) return False"},{"question":"from typing import List def contains_duplicates(nums: List[int]) -> bool: Returns True if there are any duplicates in the list, otherwise returns False. >>> contains_duplicates([1, 2, 3, 4, 5]) False >>> contains_duplicates([1, 2, 3, 2, 5]) True >>> contains_duplicates([]) False >>> contains_duplicates([1]) False >>> contains_duplicates([2, 2, 2, 2, 2]) True >>> contains_duplicates([-1000000000, 1000000000]) False >>> contains_duplicates([1000000000, 1000000000]) True >>> contains_duplicates([1, -1, 2, -2, 3, 3]) True >>> contains_duplicates([1, -1, 2, -2, 3, 4]) False","solution":"from typing import List def contains_duplicates(nums: List[int]) -> bool: Returns True if there are any duplicates in the list, otherwise returns False. seen = set() for num in nums: if num in seen: return True seen.add(num) return False"},{"question":"from typing import List from functools import cmp_to_key def largest_number(nums: List[int]) -> str: Given a list of non-negative integers, arrange them to form the largest possible integer. Parameters: nums (list): A list of non-negative integers Returns: str: The largest possible integer as a string >>> largest_number([3, 30, 34, 5, 9]) '9534330' >>> largest_number([0, 0, 0]) '0' >>> largest_number([824, 938, 1399, 5607, 6973, 5703, 9609, 4398, 8247]) '9609938824824769735703560743981399' >>> largest_number([12, 121]) '12121' >>> largest_number([5]) '5' >>> largest_number([3, 30, 34, 5]) '534330'","solution":"from functools import cmp_to_key def largest_number(nums): Given a list of non-negative integers, arrange them to form the largest possible integer. Parameters: nums (list): A list of non-negative integers Returns: str: The largest possible integer as a string # Convert all numbers to strings nums = list(map(str, nums)) # Custom comparator function def compare(x, y): if x + y > y + x: return -1 elif x + y < y + x: return 1 else: return 0 # Sort numbers using the custom comparator nums.sort(key=cmp_to_key(compare)) # Join and return the result, taking care of edge case with leading zeroes largest_num = ''.join(nums) return '0' if largest_num[0] == '0' else largest_num"},{"question":"def maximizeDifference(nums: List[int]) -> List[int]: Given a list of integers, sort the list in alternating high and low order such that the first integer is the largest, the second is the smallest, the third is the second largest, and so on. >>> maximizeDifference([4, 3, 2, 1]) [4, 1, 3, 2] >>> maximizeDifference([10, 5, 3, 8, 9, 2]) [10, 2, 9, 3, 8, 5] >>> maximizeDifference([-1, -2, -3, -4]) [-1, -4, -2, -3]","solution":"def maximizeDifference(nums): Returns the list sorted in alternating high and low order. The first integer is the largest, the second is the smallest, the third is the second largest, and so on. nums.sort() result = [] while nums: if nums: result.append(nums.pop(-1)) # largest if nums: result.append(nums.pop(0)) # smallest return result"},{"question":"def mergeAndSort(list1, list2): Merges two lists of integers and returns a sorted list in non-decreasing order. Parameters: list1 (list): First list of integers. list2 (list): Second list of integers. Returns: list: Sorted list containing all elements from list1 and list2. Examples: >>> mergeAndSort([3, 1, 4], [4, 6, 5]) [1, 3, 4, 4, 5, 6] >>> mergeAndSort([], [1, 2, 3]) [1, 2, 3] >>> mergeAndSort([1, 1, 1], [1, 1, 1]) [1, 1, 1, 1, 1, 1] >>> mergeAndSort([42], [42]) [42, 42] # Your code here","solution":"def mergeAndSort(list1, list2): Merges two lists and returns a sorted list in non-decreasing order. Parameters: list1 (list): First list of integers. list2 (list): Second list of integers. Returns: list: Sorted list containing all elements from list1 and list2. merged_list = list1 + list2 merged_list.sort() return merged_list"},{"question":"def numClosedIslands(grid: List[List[int]]) -> int: Find the number of closed islands in a 2D grid. A closed island is surrounded by water and not connected to the boundary. >>> numClosedIslands([ ... [1, 0, 1, 0, 1, 0], ... [0, 0, 0, 1, 1, 0], ... [1, 1, 0, 1, 0, 1], ... [0, 1, 1, 0, 1, 1], ... [0, 0, 1, 1, 0, 1], ... [1, 1, 0, 1, 0, 1]]) 2 >>> numClosedIslands([ ... [1, 1, 1, 1], ... [1, 0, 0, 1], ... [1, 0, 0, 1], ... [1, 1, 1, 1]]) 1","solution":"def numClosedIslands(grid): def dfs(x, y): if x < 0 or x >= m or y < 0 or y >= n: return False if grid[x][y] == 1: return True grid[x][y] = 1 # mark as visited up = dfs(x - 1, y) down = dfs(x + 1, y) left = dfs(x, y - 1) right = dfs(x, y + 1) return up and down and left and right if not grid: return 0 m, n = len(grid), len(grid[0]) closed_islands = 0 for i in range(1, m - 1): for j in range(1, n - 1): if grid[i][j] == 0: if dfs(i, j): closed_islands += 1 return closed_islands"},{"question":"from typing import List import heapq def flood_fill_time(height_grid: List[List[int]]) -> int: Determines the minimum time required for water to fill the entire grid starting from (0, 0). >>> flood_fill_time([[1, 2, 2], [3, 8, 2], [3, 4, 5]]) 5 >>> flood_fill_time([[1]]) 1 >>> flood_fill_time([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 9 >>> flood_fill_time([[3, 3, 3], [3, 3, 3], [3, 3, 3]]) 3 >>> flood_fill_time([[8, 6, 7], [5, 3, 2], [4, 1, 9]]) 9 def test_example_case(): grid = [ [1, 2, 2], [3, 8, 2], [3, 4, 5] ] assert flood_fill_time(grid) == 5 def test_single_cell(): grid = [[1]] assert flood_fill_time(grid) == 1 def test_increasing_heights(): grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert flood_fill_time(grid) == 9 def test_plateau(): grid = [ [3, 3, 3], [3, 3, 3], [3, 3, 3] ] assert flood_fill_time(grid) == 3 def test_varied_heights(): grid = [ [8, 6, 7], [5, 3, 2], [4, 1, 9] ] assert flood_fill_time(grid) == 9 def test_large_grid(): grid = [list(range(1000))] * 1000 assert flood_fill_time(grid) == 999 # the max height in the last cell of the increasing grid","solution":"from typing import List import heapq def flood_fill_time(height_grid: List[List[int]]) -> int: n = len(height_grid) min_heap = [(height_grid[0][0], 0, 0)] visited = set() visited.add((0, 0)) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] max_height = 0 while min_heap: height, x, y = heapq.heappop(min_heap) max_height = max(max_height, height) if x == n - 1 and y == n - 1: return max_height for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited: visited.add((nx, ny)) heapq.heappush(min_heap, (height_grid[nx][ny], nx, ny)) return -1 # if somehow the grid is not valid, but based on constraints, it should always be valid."},{"question":"class Matrix: def __init__(self, grid): self.grid = grid def __repr__(self): return f\\"Matrix({self.grid})\\" def add(self, other): Add two matrices of the same dimensions. >>> Matrix([[1, 2], [3, 4]]).add(Matrix([[5, 6], [7, 8]])) Matrix([[6, 8], [10, 12]]) >>> Matrix([[1, 2], [3, 4]]).add(Matrix([[5, 6, 7], [8, 9, 10]])) Traceback (most recent call last): ... ValueError: Matrices must have the same dimensions to be added. def multiply(self, other): Multiply two matrices where the number of columns in the first is equal to the number of rows in the second. >>> Matrix([[1, 2, 3], [4, 5, 6]]).multiply(Matrix([[7, 8], [9, 10], [11, 12]])) Matrix([[58, 64], [139, 154]]) >>> Matrix([[1, 2], [3, 4]]).multiply(Matrix([[5, 6, 7]])) Traceback (most recent call last): ... ValueError: Number of columns in first matrix must be equal to number of rows in second matrix to multiply.","solution":"class Matrix: def __init__(self, grid): self.grid = grid def __repr__(self): return f\\"Matrix({self.grid})\\" def add(self, other): if len(self.grid) != len(other.grid) or len(self.grid[0]) != len(other.grid[0]): raise ValueError(\\"Matrices must have the same dimensions to be added.\\") result = [] for row in range(len(self.grid)): result_row = [] for col in range(len(self.grid[row])): result_row.append(self.grid[row][col] + other.grid[row][col]) result.append(result_row) return Matrix(result) def multiply(self, other): if len(self.grid[0]) != len(other.grid): raise ValueError(\\"Number of columns in first matrix must be equal to number of rows in second matrix to multiply.\\") result = [] for i in range(len(self.grid)): result_row = [] for j in range(len(other.grid[0])): cell_sum = 0 for k in range(len(self.grid[0])): cell_sum += self.grid[i][k] * other.grid[k][j] result_row.append(cell_sum) result.append(result_row) return Matrix(result)"},{"question":"def infected_computers(t: int, test_cases: List[Tuple[int, List[List[int]]]]) -> List[int]: Determine the number of infected computers after the virus has finished spreading. Args: t (int): the number of test cases. test_cases (List[Tuple[int, List[List[int]]]]): a list containing the number of computers and the matrix M for each test case. Returns: List[int]: a list of integers representing the number of infected computers for each test case. Example: >>> infected_computers(2, [ ... (3, [[0, 1, 0], [1, 0, 1], [0, 1, 0]]), ... (4, [[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]]) ... ]) [3, 4]","solution":"def infected_computers(t, test_cases): results = [] for test in test_cases: n, matrix = test infected = [False] * n infected[0] = True queue = [0] while queue: current = queue.pop(0) for i in range(n): if matrix[current][i] == 1 and not infected[i]: infected[i] = True queue.append(i) results.append(sum(infected)) return results"},{"question":"from typing import List def sum_except_self(lst: List[int]) -> List[int]: Takes a list of integers and returns a new list where each integer is replaced by the sum of all integers in the input list except itself. >>> sum_except_self([1, 2, 3, 4]) [9, 8, 7, 6] >>> sum_except_self([5]) [0] >>> sum_except_self([0, 0, 0, 0]) [0, 0, 0, 0] >>> sum_except_self([-1, -2, -3, -4]) [-9, -8, -7, -6] >>> sum_except_self([1, -1, 2, -2]) [-1, 1, -2, 2]","solution":"def sum_except_self(lst): Takes a list of integers and returns a new list where each integer is replaced by the sum of all integers in the input list except itself. total_sum = sum(lst) return [total_sum - num for num in lst]"},{"question":"def check_seating_possibility(t, cases): Determine if it is possible to seat all guests and family members according to the rules. :param t: an integer, number of test cases :param cases: list of tuples, each tuple containing the grid dimensions, number of guests, number of family members, and reserved seats. :return: a list of strings, \\"Possible\\" or \\"Impossible\\" for each test case >>> check_seating_possibility(3, [(3, 3, 4, 2, [(1, 1), (3, 3)]), (4, 5, 18, 6, [(1, 1), (1, 2), (1, 3), (1, 4), (2, 1), (2, 2)]), (2, 2, 2, 0, [])]) [\\"Possible\\", \\"Impossible\\", \\"Possible\\"]","solution":"def can_seat_all_guests(t, cases): results = [] for case in cases: N, M, G, F, family_reserved = case total_seats = N * M family_seats = len(family_reserved) available_seats = total_seats - family_seats if G <= available_seats: results.append(\\"Possible\\") else: results.append(\\"Impossible\\") return results"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring with all unique characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"\\") 0 >>> length_of_longest_substring(\\"aab\\") 2 >>> length_of_longest_substring(\\"dvdf\\") 3","solution":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring with all unique characters. char_map = {} max_length = 0 start = 0 for end in range(len(s)): if s[end] in char_map: start = max(start, char_map[s[end]] + 1) char_map[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"from typing import List def sum_of_primes(numbers: List[int]) -> int: Create a function that takes a list of integers and returns the sum of all prime numbers in the list. If there are no prime numbers in the list, the function should return 0. Remember, a prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. >>> sum_of_primes([2, 3, 4, 5, 6]) == 10 >>> sum_of_primes([1, 4, 6, 8]) == 0 >>> sum_of_primes([7, 13, 19, 23]) == 62","solution":"from typing import List def is_prime(n: int) -> bool: Check if a number is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def sum_of_primes(numbers: List[int]) -> int: Returns the sum of all prime numbers in the list. return sum(n for n in numbers if is_prime(n))"},{"question":"def lis_lengths(arr): Implement a function that takes an array of integers and returns an array containing the lengths of the longest increasing subsequence (LIS) ending at each index. >>> lis_lengths([10, 9, 2, 5, 3, 7, 101, 18]) [1, 1, 1, 2, 2, 3, 4, 4] >>> lis_lengths([0, 1, 0, 3, 2, 3]) [1, 2, 1, 3, 3, 4] >>> lis_lengths([7, 7, 7, 7, 7, 7, 7]) [1, 1, 1, 1, 1, 1, 1]","solution":"def lis_lengths(arr): Returns an array containing the lengths of the longest increasing subsequence ending at each index. if not arr: return [] lis = [1] * len(arr) for i in range(1, len(arr)): for j in range(i): if arr[i] > arr[j]: lis[i] = max(lis[i], lis[j] + 1) return lis"},{"question":"def calculate_balance(transactions): Calculate the final balance after processing a list of transactions. :param transactions: List of strings representing transactions. Each string starts with 'D' for deposit or 'W' for withdrawal, followed by the amount. :return: Final balance after processing all valid transactions. pass def test_calculate_balance_only_deposits(): assert calculate_balance([\\"D100\\", \\"D200\\", \\"D300\\"]) == 600 def test_calculate_balance_only_withdrawals_with_sufficient_balance(): assert calculate_balance([\\"D500\\", \\"D200\\", \\"W100\\", \\"W200\\"]) == 400 def test_calculate_balance_mixed_transactions(): assert calculate_balance([\\"D300\\", \\"W200\\", \\"D100\\", \\"W500\\", \\"D400\\"]) == 600 def test_calculate_balance_invalid_withdrawal_due_to_insufficient_balance(): assert calculate_balance([\\"D300\\", \\"W200\\", \\"W200\\"]) == 100 def test_calculate_balance_with_no_transactions(): assert calculate_balance([]) == 0 def test_calculate_balance_initial_withdrawal(): assert calculate_balance([\\"W100\\", \\"D200\\", \\"W50\\"]) == 150","solution":"def calculate_balance(transactions): Calculate the final balance after processing a list of transactions. :param transactions: List of strings representing transactions. Each string starts with 'D' for deposit or 'W' for withdrawal, followed by the amount. :return: Final balance after processing all valid transactions. balance = 0 for transaction in transactions: type_of_transaction = transaction[0] amount = int(transaction[1:]) if type_of_transaction == 'D': balance += amount elif type_of_transaction == 'W': if balance >= amount: balance -= amount # Ignore invalid withdrawals return balance"},{"question":"def find_triplet_numbers(lst: List[int]) -> List[int]: Given a list of integers, returns a sorted list of \\"triplet numbers\\" in ascending order. A \\"triplet number\\" is a number that appears at least three times in the list. Args: lst (List[int]): A list of integers. Returns: List[int]: A sorted list of triplet numbers in ascending order. If no such numbers exist, returns an empty list. Example: >>> find_triplet_numbers([1, 2, 2, 2, 3, 3, 3, 4, 5, 5, 5, 5]) [2, 3, 5] >>> find_triplet_numbers([7, 8, 9, 7, 8, 9, 10]) [] >>> find_triplet_numbers([4, 4, 4, 2, 2, 2, 6, 6, 1]) [2, 4] from solution import find_triplet_numbers def test_no_triplet_numbers(): assert find_triplet_numbers([7, 8, 9, 7, 8, 9, 10]) == [] def test_mixed_numbers(): assert find_triplet_numbers([1, 2, 2, 2, 3, 3, 3, 4, 5, 5, 5, 5]) == [2, 3, 5] def test_single_triplet(): assert find_triplet_numbers([1, 1, 1, 2, 3, 4, 5]) == [1] def test_multiple_triplets(): assert find_triplet_numbers([4, 4, 4, 2, 2, 2, 6, 6, 1]) == [2, 4] def test_empty_list(): assert find_triplet_numbers([]) == [] def test_all_identical_numbers(): assert find_triplet_numbers([9, 9, 9, 9, 9]) == [9] def test_non_triplet_numbers(): assert find_triplet_numbers([1, 2, 3, 4, 5]) == [] def test_triplet_with_duplicates(): assert find_triplet_numbers([1, 1, 1, 1, 1, 1, 2, 2, 2, 3, 3, 3, 3]) == [1, 2, 3]","solution":"def find_triplet_numbers(lst): Returns a sorted list of integers that appear at least three times in the input list. from collections import Counter counter = Counter(lst) triplet_numbers = [number for number, count in counter.items() if count >= 3] return sorted(triplet_numbers)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_power_of_two_path_sum(root: TreeNode) -> int: Returns the maximum sum of values along any path from the root to a leaf considering only the node values that are powers of two. >>> root = TreeNode(5, TreeNode(3, TreeNode(1), TreeNode(4)), TreeNode(10, TreeNode(2), TreeNode(8))) >>> max_power_of_two_path_sum(root) 8 >>> max_power_of_two_path_sum(TreeNode(8)) 8 >>> max_power_of_two_path_sum(TreeNode(10)) 0 >>> root = TreeNode(4, TreeNode(2), TreeNode(8, TreeNode(4), TreeNode(16))) >>> max_power_of_two_path_sum(root) 28 >>> root = TreeNode(5, TreeNode(3), TreeNode(9)) >>> max_power_of_two_path_sum(root) 0 >>> root = TreeNode(1, TreeNode(3), TreeNode(2, TreeNode(4), TreeNode(16))) >>> max_power_of_two_path_sum(root) 19 >>> root = TreeNode(10**9, TreeNode(10**6), TreeNode(2**30)) >>> max_power_of_two_path_sum(root) 2**30","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_power_of_two(x): Helper function to determine if a number is a power of two. return (x & (x - 1) == 0) and x != 0 def max_power_of_two_path_sum(root: TreeNode) -> int: Returns the maximum sum of values along any path from the root to a leaf considering only the node values that are powers of two. def helper(node): if not node: return 0 if not node.left and not node.right: return node.val if is_power_of_two(node.val) else 0 left_sum = helper(node.left) right_sum = helper(node.right) max_child_sum = max(left_sum, right_sum) return node.val + max_child_sum if is_power_of_two(node.val) else max_child_sum return helper(root)"},{"question":"def longest_palindrome_substring(s: str) -> str: Returns the longest palindromic substring in the given string s. >>> longest_palindrome_substring(\\"\\") == \\"\\" >>> longest_palindrome_substring(\\"a\\") == \\"a\\" >>> longest_palindrome_substring(\\"ac\\") in [\\"a\\", \\"c\\"] >>> longest_palindrome_substring(\\"cbbd\\") == \\"bb\\" >>> longest_palindrome_substring(\\"babad\\") in [\\"bab\\", \\"aba\\"] >>> longest_palindrome_substring(\\"abccba\\") == \\"abccba\\" >>> longest_palindrome_substring(\\"abcdefg\\") == \\"a\\" >>> longest_palindrome_substring(\\"racecarannakayak\\") == \\"racecar\\" >>> longest_palindrome_substring(\\"aabbcbbaa\\") == \\"aabbcbbaa\\" >>> longest_palindrome_substring(\\"abaxyzyx\\") == \\"xyzyx\\"","solution":"def longest_palindrome_substring(s): Returns the longest palindromic substring in the given string s. if not s: return \\"\\" n = len(s) start, max_length = 0, 1 def expand_around_center(left, right): nonlocal start, max_length while left >= 0 and right < n and s[left] == s[right]: current_length = right - left + 1 if current_length > max_length: start = left max_length = current_length left -= 1 right += 1 for i in range(n): expand_around_center(i, i) # Odd length palindromes expand_around_center(i, i + 1) # Even length palindromes return s[start:start + max_length]"},{"question":"def time_to_meet(n: int) -> int: Returns the time in minutes when Alice and Bob will meet or pass each other in a corridor of length n. >>> time_to_meet(5) 2 >>> time_to_meet(6) 3 >>> time_to_meet(1) 0 >>> time_to_meet(1000000000) 500000000","solution":"def time_to_meet(n): Returns the time in minutes when Alice and Bob will meet or pass each other in a corridor of length n. return n // 2"},{"question":"def compute_powers(a: int, b: int, c: int) -> tuple: Computes and returns the power values. >>> compute_powers(2, 3, 5) (8, 3) >>> compute_powers(3, 4, 5) (81, 1) >>> compute_powers(4, 0, 6) (1, 1)","solution":"def compute_powers(a, b, c): Computes and returns the power values. - First, returns pow(a, b) - Second, returns pow(a, b, c) result1 = pow(a, b) result2 = pow(a, b, c) return result1, result2"},{"question":"def countTrailingZeros(n: int) -> int: Returns the number of trailing zeros in the factorial of the integer n. >>> countTrailingZeros(0) 0 >>> countTrailingZeros(1) 0 >>> countTrailingZeros(4) 0 >>> countTrailingZeros(5) 1 >>> countTrailingZeros(10) 2 >>> countTrailingZeros(25) 6 >>> countTrailingZeros(50) 12 >>> countTrailingZeros(100) 24 >>> countTrailingZeros(125) 31 >>> countTrailingZeros(1000) 249 >>> countTrailingZeros(5000) 1249 >>> countTrailingZeros(10000) 2499","solution":"def countTrailingZeros(n): Returns the number of trailing zeros in the factorial of the integer n. count = 0 while n >= 5: n //= 5 count += n return count"},{"question":"def generate_valid_grid(n: int) -> List[List[int]]: Generates an n x n grid with unique row and column sums where the sum of all row sums is equal to the sum of all column sums. >>> generate_valid_grid(3) [[9, 2, 4], [7, 5, 1], [3, 8, 6]] >>> generate_valid_grid(2) [[1, 4], [3, 2]]","solution":"import random def generate_grid(n): Generates an n x n grid with unique row and column sums and an equal sum of all row sums to all column sums. numbers = list(range(1, n * n + 1)) random.shuffle(numbers) grid = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): grid[i][j] = numbers.pop() return grid def check_unique_sums(grid): n = len(grid) row_sums = [sum(row) for row in grid] col_sums = [sum(col) for col in zip(*grid)] if len(set(row_sums)) != n or len(set(col_sums)) != n: return False return sum(row_sums) == sum(col_sums) def fix_grid(grid): n = len(grid) while not check_unique_sums(grid): grid = generate_grid(n) return grid def generate_valid_grid(n): grid = generate_grid(n) grid = fix_grid(grid) return grid"},{"question":"def organize_auction(n: int, k: int, items: List[Tuple[int, str]]) -> List[Tuple[int, str]]: Organize the auction sequence with the top k most valuable items first. Parameters: n (int): Total number of items. k (int): Number of high-value items to be displayed first. items (List[Tuple[int, str]]): List of tuples where each tuple contains the value (int) and identifier (str) of an item. Returns: List[Tuple[int, str]]: List of tuples representing the auction sequence. >>> organize_auction(5, 3, [(3000, 'A1'), (1500, 'B2'), (2000, 'C3'), (1000, 'D4'), (500, 'E5')]) [(3000, 'A1'), (2000, 'C3'), (1500, 'B2'), (1000, 'D4'), (500, 'E5')] >>> organize_auction(4, 2, [(2000, 'A1'), (1000, 'B2'), (3000, 'C3'), (1500, 'D4')]) [(3000, 'C3'), (2000, 'A1'), (1000, 'B2'), (1500, 'D4')] >>> organize_auction(3, 0, [(1000, 'A1'), (2000, 'B2'), (3000, 'C3')]) [(1000, 'A1'), (2000, 'B2'), (3000, 'C3')]","solution":"def organize_auction(n, k, items): Organize the auction sequence with the top k most valuable items first. :param n: int, total number of items. :param k: int, number of high-value items to be displayed first. :param items: list of tuples [(value, id), ...], value is an integer and id is a string. :return: list of tuples [(value, id), ...] in the desired auction sequence. if k == 0: return items # Sort items by value in descending order and pick the top k items top_k_items = sorted(items, key=lambda x: x[0], reverse=True)[:k] # The remaining items in their original order but without the top k items remaining_items = [item for item in items if item not in top_k_items] # Concatenate top k items with remaining items result = top_k_items + remaining_items return result"},{"question":"import math from typing import List def is_triangle_number(num: int) -> int: Determines if 'num' is a triangular number and returns the corresponding 'n' if it is. If 'num' is not a triangular number, returns -1. Args: num (int): The number to be checked. Returns: int: The 'n' which makes 'num' a triangular number or -1 if 'num' is not a triangular number. Examples: >>> is_triangle_number(6) 3 >>> is_triangle_number(10) 4 >>> is_triangle_number(8) -1 >>> is_triangle_number(15) 5 >>> is_triangle_number(1) 1 >>> is_triangle_number(5) -1 from solution import is_triangle_number def test_triangle_number_6(): assert is_triangle_number(6) == 3 def test_triangle_number_10(): assert is_triangle_number(10) == 4 def test_triangle_number_8(): assert is_triangle_number(8) == -1 def test_triangle_number_15(): assert is_triangle_number(15) == 5 def test_triangle_number_1(): assert is_triangle_number(1) == 1 def test_triangle_number_5(): assert is_triangle_number(5) == -1 def test_large_triangle_number(): assert is_triangle_number(5050) == 100 # 5050 is the 100th triangular number def test_non_triangle_large_number(): assert is_triangle_number(123456) == -1 def test_triangle_number_edge_case(): assert is_triangle_number(0) == -1 def test_triangle_number_negative(): assert is_triangle_number(-10) == -1 # Although the problem states input is positive, testing negative inputs.","solution":"import math def is_triangle_number(num): Determines if 'num' is a triangular number and returns the corresponding 'n' if it is. If 'num' is not a triangular number, returns -1. Args: num (int): The number to be checked. Returns: int: The 'n' which makes 'num' a triangular number or -1 if 'num' is not a triangular number. # Solving the quadratic equation n^2 + n - 2*num = 0 discriminant = 1 + 8 * num if discriminant < 0: return -1 n = (-1 + math.sqrt(discriminant)) / 2 # Check if n is a positive integer if n.is_integer() and n > 0: return int(n) else: return -1"},{"question":"def shift_string(s: str, k: int) -> str: Implement a function that shifts every letter in the string \`s\` by \`k\` positions in the alphabet. The shift wraps around, so if shifting a letter by \`k\` places exceeds the letter 'z', it wraps back around to 'a'. Spaces and punctuation in the string should remain unchanged. >>> shift_string(\\"hello\\", 2) 'jgnnq' >>> shift_string(\\"abc xyz!\\", 3) 'def abc!' >>> shift_string(\\"shift by twenty-six\\", 26) 'shift by twenty-six'","solution":"def shift_string(s, k): def shift_char(c, k): if c.islower(): return chr((ord(c) - ord('a') + k) % 26 + ord('a')) elif c.isupper(): return chr((ord(c) - ord('A') + k) % 26 + ord('A')) else: return c return ''.join(shift_char(char, k) for char in s)"},{"question":"def two_sum(nums, target): Returns the indices of the two numbers that add up to the target. :param nums: List[int] :param target: int :return: List[int] >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([3, 2, 4], 6) [1, 2] >>> two_sum([3, 3], 6) [0, 1]","solution":"def two_sum(nums, target): Returns the indices of the two numbers that add up to the target. :param nums: List[int] :param target: int :return: List[int] num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i return [] # Example usage # result = two_sum([2, 7, 11, 15], 9) # should return [0, 1]"},{"question":"from typing import List def filter_even_numbers(lst: List[int]) -> List[int]: Returns a new list containing only the even numbers from the original list. >>> filter_even_numbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) [2, 4, 6, 8, 10] >>> filter_even_numbers([1, 3, 5, 7, 9]) [] >>> filter_even_numbers([-1, -2, -3, -4, -5, -6]) [-2, -4, -6] >>> filter_even_numbers([0, 2, 4, 6]) [0, 2, 4, 6] >>> filter_even_numbers([]) [] >>> filter_even_numbers([3]) [] >>> filter_even_numbers([4]) [4]","solution":"from typing import List def filter_even_numbers(lst: List[int]) -> List[int]: Returns a new list containing only the even numbers from the original list. :param lst: List of integers :return: List of even integers return [num for num in lst if num % 2 == 0]"},{"question":"def max_non_overlapping_events(events): Determines the maximum number of non-overlapping events that can be attended. Args: events (list of tuple): A list of tuples where each tuple contains two integers (start time, duration). Returns: int: The maximum number of non-overlapping events. >>> max_non_overlapping_events([(1, 4), (3, 3), (0, 2), (5, 2), (8, 1)]) 3 >>> max_non_overlapping_events([(1, 5), (2, 5), (3, 5)]) 1 >>> max_non_overlapping_events([(1, 2), (3, 2), (5, 2), (7, 2)]) 4 def parse_input(input_text): Parses the input text into a list of events. Args: input_text (str): The input text. Returns: List[Tuple[int, int]]: A list of events where each event is described as a tuple (start time, duration). >>> parse_input(\\"5n1 4n3 3n0 2n5 2n8 1n\\") [(1, 4), (3, 3), (0, 2), (5, 2), (8, 1)] >>> parse_input(\\"1n0 10n\\") [(0, 10)] >>> parse_input(\\"3n1 5n2 5n3 5n\\") [(1, 5), (2, 5), (3, 5)]","solution":"def max_non_overlapping_events(events): Determines the maximum number of non-overlapping events that can be attended. Args: events (list of tuple): A list of tuples where each tuple contains two integers (start time, duration). Returns: int: The maximum number of non-overlapping events. # Sorting events by their end time (start time + duration) sorted_events = sorted(events, key=lambda x: x[0] + x[1]) count = 0 last_end_time = -1 for start, duration in sorted_events: end_time = start + duration if start >= last_end_time: count += 1 last_end_time = end_time return count def parse_input(input_text): Parses the input text into a list of events. Args: input_text (str): The input text. Returns: List[Tuple[int, int]]: A list of events where each event is described as a tuple (start time, duration). lines = input_text.split('n') events = [] for line in lines[1:]: if line.strip(): s, d = map(int, line.split()) events.append((s, d)) return events"},{"question":"from typing import List, Tuple def distinct_circular_routes(T: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]: Determine the number of distinct circular routes the King can take, starting and ending at village 1. Args: T (int): The number of test cases. test_cases (List[Tuple[int, List[Tuple[int, int]]]]): A list where each element is a tuple containing the number of villages and a list of tuples representing the roads between villages. Returns: List[int]: A list of integers, each representing the number of distinct circular routes for a test case modulo 10^9+7. import pytest @pytest.mark.parametrize(\\"T, test_cases, expected\\", [ (2, [(3, [(1, 2), (1, 3)]), (4, [(1, 2), (2, 3), (3, 4)])], [2, 6]), (1, [(2, [(1, 2)])], [1]), (1, [(5, [(1, 2), (1, 3), (1, 4), (1, 5)])], [24]), (1, [(6, [(1, 2), (2, 3), (2, 4), (4, 5), (4, 6)])], [120]), (1, [(10, [(1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (1, 7), (1, 8), (1, 9), (1, 10)])], [362880]), ]) def test_distinct_circular_routes(T, test_cases, expected): assert distinct_circular_routes(T, test_cases) == expected","solution":"def factorial(n): Calculates factorial of n. if n == 0 or n == 1: return 1 result = 1 for i in range(2, n + 1): result *= i return result def distinct_circular_routes(T, test_cases): MOD = 10**9 + 7 results = [] for case in test_cases: N = case[0] if N == 2: results.append(1) else: count = factorial(N - 1) % MOD results.append(count) return results"},{"question":"from typing import List from collections import Counter def can_rearrange_adjacent_distinct(strings: List[str]) -> List[str]: Determine if you can rearrange the characters of each string such that no two adjacent characters are the same. Args: strings (List[str]): A list of strings each consisting of lowercase letters. Returns: List[str]: A list containing \\"YES\\" or \\"NO\\" for each string. >>> can_rearrange_adjacent_distinct([\\"aabb\\", \\"aaab\\", \\"abc\\", \\"zzzz\\"]) [\\"YES\\", \\"NO\\", \\"YES\\", \\"NO\\"] >>> can_rearrange_adjacent_distinct([\\"a\\"]) [\\"YES\\"] >>> can_rearrange_adjacent_distinct([\\"aaa\\"]) [\\"NO\\"] # [Function body to be implemented.] def process_test_cases(T: int, test_cases: List[str]) -> List[str]: Processes the test cases and determines if each string can be rearranged such that no two adjacent characters are the same. Args: T (int): Number of test cases. test_cases (List[str]): List of strings representing each test case. Returns: List[str]: A list containing \\"YES\\" or \\"NO\\" for each test case. >>> process_test_cases(4, [\\"aabb\\", \\"aaab\\", \\"abc\\", \\"zzzz\\"]) [\\"YES\\", \\"NO\\", \\"YES\\", \\"NO\\"] # [Function body to be implemented.]","solution":"from collections import Counter def can_rearrange_adjacent_distinct(strings): results = [] for s in strings: count = Counter(s) max_freq = max(count.values()) if max_freq > (len(s) + 1) // 2: results.append(\\"NO\\") else: results.append(\\"YES\\") return results def process_test_cases(T, test_cases): return can_rearrange_adjacent_distinct(test_cases)"},{"question":"from datetime import datetime from typing import List, Dict, Tuple def productSales(sales_log: List[Tuple[str, int, int]], start_date: str, end_date: str) -> Dict[int, int]: Calculates the total sales each product had in a given date range. :param sales_log: List of tuples where each tuple contains a date (YYYY-MM-DD), product ID, and the number of items sold. :param start_date: String representing the start of the date range in YYYY-MM-DD format. :param end_date: String representing the end of the date range in YYYY-MM-DD format. :return: Dictionary where keys are product IDs and values are the total sales for that product in the given period. >>> sales_log = [(\\"2023-01-20\\", 101, 5), (\\"2023-02-10\\", 102, 3), (\\"2023-03-15\\", 101, 2), (\\"2023-03-20\\", 103, 1)] >>> start_date = \\"2023-02-01\\" >>> end_date = \\"2023-03-31\\" >>> productSales(sales_log, start_date, end_date) {101: 2, 102: 3, 103: 1} >>> sales_log = [(\\"2023-01-01\\", 101, 10), (\\"2023-01-02\\", 101, 5), (\\"2023-01-03\\", 102, 8), (\\"2023-01-04\\", 103, 6), (\\"2023-01-05\\", 101, 7)] >>> start_date = \\"2023-01-01\\" >>> end_date = \\"2023-01-03\\" >>> productSales(sales_log, start_date, end_date) {101: 15, 102: 8} pass from solution import productSales def test_productSales_example1(): sales_log = [(\\"2023-01-20\\", 101, 5), (\\"2023-02-10\\", 102, 3), (\\"2023-03-15\\", 101, 2), (\\"2023-03-20\\", 103, 1)] start_date = \\"2023-02-01\\" end_date = \\"2023-03-31\\" result = productSales(sales_log, start_date, end_date) assert result == {101: 2, 102: 3, 103: 1} def test_productSales_example2(): sales_log = [(\\"2023-01-01\\", 101, 10), (\\"2023-01-02\\", 101, 5), (\\"2023-01-03\\", 102, 8), (\\"2023-01-04\\", 103, 6), (\\"2023-01-05\\", 101, 7)] start_date = \\"2023-01-01\\" end_date = \\"2023-01-03\\" result = productSales(sales_log, start_date, end_date) assert result == {101: 15, 102: 8} def test_productSales_no_sales_in_range(): sales_log = [(\\"2023-01-01\\", 101, 10), (\\"2023-01-02\\", 101, 5)] start_date = \\"2023-02-01\\" end_date = \\"2023-02-28\\" result = productSales(sales_log, start_date, end_date) assert result == {} def test_productSales_all_sales_in_range(): sales_log = [(\\"2023-01-01\\", 101, 10), (\\"2023-01-02\\", 101, 5)] start_date = \\"2023-01-01\\" end_date = \\"2023-01-02\\" result = productSales(sales_log, start_date, end_date) assert result == {101: 15} def test_productSales_partial_sales_in_range(): sales_log = [(\\"2023-01-01\\", 101, 10), (\\"2023-01-02\\", 101, 5), (\\"2023-01-03\\", 102, 8), (\\"2023-01-04\\", 103, 6)] start_date = \\"2023-01-02\\" end_date = \\"2023-01-03\\" result = productSales(sales_log, start_date, end_date) assert result == {101: 5, 102: 8}","solution":"from datetime import datetime def productSales(sales_log, start_date, end_date): Calculates the total sales each product had in a given date range. :param sales_log: List of tuples where each tuple contains a date (YYYY-MM-DD), product ID, and the number of items sold. :param start_date: String representing the start of the date range in YYYY-MM-DD format. :param end_date: String representing the end of the date range in YYYY-MM-DD format. :return: Dictionary where keys are product IDs and values are the total sales for that product in the given period. start = datetime.strptime(start_date, '%Y-%m-%d') end = datetime.strptime(end_date, '%Y-%m-%d') sales_dict = {} for sale_date_str, product_id, count in sales_log: sale_date = datetime.strptime(sale_date_str, '%Y-%m-%d') if start <= sale_date <= end: if product_id in sales_dict: sales_dict[product_id] += count else: sales_dict[product_id] = count return sales_dict"},{"question":"from typing import List, Tuple def shortest_paths(n: int, roads: List[Tuple[int, int, int]], queries: List[Tuple[int, int]]) -> List[int]: Find the shortest paths in a virtual city from one city to another. The function should return a list of shortest path lengths for each query. Args: n: Number of cities roads: List of roads where each road is a tuple (u, v, w) representing a road between cities u and v with length w queries: List of queries where each query is a tuple (a, b) representing a request for the shortest path from city a to city b Returns: List of integers representing the shortest path lengths for each query. If there is no path between two queried cities, return -1. Example: >>> n = 5 >>> roads = [(1, 2, 3), (1, 3, 5), (2, 3, 2), (3, 4, 4), (2, 4, 6), (4, 5, 1)] >>> queries = [(1, 5), (2, 4), (3, 1)] >>> shortest_paths(n, roads, queries) [10, 6, 5] pass def test_example_case(): n = 5 roads = [ (1, 2, 3), (1, 3, 5), (2, 3, 2), (3, 4, 4), (2, 4, 6), (4, 5, 1) ] queries = [ (1, 5), (2, 4), (3, 1) ] expected_output = [10, 6, 5] assert shortest_paths(n, roads, queries) == expected_output def test_disconnected_cities(): n = 4 roads = [ (1, 2, 4), (3, 4, 7) ] queries = [ (1, 4), (2, 3) ] expected_output = [-1, -1] assert shortest_paths(n, roads, queries) == expected_output def test_single_road(): n = 2 roads = [ (1, 2, 3) ] queries = [ (1, 2), (2, 1) ] expected_output = [3, 3] assert shortest_paths(n, roads, queries) == expected_output def test_multiple_paths(): n = 3 roads = [ (1, 2, 1), (2, 3, 2), (1, 3, 4) ] queries = [ (1, 3), (3, 1) ] expected_output = [3, 3] assert shortest_paths(n, roads, queries) == expected_output","solution":"import heapq def dijkstra(graph, start, n): distances = [float('inf')] * (n + 1) distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_city = heapq.heappop(priority_queue) if current_distance > distances[current_city]: continue for neighbor, weight in graph[current_city]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances def shortest_paths(n, roads, queries): # Create the graph as adjacency list graph = {i: [] for i in range(1, n + 1)} for u, v, w in roads: graph[u].append((v, w)) graph[v].append((u, w)) # Calculate shortest paths using Dijkstra for each city all_distances = {} for city in range(1, n + 1): all_distances[city] = dijkstra(graph, city, n) # Process each query results = [] for a, b in queries: distance = all_distances[a][b] if distance == float('inf'): results.append(-1) else: results.append(distance) return results"},{"question":"def can_sort_by_one_swap(N: int, scores: List[int]) -> str: Determines if the array can be sorted by swapping exactly two elements once. Returns 'YES' if it is possible and 'NO' otherwise. >>> can_sort_by_one_swap(5, [1, 2, 3, 4, 5]) 'YES' >>> can_sort_by_one_swap(5, [1, 3, 2, 4, 5]) 'YES' >>> can_sort_by_one_swap(4, [4, 1, 3, 2]) 'NO'","solution":"def can_sort_by_one_swap(N, scores): Determines if the array can be sorted by swapping exactly two elements once. Returns \\"YES\\" if it is possible and \\"NO\\" otherwise. # Create a sorted version of the scores sorted_scores = sorted(scores) # Find all positions where the scores don't match the sorted version mismatch_positions = [] for i in range(N): if scores[i] != sorted_scores[i]: mismatch_positions.append(i) # If there are no mismatches, the list is already sorted if len(mismatch_positions) == 0: return \\"YES\\" # If there are exactly 2 mismatches, check if swapping them would sort the list if len(mismatch_positions) == 2: i, j = mismatch_positions scores[i], scores[j] = scores[j], scores[i] if scores == sorted_scores: return \\"YES\\" else: return \\"NO\\" # More than 2 mismatches means we can't fix the list with a single swap return \\"NO\\""},{"question":"def longest_subarray(arr: List[int]) -> int: Given a list of integers, find the length of the longest subarray where the absolute difference between any two elements is at most 1. >>> longest_subarray([1, 2, 2, 3, 1, 2]) 5 >>> longest_subarray([-1, -2, -2, -1, 0, 1, 1]) 4 >>> longest_subarray([1, 5, 9, 15, 20, 30]) 1 >>> longest_subarray([1, 1, 1, 1, 1]) 5 >>> longest_subarray([1, 2, 3, 4, 5, 6, 7]) 2 >>> longest_subarray([]) 0 The list may contain positive or negative integers.","solution":"def longest_subarray(arr): from collections import defaultdict if not arr: return 0 frequency = defaultdict(int) max_length = 0 for num in arr: frequency[num] += 1 current_length = frequency[num] + frequency[num - 1] max_length = max(max_length, current_length) current_length = frequency[num] + frequency[num + 1] max_length = max(max_length, current_length) return max_length"},{"question":"def max_histogram_area(heights: List[int]) -> int: Calculate the area of the largest rectangle that can be formed within the bounds of the histogram. :param heights: List[int] - List of integers representing the heights of the histogram bars :return: int - The area of the largest rectangle Examples: >>> max_histogram_area([2, 1, 5, 6, 2, 3]) 10 >>> max_histogram_area([2, 4]) 4 from solution import max_histogram_area def test_max_histogram_area_example1(): assert max_histogram_area([2, 1, 5, 6, 2, 3]) == 10 def test_max_histogram_area_example2(): assert max_histogram_area([2, 4]) == 4 def test_max_histogram_area_example3(): assert max_histogram_area([6, 2, 5, 4, 5, 1, 6]) == 12 def test_max_histogram_area_single_bar(): assert max_histogram_area([5]) == 5 def test_max_histogram_area_increasing_heights(): assert max_histogram_area([1, 2, 3, 4, 5]) == 9 def test_max_histogram_area_decreasing_heights(): assert max_histogram_area([5, 4, 3, 2, 1]) == 9 def test_max_histogram_area_equal_heights(): assert max_histogram_area([3, 3, 3, 3]) == 12","solution":"def max_histogram_area(heights): Returns the area of the largest rectangle that can be formed within the bounds of the histogram. :param heights: List[int] - List of integers representing the heights of the histogram bars :return: int - The area of the largest rectangle stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def find_min_cameras(n: int, m: int, edges: List[Tuple[int, int]]) -> int: Determine the minimum number of cameras needed to cover all hallways in the museum. >>> find_min_cameras(5, 5, [(1, 2), (1, 3), (2, 3), (4, 5), (3, 4)]) == 2 >>> find_min_cameras(4, 3, [(1, 2), (1, 3), (1, 4)]) == 1 >>> find_min_cameras(6, 7, [(1, 2), (1, 3), (1, 4), (2, 5), (3, 6), (4, 5), (4, 6)]) == 3 >>> find_min_cameras(3, 3, [(1, 2), (1, 3), (2, 3)]) == 1 >>> find_min_cameras(4, 2, [(1, 2), (3, 4)]) == 2 >>> find_min_cameras(5, 0, []) == 0 >>> find_min_cameras(6, 4, [(1, 2), (2, 3), (4, 5), (5, 6)]) == 2 >>> edges = [(i, i + 1) for i in range(1, 1000)] >>> find_min_cameras(1000, 999, edges) == 500 pass","solution":"def find_min_cameras(n, m, edges): from collections import defaultdict # Helper function for finding a vertex cover of the graph def find_vertex_cover(n, edges): adj = defaultdict(list) for u, v in edges: adj[u].append(v) adj[v].append(u) # Initialize all vertices as not visited visited = [False] * (n + 1) vertex_cover = [] # Consider each edge for u, v in edges: if not visited[u] and not visited[v]: visited[u] = True visited[v] = True vertex_cover.append(u) vertex_cover.append(v) return len(vertex_cover) // 2 return find_vertex_cover(n, edges)"},{"question":"def find_pairs(k: int) -> List[Tuple[int, int]]: Returns all possible pairs (a, b) of distinct integers such that a * b = k and 1 ≤ a < b. >>> find_pairs(6) [(1, 6), (2, 3)] >>> find_pairs(12) [(1, 12), (2, 6), (3, 4)] >>> find_pairs(1) [] >>> find_pairs(25) [(1, 25)] >>> find_pairs(100) [(1, 100), (2, 50), (4, 25), (5, 20)] >>> find_pairs(13) [(1, 13)] >>> find_pairs(15) [(1, 15), (3, 5)]","solution":"def find_pairs(k): Returns all possible pairs (a, b) of distinct integers such that a * b = k and 1 ≤ a < b. pairs = [] for a in range(1, int(k**0.5) + 1): if k % a == 0: b = k // a if a < b: pairs.append((a, b)) return pairs"},{"question":"def longest_recurring_pattern(S1: str, S2: str) -> str: Find the longest recurring pattern that appears in both strings S1 and S2. >>> longest_recurring_pattern(\\"abcabcabc\\", \\"bcabcabc\\") \\"bcabcabc\\" >>> longest_recurring_pattern(\\"abcdefg\\", \\"hijklmn\\") \\"No pattern found\\" pass from solution import longest_recurring_pattern def test_sample_1(): S1 = \\"abcabcabc\\" S2 = \\"bcabcabc\\" assert longest_recurring_pattern(S1, S2) == \\"bcabcabc\\" def test_sample_2(): S1 = \\"abcdefg\\" S2 = \\"hijklmn\\" assert longest_recurring_pattern(S1, S2) == \\"No pattern found\\" def test_partial_overlap(): S1 = \\"abcde\\" S2 = \\"abcabcde\\" assert longest_recurring_pattern(S1, S2) == \\"abcde\\" def test_complete_overlap(): S1 = \\"abcdef\\" S2 = \\"abcdef\\" assert longest_recurring_pattern(S1, S2) == \\"abcdef\\" def test_smallest_input(): S1 = \\"a\\" S2 = \\"a\\" assert longest_recurring_pattern(S1, S2) == \\"a\\" def test_no_common_substring(): S1 = \\"xyz\\" S2 = \\"abc\\" assert longest_recurring_pattern(S1, S2) == \\"No pattern found\\"","solution":"def longest_recurring_pattern(S1, S2): Find the longest recurring pattern that appears in both strings S1 and S2. m, n = len(S1), len(S2) max_len = 0 result = \\"No pattern found\\" # Creating a DP table to store lengths of the longest common suffixes dp = [[0] * (n + 1) for _ in range(m + 1)] # Building the DP table for i in range(m): for j in range(n): if S1[i] == S2[j]: dp[i+1][j+1] = dp[i][j] + 1 if dp[i+1][j+1] > max_len: max_len = dp[i+1][j+1] result = S1[i - max_len + 1:i + 1] else: dp[i+1][j+1] = 0 return result"},{"question":"def findLongestSubstring(s: str) -> str: Returns the longest substring with all distinct characters. >>> findLongestSubstring(\\"abcabcbb\\") \\"abc\\" >>> findLongestSubstring(\\"bbbbb\\") \\"b\\" >>> findLongestSubstring(\\"pwwkew\\") \\"wke\\" >>> findLongestSubstring(\\"\\") \\"\\" >>> findLongestSubstring(\\"abccdefgh\\") \\"cdefgh\\"","solution":"def findLongestSubstring(s): Returns the longest substring with all distinct characters. n = len(s) if n == 0: return \\"\\" # Dictionary to store the last positions of occurrence last_index = {} max_length = 0 start = 0 longest_substring_start = 0 for end in range(n): # If found within the current window, move the start right after the last occurrence if s[end] in last_index and last_index[s[end]] >= start: start = last_index[s[end]] + 1 # Update the last occurrence of the character last_index[s[end]] = end # Update the max length if needed if end - start + 1 > max_length: max_length = end - start + 1 longest_substring_start = start return s[longest_substring_start:longest_substring_start + max_length]"},{"question":"def min_changes_to_palindrome(s: str) -> int: Given a string \`s\` consisting of lowercase English letters, returns the minimum number of character changes required to make the string \`s\` a palindrome. >>> min_changes_to_palindrome(\\"abca\\") 1 >>> min_changes_to_palindrome(\\"racecar\\") 0 >>> min_changes_to_palindrome(\\"abcd\\") 2","solution":"def min_changes_to_palindrome(s): Returns the minimum number of character changes required to make the given string \`s\` a palindrome. n = len(s) changes = 0 for i in range(n // 2): if s[i] != s[n - i - 1]: changes += 1 return changes"},{"question":"def findOdd(arr): Given an array/list of integers, find the first element that appears an odd number of times. Args: arr (List[int]): A list of integers with at least one element appearing an odd number of times. Returns: int: The first integer in the list that appears an odd number of times. >>> findOdd([1,7,2,9,2,7,3,7]) 1 >>> findOdd([-3,-3,7,5,3,5,5,7]) 5 >>> findOdd([0,0,2,2,3,3,4,4,4]) 4 from solution import findOdd def test_case1(): assert findOdd([1,7,2,9,2,7,3,7]) == 1 def test_case2(): assert findOdd([-3,-3,7,5,3,5,5,7]) == 5 def test_case3(): assert findOdd([0,0,2,2,3,3,4,4,4]) == 4 def test_case4(): assert findOdd([10, 10, -1, -1, -2, -2, -3]) == -3 def test_case5(): assert findOdd([8, 8, 3, 3, 4, 2, 2, 1]) == 4","solution":"def findOdd(arr): Given an array/list of integers, find the first element that appears an odd number of times. # Create a dictionary to count the occurrences of each element counts = {} # Count the occurrences for num in arr: if num in counts: counts[num] += 1 else: counts[num] = 1 # Find the first element with an odd count for num in arr: if counts[num] % 2 != 0: return num"},{"question":"def can_form_palindrome(s: str) -> bool: Determines if a given string can be rearranged to form a palindrome. Args: s (str): Input string Returns: bool: True if the string can be rearranged to form a palindrome, False otherwise. Example: >>> can_form_palindrome(\\"aabb\\") True >>> can_form_palindrome(\\"racecar\\") True >>> can_form_palindrome(\\"hello\\") False","solution":"def can_form_palindrome(s): Determines if the given string can be rearranged to form a palindrome. Args: s (str): Input string Returns: bool: True if the string can be rearranged to form a palindrome, False otherwise. from collections import Counter # Count frequency of each character char_count = Counter(s) # Count how many characters have an odd count odd_count = sum(1 for count in char_count.values() if count % 2 == 1) # A string can be rearranged to a palindrome if there is at most one character with an odd count return odd_count <= 1"},{"question":"class RangeSumMatrix: def __init__(self, matrix: List[List[int]]): Initialize the RangeSumMatrix with the given 2D matrix. pass def updateElement(self, row: int, col: int, newValue: int): Update the value of the matrix at the given (row, col) position to newValue. pass def getSum(self, row1: int, col1: int, row2: int, col2: int) -> int: Return the sum of the elements in the submatrix defined by (row1, col1) and (row2, col2). >>> rsm = RangeSumMatrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) >>> rsm.updateElement(0, 0, 10) >>> rsm.getSum(0, 0, 1, 1) 21 >>> rsm.updateElement(2, 2, 5) >>> rsm.getSum(1, 0, 2, 2) 35 >>> rsm2 = RangeSumMatrix([[2, 4], [6, 8]]) >>> rsm2.getSum(0, 0, 1, 1) 20 >>> rsm2.updateElement(1, 1, 5) >>> rsm2.getSum(0, 0, 1, 1) 17 >>> rsm2.updateElement(0, 0, 3) >>> rsm2.getSum(0, 1, 0, 1) 4 pass","solution":"class RangeSumMatrix: def __init__(self, matrix): Initialize the RangeSumMatrix with the given 2D matrix. self.matrix = matrix def updateElement(self, row, col, newValue): Update the value of the matrix at the given (row, col) position to newValue. self.matrix[row][col] = newValue def getSum(self, row1, col1, row2, col2): Return the sum of the elements in the submatrix defined by (row1, col1) and (row2, col2). sum_val = 0 for i in range(row1, row2 + 1): for j in range(col1, col2 + 1): sum_val += self.matrix[i][j] return sum_val"},{"question":"def validPalindrome(s: str) -> bool: Returns true if the string can be made into a palindrome by removing at most one character. >>> validPalindrome(\\"abca\\") == True >>> validPalindrome(\\"racecar\\") == True >>> validPalindrome(\\"abc\\") == False >>> validPalindrome(\\"RaceCar\\") == True >>> validPalindrome(\\"\\") == True >>> validPalindrome(\\"a\\") == True","solution":"def validPalindrome(s: str) -> bool: Returns true if the string can be made into a palindrome by removing at most one character. def is_palindrome_range(i, j): return all(s[k] == s[j-k+i] for k in range(i, j)) i, j = 0, len(s) - 1 while i < j: if s[i].lower() != s[j].lower(): return is_palindrome_range(i+1, j) or is_palindrome_range(i, j-1) i += 1 j -= 1 return True"},{"question":"def double_char(s: str) -> str: Returns a new string where every character in the input string is duplicated. :param s: The input string :return: A new string with each character duplicated >>> double_char(\\"hello\\") == \\"hheelllloo\\" >>> double_char(\\"\\") == \\"\\" >>> double_char(\\"a\\") == \\"aa\\" >>> double_char(\\"Z\\") == \\"ZZ\\" >>> double_char(\\"123!\\") == \\"112233!!\\" >>> double_char(\\"!@#\\") == \\"!!@@\\" >>> double_char(\\"H3ll0!\\") == \\"HH33llll00!!\\" >>> double_char(\\"a b c\\") == \\"aa bb cc\\"","solution":"def double_char(s): Returns a new string where every character in the input string is duplicated. :param s: The input string :return: A new string with each character duplicated return ''.join([c * 2 for c in s])"},{"question":"def min_operations_to_sort_sequence(n: int, sequence: List[int]) -> int: Determine the minimum number of operations required to make the sequence strictly increasing. Args: n (int): The length of the sequence. sequence (List[int]): The sequence of integers. Returns: int: The minimum number of operations. >>> min_operations_to_sort_sequence(5, [3, 1, 2, 5, 4]) 2 >>> min_operations_to_sort_sequence(3, [2, 3, 1]) 1 >>> min_operations_to_sort_sequence(6, [1, 2, 3, 4, 5, 6]) 0","solution":"def min_operations_to_sort_sequence(n, sequence): Determine the minimum number of operations required to make the sequence strictly increasing. Args: n (int): The length of the sequence. sequence (List[int]): The sequence of integers. Returns: int: The minimum number of operations. from bisect import bisect_left lis = [] for x in sequence: pos = bisect_left(lis, x) if pos < len(lis): lis[pos] = x else: lis.append(x) # Length of LIS lis_length = len(lis) # Minimum number of operations return n - lis_length"},{"question":"def abs_value(x): Returns the absolute value of the integer x. Args: x (int): The integer to find the absolute value of. Returns: int: The absolute value of the input integer. >>> abs_value(5) 5 >>> abs_value(-5) 5 >>> abs_value(0) 0 >>> abs_value(123456789) 123456789 >>> abs_value(-123456789) 123456789","solution":"def abs_value(x): Returns the absolute value of the integer x. if x < 0: return -x return x"},{"question":"import heapq from typing import List def minimumEffortPath(heights: List[List[int]]) -> int: A 2D grid is represented as a list of lists of integers, where each integer represents the height of a position in the grid. You are currently located on the top-left position (0, 0) and would like to reach the bottom-right position (n-1, m-1) with the minimum effort. Effort is defined as the absolute difference in height between two consecutive positions in the path. Find a path from the top-left to the bottom-right position such that the maximum effort along the path is minimized. Return the minimum effort required to reach the destination. Example: >>> minimumEffortPath([[1, 2, 2], [3, 8, 2], [5, 3, 5]]) 2 >>> minimumEffortPath([[1, 2, 3], [3, 8, 4], [5, 3, 5]]) 1 >>> minimumEffortPath([[1, 2, 1, 1, 1], [1, 2, 1, 2, 1], [1, 2, 1, 2, 1], [1, 2, 1, 2, 1], [1, 1, 1, 2, 1]]) 0 Constraints: - heights.length == n - heights[i].length == m - 1 <= n, m <= 100 - 1 <= heights[i][j] <= 10^6 def test_example_1(): heights = [[1, 2, 2], [3, 8, 2], [5, 3, 5]] assert minimumEffortPath(heights) == 2 def test_example_2(): heights = [[1, 2, 3], [3, 8, 4], [5, 3, 5]] assert minimumEffortPath(heights) == 1 def test_example_3(): heights = [[1, 2, 1, 1, 1], [1, 2, 1, 2, 1], [1, 2, 1, 2, 1], [1, 2, 1, 2, 1], [1, 1, 1, 2, 1]] assert minimumEffortPath(heights) == 0 def test_single_cell(): heights = [[1]] assert minimumEffortPath(heights) == 0 def test_large_difference(): heights = [[1, 10], [10, 1]] assert minimumEffortPath(heights) == 9 def test_uniform_grid(): heights = [[1, 1, 1], [1, 1, 1], [1, 1, 1]] assert minimumEffortPath(heights) == 0","solution":"import heapq def minimumEffortPath(heights): def neighbors(x, y): for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < len(heights) and 0 <= ny < len(heights[0]): yield nx, ny def get_effort(x, y, nx, ny): return abs(heights[nx][ny] - heights[x][y]) n, m = len(heights), len(heights[0]) effort = [[float('inf')] * m for _ in range(n)] effort[0][0] = 0 pq = [(0, 0, 0)] # (effort, x, y) while pq: current_effort, x, y = heapq.heappop(pq) if x == n - 1 and y == m - 1: return current_effort for nx, ny in neighbors(x, y): new_effort = max(current_effort, get_effort(x, y, nx, ny)) if new_effort < effort[nx][ny]: effort[nx][ny] = new_effort heapq.heappush(pq, (new_effort, nx, ny)) return -1 # Should never reach here for valid input"},{"question":"from typing import List def max_sliding_window(nums: List[int], k: int) -> List[int]: Returns a list of the maximum elements in the sliding window of size k for each position the window slides through the array. >>> max_sliding_window([1, 3, -1, -3, 5, 3, 6, 7], 3) [3, 3, 5, 5, 6, 7] >>> max_sliding_window([9, 11], 2) [11] pass # Unit tests def test_example_1(): assert max_sliding_window([1, 3, -1, -3, 5, 3, 6, 7], 3) == [3, 3, 5, 5, 6, 7] def test_example_2(): assert max_sliding_window([9, 11], 2) == [11] def test_single_element(): assert max_sliding_window([1], 1) == [1] def test_large_k(): assert max_sliding_window([1, 2, 3, 4, 5], 5) == [5] def test_all_negative(): assert max_sliding_window([-1, -3, -5, -7], 2) == [-1, -3, -5] def test_decreasing_sequence(): assert max_sliding_window([5, 4, 3, 2, 1], 2) == [5, 4, 3, 2] def test_increasing_sequence(): assert max_sliding_window([1, 2, 3, 4, 5], 2) == [2, 3, 4, 5] def test_empty_list(): assert max_sliding_window([], 3) == [] def test_k_greater_than_list_length(): assert max_sliding_window([1, 2, 3], 4) == []","solution":"from collections import deque def max_sliding_window(nums, k): Returns a list of the maximum elements in the sliding window of size k for each position the window slides through the array. if not nums or k == 0: return [] n = len(nums) deq = deque() result = [] for i in range(n): # Remove elements not in the window while deq and deq[0] < i - k + 1: deq.popleft() # Remove smaller elements in k range as they are useless while deq and nums[deq[-1]] < nums[i]: deq.pop() # Add new element index deq.append(i) # Append the max value in current window to result if i >= k - 1: result.append(nums[deq[0]]) return result"},{"question":"def longest_string(strings: List[str]) -> str: Returns the longest string from an array of strings. If there are multiple strings of the same maximum length, the function returns the one that appears first in the array. >>> longest_string([\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"]) == \\"banana\\" >>> longest_string([\\"one\\", \\"three\\", \\"two\\"]) == \\"three\\" >>> longest_string([\\"cat\\", \\"dog\\", \\"mouse\\", \\"elephant\\"]) == \\"elephant\\" >>> longest_string([\\"a\\", \\"bc\\", \\"de\\", \\"fg\\"]) == \\"bc\\" >>> longest_string([]) == ''","solution":"def longest_string(strings): Returns the longest string from an array of strings. If there are multiple strings of the same maximum length, the function returns the one that appears first in the array. if not strings: return '' longest = strings[0] for s in strings[1:]: if len(s) > len(longest): longest = s return longest"},{"question":"def can_arrange_flowers(N: int, intervals: List[Tuple[int, int]]) -> bool: Determine if it's possible to arrange flowers such that there is always at least one flower blooming at any given time from the earliest blooming time to the latest wilting time. Args: N (int): Number of flowers. intervals (List[Tuple[int, int]]): List of tuples containing blooming and wilting times. Returns: bool: True if it's possible to arrange the flowers, False otherwise. >>> can_arrange_flowers(3, [(1, 4), (5, 8), (2, 6)]) True >>> can_arrange_flowers(3, [(1, 3), (4, 6), (7, 9)]) False","solution":"def can_arrange_flowers(N, intervals): Determine if it's possible to arrange flowers such that there is always at least one flower blooming at any given time from the earliest blooming time to the latest wilting time. Parameters: N (int): Number of flowers. intervals (list): List of tuples containing blooming and wilting times. Returns: bool: True if it's possible to arrange the flowers, False otherwise. # Sort intervals by blooming time intervals.sort() # Initialize the end variable with the ending time of the first interval end = intervals[0][1] for i in range(1, N): # If the next flower blooms after the current one has wilted, return False if intervals[i][0] > end: return False # Update the end to the maximum wilting time encountered end = max(end, intervals[i][1]) return True def flowers_blooming_possible(N, data): if can_arrange_flowers(N, data): print(\\"YES\\") else: print(\\"NO\\")"},{"question":"def maximalRectangle(matrix): Given a rectangular 2D grid, find the size of the largest rectangle containing only 1s and return its area. >>> maximalRectangle([ ... [\\"1\\",\\"0\\",\\"1\\",\\"0\\",\\"0\\"], ... [\\"1\\",\\"0\\",\\"1\\",\\"1\\",\\"1\\"], ... [\\"1\\",\\"1\\",\\"1\\",\\"1\\",\\"1\\"], ... [\\"1\\",\\"0\\",\\"0\\",\\"1\\",\\"0\\"] ... ]) 6 >>> maximalRectangle([ ... [\\"0\\"] ... ]) 0 >>> maximalRectangle([ ... [\\"1\\"] ... ]) 1 >>> maximalRectangle([]) 0 >>> maximalRectangle([ ... [\\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\"] ... ]) 0 >>> maximalRectangle([ ... [\\"1\\",\\"0\\",\\"1\\",\\"1\\"] ... ]) 2 >>> maximalRectangle([ ... [\\"1\\"], ... [\\"1\\"], ... [\\"1\\"] ... ]) 3","solution":"def maximalRectangle(matrix): if not matrix or not matrix[0]: return 0 max_area = 0 cols = len(matrix[0]) heights = [0] * (cols + 1) # extra zero for easier calculation of dimensions for row in matrix: for i in range(cols): heights[i] = heights[i] + 1 if row[i] == '1' else 0 stack = [-1] for i in range(cols + 1): while heights[i] < heights[stack[-1]]: h = heights[stack.pop()] w = i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) return max_area"},{"question":"def longest_alternating_bit_sequence(arr: List[int]) -> int: Returns the length of the longest subsequence that forms an alternating bit sequence. >>> longest_alternating_bit_sequence([5,6,5,6,5]) 5 >>> longest_alternating_bit_sequence([5,6,4,5,6,7]) 4 >>> longest_alternating_bit_sequence([7,7,7,7,7]) 1 >>> longest_alternating_bit_sequence([1,2,3,4,5,6,7,8,9,10]) 2 >>> longest_alternating_bit_sequence([]) 0 >>> longest_alternating_bit_sequence([1]) 1 >>> longest_alternating_bit_sequence([1, 3, 5, 7]) 1 >>> longest_alternating_bit_sequence([1, 2, 1, 2, 1]) 5 >>> longest_alternating_bit_sequence([3,5,4,5,6,7]) 3","solution":"def longest_alternating_bit_sequence(arr): Returns the length of the longest subsequence that forms an alternating bit sequence. if not arr: return 0 n = len(arr) if n == 1: return 1 # dp[i][0] stores max length of alternating sequence ending at arr[i] where last diff was +1 # dp[i][1] stores max length of alternating sequence ending at arr[i] where last diff was -1 dp = [[1, 1] for _ in range(n)] max_length = 1 for i in range(1, n): for j in range(i): if arr[i] - arr[j] == 1: dp[i][0] = max(dp[i][0], dp[j][1] + 1) elif arr[i] - arr[j] == -1: dp[i][1] = max(dp[i][1], dp[j][0] + 1) max_length = max(max_length, dp[i][0], dp[i][1]) return max_length"},{"question":"def highest_average_student(names: List[str], scores: List[Tuple[int, int, int]]) -> str: Given a list of student names and their corresponding scores in three different subjects, find the name of the student who has the highest average score across all three subjects. If multiple students have the same highest average score, return the one whose name comes first lexicographically. >>> highest_average_student([\\"Alice\\", \\"Bob\\", \\"Charlie\\"], [(80, 70, 90), (85, 75, 95), (80, 80, 80)]) 'Bob' >>> highest_average_student([\\"Alice\\", \\"Bob\\"], [(80, 80, 80), (80, 80, 80)]) 'Alice' >>> highest_average_student([], []) 'No students'","solution":"def highest_average_student(names, scores): if not names: return \\"No students\\" max_average = -1 top_student = None for i, name in enumerate(names): average = sum(scores[i]) / len(scores[i]) if average > max_average or (average == max_average and name < top_student): max_average = average top_student = name return top_student"},{"question":"from typing import List def filter_primes(arr: List[int]) -> List[int]: Returns a new array containing only the prime numbers from the original array. >>> filter_primes([4, 6, 8, 9, 10]) == [] >>> filter_primes([2, 3, 5, 7, 11]) == [2, 3, 5, 7, 11] >>> filter_primes([2, 4, 5, 6, 7, 10]) == [2, 5, 7] >>> filter_primes([-2, -3, -5, -7, 2, 3, 5, 7]) == [2, 3, 5, 7] >>> filter_primes([]) == [] >>> filter_primes([7]) == [7] >>> filter_primes([4]) == []","solution":"def is_prime(n): Checks if a number is prime. if n <= 1: return False for i in range(2, int(n**0.5) + 1): if n % i == 0: return False return True def filter_primes(arr): Returns a new array containing only the prime numbers from the original array. return [x for x in arr if is_prime(x)]"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def minDepth(root): Determine the minimum depth of a binary tree. >>> root = TreeNode(3) >>> root.left = TreeNode(9) >>> root.right = TreeNode(20) >>> root.right.left = TreeNode(15) >>> root.right.right = TreeNode(7) >>> minDepth(root) 2 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> minDepth(root) 2 pass # Unit tests def test_single_node_tree(): root = TreeNode(1) assert minDepth(root) == 1 def test_left_skewed_tree(): root = TreeNode(1) root.left = TreeNode(2) root.left.left = TreeNode(3) assert minDepth(root) == 3 def test_right_skewed_tree(): root = TreeNode(1) root.right = TreeNode(2) root.right.right = TreeNode(3) assert minDepth(root) == 3 def test_balanced_tree(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) assert minDepth(root) == 2 def test_tree_with_empty_left_child(): root = TreeNode(1) root.right = TreeNode(2) root.right.left = TreeNode(3) assert minDepth(root) == 3 def test_example1(): root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20) root.right.left = TreeNode(15) root.right.right = TreeNode(7) assert minDepth(root) == 2 def test_example2(): root = TreeNode(1) root.left = TreeNode(2) assert minDepth(root) == 2","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def minDepth(root): if root is None: return 0 # If left subtree is Null, check right subtree if root.left is None: return minDepth(root.right) + 1 # If right subtree is Null , check left subtree if root.right is None: return minDepth(root.left) + 1 # If none of the subtree is Null, check both subtrees return min(minDepth(root.left), minDepth(root.right)) + 1"},{"question":"def snake_to_pascal(snake_str: str) -> str: Converts a snake_case string to PascalCase string. Args: snake_str (str): String in snake_case format. Returns: str: String in PascalCase format. >>> snake_to_pascal(\\"hello_world\\") \\"HelloWorld\\" >>> snake_to_pascal(\\"this_is_a_test\\") \\"ThisIsATest\\" >>> snake_to_pascal(\\"convert_me_to_pascal\\") \\"ConvertMeToPascal\\" >>> snake_to_pascal(\\"python_challenge\\") \\"PythonChallenge\\" >>> snake_to_pascal(\\"snake\\") \\"Snake\\" >>> snake_to_pascal(\\"\\") \\"\\"","solution":"def snake_to_pascal(snake_str): Converts a snake_case string to PascalCase string. Args: snake_str (str): String in snake_case format. Returns: str: String in PascalCase format. words = snake_str.split('_') pascal_str = ''.join(word.capitalize() for word in words) return pascal_str"},{"question":"import re def validate_phone_numbers(n: int, phone_numbers: list) -> None: Prints valid phone numbers from the list or \\"None\\" if no valid phone numbers exist. Args: n (int): Number of phone numbers provided. phone_numbers (list): List of input phone numbers as strings. >>> validate_phone_numbers(2, ['1234567890', '0987654321']) 1234567890 0987654321 >>> validate_phone_numbers(3, ['12345abcd9', '09876 54321', 'abcdefghij']) None","solution":"import re def validate_phone_numbers(n, phone_numbers): Prints valid phone numbers from the list or \\"None\\" if no valid phone numbers exist. Args: n (int): Number of phone numbers provided. phone_numbers (list): List of input phone numbers as strings. pattern = re.compile(r'^d{10}') valid_numbers = [] for number in phone_numbers: if pattern.match(number): valid_numbers.append(number) if valid_numbers: for number in valid_numbers: print(number) else: print(\\"None\\")"},{"question":"def list_to_string(lst: List[int]) -> str: Returns a string representation of the list where each integer is separated by a comma and a space. If the list is empty, returns the string \\"empty list\\". >>> list_to_string([1, 2, 3, 4, 5]) == \\"1, 2, 3, 4, 5\\" >>> list_to_string([10, 20, 30]) == \\"10, 20, 30\\" >>> list_to_string([]) == \\"empty list\\"","solution":"def list_to_string(lst): Returns a string representation of the list where each integer is separated by a comma and a space. If the list is empty, returns the string \\"empty list\\". if not lst: return \\"empty list\\" return \\", \\".join(map(str, lst))"},{"question":"from typing import List, Tuple def max_non_adjacent_sum(arr: List[int]) -> int: Returns the maximum sum of non-adjacent elements in the sequence arr. >>> max_non_adjacent_sum([3, 2, 5, 10]) 13 >>> max_non_adjacent_sum([3, 2, 7, 10, 12]) 22 >>> max_non_adjacent_sum([-1, -2, -3, -4]) 0 >>> max_non_adjacent_sum([0, 0, 0, 0]) 0 >>> max_non_adjacent_sum([1]) 1 >>> max_non_adjacent_sum([]) 0 >>> max_non_adjacent_sum([2, 4, 6, 2, 5]) 13 >>> max_non_adjacent_sum([5, 1, 1, 5]) 10 pass def solve_max_non_adjacent_sums(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Returns the maximum sum of non-adjacent elements for each test case. :param test_cases: A list of tuples, each tuple containing an integer N and a list of N integers. :return: A list of integers representing the result for each test case. >>> test_cases = [(4, [3, 2, 5, 10]), (5, [3, 2, 7, 10, 12])] >>> solve_max_non_adjacent_sums(test_cases) [13, 22] >>> test_cases = [(4, [3, 2, 5, 10]), (5, [3, 2, 7, 10, 12]), (10, [3, 2, 5, 10, 1, 12, 1, 2, 3, 1]), (4, [-1, -2, -3, -4]), (4, [0, 0, 0, 0])] >>> solve_max_non_adjacent_sums(test_cases) [13, 22, 28, 0, 0] pass","solution":"def max_non_adjacent_sum(arr): Returns the maximum sum of non-adjacent elements in the sequence arr. if not arr: return 0 if len(arr) == 1: return max(0, arr[0]) max_excluding_prev = 0 max_including_prev = 0 for num in arr: new_max_including_prev = max_excluding_prev + num max_excluding_prev = max(max_excluding_prev, max_including_prev) max_including_prev = new_max_including_prev return max(max_including_prev, max_excluding_prev) def solve_max_non_adjacent_sums(test_cases): results = [] for N, sequence in test_cases: results.append(max_non_adjacent_sum(sequence)) return results"},{"question":"def max_product(nums: List[int]) -> int: Returns the maximum product of two distinct elements in the array. >>> max_product([3, 4, 5, 2]) 20 >>> max_product([1, 5, 4, 5]) 25 from solution import max_product def test_example_1(): assert max_product([3, 4, 5, 2]) == 20 def test_example_2(): assert max_product([1, 5, 4, 5]) == 25 def test_two_elements(): assert max_product([1, 2]) == 2 def test_larger_numbers(): assert max_product([10, 15, 20, 5, 30]) == 600 def test_with_zeros(): assert max_product([0, 2, 3, 0]) == 6 def test_with_all_same_numbers(): assert max_product([5, 5, 5, 5]) == 25","solution":"def max_product(nums): Returns the maximum product of two distinct elements in the array. # Sort the array in descending order. nums.sort(reverse=True) # The maximum product will be the product of the two largest elements # in the sorted array. return nums[0] * nums[1]"},{"question":"def min_jumps(nums): Determines the minimum number of jumps required to reach the last index. Parameters: nums (list): List of integers representing the maximum jump length at each position. Returns: int: Minimum number of jumps to reach the end or -1 if it is not possible. Examples: >>> min_jumps([2, 3, 1, 1, 4]) 2 >>> min_jumps([3, 2, 1, 0, 4]) -1 >>> min_jumps([0]) 0 >>> min_jumps([1, 0]) 1 >>> min_jumps([1, 1, 1, 1]) 3 >>> min_jumps([10, 1, 1, 1, 1]) 1","solution":"def min_jumps(nums): Determines the minimum number of jumps required to reach the last index. Parameters: nums (list): List of integers representing the maximum jump length at each position. Returns: int: Minimum number of jumps to reach the end or -1 if it is not possible. if len(nums) <= 1: return 0 jumps = 0 current_end = 0 farthest = 0 for i in range(len(nums) - 1): farthest = max(farthest, i + nums[i]) if i == current_end: jumps += 1 current_end = farthest if current_end >= len(nums) - 1: return jumps return -1 # if we exit the loop, it means we can't reach the end"},{"question":"import heapq from typing import List, Tuple class TaskScheduler: def __init__(self): self.task_list = [] self.task_set = set() def add_task(self, y): Adds a task with priority y to the task list. pass def remove_task(self, y): Removes a task with priority y from the task list. If no task with priority y exists, do nothing. pass def query_highest_priority(self): Queries the highest priority task currently in the task list. If the task list is empty, return -1. pass def simulate_task_scheduling(p: int, r: int, operations: List[Tuple[int, int]]) -> List[int]: Simulates the task scheduling system based on the provided operations and returns the result of each query operation. >>> simulate_task_scheduling(5, 7, [(1, 3), (1, 1), (3, 0), (2, 3), (1, 2), (3, 0), (1, 5)]) == [3, 2] >>> simulate_task_scheduling(3, 5, [(1, 2), (2, 2), (3, 0), (1, 1), (3, 0)]) == [-1, 1] >>> simulate_task_scheduling(1, 3, [(1, 1), (2, 1), (3, 0)]) == [-1] >>> simulate_task_scheduling(4, 6, [(1, 4), (3, 0), (1, 3), (2, 4), (3, 0), (2, 3)]) == [4, 3] >>> simulate_task_scheduling(2, 4, [(1, 2), (1, 1), (3, 0), (2, 2)]) == [2] >>> simulate_task_scheduling(5, 8, [(1, 5), (1, 3), (3, 0), (1, 4), (2, 5), (3, 0)]) == [5, 4] pass","solution":"import heapq class TaskScheduler: def __init__(self): self.task_list = [] self.task_set = set() def add_task(self, y): if y not in self.task_set: heapq.heappush(self.task_list, -y) self.task_set.add(y) def remove_task(self, y): if y in self.task_set: self.task_set.remove(y) def query_highest_priority(self): while self.task_list and -self.task_list[0] not in self.task_set: heapq.heappop(self.task_list) if self.task_list: return -self.task_list[0] else: return -1 def simulate_task_scheduling(p, r, operations): scheduler = TaskScheduler() results = [] for operation in operations: if operation[0] == 1: scheduler.add_task(operation[1]) elif operation[0] == 2: scheduler.remove_task(operation[1]) elif operation[0] == 3: results.append(scheduler.query_highest_priority()) return results"},{"question":"def hamming_distance(str1: str, str2: str) -> int: Compute the Hamming distance between two strings of equal length. Parameters: str1 (str): The first string. str2 (str): The second string. Returns: int: The Hamming distance between str1 and str2. >>> hamming_distance(\\"karolin\\", \\"kathrin\\") 3 >>> hamming_distance(\\"abc\\", \\"abc\\") 0 >>> hamming_distance(\\"a\\", \\"b\\") 1 pass import pytest def test_hamming_distance_same_strings(): assert hamming_distance(\\"abc\\", \\"abc\\") == 0 def test_hamming_distance_karolin_kathrin(): assert hamming_distance(\\"karolin\\", \\"kathrin\\") == 3 def test_hamming_distance_empty_strings(): assert hamming_distance(\\"\\", \\"\\") == 0 def test_hamming_distance_single_char(): assert hamming_distance(\\"a\\", \\"b\\") == 1 def test_hamming_distance_single_char_same(): assert hamming_distance(\\"a\\", \\"a\\") == 0 def test_hamming_distance_different_lengths(): try: hamming_distance(\\"abc\\", \\"abcd\\") except ValueError as e: assert str(e) == \\"Strings must be of equal length\\" if __name__ == \\"__main__\\": pytest.main()","solution":"def hamming_distance(str1: str, str2: str) -> int: Compute the Hamming distance between two strings of equal length. Parameters: str1 (str): The first string. str2 (str): The second string. Returns: int: The Hamming distance between str1 and str2. if len(str1) != len(str2): raise ValueError(\\"Strings must be of equal length\\") distance = 0 for i in range(len(str1)): if str1[i] != str2[i]: distance += 1 return distance"},{"question":"def is_advanced_palindrome(s: str) -> bool: Checks if the given string s is a palindrome by considering all characters and case sensitivity. >>> is_advanced_palindrome(\\"A man, a plan, a canal, Panama\\") False >>> is_advanced_palindrome(\\"No lemon, no melon\\") False >>> is_advanced_palindrome(\\"Able was I ere I saw Elba\\") False >>> is_advanced_palindrome(\\"abba\\") True >>> is_advanced_palindrome(\\"aBba\\") False >>> is_advanced_palindrome(\\"a\\") True >>> is_advanced_palindrome(\\"\\") True >>> is_advanced_palindrome(\\"!@@!\\") True","solution":"def is_advanced_palindrome(s: str) -> bool: Checks if the given string s is a palindrome by considering all characters and case sensitivity. return s == s[::-1]"},{"question":"def longest_contiguous_subarray(arr: List[int]) -> int: Find the maximum length of a contiguous subarray within the given array where the absolute difference between any two elements is less than or equal to 1. Args: arr (list of int): List of integers. Returns: int: Length of the longest contiguous subarray. Examples: >>> longest_contiguous_subarray([8, 2, 3, 3, 2, 4, 8, 9]) 4 >>> longest_contiguous_subarray([1, 1, 1, 1, 1]) 5","solution":"def longest_contiguous_subarray(arr): Find the maximum length of a contiguous subarray within the given array where the absolute difference between any two elements is less than or equal to 1. Args: arr (list of int): List of integers. Returns: int: Length of the longest contiguous subarray. if not arr: return 0 # Initialize variables max_length = 1 current = 1 # Traverse the array for i in range(1, len(arr)): if abs(arr[i] - arr[i - 1]) <= 1: current += 1 else: max_length = max(max_length, current) current = 1 max_length = max(max_length, current) # Return the longest length found return max_length"},{"question":"def two_sum_exists(arr, target): Returns \\"YES\\" if there are two distinct elements in the array that add up to the target sum. Returns \\"NO\\" otherwise. >>> two_sum_exists([1, 2, 3, 4, 5], 9) \\"YES\\" >>> two_sum_exists([1, 2, 3, 4, 5], 10) \\"NO\\" >>> two_sum_exists([5], 10) \\"NO\\" >>> two_sum_exists([-1, -2, -3, -4, -5], -8) \\"YES\\" >>> two_sum_exists([-1, -2, -3, -4, -5], -10) \\"NO\\" >>> two_sum_exists([-1, 2, -3, 4, 5], 1) \\"YES\\" >>> two_sum_exists([-1, 2, -3, 4, 5], 10) \\"NO\\" >>> two_sum_exists([0, 0, 1, 2, 3], 0) \\"YES\\" >>> two_sum_exists([0, 1, 2, 3, 4], 6) \\"YES\\"","solution":"def two_sum_exists(arr, target): Returns \\"YES\\" if there are two distinct elements in the array that add up to the target sum. Returns \\"NO\\" otherwise. seen = set() for number in arr: if target - number in seen: return \\"YES\\" seen.add(number) return \\"NO\\""},{"question":"def bmi_calculator(weight: float, height: float) -> str: Calculate BMI and classify into categories based on weight and height. >>> bmi_calculator(70, 1.75) \\"Normal weight\\" >>> bmi_calculator(50, 1.6) \\"Underweight\\" >>> bmi_calculator(90, 1.8) \\"Overweight\\" >>> bmi_calculator(110, 1.75) \\"Obesity\\"","solution":"def bmi_calculator(weight, height): Calculate BMI and return the category. Parameters: weight (int/float): Weight in kilograms. height (int/float): Height in meters. Returns: str: The BMI category. bmi = weight / (height ** 2) if bmi < 18.5: return \\"Underweight\\" elif 18.5 <= bmi < 24.9: return \\"Normal weight\\" elif 25 <= bmi < 29.9: return \\"Overweight\\" else: return \\"Obesity\\""},{"question":"def min_jumps(nums: List[int]) -> int: Determines the minimum number of jumps to reach the last index starting from the first index. If it is not possible to reach the last index, return -1. Args: nums (List[int]): An array of integers representing the jumping power from each position on the array. Returns: int: The minimum number of jumps to reach the last index or -1 if not possible. Example: >>> min_jumps([2, 3, 1, 1, 4]) 2 >>> min_jumps([2, 3, 0, 1, 4]) 2 >>> min_jumps([1, 2, 0, 1]) 2 from solution import min_jumps def test_example1(): assert min_jumps([2, 3, 1, 1, 4]) == 2 def test_example2(): assert min_jumps([2, 3, 0, 1, 4]) == 2 def test_example3(): assert min_jumps([1, 2, 0, 1]) == 2 def test_single_element(): assert min_jumps([0]) == 0 def test_not_possible(): assert min_jumps([0, 2, 3]) == -1 def test_all_ones(): assert min_jumps([1, 1, 1, 1]) == 3 def test_large_jump(): assert min_jumps([5, 1, 1, 1, 1, 1]) == 1 def test_zero_middle(): assert min_jumps([1, 2, 0, 1, 4]) == 3","solution":"def min_jumps(nums): Determines the minimum number of jumps to reach the last index. :param nums: List[int] - An array of integers representing the jumping power. :return: int - The minimum number of jumps to reach the last index or -1 if not possible. if len(nums) <= 1: return 0 jumps = 0 curr_end = 0 farthest = 0 for i in range(len(nums) - 1): farthest = max(farthest, i + nums[i]) if i == curr_end: jumps += 1 curr_end = farthest if curr_end >= len(nums) - 1: break return jumps if curr_end >= len(nums) - 1 else -1"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_of_left_leaves_with_value_one(root): Calculate the sum of all left leaf nodes that have a value of 1. pass from solution import TreeNode, sum_of_left_leaves_with_value_one def test_example_1(): # Input: 1 # / # 0 1 # / / # 1 0 -1 node = TreeNode(1) node.left = TreeNode(0) node.right = TreeNode(1) node.left.left = TreeNode(1) node.right.left = TreeNode(0) node.right.right = TreeNode(-1) assert sum_of_left_leaves_with_value_one(node) == 1 def test_example_2(): # Input: 1 # / # 1 0 # / # 0 -1 1 # / # 1 node = TreeNode(1) node.left = TreeNode(1) node.right = TreeNode(0) node.left.left = TreeNode(0) node.left.right = TreeNode(-1) node.right.right = TreeNode(1) node.right.right.left = TreeNode(1) assert sum_of_left_leaves_with_value_one(node) == 1 def test_example_3(): # Input: -1 node = TreeNode(-1) assert sum_of_left_leaves_with_value_one(node) == 0 def test_no_left_leaves_with_value_1(): # Input: 1 # / # 0 0 node = TreeNode(1) node.left = TreeNode(0) node.right = TreeNode(0) assert sum_of_left_leaves_with_value_one(node) == 0 def test_multiple_left_leaves_with_value_1(): # Input: 1 # / # 1 1 # / # 1 1 node = TreeNode(1) node.left = TreeNode(1) node.right = TreeNode(1) node.left.left = TreeNode(1) node.right.right = TreeNode(1) assert sum_of_left_leaves_with_value_one(node) == 1","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_of_left_leaves_with_value_one(root): Calculate the sum of all left leaf nodes that have a value of 1. def is_leaf(node): return node is not None and node.left is None and node.right is None def dfs(node, is_left): if node is None: return 0 if is_leaf(node): return node.val if is_left and node.val == 1 else 0 return dfs(node.left, True) + dfs(node.right, False) return dfs(root, False)"},{"question":"def string_to_alpha_sum_mod(string): Converts a string to the sum of its characters' alphabetical positions and returns the result modulo 10^9+7. >>> string_to_alpha_sum_mod(\\"abc\\") == 6 >>> string_to_alpha_sum_mod(\\"z\\") == 26 >>> string_to_alpha_sum_mod(\\"hello\\") == 52 MOD = 10**9 + 7 def process_test_cases(t, strings): Processes multiple test cases, computing the alpha sum modulo for each string. >>> process_test_cases(3, [\\"abc\\", \\"z\\", \\"hello\\"]) == [6, 26, 52] >>> process_test_cases(1, [\\"a\\"]) == [1] >>> process_test_cases(2, [\\"ab\\", \\"ba\\"]) == [3, 3]","solution":"def string_to_alpha_sum_mod(string): Converts a string to the sum of its characters' alphabetical positions and returns the result modulo 10^9+7. MOD = 10**9 + 7 total_sum = sum(ord(char) - ord('a') + 1 for char in string) return total_sum % MOD def process_test_cases(t, strings): Processes multiple test cases, computing the alpha sum modulo for each string. results = [] for string in strings: results.append(string_to_alpha_sum_mod(string)) return results # Example usage: # t = 3 # strings = [\\"abc\\", \\"z\\", \\"hello\\"] # print(process_test_cases(t, strings)) # Output: [6, 26, 52]"},{"question":"def generate_strongly_connected_castle(n, m): Generates exactly m one-directional passages that make the castle of n rooms strongly connected. Parameters: n (int): Number of rooms. m (int): Number of passages. Returns: list of tuples: Each tuple contains two integers representing a one-directional passage from room u to room v. Examples: >>> generate_strongly_connected_castle(4, 5) [(1, 2), (2, 3), (3, 4), (4, 1), (1, 3)] >>> generate_strongly_connected_castle(3, 3) [(1, 2), (2, 3), (3, 1)]","solution":"def generate_strongly_connected_castle(n, m): Generates exactly m one-directional passages that make the castle of n rooms strongly connected. Parameters: n (int): Number of rooms. m (int): Number of passages. Returns: list of tuples: Each tuple contains two integers representing a one-directional passage from room u to room v. passages = [] # Step 1: Create a basic ring to ensure strong connectivity for i in range(1, n): passages.append((i, i + 1)) passages.append((n, 1)) # Step 2: Add additional passages if m > n additional_passages_needed = m - n current_room = 1 for i in range(additional_passages_needed): from_room = current_room to_room = (current_room + 2) % n + 1 passages.append((from_room, to_room)) current_room = (current_room % n) + 1 return passages"},{"question":"def sort_digits_in_string(s: str) -> str: Sort all the digits in the string in non-descending order, while leaving the letters in their original positions. >>> sort_digits_in_string(\\"a3b2c1\\") == \\"a1b2c3\\" >>> sort_digits_in_string(\\"s1d2r3\\") == \\"s1d2r3\\" >>> sort_digits_in_string(\\"4f2g1\\") == \\"1f2g4\\" >>> sort_digits_in_string(\\"1a2b3c\\") == \\"1a2b3c\\" >>> sort_digits_in_string(\\"a9b8c7d\\") == \\"a7b8c9d\\" >>> sort_digits_in_string(\\"abc\\") == \\"abc\\" >>> sort_digits_in_string(\\"987xyz654\\") == \\"456xyz789\\" pass def process_input(input_data: str) -> str: Process the input data and return the transformed string for each input. >>> process_input('3na3b2c1ns1d2r3n4f2g1') == 'a1b2c3ns1d2r3n1f2g4' pass","solution":"def sort_digits_in_string(s): Sorts all the digits in the string in non-descending order, while leaving the letters in their original positions. # Extract all the digits from the string digits = sorted([ch for ch in s if ch.isdigit()]) digit_index = 0 result = [] for ch in s: if ch.isdigit(): result.append(digits[digit_index]) digit_index += 1 else: result.append(ch) return ''.join(result) def process_input(input_data): lines = input_data.strip().split('n') T = int(lines[0]) results = [sort_digits_in_string(lines[i + 1]) for i in range(T)] return 'n'.join(results)"},{"question":"def longestPalindromeSubstr(s: str) -> str: Find the longest palindromic substring in a given string. >>> longestPalindromeSubstr(\\"\\") == \\"\\" >>> longestPalindromeSubstr(\\"a\\") == \\"a\\" >>> longestPalindromeSubstr(\\"madam\\") == \\"madam\\" >>> longestPalindromeSubstr(\\"babad\\") in [\\"bab\\", \\"aba\\"] >>> longestPalindromeSubstr(\\"cbbd\\") == \\"bb\\" >>> longestPalindromeSubstr(\\"abcd\\") in [\\"a\\", \\"b\\", \\"c\\", \\"d\\"] >>> longestPalindromeSubstr(\\"abbc\\") == \\"bb\\"","solution":"def longestPalindromeSubstr(s: str) -> str: Function to find the longest palindromic substring. if not s: return \\"\\" if len(s) == 1: return s start = 0 max_length = 1 for i in range(1, len(s)): # Find the longest even length palindrome with center points as i-1 and i. low = i - 1 high = i while low >= 0 and high < len(s) and s[low] == s[high]: if high - low + 1 > max_length: start = low max_length = high - low + 1 low -= 1 high += 1 # Find the longest odd length palindrome with center point as i. low = i - 1 high = i + 1 while low >= 0 and high < len(s) and s[low] == s[high]: if high - low + 1 > max_length: start = low max_length = high - low + 1 low -= 1 high += 1 return s[start:start + max_length]"},{"question":"from typing import List def combination_sum2(arr: List[int], target: int) -> List[List[int]]: Returns all unique combinations of integers in the array that add up to the target sum. Each number in the array may only be used once in the combination. >>> combination_sum2([10, 1, 2, 7, 6, 1, 5], 8) [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]] >>> combination_sum2([1, 2, 3], 10) [] >>> combination_sum2([2, 4, 6, 8], 10) [[2, 8], [4, 6]] >>> combination_sum2([1, 2, 3, 4, 5], 5) [[1, 4], [2, 3], [5]] >>> combination_sum2([1, 1, 2, 5, 6, 7, 10], 8) [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]","solution":"def combination_sum2(arr, target): Returns all unique combinations in arr that add up to target. Each number in arr may only be used once in the combination. def backtrack(start, target, path): if target == 0: result.append(path) return if target < 0: return for i in range(start, len(arr)): if i > start and arr[i] == arr[i-1]: continue backtrack(i + 1, target - arr[i], path + [arr[i]]) arr.sort() result = [] backtrack(0, target, []) return result"},{"question":"from typing import List def maximalRectangle(grid: List[List[int]]) -> int: Given an MxN grid representing a rectangular farm where 0 indicates an empty cell and 1 indicates a tree, find the largest rectangle containing only 0s. >>> >>> def largestRectangleArea(heights: List[int]) -> int: Given a list of heights representing a histogram, find the largest rectangular area possible in the histogram. >>> >>> def process_test_cases(test_cases: List[List[List[int]]]) -> List[int]: Process multiple test cases and return a list of results. Each test case consists of a grid. >>> >>> def parse_input(input_string: str) -> List[List[List[int]]]: Parse the input data into a list of grids representing the test cases. >>> >>> def format_output(results: List[int]) -> str: Format the output data as a string, each result on a new line. >>> >>> def main(input_string: str) -> str: Given the input string, parse the input, process the test cases, and format the output. >>> >>> # Unit Tests import pytest def test_example1(): input_string = \\"2n4 4n0 1 0 0n0 0 0 1n1 0 0 0n1 1 1 0n3 3n1 1 1n1 0 0n1 0 0\\" expected_output = \\"4n4\\" assert main(input_string) == expected_output def test_single_row(): input_string = \\"1n1 5n0 0 1 0 0\\" expected_output = \\"2\\" assert main(input_string) == expected_output def test_single_column(): input_string = \\"1n5 1n0n0n1n0n0\\" expected_output = \\"2\\" assert main(input_string) == expected_output def test_full_of_trees(): input_string = \\"1n4 4n1 1 1 1n1 1 1 1n1 1 1 1n1 1 1 1\\" expected_output = \\"0\\" assert main(input_string) == expected_output def test_full_of_empty(): input_string = \\"1n3 3n0 0 0n0 0 0n0 0 0\\" expected_output = \\"9\\" assert main(input_string) == expected_output if __name__ == \\"__main__\\": pytest.main()","solution":"def maximalRectangle(grid): if not grid: return 0 M, N = len(grid), len(grid[0]) height = [0] * N max_area = 0 for row in grid: for i in range(N): height[i] = height[i] + 1 if row[i] == 0 else 0 max_area = max(max_area, largestRectangleArea(height)) return max_area def largestRectangleArea(heights): stack = [] max_area = 0 heights.append(0) for i in range(len(heights)): while stack and heights[i] < heights[stack[-1]]: h = heights[stack.pop()] w = i if not stack else i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) heights.pop() return max_area def process_test_cases(test_cases): results = [] for grid in test_cases: results.append(maximalRectangle(grid)) return results def parse_input(input_string): lines = input_string.strip().split('n') T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): M, N = map(int, lines[index].split()) index += 1 grid = [] for _ in range(M): grid.append(list(map(int, lines[index].split()))) index += 1 test_cases.append(grid) return test_cases def format_output(results): return 'n'.join(map(str, results)) def main(input_string): test_cases = parse_input(input_string) results = process_test_cases(test_cases) return format_output(results)"},{"question":"def concatenate_strings(string_list: List[str]) -> str: Concatenates a list of strings into a single string separated by commas. If the input list is empty, returns an empty string. Parameters: string_list (list): A list of strings to be concatenated. Returns: str: A single string with all the original strings concatenated together, separated by commas. >>> concatenate_strings([\\"apple\\", \\"banana\\", \\"cherry\\"]) == \\"apple,banana,cherry\\" >>> concatenate_strings([]) == \\"\\"","solution":"def concatenate_strings(string_list): Concatenates a list of strings into a single string separated by commas. If the input list is empty, returns an empty string. Parameters: string_list (list): A list of strings to be concatenated. Returns: str: A single string with all the original strings concatenated together, separated by commas. return ','.join(string_list)"},{"question":"def findUnsortedSubarray(nums: List[int]) -> int: Given an array nums, find the smallest window in nums that, when sorted, will result in the entire array being sorted. If the array is already sorted, return 0. >>> findUnsortedSubarray([]) == 0 >>> findUnsortedSubarray([1, 2, 3, 4]) == 0 >>> findUnsortedSubarray([2, 6, 4, 8, 10, 9, 15]) == 5 >>> findUnsortedSubarray([1, 3, 2, 2, 2]) == 4 >>> findUnsortedSubarray([5, 4, 3, 2, 1]) == 5 >>> findUnsortedSubarray([-1, -3, -2, -2, -5]) == 5 >>> findUnsortedSubarray([1]) == 0 >>> findUnsortedSubarray([1, 2]) == 0 >>> findUnsortedSubarray([2, 1]) == 2","solution":"from typing import List def findUnsortedSubarray(nums: List[int]) -> int: if not nums: return 0 sorted_nums = sorted(nums) start, end = 0, len(nums) - 1 while start < len(nums) and nums[start] == sorted_nums[start]: start += 1 while end > start and nums[end] == sorted_nums[end]: end -= 1 return end - start + 1 if start != len(nums) else 0"},{"question":"def find_average(numbers: List[int]) -> float: Returns the average of the integers in the list. If the list is empty, returns None. >>> find_average([1, 2, 3, 4, 5]) 3.0 >>> find_average([10, -10, 20, -20]) 0.0 >>> find_average([]) None","solution":"def find_average(numbers): Returns the average of the integers in the list. If the list is empty, returns None. if not numbers: return None return sum(numbers) / len(numbers)"},{"question":"def can_provide_resources(N: int, M: int, classroom_requirements: List[List[int]], available_resources: List[int]) -> str: Check if available resources are enough to meet the requirements for all classrooms. >>> can_provide_resources(3, 3, [[1, 2, 3], [3, 2, 1], [2, 2, 2]], [10, 10, 10]) 'Yes' >>> can_provide_resources(2, 2, [[5, 5], [4, 4]], [8, 8]) 'No'","solution":"def can_provide_resources(N, M, classroom_requirements, available_resources): total_requirements = [0] * M # Aggregate the requirements for each resource type for requirement in classroom_requirements: for j in range(M): total_requirements[j] += requirement[j] # Check if available resources meet the total requirements for j in range(M): if available_resources[j] < total_requirements[j]: return \\"No\\" return \\"Yes\\""},{"question":"class TaskManager: A class to assign and manage tasks among team members. Methods: - assign_task(task_name: str, member_name: str) -> bool: Assigns a given task to the specified team member. - complete_task(task_name: str) -> bool: Marks the specified task as completed. - task_status(task_name: str) -> str: Returns the current status of the task. - tasks_of_member(member_name: str) -> List[str]: Returns the current list of tasks assigned to the member in alphabetical order. - members_of_task(task_name: str) -> List[str]: Returns the names of members the task is assigned to in alphabetical order. def __init__(self): pass def assign_task(self, task_name: str, member_name: str) -> bool: pass def complete_task(self, task_name: str) -> bool: pass def task_status(self, task_name: str) -> str: pass def tasks_of_member(self, member_name: str) -> List[str]: pass def members_of_task(self, task_name: str) -> List[str]: pass # Example if __name__ == \\"__main__\\": tm = TaskManager() print(tm.assign_task(\\"TaskA\\", \\"Alice\\")) # True print(tm.assign_task(\\"TaskB\\", \\"Bob\\")) # True print(tm.task_status(\\"TaskA\\")) # 'assigned' print(tm.task_status(\\"TaskC\\")) # 'unassigned' print(tm.tasks_of_member(\\"Alice\\")) # ['TaskA'] print(tm.complete_task(\\"TaskA\\")) # True print(tm.complete_task(\\"TaskA\\")) # False (already completed) print(tm.tasks_of_member(\\"Alice\\")) # [] (no current tasks) print(tm.task_status(\\"TaskA\\")) # 'completed' print(tm.assign_task(\\"TaskA\\", \\"Alice\\")) # False (already completed) print(tm.assign_task(\\"TaskC\\", \\"Bob\\")) # True print(tm.members_of_task(\\"TaskC\\")) # ['Bob'] # Unit Tests def test_assign_task(): tm = TaskManager() assert tm.assign_task(\\"TaskA\\", \\"Alice\\") == False tm.members[\\"Alice\\"] = [] assert tm.assign_task(\\"TaskA\\", \\"Alice\\") == True assert tm.assign_task(\\"TaskA\\", \\"Bob\\") == False def test_complete_task(): tm = TaskManager() tm.members[\\"Alice\\"] = [] tm.assign_task(\\"TaskA\\", \\"Alice\\") assert tm.complete_task(\\"TaskA\\") == True assert tm.complete_task(\\"TaskA\\") == False assert tm.complete_task(\\"TaskB\\") == False def test_task_status(): tm = TaskManager() tm.members[\\"Alice\\"] = [] tm.assign_task(\\"TaskA\\", \\"Alice\\") assert tm.task_status(\\"TaskA\\") == 'assigned' tm.complete_task(\\"TaskA\\") assert tm.task_status(\\"TaskA\\") == 'completed' assert tm.task_status(\\"TaskB\\") == 'unassigned' def test_tasks_of_member(): tm = TaskManager() tm.members[\\"Alice\\"] = [] tm.members[\\"Bob\\"] = [] tm.assign_task(\\"TaskA\\", \\"Alice\\") tm.assign_task(\\"TaskB\\", \\"Alice\\") tm.assign_task(\\"TaskC\\", \\"Bob\\") assert tm.tasks_of_member(\\"Alice\\") == ['TaskA', 'TaskB'] assert tm.tasks_of_member(\\"Bob\\") == ['TaskC'] assert tm.tasks_of_member(\\"Charlie\\") == [] def test_members_of_task(): tm = TaskManager() tm.members[\\"Alice\\"] = [] tm.assign_task(\\"TaskA\\", \\"Alice\\") assert tm.members_of_task(\\"TaskA\\") == ['Alice'] assert tm.members_of_task(\\"TaskB\\") == []","solution":"class TaskManager: def __init__(self): self.tasks = {} self.members = {} def assign_task(self, task_name, member_name): if task_name in self.tasks: if self.tasks[task_name]['status'] == 'completed': return False if self.tasks[task_name]['member'] is not None and self.tasks[task_name]['member'] != member_name: return False if member_name not in self.members: return False self.tasks[task_name] = {'status': 'assigned', 'member': member_name} if member_name not in self.members: self.members[member_name] = [] self.members[member_name].append(task_name) return True def complete_task(self, task_name): if task_name not in self.tasks or self.tasks[task_name]['status'] != 'assigned': return False self.tasks[task_name]['status'] = 'completed' member = self.tasks[task_name]['member'] self.members[member].remove(task_name) return True def task_status(self, task_name): if task_name not in self.tasks: return 'unassigned' return self.tasks[task_name]['status'] def tasks_of_member(self, member_name): if member_name not in self.members: return [] return sorted(self.members[member_name]) def members_of_task(self, task_name): if task_name not in self.tasks or self.tasks[task_name]['member'] is None: return [] return [self.tasks[task_name]['member']]"},{"question":"def max_product_of_three(nums: List[int]) -> int: Returns the product of the three integers in the list that form the largest possible product. If the list has fewer than three integers, returns None. >>> max_product_of_three([1, 10, -5, 1, -100]) 5000 >>> max_product_of_three([1, 2]) None","solution":"def max_product_of_three(nums): Returns the product of the three integers in the list that form the largest possible product. If the list has fewer than three integers, returns None. if len(nums) < 3: return None nums.sort() return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])"},{"question":"def maxProfit(prices: List[int]) -> int: You are given an array of integers representing the stock prices of a company on different days. The function should return the maximum profit achievable by performing a single buy and a single sell operation. If it is not possible to make any profit, return 0. Examples: >>> maxProfit([7, 1, 5, 3, 6, 4]) 5 >>> maxProfit([7, 6, 4, 3, 1]) 0","solution":"def maxProfit(prices): Returns the maximum profit that can be achieved by performing a single buy and a single sell operation. If no profit can be made, returns 0. if not prices or len(prices) < 2: return 0 min_price = prices[0] max_profit = 0 for price in prices: if price < min_price: min_price = price else: potential_profit = price - min_price if potential_profit > max_profit: max_profit = potential_profit return max_profit"},{"question":"def count_total_set_bits(n: int) -> int: Given a positive integer n, return the total number of set bits (1s) in the binary representation of all numbers from 1 to n. >>> count_total_set_bits(2) 2 >>> count_total_set_bits(5) 7 >>> count_total_set_bits(10) 17","solution":"def count_total_set_bits(n): Given a positive integer n, return the total number of set bits (1s) in the binary representation of all numbers from 1 to n. :param n: a positive integer :return: total number of set bits in binary representations of numbers from 1 to n def count_set_bits(x): count = 0 while x: count += x & 1 x >>= 1 return count total_set_bits = 0 for i in range(1, n+1): total_set_bits += count_set_bits(i) return total_set_bits"},{"question":"def find_duplicate_numbers(nums: List[int]) -> List[int]: Write a function \`find_duplicate_numbers\` that takes a list of integers \`nums\` and returns a list of integers that are duplicates in the input list. The order of the returned list should be the same as the first occurrence of each duplicate in the input list. If no duplicates are found, return an empty list. :param nums: List of integers :return: List of integer duplicates Example: >>> find_duplicate_numbers([1, 2, 3, 2, 4, 5, 3, 6, 4]) [2, 3, 4] >>> find_duplicate_numbers([1, 2, 3, 4, 5]) [] >>> find_duplicate_numbers([5, 5, 5, 5, 5]) [5]","solution":"def find_duplicate_numbers(nums): Returns a list of duplicate numbers from the input list \`nums\`. The order of the returned list matches the first occurrence of each duplicate. :param nums: List of integers :return: List of integer duplicates seen = set() duplicates = [] for num in nums: if num in seen and num not in duplicates: duplicates.append(num) seen.add(num) return duplicates"},{"question":"def aliquot_divisors(lst): Given a list of non-negative integers, return a list of the same length where each element represents the count of how many aliquot divisors the original element has. An aliquot divisor of a number is any divisor of that number excluding the number itself. Args: lst (List[int]): List of non-negative integers Returns: List[int]: List where each element represents the count of how many aliquot divisors the original element has. Examples: >>> aliquot_divisors([6, 8, 10]) [3, 3, 3] >>> aliquot_divisors([0, 1, 2, 3, 5]) [0, 0, 1, 1, 1]","solution":"def aliquot_divisors(lst): Takes a list of non-negative integers and returns a list where each element represents the count of how many aliquot divisors the original element has. def count_aliquot_divisors(n): if n == 0: return 0 divisors = [i for i in range(1, n) if n % i == 0] return len(divisors) return [count_aliquot_divisors(x) for x in lst]"},{"question":"def two_sum(nums, target): Given an array of integers and a target integer, find two distinct integers in the array that sum up to the target value. Implement a function that returns the indices of these two integers. If no such integers exist, return \`null\`. The input to the function is an array of integers and a target integer. The function should return an array of indices \`[index1, index2]\` with \`index1\` being less than \`index2\`. Example: >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([3, 2, 4], 6) [1, 2] >>> two_sum([1], 1) None >>> two_sum([1, 5, 1, 3], 6) [0, 1] >>> two_sum([-3, 4, 3, 90], 0) [0, 2] >>> two_sum([3, 0, 4, 6, -3], 0) [0, 4] >>> two_sum([1000000, 300, 700, 3000000], 4000000) [0, 3]","solution":"def two_sum(nums, target): Returns the indices of the two distinct integers in the array that sum up to the target value. num_to_index = {} for index, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], index] num_to_index[num] = index return None"},{"question":"def num_islands(grid: List[List[str]]) -> int: Calculate the number of distinct islands in the grid. In a 2-dimensional grid, consider some cells as \\"islands\\" if they are filled (indicated by '1') and some as \\"water\\" (indicated by '0'). An island is surrounded by water and is formed by connecting horizontal or vertical adjacent land cells. Arguments: grid: A list of list of strings representing the grid. Returns: An integer count of the number of distinct islands. >>> num_islands([ ... [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], ... [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], ... [\\"0\\",\\"0\\",\\"1\\",\\"0\\",\\"0\\"], ... [\\"0\\",\\"0\\",\\"0\\",\\"1\\",\\"1\\"] ... ]) 3 >>> num_islands([[\\"1\\", \\"1\\", \\"0\\", \\"0\\", \\"1\\"]]) 2 >>> num_islands([[\\"0\\", \\"0\\", \\"0\\", \\"0\\", \\"0\\"]]) 0 from solution import num_islands def test_num_islands_empty_grid(): assert num_islands([]) == 0 def test_num_islands_single_cell(): assert num_islands([[\\"1\\"]]) == 1 assert num_islands([[\\"0\\"]]) == 0 def test_num_islands_single_row(): assert num_islands([[\\"1\\", \\"1\\", \\"0\\", \\"0\\", \\"1\\"]]) == 2 def test_num_islands_single_column(): assert num_islands([[\\"1\\"], [\\"1\\"], [\\"0\\"], [\\"0\\"], [\\"1\\"]]) == 2 def test_num_islands_example_case(): grid = [ [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], [\\"0\\",\\"0\\",\\"1\\",\\"0\\",\\"0\\"], [\\"0\\",\\"0\\",\\"0\\",\\"1\\",\\"1\\"] ] assert num_islands(grid) == 3 def test_num_islands_all_land(): grid = [ [\\"1\\",\\"1\\",\\"1\\"], [\\"1\\",\\"1\\",\\"1\\"], [\\"1\\",\\"1\\",\\"1\\"] ] assert num_islands(grid) == 1 def test_num_islands_all_water(): grid = [ [\\"0\\",\\"0\\",\\"0\\"], [\\"0\\",\\"0\\",\\"0\\"], [\\"0\\",\\"0\\",\\"0\\"] ] assert num_islands(grid) == 0","solution":"def num_islands(grid): if not grid: return 0 n, m = len(grid), len(grid[0]) num_islands = 0 def dfs(i, j): if i < 0 or i >= n or j < 0 or j >= m or grid[i][j] == '0': return grid[i][j] = '0' # mark as visited # explore neighbors dfs(i + 1, j) dfs(i - 1, j) dfs(i, j + 1) dfs(i, j - 1) for i in range(n): for j in range(m): if grid[i][j] == '1': num_islands += 1 dfs(i, j) return num_islands"},{"question":"from typing import List def has_repeated_substring_pattern(s: str) -> str: Check if the string can be formed by multiple copies of some substring. >>> has_repeated_substring_pattern(\\"abab\\") == \\"YES\\" >>> has_repeated_substring_pattern(\\"abcd\\") == \\"NO\\" >>> has_repeated_substring_pattern(\\"abcabcabc\\") == \\"YES\\" >>> has_repeated_substring_pattern(\\"aabb\\") == \\"NO\\" pass def check_strings_for_pattern(T: int, test_cases: List[str]) -> List[str]: For each test case string, determine if it has the special repeated substring pattern. >>> T = 4 >>> test_cases = [\\"abab\\", \\"abcd\\", \\"abcabcabc\\", \\"aabb\\"] >>> check_strings_for_pattern(T, test_cases) == [\\"YES\\", \\"NO\\", \\"YES\\", \\"NO\\"] pass def test_has_repeated_substring_pattern(): assert has_repeated_substring_pattern(\\"abab\\") == \\"YES\\" assert has_repeated_substring_pattern(\\"abcabcabc\\") == \\"YES\\" assert has_repeated_substring_pattern(\\"aaa\\") == \\"YES\\" assert has_repeated_substring_pattern(\\"abac\\") == \\"NO\\" assert has_repeated_substring_pattern(\\"abcd\\") == \\"NO\\" assert has_repeated_substring_pattern(\\"aabb\\") == \\"NO\\" assert has_repeated_substring_pattern(\\"a\\") == \\"NO\\" assert has_repeated_substring_pattern(\\"aa\\") == \\"YES\\" assert has_repeated_substring_pattern(\\"aaaaa\\") == \\"YES\\" def test_check_strings_for_pattern(): T = 4 test_cases = [\\"abab\\", \\"abcd\\", \\"abcabcabc\\", \\"aabb\\"] expected = [\\"YES\\", \\"NO\\", \\"YES\\", \\"NO\\"] assert check_strings_for_pattern(T, test_cases) == expected T = 6 test_cases = [\\"a\\", \\"aa\\", \\"aaa\\", \\"aabb\\", \\"ababab\\", \\"abcabc\\"] expected = [\\"NO\\", \\"YES\\", \\"YES\\", \\"NO\\", \\"YES\\", \\"YES\\"] assert check_strings_for_pattern(T, test_cases) == expected","solution":"def has_repeated_substring_pattern(s): Check if the string can be formed by multiple copies of some substring. n = len(s) for i in range(1, n // 2 + 1): if n % i == 0: if s[:i] * (n // i) == s: return \\"YES\\" return \\"NO\\" def check_strings_for_pattern(T, test_cases): For each test case string, determine if it has the special repeated substring pattern. results = [has_repeated_substring_pattern(tc) for tc in test_cases] return results"}]`),S={name:"App",components:{PoemCard:N},data(){return{searchQuery:"",visibleCount:4,poemsData:j,isLoading:!1}},computed:{filteredPoems(){const n=this.searchQuery.trim().toLowerCase();return n?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(n)||e.solution&&e.solution.toLowerCase().includes(n)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(n=>setTimeout(n,1e3)),this.visibleCount+=4,this.isLoading=!1}}},E={class:"search-container"},C={class:"card-container"},F={key:0,class:"empty-state"},P=["disabled"],D={key:0},I={key:1};function z(n,e,l,_,i,a){const f=p("PoemCard");return s(),r("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",E,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),g(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>i.searchQuery=o),placeholder:"Search..."},null,512),[[b,i.searchQuery]]),i.searchQuery?(s(),r("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>i.searchQuery="")}," ✕ ")):u("",!0)]),t("div",C,[(s(!0),r(w,null,v(a.displayedPoems,(o,h)=>(s(),x(f,{key:h,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(s(),r("div",F,' No results found for "'+d(i.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(s(),r("button",{key:0,class:"load-more-button",disabled:i.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[i.isLoading?(s(),r("span",I,"Loading...")):(s(),r("span",D,"See more"))],8,P)):u("",!0)])}const M=c(S,[["render",z],["__scopeId","data-v-8bab2e8d"]]),B=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"grok/56.md","filePath":"grok/56.md"}'),O={name:"grok/56.md"},G=Object.assign(O,{setup(n){return(e,l)=>(s(),r("div",null,[y(M)]))}});export{B as __pageData,G as default};
