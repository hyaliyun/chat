import{_ as c,o as n,c as i,a as t,m as h,t as d,C as g,M as y,U as _,f as u,F as b,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},I={class:"review-title"},A={class:"review-content"};function E(r,e,l,p,s,a){return n(),i("div",T,[t("div",q,[t("div",I,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),h(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",A,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),h(d(l.poem.solution),1)])])])}const S=c(k,[["render",E],["__scopeId","data-v-8dea244b"]]),z=JSON.parse('[{"question":"<|Analysis Begin|> # Core Identification - **Algorithm/Data Structure**: Linked List-based Addition of Numbers - **Complexity**: - **Time Complexity**: O(max(n, m)), where n and m are the number of nodes in the two input linked lists. Each node in both lists is visited once. - **Space Complexity**: O(max(n, m)) for holding the sum linked list. - **Principles**: - Iterate through both linked lists concurrently, adding corresponding digits along with carrying any overflow from the previous digit\'s sum. - Store the result as a new linked list in reverse order, representing the sum digit-by-digit. # Characteristics & Applications - **Properties**: - Each node in the linked list contains a single digit. - The linked list represents the number in reverse order. - The solution handles carrying over with inline addition. - **Common Use Cases**: - Summing large numbers that cannot be comfortably handled using traditional data types due to overflow concerns. - Operations involving numbers stored digit-by-digit, typically in scenarios where digitwise manipulation is necessary (e.g., cryptographic applications). - **Strengths/Limitations**: - **Strengths**: Suitable for adding very large numbers without needing arbitrary-precision arithmetic support. - **Limitations**: Not suitable for non-reversed number representations or applications needing floating-point arithmetic. # Implementation Challenges - **Edge Cases**: - Input linked lists of different lengths. - Input nodes containing zero, especially leading or trailing zeros. - **Performance Bottlenecks**: Limited by the length of the linked lists; excessive digits will impact both time and space requirements proportionally. - **Error Scenarios**: - Handling when one of the input lists is empty. - Ensuring correctness when there\'s a carry over that extends the final result. - **Optimization Points**: - Optimize memory allocation to avoid unnecessary node creation. - Efficient handling of input lists of unequal lengths with reduced redundant operations. <|Analysis End|> <|Question Begin|> # Problem Statement You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list. The resulting linked list should also represent the number in reverse order. # Function Signature ```python class Node: def __init__(self, x): self.val = x self.next = None def add_two_numbers(left: Node, right: Node) -> Node: # Write your implementation here ``` # Input - Two non-empty linked lists `left` and `right` each representing a non-negative integer in reverse order. # Output - A linked list representing the sum of the two input numbers, also in reverse order. # Constraints - The input strings will not contain any leading zero, except the number 0 itself. - The algorithm must handle the carry-over efficiently. # Example Input: - `left`: (2 -> 4 -> 3) represents the number 342. - `right`: (5 -> 6 -> 4) represents the number 465. Output: - 7 -> 0 -> 8 represents the number 807 (342 + 465). # Example Input: - `left`: (9 -> 9) represents the number 99. - `right`: (1) represents the number 1. Output: - 0 -> 0 -> 1 represents the number 100 (99 + 1). # Detailed Requirements - Ensure edge cases are handled correctly, particularly when the linked lists have different lengths. - Consider carrying over when the sum of two digits exceeds 9. - Optimize the solution for both time and space to ensure it performs efficiently with the given constraints. # Hints - You may create a dummy node to simplify edge cases handling and iterate through the nodes using a pointer. - While traversing the input lists simultaneously, use a variable to manage the carry-over from the sum of two digits. # Testing **Example Test Cases**: 1. `(2 -> 4 -> 3)` + `(5 -> 6 -> 4)` should return `(7 -> 0 -> 8)`. 2. `(9 -> 9)` + `(1)` should return `(0 -> 0 -> 1)`. 3. `(0)` + `(0)` should return `(0)`. Implement comprehensive unit tests to validate the solution against various scenarios, and ensure edge cases are covered.","solution":"class Node: def __init__(self, x): self.val = x self.next = None def add_two_numbers(left: Node, right: Node) -> Node: dummy = Node(0) current = dummy carry = 0 while left is not None or right is not None: l_val = left.val if left else 0 r_val = right.val if right else 0 total = l_val + r_val + carry carry = total // 10 current.next = Node(total % 10) current = current.next if left: left = left.next if right: right = right.next if carry > 0: current.next = Node(carry) return dummy.next"},{"question":"# Question: Balanced Binary Search Tree (BST) Insertion and Height Calculation You are given a partially implemented class `BST` representing a Binary Search Tree, with methods to insert elements, search for an element, and get the size of the tree. Your task is to extend this class to ensure the tree remains balanced using the AVL Tree mechanism. Additionally, write a function to calculate the height of the tree. **Objective**: 1. Ensure that the tree remains balanced after every insertion using AVL Tree rotations. 2. Implement a method to calculate the height of the BST. # Specifications 1. **Insert**: Implement the AVL Logic to ensure the tree remains balanced. This involves rotation mechanisms (single and double rotations). The insertion should continue to operate in O(log N) time. 2. **Height Calculation**: Implement a method to calculate the height of the tree. # Constraints: - Values to be inserted are unique integers. - Your height() function should return the height of the entire tree. - Follow AVL balancing rules to manage tree balance after each insert. # Input and Output: - **Input**: A series of integer values to be inserted into the BST. - **Output**: - After each insertion, check the balance of the tree. - The final height of the tree after all insertions. # Example: ```python bst = BST() values_to_insert = [10, 6, 15, 4, 9, 12, 24, 7, 20, 30, 18] for value in values_to_insert: bst.insert(value) print(\\"Height of the tree:\\", bst.height()) ``` # Expected Output: ``` Height of the tree: 4 ``` Notes: - Implement the necessary rotations (single left, single right, double left-right, double right-left) to keep the tree balanced. - Ensure that each node keeps track of its height. - Implement utility functions to update node heights and balance factors.","solution":"class Node: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class BST: def __init__(self): self.root = None def insert(self, key): self.root = self._insert(self.root, key) def _insert(self, node, key): if not node: return Node(key) if key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) # Left Left Case if balance > 1 and key < node.left.key: return self._right_rotate(node) # Right Right Case if balance < -1 and key > node.right.key: return self._left_rotate(node) # Left Right Case if balance > 1 and key > node.left.key: node.left = self._left_rotate(node.left) return self._right_rotate(node) # Right Left Case if balance < -1 and key < node.right.key: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def height(self): return self._get_height(self.root) def _get_height(self, node): if not node: return 0 return node.height def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def _left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y"},{"question":"# Description You are working on a networked application that requires sending a list of strings over a network connection. The requirement is to encode the list into a single string format and decode it back to the original list of strings on the other end. Your task is to implement the functions `encode` and `decode`. # Task 1. **Function 1 - `encode`**: - **Purpose**: Encodes a list of strings into a single string. - **Input**: A list of strings, `strs`. For example, `[\\"hello\\", \\"world\\"]`. - **Output**: A single encoded string. For example, `\\"5:hello5:world\\"`. 2. **Function 2 - `decode`**: - **Purpose**: Decodes a single string back into a list of strings. - **Input**: An encoded string, `s`. For example, `\\"5:hello5:world\\"`. - **Output**: The original list of strings. For example, `[\\"hello\\", \\"world\\"]`. # Requirements - Implement the functions `encode` and `decode` such that they can handle the edge cases mentioned in the analysis. - Ensure the encoded string format is maintainable and correctly decodable. # Examples ```python def encode(strs): Encodes a list of strings to a single string. :type strs: List[str] :rtype: str # Your code goes here def decode(s): Decodes a single string to a list of strings. :type s: str :rtype: List[str] # Your code goes here # Example 1 encoded = encode([\\"hello\\", \\"world\\"]) print(encoded) # Expected output: \\"5:hello5:world\\" decoded = decode(encoded) print(decoded) # Expected output: [\\"hello\\", \\"world\\"] # Example 2 encoded = encode([\\"\\"]) print(encoded) # Expected output: \\"0:\\" decoded = decode(encoded) print(decoded) # Expected output: [\\"\\"] ``` # Constraints - The provided input list `strs` will have at most (10^5) strings. - Each string in `strs` will have a maximum length of (10^4).","solution":"def encode(strs): Encodes a list of strings to a single string. :type strs: List[str] :rtype: str encoded_str = \'\' for s in strs: encoded_str += f\'{len(s)}:{s}\' return encoded_str def decode(s): Decodes a single string to a list of strings. :type s: str :rtype: List[str] decoded_list = [] i = 0 while i < len(s): j = s.find(\':\', i) length = int(s[i:j]) decoded_list.append(s[j + 1:j + 1 + length]) i = j + 1 + length return decoded_list"},{"question":"# Palindromic Partition Finder Context You are a software developer responsible for implementing a feature in a text processing application aimed at revealing all possible ways to partition input text into palindromic substrings. A palindrome is a string that reads the same forward and backward (such as \\"level\\" or \\"radar\\"). Objective Write a Python function `palindromic_partitions(s: str) -> List[List[str]]` that takes a string as an input and returns all possible ways to partition that string into non-empty palindromic substrings. Each partition should be represented as a list of substrings. Input and Output Formats - **Input**: A single string `s` where `0 <= len(s) <= 16`. The string contains lowercase English letters. - **Output**: A list of lists where each inner list represents a valid partition of the input string into palindromic substrings. Constraints 1. The input string `s` will only contain lowercase alphabetical characters. 2. You need to capture all possible partitions where every substring in the partition is a palindrome. 3. Complexity may reach exponential due to the combinatorics involved. Function Signature ```python def palindromic_partitions(s: str) -> List[List[str]]: pass ``` Example ```python >>> palindromic_partitions(\\"aab\\") [[\'a\', \'a\', \'b\'], [\'aa\', \'b\']] >>> palindromic_partitions(\\"abcbab\\") [[\'a\', \'b\', \'c\', \'b\', \'a\', \'b\'], [\'a\', \'b\', \'c\', \'bab\'], [\'a\', \'bcb\', \'a\', \'b\'], [\'abcba\', \'b\']] ``` Note - An empty input should return an empty list of lists: `[[]]`.","solution":"from typing import List def is_palindrome(s: str) -> bool: Helper function to check if the input string is a palindrome. return s == s[::-1] def palindromic_partitions(s: str) -> List[List[str]]: Function to find all palindromic partitions of the input string. def backtrack(start: int, path: List[str], result: List[List[str]]): if start == len(s): result.append(path[:]) return for end in range(start + 1, len(s) + 1): substring = s[start:end] if is_palindrome(substring): path.append(substring) backtrack(end, path, result) path.pop() result = [] backtrack(0, [], result) return result"},{"question":"You work at a software company where you need to frequently sort small to medium-sized lists of data. Your manager has asked you to implement an efficient solution for this use case. You have decided to use the Insertion Sort algorithm due to its simplicity and efficiency with small datasets. Task Implement an `insertion_sort` function that sorts a list of integers in non-decreasing order. Additionally, simulate each iteration showing the intermediate state of the list. Function Signature ```python def insertion_sort(arr: list[int], simulation: bool = False) -> list[int]: pass ``` Input * `arr` (list of int): The list of integers to be sorted. * `simulation` (bool): A flag to enable printing the intermediate iterations during sorting. Output * Return the sorted list of integers. Constraints * The function should effectively handle the edge case scenarios, such as empty arrays and single-element arrays. * The array length, `n`, will be such that `1 ≤ n ≤ 10^3`. * Each element in `arr` will be in the range `-10^4` to `10^4`. Example ```python arr = [10, 2, -3, 45, 0] result = insertion_sort(arr, simulation=True) # Expected Printed Output (varies): # iteration 0 : 10 2 -3 45 0 # iteration 1 : 2 10 -3 45 0 # iteration 2 : -3 2 10 45 0 # iteration 3 : -3 2 10 45 0 # iteration 4 : -3 0 2 10 45 print(result) # Output: [-3, 0, 2, 10, 45] ``` Implement the `insertion_sort` function following the constraints and ensure correctness by handling edge cases effectively.","solution":"def insertion_sort(arr: list[int], simulation: bool = False) -> list[int]: Sorts a list of integers using the insertion sort algorithm. Parameters: arr (list of int): The list of integers to be sorted. simulation (bool): A flag to enable printing the intermediate iterations during sorting. Returns: list of int: The sorted list of integers. n = len(arr) for i in range(1, n): key = arr[i] j = i - 1 while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key if simulation: print(f\'iteration {i} : {\\" \\".join(map(str, arr))}\') return arr"},{"question":"# Question: Enhanced Hailstone Sequence Generator Write a function `enhanced_hailstone` that generates the hailstone sequence for a given integer `n` (as defined by the Collatz conjecture) but with additional requirements: 1. **Input Validation**: Ensure that the input is a positive integer. If the input is not valid, raise a `ValueError` with a meaningful error message. 2. **Performance Optimization**: Use memoization to store and reuse previously computed sequences to optimize the computational performance, especially for repeated or overlapping sequences. 3. **Output Format**: Return the sequence and the number of steps taken to reach 1. # Function Signature: ```python def enhanced_hailstone(n: int) -> (List[int], int): Generate the hailstone sequence optimized with memoization. Parameters: n (int): The starting point of the sequence (must be a positive integer). Returns: Tuple: A tuple where the first element is the hailstone sequence as a list of integers and the second element is the number of steps to reach 1. Raises: ValueError: If n is not a positive integer. ``` # Constraints: * `n` must be a positive integer (1 <= n <= 10^6). # Performance: * Aim to minimize the number of redundant calculations by using memoization. # Examples: ```python # Example 1 enhanced_hailstone(6) # Output: ([6, 3, 10, 5, 16, 8, 4, 2, 1], 8) # Example 2 enhanced_hailstone(1) # Output: ([1], 0) ``` Notes: * The sequence starts with `n` and ends with 1. * The number of steps is the number of transformations required to reach 1 starting from `n`.","solution":"def enhanced_hailstone(n): Generate the hailstone sequence optimized with memoization. Parameters: n (int): The starting point of the sequence (must be a positive integer). Returns: Tuple: A tuple where the first element is the hailstone sequence as a list of integers and the second element is the number of steps to reach 1. Raises: ValueError: If n is not a positive integer. if not isinstance(n, int) or n <= 0: raise ValueError(\\"Input must be a positive integer\\") memo = {} def hailstone_sequence(x): if x == 1: return [1], 0 if x in memo: return memo[x] if x % 2 == 0: next_x = x // 2 else: next_x = 3 * x + 1 next_seq, next_steps = hailstone_sequence(next_x) seq = [x] + next_seq steps = 1 + next_steps memo[x] = (seq, steps) return seq, steps hailstone_seq, hailstone_steps = hailstone_sequence(n) return hailstone_seq, hailstone_steps"},{"question":"# Scenario: You are developing a compiler for a simplified programming language. One of the crucial components is the lexical analyzer, which uses a DFA to check if tokens (strings) in the code are valid according to the language\'s rules. Your task is to implement a function that can verify if a given string is accepted by a DFA defined by its transition rules. # Problem Statement: Implement a function `is_valid_token(transitions, start, final, string)` that determines if a given input string is accepted by the specified DFA. The DFA is described by its transition table, initial state, and accepting (final) states. # Function Signature: ```python def is_valid_token(transitions: dict, start: int, final: List[int], string: str) -> bool: ``` # Parameters: - `transitions`: A dictionary where keys are state numbers and values are dictionaries representing transitions from that state. Each inner dictionary has characters as keys and resultant states as values. - `start`: An integer representing the initial state. - `final`: A list of integers representing the accepting states. - `string`: The input string to be checked. # Returns: - `True` if the string is accepted by the DFA. - `False` otherwise. # Constraints: - Transitions cover all possible characters in the input set. - The state numbers are non-negative integers. - The DFA is deterministic and contains no epsilon transitions. # Example: ```python transitions = { 0: {\'a\': 1, \'b\': 0}, 1: {\'a\': 1, \'b\': 2}, 2: {\'a\': 1, \'b\': 0} } start = 0 final = [2] string = \\"aab\\" assert is_valid_token(transitions, start, final, string) == True string = \\"abb\\" assert is_valid_token(transitions, start, final, string) == False ``` # Notes: - Consider edge cases such as empty strings and strings containing characters with no defined transitions. - Ensure to check all states and transitions properly to avoid undefined behavior.","solution":"def is_valid_token(transitions, start, final, string): Determines if a given string is accepted by a DFA with specified transitions, start state, and final states. Parameters: - transitions (dict): The DFA\'s transition table. - start (int): The start state. - final (List[int]): The accepting states. - string (str): The input string to check. Returns: - bool: True if the string is accepted by the DFA, False otherwise. current_state = start for char in string: # If there is no valid transition for the character, reject the string if char not in transitions[current_state]: return False # Move to the next state current_state = transitions[current_state][char] # Check if the final state is one of the accepting states return current_state in final"},{"question":"You are provided with the task of detecting cycles in a directed graph to prevent potential deadlocks in a resource allocation system. Implement the function `contains_cycle(graph: Dict[str, List[str]]) -> bool` that takes a directed graph in the form of an adjacency list and returns `True` if the graph contains a cycle and `False` otherwise. # Function Signature ```python def contains_cycle(graph: Dict[str, List[str]]) -> bool: ``` # Input - `graph`: A dictionary where keys are vertices (represented as strings) and values are lists of adjacent vertices. # Output - Returns a boolean value indicating whether a cycle exists in the graph. # Constraints - The graph is represented as a dictionary with vertex names as keys and lists of adjacent vertices as values. - The graph can have up to 1000 vertices and 5000 edges. - Each vertex name is a string of length 1 to 10 containing only alphanumeric characters. - The graph can be disconnected, i.e., it can have multiple components. # Example ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': [] } print(contains_cycle(graph)) # Output: True ``` # Explanation - The graph described has a cycle: A -> B -> D -> E -> B. - Your function should detect this and return `True`. # Additional Notes - Consider edge cases such as: - A self-loop (e.g., A -> A). - Completely disconnected vertices. - Graphs where multiple cycles might exist independently or are nested. - Ensure your function handles large graphs efficiently.","solution":"def contains_cycle(graph): Detects if there is a cycle in a directed graph. :param graph: A dictionary representing the adjacency list of the graph. :return: True if there is a cycle in the graph, False otherwise. def visit(node): if node in visiting: return True if node in visited: return False visiting.add(node) for neighbor in graph.get(node, []): if visit(neighbor): return True visiting.remove(node) visited.add(node) return False visited = set() visiting = set() for node in graph: if visit(node): return True return False"},{"question":"# Scenario You are given the task to compare the efficiency of different sorting algorithms as part of a study on sorting mechanisms. As a stepping stone, you need to implement the Exchange Sort algorithm. This exercise will help you understand basic sorting techniques and their limitations. # Task Implement the function `exchange_sort(arr)` that sorts a given list of integers using the Exchange Sort algorithm. # Function Signature ```python def exchange_sort(arr: List[int]) -> List[int]: Sorts the list of integers using the Exchange Sort algorithm. :param arr: List of integers :return: Sorted list of integers ``` # Input * A list of integers `arr` within the range of (-10^5, 10^5). * The length of the list can vary from 0 to 10^3. # Output * A new list containing all the elements from `arr`, sorted in ascending order. # Constraints * Handle edge cases such as an empty array or an array with duplicate values. * Ensure the function adheres to the given signature and returns the result in the correct format. # Examples ```python assert exchange_sort([4, 2, 3, 1]) == [1, 2, 3, 4] assert exchange_sort([1, 5, 3, 3, 2]) == [1, 2, 3, 3, 5] assert exchange_sort([]) == [] assert exchange_sort([-1, 0, 3, -2, 4]) == [-2, -1, 0, 3, 4] ```","solution":"from typing import List def exchange_sort(arr: List[int]) -> List[int]: Sorts the list of integers using the Exchange Sort algorithm. :param arr: List of integers :return: Sorted list of integers n = len(arr) for i in range(n - 1): for j in range(i + 1, n): if arr[i] > arr[j]: arr[i], arr[j] = arr[j], arr[i] return arr"},{"question":"# Sparse Vector Representation and Dot Product Calculation Objective Given the provided code snippets, you are required to implement a modified version that supports storing sparse vectors and calculating their dot product more efficiently. Problem Statement You are given two large sparse vectors (vectors that predominantly contain zeros). Your task is to write a class `SparseVector` that: 1. **Converts a dense vector into a sparse representation.** 2. **Calculates the dot product between two sparse vectors.** Class Specification **Class Name**: `SparseVector` **Methods**: 1. **`__init__(self, vector)`**: - **Input**: A list of floats representing the dense vector. - **Output**: None (initialize the sparse vector representation). 2. **`dotProduct(self, vec)`**: - **Input**: An instance of `SparseVector`. - **Output**: A float representing the dot product of the two sparse vectors. Example ```python vec1 = SparseVector([1.0, 0.0, 0.0, 2.0, 3.0]) vec2 = SparseVector([0.0, 2.0, 3.0, 0.0, 0.0]) print(vec1.dotProduct(vec2)) # Output: 0.0 vec3 = SparseVector([1.0, 0.0, 0.0, 2.0, 3.0]) vec4 = SparseVector([0.0, 0.0, 0.0, 2.0, 3.0]) print(vec3.dotProduct(vec4)) # Output: 13.0 ``` # Constraints 1. Vectors can be very large (length up to (10^6)), and the number of non-zero elements is very small compared to the vector length. 2. The elements of vectors are floats and can be positive or negative. # Performance Requirements 1. Your implementation should be efficient in terms of time and space. 2. Ensure that dot product calculations and vector transformations leverage the sparse nature of the data.","solution":"class SparseVector: def __init__(self, vector): Converts a dense vector into a sparse representation. :param vector: List of floats representing the dense vector self.sparse_vector = {i: value for i, value in enumerate(vector) if value != 0} def dotProduct(self, vec): Calculates the dot product between two sparse vectors. :param vec: An instance of SparseVector :return: A float representing the dot product of the two sparse vectors result = 0.0 for i, value in self.sparse_vector.items(): if i in vec.sparse_vector: result += value * vec.sparse_vector[i] return result"},{"question":"# Diffie-Hellman Key Exchange Enhanced The following outlines a scenario where improvements are needed in the Diffie-Hellman key exchange algorithm implementation. **Scenario:** Two entities, Alice and Bob, wish to securely establish a shared secret key through an insecure network. You are tasked with implementing a robust version of the Diffie-Hellman key exchange that not only computes the shared key but also verifies the authenticity of prime `p` and primitive root `a`. # Objectives 1. Implement the primary algorithm to: - Validate prime number `p`. - Validate `a` as a primitive root of `p`. - Execute the key exchange ensuring all checks pass correctly. 2. Enhance the algorithm to handle errors gracefully (invalid `p`, invalid `a`). # Expected Input and Output Formats Input * `p`: Large prime number (1 ≤ `p` ≤ 2^31 - 1) * `a`: Primitive root of `p` Output * Boolean indicating whether the shared keys computed by Alice and Bob match. * Include necessary print statements showing the validation steps, keys, and any error messages. Constraints * Ensure `p` is a prime number and `a` is a primitive root of `p`. * Handle edge cases where the inputs could be invalid. # Performance Requirements * Efficiently handle primes and large values of `p` up to 2^31 - 1. * Ensure minimal computational overhead for key validation steps. # Steps 1. Implement function to validate prime number `p`. 2. Implement function to check if `a` is a primitive root of `p`. 3. Complete the Diffie-Hellman key exchange ensuring `p` and `a` validation. # Function Signature ```python def diffie_hellman_key_exchange_enhanced(a: int, p: int, option: bool = False) -> bool: pass ``` # Example ```python #Example 1: # Valid case result = diffie_hellman_key_exchange_enhanced(5, 23, option=True) #Expected Output: 23 is a prime number 5 is a primitive root of 23 Alice\'s private key: <Some Integer> Alice\'s public key: <Some Integer> Bob\'s private key: <Some Integer> Bob\'s public key: <Some Integer> Shared key calculated by Alice = <Some Integer> Shared key calculated by Bob = <Some Integer> True # Example 2: # Invalid case where prime \'p\' is not given result = diffie_hellman_key_exchange_enhanced(5, 21, option=True) # Expected Output: 21 is not a prime number False ``` Implement this function ensuring to perform all necessary validations and error handling.","solution":"def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def gcd(a, b): while b: a, b = b, a % b return a def is_primitive_root(a, p): if not is_prime(p): return False required_set = set(num for num in range(1, p) if gcd(num, p) == 1) actual_set = set(pow(a, power, p) for power in range(1, p)) return required_set == actual_set def diffie_hellman_key_exchange_enhanced(a, p): if not is_prime(p): print(f\\"{p} is not a prime number\\") return False else: print(f\\"{p} is a prime number\\") if not is_primitive_root(a, p): print(f\\"{a} is not a primitive root of {p}\\") return False else: print(f\\"{a} is a primitive root of {p}\\") # Alice\'s private and public keys a_private = 6 # Private key chosen arbitrarily A = pow(a, a_private, p) # Public key # Bob\'s private and public keys b_private = 15 # Private key chosen arbitrarily B = pow(a, b_private, p) # Public key # Shared secret computation shared_key_alice = pow(B, a_private, p) shared_key_bob = pow(A, b_private, p) # Printing the keys print(f\\"Alice\'s private key: {a_private}\\") print(f\\"Alice\'s public key: {A}\\") print(f\\"Bob\'s private key: {b_private}\\") print(f\\"Bob\'s public key: {B}\\") print(f\\"Shared key calculated by Alice = {shared_key_alice}\\") print(f\\"Shared key calculated by Bob = {shared_key_bob}\\") return shared_key_alice == shared_key_bob"},{"question":"# Reverse a Portion of a Singly Linked List **Objective**: Implement a function to reverse a portion (sublist) of a singly linked list, identified by a start and an end position. # Detailed Description You are given a singly linked list and two indices, left and right. Reverse the nodes in the list from the position left to the position right and return the modified list. Positions are 1-based. # Function Signature ```python def reverse_list_between(head, left, right): :type head: ListNode :type left: int :type right: int :rtype: ListNode ``` # Input * head: The head of the singly linked list (first node). * left: Integer representing the starting position (1-based from which part of the list should be reversed). * right: Integer representing the ending position (1-based up to which part of the list should be reversed). # Output * The head of the modified linked list with the specified portion reversed. # Constraints * The linked list will have at least one node. * 1 ≤ left ≤ right ≤ length of the list. # Example ```python # Example linked list: 1 -> 2 -> 3 -> 4 -> 5 -> NULL # For input (head, 2, 4) # After reversing nodes from position 2 to 4: # Output linked list should be: 1 -> 4 -> 3 -> 2 -> 5 -> NULL class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def print_list(head): while head: print(head.val, end=\\" -> \\") head = head.next print(\\"NULL\\") # Build example list n1 = ListNode(1) n2 = ListNode(2) n3 = ListNode(3) n4 = ListNode(4) n5 = ListNode(5) n1.next = n2 n2.next = n3 n3.next = n4 n4.next = n5 # Test reverse_list_between new_head = reverse_list_between(n1, 2, 4) print_list(new_head) # Expected output: 1 -> 4 -> 3 -> 2 -> 5 -> NULL ``` # Notes - Ensure the list retains its integrity and does not form cycles or lose parts during the reversal. - Optimize for time and space complexity where possible.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_list_between(head, left, right): if not head or left == right: return head dummy = ListNode(0) dummy.next = head pre = dummy for _ in range(left - 1): pre = pre.next current = pre.next temp = None for _ in range(right - left): next_temp = current.next current.next = next_temp.next next_temp.next = pre.next pre.next = next_temp return dummy.next"},{"question":"You are given two functions `serialize` and `deserialize` which handle the serialization and deserialization of a binary tree. Serialization involves converting the tree to a string, and deserialization involves reconstructing the original tree from the string. Your task is to implement the functions `serialize` and `deserialize` using pre-order traversal. # Function Signatures ```python class TreeNode(object): def __init__(self, x): self.val = x self.left = None self.right = None def serialize(root: TreeNode) -> str: # your code here def deserialize(data: str) -> TreeNode: # your code here ``` # Input/Output Formats * `serialize`: * **Input**: A binary tree root node `root` (type: `TreeNode`). * **Output**: A string representation (type: `str`) of the binary tree. * `deserialize`: * **Input**: A string `data` (type: `str`) representing the binary tree. * **Output**: The root node of the reconstructed binary tree (type: `TreeNode`). # Constraints * The value of each node in the binary tree is an integer. * The number of nodes in the tree is in the range `[0, 1000]`. # Example ```python # Example to illustrate usage # Constructing a tree root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.right.left = TreeNode(4) root.right.right = TreeNode(5) # Serializing the tree serialized_tree = serialize(root) print(serialized_tree) # Output: \\"1 2 # # 3 4 # # 5 # #\\" # Deserializing the tree deserialized_tree = deserialize(serialized_tree) print(serialize(deserialized_tree)) # Output should match the serialized_tree string. ``` Implement the functions ensuring they handle all provided constraints and edge cases efficiently.","solution":"class TreeNode(object): def __init__(self, x): self.val = x self.left = None self.right = None def serialize(root: TreeNode) -> str: Encodes a tree to a single string using pre-order traversal. :param root: TreeNode :return: str def helper(node): if node is None: return \\"# \\" return str(node.val) + \\" \\" + helper(node.left) + helper(node.right) return helper(root).strip() def deserialize(data: str) -> TreeNode: Decodes your encoded data to tree. :param data: str :return: TreeNode def helper(nodes): val = next(nodes) if val == \\"#\\": return None node = TreeNode(int(val)) node.left = helper(nodes) node.right = helper(nodes) return node node_iter = iter(data.split()) return helper(node_iter)"},{"question":"Context In the world of search algorithms, efficiency is crucial, especially when dealing with large datasets. Interpolation Search, often optimized for uniformly distributed arrays, can outperform traditional search algorithms under specific conditions. For this assessment, you will implement an extension of the Interpolation Search algorithm that dynamically chooses between Interpolation Search and Binary Search based on the characteristics of the dataset. Problem Description Implement a function `adaptive_search` that: * Combines Interpolation Search and Binary Search. * Uses Interpolation Search for uniformly distributed values and Binary Search otherwise. Your function should analyze the distribution of the array by comparing the differences between adjacent elements\' values. Function Signature ```python from typing import List def adaptive_search(array: List[int], search_key: int) -> int: pass ``` Input * `array`: A list of integers (sorted in increasing order). * `search_key`: An integer to search for in the array. Output * The function should return the index of `search_key` if found within `array`, otherwise -1. Constraints * Input array size (`n`) ranges from 0 to (10^6). * Time Complexity goal: Maintain O(log n) or better on uniformly distributed arrays, with fallback to O(log n) baseline. * Space Complexity: O(1). Guidelines 1. Determine the uniformity of the array by calculating the variance of differences between adjacent elements. 2. Switch to Binary Search if the array is deemed non-uniform according to your heuristic. 3. Ensure correct handling of edge cases, including empty arrays and single-element arrays. Examples ```python assert adaptive_search([-25, -12, -1, 10, 12, 15, 20, 41, 55], -1) == 2 assert adaptive_search([5, 10, 12, 14, 17, 20, 21], 55) == -1 assert adaptive_search([5, 10, 12, 14, 17, 20, 21], -5) == -1 assert adaptive_search([], 12) == -1 assert adaptive_search([10], 10) == 0 assert adaptive_search([10], 12) == -1 ```","solution":"from typing import List def interpolation_search(array: List[int], search_key: int) -> int: low = 0 high = len(array) - 1 while low <= high and search_key >= array[low] and search_key <= array[high]: if low == high: if array[low] == search_key: return low return -1 pos = low + ((high - low) // (array[high] - array[low]) * (search_key - array[low])) if array[pos] == search_key: return pos elif array[pos] < search_key: low = pos + 1 else: high = pos - 1 return -1 def binary_search(array: List[int], search_key: int) -> int: low = 0 high = len(array) - 1 while low <= high: mid = (low + high) // 2 if array[mid] == search_key: return mid elif array[mid] < search_key: low = mid + 1 else: high = mid - 1 return -1 def is_uniform(array: List[int]) -> bool: if len(array) < 2: return True differences = [array[i] - array[i - 1] for i in range(1, len(array))] avg_diff = sum(differences) / len(differences) variance = sum((x - avg_diff) ** 2 for x in differences) / len(differences) # If the variance is small, the array is more uniform return variance < 1e-5 def adaptive_search(array: List[int], search_key: int) -> int: if not array: return -1 if is_uniform(array): return interpolation_search(array, search_key) else: return binary_search(array, search_key)"},{"question":"# Coding Task - Enhanced Cocktail Shaker Sort Implement an enhanced version of the Cocktail Shaker Sort algorithm. Your task is to optimize the sorting process to reduce unnecessary comparisons and ensure that the function handles edge cases efficiently. Requirements * Your solution should: * Accepts an array of integers. * Sort the array in ascending order using an optimized bidirectional approach. * Minimize the number of comparisons by adjusting the range of each pass based on the last swap position. Expected Input and Output * **Input**: * A list of integers `arr` with length between 1 and 1000. * **Output**: * A sorted list of integers in ascending order. Constraints * You must handle cases where the array is empty or contains a single element. * Aim to improve the efficiency over traditional Cocktail Shaker Sort by using optimized boundaries for each pass. * Your implementation should be in Python and avoid using any built-in sorting functions. Performance Requirements * The algorithm should execute efficiently on mid-sized datasets (up to 1000 elements). Example ```python # Input arr = [5, 3, 8, 4, 2] # Output [2, 3, 4, 5, 8] # Input arr = [1, 2, 3, 4, 5] # Output [1, 2, 3, 4, 5] ``` # Notes: * Think about how you can remember the last position where a swap occurred to reduce the range of subsequent passes. * Make sure to test your implementation on a variety of inputs, including edge cases such as empty arrays, already sorted arrays, and arrays with duplicate values.","solution":"def enhanced_cocktail_shaker_sort(arr): Sorts an array of integers in ascending order using an optimized version of the Cocktail Shaker Sort. if not arr or len(arr) == 1: return arr n = len(arr) start = 0 end = n - 1 while start < end: new_end = start # Forward pass for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] new_end = i end = new_end if start >= end: break new_start = end # Backward pass for i in range(end, start, -1): if arr[i] < arr[i - 1]: arr[i], arr[i - 1] = arr[i - 1], arr[i] new_start = i start = new_start return arr"},{"question":"# Prompt You are tasked with the problem of deadlock detection in a system by modeling processes and resources as a directed graph. A deadlock occurs when there is a cycle in the graph, which means a process is dependent on a chain of processes that ultimately refer back to itself. **Your Task**: Implement a function `detect_deadlock(graph: Dict[str, List[str]]) -> bool` that detects if there is a deadlock (cycle) in a given directed graph. Input: - `graph`: A dictionary representing the graph. Keys are strings representing nodes, and values are lists of strings representing directed edges from the key node to other nodes. Output: - A boolean: `True` if there is a cycle (deadlock); `False` otherwise. Constraints: - The number of nodes (vertices) `|V|` will be in the range [0, 1000]. - The number of edges `|E|` will be in the range [0, 2000]. Example: ```python # Example 1: graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': [] } print(detect_deadlock(graph)) # Output: True, because there is a cycle {B -> D -> E -> B} # Example 2: graph = { \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [\'D\'], \'D\': [\'E\'], \'E\': [] } print(detect_deadlock(graph)) # Output: False, because there is no cycle ```","solution":"def detect_deadlock(graph): Detects if there is a deadlock (cycle) in a given directed graph. visited = set() rec_stack = set() def is_cyclic(v): visited.add(v) rec_stack.add(v) for neighbor in graph.get(v, []): if neighbor not in visited: if is_cyclic(neighbor): return True elif neighbor in rec_stack: return True rec_stack.remove(v) return False for node in graph: if node not in visited: if is_cyclic(node): return True return False"},{"question":"# Tree Subtree Check Problem **Objective**: Implement a function to check whether tree `t` is a subtree of tree `s`. **Function Signature**: ```python def is_subtree(s: Optional[TreeNode], t: Optional[TreeNode]) -> bool: ``` **Input**: - `s`: The root node of a binary tree. - `t`: The root node of a binary tree. **Output**: - `Returns` a boolean value indicating whether `t` is a subtree of `s`. **Requirements**: 1. Node values in both trees are comparable. 2. Each node value should be evaluated for equality. 3. Trees may contain duplicate values. **Constraints**: - Tree nodes are defined with: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` # Example: 1. Given `s`: ``` 3 / 4 5 / 1 2 ``` Given `t`: ``` 4 / 1 2 ``` **Output**: `True` 2. Given `s`: ``` 3 / 4 5 / 1 2 / 0 ``` Given `t`: ``` 4 / 1 2 ``` **Output**: `False` # Additional Considerations: Handle the edge cases where one or both trees might be empty. # Follow-Up: Discuss how you would optimize the function for cases where `s` is significantly larger than `t`. What changes in strategy would be recommended?","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_subtree(s: TreeNode, t: TreeNode) -> bool: if not s: return not t if is_identical(s, t): return True return is_subtree(s.left, t) or is_subtree(s.right, t) def is_identical(s: TreeNode, t: TreeNode) -> bool: if not s and not t: return True if not s or not t: return False return s.val == t.val and is_identical(s.left, t.left) and is_identical(s.right, t.right)"},{"question":"# Flatten Nested Arrays **Context:** You are working on a data processing system that needs to standardize a myriad of data forms, many of which are deeply nested arrays. To handle this, you must write a function that flattens these nested arrays into a single array. **Objective:** Write a Python function called `flatten_nested_arrays` that takes a nested list and returns a single flattened list. The function should work for any level of nesting. Additionally, implement it in an iterator form that can be used to retrieve elements one-by-one. **Function Signatures:** ```python def flatten_nested_arrays(nested_list: list) -> list: pass def flatten_nested_arrays_iter(nested_iter: Iterable) -> Iterable: pass ``` **Expected Input and Output:** * `flatten_nested_arrays(nested_list)` - **Input**: `nested_list` - A list potentially containing nested lists of arbitrary depth. - **Output**: A flattened list containing all non-iterable elements from the nested list. * `flatten_nested_arrays_iter(nested_iter)` - **Input**: `nested_iter` - An iterable potentially containing nested iterables. - **Output**: An iterator that yields elements from the nested iterable one-by-one in a flattened manner. **Constraints:** * Do not use built-in functions that directly flatten the list. * Handle iterables (except strings) recursively. * Maintain the order of elements as they appear in the nested structure. **Performance Requirements:** * Both functions should run in linear time relative to the total number of elements in the input structure. * Use minimal additional space proportional to the depth of the nested structure. **Examples:** ```python nested_list = [1, [2, 3, [4, 5], 6], 7, [8, [9, 10]]] assert flatten_nested_arrays(nested_list) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] ``` ```python nested_iter = [1, [2, 3, [4, 5], 6], 7, [8, [9, 10]]] assert list(flatten_nested_arrays_iter(nested_iter)) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] ``` **Additional Information:** * Pay special attention to strings, as they are iterable but should not be unpacked. * Consider edge cases such as empty lists and deeply nested structures.","solution":"from collections.abc import Iterable def flatten_nested_arrays(nested_list: list) -> list: Flattens a nested list into a single list. Elemente in the original order. flat_list = [] def _flatten_helper(lst): for item in lst: if isinstance(item, list): _flatten_helper(item) else: flat_list.append(item) _flatten_helper(nested_list) return flat_list def flatten_nested_arrays_iter(nested_iter: Iterable) -> Iterable: Flattens a nested iterable into a single iterator. Elements are retrieved in the original order. for item in nested_iter: if isinstance(item, Iterable) and not isinstance(item, (str, bytes)): yield from flatten_nested_arrays_iter(item) else: yield item"},{"question":"# Question: Next Bigger Number with Same Digits **Scenario:** You are provided with a positive integer number and tasked with finding the next bigger number that can be formed using the exact same set of digits. If no such number exists (i.e., the digits are in descending order), the function should return -1. # Function Signature ```python def next_bigger(num: int) -> int: ``` # Input * A single integer `num` where (1 <= num <= 10^18). The number consists of digits 0-9. # Output * A single integer that is the next bigger number formed using the same digits of `num`, or `-1` if no such number exists. # Constraints * The input number will be positive. * The input number can be very large, up to 18 digits. # Examples ```python assert next_bigger(38276) == 38627 # Example from the problem statement assert next_bigger(12345) == 12354 # Swap last two digits assert next_bigger(999) == -1 # No higher permutations assert next_bigger(54321) == -1 # Descending order, no higher permutation possible assert next_bigger(1528452) == 1528524 # Complex swap and reverse assert next_bigger(138654) == 143568 # Rearrange the digits ``` # Instructions: Implement the function `next_bigger` in the following manner: 1. Identify the rightmost index holding the digit that breaks the descending order. 2. Find the smallest digit on the right side of this index that is larger than the identified digit. 3. Perform the swap of these two digits. 4. Reverse the sequence that follows to generate the next permutation.","solution":"def next_bigger(num: int) -> int: digits = list(str(num)) n = len(digits) # Step 1: Identify where the descending order breaks from the end i = n - 2 while i >= 0 and digits[i] >= digits[i + 1]: i -= 1 # If no such index is found, return -1 if i == -1: return -1 # Step 2: Find the smallest digit on right side of digits[i] which is larger than digits[i] j = n - 1 while digits[j] <= digits[i]: j -= 1 # Step 3: Swap the found digits[i] with digits[j] digits[i], digits[j] = digits[j], digits[i] # Step 4: Reverse the sequence after the initial i+1 index digits = digits[:i+1] + digits[i+1:][::-1] return int(\\"\\".join(digits))"},{"question":"**Question**: You are tasked with implementing an algorithm to efficiently search for a given value in a sorted integer array. Given that this array may be very large, a standard linear search may be too slow. To address this, you will implement the Ternary Search algorithm. **Function Signature**: ```python def ternary_search(sorted_array: List[int], key: int) -> int: This function takes in a sorted list of integers and a search key. It returns the index of the element matching the key. If the key is not found, it returns -1. ``` **Input**: 1. `sorted_array` - A list of integers sorted in ascending order. 2. `key` - An integer value that needs to be searched in the array. **Output**: * The function returns an integer, the index of the element in the array that matches the key. If the key is not found, it returns -1. **Constraints**: * The array will have a maximum length of 10^6. * The elements of the array range between -10^9 and 10^9. * The search key will also be an integer in the range [-10^9, 10^9] **Example**: ```python assert ternary_search([1, 2, 4, 5, 6, 8, 10], 5) == 3 assert ternary_search([1, 2, 4, 5, 6, 8, 10], 7) == -1 assert ternary_search([-5, -3, -1, 0, 3, 8, 12, 15], 3) == 4 assert ternary_search([1, 2, 3, 4, 5], 1) == 0 assert ternary_search([1, 2, 3, 4, 5], 5) == 4 assert ternary_search([1, 2, 3, 4, 5], 6) == -1 ``` **Explanation**: In the first example, the index of key `5` in the array `[1, 2, 4, 5, 6, 8, 10]` is `3`. In the second example, key `7` is not present in the array, so the function returns `-1`. The solution should handle edge cases such as an empty array, arrays where the key is either the first or last element, and scenarios where the key is not present within the array. **Note**: Do not use any library functions to perform the search. Implement the ternary search algorithm from scratch.","solution":"from typing import List def ternary_search(sorted_array: List[int], key: int) -> int: def recursive_search(left: int, right: int) -> int: if left > right: return -1 third_size = (right - left) // 3 mid1 = left + third_size mid2 = right - third_size if sorted_array[mid1] == key: return mid1 if sorted_array[mid2] == key: return mid2 if key < sorted_array[mid1]: return recursive_search(left, mid1 - 1) elif key > sorted_array[mid2]: return recursive_search(mid2 + 1, right) else: return recursive_search(mid1 + 1, mid2 - 1) return recursive_search(0, len(sorted_array) - 1)"},{"question":"<|Analysis Begin|> **Algorithm/Data Structure**: The algorithm used here is for calculating the **maximum flow** in a flow network using the **Depth-First Search (DFS) method**. This is a specific implementation focusing on finding the maximum amount of \\"flow\\" that can be pushed from a source node to a sink node in a flow network, often referred to as the Ford-Fulkerson method. **Complexity**: * **Time Complexity**: O(Ef), where E is the number of edges and f is the maximum flow in the network. * **Space Complexity**: O(V^2), where V is the number of vertices. This is mainly due to the storage required for the adjacency matrix. **Principles**: 1. **Initialization**: The adjacency matrix representing graph capacities is copied to a new array for manipulation. 2. **DFS Path Finding**: Repeatedly perform DFS to find a path from the source (node 0) to the sink (last node) while tracking the visited nodes and path. 3. **Capacity Adjustment**: Once a path is found, determine the minimum flow in this path (bottleneck) and adjust the capacities along the path by reducing them by this minimum value. 4. **Flow Accumulation**: Accumulate the total flow by adding the minimum flow found in each iteration. 5. **Termination**: The algorithm stops when no more paths can be found from the source to the sink. **Properties**: - **Flow Network**: Directed graph where edges have capacities. - **Flow Conservation**: Flow into a node equals flow out of the node, except for source and sink. - **Augmenting Path**: Path found by DFS that increases the total flow. **Common Use Cases**: - Network Routing - Resource Allocation - Bipartite Matching in Graphs **Strengths/Limitations**: - **Strengths**: Simple to implement and understand. Effective in practice for many graphs with moderate edge capacities. - **Limitations**: Can be inefficient for graphs with very high capacities and/or large number of edges. **Edge Cases**: - No augmenting paths from source to sink (directly or indirectly not reachable). - All capacities exhausted, meaning paths are blocked due to maximum utilization. - Very high capacity values might lead to inefficiencies. **Performance Bottlenecks**: - Repeated deep copy of adjacency matrix; efficiently could improve. - DFS in large, highly connected graphs might cause significant stack overhead. **Error Scenarios**: - Infinite loop if not correctly tracking visited nodes. - Incorrect capacities adjustment leading to flow miscalculations. **Optimization Points**: - Use more efficient data structures to avoid deep copy; possibly work directly on a residual graph. - Replace DFS with BFS to ensure finding shortest path (Edmonds-Karp algorithm). <|Analysis End|> <|Question Begin|> You are given a directed graph represented by an adjacency matrix where each element `graph[i][j]` represents the capacity of the edge from node `i` to node `j`. You are tasked to implement a function to determine the maximum flow from the source node (node 0) to the sink node (last node in the matrix) using the Depth-First Search (DFS) method to find the augmenting paths. # Function Signature ```python def maximum_flow_dfs(adjacency_matrix: List[List[int]]) -> int: ``` # Input - `adjacency_matrix` (List[List[int]]): A 2D list of integers representing the capacities of the directed graph. The number of nodes `n` is the size of the list, i.e., `n x n`. # Output - Returns an integer denoting the maximum flow from the source node (0) to the sink node (n-1). # Constraints - The number of nodes `n` in the graph will be between 2 and 100. - Capacity values will be between 0 and 10^4. # Example ```python graph = [ [0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0] ] print(maximum_flow_dfs(graph)) # Should output 23 ``` The function must be implemented to respect performance constraints and handle edge cases effectively. Ensure it terminates correctly if no more paths can be found from source to sink.","solution":"from typing import List def dfs(graph: List[List[int]], source: int, sink: int, path: List[bool], parent: List[int]) -> bool: visited = [False] * len(graph) stack = [source] visited[source] = True while stack: u = stack.pop() for v in range(len(graph)): if visited[v] == False and graph[u][v] > 0: if v == sink: parent[v] = u return True stack.append(v) visited[v] = True parent[v] = u return False def maximum_flow_dfs(adjacency_matrix: List[List[int]]) -> int: graph = [row[:] for row in adjacency_matrix] source = 0 sink = len(graph) - 1 parent = [-1] * len(graph) max_flow = 0 while dfs(graph, source, sink, [False]*len(graph), parent): path_flow = float(\'Inf\') s = sink while(s != source): path_flow = min(path_flow, graph[parent[s]][s]) s = parent[s] v = sink while(v != source): u = parent[v] graph[u][v] -= path_flow graph[v][u] += path_flow v = parent[v] max_flow += path_flow return max_flow"},{"question":"# Question: Validate Anagram --- **Objective**: Write a function `validate_anagram(s, t)` that determines if one string is an anagram of another. **Function Signature**: ```python def validate_anagram(s: str, t: str) -> bool: ``` **Input**: * `s` (str): The first input string, containing only lowercase alphabets (1 ≤ len(s) ≤ 10^5). * `t` (str): The second input string, under the same constraints as `s`. **Output**: * Returns `True` (bool) if `t` is an anagram of `s`, otherwise returns `False`. **Constraints**: * Both strings `s` and `t` are case-insensitive and contain only lowercase alphabets. * Negative matches (unequal string lengths) must return `False`. **Examples**: ```python validate_anagram(\\"anagram\\", \\"nagaram\\") # should return True validate_anagram(\\"rat\\", \\"car\\") # should return False validate_anagram(\\"hello\\", \\"oellh\\") # should return True validate_anagram(\\"test\\", \\"ttew\\") # should return False validate_anagram(\\"aabbcc\\", \\"abcabc\\") # should return True validate_anagram(\\"\\", \\"\\") # should return True ``` **Scenario**: Consider the scenario of a user registering for an event and the system needing to verify if their password input is a rearranged version (anagram) of a preset word to ensure a form of security check. **Performance Requirements**: The function should efficiently handle strings up to 10^5 characters in length with a linear time and space complexity.","solution":"def validate_anagram(s: str, t: str) -> bool: Determines if string t is an anagram of string s. :param s: The first input string. :param t: The second input string. :return: True if t is an anagram of s, otherwise False. if len(s) != len(t): return False from collections import Counter return Counter(s) == Counter(t)"},{"question":"# Question: Markov Chain Simulation and Analysis Scenario Given a Markov chain described by a dictionary, you are tasked with simulating the Markov chain from an initial state and analyzing certain properties of the resulting sequence. Task 1. Implement a function `simulate_markov_chain(chain, initial_state, steps)` that generates a sequence of states by iterating the Markov chain from the given initial state for a specified number of steps. 2. Implement a function `state_visits(chain, initial_state, steps)` that returns a dictionary counting the number of visits to each state after simulating the Markov chain for the given number of steps. Input and Output Format - **Input**: * `chain` (dictionary): Describes the Markov chain. * `initial_state` (str): The starting state of the Markov chain. * `steps` (int): The number of steps to simulate the Markov chain. - **Output**: * `simulate_markov_chain(chain, initial_state, steps)` returns a list of states visited during the simulation. * `state_visits(chain, initial_state, steps)` returns a dictionary counting the number of visits to each state during the simulation. Constraints - `chain` will have at least one state, and all probabilities will sum to 1 for each state\'s transitions. - `steps` will be a positive integer. - The states and their transitions are strings and floating-point numbers between 0 and 1, respectively. Example Usage ```python my_chain = { \'A\': {\'A\': 0.6, \'E\': 0.4}, \'E\': {\'A\': 0.7, \'E\': 0.3} } # Simulate the Markov chain for 10 steps starting from state \'A\' print(simulate_markov_chain(my_chain, \'A\', 10)) # Output could be [\'E\', \'A\', \'E\', \'E\', \'A\', \'A\', ..., ...] # Count the number of visits to each state for 10 steps starting from state \'A\' print(state_visits(my_chain, \'A\', 10)) # Output could be {\'A\': 6, \'E\': 4} ```","solution":"import random def simulate_markov_chain(chain, initial_state, steps): state = initial_state sequence = [state] for _ in range(steps): next_state = random.choices(list(chain[state].keys()), list(chain[state].values()))[0] sequence.append(next_state) state = next_state return sequence def state_visits(chain, initial_state, steps): sequence = simulate_markov_chain(chain, initial_state, steps) visit_count = {} for state in sequence: if state in visit_count: visit_count[state] += 1 else: visit_count[state] = 1 return visit_count"},{"question":"# Markov Chain Simulation and Analysis Context You are tasked with extending the functionality of a Markov Chain simulator. Your objective is to write code that not only simulates state transitions but also provides some statistical insights over multiple iterations. Task Description 1. **Implement a function `simulate_markov_chain`** which: - Takes a Markov chain (as per the structure provided above), an initial state, and a number of steps. - Simulates the Markov Chain starting from the initial state for the given number of steps. - Returns a list of states visited over these steps. 2. **Implement a function `analyze_state_distribution`** which: - Takes the list of states returned by the simulation function. - Returns a dictionary with states as keys and their relative frequencies (as observed in the sequence) as values. 3. **Edge Cases to Handle**: - Ensure proper handling when a state has no outgoing transitions. - Handle cases where the provided steps might exceed reasonable computational limits. Function Signatures ```python def simulate_markov_chain(chain: dict, initial_state: str, steps: int) -> list: Simulates the Markov Chain for a given number of steps from the initial state. pass def analyze_state_distribution(states: list) -> dict: Analyzes the frequency distribution of states in the provided list. pass ``` Input and Output Formats 1. **simulate_markov_chain** - **Input**: * `chain` (dict): A dictionary representing the Markov Chain. * `initial_state` (str): The starting state. * `steps` (int): The number of steps to simulate. - **Output**: * (list): A list of states visited in the given sequence of steps. 2. **analyze_state_distribution** - **Input**: * `states` (list): A list of states from state transitions. - **Output**: * (dict): A dictionary with state frequencies. Constraints - Assume the Markov chain and probabilities are well-formed (probabilities sum up to 1). - The number of steps will be a positive integer. Example ```python example_chain = { \'A\': {\'A\': 0.6, \'E\': 0.4}, \'E\': {\'A\': 0.7, \'E\': 0.3} } initial_state = \'A\' steps = 5 # Expected Output visited_states = simulate_markov_chain(example_chain, initial_state, steps) # E.g., [\'A\', \'A\', \'E\', \'A\', \'E\'] state_distribution = analyze_state_distribution(visited_states) # E.g., {\'A\': 3, \'E\': 2} ``` Note that the exact output may vary due to the stochastic nature of the simulations.","solution":"import random def simulate_markov_chain(chain: dict, initial_state: str, steps: int) -> list: Simulates the Markov Chain for a given number of steps from the initial state. current_state = initial_state visited_states = [current_state] for _ in range(steps): if current_state not in chain or not chain[current_state]: break # No outgoing transitions from the current state transitions = chain[current_state] states, probabilities = zip(*transitions.items()) current_state = random.choices(states, probabilities)[0] visited_states.append(current_state) return visited_states def analyze_state_distribution(states: list) -> dict: Analyzes the frequency distribution of states in the provided list. state_counts = {} total_states = len(states) for state in states: if state in state_counts: state_counts[state] += 1 else: state_counts[state] = 1 # Convert counts to relative frequencies state_frequencies = {state: count / total_states for state, count in state_counts.items()} return state_frequencies"},{"question":"# Pigeonhole Sort Implementation Challenge Objective Write a function that sorts an array of integers using the pigeonhole sort algorithm. Demonstrate your understanding of non-comparative sorting algorithms and their application for arrays with elements in a specific range. Function Signature ```python def pigeonhole_sort(arr: List[int]) -> List[int]: pass ``` Input - `arr`: A list of integers to be sorted. The integers can be positive, negative, or zero. The list can also be empty. Output - Returns a sorted list of integers. Constraints - The list `arr` can be of length at most 10^5. - The elements of the list are within the range [-10^5, 10^5]. - Ensure that your solution is efficient in both time and space complexity within the given constraints. Performance Requirements - Your implementation should have a time complexity of O(n + Range) where `n` is the number of elements in the array, and `Range` is the difference between the maximum and minimum element values. - Minimize additional space usage. Scenario Consider you are given a large dataset of student scores that spans from -100,000 to 100,000. To quickly sort these scores for further statistical analysis, you decide to use pigeonhole sort. Example ```python arr = [8, 3, 2, 7, 4, 6, 8] sorted_arr = pigeonhole_sort(arr) print(sorted_arr) # Output: [2, 3, 4, 6, 7, 8, 8] arr = [-5, -10, 0, 5, 3, -1, -2, -8, 2, 1, 0, -2, 3, 5, -7] sorted_arr = pigeonhole_sort(arr) print(sorted_arr) # Output: [-10, -8, -7, -5, -2, -2, -1, 0, 0, 1, 2, 3, 3, 5, 5] ``` **Note**: Your implementation should be robust to handle edge cases including empty arrays, arrays with duplicate values, and arrays with negative and positive ranges.","solution":"def pigeonhole_sort(arr): Sorts an array of integers using the pigeonhole sort algorithm. :param arr: List[int]: The list of integers to be sorted. :return: List[int]: The sorted list of integers. if not arr: return [] min_value = min(arr) max_value = max(arr) size = max_value - min_value + 1 holes = [0] * size for num in arr: holes[num - min_value] += 1 sorted_arr = [] for index, count in enumerate(holes): sorted_arr.extend([index + min_value] * count) return sorted_arr"},{"question":"# Task Write a function `strip_query_params(url, params_to_strip=[])` that meets the following requirements: 1. **Removes any duplicate query string parameters** from the given URL. 2. **Removes any query string parameters specified within the `params_to_strip` argument**, which is an optional list of parameter names. Your function should handle various edge cases, including URLs without query strings, duplicate parameters, special characters in the URL, and empty parameter values. # Input Format - `url`: A string representing a URL, e.g., `\\"www.example.com?a=1&b=2&a=2\\"` - `params_to_strip`: A list of strings representing query parameters to be removed, e.g., `[\\"b\\"]`. This argument is optional and defaults to an empty list. # Output Format Return a string representing the modified URL. # Constraints - The URL will be a valid URL but may or may not contain a query string. - Parameter names and values will be alphanumeric strings. - Your solution should preserve the original parameter order as much as possible. # Performance Requirements - Aim for O(n) time complexity where n is the number of query parameters. - Optimize space usage where possible. # Examples 1. `strip_query_params(\\"www.example.com?a=1&b=2&a=2\\")` should return `\\"www.example.com?a=1&b=2\\"` 2. `strip_query_params(\\"www.example.com?a=1&b=2&c=3&a=2\\", [\\"a\\", \\"c\\"])` should return `\\"www.example.com?b=2\\"` # Implementation Guidelines Use built-in libraries and best practices where applicable to ensure readability and efficiency. Handle various edge cases gracefully, ensuring your function returns correct results for all valid inputs.","solution":"from urllib.parse import urlparse, parse_qsl, urlencode, urlunparse def strip_query_params(url, params_to_strip=[]): Removes duplicate query string parameters and specified parameters from the given URL. Args: - url (str): The URL to be modified. - params_to_strip (list): List of parameters to be removed. Returns: - str: The modified URL. parsed_url = urlparse(url) query_params = parse_qsl(parsed_url.query, keep_blank_values=True) unique_params = {} for key, value in query_params: if key not in unique_params: unique_params[key] = value filtered_params = {key: value for key, value in unique_params.items() if key not in params_to_strip} modified_query = urlencode(filtered_params, doseq=True) new_url = urlunparse((parsed_url.scheme, parsed_url.netloc, parsed_url.path, parsed_url.params, modified_query, parsed_url.fragment)) if new_url.endswith(\'?\'): new_url = new_url[:-1] return new_url"},{"question":"**Matrix Transformation Challenge** # Problem Statement: Given an `n x n` matrix, write a function that applies one of the following transformations to the matrix: 1. Rotate the matrix 90 degrees clockwise. 2. Rotate the matrix 90 degrees counterclockwise. 3. Flip the matrix top-left to bottom-right. 4. Flip the matrix bottom-left to top-right. # Expected Input and Output: * **Input**: * `matrix` (List[List[int]]): An `n x n` matrix (non-empty, square matrix). * `transformation` (str): A string indicating the type of transformation to apply. It can take one of the following values: \\"rotate_clockwise\\", \\"rotate_counterclockwise\\", \\"top_left_invert\\", \\"bottom_left_invert\\". * **Output**: * Transformed matrix (List[List[int]]): A new matrix with the specified transformation applied. # Constraints: * The matrix will always be square, i.e., it will have the same number of rows and columns. * The size of the matrix will be between 1 and 100 (inclusive). * The transformation string will always be valid. # Requirements: * Implement the following function signature: ```python def transform_matrix(matrix: List[List[int]], transformation: str) -> List[List[int]]: pass ``` # Example: Input: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], ] transformation = \\"rotate_clockwise\\" ``` Output: ```python [ [7, 4, 1], [8, 5, 2], [9, 6, 3], ] ``` # Additional Test Cases: 1. Test the function with a 2x2 matrix and each transformation type. 2. Test the function with a non-square matrix to ensure robust handling (even though input guarantees a square matrix). 3. Test with multiple transformation types sequentially to check for consistency and correctness. # Hint: Carefully consider the indices of elements during each type of transformation to correctly map the elements to their new positions.","solution":"from typing import List def transform_matrix(matrix: List[List[int]], transformation: str) -> List[List[int]]: n = len(matrix) if transformation == \\"rotate_clockwise\\": return [[matrix[n - j - 1][i] for j in range(n)] for i in range(n)] elif transformation == \\"rotate_counterclockwise\\": return [[matrix[j][n - i - 1] for j in range(n)] for i in range(n)] elif transformation == \\"top_left_invert\\": return [[matrix[j][i] for j in range(n)] for i in range(n)] elif transformation == \\"bottom_left_invert\\": return [[matrix[n - j - 1][n - i - 1] for j in range(n)] for i in range(n)] else: raise ValueError(\\"Invalid transformation type.\\")"},{"question":"# Question: Enhanced Linear Search with Multiplicity Count You are tasked with enhancing the linear search algorithm to not only find the index of the first occurrence of the query element but also to count the total number of times the query element appears in the array. Requirements: * Write a function `enhanced_linear_search` that takes two parameters: - `array`: a list of integers. - `query`: an integer representing the element to search for. * Your function should return a tuple with two values: - The index of the first occurrence of the `query` element in the array. - The total count of how many times the `query` element appears in the array. * If the `query` element is not found, return (-1, 0). Input - `array`: List of integers (0 ≤ length of array ≤ 10000) - `query`: Integer to be searched in the array (Integer limits: -10^6 to 10^6) Output - A tuple of two integers: (first_index, count) Examples ```python >>> enhanced_linear_search([1, 3, 7, 8, 7, 5, 1, 7], 7) (2, 3) >>> enhanced_linear_search([4, 2, 4, 6, 4], 4) (0, 3) >>> enhanced_linear_search([5, 1, 2, 3, 6], 9) (-1, 0) >>> enhanced_linear_search([], 3) (-1, 0) ``` Constraints - Ensure your solution works within provided input constraints. - You should always consider edge cases such as empty arrays and elements not being found.","solution":"def enhanced_linear_search(array, query): Enhanced linear search that finds the index of the first occurrence of the query element and counts the total number of times the query element appears in the array. :param array: List of integers :param query: Integer to be searched in the array :return: A tuple (first_index, count) where `first_index` is the index of the first occurrence of `query` in array and `count` is the total number of times `query` appears in array. If `query` is not found, return (-1, 0). first_index = -1 count = 0 for i in range(len(array)): if array[i] == query: count += 1 if first_index == -1: first_index = i return (first_index, count)"},{"question":"# Matrix Inversion Challenge As part of your journey to become adept with fundamental linear algebra operations, you are tasked to implement a function that computes the inverse of a given `n x n` matrix. The function will be a critical part of a larger system that solves linear equation systems. Function Signature: ```python def compute_matrix_inverse(matrix: List[List[float]]) -> List[List[float]]: pass ``` Input: * `matrix`: A list of lists where each inner list represents a row of the matrix. The matrix is guaranteed to be at least 2x2. Output: * Returns the inverse of the given matrix as a list of lists. If the matrix is not invertible or not a valid matrix, your function should handle it accordingly and print appropriate error messages as shown in the provided code snippet. Constraints: * The matrix will be at least 2x2 and up to 10x10 in size. * Matrix elements are real numbers. Performance Requirements: Your solution should handle up to 100 matrix elements efficiently, taking into account the intricacies of floating-point operations for a stable result. Example: ```python matrix = [ [4, 7], [2, 6] ] print(compute_matrix_inverse(matrix)) # Output: [[0.6, -0.7], [-0.2, 0.4]] ``` Notes: - You may use helper functions similar to those provided in the code snippet to break down the problem. - Ensure your final implementation is robust against common edge cases such as singular matrices where determinant is zero.","solution":"from typing import List def compute_matrix_inverse(matrix: List[List[float]]) -> List[List[float]]: def get_matrix_minor(m, i, j): return [row[:j] + row[j+1:] for row in (m[:i] + m[i+1:])] def get_matrix_determinant(m): if len(m) == 2: return m[0][0] * m[1][1] - m[0][1] * m[1][0] determinant = 0 for c in range(len(m)): determinant += ((-1) ** c) * m[0][c] * get_matrix_determinant(get_matrix_minor(m, 0, c)) return determinant def get_matrix_inverse(m): determinant = get_matrix_determinant(m) if determinant == 0: raise ValueError(\\"Matrix is not invertible\\") if len(m) == 2: return [ [m[1][1] / determinant, -1 * m[0][1] / determinant], [-1 * m[1][0] / determinant, m[0][0] / determinant] ] cofactors = [] for r in range(len(m)): cofactorRow = [] for c in range(len(m)): minor = get_matrix_minor(m, r, c) cofactorRow.append(((-1) ** (r + c)) * get_matrix_determinant(minor)) cofactors.append(cofactorRow) cofactors = list(map(list, zip(*cofactors))) for r in range(len(cofactors)): for c in range(len(cofactors)): cofactors[r][c] = cofactors[r][c] / determinant return cofactors return get_matrix_inverse(matrix)"},{"question":"# Scenario You are given a stack of integers and need to determine if the elements in the stack form an ascending sequence from bottom to top without altering the stack’s original order during the process. # Task Implement a function `is_sorted` to meet the following specifications: Function Signature ```python def is_sorted(stack: list[int]) -> bool: ``` Input - `stack`: A list of integers representing a stack, where the end of the list is considered the top of the stack. Output - Returns `True` if the elements in the stack occur in ascending order from bottom to top. Otherwise, it returns `False`. Constraints - The stack will have at most 10^4 elements. - All elements in the stack are integers where -10^6 ≤ element ≤ 10^6. Performance Requirements - The function should ideally run in **O(n)** time and utilize **O(n)** space. # Example Example 1: **Input**: ```python stack = [6, 3, 5, 1, 2, 4] ``` **Output**: ```python False ``` Example 2: **Input**: ```python stack = [1, 2, 3, 4, 5, 6] ``` **Output**: ```python True ``` Example 3: **Input**: ```python stack = [] ``` **Output**: ```python True ``` # Notes - Remember that `pop()` operations affect the stack by removing the top element, hence you must ensure to restore the stack to its original state before returning. - Handle edge cases like an empty stack or single element stack appropriately to ensure correct functionality across diverse inputs.","solution":"def is_sorted(stack: list[int]) -> bool: Determines if the stack of integers is sorted in ascending order from bottom to top. Parameters: stack (list[int]): List of integers representing the stack. Returns: bool: True if the stack is sorted in ascending order from bottom to top, False otherwise. # Check if the stack is empty or has a single element if len(stack) <= 1: return True # Iterate through the stack from bottom to top and check if each element is less than or equal to the next for i in range(1, len(stack)): if stack[i - 1] > stack[i]: return False return True"},{"question":"# Stutter Function for Stack Manipulation In this assessment, you are required to implement a function `stutter` that uses the given approaches to double the values in a stack. **Objective**: Write a function `stutter` that takes a stack as input and returns the stack with each original value being duplicated. **Function Signature**: ```python def stutter(stack: List[int]) -> List[int]: ``` **Input**: - A list of integers representing the stack, where the last element of the list represents the top of the stack. **Output**: - The same list where each integer in the original stack appears twice consecutively. **Constraints**: - You can use one additional stack or one additional queue as auxiliary storage. - The function should not use any other additional space except the required auxiliary storage. - You can assume the stack contains integers only. **Examples**: ```python # Example 1 input_stack = [3, 7, 1, 14, 9] output_stack = [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] assert stutter(input_stack) == output_stack # Example 2 input_stack = [] output_stack = [] assert stutter(input_stack) == output_stack # Example 3 input_stack = [5] output_stack = [5, 5] assert stutter(input_stack) == output_stack ``` **Requirements**: 1. Write a clear and efficient solution to achieve the objective with a single auxiliary storage. 2. Consider edge cases like an empty stack or a stack with only one element.","solution":"from typing import List def stutter(stack: List[int]) -> List[int]: Function to duplicate each value in a stack of integers. Uses an auxiliary list to help with the process. Args: stack (List[int]): The input stack represented as a list where the last element is the top. Returns: List[int]: The stack after duplicating each value. aux_stack = [] # Transfer elements from stack to auxiliary stack and duplicate them while stack: element = stack.pop() aux_stack.extend([element, element]) # Restore elements to original stack in original order while aux_stack: stack.append(aux_stack.pop()) return stack"},{"question":"# Transitive Closure of a Directed Graph You are given a directed graph with `V` vertices. Implement a function to find the transitive closure of the graph. Function Signature ```python def find_transitive_closure(V: int, edges: List[Tuple[int, int]]) -> List[List[int]]: pass ``` Input - `V` (int): Number of vertices in the graph. - `edges` (List[Tuple[int, int]]): A list of tuples where each tuple represents a directed edge from the first vertex to the second vertex. Output - Returns a 2D list (List[List[int]]) representing the transitive closure matrix. Constraints - Vertices are labeled from `0` to `V-1`. - `0 <= V <= 1000` - `0 <= number of edges <= V * (V-1)` Example ```python V = 4 edges = [(0, 1), (1, 2), (2, 3)] output = find_transitive_closure(V, edges) # Output should be # [ # [1, 1, 1, 1], # [0, 1, 1, 1], # [0, 0, 1, 1], # [0, 0, 0, 1] # ] ``` Hints - You need to initialize a 2-dimensional list `closure` of size `V x V` with all elements set to 0. - For each vertex, perform Depth-First Search (DFS) to mark reachable vertices. - Update the `closure` matrix during each DFS traversal.","solution":"from typing import List, Tuple def find_transitive_closure(V: int, edges: List[Tuple[int, int]]) -> List[List[int]]: # Initialize transitive closure matrix to be all zeros closure = [[0] * V for _ in range(V)] # Create a adjacency matrix directly from the edges for u, v in edges: closure[u][v] = 1 # Initialize the self-loops for i in range(V): closure[i][i] = 1 # Use Floyd-Warshall algorithm to compute the transitive closure for k in range(V): for i in range(V): for j in range(V): if closure[i][j] == 0 and closure[i][k] == 1 and closure[k][j] == 1: closure[i][j] = 1 return closure"},{"question":"# Question: **Sudoku Solver Challenge** You are given a partially filled 9x9 two-dimensional list `board`, which represents a Sudoku puzzle. Implement a `Sudoku` class with a method `solve` that solves the Sudoku puzzle by filling the empty cells. Empty cells are represented by the character `\'.\'`. # Methods to Implement: 1. `possible_values(self)`: Determines all possible values for empty cells. 2. `solve(self)`: Utilizes backtracking to solve the puzzle, updating the `board` in place. 3. `valid_one(self, n, kee, update)`: Checks the validity of the choice and updates the state. 4. `undo(self, kee, update)`: Reverts the board and dictionary state to handle backtracking. 5. `__str__(self)`: Provides a string representation of the board. # Input Format: - `board`: A 9x9 list of lists, where each element is a single character \'1\'-\'9\' or \'.\' representing the empty cells. # Output Format: - The input `board` should be modified in place to represent a valid Sudoku solution. # Constraints: - The input board will have exactly 9 rows and 9 columns. - The board will have a solution. # Example: ```python board = [ [\'5\', \'3\', \'.\', \'.\', \'7\', \'.\', \'.\', \'.\', \'.\'], [\'6\', \'.\', \'.\', \'1\', \'9\', \'5\', \'.\', \'.\', \'.\'], [\'.\', \'9\', \'8\', \'.\', \'.\', \'.\', \'.\', \'6\', \'.\'], [\'8\', \'.\', \'.\', \'.\', \'6\', \'.\', \'.\', \'.\', \'3\'], [\'4\', \'.\', \'.\', \'8\', \'.\', \'3\', \'.\', \'.\', \'1\'], [\'7\', \'.\', \'.\', \'.\', \'2\', \'.\', \'.\', \'.\', \'6\'], [\'.\', \'6\', \'.\', \'.\', \'.\', \'.\', \'2\', \'8\', \'.\'], [\'.\', \'.\', \'.\', \'4\', \'1\', \'9\', \'.\', \'.\', \'5\'], [\'.\', \'.\', \'.\', \'.\', \'8\', \'.\', \'.\', \'7\', \'9\'] ] sudoku = Sudoku(board, 9, 9) sudoku.solve() print(sudoku) ``` # Expected Output: ```plaintext 5 3 4 6 7 8 9 1 2 6 7 2 1 9 5 3 4 8 1 9 8 3 4 2 5 6 7 8 5 9 7 6 1 4 2 3 4 2 6 8 10 3 7 99 1 7 1 3 9 2 4 8 5 6 9 6 1 5 3 7 2 8 4 2 8 7 4 1 9 6 3 5 3 4 5 2 8 6 1 7 9 ``` # Notes: - Carefully handle backtracking to avoid mutating the state in an irreversible way. - Ensure the solution adheres to Sudoku rules: - Each row contains the digits 1-9 with no repetition. - Each column contains the digits 1-9 with no repetition. - Each 3x3 sub-grid contains the digits 1-9 with no repetition.","solution":"class Sudoku: def __init__(self, board): self.board = board def possible_values(self, row, col): Return a set of all possible values for the cell at (row, col). values = set(\'123456789\') for i in range(9): if self.board[row][i] in values: values.remove(self.board[row][i]) if self.board[i][col] in values: values.remove(self.board[i][col]) startRow, startCol = 3 * (row // 3), 3 * (col // 3) for i in range(3): for j in range(3): if self.board[startRow + i][startCol + j] in values: values.remove(self.board[startRow + i][startCol + j]) return values def valid_one(self, char, row, col, update=True): Checks the validity of placing \'char\' at (row, col). for i in range(9): if self.board[row][i] == char or self.board[i][col] == char: return False startRow, startCol = 3 * (row // 3), 3 * (col // 3) for i in range(3): for j in range(3): if self.board[startRow + i][startCol + j] == char: return False if update: self.board[row][col] = char return True def undo(self, row, col): Reverts the board at (row, col) to empty. self.board[row][col] = \'.\' def solve(self): Solves the Sudoku puzzle using backtracking. def backtrack(): for row in range(9): for col in range(9): if self.board[row][col] == \'.\': for char in self.possible_values(row, col): if self.valid_one(char, row, col): self.board[row][col] = char if backtrack(): return True self.undo(row, col) return False return True backtrack() def __str__(self): Provides a string representation of the board. return \'n\'.join(\' \'.join(row) for row in self.board)"},{"question":"Stack ADT Implementation and Application Objective You are to implement a stack using both array-based and linked list-based approaches, and then use one of these stacks to solve a problem related to balanced parentheses. Problem Statement A well-known problem in computer science is to check if an expression containing parentheses is balanced. This means that for every opening parenthesis, there must be a corresponding closing parenthesis and they must be properly nested. Write a function `is_balanced(expression: str) -> bool` that takes a string `expression` containing only parentheses `(` and `)` and returns `True` if the parentheses in the expression are balanced, otherwise return `False`. Implementation Steps: 1. Implement `ArrayStack` and `LinkedListStack` based on the `AbstractStack` class provided in the code snippets. 2. Use either `ArrayStack` or `LinkedListStack` to implement the `is_balanced` function. Constraints: - The length of the expression will be between 1 and 100,000. - Only parentheses will be present in the string. Input/Output Formats: - **Input**: A string containing only `(` and `)`. Example: `\\"((()))\\"` - **Output**: A boolean indicating if the expression is balanced. Example: `True` Example: ```python def is_balanced(expression: str) -> bool: # You may choose to use either ArrayStack or LinkedListStack in your implementation. pass # Example Test Cases: print(is_balanced(\\"()\\")) # True print(is_balanced(\\")(\\")) # False print(is_balanced(\\"(()))\\")) # False print(is_balanced(\\"((()))\\")) # True ``` You are expected to: 1. Complete the implementation of `ArrayStack` and `LinkedListStack` based on provided abstract class. 2. Implement the `is_balanced` function using one of the implementations.","solution":"class AbstractStack: def push(self, item): raise NotImplementedError def pop(self): raise NotImplementedError def is_empty(self): raise NotImplementedError class ArrayStack(AbstractStack): def __init__(self): self.stack = [] def push(self, item): self.stack.append(item) def pop(self): if not self.is_empty(): return self.stack.pop() raise IndexError(\\"pop from empty stack\\") def is_empty(self): return len(self.stack) == 0 class LinkedListStack(AbstractStack): class Node: def __init__(self, data, next_node=None): self.data = data self.next = next_node def __init__(self): self.top = None def push(self, item): new_node = self.Node(item) new_node.next = self.top self.top = new_node def pop(self): if not self.is_empty(): item = self.top.data self.top = self.top.next return item raise IndexError(\\"pop from empty stack\\") def is_empty(self): return self.top is None def is_balanced(expression: str) -> bool: stack = ArrayStack() for char in expression: if char == \'(\': stack.push(char) elif char == \')\': if stack.is_empty(): return False stack.pop() return stack.is_empty()"},{"question":"Scenario In a secure communication system, it\'s critical to identify if a received password is merely a rotated version of a known password from the database for integrity checks. As a developer, you\'re tasked to implement a function that serves this purpose efficiently. Problem Statement Write a function `is_rotated_password` that determines if one string is a rotated version of another string. The function should consider both time and space efficiency, aiming to ensure performance with minimal overhead. Function Signature ```python def is_rotated_password(password: str, candidate: str) -> bool: pass ``` Input and Output * **Input**: - `password` (str): The original password string, 0 ≤ len(password) ≤ 10^5. - `candidate` (str): The received or candidate password string, 0 ≤ len(candidate) ≤ 10^5. * **Output**: - (bool): `True` if `candidate` is a rotated version of `password`, `False` otherwise. Constraints * Control for the edge case where both strings are empty. * Ensure that an effective solution handles even when strings are at their maximum length constraint. Example ```python assert is_rotated_password(\\"securepass\\", \\"passsecure\\") == True assert is_rotated_password(\\"helloworld\\", \\"worldhello\\") == True assert is_rotated_password(\\"rotation\\", \\"notarot\\") == False assert is_rotated_password(\\"abc\\", \\"cab\\") == True assert is_rotated_password(\\"\\", \\"\\") == True ``` Performance Requirements * Aim for a linear time complexity solution, ideally O(N), where N is the length of the strings. * Space complexity should be managed efficiently to avoid excessive use.","solution":"def is_rotated_password(password: str, candidate: str) -> bool: Determines if the candidate password is a rotated version of the original password. if len(password) != len(candidate): return False # Check if candidate is a substring of password+password return candidate in (password + password)"},{"question":"Deep Copy a Complex Linked List Given a linked list where each node contains an additional random pointer, which could point to any node in the list or `None`, implement a function `copy_random_pointer` to return a **deep copy** of the list. # Function Signature ```python def copy_random_pointer(head: RandomListNode) -> RandomListNode: pass ``` # Input - A linked list node `head` of type `RandomListNode`, which represents the starting node of the complex linked list. # Output - Return the head of the new deep-copied linked list. # Constraints - Nodes should be deep copied, meaning each new node must be a completely new object. - The order of nodes and the `random` pointers should be the same in the new list as in the original list. - Ensure the function executes in linear time, O(n), where n is the number of nodes. - Optimize for memory usage efficiently using O(n) additional space. # Example 1 Input: ```plaintext { \\"head\\": [1,2,None,[3,2],[4,1]] } ``` Nodes listed as `[label, next_index, random_index]` where `None` means there are no further nodes, and random pointer points to the node at the provided zero-based index. Output: ```plaintext { \\"new_head\\": [1,2,None,[3,2],[4,1]] } ``` # Example 2 Input: ```plaintext { \\"head\\": [] } ``` Empty list (represented as nothing) Output: ```plaintext { \\"new_head\\": [] } ``` # Example 3 Input: ```plaintext { \\"head\\": [1,None,None] } ``` Single Element list Output: ```plaintext { \\"new_head\\": [1,None,None] } ``` # Notes 1. Consider edge cases like empty lists or lists with only one node. 2. Make sure to handle lists where random pointers may form cycles carefully. 3. Focus on optimizing the space and time efficiency of your solution.","solution":"class RandomListNode: def __init__(self, label: int = 0, next: \'RandomListNode\' = None, random: \'RandomListNode\' = None): self.label = label self.next = next self.random = random def copy_random_pointer(head: RandomListNode) -> RandomListNode: if not head: return None # Step 1: Create new nodes and place them next to the original nodes current = head while current: new_node = RandomListNode(current.label, current.next, None) current.next = new_node current = new_node.next # Step 2: Assign random pointers for the new nodes current = head while current: if current.random: current.next.random = current.random.next current = current.next.next # Step 3: Separate the newly created list from the original list current = head new_head = head.next while current: new_node = current.next current.next = new_node.next if new_node.next: new_node.next = new_node.next.next current = current.next return new_head"},{"question":"# Gnome Sort Implementation and Analysis Challenge You are provided with a simple sorting algorithm known as Gnome Sort. To test your understanding of sorting algorithms and their practical application, you are required to implement a function based on the provided code snippet and analyze its performance on different inputs. Requirements: 1. Implement the `gnome_sort` function which sorts an input list in ascending order. 2. Write another function `analyze_gnome_sort_performance` that: - Generates random lists of varying lengths. - Records the time taken to sort each list using Gnome Sort. - Plots these times to visualize the time complexity. # Constraints: - The number of elements in the list, `n`, can range from 0 to 1000. - Only integers will be present in the list. Input: - A list of integers of varying lengths. Output: - The sorted list in ascending order for the Gnome Sort implementation. - A plot showing the runtime performance of Gnome Sort on varying input sizes. # Example Usage: ```python # Function for Gnome Sort def gnome_sort(arr): n = len(arr) index = 0 while index < n: if index == 0 or arr[index] >= arr[index-1]: index = index + 1 else: arr[index], arr[index-1] = arr[index-1], arr[index] index = index - 1 return arr # Function to analyze performance import random import timeit import matplotlib.pyplot as plt def analyze_gnome_sort_performance(): sizes = [10, 50, 100, 500, 1000] times = [] for size in sizes: test_list = [random.randint(0, size) for _ in range(size)] start_time = timeit.default_timer() gnome_sort(test_list) end_time = timeit.default_timer() times.append(end_time - start_time) plt.plot(sizes, times, marker=\'o\') plt.title(\\"Gnome Sort Performance\\") plt.xlabel(\\"List Size\\") plt.ylabel(\\"Time (seconds)\\") plt.grid(True) plt.show() analyze_gnome_sort_performance() ```","solution":"def gnome_sort(arr): Sorts an array using the Gnome sort algorithm. Parameters: arr (list): The list of integers to sort. Returns: list: The sorted list in ascending order. n = len(arr) index = 0 while index < n: if index == 0 or arr[index] >= arr[index - 1]: index += 1 else: arr[index], arr[index - 1] = arr[index - 1], arr[index] index -= 1 return arr import random import timeit import matplotlib.pyplot as plt def analyze_gnome_sort_performance(): Analyzes the performance of the gnome_sort function on lists of varying sizes. Generates random lists of different sizes, sorts them using gnome_sort, and records the time taken. Plots the results to visualize the time complexity. sizes = [10, 50, 100, 500, 1000] times = [] for size in sizes: test_list = [random.randint(0, size) for _ in range(size)] start_time = timeit.default_timer() gnome_sort(test_list) end_time = timeit.default_timer() times.append(end_time - start_time) plt.plot(sizes, times, marker=\'o\') plt.title(\\"Gnome Sort Performance\\") plt.xlabel(\\"List Size\\") plt.ylabel(\\"Time (seconds)\\") plt.grid(True) plt.show() # Example usage analyze_gnome_sort_performance()"},{"question":"Longest Common Prefix Algorithm Implementation You are given an array of strings and your task is to find the longest common prefix amongst these strings. If there is no common prefix, return an empty string `\\"\\"`. Write a Python function `longest_common_prefix(strs)` that implements one of the methods (Horizontal Scanning, Vertical Scanning, or Divide and Conquer) to determine the longest common prefix. Input: - An array of strings `strs`, where 1 <= strs.length <= 200 and 0 <= strs[i].length <= 200. All `strs[i]` consist of only lowercase English letters. Output: - A string representing the longest common prefix amongst the given strings. Function Signature: ```python def longest_common_prefix(strs: List[str]) -> str: # Your code here ``` Examples: ```python # Example 1 assert longest_common_prefix([\\"flower\\",\\"flow\\",\\"flight\\"]) == \\"fl\\" # Example 2 assert longest_common_prefix([\\"dog\\",\\"racecar\\",\\"car\\"]) == \\"\\" # Example 3 assert longest_common_prefix([\\"interspecies\\", \\"interstellar\\", \\"interstate\\"]) == \\"inters\\" # Example 4 assert longest_common_prefix([\\"throne\\", \\"dungeon\\"]) == \\"\\" # Example 5 assert longest_common_prefix([\\"throne\\", \\"throne\\"]) == \\"throne\\" ``` Constraints and Performance Requirements: - Aim for a time complexity of O(S) where S is the sum of all characters in all strings. - Your solution should handle edge cases and perform efficiently for inputs at the upper constraint boundaries.","solution":"from typing import List def longest_common_prefix(strs: List[str]) -> str: if not strs: return \\"\\" # Initialize the prefix to the first string in the array prefix = strs[0] # Compare the prefix with each string in the array for s in strs[1:]: # Update the prefix by comparing current prefix with the current string while not s.startswith(prefix): prefix = prefix[:-1] if not prefix: return \\"\\" return prefix"},{"question":"Bitonic Sort Enhancement Challenge # Objective The task is to optimize the given Bitonic Sort algorithm by introducing a parallel processing approach. This will improve the runtime performance over large input sizes. The provided bitonic sort algorithm works well, but does not utilize the parallel processing for which it is ideally suited. # Problem Statement Enhance the provided Bitonic Sort algorithm by incorporating Python\'s multiprocessing capabilities to sort large arrays efficiently. Ensure your implementation works for array sizes that are powers of two. # Function Signature ```python def parallel_bitonic_sort(arr: List[int], reverse: bool = False) -> List[int]: pass ``` # Input * `arr` (List[int]): An array of integers that needs to be sorted. The size of the array will always be a power of two. * `reverse` (bool): Default is `False`. If `True`, the function sorts the array in descending order; otherwise, it sorts in ascending order. # Output * A sorted list of integers based on the given order. # Constraints * The input size will be in the range [1, 2^20]. * Use Python\'s `multiprocessing` library effectively. # Performance Requirements * The time complexity should be improved over the non-parallel implementation. # Edge Cases * Consider arrays with duplicate values. * Ensure the code handles arrays with very small sizes efficiently without unnecessary multiprocess overhead. # Example ```python # Example 1: arr = [3, 7, 2, 5, 1, 6, 4, 8] print(parallel_bitonic_sort(arr)) # Output: [1, 2, 3, 4, 5, 6, 7, 8] # Example 2: arr = [3, 7, 2, 5, 1, 6, 4, 8] print(parallel_bitonic_sort(arr, reverse=True)) # Output: [8, 7, 6, 5, 4, 3, 2, 1] ``` # Notes * Efficiently manage inter-process communication and data sharing. * Assume all necessary libraries are available and can be imported. * Document any assumptions made during implementation. Good luck and happy coding!","solution":"import multiprocessing from typing import List def compare_and_swap(arr: List[int], i: int, j: int, direction: bool): if direction == (arr[i] > arr[j]): arr[i], arr[j] = arr[j], arr[i] def bitonic_merge(arr: List[int], low: int, cnt: int, direction: bool): if cnt > 1: k = cnt // 2 for i in range(low, low + k): compare_and_swap(arr, i, i + k, direction) bitonic_merge(arr, low, k, direction) bitonic_merge(arr, low + k, k, direction) def bitonic_sort(arr: List[int], low: int, cnt: int, direction: bool): if cnt > 1: k = cnt // 2 bitonic_sort(arr, low, k, True) bitonic_sort(arr, low + k, k, False) bitonic_merge(arr, low, cnt, direction) def parallel_bitonic_sort(arr: List[int], reverse: bool = False) -> List[int]: n = len(arr) if n <= 2**8: # For small arrays, do not use parallel processing bitonic_sort(arr, 0, n, not reverse) return arr # Create a shared Array with the original array shared_arr = multiprocessing.Array(\'i\', arr) cpu_count = multiprocessing.cpu_count() def parallel_bitonic_sort_helper(low, cnt, direction): if cnt > 1: k = cnt // 2 left_process = multiprocessing.Process(target=parallel_bitonic_sort_helper, args=(low, k, True)) right_process = multiprocessing.Process(target=parallel_bitonic_sort_helper, args=(low + k, k, False)) left_process.start() right_process.start() left_process.join() right_process.join() bitonic_merge(shared_arr, low, cnt, direction) parallel_bitonic_sort_helper(0, n, not reverse) return list(shared_arr)"},{"question":"# Question: Implement an Order-Statistic Tree **Objective**: Utilize the Red-Black Tree implementation to create an Order-Statistic Tree that can efficiently determine the k-th smallest element in the tree. **Context**: You are tasked with extending the Red-Black Tree to support efficient order-statistic operations. An Order-Statistic Tree augments a Red-Black Tree to support operations to find the k-th smallest element in O(log n) time. # Requirements 1. Augment the given Red-Black Tree by adding a `size` attribute to each node, which keeps track of the size of the subtree rooted at that node. 2. Implement the following additional operations: - `os_select`: which determines the k-th smallest element in the tree. - `os_rank`: which determines the rank of a given element in the tree. # Function Details * `os_select(node: RBNode, i: int) -> int`: Returns the i-th smallest element in the subtree rooted at `node`. - **Inputs**: - `node`: The root node of the subtree. - `i`: The desired order statistic (1-based index). - **Output**: The value of the i-th smallest element. * `os_rank(root: RBNode, x: int) -> int`: Returns the rank of the node with value `x` in the subtree rooted at `root`. - **Inputs**: - `root`: The root node of the subtree. - `x`: The value whose rank is to be determined. - **Output**: The rank of the node with value `x` (1-based index). # Implementation Constraints * Ensure that the Red-Black Tree properties are not violated in performing the new operations. * Your implementation should efficiently update the `size` attribute during insertion and deletion operations. * Assume that all elements are unique. # Input and Output Format * Input: - The sequence of operations to perform, starting with insertion of nodes. - Queries in the form of `os_select` and `os_rank`. * Output: - Results of the `os_select` and `os_rank` operations. # Example ```python # Example Usage rb_tree = RBTree() nodes = [11, 2, 14, 1, 7, 15, 5, 8, 4] # Insert nodes into Red-Black Tree for value in nodes: rb_tree.insert(RBNode(value, 1)) # Perform order-statistic operations print(os_select(rb_tree.root, 3)) # Output the 3rd smallest element print(os_rank(rb_tree.root, 7)) # Output the rank of element 7 ```","solution":"class RBNode: def __init__(self, key, size=1): self.key = key self.color = \'red\' # New nodes are always red when inserted self.left = None self.right = None self.parent = None self.size = size # Size of the subtree rooted at this node class RBTree: def __init__(self): self.NIL = RBNode(key=None, size=0) self.NIL.color = \'black\' self.root = self.NIL def left_rotate(self, x): y = x.right x.right = y.left if y.left != self.NIL: y.left.parent = x y.parent = x.parent if x.parent == None: self.root = y elif x == x.parent.left: x.parent.left = y else: x.parent.right = y y.left = x x.parent = y y.size = x.size x.size = x.left.size + x.right.size + 1 def right_rotate(self, x): y = x.left x.left = y.right if y.right != self.NIL: y.right.parent = x y.parent = x.parent if x.parent == None: self.root = y elif x == x.parent.right: x.parent.right = y else: x.parent.left = y y.right = x x.parent = y y.size = x.size x.size = x.left.size + x.right.size + 1 def insert(self, z): z.left = self.NIL z.right = self.NIL z.size = 1 y = None x = self.root while x != self.NIL: x.size += 1 y = x if z.key < x.key: x = x.left else: x = x.right z.parent = y if y == None: self.root = z elif z.key < y.key: y.left = z else: y.right = z z.color = \'red\' self.insert_fixup(z) def insert_fixup(self, z): while z.parent != None and z.parent.color == \'red\': if z.parent == z.parent.parent.left: y = z.parent.parent.right if y.color == \'red\': z.parent.color = \'black\' y.color = \'black\' z.parent.parent.color = \'red\' z = z.parent.parent else: if z == z.parent.right: z = z.parent self.left_rotate(z) z.parent.color = \'black\' z.parent.parent.color = \'red\' self.right_rotate(z.parent.parent) else: y = z.parent.parent.left if y.color == \'red\': z.parent.color = \'black\' y.color = \'black\' z.parent.parent.color = \'red\' z = z.parent.parent else: if z == z.parent.left: z = z.parent self.right_rotate(z) z.parent.color = \'black\' z.parent.parent.color = \'red\' self.left_rotate(z.parent.parent) self.root.color = \'black\' # Order-Statistic Tree methods def os_select(node, i): r = node.left.size + 1 if i == r: return node.key elif i < r: return os_select(node.left, i) else: return os_select(node.right, i - r) def os_rank(root, x): r = root.left.size + 1 if x == root.key: return r elif x < root.key: return os_rank(root.left, x) else: return r + os_rank(root.right, x)"},{"question":"# Two Sum Problem Using Alternative Approach Given an array of integers and a target integer, return the indices of the two numbers such that they add up to a specific target. Assume that each input would have exactly one solution, and you may not use the same element twice. Aim to achieve an optimal solution with O(n) time complexity. Input: * An array of integers `nums`. * An integer `target`, representing the sum to achieve. Output: * A tuple containing two indices of the elements in the array that add up to the target value. Constraints: * All elements in the array and the target value are integers. * The same element cannot be used twice. * There is always only one solution. Examples: 1. Given `nums = [2, 7, 11, 15]` and `target = 9`, Because `nums[0] + nums[1] = 2 + 7 = 9`, return `(0, 1)`. 2. Given `nums = [3, 2, 4]` and `target = 6`: Because `nums[1] + nums[2] = 2 + 4 = 6`, return `(1, 2)`. 3. Given `nums = [3, 3]` and `target = 6`: Because `nums[0] + nums[1] = 3 + 3 = 6`, return `(0, 1)`. Function Signature: ```python def two_sum_alternative(nums: List[int], target: int) -> Tuple[int, int]: ``` Addendum: Alongside writing the function to find the indices, ensure that the function handles edge cases gracefully and includes appropriate error checks for invalid inputs. Additionally, provide a brief explanation of your approach to solving this problem.","solution":"from typing import List, Tuple def two_sum_alternative(nums: List[int], target: int) -> Tuple[int, int]: Given an array of integers and a target integer, return the indices of the two numbers such that they add up to the target. The function assumes there is exactly one solution and that same element is not used twice. Args: nums : List[int] - list of integers target : int - target integer to achieve by summing two numbers from nums Returns: Tuple[int, int] - a tuple containing the indices of the two numbers # Dictionary to record the indices of the visited numbers num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return (num_to_index[complement], i) num_to_index[num] = i # In the given problem, it\'s guaranteed that there is always one solution. # Thus, there is no need to handle the case of not finding a solution."},{"question":"# Question You have been given the task to implement an enhanced version of the Rabin-Miller primality test. Your version should not only determine whether a number is probably prime but should also count and return the number of valid witnesses encountered out of the ( k ) trials. Implement a function `enhanced_is_prime(n: int, k: int) -> Tuple[bool, int]`, where: * `n` (int): The number to be tested for primality ( ( n geq 5 ) ). * `k` (int): The number of iterations for the test. The function should return a tuple: - The first element is a boolean indicating if the number ( n ) is probably prime (`True` means probably prime, `False` means definitely composite). - The second element is an integer representing the count of valid witnesses. # Input * ( n ): integer ( n geq 5 ). * ( k ): number of iterations # Output * A tuple `(is_probably_prime, valid_witness_count)`: * `is_probably_prime` (bool): `True` if ( n ) is probably prime, otherwise `False`. * `valid_witness_count` (int): The number of valid witnesses encountered during the test. # Constraints * Consider making efficient use of the computational resources in terms of both time and space. * Ensure the code handles the intermediate modular exponentiation correctly to avoid overflow errors. # Example: ```python assert enhanced_is_prime(29, 5) == (True, 5) assert enhanced_is_prime(15, 4) == (False, 0) ``` # Performance Requirements Your implementation should operate efficiently for reasonably large values of ( n ) and ( k ), considering the algorithm\'s complexity.","solution":"import random from typing import Tuple def enhanced_is_prime(n: int, k: int) -> Tuple[bool, int]: if n % 2 == 0 or n <= 1: return False, 0 # Find d such that d * 2^r = n-1 with d odd by factoring powers of 2 from n-1 d = n - 1 r = 0 while d % 2 == 0: d //= 2 r += 1 def is_composite(a): x = pow(a, d, n) if x == 1 or x == n - 1: return False for _ in range(r - 1): x = pow(x, 2, n) if x == n - 1: return False return True total_witnesses = 0 for _ in range(k): a = random.randrange(2, n - 1) if not is_composite(a): total_witnesses += 1 else: return False, 0 # Immediately return if a composite witness is found. return True, total_witnesses"},{"question":"# Context In an online document editor, users frequently employ the search function to look for particular phrases or keywords within the text. Efficient pattern matching algorithms like the Knuth-Morris-Pratt (KMP) algorithm are crucial to enhance the user experience, especially with large documents. # Task You are required to implement the `knuth_morris_pratt` function to efficiently search for all occurrences of the pattern within a given text. Additionally, you must handle a variety of edge cases and ensure the accuracy of the search results. # Requirements 1. The function should accept two sequences (strings) `text` and `pattern`. 2. It should return a list of start indices where the pattern is found within the text. 3. Consider and handle potential edge cases, such as: - Empty text or pattern. - Pattern longer than text. - Patterns not present in the text. # Constraints - `text` and `pattern` will only contain lowercase English characters. - The lengths of `text` and `pattern` will be <= 100,000. # Function Signature ```python from typing import Sequence, List def knuth_morris_pratt(text: Sequence[str], pattern: Sequence[str]) -> List[int]: pass ``` # Examples 1. Example 1: - **Input**: `text = \\"searchingtextwithkeywords\\", pattern = \\"key\\"` - **Output**: `[17]` 2. Example 2: - **Input**: `text = \\"aaaaaaa\\", pattern = \\"aaa\\"` - **Output**: `[0, 1, 2, 3, 4]` 3. Example 3: - **Input**: `text = \\"\\", pattern = \\"abc\\"` - **Output**: `[]` 4. Example 4: - **Input**: `text = \\"short\\", pattern = \\"longerpattern\\"` - **Output**: `[]` # Performance Requirements Your solution should be efficient with a time complexity of O(N + M) and a space complexity of O(M).","solution":"from typing import Sequence, List def knuth_morris_pratt(text: Sequence[str], pattern: Sequence[str]) -> List[int]: if not pattern: return [] if not text or len(pattern) > len(text): return [] # Preprocess pattern to create the longest prefix suffix (LPS) array def create_lps(pattern: Sequence[str]) -> List[int]: length = 0 lps = [0] * len(pattern) i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps lps = create_lps(pattern) indices = [] i = 0 j = 0 while i < len(text): if pattern[j] == text[i]: i += 1 j += 1 if j == len(pattern): indices.append(i - j) j = lps[j - 1] elif i < len(text) and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return indices"},{"question":"# Problem: Enhanced Caesar Cipher with Edge Cases **Context**: Julius Caesar\'s substitution cipher is a classical algorithm for encryption, where each letter in the plaintext is shifted by a fixed number of positions down the alphabet. However, your task is to implement an enhanced version of the Caesar Cipher that not only handles standard English alphabets but also correctly processes non-alphabetic characters, numbers, and preserves spaces, punctuation, and case. **Task**: Write a function `enhanced_caesar_cipher(s, k)` that encrypts the string `s` using a Caesar Cipher with a shift `k`. The function should maintain the following behaviors: - Rotate alphabetic characters by `k` positions. - Preserve the case of the characters. - Characters that are not letters should remain unchanged. - Numbers should be shifted within their own 0-9 range. **Input**: - A string `s` containing English letters, digits, punctuation, and spaces `1 <= len(s) <= 10^5`. - An integer `k` that represents the number of positions to shift (may be positive or negative) `-10^5 <= k <= 10^5`. **Output**: - Return the encrypted string. **Example**: ```python Input: s = \\"Hello, World! 123\\", k = 3 Output: \\"Khoor, Zruog! 456\\" Input: s = \\"Hello, World! 123\\", k = -3 Output: \\"Ebiil, Tloia! 890\\" ``` **Constraints**: - Shifts should wrap around within the alphabet boundaries (e.g., a shift of +1 on `\'z\'` should result in `\'a\'` and vice versa). - Digits (0-9) should be shifted within their boundary in a circular manner (a shift of +1 on \'9\' should result in \'0\'). **Notes**: - Efficient performance handling is crucial due to string length constraints. - Handle scenarios where the shift is very large in magnitude by effectively using the modulo operation. # Implementation Define the function `enhanced_caesar_cipher(s, k)` to solve the above problem.","solution":"def enhanced_caesar_cipher(s, k): Encrypts the string `s` using a Caesar Cipher with a shift `k`. Parameters: s (str): The input string. k (int): The number of positions to shift. Returns: str: The encrypted string. def shift_char(c, k): if \'a\' <= c <= \'z\': return chr((ord(c) - ord(\'a\') + k) % 26 + ord(\'a\')) elif \'A\' <= c <= \'Z\': return chr((ord(c) - ord(\'A\') + k) % 26 + ord(\'A\')) elif \'0\' <= c <= \'9\': return chr((ord(c) - ord(\'0\') + k) % 10 + ord(\'0\')) else: return c effective_k = k % 26 # Only applies to alphabetic characters; digits handled separately return \'\'.join(shift_char(c, k if c.isdigit() else effective_k) for c in s)"},{"question":"Context You are given an infinitely long sequence of numbers generated by concatenating consecutive integers starting from 1. For example, the sequence \\"12345678910111213...\\" proceeds indefinitely. You need to write a function that determines the nth digit in this sequence. Coding Task Write a function `find_nth_digit(n)` that finds the nth digit of the infinite sequence of concatenated integers. # Function Signature ```python def find_nth_digit(n: int) -> int: Find the nth digit in the infinite sequence of concatenated integers starting from 1. Parameters: n (int): A positive integer representing the position in the infinite sequence. Returns: int: The nth digit of the sequence (0-9). ``` # Input * A single integer `n` (1 ≤ n ≤ 2^31 - 1) representing the position in the sequence. # Output * A single integer which is the nth digit in the infinite sequence. # Constraints * The input value `n` will always be a positive integer. * You should handle very large values of `n` efficiently. # Example ```python print(find_nth_digit(1)) # Output: 1 print(find_nth_digit(15)) # Output: 2 print(find_nth_digit(11)) # Output: 0 ``` # Explanation * For `find_nth_digit(1)`, the first digit in sequence \\"123...\\" is 1. * For `find_nth_digit(15)`, the 15th digit in sequence \\"123456789101112...\\" corresponds to part of the sequence \\"2\\" from the number 12. * For `find_nth_digit(11)`, the 11th digit is \'0\' from the number 10.","solution":"def find_nth_digit(n: int) -> int: Find the nth digit in the infinite sequence of concatenated integers starting from 1. Parameters: n (int): A positive integer representing the position in the infinite sequence. Returns: int: The nth digit of the sequence (0-9). # Determine the length of the numbers in the sequence length = 1 count = 9 start = 1 while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 start += (n - 1) // length s = str(start) return int(s[(n - 1) % length])"},{"question":"# Question: Determine Strong Connectivity in a Directed Graph As a new graduate joining our software engineering team, one of your tasks is to analyze the connectivity of various directed graphs that our applications generate. Specifically, you need to determine whether each graph is \\"strongly connected.\\" In graph theory, a directed graph is said to be strongly connected if there is a path from any vertex to every other vertex. You are provided with a Python class `Graph` that creates and manages a directed graph. Your task is to complete the method `is_strongly_connected(self)` within this class to determine whether the graph is strongly connected or not, using the concepts of depth-first search (DFS) and graph traversal. Function Signature ```python def is_strongly_connected(self) -> bool: pass ``` Input - The graph is represented as a set of vertices interconnected by directed edges. - The graph creation and edges are handled by methods already provided in the `Graph` class. - You can assume that `self.vertex_count` (number of vertices) and `self.graph` (adjacency list representation) are correctly initialized by the class constructor and `add_edge` method respectively. Output - Return `True` if the graph is strongly connected, otherwise return `False`. Constraints - The number of vertices ( V ) in the graph is between 1 and ( 10^4 ). - The number of edges ( E ) is between 0 and ( 10^5 ). Example ```python # Create a graph with 5 vertices g = Graph(5) g.add_edge(0, 1) g.add_edge(1, 2) g.add_edge(2, 3) g.add_edge(3, 4) g.add_edge(4, 0) # Check if the graph is strongly connected print(g.is_strongly_connected()) # Output: True # Create another graph with 3 vertices g = Graph(3) g.add_edge(0, 1) g.add_edge(1, 2) # Check if the graph is strongly connected print(g.is_strongly_connected()) # Output: False ``` Performance - Ensure that your solution runs efficiently within the provided constraints. - Consider performance implications and manage recursion intelligently to avoid stack overflow in deep recursions. --- **Note**: You need to handle edge cases where the graph might be disconnected or contain no edges. Ensure thorough error handling to maintain correct outputs for various graph configurations.","solution":"class Graph: def __init__(self, vertices): self.vertices = vertices self.graph = [[] for _ in range(vertices)] def add_edge(self, u, v): self.graph[u].append(v) def _dfs(self, v, visited): visited[v] = True for i in self.graph[v]: if not visited[i]: self._dfs(i, visited) def _get_transpose(self): g = Graph(self.vertices) for i in range(self.vertices): for j in self.graph[i]: g.add_edge(j, i) return g def is_strongly_connected(self): visited = [False] * self.vertices # Step 1: Do a DFS from the first vertex. self._dfs(0, visited) if any(not visited_vertex for visited_vertex in visited): return False # Step 2: Get the transpose of the graph gr = self._get_transpose() # Step 3: Do DFS from the first vertex in the transposed graph visited = [False] * self.vertices gr._dfs(0, visited) if any(not visited_vertex for visited_vertex in visited): return False return True"},{"question":"# Last Occurrence Finder in a Sorted Array **Objective**: Write a function to find the last occurrence of a specified number in a sorted array. **Function Signature** ```python def find_last_occurrence(arr: List[int], target: int) -> int: Given a sorted array \'arr\' of integers and a target integer \'target\', returns the index of the last occurrence of the target in the array. If the target is not found, return -1. Parameters: arr (List[int]): A list of integers sorted in increasing order. target (int): The target integer to find in the array. Returns: int: The index of the last occurrence of the target in the array or -1 if not found. pass ``` **Input**: - `arr`: List of integers sorted in non-decreasing order. Example: [2, 4, 4, 4, 6, 9, 9]. - `target`: Integer to be searched in the array. Example: 4. **Output**: - Returns an integer representing the index of the last occurrence of the target. If the target is not found, returns -1. **Constraints**: - The array \'arr\' will have a length n where 1 <= n <= 10^5. - Each integer in the array can be between -10^9 and 10^9. **Example**: 1. Input: `[2, 4, 4, 4, 6, 9, 9]`, `4` Output: `3` 2. Input: `[1, 2, 3, 5, 5, 5, 5, 5, 6, 7, 8]`, `5` Output: `7` 3. Input: `[1, 2, 3, 4, 5, 6, 7, 8, 9]`, `10` Output: `-1` **Explanation**: - In Example 1, the last occurrence of 4 is at index 3. - In Example 2, the last occurrence of 5 is at index 7. - In Example 3, the target 10 is not present in the array, hence return -1. Write your implementation of the binary search function to find the last occurrence of `target` in `arr`.","solution":"from typing import List def find_last_occurrence(arr: List[int], target: int) -> int: Returns the index of the last occurrence of the target in the array or -1 if not found. low, high = 0, len(arr) - 1 result = -1 while low <= high: mid = (low + high) // 2 if arr[mid] == target: result = mid low = mid + 1 elif arr[mid] < target: low = mid + 1 else: high = mid - 1 return result"},{"question":"# AVL Tree Implementation and Edge Case Handling in Python **Context**: You are given a partially implemented AVL Tree class with methods for insertion, rotations, and balancing. Your task is to complete the implementation and write additional methods to support the deletion of nodes as well as extra functionalities for utility. **Task**: 1. **Implement a delete method**: Create a method named `delete(key)` that deletes a node from the AVL Tree while ensuring the tree remains balanced. 2. **Ensure AVL Tree Property**: Modify the existing methods if needed to ensure the AVL Tree properties hold after deletion. 3. **Update in-order traversal**: Verify that `in_order_traverse` method accurately reflects the structure of your tree after insertions and deletions. # Function Signatures ```python def delete(self, key): Deletes a node with the given key from the AVL tree. ``` # Constraints - The tree does not include duplicate keys. - Only valid integer keys will be provided for insertion and deletion operations. - The underlying TreeNode class is provided and initialized with proper constructor and attributes. # Example ```python avl = AvlTree() avl.insert(10) avl.insert(20) avl.insert(30) avl.insert(40) avl.insert(50) print(avl.in_order_traverse()) # Output should be [10, 20, 30, 40, 50] avl.delete(30) print(avl.in_order_traverse()) # Output should be [10, 20, 40, 50] ``` # Assessment Criteria * Correctness of Implementation: Proper functioning of insertion, deletion, and balancing operations. * Handling of edge cases and maintenance of AVL properties. * Time and Space complexity adherence. * Code readability and structure.","solution":"class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class AvlTree: def __init__(self): self.root = None def insert(self, key): self.root = self._insert(self.root, key) def _insert(self, node, key): if not node: return TreeNode(key) if key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) if balance > 1 and key < node.left.key: return self._right_rotate(node) if balance < -1 and key > node.right.key: return self._left_rotate(node) if balance > 1 and key > node.left.key: node.left = self._left_rotate(node.left) return self._right_rotate(node) if balance < -1 and key < node.right.key: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def delete(self, key): self.root = self._delete(self.root, key) def _delete(self, node, key): if not node: return node if key < node.key: node.left = self._delete(node.left, key) elif key > node.key: node.right = self._delete(node.right, key) else: if node.left is None: return node.right elif node.right is None: return node.left temp = self._get_min_value_node(node.right) node.key = temp.key node.right = self._delete(node.right, temp.key) if not node: return node node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) if balance > 1 and self._get_balance(node.left) >= 0: return self._right_rotate(node) if balance > 1 and self._get_balance(node.left) < 0: node.left = self._left_rotate(node.left) return self._right_rotate(node) if balance < -1 and self._get_balance(node.right) <= 0: return self._left_rotate(node) if balance < -1 and self._get_balance(node.right) > 0: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def _left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _get_height(self, node): if not node: return 0 return node.height def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def _get_min_value_node(self, node): current = node while current.left: current = current.left return current def in_order_traverse(self): result = [] self._in_order_helper(self.root, result) return result def _in_order_helper(self, node, result): if node: self._in_order_helper(node.left, result) result.append(node.key) self._in_order_helper(node.right, result)"},{"question":"# Pythagorean Theorem Side Calculation **Context**: Given the lengths of two sides of a right-angled triangle, you will use the Pythagorean theorem to find the third side. The Pythagorean theorem is stated as `a^2 + b^2 = c^2` where: - `a` and `b` are the legs (opposite and adjacent sides) of the triangle. - `c` is the hypotenuse (the side opposite the right angle). **Task**: Implement a function called `find_triangle_side(opposite, adjacent, hypotenuse)` that fits the following requirements: 1. Accept three arguments representing the triangle sides. 2. Pass \\"?\\" to indicate the unknown side. 3. Calculate and return the length of the unknown side. 4. If input values don\'t form a valid right-angled triangle, raise an appropriate `ValueError`. **Function Signature:**: ```python def find_triangle_side(opposite: str, adjacent: str, hypotenuse: str) -> str: pass ``` **Input/Output Examples**: ```python print(find_triangle_side(\\"3\\", \\"4\\", \\"?\\")) # Output: \\"Hypotenuse = 5.0\\" print(find_triangle_side(\\"?\\", \\"4\\", \\"5\\")) # Output: \\"Opposite = 3.0\\" print(find_triangle_side(\\"3\\", \\"?\\", \\"5\\")) # Output: \\"Adjacent = 4.0\\" print(find_triangle_side(\\"3\\", \\"4\\", \\"5\\")) # Output: \\"You already know the answer!\\" print(find_triangle_side(\\"?\\", \\"?\\", \\"5\\")) # Raises ValueError: \\"Invalid argument(s) were given.\\" ``` **Constraints**: * Exactly one of the arguments must be `\\"?\\"`. * All numerical inputs are positive integers or floats. * Inputs must represent valid right angle triangles for which the Pythagorean theorem holds.","solution":"import math def find_triangle_side(opposite, adjacent, hypotenuse): Given two sides of a right-angled triangle and \\"?\\" for the unknown side, this function calculates the length of the unknown side using the Pythagorean theorem. if opposite == \\"?\\" and adjacent != \\"?\\" and hypotenuse != \\"?\\": opposite = math.sqrt(float(hypotenuse) ** 2 - float(adjacent) ** 2) return f\\"Opposite = {opposite:.1f}\\" elif adjacent == \\"?\\" and opposite != \\"?\\" and hypotenuse != \\"?\\": adjacent = math.sqrt(float(hypotenuse) ** 2 - float(opposite) ** 2) return f\\"Adjacent = {adjacent:.1f}\\" elif hypotenuse == \\"?\\" and opposite != \\"?\\" and adjacent != \\"?\\": hypotenuse = math.sqrt(float(opposite) ** 2 + float(adjacent) ** 2) return f\\"Hypotenuse = {hypotenuse:.1f}\\" elif opposite != \\"?\\" and adjacent != \\"?\\" and hypotenuse != \\"?\\": if math.isclose(float(opposite) ** 2 + float(adjacent) ** 2, float(hypotenuse) ** 2): return \\"You already know the answer!\\" else: raise ValueError(\\"Inputs do not form a valid right-angled triangle.\\") else: raise ValueError(\\"Invalid argument(s) were given.\\")"},{"question":"# Priority Queue Implementation You are tasked with implementing a Priority Queue using a linear array, demonstrating the concepts from fundamental data structures. **Objective:** Implement the following functionalities for a Priority Queue: 1. `size()`: Return the number of elements in the priority queue. 2. `push(item, priority=None)`: Insert an item with a given priority into the queue. If no priority is provided, the item itself is considered the priority. 3. `pop()`: Remove and return the item with the lowest priority. **Constraints:** - The queue should maintain the order of elements by priority, with the highest priority elements at the front. - The priority is an integer where a higher number indicates higher priority. - The queue should handle duplicate priorities correctly by inserting them based on the order of insertion. **Example Input/Output:** - After `push(1, 5), push(2, 3), push(3, 4)`, `pop()` should return `2` (the item with the lowest priority 3). - After `push(4), push(5, 2)`, `pop()` should return `5` (here `5` has priority as `2` and `4` has priority as `4`). **Function Signature:** ```python class PriorityQueue: def __init__(self, items=None, priorities=None): pass def size(self): pass def push(self, item, priority=None): pass def pop(self): pass ``` **Your task is to implement above `PriorityQueue` class methods.**","solution":"class PriorityQueue: def __init__(self): self.queue = [] def size(self): return len(self.queue) def push(self, item, priority=None): if priority is None: priority = item self.queue.append((priority, item)) self.queue.sort(key=lambda x: x[0]) def pop(self): if not self.queue: return None return self.queue.pop(0)[1]"},{"question":"# Problem: Selection Sort Enhancement and Analysis You have been provided with the basic implementation of the selection sort algorithm. Your task is to enhance this algorithm to handle specific cases more effectively and analyze its performance based on given scenarios. Objective: 1. **Enhance Selection Sort**: Modify the `selection_sort` function to handle two specific cases: - If the array is already sorted, the function should complete without unnecessary iterations. - If there are duplicate elements, ensure that their relative order is maintained (making the sort stable). 2. **Validate Output**: You will validate if the enhanced function preserves the properties of a sorted array. 3. **Performance Analysis**: - Implement logic to count and print the number of comparisons and swaps made during the sorting process. - Analyze the performance by counting and comparing these values for different input scenarios. Instructions: 1. Implement the enhanced version of the `selection_sort` algorithm in a function called `enhanced_selection_sort`. 2. The function signature should be: ```python def enhanced_selection_sort(arr: list, simulation=False) -> list ``` 3. The input is a list of integers, and the output should be the sorted list of integers. 4. If `simulation` is set to `True`, print the state of the array at each iteration and count of comparisons and swaps. 5. Ensure that the function efficiently handles already sorted arrays and preserves the relative order of duplicate elements. 6. Analyze and document the number of comparisons and swaps for the following test cases: - Case 1: An already sorted array. - Case 2: An array with all identical elements. - Case 3: A small, random unsorted array. Constraints: - Do not use any additional libraries or built-in sorting functions. - The length of the array will not exceed 1000 elements. Example: ```python # Sample usage arr = [64, 25, 12, 22, 11] sorted_arr = enhanced_selection_sort(arr, simulation=True) ``` **Expected Output with `simulation=True`**: ``` iteration 0 : 11 25 12 22 64 comparisons: X, swaps: Y iteration 1 : 11 12 25 22 64 comparisons: X, swaps: Y ... sorted array: [11, 12, 22, 25, 64] total comparisons: Z, total swaps: W ```","solution":"def enhanced_selection_sort(arr: list, simulation=False) -> list: Enhanced Selection Sort Algorithm which efficiently handles already sorted arrays and maintains the relative order of duplicate elements. n = len(arr) comparisons = 0 swaps = 0 for i in range(n - 1): min_index = i is_sorted = True for j in range(i + 1, n): comparisons += 1 if arr[j] < arr[min_index]: min_index = j if arr[j - 1] > arr[j]: is_sorted = False if is_sorted: break if min_index != i: arr[i], arr[min_index] = arr[min_index], arr[i] swaps += 1 if simulation: print(f\'iteration {i} : {arr}\') print(f\'comparisons: {comparisons}, swaps: {swaps}\') if simulation: print(f\'sorted array: {arr}\') print(f\'total comparisons: {comparisons}, total swaps: {swaps}\') return arr"},{"question":"**Problem Statement**: You are implementing a function that rotates an n x n 2D matrix by 90 degrees clockwise. Can you achieve this transformation in an efficient, in-place manner? # Function Signature ```python def rotate_matrix(matrix: list[list[int]]) -> None: pass ``` # Input * `matrix` (list of list of int): An n x n 2D matrix where 1 <= n <= 10^3, 0 <= matrix[i][j] <= 10^5. # Output * The function should not return any value. It should modify the `matrix` in-place. # Constraints * You must perform the rotation in-place without using any extra space for another matrix. # Example ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(matrix) print(matrix) ``` Expected Output ``` [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` # Notes * Consider edge cases such as an empty matrix or a single-element matrix. * Ensure to handle mutating the input matrix correctly, maintaining its integrity after the rotation. * Think about the performance implications for large matrices up to 1000 x 1000 in size.","solution":"def rotate_matrix(matrix: list[list[int]]) -> None: Rotates an n x n 2D matrix by 90 degrees clockwise in-place. n = len(matrix) # Step 1: Transpose the matrix (convert rows to columns) for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Step 2: Reverse each row for row in matrix: row.reverse()"},{"question":"# Scenario You are working in a software engineering team tasked with validating the integrity of various data structures used in a system. One of the common issues is the presence of cycles in singly linked lists, which can cause performance problems and infinite loops during list traversals. # Objective Write a function `is_cyclic(head)` that determines if a given singly linked list has a cycle in it. Your solution should be efficient and use O(1) extra space. # Function Definition ```python def is_cyclic(head): :type head: Node :rtype: bool # Your code here ``` # Input - `head`: a reference to the head of a singly linked list of nodes. Each node is an instance of the `Node` class. # Output - Return `True` if there is a cycle in the linked list. - Return `False` if there is no cycle. # Constraints - The number of nodes in the linked list can be up to 10^4. - Node values can be any integer. # Example Consider the following linked list: ``` 1 -> 2 -> 3 ^ | |____| ``` In this list, the node with value `2` points back to the node with value `3`, creating a cycle. **Input**: ```python head = Node(1) head.next = Node(2) head.next.next = Node(3) head.next.next.next = head.next # creates the cycle ``` **Output**: ```python print(is_cyclic(head)) # Should output: True ``` # Notes - Think about the edge cases such as an empty list or a list with just one node. - Focus on maintaining the O(n) time complexity while keeping space usage constant at O(1).","solution":"class Node: def __init__(self, value=0, next=None): self.value = value self.next = next def is_cyclic(head): Detects if a cycle exists in a singly linked list. :type head: Node :rtype: bool if not head: return False slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False"},{"question":"Given a fully connected directed graph with weighted edges (weights are non-negative), write a function `shortest_path` in Python that uses Dijkstra\'s Algorithm to find the shortest distances from a given source vertex to all other vertices in the graph. # Function Signature ```python def shortest_path(graph: List[List[int]], src: int) -> List[int]: ``` # Input * `graph`: A 2D list of integers where `graph[i][j]` represents the weight of the edge from vertex `i` to vertex `j`. If there is no edge, the weight is represented as 0. The graph is guaranteed to be fully connected and directed. * `src`: An integer representing the source vertex. # Output * Return a list of integers where the value at index `i` represents the shortest distance from the source vertex to vertex `i`. # Constraints * `1 <= len(graph) <= 1000` (The graph can have up to 1000 vertices) * All edge weights are non-negative integers which can be arbitrarily large. * The source vertex `src` will always be a valid vertex in the graph. # Examples Example 1: ```python graph = [ [0, 2, 9, 0], [0, 0, 6, 1], [0, 0, 0, 4], [0, 0, 0, 0] ] src = 0 shortest_path(graph, src) # Output: [0, 2, 8, 3] ``` Example 2: ```python graph = [ [0, 1, 0], [0, 0, 3], [1, 0, 0] ] src = 2 shortest_path(graph, src) # Output: [1, 2, 0] ``` # Explanation: For the first example: - The shortest path from vertex 0 to 1 is 2. - The shortest path from vertex 0 to 2 is 8 (0 -> 1 -> 2). - The shortest path from vertex 0 to 3 is 3 (0 -> 1 -> 3). Ensure you account for: * Proper initialization of distances. * Correctly identifying the next vertex to process. * Efficiently updating distances of adjacent vertices. * Avoiding infinite loops or incorrect results.","solution":"from typing import List import heapq def shortest_path(graph: List[List[int]], src: int) -> List[int]: Implements Dijkstra\'s algorithm to find the shortest distances from the source vertex to all other vertices in the graph. Parameters: graph (List[List[int]]): A 2D list of integers representing the graph. src (int): The source vertex. Returns: List[int]: A list where the value at index `i` represents the shortest distance from the source vertex to vertex `i`. # Number of vertices in the graph n = len(graph) # Distance array, initialized to infinity dist = [float(\'inf\')] * n dist[src] = 0 # Priority queue to select the vertex with the minimum distance pq = [(0, src)] # (distance, vertex) while pq: current_dist, u = heapq.heappop(pq) # If the current distance is greater than the recorded shortest distance then we skip processing if current_dist > dist[u]: continue # Iterate through all neighbors of u for v in range(n): if graph[u][v] > 0: # There is an edge between u and v alt = current_dist + graph[u][v] # If a shorter path to v is found if alt < dist[v]: dist[v] = alt heapq.heappush(pq, (alt, v)) return dist"},{"question":"# Shell Sort Optimization Challenge **Context:** As a software developer, you are working on improving the performance of a sorting function in an application that often deals with large datasets. Your current implementation uses Shell Sort due to its simplicity and better performance over simpler sorts, but you want to optimize it further. **Task:** Enhance the provided Shell Sort implementation by introducing an optimized gap sequence that improves the average performance. **Function Signature:** ```python def optimized_shell_sort(arr: List[int]) -> List[int]: ``` **Input:** - `arr`: A list of integers (1 leq text{len(arr)} leq 10^5) **Output:** - A sorted list of integers in non-decreasing order **Constraints:** - Your implementation should handle large inputs efficiently. - You should use an optimized gap sequence over the basic n/2 sequence. **Performance Requirements:** - Your solution should aim to have a better average case performance compared to the simple Shell Sort. **Example:** ```python # Input arr = [64, 34, 25, 12, 22, 11, 90] # Output [11, 12, 22, 25, 34, 64, 90] ``` **Notes:** - Consider using gap sequences such as Hibbard, Sedgewick, or Ciura. - You are encouraged to provide comments and document your choice of gap sequence.","solution":"from typing import List def optimized_shell_sort(arr: List[int]) -> List[int]: Performs optimized Shell Sort on the provided list of integers using the Ciura gap sequence. # Ciura gap sequence gaps = [701, 301, 132, 57, 23, 10, 4, 1] n = len(arr) # Start with the largest gap and work down to a gap of 1 for gap in gaps: # Do a gapped insertion sort for this gap size. # The first gap elements arr[0..gap-1] are already in gap order # keep adding one more element until the entire array is gap sorted for i in range(gap, n): # add arr[i] to the elements that have been gap sorted # save arr[i] in temp and make a hole at position i temp = arr[i] # shift earlier gap-sorted elements up until the correct location for arr[i] is found j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap # put temp (the original arr[i]) in its correct location arr[j] = temp return arr"},{"question":"# Problem Description You are tasked with implementing a function that takes a string, and returns a new string where the order of the characters in each individual word is reversed, but the words are in the original order. # Input and Output * **Input**: A single string `s` which contains words separated by spaces. The string `s` may contain leading, trailing, or multiple spaces between words. * **Output**: A string with the reversed characters of each word in the original word order. # Constraints * The input string `s` can have a length of up to 10^5 characters. * Words in `s` are separated by one or more spaces. * There will be at least one word in `s`. # Example ```python reverse_characters_in_words(\\" hello world \\") ``` **Output**: ```\\" olleh dlrow \\"``` # Detailed Requirements 1. Implement the function `reverse_characters_in_words(s: str) -> str` that performs the above described operation. 2. Your solution should handle multiple spaces appropriately. 3. Optimize for best performance in terms of both time and space complexity, considering the constraints. 4. Ensure to manage any edge cases such as strings with leading and trailing spaces, multiple spaces between words, and empty string scenarios. # Implementation Use the provided framework to implement your solution: ```python def reverse_characters_in_words(s: str) -> str: # Split the string into a list of words maintaining all spaces words = s.split(\' \') # Reverse the characters of each word reversed_words = [word[::-1] for word in words] # Join them back into a single string using \' \' as a separator return \' \'.join(reversed_words) # Test the function with various cases to ensure it works as expected if __name__ == \\"__main__\\": test_cases = [ \\" hello world \\", \\"reverse these words\\", \\" Python is fun\\", \\"double spaces\\", \\"a b \\" ] for test in test_cases: print(f\\"Original: \'{test}\'\\") print(f\\"Reversed: \'{reverse_characters_in_words(test)}\'\\") print() ```","solution":"def reverse_characters_in_words(s: str) -> str: Reverses the characters in each word of the string `s` while maintaining the original word order. Words are defined as sequences of non-space characters. Leading, trailing, and multiple spaces between words are preserved in the output. # Split the string into a list of words, maintaining all spaces as empty strings words = s.split(\' \') # Reverse the characters in each word reversed_words = [word[::-1] for word in words] # Join the reversed words with a space to form the final output return \' \'.join(reversed_words)"},{"question":"# Scenario You are working as a software developer for a data analysis company, and your team has been handed large datasets of uniformly distributed integer values. Because these arrays contain a narrowly defined range of numbers close to the count of elements, typical comparison-based sorting algorithms are not the most efficient. To address this, you need to implement a sorting algorithm that takes advantage of the nature of your datasets. # Task Implement the `pigeonhole_sort` function according to the details below. Your implementation should efficiently sort the list in ascending order. # Function Signature ```python def pigeonhole_sort(arr: List[int]) -> List[int]: pass ``` # Input * `arr`: A list of integers, where the length of the list is `n` (1 ≤ n ≤ 100,000) and the values range from `Min` to `Max` such that `Max - Min` ≤ 100,000. # Output * Returns a sorted list in ascending order. # Constraints * The list will always contain integers within the given range. * The list may contain duplicate values. # Example ```python # Example 1: arr = [8, 3, 2, 7, 4] assert pigeonhole_sort(arr) == [2, 3, 4, 7, 8] # Example 2: arr = [5, 5, 5, 5, 5] assert pigeonhole_sort(arr) == [5, 5, 5, 5, 5] # Example 3: arr = [12, 11, 13] assert pigeonhole_sort(arr) == [11, 12, 13] ``` # Notes * Consider handling edge cases such as an array of length 1 or arrays with all identical elements. * Focus on minimizing space complexity if possible while maintaining an efficient sorting time.","solution":"from typing import List def pigeonhole_sort(arr: List[int]) -> List[int]: Sorts the given list of integers using the pigeonhole sorting algorithm. Parameters: arr (List[int]): List of integers to be sorted. Returns: List[int]: Sorted list of integers. if not arr: return arr # Find the minimum and maximum values in the array min_val = min(arr) max_val = max(arr) # Calculate the range of the values range_val = max_val - min_val + 1 # Create a list of empty \\"pigeonholes\\" holes = [0] * range_val # Populate the pigeonholes for num in arr: holes[num - min_val] += 1 # Compile the sorted array from the pigeonholes sorted_arr = [] for index, count in enumerate(holes): sorted_arr.extend([min_val + index] * count) return sorted_arr"},{"question":"# Insertion Sort Simulation Enhancement Given the `insertion_sort` function that sorts an array, enhance this function to return a detailed step-by-step transformation of the array during the sorting process. The enhanced function should return a list of lists, where each sublist represents the array\'s state after each iteration of the outer loop. This will help visualize the sorting process. # Requirements: 1. **Function Definition**: Enhance the given `insertion_sort` function. 2. **Input Format**: A list of integers `arr`. 3. **Output Format**: A list of lists, where each list is the state of `arr` after each outer loop iteration. 4. **Constraints**: - `1 <= len(arr) <= 1000` - `-10000 <= arr[i] <= 10000` for any valid i # Example **Input**: ```python [4, 3, 2, 10, 12, 1, 5, 6] ``` **Output**: ```python [ [3, 4, 2, 10, 12, 1, 5, 6], [2, 3, 4, 10, 12, 1, 5, 6], [2, 3, 4, 10, 12, 1, 5, 6], [2, 3, 4, 10, 12, 1, 5, 6], [1, 2, 3, 4, 10, 12, 5, 6], [1, 2, 3, 4, 5, 10, 12, 6], [1, 2, 3, 4, 5, 6, 10, 12] ] ``` # Explanation: Each sublist corresponds to the state of the array after each outer loop iteration. This gives a clear visualization of how the array transforms step-by-step during the sorting process. # Additional Notes: - The initial unsorted array should not be part of the output. - You can use the `simulation` argument to manage whether to print the iteration details or not. However, this flag should not affect the return format described.","solution":"def insertion_sort(arr): Perform an insertion sort on the list `arr`, and return the list of lists representing the state of the array after each outer loop iteration. Parameters: arr (list): List of integers to be sorted. Returns: list of lists: Nested list with the state of the array after each iteration of the outer loop. steps = [] n = len(arr) for i in range(1, n): key = arr[i] j = i - 1 while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key steps.append(arr[:]) # Record the current state of array after each outer loop iteration return steps"},{"question":"# Character Occurrence Removal **Context**: You are developing a text processing utility that removes redundant characters from user inputs while preserving their order of first appearance. This is crucial for cleaning up data entries before further processing. **Problem**: Write a function `remove_duplicates_from_string` that takes a single input string and returns a new string with all recurring characters removed, keeping only the first occurrence of each character. Function Signature ```python def remove_duplicates_from_string(input_string: str) -> str: ``` Input * A string `input_string` (0 <= len(input_string) <= 10^6) comprising any printable ASCII characters. Output * A string with duplicated characters removed, keeping only the first occurrence. Constraints * Handle large input efficiently within time and space constraints. Example ```python assert remove_duplicates_from_string(\\"geeksforgeeks\\") == \\"geksfor\\" assert remove_duplicates_from_string(\\"hello\\") == \\"helo\\" assert remove_duplicates_from_string(\\"\\") == \\"\\" assert remove_duplicates_from_string(\\"aaaa\\") == \\"a\\" ``` Requirements * The function should run in O(n) time complexity where n is the length of the string. * The function should have a space complexity proportional to the number of unique characters in the string.","solution":"def remove_duplicates_from_string(input_string: str) -> str: Removes redundant characters from the input string while preserving the order of first appearances. seen = set() result = [] for char in input_string: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"You are tasked with extending the functionality of a recommendation system by implementing a function that computes the cosine similarity between pairs of user preference vectors. This measure will be used to find how similar one user\'s preferences are to another\'s, which is crucial for generating recommendations. # Function Signature ```python def cosine_similarity(vec1, vec2): Calculate cosine similarity between two non-zero length vectors. :param vec1: List of integers/floats representing user preferences. :param vec2: List of integers/floats representing user preferences. :return: Float value representing the cosine similarity between vec1 and vec2. pass ``` # Requirements - The two vectors, `vec1` and `vec2`, must be of the same length. - If the vectors do not have the same length, raise a `ValueError`. - If either or both vectors are zero vectors, return a similarity of `0.0`. # Expected Input and Output - Input: Two lists of integers/floats (`vec1`, `vec2`). - Output: A float representing the cosine similarity between two vectors. # Constraints - Length of the input lists: `1 <= len(vec1) == len(vec2) <= 10^6` - Values in the list: `-10^3 <= vec1[i], vec2[i] <= 10^3` # Performance Requirements - Implement the function with a time complexity of O(n). - Implement the function with a space complexity of O(1). # Examples ```python cosine_similarity([1, 1, 1], [1, 2, -1]) # Output: 0.47140452079103173 cosine_similarity([1, 0, 1], [0, 1, 1]) # Output: 0.5 cosine_similarity([0, 0, 0], [1, 1, 1]) # Output: 0.0 cosine_similarity([1, 2], [2, 4]) # Output: 1.0 ``` # Notes - Ensure your solution handles edge cases such as zero vectors effectively. - Aim to write clear and efficient code with appropriate error handling.","solution":"import math def cosine_similarity(vec1, vec2): Calculate cosine similarity between two non-zero length vectors. :param vec1: List of integers/floats representing user preferences. :param vec2: List of integers/floats representing user preferences. :return: Float value representing the cosine similarity between vec1 and vec2. if len(vec1) != len(vec2): raise ValueError(\\"Vectors must be of the same length\\") dot_product = sum(x * y for x, y in zip(vec1, vec2)) magnitude_vec1 = math.sqrt(sum(x * x for x in vec1)) magnitude_vec2 = math.sqrt(sum(y * y for y in vec2)) if magnitude_vec1 == 0 or magnitude_vec2 == 0: return 0.0 return dot_product / (magnitude_vec1 * magnitude_vec2)"},{"question":"# Merge Sort Coding Challenge You are given an unsorted list of integers. Your task is to implement the Merge Sort algorithm to sort the list in ascending order. The implementation should follow the principles of Merge Sort and must handle various edge cases efficiently. Your implementation must include: 1. **Function `merge_sort(arr)`**: This function sorts the input list by recursively dividing it and merging the sorted halves. 2. **Helper Function `merge(left, right, merged)`**: This function merges two sorted lists into a single sorted list. # Input * An unsorted list of integers `arr` where `1 <= len(arr) <= 10^5` and elements `-10^9 <= arr[i] <= 10^9`. # Output * A sorted list of integers in ascending order. # Example **Input** ```python arr = [5, 3, 8, 4, 2, 7, 6, 1] ``` **Output** ```python [1, 2, 3, 4, 5, 6, 7, 8] ``` # Constraints * Must use the Merge Sort algorithm. * Aim to minimize memory usage considering the given input constraints. ```python def merge_sort(arr): # Base case for recursion if len(arr) <= 1: return arr mid = len(arr) // 2 # Recursively split the arrays left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:]) # Create a merged array with sorted order merged = [0] * (len(left) + len(right)) merge(left, right, merged) return merged def merge(left, right, merged): left_cursor, right_cursor = 0, 0 while left_cursor < len(left) and right_cursor < len(right): if left[left_cursor] <= right[right_cursor]: merged[left_cursor + right_cursor] = left[left_cursor] left_cursor += 1 else: merged[left_cursor + right_cursor] = right[right_cursor] right_cursor += 1 # Append leftovers if any for left_cursor in range(left_cursor, len(left)): merged[left_cursor + right_cursor] = left[left_cursor] for right_cursor in range(right_cursor, len(right)): merged[left_cursor + right_cursor] = right[right_cursor] ``` Implement the `merge_sort` function to pass the example and ensure it works efficiently for large input data.","solution":"def merge_sort(arr): # Base case for recursion if len(arr) <= 1: return arr mid = len(arr) // 2 # Recursively split the arrays left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:]) # Create a merged array with sorted order merged = [] merge(left, right, merged) return merged def merge(left, right, merged): left_cursor, right_cursor = 0, 0 while left_cursor < len(left) and right_cursor < len(right): if left[left_cursor] <= right[right_cursor]: merged.append(left[left_cursor]) left_cursor += 1 else: merged.append(right[right_cursor]) right_cursor += 1 # Append leftovers if any while left_cursor < len(left): merged.append(left[left_cursor]) left_cursor += 1 while right_cursor < len(right): merged.append(right[right_cursor]) right_cursor += 1"},{"question":"You are working on an embedded system that requires highly efficient data manipulation. One of the common tasks is to swap adjacent bits in an 8-bit unsigned integer. You need to write a function that efficiently swaps the odd and even bits. Requirements: 1. **Input**: An unsigned 8-bit integer (0 to 255). 2. **Output**: An unsigned 8-bit integer with odd and even bits swapped. 3. **Constraints**: * The function should perform the operation with as few bitwise instructions as possible. * Ensure your solution works within the constraints of 8-bit integers. Specifications: * Swap adjacent bits: * Bit 0 swaps with Bit 1. * Bit 2 swaps with Bit 3. * Bit 4 swaps with Bit 5. * Bit 6 swaps with Bit 7. Example: 1. **Input**: 22 (binary: 00010110) 2. **Output**: 41 (binary: 00101001) Write a function `swap_pair` that performs this operation. ```python def swap_pair(num): # Your implementation here pass # Example usage: print(swap_pair(22)) # should output 41 print(swap_pair(10)) # should output 5 ```","solution":"def swap_pair(num): Swaps adjacent bits in an 8-bit unsigned integer. # Ensure the number is within the 8-bit unsigned integer range if not (0 <= num <= 255): raise ValueError(\\"Input must be an 8-bit unsigned integer (0 to 255).\\") # Mask even bits with 0xAA (10101010 in binary) and shift them left even_bits = (num & 0xAA) >> 1 # Mask odd bits with 0x55 (01010101 in binary) and shift them right odd_bits = (num & 0x55) << 1 # Combine the shifted bits return even_bits | odd_bits"},{"question":"# Bubble Sort in Practice Context: Imagine you are working as a software engineer tasked with developing a module that handles light preprocessing of small datasets before the main analysis pipeline. Your team has decided to start with a simple bubble sort for initial understanding and then iterate on improving efficiency. Problem: Write a function `custom_bubble_sort` in Python that takes in an array of integers and returns the sorted array. Additionally, you should implement a simulation mode that prints each step of the sorting process, helping you to debug and understand how the algorithm operates. Requirements: 1. **Function Signature**: ```python def custom_bubble_sort(arr: list[int], simulation: bool = False) -> list[int]: ``` 2. **Input**: - `arr` - A list of integers that needs to be sorted. - `simulation` - A boolean flag, if set to `True` should print each step of the sorting process. 3. **Output**: - The function should return the sorted array. 4. **Constraints**: - Do not use any built-in sorting functions. - Limit your solution to O(1) extra space complexity. - Assume that the list size is small enough to handle the worse-case performance of bubble sort. 5. **Performance Requirement**: - The solution should have a time complexity of O(n^2) where n is the number of elements in the array. Namun 6. **Edge Cases to Handle**: - Empty array input. - Single-element array. - Arrays with all equal elements. Example: ```python >>> custom_bubble_sort([3, 2, 1], True) iteration 0 : 3 2 1 iteration 1 : 2 3 1 iteration 2 : 2 1 3 iteration 3 : 1 2 3 [1, 2, 3] >>> custom_bubble_sort([5, 1, 4, 2, 8]) [1, 2, 4, 5, 8] >>> custom_bubble_sort([]) [] ``` # Hints: - Implement a helper function to swap elements. - Consider using a flag to detect if the array is already sorted partway through the sorting process.","solution":"def custom_bubble_sort(arr: list[int], simulation: bool = False) -> list[int]: n = len(arr) for i in range(n): swapped = False for j in range(0, n-i-1): if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] swapped = True if simulation: print(f\\"Iteration {i} index {j}: {arr}\\") if not swapped: break return arr"},{"question":"# Bogo Sort: Implementation and Performance Testing As a crossover between coding challenge and learning exercise, this question will test your understanding of randomized algorithms and their analysis. You are provided with an extremely inefficient sorting algorithm known as **Bogo Sort**. Objective - Implement the `bogo_sort` function, ensuring it correctly sorts an array. - Analyze and enhance the given implementation to handle edge cases and compare its inefficiency with more practical sorting algorithms. Question **1. Implement the function `bogo_sort` with the following specification:** ```python def bogo_sort(arr, simulation=False): Perform Bogo Sort on an array with optional simulation to print intermediate steps. Parameters: arr (list): List of elements to sort. simulation (bool): If true, print intermediate array states after each shuffle. Returns: list: Sorted list of elements. # Implementation needed here ``` Constraints - Array elements are integers. - The array size will not be larger than 10 to prevent excessive runtime. - Edge cases like empty array or single-element array should be handled appropriately. **2. Develop a comparison mechanism:** * Compare the performance of `bogo_sort` against a practical sorting algorithm (e.g., Python’s built-in `sorted()` function). **Hints**: * Conduct the comparison for varying array sizes (within allowed constraints). * Measure the time taken by each algorithm and discuss the observed differences. **3. Write a brief analysis:** * Why is Bogo Sort impractical for real-world use? * Under what scenarios (if any) might its use be justified? Input - A list of integers. Output - The sorted list of integers. # Context: Imagine you are tasked with choosing the correct sorting algorithm for your new application. Through this exercise, you will understand why certain sorting algorithms are typically chosen over others and identify which characteristics make Bogo Sort a poor choice.","solution":"import random def bogo_sort(arr, simulation=False): Perform Bogo Sort on an array with optional simulation to print intermediate steps. Parameters: arr (list): List of elements to sort. simulation (bool): If true, print intermediate array states after each shuffle. Returns: list: Sorted list of elements. def is_sorted(arr): return all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1)) while not is_sorted(arr): if simulation: print(f\\"Shuffling array: {arr}\\") random.shuffle(arr) return arr def compare_sorts(): Compare the performance of bogo_sort and Python\'s built-in sorted function. Returns: dict: Contains the timings and sorted arrays from both functions. import time results = {} test_arrays = [ [], [1], [2, 1], [3, 1, 2], [4, 2, 3, 1], [5, 3, 2, 1, 4] ] for arr in test_arrays: bogo_arr = arr.copy() sorted_arr = arr.copy() start = time.time() bogo_sort(bogo_arr) end = time.time() bogo_time = end - start start = time.time() sorted_arr = sorted(sorted_arr) end = time.time() sorted_time = end - start results[str(arr)] = { \'bogo_sort_time\': bogo_time, \'bogo_sorted\': bogo_arr, \'sorted_time\': sorted_time, \'builtin_sorted\': sorted_arr } return results"},{"question":"# Value Range Filtering Design a function `value_filter` that filters values from an input array based on specified minimum and/or maximum limits. Input Format * An integer array `arr` where 0 <= len(arr) <= 1000 and each element in the array is an integer. * An integer `min_lim` (optional) representing the minimum value limit; if not provided, defaults to `None`. * An integer `max_lim` (optional) representing the maximum value limit; if not provided, defaults to `None`. Output Format * A list of integers representing the filtered array where each element x from the input array satisfies `min_lim <= x <= max_lim` Constraints * The input array may be empty. * If `min_lim` is None, it should default to the smallest element in the array. * If `max_lim` is None, it should default to the largest element in the array. * If both `min_lim` and `max_lim` are None, the function should return the input array as is. Performance Requirements * The function should operate with a time complexity of O(n) and a space complexity of O(n). Example **Example 1**: ```python arr = [1, 2, 3, 4, 5] min_lim = None max_lim = 3 value_filter(arr, min_lim, max_lim) ``` Output: ``` [1, 2, 3] ``` **Example 2**: ```python arr = [8, 27, 19, 3, 5, 31] min_lim = 10 max_lim = 20 value_filter(arr, min_lim, max_lim) ``` Output: ``` [19] ``` **Example 3**: ```python arr = [1, 2, 3, 4, 5] min_lim = 2 max_lim = None value_filter(arr, min_lim, max_lim) ``` Output: ``` [2, 3, 4, 5] ``` # Function Signature ```python def value_filter(arr: List[int], min_lim: Optional[int], max_lim: Optional[int]) -> List[int]: pass ``` Implement the `value_filter` function to meet the above requirements.","solution":"from typing import List, Optional def value_filter(arr: List[int], min_lim: Optional[int] = None, max_lim: Optional[int] = None) -> List[int]: Filters values from an input array based on specified minimum and/or maximum limits. :param arr: List of integers to filter. :param min_lim: The minimum value limit (inclusive). If None, defaults to the smallest element in the array. :param max_lim: The maximum value limit (inclusive). If None, defaults to the largest element in the array. :return: A list of filtered integers. if not arr: return arr if min_lim is None: min_lim = min(arr) if max_lim is None: max_lim = max(arr) return [x for x in arr if min_lim <= x <= max_lim]"},{"question":"You have been appointed as a developer at a data-processing company. One of your key tasks includes implementing an algorithm to move all zeros in an array to the end of the array while preserving the order of other elements. **Function Signature**: ```python def move_zeros(arr: list) -> list: ``` # Input * A list `arr` containing integers and other objects (`bool`, `str`, etc.). # Output * Returns a list in which all zero values are moved to the end of the list. # Constraints * The order of non-zero elements should be preserved. * Boolean `False` should not be considered zero and should retain its position. * Minimize additional space usage if possible. # Examples 1. `move_zeros([False, 1, 0, 1, 2, 0, 1, 3, \\"a\\"])` * Output: `[False, 1, 1, 2, 1, 3, \\"a\\", 0, 0]` 2. `move_zeros([0, \\"b\\", False, 0, 1, 3, 0])` * Output: `[\\"b\\", False, 1, 3, 0, 0, 0]` 3. `move_zeros([0, 0, 0])` * Output: `[0, 0, 0]` 4. `move_zeros([1, 2, 3, 4])` * Output: `[1, 2, 3, 4]` # Notes * Consider handling edge cases such as empty arrays, arrays with no zeros. * Optimize the space complexity if possible. **Performance Requirements** * The solution should have a time complexity of at most O(n) and an additional space complexity as minimal as possible.","solution":"def move_zeros(arr: list) -> list: Move all zeros in the list to the end while preserving the order of other elements. :param arr: List containing integers and other objects :return: List with all zero values moved to the end zero_count = 0 result = [] for elem in arr: if elem == 0 and not isinstance(elem, bool): # Checking for zero but not False zero_count += 1 else: result.append(elem) result.extend([0] * zero_count) return result"},{"question":"# Segment Tree Challenge **Scenario**: You are tasked with managing a database of financial transactions over time and need to frequently query the sum and maximum values of transactions over different periods. You decide to use a Segment Tree to efficiently manage these queries. **Problem**: 1. Implement a `SegmentTree` class that can be used to handle a list of numbers and allows querying the sum of a range of these numbers in logarithmic time. 2. Enhance the `SegmentTree` class to support querying the maximum value in a range. **Implementation Requirements**: Write two functions within your `SegmentTree` class: 1. `query_sum(L, R)`: Returns the sum of elements in the range `[L, R]`. 2. `query_max(L, R)`: Returns the maximum value of elements in the range `[L, R]`. The `SegmentTree` should be initialized with a list of integers, constructing separate trees for sum and max queries. **Input/Output**: * `__init__(self, arr)`: Initializes the `SegmentTree`. * **Input**: `arr` - a list of integers. * `query_sum(self, L, R)`: Queries the sum of integers in the segment. * **Input**: `L`, `R` - start and end indices of the range. * **Output**: Sum of integers in the specified range. * `query_max(self, L, R)`: Queries the maximum value in the segment. * **Input**: `L`, `R` - start and end indices of the range. * **Output**: Maximum integer in the specified range. **Constraints**: * 1 <= len(arr) <= 10^5 * -10^6 <= arr[i] <= 10^6 * 0 <= L <= R < len(arr) **Example**: ```python # Example initialization and queries transactions = [4, 5, 2, 3, 4, 43, 3] segment_tree = SegmentTree(transactions) # Sum queries: assert segment_tree.query_sum(0, 2) == 11 assert segment_tree.query_sum(1, 5) == 57 # Max queries: assert segment_tree.query_max(0, 2) == 5 assert segment_tree.query_max(4, 6) == 43 ``` Your task is to complete the `SegmentTree` class with appropriate methods and attributes to fulfill the above requirements.","solution":"class SegmentTree: def __init__(self, arr): self.n = len(arr) self.arr = arr self.sum_tree = [0] * (2 * self.n) self.max_tree = [float(\'-inf\')] * (2 * self.n) self.build() def build(self): # Initialize leaves: for i in range(self.n): self.sum_tree[self.n + i] = self.arr[i] self.max_tree[self.n + i] = self.arr[i] # Build the trees: for i in range(self.n - 1, 0, -1): self.sum_tree[i] = self.sum_tree[2*i] + self.sum_tree[2*i + 1] self.max_tree[i] = max(self.max_tree[2*i], self.max_tree[2*i + 1]) def query_sum(self, L, R): L += self.n R += self.n + 1 sum_result = 0 while L < R: if L % 2: sum_result += self.sum_tree[L] L += 1 if R % 2: R -= 1 sum_result += self.sum_tree[R] L //= 2 R //= 2 return sum_result def query_max(self, L, R): L += self.n R += self.n + 1 max_result = float(\'-inf\') while L < R: if L % 2: max_result = max(max_result, self.max_tree[L]) L += 1 if R % 2: R -= 1 max_result = max(max_result, self.max_tree[R]) L //= 2 R //= 2 return max_result"},{"question":"You are given an array of integers and a target value. Your task is to write a function that finds all unique combinations of `n` numbers from the array that sum up to the given target. # Input Format 1. An integer `n` representing the number of elements in each combination. 2. An array `nums` of integers. 3. An integer `target` representing the target sum. # Output Format Return a list of lists, where each list represents a unique combination of `n` numbers that sum up to the given target. The elements in each combination should be sorted in ascending order, and the list of combinations should not contain any duplicates. # Constraints 1. The length of `nums` will be between 0 and 1000. 2. Elements in `nums` are integer values. 3. The input `n` will be between 2 and 5. 4. The target will be an integer value. 5. The list of combinations in the result must not contain any duplicate sets. # Example Example 1 * Input: ```python n = 4 nums = [1, 0, -1, 0, -2, 2] target = 0 ``` * Output: ```python [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]] ``` Example 2 * Input: ```python n = 2 nums = [-3, 0, -2, 1, 2, 3, 8, -9] target = -5 ``` * Output: ```python [[-9, 4], [-5, 0], [-8, 3]] ``` # Function Signature ```python def find_n_sum_combinations(n: int, nums: List[int], target: int) -> List[List[int]]: # Your code here ``` # Notes * You may define additional helper functions if needed, but ensure the main function name and signature remains unchanged. * Ensure your solution handles edge cases (e.g., empty list, all zeros, list with duplicate values) effectively.","solution":"from typing import List def find_n_sum_combinations(n: int, nums: List[int], target: int) -> List[List[int]]: def k_sum(nums, target, k, path): if not nums: return # Base case for 2-sum problem if k == 2: left, right = 0, len(nums) - 1 while left < right: curr_sum = nums[left] + nums[right] if curr_sum == target: result.append(path + [nums[left], nums[right]]) left += 1 right -= 1 while left < right and nums[left] == nums[left - 1]: left += 1 while left < right and nums[right] == nums[right + 1]: right -= 1 elif curr_sum < target: left += 1 else: right -= 1 else: for i in range(len(nums) - k + 1): if i == 0 or nums[i - 1] != nums[i]: k_sum(nums[i + 1:], target - nums[i], k - 1, path + [nums[i]]) nums.sort() result = [] k_sum(nums, target, n, []) return result"},{"question":"# Symmetric Binary Tree Checker Context You are working on a project that involves validating the symmetry of various binary tree structures. A binary tree is symmetric if it is a mirror reflection of itself around its center. Your task is to implement both a recursive and an iterative method to check if a given binary tree is symmetric. Task Implement two functions: 1. **is_symmetric(root)**: A recursive function that takes the root of a binary tree and returns `True` if the tree is symmetric, `False` otherwise. 2. **is_symmetric_iterative(root)**: An iterative function to achieve the same task. Input - `root`: The root node of the binary tree (can be `None` if the tree is empty). Output - Returns `True` if the tree is symmetric, `False` otherwise. Constraints - The number of nodes in the tree is in the range `[0, 2000]`. - Each node\'s value is an integer in the range `[-1000, 1000]`. Example ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example tree: [1,2,2,3,4,4,3] root = TreeNode(1) root.left = TreeNode(2, TreeNode(3), TreeNode(4)) root.right = TreeNode(2, TreeNode(4), TreeNode(3)) assert is_symmetric(root) == True assert is_symmetric_iterative(root) == True # Non-symmetric tree: [1,2,2,None,3,None,3] root = TreeNode(1) root.left = TreeNode(2, None, TreeNode(3)) root.right = TreeNode(2, None, TreeNode(3)) assert is_symmetric(root) == False assert is_symmetric_iterative(root) == False ``` Performance Requirements - Time Complexity: Both functions should run in O(n), where n is the number of nodes in the tree. - Space Complexity: Ensure space complexity is optimal and consider the trade-offs between recursive call stacks and iterative stacks.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_symmetric(root): def is_mirror(t1, t2): if not t1 and not t2: return True if not t1 or not t2: return False return (t1.val == t2.val) and is_mirror(t1.left, t2.right) and is_mirror(t1.right, t2.left) return is_mirror(root, root) def is_symmetric_iterative(root): if not root: return True queue = [(root, root)] while queue: t1, t2 = queue.pop(0) if not t1 and not t2: continue if not t1 or not t2: return False if t1.val != t2.val: return False queue.append((t1.left, t2.right)) queue.append((t1.right, t2.left)) return True"},{"question":"You are given a list of integers and two optional boundary values, `Min` and `Max`. You need to implement a function that filters the array, returning only the elements that are greater than or equal to `Min` and less than or equal to `Max`. If `Min` is not provided, use the smallest element in the list as the lower boundary. Similarly, if `Max` is not provided, use the largest element in the list as the upper boundary. # Function Signature ```python def limit(arr: List[int], min_lim: Optional[int] = None, max_lim: Optional[int] = None) -> List[int]: pass ``` # Input * `arr`: A list of integers. The list can be empty. * `min_lim`: An optional integer representing the lower boundary. * `max_lim`: An optional integer representing the upper boundary. # Output * A list of integers filtered to include only those elements within the specified range [min_lim, max_lim]. # Constraints * The input list can contain up to 10^6 elements. * Each element fits within the range of standard 32-bit integers. # Example ```python limit([1, 2, 3, 4, 5], None, 3) # returns [1, 2, 3] limit([10, -5, 0, 23, 100], 0, 50) # returns [10, 0, 23] limit([15, 30, 45, 60], 20, 50) # returns [30, 45] limit([7, 8, 9], None, None) # returns [7, 8, 9] ``` # Requirements 1. The function should efficiently handle the input size with optimal execution time. 2. The function must handle edge cases like empty arrays and boundaries lying outside the range of array elements.","solution":"from typing import List, Optional def limit(arr: List[int], min_lim: Optional[int] = None, max_lim: Optional[int] = None) -> List[int]: if not arr: return [] if min_lim is None: min_lim = min(arr) if max_lim is None: max_lim = max(arr) return [x for x in arr if min_lim <= x <= max_lim]"},{"question":"# Merge Sort Strategy and Implementation Merge Sort is a well-known sorting algorithm that follows the Divide and Conquer strategy. In this task, you are required to implement this sorting algorithm. The algorithm involves three core steps: 1. **Divide**: Recursively split the array into two halves until each subarray has only one element (or is empty). 2. **Conquer**: Sort each half. 3. **Merge**: Combine the sorted halves to produce a sorted array. The merging process involves comparing elements from two halves and keeping the smaller elements in order. Task Implement the `merge_sort` function as detailed below: ```python def merge_sort(arr): Sorts an array using the Merge Sort algorithm. Parameters: arr (list): A list of elements to be sorted. Returns: list: A new sorted list containing the elements from arr in ascending order. # Implementation needed here def merge(left, right): Merges two sorted arrays into a single sorted array. Parameters: left (list): Left half array (sorted). right (list): Right half array (sorted). Returns: list: A single sorted list containing all elements from left and right. # Implementation needed here ``` Input and Output - **Input**: A non-empty list of integers `arr`. - **Output**: A new list of integers that are sorted in ascending order. Constraints - 1 ≤ len(arr) ≤ 10^5 - -10^9 ≤ arr[i] ≤ 10^9 for each element in `arr`. Example **Input:** ```python arr = [38, 27, 43, 3, 9, 82, 10] ``` **Output:** ```python [3, 9, 10, 27, 38, 43, 82] ``` Use the following helpful prompts to guide your implementation: 1. **Base Case**: If the array has 1 or 0 elements, it is already sorted. 2. **Recursive Division**: Divide the array into left and right halves and apply `merge_sort` to each half. 3. **Merge**: Implement the `merge` function to combine and sort the two halves. Make sure to handle edge cases such as empty arrays or arrays with only one element, and arrays where all elements are identical.","solution":"def merge_sort(arr): Sorts an array using the Merge Sort algorithm. Parameters: arr (list): A list of elements to be sorted. Returns: list: A new sorted list containing the elements from arr in ascending order. if len(arr) <= 1: return arr mid = len(arr) // 2 left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:]) return merge(left, right) def merge(left, right): Merges two sorted arrays into a single sorted array. Parameters: left (list): Left half array (sorted). right (list): Right half array (sorted). Returns: list: A single sorted list containing all elements from left and right. result = [] i = 0 j = 0 while i < len(left) and j < len(right): if left[i] < right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 result.extend(left[i:]) result.extend(right[j:]) return result"},{"question":"Subtree Validation **Context**: You are working on ensuring the structural integrity of hierarchical data in a large database system. Your specific task is to write a function to determine if a given tree `t` is a subtree of another tree `s`. **Problem Statement**: Write a function `is_subtree(s, t)` that takes the root nodes of two binary trees `s` and `t`, and returns `True` if tree `t` is a subtree of tree `s`, and `False` otherwise. A subtree of a tree `t` is defined as a tree consisting of a node in `t` and all of its descendants in `t`. **Function Signature**: ```python def is_subtree(s: TreeNode, t: TreeNode) -> bool: ``` **Input**: - `s`: The root of the larger binary tree. - `t`: The root of the smaller binary tree. **Output**: - A boolean value: `True` if `t` is a subtree of `s`, and `False` otherwise. **Constraints**: 1. Both `s` and `t` are binary trees with at most `10000` nodes each. 2. Tree node values are integers and can be positive, negative, or zero. **Examples**: 1. Example 1: ``` Given s: 3 / 4 5 / 1 2 Given t: 4 / 1 2 is_subtree(s, t) returns True. ``` 2. Example 2: ``` Given s: 3 / 4 5 / 1 2 / 0 Given t: 4 / 1 2 is_subtree(s, t) returns False. ``` **Edge Cases**: - If either `s` or `t` is null, handle appropriately. - Consider scenarios where `s` and `t` have the same root value but different structures. **Guidelines**: 1. Implement a helper function `compare` to check if two trees are structurally identical. 2. Use level-order traversal (BFS) to iterate through the tree `s` and check for subtree equality starting at nodes that match the root of `t`. 3. Optimize for larger trees by minimizing unnecessary comparisons.","solution":"class TreeNode: def __init__(self, val: int = 0, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.val = val self.left = left self.right = right def is_subtree(s: TreeNode, t: TreeNode) -> bool: if not s: return False if is_same_tree(s, t): return True return is_subtree(s.left, t) or is_subtree(s.right, t) def is_same_tree(s: TreeNode, t: TreeNode) -> bool: if not s and not t: return True if not s or not t: return False if s.val != t.val: return False return is_same_tree(s.left, t.left) and is_same_tree(s.right, t.right)"},{"question":"You are tasked to implement an enhanced version of the provided square root function. This version should handle edge cases where the input number is very small or very large and should ensure that the function remains performant across a wide range of inputs. Additionally, the function should also return the number of iterations it took to reach the desired precision. # Requirements - **Function Name**: `enhanced_square_root` - **Input**: Two parameters: 1. `n` (a positive integer) 2. `epsilon` (a float, representing the maximum error tolerance, default value = 0.001) - **Output**: A tuple `(root, iterations)` where `root` is the approximated square root of `n` and `iterations` is the number of iterations it took to achieve this approximation. # Constraints - If `n` is 0, the function should return (0, 0). - The function should handle inputs as large as (10^{12}). - The value of `epsilon` provided will always be positive and can be as small as (10^{-12}). # Example ```python # Example 1 n = 5 epsilon = 0.001 # Function call root, iterations = enhanced_square_root(5, 0.001) # Expected output # Around (2.236, <number of iterations>) # Example 2 n = 0 # Function call root, iterations = enhanced_square_root(0, 0.001) # Expected output # (0, 0) # Example 3 n = 123456789 epsilon = 0.0000001 # Function call root, iterations = enhanced_square_root(n, epsilon) # Expected output # Around (11111.11106, <number of iterations>) ``` # Hint Consider ways to prevent infinite loops or performance issues, especially with very small epsilon values.","solution":"def enhanced_square_root(n, epsilon=0.001): Returns the approximate square root of n and the number of iterations it took to reach the desired precision. if n == 0: return (0, 0) guess = n / 2.0 iterations = 0 while True: iterations += 1 new_guess = (guess + n / guess) / 2.0 if abs(new_guess - guess) < epsilon: return (new_guess, iterations) guess = new_guess"},{"question":"Context You have been given the task to implement a sorting algorithm that minimizes the number of write operations. This is particularly important in scenarios where write operations are expensive or limited, such as in certain types of memory storage. Problem Statement Implement an in-place sorting function using Cycle Sort to sort an array of integers. Your function should minimize the number of write operations and should handle various edge cases efficiently. Function Signature ```python def cycle_sort(arr): Sorts the array in-place using Cycle Sort algorithm. Parameters: arr (list): List of integers to be sorted Returns: list: The same list sorted in ascending order ``` Input * A list of integers, `arr`, where `1 <= len(arr) <= 10^4` and elements are in the range `-10^6 <= arr[i] <= 10^6`. Output * The function should return the same list sorted in ascending order. Constraints * Minimize the number of write operations. * The function should not use any additional space for another array (in-place sorting). Example ```python # Example 1 arr = [3, 1, 4, 1, 5] print(cycle_sort(arr)) # Output: [1, 1, 3, 4, 5] # Example 2 arr = [0, -1, 3, 9, 9] print(cycle_sort(arr)) # Output: [-1, 0, 3, 9, 9] # Example 3 arr = [5, 4, 3, 2, 1] print(cycle_sort(arr)) # Output: [1, 2, 3, 4, 5] ``` Your task is to write the `cycle_sort` function. Consider all edge cases, optimize performance wherever possible, and ensure correctness across diverse input scenarios.","solution":"def cycle_sort(arr): Sorts the array in-place using Cycle Sort algorithm. Parameters: arr (list): List of integers to be sorted Returns: list: The same list sorted in ascending order n = len(arr) # Traverse the array elements and put them to the right place for start in range(0, n - 1): item = arr[start] # Find where to put the item pos = start for i in range(start + 1, n): if arr[i] < item: pos += 1 # If the item is already in the correct position if pos == start: continue # Avoid duplicates while item == arr[pos]: pos += 1 # Place the item at its correct position if pos != start: arr[pos], item = item, arr[pos] # Rotate rest of the cycle while pos != start: pos = start for i in range(start + 1, n): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 if item != arr[pos]: arr[pos], item = item, arr[pos] return arr"},{"question":"# Matrix Multiplication Challenge Background: Matrix multiplication is a fundamental operation in many scientific and engineering applications. Given two compatible matrices, your task is to implement a function that computes their product. Task: You need to write a function `multiply(multiplicand: list, multiplier: list) -> list` that multiplies two matrices and returns the resulting matrix. Inputs: 1. **multiplicand**: A list of lists of integers representing the first matrix. It will have `m` rows and `n` columns. 2. **multiplier**: A list of lists of integers representing the second matrix. It will have `n` rows and `p` columns. Output: - A list of lists of integers representing the resulting matrix of dimensions `m x p`. Constraints: - The matrices will only contain integers. - The dimensions will always be such that multiplication is possible (i.e., the number of columns of the first matrix will equal the number of rows of the second matrix). - You should handle cases where either of the matrices is empty by returning an empty matrix. Performance Requirements: - Aim for a straightforward implementation with time complexity O(m * n * p). Example: ```python # Example matrices multiplicand = [[1, 2, 3], [4, 5, 6]] multiplier = [[7, 8], [9, 10], [11, 12]] # Resultant matrix result = multiply(multiplicand, multiplier) print(result) # Output: [[58, 64], [139, 154]] ``` Notes: 1. You may assume the input matrices are always valid for multiplication with the constraints provided. 2. Ensure your code efficiently handles large matrices without running into performance bottlenecks.","solution":"def multiply(multiplicand, multiplier): Multiplies two matrices and returns the resulting matrix. multiplicand: m x n matrix multiplier: n x p matrix returns: m x p matrix (result of multiplying multiplicand by multiplier) if not multiplicand or not multiplier: return [] m = len(multiplicand) n = len(multiplicand[0]) p = len(multiplier[0]) # Initialize the result matrix with zeros result = [[0 for _ in range(p)] for _ in range(m)] # Perform the matrix multiplication for i in range(m): for j in range(p): for k in range(n): result[i][j] += multiplicand[i][k] * multiplier[k][j] return result"},{"question":"Scenario Imagine you are tasked with improving the performance of a legacy system that processes various flags stored in integers. You need to implement a function that efficiently removes a specific bit from a given integer. This function must handle bits and their manipulation accurately and efficiently. Function Specification Write a function `remove_bit(num, i)` that removes the bit at position `i` from the integer `num` and returns the resulting integer. The least significant bit (LSB) is considered to be at position `0`. Input - `num`: An integer representing the binary number from which a bit needs to be removed. - `i`: An integer representing the index of the bit to be removed (0-based). Output - Returns the resulting integer after the specified bit has been removed. Constraints - Assume `num` is a non-negative integer. - `i` will be a valid index within the number of bits in `num`. - Minimize the use of loops to achieve an optimal solution. Examples 1. `remove_bit(21, 2)` -> 9 - Binary: `21` is `10101`. - Removing bit at index `2` (counting from 0): `10101` -> `1001`, which is `9` in decimal. 2. `remove_bit(21, 4)` -> 5 - Binary: `10101`. - Removing bit at index `4`: `101` -> `5`. 3. `remove_bit(21, 0)` -> 10 - Binary: `10101`. - Removing bit at index `0`: `1010` -> `10`. Your function should be efficient and handle removing the bit from any valid position correctly. Notes - Pay attention to edge cases, such as removing bits at the boundaries (`0` or highest index). - Ensure the function remains efficient with minimal overhead by leveraging bitwise operations.","solution":"def remove_bit(num, i): Remove the bit at position i from the integer num and return the resulting integer. Args: num (int): The input number. i (int): The index of the bit to be removed. Returns: int: The resulting integer after the specified bit has been removed. # Convert number to a list of binary characters, keeping it as string representation for easy manipulation bin_str = list(bin(num)[2:]) # The position from the end of the binary string pos_from_right = len(bin_str) - 1 - i # Remove the bit at the specified position del bin_str[pos_from_right] # Convert the modified list back to an integer result = int(\'\'.join(bin_str), 2) if bin_str else 0 return result"},{"question":"# Problem Description You are tasked with implementing a function that performs a linear search on a list of integers. Given a list of integers and another integer as the query, your function should return the index of the first occurrence of the query in the list. If the query is not found, the function should return -1. Your implementation should account for various edge cases to ensure correctness. # Function Signature ```python def find_element_index(array: List[int], query: int) -> int: pass ``` # Input * `array`: List of integers. (1 <= len(array) <= 10^5) * `query`: Integer value to search for in the array. # Output * Return an integer representing the index of the first occurrence of the query in the array. If the query is not found, return -1. # Constraints * Elements in the array can be negative or positive integers. * There is no guarantee of ordering in the array. # Example ```python array = [2, 3, 5, 7, 11, 13, 17, 19] query = 7 find_element_index(array, query) # Output should be 3 array = [5, 4, 3, 2, 1] query = 6 find_element_index(array, query) # Output should be -1 array = [1, 2, 3, 4, 5, 3, 2, 1] query = 3 find_element_index(array, query) # Output should be 2 ``` # Requirements Your solution should be efficient and able to handle the upper constraint limits effectively.","solution":"from typing import List def find_element_index(array: List[int], query: int) -> int: Performs a linear search to find the index of the first occurrence of the query in the array. Returns -1 if the query is not found. Args: array (List[int]): The list of integers to search in. query (int): The integer value to search for. Returns: int: The index of the first occurrence of the query in the array, or -1 if not found. for idx, element in enumerate(array): if element == query: return idx return -1"},{"question":"Coding Assessment Question # Scenario You work for an e-commerce company that frequently sorts product ratings to display them in order of popularity. Your team primarily deals with ratings that range from 0 to 100 (integers, due to upvotes). Given the efficiency needs, you\'ve decided to use the Counting Sort algorithm to sort these ratings. However, the current implementation does not handle some particular edge cases involving negative ratings in customer feedback due to recent changes. # Objective Implement a robust version of Counting Sort that: 1. Can handle arrays with negative integer ratings. 2. Efficiently sorts the array in ascending order. # Function Signature ```python def counting_sort_with_negatives(arr: List[int]) -> List[int]: pass ``` # Input - An integer array `arr` which may contain both positive and negative integers. - Elements of `arr` will be in the range [−1000, 1000]. - Length of `arr` will be between 0 and 10^6. # Output - An integer array, `arr` sorted in ascending order. # Constraints - Your solution should handle negative values correctly. - Your solution should handle the case where arr is an empty array without any errors. - Optimize the solution to perform efficiently with the provided constraints. # Example ```python assert counting_sort_with_negatives([3, -2, -1, 0, 2, 1, 3]) == [-2, -1, 0, 1, 2, 3, 3] assert counting_sort_with_negatives([]) == [] ``` # Notes - Consider all possible edge cases, such as an array with all identical elements, arrays containing the maximum or minimum possible values, and arrays with lengths at the constraints\' limits. - Make sure your solution is thoroughly tested to handle the full range of inputs specified.","solution":"from typing import List def counting_sort_with_negatives(arr: List[int]) -> List[int]: if not arr: return [] # Find the minimum and maximum value in the array min_val = min(arr) max_val = max(arr) # Create count array range_size = max_val - min_val + 1 count = [0] * range_size # Store the count of each element in the array for num in arr: count[num - min_val] += 1 # Modify the count array to store the cumulative count for i in range(1, range_size): count[i] += count[i - 1] # Create output array output = [0] * len(arr) # Build the output array using the count array for num in reversed(arr): output[count[num - min_val] - 1] = num count[num - min_val] -= 1 return output"},{"question":"Scenario You are hired as a software engineer at a company that specializes in optimizing digital signal processing algorithms. As part of their toolbox, they need a helper function to check if certain buffer sizes are powers of two, which is a common requirement for efficient memory usage. Problem Statement Write a function `is_power_of_two(n)` that takes a single integer as input and returns a boolean indicating whether the given integer is a power of two. Function Signature ```python def is_power_of_two(n: int) -> bool: ``` Input * A single integer `n` where ( -2^{31} leq n leq 2^{31} - 1 ). Output * Return `True` if `n` is a power of two, otherwise return `False`. Constraints * The function should handle any integer input within the provided range. * Performance should be optimal with constant time complexity. Examples ```python assert is_power_of_two(1) == True # 2^0 = 1 assert is_power_of_two(16) == True # 2^4 = 16 assert is_power_of_two(218) == False # Not a power of two assert is_power_of_two(-8) == False # Negative numbers are not considered power of two assert is_power_of_two(0) == False # Zero is not a power of two ``` Notes * You need to ensure that the provided integer is handled correctly for both positive and negative values. * Consider bitwise operations for optimal performance.","solution":"def is_power_of_two(n: int) -> bool: Returns True if n is a power of two, otherwise returns False. A number is a power of two if it has exactly one \'1\' bit in its binary representation. This function uses a bitwise trick: n > 0 and (n & (n - 1)) == 0 return n > 0 and (n & (n - 1)) == 0"},{"question":"# Scenario: You are building an application that requires maintaining a dynamic set of unique integers and frequently retrieving random elements from it. To ensure the efficiency of both insertion, deletion, and random access, you\'ll implement a `RandomizedSet` data structure. # Task: Implement the `RandomizedSet` class with the following methods: 1. `insert(val: int) -> bool`: Inserts a value into the set. Returns `True` if the value was successfully inserted (i.e., not already present). Returns `False` otherwise. 2. `remove(val: int) -> bool`: Removes a value from the set. Returns `True` if the value was successfully removed (i.e., was present). Returns `False` otherwise. 3. `get_random() -> int`: Returns a random element from the set. Each element must have the same probability of being returned. # Example: ```python rs = RandomizedSet() print(rs.insert(1)) # Returns: True print(rs.insert(2)) # Returns: True print(rs.insert(3)) # Returns: True print(rs.insert(3)) # Returns: False print(rs.remove(2)) # Returns: True print(rs.remove(2)) # Returns: False print(rs.get_random()) # Returns one of the elements randomly from {1, 3} print(rs.insert(4)) # Returns: True print(rs.get_random()) # Returns one of the elements randomly from {1, 3, 4} ``` # Constraints: * All operations should handle edge cases elegantly. * Operations should perform on average O(1) time complexity. * Assume that all integers handled by the set will be in a reasonable range. Ensure your code is efficient, properly handles different scenarios, and is well-documented.","solution":"import random class RandomizedSet: def __init__(self): self.value_to_index = {} self.values_list = [] def insert(self, val: int) -> bool: if val in self.value_to_index: return False self.value_to_index[val] = len(self.values_list) self.values_list.append(val) return True def remove(self, val: int) -> bool: if val not in self.value_to_index: return False index = self.value_to_index[val] last_val = self.values_list[-1] self.values_list[index] = last_val self.value_to_index[last_val] = index self.values_list.pop() del self.value_to_index[val] return True def get_random(self) -> int: return random.choice(self.values_list)"},{"question":"# Interval Overlap Check and Merge In computer science and mathematics, intervals are a fundamental concept. An interval is a set of real numbers that includes all numbers between any two numbers in the interval. You are given an `Interval` class with some predefined functionalities such as checking for membership, equality, converting into list format, and merging intervals. Task Your task is to implement two functions: 1. `overlap_exists(intervals)` - A function to determine if any two intervals in a list overlap. 2. `merge_all_intervals(intervals)` - A function to merge all overlapping intervals and return a new list of merged intervals. Detailed Requirements 1. **Function: `overlap_exists(intervals)`** - **Input**: A list of `Interval` objects. - **Output**: A boolean value (`True` or `False`) indicating whether any two intervals overlap. 2. **Function: `merge_all_intervals(intervals)`** - **Input**: A list of `Interval` objects. - **Output**: A new list of `Interval` objects, where all overlapping intervals have been merged. Examples ```python # Example usage intervals = [Interval(1, 3), Interval(2, 6), Interval(8, 10), Interval(15, 18)] # Check for overlap print(overlap_exists(intervals)) # Output: True # Merge intervals merged_intervals = merge_all_intervals(intervals) Interval.print_intervals(merged_intervals) # Output: Interval (1, 6)Interval (8, 10)Interval (15, 18) ``` Constraints - The intervals list will contain at least one interval, and the `start` will always be less than or equal to the `end`. - The intervals could contain negative numbers. Notes - Utilize the provided `Interval` class and methods effectively to simplify your implementation. - Ensure efficient performance to handle larger lists of intervals.","solution":"class Interval: def __init__(self, start, end): self.start = start self.end = end def __repr__(self): return f\\"Interval({self.start}, {self.end})\\" def to_list(self): return [self.start, self.end] def overlaps_with(self, other): return self.start <= other.end and other.start <= self.end @staticmethod def merge(interval1, interval2): return Interval(min(interval1.start, interval2.start), max(interval1.end, interval2.end)) def overlap_exists(intervals): Check if any two intervals in the list overlap. intervals.sort(key=lambda x: x.start) for i in range(len(intervals) - 1): if intervals[i].overlaps_with(intervals[i + 1]): return True return False def merge_all_intervals(intervals): Merge all overlapping intervals in the list. if not intervals: return [] intervals.sort(key=lambda x: x.start) merged_intervals = [intervals[0]] for current in intervals[1:]: last_merged = merged_intervals[-1] if last_merged.overlaps_with(current): merged_intervals[-1] = Interval.merge(last_merged, current) else: merged_intervals.append(current) return merged_intervals"},{"question":"**Unique File Sort** **Scenario**: You are part of a software development team that handles the storage of numerous files with varying sizes. Your task is to create an efficient sorting algorithm to sort these files by their sizes. Instead of simple sorting, you will use heap sort. **Problem Statement**: Implement a function `unique_file_sort` that sorts an array of file sizes (integers) in descending order using an in-place Max-Heap Sort. Ensure that the array maintains the heap property after each insertion and deletion. # Function Signature ```python def unique_file_sort(arr: List[int]) -> List[int]: Sort an array of file sizes in descending order using max-heap sort. :param arr: List[int] - Array of file sizes. :return: List[int] - Sorted array in descending order. ``` **Input**: - A list of integers, `arr`, representing file sizes. **Output**: - A sorted list of integers in descending order. **Constraints**: - The list can contain up to 10,000 integers. - Each integer can range from 1 to 1,000,000. **Performance Requirements**: - The implementation must sort the list in O(n log(n)) time complexity. - Use O(1) space complexity beyond the input list. ****Example****: ```python # Example 1: input = [9, 4, 7, 1, -2, 6, 5] output = [9, 7, 6, 5, 4, 1, -2] # Example 2: input = [] output = [] # Example 3: input = [1, 1, 1, 1, 1] output = [1, 1, 1, 1, 1] ``` **Notes**: 1. Implement and ensure correct max-heap maintenance with heapify operations both during heap creation and sorting. 2. Provide a working implementation and justify the complexities achieved.","solution":"from typing import List def heapify(arr: List[int], n: int, i: int): \'\'\' To maintain the heap property of a max-heap \'\'\' largest = i # Initialize largest as root left = 2 * i + 1 # left = 2*i + 1 right = 2 * i + 2 # right = 2*i + 2 # See if left child of root exists and is greater than root if left < n and arr[i] < arr[left]: largest = left # See if right child of root exists and is greater than root if right < n and arr[largest] < arr[right]: largest = right # Change root, if needed if largest != i: arr[i], arr[largest] = arr[largest], arr[i] # swap # Heapify the root heapify(arr, n, largest) def unique_file_sort(arr: List[int]) -> List[int]: \'\'\' Performs heap sort to sort the array in descending order \'\'\' n = len(arr) # Build a maxheap. for i in range(n // 2 - 1, -1, -1): heapify(arr, n, i) # One by one extract elements for i in range(n - 1, 0, -1): arr[i], arr[0] = arr[0], arr[i] # swap heapify(arr, i, 0) # Since we need descending order, we just reverse the array arr.reverse() return arr"},{"question":"Next Higher Permutation **Context**: You are given a number as an input, and your task is to find the next higher number that can be formed using the same digits. If no such number exists, return -1. **Task**: Implement the function `next_bigger(num: int) -> int` which takes an integer number as input and returns the next higher number formed by the same set of digits of the original number. If no such number exists, return `-1`. ```python def next_bigger(num: int) -> int: # Your implementation here ``` **Input Format**: - An integer `num` with 1 ≤ number of digits ≤ 10^9. **Output Format**: - Return the next higher number with the same digits or -1 if not possible. **Constraints**: - The input number will always be a positive integer. - You are not allowed to use any in-built functions that generate permutations. **Examples**: ```python assert next_bigger(38276) == 38627 assert next_bigger(12345) == 12354 assert next_bigger(1528452) == 1528524 assert next_bigger(138654) == 143568 assert next_bigger(54321) == -1 assert next_bigger(999) == -1 assert next_bigger(5) == -1 ``` **Edge Cases**: 1. All digits are in descending order (e.g., 54321): should return -1. 2. All the digits are the same (e.g., 999): should return -1. 3. Single digit input (e.g., 5): should return -1. **Performance Considerations**: Your solution should be efficient in terms of both time and space complexity and be able to handle the largest possible value of input adhering to the constraints.","solution":"def next_bigger(num: int) -> int: digits = list(str(num)) length = len(digits) # Traverse the number in reverse to find the first digit that is smaller than the digit next to it for i in range(length - 2, -1, -1): if digits[i] < digits[i + 1]: break else: # If no such digit is found, that means the digits are sorted in descending order return -1 # Find the smallest digit on the right side of the \'breaking\' digit and greater than it for j in range(length - 1, i, -1): if digits[j] > digits[i]: break # Swap the \'breaking\' digit with the smallest digit found digits[i], digits[j] = digits[j], digits[i] # Sort the digits after the \'breaking\' digit to get the smallest possible number digits = digits[:i + 1] + sorted(digits[i + 1:]) return int(\\"\\".join(digits))"},{"question":"Title: **Efficient Insert Position Finder in Sorted Arrays** Objective: Using the provided function `search_insert(array, val)`, determine the index where a new value should be inserted in a sorted array to maintain the sorted order and extend it to handle multiple insertion queries efficiently. Function Signature: ```python def find_insert_positions(array, values): Given a sorted array and a list of values, determine the index for each value where it should be inserted to maintain the sorted order of the array. Return a list of indices corresponding to the insertion points of each value. :param array: List[int] - A sorted list of integers. :param values: List[int] - A list of integers to find the insertion indexes for. :return: List[int] - A list of indices where each integer from \\"values\\" would be inserted. Example: >>> find_insert_positions([1, 3, 5, 6], [5, 2, 7, 0]) [2, 1, 4, 0] pass ``` Input & Output: - **Input**: - A sorted list of integers `array` (0 <= len(array) <= 10^5) - A list of integers `values` that need to find their insertion points (0 <= len(values) <= 10^5) - **Output**: - A list of integers representing the insertion indices for each value in the `values` list. Constraints: - The input `array` is guaranteed to be sorted in ascending order. - No constraints on the elements within `array` or `values`. Performance Requirements: - Your implementation should be efficient, ideally (O(n log m)), where (n) is the length of `values` and (m) is the length of `array`. Example: ```python find_insert_positions([1, 3, 5, 6], [5, 2, 7, 0]) # Output: [2, 1, 4, 0] ``` Notes: - You should make use of the `search_insert` function within your implementation. - Think about the edge cases, including empty `array` or `values`.","solution":"from bisect import bisect_left def find_insert_positions(array, values): Given a sorted array and a list of values, determine the index for each value where it should be inserted to maintain the sorted order of the array. Return a list of indices corresponding to the insertion points of each value. :param array: List[int] - A sorted list of integers. :param values: List[int] - A list of integers to find the insertion indexes for. :return: List[int] - A list of indices where each integer from \\"values\\" would be inserted. Example: >>> find_insert_positions([1, 3, 5, 6], [5, 2, 7, 0]) [2, 1, 4, 0] return [bisect_left(array, value) for value in values]"},{"question":"<|Analysis Begin|> **Algorithm/Data Structure**: Two-pointer string manipulation algorithm. * **Type**: In-place modification using two-pointer technique. * **Purpose**: To reverse the order of vowels in a given string while keeping the other characters in their original positions. **Complexity**: * **Time Complexity**: O(n), where n is the length of the string. Each character is processed at most once. * **Space Complexity**: O(n), due to converting the string to a list (additional space is required). **Principles**: 1. Convert the string into a list of characters for in-place modifications. 2. Initialize two pointers, `i` starting from the beginning and `j` from the end. 3. Move `i` forward until it points to a vowel. 4. Move `j` backward until it points to a vowel. 5. Swap the vowels at positions `i` and `j`. 6. Continue the process until `i` is not less than `j`. **Properties**: * Only vowels are reversed, other characters remain in their initial positions. * Vowels are swapped in O(1) space complexity per swap. **Common Use Cases**: * Anagrams or scrambled text manipulation where vowel positioning is of interest. * Implementing certain game mechanics or text puzzles. **Strengths/Limitations**: * **Strengths**: Efficient in terms of time complexity, straightforward implementation using two pointers. * **Limitations**: Extra space for list conversion. It may be inefficient for extremely large strings where space overhead is critical. **Implementation Challenges**: * **Edge Cases**: - Strings with no vowels. - Strings with all vowels. - Mixed case characters. - Empty strings. * **Performance Bottlenecks**: Minimal, but list conversion can be a bottleneck for very large strings. * **Error Scenarios**: - Handling case sensitivity properly. - Avoiding out-of-bounds errors when moving pointers. * **Optimization Points**: Could be optimized further by working directly with string indices, though it will be less Pythonic and might complicate the code. <|Analysis End|> <|Question Begin|> # Question: You are tasked with writing a function that reverses the vowels in a given string. The other characters should remain in their original positions. The function `reverse_vowel(s)` should take: * A string `s` which consists of English alphabet characters and possibly other symbols. The function should return a new string with the vowels reversed. Input: - A string `s` containing at least 0 and at most 1000 characters. Output: - A string with reversed vowels. # Constraints: 1. The vowels are `A, E, I, O, U, a, e, i, o, u`. 2. Consider vowels case insensitively. # Example: Example 1: ```python Input: \\"hello\\" Output: \\"holle\\" ``` Example 2: ```python Input: \\"programming\\" Output: \\"prigrammong\\" ``` Example 3: ```python Input: \\"Python\\" Output: \\"Python\\" ``` # Implementation: Implement the function `reverse_vowel(s)` using the two-pointer approach and aim for optimal performance regarding time and space complexities.","solution":"def reverse_vowel(s): Reverses the vowels in a given string `s` while keeping other characters in their original positions. vowels = \\"AEIOUaeiou\\" s_list = list(s) i, j = 0, len(s) - 1 while i < j: if s_list[i] in vowels and s_list[j] in vowels: s_list[i], s_list[j] = s_list[j], s_list[i] i += 1 j -= 1 elif s_list[i] in vowels: j -= 1 elif s_list[j] in vowels: i += 1 else: i += 1 j -= 1 return \'\'.join(s_list)"},{"question":"**Objective**: Given the specific requirement to reverse a string, implement a function using the principles of string manipulation. Your solution should also address edge cases and aim for optimal performance. **Problem Statement**: ```markdown Develop a function `reverse_string(s: str) -> str` that takes a string `s` and returns the string reversed. Your implementation should preferably be iterative to optimize for performance while being mindful of memory usage. Additionally, ensure that your function handles edge cases such as empty strings and single-character strings correctly. **Constraints**: 1. The length of the string will not exceed 10^6 to ensure scalability. 2. The input string will only contain printable ASCII characters. **Function Signature**: ```python def reverse_string(s: str) -> str: ``` **Example**: ```python # Example 1 input: s = \\"hello\\" output: \\"olleh\\" # Example 2 input: s = \\"abcd\\" output: \\"dcba\\" # Example 3 input: s = \\"\\" output: \\"\\" # Example 4 input: s = \\"a\\" output: \\"a\\" ``` **Performance Requirements**: - Time Complexity: O(n), where n is the length of the string. - Space Complexity: O(n). **Additional Considerations**: - Aim for an implementation that is not only efficient but also clear and readable. - Avoid using overly complex methods that increase the overhead.","solution":"def reverse_string(s: str) -> str: Returns the reversed string of the input string s. return s[::-1]"},{"question":"Given a number, write a function `next_bigger(num: int) -> int` to find the next higher number using the exact same set of digits as the original number. If no such number exists, return -1. Input - A single integer `num` where `1 <= num <= 10^9`. Output - An integer representing the next higher number using the same set of digits as the original number, or -1 if no such number exists. # Example 1 ```python next_bigger(38276) ``` **Output**: `38627` # Example 2 ```python next_bigger(99999) ``` **Output**: `-1` # Constraints - The function should handle edge cases such as numbers with all digits the same or digits in descending order. - The expected time complexity is O(n) where n is the number of digits in the number. - The number will always be a positive integer within the given range. # Notes - Implementing the function efficiently is crucial due to the limitations on the input size. - Ensure your implementation is well-tested to handle various edge cases and common scenarios as discussed.","solution":"def next_bigger(num: int) -> int: Returns the next higher number using the exact same set of digits as the original number. If no such number exists, return -1. num_str = list(str(num)) length = len(num_str) # Start from the end of the number for i in range(length - 2, -1, -1): if num_str[i] < num_str[i + 1]: break else: return -1 # no greater number can be formed # Find the smallest digit on the right side of (i) which is larger than num_str[i] for j in range(length - 1, i, -1): if num_str[j] > num_str[i]: num_str[i], num_str[j] = num_str[j], num_str[i] break # the digits after (i) must be reversed to get the next smallest number num_str = num_str[:i + 1] + sorted(num_str[i + 1:]) return int(\\"\\".join(num_str))"},{"question":"Given an array of integers, implement a data structure that supports the following operations efficiently: 1. **Update**: Update the value of an element in the array. 2. **Prefix Sum**: Calculate the sum of the elements from the beginning of the array to a given index. You need to implement a Fenwick Tree to handle these operations in logarithmic time. # Function Signatures Implement the following functions: 1. `def update(bit_tree: List[int], i: int, val: int) -> None:` Updates the Fenwick Tree with a new value at index `i`. 2. `def get_sum(bit_tree: List[int], i: int) -> int:` Returns the sum of the elements from the start of the array to index `i`. 3. `def construct(arr: List[int]) -> List[int]:` Given an array, constructs and returns the Fenwick Tree. # Input * `arr`: A list of integers, representing the initial array. * `i`: An integer, index to be updated or queried. * `val`: An integer, new value for the update operation. # Output 1. `update` function: No return value, but updates the `bit_tree`. 2. `get_sum` function: Returns an integer, the prefix sum from the start to the given index. 3. `construct` function: Returns a list of integers representing the Fenwick Tree. # Constraints * `0 <= i < len(arr)` * `-10^4 <= arr[i], val <= 10^4` * The array will have at most `10^5` elements. # Example ```python arr = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3] bit_tree = construct(arr) # Query the prefix sum of the first 5 elements print(get_sum(bit_tree, 4)) # Output: 15 # Update the 3rd element to 10 update(bit_tree, 2, 10) # Query the prefix sum again print(get_sum(bit_tree, 4)) # Output: 26 ```","solution":"from typing import List def update(bit_tree: List[int], n: int, i: int, val: int) -> None: Updates the Fenwick Tree by adding `val` at index `i`. i += 1 # Fenwick Tree is 1-indexed internally while i <= n: bit_tree[i] += val i += i & -i def get_sum(bit_tree: List[int], i: int) -> int: Returns the prefix sum from the start of the array to index `i`. prefix_sum = 0 i += 1 # Fenwick Tree is 1-indexed internally while i > 0: prefix_sum += bit_tree[i] i -= i & -i return prefix_sum def construct(arr: List[int]) -> List[int]: Given an array, constructs and returns the Fenwick Tree. n = len(arr) bit_tree = [0] * (n + 1) for i in range(n): update(bit_tree, n, i, arr[i]) return bit_tree"},{"question":"**Scenario**: You are working with a large dataset of integers for a data processing task. Your dataset contains a list where every number appears exactly twice, except for one unique number that appears only once. Your goal is to identify this unique number. The solution you implement needs to be efficient both in terms of time and space. **Coding Task**: Write a function `find_unique_number(nums)` that takes a list of integers `nums` (non-empty), where each integer appears exactly twice except for one integer that appears only once. Your task is to find and return the integer that appears only once. # Input: * A list of integers `nums` where `1 <= len(nums) <= 10^5`. * Each integer in `nums` will appear exactly twice, except one integer which will appear only once. * The integers can range between `-10^6` and `10^6`. # Output: * Return the single integer that appears only once in the list. # Constraints: * Your algorithm should have a linear runtime complexity O(n). * You should implement this without using extra memory. # Example: ```python def find_unique_number(nums): Returns single number that appears only once. :type nums: List[int] :rtype: int i = 0 for num in nums: i ^= num return i # Example run nums = [4, 1, 2, 1, 2] print(find_unique_number(nums)) # Output: 4 ``` **Explanation**: In the given list, every number except for ‘4’ appears twice. By XOR-ing all the numbers together, pairs of identical numbers cancel each other out, leaving the unique number.","solution":"def find_unique_number(nums): Returns the single number that appears only once in the list. :type nums: List[int] :rtype: int unique_number = 0 for num in nums: unique_number ^= num return unique_number"},{"question":"# Question You are given an unweighted undirected graph represented as an adjacency list. An adjacency list is a dictionary where the key is a node and the value is a list of nodes that are directly connected to it. Your task is to implement a function that identifies all connected components in the graph. Each connected component should be returned as a list of nodes. The overall result should be a list of these lists. # Implementation Write a function `find_connected_components(graph: Dict[int, List[int]]) -> List[List[int]]` that finds and returns all connected components in the given graph. # Input * An adjacency list representation of an undirected graph: ```python { 0: [1, 2], 1: [0, 3], 2: [0], 3: [1], 4: [5], 5: [4] } ``` # Output * A list of lists, where each list contains all the nodes in one connected component: ```python [ [0, 1, 2, 3], [4, 5] ] ``` # Constraints * The graph is undirected and unweighted. * The graph may contain disconnected components. * Nodes are represented as non-negative integers. * The adjacency list might not explicitly list all nodes, i.e., isolated nodes might be missing from the keys. # Performance Requirements * Your solution should efficiently handle graphs with up to 1,000,000 nodes and edges. # Example ```python # Example graph graph = { 0: [1, 2], 1: [0, 3], 2: [0], 3: [1], 4: [5], 5: [4] } # Expected output: [[0, 1, 2, 3], [4, 5]] or [[4, 5], [0, 1, 2, 3]] in any order. def find_connected_components(graph): # Your implementation here ```","solution":"def find_connected_components(graph): def dfs(node, visited, component): stack = [node] while stack: current = stack.pop() if current not in visited: visited.add(current) component.append(current) stack.extend(graph.get(current, [])) visited = set() components = [] for node in graph.keys(): if node not in visited: component = [] dfs(node, visited, component) components.append(component) # Handle isolated nodes (nodes with no edges that might not be listed in adj list) nodes_with_edges = set(graph.keys()) all_nodes = nodes_with_edges.union(set(n for neighs in graph.values() for n in neighs)) isolated_nodes = all_nodes - visited for isolated_node in isolated_nodes: components.append([isolated_node]) return components"},{"question":"# Question: Calculate Combination (nCr) using Dynamic Programming **Context**: Suppose you are working on a combinatorial mathematics software that requires numerous calculations of combinations or \\"n choose r\\" operations. Your current recursive approach is too slow for large inputs, so you need to optimize it. **Task**: Write a Python function `combination_dp(n: int, r: int) -> int` that calculates the number of ways to choose `r` items from `n` items using a dynamic programming approach. **Input**: * `n` (0 ≤ n ≤ 1000): An integer representing the total items. * `r` (0 ≤ r ≤ n): An integer representing the number of items to choose. **Output**: * Return the computed value of nCr as an integer. **Constraints**: * Your implementation should optimize the calculation to avoid redundant computations. * Aim to achieve time complexity of O(n * r) and space complexity of O(n * r). **Example**: ```python print(combination_dp(5, 2)) # Output: 10 print(combination_dp(10, 5)) # Output: 252 print(combination_dp(52, 5)) # Output: 2598960 ``` **Edge Cases**: * Inputs where r = 0 or r = n should return 1. * Inputs where r > n should return 0. Make sure to handle edge cases and optimize the solution for performance.","solution":"def combination_dp(n, r): Calculate the number of ways to choose r items from n items using dynamic programming. Parameters: n (int): Total items. r (int): Number of items to choose. Returns: int: Computed value of nCr. if r > n: return 0 if r == 0 or r == n: return 1 # Initialize a 2D array to store the results of subproblems dp = [[0 for _ in range(r + 1)] for _ in range(n + 1)] # Calculate C(n, r) using bottom-up dynamic programming approach for i in range(n + 1): for j in range(min(i, r) + 1): if j == 0 or j == i: dp[i][j] = 1 else: dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j] return dp[n][r]"},{"question":"# Objective You are hired by a neighborhood security consultant to develop a software tool that helps thieves plan the optimal way to rob houses along a street so as not to trigger the security systems. Your task is to implement a function that determines how much money can be robbed without robbing two adjacent houses. # Function Signature ```python def house_robber(houses: List[int]) -> int: ``` # Input * A list of non-negative integers `houses` where each integer represents the amount of money in each house. The list has at most 10000 entries. # Output * A single integer representing the maximum amount of money that can be robbed without alerting the police. # Constraints * 0 <= len(houses) <= 10000 * 0 <= houses[i] <= 1000 # Requirements * Implement an efficient solution that runs in linear time O(n) with constant space O(1). * Correctly handle the edge cases such as empty list and single house. # Example ```python assert house_robber([2, 7, 9, 3, 1]) == 12 # Rob houses with 2, 9, and 1 assert house_robber([2, 1, 1, 2]) == 4 # Rob houses with 2 and 2, or 1, 1, and 2 assert house_robber([]) == 0 # No houses to rob assert house_robber([5]) == 5 # Only one house to rob assert house_robber([1, 2, 3, 1]) == 4 # Rob houses with 1 and 3 ``` Write your function in the box provided below. # Function Implementation ```python from typing import List def house_robber(houses: List[int]) -> int: last, now = 0, 0 for house in houses: last, now = now, max(last + house, now) return now ```","solution":"from typing import List def house_robber(houses: List[int]) -> int: Determines the maximum amount of money that can be robbed without alerting the police by not robbing two adjacent houses. :param houses: List of non-negative integers where each integer represents the amount of money in each house. :return: Maximum amount of money that can be robbed. if not houses: return 0 if len(houses) == 1: return houses[0] prev1, prev2 = 0, 0 for amount in houses: prev1, prev2 = prev2, max(prev2, prev1 + amount) return prev2"},{"question":"Integer Decomposition Problem Statement You are given a positive integer `n`. Your task is to write a function that computes the number of different ways to decompose `n` into sums of non-negative integers. Each decomposition should be considered unique if the order of addends is different. Function Signature ```python def integer_decomposition(n: int) -> int: pass ``` Input * `n` (1 <= n <= 100): A positive integer. Output * Returns an integer representing the number of unique decompositions of `n`. Example ```python # Example 1 n = 4 print(integer_decomposition(n)) # Output: 5 # Explanation: 4 can be decomposed as [4], [3,1], [2,2], [2,1,1], [1,1,1,1] # Example 2 n = 7 print(integer_decomposition(n)) # Output: 15 # Explanation: 7 can be decomposed in 15 ways as described earlier ``` Constraints * You need to ensure that the function handles the case where `n` is the smallest (e.g., 1). * Time complexity should be O(n^2) and space complexity should also be O(n^2). Approach 1. Initialize a 2D array `dp` of size (n+1) x (n+1) with zeros. 2. Populate the array using the dynamic programming approach as described. 3. Return the result stored in `dp[n][n]`.","solution":"def integer_decomposition(n: int) -> int: Returns the number of unique decompositions of the integer n into sums of non-negative integers. # Create a 2D array to store results of subproblems dp = [[0] * (n + 1) for _ in range(n + 1)] # Initialize the base case for i in range(n + 1): dp[i][0] = 1 # Fill the dp table using the dynamic programming approach for num in range(1, n + 1): for sum in range(n + 1): if sum >= num: dp[num][sum] = dp[num-1][sum] + dp[num][sum-num] else: dp[num][sum] = dp[num-1][sum] return dp[n][n]"},{"question":"Strongly Connected Directed Graph # Problem Statement You are given a directed graph that may have multiple vertices and edges. Your task is to determine if the graph is strongly connected. A graph is defined as strongly connected if there is a path between any pair of vertices in the graph. # Input - `vertex_count` (an integer): The number of vertices in the graph. - `edges` (a list of tuples): Each tuple represents a directed edge in the graph where the first element is the source vertex and the second element is the destination vertex. # Output - Returns a `boolean`: `True` if the graph is strongly connected, otherwise `False`. # Constraints * The number of vertices `1 <= vertex_count <= 1000` * The number of edges `0 <= number of edges <= 5000` * Each vertex identifier will be an integer within the range `[0, vertex_count - 1]` # Examples ```python # Example 1: # vertex_count: 5 # edges: [(0, 1), (1, 2), (2, 0), (0, 3), (3, 4), (4, 0)] # Output: True # Example 2: # vertex_count: 4 # edges: [(0, 1), (1, 2), (2, 3)] # Output: False ``` # Function Signature ```python def is_strongly_connected(vertex_count: int, edges: List[Tuple[int, int]]) -> bool: pass ``` # Guidelines: 1. Implement the `Graph` class similar to the one provided in the code snippet. 2. Utilize Depth-First Search (DFS) strategy to check if all nodes are connected starting from node 0. 3. Ensure to create and check the reversed graph to affirm strong connectivity. 4. Handle edge cases like empty graphs, disconnected nodes and subgraphs. Ensure your code is efficient and accounts for all possible scenarios based on the constraints mentioned above.","solution":"def is_strongly_connected(vertex_count, edges): from collections import defaultdict def dfs(graph, start_vertex): visited = [False] * vertex_count stack = [start_vertex] while stack: vertex = stack.pop() if not visited[vertex]: visited[vertex] = True for neighbor in graph[vertex]: if not visited[neighbor]: stack.append(neighbor) return visited if vertex_count == 0: return True graph = defaultdict(list) reverse_graph = defaultdict(list) for u, v in edges: graph[u].append(v) reverse_graph[v].append(u) visited_from_start = dfs(graph, 0) if not all(visited_from_start): return False visited_from_start_reverse = dfs(reverse_graph, 0) if not all(visited_from_start_reverse): return False return True"},{"question":"**Context**: You are working on a web application that frequently makes HTTP requests. However, it has come to your attention that some requests inappropriately carry duplicate query parameters or unnecessary parameters, causing redundant network traffic and potential issues with API rate limits or data integrity. **Task**: Write a Python function `clean_url` that takes a URL and an optional list of parameters to remove. The function should return the cleaned URL with: 1. Duplicate query parameters removed, keeping only the first occurrence. 2. Any specified parameters in the provided list omitted entirely. **Input**: * `url` (str): A URL string, potentially with query parameters. * `params_to_strip` (List[str], optional): A list of query parameter keys that should be removed from the URL. **Output**: * (str): The cleaned URL. **Constraints**: * The URL will be a valid URL containing query parameters. * Parameters are case-sensitive (`\\"a\\"` is different from `\\"A\\"`). **Example**: ```python # Example 1: # Input: \\"http://example.com?a=1&b=2&a=2\\", params_to_strip = [] # Output: \\"http://example.com?a=1&b=2\\" # Example 2: # Input: \\"http://example.com?a=1&b=2&c=3&d=4\\", params_to_strip = [\\"b\\", \\"d\\"] # Output: \\"http://example.com?a=1&c=3\\" # Example 3: # Input: \\"http://example.com?a=1&a=2&b=2\\", params_to_strip = [\\"a\\"] # Output: \\"http://example.com?b=2\\" ``` ```python def clean_url(url: str, params_to_strip: list = []) -> str: # Your implementation here pass # You can test your function with the provided examples: print(clean_url(\\"http://example.com?a=1&b=2&a=2\\")) # Should return \\"http://example.com?a=1&b=2\\" print(clean_url(\\"http://example.com?a=1&b=2&c=3&d=4\\", [\\"b\\", \\"d\\"])) # Should return \\"http://example.com?a=1&c=3\\" print(clean_url(\\"http://example.com?a=1&a=2&b=2\\", [\\"a\\"])) # Should return \\"http://example.com?b=2\\" ```","solution":"from urllib.parse import urlparse, parse_qsl, urlencode, urlunparse def clean_url(url: str, params_to_strip: list = []) -> str: parsed_url = urlparse(url) query_params = parse_qsl(parsed_url.query, keep_blank_values=True) seen_params = set() unique_params = [] for key, value in query_params: if key not in seen_params and key not in params_to_strip: seen_params.add(key) unique_params.append((key, value)) cleaned_query = urlencode(unique_params) cleaned_url = urlunparse(parsed_url._replace(query=cleaned_query)) return cleaned_url"},{"question":"You need to implement a function that multiplies two large non-negative integers represented as strings and returns the result as a string. # Function Signature ```python def multiply(num1: \\"str\\", num2: \\"str\\") -> \\"str\\": ``` # Input * `num1` (str): The first non-negative integer in string format. The length is less than 110 characters. * `num2` (str): The second non-negative integer in string format. The length is less than 110 characters. # Output * (str): The product of `num1` and `num2` in string format. # Constraints * Both `num1` and `num2` contain only digits 0-9. * Both `num1` and `num2` do not contain any leading zero, except for the number \\"0\\" itself. * You must not use any built-in BigInteger library or convert the inputs to integers directly. # Performance Requirements * Your solution must run within O(n * m) time complexity, where n is the length of `num1` and m is the length of `num2`. * Space complexity must be efficiently managed to handle intermediate results. # Example ```python print(multiply(\\"1\\", \\"23\\")) # Expected output: \\"23\\" print(multiply(\\"23\\", \\"23\\")) # Expected output: \\"529\\" print(multiply(\\"100\\", \\"23\\")) # Expected output: \\"2300\\" print(multiply(\\"100\\", \\"10000\\")) # Expected output: \\"1000000\\" ``` # Important Notes 1. Consider edge cases such as multiplying by zero and single-digit multiplications. 2. Think about how positional multiplication works and how to manage carry and place values. 3. Ensure that the final result correctly reflects all positional sums.","solution":"def multiply(num1: str, num2: str) -> str: if num1 == \\"0\\" or num2 == \\"0\\": return \\"0\\" len1, len2 = len(num1), len(num2) result = [0] * (len1 + len2) for i in range(len1 - 1, -1, -1): for j in range(len2 - 1, -1, -1): product = (ord(num1[i]) - ord(\'0\')) * (ord(num2[j]) - ord(\'0\')) pos1, pos2 = i + j, i + j + 1 sum_ = product + result[pos2] result[pos2] = sum_ % 10 result[pos1] += sum_ // 10 result_str = \'\'.join(map(str, result)) return result_str.lstrip(\'0\')"},{"question":"**Problem Statement:** You are given an array of numeric values and two optional limit values. Your task is to filter and return a list containing only the elements that fall within the specified range including the boundary values. If one of the limits is not provided, it should not restrict the filtering by that limit. If both limits are not provided, the resulting list should be a copy of the original array. **Function Signature:** ```python def filter_array(arr: List[int], min_lim: Optional[int] = None, max_lim: Optional[int] = None) -> List[int]: ``` **Input:** * `arr`: A list of integers. * `min_lim`: An optional integer that represents the inclusive lower boundary of the filter. * `max_lim`: An optional integer that represents the inclusive upper boundary of the filter. **Output:** * Returns a list of integers containing only those elements from `arr` that fall within the specified limits. **Examples:** ```python filter_array([1, 2, 3, 4, 5], None, 3) # Output: [1, 2, 3] filter_array([10, 5, 8, 20], 5, 15) # Output: [10, 5, 8] filter_array([12, 34, 56, 78], 10, 70) # Output: [12, 34, 56] filter_array([6, 7, 8, 9, 10], 7, 7) # Output: [7] filter_array([], 0, 100) # Output: [] ``` **Constraints:** 1. If the input array is empty, return an empty array. 2. If both `min_lim` and `max_lim` are `None`, return a copy of the original array. 3. Each element in the output list must maintain the relative order of elements as in the input array. **Notes:** 1. You can assume that if `min_lim` or `max_lim` are provided, they are valid integers. 2. The function should execute efficiently even for large arrays up to 10^6 elements.","solution":"from typing import List, Optional def filter_array(arr: List[int], min_lim: Optional[int] = None, max_lim: Optional[int] = None) -> List[int]: Filters and returns a list containing only the elements that fall within the specified range including the boundary values. if min_lim is None and max_lim is None: return arr.copy() return [x for x in arr if (min_lim is None or x >= min_lim) and (max_lim is None or x <= max_lim)]"},{"question":"# Ternary Search Algorithm Coding Exercise Objective: Implement a function in Python that applies the Ternary Search algorithm to find a specified key in a given sorted array. Problem Statement: You are given a sorted array `arr` of integers, and a specific key value `key`. Your task is to implement a function to efficiently find the index of the key in the array using the Ternary Search algorithm. Function Signature: ```python def find_key_with_ternary_search(arr, key) -> int: ``` Inputs: - `arr`: List of integers, sorted in ascending order. (0 leq text{len(arr)} leq 10^6) - `key`: Integer value to search for in `arr`. Outputs: - Returns the index (0-based) of the key in the array if it is found. - Returns -1 if the key is not found. Constraints: - You must use the Ternary Search Algorithm. - The solution should consider edge cases such as an empty array or single-element array. - Optimize for time complexity O(log_3(N)) and space complexity O(1). Example: ```plaintext Example 1: Input: arr = [1, 2, 3, 4, 5, 6, 7, 8, 9] key = 4 Output: 3 Example 2: Input: arr = [1, 2, 3, 4, 5, 6, 7, 8, 9] key = 10 Output: -1 ```","solution":"def find_key_with_ternary_search(arr, key): Uses the Ternary Search algorithm to find the index of the specified key in a sorted array. Parameters: arr (list): A sorted list of integers. key (int): The integer to search for. Returns: int: The index of the key if found, otherwise -1. def ternary_search(l, r, key): if r >= l: # Find the mid1 and mid2 mid1 = l + (r - l) // 3 mid2 = r - (r - l) // 3 # Check if key is at any mid if arr[mid1] == key: return mid1 if arr[mid2] == key: return mid2 # Since key is not present at mid, check in which region it is present if key < arr[mid1]: return ternary_search(l, mid1 - 1, key) elif key > arr[mid2]: return ternary_search(mid2 + 1, r, key) else: return ternary_search(mid1 + 1, mid2 - 1, key) # Key not found return -1 return ternary_search(0, len(arr) - 1, key)"},{"question":"Context: You are required to implement a min heap to manage a dynamic set of integers. The min heap should efficiently support insertions and deletions with the following interface operations: `insert` and `remove_min`. Your task is to provide implementations for these operations using a binary heap. Task: Implement the `insert` and `remove_min` functions of the `BinaryHeap` class. Class Definition: ```python class BinaryHeap(AbstractHeap): def __init__(self): self.current_size = 0 self.heap = [0] def perc_up(self, i): Helper method to move an element up in the heap. while i // 2 > 0: if self.heap[i] < self.heap[i // 2]: self.heap[i], self.heap[i // 2] = self.heap[i // 2], self.heap[i] i = i // 2 def insert(self, val): Insert `val` into the heap. - Add `val` to the end of the heap array. - Percolate up to restore heap order. Complexity: O(log N) pass # implement this function def min_child(self, i): Return the index of the smaller child of the node at index `i`. if 2 * i + 1 > self.current_size: return 2 * i if self.heap[2 * i] > self.heap[2 * i + 1]: return 2 * i + 1 return 2 * i def perc_down(self, i): Helper method to move an element down in the heap. while i * 2 <= self.current_size: mc = self.min_child(i) if self.heap[i] > self.heap[mc]: self.heap[i], self.heap[mc] = self.heap[mc], self.heap[i] i = mc def remove_min(self): Remove and return the smallest element in the heap. - Replace the root with the last element. - Percolate down to restore heap order. Complexity: O(log N) pass # implement this function ``` Constraints: 1. The heap should support a maximum of (10^5) elements. 2. Element values are integers in the range (-10^9) to (10^9). Input/Output: Input and output are implicit through the class methods, hence no specific input/output format is required. Ensure your methods handle the operations efficiently within the constraints mentioned. Example Usage: ```python heap = BinaryHeap() heap.insert(3) heap.insert(1) heap.insert(6) assert heap.remove_min() == 1 assert heap.remove_min() == 3 ```","solution":"class BinaryHeap: def __init__(self): self.current_size = 0 self.heap = [0] # We use a list initialized with a dummy element at index 0 def perc_up(self, i): Helper method to move an element up in the heap. while i // 2 > 0: if self.heap[i] < self.heap[i // 2]: self.heap[i], self.heap[i // 2] = self.heap[i // 2], self.heap[i] i = i // 2 def insert(self, val): Insert `val` into the heap. - Add `val` to the end of the heap array. - Percolate up to restore heap order. Complexity: O(log N) self.heap.append(val) self.current_size += 1 self.perc_up(self.current_size) def min_child(self, i): Return the index of the smaller child of the node at index `i`. if 2 * i + 1 > self.current_size: return 2 * i if self.heap[2 * i] > self.heap[2 * i + 1]: return 2 * i + 1 return 2 * i def perc_down(self, i): Helper method to move an element down in the heap. while i * 2 <= self.current_size: mc = self.min_child(i) if self.heap[i] > self.heap[mc]: self.heap[i], self.heap[mc] = self.heap[mc], self.heap[i] i = mc def remove_min(self): Remove and return the smallest element in the heap. - Replace the root with the last element. - Percolate down to restore heap order. Complexity: O(log N) if self.current_size == 0: return None # It\'s conventional to return None if the heap is empty root = self.heap[1] self.heap[1] = self.heap[self.current_size] self.current_size -= 1 self.heap.pop() self.perc_down(1) return root"},{"question":"Context You are working on a project that involves combinatorial calculations for large datasets. To optimize these calculations, you need to implement an efficient algorithm that can handle large values of n and r without running into performance issues. Task Write a Python function `compute_combinations` that calculates the number of ways to choose r items from n items (nCr) using an iterative dynamic programming approach to handle large inputs efficiently. Function Signature ```python def compute_combinations(n: int, r: int) -> int: ``` Input - `n`: Integer (0 ≤ n ≤ 10^3) - `r`: Integer (0 ≤ r ≤ n) Output - Return the number of ways to choose r items from n items. Constraints * Use O(n * r) time complexity. * Optimize for space and handle large values within the constraints (e.g., up to 1000). Requirements 1. Do not use recursion. 2. Use an iterative approach with a 2D table to store intermediate results. 3. Handle any invalid inputs (e.g., when r > n) by returning 0. Example ```python assert compute_combinations(5, 2) == 10 assert compute_combinations(10, 0) == 1 assert compute_combinations(15, 15) == 1 assert compute_combinations(10, 5) == 252 ``` Provide a well-commented implementation emphasizing clarity and efficiency.","solution":"def compute_combinations(n: int, r: int) -> int: Calculates the number of ways to choose r items from n items (nCr) using an iterative dynamic programming approach. if r > n: return 0 if r == 0 or r == n: return 1 # Create a table to store intermediate results, initialized to zero C = [[0 for _ in range(r + 1)] for _ in range(n + 1)] # Populate the table using the bottom-up approach for i in range(n + 1): for j in range(min(i, r) + 1): if j == 0 or j == i: C[i][j] = 1 else: C[i][j] = C[i-1][j-1] + C[i-1][j] return C[n][r]"},{"question":"Problem Statement You are given a `grid` representing a maze where `0` denotes a blocked cell and `1` denotes a free cell. You need to find the shortest path from the top-left cell (0, 0) to the bottom-right cell (n-1, m-1) using Breadth-First Search (BFS). The path can only move horizontally or vertically (not diagonally). Write a function `find_shortest_path(grid: List[List[int]]) -> int` that returns the minimum number of steps to reach the bottom-right cell from the top-left cell. If no such path exists, return `-1`. # Input - `grid`: A 2D list representing the maze. It has dimensions `n x m` and contains only `0` (blocked cell) or `1` (free cell). # Output - An integer representing the minimum number of steps required to move from the top-left cell to the bottom-right cell, or `-1` if no such path exists. # Constraints - The grid and each row in the grid will have at most 1000 elements. - The top-left cell and the bottom-right cell will be valid indices within the grid. # Performance Requirements - The solution should operate within time complexity (O(n times m)) and space complexity (O(n times m)) where `n` is the number of rows and `m` is the number of columns in the grid. # Example Example 1: ``` Input: grid = [ [1, 0, 1, 1, 1, 1], [1, 0, 1, 0, 1, 0], [1, 0, 1, 0, 1, 1], [1, 1, 1, 0, 1, 1]] Output: 14 ``` Example 2: ``` Input: grid = [ [1, 0, 0], [0, 1, 1], [0, 1, 1]] Output: -1 ``` # Notes - Ensure your function handles edge cases like starting or ending in a blocked cell. - Clearly comment on your code to demonstrate your thought process and methodology.","solution":"from typing import List from collections import deque def find_shortest_path(grid: List[List[int]]) -> int: Finds the shortest path in a grid from the top-left to the bottom-right cell. Returns the minimum number of steps required, or -1 if no path exists. if not grid or not grid[0] or grid[0][0] == 0 or grid[-1][-1] == 0: return -1 rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] visited = [[False] * cols for _ in range(rows)] queue = deque([(0, 0, 0)]) # (row, col, steps) visited[0][0] = True while queue: r, c, steps = queue.popleft() if r == rows - 1 and c == cols - 1: return steps for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 1 and not visited[nr][nc]: visited[nr][nc] = True queue.append((nr, nc, steps + 1)) return -1"},{"question":"# Coding Challenge: Binary Search Tree Implementation You are tasked with implementing a simple Binary Search Tree (BST) that supports insertion and searching functionalities. The class `TreeNode` is already defined with its structure. Requirements: 1. Implement a class `BinarySearchTree` with the following methods: - `insert(val: int) -> None`: Adds a value to the BST while maintaining the BST properties. - `search(val: int) -> bool`: Searches for a value in the BST, and returns `True` if it exists, `False` otherwise. Input/Output Format: 1. There are no input/output operations apart from the following methods. 2. The `insert` method does not return any value. 3. The `search` method returns a boolean indicating if the value exists in the BST. Example: ```python bst = BinarySearchTree() bst.insert(5) bst.insert(3) bst.insert(7) assert bst.search(3) == True # 3 is in the BST assert bst.search(8) == False # 8 is not in the BST ``` Constraints: - The values in the BST are unique and integers. - Assume all insertion and search operations are valid. Implement the class below: ```python class BinarySearchTree: def __init__(self): self.root = None def insert(self, val: int) -> None: # Your implementation here pass def search(self, val: int) -> bool: # Your implementation here pass ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BinarySearchTree: def __init__(self): self.root = None def insert(self, val: int) -> None: if self.root is None: self.root = TreeNode(val) else: self._insert_recursive(self.root, val) def _insert_recursive(self, node, val): if val < node.val: if node.left is None: node.left = TreeNode(val) else: self._insert_recursive(node.left, val) elif val > node.val: if node.right is None: node.right = TreeNode(val) else: self._insert_recursive(node.right, val) def search(self, val: int) -> bool: return self._search_recursive(self.root, val) def _search_recursive(self, node, val): if node is None: return False if val == node.val: return True elif val < node.val: return self._search_recursive(node.left, val) else: return self._search_recursive(node.right, val)"},{"question":"# Insertion Sort Helper Function Implementation Objective: Design a function that uses the given `search_insert` helper method to implement the Insertion Sort algorithm. Description: Write a Python function `insertion_sort(array)` that takes an array of integers and sorts it in ascending order using the Insertion Sort algorithm. Use the provided `search_insert` method to determine the correct position for inserting each element. Function Signature: ```python def insertion_sort(array): pass ``` Input: * `array` - A list of integers [a1, a2, ..., an], where 1 <= n <= 10^4 and -10^9 <= ai <= 10^9. Output: * Return the sorted list of integers in ascending order. Constraints: * The function must sort the array in-place and return it. Performance Requirements: * Expected performance should be analyzed considering O(n^2) complexity in the worst case scenario. Example: ```python # Example 1 input_array = [4, 3, 2, 1] sorted_array = insertion_sort(input_array) print(sorted_array) # Output: [1, 2, 3, 4] # Example 2 input_array = [1, 3, 2, 5, 6, 4] sorted_array = insertion_sort(input_array) print(sorted_array) # Output: [1, 2, 3, 4, 5, 6] ```","solution":"def search_insert(array, value, end): This function helps to find the position where the value should be inserted in the array[0:end] to maintain the sorted order. for i in range(end): if array[i] > value: return i return end def insertion_sort(array): Sorts an array of integers in ascending order using the Insertion Sort algorithm. Uses the search_insert helper method to find the correct insert position. n = len(array) for i in range(1, n): key = array[i] insert_position = search_insert(array, key, i) # Shift elements to the right to create the insert position for j in range(i, insert_position, -1): array[j] = array[j-1] array[insert_position] = key return array"},{"question":"# Problem Description Given a string `s`, identify and return the length of the longest palindromic subsequence within the string. # Function Signature ```python def longest_palindromic_subsequence(s: str) -> int: ``` # Input * A single string `s` where 1 ≤ len(s) ≤ 1000. # Output * An integer denoting the length of the longest palindromic subsequence in the string `s`. # Constraints * The input string consists only of printable ASCII characters. # Example ```python assert longest_palindromic_subsequence(\\"babad\\") == 3 # \\"bab\\" or \\"aba\\" assert longest_palindromic_subsequence(\\"cbbd\\") == 2 # \\"bb\\" assert longest_palindromic_subsequence(\\"a\\") == 1 # \\"a\\" assert longest_palindromic_subsequence(\\"acacac\\") == 5 # \\"cacac\\" or \\"acaca\\" ``` # Hints 1. Use Dynamic Programming. Consider a 2D DP table to store the lengths of the longest palindromic subsequence at different substring indices. 2. Examine characters from both ends towards the middle. # Additional Context In bioinformatics, this problem is crucial for understanding genetic sequences and structures. Efficient solutions can help in developing improved algorithms for DNA sequence analysis and other related fields.","solution":"def longest_palindromic_subsequence(s: str) -> int: n = len(s) # Create a DP array to store the results of subproblems dp = [[0] * n for _ in range(n)] # Every single character is a palindrome of length 1 for i in range(n): dp[i][i] = 1 # Build the DP table for length in range(2, n + 1): # length of the substring for i in range(n - length + 1): # start index of the substring j = i + length - 1 # end index of the substring if s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) # The result is in the top-right corner of the table return dp[0][n - 1]"},{"question":"Advanced Bit Manipulation Context You are working on a compression algorithm that requires manipulating individual bits of binary representations of data. To achieve this, you need to perform specific operations on the binary numbers—getting, setting, clearing, and updating bits at various positions. This requires efficient bitwise operations for high-performance data compression. Task Write a Python function `bit_manipulations(num, operations)` that performs a sequence of bit manipulations on a given integer `num`, based on a list of operations. Each operation is represented by a tuple of the form `(op_type, i, [bit])`, where: - `op_type` is one of `\'get\', \'set\', \'clear\', \'update\'` indicating the type of bit manipulation to perform. - `i` is the bit index (0-based from the right). - `bit` is an optional argument present only for `\'update\'` operations, representing the new bit value (0 or 1). The function should return the result after all operations are applied. For `\'get\'` operations, append the bit value to a list and return this list at the end. Function Signature ```python def bit_manipulations(num: int, operations: list) -> list: ``` Input Format - `num`: an integer, the number to manipulate. - `operations`: a list of tuples, where each tuple represents an operation. Output Format - For `\'get\'` operations, return a list of bit values obtained after all operations. - If no `\'get\'` operations are specified, return the final integer after all manipulations. Constraints - `0 <= i < 32` (Assume 32-bit integers for simplicity) - `bit` for `\'update\'` is either 0 or 1. - `num` and index values are non-negative. Example ```python # Example 1 num = 29 # binary: 11101 operations = [(\'get\', 0), (\'set\', 1), (\'get\', 1), (\'clear\', 3), (\'update\', 4, 0)] assert bit_manipulations(num, operations) == [1, 1] # Example 2 num = 0 # binary: 0 operations = [(\'set\', 3), (\'get\', 3), (\'get\', 2), (\'update\', 1, 1), (\'get\', 1)] assert bit_manipulations(num, operations) == [True, False, True] ```","solution":"def bit_manipulations(num, operations): def get_bit(n, i): return (n >> i) & 1 def set_bit(n, i): return n | (1 << i) def clear_bit(n, i): return n & ~(1 << i) def update_bit(n, i, bit): return (n & ~(1 << i)) | (bit << i) result = [] current_num = num for op in operations: if op[0] == \'get\': bit = get_bit(current_num, op[1]) result.append(bit) elif op[0] == \'set\': current_num = set_bit(current_num, op[1]) elif op[0] == \'clear\': current_num = clear_bit(current_num, op[1]) elif op[0] == \'update\': current_num = update_bit(current_num, op[1], op[2]) if any(op[0] == \'get\' for op in operations): return result else: return current_num"},{"question":"# Question: Advanced Bucket Sort Implementation You are tasked with implementing an advanced bucket sort function that uses a dynamic approach to bucket creation and a more efficient nested sorting algorithm. The goal is to handle large datasets and varying distributions effectively. Task: Implement the function `advanced_bucket_sort(arr)`. Your function should: 1. Dynamically determine the appropriate number of buckets. 2. Distribute elements into these buckets. 3. Use a more efficient sorting algorithm (Merge Sort) to sort individual buckets. 4. Return the sorted array. Input: - A list `arr` of integers, where `1 <= len(arr) <= 10^6`. Output: - A sorted list of integers. Constraints: - The range of elements in `arr` can be very large. Performance Requirements: - Your implementation should have an average case time complexity of O(n log n) and a worst case complexity not exceeding O(n^2). Note: - Use the provided merge sort function for sorting within buckets to ensure efficiency. ```python def merge_sort(arr): if len(arr) > 1: mid = len(arr) // 2 left_half = arr[:mid] right_half = arr[mid:] merge_sort(left_half) merge_sort(right_half) i = j = k = 0 while i < len(left_half) and j < len(right_half): if left_half[i] < right_half[j]: arr[k] = left_half[i] i += 1 else: arr[k] = right_half[j] j += 1 k += 1 while i < len(left_half): arr[k] = left_half[i] i += 1 k += 1 while j < len(right_half): arr[k] = right_half[j] j += 1 k += 1 return arr def advanced_bucket_sort(arr): # Your implementation here pass # Example usage: # arr = [random integers] # print(advanced_bucket_sort(arr)) ``` Hint: - Carefully consider the range and distribution of the input values when designing the bucket creation logic. - Focus on both the time and space efficiencies of your implementation.","solution":"def merge_sort(arr): Helper function to perform merge sort on an array. if len(arr) > 1: mid = len(arr) // 2 left_half = arr[:mid] right_half = arr[mid:] merge_sort(left_half) merge_sort(right_half) i = j = k = 0 while i < len(left_half) and j < len(right_half): if left_half[i] < right_half[j]: arr[k] = left_half[i] i += 1 else: arr[k] = right_half[j] j += 1 k += 1 while i < len(left_half): arr[k] = left_half[i] i += 1 k += 1 while j < len(right_half): arr[k] = right_half[j] j += 1 k += 1 return arr def advanced_bucket_sort(arr): if len(arr) <= 1: return arr # Find the minimum and maximum values in the array min_val = min(arr) max_val = max(arr) # Determine the number of buckets dynamically bucket_count = int(len(arr) ** 0.5) if len(arr) ** 0.5 > 1 else 2 # Calculate the bucket range bucket_range = (max_val - min_val + 1) / bucket_count # Create the buckets buckets = [[] for _ in range(bucket_count)] # Distribute the elements into the buckets for num in arr: bucket_index = int((num - min_val) // bucket_range) if bucket_index >= bucket_count: bucket_index = bucket_count - 1 buckets[bucket_index].append(num) # Sort individual buckets and concatenate the results sorted_arr = [] for bucket in buckets: sorted_arr.extend(merge_sort(bucket)) return sorted_arr"},{"question":"Enhanced Base Conversion Context You are tasked with enhancing an existing integer base conversion system. The current system can handle bases only up to 36. Your goal is to extend this system to handle higher bases up to 62, incorporating both uppercase and lowercase letters for digit representation. Objective Write two functions, `extended_int_to_base` and `extended_base_to_int`, that convert integers to strings in a given base and vice-versa, supporting bases from 2 to 62. Function Specifications 1. **Function `extended_int_to_base`**: * **Input**: An integer `num` and an integer `base` (2 <= base <= 62). * **Output**: A string representing the integer in the specified base. 2. **Function `extended_base_to_int`**: * **Input**: A string `str_to_convert` representing a number in a given base and an integer `base` (2 <= base <= 62). * **Output**: An integer which is the base 10 representation of the string. Input and Output Formats * **Input for `extended_int_to_base`**: * `num`: Integer (-10^9 <= num <= 10^9) * `base`: Integer (2 <= base <= 62) * **Output for `extended_int_to_base`**: * `str`: String representing the number in the specified base. * **Input for `extended_base_to_int`**: * `str_to_convert`: String in base format `base` * `base`: Integer (2 <= base <= 62) * **Output for `extended_base_to_int`**: * `int`: Integer, the base 10 representation of the input string. Constraints * Efficiently handle conversions for both positive and negative numbers. * Ensure conversions are accurate up to base 62. Example ```python # Example for extended_int_to_base print(extended_int_to_base(125, 62)) # Output: \\"21\\" print(extended_int_to_base(-255, 16)) # Output: \\"-FF\\" # Example for extended_base_to_int print(extended_base_to_int(\\"21\\", 62)) # Output: 125 print(extended_base_to_int(\\"-FF\\", 16)) # Output: -255 ``` Requirements 1. Implement the `extended_int_to_base` function. 2. Implement the `extended_base_to_int` function. 3. Ensure handling of edge cases such as zero, negative numbers, and the full range of supported bases.","solution":"def extended_int_to_base(num, base): Convert an integer to a string in a specified base (from 2 to 62). if base < 2 or base > 62: raise ValueError(\\"Base must be between 2 and 62\\") if num == 0: return \\"0\\" digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\\" negative = num < 0 if negative: num = -num result = [] while num >= base: result.append(digits[num % base]) num //= base result.append(digits[num]) if negative: result.append(\'-\') return \'\'.join(reversed(result)) def extended_base_to_int(str_to_convert, base): Convert a string in a specified base (from 2 to 62) to an integer. if base < 2 or base > 62: raise ValueError(\\"Base must be between 2 and 62\\") digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\\" digit_map = {digits[i]: i for i in range(len(digits))} num = 0 negative = str_to_convert[0] == \'-\' if negative: str_to_convert = str_to_convert[1:] for char in str_to_convert: num = num * base + digit_map[char] return -num if negative else num"},{"question":"**Scenario**: As part of an automated student records management system, you need to quickly find the information of students based on their unique student IDs. Since the student IDs are stored in sorted order for efficient retrieval, your task is to implement a function to search for a student ID using the Binary Search algorithm. **Task**: Write a function `find_student_id` that utilizes the Binary Search algorithm to find a given student ID within a sorted list of student IDs. Implement both iterative and recursive versions of the Binary Search. **Function Signature**: ```python def find_student_id_iterative(student_ids: List[int], target_id: int) -> int: pass def find_student_id_recursive(student_ids: List[int], target_id: int) -> int: pass ``` **Input**: * `student_ids` (List[int]): A list of student IDs sorted in ascending order. * `target_id` (int): The student ID that you are searching for. **Output**: * Return the index of the `target_id` in the list if found, else return -1. **Constraints**: * The length of the `student_ids` list will not exceed 10^6. * Each student ID will be a unique non-negative integer. **Performance Requirements**: The search operation should have a time complexity of O(log n). **Example**: ```python # Example 1: student_ids = [1001, 1003, 1004, 1007, 1010] target_id = 1004 # Output: 2 # Example 2: student_ids = [1001, 1003, 1004, 1007, 1010] target_id = 1011 # Output: -1 # Example 3: student_ids = [] target_id = 1001 # Output: -1 ``` **Additional Notes**: - Ensure your function handles edge cases, such as an empty list or a target ID not present in the list. - You can split the recursive function call into a helper function if needed.","solution":"from typing import List def find_student_id_iterative(student_ids: List[int], target_id: int) -> int: Iterative Binary Search to find the student ID in a sorted list of IDs. Returns the index of target_id if found, else returns -1. low, high = 0, len(student_ids) - 1 while low <= high: mid = (low + high) // 2 if student_ids[mid] == target_id: return mid elif student_ids[mid] < target_id: low = mid + 1 else: high = mid - 1 return -1 def find_student_id_recursive(student_ids: List[int], target_id: int) -> int: Recursive Binary Search to find the student ID in a sorted list of IDs. Returns the index of target_id if found, else returns -1. def search(low, high): if low > high: return -1 mid = (low + high) // 2 if student_ids[mid] == target_id: return mid elif student_ids[mid] < target_id: return search(mid + 1, high) else: return search(low, mid - 1) return search(0, len(student_ids) - 1)"},{"question":"Serialize and Deserialize a Binary Search Tree Context You are tasked with implementing reliable serialization and deserialization methods for binary search trees (BST). A BST is a node-based binary tree structure characterized by the following properties: - The left subtree of a node contains only nodes with values less than the node\'s value. - The right subtree of a node contains only nodes with values greater than the node\'s value. - Both the left and right subtrees must also be binary search trees. Task Implement the `serializeBST` and `deserializeBST` methods for a BST. These methods should effectively convert a BST to a string and reconstruct the BST from the string, respectively. Function Signatures ```python def serializeBST(root): # Implement the serialization logic here. pass def deserializeBST(data): # Implement the deserialization logic here. pass ``` Input/Output Formats * **serializeBST(root)** * **Input**: A root node of the BST. * **Output**: A string that represents the serialized BST. * **deserializeBST(data)** * **Input**: A string that represents the serialized BST. * **Output**: The root node of the deserialized BST. Constraints * Node values are distinct integers. * The maximum number of nodes in the BST is 10^4. * Node values can range between -10^5 and 10^5. Examples ```python # Example Input BST # 5 # / # 3 8 # / / # 2 4 7 9 root = TreeNode(5) root.left = TreeNode(3) root.right = TreeNode(8) root.left.left = TreeNode(2) root.left.right = TreeNode(4) root.right.left = TreeNode(7) root.right.right = TreeNode(9) serialized_data = serializeBST(root) print(serialized_data) # Expected output: A string representing the BST deserialized_tree = deserializeBST(serialized_data) # Expected output: # The reconstructed BST that matches the input BST in structure and values ``` Performance Requirements Favor methods that have linear time complexity O(N) and space complexity O(N), where N is the number of nodes.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def serializeBST(root): Encodes a tree to a single string. def preorder(node): return [node.val] + preorder(node.left) + preorder(node.right) if node else [] return \' \'.join(map(str, preorder(root))) def deserializeBST(data): Decodes your encoded data to tree. if not data: return None preorder = list(map(int, data.split())) inorder = sorted(preorder) def build(preorder, inorder): if not preorder: return None root_val = preorder[0] root_index = inorder.index(root_val) root = TreeNode(root_val) root.left = build(preorder[1:1+root_index], inorder[:root_index]) root.right = build(preorder[1+root_index:], inorder[root_index+1:]) return root return build(preorder, inorder)"},{"question":"# Subsets Generation Using Backtracking Objective: Design a function to generate all possible subsets of a given set of distinct integers by implementing a backtracking approach. Problem Statement: Write a function `generate_subsets(nums: List[int]) -> List[List[int]]` that takes a list of distinct integers and returns all possible subsets (the power set) of the given list. The subsets in the output list can be in any order. Description: - Implement the function using a backtracking approach. - The solution set should not contain duplicate subsets. - An empty list should also be a part of the solution set. Input: - A list `nums` of distinct integers where `0 <= len(nums) <= 20`. Output: - A list of lists, where each list represents a subset of the input list. # Constraints: 1. The solution must use backtracking to generate subsets. 2. The input list does not contain duplicate elements. 3. The function should handle edge cases where the input list is empty. # Examples: 1. Input: `nums = [1, 2, 3]` Output: `[[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]` 2. Input: `nums = [9]` Output: `[[], [9]]` 3. Input: `nums = []` Output: `[[]]` # Hint: Think about how you can use recursion to explore two possibilities for each element of the list: either include the element in the current subset or exclude it, thus systematically generating all possible subsets.","solution":"from typing import List def generate_subsets(nums: List[int]) -> List[List[int]]: Generates all possible subsets of a given list of distinct integers using backtracking. :param nums: List of distinct integers :return: List of lists where each sublist is a subset of the input list def backtrack(start: int, path: List[int]): # Append the current path as a subset subsets.append(path[:]) for i in range(start, len(nums)): # Include nums[i] in the subset path.append(nums[i]) # Continue with the next elements backtrack(i + 1, path) # Exclude nums[i] from the subset for backtracking path.pop() subsets = [] backtrack(0, []) return subsets"},{"question":"You are required to implement a CircularQueue that is more memory efficient than the simple array-based queue provided. In a CircularQueue, the underlying array is treated in a circular manner so that unused spaces at the front of the array can be reused once space is freed up from the rear. # Function Signatures ```python class CircularQueue(AbstractQueue): def __init__(self, capacity=10): Initialize CircularQueue with given capacity. :param capacity: the maximum size of the queue def enqueue(self, value): Add a new item to the queue. :param value: value to add def dequeue(self): Remove the front item from the queue. :return: the removed item def peek(self): Get the front item. :return: front item in the queue def __iter__(self): Allow iteration over items in the queue in order. ``` # Instructions: 1. Implement the CircularQueue class with the specified capacity. 2. Ensure all operations conform to the FIFO principle. 3. Handle edge cases where queue is empty or full. 4. Ensure that memory is reused efficiently in a circular manner. # Constraints: * The CircularQueue should manage up to (10^5) elements efficiently in terms of time and space. * Each element will be an integer in the range ([-10^9, 10^9]). * Exceptions should be thrown for invalid operations (e.g., dequeue on an empty queue). # Example ```python cq = CircularQueue(3) cq.enqueue(1) cq.enqueue(2) cq.enqueue(3) assert cq.dequeue() == 1 cq.enqueue(4) assert list(cq) == [2, 3, 4] assert cq.dequeue() == 2 assert list(cq) == [3, 4] ```","solution":"class CircularQueue: def __init__(self, capacity=10): Initialize CircularQueue with given capacity. :param capacity: the maximum size of the queue self.capacity = capacity self.queue = [None] * capacity self.front = -1 self.rear = -1 self.size = 0 def enqueue(self, value): Add a new item to the queue. :param value: value to add if self.size == self.capacity: raise Exception(\\"Queue is full\\") if self.size == 0: self.front = 0 self.rear = 0 else: self.rear = (self.rear + 1) % self.capacity self.queue[self.rear] = value self.size += 1 def dequeue(self): Remove the front item from the queue. :return: the removed item if self.size == 0: raise Exception(\\"Queue is empty\\") value = self.queue[self.front] self.queue[self.front] = None self.front = (self.front + 1) % self.capacity self.size -= 1 if self.size == 0: self.front = -1 self.rear = -1 return value def peek(self): Get the front item. :return: front item in the queue if self.size == 0: raise Exception(\\"Queue is empty\\") return self.queue[self.front] def __iter__(self): Allow iteration over items in the queue in order. idx = self.front count = 0 while count < self.size: yield self.queue[idx] idx = (idx + 1) % self.capacity count += 1"},{"question":"# Merge Sort Assessment Question **Objective**: You are tasked with implementing a sorting algorithm called Merge Sort. This algorithm should take an array of integers as input and return the array sorted in non-decreasing order. **Input Format**: A single list of integers `arr` where `0 <= len(arr) <= 10^5` and all elements of `arr` are integers with values in the range of `-10^9` to `10^9`. **Output Format**: A list of integers sorted in non-decreasing order. **Constraints**: * The implementation should maintain a time complexity of O(n log n). * The algorithm should be stable, meaning the relative order of elements that are equal should be preserved. **Function Signature**: ```python def merge_sort(arr: List[int]) -> List[int]: # Your code here ``` **Example**: ```python # Example 1 arr = [4, 2, 5, 1, 6, 3] print(merge_sort(arr)) # Output: [1, 2, 3, 4, 5, 6] # Example 2 arr = [] print(merge_sort(arr)) # Output: [] # Example 3 arr = [7, -3, 4, -1, 6, -5] print(merge_sort(arr)) # Output: [-5, -3, -1, 4, 6, 7] ``` **Edge Cases**: 1. An empty array should return an empty array. 2. An array with a single element should return the same array. 3. An array where all elements are the same should return the same array. **Instructions**: 1. Define the `merge_sort` function to take a list of integers and return it sorted. 2. Ensure that the function is stable and maintains a consistent time complexity of O(n log n). 3. You may define and use helper functions as needed.","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: Sorts an array of integers using Merge Sort algorithm. - The function is stable and maintains O(n log n) time complexity. if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half) def merge(left: List[int], right: List[int]) -> List[int]: Merges two sorted lists into one sorted list. sorted_list = [] i = j = 0 # Merge the sorted halves while maintaining stability while i < len(left) and j < len(right): if left[i] <= right[j]: sorted_list.append(left[i]) i += 1 else: sorted_list.append(right[j]) j += 1 # Append remaining elements from left while i < len(left): sorted_list.append(left[i]) i += 1 # Append remaining elements from right while j < len(right): sorted_list.append(right[j]) j += 1 return sorted_list"},{"question":"Context You are given a directed graph where each vertex represents a process, and an edge from vertex A to vertex B indicates that process A is waiting for process B to release some resource. You need to determine if there is a cycle in the graph, which would imply a deadlock situation. Task Write a function `contains_cycle(graph)` that takes a directed graph as input, represented as a dictionary, and returns `True` if there is a cycle in the graph and `False` otherwise. Input * `graph`: A dictionary where keys are vertices and values are lists of adjacent vertices. - Example: ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': [] } ``` Output * A Boolean value: `True` if there is a cycle in the graph, otherwise `False`. Constraints * Aim to achieve a time complexity of O(V + E), where V is the number of vertices and E is the number of edges. * The graph does not contain parallel edges or multiple edges between any pair of vertices. Example Here is the graph visualization: ``` A -> B -> D -> E | | | v v v C F <- B (cycle) | v F ``` If you run `contains_cycle(graph)`, it should return `True` because the graph contains a cycle (`B->D->E->B`). Requirements Demonstrate your understanding of cycle detection in directed graphs using Depth First Search (DFS) and state traversal. Ensure you handle different edge cases and verify your solution is correct.","solution":"def contains_cycle(graph): Determines if the directed graph contains a cycle. :param graph: Dictionary representing the directed graph :return: Boolean, True if there is a cycle, False otherwise def dfs(vertex, visiting, visited): if vertex in visiting: return True if vertex in visited: return False visiting.add(vertex) for neighbor in graph[vertex]: if dfs(neighbor, visiting, visited): return True visiting.remove(vertex) visited.add(vertex) return False visited = set() visiting = set() for vertex in graph: if dfs(vertex, visiting, visited): return True return False"},{"question":"# Question: Implement a Polynomial Differentiation Function Context You are given a Polynomial class that supports addition, subtraction, multiplication, and basic symbolic manipulation tasks. However, the feature to differentiate a polynomial with respect to a given variable is missing. Your task is to implement this feature. Differentiation of polynomials is fundamental in calculus and has various applications in fields like physics, economics, and engineering. Task Implement a method `differentiate` in the `Polynomial` class. This method should return a new `Polynomial` object representing the derivative of the original polynomial with respect to a given variable. # Requirements * The `differentiate` method should take one parameter `var` representing the variable with respect to which the differentiation is to be performed. * The method should return a new `Polynomial` object. * If the variable is not present in the polynomial, return a polynomial equivalent to zero. * Handle constant monomials appropriately (derivative of a constant is zero). * Address monomials with negative powers correctly. # Input and Output Formats * **Input**: * var (int): The integer identifier of the variable to differentiate against. * The `Polynomial` is already instantiated with terms when the method is called. * **Output**: * Return a `Polynomial` object that represents the derivative with respect to the variable `var`. # Constraints and Limits * Assume all polynomial operations are well-defined within the given constraints. * Performance should be optimized for polynomials up to hundreds of monomials. # Example ```python # Create the following polynomial: # 3(a_1)^3(a_2)^2 + a_2 + 5 poly = Polynomial([ Monomial({1: 3, 2: 2}, 3), Monomial({2: 1}, 1), Monomial({}, 5) ]) # Differentiate with respect to variable 1 derivative_1 = poly.differentiate(1) print(derivative_1) # Output should be equivalent to (3*3)(a_1)^2(a_2)^2 # Differentiate with respect to variable 2 derivative_2 = poly.differentiate(2) print(derivative_2) # Output should be equivalent to (3*2)(a_1)^3(a_2) + 1 ``` Implement the `differentiate` method considering the provided statements and examples.","solution":"class Monomial: def __init__(self, powers, coefficient): Initialize a monomial with given powers and coefficient. :param powers: A dictionary mapping variable indices to their powers. :param coefficient: The coefficient of the monomial. self.powers = powers self.coefficient = coefficient def differentiate(self, var): Differentiate this monomial with respect to the given variable. :param var: The variable index to differentiate against. :return: A new Monomial which is the derivative, or None if the derivative is zero. if var not in self.powers: return None new_coefficient = self.coefficient * self.powers[var] new_powers = self.powers.copy() if new_powers[var] == 1: del new_powers[var] else: new_powers[var] -= 1 return Monomial(new_powers, new_coefficient) class Polynomial: def __init__(self, monomials): Initialize a polynomial with a list of monomials. :param monomials: A list of Monomial objects. self.monomials = monomials def differentiate(self, var): Differentiate this polynomial with respect to the given variable. :param var: The variable index to differentiate against. :return: A new Polynomial which is the derivative. differentiated_monomials = [] for monomial in self.monomials: differentiated_monomial = monomial.differentiate(var) if differentiated_monomial: differentiated_monomials.append(differentiated_monomial) # If no monomials are left after differentiation, it means derivative is zero if not differentiated_monomials: return Polynomial([Monomial({}, 0)]) return Polynomial(differentiated_monomials) # Printing function is added just for demonstration purposes, # it would be better to implement __str__ method properly. def print_polynomial(poly): terms = [] for monomial in poly.monomials: if not monomial.powers: terms.append(f\\"{monomial.coefficient}\\") else: term_str = f\\"{monomial.coefficient}\\" for var, power in monomial.powers.items(): term_str += f\\"*(a_{var})^{power}\\" terms.append(term_str) return \\" + \\".join(terms) # Example usage poly = Polynomial([ Monomial({1: 3, 2: 2}, 3), Monomial({2: 1}, 1), Monomial({}, 5) ]) derivative_1 = poly.differentiate(1) print(print_polynomial(derivative_1)) # Output should be (3*3)(a_1)^2(a_2)^2 derivative_2 = poly.differentiate(2) print(print_polynomial(derivative_2)) # Output should be (3*2)(a_1)^3(a_2) + 1"},{"question":"Context You were recently hired by a company that manages oil pipelines. They need a program to compute the maximum flow of oil from the main reservoir (source) to the base station (sink) through a complex network of pipes. Each pipe has a certain capacity, and you need to use network flow algorithms to determine how much oil can be transported at maximum. Problem Statement You are provided with three implementations of network flow algorithms: Ford-Fulkerson, Edmonds-Karp, and Dinic’s algorithm. Your task is to implement a function that compares these three algorithms by computing maximum flow values on the same input graph and then returning the results. Task Write a function `compare_flow_algorithms(capacity, source, sink)` that takes the following inputs: - `capacity`: A two-dimensional list representing the capacities of the edges in the graph. `capacity[i][j]` is the capacity of the edge from node `i` to node `j`. If no direct edge exists, `capacity[i][j]` should be zero. - `source`: An integer representing the index of the source node. - `sink`: An integer representing the index of the sink node. The output should be a dictionary with the names of the algorithms as keys (\\"Ford-Fulkerson\\", \\"Edmonds-Karp\\", \\"Dinic\\") and their respective computed maximum flows as values. Constraints 1. The graph can have up to 200 nodes. 2. Each node index is between `0` and `199`. 3. The capacity matrix will be a 200x200 matrix with non-negative integers. Example ```python capacity = [ [0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0] ] source = 0 sink = 5 print(compare_flow_algorithms(capacity, source, sink)) # Output should be something like: # { # \\"Ford-Fulkerson\\": 23, # \\"Edmonds-Karp\\": 23, # \\"Dinic\\": 23 # } ``` Requirements 1. Use the provided implementations for the three algorithms. 2. Your solution should be efficient and handle the upper constraint limits. 3. Ensure the output is accurate and matches the required format. 4. Consider all edge cases mentioned in the analysis, such as disconnected graphs or nodes with zero capacity connections.","solution":"from collections import deque # Helper function to perform BFS for Edmonds-Karp def bfs(C, F, source, sink, parent): visited = [False] * len(C) queue = deque([source]) visited[source] = True while queue: u = queue.popleft() for v in range(len(C)): if not visited[v] and C[u][v] - F[u][v] > 0: queue.append(v) visited[v] = True parent[v] = u if v == sink: return True return False # Ford-Fulkerson (using Edmonds-Karp as it is an implementation of Ford-Fulkerson with BFS) def ford_fulkerson(C, source, sink): n = len(C) F = [[0] * n for _ in range(n)] parent = [-1] * n max_flow = 0 while bfs(C, F, source, sink, parent): path_flow = float(\'Inf\') s = sink while s != source: path_flow = min(path_flow, C[parent[s]][s] - F[parent[s]][s]) s = parent[s] v = sink while v != source: u = parent[v] F[u][v] += path_flow F[v][u] -= path_flow v = parent[v] max_flow += path_flow return max_flow # Edmonds-Karp (already implemented in Ford-Fulkerson above) def edmonds_karp(C, source, sink): return ford_fulkerson(C, source, sink) # Helper function to perform BFS for level graph in Dinic\'s algorithm def bfs_dinic(C, source, sink, level): visited = [False] * len(C) queue = deque([source]) visited[source] = True level[source] = 0 while queue: u = queue.popleft() for v in range(len(C)): if not visited[v] and C[u][v] > 0: queue.append(v) visited[v] = True level[v] = level[u] + 1 if v == sink: return True return False # Helper function to perform DFS with flow in Dinic\'s algorithm def dfs_dinic(C, F, u, sink, flow, level): if u == sink: return flow while F[u]: v = F[u].pop() if level[v] == level[u] + 1 and C[u][v] > 0: min_cap = min(flow, C[u][v]) dfs_flow = dfs_dinic(C, F, v, sink, min_cap, level) if dfs_flow > 0: C[u][v] -= dfs_flow C[v][u] += dfs_flow return dfs_flow return 0 # Dinic\'s algorithm def dinic(C, source, sink): n = len(C) max_flow = 0 while True: level = [-1] * n if not bfs_dinic(C, source, sink, level): break F = [list(range(n)) for _ in range(n)] while True: flow = dfs_dinic(C, F, source, sink, float(\'Inf\'), level) if flow == 0: break max_flow += flow return max_flow # Compare the three algorithms def compare_flow_algorithms(capacity, source, sink): return { \\"Ford-Fulkerson\\": ford_fulkerson([row[:] for row in capacity], source, sink), \\"Edmonds-Karp\\": edmonds_karp([row[:] for row in capacity], source, sink), \\"Dinic\\": dinic([row[:] for row in capacity], source, sink), }"},{"question":"Problem Statement You are given an array of words and an array of symbols. Your task is to display each word with its matched symbol surrounded by square brackets. If a word matches multiple symbols, the symbol with the longest length should be chosen. The symbols may overlap or be substrings of others, and the longest match should be prioritized. # Input - `words`: A list of strings representing the words to be matched. - `symbols`: A list of strings representing the symbols that need to be matched within the words. # Output - A list of strings where each word has been modified by adding the longest matching symbol surrounded by brackets. # Constraints - `1 <= len(words) <= 10^5` - `1 <= len(symbols) <= 10^3` - `1 <= len(words[i]) <= 100` - `1 <= len(symbols[j]) <= 50` # Example Input: ```python words = [\'Amazon\', \'Microsoft\', \'Google\'] symbols = [\'i\', \'Am\', \'cro\', \'Na\', \'le\', \'abc\'] ``` Output: ```python [\'[Am]azon\', \'Mi[cro]soft\', \'Goog[le]\'] ``` # Requirements 1. Implement a function `bracket(words, symbols)` that returns the modified list of words. 2. Construct an efficient algorithm that handles the constraints effectively. 3. Avoid nested loops where possible to keep the algorithm performant. # Function Signature ```python def bracket(words: List[str], symbols: List[str]) -> List[str]: pass ``` # Note - Consider using a Trie for efficient symbol matching. - Ensure that the solution handles symbols of different lengths and prioritizes the longest match. - Think about edge cases such as symbols that do not appear in any word or words with no matching symbols at all. Good luck!","solution":"from typing import List def bracket(words: List[str], symbols: List[str]) -> List[str]: # Sort symbols by length in descending order to prioritize the longest symbol symbols = sorted(symbols, key=len, reverse=True) # Create a list for the result result = [] # Iterate through each word for word in words: longest_match = \\"\\" # Check for each symbol if it\'s in the word and get the first longest matching symbol for symbol in symbols: if symbol in word: if len(symbol) > len(longest_match): longest_match = symbol break # If a match is found, apply the brackets if longest_match: word = word.replace(longest_match, f\\"[{longest_match}]\\") result.append(word) return result"},{"question":"Suppose you are working as a data analyst in a finance company, and you are asked to analyze the stock price changes over a period of time. Given an array of integers representing the stock prices on different days and an integer `k` representing the size of the sliding window, your task is to write a function that returns an array of the maximum stock prices for each window of size `k`. # Function Signature ```python def max_stock_prices(prices, k): # your code here ``` # Input - `prices`: List[int] - An array of integers representing the stock prices. - `k`: int - An integer representing the size of the sliding window (1 <= k <= len(prices)). # Output - List[int] - An array of integers representing the maximum stock prices for each sub-array of length `k`. # Constraints - The length of `prices` will be at least 1 and at most 10^5. - 1 <= k <= len(prices). # Example ```python assert max_stock_prices([1,3,-1,-3,5,3,6,7], 3) == [3, 3, 5, 5, 6, 7] assert max_stock_prices([1,3,1,2,0,5], 2) == [3, 3, 2, 2, 5] ``` # Notes - When `k` is 1, the result should be the array itself, as each element would be the maximum of its own window. - Consider efficiency both in terms of time and space complexity to handle the large size of input array effectively. Write an efficient solution to ensure your code runs within acceptable time limits for large inputs.","solution":"from collections import deque def max_stock_prices(prices, k): Returns an array of the maximum stock prices for each sub-array of length k. if not prices or k <= 0: return [] n = len(prices) if k == 1: return prices result = [] deq = deque() for i in range(n): # Remove elements from the front of deque that are outside the current window if deq and deq[0] < i - k + 1: deq.popleft() # Remove elements from the back of deque that are less than the current element while deq and prices[deq[-1]] < prices[i]: deq.pop() deq.append(i) # The first element of deque is the largest element of the current window if i >= k - 1: result.append(prices[deq[0]]) return result"},{"question":"# Question: Imagine you are working on a package delivery system, and you need to determine if there is a possible delivery route between two delivery centers. Each delivery center is represented as a node, and a direct route between centers as a directed edge. Your task is to write a function that checks if there is a route between two given delivery centers in a directed graph. Function Signature: ```python def is_reachable(vertex_count: int, edges: List[Tuple[int, int]], source: int, target: int) -> bool: pass ``` # Input: - `vertex_count` (int): The number of delivery centers (vertices) in the graph. - `edges` (List[Tuple[int, int]]): A list of tuples representing directed edges between the centers. - `source` (int): The delivery center you start from. - `target` (int): The delivery center you want to check connectivity to. # Output: - Returns `True` if there is a directed path from `source` to `target`, otherwise returns `False`. # Constraints: - `1 <= vertex_count <= 1000` - `0 <= source, target < vertex_count` - Each tuple in `edges` is a pair of integers representing a directed edge. # Performance Requirements: - The solution should be optimized to handle large graphs efficiently. # Example: ```python vertex_count = 4 edges = [(0, 1), (1, 2), (2, 3), (3, 0)] source = 0 target = 3 assert is_reachable(vertex_count, edges, source, target) == True vertex_count = 4 edges = [(0, 1), (1, 2), (2, 3)] source = 3 target = 0 assert is_reachable(vertex_count, edges, source, target) == False ``` # Additional Notes: - Ensure your solution handles graphs with no edges. - Account for self-loops and the possibility of traversing the same node multiple times.","solution":"from typing import List, Tuple def is_reachable(vertex_count: int, edges: List[Tuple[int, int]], source: int, target: int) -> bool: if source == target: return True from collections import deque, defaultdict graph = defaultdict(list) for u, v in edges: graph[u].append(v) visited = set() queue = deque([source]) while queue: current = queue.popleft() if current == target: return True if current not in visited: visited.add(current) for neighbor in graph[current]: if neighbor not in visited: queue.append(neighbor) return False"},{"question":"You are tasked with designing an algorithm that determines the number of distinct ways to reach the top of a staircase where you can take either 1 step or 2 steps at a time. # Function Signature ```python def count_ways_to_climb(steps: int) -> int: :param steps: int - Total number of steps in the staircase (1 <= steps <= 10^5). :return: int - Number of distinct ways to reach the top. ``` # Input - An integer `steps` representing the number of steps in the staircase. # Output - An integer representing the number of distinct ways to reach the top of the staircase. # Requirements - Your function should have a time complexity of O(n). - Your function should have a space complexity of O(1). # Example 1. `count_ways_to_climb(2)` should return `2`. There are two ways to reach step 2: (1 step + 1 step) or (2 steps). 2. `count_ways_to_climb(3)` should return `3`. There are three ways to reach step 3: (1 step + 1 step + 1 step), (1 step + 2 steps), or (2 steps + 1 step). # Constraints - `1 <= steps <= 100000` # Scenario Imagine you are assisting a robotic cleaner that needs to plan its path up a staircase. The robot can either move one step or two steps at a time. Your task is to tell the robot in how many different sequences it can reach the top to clean the final step. # Additional Information The problem must be solved using dynamic programming, ideally focusing on space efficiency as well as time efficiency.","solution":"def count_ways_to_climb(steps: int) -> int: if steps == 1: return 1 elif steps == 2: return 2 # Initializing the variables for dynamic programming prev1, prev2 = 2, 1 for i in range(3, steps + 1): current = prev1 + prev2 prev2 = prev1 prev1 = current return prev1"},{"question":"# Binary Search Tree (BST) Coding Assessment You are to implement additional functionality to a Binary Search Tree (BST) that includes finding the minimum and maximum values, deleting a node, and checking if the tree is a valid BST. Complete the functions as specified below. Function Signatures ```python class BST(object): def find_min(self) -> int: pass def find_max(self) -> int: pass def delete(self, data: int) -> bool: pass def is_valid_bst(self, root: Node = None) -> bool: pass ``` New Methods Specification: 1. **find_min**: * Returns the smallest integer in the BST. 2. **find_max**: * Returns the largest integer in the BST. 3. **delete**: * Removes the node containing the specified data. * Returns True if the data was found and deleted, False if the data was not found. 4. **is_valid_bst**: * Checks if the tree is a valid binary search tree. * Returns True if valid, otherwise False. Input/Output * Inputs will be provided through method calls on the BST instance. * Outputs should be the respective return values of the methods. Constraints 1. The tree can have at most 10^5 nodes. 2. All node values are distinct integers within the range of -10^9 to +10^9. 3. Do not use built-in library functions for any tree operations. # Example ```python bst = BST() bst.insert(10) bst.insert(15) bst.insert(6) print(bst.find_min()) # Output: 6 print(bst.find_max()) # Output: 15 print(bst.delete(15)) # Output: True print(bst.is_valid_bst()) # Output: True print(bst.delete(20)) # Output: False ``` Ensure your solution covers typical scenarios including edge cases such as: - An empty tree - A tree with one node - Deleting a leaf node, a node with one child, and a node with two children - Checking an invalid BST Test your implementation rigorously.","solution":"class Node: def __init__(self, data): self.data = data self.left = None self.right = None class BST(object): def __init__(self): self.root = None def insert(self, data): if self.root is None: self.root = Node(data) else: self._insert(data, self.root) def _insert(self, data, node): if data < node.data: if node.left is None: node.left = Node(data) else: self._insert(data, node.left) else: if node.right is None: node.right = Node(data) else: self._insert(data, node.right) def find_min(self) -> int: if self.root is None: raise ValueError(\\"The BST is empty\\") current = self.root while current.left: current = current.left return current.data def find_max(self) -> int: if self.root is None: raise ValueError(\\"The BST is empty\\") current = self.root while current.right: current = current.right return current.data def delete(self, data: int) -> bool: self.root, deleted = self._delete(self.root, data) return deleted def _delete(self, node, data): if node is None: return node, False if data < node.data: node.left, deleted = self._delete(node.left, data) elif data > node.data: node.right, deleted = self._delete(node.right, data) else: # Node with only one child or no child if node.left is None: temp = node.right node = None return temp, True if node.right is None: temp = node.left node = None return temp, True # Node with two children temp = self._min_value_node(node.right) node.data = temp.data node.right, _ = self._delete(node.right, temp.data) deleted = True return node, deleted def _min_value_node(self, node): current = node while current.left is not None: current = current.left return current def is_valid_bst(self, root: Node = None) -> bool: if root is None: root = self.root return self._is_valid_bst(root, float(\'-inf\'), float(\'inf\')) def _is_valid_bst(self, node, low, high): if node is None: return True if not (low < node.data < high): return False return self._is_valid_bst(node.left, low, node.data) and self._is_valid_bst(node.right, node.data, high)"},{"question":"# Question: Serialize and Deserialize a Binary Tree Implement a class `Codec` that provides methods to serialize and deserialize a binary tree. The serialization format should use pre-order traversal with `#` as a placeholder for null nodes. Method Definitions: * `serialize(self, root: TreeNode) -> str`: Serializes the tree rooted at `root` into a string. * `deserialize(self, data: str) -> TreeNode`: Deserializes the string back into the original binary tree structure. Example: ```python # Example usage # Input tree: # 1 # / # 2 3 # / # 4 5 codec = Codec() tree_string = codec.serialize(root) # Generates the string \\"1 2 # # 3 4 # # 5 # #\\" tree_root = codec.deserialize(tree_string) # Reconstructs the original tree ``` Constraints: * The number of nodes in the tree is in the range [0, 10^4]. * Node values are integer values that can be positive, negative, or zero. * Aim for efficient time and space complexity in both methods. Notes: * Focus on constructing a robust solution that correctly handles edge cases, such as trees with varying structures and size. * Ensure your solution is capable of handling large input sizes efficiently.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class Codec: def serialize(self, root): Encodes a tree to a single string. def preorder(node): if not node: return [\'#\'] return [str(node.val)] + preorder(node.left) + preorder(node.right) return \' \'.join(preorder(root)) def deserialize(self, data): Decodes your encoded data to tree. def helper(nodes): val = next(nodes) if val == \'#\': return None node = TreeNode(int(val)) node.left = helper(nodes) node.right = helper(nodes) return node nodes = iter(data.split()) return helper(nodes)"},{"question":"# Question: Optimized Sorting Check You have learned about the inefficient Bogo Sort algorithm, which sorts an array by brute-force shuffling until it is ordered. Now, let\'s create a more efficient function that sorts an array using a standard efficient sorting algorithm but also integrates a check that outputs a message when the array is already sorted. Objective Write a function `optimized_sort` that takes an array of integers as input and returns a sorted array. The function should: 1. Check if the array is already sorted before attempting to sort. 2. Print \\"Array is already sorted\\" if the input array is already in non-decreasing order. 3. Use a more efficient sorting algorithm (e.g., Merge Sort or Quick Sort) to sort the array if it is not already sorted. Constraints * The array elements will be integers and can be negative. * Length of the array will be within the range [0, 10^6]. Input * An array of integers, e.g., `[3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]` Output * A sorted array in non-decreasing order. Example ```python >>> optimized_sort([1, 2, 3, 4, 5]) Array is already sorted [1, 2, 3, 4, 5] >>> optimized_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] ``` Performance Requirements * The solution should efficiently handle arrays of up to 1,000,000 elements. # Implementation Implement the `optimized_sort` function to meet the above requirements. Use any efficient sorting algorithm of your choice for the sorting step if needed. ```python def optimized_sort(arr): # Implementation here ```","solution":"def optimized_sort(arr): Sort an array of integers in non-decreasing order. Prints a message if the array is already sorted. Uses Timsort, which is the sorting algorithm used by Python\'s built-in sort() function. if not arr or arr == sorted(arr): print(\\"Array is already sorted\\") return arr else: return sorted(arr)"},{"question":"You are given the design for serializing and deserializing a binary tree provided by the `TreeNode` class and two functions `serialize` and `deserialize`. However, these functions are only implemented for binary trees. Generalize these functions to work for an n-ary tree, where a node can have multiple child nodes. Function Specifications 1. **serialize(root: Node) -> str** * **Input**: * `root`: The root node of the n-ary tree, where each node follows the structure: ```python class Node: def __init__(self, x): self.val = x self.children = [] ``` * **Output**: A string representation of the tree structure using pre-order traversal. Use \'#\' to denote null nodes and separate node values by space. 2. **deserialize(data: str) -> Node** * **Input**: * `data`: A string representation of the serialized n-ary tree. * **Output**: The root node of the reconstructed n-ary tree. Constraints 1. The characters in the `data` string are only digits and spaces. 2. A node\'s value is a non-negative integer. 3. Ensure that edge cases such as an empty tree or malformed input are handled appropriately. Example ```python # Define the Node class class Node: def __init__(self, x): self.val = x self.children = [] root = Node(1) root.children.append(Node(2)) root.children.append(Node(3)) root.children[1].children.append(Node(4)) root.children[1].children.append(Node(5)) # Serialization example s = serialize(root) print(s) # Possible output: \\"1 2 # # 3 4 # # 5 # #\\" # Deserialization example tree = deserialize(s) assert tree.val == 1 assert tree.children[0].val == 2 assert tree.children[1].val == 3 assert tree.children[1].children[0].val == 4 assert tree.children[1].children[1].val == 5 ``` Your task is to implement the `serialize` and `deserialize` functions for an n-ary tree.","solution":"class Node: def __init__(self, x): self.val = x self.children = [] def serialize(root): Serializes an n-ary tree to a single string. res = [] def preorder(node): if node is None: return res.append(str(node.val)) for child in node.children: preorder(child) res.append(\'#\') # Marks end of children preorder(root) return \' \'.join(res) def deserialize(data): Deserializes a string to an n-ary tree. if not data: return None tokens = iter(data.split()) root_val = int(next(tokens)) root = Node(root_val) def helper(node): for token in tokens: if token == \'#\': return child_val = int(token) child = Node(child_val) node.children.append(child) helper(child) helper(root) return root"},{"question":"# Quick Sort Implementation Challenge Objective Write an efficient implementation of the Quick Sort algorithm that handles large data sets while minimizing the possibility of hitting the worst-case performance. Task You are required to implement the `quick_sort_modified` function. **Function Signature**: ```python def quick_sort_modified(arr: List[int], simulation: bool=False) -> List[int]: # Your implementation here ``` **Input**: * `arr`: a list of integers which needs to be sorted. * `simulation`: a boolean flag that, when set to True, prints the array after each iteration of the partitioning step for debugging purposes. Defaults to False. **Output**: * The sorted list of integers. Constraints * Do not use Python\'s built-in `sorted()` or `sort()` functions. * Your function should modify the input list in-place. * Consider optimizations that ensure better performance on sorted or nearly sorted input. Example ```python # Example 1 arr = [3, 6, 8, 10, 1, 2, 1] quick_sort_modified(arr) # Output should be [1, 1, 2, 3, 6, 8, 10] # Example 2 arr = [1, 3, 9, 4, 2, 5] quick_sort_modified(arr, simulation=True) # Should output intermediate iterations and finally: # iteration 1: [1, 2, 9, 4, 3, 5] # iteration 2: [1, 2, 3, 4, 9, 5] # iteration 3: [1, 2, 3, 4, 5, 9] ``` Notes * Ensure that your code is robust and handles edge cases such as empty arrays and arrays with duplicate values. * Discuss how your pivot selection strategy works and why it helps to avoid the worst-case scenario.","solution":"import random from typing import List def quick_sort_modified(arr: List[int], simulation: bool=False) -> List[int]: Sorts the array in-place using the Quick Sort algorithm and returns it. Args: arr (List[int]): The list of integers to sort. simulation (bool): When True, prints the array after each partitioning step for debugging. Returns: List[int]: The sorted list of integers. def quick_sort(arr, low, high): if low < high: pi = partition(arr, low, high) if simulation: print(f\\"iteration: {arr}\\") quick_sort(arr, low, pi-1) quick_sort(arr, pi+1, high) def partition(arr, low, high): pivot_index = random.randint(low, high) pivot = arr[pivot_index] arr[pivot_index], arr[high] = arr[high], arr[pivot_index] # Move pivot to end for simplification i = low - 1 for j in range(low, high): if arr[j] < pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i+1], arr[high] = arr[high], arr[i+1] return i + 1 quick_sort(arr, 0, len(arr)-1) return arr"},{"question":"# Question You are given a series of positive integers. Your task is to write a function that determines whether each integer has alternating bits in its binary representation. The function should return a list of boolean values indicating whether the condition holds true for each integer in the input list. Implement two functions: 1. A function that utilizes a basic bitwise approach: ```python def check_alternating_bits(nums: List[int]) -> List[bool]: Given a list of positive integers, return a list of boolean values indicating whether each integer has alternating bits. Args: nums: List[int] - A list of positive integers. Returns: List[bool] - A list of boolean values for each integer indicating whether it has alternating bits. pass ``` 2. An optimized version with constant-time bitwise operations. # Input * A list of positive integers `nums` (1 <= nums.length <= 10^5, 1 <= nums[i] <= 10^9). # Output * A list of boolean values corresponding to each input integer indicating whether it has alternating bits. # Constraints * Both functions should correctly handle lists with up to 100,000 integers. * The optimized function should have a constant time complexity O(1) for each integer check. # Example * Input: [5, 7, 11, 10] * Output: [True, False, False, True] # Notes * Given an integer, its binary representation may have leading zeroes which do not affect the alternating bit condition.","solution":"from typing import List def check_alternating_bits(nums: List[int]) -> List[bool]: Given a list of positive integers, return a list of boolean values indicating whether each integer has alternating bits. Args: nums: List[int] - A list of positive integers. Returns: List[bool] - A list of boolean values for each integer indicating whether it has alternating bits. result = [] for num in nums: current_bit = num & 1 num >>= 1 has_alternating_bits = True while num > 0: next_bit = num & 1 if next_bit == current_bit: has_alternating_bits = False break current_bit = next_bit num >>= 1 result.append(has_alternating_bits) return result def check_alternating_bits_optimized(nums: List[int]) -> List[bool]: Given a list of positive integers, return a list of boolean values indicating whether each integer has alternating bits using constant-time bitwise operations. Args: nums: List[int] - A list of positive integers. Returns: List[bool] - A list of boolean values for each integer indicating whether it has alternating bits. result = [] for num in nums: # n = num, n shifted right by 1 (making last bit disappear) # Combining them with XOR to create all 1s binary string n = num ^ (num >> 1) # Check if `n` and `n + 1` make all bits be 0 in binary doing AND result.append((n & (n + 1)) == 0) return result"},{"question":"You are given an array of integers where every element appears twice except for one. Your task is to find that single one using an efficient algorithm that runs in linear time complexity and does not use extra memory. # Function Specification You need to write a function `single_number(nums)` that takes a list of integers as input and returns the single number that appears only once. Input - A list of integers `nums` with the following properties: - Each integer in the list appears exactly twice except for one integer, which appears once. - The list size ranges from 1 to (10^5). - The elements can be negative or positive integers. Output - Return the single integer that appears only once in the list. - If the list is empty, return 0. Constraints - The algorithm should have a time complexity of O(n). - The algorithm should have a space complexity of O(1). # Example Example 1: ```python nums = [2, 2, 1] single_number(nums) # Output: 1 ``` Example 2: ```python nums = [4, 1, 2, 1, 2] single_number(nums) # Output: 4 ``` Example 3: ```python nums = [1] single_number(nums) # Output: 1 ``` # Notes - Your solution should efficiently find the single number using bitwise operations. - Handle edge cases such as an empty list and a list with only one element.","solution":"def single_number(nums): Finds the single number that appears only once in the list where every other number appears twice. Parameters: nums (List[int]): The list of integers. Returns: int: The single number that appears only once. if not nums: # Return 0 for empty list as specified return 0 # Initialize result result = 0 # Iterate over all elements and xor them for num in nums: result ^= num return result"},{"question":"**Scenario**: You are given a sequence formed by concatenating all positive integers in order: \\"123456789101112...\\". Your task is to identify the nth digit in this sequence. This problem challenges your understanding of numerical position encoding and efficient algorithm computation. **Task**: Write a function `find_nth_digit(n)` that returns the nth digit (1-indexed) in the concatenated sequence of positive integers. # Function Signature: ```python def find_nth_digit(n: int) -> int: Returns the nth digit in the infinite sequence of positive integers concatenated together. Parameters: n (int): The position of the digit (1-indexed) Returns: int: The nth digit in the sequence ``` # Input: * `n` (1 ≤ n ≤ 10^9): An integer representing the position in the infinite sequence. # Output: * A single integer representing the nth digit in the sequence. # Constraints: * The computation should be efficient. * The time complexity should be approximately O(log n). * Handle large values of n appropriately without overflow. # Examples: ```python # Example 1 print(find_nth_digit(3)) # Output: 3 # Explanation: The sequence starts \\"123\\", and the 3rd digit is \\"3\\". # Example 2 print(find_nth_digit(11)) # Output: 0 # Explanation: The sequence starts \\"12345678910\\", and the 11th digit is \\"0\\". # Example 3 print(find_nth_digit(15)) # Output: 2 # Explanation: The sequence starts \\"123456789101112\\", and the 15th digit is \\"2\\". ``` **Performance Requirement**: * Consider the efficiency and avoid brute-force approaches that would iterate over large sequences directly.","solution":"def find_nth_digit(n: int) -> int: Returns the nth digit in the infinite sequence of positive integers concatenated together. Parameters: n (int): The position of the digit (1-indexed) Returns: int: The nth digit in the sequence # Initial values length = 1 # the length of the current numbers (1 for \'1-9\', 2 for \'10-99\', etc.) count = 9 # total count of numbers with \'length\' digits while n > length * count: n -= length * count length += 1 count *= 10 # The actual number where the nth digit is located start = 10 ** (length - 1) number = start + (n - 1) // length # Find the exact digit digit_index = (n - 1) % length return int(str(number)[digit_index])"},{"question":"**Title**: Implement and Optimize Selection Sort **Scenario**: You are a software engineer at a company that deals with sorting large datasets for data analysis. Your team uses Selection Sort for its simplicity on small datasets, but they are looking for any possible efficiencies. **Task**: Implement the Selection Sort algorithm based on the given pseudocode and optimize it to reduce the number of swaps. Additionally, complete the function so that it handles the following edge cases gracefully: * Empty array * Array of length one * Already sorted arrays * Reverse sorted arrays Implement a function `optimized_selection_sort` that accepts a list of integers and returns the sorted list. For demonstration purposes, include a `simulation` flag that prints the array at each iteration. **Function Signature**: ```python def optimized_selection_sort(arr: List[int], simulation: bool = False) -> List[int]: ``` **Input**: * `arr`: A list of integers to be sorted. * `simulation`: A boolean flag to print the array after each iteration for debugging purposes. **Output**: * Returns the sorted list of integers. **Constraints**: * Do not use any built-in sort functions. * The function must handle empty and singleton arrays. * Ensure the function is robust against already sorted and reverse sorted inputs. **Examples**: 1. `optimized_selection_sort([64, 25, 12, 22, 11])` should return `[11, 12, 22, 25, 64]`. 2. `optimized_selection_sort([1, 2, 3, 4, 5, 6], simulation=True)` should print the array at each iteration and return `[1, 2, 3, 4, 5, 6]`. 3. `optimized_selection_sort([])` should return `[]`. 4. `optimized_selection_sort([10])` should return `[10]`. **Bonus**: Identify at least one additional optimization that could be applied to the classic Selection Sort algorithm and implement it.","solution":"from typing import List def optimized_selection_sort(arr: List[int], simulation: bool = False) -> List[int]: Sorts a list of integers using an optimized selection sort algorithm. n = len(arr) for i in range(n): # Find the minimum element in remaining unsorted array min_idx = i for j in range(i+1, n): if arr[j] < arr[min_idx]: min_idx = j # Swap the found minimum element with the first element if they are not the same if min_idx != i: arr[i], arr[min_idx] = arr[min_idx], arr[i] # Print the array at each iteration if simulation flag is true if simulation: print(arr) return arr"},{"question":"# Moving Average with Running Total **Scenario**: You are developing a monitoring tool to track real-time data streams, such as system performance metrics or stock prices. One common requirement is to compute the moving average of a recent set of numbers to smooth out short-term fluctuations and visualize trends. **Objective**: Implement a `MovingAverage` class with optimized sum calculation to compute the moving average of the last `k` elements in constant time. **Function Details**: 1. `__init__(self, size)`: Constructor to initialize the class with a window size `size`. 2. `next(self, val)`: Method to accept the next integer value `val` and return the moving average of the last `k` elements in the stream. **Input Format**: - `next(val)`: where `val` is an integer. **Output Format**: - Returns a float representing the moving average. **Constraints**: - All integer values are between `-10^4` and `10^4`. - The size `k` will be between `1` and `10000`. - The method `next` will be called at most `10^4` times. **Example**: ```python if __name__ == \'__main__\': m = MovingAverage(3) print(m.next(1)) # 1.0 print(m.next(10)) # 5.5 print(m.next(3)) # 4.6666... print(m.next(5)) # 6.0 ``` **Implementation Notes**: - Optimize the solution to avoid recomputing the sum of elements in the window from scratch every time. Use a running total that updates with each new value.","solution":"class MovingAverage: def __init__(self, size): Initializes the MovingAverage with a specified window size. :param size: an integer representing the window size self.size = size self.window = [] self.window_sum = 0 def next(self, val): Adds a new value to the window and returns the moving average of the last k elements. :param val: an integer value to be added to the window :return: a float representing the moving average of the last k elements if len(self.window) == self.size: self.window_sum -= self.window.pop(0) self.window.append(val) self.window_sum += val return self.window_sum / len(self.window)"},{"question":"You are given an array of integers representing the frequency of elements. Implement a class `FenwickTree` using Binary Indexed Trees (BIT) to support the following operations efficiently: 1. **Update the frequency of an element** at a specified index. 2. **Compute the sum of frequencies from index 0 to a specified index**. # Class Signature ```python class FenwickTree: def __init__(self, freq: List[int]): Initializes the Fenwick Tree with the given frequency array. Parameters: freq (List[int]): List of integers representing the frequency of elements. def update(self, index: int, value: int): Updates the frequency at the specified index by adding the given value. Parameters: index (int): The index to be updated (0-based). value (int): The value to be added at the specified index. def get_sum(self, index: int) -> int: Computes the sum of frequencies from index 0 to the specified index. Parameters: index (int): The index till which the sum needs to be computed (0-based). Returns: int: The sum of frequencies from index 0 to the specified index. ``` # Constraints * `0 <= index < len(freq)` * The array size `n` will be up to `10^5`. * Values in the array and updates can be negative or positive integers, within the range `-10^6` to `10^6`. # Example ```python # Example Usage freq = [1, 7, 3, 0, 7, 8, 3, 2, 6, 2, 3] fenwick_tree = FenwickTree(freq) # Initial construction should set up the tree properly print(fenwick_tree.get_sum(4)) # Output should be the sum of elements from index 0 to 4 fenwick_tree.update(3, 6) # This will add 6 to the element at index 3 print(fenwick_tree.get_sum(4)) # Output should reflect the updated sum ``` # Evaluation Criteria 1. **Correctness**: The implementation should correctly compute prefix sums and perform updates. 2. **Efficiency**: Operations should be performed in O(log n) time. 3. **Edge Cases Handling**: Consider cases such as updates at the start, middle, and end of the array. 4. **Code Quality**: Clean and understandable code with appropriate comments for clarity.","solution":"class FenwickTree: def __init__(self, freq): Initializes the Fenwick Tree with the given frequency array. Parameters: freq (List[int]): List of integers representing the frequency of elements. self.n = len(freq) self.bit = [0] * (self.n + 1) for i in range(self.n): self.update(i, freq[i]) def update(self, index, value): Updates the frequency at the specified index by adding the given value. Parameters: index (int): The index to be updated (0-based). value (int): The value to be added at the specified index. index += 1 while index <= self.n: self.bit[index] += value index += index & -index def get_sum(self, index): Computes the sum of frequencies from index 0 to the specified index. Parameters: index (int): The index till which the sum needs to be computed (0-based). Returns: int: The sum of frequencies from index 0 to the specified index. index += 1 result = 0 while index > 0: result += self.bit[index] index -= index & -index return result"},{"question":"# Bucket Sort Implementation **Scenario**: You are given the task of implementing the Bucket Sort algorithm to sort an array of floating-point numbers in the range [0, 1). Bucket Sort is particularly effective in this case due to the uniform distribution characteristic. **Task**: Write a function named `bucket_sort(arr)` that takes in an array `arr` of floating-point numbers in the range [0, 1) and returns the sorted array. **Input and Output Formats**: - **Input**: A list of floating-point numbers `arr` where 0 <= arr[i] < 1. - **Output**: A sorted list of floating-point numbers. **Constraints**: - The length of `arr` will be in the range [0, 1000]. - All elements in `arr` will be distinct. **Performance Requirements**: - Aim for an average time complexity of O(n). ```python def bucket_sort(arr): \'\'\' Bucket Sort Complexity: O(n^2) in the worst case Average Time Complexity: O(n) \'\'\' if len(arr) == 0: return arr # The number of buckets and make buckets num_buckets = len(arr) buckets = [[] for _ in range(num_buckets)] # Assign values into buckets for value in arr: index = int(value * num_buckets) # calculate bucket index buckets[index].append(value) # Sort each bucket and concatenate the results sorted_list = [] for i in range(num_buckets): sorted_list.extend(insertion_sort(buckets[i])) return sorted_list def insertion_sort(arr): for i in range(1, len(arr)): key = arr[i] j = i - 1 while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr ``` **Additional Requirements**: - Do not use any built-in Python sorting functions. - Make sure to handle edge cases like empty input or very small input size. You may assume that the auxiliary function `insertion_sort(arr)` is provided as a helper function to perform insertion sort on individual buckets.","solution":"def insertion_sort(arr): Helper function to sort array using insertion sort. for i in range(1, len(arr)): key = arr[i] j = i - 1 while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr def bucket_sort(arr): Sorts an array of floating-point numbers in the range [0, 1) using bucket sort. if len(arr) == 0: return arr num_buckets = len(arr) buckets = [[] for _ in range(num_buckets)] # Distribute array elements into buckets for value in arr: index = int(value * num_buckets) buckets[index].append(value) # Sort individual buckets and concatenate the result sorted_list = [] for bucket in buckets: sorted_list.extend(insertion_sort(bucket)) return sorted_list"},{"question":"You have been hired as a software engineer by a company that specializes in DNA sequence analysis. As part of their analytical toolset, you are required to implement a function that efficiently searches for patterns within a DNA sequence using the Knuth-Morris-Pratt (KMP) string matching algorithm. Problem Statement Implement a function `dna_pattern_search(dna: str, pattern: str) -> List[int]` that takes a DNA sequence and a pattern, and returns a list of start indices where the pattern is found in the DNA sequence using the KMP algorithm. Function Signature ```python def dna_pattern_search(dna: str, pattern: str) -> List[int]: pass ``` Input Format - `dna`: A string representing the DNA sequence, where each character can be one of A, C, G, T. - `pattern`: A string representing the pattern to search for in the DNA sequence, where each character can be one of A, C, G, T. Output Format - A list of integers representing the start indices of where the pattern is found in the DNA sequence. If the pattern is not found, return an empty list. Constraints - The length of `dna` will be between 1 and 10^5. - The length of `pattern` will be between 1 and 10^4. Example ```python >>> dna_pattern_search(\\"ACGTACGTGACG\\", \\"ACG\\") [0, 4, 9] >>> dna_pattern_search(\\"GATTACA\\", \\"GATT\\") [0] >>> dna_pattern_search(\\"AGCTAGC\\", \\"GGG\\") [] ``` Performance Considerations Your solution should efficiently handle large input sizes as specified in the constraints.","solution":"from typing import List def compute_lps_array(pattern: str) -> List[int]: KMP algorithm helper function that preprocesses the pattern to produce the longest prefix suffix (LPS) array. lps = [0] * len(pattern) length = 0 i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps def dna_pattern_search(dna: str, pattern: str) -> List[int]: Function to search for a pattern in a DNA sequence using the KMP algorithm. m = len(pattern) n = len(dna) if m == 0 or n == 0 or m > n: return [] lps = compute_lps_array(pattern) result = [] i = 0 # index for dna[] j = 0 # index for pattern[] while i < n: if pattern[j] == dna[i]: i += 1 j += 1 if j == m: result.append(i - j) j = lps[j - 1] elif i < n and pattern[j] != dna[i]: if j != 0: j = lps[j - 1] else: i += 1 return result"},{"question":"You are required to write a function `find_special_numbers(low, high)` that finds all numbers within a given range `[low, high]` that satisfy a special property: The sum of the digits of a number raised to consecutive powers starting from 1 should equal the number itself. Input * `low` (int): The lower bound of the range (inclusive). * `high` (int): The upper bound of the range (inclusive). Output * A list of integers that meet the described property, in ascending order. # Example **Example 1:** ``` Input: low = 1, high = 10 Output: [1, 2, 3, 4, 5, 6, 7, 8, 9] ``` **Example 2:** ``` Input: low = 1, high = 100 Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 89] ``` # Constraints 1. `1 <= low <= high <= 10^4` 2. The function should be efficient enough to handle up to the maximum range within a reasonable time limit. Additional Requirements Provide a brief explanation of your approach and why it is correct. Discuss any assumptions or considerations you took into account while devising your solution.","solution":"def find_special_numbers(low, high): def is_special_number(num): digits = list(map(int, str(num))) powered_sum = sum(digit ** (index + 1) for index, digit in enumerate(digits)) return powered_sum == num special_numbers = [num for num in range(low, high + 1) if is_special_number(num)] return special_numbers"},{"question":"Absolute File Path Conversion You are tasked with implementing a function that will convert a variety of file path inputs into their absolute paths. This is crucial for applications to access or manipulate files reliably, especially when dealing with user inputs that reference different directories or user home directories. # Specifications **Function Signature**: ```python def get_full_path(file_path: str) -> str: pass ``` **Input and Output**: - `file_path` (str): A string representing the file path which may be relative, absolute, or contain user home directory shorthand (`~`). - Returns (str): The absolute path corresponding to the input `file_path`. **Constraints**: - The input string will have a maximum length of 1024 characters. - The function should correctly handle paths that include `~` for user directories. - The function should convert relative paths to absolute paths. **Performance Requirements**: - The function should be optimized for efficiency, typically performing within O(n) where n is the length of the path string. # Scenario Imagine developing a cross-platform application that manages user documents. Users may input paths that are relative, absolute, or use shortcuts like `~` to indicate their home directory. Your function should be capable of converting these diverse inputs into consistent absolute paths to avoid any file access errors. # Example ```python print(get_full_path(\\"~/documents/file.txt\\")) # Should return the absolute path of \'file.txt\' in the user\'s documents directory. print(get_full_path(\\"./scripts/run.sh\\")) # Should return the absolute path if \'run.sh\' in the scripts subdirectory relative to the current directory. print(get_full_path(\\"/usr/local/bin\\")) # Should return the same absolute path \'/usr/local/bin\'. ``` # Additional Guidelines - Implement the necessary error handling for incorrect inputs. - Provide meaningful comments in your code to explain each step of the function.","solution":"import os def get_full_path(file_path: str) -> str: Converts a given file path to an absolute path. Parameters: - file_path: str : The input file path which can be relative, absolute, or contain user home directory shorthand (~). Returns: - str : The absolute path corresponding to the input file path. # Expand user home directory shortcut if present expanded_path = os.path.expanduser(file_path) # Convert the expanded path to an absolute path absolute_path = os.path.abspath(expanded_path) return absolute_path"},{"question":"# Matrix Operations: Determinant Calculator and Minor Matrix Extractor Objective: Implement functions to calculate the determinant of a matrix and extract minors, which are fundamental steps in more complex algorithms, such as matrix inversion. Task: 1. Implement a function `calculate_determinant(matrix)` that computes the determinant of a given square matrix. 2. Implement a function `extract_minor(matrix, row, column)` that extracts the minor of the matrix by removing the specified row and column. Function Specifications: 1. **`calculate_determinant(matrix: List[List[float]]) -> float`**: * **Input**: A square matrix `matrix` represented as a list of lists of floats (e.g., `[[3, 8], [4, 6]]`). * **Output**: The determinant of the given matrix as a float. 2. **`extract_minor(matrix: List[List[float]], row: int, column: int) -> List[List[float]]`**: * **Input**: * A square matrix `matrix` represented as a list of lists of floats. * The integer `row` and `column` to be removed. * **Output**: The minor matrix of the input matrix as a list of lists of floats. Constraints: * The matrix will always be a square matrix (n x n). * The size of the matrix will be between 2x2 and 10x10. * All elements in the matrix will be integers or floats. Example: ```python def main(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] print(calculate_determinant(matrix)) # Output: 0 print(extract_minor(matrix, 0, 0)) # Output: [[5, 6], [8, 9]] if __name__ == \\"__main__\\": main() ```","solution":"def calculate_determinant(matrix): Computes the determinant of a given square matrix. # Base case for 2x2 matrix if len(matrix) == 2: return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0] determinant = 0 for c in range(len(matrix)): determinant += ((-1) ** c) * matrix[0][c] * calculate_determinant(extract_minor(matrix, 0, c)) return determinant def extract_minor(matrix, row, column): Extracts the minor of the matrix by removing the specified row and column. return [row[:column] + row[column + 1:] for row in (matrix[:row] + matrix[row + 1:])]"},{"question":"Problem Statement You are tasked with finding the number of islands in a given 2D grid map. An island is defined as a group of `\'1\'`s (land) connected 4-directionally (horizontally or vertically). Assume all the edges of the grid are surrounded by water (`\'0\'`). You need to write an algorithm using Breadth-First Search (BFS). Input Format: - A 2D list of characters `grid` where: - `\'1\'` represents land. - `\'0\'` represents water. Output Format: - Return an integer representing the number of islands. Constraints: - The number of rows `M` and the number of columns `N` in the grid will not exceed 300. Example: ```python Example 1: Input: grid = [ [ \'1\', \'1\', \'1\', \'1\', \'0\'], [ \'1\', \'1\', \'0\', \'1\', \'0\'], [ \'1\', \'1\', \'0\', \'0\', \'0\'], [ \'0\', \'0\', \'0\', \'0\', \'0\'] ] Output: 1 Example 2: Input: grid = [ [ \'1\', \'1\', \'0\', \'0\', \'0\'], [ \'1\', \'1\', \'0\', \'0\', \'0\'], [ \'0\', \'0\', \'1\', \'0\', \'0\'], [ \'0\', \'0\', \'0\', \'1\', \'1\'] ] Output: 3 ``` Function Signature: ```python def count_islands(grid: List[List[str]]) -> int: # Your code here ``` Requirements: 1. Implement the function `count_islands` utilizing BFS. 2. Handle edge cases gracefully. 3. Optimize for performance and readability. Hints: - Use a queue data structure to assist with the BFS traversal. - Maintain a `visited` matrix to track cells you have already processed. - Make sure to check boundary conditions when exploring neighbor cells.","solution":"from collections import deque from typing import List def count_islands(grid: List[List[str]]) -> int: if not grid or not grid[0]: return 0 def bfs(r, c): queue = deque([(r, c)]) while queue: row, col = queue.popleft() directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] for dr, dc in directions: r, c = row + dr, col + dc if 0 <= r < m and 0 <= c < n and grid[r][c] == \'1\': grid[r][c] = \'0\' queue.append((r, c)) m, n = len(grid), len(grid[0]) islands_count = 0 for r in range(m): for c in range(n): if grid[r][c] == \'1\': islands_count += 1 grid[r][c] = \'0\' # mark as visited by changing \'1\' to \'0\' bfs(r, c) return islands_count"},{"question":"# Problem Description You are to implement a function that receives a sorted list of unique integers and returns a summary of their ranges. Each range is represented as a tuple and should be returned in a list of tuples. If the range is a single number, it should still be represented as a tuple with one element. # Function Signature ```python from typing import List, Tuple def summarize_ranges(array: List[int]) -> List[Tuple[int]]: pass ``` # Input * A list of integers `array` such that: * `1 <= len(array) <= 10^4` * The elements of `array` are sorted in non-decreasing order and do not contain duplicates. # Output * A list of tuples, each representing a range of consecutive integers. # Constraints * The elements in the input list `array` are between `-10^5` and `10^5`. # Example ```python # Example 1 array = [0, 1, 2, 4, 5, 7] # Returns: [(0, 2), (4, 5), (7, 7)] # Example 2 array = [1, 3, 4, 5, 6, 8, 10] # Returns: [(1, 1), (3, 6), (8, 8), (10, 10)] # Example 3 array = [100, 101, 103, 104, 105, 108] # Returns: [(100, 101), (103, 105), (108, 108)] assert summarize_ranges([0, 1, 2, 4, 5, 7]) == [(0, 2), (4, 5), (7, 7)] assert summarize_ranges([1, 3, 4, 5, 6, 8, 10]) == [(1, 1), (3, 6), (8, 8), (10, 10)] ``` # Notes * Ensure that your function handles edge cases, such as a single element or entirely consecutive sequences appropriately. * Focus on correctness and efficiency to handle all cases within the constraints.","solution":"from typing import List, Tuple def summarize_ranges(array: List[int]) -> List[Tuple[int]]: if not array: return [] ranges = [] start = array[0] end = array[0] for i in range(1, len(array)): if array[i] == end + 1: end = array[i] else: ranges.append((start, end)) start = array[i] end = array[i] ranges.append((start, end)) return ranges"},{"question":"# Problem Description You are required to implement a B-Tree that supports efficient insertion, deletion, and search operations. The B-Tree should dynamically adjust and maintain balance upon each operation to ensure consistent performance. # Task Extend the provided B-Tree class to include the following features: 1. Implement a function `get_all_keys` that returns all keys of the B-Tree in a sorted order. 2. Implement a function `range_search` that returns all keys within a specified range `[low, high]`. # Function Signatures ```python class BTree: def get_all_keys(self) -> List[int]: Return all keys in the B-Tree in a sorted order. pass def range_search(self, low: int, high: int) -> List[int]: Return all keys within a specified range [low, high]. pass ``` # Input and Output Formats 1. **get_all_keys**: - No input arguments. - Output: A list of integers representing all the keys in the B-Tree in sorted order. 2. **range_search**: - Inputs: two integers `low` and `high`. - Output: A list of integers representing all keys within the specified range `[low, high]` in sorted order. - Constraints: Assume `low <= high`. # Constraints 1. Keys are unique integers. 2. Initial B-Tree is empty. 3. `1 <= t <= 10` 4. `-10^5 <= key <= 10^5` # Example ```python btree = BTree(t_val=2) btree.insert_key(10) btree.insert_key(20) btree.insert_key(5) btree.insert_key(6) btree.insert_key(12) btree.insert_key(30) btree.insert_key(7) btree.insert_key(17) print(btree.get_all_keys()) # Output: [5, 6, 7, 10, 12, 17, 20, 30] print(btree.range_search(10, 20)) # Output: [10, 12, 17, 20] ``` # Performance Requirements 1. The `get_all_keys` should return the keys in O(n) time. 2. The `range_search` should operate in O(k + log n) time, where `k` is the number of keys in the specified range. # Notes Ensure to test your functions with different tree structures including edge cases, such as: 1. All keys being in the range. 2. No keys being in the range. 3. Keys just at the boundaries of the range.","solution":"class BTreeNode: def __init__(self, t, leaf=False): self.t = t self.leaf = leaf self.keys = [] self.children = [] class BTree: def __init__(self, t_val): self.root = BTreeNode(t_val, True) self.t = t_val def insert_key(self, key): root = self.root if len(root.keys) == (2 * self.t) - 1: temp = BTreeNode(self.t, False) self.root = temp temp.children.append(root) self.split_child(temp, 0) self.insert_non_full(temp, key) else: self.insert_non_full(root, key) def split_child(self, node, i): t = self.t y = node.children[i] z = BTreeNode(t, y.leaf) node.children.insert(i + 1, z) node.keys.insert(i, y.keys[t - 1]) z.keys = y.keys[t:(2 * t) - 1] y.keys = y.keys[0:t - 1] if not y.leaf: z.children = y.children[t:(2 * t)] y.children = y.children[0:t - 1] def insert_non_full(self, node, key): i = len(node.keys) - 1 if node.leaf: node.keys.append(None) while i >= 0 and key < node.keys[i]: node.keys[i + 1] = node.keys[i] i -= 1 node.keys[i + 1] = key else: while i >= 0 and key < node.keys[i]: i -= 1 i += 1 if len(node.children[i].keys) == (2 * self.t) - 1: self.split_child(node, i) if key > node.keys[i]: i += 1 self.insert_non_full(node.children[i], key) def get_all_keys(self): def traverse(node): keys = [] for i in range(len(node.keys)): if not node.leaf: keys.extend(traverse(node.children[i])) keys.append(node.keys[i]) if not node.leaf: keys.extend(traverse(node.children[len(node.children) - 1])) return keys return traverse(self.root) def range_search(self, low, high): def traverse_range(node, low, high): result = [] for i, key in enumerate(node.keys): if not node.leaf: result.extend(traverse_range(node.children[i], low, high)) if low <= key <= high: result.append(key) if not node.leaf: result.extend(traverse_range(node.children[len(node.children) - 1], low, high)) return result return traverse_range(self.root, low, high)"},{"question":"# Question # Check Digit-Powered Numbers Your task is to implement a function `find_digit_powered_numbers(low, high)` that takes two integers `low` and `high` as input parameters and returns a list of all numbers within this range (inclusive) that can be expressed as the sum of their digits each raised to consecutive powers. Input * `low` (1 <= low < high <= 10^6): An integer representing the lower bound of the range. * `high`: An integer representing the upper bound of the range. Output * A list of integers that meet the criteria mentioned above. # Example ```python def find_digit_powered_numbers(low, high): # Implement the function logic here pass # Example Usage # The range [1, 10): assert find_digit_powered_numbers(1, 10) == [1, 2, 3, 4, 5, 6, 7, 8, 9] # The range [1, 100): assert find_digit_powered_numbers(1, 100) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 89] ``` # Constraints * Consider performance optimizations for inputs approaching the higher end of the range. # Performance Requirements * The function should handle up to a range of `10^6` efficiently. **Note**: * Ensure to handle any edge cases such as invalid ranges or extremely large values that could impact performance.","solution":"def sum_of_digits_to_consecutive_powers(n): digits = [int(d) for d in str(n)] return sum(d**(i+1) for i, d in enumerate(digits)) def find_digit_powered_numbers(low, high): result = [] for n in range(low, high): if n == sum_of_digits_to_consecutive_powers(n): result.append(n) return result"},{"question":"You are tasked with implementing a function that checks if a given string follows a specific pattern. A string follows a pattern if there is a one-to-one correspondence between characters in the pattern and words in the string. Each character in the pattern must map to exactly one word, and each word must map to exactly one character. # Input * `pattern` (string): a string containing only lowercase letters. * `str` (string): a string containing lowercase words separated by single spaces. # Output * Boolean: `True` if the string follows the pattern, `False` otherwise. # Example ```python def word_pattern(pattern, str): # Example 1 print(word_pattern(\\"abba\\", \\"dog cat cat dog\\")) # should return True # Example 2 print(word_pattern(\\"abba\\", \\"dog cat cat fish\\")) # should return False # Example 3 print(word_pattern(\\"aaaa\\", \\"dog cat cat dog\\")) # should return False # Example 4 print(word_pattern(\\"abba\\", \\"dog dog dog dog\\")) # should return False ``` # Constraints * The pattern consists only of lowercase letters. * The input string consists of lowercase words separated by single space characters. * The length of the `pattern` will not exceed 1000. * The total length of `str` will not exceed 1000. # Requirements * Ensure that the function `word_pattern` achieves the following performance: * Time Complexity: O(n) * Space Complexity: O(n) # Implementation Guidelines 1. Split the `str` input into words. 2. Compare the lengths of the pattern and the words list; if they do not match, return `False`. 3. Use a dictionary to store the mapping from characters to words. 4. Use a set to ensure each word is mapped to exactly one character. # Additional Information Consider edge cases such as: * Patterns of different lengths. * Repeated words in the string. * Empty patterns or empty strings. Implement the function `word_pattern` to satisfy these constraints and requirements.","solution":"def word_pattern(pattern, str): # Split the input string into words words = str.split() # Check if the length of pattern matches the number of words if len(pattern) != len(words): return False # Dictionaries to map pattern to words and words to pattern char_to_word = {} word_to_char = {} # Iterate through each character in pattern and corresponding word for c, w in zip(pattern, words): if c in char_to_word: if char_to_word[c] != w: return False else: if w in word_to_char: return False char_to_word[c] = w word_to_char[w] = c return True"},{"question":"# Task You are provided with the `Node` class that represents a node in a binary tree and two functions (iterative and recursive implementations) that perform a postorder traversal on the binary tree. Your task is to write two functions: 1. `postorder_sum(root)`: which performs a postorder traversal of the binary tree and returns the sum of all node values. 2. `postorder_contains(root, val)`: which performs a postorder traversal of the binary tree and returns `True` if the provided value `val` is found in the tree, and `False` otherwise. Function signatures: ```python def postorder_sum(root: Node) -> int: # Implement this function pass def postorder_contains(root: Node, val: int) -> bool: # Implement this function pass ``` Input: - `root`: The root node of the binary tree. - `val`: The value to search for in the binary tree (for `postorder_contains` function). Output: - `postorder_sum` should return the sum of all nodes\' values. - `postorder_contains` should return a boolean, `True` if `val` is found, `False` otherwise. Constraints: - There can be at most (10^4) nodes in the tree. - Node values are integers in the range (-10^6) to (10^6). Example: Given the binary tree, ``` 5 / 3 7 / / 2 6 8 ``` - `postorder_sum(root)` should return `31`. - `postorder_contains(root, 6)` should return `True`. - `postorder_contains(root, 10)` should return `False`. Note that you may utilize helper functions provided in the code snippets to assist your implementations if you find them useful.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key def postorder_sum(root: Node) -> int: Perform a postorder traversal and return the sum of all node values. if root is None: return 0 left_sum = postorder_sum(root.left) right_sum = postorder_sum(root.right) return left_sum + right_sum + root.val def postorder_contains(root: Node, val: int) -> bool: Perform a postorder traversal and return True if the value is found. if root is None: return False if postorder_contains(root.left, val) or postorder_contains(root.right, val): return True return root.val == val"},{"question":"# Question: Insert Position in Sorted Array You have been tasked to implement a function that finds the insertion position of a target value within a sorted array using binary search. The function should be efficient and should consider edge cases such as empty arrays and arrays with only one element. **Function Signature**: ```python def search_insert(array: List[int], val: int) -> int: pass ``` **Input**: - `array`: A list of integers sorted in ascending order. - `val`: An integer target value. **Output**: - Return the index where the target value should be inserted to maintain the sorted order. # Constraints: - The length of `array` will be in the range `[0, 10^5]`. - Each element of `array` will be in the range `[-10^4, 10^4]`. - The value `val` will be in the range `[-10^4, 10^4]`. # Example: ```python search_insert([1, 3, 5, 6], 5) # returns 2 search_insert([1, 3, 5, 6], 2) # returns 1 search_insert([1, 3, 5, 6], 7) # returns 4 search_insert([1, 3, 5, 6], 0) # returns 0 search_insert([], 5) # returns 0 ``` # Description: Your task is to implement the provided binary search-based function that determines the correct insertion point for a given integer value in a sorted list. **Performance Requirements**: - Your solution should aim for a time complexity of O(log n) and a space complexity of O(1).","solution":"from typing import List def search_insert(array: List[int], val: int) -> int: Finds the insertion position of val in a sorted array using binary search. Parameters: - array: List[int] - a list of sorted integers. - val: int - the target integer to find the insertion point for. Returns: - int: The index at which val should be inserted to maintain sorted order. left, right = 0, len(array) - 1 while left <= right: mid = (left + right) // 2 if array[mid] == val: return mid elif array[mid] < val: left = mid + 1 else: right = mid - 1 return left"},{"question":"# Pathfinding in Graphs Background You are designing a system that models a network of computers where each node represents a computer and each edge represents a direct communication link between two computers. To efficiently manage data transfers, you need to implement algorithms to determine paths between any two computers in the network. Problem Statement Write three functions to find paths in an undirected graph: 1. `find_path(graph, start, end)`: Find any path between the `start` and `end` nodes. 2. `find_all_paths(graph, start, end)`: Find all possible paths between the `start` and `end` nodes. 3. `find_shortest_path(graph, start, end)`: Find the shortest path between the `start` and `end` nodes. The graph will be represented as an adjacency list (a dictionary where keys are nodes and values are lists of connected nodes). The functions should handle cases where: 1. Either `start` or `end` does not exist in the graph. 2. There are cycles in the graph. 3. No path exists between the `start` and `end` nodes. Input * `graph`: A dictionary representing the graph. Example: ```python { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\', \'E\'], \'C\': [\'A\', \'F\'], \'D\': [\'B\'], \'E\': [\'B\', \'F\'], \'F\': [\'C\', \'E\'] } ``` * `start`: Starting node (string). * `end`: Ending node (string). Output * For `find_path`: A list representing any path from `start` to `end`. Return `None` if no path exists. * For `find_all_paths`: A list of lists, where each sublist represents a distinct path from `start` to `end`. Return an empty list if no paths exist. * For `find_shortest_path`: A list representing the shortest path from `start` to `end`. Return `None` if no path exists. Constraints * The graph contains at most 1000 nodes. * Nodes are labeled with unique strings. * The graph can be disconnected and can have cycles. Example ```python graph_example = { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\', \'E\'], \'C\': [\'A\', \'F\'], \'D\': [\'B\'], \'E\': [\'B\', \'F\'], \'F\': [\'C\', \'E\'] } print(find_path(graph_example, \'A\', \'F\')) # Possible output: [\'A\', \'C\', \'F\'] print(find_all_paths(graph_example, \'A\', \'F\')) # Possible output: [[\'A\', \'B\', \'E\', \'F\'], [\'A\', \'C\', \'F\']] print(find_shortest_path(graph_example, \'A\', \'F\')) # Possible output: [\'A\', \'C\', \'F\'] ```","solution":"def find_path(graph, start, end, path=[]): path = path + [start] if start == end: return path if start not in graph: return None for node in graph[start]: if node not in path: newpath = find_path(graph, node, end, path) if newpath: return newpath return None def find_all_paths(graph, start, end, path=[]): path = path + [start] if start == end: return [path] if start not in graph: return [] paths = [] for node in graph[start]: if node not in path: newpaths = find_all_paths(graph, node, end, path) for newpath in newpaths: paths.append(newpath) return paths from collections import deque def find_shortest_path(graph, start, end): if start not in graph or end not in graph: return None queue = deque([(start, [start])]) visited = set() while queue: vertex, path = queue.popleft() if vertex == end: return path visited.add(vertex) for neighbor in graph[vertex]: if neighbor not in visited: queue.append((neighbor, path + [neighbor])) visited.add(neighbor) return None"},{"question":"Problem Statement: You are given a class of students, each represented by a unique string identifier. As part of a cryptography assignment, you are required to write a function `reverse_string(s: str) -> str` that reverses the given string. You must implement this function using an **iterative approach**. Input: * A string `s` which represents a student identifier. The length of the string can be as long as 10^6 characters. Output: * The reversed string of the input `s`. Constraints: * The input string `s` will consist of uppercase and lowercase English letters and digits. * You are required to reverse the string without using any built-in Python string reverse functions. Example: ```python assert reverse_string(\\"abcdef\\") == \\"fedcba\\" assert reverse_string(\\"12345\\") == \\"54321\\" assert reverse_string(\\"A1B2C3\\") == \\"3C2B1A\\" assert reverse_string(\\"zzz\\") == \\"zzz\\" assert reverse_string(\\"\\") == \\"\\" ``` # Implementation: Write your function implementation below: ```python def reverse_string(s: str) -> str: # Your code here pass ``` **Performance Requirements**: * The implemented function should have a time complexity of O(n) and space complexity of O(n).","solution":"def reverse_string(s: str) -> str: Iteratively reverses the given string `s` and returns the reversed string. reversed_string = [] # Iterate over the string from the last character to the first character for i in range(len(s) - 1, -1, -1): reversed_string.append(s[i]) return \'\'.join(reversed_string)"},{"question":"# Task You are given a string `s`, and your task is to write a function `delete_reoccurring_characters(s)` that removes any reoccurring characters from the string and returns the new string. Each character in the resulting string should appear only once, in the order they first appear in the input string. # Input * A single string `s` with a maximum length of 10^5 characters. The string consists of printable ASCII characters. # Output * A string with no recurring characters. # Examples ```python assert delete_reoccurring_characters(\\"google\\") == \\"gole\\" assert delete_reoccurring_characters(\\"hello\\") == \\"helo\\" assert delete_reoccurring_characters(\\"\\") == \\"\\" assert delete_reoccurring_characters(\\"a\\") == \\"a\\" assert delete_reoccurring_characters(\\"aaabbbccc\\") == \\"abc\\" ``` # Constraints * The function should handle strings with a large number of characters efficiently. * The function should be optimized to avoid inefficient operations. # Notes To meet the performance requirement: - Avoid repeated string concatenation inside loops. - You may find it useful to use a data structure like a set to track seen characters and a list to store the result efficiently.","solution":"def delete_reoccurring_characters(s): Removes any reoccurring characters from the string and returns the new string. Each character should appear only once, in the order they first appear in the input string. seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"You are given a list of distinct integers. Your task is to implement the recursive algorithm to return all possible permutations of the list. Subsequently, you will also implement a generator function to yield permutations one at a time. # Function Details Function 1: permute(elements: List[int]) -> List[List[int]] * **Input**: A list of distinct integers. * **Output**: A list of lists, where each list represents a possible permutation of the input. Function 2: permute_iter(elements: List[int]) -> Iterator[List[int]] * **Input**: A list of distinct integers. * **Output**: An iterator that yields permutations of the input list one at a time. # Example Example 1: ```python elements = [1, 2, 3] print(permute(elements)) # Output: # [ # [1, 2, 3], # [1, 3, 2], # [2, 1, 3], # [2, 3, 1], # [3, 1, 2], # [3, 2, 1] # ] for permutation in permute_iter(elements): print(permutation) # Output: # [1, 2, 3] # [1, 3, 2] # [2, 1, 3] # [2, 3, 1] # [3, 1, 2] # [3, 2, 1] ``` # Constraints * The elements list will contain at most 10 integers. * Each integer in elements is unique.","solution":"from typing import List, Iterator def permute(elements: List[int]) -> List[List[int]]: Returns all possible permutations of the list of elements. result = [] if len(elements) == 0: return [[]] for i in range(len(elements)): # Select the current element current_element = elements[i] # Recursively find the permutations of the remaining elements remaining_elements = elements[:i] + elements[i + 1:] for p in permute(remaining_elements): result.append([current_element] + p) return result def permute_iter(elements: List[int]) -> Iterator[List[int]]: Yields all possible permutations of the list of elements one at a time. if len(elements) == 0: yield [] else: for i in range(len(elements)): current_element = elements[i] remaining_elements = elements[:i] + elements[i + 1:] for p in permute_iter(remaining_elements): yield [current_element] + p"},{"question":"As part of a digital control system, you are required to manage a set of 32 binary flags that represent different statuses of the system. Your task is to implement a function that checks if any two flags in the system are set simultaneously (both bits are 1 at their respective positions). # Function Signature ```python def has_any_two_flags_set(num: int) -> bool: This function checks whether any two or more bits in a given 32-bit integer `num` are set to 1. Parameters: - num (int): A 32-bit integer where each bit represents a flag. Returns: - bool: True if any two or more bits are set to 1, False otherwise. ``` # Input * `num` - A 32-bit integer. # Output * Return `True` if any two or more bits are set to 1 in the given number, otherwise return `False`. # Constraints * Input integer `num` can be positive, negative, or zero. * Ensure the operation performs efficiently with a time complexity of O(1). # Example ```python print(has_any_two_flags_set(0b00000000000000000000000000001011)) # Output: True (more than one bit is set) print(has_any_two_flags_set(0b00000000000000000000000000000010)) # Output: False (exactly one bit is set) print(has_any_two_flags_set(0b00000000000000000000000000000000)) # Output: False (no bits are set) ``` # Guidelines 1. Use bitwise operations to solve the problem. 2. Think about how you can efficiently determine if more than one bit is set. 3. Remember to handle edge cases where there may be no bits set or only one bit set.","solution":"def has_any_two_flags_set(num: int) -> bool: This function checks whether any two or more bits in a given 32-bit integer `num` are set to 1. Parameters: - num (int): A 32-bit integer where each bit represents a flag. Returns: - bool: True if any two or more bits are set to 1, False otherwise. # Perform a bitwise AND operation between `num` and `num - 1`. # If the result is non-zero, then `num` had more than one bit set. return num & (num - 1) != 0"},{"question":"# Insertion Sort Implementation with Optimization Objective You are tasked with implementing a function that sorts an array using the Insertion Sort algorithm. To optimize the insertion process, you should use binary search to determine the appropriate position to insert each element. Specification Write a function `insertion_sort_optimized(array)` that takes a list of integers and sorts it in ascending order using the Insertion Sort algorithm. However, instead of performing a linear search to find the insertion position, use the provided `search_insert` function to find the position using binary search. Function Signature ```python def insertion_sort_optimized(array: List[int]) -> List[int]: ``` Input * `array` (List[int]): The input list of integers to be sorted. Output * Returns a new list containing the sorted integers. Constraints * The input list can be of any size, including empty. * You need to ensure that the sorting is stable. * Aim for optimizing the insertion part using binary search as provided in the snippet. Example ```python # Example Usage: input_array = [12, 11, 13, 5, 6] print(insertion_sort_optimized(input_array)) # Output: [5, 6, 11, 12, 13] ``` Additional Information - Make sure to handle edge cases such as an empty input list or a list with one element. - Performance efficiency is a key aspect to consider in your implementation, especially for the insertion process.","solution":"from typing import List def search_insert(arr: List[int], val: int, start: int, end: int) -> int: Returns the index at which val should be inserted into arr to maintain sorted order. This function performs binary search in the subarray arr[start:end]. while start < end: mid = (start + end) // 2 if arr[mid] < val: start = mid + 1 else: end = mid return start def insertion_sort_optimized(array: List[int]) -> List[int]: Returns a sorted list of integers using the optimized insertion sort algorithm. To find the position to insert each element, binary search is used. if len(array) < 2: return array[:] sorted_array = array[:] for i in range(1, len(sorted_array)): current_value = sorted_array[i] pos = search_insert(sorted_array, current_value, 0, i) # Shift elements to the right to make space for the current_value for j in range(i, pos, -1): sorted_array[j] = sorted_array[j - 1] sorted_array[pos] = current_value return sorted_array"},{"question":"**Context**: You are implementing a new feature for a data analysis tool. One of the requirements is to quickly locate the last occurrence of a specific value in a large dataset. The dataset is sorted in increasing order, and efficiency is a crucial factor due to the massive size of the data. # Problem Statement: Write a function `last_occurrence(array, query)` that takes a sorted array of integers and a query integer as input, and returns the index of the last occurrence of the query in the array. The function should use a binary search approach to achieve optimal performance. # Input: - `array`: List of integers, sorted in increasing order. - `query`: Integer to search for. # Output: - An integer representing the index of the last occurrence of `query` in `array`. If `query` is not present in the array, return `-1`. # Constraints: - The size of the array `array` is between 0 and 10^5. - Elements in `array` are between -10^6 and 10^6. - The function should perform efficiently with a time complexity of O(log n). # Examples: ```python last_occurrence([1, 2, 2, 2, 3, 4, 5], 2) # Output: 3 last_occurrence([1, 2, 2, 2, 3, 4, 5], 6) # Output: -1 last_occurrence([], 1) # Output: -1 last_occurrence([1, 1, 1, 1, 1, 1], 1) # Output: 5 ``` # Notes: - Consider edge cases like an empty array, an array with all identical elements, and an array where the query does not exist. - Make sure that your solution handles large datasets efficiently.","solution":"def last_occurrence(array, query): Returns the index of the last occurrence of query in the sorted array. If the query is not present in the array, returns -1. left, right = 0, len(array) - 1 result = -1 while left <= right: mid = (left + right) // 2 if array[mid] == query: result = mid left = mid + 1 elif array[mid] < query: left = mid + 1 else: right = mid - 1 return result"},{"question":"# Primality Testing with the Rabin-Miller Algorithm You are working on a cryptography project where you need to test if large numbers are prime with high probability. Implement an efficient and reliable primality testing function using the Rabin-Miller algorithm. The function should return `True` if the number is likely prime and `False` if it is composite. Function Signature ```python def rabin_miller_test(n: int, k: int) -> bool: pass ``` * `n` (1 <= n <= 10^18): The integer to be tested for primality. * `k` (1 <= k <= 100): Number of iterations/rounds for the test to balance accuracy and performance. Input * `n`: An integer to test for primality. * `k`: The number of iterations for the test. Output * Return `True` if `n` is probably prime with high probability. * Return `False` if `n` is definitely composite. Example ```python assert rabin_miller_test(17, 5) == True assert rabin_miller_test(18, 5) == False ``` Constraints * Focus on optimizing for both time and space efficiency. * The function should handle edge cases such as small values and even numbers efficiently. Notes * You can assume that the function `random.randrange(a, b)` is available and generates a random integer between `a` and `b-1`. Implement your solution in the following cell: ```python def rabin_miller_test(n: int, k: int) -> bool: import random def pow2_factor(num): power = 0 while num % 2 == 0: num //= 2 # Use integer division power += 1 return power, num def valid_witness(a, d, n, r): x = pow(a, d, n) if x == 1 or x == n - 1: return False for _ in range(r - 1): x = pow(x, 2, n) if x == n - 1: return False return True if n < 2: return False if n in (2, 3): return True if n % 2 == 0: return False r, d = pow2_factor(n - 1) for _ in range(k): a = random.randrange(2, n - 2) if valid_witness(a, d, n, r): return False return True ```","solution":"def rabin_miller_test(n: int, k: int) -> bool: import random def decompose(n): Decompose (n - 1) to the form of (2^r * d) where d is odd. r, d = 0, n - 1 while d % 2 == 0: r += 1 d //= 2 return r, d def is_composite(a, r, d, n): Check if a witness proves that n is composite. x = pow(a, d, n) if x == 1 or x == n - 1: return False for _ in range(r - 1): x = pow(x, 2, n) if x == n - 1: return False return True # Handle small cases directly if n < 2: return False if n in (2, 3): return True if n % 2 == 0: return False # Decompose (n - 1) to (2^r * d) r, d = decompose(n) # Perform k iterations of the test for _ in range(k): a = random.randrange(2, n - 1) if is_composite(a, r, d, n): return False return True"},{"question":"# Question Given the implementation of a Binary Search Tree (BST) and a function that computes the height of the tree, your task is to write a function to count the number of leaf nodes of the BST. A leaf node is a node that does not have any children. Function Signature ```python def count_leaves(root) -> int: pass ``` # Input * `root`: The root node of the BST (root can be `None`, indicating an empty tree). # Output * Returns an integer representing the number of leaf nodes in the tree. # Constraints * The number of nodes in the tree will be between 0 and 10,000. * The value of each node will be an integer within the range [-100,000, 100,000]. # Example ```python # Assuming Node class and bst (Binary Search Tree) class are defined: tree = bst() tree.insert(9) tree.insert(6) tree.insert(12) tree.insert(3) tree.insert(8) tree.insert(10) tree.insert(15) tree.insert(7) tree.insert(18) # This tree will look like this: # 9 # / # 6 12 # / / # 3 8 10 15 # / # 7 18 # Number of leaf nodes: 4 (Nodes 3, 7, 10, 18) count_leaves(tree.root) # Should return 4 ``` # Notes - Before implementing the function, consider how you will traverse the tree. - You should account for the edge cases such as an empty tree or a tree with only one node. - Aim for a solution with a time complexity of O(n) and a space complexity of O(h), where h is the height of the tree.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, node, key): if key < node.val: if node.left is None: node.left = Node(key) else: self._insert(node.left, key) else: if node.right is None: node.right = Node(key) else: self._insert(node.right, key) def count_leaves(root) -> int: if root is None: return 0 if root.left is None and root.right is None: return 1 return count_leaves(root.left) + count_leaves(root.right)"},{"question":"You have been tasked with creating a function that converts an integer into its equivalent Roman numeral representation. Roman numerals are typically used to represent numbers in a classical, readable format and are still popularly used to denote chapters, book volumes, and other ordinal positions. # Function Specification: Implement a function `int_to_roman(num)` that takes an integer as an input and returns a string representing its Roman numeral equivalent. ```python def int_to_roman(num): :type num: int :rtype: str ``` # Input: - `num` (int): An integer between 1 and 3999 inclusive. # Output: - A string representing the Roman numeral equivalent of the input integer. # Constraints: - The input integer will always be between 1 and 3999 inclusive. # Example: ```python assert int_to_roman(3) == \\"III\\" assert int_to_roman(58) == \\"LVIII\\" assert int_to_roman(1994) == \\"MCMXCIV\\" ``` # Requirements: 1. The solution should have a time complexity of O(1). 2. Handle all edge cases within the specified input range. 3. The Roman numeral representation must use traditional subtractive notation (e.g., 4 is \\"IV\\", 9 is \\"IX\\"). # Hints: - Consider dividing the number into thousands, hundreds, tens, and units to simplify the conversion process. - Utilize arrays to map positional values efficiently to their Roman numeral counterparts.","solution":"def int_to_roman(num): Convert an integer to a Roman numeral. :type num: int :rtype: str value_map = [ (1000, \'M\'), (900, \'CM\'), (500, \'D\'), (400, \'CD\'), (100, \'C\'), (90, \'XC\'), (50, \'L\'), (40, \'XL\'), (10, \'X\'), (9, \'IX\'), (5, \'V\'), (4, \'IV\'), (1, \'I\') ] roman_numeral = \'\' for value, symbol in value_map: while num >= value: roman_numeral += symbol num -= value return roman_numeral"},{"question":"You are tasked with developing a function that can identify missing ranges of numbers within a given sorted list of integers. This function should help in scenarios where you need to track gaps in sequences, such as missing pages in a book or missing identifiers in a database. # Function Signature ```python def missing_ranges(arr: List[int], lo: int, hi: int) -> List[Tuple[int, int]]: pass ``` # Input - `arr` (List[int]): A sorted list of unique integers. - `lo` (int): The lower bound of the range. - `hi` (int): The upper bound of the range. # Output - List[Tuple[int, int]]: A list of tuples, where each tuple represents the start and end of each missing range. # Constraints - `lo <= hi` - All elements in `arr` are within the range `[lo, hi]`. - Elements in `arr` are unique and sorted in ascending order. # Performance Requirements The solution should have a time complexity of O(n), where `n` is the length of the array `arr`. # Examples Example 1 ```python arr = [3, 5, 7] lo = 1 hi = 10 ``` **Output**: `[(1, 2), (4, 4), (6, 6), (8, 10)]` Example 2 ```python arr = [] lo = 1 hi = 5 ``` **Output**: `[(1, 5)]` Example 3 ```python arr = [1, 2, 3, 4, 5] lo = 1 hi = 5 ``` **Output**: `[]` # Prompt Write the implementation for the function `missing_ranges` that identifies and returns a list of missing number ranges within the given bounds.","solution":"from typing import List, Tuple def missing_ranges(arr: List[int], lo: int, hi: int) -> List[Tuple[int, int]]: Identifies and returns the list of missing ranges within the given bounds. Args: - arr: A sorted list of unique integers. - lo: The lower bound of the range. - hi: The upper bound of the range. Returns: - A list of tuples, where each tuple represents the start and end of each missing range. result = [] prev = lo - 1 # Initialize the previous value just before the lower bound # Iterate over the array elements and treat the higher bound as a virtual final element for curr in arr + [hi + 1]: if curr - prev > 1: result.append((prev + 1, curr - 1)) prev = curr return result"},{"question":"Sparse Vector Dot Product Imagine you are working on a recommendation system involving large, sparse vectors (where most elements are zero). Efficient storage and calculation of these vectors are crucial for performance. Your task is to implement a solution that efficiently computes the dot product of two large sparse vectors. Requirements: 1. Implement a function that converts a list (vector) of floating-point numbers to a compressed index-value list, storing only the indices and values of non-zero elements. 2. Implement a function that calculates the dot product of two such index-value lists. # Function Signatures: ```python def vector_to_index_value_list(vector: List[float]) -> List[Tuple[int, float]]: pass def dot_product(iv_list1: List[Tuple[int, float]], iv_list2: List[Tuple[int, float]]) -> float: pass ``` # Input and Output Formats: * **vector_to_index_value_list(vector)**: * **Input**: * `vector` - A list of float, representing the original dense vector. * **Output**: * A list of tuples, each tuple containing the index and value of a non-zero element. * **dot_product(iv_list1, iv_list2)**: * **Input**: * `iv_list1` - A list of tuples representing the index-value list of the first vector. * `iv_list2` - A list of tuples representing the index-value list of the second vector. * **Output**: * A float value representing the dot product of the two vectors. # Constraints: * Vectors can have up to (10^6) elements. * Up to 90% of the elements in each vector might be zeros. * Non-zero elements are guaranteed to be non-negative. # Performance Requirements: * The solutions should handle very large sparse vectors efficiently, both in terms of time and space. Example: ```python vector1 = [1.0, 0.0, 0.0, 2.0, 0.0] vector2 = [0.0, 3.0, 0.0, 4.0, 0.0] iv_list1 = vector_to_index_value_list(vector1) # iv_list1 should be [(0, 1.0), (3, 2.0)] iv_list2 = vector_to_index_value_list(vector2) # iv_list2 should be [(1, 3.0), (3, 4.0)] result = dot_product(iv_list1, iv_list2) # result should be 8.0 (since 2.0 * 4.0 = 8.0) ``` Implement the necessary functions to achieve the above requirements, thoroughly testing your solution against edge cases and performance constraints.","solution":"from typing import List, Tuple def vector_to_index_value_list(vector: List[float]) -> List[Tuple[int, float]]: Converts a list (vector) of floating-point numbers to a compressed index-value list, storing only the indices and values of non-zero elements. :param vector: List of float, representing the original dense vector. :return: A list of tuples, each containing the index and value of a non-zero element. return [(index, value) for index, value in enumerate(vector) if value != 0.0] def dot_product(iv_list1: List[Tuple[int, float]], iv_list2: List[Tuple[int, float]]) -> float: Calculates the dot product of two index-value lists. :param iv_list1: A list of tuples representing the index-value list of the first vector. :param iv_list2: A list of tuples representing the index-value list of the second vector. :return: A float value representing the dot product of the two vectors. # Convert second index-value list to a dictionary for fast look-up iv_dict2 = dict(iv_list2) # Calculate the dot product result = 0.0 for index, value in iv_list1: if index in iv_dict2: result += value * iv_dict2[index] return result"},{"question":"Scenario You are working on a text processing tool that uses pattern matching to validate input strings against predefined rules. To implement part of this tool, you need to use a Deterministic Finite Automaton (DFA) to accept or reject input strings based on their conformity to a specific language. Task Implement a function `is_accepted` that decides whether a string is accepted by a given DFA. Function Signature ```python def is_accepted(transitions, start, final, string): Determines if the input string is accepted by the DFA. Args: transitions (dict): A dictionary where keys are states and values are dictionaries that map input characters to next states. start (str/int): The initial state of the DFA. final (set): A set of accepting states. string (str): The input string to be validated. Returns: bool: True if the string is accepted by the DFA, False otherwise. pass ``` Input * `transitions`: A dictionary representing the state transition table. Each key is a state, and each value is a dictionary that maps input characters to next states. * `start`: The initial state (start state) of the DFA. * `final`: A set containing final (accepting) states. * `string`: The input string to be validated. Output * Return `True` if the string is accepted by the DFA (the machine ends in a final state after processing the entire string). * Return `False` otherwise. Example ```python transitions = { \'q0\': {\'a\': \'q1\', \'b\': \'q2\'}, \'q1\': {\'a\': \'q0\', \'b\': \'q3\'}, \'q2\': {\'a\': \'q3\', \'b\': \'q0\'}, \'q3\': {\'a\': \'q2\', \'b\': \'q1\'}, } start = \'q0\' final = {\'q0\'} string = \'abba\' print(is_accepted(transitions, start, final, string)) # Output: True ``` Constraints * The input DFA will always have at least one state and one transition. * The input string will contain only characters present in the transition dictionary. Requirements Your implementation should correctly handle edge cases, such as undefined transitions or empty input strings.","solution":"def is_accepted(transitions, start, final, string): Determines if the input string is accepted by the DFA. Args: transitions (dict): A dictionary where keys are states and values are dictionaries that map input characters to next states. start (str/int): The initial state of the DFA. final (set): A set of accepting states. string (str): The input string to be validated. Returns: bool: True if the string is accepted by the DFA, False otherwise. current_state = start for char in string: if char in transitions[current_state]: current_state = transitions[current_state][char] else: return False return current_state in final"},{"question":"# Linked List Intersection Detection You are given two singly linked lists that might share a common suffix. Your task is to write a function that detects if these two linked lists intersect and, if they do, returns the intersecting node. # Function Signature: ```python def intersection(h1: Node, h2: Node) -> Node: pass ``` # Input: * `h1` (Node): The head node of the first linked list. * `h2` (Node): The head node of the second linked list. # Output: * Returns the intersecting `Node` object if an intersection exists; otherwise, returns `None`. # Constraints: * The nodes in the linked lists contain an integer value. * The node itself is the unique identifier, not its value. * The maximum length of each linked list is `10^4`. # Example: ```python # create linked list as: # 1 -> 3 -> 5 # # 7 -> 9 -> 11 # / # 2 -> 4 -> 6 a1 = Node(1) b1 = Node(3) c1 = Node(5) d = Node(7) a2 = Node(2) b2 = Node(4) c2 = Node(6) e = Node(9) f = Node(11) a1.next = b1 b1.next = c1 c1.next = d a2.next = b2 b2.next = c2 c2.next = d d.next = e e.next = f assert intersection(a1, a2).val == 7 ``` # Explanation: In this example, the intersection occurs at node with value `7`. Your function will first determine the lengths of both linked lists, align the longer one with the shorter one, and then traverse both lists to determine if there\'s an intersecting node. Ensure that your implementation is efficient and handles edge cases such as null linked lists, or lists that do not intersect.","solution":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def intersection(h1: Node, h2: Node) -> Node: # Helper function to get the length of a list def get_length(head): length = 0 while head: length += 1 head = head.next return length if not h1 or not h2: return None # Get the lengths of both lists len1 = get_length(h1) len2 = get_length(h2) # Align both lists by advancing the pointer of the longer list while len1 > len2: h1 = h1.next len1 -= 1 while len2 > len1: h2 = h2.next len2 -= 1 # Traverse both lists together to find intersection while h1 and h2: if h1 is h2: return h1 h1 = h1.next h2 = h2.next return None"},{"question":"**Question**: You are given a list `arr` containing `n` integers. Your task is to implement the Selection Sort algorithm to sort the list in ascending order. Implement the function `selection_sort(arr)` that sorts the array `arr` using the Selection Sort algorithm, as described below: 1. Traverse the array from the beginning to the end. 2. For each position in the array (starting from 0 to n-1), identify the position (index) of the smallest element in the unsorted part. 3. Swap this smallest element with the first element of the unsorted part. 4. Repeat the above steps until the entire array is sorted. **Input**: - A list `arr` of integers where `1 <= len(arr) <= 1000`. **Output**: - The sorted list in ascending order. **Constraints**: - You may assume that the elements of `arr` are in the range of `-10^6` to `10^6`. **Example**: ```python assert selection_sort([64, 25, 12, 22, 11]) == [11, 12, 22, 25, 64] assert selection_sort([4, 2, -3, 6, 1]) == [-3, 1, 2, 4, 6] assert selection_sort([100, 54, 56, 90, 12]) == [12, 54, 56, 90, 100] ``` Implement the `selection_sort` function that meets the above requirements.","solution":"def selection_sort(arr): n = len(arr) for i in range(n): min_index = i for j in range(i+1, n): if arr[j] < arr[min_index]: min_index = j arr[i], arr[min_index] = arr[min_index], arr[i] return arr"},{"question":"**Title**: Swap Successive Pairs in a Stack **Objective**: Given a stack of integers, your task is to write a function that switches successive pairs of numbers starting from the bottom of the stack. **Function Signature**: ```python def switch_pairs(stack): pass ``` **Expected Input and Output**: - Input: A list `stack` representing a stack of integers. Example: [3, 8, 17, 9, 1, 10] - Output: A list of integers where each successive pair has been switched in place. Example: [8, 3, 9, 17, 10, 1] **Constraints**: - Only use a single auxiliary stack or queue. - Maintain the original order where pairs start from the bottom of the stack. - Avoid using any built-in functions that directly solve the problem. - No restriction on the length of the stack; must handle from empty to large stacks. **Performance Requirements**: - Aim to minimize the number of operations and memory usage. - Ensure the solution is robust even with edge cases like odd number of elements or empty input stack. **Context**: You are a software developer tasked with managing a priority task queue represented by a stack. Due to a specific malfunction, all tasks must swap positions in pairs for a successful recovery. Develop a solution that ensures pairs are swapped efficiently and correctly. **Examples**: 1. **Example 1**: * Input: [3, 8, 17, 9, 1, 10] * Output: [8, 3, 9, 17, 10, 1] 2. **Example 2**: * Input: [3, 8, 17, 9, 1] * Output: [8, 3, 9, 17, 1] 3. **Example 3**: * Input: [] * Output: [] 4. **Example 4**: * Input: [1] * Output: [1] Write an efficient implementation for the `switch_pairs` function, ensuring all edge cases are handled properly.","solution":"def switch_pairs(stack): Switches successive pairs of elements in the stack starting from the bottom. n = len(stack) for i in range(0, n - n % 2, 2): stack[i], stack[i + 1] = stack[i + 1], stack[i] return stack # Example usage: # print(switch_pairs([3, 8, 17, 9, 1, 10])) # Output: [8, 3, 9, 17, 10, 1]"},{"question":"You are tasked with developing a class to efficiently add and search for words in a database. The search functionality should support regular expression-like patterns where the character \'.\' can match any letter. # Requirements 1. You need to create a class `WordDictionary` with the following methods: * `add_word(word: str) -> None`: Adds `word` to the data structure. * `search(word: str) -> bool`: Returns True if `word` is in the data structure or matches any previously added word (where \'.\' can match any character); otherwise, returns False. # Constraints * All inputs are lowercase English letters. * An empty string is not a valid input for either `add_word` or `search`. # Examples ```python wd = WordDictionary() wd.add_word(\\"bad\\") wd.add_word(\\"dad\\") wd.add_word(\\"mad\\") print(wd.search(\\"pad\\")) # Output: False print(wd.search(\\"bad\\")) # Output: True print(wd.search(\\".ad\\")) # Output: True print(wd.search(\\"b..\\")) # Output: True Edge Case print(wd.search(\\"\\")) # Output: False (Empty string is invalid input) ``` # Implementation Implement the `WordDictionary` class to support efficient word addition and search. Use either the Trie-based approach or a dictionary-based approach as analyzed above to maximize both performance and memory efficiency.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class WordDictionary: def __init__(self): self.root = TrieNode() def add_word(self, word: str) -> None: curr = self.root for char in word: if char not in curr.children: curr.children[char] = TrieNode() curr = curr.children[char] curr.is_end_of_word = True def search(self, word: str) -> bool: def search_in_node(word, node): for i, char in enumerate(word): if char not in node.children: if char == \'.\': for child in node.children.values(): if search_in_node(word[i+1:], child): return True return False else: node = node.children[char] return node.is_end_of_word return search_in_node(word, self.root)"},{"question":"**Bit Flip Counter** Suppose you are developing a software that deals with data from different systems. Sometimes, data discrepancies happen, and you need to measure how different two pieces of integer data are, bit by bit. To do this, you must count the minimal number of bits that need to be flipped to convert one integer to another. Write a function `minimal_bit_flips(a: int, b: int) -> int` that receives two integers `a` and `b`, and returns the number of bits you would need to flip to convert `a` to `b`. Function Signature ```python def minimal_bit_flips(a: int, b: int) -> int: pass ``` Input - `a` and `b`: Integers with values in the range [0, 2^31 - 1] Output - An integer representing the number of bit flips required. Constraints - The input integers can be large, but will be within the standard 32-bit signed integer range. Example ```python assert minimal_bit_flips(29, 15) == 2 # Explanation: # 29 in binary is 11101 # 15 in binary is 01111 # 1st, 2nd, 3rd, and 5th bits from the right are the same # The 4th and 5th bits are different # To transform 29 into 15, we need to flip 2 bits: the 4th and 5th. assert minimal_bit_flips(25, 30) == 3 # Explanation: # 25 in binary is 11001 # 30 in binary is 11110 # The 2nd, 3rd, and 5th bits from the right are different # To transform 25 into 30, we need to flip 3 bits. ``` Notes - You are expected to use bitwise operations to achieve the result efficiently. - Consider handling edge cases, such as when the integers are the same or when one of the integers is zero.","solution":"def minimal_bit_flips(a: int, b: int) -> int: Returns the number of bits that need to be flipped to convert integer a to integer b. # XOR the two integers to identify differing bits differing_bits = a ^ b # Count the number of 1s in the binary representation of differing_bits return bin(differing_bits).count(\'1\')"},{"question":"**Segment Tree Query and Update Implementation** You are required to implement a Segment Tree that supports both point updates and range queries. The primary operations to implement are: # Operations 1. **Initialization**: Create a Segment Tree based on an initial array and a commutative merge function. 2. **Update**: Update the value at a specific index and reflect the changes in the segment tree. 3. **Query**: Compute the result of the commutative merge function over a specified range of indices. # Input and Output Formats - **Initialization**: - Input: An array of elements, `arr` and a commutative function, `function`. - Output: None. - **Update Operation**: - Input: An index `i` and a new value `v`. - Output: None. - **Query Operation**: - Input: A range specified by indices `l` and `r`. - Output: The result of the commutative function applied to the specified range. # Constraints - The array can have up to 100,000 elements. - The range for queries will always be valid within the array limits. - The commutative function applied will be valid for the elements in the array. # Example ```python mytree = SegmentTree([4, 5, 2, 3, 4, 43, 3], lambda a, b: a + b) print(mytree.query(0, 6)) # Output: 64 mytree.update(2, -10) print(mytree.query(0, 6)) # Output: 52 mytree = SegmentTree([(1, 2), (4,6), (4,5)], lambda a, b: (a[0] + b[0], a[1] + b[1])) print(mytree.query(0, 2)) # Output: (9, 13) mytree.update(2, (-1, 2)) print(mytree.query(0, 2)) # Output: (4, 10) ``` You are to implement the `SegmentTree` class and its associated methods `update` and `query`.","solution":"class SegmentTree: def __init__(self, arr, func): Initialize the segment tree with arr and the merge function func. self.n = len(arr) self.func = func self.tree = [None] * (2 * self.n) # Building the tree self.build(arr) def build(self, arr): Build the segment tree. # Initialize leaves for i in range(self.n): self.tree[self.n + i] = arr[i] # Compute internal nodes for i in range(self.n - 1, 0, -1): self.tree[i] = self.func(self.tree[2 * i], self.tree[2 * i + 1]) def update(self, index, value): Update the value at index to new value and reflect this change in the segment tree. # Translate index to appropriate location in tree pos = self.n + index # Update the leaf node self.tree[pos] = value # Update the internal nodes while pos > 1: pos //= 2 self.tree[pos] = self.func(self.tree[2 * pos], self.tree[2 * pos + 1]) def query(self, left, right): Compute the result of the commutative merge function over the range [left, right]. res = None l, r = left + self.n, right + self.n + 1 while l < r: if l % 2: res = self.tree[l] if res is None else self.func(res, self.tree[l]) l += 1 if r % 2: r -= 1 res = self.tree[r] if res is None else self.func(res, self.tree[r]) l //= 2 r //= 2 return res"},{"question":"# Sudoku Solver Problem You have been provided with a class-based implementation of a Sudoku solver. The solver uses Depth-First Search (DFS) with backtracking to find a solution for a given Sudoku puzzle. Your task is to implement a function `solve_sudoku(board: List[List[str]]) -> bool` that solves the Sudoku puzzle using the principles described in the analysis section. The function should modify the board in-place by filling the empty cells with digits from \'1\' to \'9\'. # Input - `board`: A 9x9 2D list representing the Sudoku grid. Each cell is either a digit (as string) from \'1\' to \'9\' or an empty cell represented by \'.\'. # Output - Modify the `board` in-place such that it is a valid Sudoku solution. Return `True` if the puzzle is solved correctly, else `False`. # Constraints - The input board is always a 9x9 grid. - Initial configuration provided in the `board` is guaranteed to be solvable. # Performance Requirements - The solution should efficiently handle backtracking without excessive recursive depth or time consumption. # Example Given the Sudoku board as: ``` [ [\'5\', \'3\', \'.\', \'.\', \'7\', \'.\', \'.\', \'.\', \'.\'], [\'6\', \'.\', \'.\', \'1\', \'9\', \'5\', \'.\', \'.\', \'.\'], [\'.\', \'9\', \'8\', \'.\', \'.\', \'.\', \'.\', \'6\', \'.\'], [\'8\', \'.\', \'.\', \'.\', \'6\', \'.\', \'.\', \'.\', \'3\'], [\'4\', \'.\', \'.\', \'8\', \'.\', \'3\', \'.\', \'.\', \'1\'], [\'7\', \'.\', \'.\', \'.\', \'2\', \'.\', \'.\', \'.\', \'6\'], [\'.\', \'6\', \'.\', \'.\', \'.\', \'.\', \'2\', \'8\', \'.\'], [\'.\', \'.\', \'.\', \'4\', \'1\', \'9\', \'.\', \'.\', \'5\'], [\'.\', \'.\', \'.\', \'.\', \'8\', \'.\', \'.\', \'7\', \'9\'] ] ``` The `solve_sudoku` function should modify the `board` to the solved state, e.g. : ``` [ [\'5\', \'3\', \'4\', \'6\', \'7\', \'8\', \'9\', \'1\', \'2\'], [\'6\', \'7\', \'2\', \'1\', \'9\', \'5\', \'3\', \'4\', \'8\'], [\'1\', \'9\', \'8\', \'3\', \'4\', \'2\', \'5\', \'6\', \'7\'], [\'8\', \'5\', \'9\', \'7\', \'6\', \'1\', \'4\', \'2\', \'3\'], [\'4\', \'2\', \'6\', \'8\', \'5\', \'3\', \'7\', \'9\', \'1\'], [\'7\', \'1\', \'3\', \'9\', \'2\', \'4\', \'8\', \'5\', \'6\'], [\'9\', \'6\', \'1\', \'5\', \'3\', \'7\', \'2\', \'8\', \'4\'], [\'2\', \'8\', \'7\', \'4\', \'1\', \'9\', \'6\', \'3\', \'5\'], [\'3\', \'4\', \'5\', \'2\', \'8\', \'6\', \'1\', \'7\', \'9\'] ] ``` # Note You may define additional helper functions as needed to keep your code organized and readable.","solution":"from typing import List def solve_sudoku(board: List[List[str]]) -> bool: def is_valid(board: List[List[str]], row: int, col: int, num: str) -> bool: for i in range(9): if board[row][i] == num or board[i][col] == num: return False if board[(row // 3) * 3 + i // 3][(col // 3) * 3 + i % 3] == num: return False return True def solve(board: List[List[str]]) -> bool: for row in range(9): for col in range(9): if board[row][col] == \'.\': for num in \'123456789\': if is_valid(board, row, col, num): board[row][col] = num if solve(board): return True board[row][col] = \'.\' return False return True return solve(board)"},{"question":"# Two Sum Problem You are tasked to implement a function `optimized_two_sum` that finds two distinct indices in an array such that the elements at those indices add up to a given target. Input: - A list of integers `nums`. - An integer `target`. Output: - A tuple of two integers, representing the indices of the two elements that add up to the target. If no such elements exist, return `None`. Constraints: - The array will contain at least two integers. - Each input will have exactly one solution. - You may not use the same element twice. - Aim for an algorithm with O(n) time complexity. Example: ``` optimized_two_sum([2, 7, 11, 15], 9) -> (0, 1) optimized_two_sum([1, 3, 4, 2], 6) -> (2, 3) ``` Explanation: In the first example, the elements at indices 0 and 1 are 2 and 7, which add up to the target value of 9. Hence, the output is (0, 1). **Function Signature:** ```python def optimized_two_sum(nums: List[int], target: int) -> Tuple[int, int]: pass ``` Notes: - Ensure your function is efficient and handles large inputs gracefully. - Be mindful of edge cases and optimize your solution for performance and clarity.","solution":"def optimized_two_sum(nums, target): Finds two distinct indices such that the elements add up to the target. Returns a tuple of these indices, or None if no solution exists. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return (num_to_index[complement], i) num_to_index[num] = i return None"},{"question":"# B-Tree Coding Assessment Question Implement a B-Tree class that supports efficient insertion, deletion, and search operations. Your implementation should adhere to the following specifications: Specifications: 1. **Insert a key**: Adds a new key to the B-Tree, maintaining the B-Tree properties. 2. **Delete a key**: Removes a key from the B-Tree, maintaining the B-Tree properties. 3. **Search for a key**: Checks if a key exists in the B-Tree. 4. **Traversal of B-Tree**: Traverse and print all keys in sorted order. Function Signatures: - `def insert_key(self, key: int) -> None` - `def remove_key(self, key: int) -> None` - `def find(self, key: int) -> bool` - `def traverse_tree(self) -> None` Input/Output: - **Insert Operation**: `insert_key(key)` where `key` is an integer. - **Delete Operation**: `remove_key(key)` where `key` is an integer. - **Find Operation**: `find(key) -> bool` where `key` is an integer and the function returns a Boolean indicating the presence or absence of the key. - **Traverse Operation**: `traverse_tree()` which prints all keys in sorted order. Constraints: - Keys will be non-negative integers. - Avoid recurrence of keys. - Assume integer input ranges within typical 32-bit signed integer limits. # Example Scenario: ```python btree = BTree(t_val=3) btree.insert_key(10) btree.insert_key(20) btree.insert_key(5) btree.insert_key(6) btree.insert_key(12) btree.insert_key(30) btree.insert_key(7) btree.insert_key(17) # Output of traverse_tree should print the keys in the sorted order btree.traverse_tree() # Expected: 5 6 7 10 12 17 20 30 assert btree.find(20) == True assert btree.find(15) == False btree.remove_key(6) btree.traverse_tree() # Expected: 5 7 10 12 17 20 30 assert btree.find(6) == False btree.remove_key(12) btree.traverse_tree() # Expected: 5 7 10 17 20 30 ``` Your goal is to complete the implementation of the B-Tree class based on the above specifications. Pay attention to maintaining balance, efficiency, and adhering to the properties of a B-Tree.","solution":"class BTreeNode: def __init__(self, t, leaf=False): self.t = t # Minimum degree (defines the range for number of keys) self.leaf = leaf # True if leaf node, else False self.keys = [] # List of keys self.children = [] # List of child pointers def insert_non_full(self, key): i = len(self.keys) - 1 if self.leaf: # The node is a leaf, just insert the key in the correct position self.keys.append(0) # Temporarily extend the size of keys list while i >= 0 and self.keys[i] > key: self.keys[i + 1] = self.keys[i] i -= 1 self.keys[i + 1] = key else: # The node is not a leaf, find the child which will have the new key while i >= 0 and self.keys[i] > key: i -= 1 i += 1 if len(self.children[i].keys) == 2 * self.t - 1: self.split_child(i, self.children[i]) if self.keys[i] < key: i += 1 self.children[i].insert_non_full(key) def split_child(self, i, y): t = self.t z = BTreeNode(t, y.leaf) self.children.insert(i + 1, z) self.keys.insert(i, y.keys[t - 1]) z.keys = y.keys[t: (2 * t - 1)] y.keys = y.keys[0: (t - 1)] if not y.leaf: z.children = y.children[t: (2 * t)] y.children = y.children[0: t] def traverse(self): for i in range(len(self.keys)): if not self.leaf: self.children[i].traverse() print(self.keys[i], end=\\" \\") if not self.leaf: self.children[-1].traverse() def find(self, key): i = 0 while i < len(self.keys) and key > self.keys[i]: i += 1 if i < len(self.keys) and self.keys[i] == key: return True if self.leaf: return False return self.children[i].find(key) class BTree: def __init__(self, t): self.t = t self.root = BTreeNode(t, True) def insert_key(self, key): root = self.root if len(root.keys) == 2 * self.t - 1: new_root = BTreeNode(self.t, False) new_root.children.append(self.root) new_root.split_child(0, self.root) self.root = new_root new_root.insert_non_full(key) else: root.insert_non_full(key) def traverse_tree(self): if self.root is not None: self.root.traverse() print() def find(self, key): return self.root.find(key) def remove_key(self, key): if not self.root: return self._remove(self.root, key) if len(self.root.keys) == 0: if not self.root.leaf: self.root = self.root.children[0] else: self.root = None def _remove(self, node, key): t = self.t if node.leaf: if key in node.keys: node.keys.remove(key) return idx = self._find_key(node, key) if idx < len(node.keys) and node.keys[idx] == key: if len(node.children[idx].keys) >= t: pred = self._get_pred(node, idx) node.keys[idx] = pred self._remove(node.children[idx], pred) elif len(node.children[idx + 1].keys) >= t: succ = self._get_succ(node, idx) node.keys[idx] = succ self._remove(node.children[idx + 1], succ) else: self._merge(node, idx) self._remove(node.children[idx], key) else: if node.leaf: return flag = (idx == len(node.keys)) if len(node.children[idx].keys) < t: self._fill(node, idx) if flag and idx > len(node.keys): self._remove(node.children[idx - 1], key) else: self._remove(node.children[idx], key) def _find_key(self, node, key): idx = 0 while idx < len(node.keys) and node.keys[idx] < key: idx += 1 return idx def _get_pred(self, node, idx): cur = node.children[idx] while not cur.leaf: cur = cur.children[-1] return cur.keys[-1] def _get_succ(self, node, idx): cur = node.children[idx + 1] while not cur.leaf: cur = cur.children[0] return cur.keys[0] def _merge(self, node, idx): child = node.children[idx] sibling = node.children[idx + 1] t = self.t child.keys.append(node.keys[idx]) child.keys.extend(sibling.keys) if not child.leaf: child.children.extend(sibling.children) node.keys.pop(idx) node.children.pop(idx + 1) def _fill(self, node, idx): t = self.t if idx != 0 and len(node.children[idx - 1].keys) >= t: self._borrow_from_prev(node, idx) elif idx != len(node.keys) and len(node.children[idx + 1].keys) >= t: self._borrow_from_next(node, idx) else: if idx != len(node.keys): self._merge(node, idx) else: self._merge(node, idx - 1) def _borrow_from_prev(self, node, idx): child = node.children[idx] sibling = node.children[idx - 1] child.keys = [node.keys[idx - 1]] + child.keys if not child.leaf: child.children = [sibling.children[-1]] + child.children node.keys[idx - 1] = sibling.keys.pop() if not sibling.leaf: sibling.children.pop() def _borrow_from_next(self, node, idx): child = node.children[idx] sibling = node.children[idx + 1] child.keys.append(node.keys[idx]) if not child.leaf: child.children.append(sibling.children[0]) node.keys[idx] = sibling.keys.pop(0) if not sibling.leaf: sibling.children.pop(0)"},{"question":"# Question Context: You are developing a system for a financial company that often deals with extremely large numbers during interest calculations. Efficiency and the avoidance of overflow in calculations are critical. You are required to implement a function that computes the power of a number using binary exponentiation, both iteratively and recursively, while also supporting modulo operation to ensure numbers do not grow too large. Task: Write two functions `iterative_power(a: int, n: int, mod: int = None)` and `recursive_power(a: int, n: int, mod: int = None)` that calculate `a` raised to the power `n`. If `mod` is provided, the result should be returned modulo `mod`. Requirements: 1. Both functions should have a time complexity of O(log(n)). 2. The iterative version should maintain a space complexity of O(1) whereas the recursive version should have a space complexity of O(log(n)). 3. You should handle edge cases where `a` and `n` could be 0 or negative. Input: * `a` (int): the base number (|a| <= 10^9). * `n` (int): the exponent (|n| <= 10^9). * `mod` (int, optional): an optional modulus (2 <= mod <= 10^9). Output: * Return an integer result of `a` raised to the power `n`, optionally modulo `mod`. Example: ```python print(iterative_power(2, 10, 1000)) # Output: 24 print(recursive_power(2, 10)) # Output: 1024 ``` Constraints: * You may assume all inputs are valid integers within the given bounds. * Handle corner cases such as a=0, n=0, a=1, n=1 appropriately. * For negative `n`, the function should raise a ValueError as negative exponents are out of scope for this task. Note: Demonstrate proper handling of recurrence and iterations. Avoid unnecessary computations to ensure optimal performance.","solution":"def iterative_power(a: int, n: int, mod: int = None) -> int: Computes a^n using the iterative method of binary exponentiation. If mod is provided, computes (a^n) % mod. if n < 0: raise ValueError(\\"Exponent cannot be negative.\\") result = 1 base = a if mod is None else a % mod while n > 0: if n % 2 == 1: result = result * base if mod is None else (result * base) % mod base = base * base if mod is None else (base * base) % mod n //= 2 return result def recursive_power(a: int, n: int, mod: int = None) -> int: Computes a^n using the recursive method of binary exponentiation. If mod is provided, computes (a^n) % mod. if n < 0: raise ValueError(\\"Exponent cannot be negative.\\") if n == 0: return 1 base = a if mod is None else a % mod half_power = recursive_power(base, n // 2, mod) half_power = half_power * half_power if mod is None else (half_power * half_power) % mod if n % 2 == 0: return half_power else: return half_power * base if mod is None else (half_power * base) % mod"},{"question":"# Context: You are responsible for developing a task management system that uses a queue to organize tasks. The queue needs to support basic operations like adding, removing, and peeking tasks, and it needs to handle at least a few edge cases gracefully. # Requirements: You need to implement a queue with the following interface: - `enqueue(task)`: Add a task to the rear. - `dequeue()`: Remove and return the front task. - `peek()`: Return the front task without removing it. - `is_empty()`: Return whether the queue is empty. - `__len__()`: Return the number of tasks in the queue. Additionally, implement a method `reverse(k)` which reverses the order of first `k` tasks in the queue. # Constraints: - The queue should be implemented using a Python list for internal storage (ArrayQueue approach). - The `reverse(k)` method should operate in O(k) time. # Input/Output: - `enqueue(task)`: task is a string representing the task. - `dequeue() -> str`: task string. - `peek() -> str`: task string. - `is_empty() -> bool`: boolean. - `__len__() -> int`: integer representation of the number of tasks. - `reverse(k)`: no return value (modifies the queue in place). # Example: ```python q = TaskQueue() q.enqueue(\\"task1\\") q.enqueue(\\"task2\\") q.enqueue(\\"task3\\") print(q.peek()) # \\"task1\\" print(q.dequeue()) # \\"task1\\" print(len(q)) # 2 q.reverse(2) print(q.dequeue()) # \\"task3\\" print(q.dequeue()) # \\"task2\\" ``` # Implementation: Implement the class `TaskQueue` that satisfies the interface and requirements specified. Be sure to handle edge cases like trying to dequeue from an empty queue or reversing more elements than the queue contains.","solution":"class TaskQueue: def __init__(self): self.queue = [] def enqueue(self, task): self.queue.append(task) def dequeue(self): if self.is_empty(): raise IndexError(\\"dequeue from empty queue\\") return self.queue.pop(0) def peek(self): if self.is_empty(): raise IndexError(\\"peek from empty queue\\") return self.queue[0] def is_empty(self): return len(self.queue) == 0 def __len__(self): return len(self.queue) def reverse(self, k): if k > len(self.queue): k = len(self.queue) self.queue[:k] = reversed(self.queue[:k])"},{"question":"# Context: You are given a custom stack implementation that ensures that all elements are sorted inside the stack, with the highest value always at the top (strictest order). This makes it different from the traditional Last In, First Out (LIFO) stack while integrating a key feature of a priority queue. # Task: Write a function `sort_stack(stack)` which takes an `OrderedStack` instance (as defined in the provided code snippet) and sorts its elements in ascending order (lowest to highest value). The function should return a new `OrderedStack` instance with the ordered elements. # Input/Output: - **Input**: An `OrderedStack` instance `stack` (object containing integer values). - **Output**: A new `OrderedStack` instance with elements sorted in ascending order. ```python # Example: # Given stack: # Stack: [3, 1, 2] # After sorting: # New Stack: [1, 2, 3] # Example code to further illustrate the desired function: def sort_stack(stack): # Your implementation here # Create an instance of OrderedStack os = OrderedStack() os.push(3) os.push(1) os.push(2) # Call sort_stack and verify sorted_os = sort_stack(os) print([sorted_os.pop() for _ in range(sorted_os.size())]) # Output should be [1, 2, 3] ``` # Constraints: - The elements in the stack are integers. - Elements within the stack can contain duplicates. # Notes: - Do not use any additional data structures except for native Python data structures and the provided `OrderedStack` structure. - Focus on maintaining efficiency with respect to both time and space complexity.","solution":"class OrderedStack: def __init__(self): self.stack = [] def push(self, value): self.stack.append(value) def pop(self): if not self.is_empty(): return self.stack.pop() return None def peek(self): if not self.is_empty(): return self.stack[-1] return None def is_empty(self): return len(self.stack) == 0 def size(self): return len(self.stack) def sort_stack(stack): aux_stack = OrderedStack() while not stack.is_empty(): current = stack.pop() while not aux_stack.is_empty() and aux_stack.peek() > current: stack.push(aux_stack.pop()) aux_stack.push(current) sorted_stack = OrderedStack() while not aux_stack.is_empty(): sorted_stack.push(aux_stack.pop()) return sorted_stack"},{"question":"You are tasked with implementing a maximum flow algorithm for an application that models a city\'s water distribution network. Given the capacities of the pipes (edges) between different facilities (nodes), your objective is to determine the maximum amount of water that can be transported from the city\'s water source to a designated facility. # Function Signature ```python def max_water_flow(capacity: List[List[int]], source: int, sink: int) -> int: Parameters: - capacity: A 2D list representing the capacity of each pipe (edge) between facilities (nodes) in the network. capacity[i][j] represents the capacity of the pipe from facility i to facility j. - source: An integer representing the index of the water source node. - sink: An integer representing the index of the target facility node. Returns: - An integer representing the maximum amount of water that can be transported from the source to the sink. pass ``` # Input * `capacity`: A 2D list where capacity[i][j] represents the capacity of the pipe from facility i to facility j. * `source`: An integer, the index of the water source node. * `sink`: An integer, the index of the target facility node. # Output * An integer representing the maximum water flow from the source to the sink. # Constraints * `1 <= len(capacity) <= 100`: The number of facilities will not exceed 100. * `0 <= capacity[i][j] <= 1000`: Each pipe\'s capacity will be a non-negative integer not exceeding 1000. * The source and sink will always be valid indices within the range of facilities. # Example ```python capacity = [ [0, 10, 10, 0, 0, 0], [0, 0, 1, 10, 0, 0], [0, 0, 0, 0, 10, 0], [0, 0, 0, 0, 0, 10], [0, 0, 0, 0, 0, 10], [0, 0, 0, 0, 0, 0] ] source = 0 sink = 5 print(max_water_flow(capacity, source, sink)) # Output: 20 ``` # Requirements * Implement one of the maximum flow algorithms (Ford-Fulkerson, Edmonds-Karp, or Dinic) to complete the `max_water_flow` function. * Make sure to handle edge cases such as no path from the source to the sink. * Aim for efficiency given the constraints.","solution":"from typing import List from collections import deque def bfs(residual_capacity: List[List[int]], source: int, sink: int, parent: List[int]) -> bool: visited = [False] * len(residual_capacity) queue = deque([source]) visited[source] = True while queue: u = queue.popleft() for v, capacity in enumerate(residual_capacity[u]): if not visited[v] and capacity > 0: queue.append(v) visited[v] = True parent[v] = u if v == sink: return True return False def max_water_flow(capacity: List[List[int]], source: int, sink: int) -> int: residual_capacity = [row[:] for row in capacity] parent = [-1] * len(capacity) max_flow = 0 while bfs(residual_capacity, source, sink, parent): path_flow = float(\'Inf\') s = sink while s != source: path_flow = min(path_flow, residual_capacity[parent[s]][s]) s = parent[s] v = sink while v != source: u = parent[v] residual_capacity[u][v] -= path_flow residual_capacity[v][u] += path_flow v = parent[v] max_flow += path_flow return max_flow"},{"question":"# Scenario: You are working on a project that involves manipulating singly linked lists. During the development, you encounter a situation where you need to delete a node from the list efficiently. Given the constraints of your project, you only have access to the node that needs to be deleted and not the entire list. # Task: Implement a function `delete_node` that deletes a given node (excluding the tail) from a singly linked list. The function signature should be: ```python def delete_node(node): ``` # Expected Input: - A non-tail node in a singly linked list. # Expected Output: - The linked list should have the node removed by modifying the given node directly. # Constraints: - You should **not** access any nodes before the given node. - The function should perform the deletion in constant time O(1). - Do **not** use extra space beyond O(1). # Error Handling: - If the node is `None` or the tail, the function should raise a `ValueError`. # Performance Requirements: - Time complexity should be O(1). - Space complexity should be O(1). # Example: Suppose you have a linked list: `1 -> 2 -> 3 -> 4` and you are given the node with value `3`. The function call should transform the list to `1 -> 2 -> 4`. # Unit Testing: You should also write tests to ensure that your function works correctly. Validate: 1. Deleting nodes from the middle of the list. 2. Attempting to delete the tail node. 3. Attempting to delete a `None` node. Here is a sample implementation of the linked list node class and the testing framework: ```python class Node: def __init__(self, x): self.val = x self.next = None ``` The test suite should use the `unittest` framework as exemplified: ```python import unittest class TestSuite(unittest.TestCase): def test_delete_node(self): # make linkedlist 1 -> 2 -> 3 -> 4 head = Node(1) curr = head for i in range(2, 6): curr.next = Node(i) curr = curr.next # node3 = 3 node3 = head.next.next # after delete_node => 1 -> 2 -> 4 delete_node(node3) curr = head self.assertEqual(1, curr.val) curr = curr.next self.assertEqual(2, curr.val) curr = curr.next self.assertEqual(4, curr.val) curr = curr.next self.assertEqual(5, curr.val) tail = curr self.assertIsNone(tail.next) self.assertRaises(ValueError, delete_node, tail) self.assertRaises(ValueError, delete_node, tail.next) if __name__ == \'__main__\': unittest.main() ```","solution":"class Node: def __init__(self, x): self.val = x self.next = None def delete_node(node): Deletes a given node (excluding the tail) from the singly linked list. :param node: Node to be deleted :raises ValueError: if the node is None or the tail if node is None or node.next is None: raise ValueError(\\"Cannot delete this node\\") node.val = node.next.val node.next = node.next.next"},{"question":"As a part of a software development team, you are tasked with implementing a function to search for specific employee records based on their ID in a sorted list of employee IDs. For this task, you will use the Binary Search algorithm. # Function Signature ```python def search_employee_id(employee_ids: List[int], target_id: int) -> int: Searches for a target employee ID in a sorted list of employee IDs. Args: employee_ids (List[int]): A sorted (in ascending order) list of employee IDs. target_id (int): The employee ID to search for. Returns: int: The index of the target ID if found, otherwise -1. pass ``` # Input - `employee_ids`: A list of integers representing sorted employee IDs. - `target_id`: An integer representing the employee ID to be searched. # Output - Returns the index of the `target_id` in `employee_ids` if found. - Returns `-1` if the `target_id` is not found in the list. # Constraints - The list `employee_ids` is non-empty and sorted in ascending order. - The list can have up to (10^6) employee IDs. - All employee IDs are unique integers. - The function must run in O(log n) time complexity. # Example ```python employee_ids = [1001, 1002, 1010, 1023, 1034, 1050, 1060] target_id = 1034 output = search_employee_id(employee_ids, target_id) # Expected output: 4 target_id = 1100 output = search_employee_id(employee_ids, target_id) # Expected output: -1 ```","solution":"from typing import List def search_employee_id(employee_ids: List[int], target_id: int) -> int: Searches for a target employee ID in a sorted list of employee IDs using Binary Search. Args: employee_ids (List[int]): A sorted (in ascending order) list of employee IDs. target_id (int): The employee ID to search for. Returns: int: The index of the target ID if found, otherwise -1. left, right = 0, len(employee_ids) - 1 while left <= right: mid = (left + right) // 2 if employee_ids[mid] == target_id: return mid elif employee_ids[mid] < target_id: left = mid + 1 else: right = mid - 1 return -1"},{"question":"**Scenario:** You are given a list of non-negative integers. Your task is to implement an optimized Radix Sort function to sort this list. Given the potential inefficiencies with varying lengths of digits, ensure your function efficiently handles different edge cases. **Function Signature:** ```python def optimized_radix_sort(arr: List[int]) -> List[int]: pass ``` **Expected Input:** - A list of non-negative integers. **Expected Output:** - A list of non-negative integers, sorted in ascending order. **Constraints:** - The list can have up to 10^5 integers. - Each integer will be in the range 0 to 10^9. **Requirements:** - Implement the sorting function ensuring it is optimized for both time and space complexity. - The function should handle edge cases such as empty lists, lists with one element, and lists where all elements are identical. - Negative integers are not within the expected input set. **Performance:** - Your implementation should aim to run in O(nk + n) time complexity and use O(n + k) space complexity efficiently.","solution":"from typing import List def optimized_radix_sort(arr: List[int]) -> List[int]: def counting_sort(arr, exp): n = len(arr) output = [0] * n count = [0] * 10 # Count the occurrences for i in range(n): index = (arr[i] // exp) % 10 count[index] += 1 # Transform count into the actual position of the digit for i in range(1, 10): count[i] += count[i - 1] # Build the output array i = n - 1 while i >= 0: index = (arr[i] // exp) % 10 output[count[index] - 1] = arr[i] count[index] -= 1 i -= 1 # Copy the output array to arr, so that arr now contains sorted numbers for i in range(n): arr[i] = output[i] # Main radix sort if not arr: return arr max1 = max(arr) exp = 1 while max1 // exp > 0: counting_sort(arr, exp) exp *= 10 return arr"},{"question":"# Bit Manipulation Utility Development **Context**: You are developing a low-level data processor where bit manipulation is a critical part. You need to ensure efficient and accurate manipulation of individual bits of integers to manage memory usage effectively. # Problem Statement Implement a class `BitManipulator` with the following methods to manipulate bits of an integer: 1. **get_bit**: ```python def get_bit(self, num: int, i: int) -> int: pass ``` - **Description**: Returns the bit value (0 or 1) at the i-th position of `num`. - **Input**: `num` (int), `i` (non-negative int representing bit position) - **Output**: Returns `0` or `1` 2. **set_bit**: ```python def set_bit(self, num: int, i: int) -> int: pass ``` - **Description**: Sets the i-th bit of `num` to `1`. - **Input**: `num` (int), `i` (non-negative int representing bit position) - **Output**: Returns the integer with the i-th bit set to `1` 3. **clear_bit**: ```python def clear_bit(self, num: int, i: int) -> int: pass ``` - **Description**: Clears the i-th bit of `num` to `0`. - **Input**: `num` (int), `i` (non-negative int representing bit position) - **Output**: Returns the integer with the i-th bit cleared to `0` 4. **update_bit**: ```python def update_bit(self, num: int, i: int, bit: int) -> int: pass ``` - **Description**: Updates the i-th bit of `num` to the provided `bit` value (either `0` or `1`). - **Input**: `num` (int), `i` (non-negative int representing bit position), `bit` (either `0` or `1`) - **Output**: Returns the integer with the i-th bit updated accordingly. # Constraints - The position `i` will always be within the range of integer bit size (0 to 31 for a 32-bit integer). - The `bit` parameter in `update_bit` will always be `0` or `1`. # Performance Requirements - All operations should run in constant time, O(1). - Use minimal additional memory. # Example ```python bm = BitManipulator() # Get bit assert bm.get_bit(5, 0) == 1 assert bm.get_bit(5, 1) == 0 # Set bit assert bm.set_bit(5, 1) == 7 # Clear bit assert bm.clear_bit(7, 1) == 5 # Update bit assert bm.update_bit(5, 1, 1) == 7 assert bm.update_bit(7, 1, 0) == 5 ```","solution":"class BitManipulator: def get_bit(self, num: int, i: int) -> int: Returns the bit value (0 or 1) at the i-th position of num. return (num >> i) & 1 def set_bit(self, num: int, i: int) -> int: Sets the i-th bit of num to 1. return num | (1 << i) def clear_bit(self, num: int, i: int) -> int: Clears the i-th bit of num to 0. return num & ~(1 << i) def update_bit(self, num: int, i: int, bit: int) -> int: Updates the i-th bit of num to the provided bit value (0 or 1). return (num & ~(1 << i)) | (bit << i)"},{"question":"Coding Assessment Question # Scenario You are on a team developing an advanced indexing system for a massive dataset consisting of numerical data points. Efficiency of search operations in this dataset is critical due to the large volume of data. # Task Implement a search function using an optimized **Interpolation Search** algorithm to find specific data points in a sorted, uniformly distributed array of integers. # Details * **Function Signature:** `def find_position(arr: List[int], key: int) -> int:` * **Input:** * `arr` (List[int]): A sorted list of integers representing the dataset. * `key` (int): The integer value to be found in the array. * **Output:** * Returns the index of `key` in the array if found. * Returns `-1` if the `key` is not present in the array. * **Constraints:** * 1 <= len(arr) <= 10^5 (The array will contain between 1 and 100,000 elements) * The array `arr` is sorted in increasing order and elements are uniformly distributed. * -10^9 <= arr[i], key <= 10^9 (Elements in the array and key can be very large, both positive and negative) # Example ```python assert find_position([10, 20, 30, 40, 50], 40) == 3 assert find_position([5, 15, 25, 35, 45, 55], 15) == 1 assert find_position([1, 3, 5, 7, 9], 4) == -1 ``` # Notes * Ensure the algorithm handles edge cases effectively. * The algorithm should be optimized for performance given the constraints. * Consider potential overflow issues with large integers during interpolation calculations.","solution":"from typing import List def find_position(arr: List[int], key: int) -> int: Perform an Interpolation Search to find the position of \'key\' in a sorted list \'arr\'. :param arr: A list of sorted, uniformly distributed integers. :param key: The integer to search for. :return: The index of \'key\' if found, otherwise -1. low, high = 0, len(arr) - 1 while low <= high and key >= arr[low] and key <= arr[high]: # To avoid division by zero if arr[high] == arr[low] if arr[low] == arr[high]: if arr[low] == key: return low else: return -1 # Estimate the position of the key pos = low + ((high - low) // (arr[high] - arr[low]) * (key - arr[low])) # Check if we found the key if arr[pos] == key: return pos if arr[pos] < key: low = pos + 1 else: high = pos - 1 return -1"},{"question":"Objective Given the provided graph representation, write a method to determine if there is a path between two nodes in the directed graph. Problem Description You should implement a method in the `DirectedGraph` class that checks if there exists a path from a given source node to a target node. Implement the following method: ```python def has_path(self, source_name: str, target_name: str) -> bool: Determine if there is a path from source_name to target_name in the directed graph. :param source_name: Name of the source node. :param target_name: Name of the target node. :return: True if there is a path, False otherwise. ``` Requirements 1. **Input**: - Two strings representing the names of the source and target nodes. - The names correspond to existing nodes in the graph. 2. **Output**: - Return `True` if there is a path from the node named `source_name` to the node named `target_name`. - Return `False` otherwise. 3. **Constraints**: - The graph is non-empty and contains at least the source and target nodes. 4. **Performance**: - Aim for efficient traversal with respect to both time and space complexities. Example Given the graph: ```json { \\"A\\": [\\"B\\", \\"C\\"], \\"B\\": [\\"C\\"], \\"C\\": [\\"D\\"], \\"D\\": [] } ``` - `has_path(\\"A\\", \\"D\\")` should return `True` (exists a path: A -> C -> D) - `has_path(\\"A\\", \\"B\\")` should return `True` (exists a path: A -> B) - `has_path(\\"B\\", \\"A\\")` should return `False` (no path from B to A) Hints - Consider using Depth-First Search (DFS) or Breadth-First Search (BFS) to implement this method. - Keep track of visited nodes to prevent cycles and redundant checks. Good luck and happy coding!","solution":"class DirectedGraph: def __init__(self, graph): self.graph = graph def has_path(self, source_name: str, target_name: str) -> bool: Determine if there is a path from source_name to target_name in the directed graph. :param source_name: Name of the source node. :param target_name: Name of the target node. :return: True if there is a path, False otherwise. visited = set() return self.dfs(source_name, target_name, visited) def dfs(self, current, target, visited): if current == target: return True if current in visited: return False visited.add(current) for neighbor in self.graph.get(current, []): if self.dfs(neighbor, target, visited): return True return False"},{"question":"# Binary Heap Coding Challenge Objective Implement a min heap data structure that supports fast insertion and removal of the minimum element while maintaining the heap properties. Implementation Requirements You should implement a class `MinHeap` with the following methods: 1. **insert(val)** * Inserts an integer `val` into the heap. * Ensures the heap property is maintained. * **Input**: Integer `val` * **Output**: None 2. **remove_min()** * Removes the smallest value from the heap. * Ensures the heap property is maintained. * **Input**: None * **Output**: Integer, the smallest value 3. **get_min()** * Returns the smallest value without removing it. * **Input**: None * **Output**: Integer, the smallest value Example Usage ```python # Create a new instance of MinHeap heap = MinHeap() # Insert elements heap.insert(10) heap.insert(5) heap.insert(2) heap.insert(8) # Get the minimum value print(heap.get_min()) # Output: 2 # Remove the minimum value print(heap.remove_min()) # Output: 2 # Get the new minimum value print(heap.get_min()) # Output: 5 ``` Constraints * The heap should support up to `10^6` elements. * All elements will be integers in the range `[-10^9, 10^9]`. * You must ensure O(log N) time complexity for both `insert` and `remove_min`. Notes * You must handle edge cases, such as removing the minimum value from an empty heap. * The heap should be implemented using an array-based approach.","solution":"class MinHeap: def __init__(self): self.heap = [] def insert(self, val): # Add value to the end of the heap self.heap.append(val) # Then, percolate up to maintain heap property self._percolate_up(len(self.heap) - 1) def remove_min(self): if not self.heap: raise IndexError(\'remove_min(): empty heap\') # Swap the root with the last element self._swap(0, len(self.heap) - 1) # Remove the last element (former root) min_val = self.heap.pop() # Percolate down the new root to maintain heap property if self.heap: self._percolate_down(0) return min_val def get_min(self): if not self.heap: raise IndexError(\'get_min(): empty heap\') return self.heap[0] def _percolate_up(self, index): parent_index = (index - 1) // 2 if index > 0 and self.heap[index] < self.heap[parent_index]: self._swap(index, parent_index) self._percolate_up(parent_index) def _percolate_down(self, index): child_index = 2 * index + 1 if child_index < len(self.heap): # Check if the right child exists and is smaller than the left child if child_index + 1 < len(self.heap) and self.heap[child_index + 1] < self.heap[child_index]: child_index += 1 # Swap if the current node is larger than the smallest child if self.heap[index] > self.heap[child_index]: self._swap(index, child_index) self._percolate_down(child_index) def _swap(self, i, j): self.heap[i], self.heap[j] = self.heap[j], self.heap[i]"},{"question":"You are working with streaming data and need to calculate the moving average of the data in real time. Design a class **EfficientMovingAverage** that efficiently computes the moving average over a fixed-size sliding window using the following specifications: Requirements: 1. **Class Initialization**: `EfficientMovingAverage(size: int)` - Initialize the instance with a window size. - Throw an error if the window size is non-positive. 2. **Method**: `next(val: float) -> float` - Add a new value `val` to the sliding window. - Return the current moving average of the values within the window. - Ensure this method operates in (O(1)) time complexity for both adding the value and computing the average. Example: ```python # Initialization ema = EfficientMovingAverage(3) # Stream of data print(ema.next(1)) # --> Output: 1.0 print(ema.next(10)) # --> Output: 5.5 print(ema.next(3)) # --> Output: 4.666666666666667 print(ema.next(5)) # --> Output: 6.0 ``` Constraints: - The window size `size` is a positive integer. - The input value `val` can be any float number (positive, negative, or zero). Performance Requirements: - The `next` method should operate in constant time (O(1)). Your task is to implement the `EfficientMovingAverage` class to meet the above specifications in Python.","solution":"from collections import deque class EfficientMovingAverage: def __init__(self, size: int): if size <= 0: raise ValueError(\\"Window size must be greater than 0\\") self.size = size self.window = deque() self.sum = 0.0 def next(self, val: float) -> float: if len(self.window) == self.size: self.sum -= self.window.popleft() self.window.append(val) self.sum += val return self.sum / len(self.window) # Example usage: # ema = EfficientMovingAverage(3) # print(ema.next(1)) # --> Output: 1.0 # print(ema.next(10)) # --> Output: 5.5 # print(ema.next(3)) # --> Output: 4.666666666666667 # print(ema.next(5)) # --> Output: 6.0"},{"question":"Objective Write a function to invert a given `n x n` matrix. Your implementation should particularly focus on matrices larger than `2 x 2`, utilizing the fundamental principles of matrix inversion as analyzed above. Ensure your code handles edge cases and invalid inputs appropriately. Function Signature ```python def invert_matrix(matrix: List[List[float]]) -> List[List[float]]: ``` Input - `matrix`: A list of lists of floats representing an `n x n` matrix (`2 <= n <= 10`). Output - Returns the inverted matrix as a list of lists of floats. - If the matrix is not invertible, return a single value matrix `[[-1]]`. Constraints - The input matrix will contain only real numbers. - Diagonal dominance is not guaranteed. - The size of the matrix will be at least `2 x 2`. Requirements 1. Your function should first validate if the input is a valid square matrix. 2. If the matrix is `2 x 2`, handle it directly with a simplified approach. 3. For larger matrices, follow these steps: - Calculate the matrix of minors. - Form the cofactor matrix. - Transpose the cofactor matrix. - Compute the determinant of the original matrix and multiply the transposed cofactor matrix by the reciprocal of this determinant. Examples ```python # Example 1 matrix = [ [4, 7], [2, 6] ] assert invert_matrix(matrix) == [ [0.6, -0.7], [-0.2, 0.4] ] # Example 2 matrix = [ [1, 2, 3], [0, 1, 4], [5, 6, 0] ] assert invert_matrix(matrix) == [ [-24, 18, 5], [20, -15, -4], [-5, 4, 1] ] ``` Notes 1. Handle edge cases such as non-square matrices, singular matrices, and dimensions not within the specified range. 2. Aim for an optimal solution considering the constraints. 3. Do NOT use any external libraries for matrix handling.","solution":"from typing import List def get_matrix_minor(matrix: List[List[float]], i: int, j: int) -> List[List[float]]: return [row[:j] + row[j+1:] for row in (matrix[:i] + matrix[i+1:])] def get_matrix_determinant(matrix: List[List[float]]) -> float: # Base case for 2x2 matrix if len(matrix) == 2: return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0] determinant = 0 for c in range(len(matrix)): determinant += ((-1)**c) * matrix[0][c] * get_matrix_determinant(get_matrix_minor(matrix, 0, c)) return determinant def get_matrix_inverse(matrix: List[List[float]]) -> List[List[float]]: determinant = get_matrix_determinant(matrix) if determinant == 0: return [[-1]] if len(matrix) == 2: return [[matrix[1][1] / determinant, -1 * matrix[0][1] / determinant], [-1 * matrix[1][0] / determinant, matrix[0][0] / determinant]] cofactors = [] for r in range(len(matrix)): cofactor_row = [] for c in range(len(matrix)): minor = get_matrix_minor(matrix, r, c) cofactor_row.append(((-1)**(r+c)) * get_matrix_determinant(minor)) cofactors.append(cofactor_row) cofactors = list(map(list, zip(*cofactors))) for r in range(len(cofactors)): for c in range(len(cofactors)): cofactors[r][c] = cofactors[r][c] / determinant return cofactors def invert_matrix(matrix: List[List[float]]) -> List[List[float]]: if not matrix or not all(len(row) == len(matrix) for row in matrix): return [[-1]] return get_matrix_inverse(matrix)"},{"question":"# Bogo Sort Implementation and Optimization Context In this exercise, you are asked to implement the Bogo Sort algorithm in Python. The Bogo Sort is a highly inefficient sorting algorithm that relies on shuffling the array until it gets sorted. Requirements 1. Implement the `bogo_sort` function with an added feature that counts and returns the number of iterations it took to sort the array. 2. Implement a helper function `is_sorted` that checks if an array is sorted in ascending order. 3. Assume the array contains only integers and can be of any length between 1 and 15. 4. Avoid using any built-in sort functions. # Function Specification 1. **Function Name**: `bogo_sort` 2. **Input**: List of integers `arr` of length `n` where `1 <= n <= 15`. 3. **Output**: Tuple containing the sorted array and the number of iterations (shuffles) needed to sort the array. # Constraints - Input array length will be between 1 and 15 inclusive. - The array might contain duplicate values. Example ```python # Example 1: input: [3, 2, 1, 5] output: ([1, 2, 3, 5], 24) # Example 2: input: [1, 2, 3, 4] output: ([1, 2, 3, 4], 0) # Example 3: input: [4, 5, 3, 2, 1] output: ([1, 2, 3, 4, 5], 1208) ``` **Note:** The number of iterations in the output examples is hypothetical. It demonstrates that the function should return a sorted array and the actual number of iterations it took to sort that array. Edge Cases - Single element array. - An array with all elements being the same. # Additional Challenge As an additional challenge, try to implement a `pseudo_bogo_sort` that might include slight optimizations, such as checking subarrays for partial ordering before shuffling the entire list. Implement your solution below: ```python import random def bogo_sort(arr): iteration = 0 def is_sorted(arr): i = 0 while i+1 < len(arr): if arr[i] > arr[i+1]: return False i += 1 return True while not is_sorted(arr): random.shuffle(arr) iteration += 1 return arr, iteration # Implement any additional code and test cases ```","solution":"import random def bogo_sort(arr): Bogo sort algorithm that sorts the array by shuffling until sorted. Returns the sorted array and the number of shuffles (iterations) taken. iterations = 0 def is_sorted(arr): Helper function to check if the array is sorted in ascending order. for i in range(len(arr) - 1): if arr[i] > arr[i + 1]: return False return True while not is_sorted(arr): random.shuffle(arr) iterations += 1 return arr, iterations"},{"question":"# Finding the Intersection Node of Two Singly Linked Lists # Objective In this coding challenge, you are required to implement a function that finds the intersection node of two singly linked lists. The nodes of the linked lists have unique identities even if they may contain the same values. # Problem Statement Given two singly linked lists, determine the node at which the two lists intersect. If the lists do not intersect, return `None`. # Input Format - The function will receive two head nodes of linked lists (`h1` and `h2`). # Output Format - Return the intersecting node if exists, otherwise, return `None`. # Constraints - You may assume there are no cycles anywhere in the entire linked structure. - Nodes are uniquely identifiable by their memory locations. - The linked lists may overlap only partially after the intersection point. # Example Consider the two linked lists: ``` List 1: 1 -> 3 -> 5 7 -> 9 -> 11 / List 2: 2 -> 4 -> 6 ``` - The function should return the node with value `7` (assuming unique address matching). # Edge Cases - One or both lists being empty. - Lists with no intersection. ```python class Node: def __init__(self, val=None): self.val = val self.next = None def intersection(h1: Node, h2: Node) -> Node: Determine the node at which two singly linked lists intersect. # Implement your function here. pass # Example test a1 = Node(1) b1 = Node(3) c1 = Node(5) d = Node(7) a2 = Node(2) b2 = Node(4) c2 = Node(6) e = Node(9) f = Node(11) a1.next = b1 b1.next = c1 c1.next = d a2.next = b2 b2.next = c2 c2.next = d d.next = e e.next = f print(intersection(a1, a2).val) # Should output 7 ``` # Note 1. Ensure that your solution is efficient with respect to both time and space complexity. 2. Handle all potential edge cases as outlined.","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def intersection(h1: Node, h2: Node) -> Node: Determine the node at which two singly linked lists intersect. Args: h1 (Node): The head of the first singly linked list. h2 (Node): The head of the second singly linked list. Returns: Node: The intersecting node if it exists, otherwise None. if not h1 or not h2: return None # Get the lengths of the two linked lists def get_length(head): length = 0 current = head while current: length += 1 current = current.next return length length1 = get_length(h1) length2 = get_length(h2) # Align the start of the longer list with the shorter list if length1 > length2: for _ in range(length1 - length2): h1 = h1.next else: for _ in range(length2 - length1): h2 = h2.next # Move both pointers until we find the intersection while h1 and h2: if h1 == h2: return h1 h1 = h1.next h2 = h2.next return None"},{"question":"# Scenario You are working on analyzing user activity logs, where each log entry is represented as an integer indicating the minute of activity. The logs are expected to be sorted in ascending order and contain no duplicate entries. To create a concise summary, you need to generate ranges of contiguous minutes to report periods of continuous activity. # Question Write a function `summarize_ranges` that takes a sorted list of unique integers and returns a list of strings summarizing the contiguous ranges of numbers. # Function Signature ```python def summarize_ranges(array: List[int]) -> List[str]: pass ``` # Input * `array` (List[int]): A sorted list of unique integers representing activity times. # Output * List[str]: A list of strings, each representing a range of contiguous numbers from the input list. Each range should be formatted as \\"start-end\\" if it covers more than one number, or simply \\"start\\" if it covers a single number. # Constraints * The length of the list `n` will be between 1 and 10^4. * The list is sorted in ascending order and has no duplicates. * Each integer in the list is within the range of -10^6 to 10^6. # Example ```python from typing import List def summarize_ranges(array: List[int]) -> List[str]: res = [] if len(array) == 1: return [str(array[0])] it = iter(array) start = end = next(it) for num in it: if num - end == 1: end = num else: res.append((start, end) if start != end else (start,)) start = end = num res.append((start, end) if start != end else (start,)) return [f\\"{r[0]}-{r[1]}\\" if len(r) > 1 else str(r[0]) for r in res] # Example Usage print(summarize_ranges([0, 1, 2, 4, 5, 7])) # Output: [\\"0-2\\", \\"4-5\\", \\"7\\"] ``` # Explanation * For the input `[0, 1, 2, 4, 5, 7]`, the function should output `[\\"0-2\\", \\"4-5\\", \\"7\\"]` indicating the ranges `0 to 2`, `4 to 5`, and the single element `7`. # Notes * Consider handling arrays with different lengths and structures efficiently, given the constraints.","solution":"from typing import List def summarize_ranges(array: List[int]) -> List[str]: if not array: return [] result = [] start = array[0] for i in range(1, len(array)): if array[i] != array[i-1] + 1: if start == array[i-1]: result.append(f\\"{start}\\") else: result.append(f\\"{start}-{array[i-1]}\\") start = array[i] if start == array[-1]: result.append(f\\"{start}\\") else: result.append(f\\"{start}-{array[-1]}\\") return result"},{"question":"# AVL Tree Deletion Given the implementation of the `AvlTree` in the above snippet, extend the functionality by implementing the deletion of a node while maintaining the AVL tree\'s properties. # Objective Write a method `delete(self, key)` in the `AvlTree` class that removes a node with the specified `key`. # Function Signature ```python def delete(self, key): pass ``` # Requirements 1. The method should maintain the tree\'s balanced state after deletion. 2. You should rotate the tree as needed to preserve the AVL properties. 3. If the specified `key` does not exist in the tree, the tree should remain unchanged. # Constraints - The `key` will be an integer. - Multiple deletions and insertions will be tested on the tree. # Expected Input and Output - **Input**: A sequence of insertions and deletions. E.g., ```python avl = AvlTree() avl.insert(10) avl.insert(20) avl.insert(30) avl.delete(20) ``` - **Output**: The modified AVL tree should remain balanced and should have in-order traversal reflecting the correct sequence of remaining nodes. # Scenario Consider you are maintaining a balanced search tree for quick lookups, insertions, and deletions of records. Each record is represented by an integer key. Implementing a robust deletion function ensures the tree\'s efficiency even after multiple modifications. # Example ```python # Create AVL Tree avl = AvlTree() # Insert nodes avl.insert(10) avl.insert(20) avl.insert(30) avl.insert(40) avl.insert(50) avl.insert(25) # Deletion avl.delete(30) # In-order Traversal after deletion assert avl.in_order_traverse() == [10, 20, 25, 40, 50] ``` **Note**: The resulting tree must maintain its AVL property through proper rebalance after deletions. # Hint - To delete a node, consider: 1. Nodes with zero or one child. 2. Nodes with two children (use in-order predecessor or successor). 3. Ensure rebalancing after deleting and updating subtree heights and balance factors.","solution":"class TreeNode: def __init__(self, key, height=1): self.key = key self.left = None self.right = None self.height = height class AvlTree: def _height(self, node): if not node: return 0 return node.height def _update_height(self, node): if not node: return node.height = max(self._height(node.left), self._height(node.right)) + 1 def _balance_factor(self, node): if not node: return 0 return self._height(node.left) - self._height(node.right) def _rotate_left(self, y): x = y.right T2 = x.left x.left = y y.right = T2 self._update_height(y) self._update_height(x) return x def _rotate_right(self, x): y = x.left T2 = y.right y.right = x x.left = T2 self._update_height(x) self._update_height(y) return y def _rebalance(self, node): self._update_height(node) balance = self._balance_factor(node) if balance > 1: if self._balance_factor(node.left) < 0: node.left = self._rotate_left(node.left) return self._rotate_right(node) if balance < -1: if self._balance_factor(node.right) > 0: node.right = self._rotate_right(node.right) return self._rotate_left(node) return node def _insert(self, node, key): if not node: return TreeNode(key) elif key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) return self._rebalance(node) def insert(self, key): if not hasattr(self, \'root\'): self.root = None self.root = self._insert(self.root, key) def _min_value_node(self, node): if node is None or node.left is None: return node return self._min_value_node(node.left) def _delete_node(self, root, key): if not root: return root if key < root.key: root.left = self._delete_node(root.left, key) elif key > root.key: root.right = self._delete_node(root.right, key) else: if root.left is None: temp = root.right root = None return temp elif root.right is None: temp = root.left root = None return temp temp = self._min_value_node(root.right) root.key = temp.key root.right = self._delete_node(root.right, temp.key) if root is None: return root return self._rebalance(root) def delete(self, key): if not hasattr(self, \'root\'): self.root = None self.root = self._delete_node(self.root, key) def in_order_traverse(self): def _in_order_traverse(node, acc): if node: _in_order_traverse(node.left, acc) acc.append(node.key) _in_order_traverse(node.right, acc) result = [] _in_order_traverse(self.root, result) return result"},{"question":"# Problem: ZigZag Iterator for Multiple Lists You are given an arbitrary number of lists and need to implement a `ZigZag Iterator` that alternates elements from each list until all lists are exhausted. # Function Signature ```python class ZigZagIterator: def __init__(self, *vectors: List[int]): Initialize your data structure here. :type *vectors: List[List[int]] def next(self) -> int: Fetch the next element in the zigzag order. :rtype: int def has_next(self) -> bool: Check if there are any more elements to return in the zigzag order. :rtype: bool ``` # Example ```python lists = [[1, 2], [3, 4, 5, 6], [7, 8, 9]] iterator = ZigZagIterator(*lists) result = [] while iterator.has_next(): result.append(iterator.next()) # Expected output: [1, 3, 7, 2, 4, 8, 5, 9, 6] print(result) ``` # Input * Multiple lists of integers (e.g., `[[1, 2], [3, 4, 5, 6], [7, 8, 9]]`). # Output * An integer returned by each successive call to `next`. # Constraints * At least one list is non-empty. * The provided input lists can contain varying numbers of integer elements, including zero. # Requirements - **Initialization**: The constructor must initialize the structure with the input lists. - **Next**: The `next()` method should return the next integer in the zigzag order. - **Has Next**: The `has_next()` method should check if any more elements are available in zigzag order. # Corner Cases - If all lists are empty, `has_next()` should return `False` immediately. - Lists with different lengths should cycle correctly through remaining elements of longer lists. Implement the `ZigZagIterator` class according to the above specifications.","solution":"class ZigZagIterator: def __init__(self, *vectors): Initialize your data structure here. :type *vectors: List[List[int]] self.vectors = vectors self.queue = [(i, 0) for i in range(len(vectors)) if vectors[i]] def next(self): Fetch the next element in the zigzag order. :rtype: int if self.has_next(): i, j = self.queue.pop(0) value = self.vectors[i][j] if j + 1 < len(self.vectors[i]): self.queue.append((i, j + 1)) return value raise StopIteration(\\"No more elements in iterator\\") def has_next(self): Check if there are any more elements to return in the zigzag order. :rtype: bool return bool(self.queue)"},{"question":"# Searchable Word Dictionary You are tasked with creating an efficient system for adding and searching words. The system must support two main operations: - `add_word(word: str)` - Adds a word to the dictionary. - `search(word: str) -> bool` - Searches for the word in the dictionary, where the word can contain the character `\'.\'` to represent any letter. Input and Output Format * **add_word**: - Input: A string `word` (1 <= len(word) <= 500). The word consists only of lowercase English letters. - Output: None * **search**: - Input: A string `word` (1 <= len(word) <= 500). The word consists of lowercase English letters or the wildcard character `\'.\'`. - Output: A boolean value indicating if the word is in the dictionary or if there exists any word in the dictionary that matches the given word pattern. Constraints - Search words may contain the wildcard character `\'.\'` representing any letter. - Words added to the dictionary will contain only lowercase English letters. Requirements - Your solution should be efficient for adding and searching large sets of words. - Focus on the space and time complexity of the operations. # Example ```python word_dictionary = WordDictionary() word_dictionary.add_word(\\"bad\\") word_dictionary.add_word(\\"dad\\") word_dictionary.add_word(\\"mad\\") assert word_dictionary.search(\\"pad\\") == False assert word_dictionary.search(\\"bad\\") == True assert word_dictionary.search(\\".ad\\") == True assert word_dictionary.search(\\"b..\\") == True ``` Implement the `WordDictionary` class with the required methods following the constraints and performance considerations discussed.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class WordDictionary: def __init__(self): self.root = TrieNode() def add_word(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: def search_in_node(word: str, node: TrieNode) -> bool: for i, char in enumerate(word): if char == \'.\': for x in node.children.values(): if search_in_node(word[i+1:], x): return True return False else: if char not in node.children: return False node = node.children[char] return node.is_end_of_word return search_in_node(word, self.root)"},{"question":"# Insertion Sort Algorithm Implementation **Objective**: Implement the full insertion sort algorithm utilizing the provided `search_insert` helper function. # Scenario You are given an unsorted array and need to sort it using insertion sort. To optimize the insertion process, you will use the `search_insert` helper function to find the correct position for each element efficiently. # Expected Input and Output Formats * **Input**: A list of integers. * **Output**: A new list containing the sorted integers. # Constraints and Performance Requirements * Input size can range from 0 to 10^5. * Focus on efficiently sorting the array using the provided helper function. * Ensure the function handles edge cases, such as empty arrays or arrays with a single element. # Example ```python def insertion_sort(array): # Your code here # Example Usage: print(insertion_sort([3, 1, 2, 5, 4])) # Output: [1, 2, 3, 4, 5] ``` **Details**: - Iterate through the array, starting from the first element. - For each element, use `search_insert` to determine its position in the sorted section of the array. - Insert the element at the appropriate index, shifting other elements as necessary. # Performance Considerations - Aim for an O(n^2) worst-case time complexity typical of insertion sort. - Space complexity should remain O(1) for the sorting operations, utilizing the input array for swaps and shifts.","solution":"def search_insert(sorted_list, value): Helper function to find the insertion index for a value in a sorted list. :param sorted_list: List of sorted integers. :param value: Integer value to be inserted. :return: Index at which `value` should be inserted to keep the list sorted. left, right = 0, len(sorted_list) while left < right: mid = (left + right) // 2 if sorted_list[mid] < value: left = mid + 1 else: right = mid return left def insertion_sort(array): Sorts an array using the insertion sort algorithm with a binary search helper for efficient insert. :param array: List of integers to be sorted. :return: New list of sorted integers. for i in range(1, len(array)): value = array[i] insert_index = search_insert(array[:i], value) array = array[:insert_index] + [value] + array[insert_index:i] + array[i+1:] return array"},{"question":"# Topological Sorting Assessment Task Context Topological sorting is a powerful technique used to order the vertices of a Directed Acyclic Graph (DAG). Given the importance in scenarios such as task scheduling, course prerequisites, and symbolic dependency resolution, it is essential to understand and correctly implement this algorithm. Task Description You are required to implement a topological sort algorithm. Specifically, write a function that performs a topological sort on a given directed graph using an iterative approach to handle any possible stack overflow issues caused by deep recursion. Write a function `iterative_top_sort(graph: dict) -> list` that performs topological sorting on the input directed graph. Function Signature ```python def iterative_top_sort(graph: dict) -> list: # Your implementation here ``` Input * A dictionary `graph` where the keys represent nodes, and the values are lists of nodes (or empty lists) representing edges from the key node to the nodes in the list. Output * A list of nodes representing the topologically sorted order of the graph. Constraints * The graph is guaranteed to be a DAG. * The number of vertices ( V ) will be in the range ( 1 leq V leq 1000 ). * The number of edges ( E ) will be in the range ( 0 leq E leq 2000 ). Example ```python graph = { \'A\': [\'C\', \'D\'], \'B\': [\'D\', \'E\'], \'C\': [\'F\'], \'D\': [\'F\', \'G\'], \'E\': [\'G\'], \'F\': [\'H\'], \'G\': [\'H\'], \'H\': [] } print(iterative_top_sort(graph)) # Possible output: [\'B\', \'A\', \'E\', \'D\', \'C\', \'G\', \'F\', \'H\'] ``` Guidelines - Implement the sorting algorithm using an iterative approach to manage calls and avoid potential recursion stack limits. - Ensure the solution efficiently handles edge cases like isolated nodes and disconnected components within the DAG. - Test your implementation with a variety of graph structures to validate its robustness and correctness.","solution":"def iterative_top_sort(graph): Perform a topological sort on the given directed graph iteratively. Parameters: graph (dict): A dictionary representing the graph where keys are nodes and values are lists of adjacent nodes. Returns: list: A list representing the topologically sorted order of the graph nodes. in_degree = {node: 0 for node in graph} # Initialize in-degree of each node to 0 for node in graph: for neighbor in graph[node]: in_degree[neighbor] += 1 # Compute in-degree of each node # Stack of nodes with in-degree 0 stack = [node for node in in_degree if in_degree[node] == 0] top_order = [] # List to store the topological order while stack: node = stack.pop() # Get the next node with in-degree 0 top_order.append(node) for neighbor in graph[node]: in_degree[neighbor] -= 1 # Decrease the in-degree of each neighbor if in_degree[neighbor] == 0: stack.append(neighbor) # If in-degree becomes 0, add to stack if len(top_order) != len(graph): raise ValueError(\\"Graph is not a DAG\\") # In case of a cycle, which should not happen as per the constraints return top_order"},{"question":"# Context You have been hired to work on a project involving frequently ordered element access. You need to implement a stack structure that always maintains its elements in sorted order whenever a new element is added. To evaluate your understanding of this data structure, you need to write and test the `OrderedStack` class. # Task **Implement and Extend the OrderedStack Class** Implement the `OrderedStack` class as follows: 1. **Maintain Sorted Order**: Ensure the stack is always sorted such that the highest value is at the top and the lowest at the bottom. 2. **Add New Method `merge`**: Write a method `merge` that merges another `OrderedStack` into the current stack while maintaining the order. 3. **Implement the Required Methods**: - Constructor: `__init__(self)` - Utility methods: `is_empty(self)`, `push(self, item)`, `push_t(self, item)`, `pop(self)`, `peek(self)`, `size(self)` - New method: `merge(self, other_stack)` 4. **Constraints**: - The elements will be integers. - The `merge` method should handle cases where elements are already ordered. **Input**: - A sequence of `push` and `merge` operations. **Output**: - The state of the stack after performing the operations, represented by top element(s) of the stack. **Example**: ```python stack1 = OrderedStack() stack1.push(3) stack1.push(1) stack1.push(2) # Stack will be [1, 2, 3] stack2 = OrderedStack() stack2.push(6) stack2.push(4) # Stack will be [4, 6] stack1.merge(stack2) # After merging, stack1 will be [1, 2, 3, 4, 6] assert stack1.pop() == 6 assert stack1.pop() == 4 ``` # Implementation Requirements Provide the complete code for `OrderedStack` including the new `merge` method. # Evaluation Criteria * Correctness: Does your implementation maintain the correct order and functionality for all methods? * Efficiency: Is your solution efficient given the constraints? * Edge Cases: Does it handle edge cases (e.g., merging with an empty stack, pushing elements in a non-increasing order)? * Code Quality: Clarity, readability, and structure of your code.","solution":"class OrderedStack: def __init__(self): self.stack = [] def is_empty(self): return len(self.stack) == 0 def push(self, item): # Insert in sorted order index = 0 while index < len(self.stack) and self.stack[index] < item: index += 1 self.stack.insert(index, item) def pop(self): if self.is_empty(): raise IndexError(\\"pop from an empty stack\\") return self.stack.pop() # Return and remove the top element def peek(self): if self.is_empty(): raise IndexError(\\"peek from an empty stack\\") return self.stack[-1] def size(self): return len(self.stack) def merge(self, other_stack): for item in other_stack.stack: self.push(item)"},{"question":"# Problem: Shortest Path Using Graph Representation Problem Statement: You are given a directed graph using the provided `DirectedGraph`, `Node`, and `DirectedEdge` classes. Your task is to implement a function that finds the shortest path between two nodes in terms of the number of edges. Function Signature: ```python def shortest_path(graph: DirectedGraph, start: str, end: str) -> int: pass ``` Input: - `graph`: An instance of `DirectedGraph`. - `start`: The name of the starting node (string). - `end`: The name of the ending node (string). Output: - The function should return an integer representing the shortest path length (number of edges) between the start node and the end node. If there\'s no path, return -1. Constraints: - The graph could be disconnected. - The graph can have cycles. - Nodes and edges are case-sensitive. Example: Consider a graph initialized like this: ```python graph_data = { \'A\': [\'B\', \'C\'], \'B\': [\'C\', \'D\'], \'C\': [\'D\'], \'D\': [\'C\'], \'E\': [\'F\'], \'F\': [\'C\'] } graph = DirectedGraph(graph_data) ``` Then `shortest_path(graph, \'A\', \'D\')` should return 2 because the shortest path from \'A\' to \'D\' is through \'B\' (i.e., A -> B -> D). Implementation Notes: - You may use any graph traversal algorithm such as BFS (breadth-first search) to find the shortest path. - Ensure to account for the case where the start node or end node does not exist in the graph. - Optimize the solution for graphs with large numbers of nodes and edges. Additional Requirements: - Include necessary helper methods if required. - Ensure the solution handles edge cases gracefully. **Performance requirements**: Your implementation should efficiently handle graphs with up to 10,000 nodes and 100,000 edges.","solution":"class DirectedGraph: def __init__(self, adjacency_list): self.adjacency_list = adjacency_list def shortest_path(graph: DirectedGraph, start: str, end: str) -> int: from collections import deque # If start or end is not in graph, return -1 if start not in graph.adjacency_list or end not in graph.adjacency_list: return -1 # BFS initialization queue = deque([(start, 0)]) # Stores (current_node, current_distance) visited = set() while queue: current_node, current_distance = queue.popleft() if current_node == end: return current_distance if current_node not in visited: visited.add(current_node) for neighbor in graph.adjacency_list.get(current_node, []): if neighbor not in visited: queue.append((neighbor, current_distance + 1)) return -1 # If no path is found"},{"question":"**Interval Merging and Point Inclusion Check** You are tasked with implementing a function to check if a set of intervals includes a specific point, in addition to merging overlapping intervals. An interval is defined by its start and end points, inclusive. # Objectives: 1. **Merge overlapping intervals**: Implement a function that takes a list of intervals and merges any overlapping or contiguous intervals. 2. **Check if a point is in any interval**: Implement a function that checks if a given point lies within any of the merged intervals. # Requirements: - **Function 1**: `merge_intervals` * **Input**: A list of tuples, where each tuple represents an interval with a start and end point (both integers). * **Output**: A list of merged intervals. - **Function 2**: `is_point_in_intervals` * **Input**: A list of merged intervals and an integer point. * **Output**: A boolean indicating if the point lies within any of the intervals. # Function Signatures: ```python def merge_intervals(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]: pass def is_point_in_intervals(merged_intervals: List[Tuple[int, int]], point: int) -> bool: pass ``` # Example: ```python input_intervals = [(1, 3), (2, 4), (5, 7), (6, 8)] merged_intervals = merge_intervals(input_intervals) # merged_intervals should be [(1, 4), (5, 8)] point = 3 result = is_point_in_intervals(merged_intervals, point) # result should be True point = 9 result = is_point_in_intervals(merged_intervals, point) # result should be False ``` # Constraints: 1. All intervals are represented by their start and end points, where `start <= end`. 2. The input list of intervals and points are integers. 3. The list of intervals may be empty. 4. The start and end points of the intervals are inclusive. Ensure your solution is both time and space-efficient, handling large lists of intervals within reasonable limits.","solution":"from typing import List, Tuple def merge_intervals(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]: if not intervals: return [] # Sort intervals by the starting point intervals.sort(key=lambda x: x[0]) merged = [intervals[0]] for current in intervals[1:]: last_merged = merged[-1] if current[0] <= last_merged[1]: # There is overlap, so merge the current interval with the last merged interval merged[-1] = (last_merged[0], max(last_merged[1], current[1])) else: # No overlap, so add the current interval to the merged list merged.append(current) return merged def is_point_in_intervals(merged_intervals: List[Tuple[int, int]], point: int) -> bool: for interval in merged_intervals: if interval[0] <= point <= interval[1]: return True return False"},{"question":"**Minimum Delete Steps to Match Words** You have been given two strings, `word1` and `word2`. Your task is to find the minimum number of delete operations required to make `word1` and `word2` equal. Write a function `min_delete_steps(word1, word2)` which uses Dynamic Programming principles to solve this problem efficiently. # Input - `word1`: A string with a length between 0 and 1000, inclusive. - `word2`: A string with a length between 0 and 1000, inclusive. # Output - An integer representing the minimum number of delete steps required. # Example ```python word1 = \\"sea\\" word2 = \\"eat\\" print(min_delete_steps(word1, word2)) # Output: 2 ``` # Constraints - You can only delete characters from `word1` or `word2` to make them identical. - The output must be computed within a reasonable time frame even for the maximum input size. # Hints - Think about how you can transform this problem into finding the longest common subsequence (LCS). - The length of the longest common subsequence can help you determine the minimum number of deletions required. # Performance Requirements - Time Complexity: O(n*m), where n is the length of `word1` and m is the length of `word2`. - Space Complexity: O(n*m), with an optimal solution achieving O(min(n, m)) using space optimization techniques.","solution":"def min_delete_steps(word1, word2): Calculate the minimum number of delete steps required to make word1 and word2 equal. n, m = len(word1), len(word2) # Create an (n+1) x (m+1) DP table to store the length of longest common subsequence dp = [[0] * (m + 1) for _ in range(n + 1)] # Fill the DP table for i in range(1, n + 1): for j in range(1, m + 1): if word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # Length of longest common subsequence lcs_length = dp[n][m] # The minimum number of deletions needed will be the sum of deletions required to remove # other characters not part of the LCS in both words. deletions = (n - lcs_length) + (m - lcs_length) return deletions"},{"question":"Imagine you are working on an application that compares user preferences based on ratings. To determine the similarity between two users\' ratings, you are asked to implement the Cosine Similarity function. This function will take two lists of ratings as input and output the cosine similarity between them. # Function Signature ```python def cosine_similarity(vec1: List[float], vec2: List[float]) -> float: pass ``` # Input * `vec1`, `vec2`: Two lists of floating-point numbers representing ratings. Both lists have the same length. # Output * Returns a float, representing the cosine similarity between the two vectors. # Constraints * Both `vec1` and `vec2` must have the same length (1 ≤ len(vec1) = len(vec2) ≤ 10^6). * Elements of the vectors can be any real numbers, including zero and negative numbers. * If either vector is a zero vector, return 0 as the cosine similarity. # Example ```python cosine_similarity([1, 1, 1], [1, 2, -1]) # Output : 0.47140452079103173 cosine_similarity([0, 0, 0], [1, 1, 1]) # Output : 0.0 ``` # Note Please make sure to handle edge cases like zero vectors properly. Avoid unnecessary computations efficiently to handle large inputs within appropriate performance constraints.","solution":"from typing import List import math def cosine_similarity(vec1: List[float], vec2: List[float]) -> float: Calculate the cosine similarity between two vectors. Args: vec1 (List[float]): First vector. vec2 (List[float]): Second vector. Returns: float: Cosine similarity between vec1 and vec2. # Compute the dot product of vec1 and vec2 dot_product = sum(a * b for a, b in zip(vec1, vec2)) # Compute the magnitude of vec1 and vec2 magnitude_vec1 = math.sqrt(sum(a * a for a in vec1)) magnitude_vec2 = math.sqrt(sum(b * b for b in vec2)) # If either magnitude is zero, return 0 if magnitude_vec1 == 0 or magnitude_vec2 == 0: return 0.0 # Compute and return the cosine similarity return dot_product / (magnitude_vec1 * magnitude_vec2)"},{"question":"You are given a non-negative integer, and your task is to find the next higher number that contains exactly the same set of digits as the original number. If no such number exists, return -1. Implement the function `next_bigger(num: int) -> int` that performs this task efficiently. # Input: * An integer `num` (1 ≤ num ≤ 10^9) # Output: * An integer which is the next higher permutation of `num`, or `-1` if no such permutation exists. # Constraints: * Do not use any libraries except standard Python libraries. * Ensure that the solution runs efficiently for large values within the constraints. # Example: Input: ``` 38276 ``` Output: ``` 38627 ``` Input: ``` 99999 ``` Output: ``` -1 ``` # Additional Example Tests: * Input: 12345 -> Output: 12354 * Input: 54321 -> Output: -1 * Input: 1528452 -> Output: 1528524 * Input: 5 -> Output: -1 # Explanation: 1. Identify the rightmost digit that violates the ascending order. 2. Swap it with the smallest digit on the right side that is larger. 3. Reverse the digits on the right to get the next higher permutation. Implement the function as specified: ```python def next_bigger(num: int) -> int: # Write your implementation here pass ``` # Unit Tests: Make sure your function passes the following test cases: ```python import unittest class TestSuite(unittest.TestCase): def test_next_bigger(self): self.assertEqual(next_bigger(38276), 38627) self.assertEqual(next_bigger(12345), 12354) self.assertEqual(next_bigger(1528452), 1528524) self.assertEqual(next_bigger(138654), 143568) self.assertEqual(next_bigger(54321), -1) self.assertEqual(next_bigger(999), -1) self.assertEqual(next_bigger(5), -1) if __name__ == \'__main__\': unittest.main() ```","solution":"def next_bigger(num: int) -> int: digits = list(str(num)) n = len(digits) # Step 1: Identify the rightmost digit that is smaller than the digit next to it for i in range(n-2, -1, -1): if digits[i] < digits[i+1]: break else: # If there is no such digit, return -1 because it is the last permutation return -1 # Step 2: Find the smallest digit on the right side of digits[i] that is larger than digits[i] for j in range(n-1, i, -1): if digits[j] > digits[i]: # Step 3: Swap that digit with digits[i] digits[i], digits[j] = digits[j], digits[i] break # Step 4: Reverse the digits after index i digits = digits[:i+1] + sorted(digits[i+1:]) # Convert back to integer result = int(\'\'.join(digits)) return result"},{"question":"# Coding Challenge Task: Implement a function to find two unique numbers in a list where every other number appears exactly twice. Your function should perform this operation in O(N) time complexity and O(1) space complexity. Function Signature: ```python def find_unique_numbers(nums: List[int]) -> List[int]: ``` # Expected Input and Output Formats - **Input**: A list of integers `nums` where exactly two elements appear only once and all other elements appear exactly twice. - Example: `[1, 2, 1, 3, 2, 5]` - **Output**: A list containing the two unique integers. - Example: `[3, 5]` or `[5, 3]` Constraints: - The given list will always fulfill the problem requirements. - The order of the output list does not matter. - Use constant extra space and linear runtime complexity. Example: - **Input**: `nums = [4, 1, 2, 1, 2, 3]` - **Output**: `[3, 4]` or `[4, 3]` Notes: - You should consider the property of XOR for solving this problem efficiently. - Ensure that your solution adheres strictly to the specifications for time and space complexity.","solution":"from typing import List def find_unique_numbers(nums: List[int]) -> List[int]: Finds the two unique numbers in a list where every other number appears exactly twice. # Step 1: XOR all numbers. The result will be the XOR of the two unique numbers xor_result = 0 for num in nums: xor_result ^= num # Step 2: Find a rightmost set bit (differentiating bit between the two unique numbers) rightmost_set_bit = xor_result & -xor_result # Step 3: Use the rightmost set bit to partition the numbers into two groups and find the unique numbers num1 = num2 = 0 for num in nums: if num & rightmost_set_bit: num1 ^= num else: num2 ^= num return [num1, num2]"},{"question":"# Question: Power Set Generation **Scenario**: You are tasked with creating an algorithm that generates all possible subsets (the power set) of a given set of distinct integers. This will help in analyzing all possible combinations of selected features for a new machine learning model. **Task**: Write a function `generate_power_set` that takes a list of distinct integers `nums` as input and returns a list of lists, where each list is a unique subset of `nums`. The subsets should be returned in a standard sorted order (first by length, then lexicographically by element). **Function Signature**: ```python def generate_power_set(nums: List[int]) -> List[List[int]]: pass ``` # Input - A list, `nums`, containing `n` distinct integers where `0 <= n <= 16`. # Output - A list of lists, representing all subsets of `nums`. # Constraints - The function must handle the edge case of an empty input list by returning a list containing an empty list `[[]]`. - The function should not return duplicate subsets. - Subsets in the output should be sorted first by length, then by lexicographical order considering each subset as a tuple of integers. # Performance Requirements - The solution should work optimally within the given constraints, and handle edge cases such as an empty list or the largest possible list (16 elements). # Example ```python # Example 1: # Input: nums = [3, 1, 2] # Output: [ [], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3] ] # Example 2: # Input: nums = [] # Output: [ [] ] # Example 3: # Input: nums = [1] # Output: [ [], [1] ] ``` # Testing To ensure your function works correctly, test your code with various edge cases such as: - An empty list. - A list with a single element. - A list with the maximum allowed elements. - Lists in ascending, descending, and random orders.","solution":"from typing import List def generate_power_set(nums: List[int]) -> List[List[int]]: nums.sort() power_set = [[]] for num in nums: power_set += [curr + [num] for curr in power_set] power_set.sort(key=lambda x: (len(x), x)) return power_set"},{"question":"You have learned about various sorting algorithms and their efficiencies. One of the least efficient sorting algorithms is the Bogo Sort, which relies on random permutations of the list until it gets sorted. Despite its impracticality, it provides a good exercise to understand the concept of algorithm efficiency and randomness. # Task Implement the `bogo_sort` function which sorts an array using the Bogo Sort technique. Your function should be able to run in simulation mode to show the intermediate steps. # Function Definition ```python def bogo_sort(arr: list, simulation: bool=False) -> list: Sorts the provided array using Bogo Sort. Parameters: arr (list): A list of integers. simulation (bool): If True, prints the array at each iteration of shuffling. Returns: list: The sorted list. ``` # Specifications - **Input**: The function accepts an array `arr` containing integers (0 <= len(arr) <= 100). - If the array is empty or contains a single element, return it as it is. - `simulation`: A boolean flag that, if set to `True`, prints the array at each iteration. - **Output**: The sorted list in non-decreasing order. - **Constraints**: - Consider the constraints to keep the problem within bounds: - Maximum length of array `arr` should not exceed 100. - Since Bogo Sort is extremely inefficient, the function should only be practiced on small arrays (recommended length <= 10). # Example ```python arr = [3, 1, 2] print(bogo_sort(arr, True)) # Expected Output (example may vary due to randomness): # iteration 0: 3 1 2 # iteration 1: 1 3 2 # iteration 2: 2 3 1 # iteration 3: 1 2 3 # [1, 2, 3] ``` # Additional Notes: - This sorting function is more of a theoretical exploration into algorithm efficiency. - Do not use this in production code due to its highly unpredictable performance.","solution":"import random def is_sorted(arr): Helper function to check if the array is sorted. for i in range(len(arr) - 1): if arr[i] > arr[i + 1]: return False return True def bogo_sort(arr, simulation=False): Sorts the provided array using Bogo Sort. Parameters: arr (list): A list of integers. simulation (bool): If True, prints the array at each iteration of shuffling. Returns: list: The sorted list. attempts = 0 while not is_sorted(arr): if simulation: print(f\\"Iteration {attempts}: {arr}\\") random.shuffle(arr) attempts += 1 if simulation: print(f\\"Iteration {attempts}: {arr}\\") # Final sorted state return arr"},{"question":"Scenario You have been hired by a tech company to build a system that tracks the connectivity of a network. The company has a grid map, and they want to determine the number of connected land areas (islands) after a series of additions of land cells. To achieve this, you decide to utilize the Union-Find data structure. Problem Statement Write a Python function `num_islands(positions: List[Tuple[int, int]]) -> List[int]` that determines the number of islands formed after each addition of land to the grid. # Input * `positions`: A list of tuples, where each tuple contains two integers representing the row and column indices (0-based) of the grid where land is added. # Output * A list of integers, where each integer at index `i` represents the number of islands after the first `i+1` additions of land. # Constraints 1. The grid size is not fixed and should be dynamically managed. 2. 0 <= row, column < 10^6 3. 1 <= len(positions) <= 10^4 # Examples ```python positions = [[0,0], [0,1], [1,2], [2,1]] print(num_islands(positions)) # Output: [1, 1, 2, 3] ``` # Instructions * Implement the Union-Find data structure to solve the problem. * Consider the efficiency and optimize for large inputs.","solution":"from typing import List, Tuple class UnionFind: def __init__(self): self.parent = {} self.rank = {} self.count = 0 def add(self, x): if x not in self.parent: self.parent[x] = x self.rank[x] = 0 self.count += 1 def find(self, x): if self.parent[x] != x: self.parent[x] = self.find(self.parent[x]) return self.parent[x] def union(self, x, y): rootX = self.find(x) rootY = self.find(y) if rootX != rootY: if self.rank[rootX] > self.rank[rootY]: self.parent[rootY] = rootX elif self.rank[rootX] < self.rank[rootY]: self.parent[rootX] = rootY else: self.parent[rootY] = rootX self.rank[rootX] += 1 self.count -= 1 def num_islands(positions: List[Tuple[int, int]]) -> List[int]: directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] uf = UnionFind() results = [] added_land = set() for r, c in positions: if (r, c) in added_land: results.append(uf.count) continue added_land.add((r, c)) uf.add((r, c)) for dr, dc in directions: nr, nc = r + dr, c + dc if (nr, nc) in added_land: uf.union((r, c), (nr, nc)) results.append(uf.count) return results"},{"question":"# Context: You are developing a financial application where users can input their expenses, and the system will help them find two expenses that add up to a particular budget. Your task is to implement a function that can be used for this purpose. # Problem Statement: ``` Given an array of integers (representing expenses) and an integer target (representing a budget), return the indices of the two numbers such that they add up to the target. You may assume that: 1. Each input will have exactly one solution. 2. You may not use the same element twice. # Input: * array: List[int] (1 <= len(array) <= 10^6, -10^9 <= array[i] <= 10^9) * target: int (-10^9 <= target <= 10^9) # Output: * Tuple[int, int] - indices of the two numbers # Constraints: - The function should return indices as a 0-based tuple. - Implement the solution efficiently within O(n) time complexity. # Example: Given `nums = [2, 7, 11, 15]` and `target = 9`, the function should return `(0, 1)` because `nums[0] + nums[1] = 2 + 7 = 9`. # Function Signature: ```python def two_sum(array: List[int], target: int) -> Tuple[int, int]: # your code here ```","solution":"from typing import List, Tuple def two_sum(array: List[int], target: int) -> Tuple[int, int]: Returns the indices of the two numbers that add up to the target. Args: array (List[int]): List of integers representing the expenses. target (int): The target sum (budget). Returns: Tuple[int, int]: A tuple of indices of the two numbers that add up to the target. hashmap = {} for i, num in enumerate(array): complement = target - num if complement in hashmap: return (hashmap[complement], i) hashmap[num] = i return ()"},{"question":"# Permutation Generation Challenge Problem Statement You are given a collection of distinct numbers. Your task is to generate all possible permutations of these numbers. However, you need to implement this using an iterative approach instead of a recursive one provided above. Function Signature ```python def permute_iterative(nums: List[int]) -> List[List[int]]: Generate all permutations of a list of distinct integers iteratively. Parameters: nums (List[int]): A list of distinct integers. Returns: List[List[int]]: A list containing all permutations of the input list. pass ``` Input * A list of distinct integers `nums` with length `n` (0 <= n <= 9). Output * A list of lists where each list is a permutation of the given numbers. Constraints * The length of the list does not exceed 9, as the number of permutations grows factorially with size. * You must implement the solution using an iterative approach. Example * `permute_iterative([1,2,3])` should return the following 6 permutations: ```python [ [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1] ] ``` Evaluation Criteria * The code should handle all edge cases, including an empty list and single-element list. * Ensure efficient iteration to avoid performance bottlenecks. * The function should be self-contained and does not use additional recursive functions.","solution":"from typing import List def permute_iterative(nums: List[int]) -> List[List[int]]: Generate all permutations of a list of distinct integers iteratively. Parameters: nums (List[int]): A list of distinct integers. Returns: List[List[int]]: A list containing all permutations of the input list. if not nums: return [[]] result = [[]] for num in nums: new_result = [] for perm in result: for i in range(len(perm) + 1): new_result.append(perm[:i] + [num] + perm[i:]) result = new_result return result"},{"question":"Bogo Sort Improvement Challenge You are given an unsorted array `arr` of integers. Your task is to implement an improved version of Bogo Sort that minimizes the number of shuffles required on average. The new algorithm should introduce optimizations, such as: 1. Pre-check for elements that are already in place. 2. Swap the incorrect elements instead of a full shuffle. Write a function `improved_bogo_sort(arr: List[int]) -> List[int]` that sorts the array using an improved Bogo Sort approach. # Input and Output - **Input**: A list of integers `arr` (1 ≤ len(arr) ≤ 10) - **Output**: A sorted list of integers # Constraints - Ensure your solution can handle small arrays efficiently with no infinite loops. - The list should remain unmodified if it is already sorted. # Example ```python # Example 1 arr = [3, 1, 2] print(improved_bogo_sort(arr)) # Output should be [1, 2, 3] # Example 2 arr = [5, 4, 2, 3, 1] print(improved_bogo_sort(arr)) # Output should be [1, 2, 3, 4, 5] ``` # Requirements 1. Implement the function `improved_bogo_sort`. 2. Ensure your function runs efficiently on lists up to length 10. 3. Handle edge cases such as already sorted arrays, arrays with repeated elements, etc.","solution":"import random from typing import List def is_sorted(arr: List[int]) -> bool: Helper function to check if an array is sorted. return all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1)) def improved_bogo_sort(arr: List[int]) -> List[int]: Sort the input array using an improved version of bogo sort. n = len(arr) while not is_sorted(arr): # Find the first position where the elements are in the wrong order for i in range(n - 1): if arr[i] > arr[i + 1]: # Swap the elements arr[i], arr[i + 1] = arr[i + 1], arr[i] break return arr"},{"question":"# Matrix Power Computation You are given three functions that perform matrix operations: `multiply` for matrix multiplication, `identity` for generating an identity matrix, and `matrix_exponentiation` for computing the power of a matrix. Your task is to implement a function `matrix_power_sequence` that takes a square matrix `mat` of size (d times d) and an integer `m`, and returns a list of matrices with the elements being the matrix raised to the powers of (1) through (m) (i.e., ([mat^1, mat^2, ..., mat^m])). # Function Signature ```python def matrix_power_sequence(mat: list, m: int) -> list: pass ``` # Input - `mat` (list of list of ints): A square matrix of size (d times d). - `m` (int): A positive integer representing the highest power to which the matrix needs to be raised. # Output - `list of list of lists`: A list containing `m` elements, where each element is a matrix representing `mat` raised to the powers from (1) through (m). # Constraints - (1 leq d leq 100) - (1 leq m leq 1000) - Matrix elements are integers in the range ([-10^9, 10^9]) # Example ```python mat = [[2, 1], [1, 2]] m = 3 output = matrix_power_sequence(mat, m) # Expected output # [ # [[2, 1], [1, 2]], # mat^1 # [[5, 4], [4, 5]], # mat^2 # [[14, 13], [13, 14]] # mat^3 # ] ``` # Notes - You can use the provided `multiply`, `identity`, and `matrix_exponentiation` functions to help implement this function. - Ensure efficient computation to handle the upper limits of the input constraints.","solution":"def multiply(A, B): Multiplies two matrices A and B d = len(A) result = [[0] * d for _ in range(d)] for i in range(d): for j in range(d): for k in range(d): result[i][j] += A[i][k] * B[k][j] return result def identity(d): Returns the identity matrix of size d x d I = [[0] * d for _ in range(d)] for i in range(d): I[i][i] = 1 return I def matrix_exponentiation(mat, exp): Computes the matrix `mat` raised to the power `exp`. d = len(mat) result = identity(d) base = mat while exp > 0: if exp % 2 == 1: result = multiply(result, base) base = multiply(base, base) exp //= 2 return result def matrix_power_sequence(mat, m): Returns a list of matrices [mat^1, mat^2, ..., mat^m]. powers = [] for i in range(1, m + 1): powers.append(matrix_exponentiation(mat, i)) return powers"},{"question":"# Unique Permutations with Duplicates Given the following problem statement, implement a function `permute_unique(nums)` that returns all possible unique permutations of numbers that might contain duplicates. Input * A list of integers `nums` which might contain duplicates. Output * A list of lists, where each inner list represents a unique permutation of the input list. Constraints * The length of `nums` will be between 1 and 8. * The elements of `nums` will be between -10 and 10. Performance Requirements * The solution should efficiently generate unique permutations, considering the input length constraint. Function Signature ```python def permute_unique(nums): # Your code here ``` Example ```python print(permute_unique([1, 1, 2])) # Expected Output: # [ # [1, 1, 2], # [1, 2, 1], # [2, 1, 1] # ] ``` # Additional Context Imagine you are automating the generation of different seating arrangements for guests at a wedding. The guest list might have repeated names, and you need to find all unique ways to arrange the seats. The function `permute_unique` will help you achieve this by showing all possible unique arrangements.","solution":"def permute_unique(nums): Returns all unique permutations of a list of numbers which might contain duplicates. from collections import Counter def backtrack(path, counter): if len(path) == len(nums): result.append(path[:]) return for num in counter: if counter[num] > 0: path.append(num) counter[num] -= 1 backtrack(path, counter) path.pop() counter[num] += 1 result = [] counter = Counter(nums) backtrack([], counter) return result"},{"question":"# Maximum Network Flow Challenge Consider a network represented by a directed graph with `n` vertices and `m` edges. Each edge (u, v) has a non-negative capacity, representing the maximum flow that can pass from vertex `u` to vertex `v`. In this challenge, you need to implement a function to compute the maximum flow from a given source vertex to a sink vertex using Dinic\'s Algorithm. You must adhere to the following instructions: **Input**: * `n`: An integer representing the number of vertices in the graph. * `edges`: A list of tuples (u, v, c) representing edges from vertex `u` to vertex `v` with capacity `c`. * `source`: An integer representing the source vertex. * `sink`: An integer representing the sink vertex. **Output**: * An integer representing the maximum flow from the source to the sink. **Function Signature**: ```python def max_flow_dinic(n: int, edges: List[Tuple[int, int, int]], source: int, sink: int) -> int: pass ``` # Constraints: * 1 <= n <= 1000 * 0 <= m <= 10000 * 0 <= u, v < n * 1 <= c <= 10^9 * `source` and `sink` are distinct and within the range of vertices. # Example: ```python n = 4 edges = [(0, 1, 100), (0, 2, 100), (1, 2, 1), (1, 3, 100), (2, 3, 100)] source = 0 sink = 3 result = max_flow_dinic(n, edges, source, sink) print(result) # Output should be 200 ``` # Note: In the example, the maximum flow is achieved by: * Flow 100 from vertex 0 to vertex 1, then 100 from vertex 1 to vertex 3. * Flow 100 from vertex 0 to vertex 2, then 100 from vertex 2 to vertex 3. Thus, the total maximum flow is 200. Implement your solution considering efficiency and edge cases, especially cycles and isolated nodes.","solution":"from collections import deque from typing import List, Tuple class Dinic: def __init__(self, n: int): self.n = n self.edges = [] self.graph = [[] for _ in range(n)] def add_edge(self, from_node: int, to_node: int, capacity: int) -> None: self.edges.append([from_node, to_node, capacity]) self.edges.append([to_node, from_node, 0]) m = len(self.edges) self.graph[from_node].append(m - 2) self.graph[to_node].append(m - 1) def bfs(self, source: int, sink: int) -> bool: self.level = [-1] * self.n self.level[source] = 0 queue = deque([source]) while queue: u = queue.popleft() for i in self.graph[u]: edge = self.edges[i] if self.level[edge[1]] < 0 and edge[2] > 0: self.level[edge[1]] = self.level[u] + 1 queue.append(edge[1]) return self.level[sink] != -1 def dfs(self, u: int, sink: int, flow: int) -> int: if u == sink: return flow for i in range(self.start[u], len(self.graph[u])): self.start[u] = i edge = self.edges[self.graph[u][i]] if edge[2] > 0 and self.level[edge[1]] == self.level[u] + 1: pushed = self.dfs(edge[1], sink, min(flow, edge[2])) if pushed > 0: self.edges[self.graph[u][i]][2] -= pushed self.edges[self.graph[u][i] ^ 1][2] += pushed return pushed return 0 def max_flow(self, source: int, sink: int) -> int: flow = 0 while self.bfs(source, sink): self.start = [0] * self.n while True: pushed = self.dfs(source, sink, float(\'Inf\')) if pushed == 0: break flow += pushed return flow def max_flow_dinic(n: int, edges: List[Tuple[int, int, int]], source: int, sink: int) -> int: dinic = Dinic(n) for u, v, c in edges: dinic.add_edge(u, v, c) return dinic.max_flow(source, sink)"},{"question":"Context You are working on a project where you need to process very large numbers that are represented as arrays of their individual digits. As part of your task, you need to write a function that increments such numbers by one. Task Write a function `increment_number` that takes a list of non-negative integers, each representing a digit of a large number, and returns the list of digits representing the number incremented by one. Function Signature ```python def increment_number(digits: List[int]) -> List[int]: pass ``` Input * `digits`: A list of integers where each integer `0 <= digit <= 9` represents a single digit of a non-negative number. The list cannot be empty. Output * Returns a list of integers representing the incremented number. Constraints * You may not use any built-in functions that directly convert the list to a number or vice versa. * You need to handle carryovers properly. * The function should handle cases where the number consists of all 9s, resulting in an increment to a number with more digits. Examples 1. `increment_number([1, 2, 3])` should return `[1, 2, 4]` 2. `increment_number([9, 9, 9])` should return `[1, 0, 0, 0]` 3. `increment_number([0])` should return `[1]` 4. `increment_number([1, 9, 9])` should return `[2, 0, 0]` Edge Cases * The input list is all `9`s, resulting in a carry that increases the length of the list. * Single element list. Performance Requirements * Your implementation should have a time complexity of O(n). * Your implementation should have a space complexity of O(1) if modifying the list in-place or O(n) if creating a new list.","solution":"def increment_number(digits): Takes a list of integers representing digits of a number, increments the number by one and returns the new list of digits. n = len(digits) for i in range(n-1, -1, -1): if digits[i] < 9: digits[i] += 1 return digits digits[i] = 0 # If we exit the loop, it means we had carries all the way to the highest digit. return [1] + [0] * n"},{"question":"# Longest Increasing Subsequence in Width-Based Building Heights **Context**: You are tasked with analyzing the height data for buildings along a city\'s street to identify patterns and improve city planning. Given the heights of buildings in a specific order, you need to determine the length of the longest subsequence of buildings that have strictly increasing heights. # Problem Statement Write a function `longest_increasing_building_heights` which takes a list of integers representing the heights of buildings and returns the length of the longest subsequence of buildings with strictly increasing heights. # Input - A list of integers `heights` where 1 ≤ len(heights) ≤ 10^4 and 1 ≤ heights[i] ≤ 10^5. # Output - An integer representing the length of the longest increasing subsequence of buildings\' heights. # Constraints 1. The list can contain up to 10,000 building heights. 2. Building heights are between 1 and 100,000. # Performance Requirements Your solution should be able to handle large inputs efficiently considering the constraints on time and space. # Example ```python # Example 1 input: [3, 4, 1, 8, 10, 2, 5, 6, 9, 7] output: 6 Explanation: The longest increasing subsequence is [3, 4, 8, 10, 5, 6, 9] # Example 2 input: [5, 3, 4, 8, 6, 7] output: 4 Explanation: The longest increasing subsequence is [3, 4, 6, 7] # Example 3 input: [50, 3, 10, 7, 40, 80] output: 4 Explanation: The longest increasing subsequence is [3, 7, 40, 80] ``` # Function Signature ```python def longest_increasing_building_heights(heights: list[int]) -> int: # Implementation Here pass ``` You are encouraged to implement an optimized solution to handle large input sizes effectively.","solution":"def longest_increasing_building_heights(heights): Find the length of the longest strictly increasing subsequence. Args: heights (list): List of integers representing building heights. Returns: int: Length of the longest strictly increasing subsequence. if not heights: return 0 n = len(heights) dp = [1] * n for i in range(1, n): for j in range(i): if heights[i] > heights[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"# Question You are given an array of integers. Your task is to write a function `find_kth_smallest(arr, k)` that returns the k-th smallest element in the array using the Selection Sort approach. Note that `k` is 1-based, meaning that k=1 corresponds to the smallest element in the array. # Function Signature ```python def find_kth_smallest(arr: List[int], k: int) -> int: pass ``` # Input * `arr` (List[int]): An array of integers (1 <= len(arr) <= 10^4) * `k` (int): An integer representing the index of the smallest element to find (1 <= k <= len(arr)) # Output * Returns the k-th smallest element in the integer array. # Constraints * The input integer array can contain duplicates. * You can assume all inputs are valid. # Examples ```python assert find_kth_smallest([7, 10, 4, 3, 20, 15], 3) == 7 assert find_kth_smallest([7, 10, 4, 3, 20, 15], 4) == 10 assert find_kth_smallest([3, 2, 1, 5, 4, 2, 1, 5], 5) == 3 assert find_kth_smallest([1], 1) == 1 ``` # Guidelines * Utilize the Selection Sort approach to find the k-th smallest element without fully sorting the array. * Consider optimizing performance to work efficiently within the given constraints. * Handle edge cases such as arrays with duplicate values and the smallest/largest possible values of `k`.","solution":"from typing import List def find_kth_smallest(arr: List[int], k: int) -> int: Returns the k-th smallest element in the array using the Selection Sort approach. k is 1-based, meaning that k=1 corresponds to the smallest element in the array. n = len(arr) for i in range(k): min_idx = i for j in range(i + 1, n): if arr[j] < arr[min_idx]: min_idx = j arr[i], arr[min_idx] = arr[min_idx], arr[i] return arr[k-1]"},{"question":"# Maximum Flow in a Network **Context**: You are managing a network where you need to optimize the maximum flow from a source node to a sink node. You have been provided with three algorithms for calculating the maximum flow in a network: Ford-Fulkerson (using DFS), Edmonds-Karp (using BFS), and Dinic\'s Algorithm. **Objective**: Your task is to implement a function that computes the maximum flow from the source to the sink in a given network using one of the three provided methods. **Task**: 1. Choose one of the methods: `ford_fulkerson`, `edmonds_karp`, or `dinic`. 2. Implement the function `compute_max_flow` using your chosen method. **Function Signature**: ```python def compute_max_flow(capacity: List[List[int]], source: int, sink: int) -> int: ``` **Input**: - `capacity` (List[List[int]]): A 2D list representing the capacity of edges in the network. `capacity[i][j]` is the capacity from node `i` to node `j`. If there is no edge, `capacity[i][j]` should be 0. - `source` (int): The start node. - `sink` (int): The end node. **Output**: - Return an integer value representing the maximum flow from source to sink. **Constraints**: - Assumes there are no negative capacities. - The capacities are integers. - The number of vertices V in the network will be at most 1000. **Performance Requirements**: - Your implementation should handle graphs with up to 1000 vertices efficiently. **Edge Cases** to consider: - Graphs with no augmenting path between source and sink. - Disconnected graph where some nodes are not reachable. - Graphs with varying capacities including very large or small capacities. **Example**: ```python capacity = [ [0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0] ] source = 0 sink = 5 assert compute_max_flow(capacity, source, sink) == 23 ``` **Notes**: - You need to use the adjacency matrix representation of the network. - It is sufficient to use one method among `ford_fulkerson`, `edmonds_karp`, and `dinic`. - Ensure your function handles various edge cases efficiently.","solution":"from typing import List from collections import deque def bfs(residual_capacity, source, sink, parent): A Breadth-First Search (BFS) based method to find if there is a path from source to sink in residual graph. Also fills parent[] to store the path. visited = [False] * len(residual_capacity) queue = deque([source]) visited[source] = True while queue: u = queue.popleft() for ind, val in enumerate(residual_capacity[u]): if visited[ind] == False and val > 0: # Check for unvisited nodes with positive residual capacity queue.append(ind) visited[ind] = True parent[ind] = u if ind == sink: # If we reached sink, we return True return True return False def edmonds_karp(capacity: List[List[int]], source: int, sink: int) -> int: Implements the Edmonds-Karp algorithm which is an implementation of the Ford-Fulkerson method using BFS to find the maximum flow in a flow network. residual_capacity = [capacity[i][:] for i in range(len(capacity))] parent = [-1] * len(capacity) max_flow = 0 while bfs(residual_capacity, source, sink, parent): # Find the maximum flow through the path found. path_flow = float(\'Inf\') s = sink while s != source: path_flow = min(path_flow, residual_capacity[parent[s]][s]) s = parent[s] # Update residual capacities of the edges and reverse edges along the path. v = sink while v != source: u = parent[v] residual_capacity[u][v] -= path_flow residual_capacity[v][u] += path_flow v = parent[v] max_flow += path_flow return max_flow compute_max_flow = edmonds_karp"},{"question":"You are provided with an array of integers. Implement the `pigeonhole_sort` function to sort the array in ascending order using the Pigeonhole Sort algorithm. Your function should ensure efficient sorting for the suitable input characteristics of this algorithm. # Function Signature ```python def pigeonhole_sort(arr: List[int]) -> List[int]: ``` # Input * `arr`: A list of integers, where -10**6 ≤ arr[i] ≤ 10**6. The list may be empty or contain up to 10^6 elements. # Output * The function should return the sorted list of integers in ascending order. # Constraints * The Pigeonhole Sort algorithm is suitable for lists where the range of the numbers (i.e., the difference between the maximum and minimum values) is not dramatically larger than the number of elements in the list. # Performance Requirements * Ensure that your implementation efficiently uses time and space. Avoid unnecessary computations and redundant storage. # Example ```python # Example 1: input_arr = [8, 3, 2, 7, 4] output_arr = pigeonhole_sort(input_arr) assert output_arr == [2, 3, 4, 7, 8] # Example 2: input_arr = [-5, -1, -3] output_arr = pigeonhole_sort(input_arr) assert output_arr == [-5, -3, -1] # Example 3: input_arr = [0] output_arr = pigeonhole_sort(input_arr) assert output_arr == [0] ``` # Note 1. Ensure your solution handles edge cases, such as arrays with all identical elements, single-element arrays, and empty arrays efficiently. 2. Consider optimizing memory usage where possible, given the potential range of integer values.","solution":"from typing import List def pigeonhole_sort(arr: List[int]) -> List[int]: if not arr: return [] min_val = min(arr) max_val = max(arr) size = max_val - min_val + 1 holes = [0] * size for num in arr: holes[num - min_val] += 1 sorted_array = [] for hole_index in range(size): while holes[hole_index] > 0: sorted_array.append(hole_index + min_val) holes[hole_index] -= 1 return sorted_array"},{"question":"# Question: Regular Expression Matching You are tasked with implementing a function that performs regular expression matching with support for the wildcard characters `.` and `*`. - `.` Matches any single character. - `*` Matches zero or more of the preceding element. The function should determine if the input string matches the pattern and cover the entire input string (not partial). # Function Signature ```python def is_match(s: str, p: str) -> bool: Determine if input string s matches the pattern p Parameters: - s (str): The input string to match - p (str): The pattern containing regular expressions Returns: - bool: True if the string matches the pattern, otherwise False ``` # Input Format - `s` and `p` are strings containing only lowercase English letters and the characters `.` and `*`. - 1 <= len(s), len(p) <= 1000 # Output Format - Return `True` if the string `s` matches the pattern `p` entirely, otherwise return `False`. # Constraints - The input string and pattern consist of only lowercase alphabetic characters, `.` and `*`. - The pattern `p` is guaranteed not to start with a `*` character. - `*` character in the pattern `p` is always preceded by another character. # Example ```plaintext is_match(\\"aa\\", \\"a\\") -> False is_match(\\"aa\\", \\"aa\\") -> True is_match(\\"aaa\\", \\"aa\\") -> False is_match(\\"aa\\", \\"a*\\") -> True is_match(\\"ab\\", \\".*\\") -> True is_match(\\"aab\\", \\"c*a*b\\") -> True ``` # Constraints and Considerations - Ensure to handle cases where the pattern includes complex combinations of `.` and `*`. - Pay attention to handling patterns that have trailing asterisks and matching scenarios accurately. Good luck!","solution":"def is_match(s: str, p: str) -> bool: def match_helper(text, pattern): if not pattern: return not text first_match = bool(text) and pattern[0] in {text[0], \'.\'} if len(pattern) >= 2 and pattern[1] == \'*\': return (match_helper(text, pattern[2:]) or first_match and match_helper(text[1:], pattern)) else: return first_match and match_helper(text[1:], pattern[1:]) return match_helper(s, p)"},{"question":"You are given the task to implement a recursive sorting function using the Stooge Sort algorithm. Stooge Sort is a highly inefficient sorting algorithm but is useful for educational purposes to understand recursion and sorting principles. Your goal is to sort an array of integers using Stooge Sort and ensure proper handling of edge cases. # Function Signature ```python def stoogesort(arr: List[int], l: int, h: int) -> None: # Your implementation here ``` # Input - `arr`: A list of integers that need to be sorted. - `l`: An integer representing the starting index of the segment of the array to be sorted. - `h`: An integer representing the ending index of the segment of the array to be sorted. # Output - The function should sort the segment of the array in place between indices `l` and `h`. - Return type is `None`. # Constraints 1. 1 <= len(arr) <= 1000 2. The values in the array will be in the range of -10^6 to 10^6. # Example Example 1 **Input**: ```python arr = [4, 2, 6, 3, 1, 5] stoogesort(arr, 0, len(arr) - 1) ``` **Output**: ```python [1, 2, 3, 4, 5, 6] ``` Example 2 **Input**: ```python arr = [10, -10, 0, 5, 20, -5] stoogesort(arr, 0, len(arr) - 1) ``` **Output**: ```python [-10, -5, 0, 5, 10, 20] ``` # Notes - You must write the function using the provided function signature. - You must ensure the function handles edge cases efficiently, including empty arrays or arrays with only one element. - Think about the performance implications, especially given the algorithm\'s inefficiency for large arrays.","solution":"from typing import List def stoogesort(arr: List[int], l: int, h: int) -> None: if l >= h: return # If the first element is greater than the last, swap them if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] # If there are more than two elements in the array if h - l + 1 > 2: t = (h - l + 1) // 3 stoogesort(arr, l, h - t) # First 2/3 elements stoogesort(arr, l + t, h) # Last 2/3 elements stoogesort(arr, l, h - t) # First 2/3 elements again"},{"question":"# Coding Assessment: Find Target Sum Pair Indices Objective You are given a sorted array of integers in ascending order and a target integer. Using the provided code snippets as a reference, implement a function to find two distinct numbers in the array that add up to the target integer. Return their indices (1-based). You may use any suitable method discussed. Function Signature ```python def find_target_pair(numbers: List[int], target: int) -> List[int]: pass ``` Input Format * A list of integers `numbers` sorted in ascending order. * An integer `target`. Output Format * A list containing two integers representing the 1-based indices of the two numbers in the array whose sum is equal to the target. Constraints * Each input would have exactly one solution. * Numbers array will contain at least two elements. * You may not use the same element twice. Example * Input: numbers = [2, 7, 11, 15], target = 9 * Output: [1, 2] * Input: numbers = [1, 2, 3, 4, 6], target = 8 * Output: [2, 5] Notes Your implementation should be efficient in terms of time complexity. Provide an explanation of your chosen method and discuss its complexity.","solution":"from typing import List def find_target_pair(numbers: List[int], target: int) -> List[int]: Returns the 1-based indices of the two numbers in the sorted array that add up to the target integer. The function uses a two-pointer technique for an efficient O(n) solution. left, right = 0, len(numbers) - 1 while left < right: current_sum = numbers[left] + numbers[right] if current_sum == target: return [left + 1, right + 1] elif current_sum < target: left += 1 else: right -= 1 return []"},{"question":"# Question: You are tasked with writing a function to find the weight of a minimum spanning tree for a given connected, undirected, weighted graph using Prim\'s algorithm. Your implementation should not only calculate the total weight, but also ensure that your solution is efficient and able to handle a variety of graph structures. # Scenario/Context: Consider you are working on a network design project where you need to minimize the total length of cables required to connect all computers in the network. Each computer is represented as a node, and possible cable connections are weighted edges between nodes indicating the length of each cable. # Function Signature: ```python def find_mst_weight(graph: Dict[str, List[Tuple[int, str]]]) -> int: pass ``` # Input: * A dictionary `graph` representing the graph where: * Keys are node identifiers (strings). * Values are lists of tuples, each containing two elements: - An integer representing the weight (length of cable). - A string representing the adjacent node. # Output: * An integer representing the total weight of the minimum spanning tree. # Constraints: * The graph is connected, undirected, with positive weights. * The nodes are represented as strings. # Performance Requirements: * Your solution should work efficiently even for larger graphs, typical constraints: - Number of nodes `V` ≤ 1000 - Number of edges `E` ≤ 10,000 # Example: ```python graph = { \'a\': [(3, \'b\'), (8, \'c\')], \'b\': [(3, \'a\'), (5, \'d\')], \'c\': [(8, \'a\'), (2, \'d\'), (4, \'e\')], \'d\': [(5, \'b\'), (2, \'c\'), (6, \'e\')], \'e\': [(4, \'c\'), (6, \'d\')] } print(find_mst_weight(graph)) # Output should be 14 ``` # Notes: * Ensure your implementation handles all edge cases such as multiple minimum edges and avoid cycles properly. * Aim for a clean and efficient solution leveraging the principles of Prim\'s algorithm.","solution":"import heapq def find_mst_weight(graph): Uses Prim\'s algorithm to find the weight of the minimum spanning tree of a graph. Parameters: graph (dict): A dictionary representation of an undirected graph where: - keys are node identifiers (str) - values are lists of tuples, each tuple contains: - an integer representing the edge weight - a string representing the adjacent node Returns: int: Total weight of the minimum spanning tree. if not graph: return 0 # Start from any node; here we start from an arbitrary node start_node = next(iter(graph)) min_heap = [] visited = set() total_weight = 0 # Initialize the heap with the edges from the start node visited.add(start_node) for weight, adj in graph[start_node]: heapq.heappush(min_heap, (weight, adj)) while min_heap: weight, node = heapq.heappop(min_heap) if node not in visited: visited.add(node) total_weight += weight for next_weight, next_node in graph[node]: if next_node not in visited: heapq.heappush(min_heap, (next_weight, next_node)) return total_weight"},{"question":"You are given a one-dimensional array of integers, and your task is to implement a function that finds the subarray with the maximum sum. Extend and modify the given algorithm to not only return the maximum sum but also to return the start and end indices of the subarray that provides this maximum sum. # Function Signature ```python def max_subarray_with_indices(array: List[int]) -> Tuple[int, int, int]: ``` # Input * `array`: A list of integers, where the length of the list is between 1 and 10^5 (inclusive). # Output * A tuple with three values. The first value represents the maximum sum that can be obtained. * The second value represents the starting index of the subarray with the maximum sum. * The third value represents the ending index of the subarray with the maximum sum. # Constraints * At least one number will be in the array, so no need to handle empty arrays. * The provided array may contain negative numbers. # Example Input ```python array = [1, 2, -3, 4, 5, -7, 23] ``` Output ```python (25, 3, 6) ``` Explanation: * The subarray [4, 5, -7, 23] has the sum of 25 and spans from indices 3 to 6. # Notes * Students should handle edge cases such as single-element arrays and arrays with all negative values. * Consider the performance and correctness of the implemented function as part of the evaluation criteria.","solution":"from typing import List, Tuple def max_subarray_with_indices(array: List[int]) -> Tuple[int, int, int]: Finds the subarray with the maximum sum and returns the sum and the start and end indices of the subarray. :param array: List of integers :return: Tuple containing the maximum sum and the start and end indices of the subarray max_sum = current_sum = array[0] start = end = s = 0 for i in range(1, len(array)): if current_sum <= 0: current_sum = array[i] s = i else: current_sum += array[i] if current_sum > max_sum: max_sum = current_sum start = s end = i return (max_sum, start, end)"},{"question":"# Question: Context: You\'ve come across a sequence formed by concatenating all positive decimal integers in order (i.e., \\"123456789101112...\\"). You are tasked with finding the nth digit of this infinite sequence. Task: Write a function `find_nth_digit(n)` that receives an integer `n` and returns the nth digit of the sequence. For instance, if `n` is 15, the digit would be 2, as the sequence is \\"12345678910111213...\\" and the 15th digit is 2. Input: - `n`: An integer (1 <= n <= 10^9) Output: - An integer representing the nth digit of the sequence. Function Signature: ```python def find_nth_digit(n: int) -> int: ``` Example: ```python assert find_nth_digit(3) == 3 assert find_nth_digit(11) == 0 assert find_nth_digit(15) == 2 ``` Constraints: - The function must run efficiently within the given constraints. - Handle the possibility of very large `n`. Performance Considerations: - Consider both time and space efficiency in your implementation. - Ensure the algorithm handles edge cases precisely, such as large values of `n`.","solution":"def find_nth_digit(n: int) -> int: length = 1 # Current length of the numbers considered (e.g., 1 for 1-9, 2 for 10-99, etc.) count = 9 # Number of integers of the current length start = 1 # The first number of the current length (e.g., 1, 10, 100, etc.) # Find the range in which the nth digit falls while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 # Find the actual number where the nth digit is start += (n - 1) // length s = str(start) return int(s[(n - 1) % length])"},{"question":"Coding Assessment Question # Context You\'ve been hired as a consultant to optimize the scheduling of jobs for a startup. They have a series of jobs each defined by a start time, an end time, and a profit. The company wants to maximize the profit by scheduling non-overlapping jobs. # Task Your task is to write a function `maximize_profit` that takes a list of jobs (each job represented as a tuple of (start_time, end_time, profit)) and returns the maximum profit that can be achieved by scheduling non-overlapping jobs. # Implementation Details Function Signature ```python def maximize_profit(jobs: List[Tuple[int, int, int]]) -> int: ``` Input - `jobs`: A list of tuples where each tuple represents a job with `start_time`, `end_time`, and `profit`. - `0 <= len(jobs) <= 10^4` - `0 <= start_time, end_time, profit <= 10^4` - `start_time <= end_time` for each job Output - `int`: The maximum profit that can be achieved. Performance Requirements - The solution should efficiently handle up to `10^4` jobs within the given constraints. Example ```python jobs = [(1, 3, 50), (3, 5, 20), (2, 6, 100), (4, 7, 200)] print(maximize_profit(jobs)) # Output: 250 ``` # Constraints - Assume the input jobs list is not sorted. - The jobs do not need to be contiguous in time. # Notes - You may define helper functions as necessary. - Think carefully about edge cases, such as empty job lists or jobs with identical timing. # Submission Implement the function `maximize_profit` in Python and ensure it meets the performance requirements.","solution":"from typing import List, Tuple def maximize_profit(jobs: List[Tuple[int, int, int]]) -> int: if not jobs: return 0 # Sort jobs by end_time jobs.sort(key=lambda x: x[1]) # DP array to store maximum profit up to the i-th job n = len(jobs) dp = [0] * n # Initialize the dp array with the profit of the first job dp[0] = jobs[0][2] for i in range(1, n): # Include profit of the current job incl_prof = jobs[i][2] # Find the latest job that doesn\'t conflict with current job for j in range(i-1, -1, -1): if jobs[j][1] <= jobs[i][0]: incl_prof += dp[j] break # Store the maximum profit of including or excluding the current job dp[i] = max(incl_prof, dp[i-1]) return dp[-1]"},{"question":"# Sorting Problem with Constraints **Context**: You are provided with a list of product prices from an e-commerce website. The number of prices, `n`, and the range of prices both significantly influence the sorting choice. Given this scenario, you need to implement the Pigeonhole Sorting algorithm and verify that it handles various edge cases and performs efficiently for large datasets. **Task**: Implement the `pigeonhole_sort` function following the given constraints: Function Signature: ```python def pigeonhole_sort(arr: List[int]) -> List[int]: ``` Input: - `arr`: A list of integers representing prices of products. Constraints: - 0 ≤ arr[i] ≤ 10^5 - 1 ≤ len(arr) ≤ 10^5 Output: - A sorted list of integers in non-decreasing order. Performance Requirements: - The function should have a time complexity of O(n + Range) where n is the number of elements in the array and Range is the difference between the maximum and minimum value in the array. - The function should efficiently handle the edge cases without exceeding memory limits. Edge Cases to Handle: - Lists with all identical elements. - Empty lists (the function should return an empty list). - Large range of values while maintaining performance requirements. - Lists with negative values (consider extending the provided implementation). Write and test your implementation considering these constraints and edge cases.","solution":"def pigeonhole_sort(arr): Perform the pigeonhole sort on the provided list of integers. Parameters: arr (list of int): A list of integers representing product prices. Returns: sorted_arr (list of int): The sorted list of integers in non-decreasing order. if not arr: return [] min_value = min(arr) max_value = max(arr) range_of_elements = max_value - min_value + 1 holes = [0] * range_of_elements for number in arr: holes[number - min_value] += 1 sorted_arr = [] for index in range(range_of_elements): count = holes[index] while count > 0: sorted_arr.append(index + min_value) count -= 1 return sorted_arr"},{"question":"# Pigeonhole Sort Implementation and Enhancement **Description**: Pigeonhole Sort is a non-comparison-based sorting algorithm that efficiently sorts an array of integers. In this task, you are required to implement and enhance the Pigeonhole Sort algorithm considering several edge cases and performance opportunities. **Objective**: 1. Implement the Pigeonhole Sort algorithm. 2. Extend the basic implementation to handle negative integers. 3. Optimize the algorithm to manage large ranges more efficiently. **Function Signature**: ```python def enhanced_pigeonhole_sort(arr: List[int]) -> List[int]: pass ``` **Input**: * `arr` : A list of integers, which can be positive or negative. The list may also be empty. **Output**: * Returns a sorted list of integers. **Constraints**: * The input list\'s length, `n`, will be in the range 0 ≤ n ≤ 10^6. * The integers in the list may range between -10^6 to 10^6. **Performance Requirements**: * The algorithm should run in O(n + Range) time complexity in most cases. * Emphasis on handling large input sizes and ranges efficiently. **Example**: Let\'s examine a few scenarios: ```python assert enhanced_pigeonhole_sort([8, 3, 7, 3, 7]) == [3, 3, 7, 7, 8] assert enhanced_pigeonhole_sort([-5, -2, 2, 3, 4, 6, 1, 0]) == [-5, -2, 0, 1, 2, 3, 4, 6] assert enhanced_pigeonhole_sort([]) == [] assert enhanced_pigeonhole_sort([1, 1, 1, 1]) == [1, 1, 1, 1] ``` **Hints**: 1. Consider how to handle negative values properly. 2. Think about ways to efficiently use space when the range of values is large. 3. Simple errors like indexing out of bound or incorrect pigeonhole initialization can disrupt the sorting.","solution":"def enhanced_pigeonhole_sort(arr): # If the array is empty, return it as it is. if len(arr) == 0: return arr # Find the minimum and maximum elements in the array min_value = min(arr) max_value = max(arr) # Calculate the range of the elements range_ = max_value - min_value + 1 # Create holes and count array holes = [0] * range_ # Fill the holes with the frequency of each element for number in arr: holes[number - min_value] += 1 # Construct the sorted array sorted_array = [] for index in range(range_): while holes[index] > 0: sorted_array.append(index + min_value) holes[index] -= 1 return sorted_array"},{"question":"# B-Tree Implementation and Operations **Problem Statement**: You are asked to implement a B-Tree data structure and its core operations efficiently. A B-Tree is a self-balancing tree data structure that maintains sorted data and allows searches, sequential access, insertions, and deletions in logarithmic time. **Operations to Implement**: 1. **Insertion**: `insert_key(self, key) -> None` 2. **Deletion**: `remove_key(self, key) -> None` 3. **Search**: `find(self, key) -> bool` 4. **Traversal**: `traverse_tree(self) -> None` **Detailed Requirements**: 1. **Insertion**: - Insert a key into the B-Tree while maintaining the B-Tree properties. - Handle node splitting when necessary. 2. **Deletion**: - Remove a key while ensuring the tree remains balanced. - Handle merging and redistribution of nodes. 3. **Search**: - Search for a key in the B-Tree and return `True` if found; otherwise, return `False`. 4. **Traversal**: - Traverse the tree and print keys in sorted order. **Input/Output Formats**: - **Insert Method**: - Input: `insert_key(key: int)` - Output: None - **Delete Method**: - Input: `remove_key(key: int)` - Output: None - **Search Method**: - Input: `find(key: int) -> bool` - Output: `True` or `False` depending on whether the key is found. - **Traversal Method**: - Input: `traverse_tree()` - Output: Print keys in sorted order. **Constraints**: - The keys are integers. - Tree degree `t` (minimum degree) is given and is at least 2. **Performance Requirements**: - Ensure all operations (insert, delete, search) are logarithmic in time complexity relative to the number of elements in the tree. **Example**: ```python # Create a B-Tree with minimum degree t=2 b_tree = BTree(t_val=2) # Insert keys b_tree.insert_key(10) b_tree.insert_key(20) b_tree.insert_key(5) b_tree.insert_key(6) b_tree.insert_key(12) b_tree.insert_key(30) b_tree.insert_key(7) b_tree.insert_key(17) # Traverse the tree b_tree.traverse_tree() # Output: 5 6 7 10 12 17 20 30 # Search for a key print(b_tree.find(6)) # Output: True print(b_tree.find(21)) # Output: False # Delete a key b_tree.remove_key(6) b_tree.traverse_tree() # Output: 5 7 10 12 17 20 30 ``` Note: You are expected to implement the B-Tree structure and its methods from scratch according to the specifications outlined here. Ensure your implementation maintains the properties and efficiency of a B-Tree.","solution":"class BTreeNode: def __init__(self, t, leaf=False): self.t = t # minimum degree (defines the range for number of keys) self.leaf = leaf # True if leaf node, else False self.keys = [] # list of keys in node self.children = [] # list of child pointers class BTree: def __init__(self, t_val): self.t = t_val # minimum degree of B-tree self.root = BTreeNode(t_val, True) # initially root is a leaf def traverse_tree(self): self._traverse_node(self.root) def _traverse_node(self, node): for i in range(len(node.keys)): if not node.leaf: self._traverse_node(node.children[i]) print(node.keys[i], end=\\" \\") if not node.leaf: self._traverse_node(node.children[len(node.keys)]) def find(self, key): return self._find_in_node(self.root, key) def _find_in_node(self, node, key): i = 0 while i < len(node.keys) and key > node.keys[i]: i += 1 if i < len(node.keys) and key == node.keys[i]: return True if node.leaf: return False return self._find_in_node(node.children[i], key) def insert_key(self, key): root = self.root if len(root.keys) == (2 * self.t) - 1: temp = BTreeNode(self.t) self.root = temp temp.children.insert(0, root) self._split_child(temp, 0) self._insert_non_full(temp, key) else: self._insert_non_full(root, key) def _split_child(self, parent, i): t = self.t node = parent.children[i] new_node = BTreeNode(node.t, node.leaf) parent.children.insert(i + 1, new_node) parent.keys.insert(i, node.keys[t - 1]) new_node.keys = node.keys[t: (2 * t) - 1] node.keys = node.keys[0: t - 1] if not node.leaf: new_node.children = node.children[t: 2 * t] node.children = node.children[0: t - 1] def _insert_non_full(self, node, key): t = self.t i = len(node.keys) - 1 if node.leaf: node.keys.append(key) node.keys.sort() else: while i >= 0 and key < node.keys[i]: i -= 1 i += 1 if len(node.children[i].keys) == (2 * t) - 1: self._split_child(node, i) if key > node.keys[i]: i += 1 self._insert_non_full(node.children[i], key) def remove_key(self, key): self._remove_key_from_node(self.root, key) if len(self.root.keys) == 0: if not self.root.leaf: self.root = self.root.children[0] else: self.root = BTreeNode(self.t, True) def _remove_key_from_node(self, node, key): t = self.t i = 0 while i < len(node.keys) and key > node.keys[i]: i += 1 if i < len(node.keys) and key == node.keys[i]: if node.leaf: node.keys.pop(i) else: self._remove_internal_key(node, key, i) elif node.leaf: return else: flag = (i == len(node.keys)) if len(node.children[i].keys) < t: self._fill_child(node, i) if flag and i > len(node.keys): self._remove_key_from_node(node.children[i-1], key) else: self._remove_key_from_node(node.children[i], key) def _remove_internal_key(self, node, key, i): t = self.t if len(node.children[i].keys) >= t: pred = self._get_predecessor(node, i) node.keys[i] = pred self._remove_key_from_node(node.children[i], pred) elif len(node.children[i + 1].keys) >= t: succ = self._get_successor(node, i) node.keys[i] = succ self._remove_key_from_node(node.children[i + 1], succ) else: self._merge_children(node, i) self._remove_key_from_node(node.children[i], key) def _get_predecessor(self, node, i): current = node.children[i] while not current.leaf: current = current.children[-1] return current.keys[-1] def _get_successor(self, node, i): current = node.children[i + 1] while not current.leaf: current = current.children[0] return current.keys[0] def _fill_child(self, node, i): t = self.t if i != 0 and len(node.children[i - 1].keys) >= t: self._borrow_from_prev(node, i) elif i != len(node.keys) and len(node.children[i + 1].keys) >= t: self._borrow_from_next(node, i) else: if i != len(node.keys): self._merge_children(node, i) else: self._merge_children(node, i - 1) def _borrow_from_prev(self, node, i): child = node.children[i] sibling = node.children[i - 1] for j in range(len(child.keys) - 1, -1, -1): child.keys.insert(j + 1, child.keys[j]) if not child.leaf: for j in range(len(child.children) - 1, -1, -1): child.children.insert(j + 1, child.children[j]) child.keys.insert(0, node.keys[i - 1]) if not child.leaf: child.children.insert(0, sibling.children[-1]) sibling.children.pop() node.keys[i - 1] = sibling.keys.pop() def _borrow_from_next(self, node, i): child = node.children[i] sibling = node.children[i + 1] child.keys.append(node.keys[i]) node.keys[i] = sibling.keys.pop(0) if not sibling.leaf: child.children.append(sibling.children.pop(0)) def _merge_children(self, node, i): t = self.t child = node.children[i] sibling = node.children[i + 1] child.keys.append(node.keys.pop(i)) for j in range(len(sibling.keys)): child.keys.append(sibling.keys[j]) if not sibling.leaf: for j in range(len(sibling.children)): child.children.append(sibling.children[j]) node.children.pop(i + 1)"},{"question":"You have been tasked to extend the function `contain_string` to increase its efficiency. The current implementation performs a brute-force search to find the index of the first occurrence of a substring (needle) within a larger string (haystack). However, this approach can be slow for large inputs due to its O(n*m) time complexity. Your task is to use an improved algorithm, such as the Knuth-Morris-Pratt (KMP) algorithm, to optimize this function. The KMP algorithm builds a partial match table (also known as the \\"prefix\\" table) to skip unnecessary comparisons, reducing the overall time complexity to O(n + m). # Requirements 1. Implement the `contain_string_optimized(haystack, needle)` function using the KMP algorithm. 2. Ensure the function returns the index of the first occurrence of the needle in the haystack if found, and -1 if the needle is not a substring of the haystack. 3. Address edge cases where the needle is an empty string (should return 0) and where the needle is longer than the haystack (should return -1). # Input Format - `haystack`: A string containing the text in which to search for the `needle`. - `needle`: A string containing the pattern to search for within `haystack`. # Output Format - Return an integer representing the index of the first occurrence of `needle` in `haystack`, or -1 if `needle` is not found. # Constraints - `1 <= len(haystack) <= 10^5` - `1 <= len(needle) <= 10^5` - Both `haystack` and `needle` comprise only lowercase English letters. # Example **Input:** ```python haystack = \\"abxabcabcaby\\" needle = \\"abcaby\\" ``` **Output:** ```python 6 ``` # Explanation: In the given example, the substring \\"abcaby\\" first appears in the haystack starting from index 6. # Function Signature ```python def contain_string_optimized(haystack: str, needle: str) -> int: pass ``` # Note Implement the function `contain_string_optimized` using the KMP algorithm or another efficient substring search algorithm to meet the performance requirements.","solution":"def build_lps(needle): Builds the longest prefix which is also suffix array (lps) for the KMP algorithm. lps = [0] * len(needle) length = 0 # length of the previous longest prefix suffix i = 1 while i < len(needle): if needle[i] == needle[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps def contain_string_optimized(haystack: str, needle: str) -> int: Uses the KMP algorithm to find the index of the first occurrence of the needle in the haystack. Returns -1 if not found. if not needle: return 0 n, m = len(haystack), len(needle) if m > n: return -1 lps = build_lps(needle) i = j = 0 # i is index for haystack, j is index for needle while i < n: if haystack[i] == needle[j]: i += 1 j += 1 if j == m: return i - j # match found, return index elif i < n and haystack[i] != needle[j]: if j != 0: j = lps[j - 1] else: i += 1 return -1 # no match found"},{"question":"# Coding Challenge: Implement and Optimize Merge Sort **Objective**: Given an array of integers, you are required to implement the Merge Sort algorithm. Your implementation should handle the array in an efficient manner and should work correctly for all edge cases. **Requirements**: - Implement the `merge_sort` function that takes an array `arr` as input and returns the sorted array. - Ensure that the `merge` helper function is optimized for in-place merging to reduce space complexity. - Your algorithm should maintain the stability of the sort. **Input**: The input will be provided as a list of integers `arr`. **Output**: Return the sorted list of integers. **Constraints**: - [1 <= len(arr) <= 10^5] - [-10^9 <= arr[i] <= 10^9] **Example**: ``` Input: arr = [38, 27, 43, 3, 9, 82, 10] Output: [3, 9, 10, 27, 38, 43, 82] Input: arr = [1, 20, 6, 4, 5] Output: [1, 4, 5, 6, 20] ``` # Implementation: ```python def merge_sort(arr): if len(arr) <= 1: return arr mid = len(arr) // 2 left, right = merge_sort(arr[:mid]), merge_sort(arr[mid:]) # Perform in-place merging merge(left, right, arr) return arr def merge(left, right, merged): left_cursor, right_cursor = 0, 0 while left_cursor < len(left) and right_cursor < len(right): if left[left_cursor] <= right[right_cursor]: merged[left_cursor + right_cursor] = left[left_cursor] left_cursor += 1 else: merged[left_cursor + right_cursor] = right[right_cursor] right_cursor += 1 for left_cursor in range(left_cursor, len(left)): merged[left_cursor + right_cursor] = left[left_cursor] for right_cursor in range(right_cursor, len(right)): merged[left_cursor + right_cursor] = right[right_cursor] ```","solution":"def merge_sort(arr): if len(arr) <= 1: return arr mid = len(arr) // 2 left, right = merge_sort(arr[:mid]), merge_sort(arr[mid:]) # Perform in-place merging merge(left, right, arr) return arr def merge(left, right, merged): left_cursor, right_cursor = 0, 0 while left_cursor < len(left) and right_cursor < len(right): if left[left_cursor] <= right[right_cursor]: merged[left_cursor + right_cursor] = left[left_cursor] left_cursor += 1 else: merged[left_cursor + right_cursor] = right[right_cursor] right_cursor += 1 for left_cursor in range(left_cursor, len(left)): merged[left_cursor + right_cursor] = left[left_cursor] for right_cursor in range(right_cursor, len(right)): merged[left_cursor + right_cursor] = right[right_cursor]"},{"question":"# Inorder Traversal Enhancement **Context**: You are given a simple binary tree structure with an inorder traversal implemented both iteratively and recursively. While these implementations work for basic cases, real-world applications often demand additional features such as handling more complex tree structures or performing traversal while maintaining certain constraints. Problem Statement: Extend the given inorder traversal to support the following additional functionalities: 1. **Parent Pointer**: Modify the binary tree node structure to include a pointer to the parent node. 2. **Handling Duplicates**: Ensure that the inorder traversal can handle trees with duplicate values. 3. **Range Queries**: Implement a function that performs an inorder traversal returning only the nodes within a specific range [low, high]. 4. **Balance Check**: Implement a function that checks if the tree is balanced (the height difference between left and right subtrees for any node is not more than 1). Input and Output * **Input**: - `root`: The root node of the binary tree. - `low`: Integer representing the lower bound of the range (for range queries). - `high`: Integer representing the upper bound of the range (for range queries). * **Output**: - A list of integers representing the inorder traversal within the specified range. - A boolean value indicating whether the tree is balanced. Constraints: - All values in the tree nodes are integers. Performance Requirements: - Your functions should have a time complexity of O(n) where n is the number of nodes in the tree. Function Signatures: ```python class Node: def __init__(self, val, left=None, right=None, parent=None): self.val = val self.left = left self.right = right self.parent = parent def inorder_range(root, low, high): # Returns list of node values in-order between low and high (inclusive) pass def is_balanced(root): # Returns True if the tree is balanced, False otherwise pass ``` **Example**: ```python if __name__ == \'__main__\': n1 = Node(100) n2 = Node(50, parent=n1) n3 = Node(150, parent=n1) n4 = Node(25, parent=n2) n5 = Node(75, parent=n2) n6 = Node(125, parent=n3) n7 = Node(175, parent=n3) n1.left, n1.right = n2, n3 n2.left, n2.right = n4, n5 n3.left, n3.right = n6, n7 print(inorder_range(n1, 50, 150)) # Output: [50, 75, 100, 125, 150] print(is_balanced(n1)) # Output: True ```","solution":"class Node: def __init__(self, val, left=None, right=None, parent=None): self.val = val self.left = left self.right = right self.parent = parent def inorder_range(root, low, high): Performs an inorder traversal of the binary tree and returns the values of nodes within the range [low, high]. result = [] def _inorder(node): if not node: return # Traverse the left subtree _inorder(node.left) # Visit the current node if low <= node.val <= high: result.append(node.val) # Traverse the right subtree _inorder(node.right) _inorder(root) return result def is_balanced(root): Checks if the binary tree is balanced. def _check_balance(node): if not node: return 0, True left_height, left_balanced = _check_balance(node.left) right_height, right_balanced = _check_balance(node.right) current_height = 1 + max(left_height, right_height) height_diff = abs(left_height - right_height) current_balanced = left_balanced and right_balanced and (height_diff <= 1) return current_height, current_balanced _, balanced = _check_balance(root) return balanced"},{"question":"# Question: Implement Newton\'s Method for Square Roots with Additional Features You are required to implement an enhanced version of the Newton-Raphson method for estimating square roots, based on the following specifications: Function Signature ```python def enhanced_square_root(n: float, epsilon: float = 0.001) -> float: pass ``` Parameters - `n` (float): A positive floating point number representing the value whose square root is to be computed. - `epsilon` (float, optional): A positive floating point number representing the desired precision of the result. The default value is 0.001. Return - (float): An estimation of the square root of `n` with the specified precision. Constraints - The function should handle values of `n` from 1e-5 to 1e10. - Precision `epsilon` should be a positive value less than 1. Requirements - Ensure that your implementation correctly handles edge cases such as: - Extremely small values of `n` close to zero. - Large values requiring high precision. - Verify if `n` is a perfect square, and return the exact square root directly if true. Example ```python # Example 1 n = 5 epsilon = 0.001 # Notice that the actual square root of 5 is approximately 2.236 # Therefore, the output could be a value between 2.235 and 2.237 print(enhanced_square_root(n, epsilon)) # Expected range: [2.235, 2.237] # Example 2 n = 0.0001 epsilon = 0.00001 print(enhanced_square_root(n, epsilon)) # Expected range around: 0.01 ``` Notes - Consider using an improved initial guess to enhance convergence speed. - Validate input parameters to ensure they meet the specified constraints.","solution":"def enhanced_square_root(n: float, epsilon: float = 0.001) -> float: Calculate the square root of a number using the Newton-Raphson method with a specified precision. Parameters: - n (float): The number to find the square root of. Must be positive. - epsilon (float): The desired precision of the result. Default is 0.001. Returns: - float: The estimated square root of the number. if n < 0: raise ValueError(\\"The value of n must be a non-negative number.\\") if epsilon <= 0 or epsilon >= 1: raise ValueError(\\"Epsilon should be a positive number less than 1.\\") # Handle the case for very small n where n is close to 0 if n == 0: return 0.0 # Handle perfect squares directly if int(n**0.5)**2 == n: return float(int(n**0.5)) # Initial guess can be n / 2.0 or a better initial guess guess = n / 2.0 while True: next_guess = (guess + n / guess) / 2.0 if abs(guess - next_guess) < epsilon: return next_guess guess = next_guess"},{"question":"# Pairwise Swap Algorithm in a Stack Problem Statement: Given a stack of integers, write a function `switch_pairs(stack)` that switches successive pairs of numbers starting from the bottom of the stack. If there is an odd number of values in the stack, the value at the top of the stack should not be moved. Input: - A list of integers representing the stack. The first element in the list is the bottom of the stack and the last element is the top. Output: - A list of integers representing the stack after successive pairs have been switched. Constraints: - You are allowed to use only one auxiliary data structure. Example: ```python # Example 1 stack = [3, 8, 17, 9, 1, 10] print(switch_pairs(stack)) # Expected Output: [8, 3, 9, 17, 10, 1] # Example 2 stack = [3, 8, 17, 9, 1] print(switch_pairs(stack)) # Expected Output: [8, 3, 9, 17, 1] ``` Performance Requirements: - The solution should have a time complexity of O(n) and space complexity of O(n).","solution":"def switch_pairs(stack): Switch successive pairs of elements in the input stack. Parameters: stack (list of int): The input stack represented as a list. The first element is the bottom of the stack and the last element is the top. Returns: list of int: The stack after switching successive pairs. n = len(stack) for i in range(0, n - 1, 2): stack[i], stack[i + 1] = stack[i + 1], stack[i] return stack"},{"question":"# Question In this exercise, you are required to implement a function `find_paths` that finds all paths from a given start node to an end node in a directed graph. The graph is represented using the provided `Node`, `DirectedEdge`, and `DirectedGraph` classes. Function Signature ```python def find_paths(directed_graph, start_node, end_node): Args: directed_graph (DirectedGraph): The directed graph instance. start_node (str): The name of the start node. end_node (str): The name of the end node. Returns: List[List[str]]: A list of all paths from start_node to end_node, each path represented as a list of node names. pass ``` # Input * A `DirectedGraph` instance with added nodes and edges. * `start_node`: A string denoting the name of the start node. * `end_node`: A string denoting the name of the end node. # Output * A list of paths, where each path is itself a list of node names representing a valid, directed path from `start_node` to `end_node`. # Constraints * Ensure your solution handles cases where there are no paths available. * Avoid cycles to prevent infinite loops. * The solution should be efficient enough to handle moderately sized graphs with around 100 nodes and 500 edges. # Example ```python graph = DirectedGraph({ \\"A\\": [\\"B\\", \\"C\\"], \\"B\\": [\\"C\\", \\"D\\"], \\"C\\": [\\"D\\"], \\"D\\": [\\"E\\"], \\"E\\": [] }) print(find_paths(graph, \\"A\\", \\"D\\")) # Output: [[\'A\', \'B\', \'D\'], [\'A\', \'B\', \'C\', \'D\'], [\'A\', \'C\', \'D\']] ``` # Implementation Hints * Use depth-first search (DFS) to explore all possible paths. * Maintain a visited set to avoid cycles. * Collect paths using a temporary list during recursive traversal and store complete paths once the end node is reached.","solution":"class Node: def __init__(self, name): self.name = name self.neighbors = [] def __repr__(self): return self.name class DirectedEdge: def __init__(self, frm, to): self.frm = frm self.to = to class DirectedGraph: def __init__(self): self.nodes = {} def add_node(self, name): if name not in self.nodes: self.nodes[name] = Node(name) def add_edge(self, frm, to): if frm not in self.nodes: self.add_node(frm) if to not in self.nodes: self.add_node(to) self.nodes[frm].neighbors.append(self.nodes[to]) def find_paths(directed_graph, start_node, end_node): def dfs(current_node, end_node, path, paths): path.append(current_node.name) if current_node.name == end_node: paths.append(path.copy()) else: for neighbor in current_node.neighbors: if neighbor.name not in path: # avoid cycles dfs(neighbor, end_node, path, paths) path.pop() if start_node not in directed_graph.nodes or end_node not in directed_graph.nodes: return [] all_paths = [] start = directed_graph.nodes[start_node] dfs(start, end_node, [], all_paths) return all_paths"},{"question":"# Bogo Sort Simulation and Analysis Objective Given a sorting algorithm, Bogo Sort, which sorts an array by repeatedly shuffling it until it is sorted, your task is to implement a function that evaluates its performance and analyze the iterations it takes to sort arrays of different sizes. Prompt 1. **Implement the `bogo_sort` function as described.** Ensure it correctly identifies when the array is sorted and efficiently shuffles the array. 2. **Modify the `bogo_sort` function to count and return the number of iterations it takes to sort the array.** Utilize a limit for maximum iteration to avoid infinite loops. 3. **Create a `evaluate_performance` function.** This function should test the `bogo_sort` on arrays of different sizes and return the average number of iterations required for each size. Input and Output Formats - The `bogo_sort` function: - **Input**: A list of integers representing the array to be sorted. - **Output**: Return the sorted list and the number of iterations it took to sort. - The `evaluate_performance` function: - **Input**: A list of integers representing different array sizes to be tested. - **Output**: A dictionary where the key is the array size, and the value is the average number of iterations required to sort arrays of that size. Constraints - For the evaluation, restrict the `bogo_sort` function to a maximum of `10000` iterations to prevent infinite loops. - Test the `bogo_sort` function on small arrays (sizes up to `10`) to ensure completion within reasonable time. Requirements - Handle edge cases, such as already sorted arrays and arrays with duplicated elements. - Each array size in `evaluate_performance` should be tested on at least `100` randomly generated arrays to compute the average number of iterations. # Example ```python def bogo_sort(arr, max_iter=10000): # your implementation def evaluate_performance(sizes): # your implementation print(evaluate_performance([2,3,4,5,6])) # Example output: {2: 2.5, 3: 16.0, 4: 50.0, 5: 300.0, 6: 1700.0} ```","solution":"import random def is_sorted(arr): Checks if the array is sorted in non-decreasing order. for i in range(len(arr) - 1): if arr[i] > arr[i + 1]: return False return True def bogo_sort(arr, max_iter=10000): Sorts an array using Bogo Sort algorithm and returns the sorted array along with the number of iterations it took to sort. Limits to max_iter to avoid infinite loop. iterations = 0 while not is_sorted(arr) and iterations < max_iter: random.shuffle(arr) iterations += 1 return arr, iterations def evaluate_performance(sizes, num_trials=100): Evaluates the performance of Bogo Sort by calculating the average number of iterations it takes to sort arrays of various sizes. :param sizes: List of array sizes to be tested. :param num_trials: Number of trials for each array size to compute the average iterations. :return: Dictionary mapping array sizes to the average number of iterations required. results = {} for size in sizes: total_iterations = 0 for _ in range(num_trials): array = [random.randint(0, 100) for _ in range(size)] _, iterations = bogo_sort(array) total_iterations += iterations results[size] = total_iterations / num_trials return results"},{"question":"# Question: Efficient Calculation of Binomial Coefficient You are given the task to design an efficient algorithm that calculates the binomial coefficient `C(n, r)`, which represents the number of ways to choose `r` items from `n` distinct items. This is key in combinatorial problems and statistical calculations. However, for larger values of `n` and `r`, performance matters, so consider optimized solutions. # Objective Implement a function `binomial_coefficient(n: int, r: int) -> int` that calculates the binomial coefficient efficiently. # Requirements 1. The solution must handle the recursive approach initially but should be optimized using memoization to avoid redundant calculations. 2. Consider the edge cases and validate the function inputs effectively. # Function Signature ```python def binomial_coefficient(n: int, r: int) -> int: pass ``` # Input - An integer `n` (0 <= n <= 100) - An integer `r` (0 <= r <= n) # Output - Returns an integer which is the binomial coefficient C(n, r). # Constraints - The function should handle up to 100 for `n` within reasonable execution time. # Example ```python # Example 1 print(binomial_coefficient(5, 2)) # Output: 10 (5C2) # Example 2 print(binomial_coefficient(10, 5)) # Output: 252 (10C5) ``` # Notes - The function should handle invalid inputs such as `r > n` by returning 0. - Optimize for performance by using a memoization technique. - Consider both time and space complexities while implementing the function.","solution":"def binomial_coefficient(n: int, r: int) -> int: if r > n: return 0 # Initialize the memoization table memo = [[-1 for _ in range(r+1)] for _ in range(n+1)] def binomial_coefficient_memo(n, r): if r == 0 or r == n: return 1 if memo[n][r] != -1: return memo[n][r] memo[n][r] = binomial_coefficient_memo(n-1, r-1) + binomial_coefficient_memo(n-1, r) return memo[n][r] return binomial_coefficient_memo(n, r)"},{"question":"You are given a range from 1 to 3999 (both inclusive) and need to write a function that converts a given integer within this range to its corresponding Roman numeral. # Function Signature ```python def int_to_roman(num): :type num: int :rtype: str ``` # Input - `num` (int): An integer within the range from 1 to 3999 (inclusive). # Output - `str`: The Roman numeral representation of the given integer. # Constraints - 1 ≤ num ≤ 3999 # Example ```python print(int_to_roman(58)) # Output: \\"LVIII\\" print(int_to_roman(1994)) # Output: \\"MCMXCIV\\" print(int_to_roman(3999)) # Output: \\"MMMCMXCIX\\" ``` # Explanation - For the input 58, the conversion goes as: - Tens: 50 (L) - Units: 8 (VIII) - For the input 1994, the conversion goes as: - Thousands: 1000 (M) - Hundreds: 900 (CM) - Tens: 90 (XC) - Units: 4 (IV) # Solution Requirements - You must consider the performance for the given constraints, ensuring the implementation remains efficient with constant-time operations. - Be cautious about how you handle indices to avoid out-of-bounds errors. - Ensure your implementation adheres strictly to standard Roman numeral conventions. Implement the function as per the provided signature to pass the example test cases.","solution":"def int_to_roman(num): Converts an integer to its corresponding Roman numeral. :param num: int: The integer to convert, in the range 1 to 3999. :return: str: The Roman numeral representation of the integer. val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syb = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_num = \'\' i = 0 while num > 0: for _ in range(num // val[i]): roman_num += syb[i] num -= val[i] i += 1 return roman_num"},{"question":"Kruskal\'s Minimum Spanning Tree As a network engineer, you’ve been tasked with creating an efficient, cost-effective network. Given an undirected graph representing the network nodes and the connections between them, your goal is to find the Minimum Spanning Tree (MST) such that the total cost to connect all nodes is minimized. Implement Kruskal’s algorithm to compute the MST. **Function Signature**: ```python def minimum_spanning_tree(vertex_count: int, edge_list: List[Tuple[int, int, int]]) -> int: ``` # Input - `vertex_count` (int): The number of vertices in the graph, V. - `edge_list` (List[Tuple[int, int, int]]): A list of tuples where each tuple represents an edge between two nodes with format (source, target, weight). `source` and `target` are zero-indexed. # Output - (int): The sum of the weights of the edges in the Minimum Spanning Tree (MST). # Constraints - 1 ≤ V ≤ 1000 - 0 ≤ E ≤ 100000 - -1000 ≤ weight ≤ 1000 # Examples ```python vertex_count = 5 edge_list = [ (0, 1, 3), (0, 2, 8), (1, 3, 5), (2, 3, 2), (2, 4, 4), (3, 4, 6) ] print(minimum_spanning_tree(vertex_count, edge_list)) # Output: 14 vertex_count = 3 edge_list = [ (1, 0, 20), (2, 0, 20), (1, 2, 100) ] print(minimum_spanning_tree(vertex_count, edge_list)) # Output: 40 ``` # Requirements - Implement the disjoint set (union-find) mechanism with path compression. - Sort the edges based on their weights. - Process the edges and use Kruskal’s algorithm to find and print the MST’s total weight. **Note**: You should not use any built-in libraries for disjoint set operations. Implement them from scratch.","solution":"from typing import List, Tuple class DisjointSet: def __init__(self, n): self.parent = list(range(n)) self.rank = [0] * n def find(self, node): if self.parent[node] != node: self.parent[node] = self.find(self.parent[node]) # Path compression return self.parent[node] def union(self, node1, node2): root1 = self.find(node1) root2 = self.find(node2) if root1 != root2: # Union by rank if self.rank[root1] > self.rank[root2]: self.parent[root2] = root1 elif self.rank[root1] < self.rank[root2]: self.parent[root1] = root2 else: self.parent[root2] = root1 self.rank[root1] += 1 def minimum_spanning_tree(vertex_count: int, edge_list: List[Tuple[int, int, int]]) -> int: ds = DisjointSet(vertex_count) mst_weight = 0 edge_list.sort(key=lambda x: x[2]) # Sort edges by weight for edge in edge_list: u, v, weight = edge if ds.find(u) != ds.find(v): ds.union(u, v) mst_weight += weight return mst_weight"},{"question":"You have been provided two implementations of the Binary Exponentiation algorithm: one iterative and one recursive. Both implementations calculate (a^n) efficiently in (O(log n)) time. However, the recursive implementation can consume extra space due to the call stack. # Task Your task is to implement a hybrid version of the binary exponentiation function. This hybrid function should start with the iterative approach and switch to the recursive approach once the exponent is reduced below a certain threshold. This hybrid approach aims to leverage the benefits of both methods. # Input * `a` (integer): the base of the exponentiation. * `n` (integer): the exponent. * `mod` (integer, optional): if specified, return the result modulo `mod`. * `threshold` (integer): the point at which to switch from iterative to recursive approach. (n < 0) should not be handled. # Output * Returns the result of (a^n) (mod `mod` if specified). # Constraints * (1 leq a leq 10^9) * (0 leq n leq 10^9) * (1 leq text{threshold} leq 10^6) # Example ```python def power_hybrid(a: int, n: int, mod: int = None, threshold: int = 1000) -> int: # Write your code here pass # Example Usage print(power_hybrid(2, 10)) # Output: 1024 print(power_hybrid(2, 10, 1000)) # Output: 24 print(power_hybrid(2, 3, mod=5, threshold=2)) # Output: 3 ``` Implement the function `power_hybrid` to meet the above requirements.","solution":"def power_hybrid(a: int, n: int, mod: int = None, threshold: int = 1000) -> int: def power_recursive(base, exp, modulo): if exp == 0: return 1 half = power_recursive(base, exp // 2, modulo) half = (half * half) % modulo if modulo else half * half if exp % 2 != 0: half = (half * base) % modulo if modulo else half * base return half def power_iterative(base, exp, modulo): result = 1 while exp >= threshold: if exp % 2 != 0: result = (result * base) % modulo if modulo else result * base base = (base * base) % modulo if modulo else base * base exp //= 2 return result, base, exp result, base, exp = power_iterative(a, n, mod) if exp < threshold: result = (result * power_recursive(base, exp, mod)) % mod if mod else result * power_recursive(base, exp, None) return result"},{"question":"# Scenario You are working on an application that dynamically manages a leaderboard for an online game. The player scores are continuously updated, and the leaderboard must always remain in sorted order for efficient retrieval and display. In this task, your primary job is to implement a function to find the correct position to insert a new score in the leaderboard, ensuring the leaderboard remains sorted. # Challenge Implement the `search_insert` function which finds the index of a target value in a sorted array. If the target is not found, it should return the index where it should be inserted to maintain the order. **Function Signature:** ```python def search_insert(array: List[int], val: int) -> int: Find the index or insertion point for val in sorted array. Args: array (List[int]): A sorted list of integers. val (int): The target integer. Returns: int: The index if found, otherwise the index where it would be inserted. ``` # Input Format: * `array`: a sorted list of integers where the search is performed. * `val`: an integer to be searched or inserted. # Output Format: * An integer representing the index at which `val` is found or should be inserted. # Constraints: * The array will have at most `10^4` elements. * All elements of the array fit within 32-bit integer range. # Performance Requirements: * The solution should work in logarithmic time, O(log n). # Example: ```python # Example 1 assert search_insert([1, 3, 5, 6], 5) == 2 # Example 2 assert search_insert([1, 3, 5, 6], 2) == 1 # Example 3 assert search_insert([1, 3, 5, 6], 7) == 4 # Example 4 assert search_insert([1, 3, 5, 6], 0) == 0 ``` # Notes - Ensure you handle edge cases where the array is empty. - Do not use any in-built library functions that perform binary search.","solution":"def search_insert(array, val): Find the index or insertion point for val in sorted array. Args: array (List[int]): A sorted list of integers. val (int): The target integer. Returns: int: The index if found, otherwise the index where it would be inserted. left, right = 0, len(array) - 1 while left <= right: mid = (left + right) // 2 if array[mid] == val: return mid elif array[mid] < val: left = mid + 1 else: right = mid - 1 return left"},{"question":"# Insertion Sort Extension with Median Calculation Context: Imagine you work for a financial data processing company. You have been tasked with enhancing the company\'s data preprocessing steps by implementing a feature that not only sorts a dataset using the Insertion Sort algorithm but also calculates the median of the list at each step of the sorting process. This will help in real-time analytics and monitoring of the data trends. Task: Implement a function that sorts a given list of integers using the Insertion Sort algorithm. During each step of the sort, calculate the median of the partially sorted list up to the current point. Store these medians and return them once the sorting is complete. Function Signature: ```python def insertion_sort_with_median(arr: list[int]) -> list[float]: Args: - arr: list of integers to be sorted. Returns: - list of float: a list containing the median of the list at each step of the insertion sort process. pass ``` Example: ```python arr = [5, 2, 9, 1, 6] result = insertion_sort_with_median(arr) print(result) # Expected output: [5.0, 3.5, 5.0, 3.5, 5.0] ``` Constraints: * The list contains at least one integer and no more than 10^3 integers. * The values in the list are in the range of -10^6 to 10^6. Performance Requirements: * The function should work efficiently within the given constraints. Your implementation should ensure that the computation of the median at each step is efficient to avoid performance bottlenecks.","solution":"def insertion_sort_with_median(arr: list[int]) -> list[float]: Sorts the given list using the Insertion Sort algorithm and calculates the median at each step. Parameters: - arr (list[int]): List of integers to be sorted. Returns: - list[float]: List of medians at each step of the sorting process. def calculate_median(nums: list[int]) -> float: n = len(nums) if n % 2 == 1: return float(nums[n//2]) else: return (nums[n//2 - 1] + nums[n//2]) / 2 medians = [] sorted_sublist = [] for num in arr: # Insert the current number into the sorted sublist sorted_sublist.append(num) sorted_sublist.sort() # Calculate the median of the current sorted sublist median = calculate_median(sorted_sublist) medians.append(median) return medians"},{"question":"# Stooge Sort Implementation and Extension Given the Stooge Sort algorithm, which is notoriously inefficient but interesting from an educational standpoint, your task is two-fold: 1. **Function Implementation**: Implement the Stooge Sort algorithm as a Python function. 2. **Additional Feature**: After sorting the array, return the number of swaps that occurred during the sorting process. # Requirements 1. **Input**: - An integer array `arr` of length `n` (1 <= n <= 1000). - Two indices `l` and `h` representing the segment of the array to sort. 2. **Output**: - The sorted array. - The number of swaps performed. # Constraints - The function should handle the recursion efficiently. - The input array can have both positive and negative integers. # Example ```python Input: arr = [4, 3, 2, 1] l = 0 h = 3 Output: sorted_array = [1, 2, 3, 4] num_swaps = 4 ``` # Function Signature ```python def stoogesort(arr: List[int], l: int, h: int) -> Tuple[List[int], int]: pass ``` # Instructions - Write a function `stoogesort(arr: List[int], l: int, h: int) -> Tuple[List[int], int]` that takes an array `arr` and indices `l` and `h`, sorts the array using Stooge Sort, and returns the sorted array along with the count of swaps. - Ensure your code handles possible edge cases effectively. - Avoid using built-in sorting libraries, and focus on a proper implementation of the given algorithm.","solution":"from typing import List, Tuple def stoogesort(arr: List[int], l: int, h: int) -> Tuple[List[int], int]: swap_count = 0 def sort(arr, l, h): nonlocal swap_count if l >= h: return # If the first element is greater than the last, swap them if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] swap_count += 1 # If there are at least three elements if h-l+1 > 2: t = (h-l+1) // 3 # Recursively sort first 2/3 elements sort(arr, l, h-t) # Recursively sort last 2/3 elements sort(arr, l+t, h) # Recursively sort first 2/3 elements again to confirm sort(arr, l, h-t) sort(arr, l, h) return arr, swap_count"},{"question":"You are given a number `a`, an exponent `n`, and an optional modulus `mod`. Your task is to implement the binary exponentiation algorithm both iteratively and recursively, which efficiently calculates (a^n) while optionally computing the result modulo `mod`. # Function Signature: ```python def power(a: int, n: int, mod: int = None) -> int: pass def power_recur(a: int, n: int, mod: int = None) -> int: pass ``` # Input: - `a` (integer, 0 ≤ |a| ≤ 10^9): the base number. - `n` (integer, 0 ≤ n ≤ 10^9): the exponent. - `mod` (integer, optional, 1 ≤ mod ≤ 10^9): modulus for the result, if provided. # Output: - Both functions should return an integer, the result of (a^n). - If `mod` is provided, the result should be (a^n mod text{mod}). # Constraints: - `a` can be positive or negative, zero. - `n` is always non-negative. - If `mod` is not provided, you may assume it to be `None`. # Example: ```python # Example 1: power(2, 10) # returns 1024 power_recur(2, 10) # returns 1024 # Example 2: power(2, 10, 1000) # returns 24 power_recur(2, 10, 1000) # returns 24 # Example 3: power(-2, 3) # returns -8 power_recur(-2, 3) # returns -8 # Example 4: power(0, 5) # returns 0 power_recur(0, 5) # returns 0 # Example 5: power(2, 0) # returns 1 power_recur(2, 0) # returns 1 ``` # Notes: - Focus on the performance and correctness of your implementation. - Ensure to handle all edge cases such as (a=0), (n=0), and (mod) provided appropriately. - You may assume all inputs are within the provided constraints.","solution":"def power(a: int, n: int, mod: int = None) -> int: result = 1 base = a if mod: base %= mod while n > 0: if n % 2 == 1: # If n is odd, multiply by the base result = (result * base) % mod if mod else result * base base = (base * base) % mod if mod else base * base n //= 2 return result def power_recur(a: int, n: int, mod: int = None) -> int: if n == 0: return 1 if n % 2 == 1: return (a * power_recur(a, n-1, mod)) % mod if mod else a * power_recur(a, n-1, mod) half = power_recur(a, n // 2, mod) return (half * half) % mod if mod else half * half"},{"question":"# Pattern Matching with Substring Mapping Problem Statement You are given a pattern and a string. Your task is to determine if the string follows the same pattern. A string follows a pattern if there is a bijection between a letter in the pattern and a non-empty substring in the string. Input 1. `pattern` (1 <= length of pattern <= 10): A string contains only lowercase letters. 2. `string` (1 <= length of string <= 20): A string contains only lowercase letters. Output Return `True` if the string follows the given pattern, otherwise return `False`. Examples ```plaintext pattern = \\"abab\\", string = \\"redblueredblue\\" Output: True pattern = \\"aaaa\\", string = \\"asdasdasdasd\\" Output: True pattern = \\"aabb\\", string = \\"xyzabcxzyabc\\" Output: False ``` Constraints - You may assume both pattern and string contain only lowercase letters. - The lengths of the pattern and the string are constrained to ensure the solution completes in a reasonable time. Requirements Implement the function `pattern_match(pattern, string)` that takes in a string `pattern` and a string `string` and returns a boolean value indicating whether the string follows the given pattern.","solution":"def pattern_match(pattern, string): def is_match(pattern, string, p_map, s_map): if not pattern: return not string if pattern[0] in p_map: mapped = p_map[pattern[0]] if string.startswith(mapped): return is_match(pattern[1:], string[len(mapped):], p_map, s_map) return False for i in range(1, len(string) - len(pattern) + 2): candidate = string[:i] if candidate in s_map: continue p_map[pattern[0]] = candidate s_map[candidate] = pattern[0] if is_match(pattern[1:], string[i:], p_map, s_map): return True del p_map[pattern[0]] del s_map[candidate] return False return is_match(pattern, string, {}, {})"},{"question":"**Scenario**: You have been hired by an e-book company to improve the search functionality on their online reader. Users can highlight text and search for specific phrases within their books. Your task as a developer is to implement a function that efficiently finds the first occurrence of a user\'s search phrase (needle) within the book\'s text (haystack). Your goal is to create a more efficient function to improve user experience by reducing search time, even for large books (haystacks) and phrases (needles). **Function Signature**: ```python def contain_string(haystack: str, needle: str) -> int: pass ``` **Input**: - `haystack`: The entire content of the book as a single string (1 <= len(haystack) <= 10^5) - `needle`: The search phrase as a string (0 <= len(needle) <= 10^4) **Output**: - Return the index of the first occurrence of `needle` in `haystack`. - If `needle` is not part of `haystack`, return -1. **Constraints**: - Empty `needle` should return 0. - Aim to optimize for larger inputs. **Performance Requirements**: - Time Complexity should ideally be better than O((N - M + 1) * M). **Examples**: ```python assert contain_string(\\"hello\\", \\"ll\\") == 2 assert contain_string(\\"aaaaa\\", \\"bba\\") == -1 assert contain_string(\\"\\", \\"\\") == 0 assert contain_string(\\"a\\", \\"\\") == 0 assert contain_string(\\"abc\\", \\"c\\") == 2 assert contain_string(\\"mississippi\\", \\"pi\\") == 9 ``` **Notes**: - Discuss and implement any advanced substring search algorithms like KMP (Knuth-Morris-Pratt), Boyer-Moore, or Rabin-Karp if necessary to meet performance requirements.","solution":"def contain_string(haystack: str, needle: str) -> int: Returns the index of the first occurrence of `needle` in `haystack`, or -1 if `needle` is not part of `haystack`. Implements Knuth-Morris-Pratt (KMP) algorithm for efficient pattern searching. if not needle: return 0 # Generate the KMP partial match table (also known as \\"failure function\\") def kmp_table(needle): table = [0] * len(needle) j = 0 for i in range(1, len(needle)): if needle[i] == needle[j]: j += 1 table[i] = j else: if j != 0: j = table[j-1] i -= 1 else: table[i] = 0 return table lps = kmp_table(needle) i = j = 0 while i < len(haystack): if haystack[i] == needle[j]: i += 1 j += 1 if j == len(needle): return i - j elif i < len(haystack) and haystack[i] != needle[j]: if j != 0: j = lps[j-1] else: i += 1 return -1"},{"question":"# Comb Sort Implementation and Enhancement Background Comb sort improves upon the basic idea of bubble sort by initially comparing elements far apart; this helps remove small values near the end and large values near the start more quickly than bubble sort. The distance between compared elements (the gap) starts out relatively large but shrinks over time. Objective Your task is to implement the Comb Sort algorithm for sorting an array. Additionally, enhance the algorithm by optimizing the gap sequence and ensure it handles edge cases efficiently. Detailed Instructions 1. Implement the `comb_sort` function that takes an array of integers as input and returns a sorted array. 2. Optimize the gap sequence, possibly trying different shrinking factors or methods for shrinking gap sizes. 3. Handle edge cases such as empty arrays, arrays with a single element, and pre-sorted arrays. Function Signature ```python def comb_sort(arr: List[int]) -> List[int]: pass ``` Input and Output Format * **Input**: A list of integers. - `arr` (1 <= len(arr) <= 10⁵): List of integers to sort. * **Output**: A new list of integers, sorted in ascending order. Constraints * The function must utilize in-place sorting. * You must ensure the function handles edge cases properly. * Aim for efficiency; prefer optimization without compromising readability. Examples ```python print(comb_sort([5, 3, 8, 4, 2])) # Output: [2, 3, 4, 5, 8] print(comb_sort([100])) # Output: [100] print(comb_sort([])) # Output: [] print(comb_sort([9, 7, 5, 3, 1])) # Output: [1, 3, 5, 7, 9] print(comb_sort([1, 2, 3, 4, 5])) # Output: [1, 2, 3, 4, 5] ```","solution":"from typing import List def comb_sort(arr: List[int]) -> List[int]: Performs comb sort on the given list and returns the sorted list. if len(arr) <= 1: return arr def get_next_gap(gap): # Shrink gap by a shrink factor of 1.3 gap = int(gap / 1.3) if gap < 1: return 1 return gap n = len(arr) gap = n swapped = True while gap != 1 or swapped: gap = get_next_gap(gap) swapped = False for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"# Question As a data analyst, you often need to calculate the number of digits in integers to format and validate user entries quickly. To enhance performance, you need a robust method that achieves this in constant time. Write a function `num_digits(n)` that will return the number of digits in a number. Your function should be designed to handle both positive and negative integers effectively. You should make sure to account for edge cases such as zero and very large integers. # Function Signature ```python def num_digits(n: int) -> int: pass ``` # Inputs * `n`: An integer (both positive and negative). # Outputs * An integer representing the number of digits in the absolute value of `n`. # Constraints * The function should work for negative numbers and zero. * The function should have a time complexity of O(1). # Examples 1. `num_digits(123)` should return `3` 2. `num_digits(-456)` should return `3` 3. `num_digits(0)` should return `1` 4. `num_digits(7890123456789)` should return `13` Use the algorithm analysis as a guide to consider all relevant edge cases and optimizations while implementing the function.","solution":"def num_digits(n: int) -> int: Return the number of digits in the absolute value of the given integer n. # Handle the edge case for zero explicitly if n == 0: return 1 # Convert absolute value of n to string and count the characters return len(str(abs(n)))"},{"question":"# Comb Sort Implementation Challenge Implement the `comb_sort` function described below in Python: Function Signature ```python def comb_sort(arr: List[int]) -> List[int]: ``` # Function Description * **Input**: A `List[int]` which represents an unsorted list of integers. * **Output**: Return a `List[int]` that represents the sorted version of the input list in ascending order. # Constraints * You should not use any built-in sorting functions (like `sorted()`, `sort()`, etc.). * The input list can be of any length from 0 to 10^6. * Handle edge cases such as an empty list, lists with all identical values, or lists with negative integers. # Performance Requirement * The implementation should keep memory overhead low (O(1) space complexity). # Scenario Imagine you are assigned the task of improving an old legacy system where the Bubble Sort algorithm is frequently used, leading to inefficiencies. Rewrite the sorting function using Comb Sort to improve its performance. Focus on adhering to the constraints mentioned and ensuring the list is always sorted correctly in ascending order.","solution":"from typing import List def comb_sort(arr: List[int]) -> List[int]: Implements the comb sort algorithm to sort an array in ascending order. def get_next_gap(gap): gap = (gap * 10) // 13 if gap < 1: return 1 return gap n = len(arr) gap = n swapped = True while gap != 1 or swapped: gap = get_next_gap(gap) swapped = False for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"Coding Assessment Question # Context: You\'re working on a piece of software that processes text data. As part of this software, you need to rearrange certain characters within strings while maintaining the positions of all others. Specifically, you need to swap the positions of all vowels in a given string. # Task: Write a function `reverse_vowels(s: str) -> str` that takes a string `s` as input and returns a new string where all the vowels in the original string are reversed in order, but all other characters remain in their original positions. # Function Signature: ```python def reverse_vowels(s: str) -> str: ``` # Input: - `s` (1 <= len(s) <= 10^5): A string consisting of ASCII characters. # Output: - A string with the vowels reversed in their positions. # Constraints: - Vowels to consider: \\"A\\", \\"E\\", \\"I\\", \\"O\\", \\"U\\" and their lowercase counterparts. - The function must operate within O(n) time complexity. - The function must limit additional space usage to O(n). # Example: ```python assert reverse_vowels(\\"hello\\") == \\"holle\\" assert reverse_vowels(\\"leetcode\\") == \\"leotcede\\" assert reverse_vowels(\\"aA\\") == \\"Aa\\" assert reverse_vowels(\\"bcdf\\") == \\"bcdf\\" assert reverse_vowels(\\"\\") == \\"\\" ``` # Explanation: 1. For input `\\"hello\\"`, the vowels \'e\' and \'o\' are reversed to form `\\"holle\\"`. 2. For input `\\"leetcode\\"`, the vowels \'e\', \'e\', and \'o\' are reversed to form `\\"leotcede\\"`. 3. For input `\\"aA\\"`, the two vowels \'a\' and \'A\' are reversed to form `\\"Aa\\"`. 4. For input `\\"bcdf\\"`, no vowels are present, so the original string `\\"bcdf\\"` is returned as-is. 5. For an empty input string `\\"\\"`, the output should also be an empty string.","solution":"def reverse_vowels(s: str) -> str: vowels = \\"aeiouAEIOU\\" s_list = list(s) i, j = 0, len(s) - 1 while i < j: if s_list[i] not in vowels: i += 1 continue if s_list[j] not in vowels: j -= 1 continue s_list[i], s_list[j] = s_list[j], s_list[i] i += 1 j -= 1 return \'\'.join(s_list)"},{"question":"You\'ve been hired by a tech company to assist in the development of a concurrent system. They are particularly concerned about deadlock scenarios where certain processes could be waiting for each other indefinitely, effectively creating a cycle. Your task is to write a function that detects cycles in the system\'s resource allocation graph. This is crucial for preventing deadlocks and ensuring the system\'s smooth operation. **Problem**: Given a directed graph represented as an adjacency list (dictionary), write a function that checks if there is a cycle within the graph. The graph is defined by key-value pairs where keys represent vertices and values are lists of adjacent vertices. **Function Signature**: ```python def contains_cycle(graph: dict) -> bool: pass ``` **Input**: - `graph` (dict): A dictionary where keys are vertex identifiers (strings) and values are lists of vertex identifiers that represent directed edges. **Output**: - Return `True` if there is a cycle in the graph. Otherwise, return `False`. **Constraints**: - The graph may contain self-loops and isolated vertices. - The graph can have up to 10^4 vertices and 10^5 edges. **Examples**: 1. Given graph: ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': [] } ``` Output: ``` True # There is a cycle involving vertices B -> D -> E -> B ``` 2. Given graph: ```python graph = { \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [\'D\'], \'D\': [\'E\'], \'E\': [] } ``` Output: ``` False # No cycles ``` **Implementation Detail**: You can use a state-tracking mechanism where each vertex can be WHITE (unvisited), GRAY (being processed), or BLACK (completed). Implement a depth-first search (DFS) to explore the graph and detect cycles based on node states.","solution":"def contains_cycle(graph: dict) -> bool: WHITE, GRAY, BLACK = 0, 1, 2 def dfs(vertex): if state[vertex] == GRAY: return True if state[vertex] == BLACK: return False state[vertex] = GRAY for neighbor in graph.get(vertex, []): if dfs(neighbor): return True state[vertex] = BLACK return False state = {vertex: WHITE for vertex in graph} for vertex in graph: if state[vertex] == WHITE: if dfs(vertex): return True return False"},{"question":"You are required to implement a function that adds two signed integers without using the \'+\' operator. The function should use bitwise operations to perform this addition. Your implementation should handle negative integers as well as positive ones. # Function Signature ```python def add_signed_integers(x: int, y: int) -> int: ``` # Input Format - `x` (int): The first integer, which can be positive or negative. - `y` (int): The second integer, which can be positive or negative. # Output Format - Return the result of adding `x` and `y` without using the \'+\' operator. # Constraints 1. The inputs `x` and `y` are in the range of a 32-bit signed integer: -2^31 <= x, y <= 2^31 - 1. # Performance Requirements - Your solution should run in linear time with respect to the number of bits in the input integers. # Example Example 1 ```python x = 2 y = 3 Output: 5 ``` Example 2 ```python x = -2 y = -3 Output: -5 ``` Example 3 ```python x = -2 y = 3 Output: 1 ``` # Assumptions - The function does not handle integer overflow which is outside the range of a typical 32-bit integer.","solution":"def add_signed_integers(x: int, y: int) -> int: # 32-bit integer max and mask MAX_INT = 0x7FFFFFFF MASK = 0xFFFFFFFF # Iterate till there\'s no carry while y != 0: # Compute carry carry = (x & y) & MASK # Perform addition without carry x = (x ^ y) & MASK # Shift carry to the left by 1 y = (carry << 1) & MASK # Handle negative numbers return x if x <= MAX_INT else ~(x ^ MASK)"},{"question":"# Question: Efficient Fibonacci Number Calculation Given a number `n`, your task is to implement an efficient algorithm to calculate the nth Fibonacci number. You are required to use an iterative approach to ensure both time and space efficiency. Input - An integer `n` (0 ≤ n ≤ 10^6). Output - Return the nth Fibonacci number. Constraints - Your solution should run in (O(n)) time complexity. - Your solution should use (O(1)) space complexity. Example ```python fib_iter(10) => 55 fib_iter(100) => 354224848179261915075 fib_iter(0) => 0 fib_iter(1) => 1 fib_iter(5) => 5 ``` Implement the function `fib_iter(n)` which returns the nth Fibonacci number. **Note**: Consider the edge cases where `n` is 0 or 1. Ensure that your solution can handle large values of `n` efficiently.","solution":"def fib_iter(n): Returns the nth Fibonacci number using an iterative approach. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for i in range(2, n + 1): a, b = b, a + b return b"},{"question":"You are given a set of distinct integers, `nums`. Your task is to write a function `generate_subsets` that returns all possible subsets of the set `nums`. # Function Signature ```python def generate_subsets(nums: List[int]) -> List[List[int]]: ``` # Input * `nums` (List[int]): A list of distinct integers where 1 <= len(nums) <= 30. # Output * List[List[int]]: A list containing all possible subsets of the input set. # Constraints * The solution set must not contain duplicate subsets. * The subsets can be returned in any order. # Examples 1. Input: `nums = [1, 2, 3]` Output: `[[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]` 2. Input: `nums = []` Output: `[[]]` # Performance Requirements * The solution should aim for a complexity of O(2^n) for both time and space. # Explanation In this problem, you are to explore all possible subsets of a given list of distinct integers. Your implementation should be able to handle an empty set as well as sets of up to 30 elements. # Scenario In a combinatorics class, you have learned about subsets and their significance in problem-solving. Your task is to implement what you have learned by writing a function that generates all possible subsets of a given set of integers. This will help you understand the practical implications of generating combinations in real-world scenarios.","solution":"from typing import List def generate_subsets(nums: List[int]) -> List[List[int]]: This function generates all possible subsets of a given list of distinct integers. subsets = [[]] # Start with an empty subset for num in nums: # For each number, add it to all existing subsets new_subsets = [subset + [num] for subset in subsets] subsets.extend(new_subsets) return subsets"},{"question":"# Decoding Encoded Messages Using Dynamic Programming You are given an encoded message containing digits, where `\\"A\\"` is `\\"1\\"`, `\\"B\\"` is `\\"2\\"`, ..., and `\\"Z\\"` is `\\"26\\"`. Your task is to write a function to determine the total number of ways to decode the message. Function Details * **Function Name**: `num_decodings` * **Parameters**: - `enc_mes` (str): The encoded message string containing only digit characters. * **Returns**: - int: The total number of ways to decode the given message. Constraints * The input string will consist of valid digit characters (`0`-`9`) only and will not be empty. * The function should validate whether the encoded message can be decoded according to the rules provided. Example Scenario Consider the input: ```python encoded_message = \\"12\\" ``` Possible decodings are: - \\"AB\\" (1 2) - \\"L\\" (12) Hence, there are 2 ways to decode the message `\\"12\\"`. Test Cases 1. `num_decodings(\\"12\\")` should return `2` 2. `num_decodings(\\"226\\")` should return `3` (2-26, 22-6, 2-2-6) 3. `num_decodings(\\"06\\")` should return `0` (Invalid consecutive starting with 0) 4. `num_decodings(\\"10\\")` should return `1` (10 only, as \'0\' cannot stand alone) # Requirements Implement the function to handle edge cases efficiently: * Sequences starting with \'0\'. * Valid two-digit sequence checks between 10 and 26 inclusively. ```python def num_decodings(enc_mes): :type enc_mes: str :rtype: int if not enc_mes or enc_mes[0] == \'0\': return 0 last_char, last_two_chars = 1, 1 for i in range(1, len(enc_mes)): last = last_char if enc_mes[i] != \'0\' else 0 last_two = last_two_chars if 10 <= int(enc_mes[i-1:i+1]) <= 26 else 0 last_two_chars = last_char last_char = last + last_two return last_char ```","solution":"def num_decodings(enc_mes): Determine the total number of ways to decode the given message. Args: enc_mes (str): The encoded message string containing only digit characters. Returns: int: The total number of ways to decode the given message. if not enc_mes or enc_mes[0] == \'0\': return 0 n = len(enc_mes) dp = [0] * (n + 1) dp[0] = 1 # An empty string has one way to be decoded dp[1] = 1 # The first character is guaranteed to be a valid character (not \'0\') for i in range(2, n + 1): one_digit = int(enc_mes[i-1:i]) two_digits = int(enc_mes[i-2:i]) # Check if single digit character is valid if 1 <= one_digit <= 9: dp[i] += dp[i-1] # Check if two digit character is valid if 10 <= two_digits <= 26: dp[i] += dp[i-2] return dp[n]"},{"question":"You are given the task of designing a utility function that calculates the number of digits in an input number. Your function should handle both positive and negative integers, and should return `1` for the number `0`. Your task is to implement a function `count_digits` with the following specifications: Function Signature ```python def count_digits(n: int) -> int: pass ``` Input * A single integer `n` where `-10^9 <= n <= 10^9`. Output * An integer representing the number of digits in the input number `n`. # Constraints 1. The input number `n` will be within the bounds of a 32-bit signed integer. 2. The function should run in constant time, O(1). # Examples 1. `count_digits(1234)` should return `4`. 2. `count_digits(-567)` should return `3`. 3. `count_digits(0)` should return `1`. # Additional Information Handle edge cases like: - Negative numbers by converting them to their absolute value. - The number zero which should return `1`. *Note*: You must not use any string conversion operations (e.g., converting to string and checking the length of the string).","solution":"def count_digits(n: int) -> int: Returns the number of digits in the input integer `n`. if n == 0: return 1 count = 0 n = abs(n) while n > 0: n //= 10 count += 1 return count"},{"question":"Context: You are tasked with improving the performance of a data processing pipeline that involves sorting medium-sized datasets. The Shell Sort algorithm is known for its simplicity and improved performance over insertion sort for medium-sized inputs. Task: Write a function `enhanced_shell_sort` that takes an array of integers as input and returns a sorted version of the array using the Shell Sort algorithm. You are encouraged to experiment with different gap sequences and analyze their impacts on the sorting performance. Function Signature: ```python def enhanced_shell_sort(arr: list) -> list: pass ``` Constraints: * The input array can have between 0 and 10^5 elements. * Each element in the array is an integer between -10^9 and 10^9. Example: ```python assert enhanced_shell_sort([64, 34, 25, 12, 22, 11, 90]) == [11, 12, 22, 25, 34, 64, 90] assert enhanced_shell_sort([]) == [] assert enhanced_shell_sort([1]) == [1] assert enhanced_shell_sort([5, 3, 3, 2, 9, 1, 1, 0]) == [0, 1, 1, 2, 3, 3, 5, 9] ``` Additional Details: * Consider traditional gap sequences like `[n//2, n//4, ..., 1]`, but feel free to experiment with others like Hibbard\'s, Sedgewick\'s, or Tokuda\'s sequences. * Modify the implementation of shell sort to iterate over the gaps and perform the insertion sort accordingly.","solution":"def enhanced_shell_sort(arr: list) -> list: Sorts an array using the Shell Sort algorithm. n = len(arr) # Using the Knuth sequence: h = 1, 4, 13, 40, 121, 364, ... gap = 1 while gap < n // 3: gap = 3 * gap + 1 while gap > 0: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp gap //= 3 return arr"},{"question":"# Question: Right-Angle Triangle Side Length Calculation You are tasked with implementing a function to calculate the missing side of a right-angled triangle given the lengths of two sides. Function Signature ```python def calculate_third_side(opposite: float, adjacent: float, hypotenuse: float) -> float: Calculate the length of the missing side of a right-angled triangle based on the Pythagorean theorem. :param opposite: Length of the opposite side (set to -1 if unknown). :param adjacent: Length of the adjacent side (set to -1 if unknown). :param hypotenuse: Length of the hypotenuse (set to -1 if unknown). :return: Calculated length of the missing side as a positive float. :raises ValueError: If inputs are invalid or do not form a right-angled triangle. ``` Input Format - **opposite**: A positive real number (or -1 if this side\'s length is unknown). - **adjacent**: A positive real number (or -1 if this side\'s length is unknown). - **hypotenuse**: A positive real number (or -1 if this side\'s length is unknown). Output Format - A single positive float representing the length of the missing side. Constraints - Exactly one of the three side lengths will be -1, representing the side to be calculated. - The values provided must form a valid right-angled triangle. Examples 1. **Input**: `opposite = -1`, `adjacent = 3`, `hypotenuse = 5` **Output**: `4.0` 2. **Input**: `opposite = 6`, `adjacent = -1`, `hypotenuse = 10` **Output**: `8.0` 3. **Input**: `opposite = 8`, `adjacent = 15`, `hypotenuse = -1` **Output**: `17.0` Explanation In each example, exactly one side is unknown and the function needs to calculate it using the Pythagorean theorem: - ( c^2 = a^2 + b^2 ) for the hypotenuse. - ( a^2 = c^2 - b^2 ) or ( b^2 = c^2 - a^2 ) for the other sides. You may assume the provided values are valid and lead to a right-angled triangle solution.","solution":"import math def calculate_third_side(opposite: float, adjacent: float, hypotenuse: float) -> float: Calculate the length of the missing side of a right-angled triangle based on the Pythagorean theorem. :param opposite: Length of the opposite side (set to -1 if unknown). :param adjacent: Length of the adjacent side (set to -1 if unknown). :param hypotenuse: Length of the hypotenuse (set to -1 if unknown). :return: Calculated length of the missing side as a positive float. :raises ValueError: If inputs are invalid or do not form a right-angled triangle. if opposite == -1: if hypotenuse <= adjacent: raise ValueError(\\"Invalid side lengths, hypotenuse must be the longest side.\\") return math.sqrt(hypotenuse ** 2 - adjacent ** 2) elif adjacent == -1: if hypotenuse <= opposite: raise ValueError(\\"Invalid side lengths, hypotenuse must be the longest side.\\") return math.sqrt(hypotenuse ** 2 - opposite ** 2) elif hypotenuse == -1: return math.sqrt(opposite ** 2 + adjacent ** 2) else: raise ValueError(\\"Exactly one side length must be unknown (set to -1).\\")"},{"question":"# Linked List Cycle Detection Given a linked list, write a function `detect_cycle` that detects whether the linked list contains a cycle. If a cycle is detected, return `True`; otherwise, return `False`. Function Signature ```python def detect_cycle(head: Node) -> bool: ``` Input - `head`: The first node of the linked list. Each `Node` contains an integer `val` and a reference to the next node `next`. Expected Output - Return `True` if the linked list has a cycle, `False` otherwise. Constraints - You must solve it without using extra space. - The linked list nodes will have values of type integer. Performance Requirements - The solution must run in O(n) time complexity and use O(1) additional space. Example 1. Given a linked list: 3 -> 2 -> 0 -> -4 -> 2 (cycle), `detect_cycle` should return `True`. 2. Given a linked list: 1 -> 2 -> 3 -> 4 (no cycle), `detect_cycle` should return `False`. # Detailed Description - Your function should start by checking if the head is `None` (empty list) or if the list only contains a single node without a cycle. - Use two pointers (a fast pointer \\"runner\\" and a slow pointer \\"walker\\") to traverse the list. - Move the runner by two steps and the walker by one step, and check if they meet. - If they meet, a cycle exists and you should return `True`. - If the runner\'s next nodes are `None`, the list ends and no cycle exists, thus return `False`. Take care of edge cases and ensure that your code handles the conditions seamlessly.","solution":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def detect_cycle(head: Node) -> bool: if not head or not head.next: return False slow, fast = head, head.next while fast is not None and fast.next is not None: if slow == fast: return True slow = slow.next fast = fast.next.next return False"},{"question":"# Interval Merging and Manipulation You are given a class `Interval` representing a range of real numbers and a function `merge_intervals` that merge intervals. Your task is to implement a new function `interval_difference` that computes the difference between two sets of intervals. # Function Signature ```python def interval_difference(intervals1: List[Interval], intervals2: List[Interval]) -> List[Interval]: pass ``` # Input - `intervals1`: A list of `Interval` objects representing the first set of intervals. - `intervals2`: A list of `Interval` objects representing the second set of intervals. # Output - Returns a list of `Interval` objects representing the intervals in `intervals1` that do not overlap with any interval in `intervals2`. # Constraints - Each Interval is assumed to be valid, i.e., `start <= end`. - Intervals in the same list may overlap. # Scenario Consider the following scenario: You are managing event scheduling for a conference room. The function `interval_difference` helps check available times by removing intervals that overlap with already booked times (given in `intervals2`). # Example Given the intervals: ```python intervals1 = [Interval(1, 5), Interval(6, 8)] intervals2 = [Interval(4, 7)] ``` The output should be: ```python [Interval(1, 3), Interval(7, 8)] ``` # Implementation Implement your solution by iterating through the set of intervals in `intervals1`, comparing each with intervals in `intervals2` and computing the non-overlapping parts.","solution":"from typing import List class Interval: def __init__(self, start: float, end: float): self.start = start self.end = end def __repr__(self): return f\\"Interval({self.start}, {self.end})\\" def __eq__(self, other): return self.start == other.start and self.end == other.end def interval_difference(intervals1: List[Interval], intervals2: List[Interval]) -> List[Interval]: result = [] def subtract_interval(a: Interval, b: Interval) -> List[Interval]: if b.end <= a.start or b.start >= a.end: return [a] if b.start <= a.start and b.end >= a.end: return [] if b.start > a.start and b.end < a.end: return [Interval(a.start, b.start), Interval(b.end, a.end)] if b.start <= a.start: return [Interval(b.end, a.end)] return [Interval(a.start, b.start)] for interval1 in intervals1: temp_intervals = [interval1] for interval2 in intervals2: next_intervals = [] for temp in temp_intervals: next_intervals.extend(subtract_interval(temp, interval2)) temp_intervals = next_intervals result.extend(temp_intervals) return result"},{"question":"Implement In-Place Merge Sort You are tasked to implement the merge sort algorithm with minimal space usage by merging the sorted halves within the original array without using additional subarrays. Problem Statement Write a function `merge_sort_inplace(arr)` that sorts an array `arr` of integers in non-decreasing order using in-place merge sort. Requirements * **Input Format**: A list of integers `arr`, where `1 <= len(arr) <= 10^5` and `-10^6 <= arr[i] <= 10^6`. * **Output Format**: The input list `arr` should be sorted in-place. * **Constraints/Limitations**: * Your solution should minimize the usage of extra space (avoid using additional subarrays for merging). * The sorting should be done in-place with a preferable space complexity of O(1) beyond the provided array. Function Signature ```python def merge_sort_inplace(arr: List[int]) -> None: # Implementation goes here ``` Example ```python # Example 1 arr = [4, 2, 5, 1, 3] merge_sort_inplace(arr) print(arr) # Output: [1, 2, 3, 4, 5] # Example 2 arr = [10, -1, 2, 5, 0] merge_sort_inplace(arr) print(arr) # Output: [-1, 0, 2, 5, 10] ``` # Detailed Explanation You should start by modifying the merge sort algorithm to work without creating additional arrays during the merge step. Focus on optimizing the space complexity while maintaining the sorting stability and O(n log n) time complexity.","solution":"from typing import List def merge(arr: List[int], start: int, mid: int, end: int) -> None: Merges two sorted halves of the array in place. start2 = mid + 1 # If the direct merge is already sorted if arr[mid] <= arr[start2]: return # Two pointers to maintain start of both arrays to merge while start <= mid and start2 <= end: # If element 1 is in right place if arr[start] <= arr[start2]: start += 1 else: value = arr[start2] index = start2 # Shift all the elements between element 1 # element 2, right by 1. while index != start: arr[index] = arr[index - 1] index -= 1 arr[start] = value # Update all the pointers start += 1 mid += 1 start2 += 1 def merge_sort_inplace(arr: List[int], l: int = 0, r: int = None) -> None: if r is None: r = len(arr) - 1 if l < r: # Same as (l + r) // 2, but avoids overflow for large l and r m = l + (r - l) // 2 # Sort first and second halves merge_sort_inplace(arr, l, m) merge_sort_inplace(arr, m + 1, r) merge(arr, l, m, r)"},{"question":"# Coding Challenge: Optimizing Matrix Chain Multiplication Context: You are given a series of matrices to multiply, and your task is to determine the most efficient order of multiplications. This is crucial for many applications involving large-scale data operations, including machine learning algorithms and scientific computations. Problem Statement Implement a function to determine the optimal order of matrix multiplications specifically to minimize the number of scalar multiplications. Your implementation should follow the dynamic programming approach. Function Signature: ```python def matrix_chain_order(array: list[int]) -> tuple[list[list[int]], list[list[int]]]: Given a list of dimensions, returns two tables: - The minimum number of scalar multiplications needed to multiply the chain of matrices. - The table to reconstruct the optimal order of matrix multiplications. Parameters: array (list[int]): List of dimensions where the ith matrix has dimensions (array[i-1] x array[i]). Returns: tuple: A tuple containing two 2D lists: - The cost table of dimensions (n x n). - The solution table used to construct the optimal order. ``` Inputs and Outputs: * **Input Format**: - A list of integers where the ith matrix has dimensions (array[i-1] x array[i]). - Example: `[30, 35, 15, 5, 10, 20, 25]` represents matrices 30x35, 35x15, 15x5, 5x10, 10x20, and 20x25. * **Output Format**: - Two 2D lists (cost table and solution table). Constraints: 1. The length of the array will be between 2 and 100. 2. Each integer in the array will be between 1 and 1000. Performance Requirements: Your implementation should efficiently handle the constraints mentioned, aiming for both time and space complexities in line with given guidelines. Example: ```python array = [30, 35, 15, 5, 10, 20, 25] matrix, optimal_solution = matrix_chain_order(array) # matrix and optimal_solution should contain the necessary tables to reconstruct the optimal multiplication order. # Expected output # Appropriate tables reflecting minimum multiplication cost and order of operations. ``` Additional Instructions: Write additional helper functions as required to format the output and verify the results.","solution":"def matrix_chain_order(array): Given a list of dimensions, returns two tables: - The minimum number of scalar multiplications needed to multiply the chain of matrices. - The table to reconstruct the optimal order of matrix multiplications. Parameters: array (list[int]): List of dimensions where the ith matrix has dimensions (array[i-1] x array[i]). Returns: tuple: A tuple containing two 2D lists: - The cost table of dimensions (n x n). - The solution table used to construct the optimal order. # Number of matrices n = len(array) - 1 # Initialize the cost table and the solution table m = [[0 for _ in range(n)] for _ in range(n)] s = [[0 for _ in range(n)] for _ in range(n)] # Length of the chain (cl) varies from 2 to n for cl in range(2, n + 1): for i in range(1, n - cl + 2): j = i + cl - 1 m[i-1][j-1] = float(\'inf\') for k in range(i, j): q = m[i-1][k-1] + m[k][j-1] + array[i-1] * array[k] * array[j] if q < m[i-1][j-1]: m[i-1][j-1] = q s[i-1][j-1] = k return m, s"},{"question":"# Question **RSA Key Generation and Encryption/Decryption** The RSA algorithm is widely used for secure data transmission. This question tasks you with implementing the RSA key generation, encryption, and decryption process. The RSA algorithm involves generating three numbers (n), (e), and (d) which are used for encrypting and decrypting data. **Function Implementations**: 1. `generate_key(k: int, seed: int = None) -> Tuple[int, int, int]` - **Input**: - `k` : an integer specifying the number of bits in the modulus `n`. - `seed` : an optional integer for seeding the random number generator (useful for reproducibility). - **Output**: A tuple (n, e, d). - **Description**: Generate a pair of RSA keys with bit length `k`. 2. `encrypt(data: int, e: int, n: int) -> int` - **Input**: - `data` : the plaintext integer data to encrypt. - `e` : the RSA encryption exponent. - `n` : the RSA modulus. - **Output**: The encrypted integer data. - **Description**: Encrypt the provided data using the RSA encryption parameters. 3. `decrypt(data: int, d: int, n: int) -> int` - **Input**: - `data` : the encrypted integer data. - `d` : the RSA decryption exponent. - `n` : the RSA modulus. - **Output**: The decrypted integer data. - **Description**: Decrypt the provided data using the RSA decryption parameters. **Constraints**: - The value of `k` should be at least 16. - The data to be encrypted should be smaller than `n`. - Use efficient prime generation and modular arithmetic. **Example**: ```python # Example usage: k = 16 n, e, d = generate_key(k) data = 20 encrypted = encrypt(data, e, n) decrypted = decrypt(encrypted, d, n) assert decrypted == data ``` Create the three functions described above. Ensure to consider edge cases such as very small values for `k` or incorrect prime detection. Return the generated key values and ensure the decryption returns the original data.","solution":"import random from typing import Tuple from sympy import isprime, mod_inverse def generate_prime(bits, seed=None): if seed: random.seed(seed) while True: p = random.getrandbits(bits) if isprime(p): return p def generate_key(k: int, seed: int = None) -> Tuple[int, int, int]: if k < 16: raise ValueError(\\"k must be at least 16 bits.\\") bits = k // 2 p = generate_prime(bits, seed) q = generate_prime(bits, seed) n = p * q phi = (p - 1) * (q - 1) e = 65537 # A common choice for e d = mod_inverse(e, phi) return n, e, d def encrypt(data: int, e: int, n: int) -> int: if data >= n: raise ValueError(\\"Data must be less than n.\\") return pow(data, e, n) def decrypt(data: int, d: int, n: int) -> int: return pow(data, d, n)"},{"question":"Scenario You are working for a logistics company that manages a network of roads connecting various distribution centers. Each road has a certain capacity which represents the maximum number of goods that can pass through it per unit time. The company needs to figure out the maximum number of goods that can be transported from the main warehouse (source node) to a major retail center (sink node) efficiently. # Task Write a function `compute_max_flow` that takes an adjacency matrix representing the graph and returns the maximum flow from the given source node (first node) to the sink node (last node). You are required to use DFS for finding augmenting paths. Function Signature ```python def compute_max_flow(adjacency_matrix: List[List[int]]) -> int: pass ``` Input * `adjacency_matrix` (List[List[int]]): A 2D list of integers where `adjacency_matrix[i][j]` represents the capacity of the directed edge from node i to node j. If there is no edge, the value will be 0. Output * Returns an integer representing the maximum flow value from the source node to the sink node. Constraints * The number of nodes ( n ) will be between 2 and 100. * The capacity values will be non-negative integers. Example ```python graph = [[0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0]] result = compute_max_flow(graph) print(result) # Output: 23 ``` Notes * Assume the first node in the matrix (index 0) is always the source. * Assume the last node in the matrix (index n-1) is always the sink. * Implement the algorithm using a depth-first search (DFS) to find augmenting paths. * Handle edge cases where there is no path from source to sink. Good luck and make sure your code is optimized for clarity and performance!","solution":"from typing import List def compute_max_flow(adjacency_matrix: List[List[int]]) -> int: def dfs(source, sink, flow, visited): if source == sink: return flow visited[source] = True for i, capacity in enumerate(adjacency_matrix[source]): if not visited[i] and capacity > 0: new_flow = min(flow, capacity) result = dfs(i, sink, new_flow, visited) if result > 0: adjacency_matrix[source][i] -= result adjacency_matrix[i][source] += result return result return 0 n = len(adjacency_matrix) source, sink = 0, n - 1 max_flow = 0 while True: visited = [False] * n flow = dfs(source, sink, float(\'Inf\'), visited) if flow == 0: break max_flow += flow return max_flow"},{"question":"**Question:** You are given an array of integers where every element appears exactly twice, except for one element which appears only once. Your task is to implement a function `find_unique_number` that returns the element which appears only once. The function should operate with a linear time complexity and constant extra space. It should handle edge cases properly and return the unique number correctly as per the requirements. Function Signature: ```python def find_unique_number(nums: List[int]) -> int: ``` # Example ```python assert find_unique_number([2, 2, 1]) == 1 assert find_unique_number([4, 1, 2, 1, 2]) == 4 assert find_unique_number([1]) == 1 assert find_unique_number([]) == 0 # Empty array edge case assert find_unique_number([1, 1, 1, 1, 1]) == 1 # All elements are the same (although it does not exactly fit the constraints) ``` # Input * `nums`: A list of integers where every element appears twice except for one element which appears only once. # Output * The function should return the one element that appears only once. If all numbers appear twice, return 0. # Constraints: * The algorithm should have a linear runtime complexity. * Avoid using extra memory beyond a constant amount. # Scenario: Imagine you\'re processing a log of system events where each event ID is recorded twice, representing its start and end time. However, there is a corrupted log entry where one event ID appears only once. Your task is to find this corrupted log entry efficiently to avoid scanning through the whole log multiple times.","solution":"from typing import List def find_unique_number(nums: List[int]) -> int: Function to find the unique number in a list where every element except one appears twice. unique_num = 0 for num in nums: unique_num ^= num return unique_num"},{"question":"Longest Increasing Subsequence **Context**: You are a software engineer tasked with analyzing and optimizing a dataset for an e-commerce platform. The platform wants to better understand the patterns in user transaction sequences, and your task is to identify the longest subsequence of transactions where each transaction amount is greater than the previous ones. Problem Statement: Write a function `longest_increasing_subsequence` that takes a list of integers representing transaction amounts and returns the length of the longest increasing subsequence. **Function Signature**: ```python def longest_increasing_subsequence(transactions: list[int]) -> int: ``` Input: - A list of integers `transactions` representing transaction amounts. (1 <= len(transactions) <= 10^5, 1 <= transactions[i] <= 10^9). Output: - An integer representing the length of the longest increasing subsequence. Constraints: - You must implement an efficient solution with a time complexity of O(n log n) and space complexity of O(n). Performance Requirements: - The solution should handle large inputs efficiently. - Consider edge cases like empty list, single element list, and lists with large ranges of values. Example: ```python # Input transactions = [10, 9, 2, 5, 3, 7, 101, 18] # Output print(longest_increasing_subsequence(transactions)) # 4 ``` **Explanation**: The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4. Additional Requirements: - Include comments explaining your approach, especially any complex operations. - Ensure your code handles edge cases gracefully. - Optimize for both time and space efficiency. **Notes**: - Consider using advanced data structures like segment trees or binary indexed trees if necessary to achieve the required complexity.","solution":"import bisect def longest_increasing_subsequence(transactions): Computes the length of the longest increasing subsequence of transaction amounts. Parameters: transactions (list[int]): A list of integers representing transaction amounts. Returns: int: Length of the longest increasing subsequence. if not transactions: return 0 # Array to store our increasing subsequence lis = [] for transaction in transactions: # Use binary search to find the position where the current transaction # should be placed pos = bisect.bisect_left(lis, transaction) # If pos is equal to the length of lis, it means transaction can be added to # the end of lis if pos == len(lis): lis.append(transaction) else: # Otherwise, replace the element at the found position with transaction lis[pos] = transaction return len(lis)"},{"question":"Scenario You are working as a software engineer at a company that builds search engines. Your team is tasked with optimizing the search query performance. One approach is to use Binary Search Trees (BST) due to their efficient search capabilities. Given a sorted array of search terms, you need to convert this array into a balanced BST, ensuring the tree is height-balanced. Task Implement a function `sorted_array_to_bst` which takes a sorted array of integers and converts it into a height-balanced Binary Search Tree (BST). Function Signature ```python def sorted_array_to_bst(nums: List[int]) -> TreeNode: pass ``` Input * A list of integers sorted in ascending order. `[int]`, where `1 <= len(nums) <= 1000`. Output * A `TreeNode` representing the root of the height-balanced BST. Constraints * The array will always be sorted in ascending order. * Solution should account for typical edge cases like empty arrays or single element arrays. Example ```python # Example 1 input_list = [-10, -3, 0, 5, 9] root = sorted_array_to_bst(input_list) # The constructed BST should be: # 0 # / # -3 9 # / / # -10 5 # Example 2 input_list = [1, 3] root = sorted_array_to_bst(input_list) # The constructed BST should be: # 3 # / # 1 ``` Your solution will be evaluated based on: * Correctness and tree structure. * Efficient use of time and space complexity. * Handling of edge cases.","solution":"from typing import List, Optional class TreeNode: def __init__(self, val: int = 0, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.val = val self.left = left self.right = right def sorted_array_to_bst(nums: List[int]) -> Optional[TreeNode]: Converts a sorted array into a height-balanced Binary Search Tree. Args: nums (List[int]): A sorted list of integers. Returns: TreeNode: Root node of the resulting height-balanced BST. if not nums: return None mid = len(nums) // 2 root = TreeNode(nums[mid]) root.left = sorted_array_to_bst(nums[:mid]) root.right = sorted_array_to_bst(nums[mid+1:]) return root"},{"question":"You are given an implementation of a Red-Black Tree. This self-balancing binary search tree structure ensures that the tree remains balanced with standard operations performed in O(log n) time complexity. Your task is to enhance the Red-Black Tree by implementing an additional function called `find_inorder_successor`, which finds the in-order successor of a given node in the tree. The in-order successor of a node in a binary search tree is the node with the smallest key greater than the key of the given node. # Function Signature: ```python def find_inorder_successor(tree: RBTree, node: RBNode) -> RBNode: pass ``` # Input: - `tree`: An instance of the `RBTree` class representing the Red-Black Tree. - `node`: An instance of the `RBNode` class for which the in-order successor needs to be found. # Output: - Return the `RBNode` that is the in-order successor of the given node. - If no successor exists, return `None`. # Constraints: - All node values are distinct. - The tree can be initially empty. # Requirements: - The function should maintain the properties of the Red-Black Tree and not modify the tree structure. - Use a time complexity of O(log n) for this operation. # Example: ```python # Assuming the tree is built using the provided RBTree and RBNode classes. tree = RBTree() nodes = [11, 2, 14, 1, 7, 15, 5, 8, 4] for value in nodes: n = RBNode(value, 1) tree.insert(n) # Find the in-order successor for the node with value 7 result_node = find_inorder_successor(tree, n) print(result_node.val) # Should print the value of the in-order successor ``` Note: Use the provided Red-Black Tree and Node classes directly for the `tree` and `node` inputs. Ensure to handle edge cases such as an empty tree or the node being the largest element in the tree (having no successor).","solution":"class RBNode: def __init__(self, val, color, left=None, right=None, parent=None): self.val = val self.color = color self.left = left self.right = right self.parent = parent class RBTree: def __init__(self): self.NIL_LEAF = RBNode(val=None, color=0) self.root = self.NIL_LEAF def insert(self, node): # RB-Tree insertion logic, not provided in the problem statement. pass def find_inorder_successor(tree: RBTree, node: RBNode) -> RBNode: if node.right != tree.NIL_LEAF: return find_minimum(node.right, tree.NIL_LEAF) successor = None current = tree.root while current != tree.NIL_LEAF: if node.val < current.val: successor = current current = current.left elif node.val > current.val: current = current.right else: break return successor def find_minimum(node, nil_leaf): while node.left != nil_leaf: node = node.left return node"},{"question":"**Problem Statement**: You are given a multi-dimensional array (a list of lists which may also include more lists within). Your task is to write two Python functions that flatten this array into a single-level array. One function should use a recursive approach to return a list, and the other should use a generator to yield elements one by one. **Function Specifications**: 1. **flatten(input_arr: List[Any], output_arr: Optional[List[Any]] = None) -> List[Any]** This function takes as input a multi-dimensional list `input_arr` and returns a single-dimensional list `output_arr` containing all elements from `input_arr`, flattened to a single level. 2. **flatten_iter(iterable: Iterable[Any]) -> Iterator[Any]** This function takes as input a multi-dimensional iterable `iterable` and returns a generator which can be iterated over to yield elements from the `iterable`, flattened to a single level. **Input/Output**: * **Input**: * `input_arr` and `iterable` can contain any type of data, including nested lists or other iterables that should be recursively flattened. Strings should not be further split down. * **Output**: * `flatten` should return a list. * `flatten_iter` should be used to iterate through and yield elements one by one. **Constraints**: * Do not use any built-in flattening methods or libraries. * Handle strings as atomic elements. * Ensure that your solution is robust and handles different data types. **Example**: ```python # Example for list-based function input_arr = [1, [2, [3, 4], 5], \'abc\', [6], 7] print(flatten(input_arr)) # Output: [1, 2, 3, 4, 5, \'abc\', 6, 7] # Example for generator function iterable = [1, [2, [3, 4], 5], \'abc\', [6], 7] print(list(flatten_iter(iterable))) # Output: [1, 2, 3, 4, 5, \'abc\', 6, 7] ``` Ensure that your functions handle non-trivial scenarios gracefully and are well-organized for readability and maintenance.","solution":"from typing import Any, List, Optional, Iterable, Iterator def flatten(input_arr: List[Any], output_arr: Optional[List[Any]] = None) -> List[Any]: if output_arr is None: output_arr = [] for element in input_arr: if isinstance(element, list): flatten(element, output_arr) else: output_arr.append(element) return output_arr def flatten_iter(iterable: Iterable[Any]) -> Iterator[Any]: for element in iterable: if isinstance(element, list): yield from flatten_iter(element) else: yield element"},{"question":"# Scenario: You are given a hierarchical data structure representing various categories and their associated sub-items. Each category is represented by a key, and each key maps to a list of elements. The function provided iterates through this structure and prints each key followed by its elements, ensuring the correct format and indentation. # Task: Given a nested dictionary structure, write a function `optimized_tree_print(tree)` which prints the tree structure with appropriate formatting and efficiency improvements. Focus on reducing redundant operations and ensuring precise formatting. # Input: * `tree`: A dictionary representing the nested structure. Each key is a string, mapping to a list of elements, where elements can be strings or integers. # Output: * Print the tree structure with each key on a new line followed by its elements. If an element is a list, print its contents on a new line indented correctly. # Constraints: * The dictionary can have up to `1000` keys. * Each key can map to a list containing up to `100` elements. * Elements can be either strings or integers and should be handled accordingly. # Example Input: ```python tree = { \'a\': [\'Adam\', \'Book\', 4], \'b\': [\'Bill\', \'Computer\', 5, \'TV\', 6, \'Jill\', \'Sports\', 1], \'c\': [\'Bill\', \'Sports\', 3], \'d\': [\'Adam\', \'Computer\', 3, \'Quin\', \'Computer\', 3], \'e\': [\'Quin\', \'Book\', 5, \'TV\', 2], \'f\': [\'Adam\', \'Computer\', 7], } ``` # Example Output: ``` a -> Adam -> Book -> 4 b -> Bill -> Computer -> 5 -> TV -> 6 -> Jill -> Sports -> 1 c -> Bill -> Sports -> 3 d -> Adam -> Computer -> 3 -> Quin -> Computer -> 3 e -> Quin -> Book -> 5 -> TV -> 2 f -> Adam -> Computer -> 7 ``` # Task Implementation: Write the function `optimized_tree_print(tree)` according to the specifications above. Ensure that your solution is optimized and handles edge cases properly. # Instructions: 1. Define the function `optimized_tree_print(tree)`. 2. Implement the logic to iterate through the dictionary and print elements as specified. 3. Optimize the function for efficiency by reducing redundant operations.","solution":"def optimized_tree_print(tree): This function prints a tree structure with each key followed by its elements. If an element is a list, print its contents on a new line indented correctly. for key, elements in tree.items(): print(f\\"{key} -> \\", end=\\"\\") print(\\" -> \\".join(map(str, elements)))"},{"question":"**Minimum Spanning Tree Using Kruskal\'s Algorithm** # Scenario You are a network engineer tasked with designing an optimal network of cities. You need to connect all cities with the minimum total cable length, ensuring there are no loops in the network (i.e., forming a tree). # Task Implement a function `find_mst_weight` to compute the total weight of the minimum spanning tree for a given graph using Kruskal\'s Algorithm. # Input Format - An integer `n` (1 ≤ n ≤ 1,000) representing the number of vertices. - An integer `m` (0 ≤ m ≤ 10,000) representing the number of edges. - `m` lines each containing three integers `u`, `v`, and `w` representing an edge between node `u` and node `v` with weight `w` (1 ≤ u, v ≤ n, 1 ≤ w ≤ 1,000). # Output Format - A single integer representing the total weight of the minimum spanning tree. If the graph is disconnected and no MST exists, return `-1`. # Constraints - Indexing is 1-based. - The graph is undirected and may contain parallel edges. # Example Input ```plaintext 5 6 1 2 3 1 3 8 2 4 5 3 4 2 3 5 4 4 5 6 ``` Output ```plaintext 14 ``` Explanation The MST includes edges: (3, 4), (1, 2), (3, 5), (2, 4), and the sum of weights is 14. # Implementation ```python class Edge: def __init__(self, u, v, w): self.u = u self.v = v self.w = w class DisjointSet: def __init__(self, size): self.parent = list(range(size)) self.rank = [0] * size def find(self, u): if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) return self.parent[u] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 def find_mst_weight(n, m, edges): edges = [Edge(u-1, v-1, w) for u, v, w in edges] edges.sort(key=lambda edge: edge.w) forest = DisjointSet(n) mst_weight = 0 edge_count = 0 for edge in edges: if forest.find(edge.u) != forest.find(edge.v): forest.union(edge.u, edge.v) mst_weight += edge.w edge_count += 1 if edge_count == n - 1: break return mst_weight if edge_count == n - 1 else -1 # Example of usage: n = 5 m = 6 edges = [ (1, 2, 3), (1, 3, 8), (2, 4, 5), (3, 4, 2), (3, 5, 4), (4, 5, 6) ] print(find_mst_weight(n, m, edges)) # Output: 14 ```","solution":"class Edge: def __init__(self, u, v, w): self.u = u self.v = v self.w = w class DisjointSet: def __init__(self, size): self.parent = list(range(size)) self.rank = [0] * size def find(self, u): if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) return self.parent[u] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 def find_mst_weight(n, m, edges): edges = [Edge(u-1, v-1, w) for u, v, w in edges] edges.sort(key=lambda edge: edge.w) forest = DisjointSet(n) mst_weight = 0 edge_count = 0 for edge in edges: if forest.find(edge.u) != forest.find(edge.v): forest.union(edge.u, edge.v) mst_weight += edge.w edge_count += 1 if edge_count == n - 1: break return mst_weight if edge_count == n - 1 else -1"},{"question":"# Maximum Flow Challenge Suppose you have been tasked with optimizing the flow capacity in a network of pipes, where each pipe has a specific capacity constraint. You are given a directed graph with vertices representing junctions and edges representing the pipes between these junctions. The goal is to maximize the flow from a source vertex to a sink vertex in the network. **Problem Statement**: Implement a function `max_flow` to calculate the maximum possible flow from the source to the sink in the given flow network using Dinic\'s algorithm. # Inputs: 1. `capacity` (List[List[int]]): A 2D list where `capacity[i][j]` represents the capacity of the pipe from vertex `i` to vertex `j`. If there is no pipe, `capacity[i][j]` will be 0. 2. `source` (int): The starting vertex for the flow. 3. `sink` (int): The destination vertex for the flow. # Outputs: - `max_flow_value` (int): The maximum flow value from the source to the sink. # Constraints: - The number of vertices `V` will be in the range `[2, 1000]`. - The capacity values will be non-negative integers not exceeding `10^6`. # Example: Input: ```python capacity = [ [0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0] ] source = 0 sink = 5 ``` Output: ```python max_flow_value = 23 ``` # Requirements: - Efficient implementation of Dinic\'s Algorithm. - Proper handling of edge cases (disconnects, zero capacities). You can assume that the input graph is valid and connected between the source and sink vertex. **Function Signature**: ```python def max_flow(capacity: List[List[int]], source: int, sink: int) -> int: # Implement Dinic\'s algorithm to return the maximum flow ```","solution":"from collections import deque def max_flow(capacity, source, sink): n = len(capacity) # Residual capacity from u to v residual_capacity = [row[:] for row in capacity] # Level graph for BFS to build levels level = [0] * n def bfs_level_graph(): nonlocal level level = [-1] * n level[source] = 0 queue = deque([source]) while queue: u = queue.popleft() for v in range(n): if level[v] < 0 and residual_capacity[u][v] > 0: level[v] = level[u] + 1 queue.append(v) if v == sink: return True return False def dfs_flow(u, flow): if u == sink: return flow total_flow = 0 for v in range(n): if level[v] == level[u] + 1 and residual_capacity[u][v] > 0: current_flow = min(flow, residual_capacity[u][v]) actual_flow = dfs_flow(v, current_flow) if actual_flow > 0: residual_capacity[u][v] -= actual_flow residual_capacity[v][u] += actual_flow flow -= actual_flow total_flow += actual_flow if flow == 0: break return total_flow max_flow_value = 0 while bfs_level_graph(): flow = dfs_flow(source, float(\'Inf\')) while flow: max_flow_value += flow flow = dfs_flow(source, float(\'Inf\')) return max_flow_value"},{"question":"# Understanding Huffman Coding through Implementation You are given the basic structure of a Huffman Coding system. Your task is to implement a key part to deepen your understanding of its workings. Specifically, you will implement the functions that create the Huffman tree and generate the encoding dictionary. These will be used to compress and decompress data. Functions to Implement 1. **_create_tree(signs_frequency: dict) -> Node**: - Create a Huffman tree given a dictionary of character frequencies. - Input: `signs_frequency`: A dictionary with characters as keys and their frequencies as values. - Output: Root node of the created Huffman tree. 2. **_generate_codes(tree: Node) -> dict**: - Generate a dictionary of Huffman codes by traversing the given Huffman tree. - Input: `tree`: The root node of a Huffman tree. - Output: A dictionary with characters as keys and their corresponding Huffman codes as values. # Example Input A dictionary of character frequencies: ```python {\'a\': 5, \'b\': 9, \'c\': 12, \'d\': 13, \'e\': 16, \'f\': 45} ``` Output A dictionary of Huffman codes: ```python { \'f\': \'0\', \'c\': \'100\', \'d\': \'101\', \'a\': \'1100\', \'b\': \'1101\', \'e\': \'111\' } ``` Constraints - The frequency dictionary will always contain at least one character. - Assume all characters are bytes (0-255) when constructing the code dictionary. - Use the Node class provided. - The implementation should handle typical files up to a few megabytes efficiently. # Notes 1. Test your functions thoroughly since encoding and decoding both depend on them. 2. Remember that the Huffman tree should be a binary tree and the priority queue used for the tree creation should be a min-heap based on character frequencies.","solution":"import heapq from collections import defaultdict, namedtuple Node = namedtuple(\'Node\', [\'char\', \'freq\', \'left\', \'right\']) def _create_tree(signs_frequency): Create a Huffman tree given a dictionary of character frequencies. heap = [[freq, Node(char, freq, None, None)] for char, freq in signs_frequency.items()] heapq.heapify(heap) while len(heap) > 1: lo = heapq.heappop(heap) hi = heapq.heappop(heap) new_node = Node(None, lo[0] + hi[0], lo[1], hi[1]) heapq.heappush(heap, [new_node.freq, new_node]) return heap[0][1] def _generate_codes(tree): Generate a dictionary of Huffman codes by traversing the given Huffman tree. def _generate_codes_helper(node, current_code): if node.char is not None: huffman_codes[node.char] = current_code return _generate_codes_helper(node.left, current_code + \\"0\\") _generate_codes_helper(node.right, current_code + \\"1\\") huffman_codes = {} if tree.char is not None: huffman_codes[tree.char] = \\"0\\" else: _generate_codes_helper(tree, \\"\\") return huffman_codes"},{"question":"# Question: Limited Occurrence List Truncation Given a list of integers `lst` and an integer `N`, write a function `limit_occurrences(lst, N)` that modifies the list so that each integer appears at most `N` times without changing the order of the elements. If an integer already appears `N` times in the list, any further occurrences should be removed. Input * `lst` (List[int]): A list of integers which might contain duplicates. * `N` (int): An integer representing the maximum allowed occurrences for any integer. Output * List[int]: A new list where each integer appears at most `N` times while preserving their initial order of appearance. Constraints * All elements in `lst` are integers in the range ([-10^5, 10^5]). * (0 leq N leq 1000). * The length of the list `lst` is at most (10^5). Examples ```python # Example 1 lst = [1, 2, 3, 1, 2, 1, 2, 3] N = 2 # Result: [1, 2, 3, 1, 2, 3] # Example 2 lst = [1, 1, 1, 1, 1] N = 1 # Result: [1] # Example 3 lst = [1, 2, 3, 4, 5] N = 0 # Result: [] ``` Function Signature ```python def limit_occurrences(lst, N): pass ```","solution":"def limit_occurrences(lst, N): Modifies the list so that each integer appears at most N times without changing the order of the elements. :param lst: List of integers which might contain duplicates. :param N: Integer representing the maximum allowed occurrences for any integer. :return: A new list where each integer appears at most N times. if N == 0: return [] occurrences = {} result = [] for num in lst: if num in occurrences: if occurrences[num] < N: occurrences[num] += 1 result.append(num) else: occurrences[num] = 1 result.append(num) return result"},{"question":"# **Binary String Addition** Given two binary strings `a` and `b`, write a function `add_binary(a: str, b: str) -> str` that returns their sum as a binary string. **Input** * `a`: A string `a` consisting of characters \'0\' and \'1\' only. * `b`: A string `b` consisting of characters \'0\' and \'1\' only. **Output** * Return a binary string representing the sum of `a` and `b`. **Constraints** * Each input string does not exceed 10,000 characters. * Each input string is non-empty. **Performance Requirements** * The algorithm should run in linear time, O(max(N, M)), where N and M are the lengths of the input strings `a` and `b`. * Space complexity should remain within O(max(N, M)), considering the size of the result. **Example** ```python a = \\"11\\" b = \\"1\\" # Return \\"100\\". ``` ```python a = \\"1010\\" b = \\"1011\\" # Return \\"10101\\". ``` **Scenario** Suppose you are working on a simulation that requires frequent calculations of binary string summation. You need to ensure the addition is efficient, even for very large binary numbers. This task will help implement a core utility function to handle such operations. **Function Signature**: ```python def add_binary(a: str, b: str) -> str: # Implementation here. ``` Write the implementation of the `add_binary` function.","solution":"def add_binary(a: str, b: str) -> str: Returns the sum of a and b as a binary string. max_len = max(len(a), len(b)) # Pad the shorter string with leading zeros a = a.zfill(max_len) b = b.zfill(max_len) result = [] carry = 0 # Iterate from the last character to the first character for i in range(max_len - 1, -1, -1): bit_a = int(a[i]) bit_b = int(b[i]) # Calculate the total and the carry total = bit_a + bit_b + carry carry = total // 2 result.append(str(total % 2)) # If there\'s a carry left at the end, append it if carry: result.append(\'1\') # Reverse the result to get the correct binary number return \'\'.join(result[::-1])"},{"question":"# Question: Context: You are working as a software developer for a competitive examination platform. Your task is to optimize the search functionality in your examination software for analyzing and grading multiple-choice questions (MCQs). Specifically, you need to implement a search operation that quickly matches students\' responses with the correct answers stored in a sorted array. Objective: Write a Python function `interpolation_search` that performs an interpolation search on a sorted array and returns the index of the target element if found, otherwise returns -1. The algorithm should efficiently handle uniformly distributed keys but also be robust enough to appropriately manage edge cases. Function Signature: ```python def interpolation_search(array: List[int], search_key: int) -> int: ``` Input: * `array`: A sorted list of integers (in non-decreasing order) representing the dataset to be searched, e.g., `[5, 10, 12, 14, 17, 20, 21]`. * `search_key`: An integer to search for in the array. Output: * Return the index of `search_key` if it is present in the array, or -1 if it is not. Example: ```python interpolation_search([5, 10, 12, 14, 17, 20, 21], 17) ``` Output: ``` 4 ``` Constraints: 1. The array should be sorted in non-decreasing order. 2. The search key might not be present in the array. 3. The length of the array can be very large (up to 10^6 elements). Requirements: 1. Efficiently handle the average case time complexity of O(log2(log2 n)). 2. Properly manage edge cases and avoid scenarios that may lead to incorrect results or errors (such as division by zero). 3. Provide appropriate comments in your code to explain your logic. Note: Please write your implementation considering the aspects of complexity, proper handling of corner cases, and robustness for practical usage scenarios.","solution":"from typing import List def interpolation_search(array: List[int], search_key: int) -> int: Perform an interpolation search on a sorted array and return the index of the target element. If the element is not present in the array, return -1. Parameters: array (List[int]): Sorted list of integers to search in. search_key (int): The integer to search for. Returns: int: The index of the search_key in the array if found, otherwise -1. low = 0 high = len(array) - 1 while low <= high and search_key >= array[low] and search_key <= array[high]: if low == high: if array[low] == search_key: return low return -1 # Estimate the position pos = low + ((high - low) // (array[high] - array[low]) * (search_key - array[low])) # Check if search_key is found if array[pos] == search_key: return pos # If search_key is larger, search in the upper part if array[pos] < search_key: low = pos + 1 # If search_key is smaller, search in the lower part else: high = pos - 1 return -1"},{"question":"# Context You are working on a data analysis tool that needs to identify the longest increasing trends in numerical data sequences. Your task is to implement a function that determines the length of the longest increasing subsequence in a given sequence of integers. # Problem Statement Implement a function `longest_increasing_subsequence` that takes a list of integers `sequence` and returns the length of the longest increasing subsequence within that list. # Input - `sequence`: A list of integers with a length `n`, where `0 <= n <= 10^4` and `-10^6 <= sequence[i] <= 10^6`. # Output - An integer representing the length of the longest increasing subsequence. # Constraints 1. Aim for a solution with a time complexity of O(nlogn). 2. Handle edge cases such as an empty input or sequences with duplicate elements. # Example 1 ```python Input: [10,9,2,5,3,7,101,18] Output: 4 Explanation: The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4. ``` # Example 2 ```python Input: [0,8,4,12,2,10,6,14,1,9,5,13,3,11,7,15] Output: 6 Explanation: The longest increasing subsequence is [0, 2, 6, 9, 11, 15], therefore the length is 6. ``` # Hints 1. Consider using a combination of a list to maintain the current increasing subsequences and binary search for efficient updates. 2. Python\'s `bisect` module might be useful for maintaining a dynamic list of minimum end elements of active subsequences. **Function Signature**: ```python def longest_increasing_subsequence(sequence: list[int]) -> int: pass ``` # Note 1. Avoid directly using any predefined library functions that trivialize the solution (e.g., solving it in a single line using built-in methods).","solution":"import bisect def longest_increasing_subsequence(sequence): Returns the length of the longest increasing subsequence in the given list of integers. if not sequence: return 0 tails = [] for num in sequence: pos = bisect.bisect_left(tails, num) if pos < len(tails): tails[pos] = num else: tails.append(num) return len(tails)"},{"question":"Implement a Separate Chaining Hash Table with Rehashing You are tasked with improving the provided `SeparateChainingHashTable` class by implementing rehashing functionality. Rehashing should occur when the load factor (number of elements / number of buckets) exceeds a pre-defined threshold. Specification 1. **Rehash Method**: Add a method `rehash` that doubles the size of the bucket array and re-inserts all the elements into the new array. 2. **Put Method Modification**: Modify the `put` method to check the load factor before inserting a new element. If the load factor exceeds the threshold, call the `rehash` method. 3. **Load Factor Threshold**: Use a load factor threshold of 0.75. Your implementation should ensure that the hash table maintains efficient average-case performance for insertions and lookups. Input and Output - **Input**: Pairs of operations to be performed on the hash table. - Example: `[\\"put\\", \\"hello\\", \\"world\\"]`, `[\\"get\\", \\"hello\\"]` - **Output**: Results from the operations (if any). - Example: `None` (for \\"put\\"), `\\"world\\"` (for \\"get\\") Constraints - Keys are strings. - Values can be any data type. - Performance requirements: The solution should be efficient, and the rehash operation should redistribute keys correctly. Functions to Implement ```python class SeparateChainingHashTable: # Existing methods ... def rehash(self): # Implement rehashing logic def put(self, key, value): # Implement modified put logic with rehashing ``` Examples ```python # Create a new, empty map table = SeparateChainingHashTable() # Add a new key-value pair table.put(\'hello\', \'world\') print(table.get(\'hello\')) # Output: \'world\' # Add more key-value pairs to trigger rehashing for i in range(20): table.put(f\'key{i}\', f\'value{i}\') print(table.get(\'key10\')) # Output: \'value10\' print(len(table)) # Output: 21 ``` **Note**: Your implementation should work for edge cases such as inserting, deleting, and retrieving elements in varied sequences and handling rehashing efficiently.","solution":"class SeparateChainingHashTable: def __init__(self, initial_capacity=8): self.capacity = initial_capacity self.size = 0 self.buckets = [[] for _ in range(self.capacity)] self.load_factor_threshold = 0.75 def _hash(self, key): return hash(key) % self.capacity def put(self, key, value): if self.size / self.capacity >= self.load_factor_threshold: self.rehash() index = self._hash(key) bucket = self.buckets[index] for i, (k, v) in enumerate(bucket): if k == key: bucket[i] = (key, value) return bucket.append((key, value)) self.size += 1 def get(self, key): index = self._hash(key) bucket = self.buckets[index] for k, v in bucket: if k == key: return v return None def remove(self, key): index = self._hash(key) bucket = self.buckets[index] for i, (k, v) in enumerate(bucket): if k == key: del bucket[i] self.size -= 1 return def rehash(self): old_buckets = self.buckets self.capacity *= 2 self.buckets = [[] for _ in range(self.capacity)] self.size = 0 for bucket in old_buckets: for k, v in bucket: self.put(k, v) def __len__(self): return self.size"},{"question":"# Question: Counting Digits in Large Numbers # Scenario You are working on a data formatting library that needs to handle large numbers efficiently. As part of this library, you need to implement a function that returns the number of digits in a given integer. The function should handle both positive and negative integers, including zero. Efficient performance is critical since this function will be called frequently. # Function Specification Implement the following function: ```python def count_digits(n: int) -> int: Returns the number of digits in the given integer. Parameters: n (int): The integer whose digits are to be counted. Returns: int: The number of digits in the integer. pass ``` # Input * An integer ( n ) where ( -10^{18} leq n leq 10^{18} ). # Output * An integer representing the number of digits in the decimal representation of ( n ). # Constraints * Handle negative numbers correctly by considering their absolute values. * Ensure that the function works efficiently for very large values of ( n ). # Example ```python print(count_digits(12345)) # Output: 5 print(count_digits(-12345)) # Output: 5 print(count_digits(0)) # Output: 1 print(count_digits(1000000000)) # Output: 10 ``` # Performance Requirements * The function should run in ( O(1) ) time complexity. Your task is to implement the `count_digits` function described above.","solution":"def count_digits(n: int) -> int: Returns the number of digits in the given integer. Parameters: n (int): The integer whose digits are to be counted. Returns: int: The number of digits in the integer. # Take absolute value to handle negative numbers n = abs(n) # Convert number to string to count characters return len(str(n))"},{"question":"# Question: Stack Stutter Enhancement You are given a stack of integers represented as a list. Your task is to write a function `enhanced_stutter` that duplicates each element in the stack by using either a stack or a queue for temporary storage. After duplicating each element, the original stack should maintain the order of elements as if each element were popped and then duplicated just before being pushed back. You can choose to use any auxiliary data structure (a single stack or a single queue). Optimize for readability and efficiency wherever possible. Function Signature ```python def enhanced_stutter(stack: list) -> list: pass ``` Input * `stack`: a list of integers representing the stack, where the last element in the list is considered the top of the stack. * Example: `[3, 7, 1, 14, 9]` Output * A list of integers representing the modified stack where each element in the input stack is duplicated. * Example: `[3, 3, 7, 7, 1, 1, 14, 14, 9, 9]` Constraints * Use only one auxiliary data structure (a stack or a queue). * Optimize for both time and space complexity if possible. Performance Requirements * Time complexity should be `O(n)`, where `n` is the number of elements in the stack. * Space complexity should be `O(n)`. Example ```python assert enhanced_stutter([3, 7, 1, 14, 9]) == [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] assert enhanced_stutter([1]) == [1, 1] assert enhanced_stutter([]) == [] # Edge cases assert enhanced_stutter([99, 100]) == [99, 99, 100, 100] ``` # Implementation Implement the function `enhanced_stutter` considering the given constraints and performance requirements. Your function should correctly handle empty stacks and maintain the order of elements.","solution":"from collections import deque def enhanced_stutter(stack: list) -> list: Duplicates each element in the stack and returns the modified stack. Args: stack (list): A list of integers representing the stack, where the last element is the top of the stack. Returns: list: A list with each element duplicated from the original stack. queue = deque() # Transfer elements from stack to queue while stack: element = stack.pop() queue.appendleft(element) queue.appendleft(element) # Transfer elements back to stack from queue while queue: stack.append(queue.popleft()) return stack"},{"question":"# Digital Fortress Security In the realm of Digital Fortress, high-security encryption protocols often need large exponentiations for encryption and decryption processes. You have been recruited to enhance and ensure the efficiency of one such algorithm. Problem Statement Implement a function that computes ((a^n) mod m) efficiently using Binary Exponentiation. The function should handle large exponents while maintaining performance requirements. You are provided with two code snippets as examples for iterative and recursive approaches. Function Signature ```python def modular_exponentiation(a: int, n: int, m: int) -> int: pass ``` Input - `a` (1 ≤ a ≤ 10^9): The base number. - `n` (0 ≤ n ≤ 10^9): The exponent. - `m` (1 ≤ m ≤ 10^9): The modulus. Output - An integer representing ((a^n) mod m). Constraints - Your solution should run in (O(log n)) time and use (O(1)) space. Example ```python print(modular_exponentiation(2, 10, 1000)) # Output: 24 print(modular_exponentiation(7, 5, 13)) # Output: 11 print(modular_exponentiation(123456789, 0, 1)) # Output: 0 ``` Note You must utilize the efficiency of Binary Exponentiation to solve this problem. Ensure that you handle edge cases such as (n = 0) properly, where the output should be 1 since any number to the power of 0 is 1.","solution":"def modular_exponentiation(a: int, n: int, m: int) -> int: Computes (a^n) % m using iterative Binary Exponentiation method. result = 1 a = a % m # Update a if it\'s more than or equal to m while n > 0: # If n is odd, multiply a with the result if (n % 2) == 1: result = (result * a) % m # Now n must be even n = n >> 1 # Equivalent to n //= 2 a = (a * a) % m # Change a to a^2 return result"},{"question":"# Question: Implement an Optimized Palindrome Checker Given a string, determine if it is a palindrome considering only alphanumeric characters and ignoring cases. Write an optimized function, `is_optimized_palindrome(s:str) -> bool`, that achieves this with minimal space complexity. Input: * A string `s` with length `0 <= len(s) <= 10^5`. Output: * Return `True` if the input string is a palindrome, otherwise return `False`. Constraints: * You should aim to avoid additional space usage beyond O(1). * You may assume the input string consists of printable ASCII characters. # Requirements: 1. Implement a two-pointer approach to ensure in-place space optimization. 2. Ignore non-alphanumeric characters. 3. Handle case insensitivity. # Examples: ```python assert is_optimized_palindrome(\\"A man, a plan, a canal: Panama\\") == True assert is_optimized_palindrome(\\"race a car\\") == False assert is_optimized_palindrome(\\"\\") == True assert is_optimized_palindrome(\\" \\") == True assert is_optimized_palindrome(\\"0P\\") == False ``` # Notes: - Your function should handle edge cases where the string might be empty or contain only non-alphanumeric characters. - Performance should be considered, especially for large input sizes.","solution":"def is_optimized_palindrome(s: str) -> bool: Checks if the given string is a palindrome considering only alphanumeric characters and ignoring case. left, right = 0, len(s) - 1 while left < right: # Move the left pointer to the next alphanumeric character while left < right and not s[left].isalnum(): left += 1 # Move the right pointer to the previous alphanumeric character while left < right and not s[right].isalnum(): right -= 1 # Compare characters without case sensitivity if s[left].lower() != s[right].lower(): return False left += 1 right -= 1 return True"},{"question":"# Stooge Sort with a Twist In this task, you need to implement the Stooge Sort algorithm provided, but with a twist: The sorted order should follow an alternating pattern where the first element is the smallest, the second is the largest, the third is the second smallest, the fourth is the second largest, and so on. # Input Format * You will be provided with a single integer `n` representing the number of elements in the array. * The next line will contain `n` space-separated integers denoting the array elements. # Output Format * Print the array elements sorted in the required alternating order. # Constraints * 1 ≤ n ≤ 10^5 * -10^6 ≤ arr[i] ≤ 10^6 # Example Input ``` 7 4 1 3 9 7 6 2 ``` Output ``` 1 9 2 7 3 6 4 ``` # Notes 1. You can use any efficient sorting algorithm to sort the array initially. 2. After sorting the array, rearrange it in the alternating order as described in the problem statement. 3. Be mindful of the higher values of `n`. Use an efficient sorting algorithm to avoid time limit exceed problems. # Function Signature ```python def stooge_sort_alternating(arr: List[int]) -> List[int]: # your code here ```","solution":"def stooge_sort_alternating(arr): Returns the array with elements rearranged in alternating smallest-largest order after sorting the array initially. if not arr: return [] # Step 1: Sort the array arr.sort() # Step 2: Create an alternating list n = len(arr) result = [] left = 0 right = n - 1 while left <= right: if left == right: result.append(arr[left]) else: result.append(arr[left]) result.append(arr[right]) left += 1 right -= 1 return result"},{"question":"Spiral Matrix Traversal You have been given a matrix of `m x n` elements (m rows, n columns). Your task is to implement a function `spiralOrder` that returns all elements of the matrix in spiral order. Function Signature: ```python def spiralOrder(matrix: List[List[int]]) -> List[int]: pass ``` Input: * `matrix`: A list of `m` lists, each containing `n` integers. Output: * A list of integers representing the elements of the matrix traversed in spiral order. Constraints: * The number of elements in the matrix will be at most 10^4. * Matrix dimensions `m` and `n` are positive integers. Example: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] Expected output: [1, 2, 3, 6, 9, 8, 7, 4, 5] ``` Instructions: 1. Carefully consider all edge cases such as single row/column and empty matrices. 2. Ensure that your solution is efficient in terms of time and space complexity. 3. Pay attention to how you manage the boundaries (`row_begin`, `row_end`, `col_begin`, `col_end`) to correctly change direction when needed. Scenario: Imagine you are designing a visual display for a circular marquee text on a digital screen. The text is stored as a matrix of characters, and you need to read the characters in a spiral order to display them correctly. This function will be your core utility to achieve this.","solution":"from typing import List def spiralOrder(matrix: List[List[int]]) -> List[int]: Returns the elements of the matrix in spiral order. if not matrix or not matrix[0]: return [] result = [] row_begin, row_end = 0, len(matrix) - 1 column_begin, column_end = 0, len(matrix[0]) - 1 while row_begin <= row_end and column_begin <= column_end: # Traverse Right for j in range(column_begin, column_end + 1): result.append(matrix[row_begin][j]) row_begin += 1 # Traverse Down for i in range(row_begin, row_end + 1): result.append(matrix[i][column_end]) column_end -= 1 if row_begin <= row_end: # Traverse Left for j in range(column_end, column_begin - 1, -1): result.append(matrix[row_end][j]) row_end -= 1 if column_begin <= column_end: # Traverse Up for i in range(row_end, row_begin - 1, -1): result.append(matrix[i][column_begin]) column_begin += 1 return result"},{"question":"# Scenario You are developing a basic text editor that supports undo and redo operations efficiently. To implement this functionality, you need a data structure that allows you to move back and forth between states of text edits while also adding new states efficiently. # Task Implement a `DoublyLinkedList` class with the following functionalities: 1. **Insert a node at the end of the list**: - Method signature: `def append(self, value: Any) -> None` 2. **Delete a node given a reference to it**: - Method signature: `def delete_node(self, node: DoublyLinkedListNode) -> None` 3. **Find a node by its value (returns the first occurrence)**: - Method signature: `def find(self, value: Any) -> Optional[DoublyLinkedListNode]` 4. **Print the list from head to tail and from tail to head**: - Method signature: `def print_forward(self) -> None` - Method signature: `def print_backward(self) -> None` # Constraints * Values in the list are unique for simplicity. * Ensure all pointer updates are handled correctly to maintain the integrity of the doubly linked list. # Input and Output ```python # Example usage: dll = DoublyLinkedList() dll.append(10) dll.append(20) dll.append(30) node = dll.find(20) dll.delete_node(node) dll.print_forward() # Output should be \\"10 30\\" dll.print_backward() # Output should be \\"30 10\\" ``` # Note Focus on correctly handling edge cases such as: * Deleting the head or tail node. * Operating on an empty list. * Ensure methods perform efficiently based on the properties of doubly linked lists.","solution":"class DoublyLinkedListNode: def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def append(self, value): new_node = DoublyLinkedListNode(value) if self.tail is None: # Empty list self.head = new_node self.tail = new_node else: # Non-empty list self.tail.next = new_node new_node.prev = self.tail self.tail = new_node def delete_node(self, node): if not node: return if node.prev: node.prev.next = node.next if node.next: node.next.prev = node.prev if node == self.head: self.head = node.next if node == self.tail: self.tail = node.prev def find(self, value): current = self.head while current: if current.value == value: return current current = current.next return None def print_forward(self): current = self.head while current: print(current.value, end=\' \') current = current.next print() def print_backward(self): current = self.tail while current: print(current.value, end=\' \') current = current.prev print()"},{"question":"# Power of Two Check Challenge In digital systems, ensuring that resources are utilized efficiently can be critical. For certain use cases, data sizes or buffer lengths often align with powers of two. In this challenge, you are required to write a function that determines if a given integer is a power of two. This algorithm is essential for systems requiring alignment or partitioning strategies that necessitate sizes being powers of two. Function Signature ```python def is_power_of_two(n: int) -> bool: :type n: int :rtype: bool ``` Input * An integer `n` which can be negative, zero, or positive. Output * Return `True` if `n` is a power of two. * Return `False` otherwise. Constraints * The function must run in O(1) time complexity. * The function must use minimal space, i.e., O(1) space complexity. * Integer `n` can be any 32-bit signed integer. Examples ```python # Example 1 print(is_power_of_two(1)) # Expected output: True # Example 2 print(is_power_of_two(16)) # Expected output: True # Example 3 print(is_power_of_two(18)) # Expected output: False # Example 4 print(is_power_of_two(-4)) # Expected output: False # Example 5 print(is_power_of_two(0)) # Expected output: False ``` # Scenario You are given the task to develop a function for a memory management component of an embedded system where memory blocks are always allocated in power of two sizes. This is important to maintain memory alignment and performance. Implement and validate your `is_power_of_two` function to ensure that it correctly identifies powers of two under the specified constraints.","solution":"def is_power_of_two(n: int) -> bool: Determine if a given integer is a power of two. Args: n (int): The integer to check. Returns: bool: True if n is a power of two, False otherwise. if n <= 0: return False return (n & (n - 1)) == 0"},{"question":"# Question: Implement a Markov Chain Class You are required to implement a Markov Chain class that models a system using the Markov Chain principle. Your task includes writing methods for initializing the system with states and transitions, performing state transitions, and running simulations. Class Definition Create a class `MarkovChain` that supports the following functionalities: 1. **Initialization**: * Takes a state transition dictionary as input. * Validates the transition probabilities for each state. 2. **Next State Transition**: * Method `next_state(current_state)` that returns the next state based on weighted probabilities. 3. **Simulate**: * Method `simulate(start_state, num_steps)` that returns a list representing the sequence of states starting from `start_state` for `num_steps` transitions. Input and Output Format * **Initialization**: ```python markov_chain = MarkovChain({ \'A\': {\'A\': 0.6, \'E\': 0.4}, \'E\': {\'A\': 0.7, \'E\': 0.3} }) ``` * **next_state**: ```python next_state = markov_chain.next_state(\'A\') ``` * **simulate**: ```python sequence = markov_chain.simulate(\'A\', 10) ``` Constraints * Each state\'s transition probabilities should sum up to 1. * States with no outgoing transitions should raise an error. * Ensure randomness is properly utilized in state transitions to mimic real-world unpredictability. Performance Requirements The solution should efficiently handle state transitions and simulations with: * Up to 10,000 states. * Transition steps up to 1,000,000. Example ```python markov_chain = MarkovChain({ \'A\': {\'A\': 0.6, \'E\': 0.4}, \'E\': {\'A\': 0.7, \'E\': 0.3} }) print(markov_chain.simulate(\'A\', 5)) # Sample Output: [\'A\', \'E\', \'A\', \'A\', \'E\'] ``` Notes * Ensure your solution is well-tested, covers edge cases, and provides clear error messages. * Performance should be a consideration when designing the class methods.","solution":"import random class MarkovChain: def __init__(self, transition_probabilities): Initializes the Markov Chain with a dictionary of transition probabilities. Each state must have its transition probabilities that sum up to 1. self.transition_probabilities = transition_probabilities # Validate transition probabilities for state, transitions in transition_probabilities.items(): if not isinstance(transitions, dict) or not transitions: raise ValueError(f\\"State \'{state}\' has no transitions or invalid transition format.\\") total_prob = sum(transitions.values()) if abs(total_prob - 1.0) > 1e-6: raise ValueError(f\\"Transition probabilities for state \'{state}\' do not sum to 1, but {total_prob}\\") def next_state(self, current_state): Given the current state, return the next state based on the transition probabilities. if current_state not in self.transition_probabilities: raise ValueError(f\\"State \'{current_state}\' is not a valid state in the Markov chain.\\") transitions = self.transition_probabilities[current_state] states = list(transitions.keys()) probabilities = list(transitions.values()) return random.choices(states, probabilities)[0] def simulate(self, start_state, num_steps): Simulates a sequence of states starting from start_state for num_steps transitions. Returns a list of states. if start_state not in self.transition_probabilities: raise ValueError(f\\"Start state \'{start_state}\' is not a valid initial state.\\") if num_steps < 0: raise ValueError(\\"Number of steps must be a non-negative integer.\\") current_state = start_state sequence = [current_state] for _ in range(num_steps): current_state = self.next_state(current_state) sequence.append(current_state) return sequence"},{"question":"Context You are a software developer tasked with implementing a low-level addition operation for a project that requires high-efficiency arithmetic operations on small embedded systems where traditional arithmetic might be less efficient than bitwise operations. Task Write a function `add_two_numbers(x: int, y: int) -> int` that takes two non-negative integers `x` and `y` and returns their sum using bitwise operations only. You are not allowed to use the \'+\' operator. Input * `x` (0 <= x <= 10^9) - A non-negative integer. * `y` (0 <= y <= 10^9) - A non-negative integer. Output * An integer representing the sum of `x` and `y`. Constraints * Both `x` and `y` will be within the range [0, 10^9]. * You must use bitwise operations to compute the result. * You cannot use the \'+\' operator or any direct arithmetic operators for addition. Example ```python add_two_numbers(2, 3) # Output: 5 add_two_numbers(0, 10) # Output: 10 ```","solution":"def add_two_numbers(x: int, y: int) -> int: Returns the sum of x and y using bitwise operations only. while y != 0: # carry now contains the common set bits of x and y carry = x & y # sum of bits of x and y where at least one of the bits is not set x = x ^ y # carry is shifted by one so that adding it to x gives the required sum y = carry << 1 return x"},{"question":"Context A company uses a binary search tree (BST) to manage its hierarchical data relationships. You are required to verify if a given binary tree adheres to the properties of a BST. This is crucial for ensuring the integrity of their data operations. Task Write a function `is_bst` that takes the root of a binary tree and returns `True` if it is a valid BST, and `False` otherwise. ```python def is_bst(root): :type root: TreeNode :rtype: bool # Implementation here ``` Input Format * A binary tree root `root` where each node contains an integer value and pointers to left and right children. Output Format * Return `True` if the binary tree is a valid BST. * Return `False` if it is not. Constraints * The number of nodes in the tree is in the range `[0, 10^4]`. * `-2^31 <= Node.val <= 2^31 - 1` Examples Example 1: ``` 2 / 1 3 ``` * Input: `root = [2,1,3]` * Output: `True` Example 2: ``` 1 / 2 3 ``` * Input: `root = [1,2,3]` * Output: `False` Guidelines * You should implement the function using an iterative in-order traversal method. * Consider edge cases such as an empty tree, trees with duplicate values, and single-node trees. * Ensure the code handles trees with large depths effectively.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_bst(root): :type root: TreeNode :rtype: bool def validate(node, low=float(\'-inf\'), high=float(\'inf\')): if not node: return True if node.val <= low or node.val >= high: return False return validate(node.left, low, node.val) and validate(node.right, node.val, high) return validate(root)"},{"question":"# Context: You have been given a binary tree, and your task is to implement an algorithm to perform a post-order traversal on the tree. Your solution needs to handle both iterative and recursive approaches to complete the traversal. The iterative approach will help debug and understand the traversal path better without recursive function stack overhead. # Problem Statement: Implement the function `postorder_traversal` to perform a post-order traversal on a binary tree. The function should take two arguments: 1. `root`: The root node of the binary tree. 2. `method`: A string that can either be \\"iterative\\" or \\"recursive\\" indicating which approach to use. It should return a list of node values in the order they were visited post-order. # Function Signature: ```python def postorder_traversal(root: Node, method: str) -> list: pass ``` # Input: - `root`: An instance of the `Node` class. It can be `None` if the tree is empty. - `method`: A string, either `\\"iterative\\"` or `\\"recursive\\"`. # Output: - A list of integers representing the values of nodes visited in post-order. # Constraints: - The number of nodes in the binary tree is at most 1000. # Example: ```python # Tree Structure: # 1 # / # 2 3 # / / # 4 5 6 7 root = Node(1, Node(2, Node(4), Node(5)), Node(3, Node(6), Node(7))) assert postorder_traversal(root, \\"iterative\\") == [4, 5, 2, 6, 7, 3, 1] assert postorder_traversal(root, \\"recursive\\") == [4, 5, 2, 6, 7, 3, 1] ``` # Notes: - Ensure your function handles edge cases such as an empty tree. - Avoid using built-in functions that directly provide the traversal of the nodes. Your implementation should manually handle node traversal. - Optimize performance and watch for stack overflows with deeply nested trees.","solution":"class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def postorder_traversal(root, method): def recursive_postorder(node): if node is None: return [] return recursive_postorder(node.left) + recursive_postorder(node.right) + [node.val] def iterative_postorder(node): if node is None: return [] stack, output = [node], [] while stack: node = stack.pop() output.append(node.val) if node.left: stack.append(node.left) if node.right: stack.append(node.right) return output[::-1] if method == \\"recursive\\": return recursive_postorder(root) elif method == \\"iterative\\": return iterative_postorder(root) else: raise ValueError(\\"Invalid method. Choose either \'iterative\' or \'recursive\'.\\")"},{"question":"# Context You are assigned to implement a simple encryption tool for encoding secret messages in old historical scripts. The encryption method to use is the Atbash cipher, a very ancient method of encoding text by mapping each letter to its reverse counterpart in the alphabet. # Task Write a function `atbash_cipher` that takes a string `s` as input and returns its Atbash cipher encoded string. # Function Signature ```python def atbash_cipher(s: str) -> str: ``` # Input * A string `s` of length n (1 ≤ n ≤ 10^5) that may include alphabetic characters (both uppercase and lowercase) and non-alphabetic characters (e.g., numbers, symbols, spaces). # Output * A string where each alphabetic character in `s` is replaced by its counterpart in the Atbash cipher, preserving non-alphabetic characters (e.g., spaces, punctuation) as they are. # Constraints * The function must run in linear time O(n). * Non-alphabetic characters must not be altered. # Example ```python assert atbash_cipher(\\"Attack at dawn\\") == \\"Zggzxp zg wzdm\\" assert atbash_cipher(\\"Hello, World!\\") == \\"Svool, Dliow!\\" assert atbash_cipher(\\"123 ABC xyz\\") == \\"123 ZYX cba\\" ``` # Hints * You may find the `ord` and `chr` functions useful for converting between characters and their ASCII values. * Be aware of both uppercase and lowercase mappings separately.","solution":"def atbash_cipher(s: str) -> str: def atbash_char(c): if \'A\' <= c <= \'Z\': return chr(ord(\'A\') + (ord(\'Z\') - ord(c))) elif \'a\' <= c <= \'z\': return chr(ord(\'a\') + (ord(\'z\') - ord(c))) else: return c return \'\'.join(atbash_char(c) for c in s)"},{"question":"**Context**: You are working on a Number Analysis Tool that provides various utilities for number manipulation and analysis. As part of this tool, you need to implement a function that determines the number of digits in a given integer. **Task**: Write a function `num_digits(n)` that takes a single integer `n` as input and returns the number of digits it contains. The function should operate in constant time O(1). **Requirements**: - The function should accurately handle both negative and positive integers. - If the input number is zero, the function should return 1. **Input**: - A single integer `n` within the range -10^18 to 10^18. **Output**: - An integer representing the number of digits in the input number. ```python def num_digits(n): import math # Write your implementation here pass ``` **Constraints**: - The function should work in constant time O(1). - Consider the edge cases such as `n` being zero or a negative number.","solution":"def num_digits(n): Returns the number of digits in the input integer. Parameters: n (int): The input integer, can be negative or positive. Returns: int: The number of digits in n. if n == 0: return 1 return len(str(abs(n)))"},{"question":"Optimal Path Finder in a Weighted Directed Graph Given a weighted directed graph, implement a function to find the **shortest path** from a given start node to an end node using Dijkstra\'s algorithm. Your implementation should handle graphs where some nodes might not be reachable from others and return `None` in such cases. # Function Signature ```python def dijkstra_shortest_path(graph: Dict[str, List[Tuple[str, int]]], start: str, end: str) -> Optional[List[str]]: pass ``` # Input - `graph`: A dictionary where keys are node identifiers (str), and values are lists of tuples. Each tuple contains: - A target node (str) this node has a directed edge to. - An integer weight (int) representing the edge\'s weight. - `start`: The starting node identifier (str). - `end`: The end node identifier (str). # Output - A list of node identifiers (List[str]) representing the shortest path from `start` to `end` node, including both. - Return `None` if there is no valid path from `start` to `end`. # Constraints - Node identifiers are unique. - Edge weights are non-negative integers. - The graph can have cycles but will not have negative weight cycles. - `start` and `end` nodes will always be present in the graph keys. # Examples ```python graph = { \'A\': [(\'B\', 3), (\'D\', 1)], \'B\': [(\'A\', 3), (\'D\', 3), (\'E\', 1)], \'C\': [(\'E\', 4)], \'D\': [(\'A\', 1), (\'B\', 3), (\'E\', 1)], \'E\': [(\'B\', 1), (\'C\', 4), (\'D\', 1)] } # Example 1 start = \'A\' end = \'C\' print(dijkstra_shortest_path(graph, start, end)) # Output: [\'A\', \'D\', \'E\', \'C\'] # Example 2 start = \'A\' end = \'A\' print(dijkstra_shortest_path(graph, start, end)) # Output: [\'A\'] ``` # Explanation - In the first example, the path \'A\' -> \'D\' -> \'E\' -> \'C\' is the shortest path costing 1+1+4 = 6. - In the second example, since the start and end are the same, the shortest path is just [\'A\']. # Additional Notes 1. Be sure to handle cases where a node might not be reachable from the starting node. 2. Thoroughly test your solution with varying graph structures including edge cases like disconnected nodes and direct self-loops.","solution":"import heapq from typing import Dict, List, Tuple, Optional def dijkstra_shortest_path(graph: Dict[str, List[Tuple[str, int]]], start: str, end: str) -> Optional[List[str]]: Implements Dijkstra\'s algorithm to find the shortest path in a weighted directed graph. :param graph: Dictionary representing the graph where keys are node identifiers and values are lists of tuples representing the edges and their respective weights. :param start: The starting node identifier. :param end: The end node identifier. :return: A list of node identifiers representing the shortest path from start to end. Returns None if no path exists. # Priority queue to store (cost, vertex, path_taken) heap = [(0, start, [start])] distances = {start: 0} visited = set() while heap: cost, current_node, path = heapq.heappop(heap) if current_node in visited: continue if current_node == end: return path visited.add(current_node) for neighbor, weight in graph.get(current_node, []): if neighbor in visited: continue new_cost = cost + weight if neighbor not in distances or new_cost < distances[neighbor]: distances[neighbor] = new_cost heapq.heappush(heap, (new_cost, neighbor, path + [neighbor])) return None # No path found"},{"question":"# Problem: Enhanced Sorting Algorithm You have been given an array of integers which can contain both positive and negative numbers. Your task is to enhance the given Exchange Sort algorithm to handle the following specific requirements: 1. The enhanced sort should move all negative numbers to the beginning of the array while keeping their relative order. 2. After moving the negatives, sort the remaining non-negative part of the array using an optimized sorting approach. **Function Signature:** ```python def enhanced_exchange_sort(arr: List[int]) -> List[int]: ``` **Input:** * `arr` (list of int): An array consisting of n integers, where `0 <= n <= 10^4`. **Output:** * Returns a list of integers sorted with the rules specified. **Example:** ```python # Example 1 input: [1, -2, 3, -4, 5] output: [-2, -4, 1, 3, 5] # Example 2 input: [4, -1, -3, 2, 0, -4] output: [-1, -3, -4, 0, 2, 4] ``` **Constraints:** 1. You must use the given Exchange Sort concept to partially sort the array. 2. Enhance the given Exchange Sort such that it meets the performance requirements optimally. 3. The output must be precise and cover all edge cases. 4. The function should handle an empty input array and return an empty array in such a case. **Performance Requirements:** Ensure that the sorting operation on the non-negative portion of the array uses an efficient algorithm such as QuickSort or MergeSort, with a time complexity of O(n log n) for better performance on larger datasets.","solution":"from typing import List def enhanced_exchange_sort(arr: List[int]) -> List[int]: # Step 1: Separate the negative and non-negative numbers while maintaining order negatives = [x for x in arr if x < 0] non_negatives = [x for x in arr if x >= 0] # Step 2: Sort the non-negative part using an optimized sort (QuickSort in this case) non_negatives.sort() # Step 3: Combine the results return negatives + non_negatives"},{"question":"# Matrix Multiplication Problem You are given two matrices, `A` and `B`, represented as lists of lists of integers. Your task is to write a function that computes the product of these two matrices. # Function Signature ```python def multiply(multiplicand: list, multiplier: list) -> list: :type multiplicand: List[List[int]] :type multiplier: List[List[int]] :rtype: List[List[int]] ``` # Input - `multiplicand`: A matrix represented as a list of lists of integers with dimensions `m x n`. - `multiplier`: A matrix represented as a list of lists of integers with dimensions `n x p`. # Output - Return the product of the matrices `multiplicand` and `multiplier` as a list of lists of integers with dimensions `m x p`. # Constraints - Assume that both matrices have at least one element. - The number of columns in `multiplicand` is equal to the number of rows in `multiplier`. # Performance Requirements - The algorithm should be as efficient as possible. Aim for O(n^3) time complexity and O(n^2) space complexity. # Examples ``` Input: multiplicand = [[1, 2], [3, 4]], multiplier = [[5, 6], [7, 8]] Output: [[19, 22], [43, 50]] Input: multiplicand = [[1]], multiplier = [[2]] Output: [[2]] ``` # Important Notes - If the matrices are incompatible for multiplication, the function should raise an Exception with the message \\"Multiplicand matrix not compatible with Multiplier matrix.\\" # Guidelines for Implementation 1. Verify the dimensions of the matrices. 2. Initialize the result matrix with appropriate dimensions. 3. Use nested loops to compute the product of the matrices. 4. Ensure your code is readable and well-commented.","solution":"def multiply(multiplicand: list, multiplier: list) -> list: Returns the product of two matrices multiplicand and multiplier. # Get dimensions rows_m = len(multiplicand) cols_m = len(multiplicand[0]) rows_n = len(multiplier) cols_n = len(multiplier[0]) # Verify matrix dimensions if cols_m != rows_n: raise Exception(\\"Multiplicand matrix not compatible with Multiplier matrix.\\") # Initialize the result matrix with dimensions (rows_m x cols_n) result = [[0 for _ in range(cols_n)] for _ in range(rows_m)] # Compute the product for i in range(rows_m): for j in range(cols_n): for k in range(cols_m): result[i][j] += multiplicand[i][k] * multiplier[k][j] return result"},{"question":"Markov Chain Simulator Context In this task, you are to implement a Markov Chain simulator. This simulator will generate a sequence of states starting from an initial state and moving between states based on given probabilities. Problem Description You are requested to improve and expand the provided Markov Chain implementation. Specifically, you must implement a `MarkovChainSimulator` class that: 1. Initializes with a dictionary representing the Markov Chain. 2. Stores the state and performs transitions using the given probabilities. 3. Generates a sequence of states. Class Definition ```python class MarkovChainSimulator: def __init__(self, chain): Initializes the Markov Chain Simulator with the given chain. Args: chain (dict): A dictionary representing the Markov Chain. pass def next_state(self, current_state): Given the current state, randomly choose the next state based on transition probabilities. Args: current_state (str): The current state. Returns: str: The next state. pass def generate_states(self, initial_state, num_iterations): Generate a sequence of states starting from the initial state. Args: initial_state (str): The initial state to start from. num_iterations (int): Number of state transitions to perform. Returns: List[str]: A list of states representing the sequence of states generated. pass ``` Example ```python # Sample Markov Chain chain = { \'A\': {\'A\': 0.6, \'B\': 0.4}, \'B\': {\'A\': 0.7, \'B\': 0.3} } # Initialize the simulator with the given chain simulator = MarkovChainSimulator(chain) # Generate a sequence of states starting from \'A\' for 10 iterations sequence = simulator.generate_states(\'A\', 10) print(sequence) # Example Output: [\'A\', \'B\', \'A\', \'A\', \'B\', \'A\', \'A\', \'A\', \'B\', \'A\'] ``` Constraints 1. Transition probabilities in the chain dictionary are guaranteed to sum up to 1 for each state. 2. `num_iterations` is a positive integer. Implementation Instructions 1. Implement the `__init__` method to initialize the chain. 2. Implement the `next_state` method similar to the provided `next_state` function, but encapsulate it within the class. 3. Implement the `generate_states` method to generate a sequence of states according to the specified Markov Chain and initial state. Additional Notes * Ensure that the class is efficient and adheres to the complexity constraints discussed. * Handle common edge cases like states with no outgoing transitions or nonexistent states gracefully.","solution":"import random class MarkovChainSimulator: def __init__(self, chain): Initializes the Markov Chain Simulator with the given chain. Args: chain (dict): A dictionary representing the Markov Chain. self.chain = chain def next_state(self, current_state): Given the current state, randomly choose the next state based on transition probabilities. Args: current_state (str): The current state. Returns: str: The next state. transitions = self.chain.get(current_state, {}) if not transitions: return None states = list(transitions.keys()) probabilities = list(transitions.values()) return random.choices(states, probabilities)[0] def generate_states(self, initial_state, num_iterations): Generate a sequence of states starting from the initial state. Args: initial_state (str): The initial state to start from. num_iterations (int): Number of state transitions to perform. Returns: List[str]: A list of states representing the sequence of states generated. sequence = [initial_state] current_state = initial_state for _ in range(num_iterations): current_state = self.next_state(current_state) if current_state is None: break sequence.append(current_state) return sequence"},{"question":"Context You are working on an efficient search algorithm to support a large database system recording rotating sensor readings sorted initially in ascending order but could be pivoted. This data is crucial for finding the minimal readings quickly and validating sensor performance. Problem Statement Given a sorted array that has been rotated at an unknown pivot point (e.g., `[0, 1, 2, 4, 5, 6, 7]` might become `[4, 5, 6, 7, 0, 1, 2]`), write a function `find_minimum` that efficiently finds and returns the minimum element in this array. You must implement this using a binary search mechanism to achieve a time complexity of O(log N). You may assume that no duplicate values exist in the array. Function Signature ```python def find_minimum(array: List[int]) -> int: pass ``` Input - `array`: A list of integers representing the rotated sorted array. Array length is at least 1. Output - Returns the integer value of the minimum element in the array. Constraints - The array will have at least one element. - The array does not contain duplicates. - The algorithm must run in O(log N) time complexity. Example ```python # Example 1 find_minimum([3, 4, 5, 1, 2]) -> 1 # Example 2 find_minimum([4, 5, 6, 7, 0, 1, 2]) -> 0 # Example 3 find_minimum([1]) -> 1 # Example 4 find_minimum([2, 3, 4, 5, 6, 7, 1]) -> 1 ``` Notes - Ensure to handle arrays that are not rotated. - Focus on achieving logarithmic time complexity. - Consider typical binary search edge cases in implementation.","solution":"from typing import List def find_minimum(array: List[int]) -> int: Finds the minimum element in a rotated sorted array using binary search. left, right = 0, len(array) - 1 while left < right: mid = (left + right) // 2 if array[mid] > array[right]: left = mid + 1 else: right = mid return array[left]"},{"question":"# Red-Black Tree Insertion and Deletion **Objective**: Implement functions to insert and delete nodes in a Red-Black tree. This will test your proficiency with tree operations, balancing methods, and handling edge cases. **Function Implementations**: 1. `rb_insert(node)`: Inserts a node into the Red-Black tree. 2. `rb_delete(node)`: Removes a node from the Red-Black tree and re-balances it. **Expected Input and Output**: Your implementation should include: - Class Definitions for `RBNode` and `RBTree`. - Methods `insert(self, node: RBNode)` and `delete(self, node: RBNode)` within `RBTree`. **Constraints**: - Each node in the Red-Black tree will be an instance of the `RBNode` class. - Nodes will contain integer values and a color (represented by `1` for red and `0` for black). **Insertion**: - Input: A `RBNode` object with a value to be inserted. - Output: None. The node should be appropriately placed within the tree. **Deletion**: - Input: A `RBNode` object that exists within the tree. - Output: None. The node should be properly removed, and the tree should remain balanced. **Performance**: - Ensure operations stabilize within O(log n) in average and worst cases. - Memory usage should remain linear with respect to the number of nodes. **Scenario**: Assume you are developing functionalities for a dynamic set data structure that supports both insertions and deletions efficiently using a Red-Black tree. **Example**: ```python class RBNode: def __init__(self, val, is_red, parent=None, left=None, right=None): self.val = val self.parent = parent self.left = left self.right = right self.color = is_red class RBTree: def __init__(self): self.root = None # Insert Method def insert(self, node: RBNode): # Your implementation here # Delete Method def delete(self, node: RBNode): # Your implementation here # Example Usage rb_tree = RBTree() nodes = [RBNode(val, 1) for val in [10, 20, 30, 15, 25]] for node in nodes: rb_tree.insert(node) # Delete a node rb_tree.delete(nodes[3]) assert rb_tree.root is not None ``` **NOTE**: Ensure you handle all the properties of Red-Black trees during node insertions and deletions as stated in your analysis. Pay attention to re-balancing through rotations and color changes to maintain tree properties.","solution":"class RBNode: def __init__(self, val, is_red, parent=None, left=None, right=None): self.val = val self.parent = parent self.left = left self.right = right self.color = is_red class RBTree: def __init__(self): self.NIL_LEAF = RBNode(val=None, is_red=0) # NIL_LEAF as black self.root = self.NIL_LEAF def insert(self, node: RBNode): if self.root == self.NIL_LEAF: node.color = 0 node.left = self.NIL_LEAF node.right = self.NIL_LEAF self.root = node else: self._rb_insert(self.root, node) self._fix_insert(node) def _rb_insert(self, current, node): if node.val < current.val: if current.left == self.NIL_LEAF: node.parent = current node.left = self.NIL_LEAF node.right = self.NIL_LEAF current.left = node else: self._rb_insert(current.left, node) else: if current.right == self.NIL_LEAF: node.parent = current node.left = self.NIL_LEAF node.right = self.NIL_LEAF current.right = node else: self._rb_insert(current.right, node) def _fix_insert(self, node): while node != self.root and node.parent.color == 1: if node.parent == node.parent.parent.left: uncle = node.parent.parent.right if uncle.color == 1: node.parent.color = 0 uncle.color = 0 node.parent.parent.color = 1 node = node.parent.parent else: if node == node.parent.right: node = node.parent self._left_rotate(node) node.parent.color = 0 node.parent.parent.color = 1 self._right_rotate(node.parent.parent) else: uncle = node.parent.parent.left if uncle.color == 1: node.parent.color = 0 uncle.color = 0 node.parent.parent.color = 1 node = node.parent.parent else: if node == node.parent.left: node = node.parent self._right_rotate(node) node.parent.color = 0 node.parent.parent.color = 1 self._left_rotate(node.parent.parent) self.root.color = 0 def _left_rotate(self, node): y = node.right node.right = y.left if y.left != self.NIL_LEAF: y.left.parent = node y.parent = node.parent if node.parent == None: self.root = y elif node == node.parent.left: node.parent.left = y else: node.parent.right = y y.left = node node.parent = y def _right_rotate(self, node): y = node.left node.left = y.right if y.right != self.NIL_LEAF: y.right.parent = node y.parent = node.parent if node.parent == None: self.root = y elif node == node.parent.right: node.parent.right = y else: node.parent.left = y y.right = node node.parent = y def delete(self, node: RBNode): self._rb_delete(self.root, node) def _rb_delete(self, root, node): z = node y = z y_original_color = y.color if z.left == self.NIL_LEAF: x = z.right self._transplant(z, z.right) elif z.right == self.NIL_LEAF: x = z.left self._transplant(z, z.left) else: y = self._minimum(z.right) y_original_color = y.color x = y.right if y.parent == z: x.parent = y else: self._transplant(y, y.right) y.right = z.right y.right.parent = y self._transplant(z, y) y.left = z.left y.left.parent = y y.color = z.color if y_original_color == 0: self._fix_delete(x) def _transplant(self, u, v): if u.parent == None: self.root = v elif u == u.parent.left: u.parent.left = v else: u.parent.right = v v.parent = u.parent def _minimum(self, node): while node.left != self.NIL_LEAF: node = node.left return node def _fix_delete(self, x): while x != self.root and x.color == 0: if x == x.parent.left: w = x.parent.right if w.color == 1: w.color = 0 x.parent.color = 1 self._left_rotate(x.parent) w = x.parent.right if w.left.color == 0 and w.right.color == 0: w.color = 1 x = x.parent else: if w.right.color == 0: w.left.color = 0 w.color = 1 self._right_rotate(w) w = x.parent.right w.color = x.parent.color x.parent.color = 0 w.right.color = 0 self._left_rotate(x.parent) x = self.root else: w = x.parent.left if w.color == 1: w.color = 0 x.parent.color = 1 self._right_rotate(x.parent) w = x.parent.left if w.left.color == 0 and w.right.color == 0: w.color = 1 x = x.parent else: if w.left.color == 0: w.right.color = 0 w.color = 1 self._left_rotate(w) w = x.parent.left w.color = x.parent.color x.parent.color = 0 w.left.color = 0 self._right_rotate(x.parent) x = self.root x.color = 0"},{"question":"# Queue Max Value Finder You are provided with two implementations of the Queue ADT: `ArrayQueue` and `LinkedListQueue`. Your task is to implement a function called `max_in_queue` that finds the maximum integer value in a given queue. This function should work for both types of queues. # Function Signature ```python def max_in_queue(queue: AbstractQueue) -> int: ``` # Input * An instance of `AbstractQueue` which can be of type `ArrayQueue` or `LinkedListQueue`. You can assume all elements are integers and the queue is non-empty. # Output * Returns the maximum integer value within the queue. # Example ```python q = ArrayQueue() q.enqueue(3) q.enqueue(1) q.enqueue(4) q.enqueue(1) q.enqueue(5) print(max_in_queue(q)) # Output should be 5 q2 = LinkedListQueue() q2.enqueue(10) q2.enqueue(20) q2.enqueue(5) print(max_in_queue(q2)) # Output should be 20 ``` # Constraints and Limitations * The queue will always have at least one element. * Assume that the values in the queue can fit within a standard integer data type. # Scenario Imagine you are working with different queue implementations in a task processing system, and you need to occasionally query for the peak processing duration among queued tasks. Implement the `max_in_queue` function to quickly find this information regardless of the underlying queue implementation.","solution":"def max_in_queue(queue): Returns the maximum integer value in the given queue. Args: queue (AbstractQueue): The queue containing integer elements. Returns: int: The maximum integer value in the queue. max_value = float(\'-inf\') size = queue.size() for _ in range(size): value = queue.dequeue() if value > max_value: max_value = value queue.enqueue(value) return max_value"},{"question":"**Problem Statement:** You have been hired by a software company to improve their data handling module. The current module needs a highly efficient sorting algorithm that can be massively parallelized. One of the suitable algorithms here is the Bitonic Sort, but it is essential that you understand and can implement this algorithm efficiently. Write a function `bitonic_sort(arr, reverse=False)` that implements the Bitonic Sort algorithm. This function should sort the input list `arr` in ascending order if `reverse` is `False`, and in descending order if `reverse` is `True`. **Function Signature:** ```python def bitonic_sort(arr, reverse=False): pass ``` # Input: - `arr`: a list of integers to be sorted. It is guaranteed that the length of `arr` is a power of 2. - `reverse`: a boolean flag indicating the sort order. Default is `False` (sort in ascending order). # Output: - Returns a new list of integers sorted according to the specified order. # Constraints: - The length of `arr` will be a power of 2. - The input list `arr` can be of a size from `2` up to `2^20`. # Example: ```python print(bitonic_sort([3, 7, 2, 8, 6, 4, 1, 5])) # Output: [1, 2, 3, 4, 5, 6, 7, 8] print(bitonic_sort([3, 7, 2, 8, 6, 4, 1, 5], reverse=True)) # Output: [8, 7, 6, 5, 4, 3, 2, 1] ``` # Notes: - Take care to handle the recursive nature of sorting and merging correctly. - Ensure error handling for the edge case where input length is not a power of 2, even though under normal conditions length should be guaranteed as a power of 2. - The sorting algorithm needs to be efficient and adhere to its non-parallel time complexity constraints.","solution":"def bitonic_sort(arr, reverse=False): Perform Bitonic Sort on the input list. :param arr: List of integers to be sorted. :param reverse: Boolean flag indicating the order. Default is False (ascending). :return: New list sorted in the specified order. def bitonic_merge(arr, low, cnt, direction): if cnt > 1: k = cnt // 2 for i in range(low, low + k): if (direction == (arr[i] > arr[i + k])): arr[i], arr[i + k] = arr[i + k], arr[i] bitonic_merge(arr, low, k, direction) bitonic_merge(arr, low + k, k, direction) def bitonic_sort_rec(arr, low, cnt, direction): if cnt > 1: k = cnt // 2 bitonic_sort_rec(arr, low, k, True) bitonic_sort_rec(arr, low + k, k, False) bitonic_merge(arr, low, cnt, direction) n = len(arr) bitonic_sort_rec(arr, 0, n, not reverse) return arr"},{"question":"Range Summarization of Sorted Integers Given a sorted list of distinct integers, write a function `summarize_ranges` that returns a list of strings summarizing the ranges of consecutive numbers. # Function Signature ```python def summarize_ranges(array: List[int]) -> List[str]: # your code here ``` # Input - A list of distinct integers `array` which is sorted in ascending order. - Size constraints: 1 ≤ len(array) ≤ 10^4 # Output - A list of strings, each string represents either a single integer or a range of consecutive integers in the format \\"start-end\\". # Example ```python assert summarize_ranges([0, 1, 2, 4, 5, 7]) == [\\"0-2\\", \\"4-5\\", \\"7\\"] assert summarize_ranges([1, 3, 5, 7]) == [\\"1\\", \\"3\\", \\"5\\", \\"7\\"] assert summarize_ranges([-1, 0, 1, 2, 4, 7, 8, 10]) == [\\"-1-2\\", \\"4\\", \\"7-8\\", \\"10\\"] ``` # Constraints and Limitations - The input array will always be sorted in ascending order and contain no duplicates. - The function should work efficiently with the maximum constraints. # Performance Requirements - Your algorithm\'s time complexity should be O(n). - Your algorithm\'s space complexity should be O(n), where n is the length of the input list. Develop a robust solution considering edge cases and adhering to performance constraints. Validate your implementation with provided test cases and consider additional scenarios to ensure its correctness.","solution":"from typing import List def summarize_ranges(array: List[int]) -> List[str]: if not array: return [] ranges = [] start = array[0] end = array[0] for number in array[1:]: if number == end + 1: end = number else: if start == end: ranges.append(f\\"{start}\\") else: ranges.append(f\\"{start}-{end}\\") start = number end = number if start == end: ranges.append(f\\"{start}\\") else: ranges.append(f\\"{start}-{end}\\") return ranges"},{"question":"Implementing Range Sum Queries with Segment Tree You are tasked with implementing a segment tree to compute the sum of elements in a subrange of an array. The segment tree should be able to efficiently handle range sum queries and updates to the array. Requirements: 1. **SegmentTree Class**: Implement a segment tree that supports range sum queries. 2. **Functions**: * `__init__(self, arr: List[int])`: Initializes the segment tree from the given array. * `update(self, index: int, value: int)`: Updates the element at the specified index with the new value, and updates the segment tree accordingly. * `sum_range(self, left: int, right: int) -> int`: Returns the sum of elements in the range `[left, right]` inclusive. Input and Output: * The segment tree is initialized with an array of integers. * The `sum_range` function should return an integer representing the sum of elements in the specified range. * The `update` function should modify the value at the given index and update the segment tree to reflect the change. Constraints: * The number of elements in the array will be between 1 and 10^5. * Array elements will be between -10^4 and 10^4. * Multiple sum and update operations will be performed. Example: ```python # Example usage of the SegmentTree class arr = [1, 3, 5] segment_tree = SegmentTree(arr) print(segment_tree.sum_range(0, 2)) # Output: 9 (1 + 3 + 5) segment_tree.update(1, 2) # arr becomes [1, 2, 5] print(segment_tree.sum_range(0, 2)) # Output: 8 (1 + 2 + 5) ``` Notes: * Ensure to handle edge cases like querying an empty array or updating out of bounds indices gracefully. * Provide an efficient solution to meet the problem\'s constraints.","solution":"from typing import List class SegmentTree: def __init__(self, arr: List[int]): self.n = len(arr) self.tree = [0] * (2 * self.n) self.build(arr) def build(self, arr: List[int]): # Initialize leaves for i in range(self.n): self.tree[self.n + i] = arr[i] # Initialize internal nodes for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1] def update(self, index: int, value: int): pos = index + self.n self.tree[pos] = value while pos > 1: pos //= 2 self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1] def sum_range(self, left: int, right: int) -> int: result = 0 left += self.n right += self.n + 1 while left < right: if left % 2: result += self.tree[left] left += 1 if right % 2: right -= 1 result += self.tree[right] left //= 2 right //= 2 return result"},{"question":"You are tasked with implementing a variation of the Cocktail Shaker Sort to assess your understanding of sorting algorithms. This will involve modifying the given Cocktail Shaker Sort to handle a specific scenario efficiently. # Scenario Consider a storage system where large items (represented by negative integers) need to be rearranged to come before smaller items (positive integers) in ascending order. Additionally, within each group (negative and positive), the items must be sorted in ascending order. # Task Your task is to implement a function `custom_cocktail_shaker_sort` that sorts the array under the following condition: all negative numbers should come before positive numbers, with each group sorted in ascending order. # Function Signature ```python def custom_cocktail_shaker_sort(arr: List[int]) -> List[int]: Sorts a list such that all negative numbers come before positive numbers, and each group is sorted individually in ascending order. ``` # Input Format - `arr`: List of integers where `-10^5 <= arr[i] <= 10^5` # Output Format - A sorted list of integers meeting the specified conditions. # Constraints - Sorting must be performed in-place (O(1) space complexity). # Example ```python Input: [3, -1, 2, -2, 0, -3] Output: [-3, -2, -1, 0, 2, 3] Input: [10, -5, -3, 2, 1, 0, -2] Output: [-5, -3, -2, 0, 1, 2, 10] ``` # Implementation Requirements 1. Implement the sorting algorithm such that the negative integers precede the positive ones. 2. Within the negative and positive integer groups, sort the elements in ascending order using a bidirectional approach. 3. Ensure that the function runs efficiently and handles edge cases like empty arrays or arrays with identical elements.","solution":"from typing import List def custom_cocktail_shaker_sort(arr: List[int]) -> List[int]: def cocktail_shaker_sort(sub_arr): n = len(sub_arr) start = 0 end = n - 1 swapped = True while swapped: swapped = False for i in range(start, end): if sub_arr[i] > sub_arr[i + 1]: sub_arr[i], sub_arr[i + 1] = sub_arr[i + 1], sub_arr[i] swapped = True if not swapped: break swapped = False end -= 1 for i in range(end, start, -1): if sub_arr[i] < sub_arr[i - 1]: sub_arr[i], sub_arr[i - 1] = sub_arr[i - 1], sub_arr[i] swapped = True start += 1 negatives = [x for x in arr if x < 0] non_negatives = [x for x in arr if x >= 0] cocktail_shaker_sort(negatives) cocktail_shaker_sort(non_negatives) return negatives + non_negatives"},{"question":"Given a range of integers [low, high], write a function `find_eureka_numbers(low, high)` that returns a list of numbers such that for each number in the list, it is equal to the sum of its digits raised to the consecutive powers of their positions. For example, 89 is a Eureka number since 8^1 + 9^2 = 89, and 135 is also a Eureka number since 1^1 + 3^2 + 5^3 = 135. # Input * An integer `low` (1 <= low <= 10^6) which indicates the start of the range. * An integer `high` (low <= high <= 10^6) which indicates the end of the range. # Output * A list of integers that are Eureka numbers within the specified range. # Example ```python assert find_eureka_numbers(1, 10) == [1, 2, 3, 4, 5, 6, 7, 8, 9] assert find_eureka_numbers(1, 100) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 89] assert find_eureka_numbers(90, 150) == [135] ``` # Constraints * You must ensure the implementation has a reasonable execution time for the maximum input range. * Efficient handling of mathematical operations to maintain performative bounds is advised.","solution":"def find_eureka_numbers(low, high): Returns a list of Eureka numbers (also known as sum of digits raised to consecutive powers) within the specified range [low, high]. Parameters: low (int): The start of the range. high (int): The end of the range. Returns: List[int]: List of Eureka numbers in the range [low, high]. def is_eureka_number(num): digits = [int(digit) for digit in str(num)] return num == sum(digit ** (idx + 1) for idx, digit in enumerate(digits)) return [num for num in range(low, high + 1) if is_eureka_number(num)]"},{"question":"You are tasked with implementing a function that simplifies a given Unix-style absolute file path. The input will be a string representation of the absolute path, and the function should return the simplified canonical path. This problem tests your understanding of string manipulation and stack usage. # Function Signature ```python def simplify_path(path: str) -> str: ``` # Input * A string `path` represents an absolute path in a Unix-style file system. * The path is non-empty and contains only characters `a-z`, `/`, `.` and `..`. # Output * Returns a simplified canonical path as a string. # Constraints * The resulting path must start with a single \\"/\\". * The canonical path must not have any redundant slashes (\'//\'), \\".\\" components, and \\"..\\" components should properly direct to the parent directory if applicable. * If the input path is empty or invalid, return \\"/\\". # Performance Requirements * The solution should run in O(n) time complexity, where n is the length of the path string. # Examples ```python assert simplify_path(\\"/home/\\") == \\"/home\\" assert simplify_path(\\"/a/./b/../../c/\\") == \\"/c\\" assert simplify_path(\\"/../\\") == \\"/\\" assert simplify_path(\\"/home//foo/\\") == \\"/home/foo\\" assert simplify_path(\\"/home/../../..\\") == \\"/\\" assert simplify_path(\\"/./././.\\") == \\"/\\" assert simplify_path(\\"/...\\") == \\"/...\\" assert simplify_path(\\"/home/../usr/./bin/\\") == \\"/usr/bin\\" ``` # Notes 1. Be aware of paths that attempt to navigate beyond the root directory (e.g., \\"/../\\"). 2. Ensure to handle multiple consecutive slashes correctly by treating them as a single slash. 3. Leverage a stack to manage the directories and simplify the path.","solution":"def simplify_path(path: str) -> str: Simplifies the given Unix-style absolute path to its canonical form. Parameters: path (str): The absolute path string to be simplified. Returns: str: The simplified canonical path. stack = [] parts = path.split(\'/\') for part in parts: if part == \\"..\\": if stack: stack.pop() elif part and part != \\".\\": stack.append(part) return \\"/\\" + \\"/\\".join(stack)"},{"question":"Find Connected Components in a 2D Grid You are given a grid consisting of cells with values `0` (water) and `1` (land). Two cells are considered connected if they are adjacent horizontally or vertically. Write a function `count_connected_components(grid)` to count the number of connected components of lands (`1`s) in the given grid. # Function Signature ```python def count_connected_components(grid: List[List[int]]) -> int: pass ``` # Input * `grid`: A 2D list of integers where each cell is either 0 (water) or 1 (land). # Output * An integer representing the number of connected components of lands. # Constraints * `1 <= len(grid) <= 1000` * `1 <= len(grid[0]) <= 1000` * Each element in `grid[i][j]` is either `0` or `1`. # Example ```python grid = [ [1, 1, 0, 0, 0], [0, 1, 0, 0, 1], [1, 0, 0, 1, 1], [0, 0, 0, 0, 0], [1, 0, 1, 0, 1] ] print(count_connected_components(grid)) # Output: 6 ``` # Explanation In the given example, there are six connected components of lands. Each `1` connected horizontally or vertically forms a component.","solution":"from typing import List def count_connected_components(grid: List[List[int]]) -> int: Counts the number of connected components of lands (1s) in the given grid. if not grid: return 0 rows = len(grid) cols = len(grid[0]) def dfs(r, c): stack = [(r, c)] while stack: x, y = stack.pop() if 0 <= x < rows and 0 <= y < cols and grid[x][y] == 1: grid[x][y] = -1 # mark as visited stack.append((x + 1, y)) stack.append((x - 1, y)) stack.append((x, y + 1)) stack.append((x, y - 1)) connected_components = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 1: connected_components += 1 dfs(r, c) return connected_components"},{"question":"You are given four matrix transformation functions: `rotate_clockwise`, `rotate_counterclockwise`, `top_left_invert`, and `bottom_left_invert`. These functions perform various 2D matrix manipulations either by rotating or inverting the matrix. Your task is to write a function: ```python def matrix_transform(matrix, operation): pass ``` # Input * `matrix` (List[List[int]]): A 2D list (matrix) of integers with dimensions `n x n`. * `operation` (str): A string indicating the type of transformation. It can be one of the following: - `\\"rotate_clockwise\\"`: Rotate the matrix 90 degrees clockwise. - `\\"rotate_counterclockwise\\"`: Rotate the matrix 90 degrees counterclockwise. - `\\"top_left_invert\\"`: Bottom-right to top-left transposition. - `\\"bottom_left_invert\\"`: Mirror from bottom-left to top-right. # Output * Return the transformed matrix as a 2D list. # Constraints * 1 <= n <= 10^2 * Elements of the matrix are integers. # Performance Requirements * Aim for O(n^2) time complexity and O(n^2) space complexity due to matrix transformation operations. # Function Signature ```python def matrix_transform(matrix, operation): # Your implementation here ``` # Examples ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], ] assert matrix_transform(matrix, \\"rotate_clockwise\\") == [ [7, 4, 1], [8, 5, 2], [9, 6, 3], ] assert matrix_transform(matrix, \\"rotate_counterclockwise\\") == [ [3, 6, 9], [2, 5, 8], [1, 4, 7], ] assert matrix_transform(matrix, \\"top_left_invert\\") == [ [1, 4, 7], [2, 5, 8], [3, 6, 9], ] assert matrix_transform(matrix, \\"bottom_left_invert\\") == [ [9, 6, 3], [8, 5, 2], [7, 4, 1], ] ```","solution":"def rotate_clockwise(matrix): n = len(matrix) new_matrix = [[0]*n for _ in range(n)] for i in range(n): for j in range(n): new_matrix[j][n-1-i] = matrix[i][j] return new_matrix def rotate_counterclockwise(matrix): n = len(matrix) new_matrix = [[0]*n for _ in range(n)] for i in range(n): for j in range(n): new_matrix[n-1-j][i] = matrix[i][j] return new_matrix def top_left_invert(matrix): n = len(matrix) new_matrix = [[0]*n for _ in range(n)] for i in range(n): for j in range(n): new_matrix[i][j] = matrix[j][i] return new_matrix def bottom_left_invert(matrix): n = len(matrix) new_matrix = [[0]*n for _ in range(n)] for i in range(n): for j in range(n): new_matrix[i][j] = matrix[n-1-j][n-1-i] return new_matrix def matrix_transform(matrix, operation): if operation == \\"rotate_clockwise\\": return rotate_clockwise(matrix) elif operation == \\"rotate_counterclockwise\\": return rotate_counterclockwise(matrix) elif operation == \\"top_left_invert\\": return top_left_invert(matrix) elif operation == \\"bottom_left_invert\\": return bottom_left_invert(matrix) else: raise ValueError(f\\"Unknown operation {operation}\\")"},{"question":"# Question: KMP Algorithm Implementation Challenge **Context**: You have been given a series of texts and patterns where you need to efficiently find all instances of each given pattern within its corresponding text. This is common in several applications like search engines, text editors, and DNA sequence analysis. Write a function that implements the Knuth-Morris-Pratt (KMP) string matching algorithm to find all occurrences of a pattern string within a given text string. **Function Signature**: ```python def kmp_search(text: Sequence[str], pattern: Sequence[str]) -> List[int]: ``` **Input**: - `text`: A sequence of characters where the pattern needs to be searched (0 <= len(text) <= 10^5). - `pattern`: A sequence of characters to search within the text (0 <= len(pattern) <= 10^5). **Output**: - A list of starting indices where the pattern is found in the text. If the pattern is not found, return an empty list. **Constraints**: - The function should handle edge cases such as empty strings and large input sizes efficiently. - Time complexity should be O(N + M), and space complexity should be O(M), where N is the length of the text and M is the length of the pattern. **Examples**: 1. `kmp_search(\'hello there hero!\', \'he\')` should return `[0, 7, 12]`. 2. `kmp_search(\'abcdabcabc\', \'abc\')` should return `[0, 4, 7]`. 3. `kmp_search(\'aaaaa\', \'bba\')` should return `[]`. 4. `kmp_search(\'\', \'a\')` should return `[]`. 5. `kmp_search(\'a\', \'\')` should return `[]`. **Instructions**: - Ensure your solution is efficient and handles all edge cases. - You are encouraged to optimize the code to handle large inputs within acceptable performance limits.","solution":"from typing import Sequence, List def kmp_search(text: Sequence[str], pattern: Sequence[str]) -> List[int]: if not pattern: return [] # Preprocess the pattern to create the longest prefix suffix (LPS) array lps = [0] * len(pattern) j = 0 # Build the LPS array i = 1 while i < len(pattern): if pattern[i] == pattern[j]: j += 1 lps[i] = j i += 1 else: if j != 0: j = lps[j - 1] else: lps[i] = 0 i += 1 # Now, use the LPS array to search the pattern in the text result = [] i = 0 # Index for text j = 0 # Index for pattern while i < len(text): if pattern[j] == text[i]: i += 1 j += 1 if j == len(pattern): result.append(i - j) j = lps[j - 1] # Reset j using LPS array elif i < len(text) and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return result"},{"question":"# Scenario You are given a list of integers representing the daily temperatures in a city for the last `n` days. You need to frequently answer queries and update the temperatures based on new readings. Write a class `TemperatureAnalyzer` utilizing a segment tree that supports the following operations: 1. `__init__(self, arr)`: Initializes the object with the array `arr` representing temperatures. 2. `get_max_temperature(self, L, R)`: Returns the maximum temperature recorded between days L and R (inclusive). 3. `update_temperature(self, idx, val)`: Updates the temperature at day `idx` to `val`. # Constraints - 1 <= len(arr) <= 10^5 - 1 <= L, R, idx < len(arr) - -100 <= arr[i], val <= 100 # Input and Output Formats Input for initialization and updates are arrays, while queries return values. Example: ```python # Initialize temperatures temps = TemperatureAnalyzer([30, 25, 28, 35, 32, 31, 36]) # Query the maximum temperature from days 1 to 4. print(temps.get_max_temperature(1, 4)) # Output should be 35 # Update the temperature on day 3 to 40. temps.update_temperature(3, 40) # Query again after update. print(temps.get_max_temperature(1, 4)) # Output should now be 40 ```","solution":"class TemperatureAnalyzer: def __init__(self, arr): Initializes the data structure with the input temperature array. self.n = len(arr) self.tree = [0] * (2 * self.n) self.build(arr) def build(self, arr): # Building the tree for i in range(self.n): self.tree[self.n + i] = arr[i] for i in range(self.n - 1, 0, -1): self.tree[i] = max(self.tree[i * 2], self.tree[i * 2 + 1]) def update_temperature(self, idx, val): # Update element at index `idx` and then update the segment tree pos = idx + self.n self.tree[pos] = val while pos > 1: pos //= 2 self.tree[pos] = max(self.tree[2 * pos], self.tree[2 * pos + 1]) def get_max_temperature(self, L, R): # Returns the maximum temperature between days L and R (inclusive) L += self.n R += self.n max_temp = float(\'-inf\') while L <= R: if L % 2 == 1: max_temp = max(max_temp, self.tree[L]) L += 1 if R % 2 == 0: max_temp = max(max_temp, self.tree[R]) R -= 1 L //= 2 R //= 2 return max_temp"},{"question":"# Matrix Transformation Challenge You are given a square matrix (n x n) containing integers. Your task is to implement three distinct transformations on this matrix and one composite function as follows: 1. **Rotate 90 Degrees Clockwise**: Rotate the matrix elements by 90 degrees in a clockwise direction. 2. **Rotate 90 Degrees Counterclockwise**: Rotate the matrix elements by 90 degrees in a counterclockwise direction. 3. **Invert Top to Bottom**: Vertically flip the matrix along its horizontal midline. 4. **Composite Transformation**: Implement a function that receives a sequence of the above transformations (as a list of function names) and applies them in the given order on the matrix. # Requirements * **Function Signatures**: * `def rotate_clockwise(matrix: List[List[int]]) -> List[List[int]]:` * `def rotate_counterclockwise(matrix: List[List[int]]) -> List[List[int]]:` * `def invert_top_bottom(matrix: List[List[int]]) -> List[List[int]]:` * `def composite_transformations(matrix: List[List[int]], transformations: List[str]) -> List[List[int]]:` * **Input/Output**: * Each function receives a matrix: List[List[int]] and returns a transformed matrix: List[List[int]]. * The `transformations` parameter in `composite_transformations` is a list of function names as strings, e.g., `[\\"rotate_clockwise\\", \\"invert_top_bottom\\"]`. * **Constraints**: * The matrix will always be non-empty and square (n x n where 1 <= n <= 100). * Only the valid function names will be passed to `composite_transformations`. # Example ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] print(rotate_clockwise(matrix)) # Output: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] print(rotate_counterclockwise(matrix)) # Output: # [ # [3, 6, 9], # [2, 5, 8], # [1, 4, 7] # ] print(invert_top_bottom(matrix)) # Output: # [ # [7, 8, 9], # [4, 5, 6], # [1, 2, 3] # ] print(composite_transformations(matrix, [\\"rotate_clockwise\\", \\"invert_top_bottom\\"])) # Output: # [ # [9, 6, 3], # [8, 5, 2], # [7, 4, 1] # ] ```","solution":"from typing import List def rotate_clockwise(matrix: List[List[int]]) -> List[List[int]]: Rotate the matrix 90 degrees clockwise. n = len(matrix) return [[matrix[n - j - 1][i] for j in range(n)] for i in range(n)] def rotate_counterclockwise(matrix: List[List[int]]) -> List[List[int]]: Rotate the matrix 90 degrees counterclockwise. n = len(matrix) return [[matrix[j][n - i - 1] for j in range(n)] for i in range(n)] def invert_top_bottom(matrix: List[List[int]]) -> List[List[int]]: Vertically flip the matrix along its horizontal midline. return matrix[::-1] def composite_transformations(matrix: List[List[int]], transformations: List[str]) -> List[List[int]]: Apply a sequence of transformations to the matrix in the given order. for transformation in transformations: if transformation == \\"rotate_clockwise\\": matrix = rotate_clockwise(matrix) elif transformation == \\"rotate_counterclockwise\\": matrix = rotate_counterclockwise(matrix) elif transformation == \\"invert_top_bottom\\": matrix = invert_top_bottom(matrix) else: raise ValueError(f\\"Unknown transformation: {transformation}\\") return matrix"},{"question":"# Insertion Sort with Binary Search Scenario: You have been tasked to implement a function for sorting an array of integers. To do this efficiently, you will use the insertion sort algorithm but enhance it using binary search to find the correct insertion position. Using binary search will reduce the number of comparisons needed to find the insert position. Requirements: 1. Implement the helper function `search_insert(array, val)` that returns the index where the value should be inserted in a sorted array. 2. Using this helper function, complete the `insertion_sort(array)` function to perform an insertion sort. Function Signatures: ```python def search_insert(array, val): Params: array (List[int]): A sorted list of integers val (int): The target value to find the insertion index for Returns: int: Index at which the val should be inserted to maintain sorted order # Binary search implementation pass def insertion_sort(array): Sorts the array using insertion sort enhanced with binary search to find insertion index. Params: array (List[int]): List of integers to be sorted Returns: List[int]: A new list containing the sorted integers # Use search_insert for finding correct position pass ``` Input and Output: - `search_insert(array, val)`: - Input: `array` - a sorted list of integers and `val` - the integer to be inserted. - Output: an integer representing the index at which `val` should be inserted to maintain the sorted order. - `insertion_sort(array)`: - Input: `array` - list of integers to be sorted. - Output: a new list of sorted integers. Constraints: - The maximum length of the array will be 10^3. - Each integer in the array is between -10^6 to 10^6. Example: ```python # Example for search_insert print(search_insert([1, 3, 5, 6], 5)) # Output: 2 print(search_insert([1, 3, 5, 6], 2)) # Output: 1 print(search_insert([1, 3, 5, 6], 0)) # Output: 0 print(search_insert([1, 3, 5, 6], 7)) # Output: 4 # Example for insertion_sort print(insertion_sort([12, 11, 13, 5, 6])) # Output: [5, 6, 11, 12, 13] print(insertion_sort([4, 3, 2, 10, 12, 1, 5, 6])) # Output: [1, 2, 3, 4, 5, 6, 10, 12] ```","solution":"def search_insert(array, val): Params: array (List[int]): A sorted list of integers val (int): The target value to find the insertion index for Returns: int: Index at which the val should be inserted to maintain sorted order left, right = 0, len(array) - 1 while left <= right: mid = (left + right) // 2 if array[mid] < val: left = mid + 1 elif array[mid] > val: right = mid - 1 else: return mid return left def insertion_sort(array): Sorts the array using insertion sort enhanced with binary search to find insertion index. Params: array (List[int]): List of integers to be sorted Returns: List[int]: A new list containing the sorted integers sorted_array = [] for i in range(len(array)): val = array[i] index = search_insert(sorted_array, val) sorted_array.insert(index, val) return sorted_array"},{"question":"# Problem: Abbreviation Generator You are provided with a word, and your task is to generate a list of all possible unique abbreviations for that word. An abbreviation of a word follows these rules: 1. Each abbreviation can contain letters and numbers. 2. Numbers in an abbreviation represent the count of consecutive letters that are abbreviated (skipped). For example, for the word `\\"word\\"`, the possible abbreviations are: `[\\"word\\", \\"wor1\\", \\"wo1d\\", \\"wo2\\", \\"w1rd\\", \\"w1r1\\", \\"w2d\\", \\"w3\\", \\"1ord\\", \\"1or1\\", \\"1o1d\\", \\"1o2\\", \\"2rd\\", \\"2r1\\", \\"3d\\", \\"4\\"]`. # Function Specification Function Signature: ```python def generate_abbreviations(word: str) -> List[str]: ``` Input: - `word`: A string of lowercase letters (0 <= len(word) <= 20). Output: - A list of strings representing all unique abbreviations of the given word. # Constraints: - The function should handle words of lengths up to 20 characters efficiently. - Duplicate abbreviations should not occur in the output. - Ensure that the function adheres to the specified complexity. Example: ```python print(generate_abbreviations(\\"word\\")) # Output: [\\"word\\", \\"wor1\\", \\"wo1d\\", \\"wo2\\", \\"w1rd\\", \\"w1r1\\", \\"w2d\\", \\"w3\\", \\"1ord\\", \\"1or1\\", \\"1o1d\\", \\"1o2\\", \\"2rd\\", \\"2r1\\", \\"3d\\", \\"4\\"] print(generate_abbreviations(\\"\\")) # Output: [\\"\\"] ``` # Requirements: - Implement the function without assuming the existence of helper libraries. - Consider edge cases like empty strings or strings with repeated characters. - Integrate error handling for unexpected inputs gracefully.","solution":"from typing import List def generate_abbreviations(word: str) -> List[str]: def backtrack(index: int, current: str, count: int): if index == len(word): if count > 0: current += str(count) result.append(current) else: # Abbreviate the current character backtrack(index + 1, current, count + 1) # Keep the current character new_current = current + (str(count) if count > 0 else \'\') + word[index] backtrack(index + 1, new_current, 0) result = [] backtrack(0, \\"\\", 0) return result"},{"question":"**Prime Number Batch Processor** # Problem Statement You are required to create a function `batch_prime_check` that processes a batch of numbers and returns a list indicating whether each number in the batch is prime or not. The function should leverage the given algorithm for checking prime numbers and should handle a list of multiple integers efficiently. # Function Signature ```python def batch_prime_check(nums: List[int]) -> List[bool]: ``` # Input * A list `nums` of integers, where each integer (n) is in the range ([-10^6, 10^6]). The list has at most (10^4) elements. # Output * A list of boolean values, where each boolean corresponds to the primality of the number at the same index in the input list `nums`. # Constraints * Handle negative integers and numbers like 0 appropriately, as per the definitions of prime numbers. * The solution should efficiently handle up to (10^4) individual primality checks, leveraging pre-existing algorithms or additional optimizations as necessary. # Performance Requirements * **Time Complexity**: Ideally, each primality check should run in (O(sqrt{n})). * **Space Complexity**: The space complexity should remain (O(1)), but accounting for the storage of input and output lists. # Scenario Consider a scenario where you need to process a list of integers quickly to determine which numbers are prime. For instance, a batch computation in a cryptographic application that needs to generate or validate prime numbers on the fly could use such a function. # Example ```python # Example Input nums = [2, 3, 4, 5, -1, 0, 17, 18] # Expected Output [True, True, False, True, False, False, True, False] result = batch_prime_check(nums) assert result == [True, True, False, True, False, False, True, False] ```","solution":"import math from typing import List def is_prime(n: int) -> bool: if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def batch_prime_check(nums: List[int]) -> List[bool]: return [is_prime(num) for num in nums]"},{"question":"# Question: Implement a Multi-word Auto-suggestion System Your task is to implement a system that can provide auto-suggestions based on user input prefixes for multi-word strings. The system should be able to insert phrases and query for phrases based on prefixes of any length. This will help in applications such as search bars and auto-completion engines. # Functions to Implement: 1. **insert_phrase(phrase: str)** - Insert a complete phrase into the system. 2. **query_suggestions(prefix: str) -> List[str]** - Return a list of phrases that start with the given prefix. # Input: - The function `insert_phrase` takes a single string representing a phrase. The phrase consists of one or more words separated by spaces. - The function `query_suggestions` takes a single string representing the prefix. The prefix consists of one or more words separated by spaces. # Output: - `query_suggestions` should return a list of strings where each string is a phrase that starts with the given prefix. The returned list should be sorted lexicographically. # Constraints: - All phrases and prefixes consist of lowercase letters a-z and spaces. - The number of phrases inserted into the system will not exceed 100,000. - Each phrase and prefix will have at most 100 characters. # Example: ```python # Example usage: auto_suggester = TrieAutoSuggester() auto_suggester.insert_phrase(\\"hello world\\") auto_suggester.insert_phrase(\\"hello\\") auto_suggester.insert_phrase(\\"hell yeah\\") auto_suggester.insert_phrase(\\"hi there\\") assert auto_suggester.query_suggestions(\\"h\\") == [\\"hell yeah\\", \\"hello\\", \\"hello world\\", \\"hi there\\"] assert auto_suggester.query_suggestions(\\"hello\\") == [\\"hello\\", \\"hello world\\"] assert auto_suggester.query_suggestions(\\"hell\\") == [\\"hell yeah\\", \\"hello\\", \\"hello world\\"] assert auto_suggester.query_suggestions(\\"hi\\") == [\\"hi there\\"] ``` # Note: - Implement the class `TrieAutoSuggester` with the methods described above. - Ensure your implementation is efficient in terms of both time and space. - Use a trie (prefix tree) as the underlying data structure to optimize the insert and query operations.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_phrase = False self.phrases = [] class TrieAutoSuggester: def __init__(self): self.root = TrieNode() def insert_phrase(self, phrase: str): current_node = self.root for char in phrase: if char not in current_node.children: current_node.children[char] = TrieNode() current_node = current_node.children[char] current_node.phrases.append(phrase) current_node.is_end_of_phrase = True def query_suggestions(self, prefix: str): current_node = self.root for char in prefix: if char not in current_node.children: return [] current_node = current_node.children[char] # Collect all phrases from the current node return sorted(current_node.phrases)"},{"question":"# Context You\'re building an application that needs to handle a dynamic set of user data efficiently. To accomplish this, you decide to use a hash table to store user information with the ability to add, delete, retrieve data, and resize the hash table automatically when necessary to maintain efficiency. # Task Implement a `ResizableHashTable` class based on the `HashTable` class provided. The `ResizableHashTable` should automatically resize itself when the usage reaches a specified threshold. The resize operation should approximately double the size of the table and rehash all current keys. # Function Signature and Requirements 1. Implement the class `ResizableHashTable` with necessary methods such as `put`, `get`, `del_`, resize when `2/3` of the table is filled, and appropriate constructor. 2. Ensure your implementation handles edge cases, minimizes performance bottlenecks, and correctly rehashes items on resizing. # Input and Output - **Input**: Each method: - `put(key, value)`: Adds or updates the key-value pair. - `get(key)`: Returns the value associated with the given key or `None` if the key does not exist. - `del_(key)`: Deletes the key-value pair if exists. Returns `None` if the key does not exist. - The hash table resizes and rehashes all entries when more than `2/3` of the table is filled. # Constraints - Assume keys are integers. - Keys and values are non-negative integers. - The initial table size should be 8. - Avoid rehashing on every operation, do so only when necessary to avoid performance degradation. # Example Usage ```python htable = ResizableHashTable() htable.put(1, 10) htable.put(2, 20) htable.put(3, 30) assert htable.get(1) == 10 assert htable.get(2) == 20 assert htable.get(3) == 30 htable.del_(2) assert htable.get(2) == None # assuming more puts here will trigger a resize ``` Implement the `ResizableHashTable` class considering above requirements and edge cases.","solution":"class ResizableHashTable: def __init__(self): self.size = 8 self.count = 0 self.threshold = 2 / 3 self.table = [None] * self.size def _hash(self, key): return key % self.size def _resize(self): new_size = self.size * 2 new_table = [None] * new_size for item in self.table: if item is not None: for key, value in item: new_index = key % new_size if new_table[new_index] is None: new_table[new_index] = [] new_table[new_index].append((key, value)) self.table = new_table self.size = new_size def _check_resize(self): if self.count / self.size > self.threshold: self._resize() def put(self, key, value): index = self._hash(key) if self.table[index] is None: self.table[index] = [] for i, (k, v) in enumerate(self.table[index]): if k == key: self.table[index][i] = (key, value) return self.table[index].append((key, value)) self.count += 1 self._check_resize() def get(self, key): index = self._hash(key) if self.table[index] is None: return None for k, v in self.table[index]: if k == key: return v return None def del_(self, key): index = self._hash(key) if self.table[index] is None: return None for i, (k, v) in enumerate(self.table[index]): if k == key: self.table[index].pop(i) self.count -= 1 return v return None"},{"question":"**Scenario:** You are working on a project involving hierarchical data where you need to analyze the depth of various binary tree structures. To determine the most nested level of data, you will calculate the maximum depth of these binary trees. Your task is to implement a function that efficiently computes this maximum depth based on a given binary tree. **Task:** Implement a function `max_height` that calculates the maximum depth of a given binary tree. For this purpose, you will use a breadth-first traversal method (level-order traversal). **Function Signature:** ```python def max_height(root: TreeNode) -> int: # Your implementation here ``` **Input:** - `root`: The root node of a binary tree. It is an instance of the `TreeNode` class where each node has properties `val`, `left`, and `right`. The `TreeNode` class is defined as follows: ```python class TreeNode: def __init__(self, val: int, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.val = val self.left = left self.right = right ``` **Output:** - Return an integer representing the maximum depth of the binary tree. **Constraints:** - The number of nodes in the tree is in the range [0, 10^4]. - The value of each node is an integer. **Example:** ```python tree = TreeNode(1) tree.left = TreeNode(2) tree.left.left = TreeNode(4) tree.left.right = TreeNode(5) tree.right = TreeNode(3) assert max_height(tree) == 3 ``` **Explanation:** 1. The root node has a value of 1. 2. The left child of the root node has a value of 2, and the right child of the root has a value of 3. 3. The left child of node 2 has value 4, and the right child of node 2 has value 5. The tree\'s maximum depth is 3. **Additional Notes:** - Consider edge cases such as an empty tree (root is `None`), which should result in a depth of 0. - Beware of deep, unbalanced trees that might affect memory usage or performance. - Carefully manage the queue to ensure level order processing.","solution":"from collections import deque class TreeNode: def __init__(self, val: int, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.val = val self.left = left self.right = right def max_height(root: TreeNode) -> int: if not root: return 0 max_depth = 0 queue = deque([(root, 1)]) while queue: current_node, depth = queue.popleft() max_depth = max(max_depth, depth) if current_node.left: queue.append((current_node.left, depth + 1)) if current_node.right: queue.append((current_node.right, depth + 1)) return max_depth"},{"question":"You are given a set of distinct integers `nums`. Write a function to return all possible subsets of the set. The solution should include subsets of all sizes, including the empty subset and the subset containing all the elements. # Requirements 1. Implement two versions of the function: - A recursive function using backtracking. - An iterative function. 2. Both implementations should adhere to the following specifications: - Input: A list of distinct integers `nums`. - Output: A list of lists, where each list is a subset of `nums`. # Constraints - The input list `nums` can have up to 20 distinct integers. - The integers are unique and can be any integer value. # Example ```python Input: nums = [1, 2, 3] Output: [ [], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3] ] ``` # Performance - Both implementations must handle the upper limit of the input size (20 elements) efficiently within reasonable run-time limits attributed to the O(2^n) complexity. # Function Signatures ```python def subsets_recursive(nums): # Your code here def subsets_iterative(nums): # Your code here ```","solution":"def subsets_recursive(nums): Returns all possible subsets of the list nums using a recursive approach. def backtrack(start, path): result.append(path[:]) for i in range(start, len(nums)): path.append(nums[i]) backtrack(i + 1, path) path.pop() result = [] backtrack(0, []) return result def subsets_iterative(nums): Returns all possible subsets of the list nums using an iterative approach. result = [[]] for num in nums: result += [curr + [num] for curr in result] return result"},{"question":"# Question: Consider the Stooge Sort algorithm as provided above. This algorithm, though not efficient, serves as an exercise in understanding recursive sorting. Your task is to modify the Stooge Sort algorithm to handle sorting of data beyond just integers, ensuring it can sort a list of strings lexicographically. Requirements: 1. Implement a new function `stooge_sort_strings(arr: List[str], l: int, h: int) -> None` that sorts an array of strings lexicographically using the Stooge Sort approach. 2. Ensure the algorithm correctly handles: - Different lengths of strings. - Case sensitivity (i.e., it should be case-insensitive for sorting). Input: - `arr`: A list of strings (List[str]), where each string can contain any mix of lower and upper case letters. - `l`: The starting index of the portion of the array to be sorted (int). - `h`: The ending index of the portion of the array to be sorted (int). Output: - The function should modify the list in place, resulting in a lexicographically sorted list of strings. Examples: ```python # Example 1 array = [\\"banana\\", \\"Apple\\", \\"cherry\\"] stooge_sort_strings(array, 0, len(array) - 1) print(array) # Output: [\\"Apple\\", \\"banana\\", \\"cherry\\"] # Example 2 array = [\\"Zeppelin\\", \\"apple\\", \\"Zephyr\\"] stooge_sort_strings(array, 0, len(array) - 1) print(array) # Output: [\\"Zephyr\\", \\"Zeppelin\\", \\"apple\\"] ``` Constraints: - You may assume that the input list contains at least one string and at most 1000 strings. - Each string in the list contains at least one character and at most 100 characters. Performance Note: While Stooge Sort is inherently inefficient, ensuring it handles case insensitivity correctly is an additional key requirement. Efficiency is not the primary concern due to the nature of the algorithm.","solution":"def stooge_sort_strings(arr, l, h): Sorts an array of strings lexicographically using the Stooge Sort approach. The sorting is case insensitive. :param arr: List[str] - The array of strings to be sorted. :param l: int - The starting index of the portion of the array to be sorted. :param h: int - The ending index of the portion of the array to be sorted. if l >= h: return # Case-insensitive comparison if arr[l].lower() > arr[h].lower(): arr[l], arr[h] = arr[h], arr[l] if h - l + 1 > 2: t = (h - l + 1) // 3 stooge_sort_strings(arr, l, h - t) stooge_sort_strings(arr, l + t, h) stooge_sort_strings(arr, l, h - t) # Example usage: array = [\\"banana\\", \\"Apple\\", \\"cherry\\"] stooge_sort_strings(array, 0, len(array) - 1) print(array) # Output: [\\"Apple\\", \\"banana\\", \\"cherry\\"] array = [\\"Zeppelin\\", \\"apple\\", \\"Zephyr\\"] stooge_sort_strings(array, 0, len(array) - 1) print(array) # Output: [\\"apple\\", \\"Zephyr\\", \\"Zeppelin\\"]"},{"question":"**Scenario**: You are working on a custom recommendation system. Part of this involves considering every possible combination of features to understand their individual impacts. For this problem, you need to generate all possible combinations (subsets) of given features. Implement a function `subsets(nums: List[int]) -> List[List[int]]` that takes a list of distinct integers `nums` and returns all possible subsets of the list. Input: * `nums` - A list of distinct integers (e.g. `[1,2,3]`) * The length of `nums` will be at most `20`. Output: * A list of lists, where each list is a subset of `nums`. Example: ```python >>> subsets([1,2,3]) [ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], [] ] ``` Constraints: * The solution set must not contain duplicate subsets. * You may use either recursive backtracking or an iterative approach. Performance Requirements: * Ensure that your implementation runs efficiently considering the input constraints. Remember to handle edge cases such as an empty input list or a list with a single element. **Extra Credit**: For additional practice, you may implement an alternative iterative method in a function `subsets_v2(nums: List[int]) -> List[List[int]]`. ```python def subsets(nums): Your implementation here. pass def subsets_v2(nums): Your iterative implementation here. pass ```","solution":"from typing import List def subsets(nums: List[int]) -> List[List[int]]: def backtrack(start, path): result.append(list(path)) for i in range(start, len(nums)): path.append(nums[i]) backtrack(i + 1, path) path.pop() result = [] backtrack(0, []) return result def subsets_v2(nums: List[int]) -> List[List[int]]: result = [[]] for num in nums: result += [curr + [num] for curr in result] return result"},{"question":"# Gnome Sort Optimization Problem Context Gnome Sort is a straightforward sorting algorithm that works by comparing and swapping adjacent elements similar to insertion sort. It continues moving an element to the beginning until it finds its correct position. Despite its simplicity, Gnome Sort is inefficient on large, unsorted lists due to its O(n^2) worst-case time complexity. Task You are asked to implement an optimized version of Gnome Sort for educational software. Your implementation should retain the same method but attempt to reduce the number of unnecessary swaps by avoiding them where possible. Detailed Requirements * Implement a function `optimized_gnome_sort(arr: List[int]) -> List[int]` that sorts an input list of integers using the principles of Gnome Sort but includes optimization for reducing unnecessary swaps. * Input: * `arr` - A list of integers that need to be sorted. * Output: * A list of sorted integers. * Constraints: * Minimal list length is 0 and maximum can go up to 10^4. * Performance requirements: * The solution must handle larger inputs efficiently but acknowledge that the worst-case scenario\'s complexity remains quadratic. Example Input: `[34, 2, 10, -9]` Output: `[-9, 2, 10, 34]` Note The function should handle both already sorted lists and reverse sorted lists prudently to showcase the optimization effectiveness.","solution":"from typing import List def optimized_gnome_sort(arr: List[int]) -> List[int]: Sorts a list of integers using an optimized version of the Gnome Sort algorithm. if not arr: return arr n = len(arr) index = 0 while index < n: if index == 0 or arr[index] >= arr[index - 1]: index += 1 else: arr[index], arr[index - 1] = arr[index - 1], arr[index] index -= 1 return arr"},{"question":"**Problem Statement**: Given an array of strings, write a function to find the longest common prefix string amongst them. If there is no common prefix, return an empty string. You are provided with three existing solutions using different algorithms: Horizontal Scanning, Vertical Scanning, and Divide and Conquer. Your task is to implement a new approach called Binary Search and compare its performance with the provided solutions. # Binary Search Implementation **Expected Input and Output:** * **Input**: An array of strings `strs` where `1 <= len(strs) <= 200` and `0 <= len(str[i]) <= 200`. * **Output**: The longest common prefix string. **Constraints**: - All input strings are in lowercase letters only (`a-z`). - Performance should be optimum, focusing on minimizing the number of comparisons. # Binary Search Algorithm: 1. Find the minimum string length in the array. 2. Use binary search on the range [1, min_length], and check if the prefix of a certain length is common among all strings. 3. Adjust the binary search based on the result until finding the longest common prefix. # Function Signature: ```python def longest_common_prefix_binary_search(strs: List[str]) -> str: # Implement your solution here ``` # Example 1: ```python Input: [\\"flower\\",\\"flow\\",\\"flight\\"] Output: \\"fl\\" ``` # Example 2: ```python Input: [\\"dog\\",\\"racecar\\",\\"car\\"] Output: \\"\\" ``` Your Tasks: 1. Implement the `longest_common_prefix_binary_search` function. 2. Compare the performance of your implementation with the provided solutions (`longest_common_prefix_v1`, `longest_common_prefix_v2`, `longest_common_prefix_v3`) using a list of test cases. 3. Discuss which algorithm performs the best under different scenarios and why.","solution":"from typing import List def is_common_prefix(strs: List[str], length: int) -> bool: Check if a specific length of prefix is common among all strings. prefix = strs[0][:length] return all(s.startswith(prefix) for s in strs) def longest_common_prefix_binary_search(strs: List[str]) -> str: Finds the longest common prefix string amongst an array of strings using binary search. if not strs: return \\"\\" min_length = min(len(s) for s in strs) low, high = 1, min_length while low <= high: mid = (low + high) // 2 if is_common_prefix(strs, mid): low = mid + 1 else: high = mid - 1 return strs[0][:(low + high) // 2] # Existing Solutions (for comparison) # Horizontal Scanning def longest_common_prefix_v1(strs: List[str]) -> str: if not strs: return \\"\\" prefix = strs[0] for s in strs[1:]: while s.find(prefix) != 0: prefix = prefix[:-1] if not prefix: return \\"\\" return prefix # Vertical Scanning def longest_common_prefix_v2(strs: List[str]) -> str: if not strs: return \\"\\" for i in range(len(strs[0])): char = strs[0][i] for s in strs: if i == len(s) or s[i] != char: return strs[0][:i] return strs[0] # Divide and Conquer def longest_common_prefix_v3(strs: List[str]) -> str: if not strs: return \\"\\" def common_prefix(left: str, right: str) -> str: min_length = min(len(left), len(right)) for i in range(min_length): if left[i] != right[i]: return left[:i] return left[:min_length] def divide_and_conquer(l: int, r: int) -> str: if l == r: return strs[l] mid = (l + r) // 2 lcp_left = divide_and_conquer(l, mid) lcp_right = divide_and_conquer(mid + 1, r) return common_prefix(lcp_left, lcp_right) return divide_and_conquer(0, len(strs) - 1)"},{"question":"Context You are given a singly linked list where each node contains an integer value. Your task is to write a function that swaps every two adjacent nodes and returns the head of the modified list. The function should not create new nodes or alter the values of existing nodes, but should rearrange the nodes by changing pointers. This problem tests your understanding of pointer manipulation in linked lists and in-place data structures. Function Signature ```python def swap_pairs(head: Node) -> Node: # Your code here ``` Input * `head` (Node): The head node of the singly linked list. The node class is defined as follows: ```python class Node(object): def __init__(self, x): self.val = x self.next = None ``` Output * Returns the head node of the list after swapping every two adjacent nodes. Constraints * The list should be modified in-place with constant additional space. * The nodes\' values must not be changed. * Nodes should only be rearranged by changing pointers. Example ```python # Helper function to create a linked list from a list def create_list(arr): if not arr: return None head = Node(arr[0]) current = head for val in arr[1:]: current.next = Node(val) current = current.next return head # Helper function to convert linked list to list (for easy verification) def to_list(head): result = [] while head: result.append(head.val) head = head.next return result # Example usage head = create_list([1, 2, 3, 4]) new_head = swap_pairs(head) print(to_list(new_head)) # Output: [2, 1, 4, 3] head = create_list([1]) new_head = swap_pairs(head) print(to_list(new_head)) # Output: [1] head = create_list([]) new_head = swap_pairs(head) print(to_list(new_head)) # Output: [] ```","solution":"class Node(object): def __init__(self, x): self.val = x self.next = None def swap_pairs(head: Node) -> Node: if not head or not head.next: return head dummy = Node(0) dummy.next = head prev, current = dummy, head while current and current.next: first = current second = current.next prev.next = second first.next = second.next second.next = first prev = first current = first.next return dummy.next"},{"question":"# Question: Implement Modular Exponentiation Algorithm Scenario/Context: Consider a scenario where secure communications and cryptographic applications require efficient computations of large powers with modular arithmetic. The security of encryption methods often depends on the ability to compute such large exponentiations efficiently. You are responsible for implementing a function that can handle these large computations both iteratively and recursively. Task: You are required to implement two functions: one using an iterative approach and the other using a recursive approach, to compute the power of a number with optional modular arithmetic. Detailed Requirements: 1. **Function Name**: `power_iter` (for iterative version) 2. **Function Name**: `power_recur` (for recursive version) 3. **Input format**: - `a`: Integer denoting the base. - `n`: Integer denoting the exponent (n ≥ 0). - `mod`: (Optional) Integer denoting the modulus. If `mod` is provided, compute the result modulo `mod`. 4. **Output format**: - Return the computed value of (a^n mod mod) if `mod` is provided, else return (a^n). Example: ```python assert power_iter(2, 10) == 1024 # 2^10 = 1024 assert power_iter(2, 10, 1000) == 24 # 2^10 % 1000 = 24 assert power_recur(2, 10) == 1024 # 2^10 = 1024 assert power_recur(2, 10, 1000) == 24 # 2^10 % 1000 = 24 ``` Constraints: 1. 0 ≤ n ≤ 10^9 2. 1 ≤ a ≤ 10^9 3. 2 ≤ mod ≤ 10^9 (if provided) Implement the functions considering the constraints and edge cases mentioned in the provided analysis.","solution":"def power_iter(a, n, mod=None): Iterative function to compute a^n % mod if mod is given, otherwise a^n. result = 1 base = a % mod if mod else a while n > 0: if n % 2 == 1: result = (result * base) % mod if mod else (result * base) base = (base * base) % mod if mod else (base * base) n //= 2 return result def power_recur(a, n, mod=None): Recursive function to compute a^n % mod if mod is given, otherwise a^n. if n == 0: return 1 half = power_recur(a, n // 2, mod) half = (half * half) % mod if mod else (half * half) if n % 2 == 0: return half else: return (half * a) % mod if mod else (half * a)"},{"question":"**Scenario**: Imagine that you are tasked with processing a large dataset represented as a singly linked list. The requirement is to ensure that this list contains no duplicate elements. The list may contain multiple identical elements initially. **Objective**: Write a function that removes all duplicate values from a given singly linked list such that each element appears only once. **Function Signature**: ```python class Node(): def __init__(self, val=None): self.val = val self.next = None def remove_duplicates(head: Node) -> Node: pass ``` # Input & Output **Input**: - A singly linked list where each node contains an integer value. **Output**: - The head of the modified singly linked list with duplicates removed. # Constraints 1. The function should be efficient in terms of both time and space: - A solution with O(N) time complexity and O(N) space complexity using additional data structures is acceptable but not optimal. - An O(N^2) solution without using additional data structures is acceptable. 2. The function signature, `remove_duplicates`, should not be altered. 3. The input list can be empty. # Example ```python # Helper function to build a linked list from a list of values def build_linked_list(values): if not values: return None head = Node(values[0]) current = head for value in values[1:]: current.next = Node(value) current = current.next return head # Helper function to convert a linked list to a list of values def linked_list_to_list(head): values = [] while head: values.append(head.val) head = head.next return values # Example head = build_linked_list([1, 2, 3, 2, 4, 3, 5, 5, 6]) head = remove_duplicates(head) print(linked_list_to_list(head)) # Output: [1, 2, 3, 4, 5, 6] ``` # Considerations - Consider edge cases such as an empty list, a list with all unique elements, and a list where all elements are the same. - Be mindful of in-place modifications and ensure the integrity of the linked list is maintained. You are allowed to implement either of the approaches (with or without using a set). Document your choice and the time and space complexity of your implemented solution.","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def remove_duplicates(head: Node) -> Node: Function to remove duplicates from a singly linked list. if not head: return None current = head seen_values = set() seen_values.add(current.val) while current and current.next: if current.next.val in seen_values: current.next = current.next.next else: seen_values.add(current.next.val) current = current.next return head # Helper function to build a linked list from a list of values def build_linked_list(values): if not values: return None head = Node(values[0]) current = head for value in values[1:]: current.next = Node(value) current = current.next return head # Helper function to convert a linked list to a list of values def linked_list_to_list(head): values = [] while head: values.append(head.val) head = head.next return values # Example Usage # head = build_linked_list([1, 2, 3, 2, 4, 3, 5, 5, 6]) # head = remove_duplicates(head) # print(linked_list_to_list(head)) # Output: [1, 2, 3, 4, 5, 6]"},{"question":"Context: Your company is developing a feature that requires converting numerical values between different base representations. To assess your understanding of numerical base conversion, you\'re tasked with implementing two functions that handle conversions between integer values and their base representations up to base 36. Task: Implement two functions: `int_to_base` and `base_to_int`. 1. **Function**: `int_to_base(num, base)` * **Input**: * `num` (int): The integer to convert. It could be negative. * `base` (int): The base to convert to, ranging from 2 to 36. * **Output**: * (str): The base representation of the integer as a string. * **Constraints**: * Do not use built-in functions like `bin()`, `oct()`, `hex()`, or `int()` for encoding. * Supports negative numbers. * **Example**: ```python int_to_base(5, 2) # Output: \'101\' int_to_base(-15, 16) # Output: \'-F\' ``` 2. **Function**: `base_to_int(str_to_convert, base)` * **Input**: * `str_to_convert` (str): The string representation of a number in the given base. * `base` (int): The base of the provided string, ranging from 2 to 36. * **Output**: * (int): The integer representation of the base string. * **Constraints**: * Negative numbers should be handled correctly. * Do not use built-in functions like `int()` for decoding. * **Example**: ```python base_to_int(\'101\', 2) # Output: 5 base_to_int(\'-F\', 16) # Output: -15 ``` **Note:** Include edge cases like zero, smallest and largest possible values for given bases, and invalid inputs with appropriate handling of exceptions or errors.","solution":"def int_to_base(num, base): Converts an integer to a string representation in the specified base. if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36\\") if num == 0: return \'0\' digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" negative = num < 0 num = abs(num) res = [] while num > 0: res.append(digits[num % base]) num //= base if negative: res.append(\'-\') return \'\'.join(res[::-1]) def base_to_int(str_to_convert, base): Converts a string representation of a number in the specified base to an integer. if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36\\") digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" str_to_convert = str_to_convert.upper() negative = str_to_convert[0] == \'-\' if negative: str_to_convert = str_to_convert[1:] num = 0 power = 1 for char in str_to_convert[::-1]: if char not in digits[:base]: raise ValueError(f\\"Invalid character {char} for base {base}\\") num += digits.index(char) * power power *= base return -num if negative else num"},{"question":"# Scenario You have been hired by a large e-commerce company to optimize their search functionality on their product catalog. The search operation must be efficiently performed, as product queries are executed millions of times a day. Your task is to determine the first occurrence of a given product ID in a sorted list of product IDs. # Task Write a Python function `first_occurrence` to find the index of the first occurrence of a given product ID (query) in a sorted list of product IDs (array). # Function Signature ```python def first_occurrence(array: List[int], query: int) -> int: ``` # Input * `array`: A list of integers sorted in increasing order representing product IDs. (1 ≤ len(array) ≤ 10^6) * `query`: An integer representing the product ID you are searching for. (0 ≤ query ≤ 10^9) # Output * Return the index of the first occurrence of the query element in the given sorted list. * If the query element is not present in the list, return -1. # Constraints * The function should have O(log n) time complexity due to the large size of the input. * You must handle edge cases appropriately, such as when the query is not found in the list or when the list is empty. # Examples ```python assert first_occurrence([1, 2, 2, 3, 4, 5], 2) == 1 assert first_occurrence([1, 2, 2, 3, 4, 5], 6) == -1 assert first_occurrence([], 2) == -1 assert first_occurrence([1], 1) == 0 assert first_occurrence([1, 1, 2, 3, 3, 3, 3], 3) == 3 ```","solution":"from typing import List def first_occurrence(array: List[int], query: int) -> int: This function finds the first occurrence of the given `query` in the sorted list `array` using binary search. If the element is not found, it returns -1. left, right = 0, len(array) - 1 result = -1 while left <= right: mid = (left + right) // 2 if array[mid] == query: result = mid right = mid - 1 # Continue searching in the left half elif array[mid] < query: left = mid + 1 else: right = mid - 1 return result"},{"question":"# Wiggle Sort Challenge Objective Write a function `wiggle_sort(nums)` that takes an array of integers `nums` and reorders it in-place so that it follows the pattern: `nums[0] < nums[1] > nums[2] < nums[3]...`. Function Signature ```python def wiggle_sort(nums: List[int]) -> None: # Your code here ``` Input and Output * The function takes a single argument: * `nums`: a list of integers, where 1 <= len(nums) <= 10^4 and -10^9 <= nums[i] <= 10^9. * The function does not return anything. It should modify the list `nums` in-place. Constraints 1. The input list can be empty or contain one or two elements, in which case it is already in wiggle order. 2. The function should run in O(n) time complexity. 3. The function should use O(1) extra space. Example ```python nums = [3, 5, 2, 1, 6, 4] wiggle_sort(nums) print(nums) # Output must follow the pattern nums[0] < nums[1] > nums[2] < nums[3]... # Possible Output: [3, 5, 1, 6, 2, 4] ``` Scenario Suppose you\'re working on a visualization tool that needs to highlight data points such as stock prices or wave heights in a specific pattern for better readability. Implementing the `wiggle_sort` method ensures that the data points will alternate and create a more visually distinctive representation. Key Points to Consider * Ensure you handle edge cases such as arrays with equal numbers or minimal elements. * Focus on maintaining the in-place modification with O(n) time complexity and O(1) space complexity. * Verify that your solution functions correctly for both small and large datasets while meeting the problem constraints.","solution":"def wiggle_sort(nums): Reorders nums in-place so that it follows the pattern: nums[0] < nums[1] > nums[2] < nums[3]... for i in range(len(nums) - 1): if (i % 2 == 0 and nums[i] > nums[i + 1]) or (i % 2 == 1 and nums[i] < nums[i + 1]): nums[i], nums[i + 1] = nums[i + 1], nums[i]"},{"question":"# Question: Implement Topological Sorting on a Directed Graph You are required to implement a function that determines the topological ordering of nodes in a directed acyclic graph (DAG). Topological sorting is a linear ordering of vertices such that for every directed edge \'u -> v\', vertex \'u\' comes before \'v\' in the ordering. Topological sorting is possible only if the graph has no cycles, i.e., it is a Directed Acyclic Graph (DAG). **Function Signature**: ```python def topological_sort(graph: DirectedGraph) -> List[str]: # Your code here ``` **Input**: - `graph`: An instance of the `DirectedGraph` class. **Output**: - A list of node names representing the topologically sorted order. **Constraints**: - All node names are unique strings. - The graph guarantees to be acyclic (no cycles present). **Example**: ```python graph_data = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'D\'], \'D\': [] } graph = DirectedGraph(graph_data) print(topological_sort(graph)) # Output: [\'A\', \'B\', \'C\', \'D\'] ``` **Explanation**: In the example, \'A\' has edges to both \'B\' and \'C\'. Both \'B\' and \'C\' have edges to \'D\'. Therefore, \'A\' should come before \'B\' and \'C\', and \'D\' should come after both \'B\' and \'C\' in any topological ordering. *Hints*: 1. Use Kahn\'s Algorithm (BFS based) or DFS based approach to find topological sort. 2. Ensure proper handling of the adjacency list to build the ordering.","solution":"from typing import List, Dict class DirectedGraph: def __init__(self, adjacency_list: Dict[str, List[str]]): self.adjacency_list = adjacency_list def topological_sort(graph: DirectedGraph) -> List[str]: def dfs(node: str): visited.add(node) for neighbor in graph.adjacency_list.get(node, []): if neighbor not in visited: dfs(neighbor) output.append(node) visited = set() output = [] for node in graph.adjacency_list: if node not in visited: dfs(node) return output[::-1]"},{"question":"# Sorting Customer Transactions You are working in a financial tech company where you are asked to write a function to sort customer transactions based on the transaction timestamp recorded in an array. The transactions are initially unordered and represented by tuples, where each tuple contains the transaction amount and a timestamp. The goal is to provide a sorted list of transactions based on the timestamps, using the Gnome sort algorithm. # Function Signature ```python def sort_transactions(transactions: List[Tuple[int, str]]) -> List[Tuple[int, str]]: pass ``` # Input * A list of tuples `transactions`. Each tuple contains: - An integer representing the transaction amount (positive or negative). - A string representing the timestamp in \\"YYYY-MM-DD HH:MM:SS\\" format. # Output * A list of tuples sorted by the timestamp in ascending order. # Constraints 1. The list will have at most 10^4 transactions. 2. The timestamp format is guaranteed to be valid and consistent. 3. The transaction amounts can include both positive and negative values. # Example ```python transactions = [ (200, \\"2021-03-04 12:03:45\\"), (150, \\"2021-01-30 09:30:00\\"), (-100, \\"2021-02-15 18:23:00\\"), ] result = sort_transactions(transactions) # Expected Output: # [ # (150, \\"2021-01-30 09:30:00\\"), # (-100, \\"2021-02-15 18:23:00\\"), # (200, \\"2021-03-04 12:03:45\\"), # ] ``` # Explanation The output list is sorted based on the timestamps in ascending order. # Notes - Make sure the function uses the Gnome sort algorithm. - Parse the timestamps correctly to ensure proper comparison.","solution":"from typing import List, Tuple from datetime import datetime def sort_transactions(transactions: List[Tuple[int, str]]) -> List[Tuple[int, str]]: def gnome_sort(arr): i = 0 while i < len(arr): if i == 0 or arr[i-1][1] <= arr[i][1]: i += 1 else: arr[i], arr[i-1] = arr[i-1], arr[i] i -= 1 return arr # Convert the timestamp strings to datetime objects for proper comparison transactions = [(amount, datetime.strptime(timestamp, \\"%Y-%m-%d %H:%M:%S\\")) for (amount, timestamp) in transactions] # Sort using Gnome sort sorted_transactions = gnome_sort(transactions) # Convert the datetime objects back to their original string format sorted_transactions = [(amount, timestamp.strftime(\\"%Y-%m-%d %H:%M:%S\\")) for (amount, timestamp) in sorted_transactions] return sorted_transactions"},{"question":"# Question: Symmetric Binary Tree You are given a binary tree, where each node contains an integer value and may have left and right children. Your task is to determine if this binary tree is symmetric around its center. A binary tree is symmetric if the left subtree is a mirror reflection of the right subtree. # Function Requirements 1. Implement a function `is_tree_symmetric_recursive(root)` that uses a recursive approach. 2. Implement a function `is_tree_symmetric_iterative(root)` that uses an iterative approach. # Input Format - A binary tree node, `root`, which may be `None` (representing an empty tree). # Output Format - Return `True` if the binary tree is symmetric, otherwise return `False`. # Constraints - The number of nodes in the binary tree is between 0 and 10^4. - Tree node values are integers from -10^9 to 10^9. # Example Consider the tree: ``` 1 / 2 2 / / 3 4 4 3 ``` For this tree, the input would be represented by a `TreeNode` structure, where each node pointer connects appropriately to its children. The function should return `True`. Another example: ``` 1 / 2 2 3 3 ``` For this tree, the function should return `False`. # Bonus Point - Try to solve it both recursively and iteratively and compare their performance in terms of time and space complexity. # TreeNode Definition For the purpose of this question, assume the following TreeNode class definition: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Function Signatures ```python def is_tree_symmetric_recursive(root: TreeNode) -> bool: # Your implementation here pass def is_tree_symmetric_iterative(root: TreeNode) -> bool: # Your implementation here pass ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_tree_symmetric_recursive(root: TreeNode) -> bool: Checks if the binary tree is symmetric around its center using recursion. def is_mirror(left: TreeNode, right: TreeNode) -> bool: if not left and not right: return True if not left or not right: return False return (left.val == right.val) and is_mirror(left.left, right.right) and is_mirror(left.right, right.left) return is_mirror(root, root) def is_tree_symmetric_iterative(root: TreeNode) -> bool: Checks if the binary tree is symmetric around its center using iteration. if not root: return True queue = [(root.left, root.right)] while queue: left, right = queue.pop(0) if not left and not right: continue if not left or not right or left.val != right.val: return False queue.append((left.left, right.right)) queue.append((left.right, right.left)) return True"},{"question":"Scalable Bitonic Sort Implementation Context You are working as a software engineer tasked with optimizing the performance of a large-scale numeric dataset analysis. For this purpose, you decide to implement the Bitonic Sort algorithm due to its efficiency in parallel processing environments. Your task is to write a scalable bitonic sort function that efficiently handles large arrays and provides flexibility in terms of sorting order. Task Write a function `scalable_bitonic_sort` that sorts an array of integers using the Bitonic Sort algorithm. Ensure that your function can handle both small and large datasets, and choose the correct sorting order based on the provided argument. Function Signature ```python def scalable_bitonic_sort(arr: List[int], reverse: bool = False) -> List[int]: Sorts an array of integers using the Bitonic Sort algorithm. :param arr: List[int] - Array of integers to be sorted. :param reverse: bool - If True, sort in descending order, otherwise ascending order. :return: List[int] - Sorted array. :raises ValueError if the size of the array is not a power of two. ``` Constraints 1. The input array length _must_ be a power of two. 2. You should handle both ascending and descending orders. 3. Optimize your solution to handle edge cases such as very small arrays or arrays with duplicate elements. 4. Ensure the solution is capable of performing in parallel processing environments (provide comments or pseudocode if actual parallelization implementation is complex). Example ```python # Example 1 input: [3, 7, 4, 8, 6, 2, 1, 5], reverse = False output: [1, 2, 3, 4, 5, 6, 7, 8] # Example 2 input: [12, 4, 78, 26, 9, 32, 45, 2], reverse = True output: [78, 45, 32, 26, 12, 9, 4, 2] ``` Note - Include proper error handling to manage invalid input sizes (i.e., non-power-of-two arrays). - Provide a brief description of how your solution can be optimized for parallel processing.","solution":"from typing import List def bitonic_merge(arr: List[int], low: int, count: int, direction: bool): if count > 1: k = count // 2 for i in range(low, low + k): if (direction and arr[i] > arr[i + k]) or (not direction and arr[i] < arr[i + k]): arr[i], arr[i + k] = arr[i + k], arr[i] bitonic_merge(arr, low, k, direction) bitonic_merge(arr, low + k, k, direction) def bitonic_sort(arr: List[int], low: int, count: int, direction: bool): if count > 1: k = count // 2 bitonic_sort(arr, low, k, True) bitonic_sort(arr, low + k, k, False) bitonic_merge(arr, low, count, direction) def scalable_bitonic_sort(arr: List[int], reverse: bool = False) -> List[int]: Sorts an array of integers using the Bitonic Sort algorithm. :param arr: List[int] - Array of integers to be sorted. :param reverse: bool - If True, sort in descending order, otherwise ascending order. :return: List[int] - Sorted array. :raises ValueError if the size of the array is not a power of two. n = len(arr) if n & (n - 1) != 0: raise ValueError(\\"The size of the array must be a power of two.\\") bitonic_sort(arr, 0, n, not reverse) return arr"},{"question":"Scenario Imagine you are designing a cache to store webpage content for efficient retrieval based on URLs. You decide to use a hash table to store the key-value pairs where the URLs are the keys and the webpage content is the value. However, to maintain high performance and prevent excessive collisions, you need to implement dynamic resizing of the hash table when the load factor threshold is breached. The objective is to keep the load factor (number of entries divided by the number of buckets) below 0.75. Task Write a Python class `ResizableHashTable` that extends the given `SeparateChainingHashTable` to include dynamic resizing functionality. **Dynamic Resizing Details**: * When the load factor exceeds 0.75, the hash table should resize to twice its current size. * Rehash all existing entries into the new table. Function Signature ```python class ResizableHashTable(SeparateChainingHashTable): def __init__(self, size=11): super().__init__(size) def put(self, key, value): # Call the base class put method pass # Implement resizing logic def resize(self): # Implement resizing and rehashing logic pass ``` Expected Behavior * When inserting a key-value pair, the function should check the load factor. * If the load factor exceeds 0.75, resize the hash table and rehash all entries. * The process should be efficient to ensure minimal performance impact. Constraints * Assume keys are strings, and values are any type of content (e.g., webpage data). * Initial table size should default to 11. Example Usage ```python cache = ResizableHashTable() # Inserting values cache.put(\'url1\', \'content1\') cache.put(\'url2\', \'content2\') cache.put(\'url3\', \'content3\') # Accessing values content = cache.get(\'url2\') # Returns \'content2\' # Force resize by adding more elements for i in range(100): cache.put(f\'url{i}\', f\'content{i}\') ```","solution":"class SeparateChainingHashTable: def __init__(self, size=11): self.size = size self.table = [[] for _ in range(size)] self.count = 0 def _hash(self, key): return hash(key) % self.size def put(self, key, value): h = self._hash(key) bucket = self.table[h] for i, (k, v) in enumerate(bucket): if k == key: bucket[i] = (key, value) return bucket.append((key, value)) self.count += 1 def get(self, key): h = self._hash(key) bucket = self.table[h] for k, v in bucket: if k == key: return v return None class ResizableHashTable(SeparateChainingHashTable): def __init__(self, size=11): super().__init__(size) def put(self, key, value): super().put(key, value) if self._load_factor() > 0.75: self.resize() def resize(self): old_table = self.table new_size = self.size * 2 self.table = [[] for _ in range(new_size)] self.size = new_size self.count = 0 for bucket in old_table: for key, value in bucket: self.put(key, value) def _load_factor(self): return self.count / self.size"},{"question":"# Problem You are given an implementation of a Red-Black Tree, which is a type of self-balancing binary search tree. The goal of this problem is to implement additional functionalities to enhance the given `RBTree` class. # Task Implement the following methods in the `RBTree` class: 1. **search(self, key)**: - **Input**: `key` (integer) - the value to search in the Red-Black Tree. - **Output**: Return the `RBNode` containing the key, or `None` if the key does not exist. 2. **find_successor(self, node)**: - **Input**: `node` (RBNode) - the node for which the successor needs to be found. - **Output**: Return the in-order successor of the given node in the Red-Black Tree. 3. **find_predecessor(self, node)**: - **Input**: `node` (RBNode) - the node for which the predecessor needs to be found. - **Output**: Return the in-order predecessor of the given node in the Red-Black Tree. # Constraints - All keys used in the tree operations are unique. - The tree implements standard Red-Black Tree properties and operations correctly. # Example Assume the tree is built with the following nodes: [11, 2, 14, 1, 7, 15, 5, 8, 4] ```python rb = RBTree() nodes = [11, 2, 14, 1, 7, 15, 5, 8, 4] for n in nodes: rb.insert(RBNode(n, 1)) # Example usage of search node_7 = rb.search(7) assert node_7.val == 7 # Example usage of find_successor successor_node = rb.find_successor(node_7) assert successor_node.val == 8 # Example usage of find_predecessor predecessor_node = rb.find_predecessor(node_7) assert predecessor_node.val == 5 ``` Please submit your implementation of the three methods as part of the `RBTree` class.","solution":"class RBNode: def __init__(self, val, color, left=None, right=None, parent=None): self.val = val self.color = color # 1 for Red, 0 for Black self.left = left self.right = right self.parent = parent class RBTree: def __init__(self): self.NIL_LEAF = RBNode(val=None, color=0) self.root = self.NIL_LEAF def search(self, key): current_node = self.root while current_node != self.NIL_LEAF and current_node.val != key: if key < current_node.val: current_node = current_node.left else: current_node = current_node.right return current_node if current_node != self.NIL_LEAF else None def find_successor(self, node): if node.right != self.NIL_LEAF: return self.find_minimum(node.right) parent_node = node.parent while parent_node != self.NIL_LEAF and node == parent_node.right: node = parent_node parent_node = parent_node.parent return parent_node def find_predecessor(self, node): if node.left != self.NIL_LEAF: return self.find_maximum(node.left) parent_node = node.parent while parent_node != self.NIL_LEAF and node == parent_node.left: node = parent_node parent_node = parent_node.parent return parent_node def find_minimum(self, node): while node.left != self.NIL_LEAF: node = node.left return node def find_maximum(self, node): while node.right != self.NIL_LEAF: node = node.right return node # Assume that the insert logic is already correctly implemented def insert(self, node): # Simplified insertion logic for testing purposes node.left = self.NIL_LEAF node.right = self.NIL_LEAF node.color = 1 # New nodes are Red if self.root == self.NIL_LEAF: self.root = node self.root.color = 0 # Root is always Black self.root.parent = self.NIL_LEAF return current = self.root while True: if node.val < current.val: if current.left == self.NIL_LEAF: current.left = node break current = current.left else: if current.right == self.NIL_LEAF: current.right = node break current = current.right node.parent = current # Fixup logic would go here, but is omitted for simplicity"},{"question":"# Task You are given an unsorted array of integers `array` and an integer `query`. The task is to find the index of the first occurrence of `query` in `array` using linear search. If the element is not present, return -1. # Function Signature ```python def linear_search(array: List[int], query: int) -> int: ``` # Input * `array` (List[int]): A list of integers which can be unsorted. * `query` (int): An integer to search for in the array. # Output * Returns the index of the first occurrence of `query` in `array`. If `query` is not found, returns -1. # Constraints * (0 leq text{len(array)} leq 10^6) * ( -10^9 leq text{array[i]}, query leq 10^9 ) # Performance Requirements * The solution should handle cases efficiently for (len(array) leq 10^6). # Example ```python print(linear_search([2, 3, 4, 10, 40], 10)) # Output: 3 print(linear_search([2, 3, 4, 10, 40], 5)) # Output: -1 ```","solution":"from typing import List def linear_search(array: List[int], query: int) -> int: Perform a linear search to find the first occurrence of the query in the array. Args: array (List[int]): The input list of integers. query (int): The integer value to find in the array. Returns: int: The index of the first occurrence of query in array, or -1 if not found. for index, value in enumerate(array): if value == query: return index return -1"},{"question":"# Question Scenario You\'re a software engineer for a geolocation service that needs to efficiently find the nearest landmark from a large dataset of geographical points represented by their coordinate values (latitude and longitude). Given a sorted list of latitude coordinates of landmarks, implement a function to find the index of a specific latitude coordinate using the Interpolation Search algorithm. Assume the latitude coordinates are uniformly distributed. Task Write a function `find_landmark_index` using the interpolation search algorithm that takes a sorted list of latitude coordinates and a target latitude. The function should return the index of the target latitude if it\'s present in the list; otherwise, it should return -1. Function Signature ```python def find_landmark_index(latitudes: List[float], target_latitude: float) -> int: pass ``` # Input - `latitudes` (List[float]): A sorted list of latitude coordinates in increasing order. - `target_latitude` (float): The latitude coordinate to find in the list. # Output - `int`: The index of the latitude coordinate if found, otherwise -1. # Constraints - The length of `latitudes` does not exceed (10^6). - Latitude values will follow standard geographical bounds (-90.0 to 90.0). # Example ```python latitudes = [-70.66, -45.0, 12.34, 27.45, 45.12, 70.0] target_latitude = 27.45 assert(find_landmark_index(latitudes, target_latitude) == 3) latitudes = [-90.0, -82.1, 0.0, 34.56, 80.0, 90.0] target_latitude = 50.0 assert(find_landmark_index(latitudes, target_latitude) == -1) ``` (Prompt students on handling edge cases such as empty lists and ensure they avoid potential pitfalls like division by zero.)","solution":"from typing import List def find_landmark_index(latitudes: List[float], target_latitude: float) -> int: Uses the interpolation search algorithm to find the target latitude in a sorted list of latitudes. Parameters: latitudes (List[float]): A sorted list of latitude coordinates in increasing order. target_latitude (float): The latitude coordinate to find in the list. Returns: int: The index of the latitude coordinate if found, otherwise -1. if not latitudes: return -1 low = 0 high = len(latitudes) - 1 while low <= high and target_latitude >= latitudes[low] and target_latitude <= latitudes[high]: if low == high: if latitudes[low] == target_latitude: return low return -1 # Interpolation formula pos = low + int(((float(high - low) / (latitudes[high] - latitudes[low])) * (target_latitude - latitudes[low]))) if latitudes[pos] == target_latitude: return pos if latitudes[pos] < target_latitude: low = pos + 1 else: high = pos - 1 return -1"},{"question":"Enhanced Binary Search Scenario: Your employer wants to develop software for a library that will allow staff to quickly find books based on their call numbers. You are tasked with implementing a more robust and optimized version of the binary search algorithm that efficiently finds a book\'s index in a sorted list of call numbers. Additionally, you must handle scenarios such as non-existent call numbers and empty lists gracefully. Function Signature: ```python def enhanced_binary_search(call_numbers: List[int], target: int) -> int: ``` Input: - `call_numbers`: A list of integers representing sorted call numbers where each call number is unique. - `target`: An integer representing the call number to be searched. Output: - Returns an integer representing the index of the `target` call number in the `call_numbers` list. If the target is not found, return `-1`. Constraints: - The call numbers list can have between 0 and 10^6 elements. - Each call number is a non-negative integer. Requirements: - The algorithm should have a time complexity of O(log(n)) and space complexity of O(1). - Must handle edge cases such as an empty list or target not being present. - Efficiently manage bounds and prevent overflows. # Example: ```python # Example 1: input_call_numbers = [123, 234, 345, 456, 567] target_call_number = 345 assert enhanced_binary_search(input_call_numbers, target_call_number) == 2 # Example 2: input_call_numbers = [123, 234, 345, 456, 567] target_call_number = 678 assert enhanced_binary_search(input_call_numbers, target_call_number) == -1 # Example 3: input_call_numbers = [] target_call_number = 123 assert enhanced_binary_search(input_call_numbers, target_call_number) == -1 ``` **Note**: Ensure your solution handles all edge cases and operates within the mentioned complexity constraints.","solution":"def enhanced_binary_search(call_numbers, target): Performs binary search to find the index of the target in the call_numbers list. :param call_numbers: List[int] - A list of sorted unique integers (call numbers) :param target: int - The target call number to search for :return: int - The index of the target in the list, or -1 if not found left, right = 0, len(call_numbers) - 1 while left <= right: mid = (left + right) // 2 if call_numbers[mid] == target: return mid elif call_numbers[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Segment Tree Implementation and Query Optimization Context A company needs an optimized way to handle range queries over their sales data across different product categories. You are required to help them by implementing a Segment Tree to efficiently store and query their data. Task Implement the Segment Tree class to support efficient range queries. The Segment Tree should be able to handle queries to find the sum, minimum, or maximum of elements in a specified range. Specifications 1. **Class Design**: * Implement a class `SegmentTree`. * Constructor: ```python def __init__(self, arr: List[int], function: Callable[[int, int], int]) ``` * `arr` is a list of integers. * `function` is the function to apply over segments (e.g., `sum`, `min`, or `max`). * Method to perform range queries: ```python def query(self, L: int, R: int) -> int ``` * `L` and `R` are the starting and ending indices (inclusive) of the range query. 2. **Example Usage**: ```python # To create a segment tree for maximum queries max_tree = SegmentTree([2, 4, 5, 3, 4], max) print(max_tree.query(2, 4)) # Should output the maximum value in the range 2 to 4 # Segment tree for sum queries sum_tree = SegmentTree([4, 5, 2, 3, 4, 43, 3], sum) print(sum_tree.query(1, 5)) # Should output the sum of values in the range 1 to 5 ``` 3. **Constraints**: * The length of array `arr` will be between 1 and 10^5. * The values in array `arr` will be between -10^9 and 10^9. * The function provided will be associative (like `sum`, `min`, and `max`). 4. **Performance**: * Your implementation should handle range queries efficiently and must respect the time complexity of O(log N). Notes: * You must include error handling for invalid query ranges. * Ensure that all edge cases (e.g., empty arrays, single element arrays) are considered.","solution":"from typing import List, Callable class SegmentTree: def __init__(self, arr: List[int], function: Callable[[int, int], int]): self.n = len(arr) self.function = function self.tree = [0] * (2 * self.n) # Build the tree self._build(arr) def _build(self, arr: List[int]): # Initialize leaves with array elements for i in range(self.n): self.tree[self.n + i] = arr[i] # Compute internal node values for i in range(self.n - 1, 0, -1): self.tree[i] = self.function(self.tree[i * 2], self.tree[i * 2 + 1]) def query(self, L: int, R: int) -> int: if L < 0 or R >= self.n or L > R: raise ValueError(\\"Invalid query range\\") # Convert to 0-based indexing L += self.n R += self.n result = None while L <= R: if L % 2 == 1: result = self.tree[L] if result is None else self.function(result, self.tree[L]) L += 1 if R % 2 == 0: result = self.tree[R] if result is None else self.function(result, self.tree[R]) R -= 1 L //= 2 R //= 2 return result"},{"question":"# Question: Implement Topological Sorting for a Directed Graph Context A directed graph is widely used to represent tasks and their dependencies. Topological sorting of the nodes in such a graph helps to linearize tasks in an order consistent with their dependencies, which is critical for scheduling and sequencing problems such as task management and course prerequisite resolution. Task Given the above implementation of a DirectedGraph, your objective is to implement a function `topological_sort` that returns the nodes of the graph in topologically sorted order. A topologically sorted order is where for every directed edge (U -> V), U appears before V in the list. Function Signature ```python def topological_sort(graph: DirectedGraph) -> List[str]: pass ``` Input and Output * **Input**: - `graph`: An instance of `DirectedGraph`. * **Output**: - A list of node names in topologically sorted order. Constraints * The graph is assumed to be a Directed Acyclic Graph (DAG). * If there are multiple valid topological sorts, return any one of them. Example ```python # Example graph construction load_dict = { \\"A\\": [\\"B\\", \\"C\\"], \\"B\\": [\\"D\\"], \\"C\\": [\\"D\\"], \\"D\\": [\\"E\\"], \\"E\\": [] } graph = DirectedGraph(load_dict) print(topological_sort(graph)) # One valid output could be: [\'A\', \'B\', \'C\', \'D\', \'E\'] ``` Requirements * Ensure your solution handles nodes without predecessors effectively. * Your solution should run efficiently with a time complexity of O(V + E) and appropriate space complexity.","solution":"from typing import List, Dict from collections import defaultdict, deque class DirectedGraph: def __init__(self, adj_list: Dict[str, List[str]]): self.adj_list = adj_list def get_nodes(self): return list(self.adj_list.keys()) def get_neighbors(self, node: str): return self.adj_list[node] def topological_sort(graph: DirectedGraph) -> List[str]: # Compute in-degrees of all nodes in_degrees = {node: 0 for node in graph.get_nodes()} for node in graph.get_nodes(): for neighbor in graph.get_neighbors(node): in_degrees[neighbor] += 1 # Initialize a queue with nodes with 0 in-degree queue = deque([node for node in graph.get_nodes() if in_degrees[node] == 0]) sort_order = [] while queue: node = queue.popleft() sort_order.append(node) for neighbor in graph.get_neighbors(node): in_degrees[neighbor] -= 1 if in_degrees[neighbor] == 0: queue.append(neighbor) if len(sort_order) == len(graph.get_nodes()): return sort_order else: # This shouldn\'t happen in a DAG but adding safety check raise Exception(\\"Graph is not acyclic\\")"},{"question":"# Programming Task: Reverse String using Different Methods Objective Implement the reversal of a string using different approaches specified below. Ensure to handle edge cases and optimize for performance. Instructions Write a function `reverse_string(s, method)` that takes a string `s` and a `method` keyword and returns the reversed string using the specified method. The `method` keyword can be either `\'recursive\'`, `\'iterative\'`, `\'pythonic\'`, or `\'ultra_pythonic\'`. Signature ```python def reverse_string(s: str, method: str) -> str: pass ``` Input * `s` (str): The input string to be reversed. It can be empty, or contain any sequence of characters. * `method` (str): A keyword specifying which method to use for reversing the string. Valid values are `\'recursive\'`, `\'iterative\'`, `\'pythonic\'`, and `\'ultra_pythonic\'`. Output * (str): The reversed string. # Method Descriptions - `\'recursive\'`: Use the recursive approach to reverse the string. - `\'iterative\'`: Use the iterative approach with swapping elements. - `\'pythonic\'`: Use Python\'s built-in reversed function. - `\'ultra_pythonic\'`: Use Python slicing. # Constraints * The resulting function should handle input strings up to 10^4 characters efficiently. * No method should modify the original string. # Examples ```python assert reverse_string(\'hello\', \'recursive\') == \'olleh\' assert reverse_string(\'world\', \'iterative\') == \'dlrow\' assert reverse_string(\'abc\', \'pythonic\') == \'cba\' assert reverse_string(\'python\', \'ultra_pythonic\') == \'nohtyp\' assert reverse_string(\'a\', \'ultra_pythonic\') == \'a\' assert reverse_string(\'\', \'iterative\') == \'\' ``` Requirements - Implement all four methods inside `reverse_string` and handle the different cases based on the `method` input. - Input validation to ensure `method` parameter is one of the specified methods.","solution":"def reverse_string(s: str, method: str) -> str: Reverses the given string using the specified method. def recursive_reverse(s): if len(s) == 0: return s else: return s[-1] + recursive_reverse(s[:-1]) def iterative_reverse(s): result = [] for char in s: result.insert(0, char) return \'\'.join(result) def pythonic_reverse(s): return \'\'.join(reversed(s)) def ultra_pythonic_reverse(s): return s[::-1] if method == \'recursive\': return recursive_reverse(s) elif method == \'iterative\': return iterative_reverse(s) elif method == \'pythonic\': return pythonic_reverse(s) elif method == \'ultra_pythonic\': return ultra_pythonic_reverse(s) else: raise ValueError(\\"Invalid method. Choose from \'recursive\', \'iterative\', \'pythonic\', \'ultra_pythonic\'.\\")"},{"question":"You are given a string `s` containing just the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\', and potentially some alphanumeric characters as well. Your task is to determine if the input string has valid brackets. A bracket string is considered valid if: 1. Opening brackets are closed by the same type of brackets. 2. Opening brackets are closed in the correct order. For the sake of this question, alphanumeric characters should be ignored. # Function Signature: ```python def is_valid_enhanced(s: str) -> bool: ``` # Input: - A single string `s` containing the characters \'(\', \')\', \'{\', \'}\', \'[\', \']\', and potentially alphanumeric characters. (`1 <= len(s) <= 10^4`). # Output: - Return a boolean `True` if the string contains valid brackets, else return `False`. # Constraints: - Assume `s` consists of printable ASCII characters. # Example: ```python assert is_valid_enhanced(\\"a[bc]d{}e()\\") == True assert is_valid_enhanced(\\"({a(b}c)d])ef\\") == False assert is_valid_enhanced(\\"[{()}]\\") == True assert is_valid_enhanced(\\"{a[b(c)d]e}f(\\") == False assert is_valid_enhanced(\\"\\") == True ``` # Requirements: - The solution should be efficient with a time complexity of O(n) and a space complexity of O(n) where n is the length of the string `s`. - Implement any necessary error handling for invalid input scenarios within the given constraints. - Do not use any additional data structures unnecessarily, and ensure the solution is optimal and concise.","solution":"def is_valid_enhanced(s: str) -> bool: Determines if the input string s has valid brackets. Alphanumeric characters are ignored. stack = [] bracket_map = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in s: if char in bracket_map.values(): stack.append(char) elif char in bracket_map.keys(): if stack == [] or bracket_map[char] != stack.pop(): return False return stack == []"},{"question":"Sparse Matrix Multiplication You have been provided two sparse matrices represented in 2D lists. Your task is to write a Python function that multiplies the two matrices and returns the resulting matrix. You must ensure your implementation efficiently handles the sparsity of the matrices. Function Signature: ```python def sparse_matrix_multiply(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: pass ``` Input: * `A`: A 2D list representing the first sparse matrix (dimensions m x n). * `B`: A 2D list representing the second sparse matrix (dimensions n x p). Output: * A 2D list representing the resulting matrix after multiplication (dimensions m x p). Constraints: * Matrix `A` and Matrix `B` will only contain integers. * The number of columns in `A` must be equal to the number of rows in `B`. * The dimensions of the resulting matrix will be `m x p`. Example: ```python A = [ [1, 0, 0], [-1, 0, 3] ] B = [ [7, 0, 0], [0, 0, 0], [0, 0, 1] ] sparse_matrix_multiply(A, B) # Output: [[7, 0, 0], [-7, 0, 3]] ``` Performance Requirements: * Ensure your solution is optimized for handling sparse matrices. * Avoid unnecessary computations involving zero values. Additional Context: Sparse matrices are matrices in which most of the elements are zero, and storing and processing such matrices efficiently can significantly reduce both time and space complexity in many applications, including scientific computing and graph algorithms.","solution":"from typing import List def sparse_matrix_multiply(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: m, n = len(A), len(A[0]) n_b, p = len(B), len(B[0]) if n != n_b: raise ValueError(\\"Number of columns in A must equal number of rows in B.\\") # Initialize the result matrix with zeros result = [[0] * p for _ in range(m)] # Convert B to a dictionary for quicker access dict_B = {} for k in range(n): for j in range(p): if B[k][j] != 0: if k not in dict_B: dict_B[k] = {} dict_B[k][j] = B[k][j] # Sparse matrix multiplication for i in range(m): for k in range(n): if A[i][k] != 0: if k in dict_B: for j in dict_B[k]: result[i][j] += A[i][k] * dict_B[k][j] return result"},{"question":"# Array Rotation - Advanced Implementation Background Rotating an array is a common problem with various applications in real-world scenarios such as gaming, scheduling, and dealing with circular data structures. Given a method to rotate elements in an array efficiently, it can significantly optimize these operations. Task Implement a function `rotate_array` that rotates an array to the right by k steps efficiently using in-place operations. # Requirements: - The function should modify the array in-place and return nothing. - It should handle arrays of any length n, including edge cases where n is zero. - The function should be efficient with a time complexity of O(n) and space complexity of O(1). # Function Signature ```python def rotate_array(array: List[int], k: int) -> None: pass ``` Example ```python # Example 1 array = [1, 2, 3, 4, 5, 6, 7] rotate_array(array, 3) print(array) # Output: [5, 6, 7, 1, 2, 3, 4] # Example 2 array = [1, 2] rotate_array(array, 3) print(array) # Output: [2, 1] ``` # Constraints: - Array length (n) is a non-negative integer. - The value of k is a non-negative integer. # Notes 1. You can leverage the in-place reversal technique discussed in the analysis. 2. Ensure your solution handles edge cases effectively, such as k being greater than the length of the array or array being empty.","solution":"from typing import List def rotate_array(array: List[int], k: int) -> None: Rotates the array to the right by k steps in-place. n = len(array) if n == 0: return k = k % n # If k is greater than n, reduce it to within the array range. def reverse(arr, start, end): while start < end: arr[start], arr[end] = arr[end], arr[start] start += 1 end -= 1 # Step 1: Reverse the entire array reverse(array, 0, n - 1) # Step 2: Reverse the first k elements reverse(array, 0, k - 1) # Step 3: Reverse the elements from k to the end reverse(array, k, n - 1)"},{"question":"**Pattern Recognition using Finite Automaton** # Background You are given a deterministic finite automaton (DFA) that recognizes certain patterns in strings. The DFA operates using a series of state transitions based on characters of the input string. Your task is to write a function that processes an input string and determines if this string is accepted by the DFA. # Problem Statement Write a function `is_accepted(transitions, start, final, string)` that returns `True` if the DFA accepts the string and `False` otherwise. # Input - `transitions`: A dictionary where each key is a state and each value is another dictionary. The inner dictionary keys are characters and the values are the target states. - `start`: An integer representing the start state. - `final`: A list of integers representing the final accepting states. - `string`: A string consisting of characters to be processed by the DFA. # Output - `True` if the string is accepted by the DFA. - `False` if the string is not accepted by the DFA. # Constraints - The transition table may contain any ASCII characters. - There may be multiple final states. - The length of the string is at most 10^4. # Example ```python transitions = { 0: {\'a\': 1, \'b\': 2}, 1: {\'a\': 1, \'b\': 3}, 2: {\'a\': 3, \'b\': 2}, 3: {\'a\': 3, \'b\': 3} } start = 0 final = [3] string = \\"ab\\" # is_accepted(transitions, start, final, string) should return True string = \\"aa\\" # is_accepted(transitions, start, final, string) should return False ``` # Implementation Implement the `is_accepted` function following the provided specifications.","solution":"def is_accepted(transitions, start, final, string): Determines if the DFA accepts the input string. :param transitions: A dictionary representing state transitions. :param start: An integer representing the start state. :param final: A list of integers representing final accepting states. :param string: The input string to process. :return: True if the string is accepted by the DFA, False otherwise. current_state = start for char in string: if char in transitions[current_state]: current_state = transitions[current_state][char] else: return False return current_state in final"},{"question":"# Problem Description: You are tasked to implement a modified Run-Length Encoding and Decoding mechanism that also supports nested compression sequences. This means that an already compressed sequence can be further compressed if it has repetitive patterns. Your job is to ensure efficient encoding and decoding using Run-Length Encoding, even if the input contains nested compression sequences. # Requirements: * Implement two functions, `encode_rle_advanced` and `decode_rle_advanced`, that handle nested sequences. * Ensure the functions are robust against edge cases and handle nested patterns correctly. # Function Signatures: ```python def encode_rle_advanced(input: str) -> str: pass def decode_rle_advanced(input: str) -> str: pass ``` # Input/Output Formats: * `encode_rle_advanced`: - **Input**: A string `input` consisting of uppercase/lowercase alphabets. - **Output**: A string representing the nested Run-Length Encoded form of the input. * `decode_rle_advanced`: - **Input**: A string `input` representing a nested Run-Length Encoded string. - **Output**: A string representing the fully decoded original string. # Constraints: * The input string length will be at most 10^4. * Ensure your solution efficiently handles nested compressions and decompressions of reasonable depth. # Performance Considerations: * Ensure the encoding and decoding functions handle the worst-case scenarios in linear time relative to the length of the input. * Optimize space usage by avoiding unnecessary data duplications. # Example: Given the following input/output transformations: ```python assert encode_rle_advanced(\\"aaabbbbccccc\\") == \\"3a4b5c\\" assert decode_rle_advanced(\\"3a4b5c\\") == \\"aaabbbbccccc\\" # Nested example assert encode_rle_advanced(\\"aaaabcccaaaccc\\") == \\"4a1b3c3a3c\\" assert decode_rle_advanced(\\"4a1b3c3a3c\\") == \\"aaaabcccaaaccc\\" ```","solution":"def encode_rle_advanced(input: str) -> str: Returns the nested Run-Length Encoded form of the input string. if not input: return \\"\\" # First-level RLE encoding encoded = \\"\\" prev_char = input[0] count = 1 for char in input[1:]: if char == prev_char: count += 1 else: encoded += f\\"{count}{prev_char}\\" prev_char = char count = 1 encoded += f\\"{count}{prev_char}\\" # Add the last run return encoded def decode_rle_advanced(input: str) -> str: Returns the fully decoded original string from its nested RLE representation. decoded = \\"\\" count = \\"\\" for char in input: if char.isdigit(): count += char else: decoded += char * int(count) count = \\"\\" return decoded"},{"question":"# Binary Tree Comparison Challenge Objective Create a function to determine if two given binary trees are identical, both in structure and node values. Scenario Imagine you have two filesystems represented as binary trees. You need to verify if these two filesystems are identical to ensure data consistency after migration between servers. The filesystem nodes contain information about file contents, and the structure of the binary tree represents the hierarchical directory structure. Function Specification Implement the function `is_same_tree(tree_p, tree_q)` that checks if binary trees `tree_p` and `tree_q` are equal. Input - `tree_p`: Root node of the first binary tree (an instance of TreeNode or `None`). - `tree_q`: Root node of the second binary tree (an instance of TreeNode or `None`). Output - Return `True` if both trees are identical in structure and values. - Return `False` otherwise. Constraints - Tree nodes contain integer values and can hold any integer value. - The number of nodes in both trees can be up to 10^4. Example ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example usage: tree_p = TreeNode(1, TreeNode(2), TreeNode(3)) tree_q = TreeNode(1, TreeNode(2), TreeNode(3)) assert is_same_tree(tree_p, tree_q) == True tree_p = TreeNode(1, TreeNode(2)) tree_q = TreeNode(1, right=TreeNode(2)) assert is_same_tree(tree_p, tree_q) == False ``` Performance Requirement - The implementation should be efficient enough to handle up to 10^4 nodes and depths of up to tree height.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_same_tree(tree_p, tree_q): Determines if two binary trees are identical in structure and node values. Args: tree_p (TreeNode): Root node of the first binary tree. tree_q (TreeNode): Root node of the second binary tree. Returns: bool: True if both trees are identical, False otherwise. # Base cases if not tree_p and not tree_q: return True if not tree_p or not tree_q: return False if tree_p.val != tree_q.val: return False # Recursive cases return is_same_tree(tree_p.left, tree_q.left) and is_same_tree(tree_p.right, tree_q.right)"},{"question":"# Deepest Left Node Finder A company uses a binary tree where each node represents a department. For effective communication, they need to identify the deepest department that is directly managed by its parent as a left child. Your task is to implement a function that finds this deepest left child node in the given binary tree. Function Signature ```python def find_deepest_left_node(root: TreeNode) -> Optional[int]: ``` Input - `root` : A `TreeNode` which is the root of the binary tree. - The `TreeNode` class is defined as follows: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None ``` Output - An `int` which is the value of the deepest left child, or `None` if there is no such node. Constraints - The number of nodes in the tree will be in the range `[0, 10^4]`. - The values of the nodes are unique integers within an acceptable range. Example - Given binary tree: ``` 1 / 2 3 / 4 5 6 7 ``` The deepest left child is `4`. Note - You may assume the `TreeNode` class and helper classes have been properly defined as per standard binary tree nodes. Performance Requirements - Aim for time complexity of `O(N)` and space complexity of `O(H)`, where `N` is the number of nodes and `H` is the height of the tree.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def find_deepest_left_node(root: TreeNode) -> int: if root is None: return None max_depth = -1 deepest_left_val = None def dfs(node, is_left, depth): nonlocal max_depth, deepest_left_val if node is None: return if is_left and depth > max_depth: max_depth = depth deepest_left_val = node.val # Traverse left and right children dfs(node.left, True, depth + 1) dfs(node.right, False, depth + 1) dfs(root, False, 0) return deepest_left_val"},{"question":"**Context**: You are developing an application that handles sorted lists of integers. One critical operation in this application is to insert a new number in the correct position to maintain the list\'s sorted order. To do this efficiently, you need to determine the correct index at which the new number should be inserted. **Task**: Implement a function `insert_index(sorted_list, num)` that takes a sorted list of integers `sorted_list` and an integer `num`, and returns the index where `num` should be inserted to keep the list sorted. You must use a binary search approach for this implementation. **Function Signature**: ```python def insert_index(sorted_list: list, num: int) -> int: :param sorted_list: List[int] - A list of integers sorted in ascending order. :param num: int - The number to insert. :return: int - The index at which num should be inserted. pass ``` **Input**: * `sorted_list`: A list of integers sorted in ascending order. The length of the list `n` will be in the range 0 ≤ n ≤ 10^5. * `num`: An integer where -10^6 ≤ num ≤ 10^6. **Output**: * An integer representing the index in the list where `num` should be inserted. **Constraints**: * The algorithm must have a time complexity of O(log n). * The function must handle edge cases such as an empty list or when `num` is smaller/larger than all elements in the list. **Examples**: ```python assert insert_index([1, 3, 5, 6], 5) == 2 assert insert_index([1, 3, 5, 6], 2) == 1 assert insert_index([1, 3, 5, 6], 7) == 4 assert insert_index([1, 3, 5, 6], 0) == 0 assert insert_index([], 5) == 0 ``` **Explanation**: 1. In the first example, `5` is already in the list at index `2`, so it returns `2`. 2. In the second example, `2` would fit between `1` and `3`, so it returns `1`. 3. In the third example, `7` is larger than all elements and would go at the end, so it returns `4`. 4. In the fourth example, `0` is smaller than all elements and should go at the start, so it returns `0`. 5. In the fifth example, the list is empty, so `5` should go at index `0`. Good luck and happy coding!","solution":"def insert_index(sorted_list, num): Returns the index at which num should be inserted to maintain sorted order. :param sorted_list: List[int] - A list of integers sorted in ascending order. :param num: int - The number to insert. :return: int - The index at which num should be inserted. left, right = 0, len(sorted_list) while left < right: mid = (left + right) // 2 if sorted_list[mid] < num: left = mid + 1 else: right = mid return left"},{"question":"You are tasked with extending and improving the functionality of an anagram checking algorithm. The existing function checks if two given strings are anagrams, assuming all characters are lowercase English letters (a-z). # Requirements You need to implement a function `is_anagram(s1: str, s2: str) -> bool` that: 1. Checks if the given strings are anagrams. 2. Handles uppercase letters by treating \'A\' and \'a\' as the same. 3. Ignores and skips non-alphabet characters. 4. Returns `True` if the strings are anagrams under these conditions, and `False` otherwise. # Input * Two input strings, `s1` and `s2`. # Output * Returns a boolean value `True` if `s1` and `s2` are anagrams under the described conditions, otherwise `False`. # Constraints * Both strings should not exceed 1000 characters in length. * The function should run efficiently within O(n) time complexity, where n is the length of the strings. * The function should operate within O(1) space complexity for the alphabet counting part. # Example ```python assert is_anagram(\\"Dormitory!\\", \\"Dirty room\\") == True assert is_anagram(\\"The eyes\\", \\"They see\\") == True assert is_anagram(\\"abc\\", \\"abd!\\") == False assert is_anagram(\\"Astronomer\\", \\"Moon starer!\\") == True ``` # Notes * Strings containing special characters or spaces should be preprocessed to ignore those characters. * The function should be case-insensitive.","solution":"def is_anagram(s1: str, s2: str) -> bool: from collections import Counter # Preprocess strings by removing non-alphabet chars and converting to lowercase def preprocess(s: str) -> str: return \'\'.join(char.lower() for char in s if char.isalpha()) processed_s1 = preprocess(s1) processed_s2 = preprocess(s2) return Counter(processed_s1) == Counter(processed_s2)"},{"question":"You are given an array of integers representing student ID numbers. Write a function `find_student_id` that performs linear search to locate a given student ID within the array. If the student ID is found, return the index position of its first occurrence. If the ID is not found, return -1. # Function Signature ```python def find_student_id(student_ids: List[int], target_id: int) -> int: pass ``` # Input 1. `student_ids`: A list of integers where each integer represents a student ID. (1 <= len(student_ids) <= 10^4) 2. `target_id`: An integer representing the student ID to search for. (-10^9 <= target_id <= 10^9) # Output - Return the index of the first occurrence of `target_id` in `student_ids`. - If `target_id` is not found, return -1. # Constraints - The list `student_ids` can contain both positive and negative numbers. - The list can be empty as well (return -1 in such cases). # Example ```python print(find_student_id([32, 15, 7, 23, 7, 10], 7)) # Output: 2 print(find_student_id([4, 2, 8, 6, 1, 9], 10)) # Output: -1 print(find_student_id([], 5)) # Output: -1 ``` # Explanation In the first example, the target_id 7 is found at index 2. In the second example, the target_id 10 is not present in the array, hence -1 is returned. In the third example, the array is empty, so the function returns -1.","solution":"from typing import List def find_student_id(student_ids: List[int], target_id: int) -> int: Returns the index of the first occurrence of target_id in student_ids. If target_id is not found, returns -1. for index, id in enumerate(student_ids): if id == target_id: return index return -1"},{"question":"# Problem: Swap Odd and Even Bits You are required to write a function `swap_pair` that swaps the odd and even bits in an integer. The function should take an integer as input and return an integer where all odd position bits are swapped with the neighboring even position bits. Function Signature ```python def swap_pair(num: int) -> int: ``` Input * An integer `num` where `0 <= num <= 2^32 - 1`. Output * An integer with odd and even bits swapped. Example ```python print(swap_pair(22)) # Output: 41 print(swap_pair(10)) # Output: 5 ``` Constraints * The function must operate with a time complexity of O(1). * Only use bitwise operations (AND, OR, shifts). Hints * Use masks `0xAAAAAAAA` and `0x55555555` to isolate odd and even bits. * Apply bitwise shifts to reposition these bits. Scenario Consider a scenario where you are working on a compression algorithm for a video codec. The compression algorithm needs to swap pixel data stored in binary formats efficiently. Your task is to write a function that swaps odd and even bits in pixel data values.","solution":"def swap_pair(num: int) -> int: Swaps the odd and even bits in an integer. :param num: An integer where 0 <= num <= 2^32 - 1 :return: An integer with odd and even bits swapped # Create masks for odd and even bits EVEN_BITS_MASK = 0x55555555 # Mask for bits in even positions (0, 2, 4, ...) ODD_BITS_MASK = 0xAAAAAAAA # Mask for bits in odd positions (1, 3, 5, ...) # Right shift odd bits to even positions odd_bits_shifted = (num & ODD_BITS_MASK) >> 1 # Left shift even bits to odd positions even_bits_shifted = (num & EVEN_BITS_MASK) << 1 # Combine both shifted bits return odd_bits_shifted | even_bits_shifted"},{"question":"# Coding Assessment: Radix Sort Implementation Objective: Implement the Radix Sort algorithm to sort an array of non-negative integers. Instructions: You are required to implement a function called `radix_sort` that sorts an array of non-negative integers in ascending order. Do not use any in-built sorting functions; instead, focus on the Radix Sort technique. Function Signature: ```python def radix_sort(arr: List[int], simulation: bool=False) -> List[int]: ... ``` Input: * `arr`: A list of non-negative integers, at most 100,000 elements long. * `simulation` (optional): A boolean flag for enabling intermediate steps display, defaulted to `False`. Output: * Return the sorted list of integers in ascending order. Constraints: * All integers in the array are non-negative. * The maximum integer value in the array will not exceed 10^9. Scenario: A large database of customer IDs needs to be sorted efficiently. Each customer ID is a non-negative integer, and the company expects the solution to process within reasonable time and memory limits even for large ID lists. Examples: ```python print(radix_sort([170, 45, 75, 90, 802, 24, 2, 66])) # Output: [2, 24, 45, 66, 75, 90, 170, 802] print(radix_sort([3, 3, 3, 3], simulation=True)) # Output with simulation: # iteration 0 : 3 3 3 3 # iteration 1 : 3 3 3 3 # Output: [3, 3, 3, 3] ``` Performance: * Your implementation should have a time complexity of O(nk) and space complexity of O(n + k) in typical cases. * Ensure to handle edge cases, such as empty lists and lists with identical elements.","solution":"from typing import List def counting_sort_for_radix(arr, exp): n = len(arr) output = [0] * n count = [0] * 10 for i in range(n): index = (arr[i] // exp) % 10 count[index] += 1 for i in range(1, 10): count[i] += count[i-1] i = n - 1 while i >= 0: index = (arr[i] // exp) % 10 output[count[index] - 1] = arr[i] count[index] -= 1 i -= 1 for i in range(n): arr[i] = output[i] def radix_sort(arr: List[int], simulation: bool=False) -> List[int]: if not arr: return [] max_val = max(arr) exp = 1 iteration = 0 while max_val // exp > 0: counting_sort_for_radix(arr, exp) if simulation: print(f\\"iteration {iteration} : {\' \'.join(map(str, arr))}\\") exp *= 10 iteration += 1 return arr"},{"question":"# Problem: Segment Tree Operations Given an integer array `arr` and an associative function `func`, your task is to implement a SegmentTree class that supports efficient range queries and point updates. Specifically, your implementation should provide the following functionalities: 1. **Initialize the segment tree** with the given array and function. 2. **Perform point updates** to change an element in the array. 3. **Perform range queries** to aggregate results over a specified range using the provided function. Your implementation should support various associative functions, including but not limited to addition, minimum, and maximum. Class Definition: ```python class SegmentTree: def __init__(self, arr, function): Initialize the segment tree with the given array and function. Parameters: arr (List[int] or List[Tuple[int, int]]): The input array. function (Callable[[Any, Any], Any]): The associative function to be used. def update(self, p, v): Update the element at index p to value v. Parameters: p (int): The index to update. v (int or Tuple[int, int]): The new value. def query(self, l, r): Query the range [l, r] and return the aggregated result using the provided function. Parameters: l (int): The starting index of the range. r (int): The ending index of the range. Returns: int or Tuple[int, int]: The result of the range query. ``` Input: * An integer array `arr` of size ( n ) with elements ( arr[i] ). * An associative function `func` which can either be a built-in function like `sum`, `min`, `max`, or a user-defined function using `lambda`. * For `update` function: * `p`: Index in the array that needs to be updated. * `v`: New value to be updated at index `p`. * For `query` function: * `l`: Starting index of the range. * `r`: Ending index of the range. Output: * The `update` function does not return any value. It updates the segment tree in-place. * The `query` function returns the result of the associative function applied over the range `[l, r]`. Constraints: * ( 1 leq n leq 10^5 ) * ( 0 leq l, r < n ) * ( 0 leq p < n ) * ( -10^9 leq arr[i], v leq 10^9 ) Example: ```python # Example 1 mytree = SegmentTree([2, 4, 5, 3, 4], max) print(mytree.query(2, 4)) # Output: 5 mytree.update(3, 6) print(mytree.query(0, 3)) # Output: 6 # Example 2 mytree = SegmentTree([4, 5, 2, 3, 4, 43, 3], lambda a, b: a + b) print(mytree.query(0, 6)) # Output: 64 mytree.update(2, -10) print(mytree.query(0, 6)) # Output: 52 # Example 3 mytree = SegmentTree([(1, 2), (4, 6), (4, 5)], lambda a, b: (a[0] + b[0], a[1] + b[1])) print(mytree.query(0, 2)) # Output: (9, 13) mytree.update(2, (-1, 2)) print(mytree.query(0, 2)) # Output: (4, 10) ``` Your task is to implement the `SegmentTree` class satisfying the requirements above.","solution":"class SegmentTree: def __init__(self, arr, function): self.n = len(arr) self.func = function self.tree = [None] * (2 * self.n) self.build(arr) def build(self, arr): # Building the tree for i in range(self.n): self.tree[self.n + i] = arr[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.func(self.tree[i * 2], self.tree[i * 2 + 1]) def update(self, p, v): # Update the value at index p to v p += self.n self.tree[p] = v while p > 1: p //= 2 self.tree[p] = self.func(self.tree[2 * p], self.tree[2 * p + 1]) def query(self, l, r): # Query the range [l, r] res = None l += self.n r += self.n + 1 while l < r: if l % 2: res = self.tree[l] if res is None else self.func(res, self.tree[l]) l += 1 if r % 2: r -= 1 res = self.tree[r] if res is None else self.func(res, self.tree[r]) l //= 2 r //= 2 return res"},{"question":"**Scenario**: You are working on a system that frequently processes large arrays of data. Efficient search operations are crucial for this system\'s performance. Although you currently use linear search, you suspect that switching to a different algorithm could significantly boost performance in certain scenarios. # Task: Implement a function that performs a binary search on a sorted array. Binary search should offer improved performance over linear search on sorted data. Analyze and compare the performance aspects of both. # Specifications: - **Function Signature**: `def binary_search(array: list[int], query: int) -> int:` - **Input**: - `array` (list of int): Sorted in ascending order. - `query` (int): The element to search for. - **Output**: - (int): The index of the `query` in the array if found; otherwise, return -1. - **Constraints**: - The array can have up to (10^6) elements. - The query range is within the integer limits (-10^9 to 10^9). # Requirements: 1. Implement the `binary_search` function. 2. Analyze and compare the performance (time and space complexity) of linear search vs binary search. 3. Identify scenarios where binary search may not be suitable even with a sorted array. # Example Case: ```python # Example 1 array = [1, 3, 5, 7, 9, 11, 13] query = 7 binary_search(array, query) # Output: 3 # Example 2 array = [1, 3, 5, 7, 9, 11, 13] query = 8 binary_search(array, query) # Output: -1 ``` **Note**: Your implementation should properly handle edge cases such as an empty array or negative numbers within the array.","solution":"def binary_search(array: list[int], query: int) -> int: Performs binary search on a sorted array. Parameters: array (list of int): The sorted array to search. query (int): The value to search for. Returns: int: The index of the query in the array if found, otherwise -1. left, right = 0, len(array) - 1 while left <= right: mid = left + (right - left) // 2 if array[mid] == query: return mid elif array[mid] < query: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Graph Cloning with BFS/DFS **Context:** You are given a connected undirected graph where each node has a unique label and a list of links to its neighboring nodes. The graph contains cycles and self-loops. Your task is to write a function to clone this graph. The cloned graph should have the exact same structure and the same labels on each node as the original graph. **Requirements:** 1. Implement two versions of the graph clone function: * One using Breadth-First Search (BFS). * One using Depth-First Search (DFS). 2. The function should correctly handle self-loops and cycles. 3. Ensure that the function has O(V + E) time complexity and O(V) space complexity. **Function Signatures:** ```python class UndirectedGraphNode: def __init__(self, label: int): self.label = label self.neighbors = [] def clone_graph_bfs(node: UndirectedGraphNode) -> UndirectedGraphNode: pass def clone_graph_dfs(node: UndirectedGraphNode) -> UndirectedGraphNode: pass ``` **Constraints:** - The graph nodes are labeled uniquely as non-negative integers. - The input graph is connected, meaning there is a path between any two nodes. - The maximum number of nodes in the graph is 10^4. **Example:** The serialized graph `{0,1,2#1,2#2,2}` describes a graph with: - Node 0 connected to nodes 1 and 2. - Node 1 connected to node 2. - Node 2 connected to itself (self-loop). **Edge Cases:** - The input graph can have nodes with no neighbors. - The function should handle the `None` input by returning `None`. **Implementation Detail:** - Use a dictionary to map original nodes to their clones. - Ensure the cloned graph maintains the exact same connections as the original graph. Write your code below: ```python class UndirectedGraphNode: def __init__(self, label: int): self.label = label self.neighbors = [] def clone_graph_bfs(node: UndirectedGraphNode) -> UndirectedGraphNode: if not node: return None node_copy = UndirectedGraphNode(node.label) dic = {node: node_copy} queue = collections.deque([node]) while queue: current = queue.popleft() for neighbor in current.neighbors: if neighbor not in dic: neighbor_copy = UndirectedGraphNode(neighbor.label) dic[neighbor] = neighbor_copy dic[current].neighbors.append(neighbor_copy) queue.append(neighbor) else: dic[current].neighbors.append(dic[neighbor]) return node_copy def clone_graph_dfs(node: UndirectedGraphNode) -> UndirectedGraphNode: if not node: return None node_copy = UndirectedGraphNode(node.label) dic = {node: node_copy} stack = [node] while stack: current = stack.pop() for neighbor in current.neighbors: if neighbor not in dic: neighbor_copy = UndirectedGraphNode(neighbor.label) dic[neighbor] = neighbor_copy dic[current].neighbors.append(neighbor_copy) stack.append(neighbor) else: dic[current].neighbors.append(dic[neighbor]) return node_copy ```","solution":"class UndirectedGraphNode: def __init__(self, label: int): self.label = label self.neighbors = [] def clone_graph_bfs(node: UndirectedGraphNode) -> UndirectedGraphNode: import collections if not node: return None node_copy = UndirectedGraphNode(node.label) dic = {node: node_copy} queue = collections.deque([node]) while queue: current = queue.popleft() for neighbor in current.neighbors: if neighbor not in dic: neighbor_copy = UndirectedGraphNode(neighbor.label) dic[neighbor] = neighbor_copy queue.append(neighbor) dic[current].neighbors.append(dic[neighbor]) return node_copy def clone_graph_dfs(node: UndirectedGraphNode) -> UndirectedGraphNode: if not node: return None def dfs(node, dic): if node in dic: return dic[node] node_copy = UndirectedGraphNode(node.label) dic[node] = node_copy for neighbor in node.neighbors: node_copy.neighbors.append(dfs(neighbor, dic)) return node_copy return dfs(node, {})"},{"question":"Context: You are working on developing an efficient way to modify binary representations of integers. Specifically, you need to insert one or multiple bits at a specific position within the integer\'s binary format. The primary objective is to manipulate the bits without losing the original information before and after the insertion point. Task: Implement two functions in Python to achieve this: 1. **insert_one_bit(num, bit, i)**: - **Input**: - `num`: an integer (0 ≤ num ≤ 10^9). - `bit`: single bit value (0 or 1). - `i`: the position to insert the bit (0 ≤ i ≤ the length of binary representation of `num`). - **Output**: - A new integer representing the binary form of `num` with the specified `bit` inserted at position `i`. 2. **insert_mult_bits(num, bits, length, i)**: - **Input**: - `num`: an integer (0 ≤ num ≤ 10^9). - `bits`: a sequence of bits (0 ≤ bits < 2^length). - `length`: the length of the bits sequence to be inserted (1 ≤ length ≤ 30). - `i`: the position to insert the bits (0 ≤ i ≤ the length of binary representation of `num`). - **Output**: - A new integer representing the binary form of `num` with the specified `bits` inserted at position `i`. Constraints: - Ensure the bit manipulations do not overflow the standard integer representation. - Consider edge cases such as inserting at the beginning or end of the binary representation. - Functions should operate within O(1) time and space complexity. Example: ```python # Example usage of insert_one_bit insert_one_bit(21, 1, 2) # Output: 45 (binary 101101) insert_one_bit(21, 0, 2) # Output: 41 (binary 101001) insert_one_bit(21, 1, 5) # Output: 53 (binary 110101) insert_one_bit(21, 1, 0) # Output: 43 (binary 101011) # Example usage of insert_mult_bits insert_mult_bits(5, 7, 3, 1) # Output: 47 (binary 101111) insert_mult_bits(5, 7, 3, 0) # Output: 47 (binary 101111) insert_mult_bits(5, 7, 3, 3) # Output: 61 (binary 111101) ``` You should write the `insert_one_bit` and `insert_mult_bits` functions to achieve the results demonstrated in the examples above.","solution":"def insert_one_bit(num, bit, i): Inserts a single bit at position i in the binary representation of num. Params: - num: an integer - bit: single bit value (0 or 1) - i: the position to insert the bit Returns: - The new integer representing the binary form of num with \'bit\' inserted at position \'i\'. # Split the binary representation into two parts, insert the bit, then recombine left = (num >> i) << (i + 1) right = num & ((1 << i) - 1) return left | (bit << i) | right def insert_mult_bits(num, bits, length, i): Inserts multiple bits at position i in the binary representation of num. Params: - num: an integer - bits: a sequence of bits - length: the length of the bits sequence - i: the position to insert the bits Returns: - The new integer representing the binary form of num with \'bits\' inserted at position \'i\'. # Split the binary representation into two parts, insert the bits, then recombine left = (num >> i) << (i + length) right = num & ((1 << i) - 1) return left | (bits << i) | right"},{"question":"# Scenario You\'ve been hired by a company that deals with hardware that has very limited write endurance (the number of times each memory location can be written to is very low). Efficiently managing the number of writes to memory when sorting data can have a significant impact on the system\'s lifespan. # Problem Statement Implement the Cycle Sort algorithm to sort an array of integers in non-decreasing order. The function should minimize the number of write operations to the array. # Input Format - An integer `n`, representing the number of elements in the array (0 ≤ n ≤ 10^5). - A list of `n` integers, `arr` (1 ≤ arr[i] ≤ 10^5 for all i). # Output Format - A list of `n` integers sorted in non-decreasing order. # Example Input ```python n = 5 arr = [4, 3, 2, 1, 5] ``` Output ```python [1, 2, 3, 4, 5] ``` # Constraints - Write operations should be minimized. - The implementation should be done in-place (use O(1) additional space). # Function Signature ```python def cycle_sort(arr: List[int]) -> List[int]: pass ``` # Additional Notes - Consider and handle edge cases mentioned in the analysis. - While performance might not meet modern sorting algorithms for large arrays, focus on the understanding and correct implementation of Cycle Sort.","solution":"def cycle_sort(arr): Sorts an array using Cycle Sort algorithm with minimum write operations. Args: arr: A list of integers to be sorted. Returns: The sorted list of integers. n = len(arr) for start in range(0, n - 1): item = arr[start] # Find the position where we put the item. pos = start for i in range(start + 1, n): if arr[i] < item: pos += 1 # If the item is already in the correct position. if pos == start: continue # Ignore all duplicate elements while item == arr[pos]: pos += 1 # Put the item to its right position. if pos != start: arr[pos], item = item, arr[pos] # Rotate the rest of the cycle. while pos != start: pos = start for i in range(start + 1, n): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 if item != arr[pos]: arr[pos], item = item, arr[pos] return arr"},{"question":"# Caesar Cipher Implementation Context: You are helping a friend to protect messages using a simple shift substitution encryption method called Caesar Cipher. Each letter in the plaintext is shifted a certain number of places down or up the alphabet. If the shift takes you past the end of the alphabet, it wraps around to the beginning. Problem: Write a function `caesar_cipher(s, k)` that takes a string `s` and an integer `k`, and returns the encrypted string using the Caesar Cipher technique. Input: - A string `s` which may contain uppercase letters (A-Z), lowercase letters (a-z), and non-alphabet characters. - An integer `k` representing the shift amount. This can be any integer (both positive and negative, and possibly larger than 26). Output: - A string which represents the encrypted text. Constraints: - The string length will be in the range [1, 1000]. - The shift `k` can be any integer where -1000 ≤ k ≤ 1000. Examples: 1. `caesar_cipher(\\"abc\\", 2)` should return \\"cde\\". 2. `caesar_cipher(\\"xyz\\", 3)` should return \\"abc\\". 3. `caesar_cipher(\\"XYZ\\", 4)` should return \\"BCD\\". 4. `caesar_cipher(\\"Hello, World!\\", 5)` should return \\"Mjqqt, Btwqi!\\". Notes: - Non-letter characters should remain unchanged in the encrypted string. - For negative shifts, the function should correctly wrap-around the alphabet in the opposite direction. Implementation: ```python def caesar_cipher(s, k): result = \\"\\" for char in s: n = ord(char) if 65 <= n <= 90: n = ((n - 65 + k) % 26 + 26) % 26 + 65 # upper-case letters elif 97 <= n <= 122: n = ((n - 97 + k) % 26 + 26) % 26 + 97 # lower-case letters result = result + chr(n) return result ``` Test the code with different inputs and ensure all edge cases are covered.","solution":"def caesar_cipher(s, k): result = \\"\\" for char in s: n = ord(char) if 65 <= n <= 90: n = ((n - 65 + k) % 26 + 26) % 26 + 65 # upper-case letters elif 97 <= n <= 122: n = ((n - 97 + k) % 26 + 26) % 26 + 97 # lower-case letters result = result + chr(n) if char.isalpha() else result + char return result"},{"question":"You are given a network of pipes represented as a directed graph. Each pipe has a certain maximum capacity for fluid flow. The objective is to determine the maximum amount of fluid that can flow from a designated source node to a designated sink node using one of the maximum flow algorithms. Implement a function `max_flow` that computes the maximum flow from source to sink using the Dinic’s Algorithm. You are provided with the capacity matrix, the source node, and the sink node. # Function Signature ```python def max_flow(capacity: List[List[int]], source: int, sink: int) -> int: ``` # Input 1. `capacity`: A 2D list where `capacity[i][j]` indicates the maximum capacity of fluid that can flow from node `i` to node `j`. If there is no direct pipe between nodes `i` and `j`, `capacity[i][j]` is 0. 2. `source`: An integer representing the source node. 3. `sink`: An integer representing the sink node. # Output - **Integer**: The maximum flow from the source to the sink. # Constraints - The number of nodes (N) in the network: `2 <= N <= 500`. - Capacity values are non-negative integers (including zero). - The graph can have multiple edges and self-loops but no negative capacities. - The solution should be efficient to handle large graphs in terms of both time and space. # Sample Input ```python capacity = [ [0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0] ] source = 0 sink = 5 ``` # Sample Output ```python 23 ``` # Explanation In this network, the maximum flow from node `0` (source) to node `5` (sink) is `23`. The Dinic\'s Algorithm is used to find this maximum flow efficiently. # Notes - Consider edge cases such as disconnections, no path from source to sink, zero capacities, multiple edges, and self-loops. - Ensure your implementation handles large input sizes efficiently to avoid performance bottlenecks. ***Implement the requested function in Python:*** ```python # Add your implementation here. def dinic_bfs(capacity, flow, level, source, sink): BFS function for Dinic algorithm. Check whether sink is reachable only using edges that is not full. from queue import Queue vertices = len(capacity) queue = Queue() queue.put(source) level[source] = 0 while queue.qsize(): front = queue.get() for nxt in range(vertices): if level[nxt] == -1 and flow[front][nxt] < capacity[front][nxt]: level[nxt] = level[front] + 1 queue.put(nxt) return level[sink] != -1 def dinic_dfs(capacity, flow, level, idx, sink, work, current_flow = 1 << 63): DFS function for Dinic algorithm. Finds new flow using edges that is not full. if idx == sink: return current_flow vertices = len(capacity) while work[idx] < vertices: nxt = work[idx] if level[nxt] == level[idx] + 1 and flow[idx][nxt] < capacity[idx][nxt]: available_flow = min(current_flow, capacity[idx][nxt] - flow[idx][nxt]) tmp = dinic_dfs(capacity, flow, level, nxt, sink, work, available_flow) if tmp > 0: flow[idx][nxt] += tmp flow[nxt][idx] -= tmp return tmp work[idx] += 1 return 0 def max_flow(capacity, source, sink): Computes maximum flow from source to sink using Dinic algorithm. vertices = len(capacity) flow = [[0]*vertices for _ in range(vertices)] ret = 0 while True: level = [-1 for _ in range(vertices)] work = [0 for _ in range(vertices)] if not dinic_bfs(capacity, flow, level, source, sink): break while True: tmp = dinic_dfs(capacity, flow, level, source, sink, work) if tmp > 0: ret += tmp else: break return ret ```","solution":"from typing import List from collections import deque def dinic_bfs(capacity, flow, level, source, sink): BFS function for Dinic\'s algorithm. Sets level array using a level graph concept. queue = deque([source]) level[source] = 0 while queue: u = queue.popleft() for v in range(len(capacity)): if level[v] == -1 and flow[u][v] < capacity[u][v]: level[v] = level[u] + 1 queue.append(v) return level[sink] != -1 def dinic_dfs(capacity, flow, level, work, u, sink, current_flow): DFS function for Dinic\'s algorithm. Finds a blocking flow using the level graph. if u == sink: return current_flow for v in range(work[u], len(capacity)): if level[v] == level[u] + 1 and flow[u][v] < capacity[u][v]: min_cap = min(current_flow, capacity[u][v] - flow[u][v]) result_flow = dinic_dfs(capacity, flow, level, work, v, sink, min_cap) if result_flow > 0: flow[u][v] += result_flow flow[v][u] -= result_flow return result_flow work[u] += 1 return 0 def max_flow(capacity: List[List[int]], source: int, sink: int) -> int: Computes maximum flow from source to sink using Dinic\'s algorithm. n = len(capacity) flow = [[0] * n for _ in range(n)] total_flow = 0 while True: level = [-1] * n if not dinic_bfs(capacity, flow, level, source, sink): break work = [0] * n while True: delta = dinic_dfs(capacity, flow, level, work, source, sink, float(\'Inf\')) if delta == 0: break total_flow += delta return total_flow"},{"question":"Context: You are working on a project related to resource allocation in a distributed system where resources are allocated in powers of two for efficiency. It is crucial to determine whether a given number of resources is a valid power of two. Task: Write a function called `is_power_of_two` that checks whether a given integer is a power of two. Function Signature: ```python def is_power_of_two(n: int) -> bool: ``` Input: * `n`: an integer (1 <= n <= 2^31 - 1) Output: * `True` if `n` is a power of two, `False` otherwise. Constraints: * The function should have a time complexity of O(1). * The function should have a space complexity of O(1). Special Guidelines: * Consider edge cases where `n` could be zero or negative. Examples: ```python assert is_power_of_two(1) == True # 2^0 assert is_power_of_two(2) == True # 2^1 assert is_power_of_two(3) == False # 3 is not a power of two assert is_power_of_two(16) == True # 2^4 assert is_power_of_two(0) == False # 0 is not a power of two assert is_power_of_two(-4) == False # negative numbers are not powers of two ``` Note: Make sure your code runs efficiently and correctly handles all edge cases.","solution":"def is_power_of_two(n: int) -> bool: Checks whether a given integer is a power of two. Args: n (int): The integer to check. Returns: bool: True if the integer is a power of two, False otherwise. if n <= 0: return False return (n & (n - 1)) == 0"},{"question":"Implement a Priority Queue Using a Min Heap Context Your task is to create a priority queue implemented using a Min Heap. This data structure should support two primary operations: 1. **Insert a new element with a given priority**. 2. **Extract the element with the highest priority (minimum value)**. You will be provided with a list of operations to perform on the priority queue. Each operation will be one of the following: - \\"insert x\\": Insert element `x` into the queue. - \\"extract_min\\": Remove and return the element with the highest priority. Function Signature Implement the function `priority_queue_operations(operations: List[str]) -> List[int]`. Input - `operations`: A list of strings where each string is either \\"insert x\\" or \\"extract_min\\". - Operations format: - \\"insert x\\": Where `x` is an integer. - \\"extract_min\\": No value follows. - Always assume the initial heap is empty. - Valid operations are guaranteed. Output - A list of integers, where each integer is the result of an \\"extract_min\\" operation. - If there are no elements to extract, return -1 for that operation. Example ```python priority_queue_operations([\\"insert 4\\", \\"insert 10\\", \\"extract_min\\", \\"insert 8\\", \\"extract_min\\", \\"extract_min\\"]) ``` Should return: ```python [4, 8, 10] ``` Constraints - The number of operations (1 leq |operations| leq 10^4) - The value for `insert x` will be within the range of a 32-bit signed integer.","solution":"import heapq def priority_queue_operations(operations): min_heap = [] result = [] for operation in operations: if operation.startswith(\\"insert\\"): _, x = operation.split() heapq.heappush(min_heap, int(x)) elif operation == \\"extract_min\\": if min_heap: result.append(heapq.heappop(min_heap)) else: result.append(-1) return result"},{"question":"Context: You are working on a search engine that quickly retrieves records from a large, uniformly distributed dataset. Given a set of sorted records, implement a function to efficiently find the position of a specified search key using the interpolation search algorithm. Task: Implement the function `enhanced_interpolation_search(array: List[int], search_key: int) -> int` that finds the index of a given search key in a sorted array. If the key is not found, return -1. The function should: 1. Handle edge cases such as empty arrays and single-element arrays. 2. Ensure that the algorithm does not perform division by zero. 3. Optionally, add initial checks to quickly resolve boundary cases. Input/Output Format: * Input: - `array`: A sorted list of integers. - `search_key`: An integer representing the key to be searched. * Output: - Index of the search_key in the array if found, else -1. Constraints: - The array can have up to (10^6) elements. - The elements in the array are unique and range from (-10^9) to (10^9). Examples: ```python >>> enhanced_interpolation_search([-25, -12, -1, 10, 12, 15, 20, 41, 55], -1) 2 >>> enhanced_interpolation_search([5, 10, 12, 14, 17, 20, 21], 55) -1 >>> enhanced_interpolation_search([5, 10, 12, 14, 17, 20, 21], -5) -1 >>> enhanced_interpolation_search([], 10) -1 >>> enhanced_interpolation_search([10], 10) 0 ``` Performance Requirements: - The function must run efficiently with a complexity close to O(log2(log2 n)) for large uniformly distributed arrays.","solution":"from typing import List def enhanced_interpolation_search(array: List[int], search_key: int) -> int: Performs an interpolation search on a sorted array to find the index of the search_key. Returns the index if found, otherwise returns -1. if not array: return -1 low = 0 high = len(array) - 1 while low <= high and search_key >= array[low] and search_key <= array[high]: if low == high: if array[low] == search_key: return low return -1 pos = low + int((float(high - low) / (array[high] - array[low]) * (search_key - array[low]))) if array[pos] == search_key: return pos if array[pos] < search_key: low = pos + 1 else: high = pos - 1 return -1"},{"question":"# Binary Tree Serialization and Deserialization You are given the implementation of a binary tree node `TreeNode` and two functions `serialize` and `deserialize` that handle the serialization and deserialization of a binary tree, respectively. Your task is to implement a function that checks if two binary trees are the same. # Function Signature ```python def is_same_tree(p: TreeNode, q: TreeNode) -> bool: pass ``` # Input * p: TreeNode - Root node of the first binary tree. * q: TreeNode - Root node of the second binary tree. # Output * bool - Return `True` if both trees are identical, otherwise `False`. # Constraints * The number of nodes in each binary tree will be in the range [0, 1000]. * The values of the nodes will be in the range [-1000, 1000]. # Example ```python # Example 1 p = TreeNode(1) p.left = TreeNode(2) p.right = TreeNode(3) q = TreeNode(1) q.left = TreeNode(2) q.right = TreeNode(3) print(is_same_tree(p, q)) # Output: True # Example 2 p = TreeNode(1) p.left = TreeNode(2) q = TreeNode(1) q.right = TreeNode(2) print(is_same_tree(p, q)) # Output: False # Example 3 p = None q = None print(is_same_tree(p, q)) # Output: True ``` # Challenge Ensure your algorithm handles various edge cases, such as different tree shapes, and large trees efficiently.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_same_tree(p: TreeNode, q: TreeNode) -> bool: if not p and not q: # Both nodes are None return True if not p or not q: # One of the nodes is None return False if p.val != q.val: # Node values are different return False # Check recursively for left and right subtrees return is_same_tree(p.left, q.left) and is_same_tree(p.right, q.right)"},{"question":"# Coding Assessment: Maze Pathfinding Objective: Develop a function to find the shortest path in a maze represented as a 2D grid using graph traversal algorithms. Context: You are tasked with navigating a maze where \'0\' represents an open cell, and \'1\' represents a wall. Your objective is to find the shortest path from a starting position to a destination position. Function Signature: ```python def shortest_maze_path(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> List[Tuple[int, int]]: pass ``` Input: - `grid`: A 2D list of integers (M x N), where \'0\' indicates open cells, and \'1\' indicates walls. - `start`: A tuple `(r, c)` indicating the starting position in the grid. - `end`: A tuple `(r, c)` indicating the destination position in the grid. Output: - Returns a list of tuples indicating the cells `(r, c)` that form the shortest path from start to end. If no path is found, return an empty list. Constraints: - Assume `grid` has at least one row and one column. - `grid` dimensions will be M, N where 1 ≤ M, N ≤ 100. - `start` and `end` will always be valid indices within the grid. - You can move up, down, left, or right but cannot move diagonally. - Moving through a cell counts as one step. Performance Requirements: - Aim for a time complexity of O(M * N) where M and N are the dimensions of the grid. Example: ```python grid = [ [0, 0, 1, 0], [1, 0, 1, 0], [1, 0, 0, 0], [0, 1, 1, 0], [0, 0, 0, 0] ] start = (0, 0) end = (4, 3) ``` Expected output: ```python [(0, 0), (1, 1), (2, 1), (2, 2), (2, 3), (3, 2), (4, 3)] ``` # Hint: - Utilize a graph traversal algorithm such as Breadth-First Search (BFS) for efficient pathfinding in a grid layout.","solution":"from typing import List, Tuple from collections import deque def shortest_maze_path(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> List[Tuple[int, int]]: rows, cols = len(grid), len(grid[0]) def is_valid(r, c): return 0 <= r < rows and 0 <= c < cols and grid[r][c] == 0 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # right, down, left, up queue = deque([(start, [start])]) visited = set([start]) while queue: (current_r, current_c), path = queue.popleft() if (current_r, current_c) == end: return path for dr, dc in directions: new_r, new_c = current_r + dr, current_c + dc if is_valid(new_r, new_c) and (new_r, new_c) not in visited: visited.add((new_r, new_c)) queue.append(((new_r, new_c), path + [(new_r, new_c)])) return [] # No path found"},{"question":"# Scenario You have been hired by a software company that specializes in building tools for analyzing various types of data structures. One of their upcoming projects involves allowing users to visualize different paths in a binary tree that sum up to a given value. This feature will help users understand how the data flows within their systems better. # Problem Statement Given the implementation provided, your task is to implement a function `path_sum_divisible_by_k` which returns all root-to-leaf paths where each path\'s sum is divisible by a given integer `k`. Implement the following function: ```python def path_sum_divisible_by_k(root, k): pass ``` # Input Format - `root`: The root node of the binary tree. Each node contains an integer value. - `k`: An integer representing the divisor for checking the path sum. # Output Format - A list of lists, where each inner list represents the path from the root to a leaf with the path sum divisible by `k`. # Constraints - The number of nodes in the tree is in the range [0, 1000]. - All node values are integers (can be negative). - The integer `k` will be non-zero and can be negative. # Example Given the binary tree and k = 22, ``` 5 / 4 8 / / 11 13 4 / / 7 2 5 1 ``` For a divisor `k = 11`, the function should return: ``` [ [5,4,11,2], [5,8,4,5] ] ``` # Performance Note - Aim for a solution with a time complexity of O(n) and a space complexity of O(h) (or O(w) for BFS), where n is the number of nodes in the tree, h is the height of the tree, and w is the maximum width of the tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def path_sum_divisible_by_k(root, k): def dfs(node, path, current_sum): if not node: return path.append(node.val) current_sum += node.val if not node.left and not node.right: # Check if it\'s a leaf node if current_sum % k == 0: result.append(list(path)) dfs(node.left, path, current_sum) dfs(node.right, path, current_sum) # Backtrack path.pop() result = [] dfs(root, [], 0) return result"},{"question":"You are given an array of integers where every element appears three times except for one, which appears exactly once. Your task is to write a function that finds that single unique number without using any extra memory beyond fixed extra variables. **Function Signature**: ```python def find_unique(nums: List[int]) -> int: ``` **Input**: * `nums`: A list of integers where `1 <= len(nums) <= 10^5`. **Output**: * Returns an integer representing the unique number that appears exactly once. **Example**: ```python assert find_unique([2, 2, 3, 2]) == 3 assert find_unique([0, 1, 0, 1, 0, 1, 99]) == 99 assert find_unique([-2, -2, 1, -2]) == 1 ``` **Constraints**: * Your algorithm should run in O(n) time complexity. * Do not use any extra memory (i.e., the space complexity must be O(1)). **Scenario**: Imagine you are working on a data analysis project where you have a massive dataset of readings, and due to some transmission issues, every reading has been recorded three times, except for one fraudulent reading recorded only once. To uphold data integrity, you need to identify and remove this single erroneous reading. Hint: Use bitwise operations to achieve the required time and space complexity.","solution":"from typing import List def find_unique(nums: List[int]) -> int: Finds the unique number in a list where every other element appears three times. once = 0 twice = 0 for num in nums: # `twice` gets the set bits that appear twice twice |= once & num # XOR operation with `once` will keep the bits that have appeared odd times once ^= num # `thrice` set bits that have appeared three times thrice = once & twice # Remove bits that have appeared three times from `once` and `twice` once &= ~thrice twice &= ~thrice return once"},{"question":"**Context**: In a medical record application, patient test results are sequentially stored in a singly linked list. Each record is a node in the list, containing the patient\'s name, test value, and a pointer to the next record. **Task**: Write a function `delete_patient_record(current_patient)` to delete a given patient record (represented by a node in the list) from the system, without having access to the head of the list. You should assume that the record to delete is neither `None` nor the last record in the list. # Requirements 1. **Input**: A node `current_patient` in a singly linked list. 2. **Output**: No return value. Modify the list in place to remove the given node. 3. **Constraints**: - `current_patient` is guaranteed not to be `None` and not to be the last node in the list. - You have direct access only to the node to be deleted. # Example Given the singly linked list: ``` {\\"name\\": \\"John\\", \\"value\\": 7} -> {\\"name\\": \\"Doe\\", \\"value\\": 5} -> {\\"name\\": \\"Jane\\", \\"value\\": 8} ``` and the node representing \\"Doe\\": After calling `delete_patient_record(current_patient)` it should become: ``` {\\"name\\": \\"John\\", \\"value\\": 7} -> {\\"name\\": \\"Jane\\", \\"value\\": 8} ``` # Function Signature ```python class PatientRecord: def __init__(self, name, value): self.name = name self.value = value self.next = None def delete_patient_record(current_patient): # Your code goes here. ``` **Implementation Challenge**: Ensure proper handling of edge cases as defined in the analysis. **Notes**: - Do not create any new nodes or lists, modify only the structure in place. - Assume that `current_patient` will not be `None` and it won\'t be the last node in the list.","solution":"class PatientRecord: def __init__(self, name, value): self.name = name self.value = value self.next = None def delete_patient_record(current_patient): Deletes the given patient record from the linked list by copying the data from the next node into the current node and then bypassing the next node. if current_patient.next: next_record = current_patient.next current_patient.name = next_record.name current_patient.value = next_record.value current_patient.next = next_record.next"},{"question":"# Scenario You are tasked with implementing a function in a database system that supports a dynamic set of sorted data. The system uses B-Trees for indexing. You need to implement a B-Tree data structure with operations to add, search, and delete nodes, ensuring balance and efficient data access. # Task Implement a B-Tree with the following functionalities: 1. **Insert a key**: `def insert_key(key: int) -> None`. 2. **Find/Search a key**: `def find_key(key: int) -> bool`. 3. **Remove/Delete a key**: `def remove_key(key: int) -> None`. 4. **Traverse the tree**: `def traverse_tree() -> List[int]`. # Requirements - Handle all edge cases such as splitting the root, merging nodes, and handling nodes with the minimum number of keys during deletion. - Ensure that the B-tree maintains balance after each operation. - Consider performance and optimize for disk operations in a real-world application. # Function Signatures ```python class BTree: def __init__(self, t_val=2): Initialize the B-tree with the given degree t_val. def insert_key(self, key: int) -> None: Insert the key into the B-tree. def find_key(self, key: int) -> bool: Return True if the key is present in the B-tree, otherwise return False. def remove_key(self, key: int) -> None: Remove the key from the B-tree. def traverse_tree(self) -> List[int]: Return a list of all keys in the B-tree in ascending order. ``` # Input and Output Formats - `insert_key` accepts an integer key and inserts it into the B-tree. It doesn\'t return any value. - `find_key` accepts an integer key and returns a boolean indicating whether the key exists in the B-tree. - `remove_key` accepts an integer key and removes it from the B-tree. It doesn\'t return any value. - `traverse_tree` returns a list of all keys in the B-tree in ascending order. # Examples ```python btree = BTree(2) # Insert keys btree.insert_key(10) btree.insert_key(20) btree.insert_key(5) btree.insert_key(6) btree.insert_key(12) btree.insert_key(30) btree.insert_key(7) btree.insert_key(17) # Search for keys print(btree.find_key(10)) # Output: True print(btree.find_key(15)) # Output: False # Traverse tree print(btree.traverse_tree()) # Output: [5,6,7,10,12,17,20,30] # Delete keys btree.remove_key(6) btree.remove_key(13) btree.remove_key(7) btree.remove_key(4) # Traverse tree again print(btree.traverse_tree()) # Output: [5,10,12,17,20,30] ``` # Constraints - You may assume keys are unique and are non-negative integers. - Handle large inputs efficiently, maintaining the logarithmic complexity for B-Tree operations.","solution":"class BTreeNode: def __init__(self, t, leaf=False): self.t = t # Minimum degree (defines the range for number of keys) self.leaf = leaf # True if leaf node self.keys = [] # List of keys self.children = [] # List of child pointers class BTree: def __init__(self, t_val=2): self.t = t_val self.root = BTreeNode(t_val, True) def traverse_tree(self): keys = [] def traverse(node): for i in range(len(node.keys)): if not node.leaf: traverse(node.children[i]) keys.append(node.keys[i]) if not node.leaf: traverse(node.children[len(node.keys)]) traverse(self.root) return keys def find_key(self, key): def search(node, key): i = 0 while i < len(node.keys) and key > node.keys[i]: i += 1 if i < len(node.keys) and node.keys[i] == key: return True if node.leaf: return False else: return search(node.children[i], key) return search(self.root, key) def insert_key(self, key): r = self.root if len(r.keys) == 2 * self.t - 1: temp = BTreeNode(self.t, False) self.root = temp temp.children.insert(0, r) self.split_child(temp, 0) self._insert_non_full(temp, key) else: self._insert_non_full(r, key) def _insert_non_full(self, node, key): i = len(node.keys) - 1 if node.leaf: node.keys.append(0) while i >= 0 and key < node.keys[i]: node.keys[i + 1] = node.keys[i] i -= 1 node.keys[i + 1] = key else: while i >= 0 and key < node.keys[i]: i -= 1 i += 1 if len(node.children[i].keys) == 2 * self.t - 1: self.split_child(node, i) if key > node.keys[i]: i += 1 self._insert_non_full(node.children[i], key) def split_child(self, parent, i): t = self.t y = parent.children[i] z = BTreeNode(t, y.leaf) parent.children.insert(i + 1, z) parent.keys.insert(i, y.keys[t - 1]) z.keys = y.keys[t:(2 * t - 1)] y.keys = y.keys[0:t - 1] if not y.leaf: z.children = y.children[t:(2 * t)] y.children = y.children[0:t] def remove_key(self, key): if not self.root: return None self._remove(self.root, key) if len(self.root.keys) == 0: if not self.root.leaf: self.root = self.root.children[0] else: self.root = None def _remove(self, node, key): t = self.t def find_key_index(node, key): index = 0 while index < len(node.keys) and node.keys[index] < key: index += 1 return index index = find_key_index(node, key) if index < len(node.keys) and node.keys[index] == key: if node.leaf: node.keys.pop(index) else: self._remove_internal_node(node, key, index) else: if node.leaf: return None flag = index == len(node.keys) if len(node.children[index].keys) < t: self._fill(node, index) if flag and index > len(node.keys): self._remove(node.children[index - 1], key) else: self._remove(node.children[index], key) def _remove_internal_node(self, node, key, index): t = self.t if len(node.children[index].keys) >= t: pred_key = self._get_pred(node, index) node.keys[index] = pred_key self._remove(node.children[index], pred_key) elif len(node.children[index + 1].keys) >= t: succ_key = self._get_succ(node, index) node.keys[index] = succ_key self._remove(node.children[index + 1], succ_key) else: self._merge(node, index) self._remove(node.children[index], key) def _get_pred(self, node, index): current = node.children[index] while not current.leaf: current = current.children[len(current.keys)] return current.keys[len(current.keys) - 1] def _get_succ(self, node, index): current = node.children[index + 1] while not current.leaf: current = current.children[0] return current.keys[0] def _fill(self, node, index): t = self.t if index != 0 and len(node.children[index - 1].keys) >= t: self._borrow_from_prev(node, index) elif index != len(node.keys) and len(node.children[index + 1].keys) >= t: self._borrow_from_next(node, index) else: if index != len(node.keys): self._merge(node, index) else: self._merge(node, index - 1) def _borrow_from_prev(self, node, index): child = node.children[index] sibling = node.children[index - 1] for i in range(len(child.keys) - 1, -1, -1): child.keys.insert(i + 1, child.keys[i]) if not child.leaf: for i in range(len(child.children) - 1, -1, -1): child.children.insert(i + 1, child.children[i]) child.keys[0] = node.keys[index - 1] if not node.leaf: child.children[0] = sibling.children.pop() node.keys[index - 1] = sibling.keys.pop() def _borrow_from_next(self, node, index): child = node.children[index] sibling = node.children[index + 1] child.keys.append(node.keys[index]) if not child.leaf: child.children.append(sibling.children.pop(0)) node.keys[index] = sibling.keys.pop(0) def _merge(self, node, index): child = node.children[index] sibling = node.children[index + 1] child.keys.append(node.keys.pop(index)) child.keys.extend(sibling.keys) if not child.leaf: child.children.extend(sibling.children) node.children.pop(index + 1)"},{"question":"# Problem: You are given a list of lowercase characters sorted in non-decreasing order and a target character. You need to find the smallest character in the list that is greater than the given target character. The list is circular, meaning that if no such character exists, it should return the first character in the list. # Function Signature: ```python def find_next_char(letters: List[str], target: str) -> str: ``` # Input: - `letters`: List of lowercase characters sorted in non-decreasing order. (1 <= len(letters) <= 10^4) - `target`: A lowercase character. # Output: - Returns the smallest character in `letters` that is larger than `target`. # Constraints: - The input list `letters` is guaranteed to be sorted in non-decreasing order. - `letters` will wrap around if the target is larger than the largest character in the list. # Example: ```python # Given examples to illustrate the problem print(find_next_char([\\"c\\", \\"f\\", \\"j\\"], \\"a\\")) # Output: \\"c\\" print(find_next_char([\\"c\\", \\"f\\", \\"j\\"], \\"c\\")) # Output: \\"f\\" print(find_next_char([\\"c\\", \\"f\\", \\"j\\"], \\"d\\")) # Output: \\"f\\" print(find_next_char([\\"c\\", \\"f\\", \\"j\\"], \\"j\\")) # Output: \\"c\\" print(find_next_char([\\"a\\", \\"b\\", \\"c\\"], \\"z\\")) # Output: \\"a\\" ``` # Requirements: - The solution should aim for an O(log N) time complexity. - Handle edge cases such as empty lists or lists with a single element effectively. - Consider additional constraints such as time and space efficiency when implementing the solution.","solution":"from typing import List def find_next_char(letters: List[str], target: str) -> str: Finds the smallest character in the list that is greater than the given target character. The list is circular. left, right = 0, len(letters) while left < right: mid = (left + right) // 2 if letters[mid] <= target: left = mid + 1 else: right = mid return letters[left % len(letters)]"},{"question":"# Hash Table Operations with Dynamic Resizing Objective You are required to implement a hash table that not only efficiently handles basic operations but also dynamically resizes itself to maintain performance as it grows. The hash table should handle collisions using linear probing and resize itself when it exceeds a certain load factor. Function Signature ```python class ResizableHashTable(HashTable): def put(self, key, value): pass def __resize(self): pass ``` Input and Output Formats - **Input**: - `put(key, value)`: Takes in a key-value pair where `key` is an integer, and `value` is any python object. - `get(key)`: Takes an integer key and returns the corresponding value or `None` if the key does not exist. - `del(key)`: Takes an integer key and removes the key-value pair from the table. - **Output**: - `put`: No return value. It just modifies the internal state of the hash table. - `get`: Returns the value associated with the key or `None` if the key is not found. - `del`: No return value. It just modifies the internal state of the hash table. Constraints - The hash table size should double when the number of elements exceeds 2/3 of the current table size. - Keys are integers and values can be of any type. - Operations should adhere to the expected average case complexities (O(1) for put, get, and delete). Example ```python ht = ResizableHashTable() ht.put(1, \\"value1\\") ht.put(2, \\"value2\\") print(ht.get(1)) # Output: \\"value1\\" print(ht.get(3)) # Output: None ht.del_(1) print(ht.get(1)) # Output: None for i in range(20): ht.put(i, f\\"value{i}\\") print(ht.size) # Expected output: A size that is greater to or equal to 32 ``` Note - You should handle edge cases such as inserting duplicate keys, deletions of non-existent keys, and the table being full. - Ensure to maintain and correctly update the internal state to match the expected behaviors. Your task is to complete the `put` method to incorporate resizing and ensure it works efficiently.","solution":"class ResizableHashTable: def __init__(self, initial_capacity=8): self.capacity = initial_capacity self.size = 0 self.table = [None] * self.capacity self.load_factor_threshold = 2 / 3 # When 2/3 of the table is filled, resize def put(self, key, value): if self.size / self.capacity >= self.load_factor_threshold: self.__resize() index = self.__hash(key) while self.table[index] is not None: current_key, _ = self.table[index] if current_key == key: # Update existing key self.table[index] = (key, value) return index = (index + 1) % self.capacity self.table[index] = (key, value) self.size += 1 def get(self, key): index = self.__hash(key) while self.table[index] is not None: current_key, value = self.table[index] if current_key == key: return value index = (index + 1) % self.capacity return None def del_(self, key): index = self.__hash(key) while self.table[index] is not None: current_key, _ = self.table[index] if current_key == key: self.table[index] = None self.size -= 1 self.__rehash_from_index((index + 1) % self.capacity) return index = (index + 1) % self.capacity def __hash(self, key): return key % self.capacity def __resize(self): old_table = self.table self.capacity *= 2 self.table = [None] * self.capacity self.size = 0 for entry in old_table: if entry is not None: key, value = entry self.put(key, value) def __rehash_from_index(self, start_index): index = start_index while self.table[index] is not None: key, value = self.table[index] self.table[index] = None self.size -= 1 self.put(key, value) index = (index + 1) % self.capacity ht = ResizableHashTable() ht.put(1, \\"value1\\") ht.put(2, \\"value2\\") print(ht.get(1)) # Output: \\"value1\\" print(ht.get(3)) # Output: None ht.del_(1) print(ht.get(1)) # Output: None for i in range(20): ht.put(i, f\\"value{i}\\") print(ht.capacity) # Expected output: A size that is greater to or equal to 32"},{"question":"# Question: You are provided with a list of integers `arr`, and you are required to sort this list in non-decreasing order using the Gnome Sort algorithm. The Gnome Sort algorithm performs sorting by comparing and swapping adjacent elements, moving backward if the current element is smaller and forward otherwise. Function Signature: ```python def gnome_sort(arr: List[int]) -> List[int]: ``` Input: - `arr`: A list of integers. The elements of `arr` can be negative, zero, or positive integers. Output: - A list of integers sorted in non-decreasing order. Constraints: - 0 <= len(arr) <= 10^4 - -10^6 <= arr[i] <= 10^6 Example: ```python # Example 1 arr = [34, 2, 10, -9] print(gnome_sort(arr)) # Output: [-9, 2, 10, 34] # Example 2 arr = [5, 3, 2, 4] print(gnome_sort(arr)) # Output: [2, 3, 4, 5] ``` Notes: - Make sure to handle edge cases such as an empty list or a single element list. - Aim for clear and efficient implementation within the constraints. - Discuss and justify any enhancements or modifications to the original Gnome Sort algorithm that you implement.","solution":"from typing import List def gnome_sort(arr: List[int]) -> List[int]: Sorts a list of integers using the Gnome Sort algorithm. n = len(arr) pos = 0 while pos < n: if pos == 0 or arr[pos] >= arr[pos - 1]: pos += 1 else: arr[pos], arr[pos - 1] = arr[pos - 1], arr[pos] pos -= 1 return arr"},{"question":"# Question for Coding Assessment Context: You are working on a project that involves a considerable amount of number theory computations. As part of this, you need an efficient method to find both the Greatest Common Divisor (GCD) and Least Common Multiple (LCM) of pairs of non-negative integers, and to analyze the binary form of numbers. Specifically, you need to count the number of trailing zeroes in the binary representation of a number and use this bitwise operation to enhance the GCD calculation. Task: Implement a function `compute_gcd_and_lcm(n: int, m: int) -> Tuple[int, int]` that: 1. Computes the GCD of two non-negative integers n and m using the bitwise algorithm. 2. Computes the LCM of the same pair n and m leveraging the computed GCD. 3. Ensure to handle any edge cases (e.g., zero values) appropriately. Constraints: - The input integers `n` and `m` are in the range of (0 leq n, m leq 10^9). - Avoids direct multiplication for LCM calculation as it may cause overflow for very large integers. Expected Function Signature: ```python from typing import Tuple def compute_gcd_and_lcm(n: int, m: int) -> Tuple[int, int]: # Your implementation here return gcd_value, lcm_value ``` # Example: ```python compute_gcd_and_lcm(12, 15) # Returns (3, 60) compute_gcd_and_lcm(0, 10) # Returns (10, 0) ``` **Note**: For (LCM), if either `n` or `m` is zero, LCM should be zero. For `GCD`, follow the bitwise GCD implementation protocol.","solution":"from typing import Tuple def compute_gcd_and_lcm(n: int, m: int) -> Tuple[int, int]: def gcd(a: int, b: int) -> int: Computes the GCD using the bitwise algorithm. if a == 0: return b if b == 0: return a # Find the common factors of 2 shift = 0 while ((a | b) & 1) == 0: # Both a and b are even a >>= 1 b >>= 1 shift += 1 while (a & 1) == 0: # a is even a >>= 1 while b != 0: while (b & 1) == 0: # b is even b >>= 1 if a > b: a, b = b, a # Swap a and b b = b - a return a << shift gcd_value = gcd(n, m) if gcd_value == 0: lcm_value = 0 else: lcm_value = abs(n * m) // gcd_value return gcd_value, lcm_value"},{"question":"# Context You are working as a developer and are tasked with implementing various sorting algorithms to understand their efficiency and characteristics better. One such task is to implement the Exchange Sort algorithm. # Objective Write a function `exchange_sort(arr)` that sorts an array of integers in ascending order using the Exchange Sort algorithm. # Input and Output Formats * **Input**: A list of integers, `arr` * **Output**: A list of integers, `arr`, sorted in ascending order # Constraints * The input list will have a length `n`, where `1 ≤ n ≤ 10^3`. * Each integer in the list will be in the range `-10^3 ≤ arr[i] ≤ 10^3`. # Performance Requirements The implementation should have an O(n^2) time complexity and O(1) space complexity. # Example ```python # Input arr = [64, 34, 25, 12, 22, 11, 90] # Output sorted_arr = exchange_sort(arr) # sorted_arr should be [11, 12, 22, 25, 34, 64, 90] ``` # Additional Information Consider edge cases such as empty arrays, single-element arrays, and arrays that are already sorted.","solution":"def exchange_sort(arr): Sorts an array of integers in ascending order using the Exchange Sort algorithm. Parameters: arr (list of int): The list of integers to be sorted. Returns: list of int: The sorted list of integers. n = len(arr) for i in range(n - 1): for j in range(i + 1, n): if arr[i] > arr[j]: arr[i], arr[j] = arr[j], arr[i] return arr"},{"question":"# Sum of Digits Raised to Sequential Powers Context: Given a range of integers [low, high], write a function to identify numbers within this range where the sum of its digits raised to consecutive powers equals the number itself. For example: - 89 is such a number because (8^1 + 9^2 = 89). - 135 follows this property as (1^1 + 3^2 + 5^3 = 135). Requirements: Write a function `special_numbers_in_range(low: int, high: int) -> List[int]` that: - Takes two integers `low` and `high` representing a range (inclusive). - Returns a list of integers within this range that satisfy the given property. Input: - `low` (int): Starting integer of the range. - `high` (int): Ending integer of the range. - Constraints: (1 leq low leq high leq 10^6). Output: - Returns a list of integers where each integer meets the described property. Examples: ```python special_numbers_in_range(1, 10) # returns [1, 2, 3, 4, 5, 6, 7, 8, 9] special_numbers_in_range(1, 150) # returns [1, 2, 3, 4, 5, 6, 7, 8, 9, 89, 135] ``` Constraints: - The function should efficiently handle the range up to (10^6). - Avoid using excessive memory. - Optimize to reduce the computational overhead for larger ranges.","solution":"def special_numbers_in_range(low, high): Returns a list of numbers within the range [low, high] where the sum of the digits raised to consecutive powers equals the number itself. Args: low (int): Starting integer of the range (inclusive). high (int): Ending integer of the range (inclusive). Returns: List[int]: List of special numbers within the given range. special_numbers = [] for num in range(low, high + 1): digits = list(map(int, str(num))) if num == sum(digit ** (i + 1) for i, digit in enumerate(digits)): special_numbers.append(num) return special_numbers"},{"question":"# Unique Number Finder Context In a large dataset of integers where all elements appear exactly three times except for one unique integer that appears exactly once, efficient retrieval of this unique number is required. Previous solutions have revealed that a bitwise manipulation approach often functions optimally in such scenarios, considering the problem constraints. Task Write a Python function to find the unique integer from a list where every other integer appears exactly three times. Specifications * **Function Signature**: `def find_unique_number(nums: List[int]) -> int` * **Input**: * `nums`: A list of integers `nums` (1 <= len(nums) <= 3 * 10^4), where every integer appears exactly three times except for one. * **Output**: * Return the single integer that appears once. Constraints * The solution should finish in linear time (O(n)). * The solution should not use extra memory. # Example ```python assert find_unique_number([2, 2, 3, 2]) == 3 assert find_unique_number([0, 1, 0, 1, 0, 1, 99]) == 99 ``` Additional Notes Your solution should utilize bitwise operators to achieve the desired efficiency. Consider the core principle: the sum of bits of all elements modulo three will yield the unique number\'s bits.","solution":"from typing import List def find_unique_number(nums: List[int]) -> int: ones, twos = 0, 0 for num in nums: twos |= ones & num # Add new bits to \'twos\' that appear twice ones ^= num # Add new bits to \'ones\' or remove already set bits common_bit_mask = ~(ones & twos) # Get bits that are not common to both \'ones\' and \'twos\' ones &= common_bit_mask # Remove common bits from \'ones\' twos &= common_bit_mask # Remove common bits from \'twos\' return ones"},{"question":"**Objective:** Develop a function to match and replace symbols within given words, ensuring that the longest matching symbol is used for replacement. **Problem Statement:** You are given a list of words and a list of symbols. Your task is to replace occurrences of the longest possible symbols within each word. Each matched symbol should be surrounded by square brackets `[symbol]`. If a word matches more than one symbol, you must choose the one with the longest length. If a word does not match any symbol, it should remain unchanged. **Input:** - A list of strings `words` (1 ≤ length of each word ≤ 100). - A list of strings `symbols` (1 ≤ length of each symbol ≤ 50). **Output:** - A list where each element is a word with replaced symbols or unchanged if no match found. **Constraints:** - All characters in words and symbols are lowercase alphabetical. - There are no duplicate symbols. - Each symbol is unique and appears at most once in a word. **Function Signature:** ```python def match_symbols(words: List[str], symbols: List[str]) -> List[str]: pass ``` **Example:** ```python words = [\'amazon\', \'microsoft\', \'google\'] symbols = [\'i\', \'am\', \'cro\', \'na\', \'le\', \'abc\'] output = [\\"[am]azon\\", \\"mi[cro]soft\\", \\"goog[le]\\"] ``` **Explanation:** - `\\"amazon\\"`: Matches \\"am\\" and \\"na\\", \\"am\\" is longer. - `\\"microsoft\\"`: Matches \\"i\\" and \\"cro\\", \\"cro\\" is longest. - `\\"google\\"`: Matches \\"le\\". **Requirements:** - Ensure optimal runtime complexity. - Handle edge cases effectively. - Maintain clear and efficient code structure.","solution":"from typing import List def match_symbols(words: List[str], symbols: List[str]) -> List[str]: symbols = sorted(symbols, key=len, reverse=True) # Sort symbols by length descending output = [] for word in words: replaced_word = word for symbol in symbols: if symbol in word: replaced_word = word.replace(symbol, f\'[{symbol}]\') break output.append(replaced_word) return output"},{"question":"# Doubly Linked List: Implement Deletion and Reverse Traversal Scenario You are tasked with implementing core functionalities for a doubly linked list class predominantly used in real-time processing of heterogeneous data streams where elements frequently need to be inserted, deleted, and accessed in reverse order. Task Implement a class `DoublyLinkedList` that supports the following methods: 1. **insert_at_head(value)**: Insert a new node with the given value at the head of the list. 2. **delete_by_value(value)**: Delete the first node in the list that has the given value. 3. **reverse_traverse()**: Return a list of values representing the elements of the list traversed from tail to head. Input/Output * `insert_at_head(value)` - **Input**: A value to insert (can be any data type). - **Output**: None * `delete_by_value(value)` - **Input**: A value to delete (can be any data type). - **Output**: None * `reverse_traverse()` - **Input**: None - **Output**: A list of elements in the reverse order Constraints * The list length can be large, but assume it fits in memory. * Handling duplicate keys is required for the `delete_by_value` method. Only the first occurrence needs to be deleted. * Optimize for efficient operations as described in the `DoublyLinkedList` class. Example ```python dll = DoublyLinkedList() dll.insert_at_head(10) dll.insert_at_head(20) dll.insert_at_head(30) dll.delete_by_value(20) print(dll.reverse_traverse()) # Output: [10, 30] ``` Required Implementation ```python class DoublyLinkedListNode: def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def insert_at_head(self, value): # Implement this method pass def delete_by_value(self, value): # Implement this method pass def reverse_traverse(self): # Implement this method pass ```","solution":"class DoublyLinkedListNode: def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def insert_at_head(self, value): new_node = DoublyLinkedListNode(value) if not self.head: self.head = self.tail = new_node else: new_node.next = self.head self.head.prev = new_node self.head = new_node def delete_by_value(self, value): current = self.head while current: if current.value == value: if current.prev: current.prev.next = current.next if current.next: current.next.prev = current.prev if current == self.head: self.head = current.next if current == self.tail: self.tail = current.prev return current = current.next def reverse_traverse(self): values = [] current = self.tail while current: values.append(current.value) current = current.prev return values"},{"question":"You are tasked with designing and implementing a function to build and print a hierarchical tree structure from a given list of records. Each record contains a series of hierarchical components (e.g., categories and subcategories) ending with a numerical value. The function should build a tree (a nested dictionary in Python) and provide a convenient way to print its structure in a readable fashion. Input: A list of tuples, each containing several strings followed by an integer. Each tuple represents a path from the root to a leaf in a tree. For example: ```python records = [ (\'Adam\', \'Book\', 4), (\'Bill\', \'Computer\', 5), (\'Bill\', \'TV\', 6), (\'Jill\', \'Sports\', 1), (\'Bill\', \'Sports\', 3), (\'Adam\', \'Computer\', 3), (\'Quin\', \'Computer\', 3), (\'Quin\', \'Book\', 5), (\'Quin\', \'TV\', 2), (\'Adam\', \'Computer\', 7) ] ``` Output: The tree should be printed in a hierarchical format reflecting the paths defined by the tuples. Each element at each level should be indented further for each level. For example: ``` Adam -> Book -> 4 -> Computer -> 3 -> 7 Bill -> Computer -> 5 -> TV -> 6 -> Sports -> 3 Jill -> Sports -> 1 Quin -> Computer -> 3 -> Book -> 5 -> TV -> 2 ``` # Function Signature: Your task is to implement the following function: ```python def build_and_print_tree(records): # build the tree and print it ``` # Constraints: * The input list of records can contain up to 1000 tuples. * Each tuple will have at least two elements: the path components and a final integer value. * All strings will be non-empty and contain only alphanumeric characters. # Performance Requirements: * Your function should construct and print the tree efficiently. * Pay attention to minimizing redundant operations and consider the time complexity for both building and printing the tree. Ensure that your implementation handles edge cases like: - Empty input list. - Nested paths with the same initial segments. - Proper hierarchical indentation for nested paths.","solution":"def build_and_print_tree(records): from collections import defaultdict import pprint def add_to_tree(tree, parts): if len(parts) == 1: tree[parts[0]] = tree.get(parts[0], parts[-1]) # Add value else: if parts[0] not in tree: tree[parts[0]] = {} add_to_tree(tree[parts[0]], parts[1:]) def print_tree(tree, indent=0): for key, value in tree.items(): if isinstance(value, dict): print(f\'{\\" \\" * indent}{key}\') print_tree(value, indent + 4) else: print(f\'{\\" \\" * indent}{key} -> {value}\') tree = {} for record in records: add_to_tree(tree, record) print_tree(tree) # Example usage records = [ (\'Adam\', \'Book\', 4), (\'Bill\', \'Computer\', 5), (\'Bill\', \'TV\', 6), (\'Jill\', \'Sports\', 1), (\'Bill\', \'Sports\', 3), (\'Adam\', \'Computer\', 3), (\'Quin\', \'Computer\', 3), (\'Quin\', \'Book\', 5), (\'Quin\', \'TV\', 2), (\'Adam\', \'Computer\', 7) ] build_and_print_tree(records)"},{"question":"# B-Tree Implementation and Search Context: You are a software engineer at a database company, and your task is to implement and test a B-Tree, ensuring that it correctly handles search, insertions, deletions, and maintains its balanced property. Your B-Tree will be used to quickly and efficiently manage large sets of data. # Task: Implement the `find`, `insert_key`, and `remove_key` methods in the `BTree` class provided. Ensure your code maintains the tree’s balanced properties through proper node splits and merges. # Specification: 1. **insert_key(key: int) -> None**: - Inserts a key into the B-Tree following B-Tree properties. - If the node is full, splits the node and possibly increases the tree’s height. 2. **find(key: int) -> bool**: - Searches for a key in the B-Tree. - Returns `True` if the key is found, `False` otherwise. 3. **remove_key(key: int) -> None**: - Deletes a key from the B-Tree maintaining the properties of balanced nodes. - Ensures nodes do not fall below minimum keys after deletion. # Constraints: - The degree of the tree `t` will be at least 2. - Keys will be unique integers. - `1 <= key <= 10^6` # Input: - Sequence of operations to insert, find or delete keys in the B-Tree. # Output: - For each `find` operation, return `True` or `False` indicating key presence. # Example: ```python btree = BTree(t_val=3) btree.insert_key(10) btree.insert_key(20) btree.insert_key(5) print(btree.find(10)) # Output: True print(btree.find(15)) # Output: False btree.remove_key(10) print(btree.find(10)) # Output: False ``` Notes: - Ensure the `BTree` maintains its balanced state after each modification. - Thoroughly test edge cases, such as inserting into an empty tree, deleting root elements, etc. # Implementation: ```python # Complete the methods insert_key, find, and remove_key of BTree class provided above. class BTree: # Constructor and other methods remain the same ... def find(self, key: int) -> bool: ... def insert_key(self, key: int): ... def remove_key(self, key: int): ... # Initialize and use B-Tree with degree 3 (Minimum 2 keys, Maximum 5 keys in a node) btree = BTree(t_val=3) btree.insert_key(10) btree.insert_key(20) btree.insert_key(5) print(btree.find(10)) # True print(btree.find(15)) # False btree.remove_key(10) print(btree.find(10)) # False ``` # Evaluation: Your solution will be evaluated based on correctness, efficiency, and the ability to handle edge cases effectively.","solution":"class Node: def __init__(self, t, leaf=False): self.t = t self.keys = [] self.children = [] self.leaf = leaf class BTree: def __init__(self, t_val): self.root = Node(t_val, leaf=True) self.t = t_val def insert_key(self, key): root = self.root if len(root.keys) == 2 * self.t - 1: temp = Node(self.t, False) temp.children.append(self.root) self._split_child(temp, 0) self._insert_non_full(temp, key) self.root = temp else: self._insert_non_full(root, key) def _split_child(self, parent, i): t = self.t y = parent.children[i] z = Node(t, y.leaf) parent.children.insert(i + 1, z) parent.keys.insert(i, y.keys[t - 1]) z.keys = y.keys[t:(2 * t - 1)] y.keys = y.keys[0:(t - 1)] if not y.leaf: z.children = y.children[t:(2 * t)] y.children = y.children[0:t] def _insert_non_full(self, x, key): i = len(x.keys) - 1 if x.leaf: x.keys.append(0) while i >= 0 and key < x.keys[i]: x.keys[i + 1] = x.keys[i] i -= 1 x.keys[i + 1] = key else: while i >= 0 and key < x.keys[i]: i -= 1 i += 1 if len(x.children[i].keys) == 2 * self.t - 1: self._split_child(x, i) if key > x.keys[i]: i += 1 self._insert_non_full(x.children[i], key) def find(self, key): return self._find(self.root, key) def _find(self, node, key): i = 0 while i < len(node.keys) and key > node.keys[i]: i += 1 if i < len(node.keys) and key == node.keys[i]: return True if node.leaf: return False return self._find(node.children[i], key) def remove_key(self, key): self._remove(self.root, key) if len(self.root.keys) == 0: if not self.root.leaf: self.root = self.root.children[0] else: self.root = Node(self.t, leaf=True) def _remove(self, node, key): t = self.t idx = 0 while idx < len(node.keys) and node.keys[idx] < key: idx += 1 if idx < len(node.keys) and node.keys[idx] == key: if node.leaf: node.keys.pop(idx) else: self._remove_internal_node(node, key, idx) elif not node.leaf: flag = (idx == len(node.keys)) if len(node.children[idx].keys) < t: self._fill(node, idx) if flag and idx > len(node.keys): self._remove(node.children[idx - 1], key) else: self._remove(node.children[idx], key) def _remove_internal_node(self, node, key, idx): t = self.t if len(node.children[idx].keys) >= t: pred_key = self._get_pred(node, idx) node.keys[idx] = pred_key self._remove(node.children[idx], pred_key) elif len(node.children[idx + 1].keys) >= t: succ_key = self._get_succ(node, idx) node.keys[idx] = succ_key self._remove(node.children[idx + 1], succ_key) else: self._merge(node, idx) self._remove(node.children[idx], key) def _get_pred(self, node, idx): current = node.children[idx] while not current.leaf: current = current.children[-1] return current.keys[-1] def _get_succ(self, node, idx): current = node.children[idx + 1] while not current.leaf: current = current.children[0] return current.keys[0] def _fill(self, node, idx): t = self.t if idx != 0 and len(node.children[idx - 1].keys) >= t: self._borrow_from_prev(node, idx) elif idx != len(node.keys) and len(node.children[idx + 1].keys) >= t: self._borrow_from_next(node, idx) else: if idx != len(node.keys): self._merge(node, idx) else: self._merge(node, idx - 1) def _borrow_from_prev(self, node, idx): child = node.children[idx] sibling = node.children[idx - 1] child.keys.insert(0, node.keys[idx - 1]) if not child.leaf: child.children.insert(0, sibling.children.pop()) node.keys[idx - 1] = sibling.keys.pop() def _borrow_from_next(self, node, idx): child = node.children[idx] sibling = node.children[idx + 1] child.keys.append(node.keys[idx]) if not child.leaf: child.children.append(sibling.children.pop(0)) node.keys[idx] = sibling.keys.pop(0) def _merge(self, node, idx): t = self.t child = node.children[idx] sibling = node.children[idx + 1] child.keys.append(node.keys.pop(idx)) child.keys.extend(sibling.keys) if not child.leaf: child.children.extend(sibling.children) node.children.pop(idx + 1)"},{"question":"Implement a Custom Stack Problem Description As a software developer, you are required to implement a custom stack to manage function calls for a small embedded system. This stack needs to handle variable allocations based on function depth during execution, ensuring efficient memory usage and minimizing expansion operations. Requirements 1. Implement a custom stack with the following operations: - `push(item)`: Add an item to the top of the stack. - `pop()`: Remove and return the top item of the stack. - `peek()`: Return the top item of the stack without removing it. - `is_empty()`: Return whether the stack is empty. 2. Ensure the stack is based on a static array and supports dynamic resizing. 3. Optimize memory usage by expanding the stack efficiently. Expected Input and Output Format ```python class CustomStack: def __init__(self, initial_size=10): Initializes the stack with an internal array of a given size. The default size is 10. pass def push(self, item): Pushes an item onto the stack. :param item: The item to be pushed onto the stack. :return: None pass def pop(self): Removes and returns the top item from the stack. :return: The top item from the stack. :raises IndexError: If the stack is empty. pass def peek(self): Returns the top item from the stack without removing it. :return: The top item from the stack. :raises IndexError: If the stack is empty. pass def is_empty(self): Returns whether the stack is empty. :return: True if the stack is empty, False otherwise. pass def __str__(self): Returns a string representation of the stack. pass ``` Constraints * Do not use Python\'s built-in list methods for stack operations (except for initialization). * Handle Stack Underflow situations by raising `IndexError`. * Optimize dynamic resizing operations to enhance performance. Example ```python stack = CustomStack() stack.push(10) stack.push(20) stack.push(30) print(stack.pop()) # Output: 30 print(stack.peek()) # Output: 20 print(stack.is_empty()) # Output: False stack.pop() stack.pop() print(stack.is_empty()) # Output: True ```","solution":"class CustomStack: def __init__(self, initial_size=10): Initializes the stack with an internal array of a given size. The default size is 10. self.array = [None] * initial_size self.size = initial_size self.top = -1 def push(self, item): Pushes an item onto the stack. :param item: The item to be pushed onto the stack. :return: None if self.top + 1 == self.size: self.resize() self.top += 1 self.array[self.top] = item def pop(self): Removes and returns the top item from the stack. :return: The top item from the stack. :raises IndexError: If the stack is empty. if self.top == -1: raise IndexError(\\"Pop from an empty stack\\") item = self.array[self.top] self.array[self.top] = None self.top -= 1 return item def peek(self): Returns the top item from the stack without removing it. :return: The top item from the stack. :raises IndexError: If the stack is empty. if self.top == -1: raise IndexError(\\"Peek from an empty stack\\") return self.array[self.top] def is_empty(self): Returns whether the stack is empty. :return: True if the stack is empty, False otherwise. return self.top == -1 def resize(self): Dynamically resizes the internal array when capacity is reached. new_size = self.size * 2 new_array = [None] * new_size for i in range(self.size): new_array[i] = self.array[i] self.size = new_size self.array = new_array def __str__(self): Returns a string representation of the stack. return str([self.array[i] for i in range(self.top + 1)])"},{"question":"Scenario: You are developing a text editor that provides real-time spelling and grammar suggestions. One essential part of this functionality involves comparing user-inputted words with dictionary words to find the best suggestions. To achieve this, you need to implement an algorithm to calculate the edit distance between two words. Problem Statement: Write a Python function named `edit_distance` that calculates the edit distance between two words, `word_a` and `word_b`. The function should return the minimum number of operations required to transform `word_a` into `word_b`. Input: - `word_a`: a string (1 ≤ length ≤ 500) - `word_b`: a string (1 ≤ length ≤ 500) Output: - An integer representing the edit distance between `word_a` and `word_b`. Constraints: - The function should handle cases where either or both strings are empty. - The function must be implemented using dynamic programming. - Ensure your solution is optimized for performance within the given constraints. Example: ```python # Example 1: word_a = \\"kitten\\" word_b = \\"sitting\\" print(edit_distance(word_a, word_b)) # Output: 3 Explanation: kitten -> sitten (substitute \'k\' with \'s\') sitten -> sittin (substitute \'e\' with \'i\') sittin -> sitting (insert \'g\') # Example 2: word_a = \\"flaw\\" word_b = \\"lawn\\" print(edit_distance(word_a, word_b)) # Output: 2 Explanation: flaw -> law (delete \'f\') law -> lawn (insert \'n\') ``` Write your function below: ```python def edit_distance(word_a, word_b): Finds edit distance between word_a and word_b Keyword arguments: word_a -- string word_b -- string # Your implementation here ```","solution":"def edit_distance(word_a, word_b): Calculate the edit distance between two words. Keyword arguments: word_a -- first string word_b -- second string len_a, len_b = len(word_a), len(word_b) # Initialize the DP table dp = [[0] * (len_b + 1) for _ in range(len_a + 1)] # Populate base cases for i in range(len_a + 1): dp[i][0] = i for j in range(len_b + 1): dp[0][j] = j # Compute the edit distance using DP for i in range(1, len_a + 1): for j in range(1, len_b + 1): if word_a[i - 1] == word_b[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = min(dp[i - 1][j] + 1, # Deletion dp[i][j - 1] + 1, # Insertion dp[i - 1][j - 1] + 1) # Substitution return dp[len_a][len_b]"},{"question":"# Question: Implement an Optimized Primality Test You are tasked with implementing an optimized primality test using the Rabin-Miller algorithm. Your implementation should ensure that it handles edge cases, performance bottlenecks, and error scenarios effectively. You will be providing an optimized version of the `is_prime` function. Input: * `n` - A positive integer representing the number to be tested for primality. * `k` - A positive integer representing the number of iterations for the test. Output: * Return `True` if `n` is probably prime with a probability threshold of ( 4^{-k} ), else `False`. Constraints: * ( 2 leq n leq 10^{18} ) * ( 1 leq k leq 100 ) Example: ```python assert is_prime(17, 5) == True assert is_prime(18, 5) == False assert is_prime(7919, 10) == True ``` Notes: 1. Consider using libraries for handling large integers if necessary. 2. Optimize modular exponentiation techniques. 3. Ensure to handle edge cases like small numbers and powers of 2 effectively. Your implementation of `is_prime(n, k)` should be robust, efficient, and account for the elements discussed in the above analysis.","solution":"import random def is_prime(n, k): Perform an optimized primality test using the Rabin-Miller algorithm. Parameters: n (int): The number to test for primality. k (int): The number of iteration tests. Returns: bool: True if n is probably prime with a probability threshold of 4^{-k}, else False. if n <= 1: return False if n <= 3: return True if n % 2 == 0: return False # Write (n - 1) as 2^r * d r, d = 0, n - 1 while d % 2 == 0: r += 1 d //= 2 def miller_rabin_test(a): x = pow(a, d, n) if x == 1 or x == n - 1: return True for _ in range(r - 1): x = pow(x, 2, n) if x == n - 1: return True return False for _ in range(k): a = random.randint(2, n - 2) if not miller_rabin_test(a): return False return True"},{"question":"# Question: Robust Run-Length Encoding and Decoding You are tasked with enhancing and validating a run-length encoding and decoding system. Your mission is to implement two robust functions: 1. `encode_rle(input: str) -> str`: Compresses the input string using run-length encoding. 2. `decode_rle(input: str) -> str`: Decompresses the encoded string back to its original form. Your functions must ensure they handle a variety of edge cases and input constraints effectively. Requirements: - **Encoding**: * Handle empty strings. * Handle strings with unique characters. * Ensure correctly encoding strings with consecutive characters (e.g., \\"AAABBB\\" -> \\"3A3B\\"). - **Decoding**: * Handle empty strings. * Ensure correctly decoding only valid RLE strings where the format follows strictly alternating digit(s) and character(s). Constraints: - Input strings for encoding will only contain lowercase and uppercase alphabets. - Input strings for decoding will strictly maintain correctness. Example: ```python assert encode_rle(\\"\\") == \\"\\" assert encode_rle(\\"AAABBBCCCAAAA\\") == \\"3A3B3C4A\\" assert encode_rle(\\"ABCDE\\") == \\"1A1B1C1D1E\\" assert decode_rle(\\"\\") == \\"\\" assert decode_rle(\\"4A3B2C\\") == \\"AAAABBBCC\\" assert decode_rle(\\"1A1B1C1D1E\\") == \\"ABCDE\\" ``` Implement the functions below: ```python def encode_rle(input: str) -> str: # Your implementation here pass def decode_rle(input: str) -> str: # Your implementation here pass ```","solution":"def encode_rle(input: str) -> str: if not input: return \\"\\" encoded = [] count = 1 prev_char = input[0] for char in input[1:]: if char == prev_char: count += 1 else: encoded.append(f\\"{count}{prev_char}\\") count = 1 prev_char = char encoded.append(f\\"{count}{prev_char}\\") return \\"\\".join(encoded) def decode_rle(input: str) -> str: import re if not input: return \\"\\" decoded = [] pattern = re.compile(r\'(d+)([a-zA-Z])\') for count, char in pattern.findall(input): decoded.append(char * int(count)) return \\"\\".join(decoded)"},{"question":"# Problem: Implement In-Place Merge Sort Given an array `arr` of integers, implement the merge sort algorithm that sorts the array in-place. You are not allowed to use additional space beyond a constant amount for merging. Function Signature: ```python def merge_sort_in_place(arr: List[int]): ``` Input: * `arr`: A list of integers. Output: The function should modify the input list `arr` directly, arranging the elements in non-decreasing order. Constraints: * The function must operate in O(n log(n)) time complexity. * Only a constant amount of extra space (apart from the input list) can be used. Performance Requirements: * The solution should handle large arrays efficiently. Example: ```python arr = [38, 27, 43, 3, 9, 82, 10] merge_sort_in_place(arr) print(arr) # Output: [3, 9, 10, 27, 38, 43, 82] ``` Explanation: In the example above, the array `[38, 27, 43, 3, 9, 82, 10]` is sorted in-place to achieve the sorted array `[3, 9, 10, 27, 38, 43, 82]`. Edge Cases to Consider: * Empty array * Arrays with single element * Arrays where all elements are the same Note: Ensure that your implementation merges the halves of the array without using additional arrays for temporary storage. Consider how you can manage the merging operation to fit within the in-place constraint.","solution":"from typing import List def merge_sort_in_place(arr: List[int]): def merge(arr, start, mid, end): start2 = mid + 1 # If the direct merge is already sorted if arr[mid] <= arr[start2]: return # Two pointers to maintain start of both arrays to merge while start <= mid and start2 <= end: # If element 1 is in right place if arr[start] <= arr[start2]: start += 1 else: value = arr[start2] index = start2 # Shift all the elements between element 1 and element 2, right by 1. while index != start: arr[index] = arr[index - 1] index -= 1 arr[start] = value # Update all the pointers start += 1 mid += 1 start2 += 1 def merge_sort(arr, l, r): if l < r: m = l + (r - l) // 2 merge_sort(arr, l, m) merge_sort(arr, m + 1, r) merge(arr, l, m, r) merge_sort(arr, 0, len(arr) - 1)"},{"question":"You are provided with two variants of the Heap Sort algorithm: `max_heap_sort` and `min_heap_sort`. Your task is to implement a hybrid heap sort method called `hybrid_heap_sort` that dynamically chooses between max heap sort and min heap sort based on the input array. # Objective Write a function `hybrid_heap_sort(arr: List[int], simulation: bool = False) -> List[int]`, which sorts an input array in ascending order using the following approach: - If the majority of elements are in ascending order, use `min_heap_sort`. - If the majority of elements are in descending order, use `max_heap_sort`. - If neither condition is met, you may choose either sorting strategy. # Input - `arr`: List of integers to be sorted. - `simulation` (optional): Boolean flag to print each iteration\'s array state (for educational purposes). # Expected Output - A new list of integers sorted in ascending order. # Constraints - The input array `arr` can have a length in the range `[0, 10^6]`. - Each element in `arr` is an integer between `-10^9` and `10^9`. # Performance Requirements - Time complexity: **O(n log(n))** for average and worst cases. - Space complexity: **O(1)** additional space beyond the input array. # Implementation Hints - Devise a strategy to assess whether the input array is mostly ascending or descending. - Reuse the given `max_heap_sort` and `min_heap_sort` for efficiency. # Example ```python # Example Usage arr = [3, 1, 2, 4, 5] sorted_arr = hybrid_heap_sort(arr, simulation=False) print(sorted_arr) # Output: [1, 2, 3, 4, 5] ```","solution":"def max_heapify(arr, n, i): largest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[left] > arr[largest]: largest = left if right < n and arr[right] > arr[largest]: largest = right if largest != i: arr[i], arr[largest] = arr[largest], arr[i] max_heapify(arr, n, largest) def min_heapify(arr, n, i): smallest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[left] < arr[smallest]: smallest = left if right < n and arr[right] < arr[smallest]: smallest = right if smallest != i: arr[i], arr[smallest] = arr[smallest], arr[i] min_heapify(arr, n, smallest) def max_heap_sort(arr): n = len(arr) for i in range(n // 2 - 1, -1, -1): max_heapify(arr, n, i) for i in range(n - 1, 0, -1): arr[i], arr[0] = arr[0], arr[i] max_heapify(arr, i, 0) return arr def min_heap_sort(arr): n = len(arr) for i in range(n // 2 - 1, -1, -1): min_heapify(arr, n, i) for i in range(n - 1, 0, -1): arr[i], arr[0] = arr[0], arr[i] min_heapify(arr, i, 0) arr.reverse() return arr def hybrid_heap_sort(arr, simulation=False): n = len(arr) if n <= 1: return arr asc_count = sum(1 for i in range(1, n) if arr[i] >= arr[i-1]) desc_count = sum(1 for i in range(1, n) if arr[i] <= arr[i-1]) if asc_count > desc_count: if simulation: print(\\"Determined to use min_heap_sort based on ascending order of elements.\\") return min_heap_sort(arr) elif desc_count > asc_count: if simulation: print(\\"Determined to use max_heap_sort based on descending order of elements.\\") return max_heap_sort(arr) else: # By default choose max_heap_sort if neither condition is met, you may change to min_heap_sort if you prefer. if simulation: print(\\"Choosing max_heap_sort by default.\\") return max_heap_sort(arr)"},{"question":"# Context You are tasked with sorting routines for a small embedded system with limited memory capacity. Due to the simplicity and minimal memory usage of exchange sort, you are to demonstrate an understanding of this algorithm by implementing a variant of it that sorts an array of numbers. # Task Write a function `custom_exchange_sort(arr)` that implements the exchange sort algorithm to sort an array of integers in ascending order. # Input - An array `arr` of integers where (0 leq text{len}(arr) leq 10^3). # Output - Return the sorted array in ascending order. # Constraints - Consider that the input array might be already sorted or contain duplicate values. - The function should handle the edge cases of empty arrays and arrays with a single element properly. # Example ```python print(custom_exchange_sort([34, 2, 23, 67, 45])) # Output: [2, 23, 34, 45, 67] print(custom_exchange_sort([5, 5, 5, 5])) # Output: [5, 5, 5, 5] ```","solution":"def custom_exchange_sort(arr): Implements the exchange sort algorithm to sort an array of integers in ascending order. n = len(arr) for i in range(n-1): for j in range(i+1, n): if arr[i] > arr[j]: arr[i], arr[j] = arr[j], arr[i] return arr"},{"question":"Implement a Customizable Hash Table Problem Statement You are tasked with implementing a **Customizable HashTable** class, a variant of the standard hash table with dynamic resizing and the option to use custom hash functions and collision resolution methods. Your implementation will include the following functionalities: 1. **Initialization** with a customizable size, hash function, and rehash function. 2. **Put** operation to add a new key-value pair. 3. **Get** operation to retrieve the value for a given key. 4. **Delete** operation to remove a key-value pair. 5. **Support for dynamic resizing** when the load factor exceeds a certain threshold, which should also be customizable. 6. **Handle special cases**, including but not limited to collisions, deletions, and attempts to overfill. Function Specifications 1. `__init__(self, size=11, hash_func=None, rehash_func=None, load_factor_threshold=0.66)`: - `size`: Initial size of the hash table. - `hash_func`: Custom hash function. Defaults to `key % size`. - `rehash_func`: Custom rehash function for probing. Defaults to linear probing. - `load_factor_threshold`: The load factor at which the table should resize. Default is `0.66`. 2. `put(self, key, value)`: - Adds the key-value pair into the hash table. - Resizes the table if the current load factor exceeds the threshold. 3. `get(self, key)`: - Returns the value associated with the key. Returns None if the key isn\'t found. 4. `delete(self, key)`: - Deletes the key-value pair with the specified key from the hash table. Expected Input and Output Formats - **Input**: - `put(key: int, value: Any)`: Adds the key-value pair. - `get(key: int) -> Any`: Returns the value for the given key or None. - `delete(key: int)`: Removes the key-value pair. - **Output**: - `get`: Any value type that corresponds to the key or None. Constraints 1. Keys are integers. Values can be any data type. 2. Custom hash and rehash functions should handle edge cases. 3. Implementations should manage memory and handle high volume effectively. Below is the skeleton code to get you started: ```python class CustomizableHashTable(object): def __init__(self, size=11, hash_func=None, rehash_func=None, load_factor_threshold=0.66): self.size = size self._len = 0 self._keys = [None] * size self._values = [None] * size self.hash_func = hash_func if hash_func is not None else lambda key: key % size self.rehash_func = rehash_func if rehash_func is not None else self.default_rehash self.load_factor_threshold = load_factor_threshold def put(self, key, value): # Implementation here pass def get(self, key): # Implementation here pass def delete(self, key): # Implementation here pass def default_rehash(self, old_hash): return (old_hash + 1) % self.size # Additional methods and resizing function def resize(self): # Implementation here pass def load_factor(self): return self._len / self.size ``` Complete the implementation by filling in the `put`, `get`, `delete`, and `resize` methods. Make sure to handle edge cases and ensure that the class works efficiently even for large inputs.","solution":"class CustomizableHashTable(object): def __init__(self, size=11, hash_func=None, rehash_func=None, load_factor_threshold=0.66): self.size = size self._len = 0 self._keys = [None] * size self._values = [None] * size self.hash_func = hash_func if hash_func is not None else lambda key: key % size self.rehash_func = rehash_func if rehash_func is not None else self.default_rehash self.load_factor_threshold = load_factor_threshold def put(self, key, value): if self.load_factor() > self.load_factor_threshold: self.resize() index = self.hash_func(key) while self._keys[index] is not None and self._keys[index] != key: index = self.rehash_func(index) if self._keys[index] is None: self._len += 1 self._keys[index] = key self._values[index] = value def get(self, key): index = self.hash_func(key) while self._keys[index] is not None: if self._keys[index] == key: return self._values[index] index = self.rehash_func(index) return None def delete(self, key): index = self.hash_func(key) while self._keys[index] is not None: if self._keys[index] == key: self._keys[index] = None self._values[index] = None self._len -= 1 self.reinsert_chain(index) return index = self.rehash_func(index) def default_rehash(self, old_hash): return (old_hash + 1) % self.size def resize(self): old_keys = self._keys old_values = self._values self.size *= 2 self._keys = [None] * self.size self._values = [None] * self.size self._len = 0 for i in range(len(old_keys)): if old_keys[i] is not None: self.put(old_keys[i], old_values[i]) def load_factor(self): return self._len / self.size def reinsert_chain(self, index): start_index = self.rehash_func(index) while self._keys[start_index] is not None: key_to_reinsert = self._keys[start_index] value_to_reinsert = self._values[start_index] self._keys[start_index] = None self._values[start_index] = None self._len -= 1 self.put(key_to_reinsert, value_to_reinsert) start_index = self.rehash_func(start_index)"},{"question":"# Regular Expression Matching Given the provided dynamic programming algorithm for regular expression matching, you\'ll implement this algorithm to demonstrate your comprehension of dynamic programming concepts and the handling of special characters in patterns. Problem Statement: Implement regular expression matching with the following rules: - `.` Matches any single character. - `*` Matches zero or more of the preceding element. The function should return whether the entire input string matches the pattern. Requirements - You must implement the function `is_match(s: str, p: str) -> bool` - Inputs `s` and `p` will be non-empty strings that may include lowercase letters, `.` and `*`. - The output should be a boolean indicating whether `s` matches `p`. Constraints: - `1 <= s.length, p.length <= 20` - `s` contains only lowercase English letters. - `p` contains only lowercase English letters, `.` and `*`. Input and Output: - Input: - `s` - the input string to be matched. - `p` - the pattern string containing `.` and `*`. - Output: - Boolean indicating whether the input string `s` matches the pattern `p`. Examples: ```python print(is_match(\\"aa\\", \\"a\\")) # → False print(is_match(\\"aa\\", \\"aa\\")) # → True print(is_match(\\"aaa\\", \\"aa\\")) # → False print(is_match(\\"aa\\", \\"a*\\")) # → True print(is_match(\\"aa\\", \\".*\\")) # → True print(is_match(\\"ab\\", \\".*\\")) # → True print(is_match(\\"aab\\", \\"c*a*b\\")) # → True ``` Detailed Explanation: You need to construct a 2D table `matches` where `matches[i][j]` represents whether the first `i` characters of `s` match the first `j` characters of `p`. Initialize the table and fill it based on the following rules: - If `p[j-1]` is not `*`, set `matches[i][j]` to True if `matches[i-1][j-1]` is True and `s[i-1]` matches `p[j-1]` or `p[j-1]` is `.`. - If `p[j-1]` is `*`, set `matches[i][j]` to True in two cases: - `matches[i][j-2]` is True (we ignore the `*` and preceding character). - `matches[i-1][j]` is True (we use the preceding character one or more times). Your function should return the value at `matches[len(s)][len(p)]` which reflects the match status of entire input string `s` with pattern `p`.","solution":"def is_match(s: str, p: str) -> bool: Returns whether the input string \'s\' matches the pattern \'p\'. # Create a 2D DP table initialized to False dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)] # Empty string matches empty pattern dp[0][0] = True # Handle patterns with \'*\' where it can match zero occurrence of the preceding element for j in range(2, len(p) + 1): if p[j-1] == \'*\': dp[0][j] = dp[0][j-2] # Fill the DP table for i in range(1, len(s) + 1): for j in range(1, len(p) + 1): if p[j-1] == \'.\' or p[j-1] == s[i-1]: dp[i][j] = dp[i-1][j-1] elif p[j-1] == \'*\': dp[i][j] = dp[i][j-2] or (dp[i-1][j] if (p[j-2] == s[i-1] or p[j-2] == \'.\') else False) else: dp[i][j] = False # The result is in dp[len(s)][len(p)] return dp[len(s)][len(p)]"},{"question":"# Problem: You are given a non-negative integer `n`. Your task is to write a function `find_next_perfect_square(n)` that returns the next perfect square greater than `n`. If `n` is not a perfect square, return -1. # Input: - A non-negative integer `n`. # Output: - Returns the next perfect square greater than `n` if `n` is a perfect square. - Returns -1 if `n` is not a perfect square. # Constraints: - `0 <= n <= 10^12` - Aim for a solution with O(1) time complexity. # Example Scenarios: 1. **Input**: `121` - **Output**: `144` - **Explanation**: `121` is a perfect square (11 * 11). The next perfect square is `12 * 12`, which is `144`. 2. **Input**: `10` - **Output**: `-1` - **Explanation**: `10` is not a perfect square. 3. **Input**: `64` - **Output**: `81` - **Explanation**: `64` is a perfect square (8 * 8). The next perfect square is `9 * 9`, which is `81`. # Task: Implement the function `find_next_perfect_square(n)`. ```python def find_next_perfect_square(n): # Calculate the square root of n root = n ** 0.5 # Check if root is an integer if root.is_integer(): # Calculate and return the next perfect square next_root = int(root) + 1 return next_root ** 2 # Return -1 if n is not a perfect square return -1 # Testing the function print(find_next_perfect_square(121)) # Output: 144 print(find_next_perfect_square(10)) # Output: -1 print(find_next_perfect_square(64)) # Output: 81 ```","solution":"def find_next_perfect_square(n): Returns the next perfect square greater than `n` if `n` is a perfect square. Returns -1 if `n` is not a perfect square. root = n ** 0.5 if root.is_integer(): next_root = int(root) + 1 return next_root ** 2 return -1"},{"question":"You have been given a string `s` and a dictionary of words `words_dict`, your task is to determine the number of ways to break the string into a sequence of one or more dictionary words. Implement a function to achieve this. **Function Signature**: ```python def count_sentences(s: str, words_dict: List[str]) -> int: ``` # Input * `s` : A non-empty string of lowercase letters (1 ≤ |s| ≤ 20). * `words_dict` : A list of words, each should be a non-empty string (1 ≤ |words_dict| ≤ 1000). # Output * Return the number of sentences that can be formed from the given string where each word in the sentence is from the dictionary. # Constraints - The same word from the dictionary can be reused multiple times in the sentence. - If no possible sentence can be formed, return 0. # Example Example 1: ```python assert count_sentences(\\"appletablet\\", [\\"apple\\", \\"tablet\\", \\"applet\\", \\"able\\", \\"t\\"]) == 3 ``` Explanation: - The combinations are: - \\"apple\\" + \\"tablet\\" - \\"applet\\" + \\"t\\" + \\"able\\" - \\"apple\\" + \\"table\\" + \\"t\\" Example 2: ```python assert count_sentences(\\"thing\\", [\\"thing\\"]) == 1 ``` Explanation: - The only combination is: - \\"thing\\" # Additional Instructions - Handle recursion limits if using heavy recursive solutions. - Optimize the solution to run within a reasonable time limit given the constraints. # Considerations - Think about how you can use memoization to avoid redundant calculations. - Ensure your solution correctly handles edge cases, such as an empty string or no possible word breaks.","solution":"from typing import List def count_sentences(s: str, words_dict: List[str]) -> int: def helper(s, words_set, memo): if s in memo: return memo[s] if s == \\"\\": return 1 count = 0 for word in words_set: if s.startswith(word): count += helper(s[len(word):], words_set, memo) memo[s] = count return count words_set = set(words_dict) memo = {} return helper(s, words_set, memo)"},{"question":"Scenario You are tasked with developing a function to assist a retail store in analyzing customer purchases. The store\'s system outputs transactions as a sorted list of monetary amounts for different purchases. Your goal is to help the store identify pairs of transactions that sum up to a given target value, where each purchase is used only once. Task Write a function `find_pairs` that receives a sorted list of integers `transactions` (transaction amounts) and an integer `target` (the target sum of two transaction amounts). Return the indices of the two transactions that sum up to the target, where index1 must be less than index2. Note that the indices are 1-based. Input and Output Formats * **Input**: * `transactions`: List of sorted integers, each representing a transaction amount. * `target`: Integer representing the sum of two transaction amounts. * **Output**: * List of two integers representing the 1-based indices of the two transactions that add up to the target. Constraints * Each input list will have exactly one solution. * Transaction amounts are unique. * The list will have at least two elements. * The maximum length of the list is 10^4. * The transaction amounts and target will be non-negative integers. Examples * **Example 1**: ```python find_pairs([2, 7, 11, 15], 9) ``` * **Output**: `[1, 2]` * **Example 2**: ```python find_pairs([1, 3, 5, 7, 9], 10) ``` * **Output**: `[1, 5]` Requirements * Your solution should handle large lists efficiently. * Ensure correctness by considering typical edge cases (e.g., small lists, edge values).","solution":"def find_pairs(transactions, target): Find indices of two transactions that sum up to the target. Args: transactions: List of sorted integers representing transaction amounts. target: Integer representing the target sum of two transaction amounts. Returns: List of two integers representing the 1-based indices of the two transactions. left, right = 0, len(transactions) - 1 while left < right: current_sum = transactions[left] + transactions[right] if current_sum == target: return [left + 1, right + 1] elif current_sum < target: left += 1 else: right -= 1 # Since the problem guarantees one solution, we should never reach here return []"},{"question":"# Context: Simplifying File Paths You are developing a command-line interface (CLI) tool for file management in a Unix-based environment. One of the features required is to simplify file paths provided by users. These paths may include unnecessary navigation such as `.` (current directory) or `..` (parent directory), and redundant slashes. Your task is to implement a function to generate a canonical path from the given Unix-style file paths. # Task Implement the function `simplify_path(path)` where: * `path` (string): A string representing a Unix-style absolute file path. The function should return the canonical file path by: 1. Removing redundant slashes. 2. Resolving `..` (parent directory) and `.` (current directory) segments. 3. Ensuring the result starts with a `/`. # Input * `path`: A non-empty string representing a Unix-style absolute file path, between 1 and 3000 characters in length. # Output * Return a canonical string that represents the simplest version of the given path. # Constraints 1. `path` will always start with a `/`. 2. Segments in `path` are separated by `/`. # Performance Requirement Your function should run in linear time relative to the length of the path. # Examples ```python >>> simplify_path(\\"/home/\\") \\"/home\\" >>> simplify_path(\\"/a/./b/../../c/\\") \\"/c\\" >>> simplify_path(\\"/../\\") \\"/\\" >>> simplify_path(\\"/home//foo/\\") \\"/home/foo\\" ``` Ensure that the function correctly handles all corner cases and adheres to the Unix-style file path simplification rules.","solution":"def simplify_path(path): Simplifies the given Unix-style absolute file path. :param path: A string representing a Unix-style absolute file path. :return: A canonical string that represents the simplest version of the given path. # A stack to keep our simplified path parts stack = [] # Split the input path by \'/\' components = path.split(\\"/\\") for component in components: if component == \\"\\" or component == \\".\\": # Skip empty components and current directory notation continue elif component == \\"..\\": # Handle parent directory notation if stack: stack.pop() else: # Normal directory name, add to stack stack.append(component) # Join the stack to form the canonical path return \\"/\\" + \\"/\\".join(stack)"},{"question":"# Priority Queue Implementation You are tasked with extending the functionality of the given PriorityQueue class to include a method that will remove an element by its value. Problem Statement Extend the PriorityQueue class to implement a method `remove(item)` that removes the given item from the priority queue while maintaining its order based on the current priorities of elements. # Specifications: * **Function Signature**: ```python def remove(self, item: Any) -> bool: ``` * **Parameters**: * `item` - The item to be removed from the priority queue. * **Return**: * Return `True` if the item was successfully removed, `False` otherwise (e.g., if the item does not exist in the priority queue). # Constraints: * Operations must maintain the priority queue properties. * The method should carefully handle cases where the item appears multiple times. * Efficient handling of edge cases such as removing from an empty queue or an item not present in the queue. * The number of elements in the queue can be assumed to fit in memory. Input/Output Examples 1. Given a priority queue with elements [(10, 2), (20, 1), (30, 3)] and invoked `remove(20)`, the state should be updated to [(10, 2), (30, 3)], and return `True`. 2. Given an empty priority queue and invoked `remove(5)`, it should return `False`.","solution":"from heapq import heapify, heappop, heappush from typing import Any, List, Tuple class PriorityQueue: def __init__(self): self.heap: List[Tuple[int, Any]] = [] def push(self, priority: int, item: Any): heappush(self.heap, (priority, item)) def pop(self) -> Any: if not self.heap: return None return heappop(self.heap)[1] def remove(self, item: Any) -> bool: Removes the given item from the priority queue while maintaining order. Parameters: item (Any): The item to remove from the queue. Returns: bool: True if the item was successfully removed, False otherwise. for i in range(len(self.heap)): if self.heap[i][1] == item: del self.heap[i] heapify(self.heap) return True return False"},{"question":"# Scenario: You are tasked with implementing a simple Rehashing Hash Table in Python, designed to store integer keys and their corresponding values. The hash table should support efficient insertion, retrieval, and deletion of keys, and it should automatically resize itself when the load factor exceeds a specified threshold to maintain performance. # Requirements: 1. The hash table initially operates with a size of 11. 2. Implement both linear probing and resizing to handle collisions and load factor exceeding 2/3. 3. Your hash table should support the following operations: - `put(key, value)`: Insert or update a key-value pair. - `get(key)`: Retrieve the value associated with a key. - `del(key)`: Delete a key-value pair. - `len()`: Return the number of key-value pairs stored. - `in(key)`: Check if a key is present in the hash table. # Input and Output: - `put(key, value)`: - **Input:** `key` (integer), `value` (any data type) - **Output:** None - `get(key)`: - **Input:** `key` (integer) - **Output:** `value` (corresponding value or `None` if not found) - `del(key)`: - **Input:** `key` (integer) - **Output:** None - `len()`: - **Input:** None - **Output:** `length` (integer) - `in(key)`: - **Input:** `key` (integer) - **Output:** `True` or `False` # Constraints: - All key values will be positive integers. - You must handle edge cases like collisions and high load factors efficiently. - Your hash table should not use any external libraries for hash table implementation. # Performance Requirements: - Ensure that the average case time complexity of `put`, `get`, and `del` operations is O(1). # Example: ```python # Create a hash table hash_table = HashTable() # Insert key-value pairs hash_table.put(1, \\"Value1\\") hash_table.put(2, \\"Value2\\") # Retrieve values print(hash_table.get(1)) # Output: \\"Value1\\" print(hash_table.get(2)) # Output: \\"Value2\\" # Check presence of keys print(hash_table.in(1)) # Output: True print(hash_table.in(3)) # Output: False # Delete a key hash_table.del(1) # Check length print(len(hash_table)) # Output: 1 # Check presence of keys print(hash_table.in(1)) # Output: False ``` Implement the `HashTable` class as described, ensuring your code efficiently handles all operations and scenarios.","solution":"class HashTable: def __init__(self): self.size = 11 self.count = 0 self.load_factor_threshold = 2/3 self.table = [None] * self.size def hash_function(self, key): return key % self.size def rehash(self): old_table = self.table new_size = self.size * 2 self.size = new_size self.table = [None] * self.size self.count = 0 for item in old_table: if item is not None: key, value = item self.put(key, value) def put(self, key, value): if self.count / self.size > self.load_factor_threshold: self.rehash() index = self.hash_function(key) while self.table[index] is not None: if self.table[index][0] == key: break index = (index + 1) % self.size if self.table[index] is None: self.count += 1 self.table[index] = (key, value) def get(self, key): index = self.hash_function(key) for _ in range(self.size): if self.table[index] is None: return None if self.table[index][0] == key: return self.table[index][1] index = (index + 1) % self.size return None def delete(self, key): index = self.hash_function(key) for _ in range(self.size): if self.table[index] is None: return if self.table[index][0] == key: self.table[index] = None self.count -= 1 next_index = (index + 1) % self.size while self.table[next_index] is not None: k, v = self.table[next_index] self.table[next_index] = None self.count -= 1 self.put(k, v) next_index = (next_index + 1) % self.size return index = (index + 1) % self.size def __len__(self): return self.count def __contains__(self, key): return self.get(key) is not None"},{"question":"# RSA Key Pair Generation and Encryption Objective Your task is to implement the RSA key generation, encryption, and decryption functions. This will test your understanding of modular arithmetic and prime generation, both fundamental concepts in cryptography. # Problem Statement Create a Python function `generate_key_pair(k)` that generates and returns an RSA key pair (encryption key `e` and decryption key `d`) along with the modulus `n`. Additionally, implement two more functions `encrypt(data, e, n)` and `decrypt(data, d, n)` to encrypt and decrypt data respectively. # Functions ```python def generate_key_pair(k): Generates RSA encryption and decryption keys. Parameters: k (int): The number of bits in the modulus. Returns: Tuple[int, int, int]: (n, e, d) where n is the modulus, e is the encryption exponent, and d is the decryption exponent. pass def encrypt(data, e, n): Encrypts a given data using RSA encryption. Parameters: data (int): The plaintext data to be encrypted. e (int): The encryption exponent. n (int): The modulus. Returns: int: The encrypted data. pass def decrypt(data, d, n): Decrypts a given data using RSA decryption. Parameters: data (int): The encrypted data to be decrypted. d (int): The decryption exponent. n (int): The modulus. Returns: int: The decrypted data (plaintext). pass ``` # Constraints 1. `k` is an integer with ( 8 leq k leq 1024 ). 2. `data` is a non-negative integer less than `n`. # Example ```python n, e, d = generate_key_pair(16) data = 20 encrypted = encrypt(data, e, n) decrypted = decrypt(encrypted, d, n) assert decrypted == data print(f\\"Original: {data}, Encrypted: {encrypted}, Decrypted: {decrypted}\\") ``` # Notes 1. Use built-in or widely accepted libraries or mechanisms to test primality efficiently. 2. Ensure proper handling of large integers and modular operations to avoid overflow or computational errors. 3. Carefully consider edge cases such as very large primes, ensuring (e) and (lambda(n)) are coprime.","solution":"import random from math import gcd def is_prime(n, k=128): Test if a number is prime using Miller-Rabin primality test. if n <= 1: return False if n <= 3: return True if n % 2 == 0: return False r, d = 0, n - 1 while d % 2 == 0: r += 1 d //= 2 def miller_rabin_test(a): x = pow(a, d, n) if x == 1 or x == n - 1: return True for _ in range(r - 1): x = pow(x, 2, n) if x == n - 1: return True return False for _ in range(k): a = random.randint(2, n - 2) if not miller_rabin_test(a): return False return True def generate_prime_candidate(length): Generate an odd integer randomly. p = random.getrandbits(length) p |= (1 << length - 1) | 1 return p def generate_prime_number(length): Generate a prime number of specified bit length. p = 4 while not is_prime(p, 128): p = generate_prime_candidate(length) return p def modinv(a, m): Return modular inverse of a mod m. m0, x0, x1 = m, 0, 1 while a > 1: q = a // m m, a = a % m, m x0, x1 = x1 - q * x0, x0 return x1 + m0 if x1 < 0 else x1 def generate_key_pair(k): p = generate_prime_number(k // 2) q = generate_prime_number(k // 2) n = p * q phi = (p - 1) * (q - 1) e = 65537 if gcd(e, phi) != 1: raise ValueError(\\"Invalid RSA key pair generation, try again\\") d = modinv(e, phi) return (n, e, d) def encrypt(data, e, n): return pow(data, e, n) def decrypt(encrypted_data, d, n): return pow(encrypted_data, d, n)"},{"question":"# Question: Efficient Sorting for a Record Management System Context: You are developing a record management system where performance is critical. The system handles sorting of user records based on their ages. Due to performance constraints, you need to replace your current inefficient sorting algorithm (Exchange Sort) with a more efficient algorithm like Merge Sort. Task: Write a function `merge_sort` that sorts an array of integers in ascending order using the Merge Sort algorithm. # Function Signature: ```python def merge_sort(arr: List[int]) -> List[int]: ``` # Input: * `arr`: A list of integers, where 0 <= len(arr) <= 10^5 and each integer lies in the range [0, 10^6]. # Output: * Returns a new list with the elements sorted in ascending order. # Constraints: * Your implementation should have an average and worst-case time complexity of O(n log n). * Memory usage should not exceed O(n). # Example: ```python >>> merge_sort([38, 27, 43, 3, 9, 82, 10]) [3, 9, 10, 27, 38, 43, 82] >>> merge_sort([]) [] ``` Notes: Make sure to handle edge cases like empty arrays or single-element arrays efficiently.","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: Sorts an array of integers in ascending order using the Merge Sort algorithm. if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half) def merge(left: List[int], right: List[int]) -> List[int]: Merges two sorted input lists into a single sorted list. sorted_list = [] left_index, right_index = 0, 0 while left_index < len(left) and right_index < len(right): if left[left_index] <= right[right_index]: sorted_list.append(left[left_index]) left_index += 1 else: sorted_list.append(right[right_index]) right_index += 1 while left_index < len(left): sorted_list.append(left[left_index]) left_index += 1 while right_index < len(right): sorted_list.append(right[right_index]) right_index += 1 return sorted_list"},{"question":"# Scenario You are working on an efficient compression tool that helps reduce the size of large text files. Your task involves implementing functions to compress (encode) and decompress (decode) data using Run-Length Encoding (RLE). RLE compresses data by replacing sequences of the same character with a count followed by the character itself. # Problem Write two functions: `encode_rle` and `decode_rle`. - The `encode_rle` function should take a string as input and return its Run-Length Encoded version. - The `decode_rle` function should take a Run-Length Encoded string and return the original uncompressed string. # Constraints 1. The input strings for both functions will only contain alphabetic characters and numbers representing counts. 2. Both functions should handle empty input strings appropriately. 3. Ensure that the encoding process handles up to maximum character repetitions without error. # Function Specifications Function 1: `encode_rle` **Input**: - `input` (string): A string of characters to be compressed. **Output**: - (string): A Run-Length Encoded string. Function 2: `decode_rle` **Input**: - `input` (string): A Run-Length Encoded string. **Output**: - (string): A decompressed string, representing the original data. # Example ```python # Example for `encode_rle` function: assert encode_rle(\\"aaabbcccc\\") == \\"3a2b4c\\" assert encode_rle(\\"\\") == \\"\\" # Example for `decode_rle` function: assert decode_rle(\\"3a2b4c\\") == \\"aaabbcccc\\" assert decode_rle(\\"\\") == \\"\\" ``` Your implementation should pass these example cases and be capable of handling edge cases efficiently.","solution":"def encode_rle(input): Encodes the input string using Run-Length Encoding. if not input: return \\"\\" encoded_string = \\"\\" count = 1 current_char = input[0] for char in input[1:]: if char == current_char: count += 1 else: encoded_string += f\\"{count}{current_char}\\" current_char = char count = 1 encoded_string += f\\"{count}{current_char}\\" return encoded_string def decode_rle(input): Decodes the input string using Run-Length Decoding. if not input: return \\"\\" decoded_string = \\"\\" count = \\"\\" for char in input: if char.isdigit(): count += char else: decoded_string += char * int(count) count = \\"\\" return decoded_string"},{"question":"# Word Search Algorithm Implementation Context You are tasked with developing a system that can find specific words within a matrix of characters, akin to solving a word search puzzle. This involves checking horizontal, vertical paths to find any of the given words. To accomplish this efficiently, you should use a combination of a Trie data structure and backtracking. # Task Write a function `find_words(board, words)` that searches for words in a given 2D board of characters and returns a list of the words that can be found within the board. The path can only move horizontally or vertically. Function Signature ```python def find_words(board: List[List[str]], words: List[str]) -> List[str]: ``` Input 1. `board`: A 2D list of characters representing the board. 2. `words`: A list of strings representing the words to be searched. Output * A list of strings containing all words found in the board. Constraints * All characters in the board and words are lowercase English letters. * 1 <= board.length, board[i].length <= 12 * 1 <= sum(len(word) for word in words) <= 10^2 * Each word may only be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are horizontally or vertically neighboring. * The same letter cell may not be used more than once per word. Example ```python board = [ [\'o\',\'a\',\'a\',\'n\'], [\'e\',\'t\',\'a\',\'e\'], [\'i\',\'h\',\'k\',\'r\'], [\'i\',\'f\',\'l\',\'v\'] ] words = [\\"oath\\", \\"pea\\", \\"eat\\", \\"rain\\"] # Expected output: [\\"oath\\", \\"eat\\"] print(find_words(board, words)) ``` Notes * Think about efficiently searching for prefixes of words to minimize redundant checks. * Make sure to handle typical edge cases such as overlapping paths and non-existing words in the board efficiently. * Pay attention to performance implications and aim for an optimized and scalable solution.","solution":"from typing import List, Set, Dict, Tuple class TrieNode: def __init__(self): self.children: Dict[str, TrieNode] = {} self.word: str = None def build_trie(words: List[str]) -> TrieNode: root = TrieNode() for word in words: node = root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.word = word return root def find_words(board: List[List[str]], words: List[str]) -> List[str]: def backtrack(node: TrieNode, i: int, j: int): if node.word: found_words.add(node.word) node.word = None if not (0 <= i < len(board) and 0 <= j < len(board[0])): return temp = board[i][j] node = node.children.get(temp) if not node: return board[i][j] = \\"#\\" for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: x, y = i + dx, j + dy backtrack(node, x, y) board[i][j] = temp if not board or not board[0] or not words: return [] trie_root = build_trie(words) found_words = set() for i in range(len(board)): for j in range(len(board[0])): if board[i][j] in trie_root.children: backtrack(trie_root, i, j) return list(found_words)"},{"question":"Merge Sort Optimization **Objective**: Implement an optimized version of the Merge Sort algorithm that reduces space complexity by performing in-place merging. **Context**: Merge Sort is an efficient, stable, comparison-based, divide-and-conquer sorting algorithm. The traditional implementation of Merge Sort requires additional space for the merge operation. In this task, you are required to implement a version that performs the merge operation in-place, thus minimizing the additional space usage. **Task Description**: Implement the following function: ```python def in_place_merge_sort(arr): Sorts an array in ascending order using an optimized version of Merge Sort that performs in-place merging. Parameters: arr (list): A list of comparable elements. Returns: list: The sorted list. pass ``` # Input - **`arr`**: A list of `n` elements, where `1 <= n <= 10^5`. The elements can be integers, floats, or strings. # Output - A list containing the elements of `arr`, sorted in ascending order. # Constraints - Use the Merge Sort algorithm with in-place merging to minimize additional space. - Ensure the solution works efficiently within the given input size constraint. # Performance Requirements - Time Complexity: O(n log(n)) - Space Complexity: O(log(n)) due to the recursive stack. # Example ```python # Example 1 arr = [34, 7, 23, 32, 5, 62] print(in_place_merge_sort(arr)) # Output: [5, 7, 23, 32, 34, 62] # Example 2 arr = [1] print(in_place_merge_sort(arr)) # Output: [1] # Example 3 arr = [4, 4, 4, 4] print(in_place_merge_sort(arr)) # Output: [4, 4, 4, 4] # Example 4 arr = [] print(in_place_merge_sort(arr)) # Output: [] ``` # Approach: In this version, instead of creating new lists during the merge step, adjust the elements directly within the given array to achieve sorting in-place. Take special care to handle index manipulation to avoid overwriting elements prematurely.","solution":"def in_place_merge_sort(arr): Sorts an array in ascending order using an optimized version of Merge Sort that performs in-place merging. Parameters: arr (list): A list of comparable elements. Returns: list: The sorted list. def merge(arr, start, mid, end): if arr[mid] <= arr[mid + 1]: return left = start right = mid + 1 while left <= mid and right <= end: if arr[left] <= arr[right]: left += 1 else: value = arr[right] index = right while index != left: arr[index] = arr[index - 1] index -= 1 arr[left] = value left += 1 mid += 1 right += 1 def merge_sort(arr, start, end): if start < end: mid = (start + end) // 2 merge_sort(arr, start, mid) merge_sort(arr, mid + 1, end) merge(arr, start, mid, end) merge_sort(arr, 0, len(arr) - 1) return arr"},{"question":"# Question: Binary Tree In-Order Traversal You are given the definition of a binary tree node and two functions, `inorder` and `inorder_rec`, which perform in-order traversal of a binary tree using iterative and recursive approaches, respectively. Implement a function `find_kth_smallest_element` that finds the k-th smallest element in a binary search tree (BST). A BST is a binary tree in which each node has at most two children such that: * The left subtree of a node contains only nodes with keys less than the node’s key. * The right subtree of a node contains only nodes with keys greater than the node’s key. * Both the left and right subtrees must also be binary search trees. ```python # Definition for a binary tree node. class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_kth_smallest_element(root: Node, k: int) -> int: # Your code here ``` # Input * The function takes a `Node` representing the root of a BST. * An integer `k`. # Output * The function should return an integer representing the k-th smallest element in the BST. # Constraints * The BST will contain at least k nodes. * 1 <= k <= number of nodes in the BST. # Example ```python # Building the BST root = Node(5) root.left = Node(3) root.right = Node(7) root.left.left = Node(2) root.left.right = Node(4) root.right.left = Node(6) root.right.right = Node(8) # Find the 3rd smallest element print(find_kth_smallest_element(root, 3)) # Output: 4 ``` # Notes * You must utilize the in-order traversal methodologies analyzed and provided in the snippets. * Ensure your implementation handles edge cases such as when the tree is empty or highly skewed. * Think about the efficient way to stop traversal early once you\'ve found the k-th smallest element.","solution":"# Definition for a binary tree node. class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_kth_smallest_element(root: Node, k: int) -> int: Finds the k-th smallest element in a binary search tree (BST). :param root: Node, the root of the BST. :param k: int, the k-th smallest element to find. :return: int, the k-th smallest element in the BST. def inorder_traversal(r): if r is not None: yield from inorder_traversal(r.left) yield r.val yield from inorder_traversal(r.right) gen = inorder_traversal(root) result = None for _ in range(k): result = next(gen) return result"},{"question":"As a junior developer at a software company, you have encountered frequent performance issues with the sorting mechanism in your current codebase. The software currently uses Bubble Sort. You have decided to replace it with Comb Sort for better average performance while keeping space complexity minimal. **Task**: Write a function `comb_sort` that sorts an array of integers in ascending order using the Comb Sort algorithm. **Function Signature**: ```python def comb_sort(arr: List[int]) -> List[int]: ``` **Input**: - `arr`: A list of integers, with length n (0 <= n <= 10^5). **Output**: - Return a list of integers sorted in ascending order. **Constraints**: - The solution must be implemented in place (no additional data structures except variables). - The sorting should be stable and efficient, even for the worst case. **Performance Requirements**: - Ensure that your implementation terminates within reasonable time limits for the input constraints. **Example**: ```python assert comb_sort([5, 2, 9, 1, 5, 6]) == [1, 2, 5, 5, 6, 9] assert comb_sort([4, 3, 7, 8, 2]) == [2, 3, 4, 7, 8] assert comb_sort([]) == [] assert comb_sort([1]) == [1] ``` **Notes**: - Your task is to focus solely on implementing the `comb_sort` function. - Consider edge cases like empty arrays and single-element arrays.","solution":"from typing import List def comb_sort(arr: List[int]) -> List[int]: Sorts the array using Comb Sort algorithm in ascending order. if not arr: # Handling case for empty array return arr n = len(arr) gap = n # Initial gap size shrink_factor = 1.3 # Commonly used shrink factor sorted = False while not sorted: gap = int(gap / shrink_factor) if gap <= 1: gap = 1 sorted = True # Exit loop if no swaps are made i = 0 while i + gap < n: if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] sorted = False # If a swap happened, we can\'t be sure the array is sorted yet i += 1 return arr"},{"question":"# Integer Decomposition Count Scenario: You are developing a feature for number theory software that allows users to compute the number of ways an integer can be decomposed into the sum of positive integers. This feature is essential for various combinatorial and mathematical calculations. Problem Statement: Write a function `integer_decomposition_count(n: int) -> int` that takes a positive integer `n` and returns the number of different ways it can be decomposed into sums of positive integers. Input: - A single integer `n` (1 ≤ n ≤ 1000), representing the number to be decomposed. Output: - An integer representing the number of ways to decompose `n` into sum of positive integers. Example: ```python # Example 1: input: 4 output: 5 Explanation: 4 = 4 4 = 3 + 1 4 = 2 + 2 4 = 2 + 1 + 1 4 = 1 + 1 + 1 + 1 # Example 2: input: 7 output: 15 Explanation: 7 = 7 7 = 6 + 1 7 = 5 + 2 7 = 5 + 1 + 1 7 = 4 + 3 7 = 4 + 2 + 1 7 = 4 + 1 + 1 + 1 7 = 3 + 3 + 1 7 = 3 + 2 + 2 7 = 3 + 2 + 1 + 1 7 = 3 + 1 + 1 + 1 + 1 7 = 2 + 2 + 2 + 1 7 = 2 + 2 + 1 + 1 + 1 7 = 2 + 1 + 1 + 1 + 1 + 1 7 = 1 + 1 + 1 + 1 + 1 + 1 + 1 ``` Constraints: - The solution should be efficient with the complexity limits provided, ideally O(n^2). Function Signature ```python def integer_decomposition_count(n: int) -> int: pass ```","solution":"def integer_decomposition_count(n: int) -> int: Returns the number of ways to decompose the integer n into the sum of positive integers. # Create a list to store the number of ways to decompose each number up to n dp = [0] * (n + 1) dp[0] = 1 # There is one way to decompose 0 (using zero terms) # Iterate over each number from 1 to n for i in range(1, n + 1): # Iterate through dp from i to n backwards for j in range(i, n + 1): dp[j] += dp[j - i] return dp[n]"},{"question":"# Question Graphs are powerful structures used in various applications like social networks, geographic mapping, and more. Understanding how to traverse graphs efficiently and accurately is essential. Implement a function that determines if there exists a path between two nodes in a given graph. **Function Signature**: ```python def is_path_exist(graph, start, end): ... ``` # Input - **graph** (`dict`): A dictionary representing an adjacency list of the graph. Keys are node identifiers and values are lists of adjacent nodes. - **start** (`any`): The starting node. - **end** (`any`): The destination node. # Output - **exists** (`bool`): `True` if there exists a path from `start` to `end`, otherwise `False`. # Constraints - The graph can be directed or undirected. - The graph might contain cycles. - The nodes in the graph are represented by hashable types (e.g., integers, strings). # Example ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'E\'], \'D\': [], \'E\': [\'B\'] } start = \'A\' end = \'D\' assert is_path_exist(graph, start, end) == True start = \'A\' end = \'Z\' assert is_path_exist(graph, start, end) == False ``` In this example, there is a path from \'A\' to \'D\' passing through \'B\', so the function returns `True`. However, there is no path from \'A\' to \'Z\', so the function returns `False`. # Performance Ensure that your solution has a time complexity of O(V + E) and a space complexity of O(V), where V is the number of vertices and E is the number of edges.","solution":"def is_path_exist(graph, start, end): Determines if a path exists between start and end nodes in a given graph. :param graph: Dict representing adjacency list of the graph :param start: Starting node :param end: Destination node :return: True if a path exists, otherwise False if start not in graph or end not in graph: return False visited = set() def dfs(node): if node == end: return True visited.add(node) for neighbor in graph.get(node, []): if neighbor not in visited: if dfs(neighbor): return True return False return dfs(start)"},{"question":"# Integer to Bytes and Vice Versa Conversion **Context**: In data communication, ensuring that integer data is correctly converted to and from byte representations is crucial for interoperability between different systems. This is particularly pertinent when considering systems that use different endian formats. **Task**: Write two functions: 1. `int_to_bytes_big_endian_v2(num: int) -> bytes`: Converts an integer to its big-endian byte representation without using a deque. 2. `bytes_little_endian_to_int_v2(bytestr: bytes) -> int`: Converts a little-endian byte representation to an integer, but this time consider optimization to avoid spurious memory uses. Your implementations should replicate the functionalities provided in the previous snippets with the aforementioned goals. **Constraints**: * The input integer, `num`, will be a non-negative integer (`0 <= num <= 10**18`). * The byte sequence will not exceed 8 bytes in length. **Function signatures**: ```python def int_to_bytes_big_endian_v2(num: int) -> bytes: pass def bytes_little_endian_to_int_v2(bytestr: bytes) -> int: pass ``` **Inputs and Outputs**: 1. **int_to_bytes_big_endian_v2**: * Input: A non-negative integer. * Output: A bytes object representing the integer in big-endian order. 2. **bytes_little_endian_to_int_v2**: * Input: A bytes object representing an integer in little-endian order. * Output: An integer obtained from the bytes object. **Examples**: ```python assert int_to_bytes_big_endian_v2(4660) == b\'x12x34\' assert bytes_little_endian_to_int_v2(b\'x78x56x34x12\') == 305419896 ```","solution":"def int_to_bytes_big_endian_v2(num: int) -> bytes: Converts an integer to its big-endian byte representation. if num == 0: return b\'x00\' byte_array = [] while num > 0: byte_array.append(num & 0xff) num >>= 8 return bytes(byte_array[::-1]) def bytes_little_endian_to_int_v2(bytestr: bytes) -> int: Converts a little-endian byte representation to an integer. result = 0 for i, byte in enumerate(bytestr): result += byte << (i * 8) return result"},{"question":"# Scenario: You are working in a tech company and part of your task is to ensure that the patterns of IDs generated always adhere to certain rules. Recently, your company decided that IDs must be constructed such that they have alternating bits to avoid consecutive same bits which could lead to detection errors in certain legacy systems. You need to write a function that verifies whether a given ID (in the form of a positive integer) satisfies this new requirement. # Problem: Write a function `check_alternating_bits(n: int) -> bool` that takes a positive integer `n` and returns `True` if the binary representation of `n` has alternating bits, otherwise return `False`. **Expected Input and Output:** - **Input:** A single integer `n` (1 <= n <= 2^31 - 1). - **Output:** A boolean value (`True` or `False`). **Constraints:** - Your function should have a time complexity of O(1). # Example: ```python assert check_alternating_bits(5) == True # binary representation 101 assert check_alternating_bits(7) == False # binary representation 111 assert check_alternating_bits(11) == False # binary representation 1011 assert check_alternating_bits(10) == True # binary representation 1010 ``` # Requirements: - Ensure your code handles edge cases such as the smallest and largest values in the given range. - Your solution should emphasize efficient computation, reducing any unnecessary operations, and strictly adhere to the O(1) time complexity constraint.","solution":"def check_alternating_bits(n: int) -> bool: Check if a given number has alternating bits in its binary representation. # XOR n with n >> 1 xor_result = n ^ (n >> 1) # +1 to the xor_result and check if it is a power of 2 return (xor_result & (xor_result + 1)) == 0"},{"question":"Design and implement a class `RandomizedCollection` which supports `insert(val)`, `remove(val)`, and `get_random()`. However, unlike `RandomizedSet`, this collection allows duplicate elements and still guarantees that each element has the same probability of being returned by `get_random()`. **Requirements:** - The `insert(val)` method should add the element to the collection and return `True` if the element was not present before, and `False` otherwise. - The `remove(val)` method should remove one occurrence of the element from the collection and return `True` if the element was present, and `False` otherwise. - The `get_random()` method should return a random element from the collection, where each element has an equal probability of being selected. **Input and Output Format:** - Function calls such as: ```python rc = RandomizedCollection() print(rc.insert(1)) # -> True print(rc.insert(1)) # -> False print(rc.insert(2)) # -> True print(rc.remove(1)) # -> True print(rc.get_random()) # -> Randomly returns either 1 or 2 ``` **Constraints:** - Implementing the above methods must achieve average time complexity of ( O(1) ). - The elements in `RandomizedCollection` can be integers. **Optimization**: Aim to handle edge cases, such as removing elements from an empty collection or handling large datasets.","solution":"import random from collections import defaultdict class RandomizedCollection: def __init__(self): Initialize the data structure. self.vals = [] self.indices = defaultdict(set) def insert(self, val: int) -> bool: Inserts a value to the collection. Returns true if the collection did not already contain the specified element. self.indices[val].add(len(self.vals)) self.vals.append(val) return len(self.indices[val]) == 1 def remove(self, val: int) -> bool: Removes a value from the collection. Returns true if the collection contained the specified element. if not self.indices[val]: return False remove_idx, last_val = self.indices[val].pop(), self.vals[-1] self.vals[remove_idx] = last_val if self.indices[last_val]: self.indices[last_val].add(remove_idx) self.indices[last_val].discard(len(self.vals)-1) self.vals.pop() if not self.indices[val]: del self.indices[val] return True def get_random(self) -> int: Get a random element from the collection. return random.choice(self.vals)"},{"question":"Implement a Secure Bogo Sort One component of a quirky encryption scheme in a security system you\'re auditing uses a very inefficient sorting algorithm, Bogo Sort, enhanced with a secure random number generator rather than Python\'s native `random.shuffle`. The user thinks this provides extra “security” by making it less predictable. Your task is to implement a secure version of Bogo Sort using the `secrets` module to shuffle the array. Since Bogo Sort is impractical for real-world use, you should implement an additional check: If the algorithm executes more than 50,000 iterations without sorting the array, it should abort and return a failure message. **Function Signature:** ```python from typing import List, Union def secure_bogo_sort(arr: List[int]) -> Union[List[int], str]: pass ``` **Input:** - `arr` (List[int]): A list of integers to be sorted. Empty lists and lists with one item should be considered sorted. **Output:** - Returns the sorted list if successfully sorted within 50,000 iterations. - Returns the string `\\"Failed to sort\\"` if sorting is not achieved within the iteration limit. **Constraints:** - The list `arr` can have values ranging from `-10^5` to `10^5` and up to `100` elements. - Use the `secrets` module for shuffling due to its cryptographic suitability. **Example:** ```python print(secure_bogo_sort([3, 1, 2])) # [1, 2, 3] print(secure_bogo_sort([4, 5, 1])) # [1, 4, 5] print(secure_bogo_sort([2, 3, 1, 4, 5, 7])) # [1, 2, 3, 4, 5, 7] print(secure_bogo_sort([])) # [] ``` **Scenario/Context:** This question is inspired by a real-world application\'s misuse of sorting algorithms to highlight the importance and implications of algorithm choice in software design. Implementing a cryptographically secure version of Bogo Sort (while still inefficient) teaches students about security modules and helps them understand the impact of function calls and optimization in critical systems.","solution":"import secrets from typing import List, Union def secure_bogo_sort(arr: List[int]) -> Union[List[int], str]: def is_sorted(arr): return all(arr[i] <= arr[i+1] for i in range(len(arr) - 1)) def shuffle(arr): n = len(arr) for i in range(n): j = secrets.randbelow(n) arr[i], arr[j] = arr[j], arr[i] if len(arr) <= 1: return arr iteration_count = 0 while iteration_count < 50000: if is_sorted(arr): return arr shuffle(arr) iteration_count += 1 return \\"Failed to sort\\""},{"question":"You are given an unsorted array of integers. You need to implement the `pancake_sort` function, which sorts the array using Pancake Sorting algorithm. Your implementation should sort the array in ascending order using the process of repeatedly flipping portions of the array, similar to sorting a stack of pancakes by size. The function should use the following signature: ```python def pancake_sort(arr: List[int]) -> List[int]: ... ``` # Input * A list of integers `arr` where (1 leq text{len}(arr) leq 1000). # Output * Return a list of integers sorted in ascending order. # Performance * The algorithm should run within a time complexity of (O(N^2)). # Example ```python # Sample Input arr = [3, 2, 4, 1] # Sample Output print(pancake_sort(arr)) # Output: [1, 2, 3, 4] ``` # Constraints * It is guaranteed that all integers in the array are unique. # Notes * Make sure to account for edge cases such as empty array or array with one element. * Ensure your implementation does not use any built-in sorting methods (focus on the Pancake Sort logic).","solution":"from typing import List def flip(arr: List[int], k: int) -> None: Reverses the order of the first k elements in the array. arr[:k] = arr[:k][::-1] def find_max_index(arr: List[int], n: int) -> int: Finds the index of the maximum element in arr[0..n-1]. max_index = 0 for i in range(1, n): if arr[i] > arr[max_index]: max_index = i return max_index def pancake_sort(arr: List[int]) -> List[int]: Sort the array using Pancake Sorting algorithm. n = len(arr) for curr_size in range(n, 1, -1): # Find the index of the maximum element in arr[0..curr_size-1] max_index = find_max_index(arr, curr_size) # Move the maximum element to the end of the current array if max_index != curr_size - 1: # Flip the maximum element to the front flip(arr, max_index + 1) # Flip the maximum element to the end flip(arr, curr_size) return arr"},{"question":"Red-Black Tree Balancing Challenge # Objective Implement a feature in the Red-Black Tree (RBTree) data structure provided to balance the tree efficiently after multiple insertions. You will modify the provided class to add a new feature that balances the tree and validate its balanced state. # Problem Statement Consider the existing implementation of the Red-Black Tree. Extend it by implementing a method called `balance_tree` that will ensure the tree is balanced after any number of insertions. This method should: 1. Validate that the Red-Black Tree properties are maintained. 2. Rebalance the tree if any property is violated. 3. Return a boolean indicating whether the tree was already balanced before rebalancing operations. # Function Signature ```python def balance_tree(self) -> bool: pass ``` # Input No direct input aside from the class attributes. # Output A boolean value indicating whether rebalancing was required (False if rebalancing was needed, True if the tree was already balanced). # Constraints 1. You are only allowed to modify the `RBTree` class. 2. Ensure minimal rotations and recoloring operations to achieve rebalancing. 3. You can add helper methods as needed to support your implementation. # Performance Requirements * Maintain average time complexity of O(log n) for insertion operations. * Ensure the balance_tree function runs efficiently without excessive overhead. # Example ```python if __name__ == \\"__main__\\": rb = RBTree() nodes = [11, 2, 14, 1, 7] for node in nodes: rb.insert(RBNode(node, 1)) print(rb.inorder()) # Should print the tree in order with proper colors # Validate balance (calling balance_tree) is_balanced = rb.balance_tree() print(is_balanced) # Should print True if still balanced after insertions ``` # Notes Your implementation should ensure that: * The tree maintains its balance property as per Red-Black tree rules. * The balance_tree method will verify and resolve violations by correct rotations and color fixes.","solution":"class RBNode: def __init__(self, key, color, left=None, right=None, parent=None): self.key = key self.color = color # 1 for Red, 0 for Black self.left = left self.right = right self.parent = parent class RBTree: def __init__(self): self.NIL_LEAF = RBNode(None, 0) self.root = self.NIL_LEAF def insert(self, node): node.parent = node.left = node.right = self.NIL_LEAF if self.root == self.NIL_LEAF: self.root = node else: self._insert_recursive(self.root, node) self._fix_insert(node) def _insert_recursive(self, current, node): if node.key < current.key: if current.left == self.NIL_LEAF: current.left = node node.parent = current else: self._insert_recursive(current.left, node) else: if current.right == self.NIL_LEAF: current.right = node node.parent = current else: self._insert_recursive(current.right, node) def _fix_insert(self, node): while node != self.root and node.parent.color == 1: if node.parent == node.parent.parent.left: uncle = node.parent.parent.right if uncle.color == 1: node.parent.color = 0 uncle.color = 0 node.parent.parent.color = 1 node = node.parent.parent else: if node == node.parent.right: node = node.parent self._rotate_left(node) node.parent.color = 0 node.parent.parent.color = 1 self._rotate_right(node.parent.parent) else: uncle = node.parent.parent.left if uncle.color == 1: node.parent.color = 0 uncle.color = 0 node.parent.parent.color = 1 node = node.parent.parent else: if node == node.parent.left: node = node.parent self._rotate_right(node) node.parent.color = 0 node.parent.parent.color = 1 self._rotate_left(node.parent.parent) self.root.color = 0 def _rotate_left(self, node): right = node.right node.right = right.left if right.left != self.NIL_LEAF: right.left.parent = node right.parent = node.parent if node.parent == self.NIL_LEAF: self.root = right elif node == node.parent.left: node.parent.left = right else: node.parent.right = right right.left = node node.parent = right def _rotate_right(self, node): left = node.left node.left = left.right if left.right != self.NIL_LEAF: left.right.parent = node left.parent = node.parent if node.parent == self.NIL_LEAF: self.root = left elif node == node.parent.right: node.parent.right = left else: node.parent.left = left left.right = node node.parent = left def _is_balanced(self, node): if node == self.NIL_LEAF: return True, 1 if node.color == 1 and (node.left.color == 1 or node.right.color == 1): return False, 0 left_balanced, left_black_height = self._is_balanced(node.left) right_balanced, right_black_height = self._is_balanced(node.right) if left_balanced and right_balanced and left_black_height == right_black_height: black_height = left_black_height + (1 if node.color == 0 else 0) return True, black_height return False, 0 def balance_tree(self): balanced, _ = self._is_balanced(self.root) if balanced: return True else: # Reapply rules to balance the tree nodes = [] self._inorder_with_nil(self.root, nodes) self.root = self.NIL_LEAF for node in nodes: node.color = 1 for node in nodes: self.insert(node) return False def _inorder_with_nil(self, node, nodes): if node != self.NIL_LEAF: self._inorder_with_nil(node.left, nodes) nodes.append(node) self._inorder_with_nil(node.right, nodes)"},{"question":"# Red-Black Tree Deletion Implementation You have been provided with a partial implementation of a Red-Black Tree (a self-balancing binary search tree). The provided code includes the core functionalities for insertion, rotation, and tree management. However, the deletion and its fixing logic (handling the restoration of Red-Black tree properties after deletion) need to be thoroughly tested and extended. Your task is to: 1. **Analyze** the provided code to understand the Red-Black Tree operations. 2. **Implement a function `delete(value)`** to remove a node with the given value from the tree and ensure the tree remains balanced. 3. **Ensure the tree maintains the Red-Black properties** after deletion by implementing necessary rotations and recoloring operations. 4. Write a function `validate_red_black_tree()` that validates if the tree maintains all Red-Black Tree properties. # Input/Output Format * **Function 1**: ```python class RBTree: def delete(self, value): # Find and delete the node with the given value # Ensure the tree remains balanced ``` * **Input**: Integer `value` (0 <= value <= 10^9) representing the value to be deleted. * **Output**: The red-black tree should be updated and balanced after deletion. * **Function 2**: ```python class RBTree: def validate_red_black_tree(self): # Return True if the tree satisfies all Red-Black Tree properties, else False ``` * **Output**: Boolean indicating if the tree is a valid Red-Black Tree. # Constraints and Notes * The tree may initially contain between 0 and 10^5 nodes. * Ensure minimal rebalancing steps to optimize performance. * You can add helper functions inside the class for modularity and better readability. # Example ```python if __name__ == \\"__main__\\": rb = RBTree() elements = [20, 15, 25, 10, 5, 1] for elem in elements: node = RBNode(elem, 1) rb.insert(node) assert rb.validate_red_black_tree() == True print(\\"Initial tree is valid.\\") rb.delete(10) assert rb.validate_red_black_tree() == True print(\\"Tree is valid after deletion.\\") rb.delete(20) assert rb.validate_red_black_tree() == True print(\\"Tree is valid after another deletion.\\") ``` **Scenario**: Consider a scenario where you need to maintain a dynamically ordered dataset (like keep track of a sorted online transaction list). Your job is to ensure that all elements can be quickly looked up, inserted, or deleted while the list remains balanced for optimal performance.","solution":"class RBNode: def __init__(self, value, color, left=None, right=None, parent=None): self.value = value self.color = color # 1 for Red, 0 for Black self.left = left self.right = right self.parent = parent class RBTree: def __init__(self): self.TNULL = RBNode(0, 0) self.root = self.TNULL def insert(self, node): node.parent = None node.left = self.TNULL node.right = self.TNULL node.color = 1 parent = None current = self.root while current != self.TNULL: parent = current if node.value < current.value: current = current.left else: current = current.right node.parent = parent if parent is None: self.root = node elif node.value < parent.value: parent.left = node else: parent.right = node if node.parent is None: node.color = 0 return if node.parent.parent is None: return self.fix_insert(node) def fix_insert(self, k): while k.parent.color == 1: if k.parent == k.parent.parent.right: u = k.parent.parent.left if u.color == 1: u.color = 0 k.parent.color = 0 k.parent.parent.color = 1 k = k.parent.parent else: if k == k.parent.left: k = k.parent self.right_rotate(k) k.parent.color = 0 k.parent.parent.color = 1 self.left_rotate(k.parent.parent) else: u = k.parent.parent.right if u.color == 1: u.color = 0 k.parent.color = 0 k.parent.parent.color = 1 k = k.parent.parent else: if k == k.parent.right: k = k.parent self.left_rotate(k) k.parent.color = 0 k.parent.parent.color = 1 self.right_rotate(k.parent.parent) if k == self.root: break self.root.color = 0 def delete(self, value): self.delete_node_helper(self.root, value) def delete_node_helper(self, node, key): z = self.TNULL while node != self.TNULL: if node.value == key: z = node if node.value <= key: node = node.right else: node = node.left if z == self.TNULL: print(\\"Cannot find key in the tree\\") return y = z y_original_color = y.color if z.left == self.TNULL: x = z.right self.rb_transplant(z, z.right) elif z.right == self.TNULL: x = z.left self.rb_transplant(z, z.left) else: y = self.minimum(z.right) y_original_color = y.color x = y.right if y.parent == z: x.parent = y else: self.rb_transplant(y, y.right) y.right = z.right y.right.parent = y self.rb_transplant(z, y) y.left = z.left y.left.parent = y y.color = z.color if y_original_color == 0: self.fix_delete(x) def fix_delete(self, x): while x != self.root and x.color == 0: if x == x.parent.left: s = x.parent.right if s.color == 1: s.color = 0 x.parent.color = 1 self.left_rotate(x.parent) s = x.parent.right if s.left.color == 0 and s.right.color == 0: s.color = 1 x = x.parent else: if s.right.color == 0: s.left.color = 0 s.color = 1 self.right_rotate(s) s = x.parent.right s.color = x.parent.color x.parent.color = 0 s.right.color = 0 self.left_rotate(x.parent) x = self.root else: s = x.parent.left if s.color == 1: s.color = 0 x.parent.color = 1 self.right_rotate(x.parent) s = x.parent.left if s.left.color == 0 and s.right.color == 0: s.color = 1 x = x.parent else: if s.left.color == 0: s.right.color = 0 s.color = 1 self.left_rotate(s) s = x.parent.left s.color = x.parent.color x.parent.color = 0 s.left.color = 0 self.right_rotate(x.parent) x = self.root x.color = 0 def rb_transplant(self, u, v): if u.parent == None: self.root = v elif u == u.parent.left: u.parent.left = v else: u.parent.right = v v.parent = u.parent def minimum(self, node): while node.left != self.TNULL: node = node.left return node def left_rotate(self, x): y = x.right x.right = y.left if y.left != self.TNULL: y.left.parent = x y.parent = x.parent if x.parent == None: self.root = y elif x == x.parent.left: x.parent.left = y else: x.parent.right = y y.left = x x.parent = y def right_rotate(self, x): y = x.left x.left = y.right if y.right != self.TNULL: y.right.parent = x y.parent = x.parent if x.parent == None: self.root = y elif x == x.parent.right: x.parent.right = y else: x.parent.left = y y.right = x x.parent = y def validate_red_black_tree(self): def is_red_black_node_valid(node): # If a red node has a red child, return False if node.color == 1: if node.left.color == 1 or node.right.color == 1: return False # Perform validations recursively if node != self.TNULL: return (is_red_black_node_valid(node.left) and is_red_black_node_valid(node.right)) return True def black_height(node): if node == self.TNULL: return 1 left_black_height = black_height(node.left) right_black_height = black_height(node.right) if left_black_height != right_black_height or left_black_height == 0: return 0 return left_black_height + (1 if node.color == 0 else 0) if self.root.color != 0: return False return is_red_black_node_valid(self.root) and black_height(self.root) > 0"},{"question":"**Scenario**: You are teaching your students about bitwise operations and their uses in unconventional scenarios such as adding two numbers without using any arithmetic operators. To test their understanding, you want to give them a coding problem to implement the bitwise addition algorithm. **Problem Statement**: Implement a function `bitwise_add(x: int, y: int) -> int` that takes two non-negative integers `x` and `y` and returns their sum without using the \'+\' operator. # Function Signature ```python def bitwise_add(x: int, y: int) -> int: pass ``` # Input - `x`: A non-negative integer (0 <= x <= 10^9). - `y`: A non-negative integer (0 <= y <= 10^9). # Output - The sum of `x` and `y` as a non-negative integer. # Constraints - You may not use arithmetic operators like `+`, `-`, `*`, `/`, etc. - Utilize bitwise operations to achieve the addition. # Example ```python assert bitwise_add(2, 3) == 5 assert bitwise_add(0, 0) == 0 assert bitwise_add(123, 456) == 579 ``` # Explanation - For input `(2, 3)`, the function should return `5` (since 2 + 3 = 5). - For input `(0, 0)`, the function should return `0` (since 0 + 0 = 0). - For input `(123, 456)`, the function should return `579` (since 123 + 456 = 579 using bitwise operations). Write the implementation of `bitwise_add` to pass the provided example cases and any additional cases you may come up with. Make sure to handle edge cases effectively.","solution":"def bitwise_add(x: int, y: int) -> int: Returns the sum of x and y using bitwise operations. while y != 0: carry = x & y x = x ^ y y = carry << 1 return x"},{"question":"You are working as a software engineer tasked with creating an optimized sort function. One of the basic tasks is to work with simple sorting algorithms. Your goal is to implement and enhance a sorting function that uses the insertion sort algorithm. Function Signature ```python def optimized_insertion_sort(arr, simulation=False): Sort an array using an optimized version of insertion sort. Parameters: arr : list[int] : the list of integers to sort simulation : bool : if True, print the array at each iteration Returns: list[int] : the sorted list of integers pass ``` Input - `arr`: A list of integers, where 1 <= len(arr) <= 10^4. - `simulation`: A boolean flag which if set to True, should print the state of the list after completing each iteration of the outer loop. Output - Return the sorted list of integers. Constraints - The function should operate within O(n^2) time complexity. - Optimized insertion techniques, such as binary search for the insertion point, should be considered. - You must ensure the function maintains in-place sorting properties (O(1) additional space, excluding input). Example ```python # Example 1: input_arr = [12, 11, 13, 5, 6] result = optimized_insertion_sort(input_arr) # Expected Output: [5, 6, 11, 12, 13] # Example 2: input_arr = [4, 3, 2, 10, 12, 1, 5, 6] result = optimized_insertion_sort(input_arr) # Expected Output: [1, 2, 3, 4, 5, 6, 10, 12] ``` Requirements In addition to implementing the `optimized_insertion_sort` function: - Handle edge cases, such as empty arrays or arrays with one element. - Ensure the function is stable. - If `simulation` parameter is True, print each iteration of the main loop to visualize the sorting process. - Document potential performance issues and test thoroughly with assorted cases.","solution":"def binary_search(arr, val, start, end): Helper function to perform binary search to find the insertion index. if start == end: if arr[start] > val: return start else: return start + 1 if start > end: return start mid = (start + end) // 2 if arr[mid] < val: return binary_search(arr, val, mid + 1, end) elif arr[mid] > val: return binary_search(arr, val, start, mid - 1) else: return mid def optimized_insertion_sort(arr, simulation=False): Sort an array using an optimized version of insertion sort. Parameters: arr : list[int] : the list of integers to sort simulation : bool : if True, prints the array at each iteration Returns: list[int] : the sorted list of integers for i in range(1, len(arr)): val = arr[i] j = binary_search(arr, val, 0, i - 1) arr = arr[:j] + [val] + arr[j:i] + arr[i+1:] if simulation: print(arr) return arr"},{"question":"# Question: Context: You are given a task to determine the number of unique combinations of numbers from a given list that can achieve a specific target sum. Different permutations of the same combination are considered unique for this task. Assume the list will contain all positive integers and no duplicates. Task: Write a function `count_combinations(nums: List[int], target: int) -> int` that returns the number of possible combinations that add up to `target`. Function Signature: ```python def count_combinations(nums: List[int], target: int) -> int: pass ``` Input: * `nums` - A list of unique positive integers `[n1, n2, ..., nk]` (1 <= ni <= 1000, 1 <= len(nums) <= 100), representing the numbers available for combinations. * `target` - An integer (0 <= target <= 1000) for which you need to find the number of possible unique combinations. Output: * Returns an integer representing the total number of unique combinations that add up to the given target. Constraints: * The input list will contain only positive integers. * Each input combination is counted as unique if different in sequence order even if the numbers are the same. Example: ```python assert count_combinations([1, 2, 3], 4) == 7 ``` Explanation: - The possible combination ways are: (1, 1, 1, 1) (1, 1, 2) (1, 2, 1) (1, 3) (2, 1, 1) (2, 2) (3, 1) **Note**: Different order of the same numbers are treated as unique combinations. Follow-up: If negative numbers are allowed in the given array, how does it change the problem? What specific limitation would you need to add when negative numbers are allowed?","solution":"from typing import List def count_combinations(nums: List[int], target: int) -> int: Returns the number of possible unique combinations that add up to the given target. Combination order matters and is considered unique. # Create a DP array where dp[i] will store the number of combinations to achieve sum i dp = [0] * (target + 1) # Base case: There is 1 way to achieve the target sum of 0 (using no numbers) dp[0] = 1 # Iterate through all possible sums from 1 to target for current_sum in range(1, target + 1): for num in nums: if num <= current_sum: dp[current_sum] += dp[current_sum - num] return dp[target]"},{"question":"# Coding Task: Enhanced String Sorter **Background**: You are tasked with creating an advanced sorting function for a new, high-performance search engine. This engine serves user search queries with rapidly evolving datasets which are typically near-sorted but sometimes may be reversed or contain various unique elements. For this, you want to leverage the principles of Cocktail Shaker Sort due to its bidirectional competence. **Task**: Implement a function `enhanced_string_sorter(strings: List[str]) -> List[str]`. This function should enhance the basic Cocktail Shaker Sort to: 1. Sort an array of strings in ascending lexicographical order. 2. Efficiently handle arrays that contain strings of varying lengths and characters. 3. Implement an early exit if no swaps are detected in a full pass from both directions. **Input**: - `strings`: A list of strings with a maximum length of 10^3. - Each string can contain up to 100 characters including letters, digits, and special symbols. **Output**: - A list of strings sorted in ascending lexicographical order. **Example**: ```python input = [\\"apple\\", \\"banana\\", \\"orange\\", \\"kiwi\\", \\"grape\\"] output = [\\"apple\\", \\"banana\\", \\"grape\\", \\"kiwi\\", \\"orange\\"] input = [\\"Zebra\\", \\"apple\\", \\"Apple\\", \\"banana\\", \\"Banana\\"] output = [\\"Apple\\", \\"Banana\\", \\"Zebra\\", \\"apple\\", \\"banana\\"] ``` **Constraints**: - Optimize the solution to handle early exits when the array becomes sorted during any pass. - The function should handle an array with mixed upper and lower case letters, treating them based on their lexicographical order. **Notes**: 1. Pay attention to case sensitivity; \'A\' should come before \'a\'. 2. Ensure that the function doesn\'t exceed O(N^2) time complexity in the worst case.","solution":"def enhanced_string_sorter(strings): Sorts a list of strings in ascending lexicographical order using Cocktail Shaker Sort. n = len(strings) if n == 0: return strings start = 0 end = n - 1 while start < end: new_end = start new_start = end for i in range(start, end): if strings[i] > strings[i + 1]: strings[i], strings[i + 1] = strings[i + 1], strings[i] new_end = i end = new_end for j in range(end, start, -1): if strings[j] < strings[j - 1]: strings[j], strings[j - 1] = strings[j - 1], strings[j] new_start = j start = new_start return strings"},{"question":"# Problem: Dual Queue Operations # Context: You are tasked with handling essential operations on a queue. This queue implementation should be adaptable, allowing both array-based and linked list-based representations depending on different scenarios. # Objectives: 1. Implement a class `AdvancedQueue` with the following functionalities: - **Switchable Internal Implementation**: It can dynamically switch between using an underlying dynamic array or a linked list for storing elements. - **Queue Operations (Enqueue, Dequeue, Peek, IsEmpty, Size)** # Class `AdvancedQueue`: Methods: - **__init__(self, implementation=\'array\')** - Initializes the queue with the specified internal implementation (either \'array\' or \'linked_list\'). Defaults to \'array\'. - **switch_to_array(self)** - Switches the internal storage to a dynamic array, preserving the current elements. - **switch_to_linked_list(self)** - Switches the internal storage to a linked list, preserving the current elements. # Input/Output: - `enqueue(value)`: Adds an element to the queue. - **Input**: Any comparable type `value` - **Output**: None - `dequeue()`: Removes the front element from the queue. - **Input**: None - **Output**: The front element of the queue - `peek()`: Returns the front element without removing it. - **Input**: None - **Output**: The front element of the queue - `is_empty()`: Tests if the queue is empty. - **Input**: None - **Output**: Boolean - `size()`: Returns the number of elements in the queue. - **Input**: None - **Output**: Integer # Constraints: - The initial internal storage mechanism is set to \'array\' unless specified. - Switching between storage mechanisms should be efficient and maintain the order of elements. Implement the `AdvancedQueue` class and ensure correct functionality of the switching mechanism and standard queue operations. # Example Usage: ```python queue = AdvancedQueue() queue.enqueue(10) queue.enqueue(20) print(queue.dequeue()) # Output: 10 print(queue.peek()) # Output: 20 queue.switch_to_linked_list() queue.enqueue(30) print(queue.size()) # Output: 2 print(queue.dequeue()) # Output: 20 ```","solution":"class AdvancedQueue: def __init__(self, implementation=\'array\'): self.implementation = implementation if implementation == \'array\': self.queue = [] elif implementation == \'linked_list\': self.queue = LinkedList() else: raise ValueError(\\"Invalid implementation type. Must be \'array\' or \'linked_list\'.\\") def switch_to_array(self): if self.implementation == \'linked_list\': items = [] current = self.queue.head while current: items.append(current.value) current = current.next self.queue = items self.implementation = \'array\' def switch_to_linked_list(self): if self.implementation == \'array\': linked_list = LinkedList() for item in self.queue: linked_list.append(item) self.queue = linked_list self.implementation = \'linked_list\' def enqueue(self, value): if self.implementation == \'array\': self.queue.append(value) elif self.implementation == \'linked_list\': self.queue.append(value) def dequeue(self): if self.is_empty(): raise IndexError(\\"Dequeue from an empty queue\\") if self.implementation == \'array\': return self.queue.pop(0) elif self.implementation == \'linked_list\': return self.queue.pop_front() def peek(self): if self.is_empty(): raise IndexError(\\"Peek from an empty queue\\") if self.implementation == \'array\': return self.queue[0] elif self.implementation == \'linked_list\': return self.queue.head.value def is_empty(self): if self.implementation == \'array\': return len(self.queue) == 0 elif self.implementation == \'linked_list\': return self.queue.is_empty() def size(self): if self.implementation == \'array\': return len(self.queue) elif self.implementation == \'linked_list\': return self.queue.size() class LinkedList: class Node: def __init__(self, value): self.value = value self.next = None def __init__(self): self.head = None self.tail = None self._size = 0 def append(self, value): new_node = self.Node(value) if self.tail: self.tail.next = new_node else: self.head = new_node self.tail = new_node self._size += 1 def pop_front(self): if not self.head: raise IndexError(\\"Pop from empty linked list\\") value = self.head.value self.head = self.head.next if not self.head: self.tail = None self._size -= 1 return value def is_empty(self): return self._size == 0 def size(self): return self._size"},{"question":"# Word Search Algorithm Implementation You are required to implement a function that takes a board of characters and a list of words, and returns all the words that can be formed by tracing a continuous path of characters on the board. Each path must use each cell at most once. # Input: - `board`: A 2D list of characters representing the board of characters. For example: ```python board = [ [\'o\', \'a\', \'a\', \'n\'], [\'e\', \'t\', \'a\', \'e\'], [\'i\', \'h\', \'k\', \'r\'], [\'i\', \'f\', \'l\', \'v\'] ] ``` - `words`: A list of strings representing the words to search. For example: ```python words = [\\"oath\\", \\"pea\\", \\"eat\\", \\"rain\\"] ``` # Output: - A list of words from the input list that can be formed by sequentially adjacent cells (horizontally or vertically). The words should be returned in any order. # Constraints: - `1 <= board.length <= 12` - `1 <= board[i].length <= 12` - Each string of words is within the range `[1, 10]` and all characters are lowercase English letters. # Performance Requirements: Ensure optimal time and space complexity. # Function Definition: ```python def find_words(board: List[List[str]], words: List[str]) -> List[str]: # Your code goes here ``` # Example: ```python board = [ [\'o\', \'a\', \'a\', \'n\'], [\'e\', \'t\', \'a\', \'e\'], [\'i\', \'h\', \'k\', \'r\'], [\'i\', \'f\', \'l\', \'v\'] ] words = [\\"oath\\", \\"pea\\", \\"eat\\", \\"rain\\"] assert find_words(board, words) == [\\"oath\\", \\"eat\\"] ``` **Note:** The exact order of words in the output list does not matter. # Additional Notes: - Plan your approach to construct the Trie for efficient prefix searches. - Carefully manage visited cells and backtrack to explore all possible paths.","solution":"from typing import List, Set class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def find_words(board: List[List[str]], words: List[str]) -> List[str]: def backtrack(row, col, parent, path): letter = board[row][col] curr_node = parent.children[letter] if curr_node.is_end_of_word: matched_words.add(\'\'.join(path + [letter])) board[row][col] = \'#\' for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]: new_row, new_col = row + dx, col + dy if 0 <= new_row < len(board) and 0 <= new_col < len(board[0]) and board[new_row][new_col] in curr_node.children: backtrack(new_row, new_col, curr_node, path + [letter]) board[row][col] = letter trie = Trie() for word in words: trie.insert(word) matched_words = set() for row in range(len(board)): for col in range(len(board[0])): if board[row][col] in trie.root.children: backtrack(row, col, trie.root, []) return list(matched_words)"},{"question":"# ZigZag Iteration of Multiple Lists You are required to implement a `ZigZagIteratorK` class that takes k input lists (k ≥ 2) and iterates over them in a \\"zigzag\\" fashion. Your implementation should maintain the order of elements within each list but alternate the elements between lists. # Example Given the input: ```python lists = [ [1, 2, 3], [4, 5], [6, 7, 8, 9] ] iterator = ZigZagIteratorK(lists) result = [] while iterator.has_next(): result.append(iterator.next()) print(result) ``` The output should be: ``` [1, 4, 6, 2, 5, 7, 3, 8, 9] ``` # Function Definitions * The constructor `__init__(self, lists: List[List[int]])` should initialize the iterator with the list of lists. * The method `next(self) -> int` should return the next element in the zigzag sequence. * The method `has_next(self) -> bool` should return whether the iterator has any elements left. # Constraints * The provided lists should be non-null. * The number of lists, k, will be ≥ 2. * You can assume all integers are within typical integer range. # Performance Requirements * The methods `next` and `has_next` should operate in O(1) time complexity if possible. * Use space as efficiently as possible within the requirements.","solution":"from collections import deque from typing import List class ZigZagIteratorK: def __init__(self, lists: List[List[int]]): self.queue = deque((i, 0) for i in range(len(lists)) if lists[i]) self.lists = lists def next(self) -> int: if self.has_next(): list_index, elem_index = self.queue.popleft() value = self.lists[list_index][elem_index] if elem_index + 1 < len(self.lists[list_index]): self.queue.append((list_index, elem_index + 1)) return value else: raise StopIteration(\\"There are no more elements in the iterator\\") def has_next(self) -> bool: return bool(self.queue)"},{"question":"**Problem Statement:** You are tasked with developing a function that generates all possible permutations of a given set of distinct integers. Your function should return the permutations in lexicographic order. Implement the following function: ```python def generate_permutations(nums): Generates all possible permutations of nums in lexicographic order. Parameters: nums (List[int]): A list of distinct integers. Returns: List[List[int]]: A list of lists, each containing a unique permutation of nums. pass ``` **Input:** * `nums`: A list of distinct integers (1 <= len(nums) <= 9). **Output:** * A list of lists, where each inner list is a unique permutation of `nums` in lexicographic order. **Example:** ```python # Example 1: input_nums = [1, 2, 3] output = generate_permutations(input_nums) # output should be: # [ # [1, 2, 3], # [1, 3, 2], # [2, 1, 3], # [2, 3, 1], # [3, 1, 2], # [3, 2, 1] # ] # Example 2: input_nums = [3, 2, 1] output = generate_permutations(input_nums) # output should be: # [ # [1, 2, 3], # [1, 3, 2], # [2, 1, 3], # [2, 3, 1], # [3, 1, 2], # [3, 2, 1] # ] ``` **Constraints:** 1. `nums` contains no duplicates. 2. Consider performance implications for larger inputs. 3. Implement the function such that it is efficient and handles edge cases gracefully.","solution":"from itertools import permutations def generate_permutations(nums): Generates all possible permutations of nums in lexicographic order. Parameters: nums (List[int]): A list of distinct integers. Returns: List[List[int]]: A list of lists, each containing a unique permutation of nums. return sorted(list(permutations(nums)))"},{"question":"# Integer Decomposition Given a positive integer ( n ), write a function `int_divide` that returns the number of ways to sum up to ( n ) using non-negative integers. Each integer in the sum must be greater than or equal to 1. Function Signature ```python def int_divide(decompose: int) -> int: ``` Input * An integer `decompose` ( ( 1 leq text{decompose} leq 1000 ) ). Output * An integer representing the number of unique decompositions of the given integer. Example ```python print(int_divide(4)) # Output: 5 print(int_divide(7)) # Output: 15 ``` Constraints * You must implement the solution using a dynamic programming approach. * The space complexity of your solution should be ( O(n^2) ). Write your function within the following template: ```python def int_divide(decompose): Find the number of decompositions from `decompose`. decompose -- integer # Initialization and base cases arr = [[0 for _ in range(decompose + 1)] for _ in range(decompose + 1)] # Apply the logic for filling the table for i in range(1, decompose + 1): for j in range(1, decompose + 1): if i < j: arr[i][j] = arr[i][i] elif i == j: arr[i][j] = 1 + arr[i][j - 1] else: arr[i][j] = arr[i][j - 1] + arr[i - j][j] return arr[decompose][decompose] ``` Note You do not need to handle invalid input for this problem, assume all input is valid.","solution":"def int_divide(n): Returns the number of unique ways to decompose n into sums of integers >= 1. dp = [[0] * (n + 1) for _ in range(n + 1)] # There is exactly one way to decompose 0 (empty sum) for i in range(n + 1): dp[0][i] = 1 # Fill the dp table for i in range(1, n + 1): for j in range(1, n + 1): if j > i: dp[i][j] = dp[i][i] else: dp[i][j] = dp[i][j-1] + dp[i-j][j] return dp[n][n]"},{"question":"You are given an array of integers. Your task is to implement a function which sorts the array using the Quick Sort algorithm. You should implement an optimized version to handle typical edge cases and avoid performance bottlenecks. # Function Signature ```python def optimized_quick_sort(arr: List[int]) -> List[int]: ``` # Input * A list of integers `arr` with size n (1 <= n <= 10^5). * Every element in `arr` can be any integer in the range -10^9 to 10^9. # Output * A new list with the elements from `arr` sorted in non-decreasing order. # Constraints * Your solution should handle the provided constraints efficiently. * You are not allowed to use Python\'s built-in sorting functions. # Example ```python # Example 1: input_arr = [3, 6, 8, 10, 1, 2, 1] output_arr = optimized_quick_sort(input_arr) assert output_arr == [1, 1, 2, 3, 6, 8, 10] # Example 2: input_arr = [10, 7, 8, 9, 1, 5] output_arr = optimized_quick_sort(input_arr) assert output_arr == [1, 5, 7, 8, 9, 10] # Example 3: input_arr = [0, 0, 0, 0, 0] output_arr = optimized_quick_sort(input_arr) assert output_arr == [0, 0, 0, 0, 0] ``` # Description 1. Implement the `optimized_quick_sort` function. 2. Ensure that your function handles edge cases efficiently: * Empty array. * Array with all identical elements. * Already sorted or reverse-sorted array. 3. Consider using better pivot selection techniques like median-of-three to avoid the worst-case scenario. # Performance Requirements Your solution should execute in (O(n log n)) time on average. In pathological cases, like already sorted arrays, it should still avoid (O(n^2)) performance through proper pivot selection.","solution":"from typing import List def optimized_quick_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr def quick_sort(arr, low, high): if low < high: p = partition(arr, low, high) quick_sort(arr, low, p - 1) quick_sort(arr, p + 1, high) def partition(arr, low, high): pivot = median_of_three(arr, low, high) i = low for j in range(low, high): if arr[j] < pivot: arr[i], arr[j] = arr[j], arr[i] i += 1 arr[i], arr[high] = arr[high], arr[i] return i def median_of_three(arr, low, high): mid = (low + high) // 2 # Order the elements at low, mid, high to get the median if arr[low] > arr[mid]: arr[low], arr[mid] = arr[mid], arr[low] if arr[low] > arr[high]: arr[low], arr[high] = arr[high], arr[low] if arr[mid] > arr[high]: arr[mid], arr[high] = arr[high], arr[mid] # Use the median as the pivot arr[mid], arr[high] = arr[high], arr[mid] return arr[high] quick_sort(arr, 0, len(arr) - 1) return arr"},{"question":"You are given two lists representing large sparse vectors of possibly different lengths. Each list contains floating-point numbers where most of the elements are zeros. You need to write a function that: 1. Converts these sparse vectors into a more efficient storage structure that only stores non-zero elements. 2. Computes the dot product of these vectors from this efficient storage structure. 3. Handles edge cases such as vectors of different lengths and vectors with all elements as zero. Input * `vector1`: A list of floating-point numbers representing the first sparse vector. * `vector2`: A list of floating-point numbers representing the second sparse vector. Output * Returns the dot product of the two sparse vectors. Constraints * The elements in `vector1` and `vector2` can be any floating-point numbers, including zeros. * Vector lengths could be different. Examples ```python assert sparse_vector_dot_product([1.0, 2.0, 3.0], [0.0, 2.0, 2.0]) == 10.0 assert sparse_vector_dot_product([], [0.0, 2.0, 0.0]) == 0.0 assert sparse_vector_dot_product([0.0, 0.0, 0.0], [0.0, 0.0, 0.0]) == 0.0 assert sparse_vector_dot_product([1.0, 0.0], [0.0, 2.0, 2.0]) == 0.0 ``` Implementation Template ```python def vector_to_index_value_list(vector): return [(i, v) for i, v in enumerate(vector) if v != 0.0] def sparse_vector_dot_product(vector1, vector2): iv_list1 = vector_to_index_value_list(vector1) iv_list2 = vector_to_index_value_list(vector2) product = 0 p1 = len(iv_list1) - 1 p2 = len(iv_list2) - 1 while p1 >= 0 and p2 >= 0: i1, v1 = iv_list1[p1] i2, v2 = iv_list2[p2] if i1 < i2: p1 -= 1 elif i2 < i1: p2 -= 1 else: product += v1 * v2 p1 -= 1 p2 -= 1 return product # Example usage: # print(sparse_vector_dot_product([1.0, 2.0, 3.0], [0.0, 2.0, 2.0])) # Should return 10.0 ```","solution":"def vector_to_index_value_list(vector): Converts a vector into an efficient storage structure by keeping index-value pairs of non-zero elements. return [(i, v) for i, v in enumerate(vector) if v != 0.0] def sparse_vector_dot_product(vector1, vector2): Computes the dot product of two sparse vectors represented by lists of floating-point numbers. iv_list1 = vector_to_index_value_list(vector1) iv_list2 = vector_to_index_value_list(vector2) product = 0 p1 = 0 p2 = 0 while p1 < len(iv_list1) and p2 < len(iv_list2): i1, v1 = iv_list1[p1] i2, v2 = iv_list2[p2] if i1 == i2: product += v1 * v2 p1 += 1 p2 += 1 elif i1 < i2: p1 += 1 else: p2 += 1 return product"},{"question":"Anagram Verification You are tasked with writing a function to determine if two input strings are anagrams. Two strings are considered anagrams if they contain the same characters in the same frequency, regardless of order. Function Signature ```python def are_anagrams(s1: str, s2: str) -> bool: pass ``` Input * `s1` (str): The first string. * `s2` (str): The second string. Output * `bool`: Returns `True` if the strings are anagrams, `False` otherwise. Constraints * Both strings consist of lowercase English letters (\'a\' to \'z\') only. * The length of both strings will be between `1` and `10^5`. Performance Requirements * The solution should run efficiently for strings of length up to `10^5`. Example ```python assert are_anagrams(\\"listen\\", \\"silent\\") == True assert are_anagrams(\\"triangle\\", \\"integral\\") == True assert are_anagrams(\\"apple\\", \\"papel\\") == True assert are_anagrams(\\"apple\\", \\"aplee\\") == False ```","solution":"def are_anagrams(s1: str, s2: str) -> bool: Determines if two input strings are anagrams of each other. # If the lengths of the strings are different, they cannot be anagrams. if len(s1) != len(s2): return False # Create dictionaries to count the frequency of each character in both strings. count1 = {} count2 = {} for char in s1: count1[char] = count1.get(char, 0) + 1 for char in s2: count2[char] = count2.get(char, 0) + 1 # Compare the character counts of both strings. return count1 == count2"},{"question":"You are tasked with writing a function to sort an array of integers using the Insertion Sort algorithm. However, there is a twist: The function should simulate the step-by-step process of Insertion Sort and capture each intermediate state into a list for later verification. Problem Statement Implement a function `insertion_sort_with_trace` that takes a list of integers and returns a list of lists, where each inner list represents the state of the array after each full iteration of the outer loop in the Insertion Sort algorithm. Function Signature ```python def insertion_sort_with_trace(arr: List[int]) -> List[List[int]]: ``` Input: * `arr` (List[int]): A list of integers to be sorted. Output: * `List[List[int]]`: A list containing the state of the array after each iteration of the outer loop. The first element should be the state of the initial array. Example: ```python # Example 1 arr = [5, 3, 4, 1, 2] result = insertion_sort_with_trace(arr) # Expected output: # [[5, 3, 4, 1, 2], # [3, 5, 4, 1, 2], # [3, 4, 5, 1, 2], # [1, 3, 4, 5, 2], # [1, 2, 3, 4, 5]] print(result) # Example 2 arr = [1, 2, 3, 4, 5] result = insertion_sort_with_trace(arr) # Expected output: # [[1, 2, 3, 4, 5], # [1, 2, 3, 4, 5], # [1, 2, 3, 4, 5], # [1, 2, 3, 4, 5], # [1, 2, 3, 4, 5]] print(result) ``` Constraints: * The list can contain between 0 and 1000 integers. * Each integer in the list can be between -10000 and 10000. Ensure your implementation is efficient enough to handle the upper limits of input size.","solution":"def insertion_sort_with_trace(arr): Sorts an array of integers using the Insertion Sort algorithm and traces each iteration. Parameters: arr (list of int): A list of integers to be sorted. Returns: list of list of int: A list containing the state of the array after each iteration of the outer loop. trace = [arr.copy()] # Initialize trace with the initial state of array for i in range(1, len(arr)): key = arr[i] j = i - 1 while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key trace.append(arr.copy()) # Record state of array after each iteration return trace"},{"question":"# Pythagorean Theorem Calculation Challenge **Objective**: Write a function that calculates the length of the unknown side of a right-angled triangle using the Pythagorean theorem. Your function should handle invalid inputs appropriately by raising a `ValueError` with a descriptive message. **Function Signature**: ```python def calculate_side(opposite: Union[float, str], adjacent: Union[float, str], hypotenuse: Union[float, str]) -> float: pass ``` **Input**: - `opposite`: A float representing the length of the opposite side or \'?\' if unknown. - `adjacent`: A float representing the length of the adjacent side or \'?\' if unknown. - `hypotenuse`: A float representing the length of the hypotenuse side or \'?\' if unknown. - You can assume that exactly one of the sides will be given as \'?\'. **Output**: - A float representing the length of the unknown side. **Constraints**: - All known side lengths will be positive numbers. - The hypotenuse will always be longer than the other sides. **Performance Requirements**: - Your solution should have a constant time complexity O(1) and constant space complexity O(1). **Examples**: ```python assert abs(calculate_side(\\"?\\", 3, 5) - 4.0) < 1e-9 assert abs(calculate_side(3, \\"?\\", 5) - 4.0) < 1e-9 assert abs(calculate_side(3, 4, \\"?\\") - 5.0) < 1e-9 ``` **Scenario**: Imagine you are building a geometry calculator app that assists students in solving right-angled triangle problems. They\'ve learned the Pythagorean theorem and need an accurate tool to check their manual calculations. Your task is to implement the backend logic for this tool. **Additional Requirements**: - Raise a `ValueError` with a descriptive message for any invalid input (non-numeric values, negative numbers, or when all sides are already known). - Ensure your function is robust and handles edge cases effectively.","solution":"from typing import Union def calculate_side(opposite: Union[float, str], adjacent: Union[float, str], hypotenuse: Union[float, str]) -> float: # Validation: only one side can be \'?\' sides = [opposite, adjacent, hypotenuse] if sides.count(\'?\') != 1: raise ValueError(\\"Exactly one side must be unknown.\\") # Function to parse side or raise ValueError if side is invalid def parse_side(side): if isinstance(side, (int, float)) and side > 0: return float(side) raise ValueError(\\"Sides must be positive numbers or \'?\' to denote the unknown side.\\") # Parse the sides known_sides = [parse_side(side) if side != \'?\' else None for side in sides] # Calculate unknown side using Pythagorean theorem if opposite == \'?\': adjacent, hypotenuse = known_sides[1], known_sides[2] return (hypotenuse**2 - adjacent**2) ** 0.5 elif adjacent == \'?\': opposite, hypotenuse = known_sides[0], known_sides[2] return (hypotenuse**2 - opposite**2) ** 0.5 elif hypotenuse == \'?\': opposite, adjacent = known_sides[0], known_sides[1] return (opposite**2 + adjacent**2) ** 0.5 else: raise ValueError(\\"Invalid input: All sides are known.\\")"},{"question":"# Question Problem Description You are given a problem to determine whether a string, `s`, can be constructed by interleaving two other strings `part1` and `part2`, such that the characters from each part preserve their relative order in the resulting string `s`. Implement a function: ```python def is_merge_dp(s: str, part1: str, part2: str) -> bool: ``` Input - `s` : A string made by merging `part1` and `part2`. - `part1` : First part string. - `part2` : Second part string. Output - Return `True` if `s` is a valid merge of `part1` and `part2`. Otherwise, return `False`. Constraints - Strings `s`, `part1`, and `part2` will consist of lowercase English letters only. - Length of `s` will be at most 1000. - Length of `part1` and `part2` combined will also be at most 1000. Example ```python assert is_merge_dp(\\"codewars\\", \\"cdw\\", \\"oears\\") == True assert is_merge_dp(\\"codewars\\", \\"cod\\", \\"ewars\\") == True assert is_merge_dp(\\"abc\\", \\"a\\", \\"bc\\") == True assert is_merge_dp(\\"abc\\", \\"ab\\", \\"c\\") == True assert is_merge_dp(\\"abc\\", \\"abc\\", \\"\\") == True assert is_merge_dp(\\"abc\\", \\"\\", \\"abc\\") == True assert is_merge_dp(\\"aabcc\\", \\"abc\\", \\"abc\\") == False ``` Edge Cases 1. If `part1` and `part2` combined length does not equal the length of `s`, return `False`. 2. When either `part1` or `part2` is empty, check if `s` is equal to the non-empty part string. Additional Information Optimize your function to run efficiently. A dynamic programming approach is encouraged to maximize performance.","solution":"def is_merge_dp(s: str, part1: str, part2: str) -> bool: # If the combined length of part1 and part2 is not equal to the length of s, return False if len(s) != len(part1) + len(part2): return False # DP table for memoization dp = [[False] * (len(part2) + 1) for _ in range(len(part1) + 1)] dp[0][0] = True # Initialize the dp table for part1 for i in range(1, len(part1) + 1): dp[i][0] = dp[i - 1][0] and part1[i - 1] == s[i - 1] # Initialize the dp table for part2 for j in range(1, len(part2) + 1): dp[0][j] = dp[0][j - 1] and part2[j - 1] == s[j - 1] # Fill in the rest of the dp table for i in range(1, len(part1) + 1): for j in range(1, len(part2) + 1): dp[i][j] = (dp[i - 1][j] and part1[i - 1] == s[i + j - 1]) or (dp[i][j - 1] and part2[j - 1] == s[i + j - 1]) return dp[len(part1)][len(part2)]"},{"question":"# Run-Length Encoding Compression and Decompression Context Run-length encoding (RLE) is a simple yet powerful algorithm for compressing data. It works best on data with lots of sequences of repeated values. Your task is to implement both the compression and decompression functions of the RLE algorithm. Task 1. **Compression**: Implement a function `encode_rle(data: str) -> str` that takes a string and returns the run-length encoded version of the string. 2. **Decompression**: Implement a function `decode_rle(encoded_data: str) -> str` that takes a run-length encoded string and returns the original uncompressed string. Function Signatures ```python def encode_rle(data: str) -> str: pass def decode_rle(encoded_data: str) -> str: pass ``` Input and Output Formats - The `encode_rle` function will receive a string `data`: - Length of `data` will be in the range [0, 10^4]. - `data` will only contain printable ASCII characters. - The `decode_rle` function will receive a string `encoded_data`: - The length of `encoded_data` will be in the range [0, 10^4]. - `encoded_data` will be in valid RLE format with numerical counts followed by a character. Constraints - Your solution should handle the edge cases like empty input strings. - Ensure your solution is efficient in both time and space complexity. - Operate without external libraries. Example ```python # Example 1 data = \\"aaabbbcc\\" print(encode_rle(data)) # Output: \\"3a3b2c\\" encoded_data = \\"3a3b2c\\" print(decode_rle(encoded_data)) # Output: \\"aaabbbcc\\" # Example 2 data = \\"abcd\\" print(encode_rle(data)) # Output: \\"1a1b1c1d\\" encoded_data = \\"1a1b1c1d\\" print(decode_rle(encoded_data)) # Output: \\"abcd\\" ```","solution":"def encode_rle(data: str) -> str: if not data: return \\"\\" encoded = [] count = 1 previous_char = data[0] for char in data[1:]: if char == previous_char: count += 1 else: encoded.append(f\\"{count}{previous_char}\\") count = 1 previous_char = char encoded.append(f\\"{count}{previous_char}\\") return \\"\\".join(encoded) def decode_rle(encoded_data: str) -> str: if not encoded_data: return \\"\\" decoded = [] count = 0 for char in encoded_data: if char.isdigit(): count = count * 10 + int(char) else: decoded.append(char * count) count = 0 return \\"\\".join(decoded)"},{"question":"# Coding Challenge: Circular String Rotation Checker Problem Statement Given two strings s1 and s2, write a function `is_rotated_string(s1, s2)` that returns `True` if s2 is a rotation of s1; otherwise, it returns `False`. Function Signature ```python def is_rotated_string(s1: str, s2: str) -> bool: ``` Input * `s1` (string): The base string to check against. * `s2` (string): The string to verify if it\'s a rotated version of `s1`. Output * Returns `True` if `s2` is a rotation of `s1`, otherwise `False`. Constraints 1. The length of both strings will not exceed 10^5 characters. 2. Strings may contain any printable characters. Example ```python assert is_rotated_string(\\"hello\\", \\"llohe\\") == True assert is_rotated_string(\\"hello\\", \\"helol\\") == False assert is_rotated_string(\\"abcde\\", \\"deabc\\") == True assert is_rotated_string(\\"waterbottle\\",\\"erbottlewat\\") == True assert is_rotated_string(\\"rotation\\",\\"notaroti\\") == False ``` # Additional Information 1. **Performance Requirements**: * The solution must be efficient and handle large inputs gracefully. * Aim for Linear Time Complexity `O(N)` and Space Complexity `O(N)`. 2. **Edge Cases**: * Consider cases where both strings are empty. * Handle cases where strings have different lengths immediately. 3. **Context**: * Imagine this function being used in a system that processes large volumes of text data where efficient and reliable verification of rotational patterns is crucial.","solution":"def is_rotated_string(s1: str, s2: str) -> bool: Checks if s2 is a rotation of s1. Args: s1: Base string to check against. s2: String to verify if it\'s a rotated version of s1. Returns: True if s2 is a rotation of s1, otherwise False. if len(s1) != len(s2): return False if s1 == \\"\\" and s2 == \\"\\": return True return s2 in s1 + s1"},{"question":"Scenario You are working on a project that requires data to be transmitted between different computer systems over a network. These systems adhere to different endianness conventions. To ensure accurate data transmission, you need to implement functions to convert integers to bytes and vice versa in both big-endian and little-endian formats. Problem Write a function `convert_data` that determines the type and endian of a given input and performs the appropriate conversion. The supported types are: - `integer` to bytes - bytes to `integer` The endianness can be either `big_endian` or `little_endian`. Function Signature ```python def convert_data(data, type, endian): Converts data between different types and endianness. Parameters: data (int or bytes): The input data to be converted. type (str): The target type, either \'int\' or \'bytes\'. endian (str): The endianness, either \'big_endian\' or \'little_endian\'. Returns: int or bytes: The converted data. pass ``` # Input/Output Formats * **Input**: * `data`: An integer for conversion to bytes or a byte sequence for conversion to integer. * `type`: A string \'int\' or \'bytes\' indicating the desired output type. * `endian`: A string \'big_endian\' or \'little_endian\' indicating the byte order to use. * **Output**: * The function should return an integer if `type` is \'int\'. * The function should return a byte sequence if `type` is \'bytes\'. # Constraints * `0 <= data <= 2^64 - 1` for integer input. * `len(data) <= 8` for byte input. # Example ```python # Examples of converting integer to big-endian bytes print(convert_data(305419896, \'bytes\', \'big_endian\')) # Output: b\'x12x34x56x78\' # Examples of converting big-endian bytes to integer print(convert_data(b\'x12x34x56x78\', \'int\', \'big_endian\')) # Output: 305419896 # Examples of converting little-endian bytes to integer print(convert_data(b\'xV4x12\', \'int\', \'little_endian\')) # Output: 305419896 # Examples of converting integer to little-endian bytes print(convert_data(305419896, \'bytes\', \'little_endian\')) # Output: b\'xV4x12\' ``` Requirements * Correctly handle different input types and endianness. * Ensure efficient execution for given constraints. * Properly handle edge cases, including the minimum and maximum values.","solution":"def convert_data(data, type, endian): Converts data between different types and endianness. Parameters: data (int or bytes): The input data to be converted. type (str): The target type, either \'int\' or \'bytes\'. endian (str): The endianness, either \'big_endian\' or \'little_endian\'. Returns: int or bytes: The converted data. if type == \'bytes\': # Assuming data is an integer byte_length = (data.bit_length() + 7) // 8 or 1 if endian == \'big_endian\': return data.to_bytes(byte_length, byteorder=\'big\') elif endian == \'little_endian\': return data.to_bytes(byte_length, byteorder=\'little\') elif type == \'int\': # Assuming data is bytes if endian == \'big_endian\': return int.from_bytes(data, byteorder=\'big\') elif endian == \'little_endian\': return int.from_bytes(data, byteorder=\'little\') return None"},{"question":"# Question: Find the nth Digit in a Large Sequence You are tasked with finding the nth digit from an infinite sequence formed by concatenating all the positive integers together: \\"123456789101112...\\". Write a function to find the nth digit in this sequence. Function Signature ```python def find_nth_digit(n: int) -> int: ``` Input - `n`: An integer (1 ≤ n ≤ 10^18) representing the position in the sequence. Output - Returns an integer representing the nth digit in the sequence. Constraints - The input will always be a positive integer. Example ```python assert find_nth_digit(1) == 1 # The 1st digit is \'1\' assert find_nth_digit(10) == 1 # The 10th digit is \'1\' (from the number \'10\') assert find_nth_digit(11) == 0 # The 11th digit is \'0\' (from the number \'10\') assert find_nth_digit(15) == 2 # The 15th digit is \'2\' (from the number \'12\') ``` Explanation - First 9 digits are \'1\' to \'9\'. - The 10th and 11th digits are from the number \'10\'. - Keep expanding the length of numbers considered until you find the range containing the nth digit. Ensure the function efficiently handles very large values of `n` up to 10^18. Objective You should write a function implementing the above algorithm within the provided constraints.","solution":"def find_nth_digit(n: int) -> int: Find the nth digit in the infinite sequence formed by concatenating all the positive integers. Args: - n (int): The position in the sequence. Returns: - int: The digit at the nth position in the sequence. length = 1 count = 9 start = 1 # Determine the length of the number that contains the nth digit while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 # Determine the actual number that contains the nth digit start += (n - 1) // length s = str(start) # Determine the exact digit within the number digit = s[(n - 1) % length] return int(digit)"},{"question":"**Prime Generation with Optimized Prime Check** # Problem Statement You are tasked with writing a function that generates all prime numbers up to a given integer ( n ). Your implementation should leverage the provided `prime_check` function to determine primality efficiently. # Function Signature ```python def generate_primes(n: int) -> List[int]: Generates a list of all prime numbers up to and including n. Parameters: n (int) : The upper limit to which primes need to be found. Returns: List[int]: A list containing all prime numbers up to and including n. ``` # Input * An integer ( n ) where ( 2 leq n leq 10^6 ). # Output * A list of integers. # Example ```python assert generate_primes(10) == [2, 3, 5, 7] assert generate_primes(20) == [2, 3, 5, 7, 11, 13, 17, 19] ``` # Constraints * ( n ) will always be an integer within the specified range. * Performance is critical; take care to ensure the solution handles up to ( 10^6 ) efficiently. # Additional Notes * Please reuse the provided `prime_check` function for primality testing. * Consider edge cases where ( n ) is very small or right on the boundary of prime numbers.","solution":"from typing import List def prime_check(num: int) -> bool: if num <= 1: return False if num == 2 or num == 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while (i * i) <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def generate_primes(n: int) -> List[int]: primes = [] for num in range(2, n + 1): if prime_check(num): primes.append(num) return primes"},{"question":"**Linked List Reversal with Extra Operation** You are working on a linked list library for a text editor that supports various operations on lists of characters. One key operation is to reverse a sublist of the linked list while also converting all characters to uppercase. You need to implement a function `reverse_and_uppercase_sublist` that takes three parameters: 1. `head`: The head node of a singly linked list containing lowercase characters. 2. `m`: The starting position (1-indexed) of the sublist to be reversed. 3. `n`: The ending position (1-indexed) of the sublist to be reversed. The function should return the head of the modified list. If `m` or `n` are out of bounds (less than 1 or greater than the length of the list), you should raise a ValueError. # Example Given the linked list: `a -> b -> c -> d -> e` and `m = 2`, `n = 4`, the resulting list should be: `a -> D -> C -> B -> e`. # Constraints * 1 <= m <= n <= length of list * List nodes contain only lowercase alphabetic characters. # Function Signature The function signature is: ```python def reverse_and_uppercase_sublist(head, m, n): pass ``` # Input and Output Formats - **Input**: * `head` (ListNode): The head of the linked list. * `m` (int): Starting position of the sublist. * `n` (int): Ending position of the sublist. - **Output**: * The head of the modified linked list. # Performance Requirements - The implemented solution should run with a time complexity of O(n) where n is the length of the list. - The space complexity should be O(1), considering only the extra space used for variables. # Example Usage ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next # Building the example list: a -> b -> c -> d -> e head = ListNode(\'a\', ListNode(\'b\', ListNode(\'c\', ListNode(\'d\', ListNode(\'e\'))))) # Function call new_head = reverse_and_uppercase_sublist(head, 2, 4) # Output the list current = new_head while current: print(current.val, end=\' -> \' if current.next else \'n\') ``` Expected Output: ``` a -> D -> C -> B -> e ```","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_and_uppercase_sublist(head, m, n): if m < 1 or n < 1: raise ValueError(\\"Positions m and n must be greater than or equal to 1.\\") # Dummy node to handle edge cases more easily dummy = ListNode(0) dummy.next = head pre = dummy # Move `pre` to the node just before the start of the sublist to be reversed for _ in range(m - 1): if pre is None: raise ValueError(\\"Position m is out of bounds.\\") pre = pre.next # `start` will eventually point to the first node of the reversed sublist # `then` will point to the node that will be reversed start = pre.next then = start.next # Perform the sublist reversal for _ in range(n - m): if then is None: raise ValueError(\\"Position n is out of bounds.\\") start.next = then.next then.next = pre.next pre.next = then then = start.next # Convert the values to uppercase for the reversed segment for _ in range(n - m + 1): if pre.next is None: raise ValueError(\\"Out of bounds when trying to convert to uppercase.\\") pre.next.val = pre.next.val.upper() pre = pre.next return dummy.next"},{"question":"# Comb Sort Algorithm Implementation **Context**: You are developing a software package to manage and sort collections of data. Understanding various sorting algorithms can help you optimize different types of datasets. **Task**: Implement the Comb Sort algorithm as described. **Instructions**: 1. Write a function `comb_sort(arr)` that takes a list of integers, `arr`, as input and returns the sorted list using the Comb Sort algorithm. 2. Aim for an in-place sort (i.e., do not use additional lists for sorting). **Input and Output**: * **Input**: A list of integers, e.g., [34, -50, 42, 0, 13, -5, 7] * **Output**: A sorted list of integers in ascending order, e.g., [-50, -5, 0, 7, 13, 34, 42] **Constraints**: * The list can contain both positive and negative integers. * The list may include duplicate elements. * The length of the list will be at most 10,000 elements. ```python def comb_sort(arr): def swap(i, j): arr[i], arr[j] = arr[j], arr[i] n = len(arr) gap = n shrink = 1.3 sorted = False while not sorted: gap = int(gap / shrink) if gap > 1: sorted = False else: gap = 1 sorted = True i = 0 while i + gap < n: if arr[i] > arr[i + gap]: swap(i, i + gap) sorted = False i += 1 return arr ``` **Examples**: * `comb_sort([34, -50, 42, 0, 13, -5, 7])` -> `[-50, -5, 0, 7, 13, 34, 42]` * `comb_sort([1, 3, 2, 5, 4])` -> `[1, 2, 3, 4, 5]` Ensure that your implementation passes all edge cases discussed and is tested for performance under the defined constraints.","solution":"def comb_sort(arr): def swap(i, j): arr[i], arr[j] = arr[j], arr[i] n = len(arr) gap = n shrink = 1.3 sorted = False while not sorted: gap = int(gap / shrink) if gap > 1: sorted = False else: gap = 1 sorted = True i = 0 while i + gap < n: if arr[i] > arr[i + gap]: swap(i, i + gap) sorted = False i += 1 return arr"},{"question":"# Scenario: Network Latency Minimization You are tasked with optimizing the network routing in a data center, ensuring that the path from the data center\'s main hub to all other servers is the shortest possible path. Some of the network connections might have negative latencies due to high-priority or premium routing channels. # Problem: Implement the Bellman-Ford algorithm to determine whether there exists a feasible shortest path from the hub to any other node, considering the possibility of negative weight cycles. # Function Signature: ```python def check_feasible_shortest_paths(num_servers, connections, hub): :param num_servers: An integer V, the number of servers (vertices) in the network. Each server is labeled from 0 to V-1. :param connections: A list of tuples (u, v, w), representing a directed edge from server u to server v with latency w. :param hub: An integer representing the designated hub (source vertex). :return: Boolean value, True if feasible shortest paths exist from the hub to all reachable servers, False if a negative weight cycle is detected. ``` # Constraints: * (1 leq num_servers leq 1000) * (1 leq text{number of connections} leq 10,000) * Latency weight ( w ) can be negative, positive or zero. * Self-loops or duplicate edges may be present. # Example: ```python num_servers = 5 connections = [ (0, 1, 6), (0, 4, 7), (1, 2, 5), (1, 3, -4), (1, 4, 8), (2, 1, -2), (3, 0, 2), (3, 2, 7), (4, 1, -3) ] hub = 0 assert check_feasible_shortest_paths(num_servers, connections, hub) == True connections.append((4, 3, -10)) assert check_feasible_shortest_paths(num_servers, connections, hub) == False ``` # Explanation: The function `check_feasible_shortest_paths` should implement the Bellman-Ford algorithm to detect if there are any negative weight cycles reachable from the hub. If such a cycle is detected, it returns False indicating an infeasible shortest path scenario. Otherwise, it confirms the presence of feasible shortest paths.","solution":"def check_feasible_shortest_paths(num_servers, connections, hub): Implements the Bellman-Ford algorithm to detect if there is a negative weight cycle reachable from the hub. If there is, it returns False, otherwise it returns True. # Step 1: Initialize distances from source to all other vertices as INFINITE dist = [float(\'inf\')] * num_servers dist[hub] = 0 # Step 2: Relax all edges V-1 times for _ in range(num_servers - 1): for u, v, w in connections: if dist[u] != float(\'inf\') and dist[u] + w < dist[v]: dist[v] = dist[u] + w # Step 3: Check for negative-weight cycles by trying to further relax the edges for u, v, w in connections: if dist[u] != float(\'inf\') and dist[u] + w < dist[v]: return False return True"},{"question":"You\'ve been tasked with creating a function to identify prime numbers within a given range efficiently. Your function will be part of a larger application that relies heavily on prime number calculations. Implement a function `prime_in_range(start: int, end: int) -> List[int]` that will return a list of all prime numbers within the range `[start, end]` inclusive. # Input * `start` (integer): The start of the range (1 ≤ start ≤ 10^6) * `end` (integer): The end of the range (start ≤ end ≤ 10^6) # Output * List of integers: A list containing all prime numbers within the specified range. # Constraints * Your solution should be optimized to handle ranges efficiently, especially for large values close to the upper limit. * Consider edge cases such as small ranges, where there might be no primes at all. # Performance Requirements * The solution should be able to handle the upper range limits within a reasonable time frame. * Aim for an algorithm that can run with improved efficiency over direct application of naive primality testing. # Example ```python prime_in_range(10, 50) # Expected output: [11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47] ``` # Scenario Imagine you\'re working on a system that requires frequent calculations of prime numbers over varying ranges. The efficiency of this function is crucial to ensure the overall performance of the system remains optimal. Write a function: ```python def prime_in_range(start: int, end: int) -> List[int]: pass ``` Solve this problem by leveraging the principles of the given prime checking algorithm and iterating through the specified range to generate the list of prime numbers.","solution":"from typing import List def is_prime(n: int) -> bool: Helper function to determine if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def prime_in_range(start: int, end: int) -> List[int]: Returns a list of all prime numbers within the range [start, end] inclusive. return [num for num in range(start, end + 1) if is_prime(num)]"},{"question":"You are given a list of elements where some of them might be zeros. You need to write a Python function `move_zeros_inplace(array)` that moves all zeros to the end of the array while preserving the order of the non-zero elements. Your implementation should modify the list in place. # Input: * A list `array` of length `n` where `n` can be any non-negative integer. # Output: * The function modifies `array` in place and doesn\'t return anything. # Constraints: * Do not use additional arrays or lists except for a constant amount of extra space. * The implementation should have O(n) time complexity. * The input list may contain non-integer elements, including `False`, which should not be considered as zero. # Examples: ```python array = [False, 1, 0, 1, 2, 0, 1, 3, \\"a\\"] move_zeros_inplace(array) print(array) # Output: [False, 1, 1, 2, 1, 3, \\"a\\", 0, 0] array = [0, \\"zero\\", 2, 0, 0.0, 3] move_zeros_inplace(array) print(array) # Output: [\'zero\', 2, 3, 0, 0, 0.0] ``` # Description: 1. Define a function named `move_zeros_inplace` that takes a single argument `array`. 2. Iterate using a two-pointer approach to swap elements and place zeros at the end. 3. Ensure no additional lists are used for processing the array.","solution":"def move_zeros_inplace(array): Moves all zeros to the end of the list while preserving the order of non-zero elements. # Write index for non-zero elements write_index = 0 for read_index in range(len(array)): if array[read_index] != 0 or type(array[read_index]) is bool: array[write_index] = array[read_index] write_index += 1 for i in range(write_index, len(array)): array[i] = 0"},{"question":"# Stooge Sort Implementation and Analysis Problem Statement: You are required to implement the Stooge Sort algorithm for an array of integers. Use the provided function signature and ensure your implementation is recursive, follows the divide and conquer strategy, and swaps elements as needed to sort the array in non-decreasing order. Additionally, we want you to analyze and handle various edge cases, ensuring efficient memory use. Function Signature: ```python def stooge_sort(arr: list, l: int, h: int) -> None: pass ``` Input: * `arr` (list): A list of integers to be sorted. * `l` (int): The starting index of the portion of the array to sort. * `h` (int): The ending index of the portion of the array to sort. Output: * The function should modify the list in place. No need to return any value. Constraints: * 1 <= len(arr) <= 10^4 * -10^5 <= arr[i] <= 10^5 * Use the original array for the sort (in-place sort). * Handle edge cases such as already sorted arrays, arrays with identical elements, and empty arrays. Example: ```python # Example 1: arr = [3, 5, 2, 9, 1] stooge_sort(arr, 0, len(arr) - 1) print(arr) # Output: [1, 2, 3, 5, 9] # Example 2: arr = [10, 10, 10] stooge_sort(arr, 0, len(arr) - 1) print(arr) # Output: [10, 10, 10] ``` Performance Requirement: * Make sure that your code does not exceed the memory limit because of the recursion stack. If array length is very large, handle stack overflow scenarios efficiently. * Although Stooge Sort is not efficient, ensure your output is correct for all the described edge cases and constraints. Good luck, and happy coding!","solution":"def stooge_sort(arr: list, l: int, h: int) -> None: Stooge Sort is a recursive sorting algorithm. It sorts the array in place. :param arr: List of integers :param l: Starting index :param h: Ending index if l >= h: return # If the element at start is greater than the element at end, swap them if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] # If there are more than two elements in the array if h - l + 1 > 2: t = (h - l + 1) // 3 stooge_sort(arr, l, h - t) stooge_sort(arr, l + t, h) stooge_sort(arr, l, h - t) # Example execution arr = [3, 5, 2, 9, 1] stooge_sort(arr, 0, len(arr) - 1) print(arr) # Output: [1, 2, 3, 5, 9]"},{"question":"# FizzBuzz Challenge You are required to implement a classic programming problem known as \\"FizzBuzz\\". This problem is often used to teach basic control structures in programming. # Problem Description: Write a function `fizzbuzz()` that takes an integer `n` as input and returns an array containing the numbers from 1 to `n`, but with the following rules: 1. For multiples of 3, replace the number with `\\"Fizz\\"`. 2. For multiples of 5, replace the number with `\\"Buzz\\"`. 3. For numbers which are multiples of both 3 and 5, replace the number with `\\"FizzBuzz\\"`. # Input: - An integer `n` where `n >= 1`. # Output: - A list of length `n` containing numbers or strings based on the above rules. # Constraints: - The input integer `n` is guaranteed to be at least 1. - You must validate the input to ensure it is a positive integer. # Example: ```python assert fizzbuzz(15) == [1, 2, \'Fizz\', 4, \'Buzz\', \'Fizz\', 7, 8, \'Fizz\', \'Buzz\', 11, \'Fizz\', 13, 14, \'FizzBuzz\'] assert fizzbuzz(5) == [1, 2, \'Fizz\', 4, \'Buzz\'] ``` # Additional Requirements: 1. Your function should handle invalid input by raising appropriate exceptions. 2. Provide both a direct implementation and an optimized version using a helper function. Take care to write clean, efficient, and readable code.","solution":"def fizzbuzz(n): Returns a list of numbers from 1 to n with multiples of 3 replaced with \\"Fizz\\", multiples of 5 replaced with \\"Buzz\\", and multiples of both 3 and 5 replaced with \\"FizzBuzz\\". :param n: Integer, the upper limit of the range starting from 1. :return: List of numbers and/or strings based on the FizzBuzz rules. :raises: ValueError if n is not a positive integer. if not isinstance(n, int) or n < 1: raise ValueError(\\"Input must be a positive integer.\\") result = [] for i in range(1, n + 1): if i % 15 == 0: result.append(\\"FizzBuzz\\") elif i % 3 == 0: result.append(\\"Fizz\\") elif i % 5 == 0: result.append(\\"Buzz\\") else: result.append(i) return result"},{"question":"# Objective Given an array of integers where every element appears exactly three times except for one element which appears exactly once, write a function to find that unique element using an efficient algorithm with linear time complexity and constant space complexity. # Function Signature ```python def find_unique_element(nums: List[int]) -> int: ``` # Input - `nums`: A list of integers where each integer appears exactly three times except for one integer which appears exactly once. # Output - Returns an integer, the unique element that appears exactly once. # Constraints - The length of the input list will be in the range `[1, 10^5]`. - Each element in the `nums` list will be an integer in the range of `-2^31` to `2^31 - 1`. # Example ```python assert find_unique_element([2, 2, 3, 2]) == 3 assert find_unique_element([0, 1, 0, 1, 0, 1, 99]) == 99 ``` # Requirements - The solution should have a linear runtime complexity. - The solution should not use any extra memory; that is, it should have a constant space complexity. # Note Consider edge cases like an array where the unique number is at the beginning or the end, an array containing negative numbers, and arrays with the maximum possible length and number values.","solution":"from typing import List def find_unique_element(nums: List[int]) -> int: Returns the unique element in the list where each element appears exactly three times except for one. ones, twos = 0, 0 for num in nums: # When num comes the first time, it is added to ones # When num comes the second time, it is removed from ones and added to twos # When num comes the third time, it is removed from both ones and twos ones = (ones ^ num) & ~twos twos = (twos ^ num) & ~ones return ones"},{"question":"# Coding Challenge: Binary Search Tree Depth Calculation **Objective:** Implement a function to calculate the depth of a Binary Search Tree (BST). The depth of a tree is defined as the length of the longest path from the root to a leaf node. **Function Signature:** ```python def calculate_depth(node: Node) -> int: ``` **Parameters:** - `node`: The root node of the Binary Search Tree. **Returns:** - An integer representing the depth of the tree. **Examples:** 1. Given the tree: ``` 10 / 6 15 / / 4 9 12 24 / / 7 20 30 / 18 ``` The function should return `4`. **Constraints:** - The values in the binary search tree are unique. - The tree can be skewed, meaning it can become unbalanced. **Solution Hints:** - Use recursion to calculate the maximum depth of the left and right subtrees. - Base case: the depth of an empty tree (null node) is 0. Write a function to calculate the depth of the given Binary Search Tree.","solution":"class Node: Node class represents each node in the Binary Search Tree. def __init__(self, key): self.left = None self.right = None self.val = key def calculate_depth(node: Node) -> int: Calculate the depth of the binary search tree. if node is None: return 0 else: # Compute depth of each subtree left_depth = calculate_depth(node.left) right_depth = calculate_depth(node.right) # Use the larger one return max(left_depth, right_depth) + 1"},{"question":"# Context You are working as a software engineer at a company that processes data from a wide variety of sources. A common task is to categorize data into distinct groups for further analysis and processing. One such task involves categorizing colored objects into red, white, and blue. # Problem Statement You are given an array `nums` containing `n` objects. Each object is colored red, white, or blue, and you need to sort these objects so that objects of the same color are adjacent, with red objects first, then white, and finally blue. We will use the integers `0`, `1`, and `2` to represent the colors red, white, and blue, respectively. # Tasks 1. Write a function `sort_colors(nums)` that sorts the array `nums` in-place. 2. Do not use the library’s sort function; the goal is to implement the sorting algorithm from scratch. # Input * An array `nums` of length `n`, where `n` is the number of objects and each object is represented by an integer `0`, `1`, or `2`. # Output * The function should modify the input array `nums` in-place, sorting it with the order red (0), white (1), and blue (2). # Constraints * All elements in the array `nums` should be `0`, `1`, or `2`. * Try to solve this task in O(n) time complexity and O(1) space complexity. # Example ```python nums = [2, 0, 2, 1, 1, 0] sort_colors(nums) print(nums) # Output: [0, 0, 1, 1, 2, 2] ```","solution":"def sort_colors(nums): Sorts the array nums in-place so that objects of the same color are adjacent, with the order red (0), white (1), and blue (2). low, mid, high = 0, 0, len(nums) - 1 while mid <= high: if nums[mid] == 0: nums[low], nums[mid] = nums[mid], nums[low] low += 1 mid += 1 elif nums[mid] == 1: mid += 1 else: # nums[mid] == 2 nums[high], nums[mid] = nums[mid], nums[high] high -= 1"},{"question":"You are given an array that may contain duplicate elements. The goal is to write an efficient function to remove the duplicates while preserving the order of the first occurrences of each element. # Function Signature ```python def remove_duplicates(array): # your code here ``` # Input * **array**: A list of elements which may contain duplicates. Elements can be of any data type and can be mixed. The list can have up to (10^6) elements. # Output * Returns a new list with duplicates removed, preserving the order of their first occurrence. # Constraints * Focus on optimizing for time complexity to handle large input sizes. * Avoid using nested loops for membership checks. # Example Input ```python [1, 1 ,1 ,2 ,2 ,3 ,4 ,4 ,\\"hey\\", \\"hey\\", \\"hello\\", True, True] ``` Output ```python [1, 2, 3, 4, \\"hey\\", \\"hello\\"] ``` Scenario / Context Imagine you are dealing with a dataset containing user inputs where duplicates need to be removed to ensure each user\'s input is considered only once. This function would help in cleaning the dataset. # Additional Notes Consider how you can leverage data structures that provide faster membership checks and insertions to optimize the function.","solution":"def remove_duplicates(array): Removes duplicates from the input list while preserving the order of first occurrences. :param array: A list of elements that may contain duplicates. :return: A list with duplicates removed. seen = set() result = [] for item in array: if item not in seen: seen.add(item) result.append(item) return result"},{"question":"You are tasked with implementing a **ResizableHashTable** that extends the functionalities provided in the **HashTable** class. Your implementation should handle dynamic resizing (doubling the size) when the table becomes 70% full to ensure performance efficiency. Implement the class **ResizableHashTable** with the following functions: Function: put ```python def put(self, key: int, value: int) -> None: ``` **Description**: * Inserts the key-value pair into the hash table. * If the table is 70% full after insertion, resize the table by doubling its size. Function: resize ```python def _resize(self) -> None: ``` **Description**: * Resize the hash table to double its current size and rehash all existing key-value pairs into the new table. Class Properties The `ResizableHashTable` class should have the following properties inherited from `HashTable`: * `_empty` and `_deleted` objects to mark empty and deleted slots. * `_keys` to hold keys and `_values` to hold values. * `hash` and `_rehash` functions for linear probing and collision management. # Input/Output **Constraints**: * All keys and values will be non-negative integers. * Initial table size is constrained to a small integer (e.g., 11) for better illustration but ensure your implementation works for large sizes. # Example ```python # Example usage ht = ResizableHashTable() ht.put(1, 100) ht.put(12, 200) # Causes rehash since key 12 collides with key 1 print(ht.get(1)) # Output: 100 print(ht.get(12)) # Output: 200 for i in range(20): ht.put(i, i*10) # should trigger resizing multiple times print(len(ht)) # Should print the correct number of items inserted ```","solution":"class HashTable: _empty = object() _deleted = object() def __init__(self, size=11): self._keys = [self._empty] * size self._values = [self._empty] * size self._size = 0 def hash(self, key): return key % len(self._keys) def _rehash(self, old_hash): return (old_hash + 1) % len(self._keys) def put(self, key, value): hash_value = self.hash(key) while self._keys[hash_value] not in (self._empty, self._deleted, key): hash_value = self._rehash(hash_value) if self._keys[hash_value] in (self._empty, self._deleted): self._size += 1 self._keys[hash_value] = key self._values[hash_value] = value def get(self, key): start_slot = self.hash(key) position = start_slot while self._keys[position] != self._empty: if self._keys[position] == key: return self._values[position] position = self._rehash(position) if position == start_slot: return None return None def __len__(self): return self._size class ResizableHashTable(HashTable): def put(self, key, value): super().put(key, value) if self._size / len(self._keys) > 0.7: self._resize() def _resize(self): old_keys = self._keys old_values = self._values new_size = len(self._keys) * 2 self._keys = [self._empty] * new_size self._values = [self._empty] * new_size self._size = 0 for key, value in zip(old_keys, old_values): if key not in (self._empty, self._deleted): self.put(key, value)"},{"question":"**Base Conversion Implementation** Write a function that performs both integer-to-base and base-to-integer conversions more robustly. The function should validate the inputs and handle errors gracefully. # Function Signature: `def convert_number(number, from_base, to_base) -> str` # Input: * `number` (str|int): The number to convert. Could be an integer (in case of integer to base conversion) or a string representing the number in a given base (in case of base to integer conversion). * `from_base` (int): The base of the input number. For integer input, this should be 10. * `to_base` (int): The base to convert the input number to. # Output: * `str`: The converted number as a string. The function should return: * \'ERROR\' for invalid inputs. * \'0\' if the input represents zero. * The converted string representation of the number in the target base. # Constraints: * 2 <= from_base, to_base <= 36 * number will be non-negative if `from_base` is 10. * For bases greater than 10, use digits followed by uppercase English letters. # Examples: ```python assert(convert_number(5, 10, 2) == \'101\') assert(convert_number(\'F\', 16, 10) == \'15\') assert(convert_number(\'101\', 2, 10) == \'5\') assert(convert_number(\'3F\', 16, 8) == \'77\') assert(convert_number(\'101\', 2, 36) == \'5\') assert(convert_number(\'-5\', 10, 2) == \'ERROR\') assert(convert_number(\'101\', 40, 2) == \'ERROR\') ``` # Notes: * Input validation should consider possible alphabet and digit mismatching according to the bases provided. * Handle large strings properly, maintaining performance within reasonable limits.","solution":"def convert_number(number, from_base, to_base) -> str: Convert a number from one base to another. Args: number (str|int): The number to convert. from_base (int): The base of the input number. to_base (int): The base to convert the input number to. Returns: str: The converted number as a string, or \'ERROR\' for invalid inputs. if not (2 <= from_base <= 36 and 2 <= to_base <= 36): return \'ERROR\' if from_base == 10: number_str = str(number) # Convert from base 10 to target base if not number_str.isdigit(): return \'ERROR\' number = int(number_str) else: number = str(number) # Check for valid characters in the base valid_chars = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\"[:from_base] for char in number: if char.upper() not in valid_chars: return \'ERROR\' # Convert from the given base to base 10 try: number = int(number, from_base) except ValueError: return \'ERROR\' digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" if number == 0: return \'0\' # Convert base 10 number to the target base result = [] while number > 0: result.append(digits[number % to_base]) number //= to_base return \'\'.join(reversed(result))"},{"question":"You are tasked with writing a function that computes the next higher number using the exact same set of digits as the given number. This function should take an integer as input and return the next higher number composed by rearranging its digits. If no such number exists (i.e., the number is the highest possible permutation of its digits), return `-1`. Function Signature ```python def next_bigger(number: int) -> int: pass ``` Input * `number` (1 ≤ number ≤ 10^9): An integer input. Output * A single integer which is the next higher number using the same set of digits, or `-1` if no such number exists. Example 1. Input: `38276` Output: `38627` 2. Input: `99999` Output: `-1` # Constraints * Your solution should have O(n) time complexity where n is the number of digits. * The space complexity should be minimal. Testing ```python import unittest class TestNextBigger(unittest.TestCase): def test_samples(self): self.assertEqual(next_bigger(38276), 38627) self.assertEqual(next_bigger(12345), 12354) self.assertEqual(next_bigger(1528452), 1528524) self.assertEqual(next_bigger(138654), 143568) self.assertEqual(next_bigger(54321), -1) self.assertEqual(next_bigger(999), -1) self.assertEqual(next_bigger(5), -1) if __name__ == \'__main__\': unittest.main() ``` # Explanation Using the algorithm described for finding the next permutation: 1. Convert the given number into an array of its digits. 2. Traverse from the end of the array to find the first digit that is smaller than the digit next to it. 3. From the rightmost end, find the first digit that is larger than this found digit. 4. Swap these two digits. 5. Reverse the digits to the right of the position of the first found digit.","solution":"def next_bigger(number: int) -> int: digits = list(map(int, str(number))) # Convert the number to a list of digits n = len(digits) # Step 1: Find the first digit that is smaller than the digit next to it for i in range(n - 2, -1, -1): if digits[i] < digits[i + 1]: break else: return -1 # If no such digit is found, return -1 # Step 2: Find the smallest digit on the right side of the array which is larger than digits[i] for j in range(n - 1, i, -1): if digits[j] > digits[i]: break # Step 3: Swap the above found smallest digit with digits[i] digits[i], digits[j] = digits[j], digits[i] # Step 4: Reverse the digits after index i to get the next smallest permutation digits = digits[:i + 1] + digits[i + 1:][::-1] return int(\\"\\".join(map(str, digits)))"},{"question":"**Question**: Implement an in-place merge sort for an array of integers. **Scenario**: You are given an array of integers that you need to sort in non-decreasing order using the merge sort algorithm. For this task, you must implement the merge sort algorithm in such a way that it does not use any additional arrays to store intermediate results during the merge step. This implementation should sort the array in-place to minimize extra memory usage. **Function Signature**: ```python def merge_sort_in_place(arr: List[int]) -> None: # Your implementation here ``` **Input**: * `arr` - a list of integers. **Output**: * The function should sort the array in-place. It does not need to return anything. **Constraints**: 1. The length of the array will be at most (10^5). 2. Each element in the array will be an integer within the range ([-10^6, 10^6]). **Performance Requirements**: * The algorithm should run in O(n log(n)) time complexity and use O(1) extra space complexity (excluding the input array). **Example**: ```python from typing import List arr = [38, 27, 43, 3, 9, 82, 10] merge_sort_in_place(arr) print(arr) # Output: [3, 9, 10, 27, 38, 43, 82] ``` To meet the requirement, students must understand and utilize in-place merging techniques within the merge sort strategy.","solution":"from typing import List def merge_sort_in_place(arr: List[int], left: int = 0, right: int = None) -> None: if right is None: right = len(arr) - 1 if left < right: middle = (left + right) // 2 merge_sort_in_place(arr, left, middle) merge_sort_in_place(arr, middle + 1, right) merge(arr, left, middle, right) def merge(arr: List[int], left: int, middle: int, right: int) -> None: start2 = middle + 1 if arr[middle] <= arr[start2]: return while left <= middle and start2 <= right: if arr[left] <= arr[start2]: left += 1 else: value = arr[start2] index = start2 while index != left: arr[index] = arr[index - 1] index -= 1 arr[left] = value left += 1 middle += 1 start2 += 1"},{"question":"# Question: You are given a singly linked list where each node contains a single character. Your task is to implement two functions: one to remove duplicates using additional space for temporary storage, and another one to remove duplicates without using any extra space. Function Definitions: 1. `remove_dups(head: Node) -> void` - Removes all duplicate characters from the linked list using a hash set. 2. `remove_dups_without_set(head: Node) -> void` - Removes all duplicate characters from the linked list without using any extra storage space. Inputs: - `head`: A `Node` object representing the head of the linked list. Outputs: - The linked list with duplicates removed. Constraints: - You may not assume nodes contain only alphabetical characters; they may contain any single character. - Modify the linked list in place. Example: Given the linked list: `A -> A -> B -> C -> D -> C -> F -> G` - After calling `remove_dups(head)`, the linked list should become: `A -> B -> C -> D -> F -> G`. - After calling `remove_dups_without_set(head)`, the linked list should become: `A -> B -> C -> D -> F -> G`. Notes: - You must explain the time and space complexity of your implementations. - Consider edge cases and document any assumptions you make. ```python class Node(): def __init__(self, val = None): self.val = val self.next = None ```","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def remove_dups(head: Node) -> None: if head is None: return current = head seen = set() seen.add(current.val) while current.next: if current.next.val in seen: current.next = current.next.next else: seen.add(current.next.val) current = current.next def remove_dups_without_set(head: Node) -> None: current = head while current: runner = current while runner.next: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next"},{"question":"# Scenario You are part of a team working on optimizing a large-scale data processing pipeline. One of the tasks is to clean up datasets by moving all zero entries (including integer and float zeros) to the end of the data array while preserving the order of non-zero elements. However, boolean `False` values must not be moved as they are critical flags in your data. # Task Write a function `optimize_array` that accepts an array of elements and moves all zeros (integers and floats) to the end of the array, keeping the order of non-zero elements unchanged. The function should not consider the boolean `False` as zero. # Function Signature ```python def optimize_array(array: list) -> list: pass ``` # Input - `array`: A list of elements containing integers, floats, booleans, strings, and other objects. Examples could include `[False, 1.0, 0, 1, 2.0, 0, 1, 3, \\"a\\"]`. # Output - A new list with all zero elements (integers and floats) moved to the end, while maintaining the order of non-zero elements and keeping `False` in its original position. # Constraints - The algorithm must run in O(n) time complexity. - Additional memory usage should be minimized. # Example Input: ```python optimize_array([False, 1.0, 0, 1, 2.0, 0, 1, 3, \\"a\\"]) ``` Output: ```python [False, 1.0, 1, 2.0, 1, 3, \\"a\\", 0, 0] ``` Input: ```python optimize_array([0, False, 0.0, \\"x\\", 3]) ``` Output: ```python [False, \\"x\\", 3, 0, 0.0] ```","solution":"def optimize_array(array: list) -> list: non_zeros = [] zeros = [] for item in array: if (item == 0 and not isinstance(item, bool)): # Check if item is zero and not boolean zeros.append(item) else: non_zeros.append(item) return non_zeros + zeros"},{"question":"# Matrix Multiplication Challenge You are given the task of implementing a function that multiplies two 2D matrices and returns the product. Your function should handle potential errors related to dimension mismatches and ensure that the computation is efficient. Function Signature ```python def matrix_multiply(A: list, B: list) -> list: pass ``` Input * Two 2D lists `A` and `B`, representing matrices of integers. * Constraints: - 1 <= len(A), len(B) <= 100 - 1 <= len(A[0]), len(B[0]) <= 100 - Elements of matrices can be negative or positive integers. Output * A 2D list representing the product of the matrices `A` and `B`. Example ```python A = [ [1, 2, 3], [4, 5, 6] ] B = [ [7, 8], [9, 10], [11, 12] ] matrix_multiply(A, B) ``` Output: ```python [ [58, 64], [139, 154] ] ``` Requirements 1. You must handle edge cases such as mismatched dimensions. 2. Raise an appropriate exception if the matrices are not compatible for multiplication. 3. Optimize your code to handle the maximum input sizes efficiently.","solution":"def matrix_multiply(A: list, B: list) -> list: # Check if the number of columns in A is equal to the number of rows in B if len(A[0]) != len(B): raise ValueError(\\"Matrices A and B cannot be multiplied due to dimension mismatch.\\") # Initialize the resultant matrix with zeros result = [[0 for _ in range(len(B[0]))] for _ in range(len(A))] # Perform matrix multiplication for i in range(len(A)): for j in range(len(B[0])): for k in range(len(B)): result[i][j] += A[i][k] * B[k][j] return result"},{"question":"# Matrix Chain Multiplication Optimization **Problem Statement**: Imagine you are building a system that performs a series of operations on matrices in database query optimization. Efficiently multiplying these matrices in the optimal order is crucial to minimize computational resources. Your task is to write a function to find the minimum number of scalar multiplications required to multiply a given chain of matrices in the most efficient way and the optimal order of multiplication. **Function Specifications**: 1. **Function Name**: `matrix_chain_order` 2. **Input**: A list of integers representing the dimensions of matrices in a chain. - `array`: List of integers such that `array[i-1]` x `array[i]` represents the dimension of the i-th matrix. 3. **Output**: Tuple containing: - The minimum number of scalar multiplications required. - A nested list representing the order of parentheses to achieve this minimum cost. You must also write a helper function to print out the optimal multiplication order: 1. **Function Name**: `print_optimal_solution` 2. **Input**: - Matrix of optimal split points - Indices `i` and `j` representing the starting and ending index of the matrix chain 3. **Output**: Prints the optimal order of matrix multiplication. **Constraints**: - The length of the input list will be between 2 and 100. - All dimensions given in the list will be positive integers. **Examples**: ```python def main(): Testing for matrix_chain_ordering array=[30,35,15,5,10,20,25] length=len(array) # Size of matrix created from above array will be # 30*35 35*15 15*5 5*10 10*20 20*25 matrix, optimal_solution = matrix_chain_order(array) assert matrix[1][length-1] == 15125 print(\\"Minimum number of multiplications: \\", matrix[1][length-1]) print_optimal_solution(optimal_solution, 1, length-1) if __name__ == \'__main__\': main() ``` **Explanation**: For a chain of matrices A1(30x35), A2(35x15), A3(15x5), A4(5x10), A5(10x20), and A6(20x25), the function should find the optimal order of multiplications that will require the minimum number of scalar multiplications and also print the order.","solution":"def matrix_chain_order(p): Returns the minimum number of scalar multiplications needed to compute the matrix chain product and the optimal order of multiplication. Parameters: p (list): List of dimensions for matrices such that the dimensions of matrix A[i] are p[i-1] x p[i]. Returns: tuple: A tuple containing: - matrix: 2D list where matrix[i][j] stores the minimum number of multiplications needed to compute the product of matrices A[i] to A[j]. - optimal_split: 2D list where optimal_split[i][j] stores the index that achieved the optimal split. n = len(p) - 1 # Initialize matrix M with 0 values for the diagonal and inf for the rest matrix = [[0 if i==j else float(\'inf\') for j in range(n+1)] for i in range(n+1)] # Initialize the optimal split matrix optimal_split = [[0 for j in range(n+1)] for i in range(n+1)] # Fill the matrix and optimal_split tables for length in range(2, n+1): # length of the chain segment for i in range(1, n-length+2): j = i+length-1 for k in range(i, j): q = matrix[i][k] + matrix[k+1][j] + p[i-1]*p[k]*p[j] if q < matrix[i][j]: matrix[i][j] = q optimal_split[i][j] = k return matrix, optimal_split def print_optimal_solution(optimal_split, i, j): Prints the optimal way to multiply matrices from i to j. Parameters: optimal_split (list): A 2D list containing the optimal split points for matrix chain multiplication. i (int): Starting index of matrices. j (int): Ending index of matrices. if i == j: print(f\\"A{i}\\", end=\\"\\") else: print(\\"(\\", end=\\"\\") print_optimal_solution(optimal_split, i, optimal_split[i][j]) print_optimal_solution(optimal_split, optimal_split[i][j] + 1, j) print(\\")\\", end=\\"\\")"},{"question":"You are required to implement a **Phone Directory** application using the Trie data structure. The directory must support the following operations: 1. **Add Contact**: Add a new contact to the directory. 2. **Search Contact**: Check if a contact exists in the directory. 3. **AutoComplete Contact**: Given a prefix, return all contacts that start with this prefix. # Input/Output Format Define the following API within your `PhoneDirectory` class: * `insert_contact(contact)`: Adds a contact string to the directory. * Input: String contact * Output: None * `search_contact(contact)`: Checks if the contact string exists in the directory. * Input: String contact * Output: Boolean (True if contact exists, else False) * `auto_complete(prefix)`: Returns all contacts that start with the given prefix. * Input: String prefix * Output: List of strings (empty list if no contacts match) # Constraints * All contact strings consist of lowercase a-z letters. * The maximum length of any contact string is 100. * The number of operations will not exceed 10^4. # Example ```python # Your implementation should support: directory = PhoneDirectory() directory.insert_contact(\'alice\') directory.insert_contact(\'bob\') directory.insert_contact(\'alicia\') print(directory.search_contact(\'alice\')) # Output: True print(directory.search_contact(\'alex\')) # Output: False print(directory.auto_complete(\'ali\')) # Output: [\'alice\', \'alicia\'] ``` # Notes * You can assume all inputs are lowercase strings with letters from \'a\' to \'z\'. * Consider edge cases like empty strings or prefixes that match no contacts.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class PhoneDirectory: def __init__(self): self.root = TrieNode() def insert_contact(self, contact): node = self.root for char in contact: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search_contact(self, contact): node = self.root for char in contact: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def auto_complete(self, prefix): node = self.root for char in prefix: if char not in node.children: return [] node = node.children[char] return self._find_all_contacts(node, prefix) def _find_all_contacts(self, node, prefix): contacts = [] if node.is_end_of_word: contacts.append(prefix) for char in node.children: contacts.extend(self._find_all_contacts(node.children[char], prefix + char)) return contacts"},{"question":"# Coding Challenge: Integer and Byte Array Conversion Context: You are working on a data serialization library that needs to handle conversion of integers to their byte representations and vice versa. The conversions must support both big-endian and little-endian formats. These formats are crucial when ensuring that data is interpreted correctly across different systems and architectures. # Task: Implement the following four functions in Python, each of which performs a specific conversion between integers and byte arrays in big-endian and little-endian formats. 1. **`int_to_bytes_big_endian(num: int) -> bytes`**: - Convert an integer `num` to its big-endian byte representation. 2. **`int_to_bytes_little_endian(num: int) -> bytes`**: - Convert an integer `num` to its little-endian byte representation. 3. **`bytes_big_endian_to_int(bytestr: bytes) -> int`**: - Convert a byte representation `bytestr` (big-endian) back to an integer. 4. **`bytes_little_endian_to_int(bytestr: bytes) -> int`**: - Convert a byte representation `bytestr` (little-endian) back to an integer. # Input and Output Formats: - Functions `int_to_bytes_big_endian` and `int_to_bytes_little_endian` take an integer `num` as input and return a `bytes` object. - Functions `bytes_big_endian_to_int` and `bytes_little_endian_to_int` take a `bytes` object as input and return an integer. # Constraints: - The input integer `num` will be non-negative. - The byte array for conversion back to an integer will be non-empty and correctly formatted. - Handle integers that may expand to multiple bytes (e.g., large values up to 2^63 - 1). - Consider edge cases such as conversion of zero. # Examples: ```python assert int_to_bytes_big_endian(305419896) == b\'x12x34x56x78\' assert int_to_bytes_little_endian(305419896) == b\'x78x56x34x12\' assert bytes_big_endian_to_int(b\'x12x34x56x78\') == 305419896 assert bytes_little_endian_to_int(b\'x78x56x34x12\') == 305419896 ``` Write your implementation for these functions taking into consideration the described properties and edge cases.","solution":"def int_to_bytes_big_endian(num: int) -> bytes: Converts an integer to its big-endian byte representation. length = (num.bit_length() + 7) // 8 # Calculate number of bytes needed if length == 0: return b\'x00\' # For handling zero case return num.to_bytes(length, byteorder=\'big\') def int_to_bytes_little_endian(num: int) -> bytes: Converts an integer to its little-endian byte representation. length = (num.bit_length() + 7) // 8 # Calculate number of bytes needed if length == 0: return b\'x00\' # For handling zero case return num.to_bytes(length, byteorder=\'little\') def bytes_big_endian_to_int(bytestr: bytes) -> int: Converts a big-endian byte representation back to an integer. return int.from_bytes(bytestr, byteorder=\'big\') def bytes_little_endian_to_int(bytestr: bytes) -> int: Converts a little-endian byte representation back to an integer. return int.from_bytes(bytestr, byteorder=\'little\')"},{"question":"Implement a Circular Array Queue A Circular Array Queue is an efficient way of implementing a queue using a static array that wraparounds to utilize free space once elements are dequeued from the front. **Task**: Your task is to implement the CircularArrayQueue class by extending the AbstractQueue class. # Implementation Details **Class Definition**: `CircularArrayQueue(pattern=\'ab\')` **Methods to Implement**: - `enqueue(value)`: Adds a new item to the rear of the queue. - `dequeue()`: Removes the front item from the queue and returns it. - `peek()`: Returns the item at the front of the queue without removing it. - `is_empty()`: Tests to see whether the queue is empty. - `__iter__()`: Iterates over the queue elements from front to rear. - `__len__()`: Returns the number of items in the queue. **Input and Output**: - The `enqueue` method should take an integer value as input. - The `dequeue` and `peek` methods should return the integer value at the front of the queue. - `is_empty` returns a boolean. - The `__len__` method returns an integer representing the number of elements in the queue. - The `__iter__` method should yield elements in FIFO order. **Constraints**: - Circular array should efficiently utilize free space after elements are dequeued to avoid the need for array expansion. - Queue should support a capacity of up to 1000 elements. # Example Usage ```python queue = CircularArrayQueue() queue.enqueue(10) queue.enqueue(20) queue.enqueue(30) print(queue.dequeue()) # Output: 10 print(queue.peek()) # Output: 20 print(len(queue)) # Output: 2 print(queue.is_empty()) # Output: False for item in queue: print(item) # Output: 20 30 ``` # Additional Information 1. **Edge Cases**: - Handle dequeue/peek operations on an empty queue by raising an appropriate exception: `IndexError(\\"Queue is empty\\")`. 2. **Complexity**: - Aim to keep `enqueue`, `dequeue`, and `peek` operations O(1).","solution":"class CircularArrayQueue: def __init__(self, capacity=1000): self.capacity = capacity self.queue = [None] * capacity self.front = 0 self.rear = 0 self.size = 0 def enqueue(self, value): if self.size == self.capacity: raise ValueError(\\"Queue is full\\") self.queue[self.rear] = value self.rear = (self.rear + 1) % self.capacity self.size += 1 def dequeue(self): if self.size == 0: raise IndexError(\\"Queue is empty\\") value = self.queue[self.front] self.front = (self.front + 1) % self.capacity self.size -= 1 return value def peek(self): if self.size == 0: raise IndexError(\\"Queue is empty\\") return self.queue[self.front] def is_empty(self): return self.size == 0 def __iter__(self): index = self.front count = 0 while count < self.size: yield self.queue[index] index = (index + 1) % self.capacity count += 1 def __len__(self): return self.size"},{"question":"Objective Write a function `summarize_ranges` that summarizes ranges of consecutive integers from a given sorted array of unique integers. Scenario You are tasked with compressing a large dataset for ease of readability and storage. The dataset consists of a sorted list of unique integers, representing timestamps of events. For better management and overview, you need to summarize these timestamps into ranges of continuous numbers. Task Description In your function implementation: 1. You should take an input list of sorted, unique integers. 2. Identify all ranges where the numbers are consecutive. 3. Return a list where each element is a string representation of a range, either \\"start-end\\" for ranges, or simply \\"start\\" for single numbers. Function Signature ```python def summarize_ranges(array: List[int]) -> List[str]: ``` Input - `array`: A list of integers where each integer is unique and the list is sorted in ascending order. It is guaranteed that the length of the list is at least 1 (`1 <= len(array) <= 10^5`). Output - Return a list of strings representing the consecutive ranges. Example ```python # Example 1 input: [0, 1, 2, 4, 5, 7] output: [\'0-2\', \'4-5\', \'7\'] # Example 2 input: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] output: [\'0-9\'] # Example 3 input: [0, 2, 4, 6, 8, 10] output: [\'0\', \'2\', \'4\', \'6\', \'8\', \'10\'] ``` Constraints - The list must be sorted in ascending order prior to being passed to your function. - Each integer in the list is unique and within the range of `[-10^9, 10^9]`.","solution":"from typing import List def summarize_ranges(array: List[int]) -> List[str]: if not array: return [] ranges = [] start = array[0] current = start for num in array[1:]: if num == current + 1: current = num else: if start == current: ranges.append(f\\"{start}\\") else: ranges.append(f\\"{start}-{current}\\") start = num current = start if start == current: ranges.append(f\\"{start}\\") else: ranges.append(f\\"{start}-{current}\\") return ranges"},{"question":"# Question **Context** You are given a list of integers and a number `N`. You need to create a new list that contains each number from the original list at most `N` times without changing the order of elements. **Task** Write a function `restrict_occurrences(lst, N)` that takes in a list of integers `lst` and an integer `N`, and returns a new list that retains each integer from the original list at most `N` times. **Function Signature** ```python def restrict_occurrences(lst: list, N: int) -> list: # Your code here ``` **Input** - `lst`: a list of integers. (0 ≤ len(lst) ≤ 10^5) - `N`: an integer where (0 ≤ N ≤ 10^5) **Output** - A list of integers where each element from `lst` appears at most `N` times and the order is maintained. **Constraints** - If `N` is 0, return an empty list. - The input list can be empty. - The elements in the list can be negative, positive, or zero. **Example** ```python assert restrict_occurrences([1, 2, 3, 1, 2, 1, 2, 3], 2) == [1, 2, 3, 1, 2, 3] assert restrict_occurrences([1, 2, 3, 1, 2, 1, 2, 3], 0) == [] assert restrict_occurrences([1, 1, 1, 1], 2) == [1, 1] assert restrict_occurrences([], 2) == [] assert restrict_occurrences([5, 5, 5, -5, -5], 1) == [5, -5] ``` **Performance Requirements** The implementation should aim for an O(n) runtime complexity where `n` is the number of elements in the input list.","solution":"from collections import defaultdict def restrict_occurrences(lst, N): Takes a list of integers `lst` and an integer `N` and returns a new list that retains each integer from the original list at most `N` times without changing the order. if N == 0: return [] count_dict = defaultdict(int) result = [] for num in lst: if count_dict[num] < N: result.append(num) count_dict[num] += 1 return result"},{"question":"Scenario You are tasked with implementing a customizable data structure for a game development project. The game needs to frequently compute achievable scores for players within specific segments (ranges) of time. Thus, you need a data structure to efficiently manage such range queries and allow combination operations like sum, maximum, or product. Task Implement the `SegmentTree` class with the following functionalities: 1. **Construction**: Initialize the tree with an array and a function. 2. **Perform Range Queries**: Implement function for querying a specific segment returning the combined result using the provided function. Your implementation should handle: - An array of positive integers. - Range queries with `L` (left index) and `R` (right index) to get the combined result for the range [L, R]. Specification Write a class `SegmentTree` with: 1. **Constructor** `__init__(self, arr: List[int], function: Callable[[int, int], int]) -> None`: - `arr`: List of integers, classify the segment tree with this list. - `function`: Callable function that takes two integer arguments and returns an integer. 2. **Query Method** `query(self, L: int, R: int) -> int`: - `L`: Integer representing start index of the segment. - `R`: Integer representing end index of the segment. - Returns combined result of performing the function over the specified range [L, R]. Input - `arr` (Array of integers): e.g. `[2, 4, 5, 3, 4]` - `function` (Callable function): e.g. `sum`, `max` - `L` (Integer): e.g. `1` - `R` (Integer): e.g. `3` Output - Single integer: Result of the function applied to the range [L, R]. Constraints - 1 <= len(arr) <= 100,000 - 0 <= arr[i] <= 10^9 - 0 <= L, R < len(arr) Performance Requirements - Efficient query performance: O(log N) - Efficient construction: O(N) or O(N log N) Example ```python # Initializing the segment tree: mytree = SegmentTree([2, 4, 5, 3, 4], max) # Querying the segment tree: assert mytree.query(2, 4) == 5 assert mytree.query(0, 3) == 5 # Initializing with sum function: mytree = SegmentTree([4, 5, 2, 3, 4, 43, 3], sum) assert mytree.query(1, 5) == 57 ```","solution":"from typing import List, Callable class SegmentTree: def __init__(self, arr: List[int], function: Callable[[int, int], int]) -> None: self.n = len(arr) self.function = function self.tree = [0] * (2 * self.n) self.build(arr) def build(self, arr: List[int]) -> None: # Initialize leaves (second half of the tree array) for i in range(self.n): self.tree[self.n + i] = arr[i] # Build the tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = self.function(self.tree[i * 2], self.tree[i * 2 + 1]) def query(self, L: int, R: int) -> int: # Initialize results res = None # Move L and R to the leaves range L += self.n R += self.n while L <= R: if L % 2 == 1: res = self.tree[L] if res is None else self.function(res, self.tree[L]) L += 1 if R % 2 == 0: res = self.tree[R] if res is None else self.function(res, self.tree[R]) R -= 1 L //= 2 R //= 2 return res"},{"question":"# Prime Number Checker and Optimization Scenario You are working on a cryptographic application where verifying prime numbers quickly and efficiently is critical. You have devised a prime-checking function, but there\'s room for improvement. Optimize and extend the function to handle multiple numbers efficiently. Task 1. **Function Implementation**: Write an optimized version of the prime-checking function that minimizes unnecessary computations for large numbers. 2. **Batch Processing**: Write a function that can take a list of integers and return a list indicating whether each number is prime or not. Leverage your optimized prime-checking to process multiple queries efficiently. Function Signature * `def is_prime(n: int) -> bool` * `def batch_prime_check(numbers: list) -> list` Input * `n`: An integer (1 leq n leq 10^9). * `numbers`: List of integers for batch processing, each (1 leq text{numbers[i]} leq 10^9). Output * `is_prime(n)`: Return `True` if (n) is a prime number, otherwise `False`. * `batch_prime_check(numbers)`: Return a list of booleans where each boolean indicates if the corresponding number in the input list is prime. Constraints * Optimize your implementation to handle up to (10^9). * Ensure the solution is efficient and handles large lists (up to (10^6)) of numbers in a reasonable time. Example ```python # Single prime check print(is_prime(29)) # Output: True print(is_prime(100)) # Output: False # Batch prime check print(batch_prime_check([29, 100, 37, 2, 97])) # Output: [True, False, True, True, True] ```","solution":"def is_prime(n: int) -> bool: Determines if a number is a prime number. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def batch_prime_check(numbers: list) -> list: Takes a list of numbers and returns a list indicating whether each number is prime. return [is_prime(number) for number in numbers]"},{"question":"You are given a sorted list of integers and a target value. You need to design a function that finds the index at which the target value should be inserted to maintain the order of the list. You are required to implement the function `search_insert` that takes a list of sorted integers and a target integer, and returns the index where the target should be inserted. # Function Signature ```python def search_insert(array: List[int], val: int) -> int: pass ``` # Input * `array` (List[int]): A sorted list of integers where the target needs to be inserted. The list can have any number of elements, including zero. * `val` (int): The target integer that needs to be inserted in the list. # Output * `int`: The index where the target integer should be inserted to maintain the sorted order. # Constraints * The array\'s length `n` is in the range [0, 10^4]. * The integers in the array and the target value range from -10^4 to 10^4. * Implement the function with a time complexity of O(log n). * You may not use any built-in sorting or searching functions. # Example ```python # Example 1 array = [1, 3, 5, 6] val = 5 # should return 2 # Example 2 array = [1, 3, 5, 6] val = 2 # should return 1 # Example 3 array = [1, 3, 5, 6] val = 7 # should return 4 # Example 4 array = [1, 3, 5, 6] val = 0 # should return 0 ``` # Notes * Ensure your code handles edge cases such as an empty array and very large or small target values appropriately. * Consider performance impacts and verify correctness with extensive test cases. * This is a fundamental algorithmic question aimed at testing your understanding of binary search and handling edge cases effectively.","solution":"from typing import List def search_insert(array: List[int], val: int) -> int: Returns the index at which the target value should be inserted to maintain the order of the sorted list. left, right = 0, len(array) - 1 while left <= right: mid = (left + right) // 2 if array[mid] == val: return mid elif array[mid] < val: left = mid + 1 else: right = mid - 1 return left"},{"question":"**Scenario**: You are designing a navigation system for an urban planning application. The city grid is represented as a 2D matrix where each cell is either empty land `0`, a building `1`, or an obstacle `2`. You need to determine the shortest distance from all buildings to any empty land cell. # Task: Write a function `shortest_distance(grid: List[List[int]]) -> int` that computes the shortest distance from all building cells to any empty land cell. # Input: - A 2D grid of integers `grid`: - `1` represents a building. - `0` represents an empty land. - `2` represents an obstacle. # Output: - Return an integer representing the shortest distance, or `-1` if such a cell does not exist. # Constraints: - The dimensions of the grid do not exceed 50x50. - There is at least one building in the grid. # Example: Input: ``` grid = [ [1, 0, 2, 0, 1], [0, 0, 0, 0, 0], [0, 0, 1, 0, 0] ] ``` Output: ``` 7 ``` Explanation: - The empty land cell that provides the minimum distance from all buildings is at position `(1, 2)` with a total distance of `7`. # Notes: Consider edge cases such as: 1. Grids with no empty land. 2. Grids where all cells are obstacles except buildings. Implement your solution efficiently, keeping in mind the time and space complexity constraints.","solution":"from collections import deque from typing import List def shortest_distance(grid: List[List[int]]) -> int: if not grid or not grid[0]: return -1 rows, cols = len(grid), len(grid[0]) total_buildings = sum(val == 1 for row in grid for val in row) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] distances = [[0] * cols for _ in range(rows)] reach = [[0] * cols for _ in range(rows)] def bfs(start_row, start_col): visited = [[False] * cols for _ in range(rows)] queue = deque([(start_row, start_col, 0)]) visited[start_row][start_col] = True while queue: r, c, dist = queue.popleft() for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and not visited[nr][nc] and grid[nr][nc] == 0: visited[nr][nc] = True distances[nr][nc] += dist + 1 reach[nr][nc] += 1 queue.append((nr, nc, dist + 1)) for r in range(rows): for c in range(cols): if grid[r][c] == 1: bfs(r, c) min_distance = float(\'inf\') for r in range(rows): for c in range(cols): if grid[r][c] == 0 and reach[r][c] == total_buildings: min_distance = min(min_distance, distances[r][c]) return min_distance if min_distance != float(\'inf\') else -1"},{"question":"# Pancake Sort Implementation and Analysis **Context**: Pancake sorting is an analogy-based sorting method where you sort an array just like how a chef would arrange a pile of pancakes by flipping them with a spatula. Your task is to use the principles of Pancake Sort to sort an array of numbers. **Problem Statement**: You need to write a function `pancake_sort_with_flips` that accepts a list of integers `arr` and returns a tuple consisting of the sorted list and the sequence of flips (as subarray indices) that were performed to sort the list. **Function Signature**: ```python def pancake_sort_with_flips(arr: List[int]) -> Tuple[List[int], List[int]]: pass ``` **Input**: - An unsorted list `arr` of `n` integers (0 ≤ n ≤ 1000), where each integer `arr[i]` (1 ≤ arr[i] ≤ 10^6). **Output**: - A tuple containing the sorted list and a list of integers representing the indices where the flip operations were performed. **Constraints**: - You must use the pancake sorting method. - The indices in the flips list should reflect the flip operation starting from index 0 to k (exclusive). **Example**: ```python input: arr = [3, 2, 4, 1] output: ([1, 2, 3, 4], [2, 4, 3, 2]) ``` Here, the sequence of flips shows that to sort the array, the elements were flipped at indices 2, 4, 3, and finally 2. **Edge Cases to Consider**: 1. A list with a single element should return the same list and an empty flips list. 2. An empty list should return an empty list and an empty flips list. 3. Lists with duplicate elements should be handled correctly (sorted and flipped as if elements are distinct). **Notes**: - Ensure your function handles all edge cases and provides correct sorts and accurate flip indices. - The total number of flip operations should not exceed the practical limits, ensuring the method stays within the expected O(N^2) complexity.","solution":"from typing import List, Tuple def flip(arr: List[int], k: int) -> None: Reverses the order of the first k elements in the array. arr[:k] = arr[:k][::-1] def pancake_sort_with_flips(arr: List[int]) -> Tuple[List[int], List[int]]: res = [] n = len(arr) for size in range(n, 1, -1): # Find the index of the maximum element in arr[0:size] max_index = arr.index(max(arr[:size])) # If the maximum element is not already in its correct position if max_index != size - 1: # Place the maximum element at the beginning if it\'s not already there if max_index != 0: # Flip the maximum element to the beginning flip(arr, max_index + 1) res.append(max_index + 1) # Flip the maximum element to its correct position flip(arr, size) res.append(size) return arr, res"},{"question":"# Question: Keyboard Row Word Filter **Scenario**: You\'re tasked with creating a function that helps typists who prefer using specific rows of a QWERTY keyboard. You need to identify which words from a given list can be typed using letters from only one row of the keyboard. This functionality can be useful for touch typing practice for typists limiting their practice to specific rows. **Function Signature**: ```python def find_keyboard_row(words: List[str]) -> List[str]: ``` **Input**: - `words`: A list of strings, each string representing a word comprising alphabetic characters. Length of the list can be up to (10^4) words, and word length can be up to (10^2) characters. **Output**: - Returns a list of strings, where each string is a word from the input list that is typeable using only one row of a standard QWERTY keyboard. **Constraints**: - Words contain only alphabetic characters. - The function is case insensitive (i.e., \\"Hello\\" and \\"hello\\" should be treated identically). **Example**: ```python # Example input words = [\\"Hello\\", \\"Alaska\\", \\"Dad\\", \\"Peace\\"] # Expected output [\\"Alaska\\", \\"Dad\\"] ``` **Requirements**: 1. Ensure the function handles both upper and lower case alphabetic characters. 2. Optimize the function to handle up to (10^4) words efficiently. 3. Maintain the order of input words in the output list. **Special Instructions**: - Do not include non-alphabetic characters in the words list. If they exist in any word, ignore them for the purpose of this problem. - Solve the problem using set operations to leverage efficient membership checks. Write the function `find_keyboard_row` to achieve the desired output as specified.","solution":"from typing import List def find_keyboard_row(words: List[str]) -> List[str]: Filters the given list of words to return only those that can be typed using one row of a standard QWERTY keyboard. row1 = set(\\"qwertyuiop\\") row2 = set(\\"asdfghjkl\\") row3 = set(\\"zxcvbnm\\") result = [] for word in words: lower_word = set(word.lower()) if lower_word <= row1 or lower_word <= row2 or lower_word <= row3: result.append(word) return result"},{"question":"You are tasked with writing a function that processes a string to remove repeating characters, retaining only the first occurrence of each character. The function should return the new string in the order they originally appeared but without repetitions. # Function Signature ```python def remove_duplicates(s: str) -> str: # your code here... ``` # Input * `s` (str): A string of length n (0 ≤ n ≤ 10^6), which can contain alphabetical characters (both uppercase and lowercase) and possibly digits or special characters. # Output * A string with all repeating characters removed, maintaining the original order of their first appearance. # Constraints * The function must run in O(n) time complexity. * Space complexity should be O(n) in the worst case. # Example ```python assert remove_duplicates(\\"google\\") == \\"gole\\" assert remove_duplicates(\\"data\\") == \\"dat\\" assert remove_duplicates(\\"aabbc\\") == \\"abc\\" assert remove_duplicates(\\"\\") == \\"\\" assert remove_duplicates(\\"AaBbCc\\") == \\"AaBbCc\\" assert remove_duplicates(\\"112233\\") == \\"123\\" ``` # Context This problem simulates a practical scenario where you need to clean up user inputted data by removing repeated characters to ensure a standardized single occurrence of each character without altering their first appearance position.","solution":"def remove_duplicates(s: str) -> str: Returns a string with all repeating characters removed, preserving the order of first occurrence. seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"**Max Flow Problem: BottleNeck Capacity Calculation** **Scenario:** A company is analyzing their transportation network to find out the maximum flow of goods from a main warehouse (source) to retail stores (sink). This network can be represented as a directed graph where nodes represent locations (e.g., warehouses, stores) and edges represent routes with specific capacities (maximum amount of goods that can be transported on that route). **Objective:** Your task is to implement the Ford-Fulkerson algorithm using Depth First Search (DFS) to determine the maximum flow of goods from the main warehouse to the retail stores. Alongside this, calculate the bottleneck capacity, which is the edge with the minimum capacity in the maximum flow path. **Function Signature:** ```python def max_flow_bottleneck(capacity: List[List[int]], source: int, sink: int) -> Tuple[int, int]: Compute the maximum flow and bottleneck capacity from source to sink. :param capacity: A 2D list representing the capacity of each edge (capacity[i][j] is capacity from node i to j). :param source: The source node. :param sink: The sink node. :return: A tuple containing the maximum flow and the bottleneck capacity. ``` **Input:** - `capacity` (List[List[int]]): A square matrix of integers where `capacity[i][j]` is the capacity from node `i` to `j`. If there is no edge, the capacity is `0`. - `source` (int): The starting node (main warehouse). - `sink` (int): The ending node (retail store). **Output:** - A tuple with: - The maximum flow value (integer). - The bottleneck capacity (integer). **Constraints:** - `1 <= len(capacity) <= 100` (Number of nodes) - `0 <= capacity[i][j] <= 10^4` (Capacity values) - Assume there is at least one valid path from source to sink. - There are no negative capacities. **Example:** ```python capacity = [ [0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0] ] source = 0 sink = 5 assert max_flow_bottleneck(capacity, source, sink) == (23, 4) ``` **Note:** You need to enhance the given Ford-Fulkerson algorithm to also track and return the bottleneck capacity of the maximum flow found.","solution":"from typing import List, Tuple def dfs_find_path(capacity: List[List[int]], flow: List[List[int]], source: int, sink: int, parent: List[int]) -> bool: visited = [False] * len(capacity) stack = [source] visited[source] = True while stack: u = stack.pop() for v in range(len(capacity)): if not visited[v] and capacity[u][v] - flow[u][v] > 0: # positive residual capacity stack.append(v) visited[v] = True parent[v] = u if v == sink: return True return False def max_flow_bottleneck(capacity: List[List[int]], source: int, sink: int) -> Tuple[int, int]: n = len(capacity) flow = [[0] * n for _ in range(n)] parent = [-1] * n max_flow = 0 bottleneck_capacity = float(\'inf\') while dfs_find_path(capacity, flow, source, sink, parent): # Find the maximum flow through the path found. path_flow = float(\'inf\') s = sink while s != source: path_flow = min(path_flow, capacity[parent[s]][s] - flow[parent[s]][s]) s = parent[s] # Track the bottleneck capacity. bottleneck_capacity = min(bottleneck_capacity, path_flow) # update residual capacities of the edges and reverse edges along the path v = sink while v != source: u = parent[v] flow[u][v] += path_flow flow[v][u] -= path_flow v = parent[v] max_flow += path_flow return max_flow, bottleneck_capacity"},{"question":"Diffie-Hellman Key Exchange **Context**: Alice and Bob wish to securely exchange keys over a public channel using the Diffie-Hellman Key Exchange Protocol. To ensure security, they must verify the parameters they use to generate their keys. Question Implement a function `safe_diffie_hellman(p: int, a: int) -> bool` that performs the following tasks: 1. Validates that `p` is a prime number. 2. Ensures that `a` is a primitive root of `p`. 3. Calculates the private and public keys for Alice and Bob. 4. Computes the shared secret key for both Alice and Bob. 5. Returns `True` if Alice\'s and Bob\'s calculated shared keys match, indicating a successful key exchange. Otherwise, return `False`. You are provided with helper functions: - `prime_check(num: int) -> bool` - `find_primitive_root(n: int) -> list[int]` - `alice_private_key(p: int) -> int` - `alice_public_key(a_pr_k: int, a: int, p: int) -> int` - `bob_private_key(p: int) -> int` - `bob_public_key(b_pr_k: int, a: int, p: int) -> int` - `alice_shared_key(b_pu_k: int, a_pr_k: int, p: int) -> int` - `bob_shared_key(a_pu_k: int, b_pr_k: int, p: int) -> int` **Input:** * `p`: A positive integer (supposedly a large prime number). * `a`: A positive integer (supposedly a primitive root of `p`). **Output:** * A boolean value `True` if the key exchange is successful, otherwise `False`. **Constraints:** * You may assume `1 < p < 10^9` and `1 < a < p`. Example: ```python assert safe_diffie_hellman(23, 5) == True assert safe_diffie_hellman(23, 11) == False ``` **Note**: - The first example should return `True` as 23 is a prime and 5 is a primitive root. - The second example should return `False` as 11 is not a primitive root of 23.","solution":"import sympy def prime_check(num: int) -> bool: return sympy.isprime(num) def find_primitive_root(p: int) -> int: for g in range(2, p): if all(pow(g, (p - 1) // q, p) != 1 for q in sympy.factorint(p - 1)): return g return -1 def alice_private_key(p: int) -> int: return 6 # For simplicity, using a fixed private key for Alice def alice_public_key(a_pr_k: int, a: int, p: int) -> int: return pow(a, a_pr_k, p) def bob_private_key(p: int) -> int: return 15 # For simplicity, using a fixed private key for Bob def bob_public_key(b_pr_k: int, a: int, p: int) -> int: return pow(a, b_pr_k, p) def alice_shared_key(b_pu_k: int, a_pr_k: int, p: int) -> int: return pow(b_pu_k, a_pr_k, p) def bob_shared_key(a_pu_k: int, b_pr_k: int, p: int) -> int: return pow(a_pu_k, b_pr_k, p) def safe_diffie_hellman(p: int, a: int) -> bool: if not prime_check(p): return False if a != find_primitive_root(p): return False a_pr_k = alice_private_key(p) a_pu_k = alice_public_key(a_pr_k, a, p) b_pr_k = bob_private_key(p) b_pu_k = bob_public_key(b_pr_k, a, p) alice_shared = alice_shared_key(b_pu_k, a_pr_k, p) bob_shared = bob_shared_key(a_pu_k, b_pr_k, p) return alice_shared == bob_shared"},{"question":"# Problem: Implement OrderedStack\'s Extended Functionality You are provided with an implementation of an `OrderedStack` class, where elements are kept sorted internally. Extend the given class with the following additional methods: 1. **merge(other_stack)**: * Merges another `OrderedStack` into the current one, maintaining the sorted order. * The `other_stack` will be emptied by the end of this operation. 2. **find_median()**: * Returns the median value of the stack. * If the stack size is even, return the lower of the two middle values. 3. **reverse()**: * Reverses the order of elements in the stack. # Input and Output - **merge(other_stack)**: * **Input**: An instance of `OrderedStack` * **Output**: None (modifies the stack in place) - **find_median()**: * **Input**: None * **Output**: A single integer or float representing the median value - **reverse()**: * **Input**: None * **Output**: None (modifies the stack in place) # Constraints - You may assume all elements in the stack are integers. - The stack size will not exceed 10^5 elements. # Example: ```python stack1 = OrderedStack() stack1.push(1) stack1.push(5) stack1.push(3) stack2 = OrderedStack() stack2.push(4) stack2.push(6) stack2.push(2) stack1.merge(stack2) # stack1 becomes [1, 2, 3, 4, 5, 6] median = stack1.find_median() # returns 3 stack1.reverse() # stack1 becomes [6, 5, 4, 3, 2, 1] ``` You are required to provide the implementation of the following methods within the `OrderedStack` class: ```python class OrderedStack: # ... (existing methods) def merge(self, other_stack): # To be implemented pass def find_median(self): # To be implemented pass def reverse(self): # To be implemented pass ```","solution":"class OrderedStack: def __init__(self): self.stack = [] def push(self, value): # Insert value maintaining the sorted order self.stack.append(value) self.stack.sort() def merge(self, other_stack): Merges another OrderedStack into the current one, maintaining the sorted order. The other_stack will be emptied by the end of this operation. self.stack.extend(other_stack.stack) self.stack.sort() other_stack.stack.clear() def find_median(self): Returns the median value of the stack. If the stack size is even, return the lower of the two middle values. n = len(self.stack) if n == 0: return None if n % 2 == 1: return self.stack[n // 2] else: return self.stack[n // 2 - 1] def reverse(self): Reverses the order of elements in the stack. self.stack.reverse()"},{"question":"You are tasked with implementing a robust sorting algorithm similar to an enhanced version of Selection Sort that can handle some common limitations of the classic Selection Sort. Specifically, your enhanced algorithm should ensure better time complexity while maintaining in-place sorting. **Your goal** is to implement the \'optimized_selection_sort\' function which uses a hybrid approach combining the simplicity of Selection Sort with an internal enhancement to reduce the number of comparisons. # Input: - A list of integers `arr` (1 <= len(arr) <= 10^5) # Output: - A list of integers sorted in **ascending** order. # Constraints: 1. The solution should maintain an overall improved time complexity relative to basic Selection Sort for larger datasets. 2. The solution should be in-place, i.e., O(1) additional space complexity. # Example: ```python Input: [64, 25, 12, 22, 11] Output: [11, 12, 22, 25, 64] Input: [5, 1, 4, 2, 8] Output: [1, 2, 4, 5, 8] ``` # Function Signature: ```python def optimized_selection_sort(arr: list[int]) -> list[int]: pass ``` # Requirements: - Do not use Python\'s built-in sorting methods. - The function must be optimized to handle large input sizes efficiently compared to the standard Selection Sort. # Hint: Consider implementing a double-ended selection where both the minimum and maximum are found and placed in their respective positions in the same iteration, reducing the number of required passes through the array.","solution":"def optimized_selection_sort(arr: list[int]) -> list[int]: Optimized Selection Sort function that sorts the provided list in ascending order. This version looks for the minimum and maximum elements simultaneously and places them in their correct positions, reducing the number of iterations required. n = len(arr) for i in range(n // 2): # Assume the first element is both the minimum and maximum min_idx = i max_idx = i # Traverse the array from the current start to end - i for j in range(i, n - i): if arr[j] < arr[min_idx]: min_idx = j if arr[j] > arr[max_idx]: max_idx = j # Swap the found minimum to the start arr[i], arr[min_idx] = arr[min_idx], arr[i] # Adjust max_idx in case it was swapped by the previous operation if max_idx == i: max_idx = min_idx # Swap the found maximum to the end arr[n - 1 - i], arr[max_idx] = arr[max_idx], arr[n - 1 - i] return arr"},{"question":"You are tasked with solving a variant of the classic Josephus problem. In this problem, you are given a list of individuals sitting in a circular formation. Starting from the first individual, you need to remove every k-th individual from the circle. This process continues until all individuals have been removed. Print the order in which individuals are removed. # Function Signature ```python def josephus(int_list: List[int], skip: int) -> List[int]: ``` # Input - `int_list`: A list of integers representing the individuals in the circle. - `skip`: An integer `k` such that every k-th individual is removed. # Output - A list of integers representing the order in which the individuals are removed. # Constraints - `1 <= len(int_list) <= 10^5` - `1 <= skip <= 10^5` - All elements in `int_list` are unique and positive integers. # Performance Requirements - You should minimize the time complexity to fit within the constraints. # Example ```python # Example 1 int_list = [1, 2, 3, 4, 5, 6, 7, 8, 9] skip = 3 # Output should be [3, 6, 9, 4, 8, 5, 2, 7, 1] # Example 2 int_list = [1, 2, 3, 4, 5] skip = 2 # Output should be [2, 4, 1, 5, 3] ``` # Explanation For the first example: - First, `3` will be removed (counting starts from `1` and skips two individuals `2, 3`). - Then, from the new starting position, every third person (`6`, then `9`, etc.) will be removed until all are removed.","solution":"from typing import List def josephus(int_list: List[int], skip: int) -> List[int]: result = [] index = 0 while int_list: index = (index + skip - 1) % len(int_list) result.append(int_list.pop(index)) return result"},{"question":"# Graph Traversal: Detecting Cycles and Pathfinding You are given an undirected graph which can be represented as an adjacency list. Implement a function `find_cycle(graph)` to detect if the graph contains a cycle, and a function `find_shortest_path(graph, start, end)` to find the shortest path between two nodes using BFS. Definition - **find_cycle(graph)**: - **Input**: `graph` (dictionary adjacency list), where the keys are node identifiers and the values are lists of adjacent nodes. - **Output**: Boolean value indicating the presence of a cycle. - **find_shortest_path(graph, start, end)**: - **Input**: `graph` (as defined above), `start` (the starting node), `end` (the target node). - **Output**: List of nodes representing the shortest path from `start` to `end`. Constraints - The graph is undirected. - All node identifiers are unique and within a reasonable, fixed limit. - The graph does not necessarily contain all nodes for any input range. Example Usage ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\'], \'C\': [\'A\', \'D\'], \'D\': [\'B\', \'C\', \'E\'], \'E\': [\'D\'] } assert find_cycle(graph) == True assert find_shortest_path(graph, \'A\', \'E\') == [\'A\', \'C\', \'D\', \'E\'] ``` **Your task is to implement these two functions:** 1. `find_cycle(graph)` 2. `find_shortest_path(graph, start, end)` Make sure to consider efficiency and edge cases where there might be no path or no cycle.","solution":"from collections import deque def find_cycle(graph): Detects if the graph contains a cycle. Args: graph (dict): undirected graph represented as adjacency list Returns: bool: True if the graph contains a cycle, False otherwise visited = set() def dfs(v, parent): visited.add(v) for neighbor in graph.get(v, []): if neighbor not in visited: if dfs(neighbor, v): return True elif parent != neighbor: return True return False for node in graph: if node not in visited: if dfs(node, None): return True return False def find_shortest_path(graph, start, end): Finds the shortest path between two nodes using BFS. Args: graph (dict): undirected graph represented as adjacency list start: the starting node end: the target node Returns: list: list of nodes representing the shortest path from start to end if start not in graph or end not in graph: return [] queue = deque([(start, [start])]) visited = set([start]) while queue: current, path = queue.popleft() if current == end: return path for neighbor in graph.get(current, []): if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, path + [neighbor])) return []"},{"question":"Consider a scenario where you have a sequence of unique integers in the range [0..n]. One integer is missing from this sequence. Your task is to write a function that finds and returns the missing number. You are given two methods. Using the XOR approach, implement a function that meets the following requirements: Function Signature ```python def find_missing_number(nums: List[int]) -> int: ``` Input - `nums` (List[int]): A list of unique integers in the range [0..n]. The difference between consecutive integers cannot be more than 1. Output - `int`: The missing integer from the sequence. If the sequence is complete, return the next integer in the sequence. Constraints - The list can have up to `1_000_000` integers. - It is guaranteed that the list contains n unique elements. Examples ```python assert find_missing_number([4, 1, 3, 0, 6, 5, 2]) == 7 assert find_missing_number([0, 1]) == 2 assert find_missing_number([9, 6, 7, 8, 0, 1, 2, 4, 3]) == 5 ``` In the examples, the integer missing from the sequence is identified and returned. If the sequence is complete, the next integer in line is returned.","solution":"from typing import List def find_missing_number(nums: List[int]) -> int: n = len(nums) total_xor = 0 nums_xor = 0 # XOR all numbers from 0 to n for i in range(n + 1): total_xor ^= i # XOR all numbers in the array for num in nums: nums_xor ^= num # Missing number is the XOR of the above two results return total_xor ^ nums_xor"},{"question":"# Integer-Byte Conversion Functions Objective Implement functions that convert integers to byte sequences and vice versa, with support for both big-endian and little-endian byte orders. Description You will write a set of conversion functions that: 1. Convert integers to their respective big-endian and little-endian byte sequences. 2. Convert big-endian and little-endian byte sequences back to integers. Requirements 1. **Function Definitions**: - `def int_to_bytes_big_endian(num: int) -> bytes` - `def int_to_bytes_little_endian(num: int) -> bytes` - `def bytes_big_endian_to_int(bytestr: bytes) -> int` - `def bytes_little_endian_to_int(bytestr: bytes) -> int` 2. **Input/Output Formats**: - `int_to_bytes_big_endian(num)`: - Input: An integer `num` (>= 0) - Output: Byte sequence in big-endian order. - `int_to_bytes_little_endian(num)`: - Input: An integer `num` (>= 0) - Output: Byte sequence in little-endian order. - `bytes_big_endian_to_int(bytestr)`: - Input: A byte sequence `bytestr`. - Output: The integer representation of the byte sequence assuming big-endian order. - `bytes_little_endian_to_int(bytestr)`: - Input: A byte sequence `bytestr`. - Output: The integer representation of the byte sequence assuming little-endian order. Constraints - Do not handle negative integers. - Assume that the input byte sequences are well-formed (contain only valid byte values 0-255). Example ```python # Example Usage num = 305419896 be_bytes = int_to_bytes_big_endian(num) le_bytes = int_to_bytes_little_endian(num) assert be_bytes == b\'x12x34x56x78\' assert le_bytes == b\'x78x56x34x12\' assert bytes_big_endian_to_int(be_bytes) == num assert bytes_little_endian_to_int(le_bytes) == num ``` Notes 1. Ensure your functions handle the minimal edge cases (e.g., input `0`). 2. Focus on code efficiency and clarity. 3. Do not use built-in methods for conversion directly within the implementation (`int.to_bytes()` or `int.from_bytes()`).","solution":"def int_to_bytes_big_endian(num: int) -> bytes: Converts an integer to its respective big-endian byte sequence. if num == 0: return b\'x00\' result = [] while num: result.append(num & 0xFF) num >>= 8 return bytes(result[::-1]) def int_to_bytes_little_endian(num: int) -> bytes: Converts an integer to its respective little-endian byte sequence. if num == 0: return b\'x00\' result = [] while num: result.append(num & 0xFF) num >>= 8 return bytes(result) def bytes_big_endian_to_int(bytestr: bytes) -> int: Converts a big-endian byte sequence into its integer representation. result = 0 for byte in bytestr: result = (result << 8) | byte return result def bytes_little_endian_to_int(bytestr: bytes) -> int: Converts a little-endian byte sequence into its integer representation. result = 0 for i, byte in enumerate(bytestr): result |= byte << (8 * i) return result"},{"question":"# Question: Implement a B-Tree Traversal and Verification Context You are working with a B-Tree-based storage system. You need to ensure data stored in the B-Tree is correctly ordered and can be efficiently accessed. Given the complexity of the B-Tree structure, it is crucial to verify the structural integrity of the tree and perform traversal operations to list the stored keys. Task 1. **Function Implementation**: Implement a function `is_b_tree` to verify if a given tree structure adheres to the B-Tree properties. 2. **Tree Traversal**: Implement a function `traverse_b_tree` to collect all keys in the B-Tree using an in-order traversal. Function Signatures ```python def is_b_tree(tree: BTree) -> bool: Verify if the tree structure is a valid B-Tree. Args: tree (BTree): The B-Tree to verify. Returns: bool: True if tree is a valid B-Tree, False otherwise. pass def traverse_b_tree(tree: BTree) -> list: Perform an in-order traversal of the B-Tree and return a list of keys. Args: tree (BTree): The B-Tree to traverse. Returns: list: A list of keys in ascending order. pass ``` Constraints and Requirements - **Input**: The functions will be provided with an instance of the BTree class. Assume that the BTree and Node classes are already implemented as provided in the initial snippet. - **Output**: The traversal function must return a list of keys in ascending order. - **Performance**: Your implementations should ensure optimal traversal and validation to not degrade performance. Examples ```python # Example B-Tree setup (you might need to insert keys to construct an example tree). btree = BTree(t_val=3) # Assuming various insertions here btree.insert_key(10) btree.insert_key(20) btree.insert_key(5) btree.insert_key(6) btree.insert_key(12) btree.insert_key(30) btree.insert_key(7) btree.insert_key(17) # Validate B-Tree assert is_b_tree(btree) == True # Traverse B-Tree assert traverse_b_tree(btree) == [5, 6, 7, 10, 12, 17, 20, 30] ``` Notes - Do not alter the original BTree and Node class definitions. - Ensure to consider edge cases such as empty trees, single-node trees, and trees with maximum/ minimum keys.","solution":"class Node: def __init__(self, t, is_leaf=True): self.t = t self.is_leaf = is_leaf self.keys = [] self.children = [] class BTree: def __init__(self, t): self.root = Node(t) def is_b_tree(tree): def is_valid_node(node): if not node.is_leaf: # Internal nodes must have between ceil(t/2) and t children max_children = node.t min_children = (node.t + 1) // 2 if len(node.children) < min_children or len(node.children) > max_children: return False # All nodes must have between ceil(t/2)-1 and t-1 keys max_keys = 2 * node.t - 1 min_keys = node.t - 1 if not node == tree.root else 1 # Root can have fewer keys if len(node.keys) > max_keys or len(node.keys) < min_keys: return False # Keys in the nodes must be ordered for i in range(len(node.keys) - 1): if node.keys[i] >= node.keys[i + 1]: return False # Recursively check children if not a leaf for child in node.children: if not is_valid_node(child): return False return True return is_valid_node(tree.root) def traverse_b_tree(tree): result = [] def inorder_traversal(node): i = 0 while i < len(node.keys): if not node.is_leaf: inorder_traversal(node.children[i]) result.append(node.keys[i]) i += 1 if not node.is_leaf: inorder_traversal(node.children[i]) inorder_traversal(tree.root) return result"},{"question":"# Problem Description A company keeps track of sales data in real-time. They need a system to efficiently accommodate new sales data into a sorted list by keeping it in ascending order. To achieve this, write a function `sorted_insert` that takes the current sorted list of sales figures and a new sale figure, and returns the new sorted list including the new sale figure in the correct position. # Function Signature ```python def sorted_insert(sales: List[int], new_sale: int) -> List[int]: ``` # Input - `sales`: A list of integers representing already sorted sales figures. (1 <= len(sales) <= 10^5) - `new_sale`: An integer representing the new sale figure to be inserted into the list. # Output - Returns a new list of integers with the new sale figure inserted in the correct position. # Constraints - The initial list `sales` is sorted in ascending order. - The length of the `sales` list can be at most (10^5). - The `new_sale` value is an integer which fits within the typical range of sales figures. # Example ```python # Example 1 sales = [100, 200, 300, 400] new_sale = 250 # output should be [100, 200, 250, 300, 400] # Example 2 sales = [100, 200, 300, 400] new_sale = 500 # output should be [100, 200, 300, 400, 500] # Example 3 sales = [] new_sale = 150 # output should be [150] ``` # Additional Notes * You are encouraged to utilize the `search_insert` helper function provided in the problem description. * Ensure your solution is efficient in terms of time complexity considering the input constraints.","solution":"from typing import List def sorted_insert(sales: List[int], new_sale: int) -> List[int]: Inserts a new sale figure into an already sorted list, maintaining order. Parameters: sales (List[int]): A list of sorted sales figures. new_sale (int): A new sale figure to be inserted. Returns: List[int]: A new list with the new sale figure inserted in the correct position. if not sales: return [new_sale] left, right = 0, len(sales) while left < right: mid = (left + right) // 2 if sales[mid] < new_sale: left = mid + 1 else: right = mid return sales[:left] + [new_sale] + sales[left:]"},{"question":"# Problem: Secure Message Transformation using Caesar Cipher You are tasked with implementing a function that uses Caesar\'s cipher for encrypting text messages. Your function should be able to shift each letter in the input string by a specified number of positions. This method of encryption, though basic, provides a fundamental understanding of text manipulation and security concepts. Function Signature ```python def caesar_cipher(s: str, k: int) -> str: pass ``` Input * `s`: A string consisting of alphabetic characters and potentially spaces, punctuation, or numbers. * `k`: An integer representing the number of positions each letter should be shifted. Output * A string where each alphabetic character has been shifted by `k` positions in the alphabet. Non-alphabetic characters should remain unchanged. Constraints * The integer `k` can be positive or negative, representing the shift direction (right for positive, left for negative). * Result must handle both uppercase and lowercase letters correctly. * Only alphabetic characters should be shifted. Example ```python assert caesar_cipher(\\"Hello, World!\\", 3) == \\"Khoor, Zruog!\\" assert caesar_cipher(\\"Attack at dawn.\\", -3) == \\"Xqqxzh xq axtk.\\" assert caesar_cipher(\\"Python\\", 0) == \\"Python\\" assert caesar_cipher(\\"Abc! 123\\", 27) == \\"Bcd! 123\\" ``` Performance Requirements * Your solution should run efficiently for strings with lengths up to `10^5`. Scenario Imagine you are a part of a historical research group decoding ancient encrypted messages. Your task is to decode messages written with Caesar\'s cipher. Ensure your solution can handle both simple and larger texts while maintaining accuracy and performance.","solution":"def caesar_cipher(s: str, k: int) -> str: result = [] k = k % 26 # Reduce k to a value between 0 and 25 for char in s: if char.isalpha(): # Determine if the character is upper case or lower case if char.islower(): start = ord(\'a\') else: start = ord(\'A\') # Calculate the new position with wrap-around new_char = chr((ord(char) - start + k) % 26 + start) result.append(new_char) else: result.append(char) return \'\'.join(result)"},{"question":"<|Analysis Begin|> # Core Identification * **Algorithm/Data Structure**: Consecutive Integer Check with Stack * **Type**: Algorithm - Sequential Check of Stack Elements * **Main Purpose**: To verify whether a sequence of integers in a stack follows a consecutive order from bottom to top. # Complexity * **Time Complexity**: Both `first_is_consecutive` and `second_is_consecutive` algorithms have a time complexity of O(n), where n is the number of elements in the stack. * **Space Complexity**: - `first_is_consecutive` uses O(n) extra space for the auxiliary storage stack. - `second_is_consecutive` uses O(2n) = O(n) extra space for the auxiliary queue plus temporary storage. # Principles * Both implementations pop elements from the original stack, compare consecutive pairs, and use auxiliary storage structures to temporarily hold the elements while the comparisons are ongoing. They finally restore the elements back to the original stack. # Characteristics & Applications Properties * **Sequential Check**: Both functions verify if the integers form a consecutive sequence by checking the difference between each pair of adjacent elements. * **Restoration**: Both algorithms ensure the stack remains unchanged after the function execution by restoring all elements back into the original stack. Common Use Cases * **Integrity Check**: To ascertain the correct order of elements in data processing pipelines. * **Game Development**: Checking sequences in gameplay mechanics involving stacks. Strengths/Limitations * **Strengths**: - Ensures original stack order is preserved. - Straightforward implementations that are easy to understand. * **Limitations**: - Additional space required for auxiliary storage. - Does not handle non-integer data or non-sequential orders efficiently. # Implementation Challenges Edge Cases 1. **Empty Stack**: The function should handle empty stacks gracefully and return `True`. 2. **Single Element Stack**: Should handle a stack with one element and return `True`. 3. **Odd Number of Elements**: When the stack has an odd number of elements, the function needs special handling to avoid errors. 4. **Non-conforming sequences**: Properly handle and return `False` for non-consecutive sequences. Performance Bottlenecks * The repeated push and pop operations, especially in `second_is_consecutive`, might be costly in scenarios with very large stacks due to additional overhead of a queue. Error Scenarios * Incorrect restoration of stack elements if auxiliary storage is not managed correctly. * Mishandling edge cases like empty or single-element stacks can lead to incorrect results. Optimization Points * Improve space utilization by optimizing the auxiliary storage mechanism. * Implement early exits when non-consecutive elements are detected. <|Analysis End|> <|Question Begin|> # Question: Consecutive Integer Sequence in Stack You are given a stack of integers. Your task is to implement a function `is_consecutive` that accepts a stack as input and returns `True` if the stack contains a sequence of consecutive integers starting from the bottom of the stack, and `False` otherwise. Ensure the stack remains unchanged after the function execution. **Function Signature**: ```python def is_consecutive(stack: List[int]) -> bool: ``` # Input - `stack`: A list of integers representing the stack, where the first element is the bottom of the stack, and the last element is the top. # Output - `bool`: Returns `True` if the integers in the stack are consecutive starting from the bottom, and `False` otherwise. # Constraints - The function should handle an empty stack gracefully and return `True`. - The integers in the stack can be positive, negative, or zero. # Examples ```python assert is_consecutive([3, 4, 5, 6, 7]) == True assert is_consecutive([3, 4, 6, 7]) == False assert is_consecutive([3, 2, 1]) == False assert is_consecutive([1, 2, 3, 4, 5]) == True assert is_consecutive([]) == True assert is_consecutive([42]) == True ``` # Notes - Consider the edge cases provided: - An empty stack should return `True`. - A single-element stack should return `True`. - Ensure correct handling of stacks with odd numbers of elements.","solution":"def is_consecutive(stack): Returns True if the stack contains a sequence of consecutive integers starting from the bottom of the stack to the top; False otherwise. if len(stack) <= 1: return True # To ensure the stack remains unchanged, we\'ll create a copy of it stack_copy = stack[:] while len(stack_copy) > 1: bottom_elem = stack_copy.pop(0) next_elem = stack_copy[0] if next_elem != bottom_elem + 1: return False return True"},{"question":"# Scenario You are working on a software module that deals with geographical data and need to implement a functionality to find the nearest point of interest (POI) to a given target location. The geographical data of POIs is stored in a Binary Search Tree (BST), where each node represents a POI with a specific value indicating its distance from a reference point. Your task is to write a function that finds the POI (or distance value) in the BST that is closest to a given target distance. # Task Implement the function `closest_value(root, target)` that finds the distance value in the BST which is closest to the given target distance. # Expected Input and Output * **Input**: * `root`: The root node of the BST (an instance of `TreeNode` class). * `target`: A floating point number representing the target distance. * **Output**: * An integer value representing the distance in the BST closest to the target distance. # Constraints * The BST is non-empty. * The target value is a floating point number. * The BST is guaranteed to have only one unique value that is closest to the target. # Performance Requirements * Your solution should have a time complexity of O(h), where h is the height of the BST. * Aim for a space complexity of O(h), taking care to manage the recursion stack efficiently. # Function Signature ```python def closest_value(root, target): :type root: TreeNode :type target: float :rtype: int ``` # Example ```python # Example Input # 10 # / # 5 15 # / # 3 6 20 # Suppose the target is 12, # The node with value 10 is the closest to 12. root = TreeNode(10) root.left = TreeNode(5) root.left.left = TreeNode(3) root.left.right = TreeNode(6) root.right = TreeNode(15) root.right.right = TreeNode(20) print(closest_value(root, 12)) # Expected output: 10 ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def closest_value(root, target): Find the distance value in the BST closest to the target distance. :type root: TreeNode :type target: float :rtype: int closest = root.val while root: if abs(target - root.val) < abs(target - closest): closest = root.val root = root.left if target < root.val else root.right return closest"},{"question":"# Coin Combinations You have been given a list of `coins` of different denominations and a target value `value`. Implement a function `coin_combinations` that returns the number of ways to make up the target value using the coins provided. Each type of coin is available in an infinite supply, and the order of coins in each combination does not matter. # Function Signature ```python def coin_combinations(coins: List[int], value: int) -> int: pass ``` # Input * `coins`: A list of integers where each integer represents a coin denomination. (1 <= len(coins) <= 100, 1 <= coins[i] <= 10,000) * `value`: An integer representing the target amount. (0 <= value <= 10,000) # Output * An integer representing the number of combinations to form the target `value` using the given `coins`. # Example 1. Input: ```text coins = [1, 2, 3] value = 4 ``` Output: ```text 4 ``` Explanation: There are four ways to make change for 4 cents: - [1, 1, 1, 1] - [1, 1, 2] - [2, 2] - [1, 3] 2. Input: ```text coins = [2, 5, 3, 6] value = 10 ``` Output: ```text 5 ``` Explanation: There are five ways to make change for 10 cents: - [2, 2, 2, 2, 2] - [2, 2, 3, 3] - [2, 2, 6] - [2, 3, 5] - [5, 5] # Constraints * You can assume all the coin denominations and the `value` are non-negative integers. * Your solution should have time complexity of O(n * m) and space complexity of O(n).","solution":"from typing import List def coin_combinations(coins: List[int], value: int) -> int: Returns the number of ways to make up the target value using the coins provided. Each type of coin is available in an infinite supply. # Create a list to store the number of ways to make each amount from 0 to value dp = [0] * (value + 1) # There is 1 way to make the amount 0 (using no coins) dp[0] = 1 # For each coin, update the dp array for coin in coins: for i in range(coin, value + 1): dp[i] += dp[i - coin] return dp[value]"},{"question":"Given a string `s`, identify the first non-repeating character and return its index. If no unique character exists, return -1. Implement an efficient solution leveraging a counting data structure such as a dictionary or array for frequency tracking. # Input Format - A string `s` where 1 ≤ |s| ≤ 10^5. # Output Format - An integer representing the index of the first non-repeating character, or -1 if no such character exists. # Constraints - The string `s` contains only lowercase English letters. # Examples 1. `s = \\"leetcode\\"` returns 0. 2. `s = \\"loveleetcode\\"` returns 2. 3. `s = \\"aabb\\"` returns -1. # Notes - Carefully consider edge cases such as a single character string, strings where all characters repeat, and empty strings. - The implementation should optimize for both time and space within the provided constraints. # Function Signature ```python def first_unique_char(s: str) -> int: pass ```","solution":"def first_unique_char(s: str) -> int: Returns the index of the first non-repeating character in the string `s`. If no unique character exists, returns -1. # Step 1: Create a dictionary to count the frequency of each character in the string char_frequency = {} for char in s: if char in char_frequency: char_frequency[char] += 1 else: char_frequency[char] = 1 # Step 2: Iterate through the string again and find the first character with frequency 1 for index, char in enumerate(s): if char_frequency[char] == 1: return index # If no unique character found, return -1 return -1"},{"question":"# Question: Optimized Matrix Multiplication and Exponentiation You are given three operations related to matrix computations: matrix multiplication, identity matrix generation, and matrix exponentiation. Your task is to implement optimized versions of these operations. **1. Optimized Matrix Multiplication:** Implement an optimized version of the matrix multiplication function using Strassen\'s algorithm which reduces the time complexity to approximately O(n^2.81). **2. Identity Matrix Generation:** Implement a function to generate an identity matrix of given size `n`. **3. Matrix Exponentiation using Strassen\'s Multiplication:** Combine your optimized matrix multiplication function with repeated squaring to implement matrix exponentiation. # Function Signatures ```python def optimized_multiply(matA: list, matB: list) -> list: Multiplies two square matrices matA and matB using Strassen\'s algorithm Time Complexity: Approximately O(n^2.81) pass def identity(n: int) -> list: Returns the Identity matrix of size n x n Time Complexity: O(n^2) pass def matrix_exponentiation(mat: list, n: int) -> list: Calculates mat^n by repeated squaring using Strassen\'s optimized multiplication Time Complexity: O(d^2.81 log(n)) d: dimension of the square matrix mat n: power the matrix is raised to pass ``` # Input and Output Formats 1. **optimized_multiply(matA, matB)**: * **Input**: Two 2D lists `matA` and `matB` representing square matrices of the same size. * **Output**: A 2D list representing the result of multiplying `matA` and `matB`. 2. **identity(n)**: * **Input**: An integer `n` representing the size of the identity matrix. * **Output**: A 2D list representing the identity matrix of size `n x n`. 3. **matrix_exponentiation(mat, n)**: * **Input**: A 2D list `mat` representing a square matrix and an integer `n` representing the power to which the matrix is raised. * **Output**: A 2D list representing the matrix `mat` raised to the power `n`. # Constraints * All input matrices are guaranteed to be square matrices of size at most 128x128. * `0 <= n <= 10^9` * Ensure your implementation handles large input sizes efficiently. # Example ```python # Example usage: matA = [ [1, 2], [3, 4] ] matB = [ [2, 0], [1, 2] ] print(optimized_multiply(matA, matB)) # Output: [[4, 4], [10, 8]] print(identity(3)) # Output: [[1, 0, 0], [0, 1, 0], [0, 0, 1]] mat = [ [1, 1], [1, 0] ] print(matrix_exponentiation(mat, 5)) # Output: [[8, 5], [5, 3]] ``` You should ensure your code handles edge cases effectively such as empty matrices or large exponents.","solution":"def optimized_multiply(matA: list, matB: list) -> list: Multiplies two square matrices matA and matB using Strassen\'s algorithm Time Complexity: Approximately O(n^2.81) def add_matrix(A, B): size = len(A) return [[A[i][j] + B[i][j] for j in range(size)] for i in range(size)] def subtract_matrix(A, B): size = len(A) return [[A[i][j] - B[i][j] for j in range(size)] for i in range(size)] def split_matrix(M): size = len(M) mid = size // 2 A11 = [[M[i][j] for j in range(mid)] for i in range(mid)] A12 = [[M[i][j] for j in range(mid, size)] for i in range(mid)] A21 = [[M[i][j] for j in range(mid)] for i in range(mid, size)] A22 = [[M[i][j] for j in range(mid, size)] for i in range(mid, size)] return A11, A12, A21, A22 def strassen(A, B): if len(A) == 1: return [[A[0][0] * B[0][0]]] A11, A12, A21, A22 = split_matrix(A) B11, B12, B21, B22 = split_matrix(B) M1 = strassen(add_matrix(A11, A22), add_matrix(B11, B22)) M2 = strassen(add_matrix(A21, A22), B11) M3 = strassen(A11, subtract_matrix(B12, B22)) M4 = strassen(A22, subtract_matrix(B21, B11)) M5 = strassen(add_matrix(A11, A12), B22) M6 = strassen(subtract_matrix(A21, A11), add_matrix(B11, B12)) M7 = strassen(subtract_matrix(A12, A22), add_matrix(B21, B22)) C11 = add_matrix(subtract_matrix(add_matrix(M1, M4), M5), M7) C12 = add_matrix(M3, M5) C21 = add_matrix(M2, M4) C22 = add_matrix(subtract_matrix(add_matrix(M1, M3), M2), M6) new_size = len(C11) result = [[0] * (2 * new_size) for _ in range(2 * new_size)] for i in range(new_size): for j in range(new_size): result[i][j] = C11[i][j] result[i][j + new_size] = C12[i][j] result[i + new_size][j] = C21[i][j] result[i + new_size][j + new_size] = C22[i][j] return result n = len(matA) return strassen(matA, matB) def identity(n: int) -> list: Returns the Identity matrix of size n x n Time Complexity: O(n^2) return [[1 if i == j else 0 for j in range(n)] for i in range(n)] def matrix_exponentiation(mat: list, n: int) -> list: Calculates mat^n by repeated squaring using Strassen\'s optimized multiplication Time Complexity: O(d^2.81 log(n)) d: dimension of the square matrix mat n: power the matrix is raised to if n == 0: return identity(len(mat)) if n == 1: return mat if n % 2 == 0: half_power = matrix_exponentiation(mat, n // 2) return optimized_multiply(half_power, half_power) else: return optimized_multiply(mat, matrix_exponentiation(mat, n - 1))"},{"question":"# Matrix Transformation Challenge Problem Statement You are tasked with implementing a library to perform specific matrix transformations, commonly used in various applications like image processing or game development. Given a 2D matrix of integers, you need to write functions that will rotate the matrix clockwise, rotate it counterclockwise, invert it diagonally (mirroring around the top-left to bottom-right diagonal), and invert it in a way that mirrors each cell with its counterpart in the opposite corner. Functions to Implement 1. `rotate_clockwise(matrix: List[List[int]]) -> List[List[int]]`: Rotate the matrix by 90 degrees clockwise. 2. `rotate_counterclockwise(matrix: List[List[int]]) -> List[List[int]]`: Rotate the matrix by 90 degrees counterclockwise. 3. `top_left_invert(matrix: List[List[int]]) -> List[List[int]]`: Invert the matrix along the top-left to bottom-right diagonal. 4. `bottom_left_invert(matrix: List[List[int]]) -> List[List[int]]`: Invert the matrix along the top-right to bottom-left diagonal. Input Formats - `matrix`: A 2D list of integers where `1 ≤ len(matrix), len(matrix[0]) ≤ 100`. Output Formats - Each function should return a new 2D list of integers representing the transformed matrix. Constraints - The input matrix will always have at least 1 element and each row will have the same length. - The elements of the matrix will be integers ranging from `-10^3` to `10^3`. Examples ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], ] # Rotate Clockwise # Output: [[7, 4, 1], [8, 5, 2], [9, 3, 0]] # Rotate Counterclockwise # Output: [[3, 6, 9], [2, 5, 8], [1, 4, 7]] # Top Left Invert # Output: [[1, 4, 7], [2, 5, 8], [3, 6, 9]] # Bottom Left Invert # Output: [[9, 6, 3], [8, 5, 2], [7, 4, 1]] ``` Notes - You must handle edge cases such as empty matrices and single row/column matrices. - Avoid using additional libraries, except for standard Python modules. - Aim for efficient code in terms of both time and space complexity.","solution":"def rotate_clockwise(matrix): Rotate the given matrix by 90 degrees clockwise. n = len(matrix) m = len(matrix[0]) return [[matrix[n-1-j][i] for j in range(n)] for i in range(m)] def rotate_counterclockwise(matrix): Rotate the given matrix by 90 degrees counterclockwise. n = len(matrix) m = len(matrix[0]) return [[matrix[j][m-1-i] for j in range(n)] for i in range(m)] def top_left_invert(matrix): Invert the given matrix along the top-left to bottom-right diagonal. n = len(matrix) m = len(matrix[0]) return [[matrix[j][i] for j in range(n)] for i in range(m)] def bottom_left_invert(matrix): Invert the given matrix along the top-right to bottom-left diagonal. n = len(matrix) m = len(matrix[0]) return [[matrix[n-1-j][m-1-i] for j in range(n)] for i in range(m)]"},{"question":"You are required to implement a function that finds two numbers in a given array such that they add up to a specified target. This problem tests your understanding of dictionaries and efficient lookup processes. # Function Signature ```python def find_two_sum(nums: List[int], target: int) -> Tuple[int, int]: ``` # Input - `nums`: A list of integers. - `target`: An integer representing the target sum. # Output - A tuple containing the indices of the two numbers in the list that add up to the target sum. # Constraints - Each input will have exactly one solution. - Elements in the array may not be reused. - It is guaranteed that the list will have at least two elements. # Performance Requirements - Time Complexity: O(n) - Space Complexity: O(n) # Example Given: ```python nums = [2, 7, 11, 15] target = 9 ``` Output: `(0, 1)`, because `nums[0] + nums[1] = 2 + 7 = 9`. # Additional Examples 1. Given: ```python nums = [3, 2, 4] target = 6 ``` Output: `(1, 2)`, because `nums[1] + nums[2] = 2 + 4 = 6`. 2. Given: ```python nums = [3, 3] target = 6 ``` Output: `(0, 1)`, because `nums[0] + nums[1] = 3 + 3 = 6`. # Edge Cases 1. Minimal Array Length: - Input: `nums = [1, 2], target = 3` - Output: `(0, 1)` 2. Handling Zeros and Negative Numbers: - Input: `nums = [-3, 4, 3, 90], target = 0` - Output: `(0, 2)` # Notes 1. Implement your function below the provided signature. 2. Avoid using any extra libraries or functions for this problem. 3. Consider the efficiency in terms of both time and space complexity. Good luck!","solution":"from typing import List, Tuple def find_two_sum(nums: List[int], target: int) -> Tuple[int, int]: Find two indices in nums such that their elements add up to target. Args: nums (List[int]): List of integers target (int): Target sum Returns: Tuple[int, int]: Pair of indices whose corresponding elements add up to target The function assumes exactly one solution and each input can have multiple elements. lookup = {} for i, num in enumerate(nums): complement = target - num if complement in lookup: return (lookup[complement], i) lookup[num] = i"},{"question":"You are tasked with implementing an additional feature for the `ResizableHashTable` class: making it thread-safe. This involves ensuring that multiple threads can access and modify the hash table without causing data inconsistencies or corruptions. # Requirements: 1. Implement a thread-safe version of the `ResizableHashTable` class called `ThreadSafeResizableHashTable`. 2. Use Python\'s threading module and appropriate synchronization mechanisms. 3. Ensure thread safety for all critical operations: `put()`, `get()`, `del_()`, and resizing. 4. Maintain the average-case O(1) complexity for read and write operations, considering resizing cost. 5. The rest of the class functionality should remain unchanged. # Input and Output Specifications: - **Input**: A series of operations on the `ThreadSafeResizableHashTable` (put, get, delete). These operations will be invoked concurrently from multiple threads. - **Output**: The correct state and operation results from the hash table after concurrent modifications. # Scenario: Implement a simple script demonstrating the thread-safe operations. Create several worker threads that perform a random series of `put`, `get`, and `del_` operations on a shared `ThreadSafeResizableHashTable` instance. Verify that the hash table remains consistent and performs correctly under concurrent access. # Constraints: - You can assume the operations will involve integer keys and values. - The hash table will only grow, and will not be required to shrink. # Performance Requirements: While making your implementation thread-safe, ensure that the operations remain as efficient as possible. Minimize lock contention where feasible to maintain high performance. Example usage: ```python import threading import random from time import sleep def worker(hash_table, id): for _ in range(100): operation = random.choice([\'put\', \'get\', \'del\']) key = random.randint(0, 50) if operation == \'put\': value = random.randint(0, 100) hash_table.put(key, value) elif operation == \'get\': print(f\\"Thread {id} fetched: {hash_table.get(key)}\\") elif operation == \'del\': hash_table.del_(key) sleep(random.random() * 0.1) if __name__ == \\"__main__\\": hash_table = ThreadSafeResizableHashTable() threads = [threading.Thread(target=worker, args=(hash_table, i)) for i in range(10)] for t in threads: t.start() for t in threads: t.join() ```","solution":"import threading class ThreadSafeResizableHashTable: def __init__(self, initial_capacity=10): self.lock = threading.Lock() self.capacity = initial_capacity self.size = 0 self.table = [None] * self.capacity def put(self, key, value): with self.lock: idx = self._hash(key) if self.table[idx] is None: self.table[idx] = [] else: for item in self.table[idx]: if item[0] == key: item[1] = value return self.table[idx].append([key, value]) self.size += 1 if self.size / self.capacity > 0.7: self._resize() def _hash(self, key): return hash(key) % self.capacity def _resize(self): new_capacity = 2 * self.capacity new_table = [None] * new_capacity for bucket in self.table: if bucket is not None: for key, value in bucket: idx = hash(key) % new_capacity if new_table[idx] is None: new_table[idx] = [] new_table[idx].append([key, value]) self.capacity = new_capacity self.table = new_table def get(self, key): with self.lock: idx = self._hash(key) bucket = self.table[idx] if bucket is not None: for k, v in bucket: if k == key: return v return None def del_(self, key): with self.lock: idx = self._hash(key) bucket = self.table[idx] if bucket is not None: for i, (k, v) in enumerate(bucket): if k == key: del bucket[i] if len(bucket) == 0: self.table[idx] = None self.size -= 1 return"},{"question":"# Byte Conversion Coding Challenge Context You are tasked with developing a protocol that stores integer data efficiently in a byte-oriented system. Your implementations will need to convert between integer values and their byte representations using both big-endian and little-endian formats. Task Implement the following functions: 1. `int_to_bytes_big_endian(num: int) -> bytes` 2. `int_to_bytes_little_endian(num: int) -> bytes` 3. `bytes_big_endian_to_int(bytestr: bytes) -> int` 4. `bytes_little_endian_to_int(bytestr: bytes) -> int` Specifications: * **Parameters**: * `num` (int): The integer to be converted. * `bytestr` (bytes): The byte array to be converted back to an integer. * **Returns**: * For `int_to_bytes_big_endian` and `int_to_bytes_little_endian`: A byte array representing the integer. * For `bytes_big_endian_to_int` and `bytes_little_endian_to_int`: The integer value derived from the byte array. * **Constraints**: * Assume `num` is a non-negative integer (0 <= num <= 2^64 - 1). * `bytestr` will not exceed 8 bytes in length. * **Edge Cases**: * Consider zero (`num = 0`) during conversions. * Handle empty byte arrays gracefully when converting to integers. Example Usage ```python # Big-endian examples assert int_to_bytes_big_endian(305419896) == bytes([0x12, 0x34, 0x56, 0x78]) assert bytes_big_endian_to_int(bytes([0x12, 0x34, 0x56, 0x78])) == 305419896 # Little-endian examples assert int_to_bytes_little_endian(305419896) == bytes([0x78, 0x56, 0x34, 0x12]) assert bytes_little_endian_to_int(bytes([0x78, 0x56, 0x34, 0x12])) == 305419896 ``` Ensure your implementations handle edge cases and work within the specified constraints.","solution":"def int_to_bytes_big_endian(num: int) -> bytes: Converts an integer to a big-endian byte array. length = (num.bit_length() + 7) // 8 # number of bytes needed return num.to_bytes(length, byteorder=\'big\') def int_to_bytes_little_endian(num: int) -> bytes: Converts an integer to a little-endian byte array. length = (num.bit_length() + 7) // 8 # number of bytes needed return num.to_bytes(length, byteorder=\'little\') def bytes_big_endian_to_int(bytestr: bytes) -> int: Converts a big-endian byte array to an integer. return int.from_bytes(bytestr, byteorder=\'big\') def bytes_little_endian_to_int(bytestr: bytes) -> int: Converts a little-endian byte array to an integer. return int.from_bytes(bytestr, byteorder=\'little\')"},{"question":"# Cycle Sort Implementation Objective Implement the Cycle Sort algorithm for an array of integers. Problem Statement Given an unsorted array `arr` consisting of N integers, implement the Cycle Sort algorithm to sort the array in non-decreasing order. Return the sorted array. # Function Signature ```python def cycle_sort(arr: List[int]) -> List[int]: pass ``` # Input * `arr` (1 ≤ len(arr) ≤ 10^4): An unsorted list of integers where each integer can be between -10^9 and 10^9. # Output * A list of integers sorted in non-decreasing order. # Constraints * You must sort the array in-place (modifying the original array). * Aim to achieve minimal write operations. # Example ```python # Example 1 arr = [5, 2, 9, 1, 5, 6] print(cycle_sort(arr)) # Output: [1, 2, 5, 5, 6, 9] # Example 2 arr = [1, 3, 2, 4, 3] print(cycle_sort(arr)) # Output: [1, 2, 3, 3, 4] ``` Explanation * The function `cycle_sort` should correctly rearrange the elements of `arr` in non-decreasing order using the Cycle Sort algorithm. * Consider edge cases such as arrays with duplicate elements and arrays with negative integers. # Additional Guidance * Don\'t use any in-built sorting methods or library functions that perform sorting. * Test the function with different cases including sorted, reverse-sorted, and arrays with all identical elements.","solution":"def cycle_sort(arr): writes = 0 # Loop through the array to find cycles to rotate. for cycleStart in range(0, len(arr) - 1): item = arr[cycleStart] # Find the position where we put the element. pos = cycleStart for i in range(cycleStart + 1, len(arr)): if arr[i] < item: pos += 1 # If the item is already in the correct position if pos == cycleStart: continue # Otherwise, put the item there or right after any duplicates. while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] writes += 1 # Rotate the rest of the cycle. while pos != cycleStart: pos = cycleStart # Find the position where we put the element. for i in range(cycleStart + 1, len(arr)): if arr[i] < item: pos += 1 # Put the item there or right after any duplicates. while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] writes += 1 return arr"},{"question":"# Question: Counting Digits in an Integer You are given an integer and need to find out how many digits it contains. Objectives - Implement a function `count_digits(number: int) -> int` which computes the number of digits in the given integer. Input - **number**: An integer (can be negative, zero or positive). Output - Return the count of digits in the integer. Constraints - The integer can be any value from (-10^{18}) to (10^{18}). Performance Requirements - The function must execute in constant time O(1). Examples ```python assert count_digits(123456) == 6 assert count_digits(-98765) == 5 assert count_digits(0) == 1 ``` Edge Cases to Consider - The function should correctly handle zero. - The function should handle negative numbers by counting their absolute value digits. Scenario You are working on an application that validates numerical input fields where each entry must match a given digit constraint. To streamline this, you need an efficient solution to determine the digit count of any given integer to enforce these constraints quickly.","solution":"def count_digits(number: int) -> int: Returns the number of digits in the given integer. # Convert the number to string after taking the absolute value to handle negative numbers return len(str(abs(number)))"},{"question":"Given a non-negative number, write a function `find_next_perfect_square` that returns the next perfect square greater than the input number if the input itself is a perfect square. If the input is not a perfect square, the function should return -1. Your function should be efficient, making sure not to exceed constant time and space complexity. # Input - A non-negative integer `sq` where `sq >= 0`. # Output - An integer representing the next perfect square greater than `sq` if `sq` is a perfect square; otherwise, return -1. # Constraints - The input should be a non-negative integer (`0 <= sq <= 10^12`). # Example ```python find_next_perfect_square(121) # Output: 144 find_next_perfect_square(625) # Output: 676 find_next_perfect_square(114) # Output: -1 ``` # Performance Requirements - Time Complexity: O(1) - Space Complexity: O(1) # Note Be cautious of floating-point precision issues when dealing with very large numbers.","solution":"import math def find_next_perfect_square(sq): Returns the next perfect square greater than the input if the input is a perfect square, otherwise returns -1. Parameters: sq (int): A non-negative integer representing the input number. Returns: int: The next perfect square greater than sq if sq is a perfect square, otherwise -1. if sq < 0: return -1 root = int(math.isqrt(sq)) if root * root == sq: return (root + 1) ** 2 else: return -1"},{"question":"You are tasked with implementing `encode` and `decode` methods to convert a list of strings into a single string and back again. This is useful for serializing lists of strings to send them over a network or for storage in an unambiguous format. **Function Definitions**: ```python def encode(strs: List[str]) -> str: Encodes a list of strings to a single string. :param strs: List[str] - A list of strings to be encoded :return: str - The encoded string pass def decode(s: str) -> List[str]: Decodes a single string to a list of strings. :param s: str - The encoded string :return: List[str] - The decoded list of strings pass ``` **Input and Output Specifications**: - `encode`: - Input: A list of strings. - Output: A single string representing the encoded form. - `decode`: - Input: A single string (encoded form). - Output: A list of strings. **Constraints**: - All characters in the lists are printable ASCII characters. - The entries in the list provided to `encode` are guaranteed not to be empty. **Examples**: ```python assert encode([\\"hello\\", \\"world\\"]) == \\"5:hello5:world\\" assert decode(\\"5:hello5:world\\") == [\\"hello\\", \\"world\\"] assert encode([\\"\\"]) == \\"0:\\" assert decode(\\"0:\\") == [\\"\\"] ``` **Hints**: - Consider how to handle strings that might contain the chosen delimiter (\':\' in this case). - Ensure your solution can handle edge cases like empty strings appropriately. - Think about the potential inefficiencies in string concatenation and how you might alleviate them.","solution":"def encode(strs: list) -> str: Encodes a list of strings to a single string. :param strs: List[str] - A list of strings to be encoded :return: str - The encoded string return \'\'.join(f\'{len(s)}:{s}\' for s in strs) def decode(s: str) -> list: Decodes a single string to a list of strings. :param s: str - The encoded string :return: List[str] - The decoded list of strings res = [] i = 0 while i < len(s): j = s.find(\':\', i) length = int(s[i:j]) res.append(s[j+1:j+1+length]) i = j + 1 + length return res"},{"question":"You are given an array of integers that is already sorted in ascending order. Your task is to write a function `two_sum_binary`, `two_sum_hash`, and `two_sum_two_pointer` to find two numbers in the array that add up to a specific target number. Each function should return the indices of the two numbers such that they add up to the target. The indices should be one-based, i.e., the first element in the array has index 1. # Input * `numbers`: A list of integers sorted in ascending order. * `target`: An integer representing the target sum. # Output * Return a list of two integers [index1, index2] (both one-based indices), such that: - `numbers[index1 - 1] + numbers[index2 - 1] == target` - `index1` < `index2` # Constraints * You may assume that each input will have exactly one solution. * You may not use the same element twice. * The length of `numbers` will not exceed 10^5. * The values in `numbers` will be within the range [-10^9, 10^9]. # Performance Requirements * The solution should be optimized for time and space. # Implementation Implement the following functions: 1. `two_sum_binary(numbers, target)` 2. `two_sum_hash(numbers, target)` 3. `two_sum_two_pointer(numbers, target)` # Example Input: ```python numbers = [2, 7, 11, 15] target = 9 ``` Output: ```python # For function two_sum_binary [1, 2] # For function two_sum_hash [1, 2] # For function two_sum_two_pointer [1, 2] ``` # Constraints * The solution must be implemented in Python. * Avoid using built-in functions that provide direct solutions.","solution":"def two_sum_binary(numbers, target): Returns the indices of the two numbers that add up to the target using binary search. def binary_search(nums, start, end, target): while start <= end: mid = (start + end) // 2 if nums[mid] == target: return mid elif nums[mid] < target: start = mid + 1 else: end = mid - 1 return -1 for i in range(len(numbers)): complement = target - numbers[i] j = binary_search(numbers, i + 1, len(numbers) - 1, complement) if j != -1: return [i + 1, j + 1] return [] def two_sum_hash(numbers, target): Returns the indices of the two numbers that add up to the target using hash map. num_dict = {} for i, number in enumerate(numbers): complement = target - number if complement in num_dict: return [num_dict[complement] + 1, i + 1] num_dict[number] = i return [] def two_sum_two_pointer(numbers, target): Returns the indices of the two numbers that add up to the target using two pointers. left, right = 0, len(numbers) - 1 while left < right: current_sum = numbers[left] + numbers[right] if current_sum == target: return [left + 1, right + 1] elif current_sum < target: left += 1 else: right -= 1 return []"},{"question":"# Context You have been tasked with maintaining a contact list application that needs to store and retrieve user data quickly. The underlying data structure you choose should support a large number of entries and handle collisions effectively. You\'ve decided to use a modified version of a HashTable with separate chaining using linked lists to resolve collisions. # Problem Statement Implement a `ContactList` class using the Separate Chaining Hash Table provided in the code snippet. Each contact will have a `name` (unique key) and a `phone_number` (value). # Requirements 1. **Add a contact**: * Input: (string `name`, string `phone_number`) * Function: `def add_contact(self, name: str, phone_number: str):` * Adds a new contact or updates the phone number if the contact already exists. 2. **Retrieve a phone number**: * Input: (string `name`) * Function: `def get_phone_number(self, name: str) -> str:` * Returns the phone number for the given contact name. If the contact does not exist, return \\"Contact not found\\". 3. **Delete a contact**: * Input: (string `name`) * Function: `def delete_contact(self, name: str):` * Deletes the contact with the given name from the contact list. # Input and Output Formats - Function: `add_contact` accepts two strings `name` and `phone_number`. - Function: `get_phone_number` accepts one string `name` and returns a string which is either the phone number or \\"Contact not found\\". - Function: `delete_contact` accepts one string `name` and has no return value. # Constraints - Both `name` and `phone_number` are non-empty strings with a maximum length of 100 characters. - Names are unique in the contact list. # Implementation You need to implement the `ContactList` class leveraging the `SeparateChainingHashTable` from the provided code. # Example Usage ```python contacts = ContactList() contacts.add_contact(\\"Alice\\", \\"123-456-7890\\") contacts.add_contact(\\"Bob\\", \\"234-567-8901\\") print(contacts.get_phone_number(\\"Alice\\")) # Output: \\"123-456-7890\\" print(contacts.get_phone_number(\\"Charlie\\")) # Output: \\"Contact not found\\" contacts.delete_contact(\\"Alice\\") print(contacts.get_phone_number(\\"Alice\\")) # Output: \\"Contact not found\\" ``` # Code Structure You need to use the `SeparateChainingHashTable` class to implement the functionalities in the `ContactList` class. Example: ```python class ContactList: def __init__(self): self.table = SeparateChainingHashTable() def add_contact(self, name: str, phone_number: str): self.table.put(name, phone_number) def get_phone_number(self, name: str) -> str: result = self.table.get(name) return result if result is not None else \\"Contact not found\\" def delete_contact(self, name: str): self.table.del_(name) ``` Your task is to complete the `ContactList` class as illustrated.","solution":"class Node: def __init__(self, key, value): self.key = key self.value = value self.next = None class SeparateChainingHashTable: def __init__(self, size=1024): self.size = size self.table = [None] * size def _hash(self, key): return hash(key) % self.size def put(self, key, value): index = self._hash(key) if self.table[index] is None: self.table[index] = Node(key, value) else: current = self.table[index] while True: if current.key == key: current.value = value return if current.next is None: break current = current.next current.next = Node(key, value) def get(self, key): index = self._hash(key) current = self.table[index] while current is not None: if current.key == key: return current.value current = current.next return None def del_(self, key): index = self._hash(key) current = self.table[index] prev = None while current is not None: if current.key == key: if prev is None: self.table[index] = current.next else: prev.next = current.next return prev = current current = current.next class ContactList: def __init__(self): self.table = SeparateChainingHashTable() def add_contact(self, name: str, phone_number: str): self.table.put(name, phone_number) def get_phone_number(self, name: str) -> str: result = self.table.get(name) return result if result is not None else \\"Contact not found\\" def delete_contact(self, name: str): self.table.del_(name)"},{"question":"You are given an array of integers sorted in ascending order and a specific target number. You need to find two different numbers in the array such that their sum equals the target number and return their indices. # Requirements: 1. Implement the `find_indices_binary`, `find_indices_hashtable`, and `find_indices_twopointers` functions to solve the problem using the methodologies discussed: * Binary Search (O(n log n)) * Hash Table (O(n)) * Two Pointers (O(n)) 2. Each function should take two arguments: * `numbers`: A sorted list of integers. * `target`: The integer to which two numbers should sum. 3. Each function should return a list containing two integers: * These integers should be the 1-based indices of the two numbers that add up to the target. * `index1` should be less than `index2`. # Constraints: * `2 <= len(numbers) <= 10^4` * `-10^3 <= numbers[i] <= 10^3` * `-10^3 <= target <= 10^3` * There is exactly one solution. # Example: ```python numbers = [2, 7, 11, 15] target = 9 find_indices_binary(numbers, target) # Returns: [1, 2] find_indices_hashtable(numbers, target) # Returns: [1, 2] find_indices_twopointers(numbers, target) # Returns: [1, 2] ``` # Notes: * Your solution must be efficient in time and space. * Ensure you account for edge cases and invalid inputs.","solution":"def find_indices_binary(numbers, target): This function finds two distinct numbers in \'numbers\' that sum up to the target using binary search. def binary_search(arr, x, low, high): while low <= high: mid = (low + high) // 2 if arr[mid] == x: return mid elif arr[mid] < x: low = mid + 1 else: high = mid - 1 return -1 for i in range(len(numbers)): complement = target - numbers[i] j = binary_search(numbers, complement, i + 1, len(numbers) - 1) if j != -1: return [i + 1, j + 1] def find_indices_hashtable(numbers, target): This function finds two distinct numbers in \'numbers\' that sum up to the target using hash table. seen = {} for i, num in enumerate(numbers): complement = target - num if complement in seen: return [seen[complement] + 1, i + 1] seen[num] = i def find_indices_twopointers(numbers, target): This function finds two distinct numbers in \'numbers\' that sum up to the target using two pointers. left, right = 0, len(numbers) - 1 while left < right: current_sum = numbers[left] + numbers[right] if current_sum == target: return [left + 1, right + 1] elif current_sum < target: left += 1 else: right -= 1"},{"question":"You are tasked with implementing a function to perform a ternary search on a sorted array of integers. The function should return the index of the target value if it exists in the array, otherwise, it should return -1. # Function Signature ```python def ternary_search(arr: List[int], key: int) -> int: pass ``` # Input - `arr`: A list of integers sorted in ascending order, with length `n` (0 <= n <= 10^4). - `key`: An integer that you need to search within `arr`. # Output - Returns the index of `key` in the array if found, otherwise returns -1. # Constraints - The array can be empty. - Every integer in the array will be within the range of -10^6 to 10^6. # Examples Example 1: ```python arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] key = 5 ternary_search(arr, key) # Output: 4 ``` Example 2: ```python arr = [2, 4, 6, 8, 10, 12, 14, 16, 18, 20] key = 15 ternary_search(arr, key) # Output: -1 ``` Example 3: ```python arr = [] key = 5 ternary_search(arr, key) # Output: -1 ``` # Instructions 1. Implement the `ternary_search` function using the ternary search technique. 2. Ensure to handle edge cases such as empty arrays. 3. Follow the algorithm\'s paradigm of divide and conquer precisely as described above. 4. Write your implementation considering the efficiency both in terms of time and space.","solution":"from typing import List def ternary_search(arr: List[int], key: int) -> int: Performs a ternary search on a sorted array to find the key. :param arr: List of integers (sorted in ascending order) :param key: The integer value to search for in the array :return: The index of the key if found, otherwise -1 def search(l, r): if l > r: return -1 third = (r - l) // 3 mid1 = l + third mid2 = r - third if arr[mid1] == key: return mid1 if arr[mid2] == key: return mid2 if key < arr[mid1]: return search(l, mid1 - 1) elif key > arr[mid2]: return search(mid2 + 1, r) else: return search(mid1 + 1, mid2 - 1) return search(0, len(arr) - 1)"},{"question":"You work at a company that models various probabilistic systems. You are tasked with creating a Markov Chain-based simulation to predict the sequence of states for a given Markov Chain. Given the description and functions provided, implement a function that simulates a specific number of steps in the Markov Chain starting from a given initial state. # Function Signature ```python def simulate_markov_chain(chain: dict, initial_state: str, steps: int) -> list: Simulates a series of state transitions for a given number of steps in a Markov Chain. Parameters: - chain (dict): A dictionary representing the Markov Chain. - initial_state (str): The initial state from which the simulation begins. - steps (int): The number of transitions to simulate. Returns: - list: A list of states representing the sequence of state transitions. ``` # Input - `chain`: A dictionary where each key is a state and its value is another dictionary representing the next states and their transition probabilities. - `initial_state`: A string representing the state to start the simulation. - `steps`: An integer representing the number of transitions you want to simulate. # Output - A list of states representing the sequence of transitions starting from the initial state. # Constraints 1. You can assume all probabilities in `chain` sum to 1 for each state. 2. The `steps` integer will be non-negative (0 ≤ steps ≤ 10^4). # Example ```python chain = { \'A\': {\'A\': 0.6, \'E\': 0.4}, \'E\': {\'A\': 0.7, \'E\': 0.3} } initial_state = \'A\' steps = 5 # Possible output: [\'A\', \'E\', \'A\', \'A\', \'E\'] print(simulate_markov_chain(chain, initial_state, steps)) ``` # Notes * The output sequence should reflect the simulated states starting from the `initial_state` for the given number of steps. * Use the provided functions (`__choose_state`, `next_state`, and `iterating_markov_chain`) as necessary but ensure `simulate_markov_chain` is a self-contained function.","solution":"import random def simulate_markov_chain(chain, initial_state, steps): Simulates a series of state transitions for a given number of steps in a Markov Chain. Parameters: - chain (dict): A dictionary representing the Markov Chain. - initial_state (str): The initial state from which the simulation begins. - steps (int): The number of transitions to simulate. Returns: - list: A list of states representing the sequence of state transitions. def choose_state(transition_probs): Chooses the next state based on the transition probabilities. states = list(transition_probs.keys()) probabilities = list(transition_probs.values()) return random.choices(states, probabilities)[0] current_state = initial_state states_sequence = [current_state] for _ in range(steps): current_state = choose_state(chain[current_state]) states_sequence.append(current_state) return states_sequence"},{"question":"You are tasked with implementing a function that joins parts of a URL or file path into a standardized format with single-dividers. The function should ensure that there is exactly one slash (\\"/\\") between the base and suffix, even if either of them has trailing or leading slashes respectively. **Function Signature**: ```python def standardize_path(base: str, suffix: str) -> str: pass ``` **Input**: - `base` (str): The base part of the path or URL. - `suffix` (str): The suffix part that needs to be appended to base. **Output**: - Returns a string representing the full path created by joining `base` and `suffix` with exactly one dividing slash. **Constraints**: - The base and suffix can be empty strings. - The inputs will only contain printable ASCII characters. **Examples**: ```python assert standardize_path(\\"path/to/dir\\", \\"file\\") == \\"path/to/dir/file\\" assert standardize_path(\\"path/to/dir/\\", \\"file\\") == \\"path/to/dir/file\\" assert standardize_path(\\"http://algorithms.com/\\", \\"part\\") == \\"http://algorithms.com/part\\" assert standardize_path(\\"http://algorithms.com\\", \\"/part\\") == \\"http://algorithms.com/part\\" assert standardize_path(\\"\\", \\"/file\\") == \\"/file\\" assert standardize_path(\\"path\\", \\"\\") == \\"path\\" ``` **Edge Cases**: - The base is an empty string and the suffix starts with a slash. - The base ends with a slash and the suffix is an empty string. - Both the base and suffix are empty strings. Your solution should handle these edge cases gracefully while maintaining the expected single slash divider between base and suffix. You cannot use external libraries such as `os`.","solution":"def standardize_path(base: str, suffix: str) -> str: Joins the base and suffix ensuring there\'s exactly one slash between them. if not base and not suffix: return \\"\\" # Remove any leading slash from suffix suffix = suffix.lstrip(\'/\') # Ensure there\'s no trailing slash in base if it’s not empty if base and base[-1] == \'/\': base = base.rstrip(\'/\') # Combine base and suffix with a single slash if base and suffix: return f\\"{base}/{suffix}\\" elif base: return base else: return f\\"/{suffix}\\""},{"question":"# Bogo Sort Implementation Challenge Context Bogo Sort, also whimsically known as Monkey Sort or Stupid Sort, is a highly ineffective and impractical sorting algorithm that permutes an array randomly until it is sorted. While its conceptual simplicity is intriguing, its execution can be extraordinarily time-consuming for all but the smallest datasets. Problem Statement You are required to implement the Bogo Sort algorithm. Specifically, you must write a function that takes an array of integers and sorts it using the Bogo Sort algorithm. Function Signature ```python def bogo_sort(arr: List[int]) -> List[int]: pass ``` Input * An array `arr` of `n` integers where (1 leq n leq 10). * Each integer in the array ( arr[i] ) will be in the range (-10^6 leq arr[i] leq 10^6). Output * The sorted array in non-decreasing order. Constraints * You must use the Bogo Sort method detailed. No alternative sorting algorithms are allowed. * Your implementation must include a check to ensure the array is sorted before finishing. Performance Requirements Given the inherently inefficient nature of Bogo Sort, there are no strict performance requirements for large inputs. However, your code should handle all edge cases and perform correctly within the provided input constraints. Example ```python # Input arr = [3, 1, 2] # Output [1, 2, 3] ``` ```python # Input arr = [5, 4, 3, 2, 1] # Output [1, 2, 3, 4, 5] ``` Notes - Consider the behavior and potential pitfalls associated with random shuffling and sorting checks. - Ensure your code handles edge cases gracefully, including arrays that might already be sorted.","solution":"import random from typing import List def is_sorted(arr: List[int]) -> bool: Helper function to check if the array is sorted. for i in range(len(arr) - 1): if arr[i] > arr[i + 1]: return False return True def bogo_sort(arr: List[int]) -> List[int]: Sorts the given array using the Bogo Sort algorithm. while not is_sorted(arr): random.shuffle(arr) return arr"},{"question":"Coding Assessment Question: # Scenario: You are working on a large dataset embedded in an application that allows users to search for specific values efficiently. The data is stored in a 2D matrix, where each row and each column is sorted in non-decreasing order. Your task is to implement an efficient search function to determine whether a specific value exists within this matrix. # Requirements: 1. **Function Signature**: ```python def search_in_a_sorted_matrix(matrix, key): :param matrix: List of Lists of integers, where each row and each column is sorted in non-decreasing order :param key: Integer, the value to search for within the matrix :return: Tuple of (row, column) if the key is found or (-1, -1) if the key is not found ``` 2. **Input**: - `matrix`: A list of lists of integers `[list1, list2, list3, ...]` where each inner list represents a row in the matrix and is already sorted. Each column in the matrix is also sorted. - `key`: An integer value which you need to search for within the matrix. 3. **Output**: - Return a tuple `(row_index, column_index)` representing the position of the key in the matrix (0-indexed). If the key is not found, return `(-1, -1)`. 4. **Constraints**: - The function should run in O(m + n) time complexity where `m` is the number of rows and `n` is the number of columns. - The function should use O(1) additional space. # Examples: ```python # Example 1 matrix = [ [2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20] ] key = 13 print(search_in_a_sorted_matrix(matrix, key)) # Output: (1, 2) # Example 2 matrix = [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] key = 20 print(search_in_a_sorted_matrix(matrix, key)) # Output: (-1, -1) ``` # Notes: - Handle empty matrices by returning (-1, -1). - Ensure the matrix follows the sorted constraint both row-wise and column-wise to apply the algorithm effectively.","solution":"def search_in_a_sorted_matrix(matrix, key): Search for a key in a 2D matrix where each row and each column is sorted in non-decreasing order. :param matrix: List of Lists of integers, where each row and each column is sorted in non-decreasing order :param key: Integer, the value to search for within the matrix :return: Tuple of (row, column) if the key is found or (-1, -1) if the key is not found if not matrix or not matrix[0]: return (-1, -1) rows, cols = len(matrix), len(matrix[0]) row, col = 0, cols - 1 while row < rows and col >= 0: if matrix[row][col] == key: return (row, col) elif matrix[row][col] > key: col -= 1 else: row += 1 return (-1, -1)"},{"question":"# Scenario: You are working as a software engineer developing a communication protocol for a client-server application. The client needs to transmit a list of strings to the server efficiently, and the server needs to decode this list back to its original form. You are required to implement the encoding and decoding functions to achieve this task. # Task: Implement the following methods to encode and decode a list of strings: Function Signature: ```python def encode(strs: List[str]) -> str: Encodes a list of strings to a single string. :type strs: List[str] :rtype: str # Your code here def decode(s: str) -> List[str]: Decodes a single string to a list of strings. :type s: str :rtype: List[str] # Your code here ``` Input: - **encode** function: * `strs`: List of strings (e.g., [\\"hello\\", \\"world\\"]) - **decode** function: * `s`: Single encoded string (e.g., \\"5:hello5:world\\") Output: - **encode**: A single string representing the encoded list of strings. - **decode**: A list of strings decoded from the encoded string. Constraints: - Assume strings do not contain the character \\":\\". - The length of each string does not exceed 10^5. - The total number of strings does not exceed 10^4. # Examples: ```python # Example 1 input_list = [\\"hello\\", \\"world\\"] encoded_string = encode(input_list) # encoded_string should be \\"5:hello5:world\\" decoded_list = decode(encoded_string) # decoded_list should be [\\"hello\\", \\"world\\"] # Example 2 input_list = [\\"\\"] encoded_string = encode(input_list) # encoded_string should be \\"0:\\" decoded_list = decode(encoded_string) # decoded_list should be [\\"\\"] ``` Ensure your implementation adheres to the constraints and can handle edge cases, such as an empty list of strings.","solution":"from typing import List def encode(strs: List[str]) -> str: Encodes a list of strings to a single string. encoded_string = \\"\\" for s in strs: length = len(s) encoded_string += f\\"{length}:{s}\\" return encoded_string def decode(s: str) -> List[str]: Decodes a single string to a list of strings. decoded_list = [] i = 0 while i < len(s): # Get the length of the next string j = s.find(\':\', i) length = int(s[i:j]) # Extract the string based on the length found decoded_list.append(s[j+1:j+1+length]) # Move to the next encoded string i = j + 1 + length return decoded_list"},{"question":"Context You are tasked with extending the functionality of a given Markov Chain implementation. Specifically, you need to implement a function that will generate a finite sequence of state transitions starting from an initial state, as well as a function to validate the Markov Chain input. Objectives 1. **Generate a Sequence**: Write a function `generate_sequence(chain, start_state, num_steps)` that, given a Markov chain, a start state, and the number of steps, generates a sequence of state transitions of the specified length using the provided Markov chain. 2. **Validate Markov Chain**: Write a function `validate_chain(chain)` that ensures the Markov chain is valid. The chained should be validated to ensure that probabilities for all state transitions sum up to 1. If invalid, raise a `ValueError` with an appropriate message. Function Signatures ```python def generate_sequence(chain: dict, start_state: str, num_steps: int) -> list: pass def validate_chain(chain: dict) -> bool: pass ``` Expected Input and Output * `generate_sequence`: * **Input**: * `chain` - a dictionary representing the Markov chain. * `start_state` - a string representing the starting state. * `num_steps` - an integer indicating how many steps in the sequence. * **Output**: * a list of states representing the sequence generated. * `validate_chain`: * **Input**: * `chain` - a dictionary representing the Markov chain. * **Output**: * a boolean indicating whether the chain is valid (True) or not (raises ValueError). Constraints * For `generate_sequence`: * The chain will at least have one state with valid transitions summed up to 1. * The `num_steps` will be a positive integer. * For `validate_chain`: * The chain dictionary structure will be well-formed. Example Usage ```python chain_example = { \'A\': {\'A\': 0.6, \'E\': 0.4}, \'E\': {\'A\': 0.7, \'E\': 0.3} } # Validation try: validate_chain(chain_example) # Should return True or not raise an error except ValueError as e: print(e) # Generate sequence sequence = generate_sequence(chain_example, \'A\', 5) print(sequence) # Example output: [\'A\', \'E\', \'A\', \'E\', \'A\'] ``` Notes 1. Remember to consider edge cases such as chains with no outgoing transitions. 2. Testing the functions with various chains, including edge cases, will be critical to ensuring robustness.","solution":"import random def generate_sequence(chain: dict, start_state: str, num_steps: int) -> list: Generates a sequence of state transitions of specified length using the provided Markov chain. :param chain: A dictionary representing the Markov chain. :param start_state: A string representing the starting state. :param num_steps: An integer indicating the number of steps in the sequence. :return: A list of states representing the sequence generated. sequence = [start_state] current_state = start_state for _ in range(num_steps): next_state = random.choices( population=list(chain[current_state].keys()), weights=list(chain[current_state].values()) )[0] sequence.append(next_state) current_state = next_state return sequence def validate_chain(chain: dict) -> bool: Validates that the given Markov chain is properly formed with probabilities summing up to 1. :param chain: A dictionary representing the Markov chain. :return: True if the chain is valid, raises ValueError otherwise. for state, transitions in chain.items(): if not (0 <= sum(transitions.values()) <= 1): raise ValueError(f\\"Transition probabilities for state \'{state}\' do not sum up to 1.\\") return True"},{"question":"You are provided with a broken sorting algorithm notoriously known as Bogo Sort. Your task is to refactor the existing Bogo Sort implementation so that it can sort arrays more efficiently than before and avoid random shuffling. **Requirements**: 1. Implement an Efficient Sorting Algorithm (such as Quick Sort, Merge Sort, or Heap Sort) to replace Bogo Sort. 2. Ensure all expected input and output formats are maintained. 3. Consider edge cases, performance bottlenecks, and error scenarios. 4. The function must sort the array in non-decreasing order. 5. You can rewrite the entire function if necessary, but maintain the same function signature. Input: * A list of integers `arr` which needs to be sorted. * An optional boolean parameter `simulation`. Output: * A sorted list of integers. Constraints: * The length of the input array `n` will be (1 leq n leq 10^4). * The elements of the array will be within the range (-10^5 leq arr[i] leq 10^5). Example: ```python # Example Input arr = [3, 2, 1, 5, 4] simulation = False # Example Output [1, 2, 3, 4, 5] ``` # Function Signature ```python def bogo_sort(arr: list, simulation: bool = False) -> list: # Your improved sorting algorithm instead of Bogo Sort pass ``` # Simulation Mode: When `simulation` is set to `True`, at each meaningful step of your algorithm, print the current state of the array followed by the description of the operation performed (e.g., after each partition step in Quick Sort). Note: This problem originally used a highly inefficient sorting algorithm (Bogo Sort) for demonstration purposes. You are expected to replace it with a more efficient algorithm for practical use.","solution":"def bogo_sort(arr: list, simulation: bool = False) -> list: Function to sort an array using a more efficient sorting algorithm (Quick Sort) instead of Bogo Sort. Args: arr (list): A list of integers to be sorted. simulation (bool): If True, print each step of the algorithm\'s execution. Returns: list: Sorted list of integers. def quick_sort(arr, low, high): if low < high: pi = partition(arr, low, high) if simulation: print(f\\"Partitioning with pivot {arr[pi]} at index {pi}: {arr}\\") quick_sort(arr, low, pi-1) quick_sort(arr, pi+1, high) def partition(arr, low, high): pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i+1], arr[high] = arr[high], arr[i+1] return i+1 n = len(arr) quick_sort(arr, 0, n-1) return arr"},{"question":"Custom Comb Sort You are provided with a modified version of the Comb Sort algorithm. Your task is to implement this modified version with additional features. Features to Implement: 1. **Custom Gap Sequence**: Allow the user to provide a custom sequence of gaps instead of a fixed shrink factor. If the sequence is empty or not provided, the standard shrink factor of 1.3 should be used. 2. **Order Selection**: Implement functionality to sort the array in either ascending or descending order based on user input. Function Signature: ```python def custom_comb_sort(arr: List[int], gap_sequence: Optional[List[int]] = None, order: str = \'ascending\') -> List[int]: pass ``` Parameters: * **arr (List[int])**: The list of integers to be sorted. * **gap_sequence (Optional[List[int]])**: An optional list of integers representing the custom gap sequence. * **order (str)**: A string specifying the order of sorting. It can be either \'ascending\' or \'descending\'. Default is \'ascending\'. Return: * **List[int]**: The sorted list of integers. Examples: ```python assert custom_comb_sort([5, 3, 8, 4, 2], [4, 3, 2], \'ascending\') == [2, 3, 4, 5, 8] assert custom_comb_sort([1, 4, 10, 2], [3, 2], \'descending\') == [10, 4, 2, 1] assert custom_comb_sort([4, 6, 2], order=\'ascending\') == [2, 4, 6] ``` Constraints: * The array length `n` will be in the range `[1, 1000]`. * Values in the array will be integers in the range `[-10^6, 10^6]`. * If a custom gap sequence is provided, it will always contain positive integers. Performance Requirements: * Optimize for time and space complexity given the constraints.","solution":"from typing import List, Optional def custom_comb_sort(arr: List[int], gap_sequence: Optional[List[int]] = None, order: str = \'ascending\') -> List[int]: def get_next_gap(gap): # Standard shrink factor if no custom gap sequence is provided return int(gap / 1.3) if gap_sequence is None or not gap_sequence: gap_sequence = [] # Use standard shrink factor mechanism n = len(arr) gap_index = 0 gap = gap_sequence[gap_index] if gap_index < len(gap_sequence) else n if order == \'ascending\': comparator = lambda x, y: x > y elif order == \'descending\': comparator = lambda x, y: x < y else: raise ValueError(\\"Order must be either \'ascending\' or \'descending\'\\") while gap > 1 or gap_index < len(gap_sequence): swapped = False for i in range(n - gap): if comparator(arr[i], arr[i + gap]): arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True if gap_index < len(gap_sequence): gap_index += 1 if gap_index < len(gap_sequence): gap = gap_sequence[gap_index] else: gap = get_next_gap(gap) else: gap = get_next_gap(gap) # Final bubble pass in case of gaps that left the list nearly sorted for i in range(n - 1): for j in range(n - 1 - i): if comparator(arr[j], arr[j + 1]): arr[j], arr[j + 1] = arr[j + 1], arr[j] return arr"},{"question":"# Question: String Reversal Comparison Scenario You are given multiple implementations for reversing a string. Your task is to write an optimized function that, given a string, will reverse it and ensure you handle edge cases efficiently. Furthermore, you need to analyze and improve one of the given methods to optimize for both time and space complexity. Task 1. Implement a function `reverse_string(s: str) -> str` which reverses a given string using an **optimized** approach. 2. Identify the given `recursive` method, describe potential inefficiencies and rewrite it as `optimized_recursive(s: str) -> str` without using excessive memory or facing performance bottlenecks. Input Format * A single string `s`. Output Format * A single string which is the reversed form of `s`. Constraints * The length of string `s` will be between `1` and `10^5`. * The string will contain printable ASCII characters only. Example ```plaintext Input: \\"hello\\" Output: \\"olleh\\" ``` ```plaintext Input: \\"A man, a plan, a canal, Panama\\" Output: \\"amanaP ,lanac a ,nalp a ,nam A\\" ``` Hints * Consider edge cases like an empty string and single-character strings. * Avoid deep recursion and excessive slicing for large strings. * Both time and space complexity improvements are important for large inputs. ```python def reverse_string(s): # Write your optimized code here pass def optimized_recursive(s): # Write an optimized version of the recursive reversal here pass ```","solution":"def reverse_string(s: str) -> str: Reverses the given string using an optimized approach. return s[::-1] def optimized_recursive(s: str) -> str: Optimized recursive method to reverse the given string. def helper(start, end, s_list): if start >= end: return s_list[start], s_list[end] = s_list[end], s_list[start] helper(start + 1, end - 1, s_list) s_list = list(s) helper(0, len(s) - 1, s_list) return \'\'.join(s_list)"},{"question":"# Question: Implement an Optimized Moving Average Class Given a stream of integers and a fixed window size, implement an optimized class `EfficientMovingAverage` that calculates the moving average efficiently by updating the sum incrementally. Your class should handle streams of any length efficiently, including continuous updates. Input: 1. An integer `size` representing the window size. 2. A series of integers representing the stream. Output: - The moving average for each integer added to the stream after the window has at least one element. Constraints: - The window size will be a positive integer. - The stream elements will be integers between -10^5 and 10^5. - The moving average result should be a floating point number. Example: ```python m = EfficientMovingAverage(3) print(m.next(1)) # Output: 1.0 print(m.next(10)) # Output: 5.5 print(m.next(3)) # Output: 4.666666666666667 print(m.next(5)) # Output: 6.0 ``` Performance Requirements: - The solution must maintain O(1) operations for adding a new element and updating the sum. Implementation: Implement the `EfficientMovingAverage` class as described. ```python from collections import deque class EfficientMovingAverage: def __init__(self, size): Initialize your data structure here. :type size: int self.queue = deque(maxlen=size) self.size = size self.sum = 0 def next(self, val): :type val: int :rtype: float if len(self.queue) == self.size: self.sum -= self.queue.popleft() self.queue.append(val) self.sum += val return self.sum / len(self.queue) # Example Usage: if __name__ == \'__main__\': m = EfficientMovingAverage(3) print(m.next(1)) # Output: 1.0 print(m.next(10)) # Output: 5.5 print(m.next(3)) # Output: 4.666666666666667 print(m.next(5)) # Output: 6.0 ```","solution":"from collections import deque class EfficientMovingAverage: def __init__(self, size): Initialize your data structure here. :type size: int self.queue = deque(maxlen=size) self.size = size self.sum = 0 def next(self, val): :type val: int :rtype: float if len(self.queue) == self.size: self.sum -= self.queue.popleft() self.queue.append(val) self.sum += val return self.sum / len(self.queue)"},{"question":"Sparse Matrix Multiplication Context You are part of a software development team tasked with creating an efficient algorithm to multiply large sparse matrices as used in scientific computations. The goal is to ensure the program only processes non-zero elements to save time and computational resources. Task Write a function `sparse_matrix_multiply(A: List[List[int]], B: List[List[int]]) -> List[List[int]]` that multiplies two sparse matrices, `A` and `B`, and returns the resulting matrix. Input - `A`: A list of lists of integers representing matrix A (dimension m x n). - `B`: A list of lists of integers representing matrix B (dimension n x l). Output - A list of lists of integers representing the resulting matrix C (dimension m x l). Constraints - `A`\'s column number must be equal to `B`\'s row number. - Assume matrices contain integers in the range [-100, 100]. - The size of the matrices will not exceed 1000 x 1000. Example ```python A = [ [1, 0, 0], [-1, 0, 3] ] B = [ [7, 0, 0], [0, 0, 0], [0, 0, 1] ] sparse_matrix_multiply(A, B) # Expected Output: # [ # [7, 0, 0], # [-7, 0, 3] # ] ``` Additional Notes: - Handle edge cases such as entire rows or columns being zero. - Ensure the solution does not exceed O(m * l) space complexity for the resultant matrix. Performance Requirement: - The solution should efficiently handle cases where matrices are predominantly zero, with performance benefits for sparsity in both time and space complexity.","solution":"from typing import List def sparse_matrix_multiply(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: Multiplies two sparse matrices A and B optimally to produce the result matrix C. if not A or not A[0] or not B or not B[0]: return [] m, n = len(A), len(A[0]) n_b, l = len(B), len(B[0]) # Initialize the result matrix with zeros C = [[0] * l for _ in range(m)] # Create a sparse representation for matrix B sparse_B = {} for j in range(n_b): for k in range(l): if B[j][k] != 0: if j not in sparse_B: sparse_B[j] = [] sparse_B[j].append((k, B[j][k])) # Multiply A and B using the sparse representation of B for i in range(m): for j in range(n): if A[i][j] != 0: if j in sparse_B: for (k, B_jk) in sparse_B[j]: C[i][k] += A[i][j] * B_jk return C"},{"question":"# Question Scenario In a software project dealing with generation of syntactically correct code snippets, you are required to generate valid combinations of parentheses as part of the syntactic structure validation. You are tasked to write a function to generate all combinations of `n` pairs of well-formed parentheses. Task Implement a function named `generate_parentheses` that accepts an integer `n` and returns a list of all possible combinations of `n` pairs of well-formed parentheses. Function Signature ```python def generate_parentheses(n: int) -> List[str]: pass ``` Input * An integer `n` (0 ≤ n ≤ 8), representing the number of pairs of parentheses. Output * A list of strings, where each string represents a valid combination of `n` pairs of well-formed parentheses. Constraints * The function must generate all possible combinations. * The function must make sure that the parentheses are well-formed and balanced. Example ```python generate_parentheses(3) ``` Output: ```python [ \\"((()))\\", \\"(()())\\", \\"(())()\\", \\"()(())\\", \\"()()()\\" ] ``` # Requirements * Your implementation should handle edge cases efficiently. * Ensure the function performance is optimized for `n` up to 8. * Consider the recursive depth and memory usage in your implementation.","solution":"from typing import List def generate_parentheses(n: int) -> List[str]: Generate all combinations of n pairs of well-formed parentheses. Args: n: int - The number of pairs of parentheses Returns: List[str] - A list of strings, each string representing a valid combination of n pairs of well-formed parentheses. def backtrack(S = \'\', left = 0, right = 0): if len(S) == 2 * n: result.append(S) return if left < n: backtrack(S + \'(\', left + 1, right) if right < left: backtrack(S + \')\', left, right + 1) result = [] backtrack() return result"},{"question":"# Arithmetic Expressions for Target Value Design a function to generate all arithmetic expressions from a given digit string such that the expressions evaluate to a given target value. Your function should return all possible combinations of the digits with binary operators (+, -, *) inserted, including no operator between some digits. Write a function: ```python def generate_expressions(num: str, target: int) -> List[str]: pass ``` # Input Format - `num`: A string containing only digits (0-9). - `target`: An integer representing the desired value for the expression evaluation. # Output Format - Return a list of valid arithmetic expressions (as strings) that evaluate to the given target. # Constraints - All digits in the input string must be used exactly once in the solution expressions. - Unary operators (like negation) are not allowed. - Leading zeros in any segment should be avoided unless the segment itself is zero (e.g., \\"105\\" can result in \\"1*0+5\\" but not \\"1*05\\"). # Example ```python print(generate_expressions(\\"123\\", 6)) # Output: [\\"1+2+3\\", \\"1*2*3\\"] print(generate_expressions(\\"232\\", 8)) # Output: [\\"2*3+2\\", \\"2+3*2\\"] print(generate_expressions(\\"105\\", 5)) # Output: [\\"1*0+5\\", \\"10-5\\"] print(generate_expressions(\\"00\\", 0)) # Output: [\\"0+0\\", \\"0-0\\", \\"0*0\\"] print(generate_expressions(\\"3456237490\\", 9191)) # Output: [] ``` Your implementation should handle all edge cases efficiently and correctly.","solution":"from typing import List def generate_expressions(num: str, target: int) -> List[str]: res = [] def backtrack(index: int, path: str, value: int, prev: int): if index == len(num): if value == target: res.append(path) return for i in range(index, len(num)): if i != index and num[index] == \'0\': break current_str = num[index:i + 1] current_num = int(current_str) if index == 0: backtrack(i + 1, current_str, current_num, current_num) else: backtrack(i + 1, path + \'+\' + current_str, value + current_num, current_num) backtrack(i + 1, path + \'-\' + current_str, value - current_num, -current_num) backtrack(i + 1, path + \'*\' + current_str, value - prev + prev * current_num, prev * current_num) backtrack(0, \'\', 0, 0) return res"},{"question":"# Scenario You are working on a treasure hunt game where players need to find a specific landmark among various landmarks designated on a map. The map is represented as a linear list of landmark names. You have to implement a function to help players quickly locate whether the landmark they are searching for exists on the map and its position. # Task Write a function `find_landmark_position(map_list, landmark)` that helps players find the landmark position in the list. # Function Signature ```python def find_landmark_position(map_list: List[str], landmark: str) -> int: ``` # Input * `map_list`: A list of strings representing names of landmarks (1 ≤ len(map_list) ≤ 100). * `landmark`: A string representing the name of the landmark to find. # Output * Return the index of the `landmark` in `map_list`. If it is not found, return -1. # Constraints * Landmarks\' names are case-sensitive. * Each landmark name in the map list is unique. # Examples ```python map_list = [\\"Tree\\", \\"River\\", \\"Mountain\\", \\"Castle\\"] landmark = \\"Mountain\\" assert find_landmark_position(map_list, landmark) == 2 map_list = [\\"Tree\\", \\"River\\", \\"Mountain\\", \\"Castle\\"] landmark = \\"Ocean\\" assert find_landmark_position(map_list, landmark) == -1 ``` # Performance Requirements * The function should run efficiently for the provided constraints.","solution":"def find_landmark_position(map_list, landmark): Returns the index of the landmark in the map_list. If the landmark is not found, returns -1. try: return map_list.index(landmark) except ValueError: return -1"},{"question":"Objective To assess the student\'s understanding of XOR bit manipulation to find unique elements in an array where all other elements appear exactly twice. Problem Statement Given an array of integers `nums`, in which exactly two elements appear only once while all other elements appear exactly twice, write a function to find the two elements that appear only once. Function Signature ```python def single_number3(nums: List[int]) -> List[int]: pass ``` Input and Output - **Input**: - `nums`: A list of integers where exactly two elements appear only once and all other elements appear exactly twice. Length of the list will always be even. - **Output**: - A list of two integers that appear only once in any order. Constraints - The algorithm must have a time complexity of O(N) and a space complexity of O(1). - The input list will have at least two elements and guarantee there are exactly two single numbers. Example ```python assert sorted(single_number3([1, 2, 1, 3, 2, 5])) == [3, 5] assert sorted(single_number3([4, 1, 2, 1, 2, 3])) == [3, 4] ``` # Performance Requirements - The function should be efficient and complete the task in linear time. - No additional memory should be used apart from a few variables; thus, space complexity should be constant (O(1)). # Note - The order of the resulting two numbers does not matter. Both `[3, 5]` and `[5, 3]` are correct for the given example input `[1, 2, 1, 3, 2, 5]`.","solution":"from typing import List def single_number3(nums: List[int]) -> List[int]: # Step 1: XOR all the numbers in the list. The result will be the XOR of the two unique numbers. xor_result = 0 for num in nums: xor_result ^= num # Step 2: Find the rightmost set bit in the xor_result (this helps to separate the two unique numbers). rightmost_set_bit = xor_result & -xor_result # Step 3: Using the rightmost set bit, partition the numbers into two groups and XOR to find the unique numbers. num1 = 0 num2 = 0 for num in nums: if num & rightmost_set_bit: num1 ^= num else: num2 ^= num return [num1, num2]"},{"question":"Context You have been tasked with implementing a function that processes a list of words by matching and replacing portions of words with the longest matching symbol from a given list of symbols. Problem Statement Given an array of strings `words` and an array of strings `symbols`, implement a function `highlight_symbols` which modifies each word in the `words` list by replacing the longest matching substring (symbol) with the symbol surrounded by square brackets \\"[symbol]\\". If a word contains multiple symbols of the same maximum length, replace it with the one appearing first in the `symbols` array. If no symbols are found in a word, the word remains unchanged. Input * `words`: List of non-empty strings (1 ≤ length of each word ≤ 100) * `symbols`: List of non-empty strings (1 ≤ length of each symbol ≤ 10) Output * List of strings where each original word is modified by replacing the longest matching symbol. Constraints * The list of `symbols` will have at most 100 symbols. * Each symbol will be unique. * Only one symbol will be matched per word. Function Signature ```python def highlight_symbols(words: List[str], symbols: List[str]) -> List[str]: pass ``` Example **Input**: ```python words = [\'Amazon\', \'Microsoft\', \'Google\'] symbols = [\'i\', \'Am\', \'cro\', \'Na\', \'le\', \'abc\'] ``` **Output**: ```python [\'[Am]azon\', \'Mi[cro]soft\', \'Goog[le]\'] ``` Notes * In the example above, \'Amazon\' matches \'Am\' (not \'Na\'), \'Microsoft\' matches \'cro\' (not \'i\'), and \'Google\' matches \'le\'. * Ensure the implementation is efficient for larger datasets.","solution":"from typing import List def highlight_symbols(words: List[str], symbols: List[str]) -> List[str]: symbols.sort(key=len, reverse=True) # Sort symbols by length in descending order modified_words = [] for word in words: modified_word = word for symbol in symbols: if symbol in word: modified_word = word.replace(symbol, f\'[{symbol}]\', 1) break modified_words.append(modified_word) return modified_words"},{"question":"# Insertion Sort with Binary Search Insertion In this task, you are required to implement an insertion sort algorithm using binary search to find the correct insertion point. **Scenario**: Given an unsorted array of integers, the goal is to sort the array using an optimized insertion sort mechanism. Traditional insertion sort has a time complexity of O(n^2) due to linear search for the insertion point. Your implementation should utilize binary search from the provided `search_insert` function to improve the efficiency of locating the correct index, while maintaining the insertion sort approach. # Function Signature ```python def insertion_sort_with_binary_search(arr: list) -> list: ``` # Input - `arr`: A list of integers, where `1 <= len(arr) <= 10^4` and `-10^6 <= arr[i] <= 10^6`. # Output - The function should return a sorted list of integers. # Constraints - The input list may contain duplicate elements. - The input list may be unsorted in any order. # Example ```python assert insertion_sort_with_binary_search([4, 3, 1, 2]) == [1, 2, 3, 4] assert insertion_sort_with_binary_search([10, 5, 8, 3, 6]) == [3, 5, 6, 8, 10] assert insertion_sort_with_binary_search([-1, -10, 0, 10]) == [-10, -1, 0, 10] ``` # Constraints and Performance Requirements - Your solution should be efficient, leveraging the provided `search_insert` to improve the performance of traditional insertion sort. - Aim for a time complexity closer to O(n log n) for the insertion step. # Notes - Use the provided `search_insert` function for finding the insertion index. - Ensure that the final list is sorted in non-decreasing order.","solution":"def search_insert(arr, target): Binary search to find the index where target should be inserted to keep arr sorted. left, right = 0, len(arr) while left < right: mid = (left + right) // 2 if arr[mid] < target: left = mid + 1 else: right = mid return left def insertion_sort_with_binary_search(arr): Sorts a list of integers using insertion sort with binary search for efficient insertion. if not arr: return [] # Traverse from the second element to the end for i in range(1, len(arr)): key = arr[i] # Find the correct position to insert \'key\' using binary search j = search_insert(arr[:i], key) # Shift all elements to the right to create space for the \'key\' arr = arr[:j] + [key] + arr[j:i] + arr[i + 1:] return arr"},{"question":"**Flatten Nested Arrays** You are tasked with writing a function that takes an array which can contain nested arrays of arbitrary depth, and returns a single, flat (one-dimensional) array. Your function must preserve the order of elements and handle all standard iterable types except strings (which should be treated as atomic). Additionally, write a generator function that achieves the same goal but returns a generator object. # Function Signature ```python def flatten(input_arr: list) -> list: pass def flatten_iter(iterable: list) -> \'generator\': pass ``` # Input * **input_arr**: a list which can contain integers, floats, strings, and other lists. * **iterable**: a list which can contain integers, floats, strings, and other lists. # Output * `flatten`: returns a flattened list of elements. * `flatten_iter`: returns a generator that yields flattened elements one by one. # Constraints * You may assume that the input does not contain circular references (i.e., no list will contain itself directly or indirectly). * Depth of the nested list ≤ 1000. * Number of elements in the list ≤ 10^5. # Examples ```python assert flatten([1, [2, 3], [4, [5, 6]], 7]) == [1, 2, 3, 4, 5, 6, 7] flattened_iter = flatten_iter([1, [2, 3], [4, [5, 6]], 7]) assert list(flattened_iter) == [1, 2, 3, 4, 5, 6, 7] assert flatten([]) == [] ``` # Edge Cases * An empty input list should result in an empty output list or generator. * A list with no nested elements should return itself. * The function should handle nested empty lists properly. # Requirements * Use recursion or an equivalent method to handle nested structures. * The `flatten_iter` function must return a generator yielding elements one by one.","solution":"def flatten(input_arr: list) -> list: Flattens a nested list of arbitrary depth into a single list. flat_list = [] def _flatten(sublist): for item in sublist: if isinstance(item, list): _flatten(item) else: flat_list.append(item) _flatten(input_arr) return flat_list def flatten_iter(iterable: list): A generator function that flattens a nested list of arbitrary depth. for item in iterable: if isinstance(item, list): yield from flatten_iter(item) else: yield item"},{"question":"# Randomized Set Implementation Challenge You are required to implement a data structure named `RandomizedSet` that supports the following operations in average O(1) time: 1. **insert(val)**: Inserts an item `val` to the set if not already present. 2. **remove(val)**: Removes an item `val` from the set if present. 3. **random_element()**: Returns a random element from the current set of elements. Each element must have the same probability of being returned. Input and Output Formats - The input will be a series of operations to be performed on the `RandomizedSet`, along with optional values. - The output will be the result of the corresponding operations as per the specifications. Constraints - Duplicate insertions should be ignored. - Random element retrieval should return an existing element with uniform probability. - The data structure should handle at least 10000 operations efficiently. Example ```python # Create a new RandomizedSet rand_set = RandomizedSet() # Insert value 10 to the set rand_set.insert(10) # Insert value 20 to the set rand_set.insert(20) # Remove value 10 from the set rand_set.remove(10) # Retrieve a random element from the set print(rand_set.random_element()) # Should return 20 since it\'s the only element left ``` Notes: - You should handle edge cases such as attempting to remove an element that does not exist and calling `random_element()` on an empty data structure. Implement the `RandomizedSet` data structure as specified.","solution":"import random class RandomizedSet: def __init__(self): self.dict = {} self.list = [] def insert(self, val: int) -> bool: Inserts an item val to the set if not already present. Returns True if the item was inserted, False otherwise. if val in self.dict: return False self.dict[val] = len(self.list) self.list.append(val) return True def remove(self, val: int) -> bool: Removes an item val from the set if present. Returns True if the item was removed, False otherwise. if val not in self.dict: return False # Move the last element to the place of the element to delete last_element, idx_to_remove = self.list[-1], self.dict[val] self.list[idx_to_remove], self.dict[last_element] = last_element, idx_to_remove # Remove the last element self.list.pop() del self.dict[val] return True def random_element(self) -> int: Returns a random element from the current set of elements. return random.choice(self.list)"},{"question":"You are given a singly linked list where each node contains an integer value. Implement a function to remove duplicates from this linked list without using any additional data structures. Your algorithm should be designed to run in O(N^2) time complexity and O(1) space complexity. # Function Signature ```python def remove_duplicates(head: Node) -> None: pass ``` # Input * `head` (Node): The head node of the singly linked list. # Output * The function should modify the linked list in place to remove duplicates. * The function does not need to return any value. # Constraints * The linked list can have up to (10^4) nodes. * The values within the nodes are integers which can range from (-10^6) to (10^6). # Example ```python # Suppose we have a linked list: 1 -> 2 -> 3 -> 2 -> 4 -> 3 -> 5 -> None # After removing duplicates, it should become: 1 -> 2 -> 3 -> 4 -> 5 -> None class Node: def __init__(self, val = 0, next = None): self.val = val self.next = next def print_linked_list(head): current = head while current: print(current.val, end=\\" -> \\") current = current.next print(\\"None\\") # Creating linked list for the example head = Node(1, Node(2, Node(3, Node(2, Node(4, Node(3, Node(5))))))) remove_duplicates(head) print_linked_list(head) # Expected output: 1 -> 2 -> 3 -> 4 -> 5 -> None ```","solution":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_duplicates(head): Removes duplicates from the linked list in-place. This algorithm runs in O(N^2) time complexity and O(1) space complexity. current = head while current: runner = current while runner.next: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next"},{"question":"# Scenario: Your task is to implement a simple text editor with an undo functionality for the latest operations performed. For this, we will be using a doubly linked list. # Question: Implement a doubly linked list that supports the following operations: - **Append**: Add a node with a specified value to the end of the list. - **Undo**: Remove the last node added to the list. - **Print List**: Print all the values in the list from the head to the end. # Requirements: 1. Your implementation should handle dynamic resizing without defining a fixed size at initialization. 2. Your doubly linked list should allow traversal in both directions, though only forward traversal may be necessary for output. 3. Implement error handling for undo operation when there are no elements to remove. # Signature Your class should be implemented as follows: ```python class DoublyLinkedListNode: def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def append(self, value): Append a node with the given value to the end. pass def undo(self): Remove the last node added to the list. pass def print_list(self): Print all values in the list from the head to the tail. pass ``` # Example ```plaintext # Append 1, 2, 3 dll = DoublyLinkedList() dll.append(1) dll.append(2) dll.append(3) dll.print_list() # Output: 1 -> 2 -> 3 # Undo last append dll.undo() dll.print_list() # Output: 1 -> 2 ```","solution":"class DoublyLinkedListNode: def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def append(self, value): new_node = DoublyLinkedListNode(value) if self.tail is None: # empty list self.head = new_node self.tail = new_node else: self.tail.next = new_node new_node.prev = self.tail self.tail = new_node def undo(self): if self.tail is None: return # nothing to undo if self.head == self.tail: # only one element self.head = None self.tail = None else: self.tail = self.tail.prev self.tail.next = None def print_list(self): current = self.head result = [] while current: result.append(str(current.value)) current = current.next print(\' -> \'.join(result))"},{"question":"# Gnome Sort in a Dynamic List Scenario You are given the task of implementing a sorting function using the Gnome Sort algorithm. As a part of this, you need to ensure the function can handle being given in a dynamic list scenario: elements might be frequently added to the list, and you need to maintain the list in sorted order after each addition. Function Signature: ```python def dynamic_gnome_sort(initial_list, new_elements): pass ``` Parameters: * `initial_list (List[int])`: A list of integers pre-sorted in ascending order. * `new_elements (List[int])`: A list of integers that can be added one by one to the `initial_list`. Returns: * `List[int]`: A new sorted list after all elements from `new_elements` have been added to `initial_list`. # Task & Constraints: * Implement `dynamic_gnome_sort` to utilize the Gnome Sort algorithm. * Maintain the overall sorted order of the dynamic list after each element addition from new_elements. * The solution must adhere to the operational mechanism of Gnome Sort. * The constraints are as follows: * The length of `initial_list` and `new_elements` will be up to 1000 elements each. * The elements in the lists will be integers within the range -10^6 to 10^6. # Example: ```python initial_list = [1, 3, 5, 7] new_elements = [2, 6, 4] print(dynamic_gnome_sort(initial_list, new_elements)) # Expected Output: [1, 2, 3, 4, 5, 6, 7] ```","solution":"def gnome_sort(arr): Performs Gnome Sort on the list. index = 0 while index < len(arr): if index == 0 or arr[index] >= arr[index - 1]: index += 1 else: arr[index], arr[index - 1] = arr[index - 1], arr[index] index -= 1 return arr def dynamic_gnome_sort(initial_list, new_elements): Adds elements from new_elements to initial_list one by one, sorting the list using Gnome Sort after each addition. for element in new_elements: initial_list.append(element) gnome_sort(initial_list) return initial_list"},{"question":"# Question: Advanced GCD Analysis and Application You have been provided with two different implementations of the greatest common divisor (GCD) - one using Euclid\'s division-based algorithm and the other using bitwise operations. Additionally, you understand the relationship between GCD and the least common multiple (LCM). Leveraging these concepts, you need to solve the following problem efficiently. **Problem Statement**: Given two non-negative integers, `a` and `b`, you need to implement a function that: 1. Computes and returns the GCD using the efficient bitwise method. 2. Computes and returns the LCM of the two integers. 3. Computes and returns the number of trailing zeros in the binary representation of the LCM. 4. Returns all three results in a tuple. # Function Signature: ```python def advanced_gcd_analysis(a: int, b: int) -> tuple: pass ``` # Constraints: - `0 <= a, b <= 10^9` # Example: ```python advanced_gcd_analysis(34, 40) ``` Output: ```python (2, 680, 3) ``` # Explanation: - The GCD of 34 and 40 using a bitwise method is 2. - The LCM of 34 and 40 is 680. - The binary representation of 680 is `1010101000`, which has 3 trailing zeros. Ensure that your function handles edge cases and is optimized for performance. Use helper functions when necessary to modularize your code.","solution":"def gcd_bitwise(a, b): Computes the GCD using the efficient bitwise method. if a == 0: return b if b == 0: return a # Finding common factors of 2 shift = 0 while ((a | b) & 1) == 0: a >>= 1 b >>= 1 shift += 1 while (a & 1) == 0: a >>= 1 while b != 0: while (b & 1) == 0: b >>= 1 if a > b: a, b = b, a b -= a return a << shift def lcm(a, b, gcd_value): Computes the LCM using the relationship between GCD and LCM. if a == 0 or b == 0: return 0 return abs(a * b) // gcd_value def count_trailing_zeros(n): Computes the number of trailing zeros in the binary representation of n. count = 0 while n > 0 and (n & 1) == 0: count += 1 n >>= 1 return count def advanced_gcd_analysis(a: int, b: int) -> tuple: gcd_value = gcd_bitwise(a, b) lcm_value = lcm(a, b, gcd_value) trailing_zeros_count = count_trailing_zeros(lcm_value) return gcd_value, lcm_value, trailing_zeros_count"},{"question":"You are required to implement a WordDictionary class where you can add words and search words using regular expression containing \'.\' where \'.\' can be any single letter. Your implementation should use a Trie (prefix tree) as the underlying data structure to allow efficient insertion and searching of words. # Method Signatures ```python class WordDictionary: def __init__(self): pass # Initialize your data structure here. def add_word(self, word: str) -> None: pass # Adds a word into the data structure. def search(self, word: str) -> bool: pass # Returns True if there is any string in the data structure that matches word or false otherwise. ``` # Expected Input and Output Formats - **add_word(word: str) -> None** - **Input**: - `word`: A non-empty string consisting of lowercase English letters. - **Output**: None. - **search(word: str) -> bool** - **Input**: - `word`: A string consisting of lowercase English letters or the character \'.\'. - **Output**: `True` if there is a word in the data structure that matches `word`, `False` otherwise. # Constraints - The sum of the lengths of words added will not exceed 10^6. - Length of any single word will not exceed 255. # Example ```python wordDictionary = WordDictionary() wordDictionary.add_word(\\"bad\\") wordDictionary.add_word(\\"dad\\") wordDictionary.add_word(\\"mad\\") print(wordDictionary.search(\\"pad\\")) # returns False print(wordDictionary.search(\\"bad\\")) # returns True print(wordDictionary.search(\\".ad\\")) # returns True print(wordDictionary.search(\\"b..\\")) # returns True ``` # Notes - Focus on optimizing the time complexity of the search function. - Consider edge cases such as searching for strings with multiple wildcard characters.","solution":"class TrieNode: def __init__(self): self.children = {} self.isEndOfWord = False class WordDictionary: def __init__(self): self.root = TrieNode() def add_word(self, word: str) -> None: current = self.root for char in word: if char not in current.children: current.children[char] = TrieNode() current = current.children[char] current.isEndOfWord = True def search(self, word: str) -> bool: def search_in_node(word, node): for i, char in enumerate(word): if char == \'.\': for child in node.children.values(): if search_in_node(word[i+1:], child): return True return False else: if char not in node.children: return False node = node.children[char] return node.isEndOfWord return search_in_node(word, self.root)"},{"question":"You are given a binary search tree (BST) and asked to implement an iterator class that returns elements in sorted (ascending) order during traversal. Your implementation must be efficient in terms of both time and memory usage. # Task Implement the `BSTIterator` class with the following methods: * `__init__(self, root: TreeNode) -> None`: Initializes the BSTIterator object with the root of a binary search tree. * `has_next(self) -> bool`: Returns `True` if there exists a next element in the in-order traversal, otherwise returns `False`. * `next(self) -> int`: Returns the next element in the in-order traversal. # Constraints * The number of nodes in the tree is in the range `[0, 10^4]`. * `-10^5 <= Node.val <= 10^5` # Input and Output * The binary tree will be given in the form of a `TreeNode` class, where `TreeNode` contains: * `val` (int): Node value. * `left` (TreeNode): Left child of the node. * `right` (TreeNode): Right child of the node. # Example Usage ```python # Example usage: # Given a BST as follows: # # 7 # / # 3 15 # / # 9 20 root = TreeNode(7) root.left = TreeNode(3) root.right = TreeNode(15) root.right.left = TreeNode(9) root.right.right = TreeNode(20) iterator = BSTIterator(root) result = [] while iterator.has_next(): result.append(iterator.next()) print(result) # Output: [3, 7, 9, 15, 20] ``` # Notes * The `BSTIterator` initialization should be efficient, leveraging the properties of the binary search tree. * Empty trees should be handled gracefully. * Careful consideration should be given to edge cases, such as trees with only one node or completely unbalanced trees.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BSTIterator: def __init__(self, root: TreeNode): self.stack = [] self._leftmost_inorder(root) def _leftmost_inorder(self, root): while root: self.stack.append(root) root = root.left def has_next(self) -> bool: return len(self.stack) > 0 def next(self) -> int: topmost_node = self.stack.pop() if topmost_node.right: self._leftmost_inorder(topmost_node.right) return topmost_node.val"},{"question":"Context You have been tasked with analyzing perfect squares in a sequence of numbers and implementing functionality to determine the next perfect square in the sequence. This is especially useful in educational tools that deal with mathematical concepts of perfect squares. Problem Statement Write a function `find_next_square(sq: int) -> int` that takes an integer `sq` as input and returns the next perfect square if `sq` is a perfect square itself. If `sq` is not a perfect square, the function should return `-1`. Input and Output Format - **Input**: An integer `sq` (e.g., 121) - **Output**: An integer representing the next perfect square if `sq` is a perfect square; otherwise, `-1`. Constraints - The input integer `sq` will be a non-negative integer. - The input will not exceed (10^{18}). Performance Requirements - The function should run in constant time, ( O(1) ). - Handle large numbers appropriately without significant precision loss. Examples ```python assert find_next_square(121) == 144 # 121 is a perfect square, next is 144 assert find_next_square(625) == 676 # 625 is a perfect square, next is 676 assert find_next_square(114) == -1 # 114 is not a perfect square assert find_next_square(0) == 1 # 0 is a perfect square, next is 1 ``` Edge Cases to Consider - Non-perfect squares (e.g., 3, 5, 10) - The number 0, which should return 1. - Large perfect squares close to the upper limit of (10^{18}).","solution":"import math def find_next_square(sq: int) -> int: Returns the next perfect square if the input is a perfect square. If the input is not a perfect square, returns -1. if sq < 0: return -1 root = int(math.sqrt(sq)) if root * root == sq: return (root + 1) ** 2 else: return -1"},{"question":"**Title**: Minimum Deletions to Equalize Strings **Context**: Given two strings, the task is to write a function to calculate the minimum number of steps required to make both strings identical. Each step involves a deletion of a character from any string. **Problem Statement**: Write a function `min_deletions_to_equalize(word1: str, word2: str) -> int` that takes in two strings `word1` and `word2` and returns an integer representing the minimum number of deletions required. **Input/Output Requirements**: * **Input**: * `word1`: A string of length n (1 <= n <= 1000) * `word2`: A string of length m (1 <= m <= 1000) * **Output**: * An integer representing the minimum number of deletion steps. **Constraints**: * Both strings consist of lowercase English letters. **Function Signature**: ```python def min_deletions_to_equalize(word1: str, word2: str) -> int: ``` **Example**: ```python # Example 1 print(min_deletions_to_equalize(\\"sea\\", \\"eat\\")) # Output: 2 # Example 2 print(min_deletions_to_equalize(\\"abc\\", \\"def\\")) # Output: 6 # Example 3 print(min_deletions_to_equalize(\\"abcdef\\", \\"abcxyz\\")) # Output: 6 ``` **Explanation**: 1. For `word1=\\"sea\\"` and `word2=\\"eat\\"`, the LCS is \\"ea\\": - \\"sea\\" to \\"ea\\" (delete \'s\') - \\"eat\\" to \\"ea\\" (delete \'t\') Thus, two deletions. 2. For `word1=\\"abc\\"` and `word2=\\"def\\"`, there is no common subsequence, so all characters must be deleted: 6 deletions (3 from each). 3. For `word1=\\"abcdef\\"` and `word2=\\"abcxyz\\"`, the LCS is \\"abc\\": - \\"abcdef\\" to \\"abc\\" (delete \'d\', \'e\', \'f\') - \\"abcxyz\\" to \\"abc\\" (delete \'x\', \'y\', \'z\') Thus, six deletions. **Hint**: Use dynamic programming to find the longest common subsequence and figure out how many deletions can be derived from it.","solution":"def min_deletions_to_equalize(word1: str, word2: str) -> int: def longest_common_subsequence(str1, str2): Helper function to find the length of the longest common subsequence of two strings. len1, len2 = len(str1), len(str2) dp = [[0] * (len2 + 1) for _ in range(len1 + 1)] for i in range(1, len1 + 1): for j in range(1, len2 + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[len1][len2] lcs_length = longest_common_subsequence(word1, word2) return len(word1) + len(word2) - 2 * lcs_length"},{"question":"# Binary Tree Construction from Preorder and Postorder Traversals **Context**: In computer science, constructing a binary tree from traversal arrays is a common problem, especially for tasks like reconstructing parse trees, network routing, and hierarchical data representation. This exercise involves constructing a full binary tree using given preorder and postorder traversal arrays and producing its inorder traversal. # Problem Statement You are given two arrays representing the preorder and postorder traversal of a full binary tree. Implement a function `construct_and_print_inorder(pre: List[int], post: List[int]) -> List[int]`: * **Input**: - pre: List of integers, the preorder traversal array. - post: List of integers, the postorder traversal array. * **Output**: - List of integers representing the inorder traversal of the constructed binary tree. * **Constraints**: - The binary tree is full, meaning each node has either 0 or 2 children. - 1 ≤ len(pre), len(post) ≤ 1000 and all elements are unique. - The input preorder and postorder arrays are consistent and correspond to the same binary tree. * **Example**: ```python pre = [1, 2, 4, 5, 3, 6, 7] post = [4, 5, 2, 6, 7, 3, 1] Output: [4, 2, 5, 1, 6, 3, 7] ``` * **Performance Requirements**: - Aim to minimize time complexity. Ideally better than (O(n^2)). # Advanced Scenario Consider optimizing the repeated search operations in the postorder array by using a hashmap to store value-to-index mappings, thereby improving the efficiency of root partition operations. **Note**: Handle edge cases like empty input arrays or mismatched array sizes accordingly. Good luck, and may your trees always be full!","solution":"from typing import List, Optional class TreeNode: def __init__(self, val: int = 0, left: Optional[\'TreeNode\'] = None, right: Optional[\'TreeNode\'] = None): self.val = val self.left = left self.right = right def construct_and_print_inorder(pre: List[int], post: List[int]) -> List[int]: if not pre or not post: return [] post_index_map = {val: idx for idx, val in enumerate(post)} def construct(pre_l: int, pre_r: int, post_l: int, post_r: int) -> Optional[TreeNode]: if pre_l > pre_r: return None if pre_l == pre_r: return TreeNode(pre[pre_l]) root_val = pre[pre_l] left_root_val = pre[pre_l + 1] left_subtree_size = post_index_map[left_root_val] - post_l + 1 root = TreeNode(root_val) root.left = construct(pre_l + 1, pre_l + left_subtree_size, post_l, post_l + left_subtree_size - 1) root.right = construct(pre_l + left_subtree_size + 1, pre_r, post_l + left_subtree_size, post_r - 1) return root def inorder_traversal(root: Optional[TreeNode], result: List[int]): if root is not None: inorder_traversal(root.left, result) result.append(root.val) inorder_traversal(root.right, result) root = construct(0, len(pre) - 1, 0, len(post) - 1) result = [] inorder_traversal(root, result) return result"},{"question":"# Problem: Enhanced GCD and LCM Calculator Given two non-negative integers x and y, your task is to write two functions: 1. **`enhanced_gcd(x, y)`** that calculates the greatest common divisor by intelligently combining the properties of the standard Euclidean algorithm with the binary GCD algorithm to maximize efficiency. 2. **`enhanced_lcm(x, y)`** that calculates the least common multiple using the optimized GCD function from above. # Input: - Two non-negative integers, x and y (`0 <= x, y <= 10^9`). # Output: - The greatest common divisor and the least common multiple of the two given integers. # Constraints: - The function should handle edge cases appropriately (e.g., when one or both of the integers are zero). - The function should be efficient and handle the upper limits comfortably. # Function Signature: ```python def enhanced_gcd(x: int, y: int) -> int: pass def enhanced_lcm(x: int, y: int) -> int: pass ``` # Example: ```python # Input x = 18 y = 24 # Output for GCD greatest_divisor = enhanced_gcd(x, y) # Output: 6 # Output for LCM least_multiple = enhanced_lcm(x, y) # Output: 72 ``` # Constraints: - The functions should not use the built-in `math.gcd` or `math.lcm` functions. - The calculations should be optimized for performance. # Notes: - You are expected to handle edge cases such as one of the integers being zero. - Consider the implications of large integer multiplications and divisions in the least common multiple computation to avoid integer overflow.","solution":"def enhanced_gcd(x, y): Calculates the greatest common divisor (GCD) of x and y using the Euclidean algorithm. while y != 0: x, y = y, x % y return x def enhanced_lcm(x, y): Calculates the least common multiple (LCM) of x and y using the GCD. if x == 0 or y == 0: return 0 return (x * y) // enhanced_gcd(x, y)"},{"question":"# Gnome Sort Implementation and Analysis Scenario: You are developing a sorting function for a toy problem where performance on small or nearly sorted datasets is more critical than scalability. Gnome Sort, despite being simple, serves as an excellent example of understanding elementary sorting algorithms and their behavior on various cases. Task: Implement the `gnome_sort` function that sorts a list of integers in non-decreasing order. Additionally, you need to write a function `analyze_gnome_sort` that returns the number of comparisons and swaps made during the sorting process for further analysis. Function Signature: ```python def gnome_sort(arr: List[int]) -> List[int]: pass def analyze_gnome_sort(arr: List[int]) -> Tuple[List[int], int, int]: pass ``` Input: - `gnome_sort`: an unsorted list of integers `arr` (0 <= len(arr) <= 10^4, -10^6 <= arr[i] <= 10^6). - `analyze_gnome_sort`: an unsorted list of integers `arr` (Same constraints apply). Output: - `gnome_sort`: a list of integers sorted in non-decreasing order. - `analyze_gnome_sort`: a tuple containing the sorted list, the number of comparisons, and the number of swaps made. Constraints and Requirements: - The implementation should be efficient in terms of memory usage and avoid unnecessary complexity. - You should count the number of comparisons and swaps accurately in the `analyze_gnome_sort` function and return them along with the sorted list. - Solve the problem using the principles of Gnome Sort as described. Example: ```python gnome_sort([34, 2, 23, -4, 0]) # Returns: [-4, 0, 2, 23, 34] analyze_gnome_sort([34, 2, 23, -4, 0]) # Returns: ([-4, 0, 2, 23, 34], 7, 7) # output includes the sorted list, number of comparisons, and swaps ``` Note: The number of comparisons and swaps might vary based on how the algorithm processes the array, as Gnome Sort inherently involves back-and-forth movement to ensure sorted order.","solution":"from typing import List, Tuple def gnome_sort(arr: List[int]) -> List[int]: pos = 0 while pos < len(arr): if pos == 0 or arr[pos] >= arr[pos - 1]: pos += 1 else: arr[pos], arr[pos - 1] = arr[pos - 1], arr[pos] pos -= 1 return arr def analyze_gnome_sort(arr: List[int]) -> Tuple[List[int], int, int]: comparisons = 0 swaps = 0 pos = 0 while pos < len(arr): comparisons += 1 if pos == 0 or arr[pos] >= arr[pos - 1]: pos += 1 else: # Swap values arr[pos], arr[pos - 1] = arr[pos - 1], arr[pos] swaps += 1 pos -= 1 return (arr, comparisons, swaps)"},{"question":"You are tasked with implementing a hash table using the separate chaining method. This data structure should be able to efficiently insert, retrieve, and delete key-value pairs. Unlike the basic implementation, you need to also handle dynamic resizing to maintain optimal performance as the number of elements grows. # Requirements 1. **`class DynamicHashTable`**: - Initialize with a default size of 11. - Should resize itself (double its size) when the load factor exceeds 0.7. 2. **Methods to Implement**: - `put(key, value)`: Inserts the key-value pair into the hash table. It should handle collisions using linked lists. - `get(key)`: Retrieves the value associated with the key. Returns `None` if the key doesn’t exist. - `del_(key)`: Deletes the key-value pair associated with the key. - `resize()`: Doubles the size of the internal array and rehashes all existing entries. - Optional helper methods for managing internal states if necessary. 3. **Constraints**: - Only consider hash tables of a size that is a prime number during the resizing process to ensure a good distribution of keys. 4. **Performance**: - Ensure average-case O(1) time complexity for `put`, `get`, and `del_` operations. - Ensure that resizing operations don’t degrade the average-case performance significantly. # Input and Output * **Input**: String keys and any type of value. * **Output**: Appropriate values or `None` for get operations, no output for put or delete operations. # Example ```python table = DynamicHashTable() # Add key-value pairs table.put(\'apple\', 1) table.put(\'banana\', 2) table.put(\'grape\', 5) # Retrieve value print(table.get(\'apple\')) # Output: 1 # Delete key-value pair table.del_(\'apple\') print(table.get(\'apple\')) # Output: None # Automatic resizing for i in range(9): table.put(f\'key{i}\', i) print(len(table)) # Output: 11 (or 22 after resizing) ``` # Constraints * Ensure the load factor does not exceed 0.7 after every operation. If it does, resize the table before inserting. # Scenario Imagine you are building a dynamic caching system where key-value pairs are frequently inserted and deleted. Your primary goal is to maintain efficient average-case performance despite the dynamic changes in the number and types of keys. Implement the `DynamicHashTable` to meet these needs effectively.","solution":"class DynamicHashTable: def __init__(self, initial_size=11): self.size = initial_size self.count = 0 self.table = [[] for _ in range(self.size)] def _hash(self, key): return hash(key) % self.size def _find_key(self, bucket, key): for i, (k, v) in enumerate(bucket): if k == key: return i return -1 def put(self, key, value): if (self.count + 1) / self.size > 0.7: self.resize() bucket_index = self._hash(key) bucket = self.table[bucket_index] key_index = self._find_key(bucket, key) if key_index >= 0: bucket[key_index] = (key, value) else: bucket.append((key, value)) self.count += 1 def get(self, key): bucket_index = self._hash(key) bucket = self.table[bucket_index] key_index = self._find_key(bucket, key) if key_index >= 0: return bucket[key_index][1] return None def del_(self, key): bucket_index = self._hash(key) bucket = self.table[bucket_index] key_index = self._find_key(bucket, key) if key_index >= 0: del bucket[key_index] self.count -= 1 def _next_prime(self, n): def is_prime(num): if num < 2: return False for i in range(2, int(num**0.5) + 1): if num % i == 0: return False return True while not is_prime(n): n += 1 return n def resize(self): new_size = self._next_prime(self.size * 2) new_table = [[] for _ in range(new_size)] for bucket in self.table: for key, value in bucket: new_bucket_index = hash(key) % new_size new_table[new_bucket_index].append((key, value)) self.size = new_size self.table = new_table"},{"question":"# Coding Assignment: Optimized Shell Sort Context Shell Sort is an interesting sorting algorithm that extends the concept of insertion sort by allowing comparisons and exchanges of elements that are far apart. This characteristic helps in reducing the number of moves significantly compared to the standard insertion sort algorithm. In this assignment, you are required to optimize the given Shell Sort implementation by integrating a more efficient gap sequence. Task Your task is to write a function `optimized_shell_sort(arr)` that sorts an array of integers using an optimized gap sequence for Shell Sort. The sequence to be used is the Ciura sequence: [1, 4, 10, 23, 57, 132, 301, 701, 1750]. If the array\'s length is larger than the largest value in the sequence, extend the sequence as needed. Input and Output * **Input**: A list of integers `arr` with length `n` (0 ≤ n ≤ 10^6). * **Output**: A sorted list of integers in non-decreasing order. Constraints * The array should be sorted in place to maintain the O(1) space complexity. * Aim for an optimal time complexity. Example ```python Input: arr = [12, 34, 54, 2, 3] Output: [2, 3, 12, 34, 54] Input: arr = [] Output: [] Input: arr = [5] Output: [5] ``` Requirements * Ensure your implementation handles edge cases properly, including empty arrays and arrays of one element. * Ensure you use the provided Ciura sequence and extend it appropriately for larger arrays.","solution":"def optimized_shell_sort(arr): Sorts an array of integers using an optimized Shell Sort with the Ciura gap sequence. n = len(arr) if n <= 1: return arr # Early exit for empty or single element arrays # Initial Ciura sequence ciura_sequence = [1, 4, 10, 23, 57, 132, 301, 701, 1750] # Extend Ciura sequence if needed while ciura_sequence[-1] < n // 2: ciura_sequence.append(int(ciura_sequence[-1] * 2.25)) # Perform shell sort using the extended Ciura gap sequence for gap in reversed(ciura_sequence): for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp return arr"},{"question":"# RandomizedSet Enhanced with Size Limitation Design a data structure called `LimitedRandomizedSet` that extends the functionality of the `RandomizedSet` to support an additional constraint: - The set can only hold a maximum of `N` elements at any time. The `LimitedRandomizedSet` should support the following operations: 1. **insert(val)**: Inserts an item `val` into the set if not already present and if the set has not reached its capacity `N`. Return `True` if the item was inserted successfully, otherwise `False`. 2. **remove(val)**: Removes an item `val` from the set if present. Returns `True` if the item was removed successfully, otherwise `False`. 3. **getRandom()**: Returns a random element from the current set of elements. Each element must have the same probability of being returned. 4. **hasCapacity()**: Return `True` if the set has not reached its maximum capacity `N`, otherwise `False`. You are required to handle edge cases effectively, such as attempting to insert into a full set or removing from an empty set. The insertion, removal, and random access operations should maintain O(1) average time complexity. # Input and Output Formats You need to implement the following methods in the `LimitedRandomizedSet` class: - `__init__(self, n: int)`: Initializes the data structure to store up to `n` elements. - `insert(self, val: int) -> bool`: Inserts `val` into the set if not present and set is not full. Returns `True` if insertion is successful. - `remove(self, val: int) -> bool`: Removes `val` from the set if present. Returns `True` if removal is successful. - `getRandom(self) -> int`: Returns a random element from the set. - `hasCapacity(self) -> bool`: Returns `True` if the set has not reached its maximum capacity. # Constraints - All operations should maintain an average time complexity of O(1). - The set size `N` will be a positive integer, `1 <= N <= 10^4`. - The values inserted into the set will be unique integers. # Sample Usage ```python limited_set = LimitedRandomizedSet(3) print(limited_set.insert(1)) # True print(limited_set.insert(2)) # True print(limited_set.insert(3)) # True print(limited_set.insert(4)) # False, as the set is full print(limited_set.hasCapacity()) # False, as the set has reached its capacity print(limited_set.getRandom()) # Random element from {1, 2, 3} print(limited_set.remove(2)) # True print(limited_set.insert(4)) # True print(limited_set.hasCapacity()) # True, as the set has space for one more element ```","solution":"import random class LimitedRandomizedSet: def __init__(self, n: int): self.capacity = n self.data_dict = {} self.data_list = [] def insert(self, val: int) -> bool: if val in self.data_dict or len(self.data_list) >= self.capacity: return False self.data_dict[val] = len(self.data_list) self.data_list.append(val) return True def remove(self, val: int) -> bool: if val not in self.data_dict: return False index = self.data_dict[val] last_element = self.data_list[-1] self.data_list[index] = last_element self.data_dict[last_element] = index self.data_list.pop() del self.data_dict[val] return True def getRandom(self) -> int: return random.choice(self.data_list) def hasCapacity(self) -> bool: return len(self.data_list) < self.capacity"},{"question":"Implement Stooge Sort with Enhancements Scenario: You are given an array of integers that you need to sort efficiently for academic research purposes. Although Stooge Sort is generally inefficient, this exercise will help you understand recursive algorithms and their characteristics. Problem Statement: Write a function `enhanced_stoogesort` that sorts an array of integers using the Stooge Sort algorithm. However, we want you to include an enhancement: the function should switch to Insertion Sort for subarrays smaller than a given threshold to improve performance. Function Signature: ```python def enhanced_stoogesort(arr: List[int], l: int, h: int, threshold: int) -> None: ``` Expected Input: - `arr`: A list of integers to be sorted. - `l`: The starting index of the subarray to be sorted. - `h`: The ending index of the subarray to be sorted. - `threshold`: The threshold size for subarrays to switch from Stooge Sort to Insertion Sort. Expected Output: The function should sort the subarray `arr[l:h+1]` in place. Constraints: 1. The length of the array `0 <= len(arr) <= 1000`. 2. The array elements `-10^5 <= arr[i] <= 10^5`. 3. `0 <= l <= h < len(arr)`. 4. The threshold will be a positive integer. Requirements: - Implement Stooge Sort with the enhancement described. - Use Insertion Sort for subarrays smaller than the given threshold. - Ensure that your solution handles edge cases effectively. Examples: ```python # Example 1 arr = [9, 1, 4, 7, 3] enhanced_stoogesort(arr, 0, 4, 2) print(arr) # Output: [1, 3, 4, 7, 9] # Example 2 arr = [5, 2, 9, 1, 5, 6] enhanced_stoogesort(arr, 0, 5, 3) print(arr) # Output: [1, 2, 5, 5, 6, 9] # Example 3 arr = [3] enhanced_stoogesort(arr, 0, 0, 1) print(arr) # Output: [3] ``` Note: You may assume that the helper function `insertion_sort` is provided or can be implemented by you. Tip: - Use Insertion Sort for small thresholds to see performance improvements.","solution":"def insertion_sort(arr, l, h): for i in range(l + 1, h + 1): key = arr[i] j = i - 1 while j >= l and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key def enhanced_stoogesort(arr, l, h, threshold): if h - l + 1 <= threshold: insertion_sort(arr, l, h) return if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] if h - l + 1 > 2: t = (h - l + 1) // 3 enhanced_stoogesort(arr, l, h - t, threshold) enhanced_stoogesort(arr, l + t, h, threshold) enhanced_stoogesort(arr, l, h - t, threshold)"},{"question":"# Polynomial and Monomial Manipulation Background You are given class implementations for `Monomial` and `Polynomial`. A `Monomial` represents a single term in a polynomial consisting of a coefficient and variables with exponents, while a `Polynomial` represents a collection of such monomials. Task Implement a function inside the `Polynomial` class named `derivative` that computes the derivative of a polynomial with respect to a given variable. * **Input Format**: * The method `derivative` should take an integer `variable` representing the variable with respect to which the differentiation is performed. * **Output Format**: * The method should return a new `Polynomial` object that represents the derivative of the input polynomial. * **Constraints**: * Assume all variables are represented by positive integers. * The coefficient for any term after differentiation must be rationalized to its fraction form if possible. * If the derivative results in a zero polynomial, the result should be represented correctly. * **Performance**: * Ensure the method runs efficiently even for polynomials with a large number of terms. Example For a polynomial ( P(x, y, z) = 2x^2 - 3xy^3 + 4z ), represented and initialized in the code as: ```python P = Polynomial([ Monomial({1: 2}, 2), Monomial({1: 1, 2: 3}, -3), Monomial({3: 1}, 4) ]) ``` The derivative with respect to ( x (variable=1) ): ```python P.derivative(1) ``` Should yield ( P\'(x, y, z) = 4x - 3y^3 ): ```python Polynomial([ Monomial({1: 1}, 4), Monomial({2: 3}, -3) ]) ``` Starter Code ```python from typing import Dict, Union, Set, Iterable from fractions import Fraction class Monomial: # Monomial class as provided... class Polynomial: # Polynomial class as provided... # Add your function here def derivative(self, variable: int) -> Polynomial: pass ```","solution":"from typing import Dict, Union, Set, Iterable from fractions import Fraction class Monomial: def __init__(self, variables: Dict[int, int], coefficient: Union[int, Fraction]): self.variables = variables self.coefficient = Fraction(coefficient) def derivative(self, variable: int) -> \'Monomial\': if variable not in self.variables: return Monomial({}, 0) new_variables = self.variables.copy() new_coefficient = self.coefficient * new_variables[variable] if new_variables[variable] == 1: del new_variables[variable] else: new_variables[variable] -= 1 return Monomial(new_variables, new_coefficient) def __eq__(self, other: \'Monomial\') -> bool: return self.variables == other.variables and self.coefficient == other.coefficient class Polynomial: def __init__(self, monomials: Iterable[Monomial]): self.monomials = list(monomials) def derivative(self, variable: int) -> \'Polynomial\': derived_monomials = [monomial.derivative(variable) for monomial in self.monomials] non_zero_monomials = [m for m in derived_monomials if m.coefficient != 0] return Polynomial(non_zero_monomials) def __eq__(self, other: \'Polynomial\') -> bool: return self.monomials == other.monomials def __repr__(self): return \' + \'.join(f\'{m.coefficient}{\\"\\".join([f\\"x{key}^{value}\\" for key, value in m.variables.items()])}\' for m in self.monomials)"},{"question":"You are given a singly linked list and a non-negative integer `k`. Implement a function to rotate the list to the right by `k` places. # Function Signature ```python def rotate_right(head: ListNode, k: int) -> ListNode: ``` # Input - `head`: The head node of the singly linked list, defined as `ListNode`. If the list is empty, `head` will be `None`. - `k`: A non-negative integer representing the number of places to rotate the list. # Output - Return the list rotated to the right by `k` places as the new head node of the list. # Constraints - The number of nodes in the list is in the range `[0, 500]`. - `0 <= k <= 2 * 10^9` # Example Given a linked list `1 -> 2 -> 3 -> 4 -> 5 -> NULL` and `k = 2`, Your function should return `4 -> 5 -> 1 -> 2 -> 3 -> NULL`. # Scenario Consider a scenario where you maintain a round-robin task scheduler. To synchronize tasks rotating right by a certain number of positions, you should be able to shift all elements efficiently in the scheduler. # Edge Cases to Consider 1. The list is empty (`head` is `None`). 2. The list contains only one element. 3. `k` is zero (the list remains unchanged). 4. `k` is greater than the length of the list, requiring modulus operation to determine the effective number of rotations.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rotate_right(head: ListNode, k: int) -> ListNode: if not head or not head.next or k == 0: return head # Find the length of the linked list length = 1 tail = head while tail.next: tail = tail.next length += 1 # Ensure k is within the bounds of the list\'s length k = k % length if k == 0: return head # Find the new tail, which is (length - k - 1)th node new_tail = head for _ in range(length - k - 1): new_tail = new_tail.next # The new head is the node next to new tail new_head = new_tail.next new_tail.next = None tail.next = head return new_head"},{"question":"# Scenario: You are tasked with implementing a function that searches for a target value in a sorted list of integers. Your function should return the index of the element if found or `-1` if the element is not present. The list is guaranteed to be sorted in ascending order. This will test your understanding of binary search, efficient coding practices and edge case handling. # Problem Statement Implement a function named `binary_search_element` which searches for a target integer in a given sorted list of integers. You must implement both an iterative and a recursive version of the binary search algorithm within the same function. # Function Signature ```python def binary_search_element(array: List[int], target: int) -> int: pass ``` # Input * `array` (List[int]): A list of integers sorted in ascending order. * `target` (int): The integer you need to search for in the array. # Output * int: The index of the `target` if present, otherwise `-1`. # Constraints * The length of the array will be between 0 and 10^6. * The elements of the array will be within the range [-10^9, 10^9]. # Examples 1. Input: `array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]`, `target = 5` Output: `4` 2. Input: `array = [1, 2, 3, 4, 5]`, `target = 6` Output: `-1` 3. Input: `array = [-10, -5, 0, 3, 8, 12]`, `target = 0` Output: `2` 4. Input: `array = []`, `target = 1` Output: `-1` # Notes - You should prioritize the efficiency of your implementation with respect to the time complexity. - Considering both iterative and recursive implementations will demonstrate your flexibility in approach.","solution":"from typing import List def binary_search_element(array: List[int], target: int) -> int: def iterative_binary_search(array: List[int], target: int) -> int: low, high = 0, len(array) - 1 while low <= high: mid = (low + high) // 2 if array[mid] == target: return mid elif array[mid] < target: low = mid + 1 else: high = mid - 1 return -1 def recursive_binary_search(array: List[int], low: int, high: int, target: int) -> int: if low > high: return -1 mid = (low + high) // 2 if array[mid] == target: return mid elif array[mid] < target: return recursive_binary_search(array, mid + 1, high, target) else: return recursive_binary_search(array, low, mid - 1, target) # Use iterative binary search by default or you can switch to recursive if needed. return iterative_binary_search(array, target)"},{"question":"# Scenario: You are tasked with developing a secure algorithm for a digital puzzle game where numbers must be evaluated as \\"Magic Numbers.\\" A number is termed a \\"Magic Number\\" if summing its digits recursively until a single digit results in 1. # Task: Implement a function named `is_magic_number`, which checks if the given number is a Magic Number. # Function Signature: ```python def is_magic_number(n: int) -> bool: ``` # Input: - An integer `n` (0 <= n <= 10^9). # Output: - Return a Boolean value (`True` if the number is a Magic Number, `False` otherwise). # Examples: ```python assert is_magic_number(50113) == True assert is_magic_number(1234) == True assert is_magic_number(199) == True assert is_magic_number(111) == False ``` # Constraints: - Ensure the function handles the recursive summing of digits efficiently. - Utilize the properties of digital roots if possible for optimum performance. # Notes: - Numbers can be large, so the solution should be efficient, considering time and space complexity. - Provide edge cases for testing, such as the smallest number, 0, and other boundary values.","solution":"def is_magic_number(n: int) -> bool: Check if a number is a Magic Number. A number is a Magic Number if the sum of its digits recursively until a single digit results in 1. Args: n: An integer Returns: A boolean value indicating if the number is a Magic Number def sum_of_digits(n): sum = 0 while n > 0: sum += n % 10 n //= 10 return sum while n >= 10: n = sum_of_digits(n) return n == 1"},{"question":"# BST Algorithm Skill Assessment **Scenario**: A software company is building a statistical toolkit that relies heavily on Binary Search Trees (BSTs). One of the critical functionalities is to extract the kth smallest element efficiently from a BST. # Task Implement a function to find the kth smallest element in a given binary search tree (BST). # Function Signature ```python def find_kth_smallest(root: Node, k: int) -> int: :param root: Node - The root node of a binary search tree. :param k: int - The k-th position (1-indexed) to find the smallest element. :return: int - The k-th smallest element value. ``` # Input - `root`: A Node object representing the root of a BST. Each node has `val`, `left`, and `right`. - `k`: An integer specifying the position of the smallest element to retrieve (1-indexed). # Output - Returns an integer representing the kth smallest value in the BST. # Constraints 1. The input `k` will be always valid, i.e., 1 ≤ k ≤ number of nodes in the BST. 2. You can assume that the nodes\' values are unique. # Example ```python # Given this binary tree: # 40 # / # 20 60 # / / # 10 30 50 70 n1 = Node(40) n2 = Node(20) n3 = Node(60) n4 = Node(10) n5 = Node(30) n6 = Node(50) n7 = Node(70) n1.left, n1.right = n2, n3 n2.left, n2.right = n4, n5 n3.left, n3.right = n6, n7 print(find_kth_smallest(n1, 3)) # Output: 30 print(find_kth_smallest(n1, 6)) # Output: 60 ``` # Implementation Notes - Focus on efficient implementation (preferably O(H + k) time and O(H) space). - Reproducing inorder traversal via either an iterative or recursive approach. - Ensure proper edge case handling, such as empty BST or out-of-bounds `k`.","solution":"class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_kth_smallest(root: Node, k: int) -> int: Returns the k-th smallest element in the BST. def inorder_traversal(node): if not node: return [] # In-order traversal: left, root, right return inorder_traversal(node.left) + [node.val] + inorder_traversal(node.right) # Perform in-order traversal to get elements in ascending order elements = inorder_traversal(root) # Return the k-th smallest element return elements[k-1]"},{"question":"# Coding Challenge: Optimized Heap Sort Implementation **Scenario**: You are working as a software engineer and asked to implement a robust sorting function suited for environments with limited memory while having reliable performance levels. Given the analysis and study of heap sorts (both max and min heap-based), you need to implement your optimized version of the heap sort algorithm. The function should use a max heap strategy to sort the array and optimize the existing heapify code for better performance. **Your Task**: Implement the function `optimized_heap_sort(arr: List[int], simulation: bool=False) -> List[int]` that sorts an array of integers in ascending order. **Function Signature**: ```python def optimized_heap_sort(arr: List[int], simulation: bool=False) -> List[int]: pass ``` **Input**: * `arr`: A list of integers that need to be sorted. * `simulation`: A boolean flag; if set to `True`, the function should print the array state at each iteration step. **Output**: * The sorted list of integers in ascending order. **Constraints**: * The array length can vary from 0 to 10^5 elements. * The values in the array are integers in the range of [-10^9, 10^9]. * The function should emphasize minimal additional space usage. **Performance Requirements**: * Aim for a time complexity of O(n log(n)). * Use no extra space beyond O(1). **Edge Cases**: * Empty array should return immediately as an empty array. * Single element array should return the same single element. * Arrays with duplicate elements should handle duplicates correctly without fault. **Example**: ```python input_arr = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5] sorted_arr = optimized_heap_sort(input_arr, simulation=False) # Expected output: [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] ``` Please ensure that your implementation is efficient and thoroughly tested with different cases to confirm its correctness and performance.","solution":"from typing import List def optimized_heap_sort(arr: List[int], simulation: bool=False) -> List[int]: def heapify(arr: List[int], n: int, i: int) -> None: largest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[i] < arr[left]: largest = left if right < n and arr[largest] < arr[right]: largest = right if largest != i: arr[i], arr[largest] = arr[largest], arr[i] heapify(arr, n, largest) n = len(arr) for i in range(n // 2 - 1, -1, -1): heapify(arr, n, i) if simulation: print(f\\"Heapified array at {i}: {arr}\\") for i in range(n-1, 0, -1): arr[i], arr[0] = arr[0], arr[i] heapify(arr, i, 0) if simulation: print(f\\"Array after extracting {i}: {arr}\\") return arr"},{"question":"# Bubble Sort Enhancement and Analysis Question: The provided implementation of the Bubble Sort algorithm sorts an array in ascending order. Your task is to enhance this implementation by adding the following features: 1. **Optimization**: Modify the algorithm to stop the sorting process if no swaps are made during a full pass through the array, indicating that the array is already sorted. 2. **Sorting Order**: Introduce a new parameter `ascending` to the function. If `ascending` is `True`, the array should be sorted in ascending order (default behavior). If `ascending` is `False`, the array should be sorted in descending order. 3. **Edge Cases Handling**: Make sure the function handles edge cases, such as an empty array or an array with only one element. 4. **Error Handling**: If the input array is not a list or if it contains non-comparable elements, raise an appropriate exception. You need to implement a function `enhanced_bubble_sort(arr, ascending=True, simulation=False)`. Function Signature: ```python def enhanced_bubble_sort(arr, ascending=True, simulation=False) -> list: # your code here ``` Input: - `arr`: A list of comparable elements (integers or floats). - `ascending` (optional): A boolean indicating the sorting order. - `simulation` (optional): A boolean, if `True` prints the iteration steps. Output: - A list sorted as per the specified order. Constraints: - The input list can be empty or have up to 10^4 elements. - The simulation boolean is for visualization purposes and should not affect the sorting logic. Examples: 1. Input: `enhanced_bubble_sort([3, 2, 1], True, False)` Output: `[1, 2, 3]` 2. Input: `enhanced_bubble_sort([3, 2, 1], False, False)` Output: `[3, 2, 1]` 3. Input: `enhanced_bubble_sort([1, 2, 3], True, True)` Output: `[1, 2, 3]` (should print intermediate steps if `simulation` is `True`) 4. Input: `enhanced_bubble_sort([\'a\', \'b\', \'c\'], False, False)` Raises: `TypeError` Additional Requirement: - Ensure that the function passes all possible edge case scenarios and handles erroneous inputs gracefully.","solution":"def enhanced_bubble_sort(arr, ascending=True, simulation=False): Enhanced bubble sort that sorts an array in ascending or descending order with early termination if no swaps are made in a full pass. Args: arr (list): A list of comparable elements. ascending (bool): If True, sort in ascending order, else descending. simulation (bool): If True, print iterations steps for simulation. Returns: list: The sorted array. if not isinstance(arr, list): raise TypeError(\\"Input should be a list\\") n = len(arr) if n < 2: return arr # no need to sort if array has 0 or 1 element for i in range(n): swapped = False if simulation: print(f\\"Pass {i+1}: {arr}\\") # Last i elements are already sorted for j in range(1, n - i): if (ascending and arr[j - 1] > arr[j]) or (not ascending and arr[j - 1] < arr[j]): arr[j - 1], arr[j] = arr[j], arr[j - 1] swapped = True if simulation: print(f\\" After swap: {arr}\\") if not swapped: break # Stop iteration if the array is already sorted return arr"},{"question":"Context You are developing a software module that requires frequent analysis of numeric data. To efficiently process and manage these numbers, a fundamental requirement is to quickly determine the number of digits in any given integer. Your task is to implement a function that returns the number of digits in a given integer. Problem Statement Implement a function `count_digits` that takes a single integer `n` as input and returns the number of digits in `n`. Input * An integer `n` where `-10^9 <= n <= 10^9`. Output * The function should return an integer representing the number of digits in `n`. Constraints * Function must run in O(1) time complexity. * Handle both positive and negative integers as well as zero. * Use the properties of logarithms for an efficient solution. Example ```python count_digits(12345) -> 5 count_digits(-9876) -> 4 count_digits(0) -> 1 ``` Implementation Notes * Consider edge cases such as zero and negative numbers. * Ensure that your function handles the given constraints efficiently. Implement the function as described: ```python def count_digits(n): # Your code here pass ```","solution":"def count_digits(n): Returns the number of digits in the given integer n. if n == 0: return 1 return len(str(abs(n)))"},{"question":"# Problem: Strongly Connected Graph Checker You are given a directed graph with `N` vertices, numbered from 0 to `N-1`. You need to determine if the graph is a single strongly connected component. Input: - An integer `N` representing the number of vertices. - A list of tuples `edges` where each tuple (u, v) represents a directed edge from vertex u to vertex v. Output: - Return `True` if the graph is strongly connected; otherwise, return `False`. Constraints: - `1 <= N <= 10^3` (1000) vertices. - `0 <= len(edges) <= 10^5` (100,000) edges. - Vertices are labeled from 0 to `N-1`. Example: ```python def is_strongly_connected(N, edges): # Your implementation here # Example 1 N = 5 edges = [(0, 1), (1, 2), (2, 3), (3, 4), (4, 0)] print(is_strongly_connected(N, edges)) # Should print True # Example 2 N = 4 edges = [(0, 1), (1, 2), (2, 0), (3, 2)] print(is_strongly_connected(N, edges)) # Should print False ``` Explanation: - In the first example, every vertex is reachable from every other vertex, forming a single strongly connected component. - In the second example, vertex 3 does not form part of a cycle accessible from all others, hence the graph is not strongly connected. Performance Requirements: - The solution should efficiently check strong connectivity, adhering to the constraints and operating within linear time complexity relative to the number of nodes and edges.","solution":"from collections import defaultdict, deque def is_strongly_connected(N, edges): def bfs(start, graph): visited = [False] * N queue = deque([start]) visited[start] = True while queue: node = queue.popleft() for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return all(visited) if N == 1: return True # Build the adjacency list for the graph graph = defaultdict(list) reverse_graph = defaultdict(list) for u, v in edges: graph[u].append(v) reverse_graph[v].append(u) # Check all nodes are reachable from the first node if not bfs(0, graph): return False # Check all nodes are reachable from the first node in the reversed graph if not bfs(0, reverse_graph): return False return True"},{"question":"# String Matching: Implementing a Simple Substring Search **Context**: You are working on a text editor application where one of the essential features is the find function, which allows users to locate substrings within a larger string. To boost your application\'s efficiency, you need to implement a function that finds the first occurrence of a substring within a string. **Task**: Write a function `find_substring(haystack: str, needle: str) -> int` that returns the index of the first occurrence of `needle` in `haystack`, or -1 if `needle` is not part of `haystack`. # Input * `haystack`: A string in which to search—guaranteed to be non-null. * `needle`: A string to find within `haystack`—guaranteed to be non-null. # Output * Returns the starting index of the first occurrence of `needle` within `haystack`. * Returns -1 if `needle` is not found in `haystack`. * Returns 0 if `needle` is an empty string. # Constraints * The length of `haystack` and `needle` will not exceed 10^4. # Requirements * The solution should consider edge cases and optimize for performance as much as possible. * Though an O(m*n) solution is acceptable, bonus points will be awarded for implementing a more efficient algorithm such as KMP or Boyer-Moore. # Example ```python find_substring(\\"hello\\", \\"ll\\") # Output: 2 find_substring(\\"aaaaa\\", \\"bba\\") # Output: -1 find_substring(\\"abc\\", \\"\\") # Output: 0 ``` # Solution Template ```python def find_substring(haystack: str, needle: str) -> int: # Your implementation here pass ``` **Notes**: Consider the provided constraints and requirements. Test your implementation with various edge cases to ensure correctness.","solution":"def find_substring(haystack: str, needle: str) -> int: Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. If needle is an empty string, returns 0. if not needle: return 0 # Implementing the Knuth-Morris-Pratt (KMP) algorithm for better performance def compute_lps(pattern: str): lps = [0] * len(pattern) length = 0 i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps lps = compute_lps(needle) i = j = 0 while i < len(haystack): if needle[j] == haystack[i]: i += 1 j += 1 if j == len(needle): return i - j elif i < len(haystack) and needle[j] != haystack[i]: if j != 0: j = lps[j - 1] else: i += 1 return -1"},{"question":"Context In combinatorics, the binomial coefficient ( C(n, k) ) represents the number of ways to choose ( k ) items from a set of ( n ) items without regard to the order of selection. This is widely used in fields like probability theory, statistics, and mathematical computations. Task Write a recursive function to compute the binomial coefficient ( C(n, k) ) using the properties and characteristics described above. Avoid recomputation of subproblems and catch any erroneous inputs correctly. Function Signature ```python def binomial_coefficient(n: int, k: int) -> int: pass ``` Input * ( n ) (integer): The total number of items. * ( k ) (integer): The number of items to choose. * Constraints: ( 0 leq k leq n ) Output * ( result ) (integer): The binomial coefficient ( C(n, k) ). Examples ```python >>> binomial_coefficient(5, 2) 10 >>> binomial_coefficient(10, 3) 120 >>> binomial_coefficient(0, 0) 1 >>> binomial_coefficient(8, 2) 28 ``` Additional Requirements: * Implement error handling for invalid input where ( n < k ) or if either ( n ) or ( k ) is negative. * Optimize the computation using memoization to avoid redundant computations.","solution":"def binomial_coefficient(n: int, k: int) -> int: # Handle invalid inputs if n < 0 or k < 0 or n < k: raise ValueError(\\"Invalid inputs: n and k must be non-negative and n >= k\\") # Base cases if k == 0 or k == n: return 1 # Use a memoization technique to store previously computed values memo = {} def compute(n, k): if k == 0 or k == n: return 1 if (n, k) in memo: return memo[(n, k)] # Recursive relation result = compute(n - 1, k - 1) + compute(n - 1, k) memo[(n, k)] = result return result return compute(n, k)"},{"question":"# Context You are working on a system that processes large datasets where certain integers frequently repeat. In a specific dataset, every element appears exactly three times except for one unique integer element that appears only once. Due to memory constraints and the size of the dataset, typical approaches using auxiliary data structures are not feasible. # Task Your goal is to implement a function that identifies the unique integer that appears exactly once in a list where all other integers appear exactly three times. Your implementation should not use extra memory beyond a few integer variables. # Specification - Function signature: `def find_unique(nums: List[int]) -> int:` - **Input**: A list of integers `nums` where every element appears exactly three times except for one unique element that appears only once. - **Output**: Return the element that appears only once. # Constraints - The input list `nums` is non-empty. - The length of `nums` is a multiple of 3 plus 1. - The elements in `nums` are in the range from `-2^31` to `2^31 - 1`. # Examples ```python assert find_unique([2, 2, 3, 2]) == 3 assert find_unique([0, 1, 0, 1, 0, 1, 99]) == 99 assert find_unique([30000, 500, 100, 30000, 100, 30000, 100]) == 500 ``` # Performance Your solution should run in linear time, O(n), where n is the number of elements in the array, and should use a constant amount of extra space, O(1).","solution":"from typing import List def find_unique(nums: List[int]) -> int: Finds the unique integer that appears exactly once in a list where every other integer appears exactly three times. ones, twos = 0, 0 for num in nums: ones = (ones ^ num) & ~twos twos = (twos ^ num) & ~ones return ones"},{"question":"# Binary Heap Implementation: `get_3rd_smallest_element` Function You are provided with a Binary Heap implementation in Python. Your task is to extend this implementation by creating a method to find the 3rd smallest element in the min heap. Ensure that your implementation adheres to the properties of the min heap and efficiently finds the 3rd smallest element. # Function Signature ```python def get_3rd_smallest_element(self) -> int: pass ``` # Input and Output * **Input**: This should be a method within the `BinaryHeap` class. * **Output**: An integer representing the 3rd smallest element in the min heap. # Assumptions and Constraints * You can assume that the heap contains at least 3 elements. * You must not alter the original heap structure permanently. Any temporary changes should be reverted back or avoided. # Example Given the min heap: ``` 4 / 50 7 / / 55 90 87 ``` * The heap array representation is [0, 4, 50, 7, 55, 90, 87] * Inserting values 2, 5, 3 into the heap: After Inserting 2: ``` 2 / 4 3 / / 50 7 55 5 / / 90 87 ``` * 3rd smallest element is 4. # Guidelines 1. **Read and Understand**: Understand the min heap structure and how the insertions and deletions are handled. 2. **Insertions and Removals**: Use the provided `insert` and `remove_min` methods. 3. **Implementation**: Implement the `get_3rd_smallest_element` method. 4. **Testing**: Test the method with various heap configurations. ```python def get_3rd_smallest_element(self) -> int: # Your implementation here pass ```","solution":"class BinaryHeap: def __init__(self): self.heap = [0] self.size = 0 def insert(self, k): self.heap.append(k) self.size += 1 self._perc_up(self.size) def _perc_up(self, i): while i // 2 > 0: if self.heap[i] < self.heap[i // 2]: self.heap[i], self.heap[i // 2] = self.heap[i // 2], self.heap[i] i = i // 2 def remove_min(self): retval = self.heap[1] self.heap[1] = self.heap[self.size] self.size -= 1 self.heap.pop() self._perc_down(1) return retval def _perc_down(self, i): while (i * 2) <= self.size: mc = self._min_child(i) if self.heap[i] > self.heap[mc]: self.heap[i], self.heap[mc] = self.heap[mc], self.heap[i] i = mc def _min_child(self, i): if i * 2 + 1 > self.size: return i * 2 else: if self.heap[i * 2] < self.heap[i * 2 + 1]: return i * 2 else: return i * 2 + 1 def get_3rd_smallest_element(self): if self.size < 3: raise ValueError(\\"Heap contains fewer than 3 elements\\") original_size = self.size original_heap = self.heap[:] first_min = self.remove_min() second_min = self.remove_min() third_min = self.remove_min() self.heap = original_heap self.size = original_size return third_min"},{"question":"# Question: Implementing Advanced Markov Chain Mechanisms Context You are tasked to improve and extend the functionality of a Markov Chain simulator that transitions between states based on predefined probabilities. This Markov Chain is represented using dictionaries, and your task is to address some shortcomings and add new functionalities. Requirements 1. **Initial State Validation**: * Write a function `validate_initial_state(chain, state)` that takes a Markov chain and an initial state and returns `True` if the initial state is in the chain and has valid outgoing transitions, otherwise returns `False`. 2. **Probability Sum Check**: * Extend the chain validation by implementing a function `validate_chain(chain)` that checks whether the probabilities of all outgoing transitions from any state sum to 1 (with a small tolerance for floating-point errors), returning `True` if valid, else `False`. 3. **State Transition History**: * Implement a function `markov_chain_simulation(chain, initial_state, num_transitions)` that simulates the Markov Chain from the given initial state, returning a list of states visited during the simulation including the initial state. The length of the list should be equal to `num_transitions + 1`. Constraints * **Input**: - `chain`: dict - A dictionary representing the Markov chain. - `initial_state`: str - The initial state in the chain. - `num_transitions`: int - The number of state transitions to simulate (must be non-negative). * **Output**: - For `validate_initial_state(chain, state)` and `validate_chain(chain)`: return a boolean value. - For `markov_chain_simulation(chain, initial_state, num_transitions)`: return a list of strings representing the states visited. Function Definitions ```python def validate_initial_state(chain, state): Validate if the initial state exists in the Markov chain and has outgoing transitions. :param chain: dict - The Markov chain with state transitions. :param state: str - The initial state. :return: bool - True if the state is valid, else False. # Your implementation here def validate_chain(chain): Validate if the probabilities of all outgoing transitions from any state sum to 1. :param chain: dict - The Markov chain with state transitions. :return: bool - True if all probabilities are valid, else False. # Your implementation here def markov_chain_simulation(chain, initial_state, num_transitions): Simulate the Markov Chain starting from the initial state. :param chain: dict - The Markov chain with state transitions. :param initial_state: str - The starting state. :param num_transitions: int - The number of transitions to simulate. :return: list - The list of states visited. # Your implementation here ``` Test Cases * Ensure your solution handles: - Chains with single state. - States with no outgoing transitions. - Chains with appropriate error handling. * Example ```python chain_example = { \'A\': {\'A\': 0.6, \'E\': 0.4}, \'E\': {\'A\': 0.7, \'E\': 0.3} } # Validate initial state print(validate_initial_state(chain_example, \'A\')) # True print(validate_initial_state(chain_example, \'Z\')) # False # Validate chain print(validate_chain(chain_example)) # True # Simulate markov chain print(markov_chain_simulation(chain_example, \'A\', 5)) # Possible outcome: [\'A\', \'E\', \'A\', \'A\', \'E\', \'A\'] ```","solution":"import random def validate_initial_state(chain, state): Validate if the initial state exists in the Markov chain and has outgoing transitions. :param chain: dict - The Markov chain with state transitions. :param state: str - The initial state. :return: bool - True if the state is valid, else False. return state in chain and bool(chain[state]) def validate_chain(chain): Validate if the probabilities of all outgoing transitions from any state sum to 1. :param chain: dict - The Markov chain with state transitions. :return: bool - True if all probabilities are valid, else False. for state, transitions in chain.items(): if not (0.999 <= sum(transitions.values()) <= 1.001): return False return True def markov_chain_simulation(chain, initial_state, num_transitions): Simulate the Markov Chain starting from the initial state. :param chain: dict - The Markov chain with state transitions. :param initial_state: str - The starting state. :param num_transitions: int - The number of transitions to simulate. :return: list - The list of states visited. if not validate_initial_state(chain, initial_state): raise ValueError(\\"Invalid initial state\\") if num_transitions < 0: raise ValueError(\\"Number of transitions must be non-negative\\") history = [initial_state] current_state = initial_state for _ in range(num_transitions): transitions = chain[current_state] next_state = random.choices(list(transitions.keys()), weights=transitions.values())[0] history.append(next_state) current_state = next_state return history"},{"question":"# Binary Search for Last Occurrence in a Sorted Array Scenario: You are given a sorted array of integers in increasing order. You need to find the index of the last occurrence of a given integer in the array using binary search. Task: Implement a function that will take a sorted array and a query integer, and return the index of the last occurrence of the query integer in the array. If the integer is not found in the array, return -1. Function Signature: ```python def last_occurrence(array: List[int], query: int) -> int: pass ``` # Input: 1. `array` (a list of integers in increasing order): `[int]` 2. `query` (an integer, the element to search for): `int` # Output: - Return the index of the last occurrence of the query integer. If it is not found, return `-1`. # Constraints: - The array is sorted in increasing order. - The array can have a length of `0` to `10^6`. - -10^9 < array[i] <= 10^9 for all valid indices `i` - -10^9 < query <= 10^9 # Example: ```python assert last_occurrence([1, 2, 2, 2, 3, 4, 5, 5, 5, 6], 5) == 8 assert last_occurrence([1, 2, 3, 4, 5, 6], 4) == 3 assert last_occurrence([1, 1, 1, 1, 1], 1) == 4 assert last_occurrence([1, 2, 3, 4], 7) == -1 ``` # Note: - If the array is empty, return `-1`. - Optimize for time complexity of O(log n).","solution":"from typing import List def last_occurrence(array: List[int], query: int) -> int: low, high = 0, len(array) - 1 result = -1 while low <= high: mid = (low + high) // 2 if array[mid] == query: result = mid low = mid + 1 # Continue to search in the right half elif array[mid] < query: low = mid + 1 else: high = mid - 1 return result"},{"question":"# Scenario A logistics company is facing a challenge with their shipment categorization system. They have shipments coded into three categories: low priority (coded as 0), medium priority (coded as 1), and high priority (coded as 2). They need to sort these shipments in the order of low, medium, and high priority before loading them into their transport trucks. # Task Write a function `sort_shipments(shipments: List[int]) -> None` which sorts a provided list of shipments in-place. The function should ensure that all shipments of the same category are adjacent, in the order 0 (low priority), 1 (medium priority), and 2 (high priority). The code must not use the built-in sort functions. # Input - `shipments` (List[int]): A list of integers where each integer is either 0, 1, or 2. # Output - The function should sort the list in place and not return anything. # Constraints - The length of the list can be at most 10^5. - The list contains only 0, 1, and 2 as possible elements. # Performance Requirements - The function should run in O(n) time complexity. - The function should use O(1) additional space. # Example ```python if __name__ == \\"__main__\\": shipments = [2, 0, 2, 1, 1, 0] sort_shipments(shipments) print(shipments) # Output should be [0, 0, 1, 1, 2, 2] shipments = [0, 1, 2, 2, 1, 0] sort_shipments(shipments) print(shipments) # Output should be [0, 0, 1, 1, 2, 2] shipments = [1, 0, 1, 2, 0, 1, 2, 0] sort_shipments(shipments) print(shipments) # Output should be [0, 0, 0, 1, 1, 1, 2, 2] ```","solution":"def sort_shipments(shipments): Modify the list \'shipments\' in-place to order by low, medium, and high priority (0s, followed by 1s, followed by 2s). low, mid, high = 0, 0, len(shipments) - 1 while mid <= high: if shipments[mid] == 0: shipments[low], shipments[mid] = shipments[mid], shipments[low] low += 1 mid += 1 elif shipments[mid] == 1: mid += 1 else: # shipments[mid] == 2 shipments[mid], shipments[high] = shipments[high], shipments[mid] high -= 1"},{"question":"Crout Matrix Decomposition You are given a square matrix ( A ) of size ( n times n ). Your task is to implement the Crout matrix decomposition algorithm, which decomposes ( A ) into a lower triangular matrix ( L ) and an upper triangular matrix ( U ) such that ( L times U = A ). Note that `U` will have ones on its diagonal and non-zero elements above and zeroes below, whereas `L` will have non-zero elements on and below its diagonal. # Input: * A 2D list `A` representing a square matrix of size ( n times n ) where ( 1 leq n leq 100 ). # Output: * Two 2D lists, `L` and `U` representing the lower and upper triangular matrices, respectively. # Constraints: * The matrix `A` will not be singular (i.e., no zero rows or columns). # Example: ```python Input: A = [[1, 2, 3], [3, 4, 5], [6, 7, 8]] Output: L = [[1.0, 0.0, 0.0], [3.0, -2.0, 0.0], [6.0, -5.0, 0.0]], U = [[1.0, 2.0, 3.0], [0.0, 1.0, 2.0], [0.0, 0.0, 1.0]] ``` # Guidelines: * Carefully handle situations where division by zero could occur. * Ensure your algorithm works efficiently even for the upper constraint limits. * Consider the precision errors that might arise from floating-point arithmetic. Implement the function `crout_matrix_decomposition(A: List[List[float]]) -> Tuple[List[List[float]], List[List[float]]]` to solve the problem.","solution":"from typing import List, Tuple def crout_matrix_decomposition(A: List[List[float]]) -> Tuple[List[List[float]], List[List[float]]]: Performs Crout matrix decomposition on a given square matrix A. A = L * U where L is a lower triangular matrix with non-zero diagonal and U is an upper triangular matrix with ones on the diagonal. n = len(A) if n == 0: return [], [] # Initialize L and U with zeros L = [[0.0] * n for _ in range(n)] U = [[0.0] * n for _ in range(n)] # Decomposition process for i in range(n): for j in range(i, n): # Calculate L[i][j] sum_l = sum(L[j][k] * U[k][i] for k in range(i)) L[j][i] = A[j][i] - sum_l for j in range(i, n): if i == j: U[i][i] = 1.0 else: # Calculate U[i][j] sum_u = sum(L[i][k] * U[k][j] for k in range(i)) U[i][j] = (A[i][j] - sum_u) / L[i][i] return L, U"},{"question":"# Sorting Simulation with Random Shuffling You are tasked with creating a function that simulates the sorting of an array using a highly inefficient algorithm known as Bogo Sort. The objective is to shuffle the array randomly until it becomes sorted. Function Signature: ```python def bogo_sort(arr: List[int], simulation: bool = False) -> List[int]: Args: arr : List[int] : The array to be sorted. simulation : bool : If True, print the array after each shuffling step. Returns: List[int] : The sorted array. ``` Input: - `arr`: A list of integers (1 ≤ len(arr) ≤ 50, -10^6 ≤ arr[i] ≤ 10^6). - `simulation`: A boolean flag to print the array after each shuffling during the sorting process. Output: - A list of integers sorted in non-decreasing order. Constraints: - The list will have unique integers. - You must implement the provided `bogo_sort` function with the specified signature. Performance Requirement: - Although Bogo Sort is inherently inefficient, your implementation should handle edge cases and work correctly within the constraints provided. Example: ```python bogo_sort([3, 2, 1], simulation=True) ``` Expected Output: ``` iteration 0: 3 2 1 iteration 1: <random permutation> ... iteration N: 1 2 3 [1, 2, 3] ``` Note: The actual output will vary due to the random nature of the algorithm, but eventually, it should print the sorted array.","solution":"import random from typing import List def bogo_sort(arr: List[int], simulation: bool = False) -> List[int]: Simulates the sorting of an array using Bogo Sort. Args: arr : List[int] : The array to be sorted. simulation : bool : If True, print the array after each shuffling step. Returns: List[int] : The sorted array. def is_sorted(arr: List[int]) -> bool: for i in range(len(arr) - 1): if arr[i] > arr[i + 1]: return False return True iteration = 0 while not is_sorted(arr): if simulation: print(f\\"iteration {iteration}: {arr}\\") random.shuffle(arr) iteration += 1 if simulation: print(f\\"iteration {iteration}: {arr}\\") return arr"},{"question":"# Remove Range from a Linked List Scenario: You are a software engineer tasked with manipulating data stored in a singly linked list. Part of your job involves removing a range of elements efficiently. Task: Implement a function `remove_range(head: ListNode, start: int, end: int) -> ListNode` that removes elements from index `start` to `end` (inclusive) in the linked list. Instructions: - Ensure the input linked list is non-empty. - The `start` and `end` indices will be such that (0 leq text{start} leq text{end} < text{length of the list}). - You are expected to return the head of the modified list after removal. - Aim for an optimal solution in terms of time and space complexity. Function Signature: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_range(head: ListNode, start: int, end: int) -> ListNode: pass ``` Constraints: - The list will contain between 1 and (10^5) nodes. - The values in the nodes are arbitrary integers. Example: ```python # Definition for singly-linked list. class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def print_list(head): lst = [] while head: lst.append(head.val) head = head.next return lst # Helper function to create a linked list from a list def create_linked_list(lst): dummy = ListNode(0) current = dummy for value in lst: current.next = ListNode(value) current = current.next return dummy.next # Testing structure example initial_list = [8, 13, 17, 4, 9, 12, 98, 41, 7, 23, 0, 92] start_index = 3 end_index = 8 head = create_linked_list(initial_list) modified_head = remove_range(head, start_index, end_index) assert print_list(modified_head) == [8, 13, 17, 23, 0, 92] ``` Note: Ensure that your solution is well-tested against a variety of scenarios, including different start and end positions, and the smallest and largest possible list sizes.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_range(head: ListNode, start: int, end: int) -> ListNode: if start == 0: # Edge case where we start removing from the head of the list current = head for _ in range(end - start + 1): current = current.next return current dummy = ListNode(0) dummy.next = head prev = dummy # Move the prev pointer to the node just before the start index for _ in range(start): prev = prev.next # Skip all nodes from start to end current = prev.next for _ in range(end - start + 1): current = current.next # Connect previous part of the list to the part after end index prev.next = current return dummy.next"},{"question":"# Scenario: You are tasked with developing an efficient sorting algorithm for a set of non-negative integers. Your objective is to implement Radix Sort which is suitable for sorting large arrays with wide-ranging values without using comparison-based methods. # Challenge: Implement a function `radix_sort(arr: List[int]) -> List[int]` that sorts an array of non-negative integers using Radix Sort. # Function Signature: ```python def radix_sort(arr: List[int]) -> List[int]: pass ``` # Input: * `arr`: a list of non-negative integers (0 leq arr[i] leq 10^9) * ( 0 leq len(arr) leq 10^6 ) # Output: * Returns a sorted list of integers. # Example: ```python # Example 1 arr = [170, 45, 75, 90, 802, 24, 2, 66] assert radix_sort(arr) == [2, 24, 45, 66, 75, 90, 170, 802] # Example 2 arr = [329, 457, 657, 839, 436, 720, 355] assert radix_sort(arr) == [329, 355, 436, 457, 657, 720, 839] ``` # Guidelines: * Ensure the algorithm is stable and maintains proper order of input elements with equal values. * Consider the efficiency of the solution to handle the maximum input size. # Constraints: * The array may contain repeated elements. * All integers in the array are non-negative. * The input array can be empty, in which case the function should return an empty array.","solution":"from typing import List def counting_sort(arr: List[int], exp: int) -> List[int]: n = len(arr) output = [0] * n count = [0] * 10 for i in range(n): index = (arr[i] // exp) % 10 count[index] += 1 for i in range(1, 10): count[i] += count[i - 1] i = n - 1 while i >= 0: index = (arr[i] // exp) % 10 output[count[index] - 1] = arr[i] count[index] -= 1 i -= 1 for i in range(n): arr[i] = output[i] return arr def radix_sort(arr: List[int]) -> List[int]: if len(arr) == 0: return [] max_val = max(arr) exp = 1 while max_val // exp > 0: arr = counting_sort(arr, exp) exp *= 10 return arr"},{"question":"# Coding Problem: Custom String Reversal Function Context You are working on a text editor that needs to manipulate and process strings frequently. One of the required operations is to reverse given strings. However, to ensure efficient manipulation, especially for large documents, you need to implement a robust and efficient custom string reversal function. Problem Statement Write an efficient string reversal function `custom_reverse(s)` that meets the following criteria: 1. **Input**: A string `s` (0 <= len(s) <= 10^6). 2. **Output**: A new string which is the reverse of `s`. Constraints - The function should have an overall time complexity of O(n). - The function should avoid excessive use of additional memory where possible. - You should handle edge cases such as empty strings and single-character strings. Requirements 1. Implement the function `custom_reverse(s)` ensuring it passes all edge cases and adheres to efficient memory and time usage. 2. Write thorough test cases to validate your function against typical and edge cases. ```python def custom_reverse(s): Reverses the given string s. Args: s (str): The input string. Returns: str: The reversed string. # Implement the function here pass # Test cases print(custom_reverse(\\"\\")) # Expected: \\"\\" print(custom_reverse(\\"a\\")) # Expected: \\"a\\" print(custom_reverse(\\"abcdef\\")) # Expected: \\"fedcba\\" print(custom_reverse(\\"abcdefghijklmnopqrstuvwxyz\\")) # Expected: \\"zyxwvutsrqponmlkjihgfedcba\\" print(custom_reverse(\\"racecar\\")) # Expected: \\"racecar\\" ``` Additional Notes - You are encouraged to write a function that balances time and space complexities effectively. - Comment on any decisions or trade-offs you made during implementation.","solution":"def custom_reverse(s): Reverses the given string s. Args: s (str): The input string. Returns: str: The reversed string. return s[::-1] # Example usage: # print(custom_reverse(\\"\\")) # Expected: \\"\\" # print(custom_reverse(\\"a\\")) # Expected: \\"a\\" # print(custom_reverse(\\"abcdef\\")) # Expected: \\"fedcba\\" # print(custom_reverse(\\"abcdefghijklmnopqrstuvwxyz\\")) # Expected: \\"zyxwvutsrqponmlkjihgfedcba\\" # print(custom_reverse(\\"racecar\\")) # Expected: \\"racecar\\""},{"question":"You are given the skeleton of a class to represent an undirected graph\'s node and three methods (`clone_graph1`, `clone_graph2`, and `clone_graph`) to clone a graph using BFS, iterative DFS, and recursive DFS, respectively. Each node in the graph contains a unique label and a list of its neighboring nodes. Your task is to write a function `clone_graph_with_metadata` that not only clones the graph but also associates each cloned node with additional metadata. Specifically, each cloned node should be associated with its depth in the graph, with the starting node having depth 0. You may assume that every node in the graph is uniformly reachable from the starting node. The function should take the following form: ```python def clone_graph_with_metadata(node): Parameters: - node (UndirectedGraphNode): The starting node of the graph to be cloned. Returns: - (UndirectedGraphNode, dict): A tuple where the first element is the cloned node corresponding to the input node, and the second element is a dictionary mapping each cloned node to its depth. ``` # Constraints - The graph may contain up to 1000 nodes. - Node labels are unique integers. - The graph may contain cycles or self-loops. - The graph can be disconnected. # Example Here\'s an example to illustrate the expected output: ```python # Original graph serialization: {0,1,2#1,2#2,2} # Use the provided UndirectedGraphNode class to create the graph nodes. node_0 = UndirectedGraphNode(0) node_1 = UndirectedGraphNode(1) node_2 = UndirectedGraphNode(2) node_0.neighbors = [node_1, node_2] node_1.neighbors = [node_2] node_2.neighbors = [node_2] # Clone the graph and get the depth metadata. cloned_node, depths = clone_graph_with_metadata(node_0) # The depths dictionary should contain something like: # { # cloned_node (with label 0): 0, # node (with label 1): 1, # node (with label 2): 1 # } ``` # Notes - The method needs to handle different traversals gracefully and preserve the structure and depth metadata accurately. - Consider edge cases such as empty graphs, graphs with cycles, and disconnected graphs. - Performance implications should be taken into account to handle the constraints efficiently.","solution":"class UndirectedGraphNode: def __init__(self, x): self.label = x self.neighbors = [] def clone_graph_with_metadata(node): Clones the graph and associates each cloned node with its depth in the graph. Parameters: - node (UndirectedGraphNode): The starting node of the graph to be cloned. Returns: - (UndirectedGraphNode, dict): A tuple where the first element is the cloned node corresponding to the input node, and the second element is a dictionary mapping each cloned node to its depth. if not node: return None, {} from collections import deque, defaultdict # Dictionary to map original nodes to their clones clone_map = {} # Dictionary to store depth of each cloned node depths = {} def bfs_clone(node): queue = deque([(node, 0)]) clone_map[node] = UndirectedGraphNode(node.label) depths[clone_map[node]] = 0 while queue: current, depth = queue.popleft() current_clone = clone_map[current] for neighbor in current.neighbors: if neighbor not in clone_map: # Clone the neighbor and add to the queue clone_map[neighbor] = UndirectedGraphNode(neighbor.label) queue.append((neighbor, depth + 1)) depths[clone_map[neighbor]] = depth + 1 # Add the cloned neighbor to the current clone\'s neighbors current_clone.neighbors.append(clone_map[neighbor]) # Start BFS to clone the graph and record depths bfs_clone(node) return clone_map[node], depths"},{"question":"# GCD and Trailing Zeros Combined Assessment You are tasked with solving a problem that requires advanced understanding and manipulation of integers using bitwise operations and GCD algorithms. Problem Statement Given an array of non-negative integers, your task is to compute the GCD of all integers in the array using bitwise operations and then determine the number of trailing zeros in the binary representation of this GCD. Function Signature ```python def compute_gcd_and_trailing_zeros(arr: List[int]) -> Tuple[int, int]: Given a list of non-negative integers \'arr\', returns a tuple where the first element is the GCD of all the integers in the list calculated using bitwise operations, and the second element is the number of trailing zeros in the binary representation of that GCD. Parameters: arr (List[int]): A list of non-negative integers. Returns: (int, int): A tuple of the form (gcd, trailing_zeros). ``` Input * `arr`: A list of non-negative integers. The list will have at least one element. * Integer values in the list are between 0 and 10^9. Output * A tuple with: * The first element being the GCD of the array\'s integers computed using bitwise operations. * The second element being the number of trailing zeros in the binary representation of this GCD. Constraints * The list is not empty and contains non-negative integers. * The expected time complexity is O(n * log(max(arr))). Example ```python # Example 1 arr = [40, 60, 80] # gcd of 40, 60 and 80 is 20 # binary representation of 20 is 10100, so it has 2 trailing zeros # Output: (20, 2) # Example 2 arr = [7, 14, 28] # gcd of 7, 14 and 28 is 7 # binary representation of 7 is 111, so it has 0 trailing zeros # Output: (7, 0) ``` Edge Cases to Consider * The array contains a single non-zero element. * All elements in the array are the same. * The array contains zeroes mixed with other numbers, but it will not be all zeroes. Implement the function and ensure it passes all test cases including edge cases.","solution":"from typing import List, Tuple from functools import reduce def gcd(a, b): Helper function to calculate GCD using bitwise operations. while b: a, b = b, a % b return a def compute_gcd_and_trailing_zeros(arr: List[int]) -> Tuple[int, int]: Given a list of non-negative integers \'arr\', returns a tuple where the first element is the GCD of all the integers in the list calculated using bitwise operations, and the second element is the number of trailing zeros in the binary representation of that GCD. # Calculate GCD of the array overall_gcd = reduce(gcd, arr) # Count trailing zeros in the binary representation of the GCD trailing_zeros = (overall_gcd & -overall_gcd).bit_length() - 1 if overall_gcd != 0 else 0 return overall_gcd, trailing_zeros"},{"question":"Coding Assessment Question # Context You are tasked with developing a function that provides the index of the first occurrence of a given element within a sorted array. Your implementation should efficiently search through the array, leveraging its sorted property to minimize the number of comparisons needed. # Objective Implement a function `first_occurrence` that finds and returns the index of the first occurrence of a given element in a sorted array. The array is sorted in increasing order. # Function Signature ```python def first_occurrence(array: List[int], query: int) -> int: ``` # Input - `array`: A list of integers (`List[int]`), where the elements are sorted in increasing order. - `query`: An integer (`int`), representing the element to search in the array. # Output - Returns an integer (`int`), representing the index of the first occurrence of the query element. - If the element is not found, return `-1`. # Constraints - The length of the array (`len(array)`) will be between `0` and `10^5`. - The elements of the array will be integers within the range `[-10^9, 10^9]`. - The query element will be an integer within the range `[-10^9, 10^9]`. # Performance Requirements - The algorithm should run in ( O(log n) ) time complexity. - The space complexity should be ( O(1) ). # Example ```python assert first_occurrence([1, 2, 2, 2, 3, 4, 5], 2) == 1 assert first_occurrence([1, 2, 3, 4, 5], 6) == -1 assert first_occurrence([1], 1) == 0 assert first_occurrence([], 3) == -1 ``` # Notes - Make sure to handle edge cases such as an empty array or the query element not present in the array. - The array will always be sorted in strictly increasing order.","solution":"def first_occurrence(array, query): Finds the index of the first occurrence of `query` in a sorted `array`. Returns -1 if the `query` is not in the array. :param array: List[int] - a sorted list of integers :param query: int - the element to find in the array :return: int - the index of the first occurrence of `query` in `array` or -1 if not found low, high = 0, len(array) - 1 result = -1 while low <= high: mid = (low + high) // 2 if array[mid] < query: low = mid + 1 elif array[mid] > query: high = mid - 1 else: result = mid high = mid - 1 # Move to the left part to find the first occurrence return result"},{"question":"# Binary Search Implementation Challenge Problem Statement You are given a sorted array of integers where each integer is unique. Your task is to implement a function that uses binary search to find the index of a given target value. If the target value is not present in the array, the function should return -1. Function Signature ```python def binary_search(arr: List[int], target: int) -> int: ``` Input - `arr`: A list of integers sorted in ascending order. - Each integer in the array is unique. - The length of the array will be between 1 and 10^5. - `target`: An integer representing the value to search for. Output - An integer representing the index of the `target` in the array if found, otherwise -1. Constraints - Expected time complexity: O(log(n)) - Expected space complexity: O(1) Performance Requirements - The function should handle large arrays (up to 100,000 elements) efficiently within acceptable runtime limits on standard computing environments. Example ```python # Example 1: arr = [1, 2, 4, 5, 9, 12, 18] target = 5 # Output: 3 (The index of 5 in the array) # Example 2: arr = [1, 2, 4, 5, 9, 12, 18] target = 7 # Output: -1 (7 is not present in the array) ``` Implementation Implement the `binary_search` function based on the provided specification. Be sure to consider edge cases such as an empty array and missing target values.","solution":"from typing import List def binary_search(arr: List[int], target: int) -> int: Returns the index of the target value in the sorted array if present, otherwise returns -1. left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: return mid elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Pathfinding in Graphs: Advanced Challenge **Scenario**: You are a software engineer tasked with optimizing a network service that requires efficient routing between nodes (servers). Your service must handle dynamic and complex graphs, ensuring paths are found quickly and reliably, even in large and sparse networks. **Problem Statement**: Given a directed graph represented as an adjacency list and two nodes, start and end, your task is to implement a function `find_optimized_shortest_path` that determines the shortest path from start to end. Additionally, your implementation should handle cyclic graphs efficiently. Your algorithm should be capable of handling large graphs without running into performance bottlenecks typical of recursive depth-first search. **Function Signature**: ```python def find_optimized_shortest_path(graph: Dict[str, List[str]], start: str, end: str) -> Optional[List[str]]: # Implement your solution here ``` **Input and Output**: - `graph`: Dictionary representing the directed graph, where keys are node labels and values are lists of labels for adjacent nodes. - `start`: Label of the starting node. - `end`: Label of the ending node. - Returns a list of node labels representing the shortest path from start to end. Returns `None` if no path exists. **Constraints**: - Nodes are labeled with unique string identifiers. - The graph can contain cycles. - Maximum nodes in the graph: 1000. - Maximum edges in the graph: 5000. **Example**: ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'C\', \'D\'], \'C\': [\'D\'], \'D\': [\'E\'], \'E\': [] } start = \'A\' end = \'E\' path = find_optimized_shortest_path(graph, start, end) print(path) # Expected: [\'A\', \'B\', \'D\', \'E\'] or some other shortest path ``` **Performance Requirements**: - The solution must have a time complexity of at most O(V + E). - The solution must handle cycles efficiently and avoid unnecessary calculations. **Hints/Considerations**: - Optimize using heuristics where applicable (e.g., Breadth-First Search for shortest path in unweighted graphs). - Avoid deep recursion by converting recursive logic into iterative logic using appropriate data structures (e.g., queues).","solution":"from collections import deque from typing import Dict, List, Optional def find_optimized_shortest_path(graph: Dict[str, List[str]], start: str, end: str) -> Optional[List[str]]: Determines the shortest path from start to end in a directed graph using BFS. Parameters: graph (Dict[str, List[str]]): The graph represented as an adjacency list. start (str): The starting node. end (str): The ending node. Returns: Optional[List[str]]: The shortest path from start to end or None if no path exists. if start not in graph or end not in graph: return None queue = deque([(start, [start])]) visited = set() while queue: current_node, path = queue.popleft() if current_node == end: return path visited.add(current_node) for neighbor in graph.get(current_node, []): if neighbor not in visited: queue.append((neighbor, path + [neighbor])) visited.add(neighbor) return None"},{"question":"# Scenario You are designing a system that communicates binary commands between modules of an embedded system. Ensuring that the correct signals are sent and received is crucial. One aspect of this involves flipping bits in commands to convert between two different states or versions of a command. # Problem Statement Write a function `count_flips_to_convert(a: int, b: int) -> int` that determines the minimal number of bits you would need to flip to convert integer `a` to integer `b`. Input * Two integers `a` and `b` where `0 <= a, b <= 10^9`. Output * An integer representing the minimal number of bit flips required to convert `a` to `b`. Constraints * Your function should handle the most significant bit constraints efficiently. * The solution should demonstrate the optimal use of bitwise operations with minimal time complexity. Example ``` Input: a = 29, b = 15 Output: 2 Explanation: 29 in binary: 11101 15 in binary: 01111 Bit flips needed: 2 (flip the first and third bits) ``` Use the following code template to implement your solution: ```python def count_flips_to_convert(a, b): # Implement your solution here pass # Example usage print(count_flips_to_convert(29, 15)) # Output: 2 ``` Ensure your solution runs efficiently within the given constraints.","solution":"def count_flips_to_convert(a, b): Returns the minimal number of bit flips required to convert integer `a` to integer `b`. # XOR between a and b gives a number where each bit set to 1 # represents different bits between a and b. xor_result = a ^ b # Count the number of 1\'s in the binary representation of xor_result, # which represents the number of bits we need to flip. return bin(xor_result).count(\'1\') # Example usage # print(count_flips_to_convert(29, 15)) # Output: 2"},{"question":"# Krishnamurthy Number Detection Scenario: You are tasked with creating an efficient function to detect if a given number is a Krishnamurthy number. This will help in a mathematical exploration module to identify special numbers automatically. Function Details: **Function Name**: `is_krishnamurthy_number` **Input Format**: - An integer `n` (0 <= n <= 10^7). **Output Format**: - Return `True` if the number is a Krishnamurthy number. - Return `False` otherwise. Constraints: 1. The number `n` will be a non-negative integer. 2. Your solution should be optimized for performance due to potential large input size. Performance Requirements: - Your solution should aim to run efficiently in terms of time and space. Example: 1. `is_krishnamurthy_number(145)` should return `True` 2. `is_krishnamurthy_number(40585)` should return `True` 3. `is_krishnamurthy_number(357)` should return `False` Notes: - Factorials for digits can be precomputed for optimization. Implementation: Implement the function `is_krishnamurthy_number` based on the above requirements and scenarios.","solution":"def factorial(n): Return the factorial of a given number n. if n == 0 or n == 1: return 1 result = 1 for i in range(2, n + 1): result *= i return result def is_krishnamurthy_number(n): Return True if the given number n is a Krishnamurthy number, else False. # Precomputing factorials for digits 0-9 factorials = {i: factorial(i) for i in range(10)} temp = n sum_of_factorials = 0 while temp > 0: digit = temp % 10 sum_of_factorials += factorials[digit] temp //= 10 return sum_of_factorials == n"},{"question":"# In-Order Successor in Binary Search Tree Problem Statement Given a valid Binary Search Tree (BST) and a target node `target`, write a function `find_successor(root, target)` that finds the in-order successor of the target node. The in-order successor of a node is the node with the smallest key greater than the input node\'s key. Function Signature ```python def find_successor(root, target): # Your code here ``` Input * `root`: The root node of the BST (object of TreeNode which has `val`, `left` and `right` attributes). * `target`: The target node for which the in-order successor needs to be found. Output * Return the in-order successor node of the target node. * If the target has no in-order successor, return `None`. Constraints 1. The tree contains at least one node and all node values are distinct. 2. The target node exists in the tree. 3. The given tree is a valid binary search tree. Performance Requirements The solution should aim for `O(h)` time complexity, where h is the height of the tree. Example ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.val = value self.left = left self.right = right # Example Usage root = TreeNode(20) root.left = TreeNode(10) root.right = TreeNode(30) root.left.left = TreeNode(5) root.left.right = TreeNode(15) target = root.left # Node with value 10 successor = find_successor(root, target) print(successor.val if successor else \\"None\\") # Output: 15 ``` Notes * You need to ensure that your solution works efficiently for large trees. * Handle edge cases like the situation where the `target` node has no in-order successor. Write a function `find_successor` that meets the above requirements.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.val = value self.left = left self.right = right def find_successor(root, target): Find the in-order successor of the target node in a BST. successor = None current = root while current: if target.val < current.val: successor = current current = current.left else: current = current.right return successor"},{"question":"Regex Pattern Matching Problem Statement Design a function to implement regular expression matching with support for `.` and `*`. Your function should determine if the input string matches the entire pattern. * `.` Matches any single character. * `*` Matches zero or more occurrences of the preceding element. The matching should cover the entire input string, not partial matches. Function Signature ```python def is_match(s: str, p: str) -> bool: Determines if the string `s` matches the pattern `p`. Parameters: s (str): The input string. p (str): The pattern string containing characters, \'.\', and \'*\'. Returns: bool: True if `s` matches `p` entirely, otherwise False. ``` Input and Output * **Input**: - `s`: A string of length `n` where (0 leq n leq 1000). - `p`: A string representing the pattern of length `m` where (0 leq m leq 1000). * **Output**: - A boolean value (`True` or `False`). Constraints and Considerations * Time Complexity: Ensure the solution executes in (O(n times m)). * Space Complexity: Aim to use (O(n times m)) for the dynamic programming table. * Must handle edge cases effectively, e.g., empty string/pattern, patterns ending with `*`. Examples ```text is_match(\\"aa\\", \\"a\\") → False is_match(\\"aa\\", \\"aa\\") → True is_match(\\"aaa\\", \\"aa\\") → False is_match(\\"aa\\", \\"a*\\") → True is_match(\\"aa\\", \\".*\\") → True is_match(\\"ab\\", \\".*\\") → True is_match(\\"aab\\", \\"c*a*b\\") → True ``` You are required to implement the function `is_match` to satisfy the above requirements and examples. Write code that effectively uses dynamic programming to solve the problem as described.","solution":"def is_match(s: str, p: str) -> bool: Determines if the string `s` matches the pattern `p`. Parameters: s (str): The input string. p (str): The pattern string containing characters, \'.\', and \'*\'. Returns: bool: True if `s` matches `p` entirely, otherwise False. # Create a 2D DP table with dimensions (len(s) + 1) x (len(p) + 1) dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)] dp[0][0] = True # Empty string matches empty pattern # Initialize base cases for patterns with * for j in range(1, len(p) + 1): if p[j - 1] == \'*\': dp[0][j] = dp[0][j - 2] for i in range(1, len(s) + 1): for j in range(1, len(p) + 1): if p[j - 1] == \'.\' or p[j - 1] == s[i - 1]: # Current chars match, take diagonal value dp[i][j] = dp[i - 1][j - 1] elif p[j - 1] == \'*\': # Current pattern char \'*\' can be zero or more of the preceding char in pattern dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] if p[j - 2] == s[i - 1] or p[j - 2] == \'.\' else False) return dp[len(s)][len(p)]"},{"question":"# Combination Calculation Task Implement a function that efficiently computes the number of ways to choose `r` items from `n` items (represented as `nCr`). Given the large possible values of `n` and `r`, you need to ensure that your solution handles large values without excessive computation time. Use an appropriate optimization strategy to enhance performance, such as memoization. Function Signature ```python def optimized_combination(n: int, r: int) -> int: pass ``` Input - `n` (1 ≤ n ≤ 1000): The total number of items. - `r` (0 ≤ r ≤ n): The number of items to choose. Output - Return an integer representing the number of ways to choose `r` items from `n` items (`nCr`). Constraints - Avoid deep recursion problems and optimize the solution using an appropriate technique. - Ensure the solution runs efficiently for large values of `n` and `r`. Example ```python assert optimized_combination(5, 2) == 10 assert optimized_combination(10, 5) == 252 assert optimized_combination(50, 25) == 126410606437752 ``` # Scenario In a lottery game, participants must choose `r` numbers out of `n` possible numbers. Your task is to write a function to determine how many different combinations of `r` numbers can be chosen from a set of `n` numbers. This calculation is fundamental to determining lottery odds and requires efficient computation for large inputs.","solution":"def optimized_combination(n: int, r: int) -> int: Computes the number of ways to choose `r` items from `n` items using Pascal\'s Triangle. if r > n: return 0 if r == 0 or r == n: return 1 # Initialize an array for storing binomial coefficients C = [0] * (r + 1) # Set the first value C[0] = 1 for i in range(1, n + 1): # Compute next row of Pascal\'s Triangle j = min(i, r) while j > 0: C[j] = C[j] + C[j - 1] j -= 1 return C[r]"},{"question":"# Pigeonhole Sort Implementation Objective: Implement the Pigeonhole Sort algorithm to sort a given list of integers. Your solution should handle edge cases efficiently and consider both time and space complexities. Description: You are provided with an unsorted array of integer values. The task is to sort this array using the Pigeonhole Sort algorithm and return the sorted array. Input: - An array `arr` of integers, where `1 <= len(arr) <= 10^5`. - Each integer in `arr` is within the range of a 32-bit signed integer. Output: - Return the sorted array as a list of integers. Constraints: - Optimize for both time and space complexity considering practical range limitations. - The input array can have duplicate values. Example: ```python # Example 1 Input: [8, 3, 2, 7, 4] Output: [2, 3, 4, 7, 8] # Example 2 Input: [1, 5, 3, 8, 2, 4, 7, 6] Output: [1, 2, 3, 4, 5, 6, 7, 8] ``` Additional Details: - Ensure your implementation handles edge cases, such as arrays with only one element, arrays already sorted, and arrays with identical elements. - Avoid excessive memory usage for large ranges to ensure performance remains efficient. Implement the `pigeonhole_sort` function as described.","solution":"def pigeonhole_sort(arr): Sort an array of integers using the Pigeonhole Sort algorithm. if not arr: return arr min_val = min(arr) max_val = max(arr) range_of_elements = max_val - min_val + 1 # Allocate pigeonholes holes = [0] * range_of_elements # Place elements into their respective holes for num in arr: holes[num - min_val] += 1 # Gather the sorted output sorted_arr = [] for i in range(range_of_elements): while holes[i] > 0: sorted_arr.append(i + min_val) holes[i] -= 1 return sorted_arr"},{"question":"Problem Statement You are tasked with writing a function that demonstrates your understanding of basic control structures and sequence generation using simple conditional logic. Your task is to implement the FizzBuzz algorithm as described below. # Function Signature ```python def fizzbuzz(n: int) -> list: Generates a list of values from 1 to n with specific substitutions for multiples of 3 and 5. Parameters: n (int): The upper limit of the range starting from 1. Returns: list: A list containing numbers with substitutions based on the given rules. ``` # Description 1. Generate a sequence of numbers from 1 to `n`. 2. Replace certain values based on the following conditions: - If the number is a multiple of 3, use the value \'Fizz\'. - If the number is a multiple of 5, use the value \'Buzz\'. - If the number is a multiple of both 3 and 5, use the value \'FizzBuzz\'. 3. If none of the above conditions apply, retain the number itself in the list. # Input * `n` (integer): An upper bound of the sequence. Must be greater than or equal to 1. (`1 <= n <= 10^6`) # Output * A list of integers and strings based on the rules mentioned above. # Examples 1. For `n = 15`, the function should return: ```python [1, 2, \'Fizz\', 4, \'Buzz\', \'Fizz\', 7, 8, \'Fizz\', \'Buzz\', 11, \'Fizz\', 13, 14, \'FizzBuzz\'] ``` # Constraints * `n` will always be greater than or equal to 1. * You must handle a large input size efficiently. Ensure your algorithm runs in O(n) time. # Implementation Write your implementation of the function `fizzbuzz` above and ensure it works for the provided examples.","solution":"def fizzbuzz(n: int) -> list: Generates a list of values from 1 to n with specific substitutions for multiples of 3 and 5. Parameters: n (int): The upper limit of the range starting from 1. Returns: list: A list containing numbers with substitutions based on the given rules. result = [] for i in range(1, n + 1): if i % 3 == 0 and i % 5 == 0: result.append(\'FizzBuzz\') elif i % 3 == 0: result.append(\'Fizz\') elif i % 5 == 0: result.append(\'Buzz\') else: result.append(i) return result"},{"question":"Pigeonhole Sort Implementation Context You are working on a data processing task that requires sorting large datasets efficiently. Given the nature of the data, you need a sorting algorithm that performs exceedingly well when the range of input values is relatively small. You decide to implement the Pigeonhole Sort algorithm to achieve this. Task Write a function `pigeonhole_sort` that sorts a list of integers using the Pigeonhole Sort algorithm. Function Signature ```python def pigeonhole_sort(arr: List[int]) -> List[int]: ``` Input - `arr` (List[int]): A list of integers that need to be sorted. The list can include both negative and positive integers but will always have at least one element. Output - Returns a sorted list of integers. Constraints 1. The length of the list `n` will be in the range [1, 10^5]. 2. The integer values in the list will be in the range [-10^5, 10^5]. 3. The absolute difference between the maximum and minimum value in the list will not exceed 10^5. Requirements 1. Your solution should have a time complexity of O(n + Range), where `Range` is the difference between the maximum and minimum values in the array. 2. Your solution should have a space complexity of O(Range). Examples 1. Example 1: ```python pigeonhole_sort([8, 3, 2, 7, 4]) # Output: [2, 3, 4, 7, 8] ``` 2. Example 2: ```python pigeonhole_sort([-1, -10, 3, -2, 4, -8]) # Output: [-10, -8, -2, -1, 3, 4] ``` Additional Information Make sure to handle edge cases such as: 1. Arrays consisting of all identical values (e.g., `[5, 5, 5, 5]`). 2. Arrays with negative values. 3. The smallest and largest possible values. Good luck and happy coding!","solution":"def pigeonhole_sort(arr): if not arr: return [] min_val = min(arr) max_val = max(arr) size = max_val - min_val + 1 # Initialize pigeonholes holes = [0] * size # Populate pigeonholes for num in arr: holes[num - min_val] += 1 # Collect sorted elements sorted_arr = [] for i in range(size): while holes[i] > 0: sorted_arr.append(i + min_val) holes[i] -= 1 return sorted_arr"},{"question":"Context You are developing a navigation system for a delivery service operating in a city consisting of interconnected blocks. The city map is represented as an undirected graph where nodes are street intersections, and edges are the roads connecting them. You need to design a function that helps in finding the shortest path between two given intersections. Task Implement a Python function `find_optimized_shortest_path` that efficiently finds the shortest path between two intersections in an undirected graph while considering constraints and edge cases. Use advanced techniques to handle large graphs and improve efficiency. Function Signature ```python def find_optimized_shortest_path(graph: dict, start: str, end: str) -> list: Finds the optimized shortest path between start and end intersection. :param graph: Dictionary representing a graph where keys are node identifiers and values are lists of adjacent nodes. :param start: The starting node identifier. :param end: The destination node identifier. :return: List of node identifiers representing the shortest path from start to end. If no path exists, return an empty list. pass ``` Input * `graph`: A dictionary where keys are strings representing node identifiers and values are lists of strings representing adjacent nodes. * `start`: A string representing the starting node identifier. * `end`: A string representing the destination node identifier. Output * A list of strings representing the shortest path from `start` to `end`. If no path exists, return an empty list. Constraints * The graph will not be empty and will always contain the nodes `start` and `end`. * Each node will have a unique identifier. * The graph represents a connected undirected graph. * Optimize the function for large graphs up to 10,000 nodes. Performance Requirements * Aim to achieve a time complexity close to O(V + E) and a space complexity of O(V). Example ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\', \'E\'], \'C\': [\'A\', \'F\'], \'D\': [\'B\'], \'E\': [\'B\', \'F\'], \'F\': [\'C\', \'E\'] } assert find_optimized_shortest_path(graph, \'A\', \'F\') == [\'A\', \'C\', \'F\'] assert find_optimized_shortest_path(graph, \'A\', \'D\') == [\'A\', \'B\', \'D\'] ``` Notes * Ensure your code handles edge cases efficiently, e.g., graph with cycles, large graphs, and scenarios where no path exists. * Avoid deep recursion by using iterative approaches where necessary. * Think about optimizing the search algorithm by incorporating cycle detection and early exit conditions.","solution":"from collections import deque def find_optimized_shortest_path(graph, start, end): Finds the optimized shortest path between start and end intersection. :param graph: Dictionary representing a graph where keys are node identifiers and values are lists of adjacent nodes. :param start: The starting node identifier. :param end: The destination node identifier. :return: List of node identifiers representing the shortest path from start to end. If no path exists, return an empty list. # If the start and end are the same, return the start node if start == end: return [start] # Using BFS to find the shortest path queue = deque([(start, [start])]) # Queue of tuples (current_node, path_to_node) visited = set() while queue: current_node, path = queue.popleft() if current_node not in visited: visited.add(current_node) for neighbor in graph[current_node]: if neighbor == end: return path + [end] # Return the path found queue.append((neighbor, path + [neighbor])) return [] # Return an empty list if no path is found"},{"question":"Given an array of integers, write a function `generalized_counting_sort(arr)` that sorts the array using the Counting Sort algorithm. The array can contain both positive and negative integers. # Input - An array `arr` of integers where `n` is the number of elements in the array (1 ≤ n ≤ 10^6). - The elements in `arr` can be any integer value in the range (-10^6 to 10^6). # Output - Return a sorted array of integers in non-decreasing order. # Constraints - Your code should handle edge cases such as empty arrays and arrays with all elements being the same. - Aim for a solution with optimal time and space complexity. # Example **Input:** ```python arr = [3, -1, 0, 1, -2, 1] ``` **Output:** ```python [-2, -1, 0, 1, 1, 3] ``` # Implementation Requirement: - Use the Counting Sort algorithm to implement your solution. # Notes: - Remember to handle negative numbers correctly such that the sorting algorithm works for arrays with mixed positive and negative integers.","solution":"def generalized_counting_sort(arr): if not arr: return [] min_val = min(arr) max_val = max(arr) range_of_elements = max_val - min_val + 1 count = [0] * range_of_elements output = [0] * len(arr) for num in arr: count[num - min_val] += 1 for i in range(1, len(count)): count[i] += count[i - 1] for num in reversed(arr): output[count[num - min_val] - 1] = num count[num - min_val] -= 1 return output"},{"question":"# FizzBuzz Extended Challenge Scenario You are tasked with extending the classic FizzBuzz problem with additional rules for special replacements. Additionally, provide a detailed function that ensures robustness against edge cases and potential erroneous inputs. Problem Statement Write a robust Python function `extended_fizzbuzz` that returns an array of values from 1 to N, replacing numbers based on the following rules: 1. For multiples of 3, use \'Fizz\' instead. 2. For multiples of 5, use \'Buzz\' instead. 3. For multiples of both 3 and 5, use \'FizzBuzz\' instead. 4. For multiples of 7, use \'Whizz\' instead (new rule). 5. For multiples of both 3 and 7, use \'FizzWhizz\' instead. 6. For multiples of both 5 and 7, use \'BuzzWhizz\' instead. 7. For multiples of 3, 5, and 7, use \'FizzBuzzWhizz\' instead. Function Signature ```python def extended_fizzbuzz(n: int) -> List[Union[int, str]]: ``` Input * **n (integer)**: The upper limit of the sequence, where 1 <= n <= 10^6. Output * **List[Union[int, str]]**: The resulting list following the modified rules. Example ```python extended_fizzbuzz(21) ``` Output: ```python [1, 2, \'Fizz\', 4, \'Buzz\', \'Fizz\', \'Whizz\', 8, \'Fizz\', \'Buzz\', 11, \'Fizz\', 13, \'Whizz\', \'FizzBuzz\', 16, 17, \'Fizz\', 19, \'Buzz\', \'FizzWhizz\'] ``` Constraints and Performance Requirements * Ensure minimal execution time by keeping the function\'s time complexity at O(n). * Handle inputs robustly, providing meaningful error messages for invalid inputs. Additional Hints * Carefully handle cases where multiple replacements intersect. * Use helper functions if necessary to enhance code readability.","solution":"from typing import List, Union def extended_fizzbuzz(n: int) -> List[Union[int, str]]: Returns a list of values from 1 to n where: - multiples of 3 are replaced with \'Fizz\' - multiples of 5 are replaced with \'Buzz\' - multiples of both 3 and 5 are replaced with \'FizzBuzz\' - multiples of 7 are replaced with \'Whizz\' - multiples of both 3 and 7 are replaced with \'FizzWhizz\' - multiples of both 5 and 7 are replaced with \'BuzzWhizz\' - multiples of 3, 5, and 7 are replaced with \'FizzBuzzWhizz\' if not isinstance(n, int) or n < 1: raise ValueError(\\"Input must be a positive integer\\") result = [] for i in range(1, n + 1): value = \'\' if i % 3 == 0: value += \'Fizz\' if i % 5 == 0: value += \'Buzz\' if i % 7 == 0: value += \'Whizz\' result.append(value if value else i) return result"},{"question":"# Stack Data Structure Implementation Objective Your task is to implement a stack data structure using both array-based and linked-list-based techniques. You must provide methods to perform basic stack operations (`push`, `pop`, `peek`, and `is_empty`). Ensure that your implementation correctly handles edge cases such as popping from an empty stack. Requirements 1. Implement the `ArrayStack` class. 2. Implement the `LinkedListStack` class. 3. Demonstrate the functionality of both stacks with sample usage. Constraints * You may not use Python\'s built-in list methods for stack operations other than basic list indexing. * Your implementation should handle at least 1000 elements efficiently. * Raising appropriate exceptions for error scenarios (such as popping from an empty stack) is required. Input and Output Formats There are no inputs or outputs for this task directly. However, you should write a demonstration function that showcases: 1. The creation of both stack types. 2. A sequence of `push`, `pop`, and `peek` operations. 3. Handling of edge cases like popping from an empty stack. Performance Requirements * Your implementation should be efficient with time complexities of the stack operations as specified in the analysis. * Ensure that array resizing in `ArrayStack` and memory management in `LinkedListStack` are handled optimally. ```python # Define the stack classes here. # Sample usage demonstration function. def demonstrate_stack_operations(): # Create both stack types array_stack = ArrayStack() linked_list_stack = LinkedListStack() # Perform operations on ArrayStack array_stack.push(10) array_stack.push(20) print(array_stack.peek()) # Should output 20 print(array_stack.pop()) # Should output 20 print(array_stack.pop()) # Should output 10 try: array_stack.pop() # Should raise IndexError except IndexError as e: print(e) # Output the error message # Perform operations on LinkedListStack linked_list_stack.push(30) linked_list_stack.push(40) print(linked_list_stack.peek()) # Should output 40 print(linked_list_stack.pop()) # Should output 40 print(linked_list_stack.pop()) # Should output 30 try: linked_list_stack.pop() # Should raise IndexError except IndexError as e: print(e) # Output the error message # Call the demonstration function demonstrate_stack_operations() ```","solution":"class ArrayStack: def __init__(self): self.stack = [] def push(self, item): self.stack.append(item) def pop(self): if self.is_empty(): raise IndexError(\\"pop from empty stack\\") return self.stack.pop() def peek(self): if self.is_empty(): raise IndexError(\\"peek from empty stack\\") return self.stack[-1] def is_empty(self): return len(self.stack) == 0 class LinkedListStack: class Node: def __init__(self, data): self.data = data self.next = None def __init__(self): self.top = None def push(self, item): new_node = self.Node(item) new_node.next = self.top self.top = new_node def pop(self): if self.is_empty(): raise IndexError(\\"pop from empty stack\\") data = self.top.data self.top = self.top.next return data def peek(self): if self.is_empty(): raise IndexError(\\"peek from empty stack\\") return self.top.data def is_empty(self): return self.top is None"},{"question":"Implement a class `OrderedStack` that maintains the stack elements in a non-decreasing order where the largest element is always on the top. The class should provide the following methods: * `is_empty()` - returns `True` if the stack is empty, otherwise `False`. * `push(item)` - inserts the element into the stack while maintaining the order. * `pop()` - removes and returns the highest element from the top of the stack. Raises `IndexError` if the stack is empty. * `peek()` - returns the highest element from the top of the stack without removing it. Raises `IndexError` if the stack is empty. * `size()` - returns the number of elements in the stack. # Constraints: The elements being pushed into the stack will be comparable (e.g., integers, floats). You must not use additional data structures like lists or arrays directly to maintain order. # Example: ```python stack = OrderedStack() stack.push(3) stack.push(1) stack.push(2) print(stack.pop()) # Output: 3 print(stack.peek()) # Output: 2 print(stack.size()) # Output: 2 print(stack.is_empty()) # Output: False ``` # Performance Requirements: - Your implementation should be efficient in terms of space usage. The use of additional data structures like lists or arrays is only permissible for temporary operations within the methods.","solution":"class Node: def __init__(self, value): self.value = value self.next = None class OrderedStack: def __init__(self): self.top = None self.count = 0 def is_empty(self): return self.top is None def push(self, item): new_node = Node(item) if not self.top or item > self.top.value: new_node.next = self.top self.top = new_node else: current = self.top while current.next and current.next.value > item: current = current.next new_node.next = current.next current.next = new_node self.count += 1 def pop(self): if self.is_empty(): raise IndexError(\\"pop from empty stack\\") item = self.top.value self.top = self.top.next self.count -= 1 return item def peek(self): if self.is_empty(): raise IndexError(\\"peek from empty stack\\") return self.top.value def size(self): return self.count"},{"question":"You are required to implement a function that calculates the Euler\'s Totient function for any given integer `n`. The Euler\'s Totient function, φ(n), is defined as the count of integers from 1 to `n` that are coprime with `n`. # Function Signature ```python def euler_totient(n: int) -> int: ``` # Inputs - `n` (integer, 1 <= n <= 10^6): The number for which the totient function needs to be computed. # Output - Returns an integer which is the result of the Euler\'s Totient calculation for given `n`. # Example ```python print(euler_totient(1)) # should return 1 print(euler_totient(9)) # should return 6 print(euler_totient(15)) # should return 8 ``` # Constraints - Ensure that the solution meets the performance constraints up to `n` = 10^6. - Handle edge cases properly (e.g., `n` = 1, large prime `n`). # Notes - Test the function with a variety of inputs to ensure correctness. - Consider the time and space complexity limits while crafting your solution. - No additional modules should be used apart from standard Python libraries. # Scenario Context Consider a system that encrypts data based on cryptographic algorithms which frequently reference the Euler Totient function. Efficient computation of this function ensures the algorithm maintains high performance even under high load and large data sets. Your goal is thus to create a reliable and performant implementation.","solution":"def euler_totient(n: int) -> int: Calculates the Euler\'s Totient function for a given integer n. if n == 1: return 1 result = n p = 2 while p * p <= n: if n % p == 0: while n % p == 0: n //= p result -= result // p p += 1 if n > 1: result -= result // n return result"},{"question":"# Task You are given an array of non-negative integers. Your task is to implement an in-place Cycle Sort algorithm to sort the array. Unlike other sorting algorithms, Cycle Sort minimizes the number of write operations. It decomposes the array into cycles and rotates them to place elements in their correct positions. # Implementation Details Write a function `cycle_sort(arr: List[int]) -> List[int]` that performs Cycle Sort on the given array. Input Format * `arr` - A list of non-negative integers where `1 <= len(arr) <= 10^6` and `0 <= arr[i] <= 10^9`. Output Format * A list of integers sorted in non-decreasing order. # Example ```python from typing import List def cycle_sort(arr: List[int]) -> List[int]: len_arr = len(arr) for cur in range(len_arr - 1): item = arr[cur] index = cur for i in range(cur + 1, len_arr): if arr[i] < item: index += 1 if index == cur: continue while item == arr[index]: index += 1 arr[index], item = item, arr[index] while index != cur: index = cur for i in range(cur + 1, len_arr): if arr[i] < item: index += 1 while item == arr[index]: index += 1 arr[index], item = item, arr[index] return arr # Sample input sample_array = [3, 5, 2, 7, 5, 3, 2] # Sample output sorted_array = cycle_sort(sample_array) print(sorted_array) # Output: [2, 2, 3, 3, 5, 5, 7] ``` # Constraints * The algorithm should sort the array in-place using Cycle Sort. * Avoid using additional space besides the input array. * Handle edge cases, including arrays with duplicate elements and already sorted arrays. * Ensure the algorithm performs efficiently within the given constraints.","solution":"from typing import List def cycle_sort(arr: List[int]) -> List[int]: len_arr = len(arr) for cur in range(len_arr - 1): item = arr[cur] index = cur for i in range(cur + 1, len_arr): if arr[i] < item: index += 1 if index == cur: continue while item == arr[index]: index += 1 arr[index], item = item, arr[index] while index != cur: index = cur for i in range(cur + 1, len_arr): if arr[i] < item: index += 1 while item == arr[index]: index += 1 arr[index], item = item, arr[index] return arr"},{"question":"# Scenario: You are a software developer for a hospital management system. One of your tasks is to handle emergency cases where patients are admitted based on their condition severity. To manage this, you need to implement a priority queue to schedule patients based on their urgency level. Write a **class `PatientPriorityQueue`** that manages patients based on their urgency. Implement the following functionalities: 1. **`add_patient(name: str, urgency: int)`**: * Adds a patient with a given long name and urgency level to the queue. * If a patient with the same urgency level exists, the new patient should be added at the appropriate position maintaining the urgency sorting. 2. **`get_next_patient() -> str`**: * Removes and returns the patient with the highest urgency from the queue. * If the queue is empty, return `\\"No patients in queue\\"`. 3. **`queue_size() -> int`**: * Returns the current number of patients in the queue. # Input/Output Format: - For `add_patient(name: str, urgency: int)`: name is a string of patient name, urgency is an integer where a higher number signifies higher urgency. - For `get_next_patient() -> str`: should return the name of the patient with the highest urgency. - For `queue_size() -> int`: should return an integer representing the number of patients in the queue. # Constraints: - Assume the urgency levels are unique for simplicity in this case. - Name strings will have a maximum length of 100 characters. - Number of patients in the queue will not exceed 10^6. # Performance Requirements: - Insertion of a new patient: O(n) - Getting the next highest urgency patient: O(1) Implement the `PatientPriorityQueue` class and functionalities described above. ```python class PatientPriorityQueue: def __init__(self): # Initialize an empty priority queue self.priority_queue_list = [] def add_patient(self, name: str, urgency: int): # Add a new patient based on urgency node = PriorityQueueNode(name, urgency) for index, current in enumerate(self.priority_queue_list): if current.priority < node.priority: self.priority_queue_list.insert(index, node) return self.priority_queue_list.append(node) def get_next_patient(self) -> str: # Get and remove the patient with the highest urgency if self.priority_queue_list: return self.priority_queue_list.pop().data else: return \\"No patients in queue\\" def queue_size(self) -> int: # Return the current size of the queue return len(self.priority_queue_list) ``` # Example: ```python queue = PatientPriorityQueue() queue.add_patient(\\"Alice\\", 5) queue.add_patient(\\"Bob\\", 10) print(queue.get_next_patient()) # Output: \\"Bob\\" print(queue.queue_size()) # Output: 1 queue.add_patient(\\"Charlie\\", 8) print(queue.get_next_patient()) # Output: \\"Charlie\\" print(queue.queue_size()) # Output: 1 ```","solution":"class PatientPriorityQueue: def __init__(self): self.priority_queue_list = [] def add_patient(self, name: str, urgency: int): Add a patient with a given name and urgency to the queue. node = (urgency, name) for index, current in enumerate(self.priority_queue_list): if current[0] < urgency: self.priority_queue_list.insert(index, node) return self.priority_queue_list.append(node) def get_next_patient(self) -> str: Removes and returns the patient with the highest urgency from the queue. if self.priority_queue_list: return self.priority_queue_list.pop(0)[1] else: return \\"No patients in queue\\" def queue_size(self) -> int: Returns the current number of patients in the queue. return len(self.priority_queue_list)"},{"question":"Context You are part of a team developing a geographic information system (GIS) which requires frequently searching for specific location data points across a region represented in a grid or matrix format. This matrix is sorted both row-wise and column-wise in a non-decreasing manner. Task Implement a function that searches for a given key in a matrix sorted in non-decreasing order both row-wise and column-wise. Your function should return the row and column indices if the key is found, and `None` otherwise. Function Signature ```python def search_in_sorted_matrix(matrix: List[List[int]], key: int) -> Optional[Tuple[int, int]]: Search for key in a row-wise and column-wise sorted matrix. Args: matrix: List of lists of integers, where each row and each column are sorted in non-decreasing order. key: Integer representing the target value to search for. Returns: A tuple of two integers representing row and column indices of the key found (0-based index), or None if key not found. ``` Input * `matrix`: A list of lists `m x n` integers where each row and column is sorted in non-decreasing order. * `key`: An integer to be searched within the matrix. Output * A tuple `(i, j)` where `i` is the 0-based row index and `j` is the 0-based column index if the key is found. * If the key is not present, return `None`. Constraints * The number of rows and columns in `matrix` will be between `1` and `10^3`. * All integers in the matrix are distinct. * -10^4 ≤ matrix[i][j], key ≤ 10^4 Example ```python matrix = [ [2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20] ] key = 13 # Expected output: (1, 2) print(search_in_sorted_matrix(matrix, key)) ``` Implement the function `search_in_sorted_matrix` adhering to these specifications.","solution":"from typing import List, Optional, Tuple def search_in_sorted_matrix(matrix: List[List[int]], key: int) -> Optional[Tuple[int, int]]: Search for key in a row-wise and column-wise sorted matrix. Args: matrix: List of lists of integers, where each row and each column are sorted in non-decreasing order. key: Integer representing the target value to search for. Returns: A tuple of two integers representing row and column indices of the key found (0-based index), or None if key not found. if not matrix or not matrix[0]: return None rows = len(matrix) cols = len(matrix[0]) # Start from the top-right corner of the matrix row = 0 col = cols - 1 while row < rows and col >= 0: if matrix[row][col] == key: return (row, col) elif matrix[row][col] > key: col -= 1 else: row += 1 return None"},{"question":"# Context You are working on a text editor that uses a linked list to maintain the text\'s history. To implement the undo feature, you need to reverse the linked list representation of the text history. # Problem Statement Given a singly linked list, implement a function to reverse the list. # Function Signature ```python def reverse_list(head: ListNode) -> ListNode: :type head: ListNode :rtype: ListNode def reverse_list_recursive(head: ListNode) -> ListNode: :type head: ListNode :rtype: ListNode ``` # Input and Output * **Input**: * `head`: The head node of a singly linked list. * **Output**: * Returns the head node of the reversed singly linked list. # Constraints * The number of nodes in the list is in the range [0, 10^4]. * -10^5 <= Node.val <= 10^5 # Examples 1. **Example 1**: ```python Input: 1 -> 2 -> 3 -> 4 Output: 4 -> 3 -> 2 -> 1 ``` 2. **Example 2**: ```python Input: 5 -> 1 -> 8 -> 7 Output: 7 -> 8 -> 1 -> 5 ``` # Performance Requirements * The function must handle up to 10,000 nodes efficiently. * It should perform with time complexity O(n) and space complexity O(1) for the iterative approach. # Additional Notes * Ensure to account for edge cases where the list is empty or contains only one node.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_list(head: ListNode) -> ListNode: Reverses a singly linked list iteratively. :param head: The head node of the singly linked list. :return: The head node of the reversed singly linked list. prev = None current = head while current: next_node = current.next current.next = prev prev = current current = next_node return prev def reverse_list_recursive(head: ListNode) -> ListNode: Reverses a singly linked list recursively. :param head: The head node of the singly linked list. :return: The head node of the reversed singly linked list. if not head or not head.next: return head new_head = reverse_list_recursive(head.next) head.next.next = head head.next = None return new_head"},{"question":"# Question: Implement Advanced Matrix Operations You are given a task to implement an optimized matrix inversion function. The provided function `invert_matrix(m)` inverts an `n x n` matrix `m`. However, it is inefficient for large matrices due to recursive determinant calculations. Your task is to rewrite this function using the LU decomposition method, which offers a more efficient approach for matrix inversion. # Steps to Implement: 1. **LU Decomposition**: Decompose the matrix `A` such that `A = LU`, where `L` is a lower triangular matrix and `U` is an upper triangular matrix. 2. **Matrix Inversion via LU**: Use the LU decomposition to find the inverse by solving two triangular systems. # Input & Output: - **Input**: A list of lists `m`, representing an `n x n` square matrix (`2 <= n <= 10`). - **Output**: A list of lists, representing the inverse of the input matrix. If the input is invalid, return `None`. # Constraints: - Only handle square matrices, throw an appropriate error for non-square matrices. - Handle small matrix sizes efficiently without recursion. - Return `None` if the matrix is singular (determinant is 0). # Example: ```python # Example input m = [ [4, 3], [3, 2] ] # Example output [ [-2.0, 3.0], [3.0, -4.0] ] # Example input m = [ [1, 2, 3], [0, 1, 4], [5, 6, 0] ] # Example output [ [-24.0, 18.0, 5.0], [20.0, -15.0, -4.0], [-5.0, 4.0, 1.0] ] ```","solution":"import numpy as np def lu_decomposition(matrix): Perform LU decomposition using the Doolittle factorization. n = len(matrix) L = np.zeros((n, n)) U = np.zeros((n, n)) for i in range(n): L[i][i] = 1.0 for j in range(i, n): sum = 0.0 for k in range(i): sum += L[i][k] * U[k][j] U[i][j] = matrix[i][j] - sum for j in range(i+1, n): sum = 0.0 for k in range(i): sum += L[j][k] * U[k][i] L[j][i] = (matrix[j][i] - sum) / U[i][i] return L, U def invert_matrix(m): matrix = np.array(m, dtype=float) n = matrix.shape[0] if matrix.shape[0] != matrix.shape[1]: return None L, U = lu_decomposition(matrix) # Check for singularity if not all(np.diag(U)): return None inv_L = np.linalg.inv(L) inv_U = np.linalg.inv(U) inv_matrix = np.dot(inv_U, inv_L) return inv_matrix.tolist()"}]'),C={name:"App",components:{PoemCard:S},data(){return{searchQuery:"",visibleCount:4,poemsData:z,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},O={class:"search-container"},L={class:"card-container"},N={key:0,class:"empty-state"},F=["disabled"],R={key:0},j={key:1};function Y(r,e,l,p,s,a){const f=g("PoemCard");return n(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",O,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),y(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[_,s.searchQuery]]),s.searchQuery?(n(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")}," ✕ ")):u("",!0)]),t("div",L,[(n(!0),i(b,null,v(a.displayedPoems,(o,m)=>(n(),w(f,{key:m,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),i("div",N,' No results found for "'+d(s.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(n(),i("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),i("span",j,"Loading...")):(n(),i("span",R,"See more"))],8,F)):u("",!0)])}const B=c(C,[["render",Y],["__scopeId","data-v-0273a7ff"]]),M=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"library/57.md","filePath":"library/57.md"}'),P={name:"library/57.md"},G=Object.assign(P,{setup(r){return(e,l)=>(n(),i("div",null,[x(B)]))}});export{M as __pageData,G as default};
