import{_,o as r,c as n,a as t,m,t as d,C as g,M as p,U as b,f as u,F as x,p as w,e as y,q as v}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},q={class:"poem-container"},T={class:"review"},L={class:"review-title"},R={class:"review-content"};function N(s,e,l,h,i,a){return r(),n("div",q,[t("div",T,[t("div",L,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),m(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",R,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),m(d(l.poem.solution),1)])])])}const j=_(k,[["render",N],["__scopeId","data-v-45b0e7e4"]]),F=JSON.parse(`[{"question":"def trap(height: List[int]) -> int: Returns the total amount of rainwater trapped. Args: height: List[int] - a list of integers representing the height of buildings. Returns: int - the total amount of rainwater trapped. >>> trap([]) == 0 >>> trap([4]) == 0 >>> trap([5, 4, 3, 2, 1]) == 0 >>> trap([1, 2, 3, 4, 5]) == 0 >>> trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 >>> trap([2, 0, 2]) == 2 >>> trap([4, 2, 0, 3, 2, 5]) == 9","solution":"def trap(height): Returns the total amount of rainwater trapped. Args: height: List[int] - a list of integers representing the height of buildings. Returns: int - the total amount of rainwater trapped. if not height: return 0 left, right = 0, len(height) - 1 left_max, right_max = height[left], height[right] water_trapped = 0 while left < right: if left_max < right_max: left += 1 left_max = max(left_max, height[left]) water_trapped += max(0, left_max - height[left]) else: right -= 1 right_max = max(right_max, height[right]) water_trapped += max(0, right_max - height[right]) return water_trapped"},{"question":"def count_pairs(nums, target): Returns the number of unique pairs (i, j) in the list such that nums[i] + nums[j] equals the target. The result is given modulo 10^9 + 7. Examples: >>> count_pairs([1, 2, 3, 4], 5) 2 >>> count_pairs([1, 2, 3, 4], 8) 0 >>> count_pairs([4, 4, 4, 4], 8) 1 >>> count_pairs([-1, -2, 3, 5, 2, -3], 1) 2 >>> count_pairs([1000000000000, 500000000000, 1000000000000, -1000000000000, 0], 0) 1","solution":"def count_pairs(nums, target): Returns the number of unique pairs (i, j) in the list such that nums[i] + nums[j] equals the target. The result is given modulo 10^9 + 7. MOD = 10**9 + 7 nums.sort() pairs = set() seen = set() for num in nums: if target - num in seen: pairs.add((min(num, target - num), max(num, target - num))) seen.add(num) return len(pairs) % MOD"},{"question":"def can_form_by_concatenation(s: str, words: List[str]) -> bool: Determines if the string \`s\` can be formed by concatenating all words from the list \`words\` exactly once and in any order. >>> can_form_by_concatenation(\\"wordgoodgoodword\\", [\\"word\\", \\"good\\", \\"good\\", \\"word\\"]) == True >>> can_form_by_concatenation(\\"wordgoodgoodwordextra\\", [\\"word\\", \\"good\\", \\"good\\", \\"word\\"]) == False >>> can_form_by_concatenation(\\"wordgoodgooword\\", [\\"word\\", \\"good\\", \\"good\\", \\"word\\"]) == False >>> can_form_by_concatenation(\\"goodwordgoodword\\", [\\"word\\", \\"good\\", \\"good\\", \\"word\\"]) == True >>> can_form_by_concatenation(\\"\\", []) == True >>> can_form_by_concatenation(\\"word\\", [\\"word\\"]) == True >>> can_form_by_concatenation(\\"abc\\", [\\"a\\", \\"b\\", \\"c\\"]) == True >>> can_form_by_concatenation(\\"abc\\", [\\"a\\", \\"c\\", \\"b\\"]) == True >>> can_form_by_concatenation(\\"aabbcc\\", [\\"aa\\", \\"bb\\", \\"cc\\"]) == True >>> can_form_by_concatenation(\\"aabbbcc\\", [\\"aa\\", \\"bb\\", \\"cc\\"]) == False","solution":"def can_form_by_concatenation(s, words): Determines if the string \`s\` can be formed by concatenating all words from the list \`words\` exactly once and in any order. Parameters: s (str): The string to be checked. words (list): List of words to concatenate. Returns: bool: True if \`s\` can be formed, else False. from collections import Counter # Combine the words to see if they add up to the given string \`s\` combined_words = ''.join(words) # If the combined length does not match \`s\`, return False early if len(combined_words) != len(s): return False # Use Counter to count characters in \`s\` and combined words return Counter(s) == Counter(combined_words)"},{"question":"def knapsack_max_weight(weights: List[int], capacity: int) -> int: Returns the maximum weight that can be accommodated in the knapsack without exceeding the capacity. >>> knapsack_max_weight([1, 3, 4, 5], 7) 7 >>> knapsack_max_weight([1, 3, 4, 5], 6) 6 >>> knapsack_max_weight([10, 20, 30], 5) 0 >>> knapsack_max_weight([1, 2, 3], 0) 0 >>> knapsack_max_weight([1, 2, 3, 8, 7, 4], 11) 11 >>> knapsack_max_weight([15, 10, 20, 5], 25) 25 >>> knapsack_max_weight([5, 3, 4, 2], 10) 10 >>> knapsack_max_weight([5, 3, 4, 2], 9) 9 >>> knapsack_max_weight([5, 3, 4, 2], 8) 8 >>> knapsack_max_weight([5, 3, 4, 2], 7) 7","solution":"def knapsack_max_weight(weights, capacity): Returns the maximum weight that can be accommodated in the knapsack without exceeding the capacity. n = len(weights) # Initialize a DP array with zeros. dp[j] represents the maximum weight for capacity j. dp = [0] * (capacity + 1) for weight in weights: # Traverse the dp array backwards to avoid recomputing results with the same weight for j in range(capacity, weight - 1, -1): dp[j] = max(dp[j], dp[j - weight] + weight) return dp[capacity]"},{"question":"def min_operations(s: str, k: int) -> int: Returns the minimum number of operations needed to make sure that no character in the string \`s\` appears more than \`k\` times. Parameters: - s (str): The input string consisting of lowercase English letters. - k (int): The maximum number of allowed repetitions for a character. Returns: - int: The minimum number of operations required. >>> min_operations(\\"aaaaa\\", 1) 4 >>> min_operations(\\"aaaaa\\", 2) 2 >>> min_operations(\\"aaaaa\\", 3) 1 >>> min_operations(\\"aaaaa\\", 4) 1 >>> min_operations(\\"aaaaa\\", 5) 0 >>> min_operations(\\"aabbcc\\", 2) 0 >>> min_operations(\\"aabbcc\\", 1) 3 >>> min_operations(\\"aaabbbcccddd\\", 2) 4 >>> min_operations(\\"abcdabcd\\", 2) 0 >>> min_operations(\\"\\", 1) 0 >>> min_operations(\\"abcdabcd\\", 10) 0: { { \` Law of Cosines: To find the length of side c in a triangle with sides of length a and b and included angle Î¸, use the formula: [ c = sqrt{a^2 + b^2 - 2abcos(theta)} ] This formula can be used in a Python function as shown: import math def law_of_cosines(a: float, b: float, theta: float) -> float: Calculate the length of the side 'c' using the law of cosines. Parameters: - a (float): The length of side 'a'. - b (float): The length of side 'b'. - theta (float): The angle between sides 'a' and 'b' in degrees. Returns: - float: The length of side 'c'. >>> law_of_cosines(3, 4, 90) 5.0 >>> law_of_cosines(5, 5, 60) 4.33... # Convert the angle from degrees to radians theta_radians = math.radians(theta) # Calculate side 'c' using the law of cosines formula # Return the length of side 'c'","solution":"from collections import Counter def min_operations(s: str, k: int) -> int: Returns the minimum number of operations needed to make sure that no character in the string \`s\` appears more than \`k\` times. Parameters: - s (str): The input string consisting of lowercase English letters. - k (int): The maximum number of allowed repetitions for a character. Returns: - int: The minimum number of operations required. counter = Counter(s) operations = 0 for char, count in counter.items(): if count > k: operations += (count - 1) // k return operations"},{"question":"def remove_k_digits(s, k): Removes k digits from string s to make it the smallest possible number. Args: s (str): the input string consisting of digits. k (int): the number of digits to remove. Returns: str: the smallest possible string after removing k digits. Examples: >>> remove_k_digits(\\"1432219\\", 3) \\"1219\\" >>> remove_k_digits(\\"10200\\", 1) \\"200\\" >>> remove_k_digits(\\"10\\", 1) \\"0\\" >>> remove_k_digits(\\"1234567890\\", 9) \\"0\\" >>> remove_k_digits(\\"9\\", 1) \\"0\\" >>> remove_k_digits(\\"43214321\\", 4) \\"1321\\" >>> remove_k_digits(\\"112\\", 1) \\"11\\" >>> remove_k_digits(\\"100200300\\", 1) \\"200300\\"","solution":"def remove_k_digits(s, k): Removes k digits from string s to make it the smallest possible number. Args: s (str): the input string consisting of digits. k (int): the number of digits to remove. Returns: str: the smallest possible string after removing k digits. stack = [] for digit in s: while k > 0 and stack and stack[-1] > digit: stack.pop() k -= 1 stack.append(digit) # If we still need to remove more digits, remove from the end stack = stack[:-k] if k > 0 else stack # Join stack to form the number and strip leading zeros return ''.join(stack).lstrip('0') or '0'"},{"question":"import math from typing import List, Tuple def closest_pair_of_points(points: List[List[int]]) -> Tuple[List[int], List[int]]: Finds the pair of points with the smallest Euclidean distance between them. Parameters: points (List[List[int]]): A list of points on a 2D plane. Returns: Tuple[List[int], List[int]]: The coordinates of the two points with the smallest distance. >>> closest_pair_of_points([[0, 0], [1, 1]]) ([0, 0], [1, 1]) >>> closest_pair_of_points([[0, 0], [3, 4], [2, 2], [6, 1], [1, 1]]) in [([0, 0], [1, 1]), ([1, 1], [0, 0])] True","solution":"import math def closest_pair_of_points(points): Finds the pair of points with the smallest Euclidean distance between them. Parameters: points (List[List[int]]): A list of points on a 2D plane. Returns: Tuple[List[int], List[int]]: The coordinates of the two points with the smallest distance. min_distance = float('inf') closest_pair = None for i in range(len(points)): for j in range(i + 1, len(points)): dist = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) if dist < min_distance: min_distance = dist closest_pair = (points[i], points[j]) return closest_pair"},{"question":"def partition_labels(s: str) -> List[int]: Partitions the string s into as many parts as possible so that each letter appears in at most one part and returns the lengths of these parts. pass # Unit Tests def test_single_partition(): assert partition_labels(\\"abacbc\\") == [6] def test_multiple_partitions(): assert partition_labels(\\"ababcbacadefegdehijhklij\\") == [9, 7, 8] def test_all_same_characters(): assert partition_labels(\\"aaaaa\\") == [5] def test_alternating_characters(): assert partition_labels(\\"ababab\\") == [6] def test_no_repeated_characters(): assert partition_labels(\\"abcdef\\") == [1, 1, 1, 1, 1, 1]","solution":"def partition_labels(s): Partitions the string s into as many parts as possible so that each letter appears in at most one part and returns the lengths of these parts. last_occurrence = {ch: i for i, ch in enumerate(s)} j = anchor = 0 result = [] for i, ch in enumerate(s): j = max(j, last_occurrence[ch]) if i == j: result.append(i - anchor + 1) anchor = i + 1 return result"},{"question":"from typing import List, Tuple def find_pairs_with_sum(numbers: List[int], k: int) -> List[Tuple[int, int]]: Finds all unique pairs of elements in the list 'numbers' that sum up to 'k'. Each pair consists of two different elements from 'numbers' and should be reported in a list of tuples. Each tuple should be sorted in ascending order, and the pairs of tuples should be sorted in ascending order based on the first element of each tuple. If no such pairs exist, return an empty list. >>> find_pairs_with_sum([1, 2, 3, 4, 3, 5, 0, 1], 4) [(0, 4), (1, 3)] >>> find_pairs_with_sum([1, 2, 3, 4], 5) [(1, 4), (2, 3)] >>> find_pairs_with_sum([1, 2, 3, 4], 8) [] >>> find_pairs_with_sum([-1, -2, 3, 4, -3, 1], 0) [(-3, 3), (-1, 1)] >>> find_pairs_with_sum([2, 2, 2, 1], 3) [(1, 2)] >>> find_pairs_with_sum([], 1) []","solution":"def find_pairs_with_sum(numbers, k): Finds all unique pairs in 'numbers' that sum up to 'k'. Each pair is represented as a tuple and the list is sorted. pairs = set() seen = set() for number in numbers: complement = k - number if complement in seen: pair = tuple(sorted((number, complement))) pairs.add(pair) seen.add(number) return sorted(pairs)"},{"question":"class FriendsNetwork: A class to represent a social network with bidirectional friendships. Methods ------- __init__(self, friendships) Initializes the network with the given list of friendships. addFriendship(self, a, b) Adds a bidirectional friendship between users \`a\` and \`b\`. removeFriendship(self, a, b) Removes the bidirectional friendship between users \`a\` and \`b\`. getFriendsList(self, user) Returns a list of all friends of the given \`user\`. def __init__(self, friendships): pass def addFriendship(self, a, b): pass def removeFriendship(self, a, b): pass def getFriendsList(self, user): pass # Unit tests def test_initial_friendships(): network = FriendsNetwork([(1, 2), (2, 3), (3, 4)]) assert network.getFriendsList(1) == [2] assert network.getFriendsList(2) == [1, 3] assert network.getFriendsList(3) == [2, 4] def test_add_friendship(): network = FriendsNetwork([(1, 2), (2, 3)]) network.addFriendship(2, 4) assert network.getFriendsList(2) == [1, 3, 4] assert network.getFriendsList(4) == [2] def test_remove_friendship(): network = FriendsNetwork([(1, 2), (2, 3), (2, 4)]) network.removeFriendship(2, 3) assert network.getFriendsList(2) == [1, 4] assert network.getFriendsList(3) == [] def test_get_friends_list_empty_user(): network = FriendsNetwork([(1, 2), (2, 3)]) assert network.getFriendsList(4) == [] def test_get_friends_list(): network = FriendsNetwork([]) network.addFriendship(5, 6) assert network.getFriendsList(5) == [6] network.addFriendship(5, 7) assert network.getFriendsList(5) == [6, 7] network.addFriendship(6, 7) assert network.getFriendsList(6) == [5, 7] network.addFriendship(7, 8) assert network.getFriendsList(7) == [5, 6, 8] network.removeFriendship(7, 5) assert network.getFriendsList(7) == [6, 8] assert network.getFriendsList(5) == [6]","solution":"class FriendsNetwork: def __init__(self, friendships): Initializes the network with the given list of friendships. self.network = {} for a, b in friendships: if a not in self.network: self.network[a] = set() if b not in self.network: self.network[b] = set() self.network[a].add(b) self.network[b].add(a) def addFriendship(self, a, b): Adds a bidirectional friendship between users \`a\` and \`b\`. if a not in self.network: self.network[a] = set() if b not in self.network: self.network[b] = set() self.network[a].add(b) self.network[b].add(a) def removeFriendship(self, a, b): Removes the bidirectional friendship between users \`a\` and \`b\`. if a in self.network and b in self.network[a]: self.network[a].remove(b) if b in self.network and a in self.network[b]: self.network[b].remove(a) def getFriendsList(self, user): Returns a list of all friends of the given \`user\`. if user in self.network: return sorted(list(self.network[user])) return []"},{"question":"from typing import List def shortest_path_with_one_flip(grid: List[List[int]]) -> int: Given a 2-dimensional binary grid \`grid\` where \`0\` represents water and \`1\` represents land, find the length of the shortest path from the top-left corner to the bottom-right corner by flipping at most one \`0\` to \`1\`. If such a path does not exist, return \`-1\`. The path can only be constructed by moving horizontally or vertically. >>> grid = [ ... [1, 0, 0], ... [1, 1, 0], ... [0, 1, 1] ... ] >>> shortest_path_with_one_flip(grid) 5 >>> grid = [ ... [1, 0, 0, 0], ... [1, 1, 1, 0], ... [0, 0, 1, 0], ... [1, 1, 1, 1] ... ] >>> shortest_path_with_one_flip(grid) 7 >>> grid = [ ... [1, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ] >>> shortest_path_with_one_flip(grid) -1 >>> grid = [ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ] >>> shortest_path_with_one_flip(grid) 5 >>> grid = [[0]] >>> shortest_path_with_one_flip(grid) -1 >>> grid = [[1]] >>> shortest_path_with_one_flip(grid) 1","solution":"from collections import deque def shortest_path_with_one_flip(grid): rows, cols = len(grid), len(grid[0]) if rows == 1 and cols == 1: return 1 if grid[0][0] == 1 else -1 def bfs(start): queue = deque([(start, 0, 0)]) visited = [[[False, False] for _ in range(cols)] for _ in range(rows)] visited[start[0]][start[1]][0] = True while queue: (r, c), dist, flip = queue.popleft() if (r, c) == (rows - 1, cols - 1): return dist + 1 for dr, dc in ((1, 0), (0, 1), (-1, 0), (0, -1)): nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols: if grid[nr][nc] == 1 and not visited[nr][nc][flip]: visited[nr][nc][flip] = True queue.append(((nr, nc), dist + 1, flip)) elif grid[nr][nc] == 0 and flip == 0 and not visited[nr][nc][1]: visited[nr][nc][1] = True queue.append(((nr, nc), dist + 1, 1)) return -1 return bfs((0, 0))"},{"question":"def length_of_longest_substring_two_distinct(s: str) -> int: Returns the length of the longest substring that contains at most two distinct characters. >>> length_of_longest_substring_two_distinct(\\"eceba\\") 3 >>> length_of_longest_substring_two_distinct(\\"ccaabbb\\") 5 >>> length_of_longest_substring_two_distinct(\\"a\\") 1 >>> length_of_longest_substring_two_distinct(\\"ab\\") 2 >>> length_of_longest_substring_two_distinct(\\"abcabcabc\\") 2 >>> length_of_longest_substring_two_distinct(\\"aaaa\\") 4 >>> length_of_longest_substring_two_distinct(\\"abaccc\\") 4","solution":"def length_of_longest_substring_two_distinct(s: str) -> int: Returns the length of the longest substring that contains at most two distinct characters. if len(s) < 3: return len(s) # Sliding window left and right pointers left, right = 0, 0 # Hashmap to store the count of characters in the current window window_counts = {} max_len = 2 while right < len(s): # Add the character at the right pointer to the window window_counts[s[right]] = window_counts.get(s[right], 0) + 1 right += 1 # If we have more than 2 distinct characters in the window, shrink the window from the left while len(window_counts) > 2: window_counts[s[left]] -= 1 if window_counts[s[left]] == 0: del window_counts[s[left]] left += 1 # Update the maximum length found max_len = max(max_len, right - left) return max_len"},{"question":"def longest_common_subsequence(arr1: List[int], arr2: List[int]) -> List[int]: Return the longest common subsequence (LCS) of two arrays of integers. Args: arr1 (List[int]): First list of integers, sorted in ascending order and containing unique elements. arr2 (List[int]): Second list of integers, sorted in ascending order and containing unique elements. Returns: List[int]: The longest common subsequence of arr1 and arr2. If there are multiple LCS of the same length, return any of them. Examples: >>> longest_common_subsequence([1, 3, 4, 1], [3, 4, 1]) == [3, 4, 1] >>> longest_common_subsequence([1, 2, 3], [4, 5, 6]) == [] from solution import longest_common_subsequence def test_lcs_common_elements(): assert longest_common_subsequence([1, 3, 4, 1], [3, 4, 1]) == [3, 4, 1] def test_lcs_no_common_elements(): assert longest_common_subsequence([1, 2, 3], [4, 5, 6]) == [] def test_lcs_partial_common_elements(): assert longest_common_subsequence([1, 2, 3, 4, 5], [3, 4, 1, 2, 5]) == [3, 4, 5] def test_lcs_identical_arrays(): assert longest_common_subsequence([1, 2, 3], [1, 2, 3]) == [1, 2, 3] def test_lcs_one_empty_array(): assert longest_common_subsequence([], [1, 2, 3]) == [] assert longest_common_subsequence([1, 2, 3], []) == [] def test_lcs_arrays_with_one_element(): assert longest_common_subsequence([1], [1]) == [1] assert longest_common_subsequence([1], [2]) == [] def test_lcs_arrays_with_partial_match(): assert longest_common_subsequence([2, 3, 4, 1], [3, 4, 2, 1]) == [3, 4, 1] def test_lcs_multiple_possible_lcs(): result = longest_common_subsequence([1, 2, 3, 4], [2, 4, 1, 3]) assert result in [[2, 3], [1, 3], [2, 4]]","solution":"def longest_common_subsequence(arr1, arr2): Returns the longest common subsequence of the two arrays. m, n = len(arr1), len(arr2) # Create a DP table to store lengths of longest common subsequence. dp = [[0] * (n + 1) for _ in range(m + 1)] # Build the dp table in bottom-up manner for i in range(1, m + 1): for j in range(1, n + 1): if arr1[i - 1] == arr2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # Reconstruct the longest common subsequence from the dp table. i, j = m, n lcs = [] while i > 0 and j > 0: if arr1[i - 1] == arr2[j - 1]: lcs.append(arr1[i - 1]) i -= 1 j -= 1 elif dp[i - 1][j] > dp[i][j - 1]: i -= 1 else: j -= 1 # The lcs array is constructed in reverse order. lcs.reverse() return lcs"},{"question":"def max_score_common_substring(s1: str, s2: str) -> int: Return the maximum score of any substring that appears in both s1 and s2. The score of a substring is defined as the sum of the positions of its characters in the English alphabet ('a' is 1, 'b' is 2, ..., 'z' is 26). >>> max_score_common_substring(\\"abc\\", \\"cde\\") 3 >>> max_score_common_substring(\\"abcd\\", \\"defg\\") 4 >>> max_score_common_substring(\\"abacaba\\", \\"bacabac\\") 10 >>> max_score_common_substring(\\"abcd\\", \\"xyz\\") 0 >>> max_score_common_substring(\\"aaaa\\", \\"aaa\\") 3 >>> max_score_common_substring(\\"\\", \\"\\") 0 >>> max_score_common_substring(\\"a\\", \\"\\") 0 >>> max_score_common_substring(\\"\\", \\"a\\") 0 >>> max_score_common_substring(\\"a\\", \\"a\\") 1 >>> max_score_common_substring(\\"abc\\", \\"abc\\") 6","solution":"def get_char_score(c): return ord(c) - ord('a') + 1 def get_substring_score(s): return sum(get_char_score(c) for c in s) def max_score_common_substring(s1, s2): max_score = 0 s2_substrings = set() for i in range(len(s2)): for j in range(i + 1, len(s2) + 1): s2_substrings.add(s2[i:j]) for i in range(len(s1)): for j in range(i + 1, len(s1) + 1): substring = s1[i:j] if substring in s2_substrings: max_score = max(max_score, get_substring_score(substring)) return max_score"},{"question":"def split_into_k_substrings(s: str, k: int) -> List[str]: Split the string \`s\` into \`k\` contiguous substrings such that the length of the shortest substring is maximized. The substrings should not overlap, and their concatenation should result in the original string \`s\`. >>> split_into_k_substrings('abcdefgh', 4) ['ab', 'cd', 'ef', 'gh'] >>> split_into_k_substrings('abcdefghi', 3) ['abc', 'def', 'ghi'] >>> split_into_k_substrings('a', 1) ['a'] >>> split_into_k_substrings('abcd', 4) ['a', 'b', 'c', 'd'] >>> split_into_k_substrings('abcdefghij', 2) ['abcde', 'fghij'] from typing import List # Unit tests def test_split_even_length(): s = \\"abcdefgh\\" k = 4 result = split_into_k_substrings(s, k) expected_lengths = [2, 2, 2, 2] assert all(len(sub) == expected_lengths[i] for i, sub in enumerate(result)) assert ''.join(result) == s def test_split_with_remainder(): s = \\"abcdefghi\\" k = 3 result = split_into_k_substrings(s, k) expected_lengths = [3, 3, 3] assert all(len(sub) == 3 for sub in result) assert ''.join(result) == s def test_split_one_character(): s = \\"a\\" k = 1 result = split_into_k_substrings(s, k) expected_lengths = [1] assert all(len(sub) == expected_lengths[i] for i, sub in enumerate(result)) assert ''.join(result) == s def test_split_large_k(): s = \\"abcd\\" k = 4 result = split_into_k_substrings(s, k) expected_lengths = [1, 1, 1, 1] assert all(len(sub) == expected_lengths[i] for i, sub in enumerate(result)) assert ''.join(result) == s def test_split_no_remainder_even_distribution(): s = \\"abcdefghij\\" k = 2 result = split_into_k_substrings(s, k) expected_lengths = [5, 5] assert all(len(sub) == expected_lengths[i] for i, sub in enumerate(result)) assert ''.join(result) == s","solution":"def split_into_k_substrings(s, k): Split the string 's' into 'k' contiguous substrings such that the length of the shortest substring is maximized. Return an array of 'k' substrings. n = len(s) # total length of the string min_length = n // k # minimum possible length of each substring extra_chars = n % k # extra characters to be distributed result = [] start = 0 for i in range(k): # Calculate the length of the current substring current_length = min_length + (1 if i < extra_chars else 0) result.append(s[start:start + current_length]) start += current_length return result"},{"question":"from typing import List def findMedianSortedArrays(nums1: List[int], nums2: List[int]) -> float: Finds the median of two sorted arrays with time complexity O(log(min(len(nums1), len(nums2)))). >>> findMedianSortedArrays([1, 3], [2]) == 2 >>> findMedianSortedArrays([1, 2], [3, 4]) == 2.5 >>> findMedianSortedArrays([1, 3], [2, 4, 5]) == 3 >>> findMedianSortedArrays([1, 3], []) == 2 >>> findMedianSortedArrays([1, 1, 1], [1, 1, 1]) == 1 >>> findMedianSortedArrays([2, 2, 2], [2, 2]) == 2 >>> findMedianSortedArrays([], [1]) == 1 >>> findMedianSortedArrays([], [2, 3]) == 2.5 >>> findMedianSortedArrays([1, 2, 3, 4], [5, 6, 7, 8, 9]) == 5 >>> findMedianSortedArrays([1, 3, 8], [2, 4, 6, 7, 9]) == 5","solution":"def findMedianSortedArrays(nums1, nums2): Finds the median of two sorted arrays with time complexity O(log(min(len(nums1), len(nums2)))). def get_kth_element(arr1, arr2, k): Helper function to get the k-th element in the merged and sorted array of arr1 and arr2. len1, len2 = len(arr1), len(arr2) index1, index2 = 0, 0 while True: if index1 == len1: return arr2[index2 + k - 1] if index2 == len2: return arr1[index1 + k - 1] if k == 1: return min(arr1[index1], arr2[index2]) new_index1 = min(index1 + k // 2 - 1, len1 - 1) new_index2 = min(index2 + k // 2 - 1, len2 - 1) pivot1, pivot2 = arr1[new_index1], arr2[new_index2] if pivot1 <= pivot2: k -= (new_index1 - index1 + 1) index1 = new_index1 + 1 else: k -= (new_index2 - index2 + 1) index2 = new_index2 + 1 total_length = len(nums1) + len(nums2) if total_length % 2 == 1: return get_kth_element(nums1, nums2, total_length // 2 + 1) else: return (get_kth_element(nums1, nums2, total_length // 2) + get_kth_element(nums1, nums2, total_length // 2 + 1)) / 2"},{"question":"def three_sum(nums: List[int], target: int) -> bool: Determines if there are three distinct integers in nums whose sum equals target. Args: nums (list): List of integers. target (int): Target sum. Returns: bool: True if such a combination exists, False otherwise. >>> three_sum([1, 2, 3, 4, 5], 12) == True >>> three_sum([1, 2, 3, 4, 5], 6) == True >>> three_sum([-1, 0, 1, 2, -1, -4], 0) == True >>> three_sum([1, 2, 3, 4, 5], 20) == False >>> three_sum([1, 2, 4, 5, 6], 3) == False >>> three_sum([], 0) == False >>> three_sum([1], 1) == False >>> three_sum([1, 2], 3) == False >>> three_sum([-2, -1, 1, 2, 4], 1) == True >>> three_sum([-4, -2, -3, -1], -6) == True >>> three_sum([-2, -1, 1, 2, 4], 10) == False >>> three_sum([1, 1, 1, 1, 1], 3) == True >>> three_sum([1, 1, 1, 1, 1], 2) == False","solution":"def three_sum(nums, target): Determines if there are three distinct integers in nums whose sum equals target. Args: nums (list): List of integers. target (int): Target sum. Returns: bool: True if such a combination exists, False otherwise. nums.sort() # Sort the array first n = len(nums) for i in range(n - 2): if i > 0 and nums[i] == nums[i - 1]: continue # Avoid duplicates for the first element left, right = i + 1, n - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"def count_rectangles(points1, points2): Returns the count of rectangles formed using given pairs of points as diagonally opposite corners. >>> count_rectangles([(1, 2)], [(2, 2), (1, 1)]) == 0 >>> count_rectangles([(1, 2), (2, 1)], [(2, 2), (1, 1)]) == 1 >>> count_rectangles([(1, 2), (2, 1)], [(2, 2), (1, 1), (3, 3)]) == 1 >>> count_rectangles([(1, 2), (2, 1), (3, 1)], [(2, 2), (1, 1), (3, 2), (3, 1)]) == 2","solution":"def count_rectangles(points1, points2): Returns the count of rectangles formed using given pairs of points as diagonally opposite corners. point_set = set(points2) count = 0 for i in range(len(points1)): for j in range(i + 1, len(points1)): if (points1[i][0], points1[j][1]) in point_set and (points1[j][0], points1[i][1]) in point_set: count += 1 return count"},{"question":"def max_sum_subarray_index(arr: List[int], k: int) -> int: Returns the starting index of the subarray of length k with the maximum sum in arr. >>> max_sum_subarray_index([1, 2, 3, 4, 5], 2) 3 >>> max_sum_subarray_index([1, 2, 3, 4, 5], 3) 2 >>> max_sum_subarray_index([5], 1) 0 >>> max_sum_subarray_index([2, 1, 5, 1, 3, 2], 3) 2 >>> max_sum_subarray_index([2, 1, 5, 1, 3, 2], 6) 0 >>> max_sum_subarray_index([2, 1, 5, 1, 3, 2], 7) -1 >>> max_sum_subarray_index([0, 0, 0, 0, 0], 3) 0","solution":"def max_sum_subarray_index(arr, k): Returns the starting index of the subarray of length k with the maximum sum in arr. # Check for edge case where k is greater than the length of the array if k > len(arr): return -1 max_sum = -float('inf') current_sum = 0 max_start_index = 0 for i in range(len(arr)): current_sum += arr[i] if i >= k: current_sum -= arr[i - k] if i >= k - 1 and current_sum > max_sum: max_sum = current_sum max_start_index = i - k + 1 return max_start_index"},{"question":"from typing import List def splitArray(nums: List[int], m: int) -> int: Partition the array into \`m\` continuous subarrays such that the maximum sum among these subarrays is minimized. Return the minimized maximum sum that can be achieved. >>> splitArray([7, 2, 5, 10, 8], 2) 15 >>> splitArray([1, 2, 3, 4, 5], 2) 9 >>> splitArray([1, 4, 4], 3) 4","solution":"def splitArray(nums, m): def can_split(nums, m, max_sum): sub_array_sum = 0 sub_array_count = 1 for num in nums: if sub_array_sum + num > max_sum: sub_array_count += 1 sub_array_sum = num if sub_array_count > m: return False else: sub_array_sum += num return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if can_split(nums, m, mid): right = mid else: left = mid + 1 return left"},{"question":"from typing import List def can_reach_with_max_height(matrix: List[List[int]], T: int) -> bool: Determine if there is a path from the top-left corner of the matrix to the bottom-right corner such that the maximum height encountered along this path is at most \`T\`. Args: matrix (List[List[int]]): 2D integer array representing heights of the terrain. T (int): Maximum height allowed for the path. Returns: bool: True if such a path exists, False otherwise. Examples: >>> can_reach_with_max_height([ [1, 2, 2], [3, 8, 2], [5, 3, 2] ], 3) True >>> can_reach_with_max_height([ [1, 2, 2], [3, 4, 2], [5, 3, 8] ], 3) False >>> can_reach_with_max_height([ [1, 1, 1], [1, 1, 1], [1, 1, 1] ], 1) True >>> can_reach_with_max_height([ [2] ], 3) True >>> can_reach_with_max_height([ [1, 1, 1], [1, 1, 1], [1, 1, 1] ], 1) True >>> can_reach_with_max_height([ [10, 20, 30], [30, 10, 20], [10, 30, 10] ], 100) True","solution":"def can_reach_with_max_height(matrix, T): Returns True if there is a path from the top-left to the bottom-right corner of the matrix such that the maximum height encountered along this path is at most T, otherwise False. rows, cols = len(matrix), len(matrix[0]) visited = [[False] * cols for _ in range(rows)] def dfs(x, y, max_height): if x < 0 or x >= rows or y < 0 or y >= cols or visited[x][y] or matrix[x][y] > max_height: return False if x == rows - 1 and y == cols - 1: return True visited[x][y] = True # Check all 4 directions if (dfs(x + 1, y, max_height) or dfs(x - 1, y, max_height) or dfs(x, y + 1, max_height) or dfs(x, y - 1, max_height)): return True visited[x][y] = False return False return dfs(0, 0, T)"},{"question":"def find_ball_position(grid, drop): Determine the position of each ball after it has fallen through the box. Parameters: grid (List[List[int]]): 2D list representing the box where 1 represents a wall and 0 an empty cell. drop (List[int]): List of column indices where each ball is dropped. Returns: List[int]: List of column indices where each ball comes out of the box or -1 if it gets stuck. Examples: >>> grid = [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ] >>> drop = [0, 1, 2] >>> find_ball_position(grid, drop) [0, 1, 2] >>> grid = [ ... [1, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ] >>> drop = [0, 1, 2] >>> find_ball_position(grid, drop) [-1, 1, 2] >>> grid = [ ... [0, 0, 0], ... [0, 0, 0], ... [1, 0, 0] ... ] >>> drop = [0, 1, 2] >>> find_ball_position(grid, drop) [-1, 1, 2] >>> grid = [ ... [0, 0, 0], ... [0, 1, 0], ... [1, 0, 0] ... ] >>> drop = [0, 1, 2] >>> find_ball_position(grid, drop) [-1, -1, 2] >>> grid = [ ... [0, 0, 0, 1, 0], ... [0, 1, 0, 0, 0], ... [1, 0, 0, 0, 0], ... [0, 0, 0, 0, 0] ... ] >>> drop = [0, 1, 2, 3, 4] >>> find_ball_position(grid, drop) [-1, -1, 2, -1, 4]","solution":"def find_ball_position(grid, drop): This function returns the position of each ball after it has fallen through the box. m, n = len(grid), len(grid[0]) positions = [] def fall_through_box(column): for row in range(m): if grid[row][column] == 1: return -1 elif grid[row][column] == 0: pass return column for column in drop: positions.append(fall_through_box(column)) return positions"},{"question":"def min_remove_to_make_valid(s: str) -> int: Returns the minimum number of bracket pairs you need to remove to make the string valid. >>> min_remove_to_make_valid(\\"()[]{}\\") 0 >>> min_remove_to_make_valid(\\"(]\\") 2 >>> min_remove_to_make_valid(\\"([)]\\") 2 >>> min_remove_to_make_valid(\\"{[()]}\\") 0 >>> min_remove_to_make_valid(\\"{]\\") 2 >>> min_remove_to_make_valid(\\"\\") 0 >>> min_remove_to_make_valid(\\"(((((\\") 5 >>> min_remove_to_make_valid(\\")))))\\") 5 >>> min_remove_to_make_valid(\\"()[]{}}\\") 1","solution":"def min_remove_to_make_valid(s): Returns the minimum number of bracket pairs you need to remove to make the string valid. stack = [] invalid_indices = set() for i, char in enumerate(s): if char in \\"({[\\": stack.append(i) elif char in \\")}]\\": if stack and ( (char == \\")\\" and s[stack[-1]] == \\"(\\") or (char == \\"}\\" and s[stack[-1]] == \\"{\\") or (char == \\"]\\" and s[stack[-1]] == \\"[\\") ): stack.pop() else: invalid_indices.add(i) invalid_indices = invalid_indices.union(set(stack)) return len(invalid_indices)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def deepest_leaves_sum(root: TreeNode) -> int: Returns the sum of values of the deepest leaves in the binary tree. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.right = TreeNode(6) >>> root.left.left.left = TreeNode(7) >>> root.right.right.right = TreeNode(8) >>> deepest_leaves_sum(root) 15 >>> deepest_leaves_sum(None) 0 >>> root = TreeNode(1) >>> root.left = TreeNode(2, TreeNode(4, TreeNode(7)), TreeNode(5)) >>> root.right = TreeNode(3, None, TreeNode(6, None, TreeNode(8))) >>> deepest_leaves_sum(root) 15","solution":"# Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def deepest_leaves_sum(root): Returns the sum of values of the deepest leaves in the binary tree. if not root: return 0 from collections import deque queue = deque([root]) while queue: level_sum = 0 for _ in range(len(queue)): node = queue.popleft() level_sum += node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) return level_sum"},{"question":"from typing import List class Solution: def __init__(self, nums: List[int], k: int): Initializes the Solution object with the integer array nums and the integer k. self.nums = nums self.k = k def topKFrequent(self) -> List[int]: Returns an array of the top k frequently occurring elements in nums. >>> solution = Solution([1, 1, 1, 2, 2, 3], 2) >>> solution.topKFrequent() == [1, 2] True >>> solution = Solution([1], 1) >>> solution.topKFrequent() == [1] True >>> solution = Solution([1, 1, 1, 1, 1], 1) >>> solution.topKFrequent() == [1] True >>> solution = Solution([0, 0, 0, -1, -1, -2], 2) >>> solution.topKFrequent() == [0, -1] True >>> solution = Solution([1, 2, 3, 4, 5, 6, 7, 8, 9], 9) >>> set(solution.topKFrequent()) == {1, 2, 3, 4, 5, 6, 7, 8, 9} True >>> solution = Solution([4, 4, 6, 7, 7, 7, 2, 2, 5, 5, 5, 5, 3, 3, 3], 3) >>> solution.topKFrequent() == [5, 7, 3] True","solution":"from collections import Counter import heapq class Solution: def __init__(self, nums, k): self.nums = nums self.k = k def topKFrequent(self): # Count the frequency of each element count = Counter(self.nums) # Use a heap to find the top k elements return heapq.nlargest(self.k, count.keys(), key=count.get)"},{"question":"def process_tree(n: int, edges: List[List[int]], values: List[int], queries: List[int]) -> int: Process the tree based on the given edges, values, and queries. Doubles the value of the nodes specified in the queries and returns the sum of all node values after processing. :param n: int, number of nodes in the tree :param edges: List[List[int]], the edges between nodes :param values: List[int], the initial values of the nodes :param queries: List[int], the list of queries specifying which nodes to double the value :return: int, the sum of all node values after processing the queries pass","solution":"def process_tree(n, edges, values, queries): Process the tree based on the given edges, values, and queries. Doubles the value of the nodes specified in the queries and returns the sum of all node values after processing. :param n: int, number of nodes in the tree :param edges: List[List[int]], the edges between nodes :param values: List[int], the initial values of the nodes :param queries: List[int], the list of queries specifying which nodes to double the value :return: int, the sum of all node values after processing the queries # Initialize an adjacency list for the tree (though it's not actually used, process is simple here) tree = {i: [] for i in range(1, n + 1)} for u, v in edges: tree[u].append(v) tree[v].append(u) # Process all queries for query in queries: node_index = query - 1 # convert node label to zero-based index values[node_index] *= 2 # Return the sum of all node values return sum(values)"},{"question":"def min_operations(nums, threshold): Returns the minimum number of operations required such that the sum of the array after each operation does not exceed threshold. pass def test_min_operations_example_case(): assert min_operations([4, 3, 2], 5) == 4 def test_min_operations_already_below_threshold(): assert min_operations([1, 2, 3], 10) == 0 def test_min_operations_single_element(): assert min_operations([10], 5) == 5 def test_min_operations_all_equal_elements(): assert min_operations([4, 4, 4], 5) == 7 def test_min_operations_multiple_operations(): assert min_operations([5, 6, 7], 10) == 8","solution":"def min_operations(nums, threshold): Returns the minimum number of operations required such that the sum of the array after each operation does not exceed threshold. total_sum = sum(nums) operations = 0 # We continue to decrease elements until the total_sum is not greater than threshold while total_sum > threshold: max_val = max(nums) max_index = nums.index(max_val) # Decrease the maximum element by 1 nums[max_index] -= 1 total_sum -= 1 operations += 1 return operations"},{"question":"def decompress_string(s: str) -> str: Decompresses the given compressed string and returns the expanded form. >>> decompress_string(\\"a2b1c5a3\\") == \\"aabcccccaaa\\" >>> decompress_string(\\"h1e1l3o2\\") == \\"hellloo\\" >>> decompress_string(\\"b3a4c1\\") == \\"bbbaaaac\\" >>> decompress_string(\\"x1y1z10\\") == \\"xyzzzzzzzzzz\\" >>> decompress_string(\\"a10b2\\") == \\"aaaaaaaaaabb\\" >>> decompress_string(\\"a1\\") == \\"a\\" >>> decompress_string(\\"z9\\") == \\"zzzzzzzzz\\" >>> decompress_string(\\"c5\\") == \\"ccccc\\" >>> decompress_string(\\"a100\\") == \\"a\\" * 100 >>> decompress_string(\\"b55\\") == \\"b\\" * 55 >>> decompress_string(\\"A1b2C3\\") == \\"AbbCCC\\" >>> decompress_string(\\"a2B3c1D4\\") == \\"aaBBBcDDDD\\"","solution":"def decompress_string(s): Decompresses the given compressed string and returns the expanded form. :param s: Compressed string where each character is followed by an integer indicating the number of times it appears consecutively :type s: str :return: Expanded string :rtype: str expanded_string = [] i = 0 while i < len(s): char = s[i] count = 0 # Move to the number following the character i += 1 while i < len(s) and s[i].isdigit(): count = count * 10 + int(s[i]) i += 1 expanded_string.append(char * count) return ''.join(expanded_string)"},{"question":"from typing import List def count_components_after_removal(n: int, edges: List[List[int]]) -> int: Returns the number of connected components in the graph after removing a specified edge from each node to its neighboring nodes. Parameters: n (int): number of nodes in the graph edges (List[List[int]]): list of edges between nodes Returns: int: number of connected components >>> count_components_after_removal(1, []) 1 >>> count_components_after_removal(3, []) 3 >>> count_components_after_removal(2, [[0, 1]]) 1 >>> count_components_after_removal(3, [[0, 1], [1, 2], [2, 0]]) 1 >>> count_components_after_removal(4, [[0, 1], [2, 3]]) 2 >>> count_components_after_removal(6, [[0, 1], [1, 2], [3, 4], [4, 5]]) 2 >>> count_components_after_removal(3, [[0, 1], [1, 2], [2, 0]]) 1 >>> count_components_after_removal(5, [[0, 1], [0, 2], [3, 4]]) 2 >>> count_components_after_removal(2, [[0, 0], [1, 1]]) 2 >>> count_components_after_removal(5, [[0, 1], [2, 3]]) 3","solution":"def count_components_after_removal(n, edges): Returns the number of connected components in the graph after removing a specified edge from each node to its neighboring nodes. Parameters: n (int): number of nodes in the graph edges (List[List[int]]): list of edges between nodes Returns: int: number of connected components # Creating the adjacency list graph = {i: [] for i in range(n)} for edge in edges: u, v = edge graph[u].append(v) graph[v].append(u) visited = [False] * n components = 0 def dfs(node): stack = [node] while stack: current = stack.pop() for neighbor in graph[current]: if not visited[neighbor]: visited[neighbor] = True stack.append(neighbor) for node in range(n): if not visited[node]: visited[node] = True components += 1 dfs(node) return components"},{"question":"def longest_unique_subarray(nums): Returns the length of the longest continuous subarray that contains only unique elements. >>> longest_unique_subarray([1, 2, 3, 1, 2, 3]) == 3 >>> longest_unique_subarray([1, 2, 3, 4, 5]) == 5 >>> longest_unique_subarray([1, 2, 2, 3, 4, 5]) == 4 >>> longest_unique_subarray([5, 5, 5, 5, 5]) == 1 >>> longest_unique_subarray([]) == 0 >>> longest_unique_subarray([1]) == 1 >>> longest_unique_subarray([0]) == 1 >>> longest_unique_subarray([1, 2, 3, 4, 5, 6]) == 6 >>> longest_unique_subarray([4, 4, 4, 4, 4, 5, 5, 5, 6, 6]) == 2 >>> longest_unique_subarray([1, 2, 1, 3, 4, 3, 2, 1, 2, 3, 4, 5]) == 5 >>> longest_unique_subarray([2, 2, 3, 4, 5, 6, 7]) == 6 >>> longest_unique_subarray([1, 2, 3, 4, 5, 5, 5, 5]) == 5","solution":"def longest_unique_subarray(nums): Returns the length of the longest continuous subarray that contains only unique elements. n = len(nums) if n == 0: return 0 seen = {} start = 0 max_length = 0 for end in range(n): if nums[end] in seen: start = max(start, seen[nums[end]] + 1) seen[nums[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"def findSubstring(s: str, words: List[str]) -> List[int]: Returns the starting indices of substring(s) in \`s\` that are the concatenation of each word in \`words\` exactly once without intervening characters. :param s: String in which to search :param words: List of words to be concatenated :return: List of starting indices of the concatenation substring(s) >>> findSubstring(\\"barfoothefoobarman\\", [\\"foo\\",\\"bar\\"]) [0, 9] >>> findSubstring(\\"wordgoodgoodgoodbestword\\", [\\"word\\",\\"good\\",\\"best\\",\\"word\\"]) [] >>> findSubstring(\\"barfoofoobarthefoobarman\\", [\\"bar\\",\\"foo\\",\\"the\\"]) [6, 9, 12] >>> findSubstring(\\"a\\", [\\"a\\"]) [0] >>> findSubstring(\\"\\", [\\"a\\"]) [] >>> findSubstring(\\"a\\", [\\"\\"]) [] >>> findSubstring(\\"\\", [\\"\\"]) [] >>> findSubstring(\\"wordgoodgoodgoodbestword\\", [\\"word\\",\\"good\\",\\"best\\",\\"good\\"]) [8] >>> findSubstring(\\"lingmindraboofooowingdingbarrwingmonkeypoundcake\\", [\\"fooo\\",\\"barr\\",\\"wing\\",\\"ding\\",\\"wing\\"]) [13] >>> findSubstring(\\"aaaaaaaa\\", [\\"aa\\",\\"aa\\",\\"aa\\"]) [0, 1, 2]","solution":"def findSubstring(s, words): Returns the starting indices of substring(s) in \`s\` that are the concatenation of each word in \`words\` exactly once without intervening characters. :param s: String in which to search :param words: List of words to be concatenated :return: List of starting indices of the concatenation substring(s) from collections import Counter if not s or not words or not words[0]: return [] word_len = len(words[0]) num_words = len(words) total_len = word_len * num_words words_count = Counter(words) result = [] for i in range(len(s) - total_len + 1): seen = Counter() for j in range(num_words): word_index = i + j * word_len word = s[word_index:word_index + word_len] if word in words_count: seen[word] += 1 if seen[word] > words_count[word]: break else: break else: result.append(i) return result"},{"question":"def calculate_net_balances(transactions): Calculate the net balances of individuals involved in the transactions. Parameters: transactions (list of tuples): A list of transactions where each transaction is represented as a tuple (sender, receiver, amount). Returns: dict: A dictionary where keys are individuals and values are their respective net balances. >>> calculate_net_balances([('Alice', 'Bob', 50), ('Bob', 'Charlie', 20), ('Charlie', 'Dave', 30)]) {'Alice': -50, 'Bob': 30, 'Charlie': -10, 'Dave': 30} >>> calculate_net_balances([('Alice', 'Bob', 50), ('Alice', 'Charlie', 60), ('Bob', 'Charlie', 30), ('Charlie', 'Alice', 40)]) {'Alice': -70, 'Bob': 20, 'Charlie': 50} >>> calculate_net_balances([('Alice', 'Bob', 50), ('Bob', 'Alice', 50), ('Charlie', 'Dave', 20), ('Dave', 'Charlie', 20)]) {} >>> calculate_net_balances([]) {} >>> calculate_net_balances([('Alice', 'Bob', 100)]) {'Alice': -100, 'Bob': 100}","solution":"def calculate_net_balances(transactions): Calculate the net balances of individuals involved in the transactions. Parameters: transactions (list of tuples): A list of transactions where each transaction is represented as a tuple (sender, receiver, amount). Returns: dict: A dictionary where keys are individuals and values are their respective net balances. balance_dict = {} for sender, receiver, amount in transactions: # Update the sender's balance if sender in balance_dict: balance_dict[sender] -= amount else: balance_dict[sender] = -amount # Update the receiver's balance if receiver in balance_dict: balance_dict[receiver] += amount else: balance_dict[receiver] = amount # Remove individuals with a net balance of zero net_balances = {person: balance for person, balance in balance_dict.items() if balance != 0} return net_balances"},{"question":"from typing import List def minimize_max_task_duration(tasks: List[int]) -> int: You are given a list of \`n\` different tasks, where each task has a specific duration in minutes. Tasks are represented as an array of integers \`tasks\`, where \`tasks[i]\` is the duration of the \`i\`th task. You have \`two\` workers who can work simultaneously on tasks. Your objective is to assign the tasks to the two workers in such a way that the **maximum** duration of tasks assigned to either worker is minimized. Return the **minimum possible** maximum duration of tasks assigned to either worker. >>> minimize_max_task_duration([5, 8, 1, 4]) 9 >>> minimize_max_task_duration([10]) 10 >>> minimize_max_task_duration([3, 3, 3, 3]) 6 >>> minimize_max_task_duration([15, 2, 2, 2, 2]) 15 >>> minimize_max_task_duration([7, 7, 7, 7]) 14 >>> minimize_max_task_duration([10, 5, 5]) 10 >>> minimize_max_task_duration([4, 5, 6, 7, 8]) 15 # Implementation here","solution":"def can_assign_tasks(tasks, max_time): # Start with two workers worker1_time, worker2_time = 0, 0 for task in sorted(tasks, reverse=True): if worker1_time + task <= max_time: worker1_time += task elif worker2_time + task <= max_time: worker2_time += task else: return False return True def minimize_max_task_duration(tasks): left, right = max(tasks), sum(tasks) while left < right: mid = (left + right) // 2 if can_assign_tasks(tasks, mid): right = mid else: left = mid + 1 return left"},{"question":"def remove_characters(s: str, count: int) -> str: Returns the smallest lexicographically string by removing exactly 'count' characters from 's'. >>> remove_characters(\\"bcabc\\", 1) \\"babc\\" >>> remove_characters(\\"bcabc\\", 2) \\"abc\\" >>> remove_characters(\\"abcde\\", 2) \\"abc\\" >>> remove_characters(\\"abc\\", 0) \\"abc\\" >>> remove_characters(\\"abc\\", 3) \\"\\" >>> remove_characters(\\"\\", 0) \\"\\" >>> remove_characters(\\"aaaaa\\", 2) \\"aaa\\" >>> s = \\"b\\" * 1000 + \\"a\\" * 1000 >>> remove_characters(s, 1000) == \\"a\\" * 1000","solution":"def remove_characters(s, count): Returns the smallest lexicographically string by removing exactly 'count' characters from 's'. stack = [] to_remove = count for char in s: while stack and to_remove > 0 and stack[-1] > char: stack.pop() to_remove -= 1 stack.append(char) # If there are still characters to remove, remove from the end result = stack[:-to_remove] if to_remove else stack return ''.join(result)"},{"question":"def min_changes_to_follow_guideline(s: str) -> int: Returns the minimum number of changes required to follow the health guidelines in a binary string where '0' indicates a masked person and '1' indicates an unmasked person. >>> min_changes_to_follow_guideline(\\"00000\\") 0 >>> min_changes_to_follow_guideline(\\"010101\\") 0 >>> min_changes_to_follow_guideline(\\"11111\\") 2 >>> min_changes_to_follow_guideline(\\"1001001\\") 0 >>> min_changes_to_follow_guideline(\\"1010111\\") 1 >>> min_changes_to_follow_guideline(\\"10111001\\") 1 >>> min_changes_to_follow_guideline(\\"\\") 0","solution":"def min_changes_to_follow_guideline(s): Returns the minimum number of changes required to follow the health guidelines. n = len(s) prev_char = None changes = 0 for char in s: # If previous character and current one are both '1', a change is needed if prev_char == '1' and char == '1': changes += 1 prev_char = '0' # Change current '1' to '0' to follow the guideline else: prev_char = char return changes"},{"question":"def can_form_palindrome_with_modifications(s: str, k: int) -> bool: Modify the string s by replacing at most k characters with any lowercase English letter to rearrange the string into a palindrome. >>> can_form_palindrome_with_modifications(\\"aabbcc\\", 0) True >>> can_form_palindrome_with_modifications(\\"abc\\", 1) True","solution":"def can_form_palindrome_with_modifications(s, k): from collections import Counter # Count frequency of each character in the string freq = Counter(s) # Count the number of characters with odd frequencies odd_count = sum(1 for count in freq.values() if count % 2 != 0) # In a palindrome, at most one character with an odd frequency is allowed # We need to convert (odd_count - 1) odd frequencies to even, needing (odd_count - 1) modifications # Thus, check if the necessary modifications do not exceed k return (odd_count - 1) // 2 <= k"},{"question":"def maxProfitWithTwoTransactions(arr): Given an integer array representing the stock prices of a company on different days, return the maximum profit achieved with at most two transactions. >>> maxProfitWithTwoTransactions([]) == 0 >>> maxProfitWithTwoTransactions([1]) == 0 >>> maxProfitWithTwoTransactions([1, 2]) == 1 >>> maxProfitWithTwoTransactions([2, 1]) == 0 >>> maxProfitWithTwoTransactions([3, 3, 5, 0, 0, 3, 1, 4]) == 6 >>> maxProfitWithTwoTransactions([1, 2, 3, 4, 5]) == 4 >>> maxProfitWithTwoTransactions([7, 6, 4, 3, 1]) == 0 >>> maxProfitWithTwoTransactions([1, 2, 3, 4, 5, 6, 7, 0, 2, 3, 10, 1, 3, 8]) == 17","solution":"def maxProfitWithTwoTransactions(arr): Given an integer array representing the stock prices of a company on different days, return the maximum profit achieved with at most two transactions. if not arr or len(arr) < 2: return 0 n = len(arr) # dp[i] will store the maximum profit as 'i' transactions. profits = [[0] * n for _ in range(3)] # Up to 2 transactions for k in range(1, 3): max_diff = -arr[0] for i in range(1, n): profits[k][i] = max(profits[k][i - 1], arr[i] + max_diff) max_diff = max(max_diff, profits[k - 1][i] - arr[i]) return profits[2][n - 1]"},{"question":"class SubarrayFinder: You are given an array of integers \`arr\` and an integer \`k\`. Find the maximum number of subarrays of \`arr\` of length \`k\` that are distinct. Two subarrays are considered distinct if they contain different sequences of elements. Example: finder = SubarrayFinder([1, 2, 3, 4], 2) finder.countDistinctSubarrays() # returns 3, because the subarrays are: (1, 2), (2, 3), (3, 4) def __init__(self, arr: List[int], k: int): Initialize the SubarrayFinder class with the array \`arr\` and the integer \`k\`. self.arr = arr self.k = k def countDistinctSubarrays(self) -> int: Returns the number of distinct subarrays of length \`k\` from the array \`arr\`. from solution import SubarrayFinder def test_distinct_subarrays_no_duplicates(): finder = SubarrayFinder([1, 2, 3, 4], 2) assert finder.countDistinctSubarrays() == 3 # subarrays: (1, 2), (2, 3), (3, 4) def test_distinct_subarrays_with_duplicates(): finder = SubarrayFinder([1, 2, 2, 3], 2) assert finder.countDistinctSubarrays() == 3 # subarrays: (1, 2), (2, 2), (2, 3) def test_single_length_subarrays(): finder = SubarrayFinder([1, 2, 3, 2], 1) assert finder.countDistinctSubarrays() == 3 # subarrays: (1), (2), (3) def test_entire_array_as_subarray(): finder = SubarrayFinder([1, 2, 3, 2], 4) assert finder.countDistinctSubarrays() == 1 # subarrays: (1, 2, 3, 2) def test_k_greater_than_array_length(): finder = SubarrayFinder([1, 2, 3, 2], 5) assert finder.countDistinctSubarrays() == 0 # subarray length k > array length def test_zero_length_subarray(): finder = SubarrayFinder([1, 2, 3, 2], 0) assert finder.countDistinctSubarrays() == 0 # subarray length k = 0 def test_empty_array(): finder = SubarrayFinder([], 1) assert finder.countDistinctSubarrays() == 0 # array is empty","solution":"class SubarrayFinder: def __init__(self, arr, k): self.arr = arr self.k = k def countDistinctSubarrays(self): if self.k <= 0 or self.k > len(self.arr): return 0 subarrays = set() for i in range(len(self.arr) - self.k + 1): subarray = tuple(self.arr[i:i + self.k]) subarrays.add(subarray) return len(subarrays)"},{"question":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_sums(root): Given the root of a binary tree, return a list of the sums of the values of each level. >>> root = TreeNode(1) >>> level_sums(root) [1] >>> root = TreeNode(1, TreeNode(2), TreeNode(3)) >>> level_sums(root) [1, 5] >>> root = TreeNode(1) >>> root.left = TreeNode(2, TreeNode(4), TreeNode(5)) >>> root.right = TreeNode(3, None, TreeNode(6)) >>> level_sums(root) [1, 5, 15] >>> root = None >>> level_sums(root) [] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(3) >>> root.left.left.left = TreeNode(4) >>> level_sums(root) [1, 2, 3, 4]","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_sums(root): Returns a list of sums of the values for each level of the binary tree. if not root: return [] result = [] queue = deque([root]) while queue: level_sum = 0 level_size = len(queue) for _ in range(level_size): node = queue.popleft() level_sum += node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_sum) return result"},{"question":"from typing import List def min_moves_maze(grid: List[List[int]], startRow: int, startCol: int, endRow: int, endCol: int) -> int: Determine the minimum number of moves required to reach the ending position from the starting position in a 2D maze. Args: grid: List[List[int]] - An n x n grid representing a 2D maze, where 0 represents an empty cell and 1 represents a wall. startRow: int - The starting row position. startCol: int - The starting column position. endRow: int - The ending row position. endCol: int - The ending column position. Returns: int - The minimum number of moves required to reach the ending position from the starting position, or -1 if it is not possible. Examples: >>> min_moves_maze([ ... [0, 0, 0], ... [1, 1, 0], ... [0, 0, 0] ... ], 0, 0, 2, 2) 4 >>> min_moves_maze([ ... [0, 1, 0], ... [1, 1, 1], ... [0, 0, 0] ... ], 0, 0, 2, 2) -1","solution":"from collections import deque def min_moves_maze(grid, startRow, startCol, endRow, endCol): rows, cols = len(grid), len(grid[0]) if grid[startRow][startCol] == 1 or grid[endRow][endCol] == 1: return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(startRow, startCol, 0)]) # (row, col, distance) visited = set((startRow, startCol)) while queue: r, c, dist = queue.popleft() if (r, c) == (endRow, endCol): return dist for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 0 and (nr, nc) not in visited: visited.add((nr, nc)) queue.append((nr, nc, dist + 1)) return -1"},{"question":"def number_of_students_can_see(heights: List[int]) -> List[int]: Returns an array of integers representing the number of students each student can see when looking ahead. :param heights: List[int] heights of students :return: List[int] number of students each student can see >>> number_of_students_can_see([1, 2, 3, 4, 5]) [0, 0, 0, 0, 0] >>> number_of_students_can_see([5, 4, 3, 2, 1]) [4, 3, 2, 1, 0] >>> number_of_students_can_see([2, 2, 2, 2]) [3, 2, 1, 0] >>> number_of_students_can_see([1, 3, 2, 4]) [0, 1, 0, 0] >>> number_of_students_can_see([4, 3, 3, 1]) [3, 2, 1, 0] >>> number_of_students_can_see([5]) [0] >>> number_of_students_can_see([]) []","solution":"def number_of_students_can_see(heights): Returns an array of integers representing the number of students each student can see when looking ahead. :param heights: List[int] heights of students :return: List[int] number of students each student can see n = len(heights) result = [0] * n for i in range(n): count = 0 for j in range(i + 1, n): if heights[j] <= heights[i]: count += 1 else: break result[i] = count return result"},{"question":"def can_jump(nums: List[int]) -> bool: Determines if you can reach the last index starting from the first index. :param nums: List of non-negative integers representing max jump lengths. :return: Boolean value whether you can reach the last index. >>> can_jump([2, 3, 1, 1, 4]) True >>> can_jump([3, 2, 1, 0, 4]) False >>> can_jump([0]) True >>> can_jump([0, 0, 0, 0]) False >>> can_jump([2, 0]) True >>> can_jump([1, 1, 1, 1]) True >>> can_jump([5, 5, 5, 5, 5]) True","solution":"def can_jump(nums): Determines if you can reach the last index starting from the first index. :param nums: List of non-negative integers representing max jump lengths. :return: Boolean value whether you can reach the last index. max_reach = 0 for i, jump in enumerate(nums): if i > max_reach: return False max_reach = max(max_reach, i + jump) return max_reach >= len(nums) - 1"},{"question":"def canCompleteTasks(tasks, deadlines): Determines if all tasks can be completed before their respective deadlines. :param tasks: List[int], an array where each element represents the time required for a task :param deadlines: List[int], an array where each element represents the deadline for a task :return: bool, True if all tasks can be completed before their deadlines, False otherwise pass # Unit tests def test_can_complete_all_tasks(): assert canCompleteTasks([1, 2, 3], [3, 5, 6]) == True def test_cannot_complete_tasks_due_to_tight_deadlines(): assert canCompleteTasks([3, 2, 2], [2, 3, 5]) == False def test_single_task_with_sufficient_deadline(): assert canCompleteTasks([4], [5]) == True def test_single_task_with_insufficient_deadline(): assert canCompleteTasks([5], [4]) == False def test_multiple_tasks_with_tight_schedulable(): assert canCompleteTasks([2, 2, 2], [2, 4, 6]) == True def test_tasks_with_equal_times_and_deadlines(): assert canCompleteTasks([2, 2, 2], [2, 4, 5]) == False def test_no_tasks(): assert canCompleteTasks([], []) == True","solution":"def canCompleteTasks(tasks, deadlines): Determines if all tasks can be completed before their respective deadlines. :param tasks: List[int], an array where each element represents the time required for a task :param deadlines: List[int], an array where each element represents the deadline for a task :return: bool, True if all tasks can be completed before their deadlines, False otherwise # Combine tasks and deadlines into one list of tuples (task_time, deadline) task_deadline_pairs = list(zip(tasks, deadlines)) # Sort the tasks by their deadlines task_deadline_pairs.sort(key=lambda x: x[1]) current_time = 0 for task_time, deadline in task_deadline_pairs: current_time += task_time if current_time > deadline: return False return True"},{"question":"class ListNode: def __init__(self, x): self.val = x self.next = None def hasCycle(head): Detects if a cycle exists in a linked list. :param head: ListNode - The head of the linked list. :return: bool - True if there is a cycle, False otherwise.","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def hasCycle(head): Detects if a cycle exists in a linked list. :param head: ListNode - The head of the linked list. :return: bool - True if there is a cycle, False otherwise. slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False"},{"question":"def smallest_possible_string(s: str) -> str: Returns the lexicographically smallest string possible after performing at most one swap of adjacent digits. >>> smallest_possible_string(\\"12345\\") == \\"12345\\" >>> smallest_possible_string(\\"13245\\") == \\"12345\\" >>> smallest_possible_string(\\"54321\\") == \\"45321\\" >>> smallest_possible_string(\\"32145\\") == \\"23145\\" >>> smallest_possible_string(\\"12435\\") == \\"12345\\" >>> smallest_possible_string(\\"11111\\") == \\"11111\\"","solution":"def smallest_possible_string(s): Returns the lexicographically smallest string possible after performing at most one swap of adjacent digits. n = len(s) for i in range(n - 1): if s[i] > s[i + 1]: # Swap and break s = s[:i] + s[i + 1] + s[i] + s[i + 2:] return s return s"},{"question":"def shift_characters(s, shift): Shifts each character in the string \`s\` forward by the corresponding value in the \`shift\` list. Wraps around after 'z' to 'a'. Parameters: s (str): input string of lowercase English letters. shift (list): list of integers representing shift values. Returns: str: the resulting string after all shifts are applied. Examples: >>> shift_characters(\\"abc\\", [1, 1, 1]) 'bcd' >>> shift_characters(\\"xyz\\", [1, 1, 1]) 'yza'","solution":"def shift_characters(s, shift): Shifts each character in the string \`s\` forward by the corresponding value in the \`shift\` list. Wraps around after 'z' to 'a'. Parameters: s (str): input string of lowercase English letters. shift (list): list of integers representing shift values. Returns: str: the resulting string after all shifts are applied. def shift_char(c, shift_value): # Calculate new character position new_position = (ord(c) - ord('a') + shift_value) % 26 # Return shifted character return chr(ord('a') + new_position) return ''.join(shift_char(c, shift_value) for c, shift_value in zip(s, shift))"},{"question":"def containsAllDigits(num: int) -> bool: Check if the number contains every digit from 1 to 9 at least once. >>> containsAllDigits(123456789) == True >>> containsAllDigits(9876543210) == True # 0 can be present but not required >>> containsAllDigits(13579) == False >>> containsAllDigits(1111222233334444) == False # missing digits 5, 6, 7, 8, 9 >>> containsAllDigits(192837465) == True # contains all digits, 0 not required >>> containsAllDigits(12345678901234567890) == True # large number with all digits >>> containsAllDigits(1023456789) == True # 0 can be present but not required","solution":"def containsAllDigits(num): Check if the number contains every digit from 1 to 9 at least once. Parameters: num (int): Positive integer to check Returns: bool: True if it contains all digits from 1 to 9, False otherwise digit_set = set(str(num)) required_digits = {str(d) for d in range(1, 10)} return required_digits.issubset(digit_set)"},{"question":"def splitArray(nums: List[int], k: int) -> int: Split the array into k non-empty subarrays such that the maximum sum among these subarrays is minimized using binary search and greedy algorithm. >>> splitArray([7, 2, 5, 10, 8], 2) == 18 >>> splitArray([1], 1) == 1 >>> splitArray([5, 5, 5, 5], 2) == 10 >>> splitArray([1, 2, 3, 4, 5], 5) == 5 >>> splitArray([1, 2, 3, 4], 1) == 10 >>> splitArray([2, 3, 5, 7, 11, 13, 17], 3) == 24","solution":"def splitArray(nums, k): def canSplit(mid): current_sum = 0 subarrays_needed = 1 for num in nums: if current_sum + num > mid: subarrays_needed += 1 current_sum = num if subarrays_needed > k: return False else: current_sum += num return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if canSplit(mid): right = mid else: left = mid + 1 return left"},{"question":"def sort_letters(s: str) -> str: Returns a permutation of s where the positions of digits remain unchanged, and only the letters are sorted in ascending order. >>> sort_letters(\\"dcba\\") == \\"abcd\\" >>> sort_letters(\\"12345\\") == \\"12345\\" >>> sort_letters(\\"a1b2c\\") == \\"a1b2c\\" >>> sort_letters(\\"g1h2f3z\\") == \\"f1g2h3z\\" >>> sort_letters(\\"\\") == \\"\\" >>> sort_letters(\\"123abc\\") == \\"123abc\\" >>> sort_letters(\\"789eac\\") == \\"789ace\\" >>> sort_letters(\\"abc123\\") == \\"abc123\\" >>> sort_letters(\\"zxy789\\") == \\"xyz789\\" >>> sort_letters(\\"a1b2c3d4\\") == \\"a1b2c3d4\\" >>> sort_letters(\\"z4y6x8w\\") == \\"w4x6y8z\\"","solution":"def sort_letters(s): Returns a permutation of s where the positions of digits remain unchanged, and only the letters are sorted in ascending order. chars = [c for c in s if c.isalpha()] chars.sort() result = [] letter_idx = 0 for c in s: if c.isalpha(): result.append(chars[letter_idx]) letter_idx += 1 else: result.append(c) return ''.join(result)"},{"question":"def max_buildings(arr: List[int], d: int) -> int: Return the maximum number of buildings you can visit starting from any building in the list. >>> max_buildings([1, 3, 2, 4, 3], 2) 5 >>> max_buildings([1], 0) 1 >>> max_buildings([1, 2, 3, 4, 5], 1) 5 >>> max_buildings([1, 5, 9, 13, 17], 10) 5 >>> max_buildings([1, 100, 200, 300], 50) 1","solution":"def max_buildings(arr, d): def dfs(i, visited): if visited[i]: return 0 visited[i] = True max_visits = 1 for neighbor in range(i + 1, min(i + d + 1, len(arr))): if abs(arr[i] - arr[neighbor]) <= d: max_visits = max(max_visits, 1 + dfs(neighbor, visited)) for neighbor in range(i - 1, max(i - d, -1), -1): if abs(arr[i] - arr[neighbor]) <= d: max_visits = max(max_visits, 1 + dfs(neighbor, visited)) visited[i] = False return max_visits if not arr: return 0 max_buildings_visited = 0 visited = [False] * len(arr) for i in range(len(arr)): max_buildings_visited = max(max_buildings_visited, dfs(i, visited)) return max_buildings_visited"},{"question":"def rotate(arr: List[int], k: int) -> None: Given an integer array \`arr\`, rotate the array to the right by \`k\` steps, where \`k\` is a non-negative integer. Note: You must modify the array in place with O(1) extra space and do not return anything. >>> arr = [1, 2, 3, 4, 5, 6, 7] >>> rotate(arr, 3) >>> arr [5, 6, 7, 1, 2, 3, 4] >>> arr = [1] >>> rotate(arr, 5) >>> arr [1] >>> arr = [1, 2, 3, 4, 5] >>> rotate(arr, 0) >>> arr [1, 2, 3, 4, 5] >>> arr = [1, 2, 3, 4, 5] >>> rotate(arr, 5) >>> arr [1, 2, 3, 4, 5] >>> arr = [1, 2, 3, 4, 5] >>> rotate(arr, 7) >>> arr [4, 5, 1, 2, 3]","solution":"def rotate(arr, k): Rotates the array to the right by k steps. n = len(arr) k = k % n # Handle cases where k is greater than the length of the array arr[:] = arr[-k:] + arr[:-k] # Reassign the rotated parts to the array"},{"question":"from typing import List def smallest_subarray_with_sum(arr: List[int], target: int) -> int: Returns the smallest subarray length whose sum is greater than or equal to the target. If no such subarray exists, returns -1. >>> smallest_subarray_with_sum([2, 1, 5, 2, 3, 2], 7) == 2 >>> smallest_subarray_with_sum([2, 1, 5, 2, 8], 7) == 1 >>> smallest_subarray_with_sum([3, 4, 1, 1, 6], 8) == 3 >>> smallest_subarray_with_sum([1, 1, 1, 1, 1, 1], 7) == -1 >>> smallest_subarray_with_sum([1, 2, 3, 4, 5], 11) == 3 >>> smallest_subarray_with_sum([1, 2, 3], 10) == -1 >>> smallest_subarray_with_sum([1, 1, 1, 1], 5) == -1 >>> smallest_subarray_with_sum([1, 2, 3, 4, 5], 15) == 5 >>> smallest_subarray_with_sum([5, 1, 3, 2, 8], 8) == 1 >>> smallest_subarray_with_sum([], 7) == -1 pass","solution":"def smallest_subarray_with_sum(arr, target): Returns the smallest subarray length whose sum is greater than or equal to target. If no such subarray exists, returns -1. n = len(arr) min_len = float('inf') current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum >= target: min_len = min(min_len, end - start + 1) current_sum -= arr[start] start += 1 if min_len == float('inf'): return -1 else: return min_len"},{"question":"def can_be_sorted(nums: List[int]) -> bool: Determine if it is possible to sort the array \`nums\` in ascending order using a combination of the given operations. You are allowed to: 1. Swap any two elements. 2. Reverse any subarray of the array. Args: nums (List[int]): An array of unique integers. Returns: bool: 'True' if it is possible to sort the array, otherwise 'False'. >>> can_be_sorted([1, 2, 3, 4, 5]) True >>> can_be_sorted([5, 4, 3, 2, 1]) True >>> can_be_sorted([2, 3, 1, 5, 4]) True >>> can_be_sorted([1]) True >>> can_be_sorted([10, 9, 2, 1, 5, 6, 3, 7, 8, 4]) True","solution":"def can_be_sorted(nums): Checks if the array can be sorted using the allowed operations: swap any two elements and reverse any subarray. The function returns True because with the given operations, any array can be sorted. return True"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def invert_tree(root): Inverts a binary tree by swapping the left and right child of every node. :param root: TreeNode, the root of the binary tree :return: TreeNode, the root of the inverted binary tree >>> root = TreeNode(1, TreeNode(2), TreeNode(3)) >>> inverted_root = invert_tree(root) >>> inverted_root.val 1 >>> inverted_root.left.val 3 >>> inverted_root.right.val 2","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def invert_tree(root): Inverts a binary tree by swapping the left and right child of every node. :param root: TreeNode, the root of the binary tree :return: TreeNode, the root of the inverted binary tree if root is None: return None # Swap the left and right children root.left, root.right = root.right, root.left # Recursively invert the left and right subtrees invert_tree(root.left) invert_tree(root.right) return root"},{"question":"def distinct_substrings_count(s: str, queries: List[str]) -> List[int]: Returns the number of distinct substrings that start and end with each queried character. :param s: A string consisting of lowercase English letters. :param queries: A list of query characters. :return: A list of integers where each element corresponds to the number of distinct substrings for the matching query character. >>> distinct_substrings_count(\\"a\\", ['a']) [1] >>> distinct_substrings_count(\\"abcabc\\", ['a', 'b', 'c']) [3, 3, 3] >>> distinct_substrings_count(\\"aaaa\\", ['a']) [10]","solution":"def distinct_substrings_count(s, queries): Returns the number of distinct substrings that start and end with each queried character. :param s: A string consisting of lowercase English letters. :param queries: A list of query characters. :return: A list of integers where each element corresponds to the number of distinct substrings for the matching query character. from collections import defaultdict # Function to count distinct substrings starting and ending with same character char_indices = defaultdict(list) for idx, char in enumerate(s): char_indices[char].append(idx) result = [] for char in queries: indices = char_indices[char] n = len(indices) result.append(n * (n + 1) // 2) # Number of distinct substrings for the character return result"},{"question":"def lexicographically_smallest_string(s: str) -> str: Determine the lexicographically smallest string that can be obtained by moving one character to the end of the string at most once. >>> lexicographically_smallest_string('a') == 'a' >>> lexicographically_smallest_string('abc') == 'abc' >>> lexicographically_smallest_string('cba') == 'bac' >>> lexicographically_smallest_string('bcda') == 'bcad' >>> lexicographically_smallest_string('aaaa') == 'aaaa' >>> lexicographically_smallest_string('abcdefghijklmnopqrstuvwxyz') == 'abcdefghijklmnopqrstuvwxyz' >>> lexicographically_smallest_string('zyxwvutsrqponmlkjihgfedcba') == 'yxwvutsrqponmlkjihgfedcbaz'","solution":"def lexicographically_smallest_string(s): Returns the lexicographically smallest string that can be obtained by moving one character to the end of the string at most once. n = len(s) if n <= 1: return s # Find the lexicographically smallest string by simulating the move operation min_str = s for i in range(n): new_str = s[:i] + s[i+1:] + s[i] if new_str < min_str: min_str = new_str return min_str"},{"question":"def count_ways(n: int) -> int: Returns the number of distinct ways to cover a n x 2 grid using 2x1 and 1x2 tiles. >>> count_ways(0) 1 >>> count_ways(1) 1 >>> count_ways(2) 2 >>> count_ways(3) 3 >>> count_ways(4) 5 >>> count_ways(5) 8 >>> count_ways(10) 89 >>> count_ways(20) 10946","solution":"def count_ways(n): Returns the number of distinct ways to cover a n x 2 grid using 2x1 and 1x2 tiles. # Initialize dp array where dp[i] represents the number of ways to cover a i x 2 grid dp = [0] * (n + 1) # Base cases if n == 0: return 1 if n == 1: return 1 # Initial values for the first two indexes dp[0] = 1 dp[1] = 1 # Fill dp array using the recurrence relation for i in range(2, n+1): dp[i] = dp[i-1] + dp[i-2] return dp[n]"},{"question":"def min_people_required(nums: List[int], x: int) -> int: Determines the minimum number of people required such that all tasks can be completed within x minutes. Args: nums: List of integers representing the number of minutes a person needs to finish a task. x: Integer representing the maximum permissible time for completing tasks. Returns: Integer representing the minimum number of people required. >>> min_people_required([3, 1, 4, 2, 2], 6) 2 >>> min_people_required([2, 3], 6) 1 >>> min_people_required([7, 7, 7], 7) 3 >>> min_people_required([1, 1, 1, 1, 5], 5) 2 >>> min_people_required([2, 2, 2, 2, 8], 8) 2 >>> min_people_required([5, 10, 15, 20, 25], 30) 3 >>> min_people_required([10, 10, 10, 10, 10], 20) 3 ...","solution":"from typing import List def min_people_required(nums: List[int], x: int) -> int: Determines the minimum number of people required such that all tasks can be completed within x minutes. Args: nums: List of integers representing the number of minutes a person needs to finish a task. x: Integer representing the maximum permissible time for completing tasks. Returns: Integer representing the minimum number of people required. nums.sort(reverse=True) people = [] for task_time in nums: placed = False for i in range(len(people)): if people[i] + task_time <= x: people[i] += task_time placed = True break if not placed: people.append(task_time) return len(people)"},{"question":"def rob(nums: list[int]) -> int: Returns the maximum amount of money you can rob without robbing two adjacent houses. Parameters: nums (List[int]): List of integers where each integer represents the amount of money in a house Returns: int: Maximum amount of money you can rob Examples: >>> rob([]) == 0 >>> rob([10]) == 10 >>> rob([10, 20]) == 20 >>> rob([10, 50, 20]) == 50 >>> rob([2, 7, 9, 3, 1]) == 12 >>> rob([5, 5, 5, 5, 5]) == 15 >>> rob([20, 10, 30, 10, 50]) == 100 >>> rob([100, 1, 1, 100]) == 200 # Your code here import pytest def test_rob_no_house(): assert rob([]) == 0 def test_rob_one_house(): assert rob([10]) == 10 def test_rob_two_houses(): assert rob([10, 20]) == 20 def test_rob_three_houses(): assert rob([10, 50, 20]) == 50 def test_rob_multiple_houses(): assert rob([2, 7, 9, 3, 1]) == 12 def test_rob_same_amount_houses(): assert rob([5, 5, 5, 5, 5]) == 15 def test_rob_alternating_high_low(): assert rob([20, 10, 30, 10, 50]) == 100 def test_rob_large_numbers(): assert rob([100, 1, 1, 100]) == 200","solution":"def rob(nums): Returns the maximum amount of money you can rob without robbing two adjacent houses. Parameters: nums (List[int]): List of integers where each integer represents the amount of money in a house Returns: int: Maximum amount of money you can rob if not nums: return 0 if len(nums) == 1: return nums[0] rob_next_plus_one = 0 rob_next = nums[-1] for i in range(len(nums) - 2, -1, -1): current = max(rob_next, rob_next_plus_one + nums[i]) rob_next_plus_one = rob_next rob_next = current return rob_next"},{"question":"def least_interval(tasks, cooldown): Determine the minimum total time required to execute all the tasks in the queue. The function takes a list of tasks represented by integers and an integer cooldown. Each integer represents a different type of task that takes 1 unit of time to complete. Tasks of the same type must be executed at least \`cooldown\` units of time apart. The function returns the minimum total time required to execute all the tasks. Parameters: tasks (List[int]): A list of tasks represented by integers. cooldown (int): The cooldown period between the same type of tasks. Returns: int: The minimum total time required to execute all the tasks in the queue. >>> least_interval([1, 2, 1, 2, 3, 1], 2) 7 >>> least_interval([1, 1, 1, 1], 0) 4 >>> least_interval([1, 2, 3, 4], 2) 4 >>> least_interval([1, 1, 1, 1], 2) 10 >>> least_interval([1, 1, 2, 1], 2) 7","solution":"def least_interval(tasks, cooldown): from collections import Counter, deque task_counts = Counter(tasks) max_task_count = max(task_counts.values()) max_count_tasks = sum(1 for count in task_counts.values() if count == max_task_count) intervals = (max_task_count - 1) * (cooldown + 1) + max_count_tasks return max(intervals, len(tasks))"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def lowest_common_ancestor(root: TreeNode, p: int, q: int) -> int: Find the lowest common ancestor of two nodes in the given binary tree. The LCA is defined as the deepest node that has both p and q as its descendants (where we allow a node to be a descendant of itself). Args: root (TreeNode): The root node of the binary tree. p (int): The value of the first node. q (int): The value of the second node. Returns: int: The value of the lowest common ancestor. >>> root = TreeNode(3) >>> root.left = TreeNode(5) >>> root.right = TreeNode(1) >>> lowest_common_ancestor(root, 5, 1) 3 >>> root.left.left = TreeNode(6) >>> root.left.right = TreeNode(2) >>> root.left.right.left = TreeNode(7) >>> root.left.right.right = TreeNode(4) >>> lowest_common_ancestor(root, 6, 4) 5","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def lowest_common_ancestor(root: TreeNode, p: int, q: int) -> int: if not root: return None if root.val == p or root.val == q: return root.val left_lca = lowest_common_ancestor(root.left, p, q) right_lca = lowest_common_ancestor(root.right, p, q) if left_lca and right_lca: return root.val return left_lca if left_lca else right_lca"},{"question":"def remove_excessive_characters(s: str) -> str: Remove the minimum number of characters from the string so that every letter appears at most twice. >>> remove_excessive_characters('abc') 'abc' >>> remove_excessive_characters('aaa') 'aa' >>> remove_excessive_characters('aabbbcccc') 'aabbcc' >>> remove_excessive_characters('aabbcc') 'aabbcc' >>> remove_excessive_characters('aaabbbcccaaa') 'aabbcc' >>> remove_excessive_characters('') '' >>> remove_excessive_characters('aaaaaa') 'aa'","solution":"def remove_excessive_characters(s): Remove the minimum number of characters from the string so that every letter appears at most twice. from collections import Counter count = Counter(s) result = [] # Create a temporary dictionary to keep track of occurrences of each letter in the result temp_count = {char: 0 for char in count} for char in s: if temp_count[char] < 2: result.append(char) temp_count[char] += 1 return ''.join(result)"},{"question":"def min_modifications_to_distinct_substrings(s: str, k: int) -> int: Returns the minimum number of modifications required to ensure all substrings of length k have exactly k distinct characters. >>> min_modifications_to_distinct_substrings(\\"abcde\\", 2) == 0 >>> min_modifications_to_distinct_substrings(\\"abcdef\\", 5) == 0 >>> min_modifications_to_distinct_substrings(\\"aab\\", 2) == 1 >>> min_modifications_to_distinct_substrings(\\"aaaa\\", 3) == 2 >>> min_modifications_to_distinct_substrings(\\"aaabbbccc\\", 2) == 1 >>> min_modifications_to_distinct_substrings(\\"a\\", 1) == 0 >>> min_modifications_to_distinct_substrings(\\"\\", 1) == 0 >>> min_modifications_to_distinct_substrings(\\"abc\\", 0) == 0 >>> min_modifications_to_distinct_substrings(\\"abc\\", 4) == 0","solution":"def min_modifications_to_distinct_substrings(s, k): Returns the minimum number of modifications required to ensure all substrings of length k have exactly k distinct characters. if not s or k <= 0 or k > len(s): return 0 n = len(s) min_replacements = float('inf') def is_valid_substring(substr): return len(set(substr)) == len(substr) for i in range(n - k + 1): substring = s[i:i + k] if not is_valid_substring(substring): unique_chars = set(substring) modifications_needed = k - len(unique_chars) min_replacements = min(min_replacements, modifications_needed) return min_replacements if min_replacements != float('inf') else 0"},{"question":"def max_logs(heights: List[int], h: int) -> int: Determine the maximum logs that the lumberjack can collect given a specific cutting height \`h\`. :param heights: List[int], list of tree heights in the forest. :param h: int, the cutting height. :return: int, the maximum logs that can be collected. >>> max_logs([1, 2, 3], 4) == 0 >>> max_logs([5, 6, 7], 4) == 6 >>> max_logs([3, 5, 7], 4) == 4 >>> max_logs([4, 4, 4], 4) == 0 >>> max_logs([1, 2, 3, 4, 5, 6], 3) == 6 >>> max_logs([10**6, 10**6, 10**6], 999999) == 3 >>> max_logs([], 5) == 0 pass","solution":"def max_logs(heights, h): Returns the maximum logs that the lumberjack can collect given the cutting height h. :param heights: List[int], list of tree heights in the forest. :param h: int, the cutting height. :return: int, the maximum logs that can be collected. return sum(height - h for height in heights if height > h)"},{"question":"def number_of_distinct_islands(grid: List[List[int]]) -> int: Count the number of distinct islands in the grid. Args: grid (List[List[int]]): A 2D grid where 1 represents land, and 0 represents water. Returns: int: The number of distinct islands in the grid. >>> number_of_distinct_islands([ ... [1, 1, 0, 0, 0], ... [1, 1, 0, 0, 0], ... [0, 0, 0, 0, 0], ... [0, 0, 0, 1, 1], ... [0, 0, 0, 1, 1] ... ]) 1 >>> number_of_distinct_islands([ ... [1, 1, 0, 1, 1], ... [1, 0, 0, 1, 0], ... [0, 0, 0, 0, 0], ... [0, 1, 1, 0, 1], ... [1, 1, 0, 1, 1] ... ]) 3 >>> number_of_distinct_islands([ ... [0, 0, 0, 0, 0], ... [0, 0, 0, 0, 0], ... [0, 0, 0, 0, 0], ... [0, 0, 0, 0, 0], ... [0, 0, 0, 0, 0] ... ]) 0 >>> number_of_distinct_islands([ ... [1, 0, 0, 1], ... [1, 0, 0, 1], ... [0, 0, 1, 1] ... ]) 2","solution":"def number_of_distinct_islands(grid): def dfs(x, y, direction): stack = [(x, y, direction)] path = [] while stack: i, j, d = stack.pop() if 0 <= i < m and 0 <= j < n and grid[i][j] == 1: grid[i][j] = 0 path.append(d) stack.append((i+1, j, 'D')) stack.append((i-1, j, 'U')) stack.append((i, j+1, 'R')) stack.append((i, j-1, 'L')) return tuple(path) if not grid: return 0 m, n = len(grid), len(grid[0]) unique_islands = set() for i in range(m): for j in range(n): if grid[i][j] == 1: island_shape = dfs(i, j, 'S') unique_islands.add(island_shape) return len(unique_islands)"},{"question":"def num_distinct_islands(grid: List[List[int]]) -> int: Given a 2D grid of 0's and 1's, return the number of distinct islands, considering two islands distinct if one is not equal to another (disregarding translations and rotations). >>> num_distinct_islands([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) == 0 >>> num_distinct_islands([ ... [0, 1, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) == 1 >>> num_distinct_islands([ ... [1, 0, 0, 1], ... [0, 1, 0, 0], ... [0, 0, 1, 0] ... ]) == 1 >>> num_distinct_islands([ ... [1, 1, 0, 0], ... [1, 0, 0, 1], ... [0, 0, 1, 1] ... ]) == 2 >>> num_distinct_islands([ ... [1, 1, 0, 0, 0, 1], ... [1, 0, 0, 1, 1, 1], ... [0, 0, 1, 1, 0, 0], ... [1, 1, 0, 0, 1, 1] ... ]) == 3","solution":"def num_distinct_islands(grid): Given a 2D grid of 0's and 1's, return the number of distinct islands, considering two islands distinct if one is not equal to another (disregarding translations and rotations). def dfs(i, j, direction): Perform Depth-First Search to explore the entire island if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0: return grid[i][j] = 0 # mark as visited shape.append(direction) # explore neighbors dfs(i - 1, j, \\"U\\") dfs(i + 1, j, \\"D\\") dfs(i, j - 1, \\"L\\") dfs(i, j + 1, \\"R\\") shape.append(\\"0\\") # backtracking shapes = set() for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: shape = [] dfs(i, j, \\"S\\") # start exploring the island shapes.add(tuple(shape)) # add the shape of this island to the set return len(shapes)"},{"question":"def longest_substring_after_replacement(s: str) -> int: Given a string \`s\` containing only the characters \`a\` and \`b\`, you are allowed to replace exactly one character in \`s\` with any other character to form a new string. Return the length of the longest contiguous substring of the new string that contains only one distinct character. >>> longest_substring_after_replacement(\\"aababba\\") 4 >>> longest_substring_after_replacement(\\"a\\") 1 >>> longest_substring_after_replacement(\\"bbbb\\") 4 >>> longest_substring_after_replacement(\\"ababa\\") 3 >>> longest_substring_after_replacement(\\"abbba\\") 4 >>> longest_substring_after_replacement(\\"\\") 1","solution":"def longest_substring_after_replacement(s: str) -> int: Returns the length of the longest contiguous substring that contains only one distinct character in a new string formed by replacing exactly one character in the input string \`s\`. max_length = 1 def max_length_with_replacement(char): max_len = 0 left = 0 count_diff_char = 0 for right in range(len(s)): if s[right] != char: count_diff_char += 1 while count_diff_char > 1: if s[left] != char: count_diff_char -= 1 left += 1 max_len = max(max_len, right - left + 1) return max_len max_length = max(max_length, max_length_with_replacement('a')) max_length = max(max_length, max_length_with_replacement('b')) return max_length"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def count_good_paths(root, targetSum): Returns the number of paths from root to leaf that sum up to targetSum. >>> root = TreeNode(5) >>> count_good_paths(root, 5) 1 >>> root = TreeNode(5, TreeNode(4), TreeNode(8)) >>> root.left.left = TreeNode(11) >>> root.left.left.right = TreeNode(2) >>> root.right.left = TreeNode(13) >>> root.right.right = TreeNode(4) >>> root.right.right.right = TreeNode(1) >>> count_good_paths(root, 22) 1 >>> root = TreeNode(1, TreeNode(2), TreeNode(3)) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> count_good_paths(root, 100) 0 >>> root = TreeNode(10, TreeNode(5), TreeNode(-3)) >>> root.left.left = TreeNode(3) >>> root.left.right = TreeNode(2) >>> root.left.left.left = TreeNode(3) >>> root.right.right = TreeNode(11) >>> count_good_paths(root, 21) 1 >>> count_good_paths(root, 18) 1","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def count_good_paths(root, targetSum): Returns the number of paths from root to leaf that sum up to targetSum. def dfs(node, current_sum): if not node: return 0 current_sum += node.val # Check if we have reached a leaf node with the required sum if not node.left and not node.right: return 1 if current_sum == targetSum else 0 # Process left and right subtrees left_paths = dfs(node.left, current_sum) right_paths = dfs(node.right, current_sum) return left_paths + right_paths return dfs(root, 0)"},{"question":"def min_operations_to_equal_height(heights: List[int], k: int) -> int: Calculate the minimum number of operations to make all buildings the same height. If not possible within k operations, return -1. >>> min_operations_to_equal_height([1, 2, 3], 3) 3 >>> min_operations_to_equal_height([1, 1, 1], 0) 0 >>> min_operations_to_equal_height([1, 2, 2], 2) 1 >>> min_operations_to_equal_height([1, 2, 3], 2) -1 >>> min_operations_to_equal_height([1, 5, 9], 10) -1 >>> min_operations_to_equal_height([5, 5, 5], 1) 0 >>> min_operations_to_equal_height([5], 0) 0 >>> min_operations_to_equal_height([100, 200, 300], 5000) 300","solution":"def min_operations_to_equal_height(heights, k): Calculate the minimum number of operations to make all buildings the same height. If not possible within k operations, return -1. max_height = max(heights) total_operations = sum(max_height - height for height in heights) if total_operations <= k: return total_operations else: return -1"},{"question":"def longest_substring_no_more_than_k_consecutive(s: str, k: int) -> int: Returns the length of the longest substring of \`s\` that contains no more than \`k\` consecutive characters \`a\` and \`k\` consecutive characters \`b\`. >>> longest_substring_no_more_than_k_consecutive(\\"aaabbb\\", 2) 4 >>> longest_substring_no_more_than_k_consecutive(\\"aaaaa\\", 2) 2 >>> longest_substring_no_more_than_k_consecutive(\\"bbbbb\\", 1) 1 >>> longest_substring_no_more_than_k_consecutive(\\"ababababa\\", 1) 9 >>> longest_substring_no_more_than_k_consecutive(\\"aaaa\\", 2) 2 >>> longest_substring_no_more_than_k_consecutive(\\"\\", 2) 0 >>> longest_substring_no_more_than_k_consecutive(\\"aabbabba\\", 2) 8","solution":"def longest_substring_no_more_than_k_consecutive(s, k): Returns the length of the longest substring of \`s\` that contains no more than \`k\` consecutive characters \`a\` and \`k\` consecutive characters \`b\`. max_length = 0 current_a_count = 0 current_b_count = 0 start = 0 for end in range(len(s)): if s[end] == 'a': current_a_count += 1 current_b_count = 0 else: # s[end] == 'b' current_a_count = 0 current_b_count += 1 while current_a_count > k or current_b_count > k: if s[start] == 'a': current_a_count -= 1 else: current_b_count -= 1 start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"def can_reach_end(nums: List[int]) -> bool: Given a list of integers nums representing a sequence of steps, determine whether you can reach the last position. Args: nums (list): A list of integers indicating steps forward or backward at each position. Returns: bool: True if it is possible to reach the last position, False otherwise. >>> can_reach_end([2, 3, 1, 1, 4]) True >>> can_reach_end([3, 2, 1, 0, 4]) False >>> can_reach_end([]) False >>> can_reach_end([0]) True >>> can_reach_end([2, -1, 1, 1, 1]) True >>> can_reach_end([2, -2, 0, 1, 1]) False >>> can_reach_end([4, 1, 1, 1, 1, 1]) True >>> can_reach_end([0, 0, 0, 0]) False","solution":"def can_reach_end(nums): Given a list of integers nums representing a sequence of steps, determine whether you can reach the last position. Args: nums (list): A list of integers indicating steps forward or backward at each position. Returns: bool: True if it is possible to reach the last position, False otherwise. n = len(nums) max_reach = 0 for i in range(n): if i > max_reach: return False max_reach = max(max_reach, i + nums[i]) if max_reach >= n - 1: return True return False"},{"question":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root: Optional[TreeNode]) -> List[List[int]]: Return the level order traversal of a binary tree's nodes' values. Args: root (TreeNode): The root of the binary tree. Returns: List[List[int]]: The level order traversal of each node's values. >>> root = TreeNode(3) >>> root.left = TreeNode(9) >>> root.right = TreeNode(20) >>> root.right.left = TreeNode(15) >>> root.right.right = TreeNode(7) >>> level_order_traversal(root) [[3], [9, 20], [15, 7]] >>> level_order_traversal(None) [] >>> root = TreeNode(1) >>> level_order_traversal(root) [[1]] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> level_order_traversal(root) [[1], [2, 3]] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(3) >>> level_order_traversal(root) [[1], [2], [3]] >>> root = TreeNode(1) >>> root.right = TreeNode(2) >>> root.right.right = TreeNode(3) >>> level_order_traversal(root) [[1], [2], [3]]","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root): Return the level order traversal of a binary tree's nodes' values. Args: root (TreeNode): The root of the binary tree. Returns: List[List[int]]: The level order traversal of each node's values. if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.popleft() current_level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(current_level) return result"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_list(head: ListNode) -> ListNode: Reverses a singly linked list. :param head: ListNode, the head of the singly linked list :return: ListNode, the head of the reversed singly linked list >>> linked_to_list(reverse_list(list_to_linked([1, 2, 3, 4, 5]))) == [5, 4, 3, 2, 1] >>> linked_to_list(reverse_list(list_to_linked([]))) == [] >>> linked_to_list(reverse_list(list_to_linked([1]))) == [1] >>> linked_to_list(reverse_list(list_to_linked([1, 2]))) == [2, 1]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_list(head): Reverses a singly linked list. :param head: ListNode, the head of the singly linked list :return: ListNode, the head of the reversed singly linked list prev = None current = head while current is not None: next_node = current.next current.next = prev prev = current current = next_node return prev"},{"question":"def three_sum(arr): Returns all unique triplets in the array that sum up to zero. Each triplet should be in non-descending order, with no duplicates. :param arr: List[int] - The input array of integers. :return: List[List[int]] - List of unique triplets that sum up to zero. pass from solution import three_sum def test_three_sum_empty(): assert three_sum([]) == [] def test_three_sum_no_triplets(): assert three_sum([1, 2, -2, -1]) == [] def test_three_sum_single_triplet(): assert three_sum([-1, 0, 1, 2, -1, -4]) == [[-1, -1, 2], [-1, 0, 1]] def test_three_sum_multiple_triplets(): assert three_sum([-1, 0, 1, 2, -1, -4, -2, -3, 3, 0, 4]) == [ [-4, 0, 4], [-4, 1, 3], [-3, -1, 4], [-3, 0, 3], [-3, 1, 2], [-2, -1, 3], [-2, 0, 2], [-1, -1, 2], [-1, 0, 1], ] def test_three_sum_duplicates(): assert three_sum([-1, -1, -1, 2, 2, 2]) == [[-1, -1, 2]]","solution":"def three_sum(arr): Returns all unique triplets in the array that sum up to zero. Each triplet should be in non-descending order, with no duplicates. :param arr: List[int] - The input array of integers. :return: List[List[int]] - List of unique triplets that sum up to zero. arr.sort() result = [] n = len(arr) for i in range(n - 2): if i > 0 and arr[i] == arr[i - 1]: continue left, right = i + 1, n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == 0: result.append([arr[i], arr[left], arr[right]]) while left < right and arr[left] == arr[left + 1]: left += 1 while left < right and arr[right] == arr[right - 1]: right -= 1 left += 1 right -= 1 elif current_sum < 0: left += 1 else: right -= 1 return result"},{"question":"def longest_balanced_subarray(arr: List[int], threshold: int) -> int: Returns the length of the longest balanced subarray in arr where the sum of its elements is less than or equal to threshold. >>> longest_balanced_subarray([10, 20, 30], 5) == 0 >>> longest_balanced_subarray([10], 15) == 1 >>> longest_balanced_subarray([1, 2, 3, 4], 10) == 4 >>> longest_balanced_subarray([5, 1, 3, 2, 4], 6) == 3 >>> longest_balanced_subarray([2, 3, 5, 1, 8], 6) == 2 >>> longest_balanced_subarray([1, 2, 3, 4, 5], 15) == 5 >>> longest_balanced_subarray([1, 2, 3, 4, 5], 0) == 0","solution":"def longest_balanced_subarray(arr, threshold): Returns the length of the longest balanced subarray in arr where the sum of its elements is less than or equal to threshold. n = len(arr) max_length = 0 for i in range(n): current_sum = 0 for j in range(i, n): current_sum += arr[j] if current_sum <= threshold: max_length = max(max_length, j - i + 1) else: break return max_length"},{"question":"def can_jump(nums: List[int]) -> bool: Determine if you can reach the last index starting from the first index. :param nums: List[int], array where each element represents the maximum number of steps you can jump forward from that position. :return: bool, True if you can reach the last element, otherwise False. >>> can_jump([2, 3, 1, 1, 4]) True >>> can_jump([3, 2, 1, 0, 4]) False >>> can_jump([0]) True >>> can_jump([]) False >>> can_jump([1, 0]) True >>> can_jump([2, 0, 0]) True >>> can_jump([3, 4, 2, 1, 2, 1, 5, 0, 0, 0, 1]) True >>> can_jump([3, 2, 1, 0, 4, 2, 0, 1, 0, 0, 1]) False","solution":"def can_jump(nums): Determine if you can reach the last index starting from the first index. :param nums: List[int], array where each element represents the maximum number of steps you can jump forward from that position. :return: bool, True if you can reach the last element, otherwise False. max_reach = 0 for i, num in enumerate(nums): if i > max_reach: return False max_reach = max(max_reach, i + num) if max_reach >= len(nums) - 1: return True return False"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def removeNthFromEnd(head: ListNode, n: int) -> ListNode: Removes the n-th node from the end of the list and returns the head of the modified list. >>> head = array_to_list([1, 2, 3, 4, 5]) >>> n = 2 >>> new_head = removeNthFromEnd(head, n) >>> list_to_array(new_head) [1, 2, 3, 5] >>> head = array_to_list([1, 2]) >>> n = 2 >>> new_head = removeNthFromEnd(head, n) >>> list_to_array(new_head) [2] def list_to_array(head: ListNode) -> list: Converts a linked list to an array. array = [] while head: array.append(head.val) head = head.next return array def array_to_list(array: list) -> ListNode: Converts an array to a linked list. head = ListNode(array[0]) if array else None current = head for val in array[1:]: current.next = ListNode(val) current = current.next return head","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def removeNthFromEnd(head, n): Removes the n-th node from the end of the list and returns the head of the modified list. dummy = ListNode(0) # Create a dummy node to handle edge cases dummy.next = head first = dummy second = dummy # Move first n+1 steps ahead to maintain a gap for _ in range(n + 1): first = first.next # Move both pointers until first reaches the end while first is not None: first = first.next second = second.next # Remove the nth node from end second.next = second.next.next return dummy.next"},{"question":"def min_merge_cost(elements): Calculate the minimum cost to merge all clusters into one cluster. :param elements: List[int] - a list where each element represents the size of the i-th cluster. :return: int - the minimum cost to merge all clusters into one. >>> min_merge_cost([1]) 0 >>> min_merge_cost([1, 2]) 3 >>> min_merge_cost([1, 2, 3]) 9 >>> min_merge_cost([10, 20, 30]) 90 >>> min_merge_cost([1, 2, 3, 4]) 19 >>> min_merge_cost([5, 5, 5, 5]) 40 >>> min_merge_cost([1, 1, 1, 1]) 8","solution":"def min_merge_cost(elements): Calculate the minimum cost to merge all clusters into one cluster. :param elements: List[int] - a list where each element represents the size of the i-th cluster. :return: int - the minimum cost to merge all clusters into one. import heapq # if there is only one or no cluster, no merging is needed if len(elements) <= 1: return 0 # Convert the list into a priority queue (min-heap) heapq.heapify(elements) total_cost = 0 # While there are more than one clusters to merge while len(elements) > 1: # Take the two smallest clusters first = heapq.heappop(elements) second = heapq.heappop(elements) # Merge them cost = first + second total_cost += cost # Add the merged cluster back to the priority queue heapq.heappush(elements, cost) return total_cost"},{"question":"class RestaurantBookingSystem: def __init__(self, numTables, numTimeSlots): Initialises the system with a specified number of tables and time slots. pass def book(self, table: int, timeSlot: int) -> bool: Books a specified table at a specific time slot. Returns True if the booking was successful, False if the table is already booked at that time. pass def cancel(self, table: int, timeSlot: int) -> bool: Cancels a booking for a specific table and time slot. Returns True if the cancellation was successful, False if there was no booking at that time. pass def availableTables(self, timeSlot: int) -> List[int]: Returns a list of table numbers that are available for a given time slot, sorted in ascending order. If no tables are available, returns an empty list. pass from solution import RestaurantBookingSystem def test_initialization(): system = RestaurantBookingSystem(5, 3) assert system.numTables == 5 assert system.numTimeSlots == 3 assert len(system.bookings) == 5 assert len(system.bookings[0]) == 3 def test_book_success(): system = RestaurantBookingSystem(5, 3) assert system.book(1, 2) == True assert system.bookings[1][2] == True def test_book_failure(): system = RestaurantBookingSystem(5, 3) system.book(1, 2) assert system.book(1, 2) == False def test_cancel_success(): system = RestaurantBookingSystem(5, 3) system.book(1, 2) assert system.cancel(1, 2) == True assert system.bookings[1][2] == False def test_cancel_failure(): system = RestaurantBookingSystem(5, 3) assert system.cancel(1, 2) == False def test_available_tables(): system = RestaurantBookingSystem(5, 3) system.book(1, 2) system.book(3, 2) assert system.availableTables(2) == [0, 2, 4] system.book(0, 2) assert system.availableTables(2) == [2, 4] system.cancel(1, 2) assert system.availableTables(2) == [1, 2, 4]","solution":"class RestaurantBookingSystem: def __init__(self, numTables, numTimeSlots): self.numTables = numTables self.numTimeSlots = numTimeSlots self.bookings = [[False for _ in range(numTimeSlots)] for _ in range(numTables)] def book(self, table, timeSlot): if self.bookings[table][timeSlot]: return False self.bookings[table][timeSlot] = True return True def cancel(self, table, timeSlot): if not self.bookings[table][timeSlot]: return False self.bookings[table][timeSlot] = False return True def availableTables(self, timeSlot): available = [] for table in range(self.numTables): if not self.bookings[table][timeSlot]: available.append(table) return available"},{"question":"def max_subarray_sum(arr: List[int], n: int) -> int: Returns the maximum possible sum of a subarray of size \`n\` from the original array \`arr\`. Args: arr (List[int]): The list of integers. n (int): The size of the subarray. Returns: int: The maximum sum of a subarray of size \`n\`. If no such subarray exists, return 0. Examples: >>> max_subarray_sum([1, 2, 3, 4, 5], 2) 9 >>> max_subarray_sum([5, 1, 1, 1, 5], 3) 7","solution":"def max_subarray_sum(arr, n): Returns the maximum possible sum of a subarray of size \`n\` from the original array \`arr\`. if len(arr) < n: return 0 # Compute the initial sum of the first subarray of size \`n\` max_sum = current_sum = sum(arr[:n]) # Iterate through the array using a sliding window for i in range(n, len(arr)): current_sum += arr[i] - arr[i - n] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def words_before_target(s: str, target: str) -> list: Returns a list of words that appear immediately before each occurrence of the word target in the string s. :param s: The original string containing words separated by spaces. :param target: The word for which we need to find preceding words. :return: A list of words occurring immediately before each occurrence of the target word. >>> words_before_target(\\"hello world\\", \\"world\\") [\\"hello\\"] >>> words_before_target(\\"a quick brown fox jumps over the lazy dog\\", \\"the\\") [\\"over\\"] >>> words_before_target(\\"the quick brown fox jumps over the lazy dog\\", \\"cat\\") [] >>> words_before_target(\\"hello world hello\\", \\"hello\\") [\\"world\\"] >>> words_before_target(\\"a b c target\\", \\"target\\") [\\"c\\"] >>> words_before_target(\\"\\", \\"target\\") [] >>> words_before_target(\\"a b c a b c\\", \\"c\\") [\\"b\\", \\"b\\"] >>> words_before_target(\\"a b c d e f\\", \\"d\\") [\\"c\\"]","solution":"def words_before_target(s, target): Returns a list of words that appear immediately before each occurrence of the word target in the string s. :param s: The original string containing words separated by spaces. :param target: The word for which we need to find preceding words. :return: A list of words occurring immediately before each occurrence of the target word. words = s.split() result = [] for i in range(1, len(words)): if words[i] == target: result.append(words[i-1]) return result"},{"question":"def longest_arith_seq_length(nums): Finds the length of the longest arithmetic subsequence in the array nums. :param nums: List[int], the input array of integers :return: int, the length of the longest arithmetic subsequence >>> longest_arith_seq_length([]) == 0 >>> longest_arith_seq_length([10]) == 1 >>> longest_arith_seq_length([1, 3]) == 2 >>> longest_arith_seq_length([3, 3, 3, 3]) == 4 >>> longest_arith_seq_length([3, 6, 9, 12]) == 4 >>> longest_arith_seq_length([9, 4, 7, 2, 10]) == 3 >>> longest_arith_seq_length([1, 7, 10, 13, 14, 19]) == 4","solution":"def longest_arith_seq_length(nums): Finds the length of the longest arithmetic subsequence in the array nums. :param nums: List[int], the input array of integers :return: int, the length of the longest arithmetic subsequence if not nums: return 0 n = len(nums) if n <= 2: return n dp = {} longest = 2 for i in range(n): for j in range(i + 1, n): diff = nums[j] - nums[i] if (i, diff) in dp: dp[(j, diff)] = dp[(i, diff)] + 1 else: dp[(j, diff)] = 2 longest = max(longest, dp[(j, diff)]) return longest"},{"question":"def primes_less_than(n: int) -> List[int]: Given an integer n, return a list of all prime numbers less than n. A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. >>> primes_less_than(10) [2, 3, 5, 7] >>> primes_less_than(2) [] >>> primes_less_than(1) [] >>> primes_less_than(20) [2, 3, 5, 7, 11, 13, 17, 19] >>> primes_less_than(50) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]","solution":"def primes_less_than(n): Returns a list of all prime numbers less than n. if n <= 2: return [] sieve = [True] * n sieve[0] = sieve[1] = False # 0 and 1 are not prime numbers for start in range(2, int(n**0.5) + 1): if sieve[start]: for multiple in range(start*start, n, start): sieve[multiple] = False return [num for num, is_prime in enumerate(sieve) if is_prime]"},{"question":"from typing import List from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def levelOrder(root: TreeNode) -> List[List[int]]: Given a binary tree, return the level order traversal of its nodes' values. >>> levelOrder(TreeNode(1, TreeNode(2), TreeNode(3))) [[1], [2, 3]] >>> levelOrder(TreeNode(1, right=TreeNode(2, right=TreeNode(3)))) [[1], [2], [3]] >>> levelOrder(None) []","solution":"from collections import deque from typing import List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def levelOrder(root: TreeNode) -> List[List[int]]: if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) level_nodes = [] for _ in range(level_size): node = queue.popleft() level_nodes.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_nodes) return result"},{"question":"def max_minutes(nums, k): Returns the maximum number of minutes spent in a single session that adheres to the given constraint of no more than k different tasks. >>> max_minutes([30, 20, 10], 2) == 50 >>> max_minutes([30, 20, 10], 3) == 60 >>> max_minutes([30, 20, 10, 40], 2) == 70 >>> max_minutes([30, 20, 10], 1) == 30 >>> max_minutes([5, 15, 25, 35, 45], 3) == 105 >>> max_minutes([5, 15, 25, 35, 45], 10) == 125 # k is larger than the length of the list >>> max_minutes([], 5) == 0 >>> max_minutes([5, 15, 25, 35, 45], 0) == 0","solution":"def max_minutes(nums, k): Returns the maximum number of minutes spent in a single session that adheres to the given constraint of no more than k different tasks. nums.sort(reverse=True) return sum(nums[:k])"},{"question":"def shortest_path_maze(grid, startRow, startCol): Find the shortest path from the start position to the bottom-right corner of the maze. :param grid: List[List[str]], a 2D list representing the maze :param startRow: int, the starting row index :param startCol: int, the starting column index :return: int, the length of the shortest path or -1 if no path exists >>> shortest_path_maze([ ['.', '.', '.'], ['#', '#', '.'], ['#', '#', '.'] ], 0, 0) 4 >>> shortest_path_maze([ ['.', '#', '.'], ['#', '.', '#'], ['#', '#', '.'] ], 0, 0) -1 >>> shortest_path_maze([['.']], 0, 0) 0 >>> shortest_path_maze([ ['.', '.'], ['#', '#'] ], 0, 0) -1 >>> shortest_path_maze([ ['.', '.', '.'], ['.', '.', '.'], ['.', '.', '.'] ], 0, 0) 4 >>> shortest_path_maze([ ['.', '.', '#', '.', '.', '.', '.', '#'], ['#', '.', '#', '.', '#', '#', '.', '#'], ['#', '.', '.', '.', '#', '.', '.', '#'], ['#', '#', '#', '.', '#', '.', '#', '#'], ['#', '#', '#', '.', '#', '.', '.', '.'], ['#', '.', '.', '.', '.', '#', '#', '.'], ['#', '#', '#', '#', '.', '.', '.', '.'], ['#', '.', '#', '#', '#', '#', '#', '.'] ], 0, 0) 14","solution":"from collections import deque def shortest_path_maze(grid, startRow, startCol): Find the shortest path from the start position to the bottom-right corner of the maze. :param grid: List[List[str]], a 2D list representing the maze :param startRow: int, the starting row index :param startCol: int, the starting column index :return: int, the length of the shortest path or -1 if no path exists n = len(grid) if grid[startRow][startCol] == '#' or grid[n-1][n-1] == '#': return -1 # Define possible moves (right, down, left, up) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Breadth-First Search (BFS) initialization queue = deque([(startRow, startCol, 0)]) # (row, col, distance) visited = set([(startRow, startCol)]) while queue: row, col, dist = queue.popleft() if row == n-1 and col == n-1: return dist for dr, dc in directions: newRow, newCol = row + dr, col + dc if 0 <= newRow < n and 0 <= newCol < n and grid[newRow][newCol] == '.' and (newRow, newCol) not in visited: visited.add((newRow, newCol)) queue.append((newRow, newCol, dist + 1)) return -1"},{"question":"def min_moves(grid): Returns the minimum number of moves required to reach the bottom-right corner from the top-left corner in the grid, or -1 if it is not possible. >>> min_moves([[0, 1, 2], [2, 2, 2], [3, 2, 2]]) == 4 >>> min_moves([[1, 1, 3], [6, 5, 2], [7, 8, 2]]) == -1 >>> min_moves([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == -1 >>> min_moves([[0]]) == 0 >>> min_moves([ [0, 1, 2, 3, 4], [1, 2, 3, 4, 5], [2, 3, 4, 5, 6], [3, 4, 5, 6, 7], [4, 5, 6, 7, 8] ]) == 8 >>> min_moves([ [0, 1, 2, -1, 4], [1, -1, 3, -1, 5], [2, -1, 4, 5, 6], [3, 4, -1, -1, 7], [4, 5, 6, 7, -1] ]) == -1","solution":"from collections import deque def min_moves(grid): Returns the minimum number of moves required to reach the bottom-right corner from the top-left corner in the grid, or -1 if it is not possible. n = len(grid) if grid[0][0] == -1 or grid[n-1][n-1] == -1: return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) # (x, y, moves) visited = {(0, 0)} while queue: x, y, moves = queue.popleft() if (x, y) == (n-1, n-1): return moves for direction in directions: nx, ny = x + direction[0], y + direction[1] if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited: if grid[nx][ny] <= grid[x][y] + 1: queue.append((nx, ny, moves+1)) visited.add((nx, ny)) return -1 # if the bottom-right corner is not reachable"},{"question":"def sort_words_in_string_order(s: str, words: List[str]) -> List[str]: Given a string s and a list of words that are substrings of s and appear exactly once in s, this function returns the list sorted in the order the words appear in s. >>> sort_words_in_string_order(\\"codingassessmenttask\\", [\\"task\\", \\"assessment\\", \\"coding\\"]) [\\"coding\\", \\"assessment\\", \\"task\\"] >>> sort_words_in_string_order(\\"singletest\\", [\\"singletest\\"]) [\\"singletest\\"] >>> sort_words_in_string_order(\\"onetwo\\", [\\"two\\", \\"one\\"]) [\\"one\\", \\"two\\"] >>> sort_words_in_string_order(\\"dataisbeautiful\\", [\\"data\\", \\"is\\", \\"beautiful\\"]) [\\"data\\", \\"is\\", \\"beautiful\\"] >>> sort_words_in_string_order(\\"beautifulisdata\\", [\\"data\\", \\"is\\", \\"beautiful\\"]) [\\"beautiful\\", \\"is\\", \\"data\\"]","solution":"def sort_words_in_string_order(s, words): Given a string s and a list of words that are substrings of s and appear exactly once in s, this function returns the list sorted in the order the words appear in s. positions = {word: s.index(word) for word in words} sorted_words = sorted(words, key=lambda word: positions[word]) return sorted_words"},{"question":"class ListNode: Implements a basic ListNode for a singly-linked list. Attributes: val (int): The value of the node. next (ListNode): Reference to the next node in the linked list. def __init__(self, val=0, next=None): self.val = val self.next = next def partition(head: ListNode, x: int) -> ListNode: Rearranges the given linked list by partitioning it so that nodes with values less than x come before nodes with values greater than or equal to x. The original relative order of the nodes in each of the two partitions is preserved. Args: head (ListNode): The head of the singly-linked list. x (int): The partition value. Returns: ListNode: The head of the modified linked list. >>> head = list_to_linkedlist([1, 4, 3, 2, 5, 2]) >>> x = 3 >>> new_head = partition(head, x) >>> linkedlist_to_list(new_head) [1, 2, 2, 4, 3, 5] >>> head = list_to_linkedlist([3, 4, 5]) >>> x = 2 >>> new_head = partition(head, x) >>> linkedlist_to_list(new_head) [3, 4, 5] >>> head = list_to_linkedlist([1, 2, 2]) >>> x = 3 >>> new_head = partition(head, x) >>> linkedlist_to_list(new_head) [1, 2, 2]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def partition(head, x): less_head = less = ListNode(0) greater_head = greater = ListNode(0) while head: if head.val < x: less.next = head less = less.next else: greater.next = head greater = greater.next head = head.next greater.next = None less.next = greater_head.next return less_head.next"},{"question":"def count_of_atoms(formula: str) -> dict: Count the number of each type of atom in a chemical formula. Args: formula (str): The chemical formula to parse. Returns: dict: A dictionary where keys are elements and values are their counts. >>> count_of_atoms(\\"K4(ON(SO3)2)2\\") {'K': 4, 'N': 2, 'O': 14, 'S': 4} >>> count_of_atoms(\\"H2\\") {'H': 2} >>> count_of_atoms(\\"Mg(OH)2\\") {'Mg': 1, 'O': 2, 'H': 2} >>> count_of_atoms(\\"C6H12O6\\") {'C': 6, 'H': 12, 'O': 6} >>> count_of_atoms(\\"Fe12\\") {'Fe': 12} >>> count_of_atoms(\\"(NH4)2SO4\\") {'N': 2, 'H': 8, 'S': 1, 'O': 4} >>> count_of_atoms(\\"C10H16\\") {'C': 10, 'H': 16} >>> count_of_atoms(\\"H2O\\") {'H': 2, 'O': 1} # Example test cases, not required to be part of the completion task: # assert count_of_atoms(\\"K4(ON(SO3)2)2\\") == {\\"K\\": 4, \\"N\\": 2, \\"O\\": 14, \\"S\\": 4} # assert count_of_atoms(\\"H2\\") == {\\"H\\": 2} # assert count_of_atoms(\\"Fe12\\") == {\\"Fe\\": 12} # assert count_of_atoms(\\"Mg(OH)2\\") == {\\"Mg\\": 1, \\"O\\": 2, \\"H\\": 2} # assert count_of_atoms(\\"H2O\\") == {\\"H\\": 2, \\"O\\": 1} # assert count_of_atoms(\\"C6H12O6\\") == {\\"C\\": 6, \\"H\\": 12, \\"O\\": 6} # assert count_of_atoms(\\"(NH4)2SO4\\") == {\\"N\\": 2, \\"H\\": 8, \\"S\\": 1, \\"O\\": 4} # assert count_of_atoms(\\"C10H16\\") == {\\"C\\": 10, \\"H\\": 16}","solution":"import re from collections import defaultdict from collections import Counter def count_of_atoms(formula): Count the number of each type of atom in a chemical formula. Args: formula (str): The chemical formula to parse. Returns: dict: A dictionary where keys are elements and values are their counts. def parse(): stack = [Counter()] i = 0 n = len(formula) while i < n: if formula[i] == '(': stack.append(Counter()) i += 1 elif formula[i] == ')': top = stack.pop() i += 1 i_start = i while i < n and formula[i].isdigit(): i += 1 multiplier = int(formula[i_start:i] or 1) for elem in top: stack[-1][elem] += top[elem] * multiplier else: i_start = i i += 1 while i < n and formula[i].islower(): i += 1 elem = formula[i_start:i] i_start = i while i < n and formula[i].isdigit(): i += 1 count = int(formula[i_start:i] or 1) stack[-1][elem] += count return stack.pop() counts = parse() return dict(sorted(counts.items()))"},{"question":"def longest_common_prefix(strs: List[str]) -> str: Given a list of strings, return the longest common prefix string amongst all the strings in the list. If there is no common prefix, return an empty string. >>> longest_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\"]) \\"fl\\" >>> longest_common_prefix([\\"dog\\", \\"racecar\\", \\"car\\"]) \\"\\" >>> longest_common_prefix([\\"single\\"]) \\"single\\" >>> longest_common_prefix([]) \\"\\" >>> longest_common_prefix([\\"\\", \\"b\\", \\"c\\"]) \\"\\" >>> longest_common_prefix([\\"test\\", \\"test\\", \\"test\\"]) \\"test\\" >>> longest_common_prefix([\\"@home\\", \\"@house\\", \\"@host\\"]) \\"@ho\\" >>> longest_common_prefix([\\"a\\", \\"ab\\", \\"ac\\"]) \\"a\\" >>> longest_common_prefix([]) \\"\\" >>> longest_common_prefix([\\"\\", \\"\\", \\"\\"]) \\"\\" # Your code here","solution":"def longest_common_prefix(strs): Returns the longest common prefix string amongst all the strings in the list. If there is no common prefix, return an empty string. if not strs: return \\"\\" # Start with the first string in the list as the initial prefix prefix = strs[0] # Compare the prefix with each string in the list for s in strs[1:]: while not s.startswith(prefix): # Trim the last character from the prefix until a common prefix is found prefix = prefix[:-1] if not prefix: return \\"\\" return prefix"},{"question":"def min_window(s: str, t: str) -> str: Returns the minimum window substring of s which contains all the characters in t. >>> min_window(\\"ADOBECODEBANC\\", \\"ABC\\") \\"BANC\\" >>> min_window(\\"a\\", \\"a\\") \\"a\\" >>> min_window(\\"a\\", \\"b\\") \\"\\" >>> min_window(\\"abc\\", \\"d\\") \\"\\" >>> min_window(\\"aa\\", \\"aa\\") \\"aa\\" >>> min_window(\\"ADOBECODEBANCCCC\\", \\"ABC\\") \\"BANC\\" >>> min_window(\\"ADOBECODEBANC\\", \\"\\") \\"\\" >>> min_window(\\"\\", \\"ABC\\") \\"\\" >>> min_window(\\"aaabccbabcabc\\", \\"abc\\") \\"abc\\"","solution":"def min_window(s, t): from collections import Counter if not s or not t: return \\"\\" dict_t = Counter(t) required = len(dict_t) l, r = 0, 0 formed = 0 window_counts = {} ans = float(\\"inf\\"), None, None while r < len(s): character = s[r] window_counts[character] = window_counts.get(character, 0) + 1 if character in dict_t and window_counts[character] == dict_t[character]: formed += 1 while l <= r and formed == required: character = s[l] if r - l + 1 < ans[0]: ans = (r - l + 1, l, r) window_counts[character] -= 1 if character in dict_t and window_counts[character] < dict_t[character]: formed -= 1 l += 1 r += 1 if ans[0] == float(\\"inf\\"): return \\"\\" else: return s[ans[1]: ans[2] + 1]"},{"question":"def max_sum_submatrix(mat: List[List[int]], r: int, c: int) -> int: Returns the maximum sum of a submatrix with dimensions r x c in the given m x n matrix mat. Parameters: mat (list of list of int): The input matrix with non-negative integers. r (int): The number of rows in the submatrix. c (int): The number of columns in the submatrix. Returns: int: The maximum sum of a submatrix with dimensions r x c. >>> max_sum_submatrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 2, 2) == 28 >>> max_sum_submatrix([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 3, 3) == 99 >>> max_sum_submatrix([[1, 2], [3, 4]], 2, 2) == 10 >>> max_sum_submatrix([[1, 2], [3, 4]], 3, 3) == 0 >>> max_sum_submatrix([[1, 2, 3, 4, 5]], 1, 3) == 12 >>> max_sum_submatrix([[1], [2], [3], [4], [5]], 3, 1) == 12 pass","solution":"def max_sum_submatrix(mat, r, c): Returns the maximum sum of a submatrix with dimensions r x c in the given m x n matrix mat. Parameters: mat (list of list of int): The input matrix with non-negative integers. r (int): The number of rows in the submatrix. c (int): The number of columns in the submatrix. Returns: int: The maximum sum of a submatrix with dimensions r x c. m = len(mat) n = len(mat[0]) if r > m or c > n: return 0 # If the desired submatrix exceeds the matrix's dimensions. # Precompute the prefix sum matrix prefix_sum = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): prefix_sum[i][j] = mat[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1] max_sum = float('-inf') for i in range(r, m + 1): for j in range(c, n + 1): current_sum = prefix_sum[i][j] - prefix_sum[i - r][j] - prefix_sum[i][j - c] + prefix_sum[i - r][j - c] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def min_moves_to_make_empty(s: str) -> int: Returns the minimum number of moves needed to make the given string empty. A subsequence is defined as a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. A string is considered a palindrome if it reads the same forward and backward. >>> min_moves_to_make_empty(\\"\\") 0 >>> min_moves_to_make_empty(\\"a\\") 1 >>> min_moves_to_make_empty(\\"aba\\") 1 >>> min_moves_to_make_empty(\\"level\\") 1 >>> min_moves_to_make_empty(\\"radar\\") 1 >>> min_moves_to_make_empty(\\"racecar\\") 1 >>> min_moves_to_make_empty(\\"ab\\") 2 >>> min_moves_to_make_empty(\\"abc\\") 2 >>> min_moves_to_make_empty(\\"aabb\\") 2 >>> min_moves_to_make_empty(\\"abcd\\") 2 >>> min_moves_to_make_empty(\\"abca\\") 2 >>> min_moves_to_make_empty(\\"aabbaa\\") 1 >>> min_moves_to_make_empty(\\"abacaba\\") 1","solution":"def min_moves_to_make_empty(s): Returns the minimum number of moves needed to make the given string empty. if not s: return 0 if s == s[::-1]: return 1 return 2"},{"question":"from typing import List def three_sum(arr: List[int], target: int) -> List[List[int]]: You are given an array of distinct integers 'arr' and an integer 'target'. Your task is to find all unique triplets in the array that sum up to the target number. Each triplet should be sorted in ascending order, and the triplets themselves should be sorted in ascending order based on the first element, then the second element, and finally the third element if necessary. :param arr: List of distinct integers :param target: Target sum for the unique triplets :return: A list of all unique triplets that sum up to the target Example: >>> three_sum([-1, 0, 1, 2, -1, -4], 0) [[-1, -1, 2], [-1, 0, 1]] >>> three_sum([1, 2, 3, 4], 10) [] >>> three_sum([-5, -2, -3, -1], -6) [[-3, -2, -1]] >>> three_sum([1, 2, 3, 4, 5, 6], 12) [[1, 5, 6], [2, 4, 6], [3, 4, 5]] >>> three_sum([-2, -1, 0, 1, 2], 0) [[-2, 0, 2], [-1, 0, 1]] >>> three_sum([0, -1, 2, -3, 1], 0) [[-3, 1, 2], [-1, 0, 1]] >>> three_sum([0, 0, 0, 0], 0) [[0, 0, 0]]","solution":"def three_sum(arr, target): Finds all unique triplets in the array that sum up to the target number. arr.sort() triplets = [] for i in range(len(arr) - 2): if i > 0 and arr[i] == arr[i - 1]: continue left, right = i + 1, len(arr) - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == target: triplets.append([arr[i], arr[left], arr[right]]) while left < right and arr[left] == arr[left + 1]: left += 1 while left < right and arr[right] == arr[right - 1]: right -= 1 left += 1 right -= 1 elif current_sum < target: left += 1 else: right -= 1 return triplets"},{"question":"def findUnsortedSubarray(arr: List[int]) -> int: Returns the length of the shortest subarray that needs to be sorted for the entire array to become sorted in non-decreasing order. >>> findUnsortedSubarray([2, 6, 4, 8, 10, 9, 15]) 5 >>> findUnsortedSubarray([1, 2, 3, 4]) 0 >>> findUnsortedSubarray([1]) 0 >>> findUnsortedSubarray([4, 3, 2, 1]) 4 >>> findUnsortedSubarray([1, 3, 5, 2, 4, 6]) 4","solution":"def findUnsortedSubarray(arr): Returns the length of the shortest subarray that needs to be sorted for the entire array to become sorted in non-decreasing order. n = len(arr) if n <= 1: return 0 start, end = -1, -1 max_val, min_val = float('-inf'), float('inf') for i in range(n): max_val = max(max_val, arr[i]) if arr[i] < max_val: end = i for i in range(n - 1, -1, -1): min_val = min(min_val, arr[i]) if arr[i] > min_val: start = i if start == -1 and end == -1: return 0 return end - start + 1"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_duplicates(head): Remove duplicates from a linked list where each node contains an integer value. The order of nodes should be preserved as in the original list. Return the head of the modified linked list. >>> list_to_linked_list = lambda lst: reduce(lambda acc, val: (acc.next := ListNode(val), acc)[1], lst, ListNode())[1] >>> linked_list_to_list = lambda node: reduce(lambda acc, _: acc + [node.val] + ([node := node.next] and []), iter(int,1), []) # Example test cases >>> lst = [1, 2, 3, 4, 5] >>> head = list_to_linked_list(lst) >>> modified_head = remove_duplicates(head) >>> linked_list_to_list(modified_head) == [1, 2, 3, 4, 5] True >>> lst = [1, 1, 1, 1, 1] >>> head = list_to_linked_list(lst) >>> modified_head = remove_duplicates(head) >>> linked_list_to_list(modified_head) == [1] True >>> lst = [1, 2, 2, 3, 4, 4, 5] >>> head = list_to_linked_list(lst) >>> modified_head = remove_duplicates(head) >>> linked_list_to_list(modified_head) == [1, 2, 3, 4, 5] True >>> lst = [] >>> head = list_to_linked_list(lst) >>> modified_head = remove_duplicates(head) >>> linked_list_to_list(modified_head) == [] True >>> lst = [1, 2, 1, 3, 2, 4, 3, 5] >>> head = list_to_linked_list(lst) >>> modified_head = remove_duplicates(head) >>> linked_list_to_list(modified_head) == [1, 2, 3, 4, 5] True >>> lst = [7] >>> head = list_to_linked_list(lst) >>> modified_head = remove_duplicates(head) >>> linked_list_to_list(modified_head) == [7] True","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_duplicates(head): Remove duplicates from a sorted linked list and return the head of the modified list. if not head: return head current = head seen = set() seen.add(current.val) while current and current.next: if current.next.val in seen: current.next = current.next.next else: seen.add(current.next.val) current = current.next return head"},{"question":"from typing import Dict, List def bfs_shortest_path(graph: Dict[int, List[int]], start: int, end: int) -> int: Given a connected undirected graph represented in adjacency list format, find the shortest path length between two given nodes, \`start\` and \`end\`. If there is no path between \`start\` and \`end\`, return -1. The adjacency list is represented as a dictionary where the keys are node values and the values are lists of connected nodes. >>> graph = {1: [2], 2: [1, 3], 3: [2], 4: [5], 5: [4]} >>> bfs_shortest_path(graph, 1, 4) -1 >>> graph = {1: [2, 3], 2: [1], 3: [1]} >>> bfs_shortest_path(graph, 1, 3) 1 >>> graph = {1: [2], 2: [1, 3], 3: [2, 4], 4: [3]} >>> bfs_shortest_path(graph, 1, 4) 3 >>> graph = {1: [2], 2: [1]} >>> bfs_shortest_path(graph, 1, 1) 0 >>> graph = {1: [2, 3], 2: [1, 4], 3: [1, 4, 5], 4: [2, 3, 5], 5: [3, 4]} >>> bfs_shortest_path(graph, 1, 5) 2 >>> bfs_shortest_path(graph, 2, 5) 2 >>> bfs_shortest_path(graph, 5, 1) 2 >>> bfs_shortest_path(graph, 5, 4) 1 >>> bfs_shortest_path(graph, 1, 4) 2","solution":"from collections import deque def bfs_shortest_path(graph, start, end): Find the shortest path between start and end in a graph using BFS. Return the length of the shortest path. If no path exists, return -1. if start == end: return 0 visited = set() queue = deque([(start, 0)]) while queue: current, distance = queue.popleft() if current == end: return distance if current not in visited: visited.add(current) for neighbor in graph[current]: if neighbor not in visited: queue.append((neighbor, distance + 1)) return -1"},{"question":"def length_of_longest_substring(s: str) -> int: Calculates the length of the longest substring without repeating characters. :param s: A string consisting of lowercase English letters. :return: Length of the longest substring without repeating characters. >>> length_of_longest_substring('') == 0 >>> length_of_longest_substring('abcde') == 5 >>> length_of_longest_substring('aaaaa') == 1 >>> length_of_longest_substring('abcabcbb') == 3 >>> length_of_longest_substring('bbbbb') == 1 >>> length_of_longest_substring('pwwkew') == 3 >>> length_of_longest_substring('a') == 1 >>> length_of_longest_substring('abrkaabcdefghijjxxx') == 10","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. :param s: A string consisting of lowercase English letters. :return: Length of the longest substring without repeating characters. start = 0 max_length = 0 used_char = {} for i, char in enumerate(s): if char in used_char and start <= used_char[char]: start = used_char[char] + 1 else: max_length = max(max_length, i - start + 1) used_char[char] = i return max_length"},{"question":"from typing import List import re from collections import Counter def most_frequent_words(s: str, k: int) -> List[str]: Returns the k most frequent words in the sentence. Words are case-insensitive, and ties are resolved alphabetically. >>> most_frequent_words(\\"The day is sunny; the the the Sunny is is\\", 4) [\\"the\\", \\"is\\", \\"sunny\\", \\"day\\"] >>> most_frequent_words(\\"a a a b b c\\", 2) [\\"a\\", \\"b\\"]","solution":"from collections import Counter import re def most_frequent_words(s, k): Returns the k most frequent words in the sentence. Words are case-insensitive, and ties are resolved alphabetically. # Normalize the sentence to lowercase and remove punctuation s = s.lower() words = re.findall(r'bw+b', s) # Count the frequency of each word word_counts = Counter(words) # Sort the words by frequency and then alphabetically sorted_words = sorted(word_counts.items(), key=lambda x: (-x[1], x[0])) # Extract the top k words most_frequent = [word for word, _ in sorted_words[:k]] return most_frequent"},{"question":"def can_construct_target(words, target): Determine if the target string can be constructed by concatenating any subset of the strings in words. Parameters: words (list of str): Array of strings available for concatenation. target (str): The target string to be constructed. Returns: bool: True if the target can be constructed, False otherwise. pass def test_can_construct_target_with_subset(): assert can_construct_target([\\"ab\\", \\"abc\\", \\"cd\\", \\"def\\", \\"abcd\\"], \\"abcdef\\") == True def test_can_construct_target_with_repetition(): assert can_construct_target([\\"a\\", \\"aa\\", \\"aaa\\"], \\"aaaa\\") == True def test_can_construct_target_with_exact_match(): assert can_construct_target([\\"a\\", \\"b\\", \\"c\\", \\"ab\\", \\"bc\\"], \\"abc\\") == True def test_can_construct_target_cannot_be_formed(): assert can_construct_target([\\"a\\", \\"b\\", \\"ab\\"], \\"abc\\") == False def test_can_construct_target_with_no_words(): assert can_construct_target([], \\"abc\\") == False def test_can_construct_target_with_empty_target(): assert can_construct_target([\\"a\\", \\"b\\", \\"c\\"], \\"\\") == True def test_can_construct_target_with_large_input(): assert can_construct_target([\\"ab\\", \\"cd\\", \\"ef\\", \\"abcd\\"], \\"abcdefabcd\\") == True assert can_construct_target([\\"ab\\", \\"cd\\", \\"ef\\", \\"abcd\\"], \\"abcdefg\\") == False","solution":"def can_construct_target(words, target): Determine if the target string can be constructed by concatenating any subset of the strings in words. Parameters: words (list of str): Array of strings available for concatenation. target (str): The target string to be constructed. Returns: bool: True if the target can be constructed, False otherwise. def can_construct(remaining_target, memo): if remaining_target == \\"\\": return True if remaining_target in memo: return memo[remaining_target] for word in words: if remaining_target.startswith(word): suffix = remaining_target[len(word):] if can_construct(suffix, memo): memo[remaining_target] = True return True memo[remaining_target] = False return False memo = {} return can_construct(target, memo)"},{"question":"def min_cuts_to_increasing_segment(heights: List[int]) -> int: Returns the minimum number of trees that need to be cut down to create a continuous segment of trees with strictly increasing heights. >>> min_cuts_to_increasing_segment([3]) == 0 >>> min_cuts_to_increasing_segment([]) == 0 >>> min_cuts_to_increasing_segment([1, 2, 3, 4, 5]) == 0 >>> min_cuts_to_increasing_segment([5, 1, 2, 3, 4]) == 1 >>> min_cuts_to_increasing_segment([5, 1, 2, 3, 7, 4, 5]) == 2 >>> min_cuts_to_increasing_segment([1, 3, 2, 4, 6, 5, 7]) == 2 >>> min_cuts_to_increasing_segment([5, 4, 3, 2, 1]) == 4","solution":"def min_cuts_to_increasing_segment(heights): Returns the minimum number of trees that need to be cut down to create a continuous segment of trees with strictly increasing heights. n = len(heights) if n == 0: return 0 # Create LIS and LDS arrays lis = [1] * n for i in range(1, n): for j in range(i): if heights[i] > heights[j]: lis[i] = max(lis[i], lis[j] + 1) lds = [1] * n for i in range(n-2, -1, -1): for j in range(i+1, n): if heights[i] < heights[j]: lds[i] = max(lds[i], lds[j] + 1) max_increasing_segment = 0 for i in range(n): max_increasing_segment = max(max_increasing_segment, lis[i] + lds[i] - 1) return n - max_increasing_segment"},{"question":"from collections import deque from typing import List def level_order_traversal(adj: List[List[int]]) -> List[List[int]]: Given a k-ary tree represented as an adjacency list adj, performs a level order traversal and returns the levels as a list of lists. Parameters: adj (List[List[int]]): Adjacency list representing the k-ary tree. Returns: List[List[int]]: Level order traversal of the tree. pass def test_simple_tree(): adj = [[1, 2], [], []] assert level_order_traversal(adj) == [[0], [1, 2]] def test_unbalanced_tree(): adj = [[1], [2], [3], []] assert level_order_traversal(adj) == [[0], [1], [2], [3]] def test_multiple_children(): adj = [[1, 2, 3], [], [], []] assert level_order_traversal(adj) == [[0], [1, 2, 3]] def test_single_node_tree(): adj = [[]] assert level_order_traversal(adj) == [[0]] def test_empty_tree(): adj = [] assert level_order_traversal(adj) == [] def test_full_tree(): adj = [[1, 2], [3, 4], [5, 6], [], [], [], []] assert level_order_traversal(adj) == [[0], [1, 2], [3, 4, 5, 6]]","solution":"from collections import deque def level_order_traversal(adj): Given a k-ary tree represented as an adjacency list adj, performs a level order traversal and returns the levels as a list of lists. Parameters: adj (List[List[int]]): Adjacency list representing the k-ary tree. Returns: List[List[int]]: Level order traversal of the tree. if not adj: return [] result = [] queue = deque([0]) # Start with the root node (0) while queue: level_size = len(queue) level_nodes = [] for _ in range(level_size): node = queue.popleft() level_nodes.append(node) for child in adj[node]: queue.append(child) result.append(level_nodes) return result"},{"question":"def max_water_trapped(nums: List[int]) -> int: Returns the maximum amount of water that can be trapped between two buildings. >>> max_water_trapped([1, 8, 6, 2, 5, 4, 8, 3, 7]) 49 >>> max_water_trapped([5, 5, 5, 5, 5]) 20 >>> max_water_trapped([5, 4, 3, 2, 1]) 6 >>> max_water_trapped([1, 2, 3, 4, 5]) 6 >>> max_water_trapped([5]) 0 >>> max_water_trapped([3, 4]) 3 >>> max_water_trapped([]) 0 >>> max_water_trapped([1, 2, 4, 4, 2, 1]) 6","solution":"def max_water_trapped(nums): Returns the maximum amount of water that can be trapped between two buildings. left, right = 0, len(nums) - 1 max_water = 0 while left < right: height = min(nums[left], nums[right]) width = right - left max_water = max(max_water, height * width) if nums[left] < nums[right]: left += 1 else: right -= 1 return max_water"},{"question":"def canAttendAllMeetings(meetings): Determine if a person can attend all given meetings without any overlap. :param meetings: List of tuples, each containing two integers (start, end) representing meeting times. :return: True if the person can attend all meetings without overlap, otherwise False. Examples: >>> canAttendAllMeetings([(0, 30), (5, 10), (15, 20)]) False >>> canAttendAllMeetings([(5, 8), (9, 15)]) True from solution import canAttendAllMeetings def test_no_overlap(): assert canAttendAllMeetings([(0, 1), (2, 3), (4, 5)]) == True def test_overlap_between_adjacent_meetings(): assert canAttendAllMeetings([(0, 5), (3, 9)]) == False def test_single_meeting(): assert canAttendAllMeetings([(0, 5)]) == True def test_immediate_consecutive_meetings(): assert canAttendAllMeetings([(0, 1), (1, 2), (2, 3)]) == True def test_meetings_with_gap(): assert canAttendAllMeetings([(0, 1), (2, 3), (5, 10)]) == True def test_complex_case_with_overlap(): assert canAttendAllMeetings([(0, 30), (5, 10), (15, 20)]) == False def test_complex_case_without_overlap(): assert canAttendAllMeetings([(5, 8), (9, 15)]) == True","solution":"def canAttendAllMeetings(meetings): Determine if a person can attend all given meetings without any overlap. :param meetings: List of tuples, each containing two integers (start, end) representing meeting times. :return: True if the person can attend all meetings without overlap, otherwise False. # Sort meetings by their start time meetings.sort(key=lambda x: x[0]) for i in range(1, len(meetings)): # If the start time of the current meeting is less than the end time of the previous meeting, there's overlap if meetings[i][0] < meetings[i - 1][1]: return False return True"},{"question":"def min_replacements(s: str) -> int: Returns the minimum number of replacements needed to ensure that no three consecutive characters in the string are the same. >>> min_replacements(\\"abcabcabc\\") == 0 >>> min_replacements(\\"aaabbbccc\\") == 3 >>> min_replacements(\\"aaa\\") == 1 >>> min_replacements(\\"ababaaaaabbbccc\\") == 3 >>> min_replacements(\\"aabbcc\\") == 0 >>> min_replacements(\\"aaaab\\") == 1 >>> min_replacements(\\"baaaac\\") == 1 >>> min_replacements(\\"abc\\") == 0 >>> min_replacements(\\"a\\") == 0 >>> min_replacements(\\"aa\\") == 0","solution":"def min_replacements(s): Returns the minimum number of replacements needed to ensure that no three consecutive characters in the string are the same. replacements = 0 i = 0 n = len(s) while i < n - 2: # If we find three consecutive characters the same if s[i] == s[i+1] == s[i+2]: # We need to replace one of these replacements += 1 # Skipping next two, since we already handled replacement i += 3 else: i += 1 return replacements"},{"question":"def minAddToMakeValid(s: str) -> int: Given a string s consisting of open and closed parentheses, return the minimum number of parentheses you must add to make s valid. A string is valid if it is correctly balanced, meaning every open parenthesis has a corresponding closed parenthesis and they are correctly nested. >>> minAddToMakeValid(\\"()\\") == 0 >>> minAddToMakeValid(\\"(())\\") == 0 >>> minAddToMakeValid(\\"()()\\") == 0 >>> minAddToMakeValid(\\")(\\") == 2 >>> minAddToMakeValid(\\"(()\\") == 1 >>> minAddToMakeValid(\\"(()))\\") == 1 >>> minAddToMakeValid(\\"))\\") == 2 >>> minAddToMakeValid(\\"(((\\") == 3 >>> minAddToMakeValid(\\"())(\\") == 2 >>> minAddToMakeValid(\\"((())\\") == 1 >>> minAddToMakeValid(\\"())(()\\") == 2 >>> minAddToMakeValid(\\"(()))(()\\") == 2 >>> minAddToMakeValid(\\"\\") == 0","solution":"def minAddToMakeValid(s): Returns the minimum number of parentheses to add to make the string valid. open_count = 0 close_count = 0 for char in s: if char == '(': open_count += 1 elif char == ')': if open_count > 0: open_count -= 1 else: close_count += 1 return open_count + close_count"},{"question":"def min_operations(original: List[int], modified: List[int], k: int) -> int: Return the minimum number of operations required to transform 'original' to 'modified' by flipping subarrays of length 'k'. If transformation is not possible, return -1. >>> min_operations([0, 1, 0, 1], [1, 0, 1, 0], 2) 2 >>> min_operations([0, 0, 0], [1, 0, 0], 1) 1 >>> min_operations([1, 1, 1], [0, 0, 0], 2) -1 >>> min_operations([1, 0, 1, 0], [1, 0, 1, 0], 3) 0 >>> min_operations([0, 0, 0, 0, 0], [1, 1, 0, 0, 0], 2) 1 >>> min_operations([0, 0, 0, 0], [1, 1, 1, 1], 4) 1","solution":"def min_operations(original, modified, k): n = len(original) flips = 0 flip_operation = [0] * n flip_count = 0 for i in range(n): if i >= k: flip_count ^= flip_operation[i - k] if (original[i] ^ flip_count) != modified[i]: if i + k > n: return -1 flip_operation[i] = 1 flip_count ^= 1 flips += 1 return flips"},{"question":"def canAttendMeetings(intervals): Returns True if a person can attend all meetings without any overlaps, False otherwise. >>> canAttendMeetings([[0, 30], [35, 50], [55, 60]]) True >>> canAttendMeetings([[0, 30], [25, 40], [50, 60]]) False >>> canAttendMeetings([[0, 30], [30, 40], [40, 50]]) True >>> canAttendMeetings([[0, 30], [0, 30], [30, 60]]) False >>> canAttendMeetings([]) True >>> canAttendMeetings([[0, 30]]) True","solution":"def canAttendMeetings(intervals): Returns True if a person can attend all meetings without any overlaps, False otherwise. # Sort the intervals by start time intervals.sort(key=lambda x: x[0]) # Check for any overlaps for i in range(1, len(intervals)): if intervals[i][0] < intervals[i-1][1]: return False return True"},{"question":"def min_moves_to_alternating_vowels_consonants(s: str) -> int: Returns the minimum number of moves required to make the string s alternating vowels and consonants. >>> min_moves_to_alternating_vowels_consonants(\\"\\") 0 >>> min_moves_to_alternating_vowels_consonants(\\"a\\") 0 >>> min_moves_to_alternating_vowels_consonants(\\"b\\") 0 >>> min_moves_to_alternating_vowels_consonants(\\"aeiou\\") 2 >>> min_moves_to_alternating_vowels_consonants(\\"bcdfg\\") 2 >>> min_moves_to_alternating_vowels_consonants(\\"abecidofu\\") 0 >>> min_moves_to_alternating_vowels_consonants(\\"bacadegofu\\") 0 >>> min_moves_to_alternating_vowels_consonants(\\"hello\\") 2 >>> min_moves_to_alternating_vowels_consonants(\\"testing\\") 3","solution":"def min_moves_to_alternating_vowels_consonants(s): Returns the minimum number of moves required to make the string s alternating vowels and consonants. vowels = {'a', 'e', 'i', 'o', 'u'} if not s: return 0 def is_vowel(char): return char in vowels def check_and_count(start_with_vowel): Check and count the number of moves needed if the alternation starts with a vowel or a consonant. moves = 0 for i, char in enumerate(s): if i % 2 == 0: # supposed to be vowel or consonant based on start_with_vowel flag if start_with_vowel and not is_vowel(char): moves += 1 elif not start_with_vowel and is_vowel(char): moves += 1 else: # supposed to be consonant or vowel based on start_with_vowel flag if start_with_vowel and is_vowel(char): moves += 1 elif not start_with_vowel and not is_vowel(char): moves += 1 return moves start_with_vowel_moves = check_and_count(True) start_with_consonant_moves = check_and_count(False) # Choose the minimum of two scenarios return min(start_with_vowel_moves, start_with_consonant_moves)"},{"question":"def max_number_of_teams(heights, k): Returns the maximum number of teams of exactly k consecutive students where heights are strictly increasing. :param heights: The list of heights of students. :param k: The number of consecutive students in a team. :return: The maximum number of such teams. >>> max_number_of_teams([1, 2, 3], 3) 1 >>> max_number_of_teams([1, 2, 3, 2, 3, 4], 3) 2 >>> max_number_of_teams([3, 2, 1], 2) 0 >>> max_number_of_teams([5, 4, 3, 2, 1], 1) 5 >>> max_number_of_teams([1, 3, 5, 7, 6, 2, 8, 10], 2) 5 >>> max_number_of_teams([], 2) 0 >>> max_number_of_teams([1, 2], 3) 0","solution":"def max_number_of_teams(heights, k): Returns the maximum number of teams of exactly k consecutive students where heights are strictly increasing. :param heights: The list of heights of students. :param k: The number of consecutive students in a team. :return: The maximum number of such teams. if k == 1: return len(heights) max_teams = 0 n = len(heights) for i in range(n - k + 1): is_valid_team = True for j in range(i, i + k - 1): if heights[j] >= heights[j + 1]: is_valid_team = False break if is_valid_team: max_teams += 1 return max_teams"},{"question":"def insert_spaces(s: str) -> str: Inserts exactly one space between each pair of adjacent letters that are different cases. :param s: Input string containing both lowercase and uppercase letters. :return: Modified string with spaces inserted between letters of different cases. >>> insert_spaces(\\"aBcDeF\\") == \\"a B c D e F\\" >>> insert_spaces(\\"abc\\") == \\"abc\\" >>> insert_spaces(\\"ABC\\") == \\"ABC\\" >>> insert_spaces(\\"aA\\") == \\"a A\\" >>> insert_spaces(\\"aBcDeFgHiJ\\") == \\"a B c D e F g H i J\\" >>> insert_spaces(\\"a\\") == \\"a\\" >>> insert_spaces(\\"A\\") == \\"A\\" >>> insert_spaces(\\"abCdeF\\") == \\"ab C de F\\"","solution":"def insert_spaces(s): Inserts exactly one space between each pair of adjacent letters that are different cases. :param s: Input string containing both lowercase and uppercase letters. :return: Modified string with spaces inserted between letters of different cases. result = [] for i in range(len(s)): if i > 0 and ((s[i].islower() and s[i-1].isupper()) or (s[i].isupper() and s[i-1].islower())): result.append(' ') result.append(s[i]) return ''.join(result)"},{"question":"def can_partition(nums: List[int]) -> bool: Determine if the given list of numbers can be partitioned into two subsets such that the sum of the subsets is equal. :param nums: List[int] - The list of even length integers. :return: bool - True if such a partition is possible, False otherwise. >>> can_partition([1, 5, 11, 5]) True >>> can_partition([1, 2, 3, 4]) True >>> can_partition([1, 2, 3, 5]) False >>> can_partition([1, 1]) True >>> can_partition([100, 200, 300, 400, 500, 600]) False >>> can_partition([0, 0, 0, 0]) True >>> can_partition([2, 2, 2, 2]) True >>> can_partition([1, 1, 3, 4]) False","solution":"def can_partition(nums): Determine if the given list of numbers can be partitioned into two subsets such that the sum of the subsets is equal. :param nums: List[int] - The list of even length integers. :return: bool - True if such a partition is possible, False otherwise. total_sum = sum(nums) # If total sum is odd, can't partition into two equal subsets if total_sum % 2 != 0: return False target = total_sum // 2 n = len(nums) # Initialize the DP array dp = [False] * (target + 1) dp[0] = True # Process each number for num in nums: for j in range(target, num - 1, -1): dp[j] = dp[j] or dp[j - num] return dp[target]"},{"question":"def count_people_in_front_with_greater_or_equal_height(heights: List[int]) -> List[int]: Given a 0-indexed array heights where heights[i] represents the height of the i-th person in a line, return a new array of the same length where each index i contains the number of people in front of the i-th person who have a height greater than or equal to heights[i]. A person P is considered \\"in front\\" of person Q if P appears at a lower index than Q in the array. >>> count_people_in_front_with_greater_or_equal_height([5, 5, 5, 5]) == [0, 1, 2, 3] >>> count_people_in_front_with_greater_or_equal_height([1, 2, 3, 4]) == [0, 0, 0, 0] >>> count_people_in_front_with_greater_or_equal_height([4, 3, 2, 1]) == [0, 1, 2, 3] >>> count_people_in_front_with_greater_or_equal_height([3, 1, 4, 2]) == [0, 1, 0, 2] >>> count_people_in_front_with_greater_or_equal_height([5]) == [0] >>> count_people_in_front_with_greater_or_equal_height([]) == []","solution":"def count_people_in_front_with_greater_or_equal_height(heights): Returns a list where each index contains number of people in front with height >= heights[i] result = [0] * len(heights) for i in range(1, len(heights)): count = 0 for j in range(i): if heights[j] >= heights[i]: count += 1 result[i] = count return result"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_unival_tree(root): Determines if the binary tree is uni-valued (all nodes have the same value). :param root: TreeNode, the root of the binary tree :return: bool, True if the binary tree is uni-valued, False otherwise >>> is_unival_tree(TreeNode(0, TreeNode(0), TreeNode(0))) True >>> is_unival_tree(TreeNode(1, TreeNode(1, TreeNode(1)), TreeNode(1))) True >>> is_unival_tree(TreeNode(1, TreeNode(1), TreeNode(0))) False >>> is_unival_tree(TreeNode(1)) True >>> is_unival_tree(None) True","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_unival_tree(root): Determines if the binary tree is uni-valued (all nodes have the same value). :param root: TreeNode, the root of the binary tree :return: bool, True if the binary tree is uni-valued, False otherwise if not root: return True def dfs(node): if not node: return True if node.val != root.val: return False return dfs(node.left) and dfs(node.right) return dfs(root)"},{"question":"def wiggleSort(nums): Rearranges the elements of the array in such a way that they form an alternating sequence of peaks and valleys. >>> nums = [3, 5, 2, 1, 6, 4] >>> wiggleSort(nums) >>> for i in range(0, len(nums) - 1, 2): >>> assert nums[i] <= nums[i + 1] >>> if i + 2 < len(nums): >>> assert nums[i + 1] >= nums[i + 2] >>> nums = [1, 2, 2, 3, 3, 4, 4] >>> wiggleSort(nums) >>> for i in range(0, len(nums) - 1, 2): >>> assert nums[i] <= nums[i + 1] >>> if i + 2 < len(nums): >>> assert nums[i + 1] >= nums[i + 2] >>> nums = [4, 4, 4, 4, 4] >>> wiggleSort(nums) >>> for i in range(0, len(nums) - 1, 2): >>> assert nums[i] <= nums[i + 1] >>> if i + 2 < len(nums): >>> assert nums[i + 1] >= nums[i + 2] >>> nums = [1, 2, 3, 4, 5, 6, 7] >>> wiggleSort(nums) >>> for i in range(0, len(nums) - 1, 2): >>> assert nums[i] <= nums[i + 1] >>> if i + 2 < len(nums): >>> assert nums[i + 1] >= nums[i + 2] >>> nums = [7, 6, 5, 4, 3, 2, 1] >>> wiggleSort(nums) >>> for i in range(0, len(nums) - 1, 2): >>> assert nums[i] <= nums[i + 1] >>> if i + 2 < len(nums): >>> assert nums[i + 1] >= nums[i + 2] >>> nums = [1] >>> wiggleSort(nums) >>> assert nums == [1] >>> nums = [2, 1] >>> wiggleSort(nums) >>> assert nums == [1, 2]","solution":"def wiggleSort(nums): Rearranges the elements of the array in such a way that they form an alternating sequence of peaks and valleys. for i in range(len(nums) - 1): if (i % 2 == 0 and nums[i] > nums[i + 1]) or (i % 2 == 1 and nums[i] < nums[i + 1]): # Swap elements to meet the condition nums[i], nums[i + 1] = nums[i + 1], nums[i]"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def max_alternating_path_length(root): Given a binary tree where each node contains a 0 or 1, find the maximum length of an alternating path. An alternating path is defined as a path where the values of the nodes in the path alternate between 0 and 1. Args: root (TreeNode): The root of the binary tree. Returns: int: The maximum length of an alternating path in the tree. >>> root = TreeNode(0) >>> root.left = TreeNode(1) >>> root.right = TreeNode(0) >>> root.left.left = TreeNode(0) >>> root.left.right = TreeNode(1) >>> max_alternating_path_length(root) 3 >>> root = TreeNode(0) >>> root.left = TreeNode(0) >>> root.right = TreeNode(0) >>> max_alternating_path_length(root) 1 >>> root = TreeNode(1) >>> max_alternating_path_length(root) 1 >>> root = None >>> max_alternating_path_length(root) 0","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def max_alternating_path_length(root): def dfs(node, prev_val, length): if not node: return length if node.val != prev_val: left_len = dfs(node.left, node.val, length + 1) right_len = dfs(node.right, node.val, length + 1) return max(left_len, right_len) else: left_len = dfs(node.left, node.val, 0) right_len = dfs(node.right, node.val, 0) return length if not root: return 0 left_max = dfs(root.left, root.val, 1) right_max = dfs(root.right, root.val, 1) return max(left_max, right_max)"},{"question":"def can_form_palindrome(s: str) -> bool: Determines if a given string can be rearranged to form a palindrome. >>> can_form_palindrome(\\"A man a plan a canal Panama\\") True >>> can_form_palindrome(\\"racecar\\") True >>> can_form_palindrome(\\"hello\\") False >>> can_form_palindrome(\\"\\") True >>> can_form_palindrome(\\"a\\") True >>> can_form_palindrome(\\"aabb\\") True >>> can_form_palindrome(\\"abcba\\") True >>> can_form_palindrome(\\"Able was I ere I saw Elba\\") True >>> can_form_palindrome(\\"No 'x' in Nixon\\") True >>> can_form_palindrome(\\"This is not a palindrome\\") False","solution":"def can_form_palindrome(s): Determines if a given string can be rearranged to form a palindrome. :param s: Input string to check :return: True if the string can be rearranged to form a palindrome, False otherwise # Normalize the string: remove spaces, punctuations, and convert to lowercase normalized_str = ''.join(char.lower() for char in s if char.isalnum()) # Count the frequency of each character char_count = {} for char in normalized_str: char_count[char] = char_count.get(char, 0) + 1 # A string can form a palindrome if at most one character has an odd frequency odd_count = 0 for count in char_count.values(): if count % 2 != 0: odd_count += 1 return odd_count <= 1"},{"question":"def pivot_array(arr: List[int], pivot: int) -> List[int]: Rearranges array elements such that all elements less than pivot come first, followed by elements equal to pivot, then elements greater than pivot. The relative order within each group is maintained. :param arr: List of integers to be rearranged. :param pivot: The pivot value against which the arrangement is done. :return: Rearranged array. >>> pivot_array([1, 2, 3], 4) [1, 2, 3] >>> pivot_array([5, 6, 7], 4) [5, 6, 7] >>> pivot_array([1, 4, 2, 3, 5, 6, 4], 4) [1, 2, 3, 4, 4, 5, 6] >>> pivot_array([1, 3, 5, 7], 4) [1, 3, 5, 7] >>> pivot_array([3, -1, 2, 0, -3, 1], 0) [-1, -3, 0, 3, 2, 1] >>> pivot_array([], 4) [] >>> pivot_array([3], 3) [3] >>> pivot_array([3], 4) [3] >>> pivot_array([3], 2) [3]","solution":"def pivot_array(arr, pivot): Rearranges array elements such that all elements less than pivot come first, followed by elements equal to pivot, then elements greater than pivot. The relative order within each group is maintained. :param arr: List of integers to be rearranged. :param pivot: The pivot value against which the arrangement is done. :return: Rearranged array. less_than = [x for x in arr if x < pivot] equal_to = [x for x in arr if x == pivot] greater_than = [x for x in arr if x > pivot] return less_than + equal_to + greater_than"},{"question":"def minimum_sum_after_k_removals(nums, k): Returns the minimum possible sum of the elements left in the array after performing the removal operation exactly k times. >>> minimum_sum_after_k_removals([4, 3, 2, 10, 12], 2) 26 >>> minimum_sum_after_k_removals([1, 2, 3, 4, 5], 1) 14 >>> minimum_sum_after_k_removals([7, 3, 8, 5, 6], 3) 15 >>> minimum_sum_after_k_removals([2, 2, 2, 2, 2], 3) 4 >>> minimum_sum_after_k_removals([100, 1, 50, 75, 25], 2) 225","solution":"def minimum_sum_after_k_removals(nums, k): Returns the minimum possible sum of the elements left in the array after performing the removal operation exactly k times. nums.sort() # Sort the array to maximize the sum of removed subsequences return sum(nums[k:]) # Sum of the elements left after removing k smallest elements # Example usage: # nums = [4, 3, 2, 10, 12] # k = 2 # This returns 25 because the sum of the remaining numbers after removing the two smallest (2 and 3) is 4 + 10 + 12 = 26 # print(minimum_sum_after_k_removals(nums, k))"},{"question":"from typing import List def three_sum(nums: List[int]) -> List[List[int]]: Given a list of distinct integers, find all unique triplets in the list which give the sum of zero. Each triplet should be ordered such that nums[a] < nums[b] < nums[c] and a < b < c. Triplets should be returned in lexicographical order. >>> three_sum([-1, 0, 1, 2, -1, -4]) [[-1, -1, 2], [-1, 0, 1]] >>> three_sum([]) [] >>> three_sum([1, 2, 3, 4]) [] >>> three_sum([0, 0, 0, 0]) [[0, 0, 0]] >>> three_sum([-2, 0, 1, 1, 2]) [[-2, 0, 2], [-2, 1, 1]] >>> three_sum([-1, -1, -1, 2, 2, 2]) [[-1, -1, 2]]","solution":"def three_sum(nums): Returns all unique triplets in the list which give the sum of zero. The triplets are returned in lexicographical order. nums.sort() result = [] n = len(nums) for i in range(n-2): if i > 0 and nums[i] == nums[i-1]: continue l, r = i+1, n-1 while l < r: total = nums[i] + nums[l] + nums[r] if total == 0: result.append([nums[i], nums[l], nums[r]]) while l < r and nums[l] == nums[l+1]: l += 1 while l < r and nums[r] == nums[r-1]: r -= 1 l += 1 r -= 1 elif total < 0: l += 1 else: r -= 1 # Sort the result list lexicographically result.sort() return result"},{"question":"class ListNode: def __init__(self, x): self.val = x self.next = None def hasCycle(head): Determine if the linked list has a cycle in it. Returns true if there is a cycle in the linked list, otherwise false. >>> node1 = ListNode(1) >>> node2 = ListNode(2) >>> node1.next = node2 >>> node2.next = node1 >>> hasCycle(node1) True >>> node1 = ListNode(1) >>> node2 = ListNode(2) >>> node1.next = node2 >>> hasCycle(node1) False","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def hasCycle(head): Returns true if there is a cycle in the linked list, otherwise false. slow = head fast = head while fast is not None and fast.next is not None: slow = slow.next fast = fast.next.next if slow == fast: return True return False"},{"question":"def max_consecutive_ones(s: str) -> int: Returns the maximum number of consecutive '1's obtainable by flipping exactly one '0' to '1' in the string s. >>> max_consecutive_ones(\\"1111\\") == 4 >>> max_consecutive_ones(\\"0\\") == 1 >>> max_consecutive_ones(\\"1\\") == 1 >>> max_consecutive_ones(\\"1110111\\") == 7 >>> max_consecutive_ones(\\"000001000\\") == 2 >>> max_consecutive_ones(\\"111111\\") == 6 >>> max_consecutive_ones(\\"101010\\") == 3 >>> max_consecutive_ones(\\"\\") == 0","solution":"def max_consecutive_ones(s): Returns the maximum number of consecutive '1's obtainable by flipping exactly one '0' to '1' in the string s. # Edge case: empty string if not s: return 0 n = len(s) max_ones = 0 zero_count = 0 left = 0 for right in range(n): if s[right] == '0': zero_count += 1 while zero_count > 1: if s[left] == '0': zero_count -= 1 left += 1 max_ones = max(max_ones, right - left + 1) return max_ones"},{"question":"from typing import List, Tuple import heapq def min_meeting_rooms(projects: List[Tuple[int, int]]) -> int: Determines the minimum number of meeting rooms required for the list of projects. Parameters: projects (list of tuple): A list of projects where each project is represented as (start_time, end_time) Returns: int: The minimum number of meeting rooms required >>> min_meeting_rooms([(1, 4), (2, 5), (7, 8)]) 2 >>> min_meeting_rooms([(1, 2), (2, 3), (3, 4)]) 1 >>> min_meeting_rooms([(1, 5), (2, 6), (3, 7), (4, 8)]) 4 >>> min_meeting_rooms([(1, 10), (2, 7), (3, 5), (6, 10)]) 3 >>> min_meeting_rooms([(1, 4), (2, 4), (3, 4), (4, 4)]) 3 >>> min_meeting_rooms([(1, 4), (6, 7), (9, 10)]) 1 >>> min_meeting_rooms([]) 0 pass","solution":"import heapq def min_meeting_rooms(projects): Determines the minimum number of meeting rooms required for the list of projects. Parameters: projects (list of tuple): A list of projects where each project is represented as (start_time, end_time) Returns: int: The minimum number of meeting rooms required if not projects: return 0 # Initialize a min heap. heap = [] for project in projects: start_time, end_time = project # If the earliest end time in heap is less than or equal to the start time of current project, # free up that room (remove the end_time from heap) if heap and heap[0] <= start_time: heapq.heappop(heap) # Add the current project end time into the heap heapq.heappush(heap, end_time) # The size of the heap will tell us the number of meeting rooms required. return len(heap)"},{"question":"def longest_substring_after_replacements(s, k): Given a string \`s\` and an integer \`k\`, returns the length of the longest substring with all identical characters after replacing exactly \`k\` characters in \`s\` with any lowercase letter. >>> longest_substring_after_replacements(\\"aabbcc\\", 2) 4 >>> longest_substring_after_replacements(\\"aaaa\\", 2) 4 >>> longest_substring_after_replacements(\\"abcde\\", 2) 3 >>> longest_substring_after_replacements(\\"a\\", 1) 1 >>> longest_substring_after_replacements(\\"aabbcc\\", 6) 6","solution":"def longest_substring_after_replacements(s, k): Returns the length of the longest substring with all identical characters after replacing exactly k characters in the string s. # Frequency map of character count = {} max_len = 0 left = 0 for right in range(len(s)): count[s[right]] = count.get(s[right], 0) + 1 # Window size current_window_size = right - left + 1 if (current_window_size - max(count.values())) <= k: max_len = max(max_len, current_window_size) else: # If the condition fails, shrink the window count[s[left]] -= 1 left += 1 return max_len"},{"question":"def longest_unique_subarray_length(arr: List[int]) -> int: Returns the length of the longest subarray consisting only of unique elements. If there are multiple subarrays with the same maximum length, return the one that appears first. >>> longest_unique_subarray_length([]) == 0 >>> longest_unique_subarray_length([1]) == 1 >>> longest_unique_subarray_length([1, 2, 3, 4, 5]) == 5 >>> longest_unique_subarray_length([1, 1, 1, 1]) == 1 >>> longest_unique_subarray_length([1, 2, 3, 2, 1, 4, 5]) == 5 >>> longest_unique_subarray_length([1, 2, 3, 4, 5, 1, 2, 3, 4]) == 5 >>> longest_unique_subarray_length([1, 2, 1, 3, 4, 3, 5]) == 4","solution":"def longest_unique_subarray_length(arr): Returns the length of the longest subarray consisting only of unique elements. If there are multiple subarrays with the same maximum length, return the one that appears first. if not arr: return 0 seen = {} max_len = 0 start = 0 for end, value in enumerate(arr): if value in seen: start = max(start, seen[value] + 1) seen[value] = end max_len = max(max_len, end - start + 1) return max_len"},{"question":"class TextEditor: You are implementing a text editor that includes a version history feature. Each time a modification is made to the document, the state should be saved as a new version. Users can also undo changes to revert to a previous version of the document. - \`TextEditor()\` Initializes the text editor with an empty document. - \`type(content: str)\` Appends \`content\` to the end of the document. - \`undo()\` Reverts the document to the previous version. If there are no previous versions, the document remains unchanged. - \`currentVersion() -> str\` Returns the current state of the document. If the document is empty, return an empty string. >>> editor = TextEditor() >>> editor.currentVersion() == \\"\\" >>> editor.type(\\"Hello\\") >>> editor.currentVersion() == \\"Hello\\" >>> editor.type(\\" World\\") >>> editor.currentVersion() == \\"Hello World\\" >>> editor.undo() >>> editor.currentVersion() == \\"Hello\\" >>> editor.undo() >>> editor.currentVersion() == \\"\\" >>> editor.undo() >>> editor.currentVersion() == \\"\\" def __init__(self): pass def type(self, content): pass def undo(self): pass def currentVersion(self): pass","solution":"class TextEditor: def __init__(self): self.versions = [\\"\\"] # Initial state with empty document self.current_index = 0 def type(self, content): current_version = self.versions[self.current_index] + content self.versions = self.versions[:self.current_index + 1] # Discard future versions self.versions.append(current_version) self.current_index += 1 def undo(self): if self.current_index > 0: self.current_index -= 1 def currentVersion(self): return self.versions[self.current_index]"},{"question":"def trap_water(heights: List[int]) -> int: Calculate the total amount of trapped water between the buildings. Args: heights (List[int]): list of heights of the buildings Returns: int: total amount of trapped water >>> trap_water([]) == 0 True >>> trap_water([1, 1, 1, 1]) == 0 True >>> trap_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 True >>> trap_water([5, 4, 3, 2, 1]) == 0 True >>> trap_water([1, 2, 3, 4, 5]) == 0 True >>> trap_water([3, 0, 1, 3, 0, 5]) == 8 True","solution":"def trap_water(heights): Calculate the total amount of trapped water between the buildings. Args: heights (List[int]): list of heights of the buildings Returns: int: total amount of trapped water if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n trapped_water = 0 left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) for i in range(n): trapped_water += min(left_max[i], right_max[i]) - heights[i] return trapped_water"},{"question":"from collections import Counter def min_deletions_to_equalize(s: str) -> int: Given a string \`s\` consisting only of characters 'a', 'b', and 'c', remove the minimum number of characters such that each character appears the same number of times. Return the length of the resultant string after deletions. >>> min_deletions_to_equalize('aaabbbccc') 9 >>> min_deletions_to_equalize('aaabbcc') 6","solution":"from collections import Counter def min_deletions_to_equalize(s): Returns the length of the resultant string after performing the minimal deletions so that each character ('a', 'b', 'c') appears the same number of times. counter = Counter(s) # Find the minimum frequency among 'a', 'b', 'c' min_freq = min(counter.get('a', 0), counter.get('b', 0), counter.get('c', 0)) # Calculate the length of the resultant string result_length = 3 * min_freq return result_length"},{"question":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None class BinaryTree: def __init__(self): # Initialize the tree with the root node having value 1 self.root = TreeNode(1) self.nodes = {1: self.root} def addNode(self, parent, child, direction): Adds a new node with value \`child\` as a left or right child of the node with value \`parent\`. The direction is specified by the string \`direction\`, which can be either \\"left\\" or \\"right\\". It is guaranteed that parent already exists and child does not exist in the tree. def getPath(self, node): Returns a list of node values representing the path from the root to the node with value \`node\`. If the node does not exist, return an empty list. # Unit Test def test_add_and_get_path(): bt = BinaryTree() bt.addNode(1, 2, \\"left\\") bt.addNode(1, 3, \\"right\\") bt.addNode(2, 4, \\"left\\") bt.addNode(2, 5, \\"right\\") assert bt.getPath(1) == [1] assert bt.getPath(2) == [1, 2] assert bt.getPath(3) == [1, 3] assert bt.getPath(4) == [1, 2, 4] assert bt.getPath(5) == [1, 2, 5] def test_get_path_node_not_exist(): bt = BinaryTree() bt.addNode(1, 2, \\"left\\") bt.addNode(1, 3, \\"right\\") assert bt.getPath(10) == [] def test_add_and_get_path_complex(): bt = BinaryTree() bt.addNode(1, 2, \\"left\\") bt.addNode(1, 3, \\"right\\") bt.addNode(2, 4, \\"left\\") bt.addNode(2, 5, \\"right\\") bt.addNode(3, 6, \\"left\\") bt.addNode(3, 7, \\"right\\") bt.addNode(6, 8, \\"left\\") assert bt.getPath(8) == [1, 3, 6, 8] assert bt.getPath(7) == [1, 3, 7] def test_add_node_twice(): bt = BinaryTree() bt.addNode(1, 2, \\"left\\") # Testing for the addition of already existing node should raise an error. try: bt.addNode(2, 2, \\"right\\") assert False, \\"Expected an exception for adding an existing node\\" except Exception: pass","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None class BinaryTree: def __init__(self): # Initialize the tree with the root node having value 1 self.root = TreeNode(1) self.nodes = {1: self.root} def addNode(self, parent, child, direction): Adds a new node with value \`child\` as a left or right child of the node with value \`parent\`. The direction is specified by the string \`direction\`, which can be either \\"left\\" or \\"right\\". It is guaranteed that parent already exists and child does not exist in the tree. if parent in self.nodes: parent_node = self.nodes[parent] new_node = TreeNode(child) if direction == \\"left\\": parent_node.left = new_node elif direction == \\"right\\": parent_node.right = new_node self.nodes[child] = new_node def getPath(self, node): Returns a list of node values representing the path from the root to the node with value \`node\`. If the node does not exist, return an empty list. def dfs(current, target, path): if not current: return False path.append(current.value) if current.value == target: return True # Recurse on left and right if dfs(current.left, target, path) or dfs(current.right, target, path): return True path.pop() return False path = [] if dfs(self.root, node, path): return path return []"},{"question":"def generate_fibonacci(n: int) -> List[int]: Generates a list of the first n Fibonacci numbers. If n is less than 1, returns an empty list. >>> generate_fibonacci(0) [] >>> generate_fibonacci(1) [0] >>> generate_fibonacci(2) [0, 1] >>> generate_fibonacci(5) [0, 1, 1, 2, 3] >>> generate_fibonacci(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]","solution":"def generate_fibonacci(n): Generates a list of the first n Fibonacci numbers. If n is less than 1, returns an empty list. if n < 1: return [] fibonacci_list = [0] if n > 1: fibonacci_list.append(1) for i in range(2, n): fibonacci_list.append(fibonacci_list[-1] + fibonacci_list[-2]) return fibonacci_list"},{"question":"def shortest_unsorted_subarray_length(arr, k): Finds the length of the shortest subarray that, when sorted, results in the entire array being sorted in non-decreasing order. If the array is already sorted, return 0. Parameters: arr (list): List of integers. k (int): Integer k (not utilized in this function but part of the function signature as per the question). Returns: int: Length of the shortest subarray to be sorted. # Your code goes here # Unit tests def test_sorted_array(): assert shortest_unsorted_subarray_length([1, 2, 3, 4, 5], 0) == 0 def test_single_element_array(): assert shortest_unsorted_subarray_length([1], 0) == 0 def test_unsorted_array(): assert shortest_unsorted_subarray_length([2, 6, 4, 8, 10, 9, 15], 0) == 5 def test_unsorted_duplicate_elements(): assert shortest_unsorted_subarray_length([1, 3, 2, 2, 2], 0) == 4 def test_partial_sorted_array(): assert shortest_unsorted_subarray_length([1, 3, 5, 4, 2], 0) == 4 def test_all_elements_the_same(): assert shortest_unsorted_subarray_length([2, 2, 2, 2, 2], 0) == 0 def test_empty_array(): assert shortest_unsorted_subarray_length([], 0) == 0 def test_already_sorted_with_duplicates(): assert shortest_unsorted_subarray_length([1, 2, 2, 2, 3, 4, 4], 0) == 0 def test_reverse_sorted_array(): assert shortest_unsorted_subarray_length([5, 4, 3, 2, 1], 0) == 5","solution":"def shortest_unsorted_subarray_length(arr, k): Finds the length of the shortest subarray that, when sorted, results in the entire array being sorted in non-decreasing order. If the array is already sorted, return 0. Parameters: arr (list): List of integers. k (int): Integer k (not utilized in this function but part of the function signature as per the question). Returns: int: Length of the shortest subarray to be sorted. n = len(arr) if n == 0: return 0 left, right = 0, n - 1 # Find the first element which is out of order from the beginning while left < n - 1 and arr[left] <= arr[left + 1]: left += 1 # If the array is already sorted if left == n - 1: return 0 # Find the first element which is out of order from the end while right > 0 and arr[right] >= arr[right - 1]: right -= 1 # Determine the min and max of the subarray that needs to be sorted subarray_max = max(arr[left:right+1]) subarray_min = min(arr[left:right+1]) # Extend the left boundary to include any numbers which are more than the min of the subarray while left > 0 and arr[left - 1] > subarray_min: left -= 1 # Extend the right boundary to include any numbers which are lower than the max of the subarray while right < n - 1 and arr[right + 1] < subarray_max: right += 1 return right - left + 1"},{"question":"def count_subarrays_with_unique_k(arr, k): Returns the count of subarrays with exactly k distinct integers. >>> count_subarrays_with_unique_k([1, 2, 1, 2, 3], 2) == 7 >>> count_subarrays_with_unique_k([1, 2, 1, 3, 4], 3) == 3 >>> count_subarrays_with_unique_k([1], 1) == 1 >>> count_subarrays_with_unique_k([1, 2, 3], 4) == 0 >>> count_subarrays_with_unique_k([1, 1, 1], 1) == 6 >>> count_subarrays_with_unique_k([1, 2, 3], 3) == 1 >>> count_subarrays_with_unique_k([], 1) == 0","solution":"def count_subarrays_with_unique_k(arr, k): Returns the count of subarrays with exactly k distinct integers. from collections import defaultdict def at_most_k_distinct(nums, k): count = 0 left = 0 freq = defaultdict(int) for right in range(len(nums)): freq[nums[right]] += 1 while len(freq) > k: freq[nums[left]] -= 1 if freq[nums[left]] == 0: del freq[nums[left]] left += 1 count += right - left + 1 return count return at_most_k_distinct(arr, k) - at_most_k_distinct(arr, k - 1)"},{"question":"def has_pair_with_sum(nums: List[int], target: int) -> bool: Determines if there exists two distinct indices i and j in the array such that nums[i] + nums[j] == target. >>> has_pair_with_sum([1, 2, 3, 4], 5) == True >>> has_pair_with_sum([1, 2, 3, 4], 6) == True >>> has_pair_with_sum([-1, -2, -3, -4], -5) == True >>> has_pair_with_sum([-1, 2, -3, 4], 1) == True >>> has_pair_with_sum([1, 0, -1], -1) == True >>> has_pair_with_sum([1, 2, 3, 4], 8) == False >>> has_pair_with_sum([1, 2, 3, 4], 10) == False >>> has_pair_with_sum([-1, -2, -3, -4], -10) == False >>> has_pair_with_sum([-1, 2, -3, 4], 8) == False >>> has_pair_with_sum([1, 0, -1], 5) == False >>> has_pair_with_sum([], 0) == False >>> has_pair_with_sum([3], 3) == False >>> has_pair_with_sum([3, 3], 6) == True","solution":"def has_pair_with_sum(nums, target): Determines if there exists two distinct indices i and j in the array such that nums[i] + nums[j] == target. :param nums: List of integers :param target: Integer target sum :return: True if such a pair exists, False otherwise seen = set() for num in nums: complement = target - num if complement in seen: return True seen.add(num) return False"},{"question":"def can_attack_each_other(board: List[List[int]]) -> bool: Determines if any queen on the board can attack another queen. :param board: 2D list representing the chessboard, where 0 is empty and 1 is queen. :return: boolean indicating if any queens can attack each other. >>> can_attack_each_other([ ... [1, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) == False >>> can_attack_each_other([ ... [1, 1, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) == True >>> can_attack_each_other([ ... [1, 0, 0], ... [1, 0, 0], ... [0, 0, 0] ... ]) == True >>> can_attack_each_other([ ... [1, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) == True >>> can_attack_each_other([ ... [1, 0, 0], ... [0, 0, 1], ... [0, 0, 0] ... ]) == False >>> can_attack_each_other([ ... [1] ... ]) == False >>> can_attack_each_other([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) == False","solution":"def can_attack_each_other(board): Determines if any queen on the board can attack another queen. :param board: 2D list representing the chessboard, where 0 is empty and 1 is queen. :return: boolean indicating if any queens can attack each other. rows = len(board) cols = len(board[0]) # Track if any queen is found in rows, columns, and diagonals row_check = [False] * rows col_check = [False] * cols pos_diag_check = [False] * (rows + cols - 1) neg_diag_check = [False] * (rows + cols - 1) for r in range(rows): for c in range(cols): if board[r][c] == 1: if row_check[r] or col_check[c] or pos_diag_check[r + c] or neg_diag_check[r - c + cols - 1]: return True row_check[r] = True col_check[c] = True pos_diag_check[r + c] = True neg_diag_check[r - c + cols - 1] = True return False"},{"question":"def find_palindrome_pairs(words: List[str]) -> List[Tuple[int, int]]: Given a list of unique words, finds all pairs of distinct indices (i, j) such that concatenation of words[i] + words[j] is a palindrome. >>> find_palindrome_pairs([\\"code\\", \\"edoc\\", \\"da\\", \\"d\\"]) [(0, 1), (1, 0), (2, 3)] >>> find_palindrome_pairs([\\"abc\\", \\"def\\", \\"ghi\\"]) [] >>> find_palindrome_pairs([\\"a\\", \\"b\\", \\"c\\"]) [] >>> find_palindrome_pairs([\\"bat\\", \\"tab\\", \\"cat\\"]) [(0, 1), (1, 0)] >>> find_palindrome_pairs([\\"a\\", \\"\\"]) [(0, 1), (1, 0)]","solution":"def find_palindrome_pairs(words): Returns a list of pairs of indices (i, j) such that words[i] + words[j] is a palindrome. def is_palindrome(s): return s == s[::-1] result = [] for i in range(len(words)): for j in range(len(words)): if i != j: if is_palindrome(words[i] + words[j]): result.append((i, j)) return result"},{"question":"from collections import defaultdict from typing import List def group_similar_words(words: List[str]) -> List[List[str]]: Group words into sets of similar words based on character frequencies. Parameters: words (List[str]): A list of words consisting of lowercase letters. Returns: List[List[str]]: A list of lists where each sublist contains words that are similar to each other. >>> group_similar_words([\\"tac\\", \\"cat\\", \\"bat\\", \\"tab\\", \\"rat\\"]) [['tac', 'cat'], ['bat', 'tab'], ['rat']] >>> group_similar_words([\\"hello\\"]) [['hello']] >>> group_similar_words([\\"abc\\", \\"def\\", \\"ghi\\"]) [['abc'], ['def'], ['ghi']] >>> group_similar_words([\\"abc\\", \\"bca\\", \\"cab\\"]) [['abc', 'bca', 'cab']] >>> group_similar_words([\\"abc\\", \\"bca\\", \\"cab\\", \\"def\\", \\"fed\\", \\"ghi\\"]) [['abc', 'bca', 'cab'], ['def', 'fed'], ['ghi']] >>> group_similar_words([\\"aabbcc\\", \\"bbaacc\\", \\"ccbbaa\\", \\"abc\\"]) [['aabbcc', 'bbaacc', 'ccbbaa'], ['abc']]","solution":"from collections import defaultdict def group_similar_words(words): Group words into sets of similar words based on character frequencies. Parameters: words (List[str]): A list of words consisting of lowercase letters. Returns: List[List[str]]: A list of lists where each sublist contains words that are similar to each other. groups = defaultdict(list) for word in words: # Create a frequency tuple so that we can use it as a hashable key in the dictionary. freq_tuple = tuple(sorted(word)) groups[freq_tuple].append(word) return list(groups.values())"},{"question":"def min_cost_to_paint_houses(arr: List[int], h: int) -> int: Returns the minimum total cost to paint exactly h houses such that no two adjacent houses are painted. If it is not possible to paint h houses with the given conditions, return -1. >>> min_cost_to_paint_houses([2, 5, 3, 9, 8], 2) 5 >>> min_cost_to_paint_houses([1, 5, 3, 9, 8], 4) -1 >>> min_cost_to_paint_houses([1, 2], 1) 1 >>> min_cost_to_paint_houses([1], 2) -1 >>> min_cost_to_paint_houses([7], 1) 7 pass","solution":"def min_cost_to_paint_houses(arr, h): Returns the minimum total cost to paint exactly h houses such that no two adjacent houses are painted. If it is not possible to paint h houses with the given conditions, returns -1. n = len(arr) # If the number of houses to be painted is more than available or impossible to paint without painting two consecutive if h > (n + 1) // 2: return -1 # Initialize DP table dp = [[float('inf')] * (h+1) for _ in range(n)] # Fill the first row in dp table for i in range(n): dp[i][1] = arr[i] # Fill the rest of the table for j in range(2, h+1): for i in range(j-1, n): for k in range(j-2, i-1): dp[i][j] = min(dp[i][j], dp[k][j-1] + arr[i]) return min(dp[i][h] for i in range(h-1, n))"},{"question":"def median_of_matrix(mat: List[List[int]]) -> int: Returns the median of a matrix where each row is sorted in non-decreasing order. The matrix does not contain duplicate elements. >>> median_of_matrix([[1]]) == 1 >>> median_of_matrix([[1, 3], [2, 4]]) == 2 >>> median_of_matrix([[1, 3, 5], [2, 6, 9], [3, 6, 9]]) == 5 >>> median_of_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5 >>> median_of_matrix([[1, 4, 7], [2, 5, 8], [3, 6, 9]]) == 5 >>> median_of_matrix([[10, 20, 30], [15, 25, 35], [20, 30, 40]]) == 25","solution":"def median_of_matrix(mat): Returns the median of a matrix where each row is sorted in non-decreasing order. The matrix does not contain duplicate elements. m = len(mat) n = len(mat[0]) # Helper function to count numbers less than or equal to mid in the matrix def count_less_equal(mid): count = 0 for row in mat: # Binary search for each row l, r = 0, n while l < r: mid_idx = (l + r) // 2 if row[mid_idx] <= mid: l = mid_idx + 1 else: r = mid_idx count += l return count k = (m * n + 1) // 2 low, high = mat[0][0], mat[-1][-1] while low < high: mid = (low + high) // 2 if count_less_equal(mid) < k: low = mid + 1 else: high = mid return low"},{"question":"def findUsers(logs: list) -> list: This function takes a list of logs in the format \\"user_id action\\" and returns a list of user_ids who are currently inside the system. Args: logs (list): A list of strings, each representing a log entry in the format \\"user_id action\\". Returns: list: A list of user_ids who are currently inside the system. >>> findUsers([\\"user1 enter\\", \\"user2 enter\\", \\"user1 exit\\", \\"user3 enter\\"]) [\\"user2\\", \\"user3\\"] >>> findUsers([\\"user1 enter\\", \\"user1 exit\\", \\"user1 enter\\", \\"user2 enter\\", \\"user2 exit\\", \\"user2 enter\\"]) [\\"user1\\", \\"user2\\"] >>> findUsers([\\"user1 exit\\", \\"user2 enter\\"]) [\\"user2\\"] >>> findUsers([\\"user1 enter\\", \\"user2 enter\\", \\"user3 enter\\", \\"user2 exit\\", \\"user1 enter\\"]) [\\"user1\\", \\"user3\\"] >>> findUsers([]) []","solution":"def findUsers(logs): This function takes a list of logs in the format \\"user_id action\\" and returns a list of user_ids who are currently inside the system. Args: logs (list): A list of strings, each representing a log entry in the format \\"user_id action\\". Returns: list: A list of user_ids who are currently inside the system. current_users = set() for log in logs: user_id, action = log.split() if action == \\"enter\\": current_users.add(user_id) elif action == \\"exit\\" and user_id in current_users: current_users.remove(user_id) return list(current_users)"},{"question":"def can_broadcast_to_all_servers(graph: List[List[int]]) -> bool: Checks if the central server (server 0) can broadcast to all other servers, either directly or indirectly through other servers. Parameters: graph (list of list of int): n x n adjacency matrix representing the graph. Returns: bool: True if the central server can reach all other servers, False otherwise. def test_all_connected_directly(): graph = [ [1, 1, 1], [1, 1, 1], [1, 1, 1] ] assert can_broadcast_to_all_servers(graph) == True def test_all_servers_reachable_indirectly(): graph = [ [1, 1, 0, 0], [1, 1, 1, 0], [0, 1, 1, 1], [0, 0, 1, 1] ] assert can_broadcast_to_all_servers(graph) == True def test_not_all_servers_reachable(): graph = [ [1, 1, 0], [1, 1, 0], [0, 0, 1] ] assert can_broadcast_to_all_servers(graph) == False def test_large_graph_all_reachable(): graph = [ [1, 1, 0, 0, 0], [1, 1, 1, 0, 0], [0, 1, 1, 1, 0], [0, 0, 1, 1, 1], [0, 0, 0, 1, 1] ] assert can_broadcast_to_all_servers(graph) == True def test_large_graph_not_all_reachable(): graph = [ [1, 0, 0, 0, 0], [0, 1, 1, 0, 0], [0, 1, 1, 1, 0], [0, 0, 1, 1, 1], [0, 0, 0, 1, 1] ] assert can_broadcast_to_all_servers(graph) == False","solution":"def can_broadcast_to_all_servers(graph): Checks if the central server (server 0) can broadcast to all other servers, either directly or indirectly through other servers. Parameters: graph (list of list of int): n x n adjacency matrix representing the graph. Returns: bool: True if the central server can reach all other servers, False otherwise. n = len(graph) visited = [False] * n def dfs(node): Depth First Search to mark all reachable nodes from the given node. visited[node] = True for adjacent in range(n): if graph[node][adjacent] == 1 and not visited[adjacent]: dfs(adjacent) # Start DFS from the central server (server 0) dfs(0) # Check if all servers are visited return all(visited)"},{"question":"def maximal_square(grid: List[List[int]]) -> int: Function to find the largest square containing only 1's in a 2D grid and return its area. :param grid: List[List[int]] - 2D List representing the grid :return: int - Area of the largest square containing only 1's >>> maximal_square([]) == 0 >>> maximal_square([[0]]) == 0 >>> maximal_square([[1]]) == 1 >>> maximal_square([[0, 0], [0, 0]]) == 0 >>> maximal_square([[1, 0], [0, 1]]) == 1 >>> maximal_square([[1, 1], [1, 1]]) == 4 >>> maximal_square([[1, 1, 1], [1, 1, 0], [1, 0, 1]]) == 4 >>> grid = [ ... [1, 0, 1, 0, 0], ... [1, 0, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 0, 0, 1, 0] ... ] >>> maximal_square(grid) == 4 >>> grid = [ ... [1, 1, 1, 1], ... [1, 1, 1, 1], ... [1, 1, 1, 1], ... [1, 1, 1, 1] ... ] >>> maximal_square(grid) == 16 >>> grid = [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ] >>> maximal_square(grid) == 0","solution":"def maximal_square(grid): Function to find the largest square containing only 1's in a 2D grid and return its area. :param grid: List[List[int]] - 2D List representing the grid :return: int - Area of the largest square containing only 1's if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] max_side = 0 for i in range(m): for j in range(n): if grid[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side * max_side"},{"question":"def minimize_max_water(arr: List[int]) -> int: Given an array of integers representing the amount of water in glasses, minimize the maximum amount of water in any glass after performing the operations. :param arr: List[int] - List of integers representing the amounts of water in glasses :return: int - The minimum possible maximum amount of water in any glass >>> minimize_max_water([3, 3, 3, 3]) 3 >>> minimize_max_water([1, 2, 3, 4]) 3 >>> minimize_max_water([5]) 5 >>> minimize_max_water([0, 0, 0, 0]) 0 >>> minimize_max_water([10, 20, 30, 40]) 25 >>> minimize_max_water([1, 2, 1, 2, 1, 7, 1, 1]) 2 >>> minimize_max_water([1, 1, 1, 1, 50]) 11","solution":"def minimize_max_water(arr): Returns the minimum possible maximum amount of water in any glass after performing the operations. total_water = sum(arr) n = len(arr) # The highest the maximum can be is when water is perfectly distributed # i.e., all glasses have ceil(total_water / n) left = total_water // n right = (total_water + n - 1) // n return right"},{"question":"def remove_adjacent_duplicates(s: str) -> str: Removes the minimum number of characters from the string so that no two adjacent characters are the same. >>> remove_adjacent_duplicates(\\"abc\\") == \\"abc\\" >>> remove_adjacent_duplicates(\\"aaaa\\") == \\"a\\" >>> remove_adjacent_duplicates(\\"aaabbb\\") == \\"ab\\" >>> remove_adjacent_duplicates(\\"aabbaa\\") == \\"aba\\" >>> remove_adjacent_duplicates(\\"abababababab\\") == \\"abababababab\\" >>> remove_adjacent_duplicates(\\"aabbcc\\") == \\"abc\\" >>> remove_adjacent_duplicates(\\"zzyyxx\\") == \\"zyx\\" >>> remove_adjacent_duplicates(\\"\\") == \\"\\"","solution":"def remove_adjacent_duplicates(s): Removes the minimum number of characters from the string so that no two adjacent characters are the same. stack = [] for char in s: if stack and stack[-1] == char: continue stack.append(char) return ''.join(stack)"},{"question":"from typing import List def min_operations(nums: List[int]) -> int: Returns the minimum number of operations required to make all elements in nums equal. You are given a 0-indexed integer array nums. In one operation, you can choose an integer x from nums and increase or decrease it by 1. Your goal is to make all the elements in nums equal. Return the minimum number of operations required to make all elements in nums equal. >>> min_operations([5]) 0 >>> min_operations([4, 4, 4]) 0 >>> min_operations([1, 2, 3]) 2 >>> min_operations([3, 1, 2]) 2 >>> min_operations([-1, -10, -2, -9, -4]) 16 >>> min_operations([-1, 2, -3, 4]) 10","solution":"def min_operations(nums): Returns the minimum number of operations required to make all elements in nums equal. median = sorted(nums)[len(nums) // 2] operations = sum(abs(num - median) for num in nums) return operations"},{"question":"from typing import List, Tuple def has_path_bfs(grid: List[List[str]], start: Tuple[int, int], end: Tuple[int, int]) -> bool: Determines if there is a path from start to end in the given labyrinth represented by a 2D grid. Args: grid (List[List[str]]): 2D list representing the labyrinth where '#' is a wall and '.' is free space. start (Tuple[int, int]): Coordinates of the start position (row, col). end (Tuple[int, int]): Coordinates of the end position (row, col). Returns: bool: True if a path exists from start to end, False otherwise. >>> has_path_bfs([['.', '.', '.'], ['#', '#', '.'], ['.', '.', '.']], (0, 0), (2, 2)) True >>> has_path_bfs([['.', '.', '.'], ['#', '#', '#'], ['.', '.', '.']], (0, 0), (2, 2)) False >>> has_path_bfs([['.', '.', '.'], ['#', '#', '.'], ['.', '.', '.']], (1, 2), (1, 2)) True >>> has_path_bfs([], (0, 0), (0, 0)) False >>> has_path_bfs([['.', '#', '.'], ['.', '#', '.'], ['.', '.', '.']], (0, 0), (2, 2)) True >>> has_path_bfs([ ... ['.', '.', '.', '.', '#', '.', '.'], ... ['#', '#', '#', '.', '#', '.', '#'], ... ['.', '.', '#', '.', '.', '.', '.'], ... ['.', '#', '#', '#', '#', '#', '.'], ... ['.', '.', '.', '.', '.', '.', '.'] ... ], (0, 0), (4, 6)) True >>> has_path_bfs([ ... ['.', '.', '.', '.', '#', '.', '.'], ... ['#', '#', '#', '.', '#', '.', '#'], ... ['.', '.', '#', '.', '#', '.', '.'], ... ['.', '#', '#', '#', '#', '#', '.'], ... ['.', '.', '.', '.', '.', '.', '#'] ... ], (0, 0), (4, 6)) False","solution":"def has_path_bfs(grid, start, end): Determines if there is a path from start to end in the given labyrinth represented by a 2D grid. Args: grid (List[List[str]]): 2D list representing the labyrinth where '#' is a wall and '.' is free space. start (Tuple[int, int]): Coordinates of the start position (row, col). end (Tuple[int, int]): Coordinates of the end position (row, col). Returns: bool: True if a path exists from start to end, False otherwise. if not grid: return False m, n = len(grid), len(grid[0]) start_x, start_y = start end_x, end_y = end if grid[start_x][start_y] == '#' or grid[end_x][end_y] == '#': return False from collections import deque queue = deque([(start_x, start_y)]) visited = set() visited.add((start_x, start_y)) directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] while queue: x, y = queue.popleft() if (x, y) == (end_x, end_y): return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] == '.': queue.append((nx, ny)) visited.add((nx, ny)) return False"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_kth_from_end(head: ListNode, k: int) -> ListNode: Given a linked list of integers \`head\`, and an integer \`k\`, remove the \`k\`-th node from the end of the list and return its head. Make sure your algorithm runs in O(n) time and uses constant extra space. >>> head = array_to_list([1, 2, 3, 4, 5]) >>> k = 2 >>> new_head = remove_kth_from_end(head, k) >>> list_to_array(new_head) == [1, 2, 3, 5] True >>> head = array_to_list([1]) >>> k = 1 >>> new_head = remove_kth_from_end(head, k) >>> list_to_array(new_head) == [] True >>> head = array_to_list([1, 2]) >>> k = 1 >>> new_head = remove_kth_from_end(head, k) >>> list_to_array(new_head) == [1] True >>> head = array_to_list([1, 2]) >>> k = 2 >>> new_head = remove_kth_from_end(head, k) >>> list_to_array(new_head) == [2] True >>> head = array_to_list([1, 2, 3, 4, 5]) >>> k = 3 >>> new_head = remove_kth_from_end(head, k) >>> list_to_array(new_head) == [1, 2, 4, 5] True","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_kth_from_end(head: ListNode, k: int) -> ListNode: Removes the k-th node from the end of the list and returns its head. dummy = ListNode(0) dummy.next = head first = dummy second = dummy for _ in range(k + 1): first = first.next while first is not None: first = first.next second = second.next second.next = second.next.next return dummy.next"},{"question":"def maxNonDecreasingDays(arr: List[int]) -> int: Determine the maximum number of consecutive days where the number of sales does not decrease. >>> maxNonDecreasingDays([2, 2, 3, 5, 3, 4, 4, 6]) 4 >>> maxNonDecreasingDays([1]) 1 >>> maxNonDecreasingDays([5, 4, 3, 2, 1]) 1 >>> maxNonDecreasingDays([2, 2, 2, 2, 2]) 5 >>> maxNonDecreasingDays([1, 3, 2, 4, 3, 5, 2, 6]) 2 >>> maxNonDecreasingDays([]) 0 >>> maxNonDecreasingDays([1, 2, 3, 1, 2, 3, 4]) 4","solution":"def maxNonDecreasingDays(arr): if not arr: return 0 max_length = 1 current_length = 1 for i in range(1, len(arr)): if arr[i] >= arr[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"def min_path_cost(grid: List[List[int]]) -> int: Returns the minimum cost to get from the top-left corner to the bottom-right corner of the grid. Only right or down moves are allowed. :param grid: List[List[int]] :return: int >>> min_path_cost([ [1, 3, 1], [1, 5, 1], [4, 2, 1] ]) 7 >>> min_path_cost([[5]]) 5 >>> min_path_cost([[1, 2, 3, 4]]) 10 >>> min_path_cost([ [2], [3], [4] ]) 9 >>> min_path_cost([ [1, 1, 1], [1, 1, 1], [1, 1, 1] ]) 5 >>> min_path_cost([]) 0 >>> min_path_cost([[]]) 0","solution":"def min_path_cost(grid): Returns the minimum cost to get from the top-left corner to the bottom-right corner of the grid. Only right or down moves are allowed. :param grid: List[List[int]] :return: int if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] # Initialize the first row for j in range(1, n): dp[0][j] = dp[0][j - 1] + grid[0][j] # Initialize the first column for i in range(1, m): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] return dp[-1][-1]"},{"question":"def max_product(nums: List[int]) -> int: Returns the largest product of a contiguous subarray within the given array. >>> max_product([2, 3, -2, 4]) == 6 >>> max_product([-2, 0, -1]) == 0 >>> max_product([-2, 3, -4]) == 24 >>> max_product([1, 2, 3, 4]) == 24","solution":"def max_product(nums): Returns the largest product of a contiguous subarray within the given array. if not nums: return 0 current_max = current_min = global_max = nums[0] for num in nums[1:]: if num < 0: current_max, current_min = current_min, current_max current_max = max(num, current_max * num) current_min = min(num, current_min * num) global_max = max(global_max, current_max) return global_max"},{"question":"def assign_employee_ids(arrivals): Assigns employee IDs to employees based on their arrival order in a binary format. Parameters: arrivals (list): List of integers representing arrival times. Returns: list: List of employee IDs in binary format corresponding to the order of arrivals. >>> assign_employee_ids([3, 1, 2]) ['11', '1', '10'] >>> assign_employee_ids([5]) ['1'] >>> assign_employee_ids([4, 3, 2, 1]) ['100', '11', '10', '1'] >>> assign_employee_ids([1, 2, 3, 4]) ['1', '10', '11', '100'] >>> assign_employee_ids([8, 3, 5, 7, 1, 2, 4, 6]) ['1000', '11', '101', '111', '1', '10', '100', '110']","solution":"def assign_employee_ids(arrivals): Assigns employee IDs to employees based on their arrival order in a binary format. Parameters: arrivals (list): List of integers representing arrival times. Returns: list: List of employee IDs in binary format corresponding to the order of arrivals. sorted_arrivals = sorted(arrivals) ids = {} for i, arrival in enumerate(sorted_arrivals): ids[arrival] = bin(i + 1)[2:] return [ids[arrival] for arrival in arrivals]"},{"question":"from typing import List def max_subarray_sum_circular(nums: List[int]) -> int: Calculate the total maximum sum of any contiguous subarray of a circular array. Args: nums (list): List of integers representing the circular array. Returns: int: Maximum possible sum of a contiguous subarray. pass # Test cases def test_max_subarray_sum_circular_all_positive(): assert max_subarray_sum_circular([1, 2, 3, 4, 5]) == 15 def test_max_subarray_sum_circular_all_negative(): assert max_subarray_sum_circular([-1, -2, -3, -4, -5]) == -1 def test_max_subarray_sum_circular_mixed(): assert max_subarray_sum_circular([5, -3, 5]) == 10 def test_max_subarray_sum_circular_wrap_around(): assert max_subarray_sum_circular([3, -1, 2, -1]) == 4 def test_max_subarray_sum_circular_simple(): assert max_subarray_sum_circular([3, -2, 2, -3]) == 3 def test_max_subarray_sum_circular_single_element(): assert max_subarray_sum_circular([5]) == 5 def test_max_subarray_sum_circular_all_zero(): assert max_subarray_sum_circular([0, 0, 0, 0]) == 0 def test_max_subarray_sum_circular_non_wrapping_large_sum_small_elements(): assert max_subarray_sum_circular([8, -1, -1, -1, -1]) == 8","solution":"def max_subarray_sum_circular(nums): Calculate the total maximum sum of any contiguous subarray of a circular array. Args: nums (list): List of integers representing the circular array. Returns: int: Maximum possible sum of a contiguous subarray. def kadane_max(array): max_end_here = max_so_far = array[0] for x in array[1:]: max_end_here = max(x, max_end_here + x) max_so_far = max(max_so_far, max_end_here) return max_so_far def kadane_min(array): min_end_here = min_so_far = array[0] for x in array[1:]: min_end_here = min(x, min_end_here + x) min_so_far = min(min_so_far, min_end_here) return min_so_far total_sum = sum(nums) max_kadane = kadane_max(nums) min_kadane = kadane_min(nums) if max_kadane < 0: return max_kadane return max(max_kadane, total_sum - min_kadane)"},{"question":"def restore_string(s: str, indices: List[int]) -> str: Reconstructs and returns the original string by placing each character at the given index specified in the indices array. :param s: str, the input string of lowercase English letters. :param indices: List[int], the array of indices. :return: str, the rearranged string. >>> restore_string(\\"abc\\", [0, 1, 2]) 'abc' >>> restore_string(\\"abc\\", [2, 1, 0]) 'cba' >>> restore_string(\\"aiohn\\", [3, 1, 4, 2, 0]) 'nihao' >>> restore_string(\\"aaaa\\", [3, 2, 1, 0]) 'aaaa' >>> restore_string(\\"a\\", [0]) 'a' >>> restore_string(\\"codeleet\\", [4, 5, 6, 7, 0, 2, 1, 3]) 'leetcode' pass","solution":"def restore_string(s, indices): Restores and returns the original string by placing each character at the given index specified in the indices array. :param s: str, the input string of lowercase English letters. :param indices: List[int], the array of indices. :return: str, the rearranged string. restored = [''] * len(s) for i, index in enumerate(indices): restored[index] = s[i] return ''.join(restored)"},{"question":"from collections import deque class MyStack: A class to simulate a stack using two queues. Methods: - push(int x): Pushes element x to the top of the stack. - pop() -> int: Removes the element on the top of the stack and returns it. - top() -> int: Returns the element on the top of the stack. - empty() -> bool: Returns true if the stack is empty, false otherwise. def __init__(self): self.queue1 = deque() self.queue2 = deque() def push(self, x: int) -> None: Push element x to the top of the stack. def pop(self) -> int: Remove the element on the top of the stack and return it. def top(self) -> int: Return the element on the top of the stack. def empty(self) -> bool: Return true if the stack is empty, false otherwise. # Unit tests import pytest def test_push(): stack = MyStack() stack.push(1) stack.push(2) assert stack.queue1 == deque([1, 2]) def test_pop(): stack = MyStack() stack.push(1) stack.push(2) assert stack.pop() == 2 assert stack.queue1 == deque([1]) assert stack.pop() == 1 assert stack.empty() == True def test_top(): stack = MyStack() stack.push(1) stack.push(2) assert stack.top() == 2 stack.pop() assert stack.top() == 1 def test_empty(): stack = MyStack() assert stack.empty() == True stack.push(1) assert stack.empty() == False stack.pop() assert stack.empty() == True if __name__ == \\"__main__\\": pytest.main()","solution":"from collections import deque class MyStack: def __init__(self): self.queue1 = deque() self.queue2 = deque() def push(self, x: int) -> None: self.queue1.append(x) def pop(self) -> int: while len(self.queue1) > 1: self.queue2.append(self.queue1.popleft()) popped_element = self.queue1.popleft() self.queue1, self.queue2 = self.queue2, self.queue1 return popped_element def top(self) -> int: while len(self.queue1) > 1: self.queue2.append(self.queue1.popleft()) top_element = self.queue1[0] self.queue2.append(self.queue1.popleft()) self.queue1, self.queue2 = self.queue2, self.queue1 return top_element def empty(self) -> bool: return not self.queue1"},{"question":"def min_completion_time(tasks: List[int]) -> int: Returns the minimized maximum completion time for distributing tasks between two people. >>> min_completion_time([3, 4, 5]) == 7 >>> min_completion_time([4, 4, 4, 4]) == 8 >>> min_completion_time([2, 3, 7, 4, 1, 3]) == 10 >>> min_completion_time([5]) == 5 >>> min_completion_time([8, 3]) == 8","solution":"def min_completion_time(tasks): Returns the minimized maximum completion time for distributing tasks between two people. tasks.sort(reverse=True) time_A, time_B = 0, 0 for task in tasks: if time_A <= time_B: time_A += task else: time_B += task return max(time_A, time_B)"},{"question":"from typing import List, Tuple def shortest_path(n: int, edges: List[Tuple[int, int, int]]) -> int: Given a directed graph with n nodes and m edges, each edge is represented as a triplet (u, v, w). Returns the shortest path from node 0 to node n-1. If there is no path, return -1. >>> shortest_path(2, [(0, 1, 1)]) 1 >>> shortest_path(3, [(0, 1, 1), (1, 2, 2)]) 3 >>> shortest_path(2, [(0, 1, 5)]) 5 >>> shortest_path(4, [(0, 1, 1), (1, 3, 1), (0, 2, 2), (2, 3, 1)]) 2 >>> shortest_path(3, []) -1 >>> shortest_path(4, [(0, 1, 1), (1, 2, 2), (2, 0, 4), (2, 3, 1)]) 4 >>> shortest_path(5, [(0, 1, 2), (0, 2, 3), (1, 3, 4), (2, 3, 1), (3, 4, 2), (1, 4, 7)]) 6","solution":"import heapq def shortest_path(n, edges): Returns the shortest path from node 0 to node n-1 in a directed graph with n nodes. If there is no path from node 0 to node n-1, return -1. # Build the graph graph = [[] for _ in range(n)] for u, v, w in edges: graph[u].append((v, w)) # Dijkstra's algorithm pq = [(0, 0)] # (distance, node) distances = {i: float('inf') for i in range(n)} distances[0] = 0 while pq: current_distance, u = heapq.heappop(pq) if u == n-1: return current_distance if current_distance > distances[u]: continue for v, weight in graph[u]: distance = current_distance + weight if distance < distances[v]: distances[v] = distance heapq.heappush(pq, (distance, v)) return -1 if distances[n-1] == float('inf') else distances[n-1]"},{"question":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None class BinaryTree: def __init__(self): self.root = None def insert(self, value): Insert a node with the given value into the binary tree. def rightView(self): Returns a list of all the nodes you can see from the right side of the tree. >>> bt = BinaryTree() >>> bt.rightView() [] >>> bt.insert(10) >>> bt.rightView() [10] >>> bt.insert(5) >>> bt.insert(15) >>> bt.insert(3) >>> bt.insert(8) >>> bt.insert(12) >>> bt.insert(18) >>> bt.rightView() [10, 15, 18] >>> bt = BinaryTree() >>> bt.insert(10) >>> bt.insert(9) >>> bt.insert(8) >>> bt.insert(7) >>> bt.insert(6) >>> bt.rightView() [10, 9, 8, 7, 6] >>> bt = BinaryTree() >>> bt.insert(10) >>> bt.insert(11) >>> bt.insert(12) >>> bt.insert(13) >>> bt.insert(14) >>> bt.rightView() [10, 11, 12, 13, 14]","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None class BinaryTree: def __init__(self): self.root = None def insert(self, value): new_node = TreeNode(value) if self.root is None: self.root = new_node else: self._insert_recursive(self.root, new_node) def _insert_recursive(self, current, new_node): if new_node.value < current.value: if current.left is None: current.left = new_node else: self._insert_recursive(current.left, new_node) else: if current.right is None: current.right = new_node else: self._insert_recursive(current.right, new_node) def rightView(self): result = [] if not self.root: return result queue = [(self.root, 0)] last_node_at_level = {} while queue: node, level = queue.pop(0) last_node_at_level[level] = node.value if node.left: queue.append((node.left, level + 1)) if node.right: queue.append((node.right, level + 1)) for level in range(len(last_node_at_level)): result.append(last_node_at_level[level]) return result"},{"question":"def intersect_sorted_arrays(arr1, arr2): Returns the intersection of two sorted arrays. Each element in the result should appear as many times as it shows in both arrays. Time complexity: O(n + m) >>> intersect_sorted_arrays([1, 2, 3], [4, 5, 6]) [] >>> intersect_sorted_arrays([1, 2, 3], [1, 2, 3]) [1, 2, 3] >>> intersect_sorted_arrays([1, 2, 2, 3, 4], [2, 2, 4, 6]) [2, 2, 4] >>> intersect_sorted_arrays([1, 1, 2, 2, 2, 3], [2, 2, 2, 4]) [2, 2, 2] >>> intersect_sorted_arrays([], [1, 2, 3]) [] >>> intersect_sorted_arrays([1, 2, 3], []) [] >>> intersect_sorted_arrays([1, 2, 3, 5, 7], [5, 6, 7, 8]) [5, 7]","solution":"def intersect_sorted_arrays(arr1, arr2): Returns the intersection of two sorted arrays. Each element in the result should appear as many times as it shows in both arrays. Time complexity: O(n + m) intersection = [] i, j = 0, 0 while i < len(arr1) and j < len(arr2): if arr1[i] == arr2[j]: intersection.append(arr1[i]) i += 1 j += 1 elif arr1[i] < arr2[j]: i += 1 else: j += 1 return intersection"},{"question":"def has_zero_sum_subarray(arr: List[int]) -> bool: Determine if there exists a subarray with sum zero in the given array. >>> has_zero_sum_subarray([1, 2, -3, 1]) True >>> has_zero_sum_subarray([1, 2, 3, 4]) False >>> has_zero_sum_subarray([0]) True >>> has_zero_sum_subarray([]) False >>> has_zero_sum_subarray([0, 0, 0, 0]) True >>> has_zero_sum_subarray([1, -1, 1, -1]) True >>> has_zero_sum_subarray([1000000000, -1000000000]) True","solution":"def has_zero_sum_subarray(arr): Returns True if there exists a subarray with sum zero, False otherwise. prefix_sum = 0 prefix_sum_set = set() for num in arr: prefix_sum += num if prefix_sum == 0 or prefix_sum in prefix_sum_set: return True prefix_sum_set.add(prefix_sum) return False"},{"question":"def longest_common_subsequence(word1: str, word2: str) -> int: Given two strings \`word1\` and \`word2\`, find the length of their longest common subsequence. A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters. For example, \\"abc\\", \\"ab\\", and \\"a\\" are subsequences of \\"abc\\". If there is no common subsequence, return 0. >>> longest_common_subsequence(\\"\\", \\"\\") == 0 >>> longest_common_subsequence(\\"abc\\", \\"\\") == 0 >>> longest_common_subsequence(\\"\\", \\"abc\\") == 0 >>> longest_common_subsequence(\\"abc\\", \\"def\\") == 0 >>> longest_common_subsequence(\\"abc\\", \\"abc\\") == 3 >>> longest_common_subsequence(\\"abc\\", \\"ac\\") == 2 >>> longest_common_subsequence(\\"abcdef\\", \\"ace\\") == 3 >>> longest_common_subsequence(\\"abcde\\", \\"ace\\") == 3 >>> longest_common_subsequence(\\"abcbdab\\", \\"bdcaba\\") == 4 >>> longest_common_subsequence(\\"abcde\\", \\"edcba\\") == 1 >>> longest_common_subsequence(\\"oxcpqrsvwf\\", \\"shmtulqrypy\\") == 2","solution":"def longest_common_subsequence(word1, word2): Returns the length of the longest common subsequence of word1 and word2. m, n = len(word1), len(word2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"def count_components(n: int, edges: List[List[int]], restricted: List[int]) -> int: Return the number of connected components from the starting node 0 considering the restricted nodes. Args: n (int): Number of nodes in the graph. edges (List[List[int]]): List of directed edges in the graph. restricted (List[int]): List of restricted nodes. Returns: int: Number of connected components from node 0 without passing through restricted nodes. >>> count_components(6, [[0,1],[0,2],[1,3],[3,4],[2,5]], [4, 5]) 4 >>> count_components(7, [[0,1],[1,2],[2,3],[3,4],[4,5],[5,6]], [3, 4]) 3 >>> count_components(5, [[0,1],[1,2],[2,3],[3,4]], []) 5 >>> count_components(8, [[0,1],[1,2],[2,3],[3,4],[4,5],[5,6], [6,7]], [1, 2, 3, 4, 5, 6, 7]) 1 >>> count_components(3, [[0,1],[0,2]], [1]) 2 >>> count_components(4, [[0,1],[0,2],[1,3]], [2]) 3","solution":"def count_components(n, edges, restricted): from collections import defaultdict, deque # Convert restricted list to set for O(1) lookups restricted_set = set(restricted) # Building the graph using adjacency list graph = defaultdict(list) for a, b in edges: graph[a].append(b) graph[b].append(a) # BFS to find all reachable nodes from node 0 visited = set() queue = deque([0]) visited.add(0) count = 0 while queue: node = queue.popleft() count += 1 for neighbor in graph[node]: if neighbor not in visited and neighbor not in restricted_set: visited.add(neighbor) queue.append(neighbor) return count"},{"question":"def can_receive_water(heights: List[int]) -> List[bool]: Returns a list where each boolean value indicates whether the corresponding building in the heights list can receive water from the sky. >>> can_receive_water([]) == [] >>> can_receive_water([4]) == [True] >>> can_receive_water([2, 2, 2]) == [True, True, True] >>> can_receive_water([1, 2, 3, 4]) == [False, False, False, True] >>> can_receive_water([4, 3, 2, 1]) == [True, False, False, False] >>> can_receive_water([1, 3, 7, 3, 1]) == [False, False, True, False, False] >>> can_receive_water([3, 2, 5, 2, 3, 6, 1, 6]) == [False, False, False, False, False, True, False, True] >>> can_receive_water([5, 1, 5]) == [True, False, True]","solution":"def can_receive_water(heights): Returns a list where each boolean value indicates whether the corresponding building in the heights list can receive water from the sky. n = len(heights) max_left = [0] * n max_right = [0] * n result = [False] * n if n == 0: return result max_left[0] = heights[0] for i in range(1, n): max_left[i] = max(max_left[i - 1], heights[i]) max_right[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): max_right[i] = max(max_right[i + 1], heights[i]) for i in range(n): if heights[i] >= max_left[i] and heights[i] >= max_right[i]: result[i] = True return result"},{"question":"def min_deletions_to_keep_subsequence(s: str, t: str) -> int: Returns the length of the modified string t after deleting the minimum number of characters while keeping s as a subsequence of the modified t. If it's not possible to retain s as a subsequence of t, returns -1. >>> min_deletions_to_keep_subsequence('abc', 'aebdc') 2 >>> min_deletions_to_keep_subsequence('abc', 'abc') 0 >>> min_deletions_to_keep_subsequence('abc', 'axbycz') 3 >>> min_deletions_to_keep_subsequence('', 'abc') 3 >>> min_deletions_to_keep_subsequence('abc', 'def') -1 >>> min_deletions_to_keep_subsequence('abcdef', 'abc') -1 >>> min_deletions_to_keep_subsequence('ace', 'abcdef') 3","solution":"def min_deletions_to_keep_subsequence(s, t): Returns the length of the modified string t after deleting the minimum number of characters while keeping s as a subsequence of the modified t. If it's not possible to retain s as a subsequence of t, returns -1. s_len = len(s) t_len = len(t) s_idx = 0 # Pointer for string s # Traverse the string t for char in t: if s_idx < s_len and char == s[s_idx]: s_idx += 1 if s_idx == s_len: # s is a subsequence of t return t_len - s_len else: # s is not a subsequence of t return -1"},{"question":"from typing import List def subsets(nums: List[int]) -> List[List[int]]: Returns all possible subsets (the power set) of a list of distinct integers. >>> subsets([]) == [[]] >>> subsets([1]) == [[], [1]] >>> subsets([1, 2]) == [[], [1], [2], [1, 2]] >>> subsets([1, 2, 3]) == [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]] >>> subsets([-1, 2]) == [[], [-1], [2], [-1, 2]] >>> subsets([1, 2, 3, 4]) == [ >>> [], [1], [2], [3], [4], [1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4], >>> [1, 2, 3], [1, 2, 4], [1, 3, 4], [2, 3, 4], [1, 2, 3, 4]]","solution":"def subsets(nums): Returns all possible subsets (the power set) of a list of distinct integers. result = [] subset = [] def backtrack(start): result.append(subset.copy()) for i in range(start, len(nums)): subset.append(nums[i]) backtrack(i + 1) subset.pop() backtrack(0) return result"},{"question":"def dailyTemperatures(temperatures): Returns a list of how many days until a warmer temperature for each day in the list of temperatures. If there is no future day for which it is possible, the result is 0. :param temperatures: List[int] - list of daily temperatures :return: List[int] - list of days until a warmer temperature >>> dailyTemperatures([73, 74, 75, 71, 69, 72, 76, 73]) == [1, 1, 4, 2, 1, 1, 0, 0] >>> dailyTemperatures([73, 72, 71, 70]) == [0, 0, 0, 0] >>> dailyTemperatures([70, 71, 72, 73]) == [1, 1, 1, 0] >>> dailyTemperatures([75]) == [0] >>> dailyTemperatures([70, 75, 71, 80, 72]) == [1, 2, 1, 0, 0]","solution":"def dailyTemperatures(temperatures): Returns a list of how many days until a warmer temperature for each day in the list of temperatures. If there is no future day for which it is possible, the result is 0. :param temperatures: List[int] - list of daily temperatures :return: List[int] - list of days until a warmer temperature n = len(temperatures) result = [0] * n stack = [] for i in range(n): while stack and temperatures[i] > temperatures[stack[-1]]: prev_index = stack.pop() result[prev_index] = i - prev_index stack.append(i) return result"},{"question":"def longest_same_char_substring(s: str) -> int: Returns the length of the longest substring of \`s\` that consists of the same character. >>> longest_same_char_substring(\\"\\") == 0 >>> longest_same_char_substring(\\"a\\") == 1 >>> longest_same_char_substring(\\"aaaaa\\") == 5 >>> longest_same_char_substring(\\"abcdefg\\") == 1 >>> longest_same_char_substring(\\"aaabbccaa\\") == 3 >>> longest_same_char_substring(\\"aabbccddeeeddd\\") == 3 >>> longest_same_char_substring(\\"aabbcccc\\") == 4","solution":"def longest_same_char_substring(s): Returns the length of the longest substring of \`s\` that consists of the same character. if not s: return 0 max_length = 1 current_length = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: current_length += 1 else: if current_length > max_length: max_length = current_length current_length = 1 return max(max_length, current_length)"},{"question":"class UserFollowers: def __init__(self, followers: List[int], queries: List[List[int]]): Initialize the UserFollowers object with followers array and queries array. :param followers: List of integers representing followers. :param queries: 2D list of integers representing queries in the form [x, y, bound]. def answerQueries(self) -> List[int]: Process all the queries and return an array of results for each query. :return: List of results where each result corresponds to the number of users that have followers within the specified bounds for the given range in queries. # Unit Tests def test_single_query_within_bounds(): followers = [5, 3, 8, 10, 12] queries = [[5, 10, 5]] uf = UserFollowers(followers, queries) assert uf.answerQueries() == [3] # Followers 5, 8, and 10 are within the bounds of 5 to 10. def test_multiple_queries(): followers = [5, 3, 8, 10, 12] queries = [[5, 10, 5], [1, 4, 3], [10, 12, 5]] uf = UserFollowers(followers, queries) assert uf.answerQueries() == [3, 1, 2] # Results of each query respectively. def test_query_with_bounds_out_of_range(): followers = [2, 2, 2, 2, 2] queries = [[1, 3, 5]] uf = UserFollowers(followers, queries) assert uf.answerQueries() == [5] # All followers are within the range of 1 to 3. def test_query_with_no_matches(): followers = [1, 2, 3, 4, 5] queries = [[6, 10, 5]] uf = UserFollowers(followers, queries) assert uf.answerQueries() == [0] # No followers are within the range of 6 to 10. def test_empty_followers_list(): followers = [] queries = [[1, 5, 0]] uf = UserFollowers(followers, queries) assert uf.answerQueries() == [0] # There are no followers to check.","solution":"class UserFollowers: def __init__(self, followers, queries): Initialize the object with followers array and queries array. self.followers = followers self.queries = queries def answerQueries(self): Process all the queries and return an array of results for each query. result = [] for x, y, bound in self.queries: count = 0 for follower in self.followers[:bound]: if x <= follower <= y: count += 1 result.append(count) return result"},{"question":"def autocomplete(dictionary: List[str], input: str) -> List[str]: Returns a list of strings from the dictionary that start with the given input. The comparison is case-insensitive. >>> autocomplete([\\"apple\\", \\"banana\\", \\"grape\\"], \\"\\") == [\\"apple\\", \\"banana\\", \\"grape\\"] >>> autocomplete([\\"apple\\", \\"banana\\", \\"grape\\"], \\"kiwi\\") == [] >>> autocomplete([\\"Apple\\", \\"Banana\\", \\"Grape\\"], \\"ap\\") == [\\"Apple\\"] >>> autocomplete([\\"apple\\", \\"banana\\", \\"apricot\\"], \\"ap\\") == [\\"apple\\", \\"apricot\\"] >>> autocomplete([\\"apple\\", \\"apricot\\", \\"banana\\", \\"apex\\"], \\"ap\\") == [\\"apex\\", \\"apple\\", \\"apricot\\"] >>> autocomplete([\\"apple!\\", \\"banana\\", \\"apple@\\"], \\"apple\\") == [\\"apple!\\", \\"apple@\\"]","solution":"def autocomplete(dictionary, input): Returns a list of strings from the dictionary that start with the given input. The comparison is case-insensitive. input_lower = input.lower() result = [word for word in dictionary if word.lower().startswith(input_lower)] return sorted(result)"},{"question":"def shortest_path_length(graph: dict, start: int, end: int) -> int: Determines the minimum number of edges required to reach the end node from the start node in an undirected graph. :param graph: A dictionary representing the adjacency list of the graph. :param start: The starting node. :param end: The destination node. :return: The minimum number of edges needed to reach the end node from start node, or -1 if there is no possible path. >>> graph = {1: [2, 3], 2: [1, 4], 3: [1, 4], 4: [2, 3]} >>> shortest_path_length(graph, 1, 4) 2 >>> graph = {1: [2], 2: [1], 3: []} >>> shortest_path_length(graph, 1, 3) -1 >>> graph = {1: [2, 3], 2: [1, 3], 3: [1, 2]} >>> shortest_path_length(graph, 1, 1) 0 >>> graph = {1: [2], 2: [1, 3], 3: [2, 4], 4: [3, 5], 5: [4]} >>> shortest_path_length(graph, 1, 5) 4 >>> graph = {1: [2], 2: [1], 3: [4], 4: [3]} >>> shortest_path_length(graph, 1, 3) -1","solution":"from collections import deque def shortest_path_length(graph, start, end): Returns the minimum number of edges required to reach the end node from the start node in an undirected graph. :param graph: A dictionary representing the adjacency list of the graph. :param start: The starting node. :param end: The destination node. :return: The minimum number of edges needed to reach the end node from start node, or -1 if there is no possible path. if start == end: return 0 visited = set() queue = deque([(start, 0)]) while queue: current_node, current_distance = queue.popleft() if current_node not in visited: visited.add(current_node) for neighbor in graph.get(current_node, []): if neighbor == end: return current_distance + 1 queue.append((neighbor, current_distance + 1)) return -1"},{"question":"def matrix_multiply(A, B): Multiplies two matrices A and B. A should be of dimensions n x m. B should be of dimensions m x p. Returns the resulting matrix of dimensions n x p. >>> A = [[1, 2, 3], [4, 5, 6]] >>> B = [[7, 8], [9, 10], [11, 12]] >>> matrix_multiply(A, B) [[58, 64], [139, 154]] >>> A = [[1, 2], [3, 4]] >>> identity = [[1, 0], [0, 1]] >>> matrix_multiply(A, identity) [[1, 2], [3, 4]] >>> A = [[1, 2, 3], [4, 5, 6]] >>> B = [[0, 0], [0, 0], [0, 0]] >>> matrix_multiply(A, B) [[0, 0], [0, 0]] >>> A = [[42]] >>> B = [[2]] >>> matrix_multiply(A, B) [[84]] >>> A = [[1, 2], [3, 4]] >>> B = [[1, 2]] >>> matrix_multiply(A, B) Traceback (most recent call last): ... IndexError: list index out of range","solution":"def matrix_multiply(A, B): Multiplies two matrices A and B. A should be of dimensions n x m. B should be of dimensions m x p. Returns the resulting matrix of dimensions n x p. n = len(A) m = len(A[0]) p = len(B[0]) # Initialize the result matrix with zeros result = [[0] * p for _ in range(n)] # Perform matrix multiplication for i in range(n): for j in range(p): for k in range(m): result[i][j] += A[i][k] * B[k][j] return result"},{"question":"def shortest_substring_containing_target(s: str, target: str) -> int: Given a string \`s\` consisting of lowercase alphabets and a character \`target\`, return the length of the shortest substring of \`s\` that contains all occurrences of \`target\`. If \`target\` does not appear in \`s\`, return \`-1\`. >>> shortest_substring_containing_target(\\"abcde\\", 'a') == 1 >>> shortest_substring_containing_target(\\"abcde\\", 'e') == 1 >>> shortest_substring_containing_target(\\"abac\\", 'a') == 3 >>> shortest_substring_containing_target(\\"abbaba\\", 'b') == 4 >>> shortest_substring_containing_target(\\"axaxax\\", 'x') == 5 >>> shortest_substring_containing_target(\\"abcde\\", 'f') == -1 >>> shortest_substring_containing_target(\\"aaaaa\\", 'a') == 5 >>> shortest_substring_containing_target(\\"\\", 'a') == -1","solution":"def shortest_substring_containing_target(s, target): Returns the length of the shortest substring that contains all occurrences of the target character. if target not in s: return -1 # Find all indices of the target character indices = [i for i, char in enumerate(s) if char == target] # If there are no occurrences, return -1 if not indices: return -1 # Return the length of the shortest substring containing all target characters return indices[-1] - indices[0] + 1"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def right_side_view(root): Returns the values of the nodes that are visible from the right side. # Test Cases def test_right_side_view_empty(): assert right_side_view(None) == [] def test_right_side_view_single_node(): root = TreeNode(1) assert right_side_view(root) == [1] def test_right_side_view_left_skewed(): root = TreeNode(1, TreeNode(2, TreeNode(3))) assert right_side_view(root) == [1, 2, 3] def test_right_side_view_right_skewed(): root = TreeNode(1, None, TreeNode(2, None, TreeNode(3))) assert right_side_view(root) == [1, 2, 3] def test_right_side_view_mixed_tree(): # Tree: # 1 # / # 2 3 # # 5 4 root = TreeNode(1, TreeNode(2, right=TreeNode(5)), TreeNode(3, None, TreeNode(4))) assert right_side_view(root) == [1, 3, 4] def test_right_side_view_full_tree(): # Tree: # 1 # / # 2 3 # / / # 4 5 6 7 root = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, TreeNode(6), TreeNode(7))) assert right_side_view(root) == [1, 3, 7]","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def right_side_view(root): Returns the values of the nodes that are visible from the right side. if not root: return [] right_view = [] level_nodes = [root] while level_nodes: next_level_nodes = [] for node in level_nodes: if node.left: next_level_nodes.append(node.left) if node.right: next_level_nodes.append(node.right) right_view.append(level_nodes[-1].val) level_nodes = next_level_nodes return right_view"},{"question":"def shortest_substring_with_all_words(s: str, lst: List[str]) -> str: Given a string \`s\` and a list of words \`lst\`, return the shortest substring of \`s\` that contains all the words from \`lst\`. If there is no such substring, return an empty string. The words in \`lst\` can appear in any order in the substring but must be whole words and not parts of other words. Words are separated by spaces in the string \`s\`. >>> shortest_substring_with_all_words(\\"the cat sat on the mat\\", [\\"cat\\", \\"sat\\", \\"mat\\"]) == \\"cat sat on the mat\\" >>> shortest_substring_with_all_words(\\"the cat sat on the mat\\", [\\"cat\\", \\"dog\\"]) == \\"\\" >>> shortest_substring_with_all_words(\\"the cat sat on the mat\\", [\\"sat\\", \\"mat\\"]) == \\"sat on the mat\\" >>> shortest_substring_with_all_words(\\"the quick brown fox jumps over the lazy dog\\", [\\"the\\", \\"dog\\", \\"quick\\"]) == \\"quick brown fox jumps over the lazy dog\\" >>> shortest_substring_with_all_words(\\"this is a test string with a lot of test words\\", [\\"a\\", \\"lot\\", \\"test\\"]) == \\"a lot of test\\" >>> shortest_substring_with_all_words(\\"one two three four\\", [\\"one\\", \\"two\\", \\"three\\", \\"four\\"]) == \\"one two three four\\"","solution":"def shortest_substring_with_all_words(s, lst): from collections import Counter, defaultdict words = s.split() word_count = Counter(lst) current_count = defaultdict(int) n = len(words) required_words = len(word_count) formed_words = 0 left = 0 min_length = float('inf') min_left, min_right = 0, 0 for right in range(n): if words[right] in word_count: current_count[words[right]] += 1 if current_count[words[right]] == word_count[words[right]]: formed_words += 1 while formed_words == required_words: if right - left < min_length: min_length = right - left min_left = left min_right = right if words[left] in word_count: current_count[words[left]] -= 1 if current_count[words[left]] < word_count[words[left]]: formed_words -= 1 left += 1 if min_length == float('inf'): return \\"\\" return ' '.join(words[min_left:min_right + 1])"},{"question":"def max_product(nums: List[int]) -> int: Given an array of integers 'nums', find a subarray that has the maximum product of its elements. The subarray must contain at least one number. Return the maximum product that can be obtained. >>> max_product([1, 2, 3, 4]) 24 >>> max_product([0, 2, 3, -2, 4]) 6 >>> max_product([-2, -3, -4]) 12 >>> max_product([2]) 2 >>> max_product([-2]) -2 >>> max_product([2, 3, -2, 4]) 6 >>> max_product([-2, 0, -1]) 0 >>> max_product([-2, 3, -4]) 24","solution":"def max_product(nums): Returns the maximum product of any subarray in nums. if not nums: return 0 max_prod = nums[0] min_prod = nums[0] result = nums[0] for num in nums[1:]: if num < 0: max_prod, min_prod = min_prod, max_prod max_prod = max(num, max_prod * num) min_prod = min(num, min_prod * num) result = max(result, max_prod) return result"},{"question":"def covered_length(segments: List[List[int]]) -> int: Returns the total length of the number line that is covered by at least one segment in the list. Overlapping segments are considered only once in the total length. >>> covered_length([]) == 0 >>> covered_length([[1, 4]]) == 4 >>> covered_length([[0, 0]]) == 1 >>> covered_length([[1, 4], [6, 9]]) == 8 >>> covered_length([[1, 4], [3, 5]]) == 5 >>> covered_length([[1, 10], [5, 15]]) == 15 >>> covered_length([[1, 2], [2, 3]]) == 3 >>> covered_length([[0, 1], [1, 2], [2, 3]]) == 4 >>> covered_length([[1, 4], [2, 8], [7, 10], [15, 18], [16, 17]]) == 14 >>> covered_length([[1, 4], [5, 9], [0, 6]]) == 10","solution":"def covered_length(segments): Returns the total length of the number line that is covered by at least one segment in the list. Overlapping segments are considered only once in the total length. # Sort segments by their starting points (and by end points if starting points are the same) segments.sort() # Variable to store the total covered length total_length = 0 # Variable to keep track of the end of the last added segment in the covered length current_end = -float('inf') for start, end in segments: if start > current_end: # If the new segment starts after the current end, add the full length of the segment total_length += end - start + 1 current_end = end else: # If the new segment overlaps or touches the current covered segment if end > current_end: total_length += end - current_end current_end = end return total_length"},{"question":"from typing import List def shortest_path_in_maze(grid: List[List[int]]) -> int: Returns the length of the shortest path in the maze from (0, 0) to (m-1, n-1). If there is no valid path, returns -1. >>> shortest_path_in_maze([[0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0]]) 9 >>> shortest_path_in_maze([[0, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 0]]) -1 >>> shortest_path_in_maze([[1, 1, 1], [1, 0, 1], [1, 1, 1]]) -1 >>> shortest_path_in_maze([[0]]) 1 >>> shortest_path_in_maze([[1]]) -1","solution":"from collections import deque def shortest_path_in_maze(grid): Returns the length of the shortest path in the maze from (0, 0) to (m-1, n-1). If there is no valid path, returns -1. if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return -1 m, n = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # up, down, left, right # BFS setup queue = deque([(0, 0, 1)]) # (row, col, distance) visited = set() visited.add((0, 0)) while queue: row, col, dist = queue.popleft() # If we've reached the bottom-right corner if row == m-1 and col == n-1: return dist # Explore all four directions for dr, dc in directions: r, c = row + dr, col + dc if 0 <= r < m and 0 <= c < n and grid[r][c] == 0 and (r, c) not in visited: queue.append((r, c, dist + 1)) visited.add((r, c)) return -1"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def detectCycle(head: ListNode) -> ListNode: Detect a cycle in a linked list. If a cycle exists, return the node where the cycle begins. If there is no cycle, return None. pass # Your implementation here def test_no_cycle(): head = ListNode(1, ListNode(2, ListNode(3, ListNode(4)))) assert detectCycle(head) == None def test_cycle_at_head(): head = ListNode(1) head.next = ListNode(2) head.next.next = ListNode(3) head.next.next.next = head # Cycle back to head assert detectCycle(head) == head def test_cycle_in_middle(): head = ListNode(1) second = ListNode(2) third = ListNode(3) fourth = ListNode(4) head.next = second second.next = third third.next = fourth fourth.next = second # Cycle back to second assert detectCycle(head) == second def test_cycle_single_node(): head = ListNode(1) head.next = head # Cycle back to itself assert detectCycle(head) == head def test_cycle_single_node_no_cycle(): head = ListNode(1) assert detectCycle(head) == None def test_long_list_no_cycle(): head = ListNode(1) current = head for i in range(2, 100): current.next = ListNode(i) current = current.next assert detectCycle(head) == None","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def detectCycle(head): Detect a cycle in a linked list. If a cycle exists, return the node where the cycle begins. If there is no cycle, return None. if not head or not head.next: return None slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: # Cycle detected break else: return None # No cycle detected # Find the start of the cycle slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"def splitStringIntoGroups(s: str) -> List[int]: Splits the input string \`s\` into as many part groups as possible such that each letter appears in at most one group. Returns a list of integers representing the size of these parts. >>> splitStringIntoGroups(\\"abacaba\\") in [[1, 2, 1, 1, 1, 1, 1], [5, 2], [1, 7], [7]] True >>> splitStringIntoGroups(\\"abcde\\") == [1, 1, 1, 1, 1] True >>> splitStringIntoGroups(\\"a\\") == [1] True >>> splitStringIntoGroups(\\"aaa\\") == [3] True >>> splitStringIntoGroups(\\"\\") == [] True >>> splitStringIntoGroups(\\"abacdefecba\\") in [[5, 6], [6, 5], [11]] True","solution":"def splitStringIntoGroups(s): Splits the input string \`s\` into as many part groups as possible such that each letter appears in at most one group. Returns a list of integers representing the size of these parts. last_occurrence = {char: idx for idx, char in enumerate(s)} parts = [] start, end = 0, 0 for idx, char in enumerate(s): end = max(end, last_occurrence[char]) if idx == end: parts.append(end - start + 1) start = end + 1 return parts"},{"question":"def count_unique_subsets(arr: List[int], k: int) -> int: Returns the number of unique subsets of the array where the sum of the elements in each subset is divisible by k. >>> count_unique_subsets([1, 2, 3], 1) == 8 >>> count_unique_subsets([1, 2, 3], 2) == 4 >>> count_unique_subsets([1, 2, 3], 3) == 4 >>> count_unique_subsets([1, 2, 3, 4], 2) == 8 >>> count_unique_subsets([10, 5, 2, 1], 5) == 4 >>> count_unique_subsets([], 1) == 1 >>> count_unique_subsets([], 10) == 1","solution":"from itertools import combinations def count_unique_subsets(arr, k): Returns the number of unique subsets of the array where the sum of the elements in each subset is divisible by k. unique_sums = set() n = len(arr) # Check all possible subsets for i in range(n + 1): for subset in combinations(arr, i): subset_sum = sum(subset) if subset_sum % k == 0: unique_sums.add(subset) return len(unique_sums)"},{"question":"from typing import List def maxProfit(stocks: List[int]) -> int: Calculate the maximum profit that can be achieved by trading stocks with multiple buy-sell transactions. >>> maxProfit([]) == 0 >>> maxProfit([5]) == 0 >>> maxProfit([1, 5]) == 4 >>> maxProfit([5, 1]) == 0 >>> maxProfit([7, 1, 5, 3, 6, 4]) == 7 >>> maxProfit([1, 2, 3, 4, 5]) == 4 >>> maxProfit([5, 4, 3, 2, 1]) == 0 >>> maxProfit([3, 2, 6, 5, 0, 3]) == 7","solution":"def maxProfit(stocks): Calculate the maximum profit that can be achieved by trading stocks with multiple buy-sell transactions. Parameters: stocks (List[int]): List of stock prices per day. Returns: int: Maximum profit. if not stocks: return 0 max_profit = 0 for i in range(1, len(stocks)): if stocks[i] > stocks[i - 1]: max_profit += stocks[i] - stocks[i - 1] return max_profit"},{"question":"def fizz_buzz_concat(n: int) -> str: Given an integer n, return a concatenated string of the integers from 1 to n with a twist: - Replace every number divisible by 3 with \\"Fizz\\" - Replace every number divisible by 5 with \\"Buzz\\" - Replace every number divisible by both 3 and 5 with \\"FizzBuzz\\" >>> fizz_buzz_concat(1) == \\"1\\" >>> fizz_buzz_concat(3) == \\"12Fizz\\" >>> fizz_buzz_concat(5) == \\"12Fizz4Buzz\\" >>> fizz_buzz_concat(15) == \\"12Fizz4BuzzFizz78FizzBuzz11Fizz1314FizzBuzz\\" >>> fizz_buzz_concat(0) == \\"\\" >>> fizz_buzz_concat(2) == \\"12\\" >>> fizz_buzz_concat(20) == \\"12Fizz4BuzzFizz78FizzBuzz11Fizz1314FizzBuzz1617Fizz19Buzz\\"","solution":"def fizz_buzz_concat(n): Returns a concatenated string of integers from 1 to n with the following conditions: - Replace numbers divisible by 3 with \\"Fizz\\" - Replace numbers divisible by 5 with \\"Buzz\\" - Replace numbers divisible by both 3 and 5 with \\"FizzBuzz\\" result = \\"\\" for i in range(1, n + 1): if i % 3 == 0 and i % 5 == 0: result += \\"FizzBuzz\\" elif i % 3 == 0: result += \\"Fizz\\" elif i % 5 == 0: result += \\"Buzz\\" else: result += str(i) return result"},{"question":"def min_flips(s: str) -> int: Returns the minimum number of flips required to make the string \`s\` consist of all '1's or all '0's. >>> min_flips(\\"1111\\") == 0 >>> min_flips(\\"0000\\") == 0 >>> min_flips(\\"1010\\") == 2 >>> min_flips(\\"110\\") == 1 >>> min_flips(\\"1\\") == 0 >>> min_flips(\\"0\\") == 0 >>> min_flips(\\"010101\\") == 3 >>> min_flips(\\"\\") == 0","solution":"def min_flips(s): Returns the minimum number of flips required to make the string \`s\` consist of all '1's or all '0's. count_0_to_1 = s.count('0') count_1_to_0 = s.count('1') return min(count_0_to_1, count_1_to_0)"},{"question":"from typing import List from collections import defaultdict, deque class TransactionMovingAverage: Class to calculate moving average of transaction amounts for each user over a sliding window of \`k\` transactions. def __init__(self, k: int): Initializes the object with the sliding window size \`k\`. def addTransaction(self, userId: int, timestamp: int, amount: int) -> None: Adds a new transaction for the given \`userId\`. def getMovingAverage(self, userId: int) -> float: Returns the moving average of the transaction amounts for the given \`userId\` over the last \`k\` transactions. # Unit Tests def test_basic_functionality(): tma = TransactionMovingAverage(3) tma.addTransaction(1, 1, 10) tma.addTransaction(1, 2, 20) tma.addTransaction(1, 3, 30) assert tma.getMovingAverage(1) == (10 + 20 + 30) / 3 tma.addTransaction(1, 4, 40) assert tma.getMovingAverage(1) == (20 + 30 + 40) / 3 tma.addTransaction(1, 5, 50) assert tma.getMovingAverage(1) == (30 + 40 + 50) / 3 def test_different_users(): tma = TransactionMovingAverage(2) tma.addTransaction(1, 1, 10) tma.addTransaction(2, 1, 100) tma.addTransaction(1, 2, 20) tma.addTransaction(2, 2, 200) assert tma.getMovingAverage(1) == (10 + 20) / 2 assert tma.getMovingAverage(2) == (100 + 200) / 2 def test_single_transaction(): tma = TransactionMovingAverage(1) tma.addTransaction(1, 1, 10) assert tma.getMovingAverage(1) == 10.0 def test_no_transaction(): tma = TransactionMovingAverage(3) assert tma.getMovingAverage(1) == 0.0 def test_more_transactions_than_window(): tma = TransactionMovingAverage(2) tma.addTransaction(1, 1, 10) tma.addTransaction(1, 2, 20) tma.addTransaction(1, 3, 30) assert tma.getMovingAverage(1) == (20 + 30) / 2","solution":"from collections import defaultdict, deque class TransactionMovingAverage: def __init__(self, k): self.k = k self.user_transactions = defaultdict(deque) self.user_sums = defaultdict(int) def addTransaction(self, userId, timestamp, amount): user_deque = self.user_transactions[userId] user_sums = self.user_sums user_deque.append(amount) user_sums[userId] += amount if len(user_deque) > self.k: user_sums[userId] -= user_deque.popleft() def getMovingAverage(self, userId): user_deque = self.user_transactions[userId] if len(user_deque) == 0: return 0.0 return self.user_sums[userId] / len(user_deque)"},{"question":"def replace_question_marks(s: str) -> str: Replace each '?' in the string with any digit (0-9) such that no two consecutive digits are the same. Return the resultant string. >>> replace_question_marks(\\"??\\") '09' or '90' or other valid combinations >>> replace_question_marks(\\"1?2?3\\") '10203' or '12013' or other valid combinations >>> replace_question_marks(\\"?123?\\") '01230' or '91234' or other valid combinations >>> replace_question_marks(\\"?1?2?3?\\") '0102030' or '9192929' or other valid combinations >>> replace_question_marks(\\"?\\") '0' or any other single digit >>> replace_question_marks(\\"4?\\") '40' or '45' >>> replace_question_marks(\\"?7\\") '07' or '57'","solution":"def replace_question_marks(s): Replace each '?' in the string with any digit (0-9) such that no two consecutive digits are the same. Return the resultant string. # Convert string to list to modify it easily s_list = list(s) n = len(s_list) for i in range(n): if s_list[i] == '?': for digit in '0123456789': if (i > 0 and s_list[i-1] == digit) or (i < n-1 and s_list[i+1] == digit): continue s_list[i] = digit break return ''.join(s_list)"},{"question":"from typing import List def maxCandiesTypes(nums: List[int]) -> int: Return the maximum number of different types of candies each child can get. Args: nums (List[int]): A list of integers representing different types of candies. Returns: int: The maximum number of different types of candies each child can get. Examples: >>> maxCandiesTypes([1, 1, 1, 1]) 1 >>> maxCandiesTypes([1, 2, 3, 4]) 2 >>> maxCandiesTypes([1, 2, 2, 3, 3, 3]) 3 >>> maxCandiesTypes([1, 2, 3, 1, 2, 3]) 3 >>> maxCandiesTypes([i for i in range(100)]) 50 >>> maxCandiesTypes([1, 1, 2, 2, 3, 3, 4, 4]) 4","solution":"from typing import List def maxCandiesTypes(nums: List[int]) -> int: unique_candies = len(set(nums)) max_candies_each_child_can_get = len(nums) // 2 return min(unique_candies, max_candies_each_child_can_get)"},{"question":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def rearrange_linked_list(head): Rearranges a linked list so that the odd-indexed nodes appear before the even-indexed nodes. The relative order among the odd-indexed nodes and the even-indexed nodes should remain the same as in the input. >>> # Helper function to print the list for validation >>> def linked_list_to_list(head): >>> result = [] >>> while head: >>> result.append(head.value) >>> head = head.next >>> return result >>> >>> # Test cases >>> head = ListNode(1) >>> new_head = rearrange_linked_list(head) >>> linked_list_to_list(new_head) == [1] True >>> >>> head = ListNode(1, ListNode(2)) >>> new_head = rearrange_linked_list(head) >>> linked_list_to_list(new_head) == [1, 2] True >>> >>> head = ListNode(1, ListNode(2, ListNode(3))) >>> new_head = rearrange_linked_list(head) >>> linked_list_to_list(new_head) == [1, 3, 2] True >>> >>> head = ListNode(1, ListNode(2, ListNode(3, ListNode(4)))) >>> new_head = rearrange_linked_list(head) >>> linked_list_to_list(new_head) == [1, 3, 2, 4] True >>> >>> head = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))) >>> new_head = rearrange_linked_list(head) >>> linked_list_to_list(new_head) == [1, 3, 5, 2, 4] True","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def rearrange_linked_list(head): Rearranges a linked list so odd-indexed nodes appear before even-indexed nodes. if not head or not head.next: return head odd = head even = head.next even_head = even while even and even.next: odd.next = even.next odd = odd.next even.next = odd.next even = even.next odd.next = even_head return head"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kth_smallest(root: TreeNode, k: int) -> int: Returns the k-th smallest value in the BST rooted at 'root'. If the tree has less than k elements, return -1. >>> root = TreeNode(3) >>> root.left = TreeNode(1) >>> root.left.right = TreeNode(2) >>> root.right = TreeNode(4) >>> kth_smallest(root, 1) 1 >>> kth_smallest(root, 2) 2 >>> kth_smallest(root, 3) 3 >>> kth_smallest(root, 4) 4 >>> kth_smallest(root, 5) -1","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kth_smallest(root, k): Returns the k-th smallest value in the BST rooted at 'root'. If the tree has less than k elements, return -1. def inorder_traverse(node): if node is None: return [] return inorder_traverse(node.left) + [node.val] + inorder_traverse(node.right) elements = inorder_traverse(root) if k > len(elements): return -1 return elements[k - 1]"},{"question":"from typing import List def min_operations_to_sort(heights: List[int]) -> int: Returns the minimum number of operations to sort the array in non-decreasing order by choosing any student and moving them to the end of the line. >>> min_operations_to_sort([1, 2, 3, 4, 5]) == 0 >>> min_operations_to_sort([5, 4, 3, 2, 1]) == 4 >>> min_operations_to_sort([3, 1, 2, 4, 5]) == 1 >>> min_operations_to_sort([1]) == 0 >>> min_operations_to_sort([2, 2, 2, 2]) == 0 >>> min_operations_to_sort([4, 3, 2, 1, 5, 6]) == 3","solution":"def min_operations_to_sort(heights): Returns the minimum number of operations to sort the array in non-decreasing order by choosing any student and moving them to the end of the line. n = len(heights) if n <= 1: return 0 # Find the length of the longest non-decreasing subsequence longest_nds_length = 1 current_length = 1 for i in range(1, n): if heights[i] >= heights[i - 1]: current_length += 1 else: longest_nds_length = max(longest_nds_length, current_length) current_length = 1 longest_nds_length = max(longest_nds_length, current_length) # Minimum operations needed are total length minus length of longest nds return n - longest_nds_length"},{"question":"def can_form_full_alphabet(s: str) -> bool: Determines if a string can contain all letters of the alphabet at least once by rearranging its characters and appending extra letters if needed. >>> can_form_full_alphabet(\\"abcdefghijklmnopqrstuvwxyzaaa\\") == True >>> can_form_full_alphabet(\\"abcd\\") == False >>> can_form_full_alphabet(\\"thequickbrownfoxjumpsoverthelazydog\\") == True >>> can_form_full_alphabet(\\"\\") == False >>> can_form_full_alphabet(\\"aaaaa\\") == False >>> can_form_full_alphabet(\\"abcdegfhijklmnopqrstuvwxyz\\") == True >>> can_form_full_alphabet(\\"aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ\\") == True >>> can_form_full_alphabet(\\"aAbBcC\\") == False pass","solution":"def can_form_full_alphabet(s): Determines if a string can contain all letters of the alphabet at least once by rearranging its characters and appending extra letters if needed. Params: s (string): input string consisting of only lowercase English letters Returns: bool: True if it's possible to form a full alphabet, False otherwise # Create a set of characters found in the string char_set = set(s) # Create a set of all lowercase English letters all_letters_set = set('abcdefghijklmnopqrstuvwxyz') # Check if all letters of the alphabet are present in the string set return all_letters_set.issubset(char_set)"},{"question":"def minimize_max_length(s: str, k: int) -> int: Minimize the maximum length among all k contiguous substrings. Parameters: s (str): A string consisting of distinct lowercase letters. k (int): An integer to partition the string into k contiguous substrings. Returns: int: The minimized maximum length or -1 if it is not possible. >>> minimize_max_length(\\"abcdef\\", 2) 3 >>> minimize_max_length(\\"abcdefgh\\", 3) 3 >>> minimize_max_length(\\"abcdefgh\\", 4) 2 >>> minimize_max_length(\\"a\\", 1) 1 >>> minimize_max_length(\\"\\", 1) -1 >>> minimize_max_length(\\"abcdef\\", 6) 1 >>> minimize_max_length(\\"abcdefg\\", 1) 7 >>> minimize_max_length(\\"abcdef\\", 7) -1 >>> minimize_max_length(\\"abcdef\\", 1) 6 >>> minimize_max_length(\\"a\\", 1) 1 >>> minimize_max_length(\\"abc\\", 4) -1 >>> minimize_max_length(\\"ab\\", 3) -1","solution":"def minimize_max_length(s, k): Minimize the maximum length among all k substrings. Parameters: s (str): A string consisting of distinct lowercase letters. k (int): An integer to partition the string into k contiguous substrings. Returns: int: The minimized maximum length or -1 if it is not possible. n = len(s) if k > n: return -1 if k == n: return 1 # Binary search to find the minimal possible maximum length. l, r = 1, n def can_partition(max_len): partitions = 1 current_len = 0 for char in s: current_len += 1 if current_len > max_len: partitions += 1 current_len = 1 if partitions > k: return False return True while l < r: mid = (l + r) // 2 if can_partition(mid): r = mid else: l = mid + 1 return l"},{"question":"def max_path_sum(grid: List[List[int]]) -> int: Returns the maximum sum of integers in any path from the top-left to the bottom-right corner of the grid. You can only move either right or down at any point in time. :param grid: List[List[int]] - the input n x n grid of positive integers :return: int - the maximum path sum >>> max_path_sum([[5, 3, 2], [1, 2, 1], [4, 3, 1]]) 14 >>> max_path_sum([[1, 2], [1, 3]]) 6 >>> max_path_sum([[42]]) 42 >>> max_path_sum([[1, 2, 5], [3, 2, 1], [4, 1, 2]]) 11 >>> max_path_sum([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 12","solution":"def max_path_sum(grid): Returns the maximum sum of integers in any path from the top-left to the bottom-right corner of the grid. You can only move either right or down at any point in time. :param grid: List[List[int]] - the input n x n grid of positive integers :return: int - the maximum path sum n = len(grid) # Create a DP table to store maximum path sum results dp = [[0]*n for _ in range(n)] dp[0][0] = grid[0][0] # Initialize the first row of the DP table for i in range(1, n): dp[0][i] = dp[0][i-1] + grid[0][i] # Initialize the first column of the DP table for j in range(1, n): dp[j][0] = dp[j-1][0] + grid[j][0] # Fill the rest of the DP table for i in range(1, n): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[n-1][n-1]"},{"question":"def can_make_all_elements_equal(nums: List[int], x: int) -> bool: Determine if it is possible to make all elements equal by incrementing elements by x any number of times. Args: nums: List[int] - List of integers. x: int - Increment value. Returns: bool - True if possible, else False. >>> can_make_all_elements_equal([2, 4, 6], 2) True >>> can_make_all_elements_equal([2, 5, 6], 2) False >>> can_make_all_elements_equal([5, 5, 5], 3) True >>> can_make_all_elements_equal([2, 10, 22], 4) True >>> can_make_all_elements_equal([2, 10, 23], 4) False >>> can_make_all_elements_equal([7], 5) True >>> can_make_all_elements_equal([1000, 1003, 1006, 1009, 1012], 3) True >>> can_make_all_elements_equal([1000, 1003, 1006, 1009, 1011], 3) False","solution":"def can_make_all_elements_equal(nums, x): Determines if it is possible to make all elements equal by incrementing elements by x any number of times. Args: nums: List[int] - List of integers. x: int - Increment value. Returns: bool - True if possible, else False. # Determine the remainder when each element is divided by x remainder = nums[0] % x # Check if all elements have the same remainder when divided by x for num in nums: if num % x != remainder: return False return True"},{"question":"def is_neighborhood_string(s: str) -> bool: Determine whether the given string is a neighborhood string. >>> is_neighborhood_string(\\"abc\\") True >>> is_neighborhood_string(\\"cba\\") True >>> is_neighborhood_string(\\"abd\\") False >>> is_neighborhood_string(\\"a\\") True >>> is_neighborhood_string(\\"bc\\") True >>> is_neighborhood_string(\\"ac\\") False >>> is_neighborhood_string(\\"\\") True","solution":"def is_neighborhood_string(s): Returns True if the given string s is a neighborhood string, otherwise False. if len(s) < 2: return True for i in range(len(s) - 1): if abs(ord(s[i]) - ord(s[i + 1])) != 1: return False return True"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseList(head: ListNode) -> ListNode: Reverses a singly linked list. Parameters: head (ListNode): The head of the singly linked list. Returns: ListNode: The new head of the reversed singly linked list. >>> linkedlist_to_list(reverseList(list_to_linkedlist([1]))) [1] >>> linkedlist_to_list(reverseList(list_to_linkedlist([1, 2, 3, 4, 5]))) [5, 4, 3, 2, 1] >>> linkedlist_to_list(reverseList(list_to_linkedlist([]))) [] >>> linkedlist_to_list(reverseList(list_to_linkedlist([1, 2]))) [2, 1]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseList(head): Reverses a singly linked list. Parameters: head (ListNode): The head of the singly linked list. Returns: ListNode: The new head of the reversed singly linked list. prev = None current = head while current is not None: next_node = current.next current.next = prev prev = current current = next_node return prev"},{"question":"def organize_tickets(tickets): Organizes tickets into a report based on their status. Args: tickets (list of dicts): List of tickets where each ticket is a dict with 'id' and 'status'. Returns: dict: Dictionary with 'open', 'closed', and 'pending' as keys and lists of ticket ids as values. pass # Unit tests def test_no_tickets(): assert organize_tickets([]) == {\\"open\\": [], \\"closed\\": [], \\"pending\\": []} def test_all_statuses(): tickets = [ {\\"id\\": 1, \\"status\\": \\"open\\"}, {\\"id\\": 2, \\"status\\": \\"closed\\"}, {\\"id\\": 3, \\"status\\": \\"pending\\"} ] assert organize_tickets(tickets) == { \\"open\\": [1], \\"closed\\": [2], \\"pending\\": [3] } def test_duplicate_statuses(): tickets = [ {\\"id\\": 1, \\"status\\": \\"open\\"}, {\\"id\\": 2, \\"status\\": \\"open\\"}, {\\"id\\": 3, \\"status\\": \\"closed\\"} ] assert organize_tickets(tickets) == { \\"open\\": [1, 2], \\"closed\\": [3], \\"pending\\": [] } def test_one_status(): tickets = [ {\\"id\\": 1, \\"status\\": \\"pending\\"}, {\\"id\\": 2, \\"status\\": \\"pending\\"}, {\\"id\\": 3, \\"status\\": \\"pending\\"} ] assert organize_tickets(tickets) == { \\"open\\": [], \\"closed\\": [], \\"pending\\": [1, 2, 3] } def test_mixed_statuses(): tickets = [ {\\"id\\": 1, \\"status\\": \\"open\\"}, {\\"id\\": 2, \\"status\\": \\"closed\\"}, {\\"id\\": 3, \\"status\\": \\"open\\"}, {\\"id\\": 4, \\"status\\": \\"pending\\"}, {\\"id\\": 5, \\"status\\": \\"closed\\"}, {\\"id\\": 6, \\"status\\": \\"closed\\"} ] assert organize_tickets(tickets) == { \\"open\\": [1, 3], \\"closed\\": [2, 5, 6], \\"pending\\": [4] }","solution":"def organize_tickets(tickets): Organizes tickets into a report based on their status. Args: tickets (list of dicts): List of tickets where each ticket is a dict with 'id' and 'status'. Returns: dict: Dictionary with 'open', 'closed', and 'pending' as keys and lists of ticket ids as values. report = { \\"open\\": [], \\"closed\\": [], \\"pending\\": [] } for ticket in tickets: if ticket['status'] in report: report[ticket['status']].append(ticket['id']) return report"},{"question":"def k_inverse_pairs(n: int, k: int) -> int: Given two integers \`n\` and \`k\`, return the number of different arrays consisting of numbers from \`1\` to \`n\` that have exactly \`k\` inverse pairs. >>> k_inverse_pairs(3, 0) 1 >>> k_inverse_pairs(3, 1) 2 >>> k_inverse_pairs(3, 2) 2 >>> k_inverse_pairs(3, 3) 1 >>> k_inverse_pairs(1, 0) 1 >>> k_inverse_pairs(2, 0) 1 >>> k_inverse_pairs(2, 1) 1","solution":"def k_inverse_pairs(n, k): MOD = 10**9 + 7 dp = [[0] * (k + 1) for _ in range(n + 1)] dp[0][0] = 1 for i in range(1, n + 1): for j in range(k + 1): dp[i][j] = dp[i - 1][j] if j > 0: dp[i][j] += dp[i][j - 1] if j >= i: dp[i][j] -= dp[i - 1][j - i] dp[i][j] %= MOD return dp[n][k]"},{"question":"def max_subarray_sum(arr: List[int]) -> int: Function to find the maximum sum of a contiguous subarray using Kadane's Algorithm. :param arr: List[int] - List of integers :return: int - Maximum sum of a contiguous subarray >>> max_subarray_sum([1, 2, 3, 4, 5]) 15 >>> max_subarray_sum([-1, -2, -3, -4, -5]) -1 >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([3]) 3 >>> max_subarray_sum([-3]) -3 >>> max_subarray_sum([]) 0","solution":"def max_subarray_sum(arr): Function to find the maximum sum of a contiguous subarray using Kadane's Algorithm. :param arr: List[int] - List of integers :return: int - Maximum sum of a contiguous subarray if not arr: return 0 max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"def lexicographically_smallest_concatenation(words): Concatenate the given list of strings in such a way that the resultant string is the lexicographically smallest string possible. Args: words (List[str]): List of strings to concatenate. Returns: str: Lexicographically smallest concatenated string. >>> lexicographically_smallest_concatenation(['apple']) == 'apple' >>> lexicographically_smallest_concatenation(['bat', 'apple']) == 'applebat' >>> lexicographically_smallest_concatenation(['cat', 'bat', 'apple']) == 'applebatcat' >>> lexicographically_smallest_concatenation(['cat', 'car', 'bat']) == 'batcarcat' >>> lexicographically_smallest_concatenation(['a', 'b', 'a']) == 'aab' >>> lexicographically_smallest_concatenation([]) == '' # Your code here","solution":"def lexicographically_smallest_concatenation(words): Concatenate the given list of strings in such a way that the resultant string is the lexicographically smallest string possible. Args: words (List[str]): List of strings to concatenate. Returns: str: Lexicographically smallest concatenated string. # Sort the words based on the criteria that the concatenation of two words produces the smaller string sorted_words = sorted(words, key=lambda x: (x*len(words))) return ''.join(sorted_words)"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def is_happy_linked_list(head: ListNode) -> bool: Determine whether the linked list is a \\"happy\\" linked list. >>> head = ListNode(1, ListNode(9, ListNode(7))) >>> is_happy_linked_list(head) == False >>> head = ListNode(1) >>> is_happy_linked_list(head) == True >>> head = ListNode(7) >>> is_happy_linked_list(head) == True >>> head = ListNode(2) >>> is_happy_linked_list(head) == False >>> head = ListNode(1, ListNode(0, ListNode(0))) >>> is_happy_linked_list(head) == True","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def is_happy_number(n): def sum_of_squares(num): return sum(int(digit) ** 2 for digit in str(num)) seen = set() while n != 1 and n not in seen: seen.add(n) n = sum_of_squares(n) return n == 1 def linked_list_to_number(head): num = 0 factor = 1 current = head while current: num += current.val * factor factor *= 10 current = current.next return num def is_happy_linked_list(head): number = linked_list_to_number(head) return is_happy_number(number)"},{"question":"def contains_nearby_duplicate(nums: List[int], k: int) -> bool: Determines if the array contains two distinct indices i and j such that nums[i] == nums[j] and the absolute difference between i and j is at most k. >>> contains_nearby_duplicate([1, 2, 3, 1, 2, 3], 2) False >>> contains_nearby_duplicate([1, 2, 3, 1, 2, 3], 3) True","solution":"def contains_nearby_duplicate(nums, k): Determines if the array contains two distinct indices i and j such that nums[i] == nums[j] and the absolute difference between i and j is at most k. :param nums: List[int] - Array of integers :param k: int - Maximum allowed index difference :return: bool - True if such elements exist, False otherwise index_map = {} for i, num in enumerate(nums): if num in index_map and i - index_map[num] <= k: return True index_map[num] = i return False"},{"question":"def count_valid_purchases(logs: List[List[str]]) -> Dict[str, int]: Returns a dictionary where the keys are user_id and the values are the count of valid purchase actions for that user. Args: logs: A 2D list where each element is a list containing user_id and action_type. Returns: A dictionary with user_id as keys and the count of valid purchase actions as values. >>> count_valid_purchases([[\\"user1\\", \\"login\\"], [\\"user1\\", \\"purchase\\"], [\\"user1\\", \\"logout\\"]]) {\\"user1\\": 1} >>> count_valid_purchases([[\\"user1\\", \\"purchase\\"], [\\"user1\\", \\"login\\"], [\\"user1\\", \\"logout\\"], [\\"user1\\", \\"purchase\\"]]) {\\"user1\\": 0}","solution":"def count_valid_purchases(logs): Returns a dictionary where keys are user_id and values are the count of valid 'purchase' actions for that user. users = {} user_sessions = {} for user_id, action_type in logs: if user_id not in users: users[user_id] = 0 user_sessions[user_id] = {'logged_in': False, 'valid_purchases': 0} if action_type == \\"login\\": user_sessions[user_id]['logged_in'] = True elif action_type == \\"logout\\": user_sessions[user_id]['logged_in'] = False elif action_type == \\"purchase\\": if user_sessions[user_id]['logged_in']: users[user_id] += 1 return users"},{"question":"def replace_with_product_of_previous_k(arr: List[int], k: int) -> List[int]: Replaces every element at index i in arr with the product of the previous k elements before it. If there are fewer than k elements before it, use only the available elements. Parameters: arr (List[int]): A list of integers. k (int): The number of previous elements to consider for the product. Returns: List[int]: The modified list after applying the transformation. Examples: >>> replace_with_product_of_previous_k([1, 2, 3, 4, 5], 2) [1, 1, 2, 6, 12] >>> replace_with_product_of_previous_k([1, 2, 3], 5) [1, 1, 2] >>> replace_with_product_of_previous_k([2, 3, 4], 0) [2, 3, 4] >>> replace_with_product_of_previous_k([2, 3, 4], 1) [1, 2, 3] >>> replace_with_product_of_previous_k([], 3) [] >>> replace_with_product_of_previous_k([-1, -2, -3, -4], 2) [1, -1, 2, 6] >>> replace_with_product_of_previous_k([0, 0, 0, 0], 3) [1, 0, 0, 0] >>> replace_with_product_of_previous_k([7], 2) [1] >>> replace_with_product_of_previous_k([1, 2, 3, 4, 5, 6], 10) [1, 1, 2, 6, 24, 120] pass","solution":"def replace_with_product_of_previous_k(arr, k): Replaces every element at index i in arr with the product of the previous k elements before it. If there are fewer than k elements before it, use only the available elements. if not arr or k <= 0: return arr n = len(arr) result = [0] * n for i in range(n): product = 1 for j in range(max(0, i - k), i): product *= arr[j] result[i] = product return result"},{"question":"from typing import List, Tuple import heapq def minimum_max_difference(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int: Returns the minimum possible value of the maximum altitude difference for any path from start to end in the grid. grid: List[List[int]], a 2D list representing the grid. start: Tuple[int, int], the starting coordinate. end: Tuple[int, int], the ending coordinate. >>> minimum_max_difference([ ... [1, 3, 5], ... [4, 5, 6], ... [7, 8, 9]], (0, 0), (2, 2)) 3 >>> minimum_max_difference([[1]], (0, 0), (0, 0)) 0 def test_example_case(): grid = [ [1, 3, 5], [4, 5, 6], [7, 8, 9] ] start = (0, 0) end = (2, 2) assert minimum_max_difference(grid, start, end) == 3 def test_single_cell_grid(): grid = [[1]] start = (0, 0) end = (0, 0) assert minimum_max_difference(grid, start, end) == 0 def test_horizontal_path(): grid = [ [1, 10], [1, 1] ] start = (0, 1) end = (1, 1) assert minimum_max_difference(grid, start, end) == 9 def test_vertical_path(): grid = [ [1], [10], [1] ] start = (0, 0) end = (2, 0) assert minimum_max_difference(grid, start, end) == 9 def test_larger_grid(): grid = [ [1, 2, 2, 5], [1, 2, 2, 100], [1, 2, 2, 5], [1, 2, 2, 5] ] start = (0, 0) end = (3, 3) assert minimum_max_difference(grid, start, end) == 3","solution":"import heapq def minimum_max_difference(grid, start, end): Returns the minimum possible value of the maximum altitude difference for any path from start to end in the grid. grid: List[List[int]], a 2D list representing the grid. start: Tuple[int, int], the starting coordinate. end: Tuple[int, int], the ending coordinate. m, n = len(grid), len(grid[0]) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] def valid(row, col): return 0 <= row < m and 0 <= col < n min_heap = [(0, start)] max_diff = [[float('inf')] * n for _ in range(m)] max_diff[start[0]][start[1]] = 0 while min_heap: current_diff, (x, y) = heapq.heappop(min_heap) if (x, y) == end: return current_diff for dx, dy in directions: nx, ny = x + dx, y + dy if valid(nx, ny): next_diff = max(current_diff, abs(grid[nx][ny] - grid[x][y])) if next_diff < max_diff[nx][ny]: max_diff[nx][ny] = next_diff heapq.heappush(min_heap, (next_diff, (nx, ny))) return -1 # should never reach here given the problem constraints"},{"question":"def can_finish(numCourses: int, prerequisites: List[List[int]]) -> bool: Return true if you can finish all courses given the prerequisites. >>> can_finish(2, []) True >>> can_finish(2, [[1, 0]]) True >>> can_finish(2, [[1, 0], [0, 1]]) False >>> can_finish(4, [[1, 0], [2, 1], [3, 2], [0, 3]]) False >>> can_finish(4, [[1, 0], [2, 0], [3, 1], [3, 2]]) True >>> can_finish(5, [[1, 0], [2, 1], [4, 3]]) True >>> can_finish(6, [[2, 1], [2, 0], [3, 2], [4, 2], [5, 3], [5, 4]]) True >>> can_finish(6, [[2, 1], [2, 0], [3, 2], [4, 2], [5, 3], [5, 4], [1, 5]]) False","solution":"from typing import List def can_finish(numCourses: int, prerequisites: List[List[int]]) -> bool: from collections import defaultdict, deque # Create a graph representation of the prerequisites graph = defaultdict(list) in_degree = [0] * numCourses # Build the graph and count the in-degree for each course for dest, src in prerequisites: graph[src].append(dest) in_degree[dest] += 1 # Initialize a queue with courses that have no prerequisites queue = deque([i for i in range(numCourses) if in_degree[i] == 0]) count = 0 while queue: course = queue.popleft() count += 1 for neighbor in graph[course]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # If count of courses processed equals the total number of courses, return True return count == numCourses"},{"question":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def rotateRight(head: ListNode, k: int) -> ListNode: Rotate the linked list to the right by k places. >>> list_to_python_list(rotateRight(python_list_to_list([1, 2, 3, 4, 5]), 2)) [4, 5, 1, 2, 3] >>> list_to_python_list(rotateRight(python_list_to_list([1, 2, 3, 4, 5]), 5)) [1, 2, 3, 4, 5] >>> list_to_python_list(rotateRight(python_list_to_list([1]), 2)) [1] >>> list_to_python_list(rotateRight(python_list_to_list([]), 2)) [] >>> list_to_python_list(rotateRight(python_list_to_list([1, 2, 3, 4, 5]), 0)) [1, 2, 3, 4, 5]","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def rotateRight(head, k): if not head or not head.next or k == 0: return head # Compute the length of the list and make it circular. old_tail = head length = 1 while old_tail.next: old_tail = old_tail.next length += 1 old_tail.next = head # make it circular # Find the new tail after rotation. k = k % length new_tail = head for _ in range(length - k - 1): new_tail = new_tail.next new_head = new_tail.next # Break the circular list. new_tail.next = None return new_head"},{"question":"from typing import List def rearrange_array(arr: List[int], k: int) -> List[int]: Rearrange the elements of arr such that every k consecutive numbers follow a pattern where they are in decreasing order. Parameters: arr (List[int]): Array of integers to be rearranged k (int): Segment length for the rearrangement pattern Returns: List[int]: The rearranged array Examples: >>> rearrange_array([10, 5, 20, 7, 8, 30, 15, 18], 3) [20, 10, 5, 30, 8, 7, 18, 15] >>> rearrange_array([4, 2, 1], 3) [4, 2, 1] >>> rearrange_array([1, 2, 3, 4, 5, 6, 7, 8, 9], 3) [3, 2, 1, 6, 5, 4, 9, 8, 7] >>> rearrange_array([1, 2, 3, 4, 5, 6, 7, 8], 3) [3, 2, 1, 6, 5, 4, 8, 7] >>> rearrange_array([1], 1) [1] >>> rearrange_array([1, 2, 3, 4], 4) [4, 3, 2, 1] >>> rearrange_array([1, 2, 3], 5) [3, 2, 1] >>> rearrange_array([], 5) []","solution":"def rearrange_array(arr, k): Rearrange the elements of arr such that every k consecutive numbers follow a pattern where they are in decreasing order. n = len(arr) for i in range(0, n, k): segment = arr[i:i+k] arr[i:i+k] = sorted(segment, reverse=True) return arr"},{"question":"from typing import List def minimum_cost_to_connect_computers(n: int, connections: List[List[int]]) -> int: Calculate the minimum data transfer time to connect all computers. :param n: Number of computers :param connections: List of connections where each connection is represented as [computer1, computer2, time] :return: Minimum data transfer time to connect all computers or -1 if it is impossible >>> minimum_cost_to_connect_computers(3, [[1, 2, 1], [2, 3, 2], [1, 3, 2]]) 3 >>> minimum_cost_to_connect_computers(4, [[1, 2, 1], [3, 4, 2]]) -1 >>> minimum_cost_to_connect_computers(4, [[1, 2, 1], [2, 3, 1], [3, 4, 1], [4, 1, 1]]) 3 >>> minimum_cost_to_connect_computers(5, [[1, 2, 2], [1, 3, 4], [3, 4, 3], [2, 4, 1], [2, 5, 5], [5, 3, 7]]) 11 >>> minimum_cost_to_connect_computers(1, []) 0 >>> minimum_cost_to_connect_computers(2, [[1, 2, 10]]) 10 >>> minimum_cost_to_connect_computers(2, []) -1 pass","solution":"def minimum_cost_to_connect_computers(n, connections): Calculate the minimum data transfer time to connect all computers. :param n: Number of computers :param connections: List of connections where each connection is represented as [computer1, computer2, time] :return: Minimum data transfer time to connect all computers or -1 if it is impossible parent = list(range(n)) rank = [0] * n def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 return True return False connections.sort(key=lambda x: x[2]) total_cost = 0 edges_used = 0 for u, v, weight in connections: if union(u-1, v-1): total_cost += weight edges_used += 1 if edges_used == n - 1: return total_cost return -1 if edges_used < n - 1 else total_cost"},{"question":"def can_transform_to_empty_string(s: str) -> bool: Determines whether it is possible to transform the given string into an empty string by repeatedly removing any two adjacent characters if they are different. :param s: A string of characters 'a' and 'b' :return: True if it is possible to transform the string into an empty string, False otherwise. >>> can_transform_to_empty_string(\\"\\") True >>> can_transform_to_empty_string(\\"aa\\") False >>> can_transform_to_empty_string(\\"ab\\") True >>> can_transform_to_empty_string(\\"abba\\") True >>> can_transform_to_empty_string(\\"aabbaa\\") False >>> can_transform_to_empty_string(\\"abab\\") True >>> can_transform_to_empty_string(\\"baab\\") True >>> can_transform_to_empty_string(\\"abababababab\\") True >>> can_transform_to_empty_string(\\"aabbaabb\\") True","solution":"def can_transform_to_empty_string(s): Determines whether it is possible to transform the given string into an empty string by repeatedly removing any two adjacent characters if they are different. :param s: A string of characters 'a' and 'b' :return: True if it is possible to transform the string into an empty string, False otherwise. # Initialize an empty stack stack = [] # Iterate through each character in the string for char in s: # If stack is not empty and the top of the stack is different from the current character, # it means we can remove this pair, so we pop the top of the stack. if stack and stack[-1] != char: stack.pop() else: # Otherwise, we push the current character to the stack stack.append(char) # If the stack is empty, it means the string can be reduced to an empty string return len(stack) == 0"},{"question":"from typing import List def trap_rain_water(matrix: List[List[int]]) -> int: Calculate the total amount of water trapped after it rains in a given rectangular matrix. Args: matrix (List[List[int]]): A rectangular matrix of integers representing heights of the cells. Returns: int: The total volume of water trapped. >>> trap_rain_water([[5]]) 0 >>> trap_rain_water([ [1, 1, 1, 1], [1, 2, 2, 1], [1, 2, 2, 1], [1, 1, 1, 1] ]) 0 >>> trap_rain_water([ [1, 2, 2, 3], [2, 1, 1, 2], [2, 1, 1, 2], [1, 2, 2, 2] ]) 4 >>> trap_rain_water([ [1, 4, 3, 1, 3, 2], [3, 2, 1, 3, 2, 4], [2, 3, 3, 2, 3, 1] ]) 4 >>> trap_rain_water([]) 0 >>> trap_rain_water([ [0, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, 0] ]) 0 # Function implementation here","solution":"import heapq def trap_rain_water(matrix): if not matrix or not matrix[0]: return 0 n, m = len(matrix), len(matrix[0]) visited = [[False] * m for _ in range(n)] heap = [] # Push all the cells on the border into the heap for i in range(n): heapq.heappush(heap, (matrix[i][0], i, 0)) heapq.heappush(heap, (matrix[i][m-1], i, m-1)) visited[i][0] = visited[i][m-1] = True for j in range(m): heapq.heappush(heap, (matrix[0][j], 0, j)) heapq.heappush(heap, (matrix[n-1][j], n-1, j)) visited[0][j] = visited[n-1][j] = True directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] water_trapped = 0 while heap: height, x, y = heapq.heappop(heap) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny]: visited[nx][ny] = True water_trapped += max(0, height - matrix[nx][ny]) heapq.heappush(heap, (max(height, matrix[nx][ny]), nx, ny)) return water_trapped"},{"question":"def rle_kth_character(rle_string: str, k: int) -> str: Given a Run-Length Encoded (RLE) string and a number k, return the k-th character in the original string. If k is out of bounds, return an empty string. >>> rle_kth_character(\\"a3b2c4\\", 1) \\"a\\" >>> rle_kth_character(\\"a3b2c4\\", 4) \\"b\\" >>> rle_kth_character(\\"a3b2c4\\", 6) \\"c\\" >>> rle_kth_character(\\"a3b2c4\\", 10) \\"\\" >>> rle_kth_character(\\"a1\\", 1) \\"a\\" >>> rle_kth_character(\\"a1\\", 2) \\"\\" >>> rle_kth_character(\\"a1b1c1\\", 3) \\"c\\" >>> rle_kth_character(\\"a10b5\\", 10) \\"a\\" >>> rle_kth_character(\\"a10b5\\", 11) \\"b\\" >>> rle_kth_character(\\"\\", 1) \\"\\"","solution":"def rle_kth_character(rle_string, k): Given a Run-Length Encoded (RLE) string and a number k, return the k-th character in the original string. If k is out of bounds, return an empty string. original_length = 0 i = 0 n = len(rle_string) # Decode RLE string to find the k-th character while i < n: char = rle_string[i] i += 1 count_str = '' # Read the number associated with the character while i < n and rle_string[i].isdigit(): count_str += rle_string[i] i += 1 count = int(count_str) original_length += count # Check if k-th character is within this segment if k <= original_length: return char return \\"\\" # Example usage: # rle_string = \\"a3b2c4\\" # k = 5 # print(rle_kth_character(rle_string, k)) # Output: \\"b\\""},{"question":"def is_palindrome(s: str) -> bool: Checks whether the given string is a valid palindrome considering only alphanumeric characters and ignoring cases. >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") == True >>> is_palindrome(\\"race a car\\") == False >>> is_palindrome(\\"\\") == True >>> is_palindrome(\\"a\\") == True >>> is_palindrome(\\"!@#%^&*()\\") == True","solution":"def is_palindrome(s): Checks whether the given string is a valid palindrome considering only alphanumeric characters and ignoring cases. :param s: A string to be checked for palindrome property. :return: True if the string is a palindrome, False otherwise. filtered_chars = [char.lower() for char in s if char.isalnum()] return filtered_chars == filtered_chars[::-1]"},{"question":"from typing import List def max_non_overlapping_jobs(jobs: List[List[int]]) -> int: Given a list of jobs where each job is represented by [start, end] and is sorted by their end time, find the maximum number of non-overlapping jobs that can be scheduled. >>> max_non_overlapping_jobs([[1, 3], [2, 5], [3, 9], [6, 8]]) == 2 >>> max_non_overlapping_jobs([[1, 2]]) == 1 >>> max_non_overlapping_jobs([]) == 0 >>> max_non_overlapping_jobs([[1, 2], [3, 4], [5, 6], [7, 8]]) == 4 >>> max_non_overlapping_jobs([[1, 5], [2, 6], [3, 7], [4, 8]]) == 1 >>> max_non_overlapping_jobs([[1, 4], [2, 3], [3, 6], [4, 5], [5, 8]]) == 3","solution":"def max_non_overlapping_jobs(jobs): Given a list of jobs where each job is represented by [start, end] and is sorted by their end time, find the maximum number of non-overlapping jobs that can be scheduled. if not jobs: return 0 count = 1 last_end_time = jobs[0][1] for i in range(1, len(jobs)): if jobs[i][0] >= last_end_time: count += 1 last_end_time = jobs[i][1] return count"},{"question":"def plus_one(digits: List[int]) -> List[int]: Increments the non-negative integer represented by the list of digits by one and returns the resulting list of digits. Example: >>> plus_one([1]) [2] >>> plus_one([9]) [1, 0] >>> plus_one([1, 2, 3]) [1, 2, 4] >>> plus_one([9, 9, 9]) [1, 0, 0, 0]","solution":"def plus_one(digits): Increments the non-negative integer represented by the list of digits by one and returns the resulting list of digits. n = len(digits) carry = 1 # Initialize carry as 1 since we are adding one to the number for i in range(n - 1, -1, -1): new_digit = digits[i] + carry if new_digit == 10: digits[i] = 0 else: digits[i] = new_digit carry = 0 break if carry == 1: digits.insert(0, 1) return digits"},{"question":"def rearrange_array(nums, k): Rearranges \`nums\` so that the difference between all adjacent elements is at most \`k\`. Returns the rearranged array if possible, otherwise returns an empty array. >>> rearrange_array([1, 3, 2], 2) == [1, 2, 3] >>> rearrange_array([1, 5, 9], 4) == [1, 5, 9] >>> rearrange_array([4, 1, 3, 2], 1) == [1, 2, 3, 4] >>> rearrange_array([1, 7, 9], 2) == [] >>> rearrange_array([10, 1, 5, 11], 4) == [] >>> rearrange_array([5], 1) == [5] >>> rearrange_array([2, 2, 2, 2], 0) == [2, 2, 2, 2] >>> rearrange_array([1, 100], 99) == [1, 100] >>> rearrange_array([1, 100], 50) == []","solution":"def rearrange_array(nums, k): Rearranges \`nums\` so that the difference between all adjacent elements is at most \`k\`. Returns the rearranged array if possible, otherwise returns an empty array. nums.sort() result = [nums[0]] for i in range(1, len(nums)): if abs(nums[i] - result[-1]) > k: return [] result.append(nums[i]) return result"},{"question":"def is_palindrome(n: int) -> bool: Helper function to check if a number is a palindrome. >>> is_palindrome(121) True >>> is_palindrome(123) False >>> is_palindrome(1) True >>> is_palindrome(1221) True >>> is_palindrome(10) False def closest_palindromic_number(num: int) -> int: Returns the closest palindromic number to the given number. If the number is already a palindrome, it returns the number itself. >>> closest_palindromic_number(123) 121 >>> closest_palindromic_number(121) 121 >>> closest_palindromic_number(10) 9 >>> closest_palindromic_number(1) 1 >>> closest_palindromic_number(123456) 123321 >>> closest_palindromic_number(11) 11 >>> closest_palindromic_number(22) 22","solution":"def is_palindrome(n): Helper function to check if a number is a palindrome. return str(n) == str(n)[::-1] def closest_palindromic_number(num): Returns the closest palindromic number to the given number. If the number is already a palindrome, it returns the number itself. if is_palindrome(num): return num lower, higher = num - 1, num + 1 while True: if lower > 0 and is_palindrome(lower): return lower if is_palindrome(higher): return higher lower -= 1 higher += 1"},{"question":"def range_sum(arr: List[int], queries: List[List[int]]) -> List[int]: Return the sum of elements within a given range for each query. Args: arr: List of integers. queries: List of queries, where each query is represented as a pair of integers [left, right]. Returns: List of the sums for each query range. Examples: >>> range_sum([1, 2, 3, 4, 5], [[0, 2], [1, 3], [2, 4]]) [6, 9, 12] >>> range_sum([1, 2, 3, 4, 5], [[0, 4]]) [15] >>> range_sum([1, 2, 3, 4, 5], [[1, 3]]) [9] pass # Unit Test def test_range_sum(): assert range_sum([1, 2, 3, 4, 5], [[0, 2], [1, 3], [2, 4]]) == [6, 9, 12] assert range_sum([1, 2, 3, 4, 5], [[0, 0], [1, 1], [2, 2]]) == [1, 2, 3] assert range_sum([1, 2, 3, 4, 5], [[0, 4]]) == [15] assert range_sum([1, 2, 3, 4, 5], [[1, 3]]) == [9] assert range_sum([], [[0, 0]]) == [0] assert range_sum([1], [[0, 0]]) == [1] def test_range_sum_edge_cases(): assert range_sum([10, 20, 30, 40, 50], [[0, 4], [1, 3], [2, 2]]) == [150, 90, 30] assert range_sum([100, -100, 50, -50, 0], [[0, 2], [1, 4], [2, 4]]) == [50, -100, 0]","solution":"def range_sum(arr, queries): Returns an array of sums for each query range in arr. result = [] for left, right in queries: result.append(sum(arr[left:right+1])) return result"},{"question":"from typing import List from collections import Counter import heapq def rearrange_string(s: str, k: int) -> str: Determine if you can rearrange the characters in the string such that there are at most \`k\` distinct characters between any two identical characters. If possible, return one valid arrangement. If not, return an empty string. >>> rearrange_string(\\"aabbcc\\", 2) in [\\"abacbc\\", \\"abcabc\\"] True >>> rearrange_string(\\"aaabc\\", 3) '' >>> rearrange_string(\\"aabbcc\\", 1) 'aabbcc' >>> rearrange_string(\\"abcdef\\", 6) 'abcdef' >>> rearrange_string(\\"aaa\\", 2) '' >>> rearrange_string(\\"aabb\\", 2) 'abab'","solution":"from collections import Counter import heapq def rearrange_string(s, k): if k <= 1: return s counter = Counter(s) max_heap = [(-value, key) for key, value in counter.items()] heapq.heapify(max_heap) result = [] queue = [] while max_heap: cnt, ch = heapq.heappop(max_heap) result.append(ch) queue.append((ch, cnt + 1)) if len(queue) < k: continue ch_waiting, cnt_waiting = queue.pop(0) if -cnt_waiting > 0: heapq.heappush(max_heap, (cnt_waiting, ch_waiting)) return \\"\\".join(result) if len(result) == len(s) else \\"\\""},{"question":"from typing import List def trap(height: List[int]) -> int: Given an integer array representing the heights of poles, calculate the amount of water that can be trapped. >>> trap([]) 0 >>> trap([1]) 0 >>> trap([1, 2, 3, 4, 5]) 0 >>> trap([0, 2, 0]) 0 >>> trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap([4, 2, 0, 3, 2, 5]) 9 >>> trap([3, 3, 3, 3, 3]) 0","solution":"def trap(height): Given an integer array representing the heights of poles, calculate the amount of water that can be trapped. if not height or len(height) < 3: return 0 left = 0 right = len(height) - 1 left_max = height[left] right_max = height[right] trapped_water = 0 while left < right: if height[left] < height[right]: left += 1 left_max = max(left_max, height[left]) trapped_water += left_max - height[left] else: right -= 1 right_max = max(right_max, height[right]) trapped_water += right_max - height[right] return trapped_water"},{"question":"def construct_repeated_string(nums: List[int], k: int) -> str: Constructs a string by repeating each number in \`nums\` exactly \`k\` times, placing a hyphen '-' between consecutive numbers, but excluding the hyphen after the last number in the string. Parameters: nums (list of int): The list of numbers to be repeated. k (int): The number of times each number in the list needs to be repeated. Returns: str: The constructed string based on the given rules. >>> construct_repeated_string([1, 2, 3], 2) \\"11-22-33\\" >>> construct_repeated_string([], 3) \\"\\" >>> construct_repeated_string([1, 2, 3], 0) \\"\\" >>> construct_repeated_string([5], 3) \\"555\\" >>> construct_repeated_string([8, 4, 2], 1) \\"8-4-2\\" >>> construct_repeated_string([7], 5) \\"77777\\" >>> construct_repeated_string([-1, -2], 2) \\"-1-1--2-2\\" >>> construct_repeated_string([0, 2], 3) \\"000-222\\"","solution":"def construct_repeated_string(nums, k): Constructs a string by repeating each number in \`nums\` exactly \`k\` times, placing a hyphen '-' between consecutive numbers, but excluding the hyphen after the last number in the string. Parameters: nums (list of int): The list of numbers to be repeated. k (int): The number of times each number in the list needs to be repeated. Returns: str: The constructed string based on the given rules. if k == 0 or not nums: return \\"\\" result_parts = [] for num in nums: repeated_part = str(num) * k result_parts.append(repeated_part) return '-'.join(result_parts)"},{"question":"def evaluate_expression(expression: str) -> float: Evaluates a string expression containing only digits, '+', '-', and '.'. Only handles addition and subtraction with correct precedence. >>> evaluate_expression(\\"2+3\\") 5.0 >>> evaluate_expression(\\"5-2\\") 3.0 >>> evaluate_expression(\\"10+5-3\\") 12.0 >>> evaluate_expression(\\"2.5+3.5\\") 6.0 >>> evaluate_expression(\\"10.1-1.1\\") 9.0 >>> evaluate_expression(\\"2+3.5-1+4.2-3.1\\") 5.6 >>> evaluate_expression(\\"10.5-2.5+3.2-1.2\\") 10.0 >>> evaluate_expression(\\"100+200-50\\") 250.0","solution":"def evaluate_expression(expression): Evaluates a string expression containing only digits, '+', '-', and '.'. Only handles addition and subtraction with correct precedence. tokens = [] num = \\"\\" # Tokenize the string for char in expression: if char in '0123456789.': num += char elif char in '+-': if num: tokens.append(float(num)) num = \\"\\" tokens.append(char) if num: tokens.append(float(num)) # Evaluate the expression result = tokens[0] i = 1 while i < len(tokens): op = tokens[i] num = tokens[i + 1] if op == '+': result += num elif op == '-': result -= num i += 2 return result"},{"question":"def longest_contiguous_ones(nums): Returns the length of the longest contiguous subarray of 1s that can be obtained after performing at most one flip. >>> longest_contiguous_ones([1, 1, 1, 1]) 4 >>> longest_contiguous_ones([1, 0, 1, 1, 0]) 4 >>> longest_contiguous_ones([0, 0, 0, 0]) 1 >>> longest_contiguous_ones([1, 1, 0, 1, 1, 0, 1, 1]) 5 >>> longest_contiguous_ones([1]) 1 >>> longest_contiguous_ones([0]) 1 >>> longest_contiguous_ones([]) 0 >>> longest_contiguous_ones([0, 1, 1, 1, 1]) 5 >>> longest_contiguous_ones([1, 1, 1, 1, 0]) 5","solution":"def longest_contiguous_ones(nums): Returns the length of the longest contiguous subarray of 1s that can be obtained after performing at most one flip. if not nums: return 0 max_ones = 0 left = 0 zero_count = 0 for right in range(len(nums)): if nums[right] == 0: zero_count += 1 while zero_count > 1: if nums[left] == 0: zero_count -= 1 left += 1 max_ones = max(max_ones, right - left + 1) return max_ones"},{"question":"def canTransform(s1: str, s2: str) -> bool: Determine if one string can be transformed into the other by performing insert, delete, or replace operations any number of times. Args: s1 (str): The first string. s2 (str): The second string. Returns: bool: True if s1 can be transformed into s2, False otherwise. >>> canTransform(\\"abc\\", \\"abc\\") True >>> canTransform(\\"abc\\", \\"abcd\\") False >>> canTransform(\\"abcd\\", \\"abc\\") False >>> canTransform(\\"abc\\", \\"abd\\") False >>> canTransform(\\"abcdef\\", \\"azced\\") False >>> canTransform(\\"\\", \\"\\") True >>> canTransform(\\"abc\\", \\"\\") False >>> canTransform(\\"\\", \\"abc\\") False","solution":"def canTransform(s1, s2): Returns true if s1 can be transformed into s2 by insert, delete, or replace operations, otherwise returns false. Uses the edit distance algorithm to determine the transformability. len1, len2 = len(s1), len(s2) # Create a DP table to store the minimum edit distance dp = [[0]*(len2+1) for _ in range(len1+1)] # Initialize the dp table for i in range(len1+1): for j in range(len2+1): if i == 0: dp[i][j] = j # Insert all characters of s2 elif j == 0: dp[i][j] = i # Delete all characters of s1 elif s1[i-1] == s2[j-1]: dp[i][j] = dp[i-1][j-1] # If characters are the same, no operation needed else: dp[i][j] = 1 + min(dp[i-1][j], # Delete character from s1 dp[i][j-1], # Insert character into s1 dp[i-1][j-1]) # Replace character in s1 return dp[len1][len2] == 0"},{"question":"from typing import List def permute(nums: List[int]) -> List[List[int]]: Given a list of unique integers nums, returns all possible permutations of the list. Each permutation must be a new list and the permutations can be returned in any order. >>> sorted(permute([1, 2, 3])) [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] >>> permute([1]) [[1]] >>> sorted(permute([1, 2])) [[1, 2], [2, 1]] >>> permute([]) [[]] >>> sorted(permute([1, 2, 3, 4])) == sorted([ ... [1, 2, 3, 4], [1, 2, 4, 3], [1, 3, 2, 4], [1, 3, 4, 2], [1, 4, 2, 3], [1, 4, 3, 2], ... [2, 1, 3, 4], [2, 1, 4, 3], [2, 3, 1, 4], [2, 3, 4, 1], [2, 4, 1, 3], [2, 4, 3, 1], ... [3, 1, 2, 4], [3, 1, 4, 2], [3, 2, 1, 4], [3, 2, 4, 1], [3, 4, 1, 2], [3, 4, 2, 1], ... [4, 1, 2, 3], [4, 1, 3, 2], [4, 2, 1, 3], [4, 2, 3, 1], [4, 3, 1, 2], [4, 3, 2, 1] ... ]) True","solution":"from typing import List from itertools import permutations def permute(nums: List[int]) -> List[List[int]]: Returns all possible permutations of a list of unique integers. return [list(p) for p in permutations(nums)]"},{"question":"def max_answer_sheets(times) -> int: Returns the maximum number of answer sheets that can be stacked in strictly increasing order of times. Args: times: List[int] - An array of integers representing the time taken by each student to complete a test. Returns: int - The maximum number of answer sheets that can be stacked. >>> max_answer_sheets([1, 2, 3, 4, 5]) 5 >>> max_answer_sheets([5, 4, 3, 2, 1]) 1 >>> max_answer_sheets([10, 5, 2, 8, 6, 14, 3]) 3 >>> max_answer_sheets([7]) 1 >>> max_answer_sheets([3, 3, 3]) 1 >>> max_answer_sheets([]) 0","solution":"def max_answer_sheets(times): Returns the maximum number of answer sheets that can be stacked in strictly increasing order of times. Args: times: List[int] - An array of integers representing the time taken by each student to complete a test. Returns: int - The maximum number of answer sheets that can be stacked. if not times: return 0 longest_increasing_subsequence = [1] * len(times) for i in range(1, len(times)): for j in range(i): if times[i] > times[j]: longest_increasing_subsequence[i] = max(longest_increasing_subsequence[i], longest_increasing_subsequence[j] + 1) return max(longest_increasing_subsequence)"},{"question":"def is_strictly_increasing_digits(s: str) -> bool: Checks if the digits in the string s form a strictly increasing sequence. :param s: Input string containing a mix of alphabets and digits :return: True if the digits form a strictly increasing sequence, False otherwise Examples: >>> is_strictly_increasing_digits(\\"a1b3c5d7\\") True >>> is_strictly_increasing_digits(\\"a3b2c4\\") False","solution":"def is_strictly_increasing_digits(s): Checks if the digits in the string s form a strictly increasing sequence. :param s: Input string containing a mix of alphabets and digits :return: True if the digits form a strictly increasing sequence, False otherwise digits = [int(char) for char in s if char.isdigit()] return all(earlier < later for earlier, later in zip(digits, digits[1:]))"},{"question":"def can_form_increasing_subsequence(nums: List[int], k: int) -> bool: Determine if an increasing subsequence of length k can be formed from nums. >>> can_form_increasing_subsequence([3, 1, 2, 4], 3) True >>> can_form_increasing_subsequence([10, 5, 6, 7, 1], 4) True >>> can_form_increasing_subsequence([5, 4, 3], 2) True >>> can_form_increasing_subsequence([10, 20, 30], 4) False >>> can_form_increasing_subsequence([1], 1) True >>> can_form_increasing_subsequence([1], 2) False >>> can_form_increasing_subsequence([], 1) False pass # Your code here","solution":"def can_form_increasing_subsequence(nums, k): Determine if an increasing subsequence of length k can be formed from nums. n = len(nums) if k > n: return False # Use a simple loop to form a possible increasing subsequence of length k subsequence = [] for num in sorted(nums): if len(subsequence) < k: subsequence.append(num) if len(subsequence) == k: break return len(subsequence) == k"},{"question":"from typing import List def smallestStringWithSwaps(s: str, pairs: List[List[int]]) -> str: Given a list of swapped pairs \`pairs\` where each pair [u, v] indicates that \`u\` and \`v\` can be swapped, and a string \`s\`, determine the lexicographically smallest string that can be obtained by applying any number of swaps on the characters in the string. Return the lexicographically smallest string that can be obtained after performing the swaps. >>> smallestStringWithSwaps(\\"dcab\\", [[0,3],[1,2]]) == \\"bacd\\" >>> smallestStringWithSwaps(\\"dcab\\", [[0,3],[1,2],[0,2]]) == \\"abcd\\" >>> smallestStringWithSwaps(\\"cba\\", [[0, 1], [1, 2]]) == \\"abc\\" >>> smallestStringWithSwaps(\\"\\", []) == \\"\\" >>> smallestStringWithSwaps(\\"abcd\\", []) == \\"abcd\\" >>> smallestStringWithSwaps(\\"a\\", []) == \\"a\\"","solution":"def smallestStringWithSwaps(s, pairs): from collections import defaultdict def dfs(node, idx, visited, adj, chars, indices): visited[node] = True chars.append(s[node]) indices.append(node) for neighbor in adj[node]: if not visited[neighbor]: dfs(neighbor, idx, visited, adj, chars, indices) n = len(s) adj = defaultdict(list) for u, v in pairs: adj[u].append(v) adj[v].append(u) visited = [False] * n answer = list(s) for i in range(n): if not visited[i]: chars = [] indices = [] dfs(i, i, visited, adj, chars, indices) chars.sort() indices.sort() for idx, char in zip(indices, chars): answer[idx] = char return ''.join(answer)"},{"question":"def find_k_highest(nums: List[int], k: int) -> List[int]: Find and return a list of all the k-highest numbers in non-decreasing order. A number is called a k-highest in the array if it appears at least \`k\` times in the array. >>> find_k_highest([4, 1, 2, 2, 3, 1, 2, 3, 4, 3], 3) [2, 3] >>> find_k_highest([1, 2, 3, 4, 5], 2) []","solution":"def find_k_highest(nums, k): from collections import Counter # Count the frequency of each number in the array frequency_count = Counter(nums) # Filter the numbers that have a frequency of at least k k_highest_numbers = [num for num, count in frequency_count.items() if count >= k] k_highest_numbers.sort() return k_highest_numbers"},{"question":"def largestAltitude(gain): Returns the highest altitude reached at any point along the path. :param gain: List[int] - List of net gains in altitude at each point. :return: int - The highest altitude reached. # Unit tests def test_largestAltitude_all_positive_gains(): assert largestAltitude([1, 2, 3, 4]) == 10 def test_largestAltitude_all_negative_gains(): assert largestAltitude([-1, -2, -3, -4]) == 0 def test_largestAltitude_mixed_gains(): assert largestAltitude([-5, 1, 5, 0, -7]) == 1 def test_largestAltitude_no_gains(): assert largestAltitude([0, 0, 0, 0]) == 0 def test_largestAltitude_first_highest(): assert largestAltitude([3, -2, 5, -1]) == 6 def test_largestAltitude_intermittent_high_altitudes(): assert largestAltitude([1, 2, -1, 3, -2]) == 5 def test_largestAltitude_large_input(): assert largestAltitude([i for i in range(1000)]) == sum(range(1000))","solution":"def largestAltitude(gain): Returns the highest altitude reached at any point along the path. :param gain: List[int] - List of net gains in altitude at each point. :return: int - The highest altitude reached. altitude = 0 max_altitude = 0 for g in gain: altitude += g if altitude > max_altitude: max_altitude = altitude return max_altitude"},{"question":"def min_length_string(s: str) -> int: Given a string s consisting of characters 'a', 'b', and 'c', you can perform the following operation on s any number of times: Choose any substring of s and replace it with any character from 'a', 'b', or 'c'. Return the length of the shortest string you can obtain after performing any number of the given operations. >>> min_length_string(\\"aaa\\") 1 >>> min_length_string(\\"abc\\") 1 >>> min_length_string(\\"abac\\") 1 >>> min_length_string(\\"abcabcabcabc\\") 1 pass","solution":"def min_length_string(s): Returns the length of the shortest string that can be obtained by replacing any substring with any character 'a', 'b', or 'c'. As 'a', 'b', and 'c' can replace each other, the shortest possible string would be of length 1 (e.g., replacing the entire string with 'a'). # The shortest string we can obtain is always length 1 return 1"},{"question":"def min_operations_to_one_island(grid): Returns the minimum number of operations to connect all islands in the grid into one single island. pass from solution import min_operations_to_one_island def test_min_operations_no_zeros(): grid = [ [1, 1, 1], [1, 1, 1], [1, 1, 1] ] assert min_operations_to_one_island(grid) == 0 def test_min_operations_one_island(): grid = [ [1, 1, 0], [1, 1, 1], [0, 1, 1] ] assert min_operations_to_one_island(grid) == 0 def test_min_operations_two_islands(): grid = [ [1, 1, 0], [0, 0, 0], [0, 1, 1] ] assert min_operations_to_one_island(grid) == 1 def test_min_operations_three_islands(): grid = [ [1, 0, 1], [0, 0, 0], [1, 0, 1] ] assert min_operations_to_one_island(grid) == 1 def test_min_operations_large_grid(): grid = [ [1, 0, 0, 1], [0, 0, 0, 0], [0, 0, 0, 0], [1, 1, 1, 0] ] assert min_operations_to_one_island(grid) == 2","solution":"def min_operations_to_one_island(grid): Returns the minimum number of operations to connect all islands in the grid into one single island. from collections import deque def bfs(i, j, visited): queue = deque([(i, j)]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] visited[i][j] = True island = [] while queue: x, y = queue.popleft() island.append((x, y)) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and not visited[nx][ny] and grid[nx][ny] == 1: visited[nx][ny] = True queue.append((nx, ny)) return island def find_islands(): visited = [[False]*len(grid[0]) for _ in range(len(grid))] islands = [] for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1 and not visited[i][j]: island = bfs(i, j, visited) islands.append(island) return islands def calculate_distance(island1, island2): min_distance = float('inf') for (x1, y1) in island1: for (x2, y2) in island2: distance = abs(x1 - x2) + abs(y1 - y2) - 1 min_distance = min(min_distance, distance) return min_distance islands = find_islands() if len(islands) <= 1: return 0 min_operations = float('inf') for i in range(len(islands)): for j in range(i+1, len(islands)): distance = calculate_distance(islands[i], islands[j]) min_operations = min(min_operations, distance) return min_operations"},{"question":"def longest_smooth_subarray(arr, d): Returns the length of the longest smooth subarray. A subarray is considered smooth when the difference between the maximum and minimum elements in the subarray is at most d. Args: arr (list of int): A list of integers. d (int): The maximum allowed difference between min and max in the subarray. Returns: int: The length of the longest smooth subarray. >>> longest_smooth_subarray([1, 3, 6, 7, 9, 4, 10, 5, 6], 3) 3 >>> longest_smooth_subarray([1, 2, 3, 4], 0) 1 >>> longest_smooth_subarray([4, 2, 2, 2, 4, 4, 2, 2], 0) 3 >>> longest_smooth_subarray([1, 2, 3, 4, 5, 6, 7], 2) 3 >>> longest_smooth_subarray([10, 2, 1, 4, 5, 7, 9, 6], 5) 5 >>> longest_smooth_subarray([2, 3, 3, 2, 2, 2, 4, 8, 7], 6) 9 >>> longest_smooth_subarray([], 1) 0 >>> longest_smooth_subarray([1], 0) 1 >>> longest_smooth_subarray([5], 3) 1 >>> longest_smooth_subarray([1, 1, 1, 1, 1], 10) 5 >>> longest_smooth_subarray([5, 5, 5, 5, 5], 5) 5 >>> longest_smooth_subarray([100, 1, 100, 1], 2) 1","solution":"def longest_smooth_subarray(arr, d): Returns the length of the longest smooth subarray. A subarray is considered smooth when the difference between the maximum and minimum elements in the subarray is at most d. Args: arr (list of int): A list of integers. d (int): The maximum allowed difference between min and max in the subarray. Returns: int: The length of the longest smooth subarray. from collections import deque min_deque, max_deque = deque(), deque() left, max_length = 0, 0 for right in range(len(arr)): while min_deque and arr[min_deque[-1]] >= arr[right]: min_deque.pop() while max_deque and arr[max_deque[-1]] <= arr[right]: max_deque.pop() min_deque.append(right) max_deque.append(right) while arr[max_deque[0]] - arr[min_deque[0]] > d: left += 1 if min_deque[0] < left: min_deque.popleft() if max_deque[0] < left: max_deque.popleft() max_length = max(max_length, right - left + 1) return max_length"},{"question":"from typing import List def check_subarray_sum(arr: List[int], k: int) -> bool: Determines if there is a non-empty subarray whose sum is a multiple of k. >>> check_subarray_sum([23, 2, 4, 6, 7], 6) True >>> check_subarray_sum([5, 0, 0, 0], 3) True >>> check_subarray_sum([1, 2, 3], 3) True >>> check_subarray_sum([23, 2, 6, 4, 7], 13) False >>> check_subarray_sum([1, 2, 12], 6) False >>> check_subarray_sum([0, 0], 0) True >>> check_subarray_sum([1, 0], 0) False >>> check_subarray_sum([1, 0, 0], 2) True >>> check_subarray_sum([5], 5) False >>> check_subarray_sum([0], 1) False >>> check_subarray_sum([0, 0, 0], 1) True >>> check_subarray_sum([1, 2, 3], 0) False >>> check_subarray_sum([5, 9, 3, 7], 5) True","solution":"def check_subarray_sum(arr, k): Determines if there is a non-empty subarray whose sum is a multiple of k. Parameters: arr (list of int): The array of integers. k (int): The integer which the subarray sum should be a multiple of. Returns: bool: True if such a subarray exists, False otherwise. if k == 0: return any(arr[i] + arr[i - 1] == 0 for i in range(1, len(arr))) prefix_sums = {0: -1} current_sum = 0 for i, num in enumerate(arr): current_sum += num mod = current_sum % k if mod in prefix_sums: if i - prefix_sums[mod] > 1: return True else: prefix_sums[mod] = i return False"},{"question":"from typing import List def solveSudoku(board: List[List[str]]) -> bool: Solve a given Sudoku puzzle in-place. Args: board (List[List[str]]): A 9x9 2D list of strings representing a partially filled Sudoku board. Returns: bool: True if a solution was found, False otherwise. Example: >>> board = [ ... [\\"5\\", \\"3\\", \\".\\", \\".\\", \\"7\\", \\".\\", \\".\\", \\".\\", \\".\\"], ... [\\"6\\", \\".\\", \\".\\", \\"1\\", \\"9\\", \\"5\\", \\".\\", \\".\\", \\".\\"], ... [\\".\\", \\"9\\", \\"8\\", \\".\\", \\".\\", \\".\\", \\".\\", \\"6\\", \\".\\"], ... [\\"8\\", \\".\\", \\".\\", \\".\\", \\"6\\", \\".\\", \\".\\", \\".\\", \\"3\\"], ... [\\"4\\", \\".\\", \\".\\", \\"8\\", \\".\\", \\"3\\", \\".\\", \\".\\", \\"1\\"], ... [\\"7\\", \\".\\", \\".\\", \\".\\", \\"2\\", \\".\\", \\".\\", \\".\\", \\"6\\"], ... [\\".\\", \\"6\\", \\".\\", \\".\\", \\".\\", \\".\\", \\"2\\", \\"8\\", \\".\\"], ... [\\".\\", \\".\\", \\".\\", \\"4\\", \\"1\\", \\"9\\", \\".\\", \\".\\", \\"5\\"], ... [\\".\\", \\".\\", \\".\\", \\".\\", \\"8\\", \\".\\", \\".\\", \\"7\\", \\"9\\"] ... ] >>> solveSudoku(board) True # Your code here","solution":"from typing import List def solveSudoku(board: List[List[str]]) -> bool: def is_valid(board: List[List[str]], row: int, col: int, num: str) -> bool: # Check if num is not in the current row for x in range(9): if board[row][x] == num: return False # Check if num is not in the current column for y in range(9): if board[y][col] == num: return False # Check if num is not in the current 3x3 sub-box start_row, start_col = 3 * (row // 3), 3 * (col // 3) for i in range(3): for j in range(3): if board[start_row + i][start_col + j] == num: return False return True def solve(board: List[List[str]]) -> bool: for row in range(9): for col in range(9): if board[row][col] == '.': for num in map(str, range(1, 10)): if is_valid(board, row, col, num): board[row][col] = num if solve(board): return True board[row][col] = '.' return False return True return solve(board)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kth_smallest(root, k): Find the kth smallest element in a binary search tree (BST). >>> # Construction of BST >>> # 3 >>> # / >>> # 1 4 >>> # >>> # 2 >>> root = TreeNode(3) >>> root.left = TreeNode(1) >>> root.right = TreeNode(4) >>> root.left.right = TreeNode(2) >>> kth_smallest(root, 1) == 1 >>> kth_smallest(root, 2) == 2 >>> kth_smallest(root, 3) == 3 >>> kth_smallest(root, 4) == 4 >>> kth_smallest(None, 1) == None >>> root = TreeNode(5) >>> kth_smallest(root, 1) == 5 >>> root = TreeNode(3) >>> root.left = TreeNode(1) >>> root.right = TreeNode(4) >>> root.left.right = TreeNode(2) >>> kth_smallest(root, 0) == None >>> kth_smallest(root, 5) == None","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kth_smallest(root, k): def inorder_traversal(node): if not node: return [] return inorder_traversal(node.left) + [node.val] + inorder_traversal(node.right) elements = inorder_traversal(root) return elements[k-1] if 0 < k <= len(elements) else None"},{"question":"def find_length(nums1, nums2): Finds the maximum length of a subarray that appears in both nums1 and nums2. Args: nums1 (List[int]): The first list of integers. nums2 (List[int]): The second list of integers. Returns: int: The maximum length of a subarray that appears in both lists. >>> find_length([1, 2, 3, 2, 1], [3, 2, 1, 4, 7]) 3 >>> find_length([1, 2, 3], [4, 5, 6]) 0 >>> find_length([1, 2, 3], [1, 2, 3]) 3 >>> find_length([0, 1, 1, 1, 1], [1, 1, 1, 1, 0]) 4 >>> find_length([1, 1, 1, 1, 1], [1, 1, 1, 1, 1]) 5 >>> find_length([1, 2], [2, 1]) 1","solution":"def find_length(nums1, nums2): Finds the maximum length of a subarray that appears in both nums1 and nums2. Args: nums1 (List[int]): The first list of integers. nums2 (List[int]): The second list of integers. Returns: int: The maximum length of a subarray that appears in both lists. n, m = len(nums1), len(nums2) dp = [[0] * (m + 1) for _ in range(n + 1)] max_length = 0 for i in range(1, n + 1): for j in range(1, m + 1): if nums1[i - 1] == nums2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 max_length = max(max_length, dp[i][j]) return max_length"},{"question":"from typing import List def generate_combinations(s: str) -> List[str]: Returns all possible decoded versions of the string based on the given rules. Each '?' can be replaced with a single digit from '0' to '9'. Each '*' can be replaced with any sequence of one or more digits. >>> sorted(generate_combinations(\\"?\\")) ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'] >>> sorted(generate_combinations(\\"*\\")) ['1', '2', '3', '4', '5', '6', '7', '8', '9'] >>> sorted(generate_combinations(\\"?*\\")) [str(i) + str(j) for i in range(10) for j in range(1, 10)] >>> sorted(generate_combinations(\\"??\\")) [str(i) + str(j) for i in range(10) for j in range(10)] >>> generate_combinations(\\"123\\") [\\"123\\"] >>> sorted(generate_combinations(\\"?2?3?\\")) [str(i) + '2' + str(j) + '3' + str(k) for i in range(10) for j in range(10) for k in range(10)]","solution":"from itertools import product def generate_combinations(s): Returns all possible decoded versions of the string based on the given rules. Each '?' can be replaced with a single digit from '0' to '9'. Each '*' can be replaced with any sequence of one or more digits. if not s: return [] def expand_star(): # '*' could be any sequence of digits from '1' to '9', inclusive return [str(i) for i in range(1, 10)] def dfs(index, path, result): if index == len(s): result.append(''.join(path)) return if s[index] == '?': for d in '0123456789': path.append(d) dfs(index + 1, path, result) path.pop() elif s[index] == '*': for seq in expand_star(): path.append(seq) dfs(index + 1, path, result) path.pop() else: path.append(s[index]) dfs(index + 1, path, result) path.pop() result = [] dfs(0, [], result) return result"},{"question":"def rotate_array(nums: List[int], k: int) -> List[int]: Move the first k elements of the array to the end. If k is greater than the length of the array, k % len(nums) positions are considered. >>> rotate_array([1, 2, 3, 4, 5], 2) [3, 4, 5, 1, 2] >>> rotate_array([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5] >>> rotate_array([1, 2, 3, 4, 5], 7) [3, 4, 5, 1, 2] >>> rotate_array([1], 3) [1] >>> rotate_array([], 3) [] >>> rotate_array([1, 2, 3], 0) [1, 2, 3]","solution":"def rotate_array(nums, k): Moves the first k elements of the array to the end. If k is greater than the length of nums, k is considered as k % len(nums). :param nums: List of integers :param k: Integer, the number of elements to move to the end :return: Modified list if not nums: return [] n = len(nums) k = k % n # handle cases where k > len(nums) return nums[k:] + nums[:k]"},{"question":"def has_arithmetic_progression(arr: List[int]) -> bool: Returns true if there are three ascending elements in the array that form an arithmetic progression. An arithmetic progression is a sequence of numbers where the difference between consecutive terms is constant. >>> has_arithmetic_progression([]) False >>> has_arithmetic_progression([1, 2, 4]) False >>> has_arithmetic_progression([1, 3, 5]) True >>> has_arithmetic_progression([1, 2, 3, 4, 6]) True >>> has_arithmetic_progression([-3, 0, 3]) True >>> has_arithmetic_progression([-3, 2, 5]) False >>> has_arithmetic_progression([10, 20, 30, 40, 50, 60]) True","solution":"def has_arithmetic_progression(arr): Returns true if there are three ascending elements in the array that form an arithmetic progression. if len(arr) < 3: return False for i in range(len(arr) - 2): for j in range(i + 1, len(arr) - 1): for k in range(j + 1, len(arr)): if arr[j] - arr[i] == arr[k] - arr[j]: return True return False"},{"question":"def smallest_string_after_removal(word: str) -> str: Returns the lexicographically smallest string that can be obtained by removing exactly one character from \`word\`. >>> smallest_string_after_removal('abcd') 'abc' >>> smallest_string_after_removal('cabd') 'abd' >>> smallest_string_after_removal('aabb') 'aab' >>> smallest_string_after_removal('baab') 'aab' >>> smallest_string_after_removal('abcdef') 'abcde' >>> smallest_string_after_removal('fabcde') 'abcde' >>> smallest_string_after_removal('a') '' >>> smallest_string_after_removal('z') '' >>> smallest_string_after_removal('ab') 'a' >>> smallest_string_after_removal('ba') 'a'","solution":"def smallest_string_after_removal(word): Returns the lexicographically smallest string that can be obtained by removing exactly one character from \`word\`. smallest_string = word[1:] # Initialize with first character removed for i in range(len(word)): candidate = word[:i] + word[i+1:] if candidate < smallest_string: smallest_string = candidate return smallest_string"},{"question":"from typing import List def is_disjoint_sequence(arr: List[int]) -> bool: Determines if the given array is a disjoint sequence. A sequence is considered disjoint if: - No element in the sequence repeats. - The absolute difference between every pair of consecutive elements is greater than 1. Parameters: arr (list): The integer array to be checked. Returns: bool: True if the sequence is disjoint, False otherwise. pass","solution":"def is_disjoint_sequence(arr): Determines if the given array is a disjoint sequence. A sequence is considered disjoint if: - No element in the sequence repeats. - The absolute difference between every pair of consecutive elements is greater than 1. Parameters: arr (list): The integer array to be checked. Returns: bool: True if the sequence is disjoint, False otherwise. if len(arr) == 0: return True elements_seen = set() for i in range(len(arr)): if arr[i] in elements_seen: return False elements_seen.add(arr[i]) if i > 0 and abs(arr[i] - arr[i-1]) <= 1: return False return True"},{"question":"def find_closest_pair(arr: List[int], target: int) -> Tuple[int, int]: Given a sorted array \`arr\` and an integer \`target\`, this function returns two distinct indices (i, j) such that arr[i] + arr[j] is as close as possible to the target. The indices satisfy i < j. >>> find_closest_pair([1, 2, 3, 4, 5], 7) (1, 3) # or any valid pair that satisfies the condition >>> find_closest_pair([1, 2, 3, 4, 5], 5) (0, 3) # or any valid pair that satisfies the condition >>> find_closest_pair([-4, -3, -2, -1, 0, 1, 2, 3, 4, 5], 1) (0, 10) # or any valid pair that satisfies the condition >>> find_closest_pair([1, 4, 5, 6], 10) (1, 3) # or any valid pair that satisfies the condition >>> find_closest_pair([1, 3], 5) (0, 1)","solution":"def find_closest_pair(arr, target): Given a sorted array \`arr\` and an integer \`target\`, this function returns two distinct indices (i, j) such that arr[i] + arr[j] is as close as possible to the target. The indices satisfy i < j. n = len(arr) left, right = 0, n - 1 closest_pair = (0, 1) closest_diff = float('inf') while left < right: current_sum = arr[left] + arr[right] current_diff = abs(current_sum - target) if current_diff < closest_diff: closest_diff = current_diff closest_pair = (left, right) if current_sum < target: left += 1 elif current_sum > target: right -= 1 else: break # If current_sum == target, it's the closest possible pair return closest_pair"},{"question":"def nth_nearest_point(points, n): Returns the nth nearest point to the origin (0, 0). :param points: A list of tuples representing points in a 2D plane :param n: The rank of the nearest point to find :return: The nth nearest point as a tuple or None if n exceeds the number of points >>> nth_nearest_point([(1, 2), (3, 4), (1, -1)], 1) (1, -1) >>> nth_nearest_point([(1, 2), (3, 4), (1, -1)], 2) (1, 2) >>> nth_nearest_point([(1, 2), (3, 4), (1, -1)], 3) (3, 4) >>> nth_nearest_point([(1, 1), (0, 0), (2, 2)], 1) (0, 0) >>> nth_nearest_point([(1, 1), (2, 2), (3, 3)], 4) None >>> nth_nearest_point([(-1, -2), (-3, -4), (1, 1)], 1) (1, 1) >>> nth_nearest_point([(-1, -2), (-3, -4), (1, 1)], 2) (-1, -2) >>> nth_nearest_point([(-1, -2), (-3, -4), (1, 1)], 3) (-3, -4) >>> nth_nearest_point([(3, 4)], 1) (3, 4) >>> nth_nearest_point([(3, 4)], 2) None","solution":"import math def nth_nearest_point(points, n): Returns the nth nearest point to the origin (0, 0). :param points: A list of tuples representing points in a 2D plane :param n: The rank of the nearest point to find :return: The nth nearest point as a tuple or None if n exceeds the number of points if n > len(points): return None # Calculate the Euclidean distance for each point from the origin points_with_distance = [(point, math.sqrt(point[0]**2 + point[1]**2)) for point in points] # Sort points by their distance points_with_distance.sort(key=lambda x: x[1]) # Extract the nth nearest point return points_with_distance[n-1][0]"},{"question":"def is_subsequence(str1: str, str2: str) -> bool: Determines if the entire string str2 can be found as a subsequence in str1. Parameters: str1 (str): The main string. str2 (str): The string to check as a subsequence. Returns: bool: True if str2 is a subsequence of str1, False otherwise. >>> is_subsequence(\\"abcde\\", \\"ace\\") True >>> is_subsequence(\\"abcde\\", \\"abc\\") True >>> is_subsequence(\\"abcde\\", \\"aec\\") False >>> is_subsequence(\\"abcde\\", \\"abcdx\\") False >>> is_subsequence(\\"abcde\\", \\"\\") True >>> is_subsequence(\\"abc\\", \\"abcd\\") False >>> is_subsequence(\\"abcde\\", \\"abcde\\") True","solution":"def is_subsequence(str1, str2): Determines if str2 is a subsequence of str1. Parameters: str1 (str): The main string. str2 (str): The string to check as a subsequence. Returns: bool: True if str2 is a subsequence of str1, False otherwise. iter_str1 = iter(str1) return all(char in iter_str1 for char in str2)"},{"question":"def subarray_sum(nums, k): Returns the number of non-empty consecutive subarrays that sum to k. :param nums: List of integers :param k: Integer :return: Integer pass def test_subarray_sum(): assert subarray_sum([1, 1, 1], 2) == 2 assert subarray_sum([1, 2, 3], 3) == 2 assert subarray_sum([1, -1, 1], 1) == 3 assert subarray_sum([1, 2, 1, 2, 1], 3) == 4 assert subarray_sum([-1, -1, 1], 0) == 1 assert subarray_sum([1, -1, 0], 0) == 3 def test_subarray_sum_no_match(): assert subarray_sum([1, 2, 3], 7) == 0 assert subarray_sum([3, 4, 0, -2, 1], 10) == 0 def test_subarray_sum_single_element(): assert subarray_sum([10], 10) == 1 assert subarray_sum([10], 5) == 0 def test_subarray_sum_all_elements_equal_k(): assert subarray_sum([1, 1, 1, 1], 1) == 4 assert subarray_sum([2, 2, 2, 2], 2) == 4","solution":"def subarray_sum(nums, k): Returns the number of non-empty consecutive subarrays that sum to k. :param nums: List of integers :param k: Integer :return: Integer count = 0 current_sum = 0 sum_dict = {0: 1} # Dictionary to store the cumulative sum frequencies for num in nums: current_sum += num if current_sum - k in sum_dict: count += sum_dict[current_sum - k] sum_dict[current_sum] = sum_dict.get(current_sum, 0) + 1 return count"},{"question":"from typing import List def find_kth_smallest(arr: List[int], k: int) -> int: Returns the k-th smallest element in the array without altering the original array. If k is greater than the number of elements in the array, returns -1. >>> find_kth_smallest([3, 1, 2, 4], 1) 1 >>> find_kth_smallest([3, 1, 2, 4], 2) 2 >>> find_kth_smallest([3, 1, 2, 4], 3) 3 >>> find_kth_smallest([3, 1, 2, 4], 4) 4 >>> find_kth_smallest([3, 1, 2, 4], 5) -1 >>> find_kth_smallest([3, 3, 1, 2, 4, 1], 1) 1 >>> find_kth_smallest([3, 3, 1, 2, 4, 1], 2) 1 >>> find_kth_smallest([3, 3, 1, 2, 4, 1], 3) 2 >>> find_kth_smallest([3, 3, 1, 2, 4, 1], 4) 3 >>> find_kth_smallest([-1, -3, -2, 0], 1) -3 >>> find_kth_smallest([-1, -3, -2, 0], 2) -2 >>> find_kth_smallest([-1, -3, -2, 0], 3) -1 >>> find_kth_smallest([-1, -3, -2, 0], 4) 0 >>> find_kth_smallest([1], 1) 1 >>> find_kth_smallest([], 1) -1","solution":"import heapq from typing import List def find_kth_smallest(arr: List[int], k: int) -> int: Returns the k-th smallest element in the array without altering the original array. If k is greater than the number of elements in the array, returns -1. if k > len(arr): return -1 # Copy the array to avoid modifying the original array copied_arr = list(arr) # Find the k-th smallest element using a heap heapq.heapify(copied_arr) for _ in range(k - 1): heapq.heappop(copied_arr) return heapq.heappop(copied_arr)"},{"question":"def merge_intervals(intervals: List[List[int]]) -> List[List[int]]: Merges overlapping intervals. Args: intervals (List[List[int]]): A list of intervals where each interval is a list of two integers. Returns: List[List[int]]: A new list of merged intervals. Example: >>> merge_intervals([[1, 3], [2, 6], [8, 10], [15, 18]]) [[1, 6], [8, 10], [15, 18]] >>> merge_intervals([[1, 4], [4, 5]]) [[1, 5]]","solution":"def merge_intervals(intervals): Merges overlapping intervals. Args: intervals (List[List[int]]): A list of intervals where each interval is a list of two integers. Returns: List[List[int]]: A new list of merged intervals. if not intervals: return [] # Sort intervals by the starting time intervals.sort(key=lambda x: x[0]) merged = [] for interval in intervals: # If the list of merged intervals is empty or if the current interval # does not overlap with the previous, simply append it. if not merged or merged[-1][1] < interval[0]: merged.append(interval) else: # Otherwise, there is an overlap, so we merge the current and previous intervals. merged[-1][1] = max(merged[-1][1], interval[1]) return merged"},{"question":"def update_grid(n: int, m: int, operations: List[List[int]]) -> List[List[int]]: Updates the grid based on the given operations. Parameters: n (int): Number of rows. m (int): Number of columns. operations (list of lists): List of operations where each operation is in the form of [type, r, c, k]. Returns: list of lists: The updated grid. def test_update_grid_add(): operations = [[1, 0, 0, 5], [1, 1, 1, 10]] expected = [ [5, 0], [0, 10] ] assert update_grid(2, 2, operations) == expected def test_update_grid_max(): operations = [[2, 0, 0, 5], [2, 1, 1, 10], [2, 0, 0, 3]] expected = [ [5, 0], [0, 10] ] assert update_grid(2, 2, operations) == expected def test_update_grid_mixed(): operations = [[1, 0, 0, 5], [2, 0, 0, 10], [1, 1, 1, 3], [2, 1, 1, 5]] expected = [ [10, 0], [0, 5] ] assert update_grid(2, 2, operations) == expected def test_update_grid_all_add_operations(): operations = [[1, 0, 0, 1], [1, 0, 0, 1], [1, 0, 0, 1]] expected = [ [3, 0], [0, 0] ] assert update_grid(2, 2, operations) == expected def test_update_grid_all_max_operations(): operations = [[2, 0, 0, 1], [2, 0, 0, 2], [2, 0, 0, 3]] expected = [ [3, 0], [0, 0] ] assert update_grid(2, 2, operations) == expected","solution":"def update_grid(n, m, operations): Updates the grid based on the given operations. Parameters: n (int): Number of rows. m (int): Number of columns. operations (list of lists): List of operations where each operation is in the form of [type, r, c, k]. Returns: list of lists: The updated grid. # Initialize the grid with zeros grid = [[0] * m for _ in range(n)] # Apply each operation to the grid for op in operations: if op[0] == 1: # Add k to the element at position (r, c) grid[op[1]][op[2]] += op[3] elif op[0] == 2: # Set the element at position (r, c) to the max of itself and k grid[op[1]][op[2]] = max(grid[op[1]][op[2]], op[3]) return grid"},{"question":"def num_of_substrings(s: str, words: List[str]) -> int: Returns the number of strings in words that are substrings of s. Parameters: s (str): The string in which to look for substrings. words (list of str): The list of strings to check as substrings of s. Returns: int: The number of substrings in words that are substrings of s. >>> num_of_substrings(\\"abcde\\", [\\"a\\", \\"bc\\", \\"e\\", \\"abc\\", \\"de\\"]) 5 >>> num_of_substrings(\\"abcde\\", [\\"f\\", \\"gh\\", \\"ijk\\"]) 0 >>> num_of_substrings(\\"abcde\\", [\\"a\\", \\"xyz\\", \\"de\\", \\"cd\\"]) 3 >>> num_of_substrings(\\"aaaaa\\", [\\"a\\", \\"aa\\", \\"aaa\\", \\"aaaa\\"]) 4 >>> num_of_substrings(\\"\\", [\\"a\\", \\"abc\\"]) 0","solution":"def num_of_substrings(s, words): Returns the number of strings in words that are substrings of s. Parameters: s (str): The string in which to look for substrings. words (list of str): The list of strings to check as substrings of s. Returns: int: The number of substrings in words that are substrings of s. count = 0 for word in words: if word in s: count += 1 return count"},{"question":"def search_matrix(matrix: List[List[int]], target: int) -> bool: Searches for a given target in a 2D matrix where every row and column is sorted in ascending order. >>> search_matrix( ... [ ... [1, 4, 7, 11, 15], ... [2, 5, 8, 12, 19], ... [3, 6, 9, 16, 22], ... [10, 13, 14, 17, 24], ... [18, 21, 23, 26, 30] ... ], 5) True >>> search_matrix( ... [ ... [1, 4, 7, 11, 15], ... [2, 5, 8, 12, 19], ... [3, 6, 9, 16, 22], ... [10, 13, 14, 17, 24], ... [18, 21, 23, 26, 30] ... ], 20) False","solution":"def search_matrix(matrix, target): Searches for a given target in a 2D matrix where every row and column is sorted in ascending order. Args: matrix (list of list of int): The 2D matrix to be searched. target (int): The target integer to be searched in the matrix. Returns: bool: True if target is found, and False otherwise. if not matrix or not matrix[0]: return False rows, cols = len(matrix), len(matrix[0]) row, col = 0, cols - 1 # start from the top right corner while row < rows and col >= 0: if matrix[row][col] == target: return True elif matrix[row][col] > target: col -= 1 else: row += 1 return False"},{"question":"class ContactSearch: def __init__(self): Initializes the contact list as an empty list. self.contacts = [] def addContact(self, contact): Adds a new contact name to the contacts list. def removeContact(self, contact): Removes an existing contact name from the contacts list if it exists. def search(self, query): Returns a list of all contact names that start with the given query string, in lexicographical order. >>> cs = ContactSearch() >>> cs.addContact(\\"Alice\\") >>> cs.addContact(\\"Bob\\") >>> cs.addContact(\\"Aaron\\") >>> cs.addContact(\\"Allan\\") >>> cs.search(\\"A\\") [\\"Aaron\\", \\"Alice\\", \\"Allan\\"] >>> cs.search(\\"Al\\") [\\"Alice\\", \\"Allan\\"] >>> cs.search(\\"B\\") [\\"Bob\\"] >>> cs.search(\\"C\\") []","solution":"class ContactSearch: def __init__(self): self.contacts = [] def addContact(self, contact): Adds a new contact name to the contacts list. self.contacts.append(contact) self.contacts.sort() def removeContact(self, contact): Removes an existing contact name from the contacts list. if contact in self.contacts: self.contacts.remove(contact) def search(self, query): Returns a list of all contact names that start with the given query string, in lexicographical order. result = [contact for contact in self.contacts if contact.startswith(query)] return result"},{"question":"from typing import List def longestCommonPrefix(strs: List[str]) -> str: Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string \\"\\". >>> longestCommonPrefix([\\"flower\\", \\"flow\\", \\"flight\\"]) 'fl' >>> longestCommonPrefix([\\"dog\\", \\"racecar\\", \\"car\\"]) '' >>> longestCommonPrefix([\\"single\\"]) 'single' >>> longestCommonPrefix([\\"test\\", \\"test\\", \\"test\\"]) 'test' >>> longestCommonPrefix([]) '' >>> longestCommonPrefix([\\"interspecies\\", \\"interstellar\\", \\"interstate\\"]) 'inters' >>> longestCommonPrefix([\\"\\", \\"\\", \\"\\"]) '' >>> longestCommonPrefix([\\"\\", \\"nonempty\\"]) '' >>> longestCommonPrefix([\\"ab\\", \\"a\\"]) 'a'","solution":"def longestCommonPrefix(strs): Returns the longest common prefix string amongst an array of strings. If there is no common prefix, returns an empty string \\"\\". if not strs: return \\"\\" # Find the shortest string in the list shortest_str = min(strs, key=len) for i, char in enumerate(shortest_str): for other_str in strs: if other_str[i] != char: return shortest_str[:i] return shortest_str"},{"question":"from typing import List def find_anagrams(s: str, p: str) -> List[int]: You are given two strings \`s\` and \`p\`, both consisting only of lowercase English letters. Your task is to find all the start indices of \`p\`'s anagrams in \`s\`. The anagrams do not need to be contiguous, but the order of characters must match. The solution should run in linear time complexity. Returns the list of start indices in ascending order. >>> find_anagrams(\\"cbaebabacd\\", \\"abc\\") [0, 6] >>> find_anagrams(\\"af\\", \\"be\\") [] >>> find_anagrams(\\"abab\\", \\"ab\\") [0, 1, 2] >>> find_anagrams(\\"a\\", \\"a\\") [0] >>> find_anagrams(\\"test\\", \\"test\\") [0] >>> find_anagrams(\\"short\\", \\"longer\\") [] >>> find_anagrams(\\"aaaaa\\", \\"aa\\") [0, 1, 2, 3] pass","solution":"from collections import Counter def find_anagrams(s, p): Returns a list of start indices of p's anagrams in s. p_length = len(p) s_length = len(s) if p_length > s_length: return [] p_counter = Counter(p) current_counter = Counter(s[:p_length]) result = [] if p_counter == current_counter: result.append(0) for i in range(1, s_length - p_length + 1): current_counter[s[i-1]] -= 1 if current_counter[s[i-1]] == 0: del current_counter[s[i-1]] current_counter[s[i + p_length - 1]] += 1 if p_counter == current_counter: result.append(i) return result"},{"question":"import heapq class MedianFinder: def __init__(self): Initialize the MedianFinder data structure. - max_heap stores the smaller half values (as max heap in negative form) - min_heap stores the larger half values def addNumber(self, num: int): Adds a num into the data structure. def findMedian(self) -> float: Returns the median of current numbers. >>> mf = MedianFinder() >>> mf.addNumber(1) >>> mf.findMedian() 1.0 >>> mf.addNumber(2) >>> mf.findMedian() 1.5 >>> mf.addNumber(3) >>> mf.findMedian() 2.0","solution":"import heapq class MedianFinder: def __init__(self): Initialize the MedianFinder data structure. - max_heap stores the smaller half values (as max heap in negative form) - min_heap stores the larger half values self.max_heap = [] # A max-heap to maintain the lower half of elements. self.min_heap = [] # A min-heap to maintain the upper half of elements. def addNumber(self, num: int): Adds a num into the data structure. heapq.heappush(self.max_heap, -num) if self.max_heap and self.min_heap and (-self.max_heap[0] > self.min_heap[0]): heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap)) if len(self.max_heap) > len(self.min_heap) + 1: heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap)) if len(self.min_heap) > len(self.max_heap): heapq.heappush(self.max_heap, -heapq.heappop(self.min_heap)) def findMedian(self) -> float: Returns the median of current numbers. if len(self.max_heap) > len(self.min_heap): return -self.max_heap[0] else: return (-self.max_heap[0] + self.min_heap[0]) / 2"},{"question":"def eraseOverlapIntervals(intervals: List[List[int]]) -> int: Given a collection of intervals, find the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping. Args: intervals (List[List[int]]): A list of interval pairs [start, end]. Returns: int: The minimum number of intervals to remove. >>> eraseOverlapIntervals([]) 0 >>> eraseOverlapIntervals([[1, 2], [3, 4], [5, 6]]) 0 >>> eraseOverlapIntervals([[1, 3], [2, 4], [3, 5]]) 1 >>> eraseOverlapIntervals([[1, 2], [2, 3], [3, 4], [1, 3]]) 1 >>> eraseOverlapIntervals([[1, 2], [1, 2], [1, 2]]) 2 >>> eraseOverlapIntervals([[1, 10], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 8], [8, 9], [9, 10]]) 1","solution":"def eraseOverlapIntervals(intervals): Given a collection of intervals, find the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping. Args: intervals (List[List[int]]): A list of interval pairs [start, end]. Returns: int: The minimum number of intervals to remove. if not intervals: return 0 # Sort intervals based on the end time intervals.sort(key=lambda x: x[1]) # Initialize the count of intervals to remove and the end of the previous interval count = 0 prev_end = intervals[0][1] for i in range(1, len(intervals)): # If the current interval starts before the end of the previous interval, # then it's overlapping and needs to be removed. if intervals[i][0] < prev_end: count += 1 else: # Otherwise, update the end to be the end of the current interval prev_end = intervals[i][1] return count"},{"question":"from typing import List def water_garden(grid: List[List[int]], t: int) -> int: Returns the total number of units of water used to increase the height of flowers whose height is greater than the given threshold t by 1 unit. :param grid: List[List[int]] - 2D grid representing the garden :param t: int - threshold value for flower height :return: int - total units of water used pass def test_water_garden_example(): grid = [[1, 2, 3], [4, 1, 2], [3, 4, 1]] t = 2 assert water_garden(grid, t) == 4 def test_water_garden_none_above_threshold(): grid = [[1, 1, 1], [1, 1, 1], [1, 1, 1]] t = 2 assert water_garden(grid, t) == 0 def test_water_garden_all_above_threshold(): grid = [[3, 4, 5], [6, 7, 8], [9, 10, 11]] t = 2 assert water_garden(grid, t) == 9 def test_water_garden_some_above_threshold(): grid = [[3, 1, 5], [4, 7, 2], [8, 2, 1]] t = 3 assert water_garden(grid, t) == 4 def test_water_garden_minimal_input(): grid = [[1]] t = 0 assert water_garden(grid, t) == 1 t = 1 assert water_garden(grid, t) == 0 if __name__ == '__main__': test_water_garden_example() test_water_garden_none_above_threshold() test_water_garden_all_above_threshold() test_water_garden_some_above_threshold() test_water_garden_minimal_input()","solution":"def water_garden(grid, t): Returns the total number of units of water used to increase the height of flowers whose height is greater than the given threshold t by 1 unit. :param grid: List[List[int]] - 2D grid representing the garden :param t: int - threshold value for flower height :return: int - total units of water used total_water = 0 for row in grid: for height in row: if height > t: total_water += 1 return total_water"},{"question":"def remove_duplicates(numList: List[int]) -> List[int]: Returns a new list with duplicates removed, maintaining original order. >>> remove_duplicates([4, 5, 8, 4, 5, 2, 1, 8, 2]) [4, 5, 8, 2, 1] >>> remove_duplicates([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> remove_duplicates([]) [] >>> remove_duplicates([1]) [1] >>> remove_duplicates([1, 1, 1, 1]) [1] >>> remove_duplicates([1, 2, 1, 3, 2, 4]) [1, 2, 3, 4]","solution":"def remove_duplicates(numList): Returns a new list with duplicates removed, maintaining original order. seen = set() unique_list = [] for num in numList: if num not in seen: seen.add(num) unique_list.append(num) return unique_list"},{"question":"def check_subarray_average(nums: List[int], k: int, x: int) -> bool: Determines if there exists a subarray of length k in nums such that the average of its elements is greater than or equal to x. Args: nums (List[int]): List of integers representing the array. k (int): Length of the subarray. x (int): Value to compare the average against. Returns: bool: True if such a subarray exists, otherwise False. >>> check_subarray_average([1, 4, 2, 5], 2, 3) True >>> check_subarray_average([1, 4, 2, 5], 2, 4) False >>> check_subarray_average([5, 5, 5, 5], 1, 5) True >>> check_subarray_average([1, 2, 1, 2, 1], 3, 2) False >>> check_subarray_average([10, -10, 10, -10, 10], 2, 1) False >>> check_subarray_average([1, 3, 5, 7], 4, 4) True","solution":"def check_subarray_average(nums, k, x): Determines if there exists a subarray of length k in nums such that the average of its elements is greater than or equal to x. Args: nums (list of int): List of integers representing the array. k (int): Length of the subarray. x (int): Value to compare the average against. Returns: bool: True if such a subarray exists, otherwise False. subarray_sum = sum(nums[:k]) if subarray_sum / k >= x: return True for i in range(k, len(nums)): subarray_sum += nums[i] - nums[i - k] if subarray_sum / k >= x: return True return False"},{"question":"from typing import List def oranges_rotting(grid: List[List[int]]) -> int: Returns the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1. >>> oranges_rotting([[2,2,2],[2,2,2],[2,2,2]]) == 0 >>> oranges_rotting([[1,1,1],[1,1,1],[1,1,1]]) == -1 >>> oranges_rotting([[2,1,1],[1,1,0],[0,1,1]]) == 4 >>> oranges_rotting([[2,1,1],[0,1,1],[1,0,1]]) == -1 >>> oranges_rotting([[0,0,0],[0,0,0],[0,0,0]]) == 0","solution":"from collections import deque def orangesRotting(grid): Returns the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1. rows, cols = len(grid), len(grid[0]) queue = deque() fresh_count = 0 # Initialize the queue and count fresh oranges for r in range(rows): for c in range(cols): if grid[r][c] == 2: queue.append((r, c, 0)) elif grid[r][c] == 1: fresh_count += 1 # 4-directional movement vectors directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] minutes_elapsed = 0 while queue: x, y, minutes = queue.popleft() minutes_elapsed = max(minutes_elapsed, minutes) for dr, dc in directions: nx, ny = x + dr, y + dc # If in bounds and has a fresh orange if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == 1: grid[nx][ny] = 2 # Rot the fresh orange fresh_count -= 1 queue.append((nx, ny, minutes + 1)) return minutes_elapsed if fresh_count == 0 else -1"},{"question":"def hourglass_sum(grid): Returns the maximum hourglass sum in a 2D grid. >>> hourglass_sum([ ... [1, 1, 1, 0, 0, 0], ... [0, 1, 0, 0, 0, 0], ... [1, 1, 1, 0, 0, 0], ... [0, 0, 2, 4, 4, 0], ... [0, 0, 0, 2, 0, 0], ... [0, 0, 1, 2, 4, 0] ... ]) == 19 >>> hourglass_sum([ ... [-1, -1, 0, -9, -2, -2], ... [-2, -1, -6, -8, -2, -5], ... [-1, -1, -1, -2, -3, -4], ... [-1, -9, -2, -4, -4, -5], ... [-7, -3, -3, -2, -9, -9], ... [-1, -3, -1, -2, -4, -5] ... ]) == -6 >>> hourglass_sum([ ... [1, 1, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 1, 1, 1, 1] ... ]) == 7 >>> hourglass_sum([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) == 7 pass","solution":"def hourglass_sum(grid): Returns the maximum hourglass sum in a 2D grid. rows = len(grid) cols = len(grid[0]) max_sum = float('-inf') for i in range(rows - 2): for j in range(cols - 2): top = grid[i][j] + grid[i][j + 1] + grid[i][j + 2] mid = grid[i + 1][j + 1] bot = grid[i + 2][j] + grid[i + 2][j + 1] + grid[i + 2][j + 2] hourglass = top + mid + bot if hourglass > max_sum: max_sum = hourglass return max_sum"},{"question":"from typing import List def award_scholarships(scores: List[int], k: int) -> List[int]: Returns the top k scores from the list of student scores. If multiple students have the same score, they are all considered, but the list should have exactly k elements. >>> award_scholarships([90, 80, 85, 70, 95], 3) == [95, 90, 85] >>> award_scholarships([90, 85, 85, 70, 95], 3) == [95, 90, 85] >>> award_scholarships([90, 85, 85, 70, 95, 85], 3) == [95, 90, 85] >>> award_scholarships([80, 70], 3) == [80, 70] >>> award_scholarships([90, 80, 85], 0) == [] >>> award_scholarships([], 3) == [] >>> award_scholarships([85, 85, 85, 85], 3) == [85, 85, 85] # your code here","solution":"from typing import List def award_scholarships(scores: List[int], k: int) -> List[int]: Returns the top k scores from the list of student scores. If multiple students have the same score, they are all considered, but the list should have exactly k elements. if k == 0 or not scores: return [] # Sort scores in descending order sorted_scores = sorted(scores, reverse=True) result = [] current_count = 0 # Find top k scores considering possible ties for score in sorted_scores: if current_count < k: result.append(score) current_count += 1 else: if score == result[-1]: result.append(score) else: break return result[:k]"},{"question":"def find_single_number(nums): Returns the single number that appears only once in the list where every other element appears twice. :param nums: List of integers :return: Single integer that appears only once >>> find_single_number([1, 2, 2, 3, 3]) 1 >>> find_single_number([4, 1, 2, 1, 2]) 4 >>> find_single_number([2, 2, 3, 3, 4, 6, 6]) 4 >>> find_single_number([-1, -1, -2]) -2 >>> find_single_number([i for i in range(1, 100000)] * 2 + [999999]) 999999","solution":"def find_single_number(nums): Returns the single number that appears only once in the list where every other element appears twice. :param nums: List of integers :return: Single integer that appears only once # Using XOR operation to find the single number single_number = 0 for num in nums: single_number ^= num return single_number"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseKGroup(head, k): Given a linked list, return the list after reversing every group of \`k\` nodes. If the number of nodes is not a multiple of \`k\` then left-out nodes in the end should remain as it is. You may not alter the values in the nodes, only nodes themselves may be changed. >>> from solution import ListNode, reverseKGroup, create_linked_list, linked_list_to_list >>> head = create_linked_list([1, 2, 3, 4, 5, 6]) >>> linked_list_to_list(reverseKGroup(head, 3)) [3, 2, 1, 6, 5, 4] >>> head = create_linked_list([1, 2, 3, 4, 5]) >>> linked_list_to_list(reverseKGroup(head, 3)) [3, 2, 1, 4, 5] >>> head = create_linked_list([1]) >>> linked_list_to_list(reverseKGroup(head, 1)) [1] >>> head = create_linked_list([1, 2]) >>> linked_list_to_list(reverseKGroup(head, 3)) [1, 2]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseKGroup(head, k): def reverse_linked_list(head, k): prev = None current = head while k > 0: next_node = current.next current.next = prev prev = current current = next_node k -= 1 return prev count = 0 node = head while node and count != k: # find the k+1 node node = node.next count += 1 if count == k: # if k+1 node is found reversed_head = reverse_linked_list(head, k) head.next = reverseKGroup(node, k) return reversed_head return head"},{"question":"def add_binary_strings(a: str, b: str) -> str: Returns the sum of two binary strings. >>> add_binary_strings(\\"11\\", \\"1\\") \\"100\\" >>> add_binary_strings(\\"1010\\", \\"1011\\") \\"10101\\" >>> add_binary_strings(\\"111\\", \\"1\\") \\"1000\\" >>> add_binary_strings(\\"110\\", \\"101\\") \\"1011\\" >>> add_binary_strings(\\"10\\", \\"01\\") \\"11\\" >>> add_binary_strings(\\"0\\", \\"0\\") \\"0\\" >>> add_binary_strings(\\"1101\\", \\"11\\") \\"10000\\" >>> add_binary_strings(\\"1\\", \\"1111\\") \\"10000\\" >>> add_binary_strings(\\"0\\", \\"1\\") \\"1\\" >>> add_binary_strings(\\"1\\", \\"0\\") \\"1\\" >>> add_binary_strings(\\"1\\", \\"1\\") \\"10\\" >>> add_binary_strings(\\"0\\", \\"0\\") \\"0\\"","solution":"def add_binary_strings(a, b): Returns the sum of two binary strings. max_len = max(len(a), len(b)) # Padding the shorter string with zeros a = a.zfill(max_len) b = b.zfill(max_len) carry = 0 result = [] for i in range(max_len - 1, -1, -1): total = carry total += 1 if a[i] == '1' else 0 total += 1 if b[i] == '1' else 0 result.append('1' if total % 2 == 1 else '0') carry = 0 if total < 2 else 1 if carry != 0: result.append('1') result.reverse() return ''.join(result)"},{"question":"def min_area_rect(points: List[List[int]]) -> int: Returns the area of the smallest rectangle that can enclose all the given points. points: List[List[int]], a list of [x, y] coordinates. Example: >>> min_area_rect([[1, 1], [1, 3], [3, 1], [3, 3], [2, 2]]) 4 >>> min_area_rect([[3, 4]]) 0","solution":"def min_area_rect(points): Returns the area of the smallest rectangle that can enclose all the given points. points: List[List[int]], a list of [x, y] coordinates. if not points: return 0 # Extract x and y coordinates separately x_coordinates = [point[0] for point in points] y_coordinates = [point[1] for point in points] # Find the minimum and maximum x and y values min_x = min(x_coordinates) max_x = max(x_coordinates) min_y = min(y_coordinates) max_y = max(y_coordinates) # Calculate the area of the smallest enclosing rectangle width = max_x - min_x height = max_y - min_y area = width * height return area"},{"question":"def min_operations_to_all_ones(s: str, ops: List[List[int]]) -> int: Given a 0-indexed binary string \`s\` and an array of operations \`ops\`, return the minimum number of operations needed to make all characters in the string \`s\` equal to '1'. An operation ops[i] is a list of two integers [l, r] representing a range. For every operation, toggle all the bits in the substring s[l:r] from '0' to '1' and vice versa. Args: s (str): A 0-indexed binary string which initially consists of only '0's. ops (List[List[int]]): An array of operations where each operation is a list of two integers [l, r]. Returns: int: The minimum number of operations needed to make all characters in the string 's' equal to '1'. Examples: >>> min_operations_to_all_ones(\\"111\\", []) 0 >>> min_operations_to_all_ones(\\"000\\", for: .normal) startButton.isEnabled = true } } @IBAction func startButtonPressed(_ sender: UIButton) { countdownTimer = Timer.scheduledTimer( timeInterval: 1.0, target: self, selector: #selector(updateTime), userInfo: nil, repeats: true ) startButton.setTitle(\\"Started\\", for: .normal) startButton.isEnabled = false } @objc func updateTime() { if initialTime > 0 { initialTime -= 1 timeLabel.text = \\"(initialTime) seconds\\" } else { countdownTimer.invalidate() startButton.setTitle(\\"Start\\", for: .normal) startButton.isEnabled = true } } }","solution":"def min_operations_to_all_ones(s, ops): def toggle(s, l, r): s = list(s) # convert string to list for mutability for i in range(l, r + 1): s[i] = '1' if s[i] == '0' else '0' return ''.join(s) count = 0 current_string = s for op in ops: l, r = op current_string = toggle(current_string, l, r) count += 1 if current_string == '1' * len(s): break return count"},{"question":"def can_transform(s: str, t: str) -> bool: Returns True if it's possible to transform s into t by deleting exactly one non-empty substring from s. >>> can_transform(\\"abc\\", \\"abc\\") == False >>> can_transform(\\"abcdef\\", \\"abef\\") == True >>> can_transform(\\"abcdef\\", \\"cdef\\") == True >>> can_transform(\\"abcdef\\", \\"abcd\\") == True >>> can_transform(\\"abcdef\\", \\"ghijk\\") == False >>> can_transform(\\"abcdef\\", \\"bcdef\\") == True >>> can_transform(\\"abcdef\\", \\"abcde\\") == True >>> can_transform(\\"abcdef\\", \\"abdf\\") == False","solution":"def can_transform(s, t): Returns True if it's possible to transform s into t by deleting exactly one non-empty substring from s. if s == t: return False for i in range(len(s)): for j in range(i + 1, len(s) + 1): if s[:i] + s[j:] == t: return True return False"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def is_balanced(root): Determine if a binary tree is height-balanced. A height-balanced binary tree is defined as a binary tree in which the left and right subtrees of every node differ in height by no more than 1. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> is_balanced(root) True >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(3) >>> root.left.left.left = TreeNode(4) >>> is_balanced(root) False","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def is_balanced(root): def check_height(node): if not node: return 0, True left_height, left_balanced = check_height(node.left) right_height, right_balanced = check_height(node.right) current_height = 1 + max(left_height, right_height) current_balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 return current_height, current_balanced _, balanced = check_height(root) return balanced"},{"question":"from collections import deque def min_days_to_cover_board(n, islands): Returns the minimum number of days required to transform the entire board into land. Parameters: n (int): The size of the board. islands (list of tuples): The initial coordinates of the islands. Returns: int: Minimum number of days to cover the board with land or -1 if not possible. pass # Test cases def test_all_water_board(): assert min_days_to_cover_board(3, []) == -1 def test_single_island_center(): assert min_days_to_cover_board(3, [(1, 1)]) == 2 def test_single_island_corner(): assert min_days_to_cover_board(3, [(0, 0)]) == 4 def test_multiple_islands(): assert min_days_to_cover_board(3, [(0, 0), (2, 2)]) == 2 def test_full_board_initially(): assert min_days_to_cover_board(3, [(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)]) == 0 def test_larger_board(): assert min_days_to_cover_board(5, [(2, 2)]) == 4 def test_one_by_one_board(): assert min_days_to_cover_board(1, [(0, 0)]) == 0","solution":"from collections import deque def min_days_to_cover_board(n, islands): Returns the minimum number of days required to transform the entire board into land. Parameters: n (int): The size of the board. islands (list of tuples): The initial coordinates of the islands. Returns: int: Minimum number of days to cover the board with land or -1 if not possible. if not islands: return -1 if n > 0 else 0 board = [['~'] * n for _ in range(n)] queue = deque() for x, y in islands: board[x][y] = '#' queue.append((x, y, 0)) # (x, y, days) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] max_days = 0 while queue: x, y, days = queue.popleft() for direction in directions: nx, ny = x + direction[0], y + direction[1] if 0 <= nx < n and 0 <= ny < n and board[nx][ny] == '~': board[nx][ny] = '#' queue.append((nx, ny, days + 1)) max_days = max(max_days, days + 1) for row in board: if '~' in row: return -1 # If there's still water left, return -1 return max_days"},{"question":"def is_subsequence(s: str, word: str) -> bool: Checks if word is a subsequence of s. >>> is_subsequence(\\"abcde\\", \\"ace\\") == True >>> is_subsequence(\\"abcde\\", \\"aec\\") == False >>> is_subsequence(\\"abcde\\", \\"abcde\\") == True >>> is_subsequence(\\"abcde\\", \\"\\") == True def longest_subseq_length(s: str, words: List[str]) -> int: Finds the length of the longest subsequence from s that can form one of the words in words. >>> longest_subseq_length(\\"abcde\\", [\\"a\\", \\"bb\\", \\"acd\\", \\"ace\\"]) == 3 >>> longest_subseq_length(\\"abc\\", [\\"a\\", \\"ab\\", \\"bc\\", \\"abc\\"]) == 3 >>> longest_subseq_length(\\"abc\\", [\\"d\\"]) == 0 >>> longest_subseq_length(\\"abcdefg\\", [\\"abd\\", \\"adg\\", \\"aeg\\", \\"fgh\\"]) == 3 >>> longest_subseq_length(\\"aaaaaaa\\", [\\"aa\\", \\"aaa\\", \\"aaaa\\"]) == 4 >>> longest_subseq_length(\\"\\", [\\"a\\", \\"b\\", \\"c\\"]) == 0 >>> longest_subseq_length(\\"abcde\\", []) == 0","solution":"def is_subsequence(s, word): Checks if word is a subsequence of s. it = iter(s) return all(char in it for char in word) def longest_subseq_length(s, words): Finds the length of the longest subsequence from s that can form one of the words in words. longest_length = 0 for word in words: if is_subsequence(s, word): longest_length = max(longest_length, len(word)) return longest_length"},{"question":"def evaluateExpression(s: str) -> int: Evaluates a mathematical expression and returns its value. The input expression contains digits, '+', '-', '*', '/', '(', and ')', and it follows standard mathematical conventions: 1. Parentheses 2. Multiplication and division (from left to right) 3. Addition and subtraction (from left to right) >>> evaluateExpression(\\"3+2*2\\") 7 >>> evaluateExpression(\\"3/2\\") 1 >>> evaluateExpression(\\"3+5/2\\") 5 >>> evaluateExpression(\\"(1+(4+5+2)-3)+(6+8)\\") 23 >>> evaluateExpression(\\"2*(5+5*2)/3+(6/2+8)\\") 21 >>> evaluateExpression(\\"(2+6*3+5-(3*14/7+2)*5)+3\\") -12 >>> evaluateExpression(\\"1000000*1000000/1000000*1000000\\") 1000000000000 >>> evaluateExpression(\\"(0-2)*(0-3)\\") 6 >>> evaluateExpression(\\"100/10/2\\") 5","solution":"def evaluateExpression(s): Evaluates a mathematical expression and returns its value. :param s: str :return: int def helper(tokens): stack = [] num = 0 sign = '+' while tokens: tok = tokens.pop(0) if tok.isdigit(): num = num * 10 + int(tok) if tok == '(': num = helper(tokens) if (not tok.isdigit() and tok != ' ') or not tokens: if sign == '+': stack.append(num) elif sign == '-': stack.append(-num) elif sign == '*': stack[-1] = stack[-1] * num elif sign == '/': stack[-1] = int(stack[-1] / num) # truncating towards zero sign = tok num = 0 if tok == ')': break return sum(stack) tokens = list(s) return helper(tokens)"},{"question":"def largest_rectangle_area(heights: List[int]) -> int: Calculate the area of the largest rectangle that can be formed within the histogram represented by heights. >>> largest_rectangle_area([2, 1, 5, 6, 2, 3]) 10 >>> largest_rectangle_area([2, 4]) 4 >>> largest_rectangle_area([6, 2, 5, 4, 5, 1, 6]) 12 >>> largest_rectangle_area([1, 1, 1, 1, 1, 1, 1]) 7 >>> largest_rectangle_area([4, 2, 0, 3, 2, 5]) 6 >>> largest_rectangle_area([1]) 1 >>> largest_rectangle_area([]) 0 >>> largest_rectangle_area([2, 3, 4, 5, 6]) 12 >>> largest_rectangle_area([6, 5, 4, 3, 2, 1]) 12 >>> largest_rectangle_area([0, 0, 0, 0, 0]) 0","solution":"def largest_rectangle_area(heights): Calculate the area of the largest rectangle that can be formed within the histogram represented by heights. :param heights: List[int] - A list of non-negative integers representing the heights of the bars. :return: int - The area of the largest rectangle. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def longest_consecutive_ones(s: str, k: int) -> int: Returns the length of the longest contiguous substring containing only '1's, with at most 'k' allowed consecutive changes of '0's to '1's. >>> longest_consecutive_ones(\\"110100110\\", 2) 5 >>> longest_consecutive_ones(\\"11111\\", 2) 5 >>> longest_consecutive_ones(\\"00000\\", 2) 2 >>> longest_consecutive_ones(\\"1010101\\", 1) 3 >>> longest_consecutive_ones(\\"1001001\\", 10) 7","solution":"def longest_consecutive_ones(s, k): Returns the length of the longest contiguous substring containing only '1's, with at most 'k' allowed consecutive changes of '0's to '1's. max_length = 0 start = 0 zero_count = 0 for end in range(len(s)): if s[end] == '0': zero_count += 1 while zero_count > k: if s[start] == '0': zero_count -= 1 start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"def max_profit(prices: List[int]) -> int: Returns the maximum possible profit from buying and selling one share of the stock. If no profit is possible, return 0. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0","solution":"def max_profit(prices): Returns the maximum possible profit from buying and selling one share of the stock. If no profit is possible, return 0. if not prices: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"def longest_path(n: int, edges: List[List[int]]) -> int: Determine the length of the longest path in a directed acyclic graph (DAG) with \`n\` vertices labeled from 0 to n-1. Args: n (int): Number of vertices in the graph. edges (List[List[int]]): The edges in the graph, where each edge is represented as [ui, vi], a directed edge from vertex ui to vertex vi. Returns: int: The length of the longest path in the DAG. Examples: >>> longest_path(4, [[0,1],[0,2],[1,3],[2,3]]) 2 >>> longest_path(5, [[0,1],[1,2],[2,3],[3,4]]) 4 >>> longest_path(5, [[4,3],[3,2],[2,1],[1,0]]) 4 >>> longest_path(3, [[0,1],[1,2],[0,2]]) 2 >>> longest_path(1, []) 0","solution":"from collections import defaultdict, deque def longest_path(n, edges): # Build a graph and in-degrees array graph = defaultdict(list) in_degrees = [0] * n for u, v in edges: graph[u].append(v) in_degrees[v] += 1 # Queue for all nodes with no incoming edges queue = deque() for i in range(0, n): if in_degrees[i] == 0: queue.append((i, 0)) # (node, current_path_length) longest_path_length = 0 while queue: node, current_path_length = queue.popleft() longest_path_length = max(longest_path_length, current_path_length) for neighbor in graph[node]: in_degrees[neighbor] -= 1 if in_degrees[neighbor] == 0: queue.append((neighbor, current_path_length + 1)) return longest_path_length"},{"question":"from typing import List def max_average_salary(employees: List[List[int]], target_hours: int) -> float: Calculate the maximum average salary of any satisfactory team. A satisfactory team is one where all employees work no less than \`target_hours\`. The function returns the maximum average salary of such a team rounded to two decimal places. If no satisfactory team exists, return 0. Args: employees: A list of lists where each inner list contains hours worked and corresponding salary of each employee. target_hours: The minimum number of hours an employee needs to work to be considered satisfactory. Returns: The maximum average salary of a satisfactory team rounded to two decimal places. >>> max_average_salary([[40, 3000], [50, 4000], [45, 3500]], 40) 3500.00 >>> max_average_salary([[40, 3000], [30, 2500], [50, 4000]], 40) 3500.00 >>> max_average_salary([[30, 2500], [20, 2000], [25, 2200]], 40) 0.00 >>> max_average_salary([], 40) 0.00 >>> max_average_salary([[40, 3000], [50, 4000], [45, 3500]], 60) 0.00 >>> max_average_salary([[40, 3000], [40, 4000], [40, 3500]], 40) 3500.00 # Your code here","solution":"def max_average_salary(employees, target_hours): satisfactory_employees = [salary for hours, salary in employees if hours >= target_hours] if not satisfactory_employees: return 0.00 total_salary = sum(satisfactory_employees) average_salary = total_salary / len(satisfactory_employees) return round(average_salary, 2)"},{"question":"import heapq from typing import List def min_time_to_complete_tasks(tasks: List[int], n: int) -> int: Given an array \`tasks\` where \`tasks[i]\` represents the time required to complete the \`ith\` task, and a number \`n\` representing the number of workers, this function returns the minimum possible time to complete all tasks using \`n\` workers. >>> min_time_to_complete_tasks([3, 2, 3], 2) == 5 >>> min_time_to_complete_tasks([1, 2, 3, 4], 2) == 6 def test_min_time_to_complete_tasks(): assert min_time_to_complete_tasks([5], 2) == 5 assert min_time_to_complete_tasks([7], 3) == 7 assert min_time_to_complete_tasks([5, 5, 5], 3) == 5 assert min_time_to_complete_tasks([2, 3, 2], 3) == 3 assert min_time_to_complete_tasks([3, 2, 3], 2) == 5 assert min_time_to_complete_tasks([1, 2, 3, 4], 2) == 6 assert min_time_to_complete_tasks([], 2) == 0 assert min_time_to_complete_tasks([], 1) == 0 assert min_time_to_complete_tasks([3, 2, 3], 4) == 3 assert min_time_to_complete_tasks([1, 2], 5) == 2","solution":"import heapq def min_time_to_complete_tasks(tasks, n): Given an array \`tasks\` where \`tasks[i]\` represents the time required to complete the \`ith\` task, and a number \`n\` representing the number of workers, this function returns the minimum possible time to complete all tasks using \`n\` workers. if not tasks: return 0 # Create a min-heap to represent the workers' time schedules workers = [0] * n heapq.heapify(workers) for task in tasks: # Assign the task to the worker who has the least total time min_worker_time = heapq.heappop(workers) heapq.heappush(workers, min_worker_time + task) # The time required to complete all tasks is the maximum time among all workers return max(workers)"},{"question":"def simplify_fraction(equation: str) -> str: Simplifies the given fraction equation to its simplest form a/b. Args: equation (str): A string representing a fraction in the form 'numerator/denominator'. Returns: str: Simplified fraction in the form 'a/b' where a and b are coprime integers. >>> simplify_fraction(\\"4/6\\") \\"2/3\\" >>> simplify_fraction(\\"(3+5)/(8-4)\\") \\"2/1\\" >>> simplify_fraction(\\"12/-4\\") \\"-3/1\\" >>> simplify_fraction(\\"(2+3-1)/(4+2-1)\\") \\"4/5\\" >>> simplify_fraction(\\"-8/-4\\") \\"2/1\\" >>> simplify_fraction(\\"1000000/500000\\") \\"2/1\\" >>> simplify_fraction(\\"0/10\\") \\"0/1\\" pass","solution":"from fractions import Fraction def simplify_fraction(equation): Simplifies the given fraction equation to its simplest form a/b. Args: equation (str): A string representing a fraction in the form 'numerator/denominator'. Returns: str: Simplified fraction in the form 'a/b' where a and b are coprime integers. # Split the equation into numerator and denominator numerator_expr, denominator_expr = equation.split('/') # Evaluate the expressions to get integer values numerator = eval(numerator_expr) denominator = eval(denominator_expr) # Get the simplified fraction using the Fraction class from the fractions module simplified_fraction = Fraction(numerator, denominator) # Return the string representation of the simplified fraction return f\\"{simplified_fraction.numerator}/{simplified_fraction.denominator}\\""},{"question":"def can_form_string(words: List[str], s: str) -> bool: Determines if s can be formed by concatenating a sequence of words from the array words (each word can be used multiple times). Returns True if it can be formed, otherwise returns False. >>> can_form_string([\\"cat\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cats\\"], \\"catsanddog\\") == True >>> can_form_string([\\"apple\\", \\"pen\\"], \\"applepenapple\\") == True >>> can_form_string([\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"], \\"catsandog\\") == False >>> can_form_string([\\"a\\", \\"b\\", \\"c\\"], \\"\\") == True >>> can_form_string([\\"hello\\", \\"world\\"], \\"world\\") == True >>> can_form_string([\\"a\\"], \\"aaaa\\") == True >>> can_form_string([], \\"a\\") == False","solution":"def can_form_string(words, s): Returns True if the string s can be formed by concatenating a sequence of words from the array words (each word can be used multiple times). Otherwise returns False. # Initialize a set to store the words for quick lookup word_set = set(words) # Initialize a list to handle dynamic programming approach dp = [False] * (len(s) + 1) dp[0] = True # Base case: an empty string can be formed trivially for i in range(1, len(s) + 1): for word in word_set: if dp[i - len(word)] and s[i - len(word):i] == word: dp[i] = True break # No need to check further if condition satisfied return dp[-1]"},{"question":"class FrequencyTracker: A class that tracks the frequency of elements in a dynamically updating array. FrequencyTracker() -> Initializes the FrequencyTracker object. add(number: int) -> None: Adds 'number' to the array. deleteOne(number: int) -> None: Removes one occurrence of 'number' from the array. If 'number' does not exist, do nothing. getFrequency(number: int) -> int: Returns the frequency of 'number' in the array. If the number does not exist, return 0. Example: >>> tracker = FrequencyTracker() >>> tracker.getFrequency(1) 0 >>> tracker.add(5) >>> tracker.getFrequency(5) 1 >>> tracker.add(5) >>> tracker.getFrequency(5) 2 >>> tracker.deleteOne(5) >>> tracker.getFrequency(5) 1 Unit Test: def test_initial_state(): tracker = FrequencyTracker() assert tracker.getFrequency(1) == 0 def test_add_single_element(): tracker = FrequencyTracker() tracker.add(5) assert tracker.getFrequency(5) == 1 def test_add_multiple_elements(): tracker = FrequencyTracker() tracker.add(5) tracker.add(5) tracker.add(5) assert tracker.getFrequency(5) == 3 def test_delete_one_element(): tracker = FrequencyTracker() tracker.add(5) tracker.add(5) tracker.deleteOne(5) assert tracker.getFrequency(5) == 1 def test_delete_element_not_in_tracker(): tracker = FrequencyTracker() tracker.add(5) tracker.deleteOne(3) assert tracker.getFrequency(5) == 1 assert tracker.getFrequency(3) == 0 def test_delete_element_until_zero(): tracker = FrequencyTracker() tracker.add(5) tracker.add(5) tracker.deleteOne(5) tracker.deleteOne(5) assert tracker.getFrequency(5) == 0 def test_mix_operations(): tracker = FrequencyTracker() tracker.add(5) tracker.add(3) tracker.add(5) tracker.deleteOne(3) assert tracker.getFrequency(5) == 2 assert tracker.getFrequency(3) == 0 tracker.deleteOne(5) assert tracker.getFrequency(5) == 1","solution":"class FrequencyTracker: def __init__(self): self.frequency = {} def add(self, number): if number in self.frequency: self.frequency[number] += 1 else: self.frequency[number] = 1 def deleteOne(self, number): if number in self.frequency: self.frequency[number] -= 1 if self.frequency[number] == 0: del self.frequency[number] def getFrequency(self, number): return self.frequency.get(number, 0)"},{"question":"def longest_common_subsequence(nums1, nums2): Returns the length of the longest common subsequence between two sorted arrays nums1 and nums2. >>> longest_common_subsequence([1, 3, 4, 1], [3, 4, 1, 2]) 3 >>> longest_common_subsequence([1, 2, 3], [4, 5, 6]) 0 >>> longest_common_subsequence([1, 2, 3], [1, 2, 3]) 3 >>> longest_common_subsequence([1, 3, 7, 8, 9], [1, 3, 9]) 3 >>> longest_common_subsequence([], [1, 2, 3]) 0 >>> longest_common_subsequence([1, 2, 3], []) 0 >>> longest_common_subsequence([], []) 0 >>> longest_common_subsequence([1, 2, 3], [3, 4, 5]) 1 >>> longest_common_subsequence([1, 4, 5, 6], [4, 6, 8, 10]) 2","solution":"def longest_common_subsequence(nums1, nums2): Returns the length of the longest common subsequence between two sorted arrays nums1 and nums2. m = len(nums1) n = len(nums2) # Create a 2D array to store the length of LCS dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill the dp array for i in range(1, m + 1): for j in range(1, n + 1): if nums1[i - 1] == nums2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"def first_repeated_letter(s: str) -> str: Returns the first letter to appear twice in the string s. If no letter appears twice, returns an empty string. >>> first_repeated_letter(\\"abca\\") == \\"a\\" >>> first_repeated_letter(\\"abcabc\\") == \\"a\\" >>> first_repeated_letter(\\"abcdbe\\") == \\"b\\" >>> first_repeated_letter(\\"xxy\\") == \\"x\\" >>> first_repeated_letter(\\"abcdef\\") == \\"\\" >>> first_repeated_letter(\\"xyz\\") == \\"\\"","solution":"def first_repeated_letter(s): Returns the first letter to appear twice in the string s. If no letter appears twice, returns an empty string. seen = set() for letter in s: if letter in seen: return letter seen.add(letter) return \\"\\""},{"question":"def trap(height): Return the total amount of water that would accumulate after it rains. :param height: List[int] - an array representing the height of the terrain. :return: int - total amount of water accumulated. >>> trap([]) == 0 >>> trap([1, 2, 3, 4, 5]) == 0 >>> trap([0, 1, 0, 2]) == 1 >>> trap([2, 1, 0, 1, 2]) == 4 >>> trap([0,1,0,2,1,0,1,3,2,1,2,1]) == 6 >>> trap([1, 1, 1, 1]) == 0 >>> trap([3, 0, 3]) == 3 >>> trap([0, 4, 6, 4, 0]) == 0","solution":"def trap(height): Return the total amount of water that would accumulate after it rains. :param height: List[int] - an array representing the height of the terrain. :return: int - total amount of water accumulated. if not height: return 0 left_max = [0] * len(height) right_max = [0] * len(height) left_max[0] = height[0] for i in range(1, len(height)): left_max[i] = max(left_max[i-1], height[i]) right_max[-1] = height[-1] for i in range(len(height)-2, -1, -1): right_max[i] = max(right_max[i+1], height[i]) water_trapped = 0 for i in range(len(height)): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"from typing import List def get_suspicious_transactions(transactions: List[str]) -> List[str]: Returns a list of potentially suspicious transactions based on the given rules. :param transactions: List of transaction strings in the format <name>:<time>:<amount>:<city> :return: List of strings containing potentially suspicious transactions def test_amount_exceeding_1000(): transactions = [\\"alice:20:1500:mtv\\"] assert get_suspicious_transactions(transactions) == [\\"alice:20:1500:mtv\\"] def test_different_city_within_60_minutes(): transactions = [\\"alice:20:800:mtv\\", \\"alice:50:100:beijing\\"] assert set(get_suspicious_transactions(transactions)) == set([\\"alice:20:800:mtv\\", \\"alice:50:100:beijing\\"]) def test_no_suspicious_transactions(): transactions = [\\"alice:20:500:mtv\\", \\"alice:80:100:mtv\\"] assert get_suspicious_transactions(transactions) == [] def test_multiple_suspicious_transactions(): transactions = [\\"alice:20:1500:mtv\\", \\"alice:50:100:beijing\\", \\"bob:60:200:mtv\\", \\"bob:120:300:sanjose\\"] assert set(get_suspicious_transactions(transactions)) == set([\\"alice:20:1500:mtv\\", \\"alice:50:100:beijing\\", \\"bob:60:200:mtv\\", \\"bob:120:300:sanjose\\"]) def test_mixed_conditions(): transactions = [\\"alice:20:150:mtv\\", \\"alice:50:1200:beijing\\", \\"bob:30:1200:mtv\\", \\"bob:90:800:sanjose\\"] assert set(get_suspicious_transactions(transactions)) == set([\\"alice:20:150:mtv\\", \\"alice:50:1200:beijing\\", \\"bob:30:1200:mtv\\", \\"bob:90:800:sanjose\\"]) def test_single_transaction(): transactions = [\\"alice:20:800:mtv\\"] assert get_suspicious_transactions(transactions) == []","solution":"def get_suspicious_transactions(transactions): Returns a list of potentially suspicious transactions based on the given rules. :param transactions: List of transaction strings in the format <name>:<time>:<amount>:<city> :return: List of strings containing potentially suspicious transactions suspicious_transactions = [] transaction_list = [] for transaction in transactions: name, time, amount, city = transaction.split(':') transaction_list.append({ 'name': name, 'time': int(time), 'amount': int(amount), 'city': city, 'transaction': transaction }) for i, t in enumerate(transaction_list): if t['amount'] > 1000: suspicious_transactions.append(t['transaction']) for j in range(len(transaction_list)): if i != j: t_other = transaction_list[j] if (t['name'] == t_other['name'] and t['city'] != t_other['city'] and abs(t['time'] - t_other['time']) <= 60): if t['transaction'] not in suspicious_transactions: suspicious_transactions.append(t['transaction']) if t_other['transaction'] not in suspicious_transactions: suspicious_transactions.append(t_other['transaction']) return suspicious_transactions"},{"question":"from collections import Counter from typing import List def count_words_formed(s: str, words: List[str]) -> int: Returns the count of words that can be formed by rearranging the letters in the string \`s\`. >>> count_words_formed(\\"abc\\", [\\"abc\\", \\"bca\\", \\"cab\\", \\"abcd\\"]) == 3 >>> count_words_formed(\\"xyz\\", [\\"abc\\", \\"bca\\", \\"cab\\"]) == 0 >>> count_words_formed(\\"listen\\", [\\"enlist\\", \\"google\\", \\"inlets\\", \\"banana\\"]) == 2 >>> count_words_formed(\\"word\\", [\\"word\\"]) == 1 >>> count_words_formed(\\"abc\\", [\\"abc\\", \\"abc\\", \\"abc\\"]) == 3 >>> count_words_formed(\\"\\", [\\"\\", \\"\\", \\"abc\\"]) == 2","solution":"from collections import Counter def count_words_formed(s, words): Returns the count of words that can be formed by rearranging the letters in the string \`s\`. s_counter = Counter(s) count = 0 for word in words: if Counter(word) == s_counter: count += 1 return count"},{"question":"from typing import List def min_steps(grid: List[List[int]]) -> int: Given an m x n integer matrix representing a maze, returns the minimum number of steps required to reach the bottom-right corner of the maze from the top-left corner or -1 if it's not possible. 0 represents an open path and 1 represents a wall. You may move up, down, left, or right. >>> min_steps([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) == 4 >>> min_steps([ ... [0, 1, 0], ... [1, 1, 0], ... [0, 0, 0] ... ]) == -1 pass","solution":"from collections import deque def min_steps(grid): Returns the minimum number of steps required to reach the bottom-right corner of the maze from the top-left corner. If it is not possible to reach the goal, return -1. if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return -1 m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def is_valid(x, y): return 0 <= x < m and 0 <= y < n and grid[x][y] == 0 queue = deque([(0, 0, 0)]) # (x, y, steps) visited = set((0, 0)) while queue: x, y, steps = queue.popleft() if (x, y) == (m-1, n-1): return steps for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return -1"},{"question":"def count_words_with_prefix(words, queries): For each query (prefix), count how many words in the list start with the given prefix. :param words: List of words. :param queries: List of prefix queries. :return: List of counts where each element is the number of words starting with the corresponding prefix query. >>> count_words_with_prefix([\\"apple\\", \\"app\\", \\"apricot\\", \\"banana\\", \\"bat\\", \\"bar\\"], [\\"ap\\", \\"app\\", \\"ba\\", \\"ban\\", \\"c\\"]) [3, 2, 3, 1, 0] >>> count_words_with_prefix([], [\\"a\\", \\"b\\"]) [0, 0] >>> count_words_with_prefix([\\"apple\\", \\"app\\", \\"apricot\\", \\"banana\\", \\"bat\\", \\"bar\\"], []) [] >>> count_words_with_prefix([\\"apple\\", \\"app\\", \\"apricot\\", \\"banana\\", \\"bat\\", \\"bar\\"], [\\"c\\", \\"d\\", \\"e\\"]) [0, 0, 0] >>> count_words_with_prefix([\\"apple\\", \\"apply\\", \\"appointment\\", \\"appetite\\"], [\\"app\\", \\"apple\\", \\"appl\\", \\"a\\"]) [4, 1, 2, 4] >>> count_words_with_prefix([\\"car\\", \\"cat\\", \\"carbon\\", \\"cable\\"], [\\"car\\", \\"cat\\", \\"carbon\\"]) [2, 1, 1]","solution":"def count_words_with_prefix(words, queries): For each query (prefix), count how many words in the list start with the given prefix. :param words: List of words. :param queries: List of prefix queries. :return: List of counts where each element is the number of words starting with the corresponding prefix query. from collections import defaultdict # Create a dictionary to store counts of prefixes prefix_count = defaultdict(int) # Count all possible prefixes in the words for word in words: prefix = '' for char in word: prefix += char prefix_count[prefix] += 1 # Collect counts for each query result = [] for query in queries: result.append(prefix_count[query]) return result"},{"question":"def smallest_reordered_string(s: str, k: int) -> str: Constructs a new string by reordering the letters of s such that every character that appears in s appears exactly once in the new string and return the smallest lexicographical string. If it is impossible, return an empty string. Args: s (str): The input string. k (int): Unused parameter for this problem. Returns: str: The reordered string or an empty string if impossible. >>> smallest_reordered_string(\\"a\\", 3) 'a' >>> smallest_reordered_string(\\"abc\\", 2) 'abc' >>> smallest_reordered_string(\\"aabb\\", 3) '' >>> smallest_reordered_string(\\"abca\\", 1) '' >>> smallest_reordered_string(\\"dbca\\", 1) 'abcd' >>> smallest_reordered_string(\\"\\", 1) ''","solution":"def smallest_reordered_string(s, k): Constructs a new string by reordering the letters of s such that every character that appears in s appears exactly once in the new string and return the smallest lexicographical string. If it is impossible, return an empty string. Args: s (str): The input string. k (int): Unused parameter for this problem. Returns: str: The reordered string or an empty string if impossible. # Create a frequency dictionary for characters in the string from collections import Counter freq = Counter(s) # Check if any character appears more than once which would make it impossible for value in freq.values(): if value > 1: return \\"\\" # Return the lexicographically smallest string by sorting the keys return ''.join(sorted(freq.keys()))"},{"question":"def is_interleaving(s: str, words: List[str]) -> bool: Determine if the string \`s\` is an interleaving of the strings in \`words\`. Parameters: s (str): The target string. words (list of str): List of strings to interleave. Returns: bool: True if \`s\` is an interleaving of \`words\`, False otherwise. >>> is_interleaving(\\"abc\\", [\\"a\\", \\"b\\", \\"c\\"]) True >>> is_interleaving(\\"abd\\", [\\"a\\", \\"b\\", \\"c\\"]) False >>> is_interleaving(\\"\\", [\\"a\\", \\"b\\"]) False >>> is_interleaving(\\"abc\\", []) False >>> is_interleaving(\\"\\", []) True >>> is_interleaving(\\"aadbbcbcac\\", [\\"aabcc\\", \\"dbbca\\"]) True >>> is_interleaving(\\"aadbbbaccc\\", [\\"aabcc\\", \\"dbbca\\"]) False","solution":"def is_interleaving(s, words): Determine if the string \`s\` is an interleaving of the strings in \`words\`. Parameters: s (str): The target string. words (list of str): List of strings to interleave. Returns: bool: True if \`s\` is an interleaving of \`words\`, False otherwise. def dfs(s, words, indices): if not s and all(i == len(words[j]) for j, i in enumerate(indices)): return True if not s: return False for idx, (w, i) in enumerate(zip(words, indices)): if i < len(w) and s[0] == w[i]: new_indices = indices[:] new_indices[idx] += 1 if dfs(s[1:], words, new_indices): return True return False return dfs(s, words, [0] * len(words))"},{"question":"def highest_cumulative_scores(scores, queries): Find the highest cumulative score for each query from the scores array. :param scores: List[int] - a list of integers representing the scores of employees :param queries: List[List[int]] - a list of queries where each query is a list of two integers [start, end] indicating the range of days for which to compute the cumulative score. :return: List[int] - a list of integers representing the highest cumulative scores for each query >>> test_single_query() >>> test_multiple_queries() >>> test_query_single_element() >>> test_query_entire_range() >>> test_query_with_overlapping_ranges() # Your code here def test_single_query(): scores = [1, 2, 3, 4, 5] queries = [[1, 3]] assert highest_cumulative_scores(scores, queries) == [9] def test_multiple_queries(): scores = [1, 2, 3, 4, 5] queries = [[1, 3], [0, 4], [2, 2]] assert highest_cumulative_scores(scores, queries) == [9, 15, 3] def test_query_single_element(): scores = [10, 20, 30, 40, 50] queries = [[3, 3], [1, 1]] assert highest_cumulative_scores(scores, queries) == [40, 20] def test_query_entire_range(): scores = [3, 6, 9, 12, 15] queries = [[0, 4]] assert highest_cumulative_scores(scores, queries) == [45] def test_query_with_overlapping_ranges(): scores = [2, 4, 6, 8, 10] queries = [[0, 2], [1, 3], [2, 4]] assert highest_cumulative_scores(scores, queries) == [12, 18, 24]","solution":"def highest_cumulative_scores(scores, queries): Returns the highest cumulative score for each query from the scores array. :param scores: List[int] - a list of integers representing the scores of employees :param queries: List[List[int]] - a list of queries where each query is a list of two integers [start, end] :return: List[int] - a list of integers representing the highest cumulative scores for each query results = [] for start, end in queries: cumulative_score = sum(scores[start:end+1]) results.append(cumulative_score) return results"},{"question":"def maxRobbery(nums: List[int]) -> int: Returns the maximum amount of money the robber can rob tonight without robbing two consecutive houses. >>> maxRobbery([]) == 0 >>> maxRobbery([5]) == 5 >>> maxRobbery([1, 2]) == 2 >>> maxRobbery([2, 7, 9, 3, 1]) == 12 >>> maxRobbery([1, 2, 3, 1]) == 4 >>> maxRobbery([2, 1, 1, 2]) == 4 >>> maxRobbery([100, 200, 300, 400, 500]) == 900 >>> maxRobbery([10, 5, 10, 5, 10]) == 30","solution":"def maxRobbery(nums): Returns the maximum amount of money the robber can rob tonight without robbing two consecutive houses. if not nums: return 0 n = len(nums) if n == 1: return nums[0] # Initialize two variables to keep track of the maximum profit prev1, prev2 = 0, 0 for num in nums: temp = prev1 prev1 = max(prev2 + num, prev1) prev2 = temp return prev1"},{"question":"from collections import deque class SlidingWindowMinimum: def __init__(self, nums, k): Initializes the object with the integer array \`nums\` and the fixed integer \`k\`. self.nums = nums self.k = k self.min_deque = deque() self.preprocess() def preprocess(self): Preprocess the sliding window minimum for all possible windows. self.min_arr = [None] * len(self.nums) for i in range(len(self.nums)): while self.min_deque and self.nums[self.min_deque[-1]] >= self.nums[i]: self.min_deque.pop() self.min_deque.append(i) if self.min_deque[0] <= i - self.k: self.min_deque.popleft() if i >= self.k - 1: self.min_arr[i - self.k + 1] = self.nums[self.min_deque[0]] def getMin(self, i): Return the minimum element in the sliding window starting at index \`i\`. >>> swm = SlidingWindowMinimum([1, 3, -1, -3, 5, 3, 6, 7], 3) >>> swm.getMin(0) -1 >>> swm.getMin(1) -3 >>> swm.getMin(2) -3 >>> swm.getMin(6) 6 >>> swm.getMin(7) -1 if i < 0 or i + self.k - 1 >= len(self.nums): return -1 return self.min_arr[i]","solution":"from collections import deque class SlidingWindowMinimum: def __init__(self, nums, k): self.nums = nums self.k = k self.min_deque = deque() self.preprocess() def preprocess(self): Preprocess the sliding window minimum for all possible windows. self.min_arr = [None] * len(self.nums) for i in range(len(self.nums)): while self.min_deque and self.nums[self.min_deque[-1]] >= self.nums[i]: self.min_deque.pop() self.min_deque.append(i) # Remove elements which are out of this window if self.min_deque[0] <= i - self.k: self.min_deque.popleft() # Start storing values when i is at least k-1 if i >= self.k - 1: self.min_arr[i - self.k + 1] = self.nums[self.min_deque[0]] def getMin(self, i): Return the minimum element in the sliding window starting at index i. if i < 0 or i + self.k - 1 >= len(self.nums): return -1 return self.min_arr[i]"},{"question":"from typing import List def dijkstra(n: int, edges: List[List[int]]) -> List[int]: Implements Dijkstra's algorithm to find the shortest path from node 0 to all other nodes. Parameters: n (int): The number of nodes in the graph. edges (List[List[int]]): The edges of the graph where each edge is represented as [u, v, w]. u: Starting node of the edge. v: Ending node of the edge. w: Weight of the edge. Returns: List[int]: The shortest distances from node 0 to all other nodes. If a node is unreachable, its distance is -1. >>> dijkstra(1, []) [0] >>> dijkstra(2, [[0, 1, 1]]) [0, 1] >>> dijkstra(3, [[0, 1, 4]]) [0, 4, -1] >>> edges = [ ... [0, 1, 4], [0, 2, 2], [1, 2, 5], ... [1, 3, 10], [2, 3, 3] ...] >>> dijkstra(4, edges) [0, 4, 2, 5] >>> edges = [ ... [0, 1, 4], [0, 2, -2], [1, 3, 1], ... [2, 3, 2] ...] >>> dijkstra(4, edges) [0, 4, -2, 0] >>> edges = [ ... [0, 1, 2], [1, 2, 3] ...] >>> dijkstra(4, edges) [0, 2, 5, -1] >>> edges = [ ... [0, 1, 10], [0, 2, 5], [1, 2, 2], ... [1, 3, 1], [2, 1, 3], [2, 3, 9], ... [2, 4, 2], [3, 4, 4], [4, 3, 6], [4, 0, 7] ...] >>> dijkstra(5, edges) [0, 8, 5, 9, 7] pass","solution":"import heapq def dijkstra(n, edges): Implements Dijkstra's algorithm to find the shortest path from node 0 to all other nodes. Parameters: n (int): The number of nodes in the graph. edges (List[List[int]]): The edges of the graph where each edge is represented as [u, v, w]. u: Starting node of the edge. v: Ending node of the edge. w: Weight of the edge. Returns: List[int]: The shortest distances from node 0 to all other nodes. If a node is unreachable, its distance is -1. graph = {i: [] for i in range(n)} for u, v, w in edges: graph[u].append((v, w)) # Distance table, initialized to infinity dist = [float('inf')] * n dist[0] = 0 # Priority queue for the minimum distance pq = [(0, 0)] # (distance, node) while pq: curr_dist, u = heapq.heappop(pq) if curr_dist > dist[u]: continue for v, weight in graph[u]: distance = curr_dist + weight if distance < dist[v]: dist[v] = distance heapq.heappush(pq, (distance, v)) return [d if d != float('inf') else -1 for d in dist]"},{"question":"def rearrange_and_sort_subarrays(arr, k): Rearranges the array such that every k consecutive elements form a sorted subarray. Args: arr (list): The list of integers to be rearranged. k (int): The size of each subarray. Returns: list: The modified array with sorted subarrays of size k or -1 if it's not possible. >>> rearrange_and_sort_subarrays([4, 2, 1, 3], 2) [2, 4, 1, 3] >>> rearrange_and_sort_subarrays([1, 7, 3, 9, 5], 3) [1, 3, 7, 5, 9] >>> rearrange_and_sort_subarrays([1, 2, 3], 4) [1, 2, 3] >>> rearrange_and_sort_subarrays([9, 3, 4, 8], 5) [3, 4, 8, 9] >>> rearrange_and_sort_subarrays([1, 2, 3], 0) -1 >>> rearrange_and_sort_subarrays([], 3) -1 >>> rearrange_and_sort_subarrays([1, 3, 2], -3) -1 >>> rearrange_and_sort_subarrays([9, 1, 8, 2, 7], 3) [1, 8, 9, 2, 7] >>> rearrange_and_sort_subarrays([1, 2, 3, 4, 5], 1) [1, 2, 3, 4, 5]","solution":"def rearrange_and_sort_subarrays(arr, k): Rearranges the array such that every k consecutive elements form a sorted subarray. Args: arr (list): The list of integers to be rearranged. k (int): The size of each subarray. Returns: list: The modified array with sorted subarrays of size k or -1 if it's not possible. if k <= 0 or not arr: return -1 length = len(arr) # If k is greater than the array length, return the sorted array if k >= length: return sorted(arr) # Otherwise, sort each k-length subarray result = [] for i in range(0, length, k): subarray = arr[i:i+k] result.extend(sorted(subarray)) return result"},{"question":"from typing import List def max_water_area(heights: List[int]) -> int: Returns the maximum area of water that can be trapped between any two buildings. Args: heights: List[int] - a list of integers representing the heights of the buildings Returns: int - the maximum water area >>> max_water_area([1, 8, 6, 2, 5, 4, 8, 3, 7]) 49 >>> max_water_area([1, 1]) 1 >>> max_water_area([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) 25 >>> max_water_area([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 25 >>> max_water_area([1, 2, 1]) 2 >>> max_water_area([4, 3, 2, 1, 4]) 16 >>> max_water_area([1]) 0 >>> max_water_area([1, 2, 1, 3, 4]) 6","solution":"def max_water_area(heights): Returns the maximum area of water that can be trapped between any two buildings. Args: heights: List[int] - a list of integers representing the heights of the buildings Returns: int - the maximum water area max_area = 0 left, right = 0, len(heights) - 1 while left < right: height = min(heights[left], heights[right]) width = right - left max_area = max(max_area, height * width) if heights[left] < heights[right]: left += 1 else: right -= 1 return max_area"},{"question":"def longest_substring_with_k_deletions(s: str, k: int) -> int: Returns the length of the longest substring that contains only one unique character after making at most k deletions. >>> longest_substring_with_k_deletions(\\"aaaaa\\", 2) # 5 >>> longest_substring_with_k_deletions(\\"bbbbbb\\", 1) # 6 >>> longest_substring_with_k_deletions(\\"ababab\\", 2) # 5 >>> longest_substring_with_k_deletions(\\"ab\\", 2) # 2 >>> longest_substring_with_k_deletions(\\"aaabaaa\\", 1) # 7 >>> longest_substring_with_k_deletions(\\"ababab\\", 0) # 1 >>> longest_substring_with_k_deletions(\\"\\", 2) # 0","solution":"def longest_substring_with_k_deletions(s, k): Returns the length of the longest substring that contains only one unique character after making at most k deletions. n = len(s) if n == 0: return 0 def longest_substring_with_k_replace(char): max_length = 0 left = 0 max_count = 0 counts = {'a': 0, 'b': 0} for right in range(n): counts[s[right]] += 1 max_count = max(max_count, counts[s[right]]) while (right - left + 1) - max_count > k: counts[s[left]] -= 1 left += 1 max_length = max(max_length, right - left + 1) return max_length return max(longest_substring_with_k_replace('a'), longest_substring_with_k_replace('b'))"},{"question":"from typing import List, Tuple def rob(nums: List[int], queries: List[Tuple[int, int]]) -> List[int]: Determines the maximum amount of money that can be robbed for each query without alerting the police. Parameters: nums (List[int]): An array representing the amount of money of each house. queries (List[Tuple[int, int]]): A list of intervals representing the queries. Returns: List[int]: An array of results where each result corresponds to a query in queries. >>> rob([1, 2, 3, 1], [(0, 2)]) [4] >>> rob([2, 7, 9, 3, 1], [(1, 3), (0, 4)]) [10, 12]","solution":"def rob(nums, queries): Determines the maximum amount of money that can be robbed for each query without alerting the police. def rob_linear(houses): Helper function to implement the house robber algorithm for a linear street of houses. if not houses: return 0 if len(houses) == 1: return houses[0] if len(houses) == 2: return max(houses) dp = [0] * len(houses) dp[0] = houses[0] dp[1] = max(houses[0], houses[1]) for i in range(2, len(houses)): dp[i] = max(dp[i-1], dp[i-2] + houses[i]) return dp[-1] results = [] for start, end in queries: sub_array = nums[start:end+1] max_robbed = rob_linear(sub_array) results.append(max_robbed) return results"},{"question":"def longest_substring_with_k_chars(s: str, k: int) -> int: Returns the length of the longest substring in \`s\` that contains at most \`k\` different characters. >>> longest_substring_with_k_chars(\\"A\\", 1) == 1 >>> longest_substring_with_k_chars(\\"A\\", 0) == 0 >>> longest_substring_with_k_chars(\\"ABCABC\\", 2) == 2 >>> longest_substring_with_k_chars(\\"ABCABC\\", 1) == 1 >>> longest_substring_with_k_chars(\\"ABCABC\\", 4) == 6 >>> longest_substring_with_k_chars(\\"\\", 1) == 0 >>> longest_substring_with_k_chars(\\"\\", 3) == 0 >>> longest_substring_with_k_chars(\\"AAAAAAAA\\", 1) == 8 >>> longest_substring_with_k_chars(\\"AAAABBBBCCCC\\", 3) == 12 >>> longest_substring_with_k_chars(\\"AABACCCAB\\", 2) == 5","solution":"def longest_substring_with_k_chars(s, k): Returns the length of the longest substring in \`s\` that contains at most \`k\` different characters. if k == 0: return 0 window_start = 0 max_length = 0 char_frequency = {} for window_end in range(len(s)): right_char = s[window_end] if right_char not in char_frequency: char_frequency[right_char] = 0 char_frequency[right_char] += 1 while len(char_frequency) > k: left_char = s[window_start] char_frequency[left_char] -= 1 if char_frequency[left_char] == 0: del char_frequency[left_char] window_start += 1 max_length = max(max_length, window_end - window_start + 1) return max_length"},{"question":"def top_k_scores(nums: List[int], k: int) -> List[int]: Returns the k highest scores in descending order. If there are fewer than k unique scores, returns all unique scores in descending order. :param nums: List of integers representing scores :param k: Integer representing the number of top scores to return :return: List of top k scores in descending order pass def test_top_k_scores_normal_case(): assert top_k_scores([50, 90, 85, 75, 90], 3) == [90, 85, 75] def test_top_k_scores_less_unique_scores(): assert top_k_scores([50, 90, 85, 75, 75, 85], 5) == [90, 85, 75, 50] def test_top_k_scores_more_k_than_unique(): assert top_k_scores([80, 70, 60], 5) == [80, 70, 60] def test_top_k_scores_all_same_scores(): assert top_k_scores([10, 10, 10], 1) == [10] def test_top_k_scores_zero_k(): assert top_k_scores([100, 90, 80, 70], 0) == [] def test_top_k_scores_negative_case(): assert top_k_scores([100, 100, 50, 20], 2) == [100, 50]","solution":"def top_k_scores(nums, k): Returns the k highest scores in descending order. If there are fewer than k unique scores, returns all unique scores in descending order. :param nums: List of integers representing scores :param k: Integer representing the number of top scores to return :return: List of top k scores in descending order # Convert the list to a set to get unique scores and sort them in descending order unique_scores = sorted(set(nums), reverse=True) # Return the top k scores return unique_scores[:k]"},{"question":"from typing import List def min_distance_to_park(city_area: List[List[int]]) -> List[List[int]]: Returns a 2D grid where each cell contains the minimum distance to the nearest park. -1 if the cell is an obstacle or cannot reach any park. >>> min_distance_to_park([ ... [1, 0, 0], ... [0, 0, 0], ... [0, 0, 1] ... ]) [[0, 1, 2], [1, 2, 1], [2, 1, 0]] >>> min_distance_to_park([ ... [1, 0, 0], ... [0, -1, 0], ... [0, 0, 1] ... ]) [[0, 1, 2], [1, -1, 1], [2, 1, 0]] >>> min_distance_to_park([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) [[0, 0, 0], [0, 0, 0], [0, 0, 0]] >>> min_distance_to_park([ ... [-1, -1, -1], ... [-1, -1, -1], ... [-1, -1, -1] ... ]) [[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]] >>> min_distance_to_park([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) [[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]","solution":"from collections import deque def min_distance_to_park(city_area): Returns a 2D grid where each cell contains the minimum distance to the nearest park. -1 if the cell is an obstacle or cannot reach any park. if not city_area: return [] rows, cols = len(city_area), len(city_area[0]) result = [[-1] * cols for _ in range(rows)] queue = deque() # Enqueue all parks and mark distances for obstacles for r in range(rows): for c in range(cols): if city_area[r][c] == 1: queue.append((r, c)) result[r][c] = 0 elif city_area[r][c] == -1: result[r][c] = -1 directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] # BFS to find the shortest path to the nearest park while queue: x, y = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and result[nx][ny] == -1 and city_area[nx][ny] == 0: result[nx][ny] = result[x][y] + 1 queue.append((nx, ny)) return result"},{"question":"class TextEditor: Implements a simplified text editor that supports append, delete, and retrieve functionalities. >>> editor = TextEditor() >>> editor.append(\\"Hello\\") >>> editor.text 'Hello' >>> editor.append(\\" World\\") >>> editor.text 'Hello World' >>> editor.delete(5) >>> editor.text 'Hello ' >>> editor.delete(10) >>> editor.text '' >>> editor.retrieve(5) 'Hello' >>> editor.retrieve(1) 'o' def __init__(self): # Initialize with an empty string pass def append(self, text: str): # Add 'text' to the current string pass def delete(self, k: int): # Delete the last 'k' characters from the current string pass def retrieve(self, k: int) -> str: # Return the last 'k' characters from the current string pass","solution":"class TextEditor: def __init__(self): self.text = \\"\\" def append(self, text): self.text += text def delete(self, k): if k >= len(self.text): self.text = \\"\\" else: self.text = self.text[:-k] def retrieve(self, k): if k >= len(self.text): return self.text else: return self.text[-k:]"},{"question":"from collections import deque from typing import List def shortest_path_binary_matrix(grid: List[List[int]], start: List[int], end: List[int]) -> int: Finds the shortest path from start to end in a binary matrix. Args: grid (list of lists): The binary matrix. start (list): The starting point [x, y]. end (list): The ending point [a, b]. Returns: int: The length of the shortest path, or -1 if no such path exists. >>> shortest_path_binary_matrix([[0, 1, 0], [0, 0, 0], [1, 0, 0]], [0, 0], [2, 2]) 4 >>> shortest_path_binary_matrix([[0, 1, 0], [1, 1, 0], [1, 0, 0]], [0, 0], [2, 2]) -1 >>> shortest_path_binary_matrix([[0, 0, 1, 0], [0, 1, 0, 0], [0, 1, 0, 1], [0, 0, 0, 0]], [0, 0], [3, 3]) 6 >>> shortest_path_binary_matrix([[1, 0], [0, 0]], [0, 0], [1, 1]) -1 >>> shortest_path_binary_matrix([[0, 0], [0, 1]], [0, 0], [1, 1]) -1 >>> shortest_path_binary_matrix([[0, 0, 0], [0, 0, 0], [0, 0, 0]], [0, 0], [0, 0]) 0","solution":"from collections import deque def shortest_path_binary_matrix(grid, start, end): Finds the shortest path from start to end in a binary matrix. Args: grid (list of lists): The binary matrix. start (list): The starting point [x, y]. end (list): The ending point [a, b]. Returns: int: The length of the shortest path, or -1 if no such path exists. m, n = len(grid), len(grid[0]) sx, sy = start ex, ey = end if grid[sx][sy] == 1 or grid[ex][ey] == 1: return -1 directions = [(0,1), (1,0), (0,-1), (-1,0)] queue = deque([(sx, sy, 0)]) visited = set((sx, sy)) while queue: x, y, dist = queue.popleft() if (x, y) == (ex, ey): return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"def has_pair_with_sum(arr: list, k: int) -> bool: Determines if there are any two distinct integers in the array \`arr\` that sum up to \`k\`. Parameters: - arr (list of int): The array of integers. - k (int): The target sum. Returns: - bool: True if there is a pair of integers in \`arr\` that sum up to \`k\`, False otherwise. # Example test cases # >>> has_pair_with_sum([10, 15, 3, 7], 17) # True # >>> has_pair_with_sum([1, 2, 3, 4], 8) # False # >>> has_pair_with_sum([1], 2) # False # >>> has_pair_with_sum([], 5) # False # >>> has_pair_with_sum([1000000, 3000000, 2000000, 4000000], 5000000) # True # >>> has_pair_with_sum([-1, -2, -3, -4, -5], -8) # True # >>> has_pair_with_sum([-10, 0, 10, 20, -20], 10) # True","solution":"def has_pair_with_sum(arr, k): Determines if there are any two distinct integers in the array \`arr\` that sum up to \`k\`. Parameters: - arr (list of int): The array of integers. - k (int): The target sum. Returns: - bool: True if there is a pair of integers in \`arr\` that sum up to \`k\`, False otherwise. seen = set() for number in arr: complement = k - number if complement in seen: return True seen.add(number) return False"},{"question":"def max_sum_magic_triplet(num1, num2, num3): This function finds the maximum sum of all possible magic triplets (x, y, z) such that x belongs to num1, y belongs to num2, z belongs to num3 and x < y < z. If no such triplet exists, it returns 0. >>> max_sum_magic_triplet([1, 2], [1, 2], [1, 2]) == 0 >>> max_sum_magic_triplet([1], [2], [3]) == 1 + 2 + 3 >>> max_sum_magic_triplet([1, 3], [4, 5], [6, 7, 8]) == 3 + 5 + 8 >>> max_sum_magic_triplet([-3, -2, -1], [0, 1, 2], [3, 4, 5]) == -1 + 2 + 5 >>> max_sum_magic_triplet([2, 2], [2, 2], [2, 2]) == 0 >>> num1 = list(range(1, 101)) >>> num2 = list(range(50, 151)) >>> num3 = list(range(100, 201)) >>> max_sum_magic_triplet(num1, num2, num3) == 100 + 150 + 200","solution":"def max_sum_magic_triplet(num1, num2, num3): This function finds the maximum sum of all possible magic triplets (x, y, z) such that x belongs to num1, y belongs to num2, z belongs to num3 and x < y < z. If no such triplet exists, it returns 0. max_sum = 0 found_triplet = False for x in num1: for y in num2: if y > x: for z in num3: if z > y: found_triplet = True max_sum = max(max_sum, x + y + z) return max_sum if found_triplet else 0"},{"question":"from typing import List def can_finish(num_courses: int, prerequisites: List[List[int]]) -> bool: Determine if it is possible to finish all courses given the prerequisites. Args: num_courses (int): The total number of courses. prerequisites (list): A list of pairs representing prerequisites. Returns: bool: True if it's possible to finish all courses, False otherwise. >>> can_finish(0, []) == True >>> can_finish(2, []) == True >>> can_finish(2, [[1, 0]]) == True >>> can_finish(2, [[0, 1], [1, 0]]) == False >>> can_finish(4, [[0, 1], [1, 2], [2, 3], [3, 1]]) == False >>> can_finish(4, [[0, 1], [1, 2], [2, 3]]) == True >>> can_finish(5, [[1, 0], [3, 2], [4, 3]]) == True >>> can_finish(5, [[1, 0], [2, 0], [3, 1], [4, 2], [4, 3]]) == True >>> can_finish(5, [[1, 0], [0, 2], [2, 1], [4, 3]]) == False","solution":"from collections import defaultdict, deque def can_finish(num_courses, prerequisites): Determine if it is possible to finish all courses given the prerequisites. Args: num_courses (int): The total number of courses. prerequisites (list): A list of pairs representing prerequisites. Returns: bool: True if it's possible to finish all courses, False otherwise. in_degree = [0] * num_courses adj_list = defaultdict(list) for crs, pre in prerequisites: adj_list[pre].append(crs) in_degree[crs] += 1 zero_in_degree_queue = deque([i for i in range(num_courses) if in_degree[i] == 0]) visited = 0 while zero_in_degree_queue: course = zero_in_degree_queue.popleft() visited += 1 for neighbor in adj_list[course]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: zero_in_degree_queue.append(neighbor) return visited == num_courses"},{"question":"def knapsack(weights, values, maxWeight): Determine the maximum total value that can be obtained by selecting a subset of the items such that the total weight does not exceed maxWeight. :param weights: List[int], the weights of the items :param values: List[int], the values of the items :param maxWeight: int, the maximum total weight allowed :return: int, the maximum total value obtainable within the weight constraint >>> knapsack([1, 2, 3], [10, 20, 30], 5) == 50 >>> knapsack([], [], 10) == 0 >>> knapsack([1, 2, 3], [10, 20, 30], 0) == 0 >>> knapsack([1, 3, 4], [15, 50, 60], 4) == 65 >>> knapsack([2, 3, 4, 5], [3, 4, 5, 6], 5) == 7 >>> knapsack([10, 20, 30], [60, 100, 120], 50) == 220 >>> knapsack([1, 2, 3], [10, 20, 30], 100) == 60","solution":"def knapsack(weights, values, maxWeight): Returns the maximum total value that can be obtained by selecting a subset of items where the total weight does not exceed maxWeight. :param weights: List[int], the weights of the items :param values: List[int], the values of the items :param maxWeight: int, the maximum total weight allowed :return: int, the maximum total value obtainable within the weight constraint n = len(weights) dp = [[0] * (maxWeight + 1) for _ in range(n + 1)] for i in range(n + 1): for w in range(maxWeight + 1): if i == 0 or w == 0: dp[i][w] = 0 elif weights[i-1] <= w: dp[i][w] = max(values[i-1] + dp[i-1][w-weights[i-1]], dp[i-1][w]) else: dp[i][w] = dp[i-1][w] return dp[n][maxWeight]"},{"question":"def min_removals_to_palindrome(s: str, k: int) -> int: Computes the smallest number of characters to remove to make string s a palindrome. Args: s (str): The input string. k (int): The maximum number of characters that can be removed. Returns: int: The minimum number of characters to remove to make s a palindrome. >>> min_removals_to_palindrome(\\"abca\\", 1) 1 >>> min_removals_to_palindrome(\\"abc\\", 2) 2 >>> min_removals_to_palindrome(\\"racecar\\", 0) 0 >>> min_removals_to_palindrome(\\"racecar\\", 1) 0 >>> min_removals_to_palindrome(\\"a\\", 0) 0 >>> min_removals_to_palindrome(\\"ab\\", 1) 1 >>> min_removals_to_palindrome(\\"abcde\\", 5) 4 >>> min_removals_to_palindrome(\\"abca\\", 0) -1 >>> min_removals_to_palindrome(\\"abc\\", 1) -1 >>> min_removals_to_palindrome(\\"abcd\\", 2) -1","solution":"def min_removals_to_palindrome(s: str, k: int) -> int: Computes the smallest number of characters to remove to make string s a palindrome. Args: s (str): The input string. k (int): The maximum number of characters that can be removed. Returns: int: The minimum number of characters to remove to make s a palindrome. n = len(s) # Function to find longest palindromic subsequence def longest_palindromic_subseq(s: str) -> int: dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = 1 for cl in range(2, n + 1): for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j] and cl == 2: dp[i][j] = 2 elif s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) return dp[0][n - 1] lps_length = longest_palindromic_subseq(s) min_removals = n - lps_length return min_removals if min_removals <= k else -1"},{"question":"def sum_of_subarray_products(arr: List[int]) -> int: Returns the sum of the products of all subarrays of the input array \`arr\`. >>> sum_of_subarray_products([1, 2, 3]) 20 >>> sum_of_subarray_products([5]) 5 >>> sum_of_subarray_products([1, -2, 3]) 1 + (-2) + 3 + 1*(-2) + (-2)*3 + 1*(-2)*3 >>> sum_of_subarray_products([0, 0, 0]) 0","solution":"def sum_of_subarray_products(arr): Returns the sum of the products of all subarrays of the input array \`arr\`. n = len(arr) total_sum = 0 # Iterate over all possible starting points of subarrays for start in range(n): product = 1 # Iterate over all possible ending points of subarrays starting from 'start' for end in range(start, n): product *= arr[end] total_sum += product return total_sum"},{"question":"def num_matching_subsequences(s: str, words: List[str]) -> int: Determine the number of subsequences of \`s\` that are equal to any word in \`words\`. >>> num_matching_subsequences(\\"abc\\", [\\"def\\", \\"ghi\\"]) 0 >>> num_matching_subsequences(\\"abc\\", [\\"abc\\"]) 1 >>> num_matching_subsequences(\\"abc\\", [\\"a\\", \\"b\\", \\"c\\"]) 3 >>> num_matching_subsequences(\\"abcde\\", [\\"a\\", \\"bb\\", \\"acd\\", \\"ace\\"]) 3 >>> num_matching_subsequences(\\"\\", [\\"a\\", \\"b\\", \\"c\\"]) 0 >>> num_matching_subsequences(\\"abc\\", []) 0 >>> num_matching_subsequences(\\"abcbc\\", [\\"ab\\", \\"bc\\", \\"abc\\"]) 3","solution":"def num_matching_subsequences(s, words): Function to determine the number of subsequences of \`s\` that are equal to any word in \`words\`. Args: s (str): the main string. words (List[str]): list of words to match as subsequences. Returns: int: the count of matching subsequences. def is_subsequence(s, word): it = iter(s) return all(char in it for char in word) return sum(is_subsequence(s, word) for word in words)"},{"question":"from typing import List def exist(board: List[List[str]], word: str) -> bool: Check if the word exists in the grid. Parameters: board (List[List[str]]): 2D grid of characters word (str): word to search for in the grid Returns: bool: True if the word exists in the grid, otherwise False >>> exist([['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E']], \\"ABCCED\\") True >>> exist([['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E']], \\"SEE\\") True >>> exist([['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E']], \\"ABCB\\") False >>> exist([['A']], \\"A\\") True >>> exist([['A']], \\"B\\") False pass def test_word_exists_simple(): board = [['A','B','C','E'],['S','F','C','S'],['A','D','E','E']] word = \\"ABCCED\\" assert exist(board, word) == True def test_word_exists_different_path(): board = [['A','B','C','E'],['S','F','C','S'],['A','D','E','E']] word = \\"SEE\\" assert exist(board, word) == True def test_word_not_exists(): board = [['A','B','C','E'],['S','F','C','S'],['A','D','E','E']] word = \\"ABCB\\" assert exist(board, word) == False def test_single_letter_exists(): board = [['A']] word = \\"A\\" assert exist(board, word) == True def test_single_letter_not_exists(): board = [['A']] word = \\"B\\" assert exist(board, word) == False def test_large_board(): board = [['A','B','C','E'],['S','F','E','S'],['A','D','E','E']] word = \\"ABCESEEEFS\\" assert exist(board, word) == True","solution":"def exist(board, word): Check if the word exists in the grid. Parameters: board (List[List[str]]): 2D grid of characters word (str): word to search for in the grid Returns: bool: True if the word exists in the grid, otherwise False def dfs(board, word, i, j, k): if k == len(word): return True # Check bounds and character match if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]: return False temp = board[i][j] board[i][j] = \\"\\" # Recursively search in all 4 possible directions res = dfs(board, word, i + 1, j, k + 1) or dfs(board, word, i - 1, j, k + 1) or dfs(board, word, i, j + 1, k + 1) or dfs(board, word, i, j - 1, k + 1) board[i][j] = temp # backtracking return res for i in range(len(board)): for j in range(len(board[0])): if dfs(board, word, i, j, 0): return True return False"},{"question":"def balance_string(s: str) -> str: Continuously removes adjacent matching characters from the string until no more adjacent matching characters exist and returns the resulting string. Args: s (str): Input string consisting of lowercase English letters. Returns: str: The resulting string after all balancing operations have been performed. Examples: >>> balance_string(\\"\\") '' >>> balance_string(\\"abc\\") 'abc' >>> balance_string(\\"aabb\\") '' >>> balance_string(\\"abccba\\") '' >>> balance_string(\\"abbaca\\") 'ca' >>> balance_string(\\"aabbccddeeff\\") '' >>> balance_string(\\"abxba\\") 'abxba'","solution":"def balance_string(s): Continuously removes adjacent matching characters from the string until no more adjacent matching characters exist and returns the resulting string. Args: s (str): Input string consisting of lowercase English letters. Returns: str: The resulting string after all balancing operations have been performed. stack = [] for char in s: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return ''.join(stack)"},{"question":"def rotate(nums, k): Rotates the array nums by k steps. If k is positive, rotate to the right; if k is negative, rotate to the left. This function modifies the array in-place and has O(1) extra space complexity. Parameters: nums (List[int]): The input array. k (int): The number of steps to rotate the array. Returns: List[int]: The array after rotation.","solution":"def rotate(nums, k): Rotates the array nums by k steps. If k is positive, rotate to the right; if k is negative, rotate to the left. This function modifies the array in-place and has O(1) extra space complexity. Parameters: nums (List[int]): The input array. k (int): The number of steps to rotate the array. Returns: List[int]: The array after rotation. n = len(nums) if n == 0 or k == 0: return nums k = k % n # Handle cases where k is larger than the length of the array if k < 0: k += n # Convert negative k to a positive equivalent rotation # Define a helper function to reverse a portion of the array def reverse(start, end): while start < end: nums[start], nums[end] = nums[end], nums[start] start += 1 end -= 1 reverse(0, n - 1) # Reverse the entire array reverse(0, k - 1) # Reverse the first k elements reverse(k, n - 1) # Reverse the rest of the array return nums"},{"question":"class ListNode: def __init__(self, x): self.val = x self.next = None def getIntersectionNode(headA, headB): Find the node at which the intersection of two singly linked lists begins. If there is no intersection, return None. :type headA: ListNode :type headB: ListNode :rtype: ListNode","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def getIntersectionNode(headA, headB): Find the node at which the intersection of two singly linked lists begins. If there is no intersection, return None. :type headA: ListNode :type headB: ListNode :rtype: ListNode if not headA or not headB: return None pointerA = headA pointerB = headB while pointerA is not pointerB: pointerA = headA if pointerA is None else pointerA.next pointerB = headB if pointerB is None else pointerB.next return pointerA"},{"question":"def minCuts(logs: List[int], K: int) -> int: Returns the minimum number of cuts needed to ensure that every piece has a length of at most K. >>> minCuts([2, 3, 1], 3) == 0 >>> minCuts([1, 2, 3], 5) == 0 >>> minCuts([5, 7], 2) == 5 >>> minCuts([4, 4, 4], 1) == 9 >>> minCuts([3, 8, 10], 3) == 5 >>> minCuts([6, 9, 3], 2) == 7 >>> minCuts([9], 3) == 2 >>> minCuts([10], 1) == 9","solution":"def minCuts(logs, K): Returns the minimum number of cuts needed to ensure that every piece has a length of at most K. cuts = 0 for log in logs: if log > K: cuts += (log - 1) // K return cuts"},{"question":"from typing import List def max_area_of_island(grid: List[List[int]]) -> int: Calculate the maximum area of connected land parcels (cells with value 1) in the grid. :param grid: List[List[int]], a 2D list representing a grid of lands (1) and waters (0) :return: int, the maximum area of connected lands >>> max_area_of_island([[0, 1], [1, 1]]) 3 >>> max_area_of_island([[0, 0], [0, 0]]) 0 >>> max_area_of_island([[1, 1], [1, 1]]) 4 >>> max_area_of_island([ [1, 0, 1, 0], [0, 1, 0, 1], [1, 0, 1, 0], [0, 1, 0, 1] ]) 1 >>> max_area_of_island([[1]]) 1 >>> max_area_of_island([ [1, 1, 0, 0, 0], [1, 1, 0, 1, 1], [0, 0, 0, 1, 1] ]) 4 pass","solution":"def max_area_of_island(grid): Calculate the maximum area of connected land parcels (cells with value 1) in the grid. :param grid: List[List[int]], a 2D list representing a grid of lands (1) and waters (0) :return: int, the maximum area of connected lands if not grid: return 0 m, n = len(grid), len(grid[0]) visited = [[False for _ in range(n)] for _ in range(m)] def dfs(x, y): if x < 0 or x >= m or y < 0 or y >= n or grid[x][y] == 0 or visited[x][y]: return 0 visited[x][y] = True area = 1 area += dfs(x - 1, y) area += dfs(x + 1, y) area += dfs(x, y - 1) area += dfs(x, y + 1) return area max_area = 0 for i in range(m): for j in range(n): if grid[i][j] == 1 and not visited[i][j]: max_area = max(max_area, dfs(i, j)) return max_area"},{"question":"from typing import List import heapq from collections import Counter def rearrange_string(s: str, k: int) -> str: Rearranges the characters of \`s\` such that no two adjacent characters are the same and returns the lexicographically smallest string. If it's not possible, returns an empty string. from solution import rearrange_string def test_rearrange_string_example_case1(): assert rearrange_string(\\"aabbcc\\", 2) == \\"abcabc\\" or rearrange_string(\\"aabbcc\\", 2) == \\"acbacb\\" def test_rearrange_string_example_case2(): assert rearrange_string(\\"aaabc\\", 3) == \\"\\" def test_rearrange_string_with_no_k(): assert rearrange_string(\\"aabbcc\\", 0) == \\"aabbcc\\" def test_rearrange_string_single_characters(): assert rearrange_string(\\"abcd\\", 2) == \\"abcd\\" def test_rearrange_string_repeated_characters(): assert rearrange_string(\\"aaa\\", 2) == \\"\\" def test_rearrange_string_possible_rearrangement(): assert rearrange_string(\\"aaabc\\", 2) == \\"abaca\\" assert rearrange_string(\\"aaaabbbbcc\\", 2) != \\"\\" def test_rearrange_string_with_one_char(): assert rearrange_string(\\"a\\", 1) == \\"a\\"","solution":"import heapq from collections import Counter def rearrange_string(s, k): Rearranges the characters of \`s\` such that no two adjacent characters are the same and returns the lexicographically smallest string. If it's not possible, returns an empty string. if k == 0: return ''.join(sorted(s)) counter = Counter(s) max_heap = [] for char, freq in counter.items(): heapq.heappush(max_heap, (-freq, char)) result = [] wait_queue = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) wait_queue.append((freq + 1, char)) if len(wait_queue) >= k: front = wait_queue.pop(0) if front[0] < 0: heapq.heappush(max_heap, front) return ''.join(result) if len(result) == len(s) else \\"\\""},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BinaryTree: def __init__(self, root: TreeNode): self.root = root def maxPathSum(self) -> int: Returns the maximum path sum of the binary tree. A path can start and end at any node in the tree. pass # Test Cases def test_single_node(): root = TreeNode(1) tree = BinaryTree(root) assert tree.maxPathSum() == 1 def test_positive_tree(): root = TreeNode(1, TreeNode(2), TreeNode(3)) tree = BinaryTree(root) assert tree.maxPathSum() == 6 def test_negative_tree(): root = TreeNode(-10, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7))) tree = BinaryTree(root) assert tree.maxPathSum() == 42 def test_mixed_tree(): root = TreeNode(2, TreeNode(-1)) tree = BinaryTree(root) assert tree.maxPathSum() == 2 def test_complex_tree(): root = TreeNode(-10) root.left = TreeNode(9) root.right = TreeNode(20) root.right.left = TreeNode(15) root.right.right = TreeNode(7) tree = BinaryTree(root) assert tree.maxPathSum() == 42","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BinaryTree: def __init__(self, root: TreeNode): self.root = root def maxPathSum(self) -> int: Returns the maximum path sum of the binary tree. A path can start and end at any node in the tree. self.max_sum = float('-inf') def dfs(node: TreeNode) -> int: if not node: return 0 left_max = max(dfs(node.left), 0) right_max = max(dfs(node.right), 0) # Max path including the current node price_newpath = node.val + left_max + right_max # Update global max_sum self.max_sum = max(self.max_sum, price_newpath) # For recursion, return the max gain if continue the same path return node.val + max(left_max, right_max) dfs(self.root) return self.max_sum"},{"question":"from typing import List def count_pairs_with_sum(arr: List[int], target: int) -> int: Given an integer array arr of size n, determine the number of distinct pairs (i, j) (where i < j) that satisfy the equation arr[i] + arr[j] = target, with target being an integer value provided as input. Return the count of all such pairs. >>> count_pairs_with_sum([1, 2, 3, 4], 5) 2 >>> count_pairs_with_sum([1, 1, 1, 2], 3) 3 >>> count_pairs_with_sum([1, 5, 7, -1, 5], 6) 3 >>> count_pairs_with_sum([0, 0, 0], 0) 3 >>> count_pairs_with_sum([1, -2, 3, 0, 2], 1) 2 >>> count_pairs_with_sum([], 1) 0 >>> count_pairs_with_sum([3], 3) 0","solution":"def count_pairs_with_sum(arr, target): Function to count the number of distinct pairs (i, j) where i < j that satisfy the equation arr[i] + arr[j] = target n = len(arr) count = 0 seen = {} # Iterate over each element in the array for i in range(n): # Calculate the complement that we need to reach the target complement = target - arr[i] # Check if the complement exists in the seen dictionary # and also make sure we do not consider the same element twice if complement in seen: count += seen[complement] # Add the current element to the seen dictionary if arr[i] in seen: seen[arr[i]] += 1 else: seen[arr[i]] = 1 return count"},{"question":"def restoreString(s: str, indices: List[int]) -> str: Returns the correctly ordered string based on the provided indices. Parameters: s (str): A string of lowercase English letters. indices (List[int]): A list of integers representing the new positions of each character in the string. Returns: str: The correctly ordered string. >>> restoreString(\\"aiohn\\", [3, 1, 4, 2, 0]) == \\"nihao\\" >>> restoreString(\\"a\\", [0]) == \\"a\\" >>> restoreString(\\"abc\\", [1, 2, 0]) == \\"cab\\" >>> restoreString(\\"\\", []) == \\"\\" >>> restoreString(\\"abc\\", [0, 1, 2]) == \\"abc\\"","solution":"def restoreString(s, indices): Returns the correctly ordered string based on the provided indices. Parameters: s (str): A string of lowercase English letters. indices (List[int]): A list of integers representing the new positions of each character in the string. Returns: str: The correctly ordered string. n = len(s) restored = [''] * n for i in range(n): restored[indices[i]] = s[i] return ''.join(restored)"},{"question":"def minPathSum(grid: List[List[int]]) -> int: Finds the minimum path sum from the top-left corner to the bottom-right corner of the given grid where you can only move right or down. >>> minPathSum([[5]]) 5 >>> minPathSum([[1, 2], [1, 1]]) 3 >>> minPathSum([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 7 >>> minPathSum([ ... [1, 2, 5], ... [3, 2, 1], ... [4, 3, 1] ... ]) 7 >>> minPathSum([ ... [1, 2, 3], ... [4, 5, 6] ... ]) 12 >>> minPathSum([ ... [1, 3], ... [1, 5], ... [4, 2] ... ]) 8","solution":"def minPathSum(grid): Finds the minimum path sum from the top-left corner to the bottom-right corner of the given grid where you can only move right or down. :param grid: List[List[int]] 2D grid of integers :return: int minimum path sum m = len(grid) n = len(grid[0]) # Initialize the DP table dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] # Initialize the first column for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Initialize the first row for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Populate the DP table for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[m-1][n-1]"},{"question":"def reorder(nums: List[int]) -> List[int]: Reorders the array so that nums[i-1] < nums[i] > nums[i+1] for every i from 1 to n-2 if possible. Returns an empty array if it's not possible. >>> reorder([1, 3, 2, 4]) [1, 3, 2, 4] >>> reorder([1, 2, 3, 4, 5]) [1, 3, 2, 5, 4] >>> reorder([5, 6, 2, 1, 3]) [1, 3, 2, 6, 5] >>> reorder([1, 2]) [] >>> reorder([1, 2, 3]) [1, 3, 2] >>> reorder([3, 2, 1]) [1, 3, 2] >>> reorder([]) [] >>> reorder([2]) [] >>> reorder([7, 5]) []","solution":"def reorder(nums): Reorders the array so that nums[i-1] < nums[i] > nums[i+1] for every i from 1 to n-2 if possible. Returns an empty array if it's not possible. n = len(nums) if n < 3: return [] nums.sort() for i in range(1, n - 1, 2): nums[i], nums[i + 1] = nums[i + 1], nums[i] return nums"},{"question":"def trap(height: List[int]) -> int: Calculate the amount of water that can be trapped after raining. :param height: List[int] - the elevation map where the width of each bar is 1. :return: int - the maximum amount of water that can be trapped. >>> trap([]) == 0 >>> trap([0, 1, 2, 3, 4]) == 0 >>> trap([3, 2, 1, 0]) == 0 >>> trap([0,1,0,2,1,0,1,3,2,1,2,1]) == 6 >>> trap([4, 2, 0, 3, 2, 5]) == 9 >>> trap([1, 1, 1, 1, 1]) == 0 >>> trap([4, 1, 1, 1, 4]) == 9 >>> trap([5, 1, 5]) == 4 >>> trap([0, 5, 0]) == 0","solution":"def trap(height): Calculate the amount of water that can be trapped after raining. :param height: List[int] - the elevation map where the width of each bar is 1. :return: int - the maximum amount of water that can be trapped. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i-1], height[i]) right_max[n-1] = height[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], height[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"def max_possible_min_height(heights: List[int]) -> int: You are given a list of \`n\` integers representing the heights of \`n\` buildings aligned from left to right. The buildings form a skyline, where the \`i-th\` building has a height of \`height[i]\`. You are allowed to select a continuous subarray of these buildings and increase the height of every building within this subarray by 1. However, in order to avoid monotony, after increasing the heights of the selected buildings, there should be at least one building with a height that remains greater than or equal to the maximum height of the new altered skyline, ensuring our viewpoint is always the highest. Find the maximum possible height for the lowest building within the altered subarray that can be obtained. Return the maximum possible minimum height after the operation. >>> max_possible_min_height([5, 5, 5, 5]) 5 >>> max_possible_min_height([1, 2, 3, 4]) 2 >>> max_possible_min_height([4, 3, 2, 1]) 2 >>> max_possible_min_height([3, 1, 2, 4]) 2 >>> max_possible_min_height([7]) 7","solution":"def max_possible_min_height(heights): n = len(heights) max_height = max(heights) min_height = min(heights) # If all heights are already max height, return max height as no modification will make it higher. if min_height == max_height: return max_height # Otherwise, increment every building height by 1 and re-calculate the minimum max height. return min_height + 1"},{"question":"def can_place_flowers(flowerbed: str, n: int) -> bool: Determine if it is possible to plant \`n\` flowers in the \`flowerbed\` without violating the no-adjacent-flowers rule. >>> can_place_flowers('.....', 1) == True >>> can_place_flowers('.....', 2) == True >>> can_place_flowers('.....', 3) == True >>> can_place_flowers('..F..', 1) == True >>> can_place_flowers('.F.F.', 1) == False >>> can_place_flowers('FFF', 1) == False >>> can_place_flowers('F...F', 1) == True >>> can_place_flowers('F...F', 2) == False >>> can_place_flowers('F', 0) == True >>> can_place_flowers('.', 0) == True >>> can_place_flowers('.', 1) == True >>> can_place_flowers('F.F.F.F', 2) == False","solution":"def can_place_flowers(flowerbed, n): Determine if it is possible to plant \`n\` flowers in the \`flowerbed\` without violating the no-adjacent-flowers rule. flowerbed = list(flowerbed) length = len(flowerbed) # Traverse the flowerbed to try planting flowers for i in range(length): # Check if the current position is empty and the next and previous positions are empty or boundary if flowerbed[i] == '.' and (i == 0 or flowerbed[i - 1] == '.') and (i == length - 1 or flowerbed[i + 1] == '.'): # Plant a flower here flowerbed[i] = 'F' n -= 1 # If all required flowers are planted, return True if n <= 0: return True # If remaining flowers can't be planted, return False return n <= 0"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_one_child_nodes(root: TreeNode) -> List[int]: Given the root of a binary tree, return a list of the values of all nodes that have exactly one child. If there are no such nodes, return an empty list. A node is considered to have exactly one child if it has either a single left child or a single right child, but not both. Ensure the order of the returned values follows an in-order traversal of the original tree. >>> root = TreeNode(1, TreeNode(2), TreeNode(3, TreeNode(4))) >>> find_one_child_nodes(root) [3] >>> root = TreeNode(1, TreeNode(2), TreeNode(3)) >>> find_one_child_nodes(root) []","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_one_child_nodes(root): Returns the list of values of all nodes that have exactly one child in an in-order traversal order. result = [] def inorder_traversal(node): if node: inorder_traversal(node.left) if (node.left and not node.right) or (not node.left and node.right): result.append(node.val) inorder_traversal(node.right) inorder_traversal(root) return result"},{"question":"def min_maximum_sum_partition(arr, k): Partition an array into k contiguous subarrays such that the sum of the maximum values of these subarrays is minimized, and return the minimized sum. Parameters: arr (list): List of positive integers. k (int): Number of subarrays to partition. Returns: int: The minimized sum of the maximum values of the subarrays. >>> min_maximum_sum_partition([10, 2, 20, 5, 15], 3) 20 >>> min_maximum_sum_partition([1, 2, 3, 4, 5], 2) 9 >>> min_maximum_sum_partition([1, 2, 3, 4, 5], 3) 6 >>> min_maximum_sum_partition([1, 1, 1, 1, 1], 1) 5 >>> min_maximum_sum_partition([1, 1, 1, 1, 1], 5) 1 >>> min_maximum_sum_partition([7, 2, 5, 10, 8], 2) 18","solution":"def min_maximum_sum_partition(arr, k): Partition an array into k contiguous subarrays such that the sum of the maximum values of these subarrays is minimized, and return the minimized sum. Parameters: arr (list): List of positive integers. k (int): Number of subarrays to partition. Returns: int: The minimized sum of the maximum values of the subarrays. def is_valid_partition(max_sum): current_sum = 0 count = 1 for num in arr: if current_sum + num > max_sum: count += 1 current_sum = num if count > k: return False else: current_sum += num return True low, high = max(arr), sum(arr) while low < high: mid = (low + high) // 2 if is_valid_partition(mid): high = mid else: low = mid + 1 return low"},{"question":"def minTotalCandiesAfterOperations(nums: List[int]) -> int: Given an array of integers \`nums\` where each integer represents the number of candies in a jar, minimize the total number of candies in all jars combined after performing optimal operations of removing half (rounded down) of candies. >>> minTotalCandiesAfterOperations([0, 0, 0]) == 0 >>> minTotalCandiesAfterOperations([10]) == 1 >>> minTotalCandiesAfterOperations([10, 20, 30]) == 3 >>> minTotalCandiesAfterOperations([1, 0, 3, 0, 7, 0, 2]) == 4 >>> minTotalCandiesAfterOperations([100, 200, 300, 400, 500]) == 5","solution":"def minTotalCandiesAfterOperations(nums): Function to minimize the total number of candies in all jars after performing the optimal operations of removing half (rounded down) of candies. return sum(0 if x == 0 else 1 for x in nums)"},{"question":"def smallest_m(arr): Finds the smallest integer m such that any integer between 1 and m (inclusive) can be written as the sum of one or more distinct elements from arr. >>> smallest_m([1]) == 2 >>> smallest_m([2]) == 1 >>> smallest_m([1, 2, 3]) == 7 >>> smallest_m([1, 2, 3, 4]) == 11 >>> smallest_m([1, 3, 6, 10, 11, 15]) == 2 >>> smallest_m([1, 1, 1, 1]) == 5 >>> smallest_m([1, 2, 5, 10, 20, 40]) == 4 >>> smallest_m([1, 2, 2, 2, 2]) == 10 >>> smallest_m([]) == 1","solution":"def smallest_m(arr): Finds the smallest integer m such that any integer between 1 and m (inclusive) can be written as the sum of one or more distinct elements from arr. arr.sort() m = 1 # Initialize m to 1, the smallest number we want to cover for num in arr: if num > m: break m += num return m"},{"question":"def longest_subarray(nums: List[int]) -> int: Given an unsorted array of integers \`nums\`, find the length of the longest subarray where the absolute difference between any two elements is no greater than \`1\`. Return the length of this subarray. >>> longest_subarray([1]) 1 >>> longest_subarray([1, 1, 1, 1]) 4 >>> longest_subarray([1, 2, 2, 3, 1, 2]) 5 >>> longest_subarray([2, 2, 2, 2]) 4 >>> longest_subarray([10, 12, 14, 16]) 1 >>> longest_subarray([]) 0 >>> longest_subarray([-1, -2, -2, -3]) 3 >>> longest_subarray([-1, -1, -1]) 3 >>> longest_subarray([1, 3, 2, 2, 5, 2, 3, 7]) 5","solution":"def longest_subarray(nums): from collections import defaultdict if not nums: return 0 frequency_map = defaultdict(int) for num in nums: frequency_map[num] += 1 max_length = 0 for num in frequency_map: current_length = frequency_map[num] if (num + 1) in frequency_map: current_length += frequency_map[num + 1] max_length = max(max_length, current_length) return max_length"},{"question":"def trap(height: List[int]) -> int: Calculate the total amount of trapped water given a list of heights. >>> trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap([]) 0 >>> trap([1, 1, 1, 1, 1]) 0 >>> trap([1, 2, 3, 4, 5]) 0 >>> trap([4, 2, 0, 3, 2, 5]) 9 >>> trap([3, 3, 3, 3, 3]) 0 >>> trap([5, 2, 1, 2, 1, 5]) 14","solution":"def trap(height): Calculate the total amount of trapped water given a list of heights. Args: height (List[int]): List of non-negative integers representing the heights of bars. Returns: int: Total amount of trapped water. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - height[i] return trapped_water"},{"question":"def length_of_lis(nums: List[int]) -> int: Finds the length of the longest strictly increasing subsequence among a list of integers. >>> length_of_lis([10, 9, 2, 5, 3, 7, 101, 18]) == 4 >>> length_of_lis([1, 2, 3, 4, 5]) == 5 >>> length_of_lis([5, 4, 3, 2, 1]) == 1 >>> length_of_lis([10, 22, 9, 33, 21, 50, 41, 60, 80]) == 6 >>> length_of_lis([2, 2, 2, 2, 2]) == 1 >>> length_of_lis([-1, 3, 4, 5, 2, 2, 2, 2, 2]) == 4","solution":"def length_of_lis(nums): Finds the length of the longest strictly increasing subsequence. Parameters: nums (List[int]): The input list of integers. Returns: int: The length of the longest strictly increasing subsequence. if not nums: return 0 dp = [1] * len(nums) for i in range(1, len(nums)): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def evaluate_expression(s: str) -> int: Evaluate an expression containing numbers, operators +, -, *, and parentheses. >>> evaluate_expression(\\"3\\") 3 >>> evaluate_expression(\\"2+3\\") 5 >>> evaluate_expression(\\"5-2\\") 3 >>> evaluate_expression(\\"2*3\\") 6 >>> evaluate_expression(\\"2+3*4\\") 14 >>> evaluate_expression(\\"2*3+4\\") 10 >>> evaluate_expression(\\"(2+3)*4\\") 20 >>> evaluate_expression(\\"2*(3+4)\\") 14 >>> evaluate_expression(\\"2+3*(2+3)\\") 17 >>> evaluate_expression(\\"(2+3)*(2+3)\\") 25 >>> evaluate_expression(\\"((2+3)*4-3)*2\\") 34","solution":"def evaluate_expression(s): def precedence(op): if op == '+' or op == '-': return 1 if op == '*': return 2 return 0 def apply_op(operands, operators): right = operands.pop() left = operands.pop() operator = operators.pop() if operator == '+': operands.append(left + right) elif operator == '-': operands.append(left - right) elif operator == '*': operands.append(left * right) def evaluate(tokens): operands = [] operators = [] i = 0 while i < len(tokens): if tokens[i] == '(': operators.append(tokens[i]) elif tokens[i].isdigit(): val = 0 while i < len(tokens) and tokens[i].isdigit(): val = val * 10 + int(tokens[i]) i += 1 operands.append(val) i -= 1 elif tokens[i] == ')': while operators and operators[-1] != '(': apply_op(operands, operators) operators.pop() else: while (operators and operators[-1] != '(' and precedence(operators[-1]) >= precedence(tokens[i])): apply_op(operands, operators) operators.append(tokens[i]) i += 1 while operators: apply_op(operands, operators) return operands[-1] return evaluate(s)"},{"question":"from typing import Optional class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def maximum_width_of_binary_tree(root: Optional[TreeNode]) -> int: Given a binary tree, return the maximum width of the tree. The maximum width of a tree is the maximum width among all levels. The width of one level is defined as the length between the end-nodes (the leftmost and rightmost non-null nodes), inclusive. >>> root = TreeNode(1) >>> root.left = TreeNode(3) >>> root.right = TreeNode(2) >>> root.left.left = TreeNode(5) >>> root.left.right = TreeNode(3) >>> root.right.right = TreeNode(9) >>> maximum_width_of_binary_tree(root) 4 >>> root = None >>> maximum_width_of_binary_tree(root) 0 >>> root = TreeNode(1) >>> maximum_width_of_binary_tree(root) 1 >>> root = TreeNode(1) >>> root.right = TreeNode(2) >>> root.right.right = TreeNode(3) >>> maximum_width_of_binary_tree(root) 1 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(3) >>> maximum_width_of_binary_tree(root) 1","solution":"from collections import deque class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def maximum_width_of_binary_tree(root): if not root: return 0 max_width = 0 queue = deque([(root, 0)]) # (node, current_position) while queue: level_length = len(queue) _, first_index = queue[0] # first node's position at current level _, last_index = queue[-1] # last node's position at current level # Calculate the current level width and update max_width max_width = max(max_width, last_index - first_index + 1) for _ in range(level_length): node, index = queue.popleft() if node.left: queue.append((node.left, 2 * index)) if node.right: queue.append((node.right, 2 * index + 1)) return max_width"},{"question":"from typing import List def min_days_to_complete_projects(projects: List[int], workers: int) -> int: Compute the minimum number of days required to complete all projects when evenly distributed among the workers. >>> min_days_to_complete_projects([2, 3, 5, 7], 2) 10 >>> min_days_to_complete_projects([1, 2, 3, 4, 5], 5) 5 >>> min_days_to_complete_projects([2, 2, 2], 5) 2 >>> min_days_to_complete_projects([4, 4, 4, 4, 4], 2) 12 >>> min_days_to_complete_projects([1]*1000, 1) 1000 >>> min_days_to_complete_projects([1]*1000, 10) 100 >>> min_days_to_complete_projects([1]*1000, 1000) 1","solution":"from typing import List def min_days_to_complete_projects(projects: List[int], workers: int) -> int: def feasible(days: int) -> bool: required_workers = 1 current_time = 0 for project in projects: if current_time + project <= days: current_time += project else: required_workers += 1 current_time = project if required_workers > workers: return False return True low, high = max(projects), sum(projects) while low < high: mid = (low + high) // 2 if feasible(mid): high = mid else: low = mid + 1 return low"},{"question":"def longest_palindromic_substring(s: str) -> str: Given a string \`s\`, return the longest palindromic substring in \`s\`. Examples: >>> longest_palindromic_substring(\\"babad\\") in {\\"bab\\", \\"aba\\"} True >>> longest_palindromic_substring(\\"cbbd\\") \\"bb\\" >>> longest_palindromic_substring(\\"a\\") \\"a\\" >>> longest_palindromic_substring(\\"ac\\") in {\\"a\\", \\"c\\"} True >>> longest_palindromic_substring(\\"forgeeksskeegfor\\") \\"geeksskeeg\\" >>> longest_palindromic_substring(\\"\\") \\"\\" >>> longest_palindromic_substring(\\"z\\") \\"z\\" >>> longest_palindromic_substring(\\"abcdefg\\") \\"a\\" # Output could be any single character >>> longest_palindromic_substring(\\"aaaa\\") \\"aaaa\\"","solution":"def longest_palindromic_substring(s: str) -> str: Returns the longest palindromic substring in s. def expand_around_center(s: str, left: int, right: int) -> str: while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return s[left + 1:right] if not s or len(s) == 1: return s longest = \\"\\" for i in range(len(s)): # Odd length palindrome temp = expand_around_center(s, i, i) if len(temp) > len(longest): longest = temp # Even length palindrome temp = expand_around_center(s, i, i + 1) if len(temp) > len(longest): longest = temp return longest"},{"question":"def findBuildingsWithOceanView(heights: List[int]) -> List[int]: Returns the indices of buildings that have an ocean view oriented to the right. >>> findBuildingsWithOceanView([4, 2, 3, 1]) [0, 2, 3] >>> findBuildingsWithOceanView([1, 3, 2, 3, 4]) [4] >>> findBuildingsWithOceanView([4, 3, 2, 1]) [0, 1, 2, 3] >>> findBuildingsWithOceanView([1, 2, 3, 4]) [3] >>> findBuildingsWithOceanView([]) [] >>> findBuildingsWithOceanView([5]) [0] >>> findBuildingsWithOceanView([4, 4, 4, 4]) [3] >>> findBuildingsWithOceanView([1, 1, 1, 2]) [3] >>> findBuildingsWithOceanView([2, 1, 3, 1, 2]) [2, 4]","solution":"def findBuildingsWithOceanView(heights): Returns the indices of buildings that have an ocean view. :param heights: List[int] - List of building heights :return: List[int] - List of indices of buildings with ocean views n = len(heights) if n == 0: return [] max_height_so_far = 0 result = [] for i in range(n-1, -1, -1): if heights[i] > max_height_so_far: result.append(i) max_height_so_far = heights[i] result.reverse() return result"},{"question":"def min_edges_to_connect_network(n: int, edges: List[List[int]]) -> int: Returns the minimum number of edges required to make the entire network connected. If it's impossible, returns -1. n: int - Number of computers edges: List[List[int]] - Direct connections between computers >>> min_edges_to_connect_network(4, [[0, 1], [0, 2], [1, 2]]) == 1 >>> min_edges_to_connect_network(6, [[0, 1], [0, 2], [1, 2], [3, 4], [4, 5]]) == 1 >>> min_edges_to_connect_network(3, [[0, 1], [1, 2], [2, 0]]) == 0 >>> min_edges_to_connect_network(5, [[0, 1], [0, 2]]) == -1 >>> min_edges_to_connect_network(1, []) == 0","solution":"def min_edges_to_connect_network(n, edges): Returns the minimum number of edges required to make the entire network connected. If it's impossible, returns -1. n: int - Number of computers edges: List[List[int]] - Direct connections between computers if len(edges) < n - 1: return -1 # Not enough edges to potentially connect all nodes from collections import defaultdict # Create an adjacency list representation of the graph graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = set() def dfs(node): stack = [node] while stack: current = stack.pop() for neighbor in graph[current]: if neighbor not in visited: visited.add(neighbor) stack.append(neighbor) connected_components = 0 for node in range(n): if node not in visited: visited.add(node) connected_components += 1 dfs(node) # To connect c components, we need at least (c - 1) edges return connected_components - 1"},{"question":"def min_path_cost(grid: List[List[int]]) -> int: Returns the minimum cost to travel from the top-left to bottom-right of the grid. If there is no valid path, returns -1. :param grid: List of List of integers representing the cost grid :return: Minimum cost or -1 if no valid path >>> min_path_cost([[1, 2, 3],[4, 5, 6],[7, 8, 9]]) 21 >>> min_path_cost([[1, -1, 3],[4, 5, -1],[7, 8, 9]]) 27 >>> min_path_cost([[1, -1, 3],[-1, -1, -1],[7, 8, 9]]) -1 >>> min_path_cost([[5]]) 5 >>> min_path_cost([]) -1 >>> min_path_cost([[1, 2, 3]]) 6 >>> min_path_cost([[1],[2],[3]]) 6","solution":"def min_path_cost(grid): Returns the minimum cost to travel from the top-left to bottom-right of the grid. If there is no valid path, returns -1. :param grid: List of List of integers representing the cost grid :return: Minimum cost or -1 if no valid path if not grid or not grid[0]: return -1 n = len(grid) m = len(grid[0]) # Initialize dp array dp = [[float('inf')] * m for _ in range(n)] # Starting point if grid[0][0] == -1: return -1 dp[0][0] = grid[0][0] # Fill dp array for i in range(n): for j in range(m): if grid[i][j] == -1: continue if i > 0 and grid[i-1][j] != -1: dp[i][j] = min(dp[i][j], dp[i-1][j] + grid[i][j]) if j > 0 and grid[i][j-1] != -1: dp[i][j] = min(dp[i][j], dp[i][j-1] + grid[i][j]) return dp[-1][-1] if dp[-1][-1] != float('inf') else -1"},{"question":"def findPairs(nums, k): Write a function findPairs that accepts an array nums and an integer k, and returns the number of unique pairs (i, j) such that nums[i] + nums[j] = k and i < j. The array may contain duplicate elements, and each element can only be used in one pair. >>> findPairs([1, 2, 3, 4], 5) == 2 >>> findPairs([1], 2) == 0 >>> findPairs([1, 1, 1, 1], 5) == 0 >>> findPairs([1, 2, 3, 4, 3], 6) == 2 >>> findPairs([-1, -2, -3, -4, 1], -5) == 2 >>> findPairs([1, -1, 2, -2, 3, -3], 0) == 3","solution":"def findPairs(nums, k): Returns the number of unique pairs (i, j) such that nums[i] + nums[j] = k and i < j. Each element can only be used in one pair. seen, used = set(), set() count = 0 for num in nums: diff = k - num if diff in seen and diff not in used and num not in used: count += 1 used.add(num) used.add(diff) seen.add(num) return count"},{"question":"from typing import List def remove_kth_occurrence_of_largest(arr: List[int], k: int) -> List[int]: Removes the k-th occurrence of the largest element in the array. If the k-th occurrence does not exist, returns the array unchanged. Parameters: arr (list): a list of integers k (int): an integer indicating which occurrence of the largest element to remove Returns: list: the modified array >>> remove_kth_occurrence_of_largest([3, 1, 4, 4, 5, 5, 5, 2], 2) [3, 1, 4, 4, 5, 5, 2] >>> remove_kth_occurrence_of_largest([1, 1, 1, 1], 2) [1, 1, 1] def test_remove_kth_occurrence_of_largest(): assert remove_kth_occurrence_of_largest([3, 1, 4, 4, 5, 5, 5, 2], 2) == [3, 1, 4, 4, 5, 5, 2] assert remove_kth_occurrence_of_largest([3, 1, 4, 4, 5, 5, 5, 2], 3) == [3, 1, 4, 4, 5, 5, 2] assert remove_kth_occurrence_of_largest([3, 1, 4, 4, 5, 5, 5, 2], 4) == [3, 1, 4, 4, 5, 5, 5, 2] assert remove_kth_occurrence_of_largest([3, 1, 4, 4, 5, 5, 5, 2], 1) == [3, 1, 4, 4, 5, 5, 2] assert remove_kth_occurrence_of_largest([1, 1, 1, 1], 2) == [1, 1, 1] assert remove_kth_occurrence_of_largest([1, 1, 1, 1], 5) == [1, 1, 1, 1] assert remove_kth_occurrence_of_largest([], 1) == [] assert remove_kth_occurrence_of_largest([1], 1) == [] assert remove_kth_occurrence_of_largest([1], 2) == [1] assert remove_kth_occurrence_of_largest([1, 2, 3, 4, 4], 1) == [1, 2, 3, 4] assert remove_kth_occurrence_of_largest([2, 4, 2, 4], 2) == [2, 4, 2] if __name__ == \\"__main__\\": test_remove_kth_occurrence_of_largest() print(\\"All tests passed!\\")","solution":"def remove_kth_occurrence_of_largest(arr, k): Removes the k-th occurrence of the largest element in the array. If the k-th occurrence does not exist, returns the array unchanged. Parameters: arr(list): a list of integers k(int): an integer indicating which occurrence of the largest element to remove Returns: list: the modified array if not arr or k <= 0: return arr largest = max(arr) occurrence_count = 0 for i, value in enumerate(arr): if value == largest: occurrence_count += 1 if occurrence_count == k: return arr[:i] + arr[i+1:] # If k-th occurrence does not exist return arr"},{"question":"def minimum_swaps_to_see_board(heights: List[int]) -> int: Returns the minimum number of swaps needed to ensure that every student can see the board. >>> minimum_swaps_to_see_board([1, 2, 3, 4]) == 0 >>> minimum_swaps_to_see_board([2, 1, 3, 4]) == 1 >>> minimum_swaps_to_see_board([4, 3, 2, 1]) == 2 >>> minimum_swaps_to_see_board([]) == 0 >>> minimum_swaps_to_see_board([5, 5, 5, 5]) == 0 >>> minimum_swaps_to_see_board([3, 1, 2, 4]) == 2","solution":"def minimum_swaps_to_see_board(heights): Returns the minimum number of swaps needed to ensure that every student can see the board. n = len(heights) indexed_heights = list(enumerate(heights)) indexed_heights.sort(key=lambda x: x[1]) visited = [False] * n swaps = 0 for i in range(n): if visited[i] or indexed_heights[i][0] == i: continue cycle_size = 0 j = i while not visited[j]: visited[j] = True j = indexed_heights[j][0] cycle_size += 1 if cycle_size > 0: swaps += (cycle_size - 1) return swaps"},{"question":"def longest_sequence(s: str, dict: List[str]) -> int: You are given a string \`s\` and an array of strings \`dict\` where each string in \`dict\` is of the same length. All characters in \`dict\` and \`s\` are lowercase English letters. Your task is to replace characters in \`s\` by forming the longest sequence that is identical to any string in \`dict\`. You can only replace characters in \`s\` with a character at the same position in one of the strings from \`dict\`. Return the length of the longest sequence you can form from \`s\` by using the characters from one of the strings in \`dict\`. If no such sequence can be formed, return \`0\`. :param s: Original string :param dict: List of dictionary strings :return: Length of the longest sequence >>> longest_sequence(\\"abcde\\", [\\"abcdf\\", \\"bbcde\\", \\"accde\\"]) 4 >>> longest_sequence(\\"xyz\\", [\\"abc\\", \\"def\\", \\"ghi\\"]) 0 >>> longest_sequence(\\"axcye\\", [\\"axyz\\", \\"axce\\", \\"awxyz\\", \\"axyyz\\"]) 3 >>> longest_sequence(\\"matching\\", [\\"matching\\", \\"notmatch\\", \\"matching\\"]) 8 >>> longest_sequence(\\"\\", [\\"abc\\", \\"def\\"]) 0 >>> longest_sequence(\\"abc\\", []) 0 >>> longest_sequence(\\"abcdef\\", [\\"abcxgf\\", \\"abcyhf\\", \\"abccif\\"]) 4","solution":"def longest_sequence(s, dict): Returns the length of the longest sequence that can be formed from s using characters from the given dictionary. :param s: Original string :param dict: List of dictionary strings :return: Length of the longest sequence if not s or not dict: return 0 max_length = 0 dict_len = len(dict[0]) # Iterate through each string in the dict for word in dict: current_length = 0 for i in range(min(len(s), dict_len)): if s[i] == word[i]: current_length += 1 max_length = max(max_length, current_length) return max_length"},{"question":"def trap_rainwater(heights: List[int]) -> int: Calculates the total amount of rainwater that can be trapped. :param heights: List[int] - list of non-negative integers representing the heights of blocks :return: int - total amount of trapped rainwater >>> trap_rainwater([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trap_rainwater([1,1,1,1,1]) 0 >>> trap_rainwater([]) 0 >>> trap_rainwater([1]) 0 >>> trap_rainwater([2,1,2]) 1 >>> trap_rainwater([2,0,2]) 2 >>> trap_rainwater([1,2,3,4,5]) 0 >>> trap_rainwater([5,4,3,2,1]) 0 >>> trap_rainwater([1,2,2,2,1]) 0","solution":"def trap_rainwater(heights): Calculates the total amount of rainwater that can be trapped. :param heights: List[int] - list of non-negative integers representing the heights of blocks :return: int - total amount of trapped rainwater if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n # Fill left_max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) # Fill right_max array right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) # Calculate trapped water trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - heights[i] return trapped_water"},{"question":"def longest_valid_parentheses(s: str) -> int: Returns the length of the longest valid (well-formed) parentheses substring in the given string. :param s: string containing only '(' and ')' :return: length of the longest valid parentheses substring >>> longest_valid_parentheses(\\"(()\\") 2 >>> longest_valid_parentheses(\\")()())\\") 4 >>> longest_valid_parentheses(\\"\\") 0 >>> longest_valid_parentheses(\\"((((((\\") 0 >>> longest_valid_parentheses(\\")))))\\") 0 >>> longest_valid_parentheses(\\"((()))\\") 6 >>> longest_valid_parentheses(\\"()()()(()())\\") 12 >>> longest_valid_parentheses(\\"(()))())(\\") 4 >>> longest_valid_parentheses(\\"()(())\\") 6 >>> longest_valid_parentheses(\\"()()()()\\") 8 >>> longest_valid_parentheses(\\")(\\") 0 >>> longest_valid_parentheses(\\"()()(\\") 4","solution":"def longest_valid_parentheses(s): Returns the length of the longest valid (well-formed) parentheses substring in the given string. :param s: string containing only '(' and ')' :return: length of the longest valid parentheses substring left = right = max_length = 0 # Left to right traversal for char in s: if char == '(': left += 1 else: right += 1 if left == right: max_length = max(max_length, 2 * right) elif right > left: left = right = 0 left = right = 0 # Right to left traversal for char in reversed(s): if char == '(': left += 1 else: right += 1 if left == right: max_length = max(max_length, 2 * left) elif left > right: left = right = 0 return max_length"},{"question":"def findKth(nums1, nums2, k): Find the kth smallest element in the union of two sorted arrays nums1 and nums2. The arrays nums1 and nums2 are of size m and n respectively. The time complexity of the solution should be O(log(min(m, n))). >>> findKth([1, 3, 5], [2, 4, 6], 1) 1 >>> findKth([1, 3, 5], [2, 4, 6], 2) 2 >>> findKth([1, 3, 5], [2, 4, 6], 3) 3 >>> findKth([1, 3, 5], [2, 4, 6], 4) 4 >>> findKth([1, 3, 5], [2, 4, 6], 5) 5 >>> findKth([1, 3, 5], [2, 4, 6], 6) 6 >>> findKth([], [1], 1) 1 >>> findKth([2], [], 1) 2 >>> findKth([1, 3], [2, 4, 5, 6], 4) 4 >>> findKth([1, 2, 21], [3, 4, 5, 6], 5) 5 >>> findKth([1, 2], [1, 2, 3, 4], 4) 2","solution":"def findKth(nums1, nums2, k): def kthSmallest(arr1, arr2, start1, start2, k): if start1 >= len(arr1): return arr2[start2 + k - 1] if start2 >= len(arr2): return arr1[start1 + k - 1] if k == 1: return min(arr1[start1], arr2[start2]) midVal1 = float('inf') midVal2 = float('inf') if start1 + k // 2 - 1 < len(arr1): midVal1 = arr1[start1 + k // 2 - 1] if start2 + k // 2 - 1 < len(arr2): midVal2 = arr2[start2 + k // 2 - 1] if midVal1 < midVal2: return kthSmallest(arr1, arr2, start1 + k // 2, start2, k - k // 2) else: return kthSmallest(arr1, arr2, start1, start2 + k // 2, k - k // 2) return kthSmallest(nums1, nums2, 0, 0, k)"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"abcdefg\\") 7 >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"aaaaaaa\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"\\") 0 >>> length_of_longest_substring(\\"z\\") 1 >>> length_of_longest_substring(\\"abba\\") 2","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. char_index_map = {} longest = 0 start = 0 for index, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = index longest = max(longest, index - start + 1) return longest"},{"question":"def largest_rectangle_area(heights: List[int]) -> int: Calculate the area of the largest rectangle that can be formed using the heights of the cylinders. :param heights: List[int] - A list of positive integers representing the heights of the cylinders. :return: int - The area of the largest rectangle. >>> largest_rectangle_area([2,1,5,6,2,3]) 10 >>> largest_rectangle_area([]) 0 >>> largest_rectangle_area([4]) 4 >>> largest_rectangle_area([3, 3, 3, 3]) 12 >>> largest_rectangle_area([1, 2, 3, 4, 5]) 9 >>> largest_rectangle_area([5, 4, 3, 2, 1]) 9 >>> largest_rectangle_area([2, 4, 2, 1]) 6 >>> largest_rectangle_area([2, 1, 2]) 3 >>> largest_rectangle_area([1, 2, 3, 4, 5, 3, 3, 2]) 15","solution":"def largest_rectangle_area(heights): Calculate the area of the largest rectangle that can be formed using the heights of the cylinders. :param heights: List[int] - A list of positive integers representing the heights of the cylinders. :return: int - The area of the largest rectangle. # Initializing stack and result variable stack = [] max_area = 0 # Iterate over all heights for i, h in enumerate(heights): start = i while stack and stack[-1][1] > h: index, height = stack.pop() max_area = max(max_area, height * (i - index)) start = index stack.append((start, h)) # Process the remaining elements in the stack for i, h in stack: max_area = max(max_area, h * (len(heights) - i)) return max_area"},{"question":"def can_sum(nums, target): Determines if any combination of numbers from the list nums can sum to the target. Args: nums (list of int): A list of positive integers. target (int): The target sum. Returns: bool: True if a combination exists, False otherwise. >>> can_sum([2, 3, 5], 8) True >>> can_sum([1, 2, 3], 5) True >>> can_sum([4, 6, 7], 13) True >>> can_sum([7, 14], 21) True >>> can_sum([2, 4], 7) False >>> can_sum([5, 6, 7], 1) False >>> can_sum([9, 10], 8) False >>> can_sum([1, 2, 5], 100) True >>> can_sum([1], 1) True >>> can_sum([1], 2) True >>> can_sum([3], 2) False >>> can_sum([5, 5, 5], 10) True >>> can_sum([5, 5, 5], 15) True >>> can_sum([5, 5, 5], 7) False","solution":"def can_sum(nums, target): Determines if any combination of numbers from the list nums can sum to the target. Args: nums (list of int): A list of positive integers. target (int): The target sum. Returns: bool: True if a combination exists, False otherwise. dp = [False] * (target + 1) dp[0] = True # Base case: it's always possible to form a target sum of 0 for i in range(1, target + 1): for num in nums: if i >= num and dp[i - num]: dp[i] = True break return dp[target]"},{"question":"def kth_largest_island(matrix: List[List[int]], k: int) -> int: Find the kth largest island's size in the given m x n binary matrix. Args: matrix: List of List of integers representing the binary matrix. k: Integer representing which largest island size to find. Returns: The size of the kth largest island, or -1 if there are fewer than k islands. Test cases: >>> matrix = [ ... [1, 0, 1, 0], ... [1, 1, 0, 0], ... [0, 0, 1, 1], ... [0, 1, 1, 0] ... ] >>> kth_largest_island(matrix, 1) 4 >>> kth_largest_island(matrix, 2) 3 >>> kth_largest_island(matrix, 3) 1 >>> matrix = [ ... [0, 0, 0, 0], ... [0, 0, 0, 0], ... [0, 0, 0, 0], ... [0, 0, 0, 0] ... ] >>> kth_largest_island(matrix, 1) -1 >>> matrix = [ ... [1, 0, 1, 0], ... [1, 1, 0, 0], ... [0, 0, 1, 1], ... [0, 1, 1, 0] ... ] >>> kth_largest_island(matrix, 5) -1","solution":"def kth_largest_island(matrix, k): def dfs(i, j): if i < 0 or i >= len(matrix) or j < 0 or j >= len(matrix[0]) or matrix[i][j] == 0: return 0 matrix[i][j] = 0 # mark as visited size = 1 size += dfs(i+1, j) size += dfs(i-1, j) size += dfs(i, j+1) size += dfs(i, j-1) return size if not matrix or not matrix[0]: return -1 islands_sizes = [] for i in range(len(matrix)): for j in range(len(matrix[0])): if matrix[i][j] == 1: island_size = dfs(i, j) islands_sizes.append(island_size) if len(islands_sizes) < k: return -1 islands_sizes.sort(reverse=True) return islands_sizes[k-1]"},{"question":"def can_move_to_end(heights: List[int]) -> bool: Determines if the last person in the queue can move to the end. Parameters: heights (list of int): the heights of people in the queue. Returns: bool: True if the last person can move to the end, otherwise False. >>> can_move_to_end([4, 2, 3, 5]) True >>> can_move_to_end([4, 2, 5, 3]) False >>> can_move_to_end([3, 3, 3, 3]) False >>> can_move_to_end([1, 2, 3, 4]) True >>> can_move_to_end([4, 3, 2, 1]) False >>> can_move_to_end([]) False >>> can_move_to_end([1]) True >>> can_move_to_end([1, 2]) True >>> can_move_to_end([2, 1]) False","solution":"def can_move_to_end(heights): Determines if the last person in the queue can move to the end. Parameters: heights (list of int): the heights of people in the queue. Returns: bool: True if the last person can move to the end, otherwise False. if not heights: return False last_height = heights[-1] for height in heights[:-1]: if height >= last_height: return False return True"},{"question":"def count_unique_pairs(arr: List[int], k: int) -> int: Returns the number of unique pairs (i, j) where 0 <= i < j < len(arr) and arr[i] + arr[j] == k. >>> count_unique_pairs([], 5) == 0 >>> count_unique_pairs([1], 5) == 0 >>> count_unique_pairs([1, 4], 5) == 1 >>> count_unique_pairs([1, 1], 2) == 1 >>> count_unique_pairs([1, 2, 3, 4, 5], 6) == 2 >>> count_unique_pairs([1, 2, 3, 3, 4], 6) == 2 >>> count_unique_pairs([1, 2, 3], 7) == 0 >>> count_unique_pairs([1, 1, 1, 4, 4, 4], 5) == 1 >>> count_unique_pairs([-1, -2, 3, 5, -3], 2) == 2 >>> count_unique_pairs([-1, -2, -3, -4, -5], -5) == 2 >>> count_unique_pairs([1, -1, 2, -2, 3], 0) == 2","solution":"def count_unique_pairs(arr, k): Returns the number of unique pairs (i, j) where 0 <= i < j < len(arr) and arr[i] + arr[j] == k. seen = set() unique_pairs = set() for i in range(len(arr)): complement = k - arr[i] if complement in seen: pair = tuple(sorted((arr[i], complement))) unique_pairs.add(pair) seen.add(arr[i]) return len(unique_pairs)"},{"question":"def maxSumSubmatrix(mat: List[List[int]], k: int) -> int: Given an \`m x n\` matrix \`mat\` and an integer \`k\`, return the maximum sum of any \`k x k\` submatrix in \`mat\`. Example: >>> mat = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> k = 2 >>> maxSumSubmatrix(mat, k) 28 pass # implement the function here def test_max_sum_submatrix_small_matrix(): mat = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] k = 2 assert maxSumSubmatrix(mat, k) == 28 def test_max_sum_submatrix_single_element(): mat = [ [5] ] k = 1 assert maxSumSubmatrix(mat, k) == 5 def test_max_sum_submatrix_full_matrix(): mat = [ [1, 2], [3, 4] ] k = 2 assert maxSumSubmatrix(mat, k) == 10 def test_max_sum_submatrix_another_case(): mat = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] k = 3 assert maxSumSubmatrix(mat, k) == 99 # 6 + 7 + 8 + 10 + 11 + 12 + 14 + 15 + 16 def test_max_sum_submatrix_empty_matrix(): mat = [] k = 2 assert maxSumSubmatrix(mat, k) == 0","solution":"def maxSumSubmatrix(mat, k): Returns the maximum sum of any k x k submatrix in mat. if not mat or not mat[0] or k == 0: return 0 m, n = len(mat), len(mat[0]) max_sum = float('-inf') for i in range(m - k + 1): for j in range(n - k + 1): current_sum = 0 for p in range(k): for q in range(k): current_sum += mat[i + p][j + q] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def max_area(height): Calculates the maximum amount of water that a container can store, formed by two buildings represented by heights in the input list. :param height: List[int] - an array of integers representing building heights :return: int - maximum amount of water the container can store # Implement your code here # Test cases def test_example_cases(): assert max_area([1, 8, 6, 2, 5, 4, 8, 3, 7]) == 49 assert max_area([1, 1]) == 1 def test_additional_cases(): assert max_area([4, 3, 2, 1, 4]) == 16 assert max_area([1, 2, 1]) == 2 def test_edge_cases(): assert max_area([1]) == 0 assert max_area([1, 2]) == 1 assert max_area([1]) == 0 def test_uniform_height(): assert max_area([3, 3, 3, 3, 3]) == 12","solution":"def max_area(height): Calculates the maximum amount of water that a container can store, formed by two buildings represented by heights in the input list. :param height: List[int] - an array of integers representing building heights :return: int - maximum amount of water the container can store left = 0 right = len(height) - 1 max_water = 0 while left < right: # Calculate the current amount of water current_water = min(height[left], height[right]) * (right - left) max_water = max(max_water, current_water) # Move the pointer pointing to the shorter building if height[left] < height[right]: left += 1 else: right -= 1 return max_water"},{"question":"def find_dominant_index(nums: List[int]) -> int: Finds the index of the dominant number in the given array of integers. Returns -1 if there is no dominant number. >>> find_dominant_index([5]) == 0 >>> find_dominant_index([3, 6, 1, 0]) == 1 >>> find_dominant_index([-1, -2, -3, -4]) == 0 >>> find_dominant_index([1, 2, 2, 4, 4, 3]) == -1 >>> find_dominant_index([2, 3, 3]) == -1","solution":"def find_dominant_index(nums): Finds the index of the dominant number in the given array of integers. Returns -1 if there is no dominant number. if len(nums) == 0: return -1 max_num = max(nums) max_index = nums.index(max_num) # Check if it's strictly greater than every other number. for i, num in enumerate(nums): if i != max_index and max_num <= num: return -1 return max_index"},{"question":"def kth_most_populous_city(nums: List[int], k: int) -> int: Returns the kth most populous city population from the given list of populations. :param nums: List[int] - List of populations of various cities. :param k: int - The rank of the most populous city to find. :return: int - Population of the kth most populous city. >>> kth_most_populous_city([3, 1, 2, 4, 2], 2) == 3 >>> kth_most_populous_city([3, 1, 2, 4, 2], 1) == 4 >>> kth_most_populous_city([3, 1, 2, 4, 2], 3) == 2 >>> kth_most_populous_city([3, 1, 2, 4, 2], 4) == 2 >>> kth_most_populous_city([3, 1, 2, 4, 2], 5) == 1 >>> kth_most_populous_city([10], 1) == 10 >>> kth_most_populous_city([5, 5, 5, 5, 5], 3) == 5 >>> kth_most_populous_city([8, 6, 7, 5, 3, 10], 6) == 3 >>> kth_most_populous_city([1, 3, 3, 2, 2, 4], 4) == 2 >>> kth_most_populous_city([10, 20, 20, 30], 2) == 20","solution":"def kth_most_populous_city(nums, k): Returns the kth most populous city population from the given list of populations. :param nums: List[int] - List of populations of various cities. :param k: int - The rank of the most populous city to find. :return: int - Population of the kth most populous city. sorted_populations = sorted(nums, reverse=True) return sorted_populations[k-1]"},{"question":"def max_jobs(difficulty: List[int], worker: List[int]) -> int: Returns the maximum number of jobs that can be completed given the difficulty of jobs and skill level of workers. >>> max_jobs([2, 4, 6], [3, 5, 4]) == 2 >>> max_jobs([10, 15, 20], [1, 1, 1]) == 0 >>> max_jobs([1, 2, 3], [3, 3, 3]) == 3 >>> max_jobs([1, 2], [1, 2, 2, 3]) == 2 >>> max_jobs([1, 2, 3, 4], [2, 3]) == 2 # Your code here","solution":"def max_jobs(difficulty, worker): Returns the maximum number of jobs that can be completed given the difficulty of jobs and skill level of workers. :param difficulty: List of integers representing the difficulty of each job. :param worker: List of integers representing the skill level of each worker. :return: Integer representing the maximum number of jobs that can be completed. # Sort job difficulties and worker skills difficulty.sort() worker.sort() i, j = 0, 0 completed_jobs = 0 # Traverse through workers and jobs while i < len(worker) and j < len(difficulty): if worker[i] >= difficulty[j]: # Worker can complete the job completed_jobs += 1 j += 1 # Move to the next worker regardless of job completion i += 1 return completed_jobs"},{"question":"from typing import List def shortest_to_char(s: str, c: str) -> List[int]: Returns a list of the shortest distances from character \`c\` to each character in the string \`s\`. >>> shortest_to_char(\\"loveleetcode\\", 'e') [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0] >>> shortest_to_char(\\"aaaaa\\", 'a') [0, 0, 0, 0, 0] >>> shortest_to_char(\\"abcdefgh\\", 'z') [float('inf'), float('inf'), float('inf'), float('inf'), float('inf'), float('inf'), float('inf'), float('inf')] >>> shortest_to_char(\\"abac\\", 'c') [3, 2, 1, 0] >>> shortest_to_char(\\"c\\", 'c') [0]","solution":"def shortest_to_char(s, c): Returns the list of shortest distances from character \`c\` to each character in the string \`s\`. n = len(s) result = [float('inf')] * n # First pass: Left to right prev = float('-inf') for i in range(n): if s[i] == c: prev = i result[i] = min(result[i], abs(i - prev)) # Second pass: Right to left prev = float('inf') for i in range(n-1, -1, -1): if s[i] == c: prev = i result[i] = min(result[i], abs(i - prev)) return result"},{"question":"def majority_element(nums: List[int]) -> int: Returns the majority element in nums, which appears more than n/2 times. >>> majority_element([3, 2, 3]) 3 >>> majority_element([2, 2, 2, 2, 2]) 2 >>> majority_element([1, 2, 3, 1, 1]) 1 >>> majority_element([1, 1, 2, 1, 2, 1, 2]) 1 >>> majority_element([3, 3, 4, 2, 4, 4, 4, 1, 4]) 4","solution":"def majority_element(nums): Returns the majority element in nums, which appears more than n/2 times. count = 0 candidate = None for num in nums: if count == 0: candidate = num count += (1 if num == candidate else -1) return candidate"},{"question":"def findCommonElements(mat: List[List[int]]) -> int: Returns the number of common elements in all rows of the matrix 'mat'. >>> findCommonElements([[1, 2, 3, 4, 5]]) == 5 >>> findCommonElements([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == 0 >>> findCommonElements([ ... [1, 2, 3], ... [2, 3, 4], ... [2, 3, 5] ... ]) == 2 >>> findCommonElements([ ... [1, 2, 3, 4, 5], ... [2, 3, 5, 6, 7], ... [3, 5, 7, 8, 9] ... ]) == 2 >>> findCommonElements([]) == 0 >>> findCommonElements([[], [], []]) == 0 ...","solution":"from collections import Counter def findCommonElements(mat): Returns the number of common elements in all rows of the matrix 'mat'. if not mat: return 0 # Initialize a Counter with the elements of the first row counter = Counter(mat[0]) # Intersect the counts with subsequent rows for row in mat[1:]: row_counter = Counter(row) for key in counter.keys(): if key in row_counter: counter[key] = min(counter[key], row_counter[key]) else: counter[key] = 0 # Remove elements with zero count and count the common elements common_elements_count = sum(1 for count in counter.values() if count > 0) return common_elements_count"},{"question":"from typing import List def find_anagrams(words: List[str]) -> List[str]: Returns a list of all strings in \`words\` that are anagrams of any other string in the list. >>> find_anagrams([\\"bat\\", \\"tab\\", \\"eat\\", \\"tea\\", \\"tan\\", \\"nat\\", \\"bat\\"]) == [\\"bat\\", \\"tab\\", \\"eat\\", \\"tea\\", \\"tan\\", \\"nat\\"] >>> find_anagrams([\\"apple\\", \\"banana\\", \\"carrot\\"]) == [] >>> find_anagrams([\\"apple\\", \\"pale\\", \\"leap\\", \\"banana\\"]) == [\\"pale\\", \\"leap\\"] >>> find_anagrams([\\"listen\\", \\"silent\\", \\"enlist\\", \\"google\\"]) == [\\"listen\\", \\"silent\\", \\"enlist\\"] >>> find_anagrams([]) == [] >>> find_anagrams([\\"singleton\\"]) == [] pass","solution":"def find_anagrams(words): Returns a list of all strings in \`words\` that are anagrams of any other string in the list. from collections import defaultdict anagrams = defaultdict(list) for word in words: # Sort the characters of the word and use as a key sorted_word = ''.join(sorted(word)) anagrams[sorted_word].append(word) # Filter out those lists with only one word as they cannot be anagrams with any other word result = [] for word_list in anagrams.values(): if len(word_list) > 1: result.extend(word_list) return list(set(result))"},{"question":"def count_visible_buildings(heights): Returns the number of buildings that can be seen from the leftmost building to the rightmost building. Parameters: heights (list): A list of integers representing the heights of buildings. Returns: int: The number of visible buildings. Examples: >>> count_visible_buildings([5]) 1 >>> count_visible_buildings([1, 2, 3, 4, 5]) 5 >>> count_visible_buildings([1, 3, 2, 4, 2, 5]) 4 >>> count_visible_buildings([2, 2, 2, 2, 3, 1, 4, 1]) 3 >>> count_visible_buildings([]) 0","solution":"def count_visible_buildings(heights): Returns the number of buildings that can be seen from the leftmost building to the rightmost building. Parameters: heights (list): A list of integers representing the heights of buildings. Returns: int: The number of visible buildings. visible_buildings = 0 max_height_seen = 0 for height in heights: if height > max_height_seen: visible_buildings += 1 max_height_seen = height return visible_buildings"},{"question":"def max_sum_subarrays(weights: List[int], k: int) -> int: Returns the maximum possible sum of weights that can be obtained by selecting non-overlapping subarrays of length exactly k. >>> max_sum_subarrays([1, 2, 3, 4, 5], 5) 15 >>> max_sum_subarrays([1, 2, 3, 4, 5, 6], 2) 11 >>> max_sum_subarrays([], 2) 0 >>> max_sum_subarrays([1, 2, 3], 4) 0 >>> max_sum_subarrays([1, 2, 3, 1, 2, 3], 3) 6","solution":"def max_sum_subarrays(weights, k): Returns the maximum possible sum of weights that can be obtained by selecting non-overlapping subarrays of length exactly k. if len(weights) < k: return 0 # Calculate initial sum of first window current_sum = sum(weights[:k]) max_sum = current_sum # Calculate sums of remaining windows for i in range(1, len(weights) - k + 1): current_sum = current_sum - weights[i - 1] + weights[i + k - 1] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def max_area(heights: List[int]) -> int: Given an integer array \`heights\` representing the heights of buildings, find the maximum area of water that can be trapped between the buildings. >>> max_area([1, 8, 6, 2, 5, 4, 8, 3, 7]) 49 >>> max_area([1, 1]) 1 >>> max_area([10, 1]) 1 >>> max_area([5, 5, 5, 5, 5]) 20 >>> max_area([1, 2, 3, 4, 5]) 6 >>> max_area([5, 4, 3, 2, 1]) 6 >>> max_area([4, 3, 2, 1, 4]) 16 >>> max_area([5]) 0","solution":"def max_area(heights): Given an integer array \`heights\` representing the heights of buildings, find the maximum area of water that can be trapped between the buildings. left = 0 right = len(heights) - 1 max_area = 0 while left < right: # Calculate the width width = right - left # Calculate the height as the shorter of the two heights height = min(heights[left], heights[right]) # Calculate the area current_area = width * height # Update max_area if the current_area is greater if current_area > max_area: max_area = current_area # Move the pointers to potentially find a greater area. if heights[left] < heights[right]: left += 1 else: right -= 1 return max_area"},{"question":"def check_subarray_sum(nums: List[int], k: int) -> bool: Returns true if there is a continuous subarray of nums whose elements sum up to k. >>> check_subarray_sum([1, 2, 3, 4, 5], 9) == True >>> check_subarray_sum([1, 1, 1, 1], 3) == True >>> check_subarray_sum([1, 2, 3, 7, 5], 12) == True >>> check_subarray_sum([5, 6, -1, 7, 0], 12) == True >>> check_subarray_sum([1, 2, 3, 4, 5], 20) == False >>> check_subarray_sum([1, 1, 1, 1], 5) == False >>> check_subarray_sum([5, 6, -1, 7, 0], 25) == False >>> check_subarray_sum([1, -1, 1, -1, 1], 2) == False >>> check_subarray_sum([1], 1) == True >>> check_subarray_sum([1], 0) == False >>> check_subarray_sum([], 0) == False >>> check_subarray_sum([-1, -2, -3, -4, -5], -10) == True >>> check_subarray_sum([-1, -2, -3, -4, -5], -15) == True","solution":"def check_subarray_sum(nums, k): Returns true if there is a continuous subarray of nums whose elements sum up to k. n = len(nums) for start in range(n): current_sum = 0 for end in range(start, n): current_sum += nums[end] if current_sum == k: return True return False"},{"question":"from typing import List def can_rearrange_to_meet_target(arr1: List[int], arr2: List[int], x: int) -> bool: You are given two integer arrays \`arr1\` and \`arr2\` both of length \`n\` and an integer \`x\`. You are allowed to rearrange the order of elements in \`arr2\` any way you want. Determine if there exists a permutation of \`arr2\` such that for every index \`i\` (where \`0 <= i < n\`), the sum of \`arr1[i]\` and the corresponding element in the permutation of \`arr2\` is greater than or equal to \`x\`. >>> can_rearrange_to_meet_target([1, 2, 3], [4, 5, 6], 5) True >>> can_rearrange_to_meet_target([2, 2, 2], [2, 2, 2], 5) False >>> can_rearrange_to_meet_target([1, 3, 2], [3, 2, 1], 4) True >>> can_rearrange_to_meet_target([1, 2, 3], [1, 2, 2], 6) False >>> can_rearrange_to_meet_target([100000, 200000, 300000], [400000, 500000, 600000], 700000) True","solution":"def can_rearrange_to_meet_target(arr1, arr2, x): Determines if there exists a permutation of arr2 such that for every index i (0 <= i < n), the sum of arr1[i] and the corresponding element in the permutation of arr2 is >= x. arr1.sort() arr2.sort(reverse=True) for i in range(len(arr1)): if arr1[i] + arr2[i] < x: return False return True"},{"question":"def count_pits(heights: List[int], d: int) -> int: Counts the number of pits in the landscape which have a depth of at least d. Parameters: heights (list of int): List of non-negative integers representing the heights of blocks. d (int): Minimum depth of the pit to be counted. Returns: int: Total number of pits that meet the depth requirement. >>> count_pits([1, 3, 1, 5], 1) 1 >>> count_pits([4, 2, 4], 1) 1 >>> count_pits([1, 2, 3, 4], 1) 0 >>> count_pits([5, 1, 4, 2, 4], 1) 2 >>> count_pits([1, 3, 1, 2, 5, 1, 4, 1], 1) 2 >>> count_pits([4, 1, 4], 2) 1","solution":"def count_pits(heights, d): Counts the number of pits in the landscape which have a depth of at least d. Parameters: heights (list of int): List of non-negative integers representing the heights of blocks. d (int): Minimum depth of the pit to be counted. Returns: int: Total number of pits that meet the depth requirement. n = len(heights) if n < 3: return 0 # Not enough blocks to form a pit. pit_count = 0 for i in range(1, n-1): if heights[i] < heights[i-1] and heights[i] < heights[i+1]: left = right = heights[i] l = i - 1 r = i + 1 while l > 0 and heights[l] <= heights[l-1]: left = min(left, heights[l]) l -= 1 while r < n - 1 and heights[r] <= heights[r+1]: right = min(right, heights[r]) r += 1 pit_depth = min(heights[l], heights[r]) - heights[i] if pit_depth >= d: pit_count += 1 return pit_count"},{"question":"def maxProfit(k: int, prices: List[int]) -> int: Calculate the maximum profit with at most \`k\` transactions. Args: k (int): The maximum number of transactions allowed. prices (List[int]): List of stock prices where prices[i] is the price of the stock on the i-th day. Returns: int: The maximum profit that can be achieved with at most \`k\` transactions. Examples: >>> maxProfit(2, []) 0 >>> maxProfit(0, [1, 2, 3, 4, 5]) 0 >>> maxProfit(1, [3, 2, 6, 5, 0, 3]) 4 >>> maxProfit(2, [3, 2, 6, 5, 0, 3]) 7 >>> maxProfit(100, [3, 2, 6, 5, 0, 3]) 7 >>> maxProfit(2, [7, 6, 4, 3, 1]) 0 >>> maxProfit(2, [5]) 0 >>> maxProfit(2, [2, 2, 2, 2, 2, 2]) 0","solution":"def maxProfit(k, prices): Calculate the maximum profit with at most \`k\` transactions. n = len(prices) if n == 0: return 0 # If k is greater or equal to half the number of prices, it's equivalent to unlimited transactions if k >= n // 2: return sum(max(prices[i + 1] - prices[i], 0) for i in range(n - 1)) # Dynamic programming table profits = [[0] * n for _ in range(k + 1)] for t in range(1, k + 1): max_so_far = -prices[0] for d in range(1, n): profits[t][d] = max(profits[t][d - 1], prices[d] + max_so_far) max_so_far = max(max_so_far, profits[t - 1][d] - prices[d]) return profits[k][-1]"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_complete_binary_tree(root: TreeNode) -> bool: Determine if the binary tree is complete. >>> is_complete_binary_tree(root) from solution import TreeNode, is_complete_binary_tree def test_complete_tree(): # Tree: # 1 # / # 2 3 # / / # 4 5 6 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.left = TreeNode(6) assert is_complete_binary_tree(root) == True def test_incomplete_tree(): # Tree: # 1 # / # 2 3 # / # 4 5 6 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.right = TreeNode(6) assert is_complete_binary_tree(root) == False def test_single_node_tree(): # Tree: # 1 root = TreeNode(1) assert is_complete_binary_tree(root) == True def test_empty_tree(): # Tree: # (Empty) root = None assert is_complete_binary_tree(root) == True def test_not_filled_last_level_tree(): # Tree: # 1 # / # 2 3 # / # 4 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) assert is_complete_binary_tree(root) == True","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_complete_binary_tree(root): if not root: return True queue = [root] end = False while queue: node = queue.pop(0) if node: if end: return False queue.append(node.left) queue.append(node.right) else: end = True return True"},{"question":"def has_valid_path_with_cost(grid: List[List[int]], k: int) -> bool: Determines if there exists a valid path in the given grid with a cost of at most k. A path starts at the top-left cell (0, 0) and ends at the bottom-right cell (m-1, n-1), moving only right or down at each step. The cost of a path is the number of 1's in the cells visited. >>> has_valid_path_with_cost([[0, 1, 0], [1, 0, 1], [0, 0, 0]], 2) True >>> has_valid_path_with_cost([[0, 0, 1], [1, 1, 1], [0, 0, 0]], 3) True >>> has_valid_path_with_cost([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2) False >>> has_valid_path_with_cost([[0, 0], [0, 0]], 0) True >>> has_valid_path_with_cost([[1]], 1) True >>> has_valid_path_with_cost([[0, 1, 0, 0], [1, 1, 0, 1], [0, 1, 0, 0], [0, 0, 0, 0]], 3) True","solution":"def has_valid_path_with_cost(grid, k): def dfs(x, y, cost): if x >= m or y >= n or cost > k: return False if x == m-1 and y == n-1: return cost + grid[x][y] <= k return dfs(x+1, y, cost + grid[x][y]) or dfs(x, y+1, cost + grid[x][y]) m = len(grid) n = len(grid[0]) return dfs(0, 0, 0)"},{"question":"def subarrays_div_by_k(arr, k): Returns the number of contiguous subarrays where the sum of the elements is divisible by k. :param arr: List[int] - array of integers :param k: int - integer k :return: int - number of subarrays from solution import subarrays_div_by_k def test_subarrays_div_by_k_positive_case(): assert subarrays_div_by_k([4, 5, 0, -2, -3, 1], 5) == 7 def test_subarrays_div_by_k_no_subarray(): assert subarrays_div_by_k([1, 2, 3], 7) == 0 def test_subarrays_div_by_k_all_subarrays(): assert subarrays_div_by_k([5, 10, 15], 5) == 6 def test_subarrays_div_by_k_with_negatives(): assert subarrays_div_by_k([-1, 2, 9], 2) == 2 def test_subarrays_div_by_k_single_element(): assert subarrays_div_by_k([5], 5) == 1 assert subarrays_div_by_k([3], 5) == 0 def test_subarrays_div_by_k_mixed_elements(): assert subarrays_div_by_k([0, -2, 2, 1], 2) == 6","solution":"def subarrays_div_by_k(arr, k): Returns the number of contiguous subarrays where the sum of the elements is divisible by k. :param arr: List[int] - array of integers :param k: int - integer k :return: int - number of subarrays count = 0 prefix_sum = 0 mod_count = {0: 1} for num in arr: prefix_sum += num mod = prefix_sum % k # Ensure positive mod value to handle negative numbers if mod < 0: mod += k if mod in mod_count: count += mod_count[mod] mod_count[mod] += 1 else: mod_count[mod] = 1 return count"},{"question":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def levelOrderTraversal(root: Optional[TreeNode]) -> List[List[int]]: Given a binary tree, collect all the values of the nodes in a tree in a level order manner. >>> levelOrderTraversal(None) [] >>> tree = TreeNode(1) >>> levelOrderTraversal(tree) [[1]] >>> tree = TreeNode(1, TreeNode(2), TreeNode(3)) >>> levelOrderTraversal(tree) [[1], [2, 3]] >>> tree = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3)) >>> levelOrderTraversal(tree) [[1], [2, 3], [4, 5]] >>> tree = TreeNode(1, TreeNode(2, TreeNode(4, TreeNode(5))), TreeNode(3)) >>> levelOrderTraversal(tree) [[1], [2, 3], [4], [5]] >>> tree = TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7))) >>> levelOrderTraversal(tree) [[3], [9, 20], [15, 7]]","solution":"from collections import deque from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def levelOrderTraversal(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.popleft() current_level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(current_level) return result"},{"question":"def max_hops(arr: List[int], d: int) -> int: Returns the maximum number of hops a frog can make. >>> max_hops([0, 4, 8, 12, 16, 20], 4) == 5 >>> max_hops([0, 4, 8, 13], 4) == 2 >>> max_hops([0], 4) == 0 >>> max_hops([0, 4, 8, 12, 16, 20, 24], 4) == 6 >>> max_hops([0, 1, 2, 3, 5, 7], 4) == 0 >>> max_hops([0, 4, 8, 16, 20, 32, 36], 4) == 4","solution":"def max_hops(arr, d): Returns the maximum number of hops a frog can make. max_hops = 0 current_idx = 0 while True: possible_next_steps = [i for i in range(current_idx+1, len(arr)) if arr[i] == arr[current_idx] + d or arr[i] == arr[current_idx] + 2*d] if not possible_next_steps: break current_idx = possible_next_steps[0] max_hops += 1 return max_hops"},{"question":"def can_rotate_to(s1: str, s2: str) -> bool: Determines if \`s2\` can be obtained by rotating \`s1\` by any number of positions. >>> can_rotate_to(\\"abc\\", \\"abc\\") True >>> can_rotate_to(\\"abcdef\\", \\"cdefab\\") True >>> can_rotate_to(\\"abcdef\\", \\"bacdef\\") False","solution":"def can_rotate_to(s1, s2): Returns True if s2 can be obtained by rotating s1 by any number of positions. if len(s1) != len(s2): return False # Concatenate s1 to itself to handle rotations s1_extended = s1 + s1 # Check if s2 is a substring of the extended string return s2 in s1_extended"},{"question":"def max_sub_array(arr: List[int]) -> List[int]: Finds the contiguous sub-array with the largest sum and returns the sum along with the starting and ending indices of this sub-array. :param arr: List of integers :return: A list [max_sum, start_index, end_index] >>> max_sub_array([1]) [1, 0, 0] >>> max_sub_array([-1]) [-1, 0, 0] >>> max_sub_array([1, 2, 3, 4]) [10, 0, 3] >>> max_sub_array([-1, -2, -3, -4]) [-1, 0, 0] >>> max_sub_array([-2, 1, -3, 4, -1, 2, 1, -5, 4]) [6, 3, 6] >>> max_sub_array([1, -1, 1, -1, 1, -1, 1]) [1, 0, 0] >>> max_sub_array([]) [float('-inf'), 0, 0] >>> max_sub_array([0, -3, 0, -2, 0, -1, 0]) [0, 0, 0]","solution":"def max_sub_array(arr): Finds the contiguous sub-array with the largest sum and returns the sum along with the starting and ending indices of this sub-array. :param arr: List of integers :return: A list [max_sum, start_index, end_index] max_sum = float('-inf') current_sum = 0 start = 0 start_temp = 0 end = 0 for i in range(len(arr)): if current_sum <= 0: current_sum = arr[i] start_temp = i else: current_sum += arr[i] if current_sum > max_sum: max_sum = current_sum start = start_temp end = i elif current_sum == max_sum and (start_temp < start or (start_temp == start and i < end)): start = start_temp end = i return [max_sum, start, end]"},{"question":"def length_of_shortest_word(text: str) -> int: Returns the length of the shortest word in the given text. A word is defined as a contiguous substring of text that consists of only alphabetical characters. Examples: >>> length_of_shortest_word(\\"hello world\\") 5 >>> length_of_shortest_word(\\"the quick brown fox\\") 3 >>> length_of_shortest_word(\\"hello123world\\") 5 >>> length_of_shortest_word(\\"quick!brown@fox#\\") 3 >>> length_of_shortest_word(\\"thequick%brown^fox\\") 3 >>> length_of_shortest_word(\\"hello\\") 5 >>> length_of_shortest_word(\\" a quick brown fox \\") 1 >>> length_of_shortest_word(\\"\\") 0 >>> length_of_shortest_word(\\"1234567890\\") 0 >>> length_of_shortest_word(\\"!@#%^&*()\\") 0 >>> length_of_shortest_word(\\"12quick34brown56\\") 5 >>> length_of_shortest_word(\\"7jumpsover#the^lazy@dog2\\") 3","solution":"def length_of_shortest_word(text): Returns the length of the shortest word in the given text. A word is defined as a contiguous substring of text that consists of only alphabetical characters. import re # Find all words in the text using regex words = re.findall(r'[a-zA-Z]+', text) if not words: return 0 # Find the length of the shortest word return min(len(word) for word in words)"},{"question":"def population_to_binary_string(populations): Returns a list of binary string representations of city populations, left-padded with zeros such that each binary string has the same length as the binary representation of the highest population number. >>> population_to_binary_string([3, 7, 2]) ['011', '111', '010'] >>> population_to_binary_string([5]) ['101'] >>> population_to_binary_string([4, 4, 4]) ['100', '100', '100'] >>> population_to_binary_string([0, 0, 0]) ['0', '0', '0'] >>> population_to_binary_string([15, 8, 0]) ['1111', '1000', '0000'] >>> population_to_binary_string([]) [] >>> population_to_binary_string([1023, 512, 256]) ['1111111111', '1000000000', '0100000000']","solution":"def population_to_binary_string(populations): Returns a list of binary string representations of city populations, left-padded with zeros such that each binary string has the same length as the binary representation of the highest population number. if not populations: return [] # Find the highest population to determine the length of the binary strings max_population = max(populations) max_length = len(bin(max_population)) - 2 # subtract 2 to remove '0b' prefix binary_strings = [ bin(population)[2:].zfill(max_length) for population in populations ] return binary_strings"},{"question":"def wordBreak(s: str, wordDict: List[str]) -> List[str]: Given a string \`s\` and a dictionary of words \`wordDict\`, return all the possible sentences you can form by concatenating words from the dictionary following the order in \`s\`. The words can be reused multiple times if needed. The order of words in each resultant sentence should match their order in the input string \`s\`. >>> wordBreak(\\"catsanddog\\", [\\"cat\\", \\"cats\\", \\"and\\", \\"sand\\", \\"dog\\"]) [\\"cat sand dog\\", \\"cats and dog\\"] >>> wordBreak(\\"pineapplepenapple\\", [\\"apple\\", \\"pen\\", \\"applepen\\", \\"pine\\", \\"pineapple\\"]) [\\"pine apple pen apple\\", \\"pineapple pen apple\\", \\"pine applepen apple\\"]","solution":"def wordBreak(s, wordDict): Returns all possible sentences by concatenating words from the dictionary following the order in \`s\`. memo = {} def dfs(ind): if ind in memo: return memo[ind] if ind == len(s): return [\\"\\"] res = [] for word in wordDict: if s.startswith(word, ind): for sub_sentence in dfs(ind + len(word)): if sub_sentence: res.append(word + \\" \\" + sub_sentence) else: res.append(word) memo[ind] = res return res return dfs(0)"},{"question":"def remove_min_to_non_decreasing(s: str) -> str: Removes the minimum number of digits such that the remaining digits are in non-decreasing order. >>> remove_min_to_non_decreasing(\\"1\\") \\"1\\" >>> remove_min_to_non_decreasing(\\"123456\\") \\"123456\\" >>> remove_min_to_non_decreasing(\\"654321\\") \\"1\\" >>> remove_min_to_non_decreasing(\\"1432219\\") \\"119\\" >>> remove_min_to_non_decreasing(\\"1112234\\") \\"1112234\\" >>> remove_min_to_non_decreasing(\\"2222\\") \\"2222\\" >>> remove_min_to_non_decreasing(\\"98765432123456789\\") \\"123456789\\"","solution":"def remove_min_to_non_decreasing(s): Removes the minimum number of digits such that the remaining digits are in non-decreasing order. stack = [] for digit in s: while stack and stack[-1] > digit: stack.pop() stack.append(digit) return ''.join(stack)"},{"question":"def min_subarray_len(nums: List[int], target: int) -> int: Return the length of the shortest subarray with a sum >= target. If no such subarray exists, return -1. >>> min_subarray_len([2, 3, 1, 2, 4, 3], 7) == 2 >>> min_subarray_len([1, 4, 4], 4) == 1 >>> min_subarray_len([1, 1, 1, 1, 1, 1, 1, 1], 11) == -1 >>> min_subarray_len([1, 2, 3, 4, 5], 11) == 3 >>> min_subarray_len([10, 2, 3], 6) == 1 >>> min_subarray_len([1, 1, 1, 1, 1], 5) == 5 >>> min_subarray_len([5, 1, 3, 5, 10, 7, 4, 9, 2, 8], 15) == 2 >>> min_subarray_len([], 100) == -1 >>> min_subarray_len([1, 2, 3, 4], 100) == -1 >>> min_subarray_len([10], 10) == 1 >>> min_subarray_len([5], 5) == 1 >>> min_subarray_len([1], 2) == -1","solution":"def min_subarray_len(nums, target): Return the length of the shortest subarray with a sum >= target. If no such subarray exists, return -1. n = len(nums) min_len = float('inf') left = 0 current_sum = 0 for right in range(n): current_sum += nums[right] while current_sum >= target: min_len = min(min_len, right - left + 1) current_sum -= nums[left] left += 1 return min_len if min_len != float('inf') else -1"},{"question":"from typing import List def longest_subarray(nums: List[int], limit: int) -> int: Returns the length of the longest contiguous subarray such that the absolute difference between any two elements is less than or equal to the given limit. >>> longest_subarray([8, 2, 4, 7], 4) == 2 >>> longest_subarray([10,1,2,4,7,2], 5) == 4 >>> longest_subarray([4,2,2,2,4,4,2,2], 0) == 3 >>> longest_subarray([1], 0) == 1 >>> longest_subarray([2,2,2,2], 0) == 4 >>> longest_subarray([1, 5, 6, 2, 8, 10, 7], 10) == 7 >>> longest_subarray([1, 5, 6, 2, 8, 10, 7], 0) == 1","solution":"from collections import deque import heapq def longest_subarray(nums, limit): Returns the length of the longest contiguous subarray such that the absolute difference between any two elements is less than or equal to the given limit. max_len = 0 queue_min = deque() queue_max = deque() start = 0 for end in range(len(nums)): while queue_max and nums[end] > queue_max[-1]: queue_max.pop() while queue_min and nums[end] < queue_min[-1]: queue_min.pop() queue_max.append(nums[end]) queue_min.append(nums[end]) while queue_max and queue_min and (queue_max[0] - queue_min[0] > limit): if queue_max[0] == nums[start]: queue_max.popleft() if queue_min[0] == nums[start]: queue_min.popleft() start += 1 max_len = max(max_len, end - start + 1) return max_len"},{"question":"def evaluate_expr(s: str) -> int: Evaluate a valid arithmetic expression containing only non-negative integers, '+', '-', '*', '/' operators, and empty spaces. Division truncates towards zero. >>> evaluate_expr(\\"3+2\\") 5 >>> evaluate_expr(\\"10-3\\") 7 >>> evaluate_expr(\\"4*5\\") 20 >>> evaluate_expr(\\"10/2\\") 5 >>> evaluate_expr(\\"2+3*4\\") 14 >>> evaluate_expr(\\"20/4-3\\") 2 >>> evaluate_expr(\\" 3 + 4 * 2 / 1 \\") 11 >>> evaluate_expr(\\"8/3\\") 2 >>> evaluate_expr(\\"7/2\\") 3 >>> evaluate_expr(\\"2+3-4*5+6/3\\") -13","solution":"def evaluate_expr(s): Evaluates a valid arithmetic expression containing only non-negative integers, '+', '-', '*', '/' operators, and empty spaces. Division truncates towards zero. def operate(op, second, first): if op == '+': return first + second if op == '-': return first - second if op == '*': return first * second if op == '/': return int(first / second) # truncate towards zero num, stack, op = 0, [], '+' s = s.replace(' ', '') + '+' for i, ch in enumerate(s): if ch.isdigit(): num = num * 10 + int(ch) elif ch in '+-*/': if op == '+': stack.append(num) elif op == '-': stack.append(-num) elif op in '*/': stack.append(operate(op, num, stack.pop())) num, op = 0, ch return sum(stack)"},{"question":"from typing import List def combination_sum_k(nums: List[int], target: int, k: int) -> List[List[int]]: Given an integer array nums and an integer target, return all possible combinations of k elements from nums that add up to target. Each combination should be unique and the order of elements within each combination does not matter. Args: nums (List[int]): List of distinct integers. target (int): The target sum of the combinations. k (int): The number of elements in each combination. Returns: List[List[int]]: List of unique combinations that add up to target. Examples: >>> combination_sum_k([2, 3, 6, 7], 9, 2) [[2, 7], [3, 6]] >>> combination_sum_k([5, 10, 15, 20, 25], 35, 2) [[10, 25], [15, 20]]","solution":"from itertools import combinations def combination_sum_k(nums, target, k): Returns all unique combinations of k elements from nums that sum to target. result = [] for comb in combinations(nums, k): if sum(comb) == target: result.append(list(comb)) return result"},{"question":"def min_time_to_complete(tasks: List[int], n: int) -> int: Returns the minimum amount of time required to complete all the tasks given a number of workers. Parameters: tasks (list): List of integers representing the time duration of each task. n (int): Number of workers available. Returns: int: Minimum time to complete all tasks. pass def test_all_tasks_equal_time(): assert min_time_to_complete([4, 4, 4, 4], 2) == 8 assert min_time_to_complete([4, 4, 4], 3) == 4 def test_single_task(): assert min_time_to_complete([10], 5) == 10 def test_more_workers_than_tasks(): assert min_time_to_complete([5, 7, 2], 5) == 7 def test_more_tasks_than_workers(): assert min_time_to_complete([2, 2, 2, 2, 2], 2) == 6 assert min_time_to_complete([1, 2, 3, 5, 4], 3) == 5 def test_varied_tasks_with_minimum_workers(): assert min_time_to_complete([7, 2, 5, 8, 4], 1) == 26 def test_all_tasks_different_time(): assert min_time_to_complete([10, 10, 9, 8, 7], 2) == 25","solution":"def min_time_to_complete(tasks, n): Returns the minimum amount of time required to complete all the tasks given a number of workers. Parameters: tasks (list): List of integers representing the time duration of each task. n (int): Number of workers available. Returns: int: Minimum time to complete all tasks. # Sort tasks in descending order tasks.sort(reverse=True) # Initialize list to keep track of time worked by each worker workers = [0] * n # Greedily assign each task to the worker with the least amount of work so far for task in tasks: workers.sort() workers[0] += task # The maximum work by any worker will be the minimum time to finish all tasks return max(workers)"},{"question":"from typing import List def maxProfit(prices: List[int]) -> int: Calculate the maximum profit that can be achieved from given stock prices. Parameters: prices (List[int]): List of stock prices where prices[i] is the price of the stock on the i-th day. Returns: int: The maximum profit that can be achieved. # Implement your solution here from solution import maxProfit def test_example_cases(): assert maxProfit([7,1,5,3,6,4]) == 7 assert maxProfit([1,2,3,4,5]) == 4 assert maxProfit([7,6,4,3,1]) == 0 def test_edge_cases(): assert maxProfit([]) == 0 assert maxProfit([1]) == 0 assert maxProfit([1, 5, 3, 8, 4, 10]) == 15 def test_all_increasing_and_decreasing(): assert maxProfit([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 9 assert maxProfit([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) == 0","solution":"from typing import List def maxProfit(prices: List[int]) -> int: Calculate the maximum profit that can be achieved from given stock prices. Parameters: prices (List[int]): List of stock prices where prices[i] is the price of the stock on the i-th day. Returns: int: The maximum profit that can be achieved. if not prices: return 0 max_profit = 0 for i in range(1, len(prices)): if prices[i] > prices[i - 1]: max_profit += prices[i] - prices[i - 1] return max_profit"},{"question":"from typing import List def min_time_to_finish_tasks(tasks: List[int], k: int) -> int: Calculates the minimum time required to finish all tasks with a cooldown constraint. Parameters: tasks (list): List of tasks represented by integers. k (int): Cooldown period between consecutive execution of the same task. Returns: int: Minimum time required to finish all tasks. pass # Test cases def test_no_tasks(): assert min_time_to_finish_tasks([], 2) == 0 def test_single_task(): assert min_time_to_finish_tasks([1], 2) == 1 def test_no_cooldown(): assert min_time_to_finish_tasks([1, 1, 2, 2, 3, 3], 0) == 6 def test_cooldown_one(): assert min_time_to_finish_tasks([1, 2, 1, 2], 1) == 4 def test_cooldown_greater(): assert min_time_to_finish_tasks([1, 1, 1, 2, 2], 2) == 7 def test_multiple_tasks_with_different_counts(): assert min_time_to_finish_tasks([1, 1, 2, 1], 2) == 7 def test_all_tasks_same(): assert min_time_to_finish_tasks([1, 1, 1, 1], 2) == 10 def test_alternate_tasks(): assert min_time_to_finish_tasks([1, 2, 1, 2, 1], 2) == 7","solution":"from collections import Counter, deque def min_time_to_finish_tasks(tasks, k): Calculates the minimum time required to finish all tasks with a cooldown constraint. Parameters: tasks (list): List of tasks represented by integers. k (int): Cooldown period between consecutive execution of the same task. Returns: int: Minimum time required to finish all tasks. if not tasks: return 0 task_counts = Counter(tasks) max_count = max(task_counts.values()) max_count_tasks = list(task_counts.values()).count(max_count) # Calculate the number of slots of cooldown we need total_slots = (max_count - 1) * (k + 1) + max_count_tasks return max(total_slots, len(tasks))"},{"question":"from typing import List def canPartition(nums: List[int]) -> bool: Determines whether the given array can be partitioned into two subsets such that the sum of elements in both subsets is the same. >>> canPartition([1, 5, 11, 5]) True >>> canPartition([1, 2, 3, 5]) False >>> canPartition([0, 0, 0, 0]) True >>> canPartition([1]) False >>> canPartition([10, 10]) True >>> canPartition([1, 10]) False >>> canPartition([2, 2, 1, 1, 5, 9]) True >>> canPartition([2, 2, 1, 1, 9]) False","solution":"def canPartition(nums): Determines whether the given array can be partitioned into two subsets such that the sum of elements in both subsets is the same. :param nums: A list of integers. :return: A boolean value: True if the array can be partitioned; False otherwise. total_sum = sum(nums) # If total sum is odd, it's not possible to partition it into equal subsets if total_sum % 2 != 0: return False target = total_sum // 2 n = len(nums) # Initialize a boolean dp array where dp[i] means if a sum i can be formed dp = [False] * (target + 1) dp[0] = True # There's always a way to get zero sum(subset of no elements) for num in nums: for i in range(target, num - 1, -1): dp[i] = dp[i] or dp[i - num] return dp[target]"},{"question":"def unique_paths_with_obstacles(x: int, y: int, obstacles: List[Tuple[int, int]]) -> int: Returns the number of distinct paths from the top-left to the bottom-right corner of an x by y grid, navigating around obstacles. :param x: int - the number of rows in the grid :param y: int - the number of columns in the grid :param obstacles: List[Tuple[int, int]] - list containing coordinates of obstacles :return: int - number of distinct paths >>> unique_paths_with_obstacles(3, 3, []) == 6 >>> unique_paths_with_obstacles(3, 3, [(1, 1)]) == 2 >>> unique_paths_with_obstacles(3, 3, [(1, 0), (1, 1)]) == 1 >>> unique_paths_with_obstacles(3, 3, [(0, 1), (1, 0)]) == 0 >>> unique_paths_with_obstacles(4, 4, []) == 20 >>> unique_paths_with_obstacles(4, 4, [(1, 1), (2, 2)]) == 4 >>> unique_paths_with_obstacles(3, 3, [(0, 0)]) == 0 >>> unique_paths_with_obstacles(3, 3, [(2, 2)]) == 0","solution":"def unique_paths_with_obstacles(x, y, obstacles): Returns the number of distinct paths from the top-left to the bottom-right corner of an x by y grid, navigating around obstacles. :param x: int - the number of rows in the grid :param y: int - the number of columns in the grid :param obstacles: list of tuples - list containing coordinates of obstacles :return: int - number of distinct paths # Create a 2D list initialized to 0 grid = [[0] * y for _ in range(x)] # Set the start position to 1 if it's not an obstacle if (0, 0) not in obstacles: grid[0][0] = 1 # Fill the grid using dynamic programming for i in range(x): for j in range(y): if (i, j) in obstacles: grid[i][j] = 0 else: if i > 0: grid[i][j] += grid[i-1][j] if j > 0: grid[i][j] += grid[i][j-1] # The value at the bottom-right corner is the number of unique paths return grid[x-1][y-1]"},{"question":"from typing import List def longest_arithmetic_subsequence(nums: List[int]) -> int: Finds the length of the longest arithmetic subsequence where the difference between consecutive elements is consistent. >>> longest_arithmetic_subsequence([1]) 1 >>> longest_arithmetic_subsequence([1, 3]) 2 >>> longest_arithmetic_subsequence([3, 6, 9, 12]) 4 >>> longest_arithmetic_subsequence([9, 4, 7, 2, 10]) 3 >>> longest_arithmetic_subsequence([20, 1, 15, 3, 10, 5, 8]) 4","solution":"def longest_arithmetic_subsequence(nums): Returns the length of the longest arithmetic subsequence. if len(nums) <= 1: return len(nums) longest_length = 1 dp = [{} for _ in range(len(nums))] for i in range(len(nums)): for j in range(i): diff = nums[i] - nums[j] if diff in dp[j]: dp[i][diff] = dp[j][diff] + 1 else: dp[i][diff] = 2 longest_length = max(longest_length, dp[i][diff]) return longest_length"},{"question":"def replace_indices(str1: str, str2: str, indices: List[int]) -> str: Replaces characters in str1 with characters from str2 at specified indices. :param str1: The original string to be modified. :param str2: The string containing replacement characters. :param indices: The list of indices in str1 where replacements should be done. :return: The resulting string after replacements. >>> replace_indices(\\"abcd\\", \\"wxyz\\", [0, 1, 2, 3]) == \\"wxyz\\" >>> replace_indices(\\"abcd\\", \\"wx\\", [1, 2]) == \\"awxd\\" >>> replace_indices(\\"hello\\", \\"x\\", [1]) == \\"hxllo\\" >>> replace_indices(\\"hello\\", \\"\\", []) == \\"hello\\" >>> replace_indices(\\"123456\\", \\"abcdef\\", [5, 4, 3, 2, 1, 0]) == \\"fedcba\\"","solution":"def replace_indices(str1, str2, indices): Replaces characters in str1 with characters from str2 at specified indices. :param str1: The original string to be modified. :param str2: The string containing replacement characters. :param indices: The list of indices in str1 where replacements should be done. :return: The resulting string after replacements. str1_list = list(str1) for i, index in enumerate(indices): str1_list[index] = str2[i] return ''.join(str1_list)"},{"question":"def min_operations_to_equal_candies(nums: List[int]) -> int: Returns the minimum number of operations needed such that all jars contain the same number of candies. Args: nums (List[int]): A list of integers representing the number of candies in each jar. Returns: int: The minimum number of operations to make all jars contain the same number of candies. Examples: >>> min_operations_to_equal_candies([3, 3, 3]) 0 >>> min_operations_to_equal_candies([1, 2, 3]) 3 >>> min_operations_to_equal_candies([10, 20, 30]) 30","solution":"def min_operations_to_equal_candies(nums): Returns the minimum number of operations needed such that all jars contain the same number of candies. if not nums: return 0 min_candies = min(nums) operations = sum(candies - min_candies for candies in nums) return operations"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def longest_univalue_path(root): Returns the length of the longest path in the tree such that every subpath of that path has the same node value. >>> test_longest_univalue_path_empty_tree() >>> test_longest_univalue_path_single_node() >>> test_longest_univalue_path_two_same_nodes() >>> test_longest_univalue_path_two_different_nodes() >>> test_longest_univalue_path_complex_tree() >>> test_longest_univalue_path_all_same_values() def test_longest_univalue_path_empty_tree(): assert longest_univalue_path(None) == 0 def test_longest_univalue_path_single_node(): root = TreeNode(1) assert longest_univalue_path(root) == 0 def test_longest_univalue_path_two_same_nodes(): root = TreeNode(1, TreeNode(1)) assert longest_univalue_path(root) == 1 def test_longest_univalue_path_two_different_nodes(): root = TreeNode(1, TreeNode(2)) assert longest_univalue_path(root) == 0 def test_longest_univalue_path_complex_tree(): root = TreeNode(1, TreeNode(4, TreeNode(4), TreeNode(4)), TreeNode(5, None, TreeNode(5))) assert longest_univalue_path(root) == 2 def test_longest_univalue_path_all_same_values(): root = TreeNode(1, TreeNode(1, TreeNode(1), TreeNode(1)), TreeNode(1, None, TreeNode(1))) assert longest_univalue_path(root) == 4","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def longest_univalue_path(root): Returns the length of the longest path in the tree such that every subpath of that path has the same node value. def longest_path(node): if not node: return 0, 0 # (max_length_with_node, max_length_with_parent) left_len, left_with_parent = longest_path(node.left) right_len, right_with_parent = longest_path(node.right) left = right = 0 if node.left and node.left.value == node.value: left = left_with_parent + 1 if node.right and node.right.value == node.value: right = right_with_parent + 1 max_length_with_node = max(left_len, right_len, left + right) max_length_with_parent = max(left, right) return max_length_with_node, max_length_with_parent max_length, _ = longest_path(root) return max_length"},{"question":"def find_words(board, words): Returns a list of words found in the boggle board. Parameters: board (List[List[str]]): A 2D list representing a boggle game board. words (List[str]): A list of words to search for in the board. Returns: List[str]: A list of words found in the boggle board. pass # Test cases def test_find_words_simple(): board = [ ['o', 'a', 'a', 'n'], ['e', 't', 'a', 'e'], ['i', 'h', 'k', 'r'], ['i', 'f', 'l', 'v'] ] words = [\\"oath\\", \\"pea\\", \\"eat\\", \\"rain\\"] result = find_words(board, words) assert set(result) == {\\"oath\\", \\"eat\\"} def test_find_words_no_match(): board = [ ['a', 'b'], ['c', 'd'] ] words = [\\"ei\\", \\"if\\", \\"cbe\\", \\"ea\\"] result = find_words(board, words) assert set(result) == set() def test_find_words_single_letter_board(): board = [ ['a'] ] words = [\\"a\\", \\"b\\"] result = find_words(board, words) assert set(result) == {\\"a\\"} def test_find_words_large_board(): board = [ ['a', 'b', 'c', 'e'], ['s', 'f', 'c', 's'], ['a', 'd', 'e', 'e'] ] words = [\\"see\\", \\"dea\\", \\"abcced\\", \\"fcs\\"] result = find_words(board, words) assert set(result) == {\\"see\\", \\"abcced\\", \\"fcs\\"}","solution":"def find_words(board, words): Returns a list of words found in the boggle board. Parameters: board (List[List[str]]): A 2D list representing a boggle game board. words (List[str]): A list of words to search for in the board. Returns: List[str]: A list of words found in the boggle board. def dfs(board, word, i, j, index): if index == len(word): return True if i < 0 or j < 0 or i >= len(board) or j >= len(board[0]) or board[i][j] != word[index]: return False temp = board[i][j] board[i][j] = '#' # mark as visited found = (dfs(board, word, i + 1, j, index + 1) or dfs(board, word, i - 1, j, index + 1) or dfs(board, word, i, j + 1, index + 1) or dfs(board, word, i, j - 1, index + 1) or dfs(board, word, i + 1, j + 1, index + 1) or dfs(board, word, i - 1, j - 1, index + 1) or dfs(board, word, i + 1, j - 1, index + 1) or dfs(board, word, i - 1, j + 1, index + 1)) board[i][j] = temp return found found_words = set() for word in words: for i in range(len(board)): for j in range(len(board[0])): if dfs(board, word, i, j, 0): found_words.add(word) break return list(found_words)"},{"question":"def restore_string(s: str, indices: List[int]) -> str: Reconstructs and returns the original word by placing the characters of s at the correct position according to the indices array. >>> restore_string(\\"aiohn\\", [3, 1, 4, 2, 0]) \\"nihao\\" >>> restore_string(\\"a\\", [0]) \\"a\\" >>> restore_string(\\"abcde\\", [0, 1, 2, 3, 4]) \\"abcde\\" >>> restore_string(\\"dcba\\", [3, 2, 1, 0]) \\"abcd\\" >>> restore_string(\\"art\\", [1, 0, 2]) \\"rat\\"","solution":"def restore_string(s, indices): Reconstructs and returns the original word by placing the characters of s at the correct position according to the indices array. :param s: str : The jumbled word :param indices: List[int] : The correct positions of each character in s :return: str : The original word original_word = [''] * len(s) for char, index in zip(s, indices): original_word[index] = char return ''.join(original_word)"},{"question":"def checkSubarraySum(nums: List[int], k: int) -> bool: Determine whether there exists a subarray of length \`k\` such that the sum of its elements is divisible by \`k\`. Args: nums: List[int] - list of integers k: int - integer value Returns: bool - True if such a subarray exists, otherwise False >>> checkSubarraySum([23, 2, 4, 6, 7], 3) True >>> checkSubarraySum([1, 2, 3], 4) False >>> checkSubarraySum([23, 2, 6, 4, 7], 3) True >>> checkSubarraySum([3], 3) False >>> checkSubarraySum([], 3) False >>> checkSubarraySum([1, 2, 3, 4, 5], 1) True >>> checkSubarraySum([1, 2, 3], 0) False","solution":"def checkSubarraySum(nums, k): Determine whether there exists a subarray of length \`k\` such that the sum of its elements is divisible by \`k\`. Args: nums: List[int] - list of integers k: int - integer value Returns: bool - True if such a subarray exists, otherwise False if k == 0: return False for i in range(len(nums) - k + 1): if sum(nums[i:i + k]) % k == 0: return True return False"},{"question":"from typing import List, Tuple def two_sum_pairs(arr: List[int], target: int) -> List[Tuple[int, int]]: Finds all unique pairs in the array that sum up to the given target value. :param arr: List[int] - List of integers :param target: int - Target sum :return: List[Tuple[int, int]] - List of unique pairs that sum up to target >>> two_sum_pairs([1, 2, 3, 4, 5], 5) [(1, 4), (2, 3)] >>> two_sum_pairs([1, 2, 3], 7) [] >>> two_sum_pairs([1, 2, 3, 4, 3], 6) [(2, 4), (3, 3)] >>> two_sum_pairs([-1, 0, 1, 2, -2, 3], 1) [(-2, 3), (-1, 2), (0, 1)] >>> two_sum_pairs([1, 1, 2, 2, 3, 3], 4) [(1, 3), (2, 2)] >>> two_sum_pairs([], 5) [] >>> two_sum_pairs([2, 2, 2, 2], 4) [(2, 2)]","solution":"def two_sum_pairs(arr, target): Finds all unique pairs in the array that sum up to the given target value. :param arr: List[int] - List of integers :param target: int - Target sum :return: List[Tuple[int, int]] - List of unique pairs that sum up to target pairs = set() seen = set() for num in arr: complement = target - num if complement in seen: pairs.add((min(num, complement), max(num, complement))) seen.add(num) return sorted(pairs)"},{"question":"def merge_and_sort(a: str, b: str) -> str: Merges two strings a and b into a single sorted string in non-decreasing order by alternatively picking characters from each string. :param a: First string :param b: Second string :return: Merged and sorted string >>> merge_and_sort(\\"ace\\", \\"bd\\") == \\"abcde\\" >>> merge_and_sort(\\"a\\", \\"\\") == \\"a\\" >>> merge_and_sort(\\"\\", \\"z\\") == \\"z\\" >>> merge_and_sort(\\"ace\\", \\"bdf\\") == \\"abcdef\\" >>> merge_and_sort(\\"abc\\", \\"def\\") == \\"abcdef\\" >>> merge_and_sort(\\"\\", \\"\\") == \\"\\"","solution":"def merge_and_sort(a, b): Merges two strings a and b into a single sorted string in non-decreasing order by alternatively picking characters from each string. :param a: First string :param b: Second string :return: Merged and sorted string result = [] length_a, length_b = len(a), len(b) i, j = 0, 0 while i < length_a and j < length_b: if a[i] < b[j]: result.append(a[i]) i += 1 else: result.append(b[j]) j += 1 while i < length_a: result.append(a[i]) i += 1 while j < length_b: result.append(b[j]) j += 1 return ''.join(result)"},{"question":"def evaluateExpression(expression: str) -> int: Evaluates a basic mathematical expression with non-negative integers and +, -, *, / operators considering left to right precedence, returning the result as an integer. Parameters: expression (str): The mathematical expression Returns: int: The result of the evaluation or 0 for invalid expressions Examples: >>> evaluateExpression(\\"3 + 5\\") 8 >>> evaluateExpression(\\"10 - 2\\") 8 >>> evaluateExpression(\\"2 * 3\\") 6 >>> evaluateExpression(\\"8 / 2\\") 4 >>> evaluateExpression(\\"3 + 5 - 2\\") 6 >>> evaluateExpression(\\"10 - 2 * 3\\") 24 >>> evaluateExpression(\\"6 / 2 * 3\\") 9 >>> evaluateExpression(\\"8 * 3 + 5 - 2\\") 27 >>> evaluateExpression(\\" 3 + 5 \\") 8 >>> evaluateExpression(\\"3 +\\") 0 >>> evaluateExpression(\\"5 5 +\\") 0 >>> evaluateExpression(\\"+ 3 5\\") 0 >>> evaluateExpression(\\"3 + + 5\\") 0 >>> evaluateExpression(\\"3 + 5 *\\") 0 >>> evaluateExpression(\\"\\") 0 >>> evaluateExpression(\\"three + five\\") 0 >>> evaluateExpression(\\"3 + five\\") 0 >>> evaluateExpression(\\"5 / 0\\") 0 >>> evaluateExpression(\\"5\\") 5 >>> evaluateExpression(\\"0\\") 0","solution":"def evaluateExpression(expression): Evaluates a basic mathematical expression with non-negative integers and +, -, *, / operators considering left to right precedence, returning the result as an integer. Parameters: expression (str): The mathematical expression Returns: int: The result of the evaluation import operator # Define operators ops = { '+': operator.add, '-': operator.sub, '*': operator.mul, '/': lambda x, y: int(operator.truediv(x, y)), # Ensure integer division } # Split the expression by whitespace to form tokens tokens = expression.split() # Check if the tokens form a valid expression if len(tokens) % 2 == 0: return 0 # Initialize the initial value result = 0 try: # The first token must be a number result = int(tokens[0]) # Iterate through tokens in pairs: (operator, number) for i in range(1, len(tokens), 2): op = tokens[i] num = int(tokens[i + 1]) result = ops[op](result, num) except (ValueError, KeyError, IndexError, ZeroDivisionError): return 0 return result"},{"question":"def can_place_words(grid: List[List[str]], words: List[str]) -> bool: Check if all the words in the list can be placed in the grid according to crossword rules. >>> can_place_words([ ['.', '.', '.', '.'], ['.', '.', '.', '.'], ['.', '.', '.', '.'], ['.', '.', '.', '.'] ], [\\"this\\", \\"test\\"]) True >>> can_place_words([ ['.', '.', '.', '.'], ['.', '.', '.', '.'], ['.', '.', '.', '.'], ['.', '.', '.', '.'] ], [\\"this\\", \\"tend\\"]) True >>> can_place_words([ ['.', '.', '.', '.'], ['.', '.', '.', '.'], ['.', '.', '.', '.'], ['.', '.', '.', '.'] ], [\\"this\\", \\"ten\\"]) True >>> can_place_words([ ['t', 'h', 'i', 's'], ['.', '.', '.', '.'], ['.', '.', '.', '.'], ['.', '.', '.', '.'] ], [\\"tend\\", \\"test\\"]) False >>> can_place_words([ ['t', 'h', 'i', 's'], ['.', '.', '.', '.'], ['.', '.', '.', '.'], ['.', '.', '.', '.'] ], [\\"test\\"]) True","solution":"def can_place_words(grid, words): Check if all the words in the list can be placed in the grid according to crossword rules. def can_place_word(word, row, col, direction): if direction == 'horizontal': if col + len(word) > len(grid[0]): return False for i in range(len(word)): if grid[row][col + i] not in (word[i], '.'): return False return True elif direction == 'vertical': if row + len(word) > len(grid): return False for i in range(len(word)): if grid[row + i][col] not in (word[i], '.'): return False return True def place_word(word, row, col, direction): if direction == 'horizontal': for i in range(len(word)): grid[row][col + i] = word[i] elif direction == 'vertical': for i in range(len(word)): grid[row + i][col] = word[i] for word in words: placed = False for row in range(len(grid)): for col in range(len(grid[0])): if can_place_word(word, row, col, 'horizontal'): place_word(word, row, col, 'horizontal') placed = True break if can_place_word(word, row, col, 'vertical'): place_word(word, row, col, 'vertical') placed = True break if placed: break if not placed: return False return True"},{"question":"def remove_duplicates(s: str) -> str: Given a string s consisting of lowercase English letters, repeatedly removes adjacent duplicate characters until no more such characters can be removed and returns the resultant string. Args: s (str): The input string containing only lowercase English letters. Returns: str: The string after all possible duplicate removals.","solution":"def remove_duplicates(s: str) -> str: Given a string s consisting of lowercase English letters, repeatedly removes adjacent duplicate characters until no more such characters can be removed and returns the resultant string. Args: s (str): The input string containing only lowercase English letters. Returns: str: The string after all possible duplicate removals. stack = [] for char in s: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return ''.join(stack)"},{"question":"from typing import List, Tuple def buildOrder(numProjects: int, dependencies: List[Tuple[int, int]]) -> List[int]: Generate the build order of the projects given the number of projects and the list of dependencies. >>> buildOrder(4, [(2, 1), (3, 1), (1, 0)]) [0, 1, 2, 3] or [0, 1, 3, 2] >>> buildOrder(4, [(2, 1), (3, 1), (1, 2)]) []","solution":"from collections import defaultdict, deque from typing import List, Tuple def buildOrder(numProjects: int, dependencies: List[Tuple[int, int]]) -> List[int]: in_degree = {i: 0 for i in range(numProjects)} graph = defaultdict(list) for dest, src in dependencies: graph[src].append(dest) in_degree[dest] += 1 zero_in_degree_queue = deque([k for k, v in in_degree.items() if v == 0]) topo_order = [] while zero_in_degree_queue: vertex = zero_in_degree_queue.popleft() topo_order.append(vertex) for neighbor in graph[vertex]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: zero_in_degree_queue.append(neighbor) if len(topo_order) == numProjects: return topo_order else: return []"},{"question":"def maxSumOfIncreasingSubarray(arr): Returns the sum of the contiguous non-decreasing subarray with the largest sum. If there are multiple subarrays with the same sum, the length of the longest one is preferred. >>> maxSumOfIncreasingSubarray([1]) 1 >>> maxSumOfIncreasingSubarray([1, 2, 3, 4, 5]) 15 >>> maxSumOfIncreasingSubarray([5, 4, 3, 2, 1]) 5 >>> maxSumOfIncreasingSubarray([5, 1, 2, 3, 1, 2, 3, 4]) 10 >>> maxSumOfIncreasingSubarray([1, 2, 1, 2, 1, 2, 1, 2]) 3 >>> maxSumOfIncreasingSubarray([-1, -2, -3, -4, -5]) -1 >>> maxSumOfIncreasingSubarray([]) 0","solution":"def maxSumOfIncreasingSubarray(arr): Returns the sum of the contiguous non-decreasing subarray with the largest sum. If there are multiple subarrays with the same sum, the length of the longest one is preferred. n = len(arr) if n == 0: return 0 max_sum = current_sum = arr[0] max_length = current_length = 1 for i in range(1, n): if arr[i] >= arr[i - 1]: current_sum += arr[i] current_length += 1 else: if current_sum > max_sum or (current_sum == max_sum and current_length > max_length): max_sum = current_sum max_length = current_length current_sum = arr[i] current_length = 1 if current_sum > max_sum or (current_sum == max_sum and current_length > max_length): max_sum = current_sum max_length = current_length return max_sum"},{"question":"def sunset_views(heights: List[int]) -> List[int]: Returns the list of indices of all buildings that have a sunset view in ascending order. A building has a sunset view if its height is strictly greater than all the buildings to its right. :param heights: List[int] - List of integers representing the heights of buildings. :return: List[int] - List of indices of buildings that have a sunset view in ascending order. pass # Unit tests def test_sunset_views_all_increasing(): assert sunset_views([1, 2, 3, 4]) == [3] def test_sunset_views_single_building(): assert sunset_views([10]) == [0] def test_sunset_views_constant_heights(): assert sunset_views([5, 5, 5, 5]) == [3] def test_sunset_views_varying_heights(): assert sunset_views([3, 2, 4, 6, 1, 2]) == [3, 5] def test_sunset_views_descending(): assert sunset_views([7, 6, 5, 4, 3, 2, 1]) == [0, 1, 2, 3, 4, 5, 6] def test_sunset_views_mixed_pattern(): assert sunset_views([2, 3, 1, 2, 2, 1, 7]) == [6]","solution":"def sunset_views(heights): Returns the list of indices of all buildings that have a sunset view in ascending order. A building has a sunset view if its height is strictly greater than all the buildings to its right. :param heights: List[int] - List of integers representing the heights of buildings. :return: List[int] - List of indices of buildings that have a sunset view in ascending order. sunset_view_buildings = [] max_height_so_far = float('-inf') for i in range(len(heights) - 1, -1, -1): if heights[i] > max_height_so_far: sunset_view_buildings.append(i) max_height_so_far = heights[i] return sorted(sunset_view_buildings)"},{"question":"from typing import List def find_smallest_peak(nums: List[int]) -> int: Returns the index of the smallest peak element in the array \`nums\`. A peak element is an element that is greater than its neighbors. Args: nums (List[int]): List of integers. Returns: int: Index of the smallest peak element. >>> find_smallest_peak([1, 3, 2]) 1 >>> find_smallest_peak([5, 1, 2]) 0 >>> find_smallest_peak([1, 2, 5]) 2 >>> find_smallest_peak([1, 3, 2, 4]) 1 >>> find_smallest_peak([1, 2, 6, 4, 3]) 2 >>> find_smallest_peak([1, 3, 1, 3, 1]) 1 >>> find_smallest_peak([1, 3, 1, 2, 3, 2]) 1 >>> find_smallest_peak([1, 2, 3, 4, 5]) 4 >>> find_smallest_peak([5, 4, 3, 2, 1]) 0","solution":"def find_smallest_peak(nums): Returns the index of the smallest peak element in the array \`nums\`. A peak element is an element that is greater than its neighbors. Args: nums (List[int]): List of integers. Returns: int: Index of the smallest peak element. n = len(nums) for i in range(n): if (i == 0 or nums[i] > nums[i - 1]) and (i == n - 1 or nums[i] > nums[i + 1]): return i"},{"question":"from typing import List def max_length_subarray_two_colors(arr: List[int]) -> int: You are given an array of integers where each integer represents a different color of a marble. You need to form the largest possible contiguous subarray such that no more than two distinct colors are present in the subarray. Return the length of the longest such subarray. >>> max_length_subarray_two_colors([1, 2, 1]) 3 >>> max_length_subarray_two_colors([1, 2, 3, 2, 2]) 4 >>> max_length_subarray_two_colors([3, 3, 3, 1, 2, 1, 1, 2, 3, 3, 4]) 5 >>> max_length_subarray_two_colors([]) 0 >>> max_length_subarray_two_colors([1, 1, 1, 1]) 4 >>> max_length_subarray_two_colors([1, 2, 1, 2, 1]) 5 >>> max_length_subarray_two_colors([1, 2, 1, 3, 4, 2, 3]) 3 # Your code here","solution":"def max_length_subarray_two_colors(arr): from collections import defaultdict if not arr: return 0 max_length = 0 start = 0 color_count = defaultdict(int) for end in range(len(arr)): color_count[arr[end]] += 1 while len(color_count) > 2: color_count[arr[start]] -= 1 if color_count[arr[start]] == 0: del color_count[arr[start]] start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"from typing import List def coin_change(coins: List[int], amount: int) -> int: Return the minimum number of coins needed to make up the given amount using the available denominations. If it is not possible to reach the amount with the given coins, return -1. >>> coin_change([1], 10) == 10 >>> coin_change([2], 10) == 5 >>> coin_change([3], 10) == -1 >>> coin_change([1, 2, 5], 11) == 3 >>> coin_change([2, 5, 10], 27) == 4 >>> coin_change([1, 5, 10, 25], 13) == 4 >>> coin_change([2, 5, 10], 1) == -1 >>> coin_change([2, 4], 7) == -1 >>> coin_change([5, 10], 3) == -1 >>> coin_change([1, 2, 5, 10], 100) == 10 >>> coin_change([1, 2, 5], 100) == 20","solution":"def coin_change(coins, amount): Return the fewest number of coins that you need to make up the amount. If that amount of money cannot be made up by any combination of the coins, return -1. # Create a list to store the minimum coins needed for each amount from 0 to amount dp = [float('inf')] * (amount + 1) dp[0] = 0 # Base case: 0 coins needed to make the amount 0 # Build up the dp array for coin in coins: for x in range(coin, amount + 1): dp[x] = min(dp[x], dp[x - coin] + 1) # Check if we have found a solution for the amount return dp[amount] if dp[amount] != float('inf') else -1"},{"question":"from typing import List def numOfMinutes(n: int, headID: int, manager: List[int], informTime: List[int]) -> int: Returns the total time it takes for the head to inform all employees. :param n: Number of employees :param headID: The ID of the head/CEO :param manager: Integer array where manager[i] is the direct manager of the i-th employee :param informTime: Integer array where informTime[i] is the time it takes for the i-th employee to inform all of their direct subordinates :return: Total time to inform all employees >>> numOfMinutes(1, 0, [-1], [0]) 0 >>> numOfMinutes(6, 2, [2, 2, -1, 2, 2, 2], [0, 0, 1, 0, 0, 0]) 1 >>> numOfMinutes(7, 6, [1, 2, 3, 4, 5, 6, -1], [0, 6, 5, 4, 3, 2, 1]) 21 >>> numOfMinutes(4, 0, [-1, 0, 1, 2], [1, 2, 3, 4]) 10 >>> numOfMinutes(7, 3, [3, 3, 3, -1, 2, 2, 1], [0, 1, 1, 1, 0, 0, 0]) 2","solution":"from collections import defaultdict, deque def numOfMinutes(n, headID, manager, informTime): Returns the total time it takes for the head to inform all employees. :param n: Number of employees :param headID: The ID of the head/CEO :param manager: Integer array where manager[i] is the direct manager of the i-th employee :param informTime: Integer array where informTime[i] is the time it takes for the i-th employee to inform all of their direct subordinates :return: Total time to inform all employees # Create an adjacency list to represent the hierarchy employee_tree = defaultdict(list) for i in range(n): if manager[i] != -1: employee_tree[manager[i]].append(i) # Function to perform DFS and return total inform time def dfs(employee_id): max_time = 0 for subordinate in employee_tree[employee_id]: max_time = max(max_time, dfs(subordinate)) return max_time + informTime[employee_id] return dfs(headID)"},{"question":"def remove_duplicates(nums: List[int]) -> int: Removes some duplicates in-place such that each unique element appears at most twice. Returns the new length of the array after removing the duplicates while ensuring the first part of the array contains the unique elements up to the new length in non-decreasing order. :param nums: List[int] - an integer array sorted in non-decreasing order :return: int - the new length of the array >>> remove_duplicates([1, 2, 3, 4, 5]) 5 >>> remove_duplicates([1, 1, 1, 2, 2, 3]) 5 >>> remove_duplicates([1, 1, 1, 1, 1]) 2 >>> remove_duplicates([1]) 1 >>> remove_duplicates([]) 0 pass","solution":"def remove_duplicates(nums): Removes some duplicates in-place such that each unique element appears at most twice. Returns the new length of the array after removing the duplicates while ensuring the first part of the array contains the unique elements up to the new length in non-decreasing order. :param nums: List[int] - an integer array sorted in non-decreasing order :return: int - the new length of the array if not nums: return 0 write_index = 1 count = 1 for i in range(1, len(nums)): if nums[i] == nums[i - 1]: count += 1 else: count = 1 if count <= 2: nums[write_index] = nums[i] write_index += 1 return write_index"},{"question":"def canBePalindrome(s: str) -> bool: Determine if it is possible to make \`s\` a palindrome by deleting at most one character. >>> canBePalindrome(\\"abca\\") True >>> canBePalindrome(\\"racecar\\") True >>> canBePalindrome(\\"abcdef\\") False def test_canBePalindrome(): assert canBePalindrome(\\"abca\\") == True assert canBePalindrome(\\"racecar\\") == True assert canBePalindrome(\\"abcdef\\") == False assert canBePalindrome(\\"aba\\") == True assert canBePalindrome(\\"a\\") == True assert canBePalindrome(\\"ab\\") == True assert canBePalindrome(\\"aa\\") == True assert canBePalindrome(\\"abc\\") == False assert canBePalindrome(\\"abccba\\") == True # already a palindrome assert canBePalindrome(\\"abcdba\\") == True # remove 'c' assert canBePalindrome(\\"abcd\\") == False # not possible with one removal assert canBePalindrome(\\"deeee\\") == True # already a palindrome","solution":"def canBePalindrome(s): Determine if it is possible to make \`s\` a palindrome by deleting at most one character. Args: s (str): The input string. Returns: bool: True if it is possible to make \`s\` a palindrome by deleting at most one character, otherwise False. def is_palindrome_range(i, j): Helper function to check if s is a palindrome in the range [i, j]. return all(s[k] == s[j - k + i] for k in range(i, j)) left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: # Check by removing the left character or the right character return is_palindrome_range(left + 1, right) or is_palindrome_range(left, right - 1) left += 1 right -= 1 return True"},{"question":"def josephus(n: int, k: int) -> int: Solves the Josephus problem by finding the position of the last person standing. Parameters: n (int): The number of people standing in the circle. k (int): The step count (the k-th person is executed). Returns: int: The position of the last person standing (0-indexed). >>> josephus(1, 1) 0 >>> josephus(7, 3) 3 >>> josephus(5, 2) 2 >>> josephus(10, 4) 4 >>> josephus(5, 1) 4 >>> josephus(6, 6) 3","solution":"def josephus(n, k): Solves the Josephus problem. Parameters: n (int): The number of people standing in the circle. k (int): The step count (the k-th person is executed). Returns: int: The position of the last person standing (0-indexed). if n == 1: return 0 else: return (josephus(n-1, k) + k) % n"},{"question":"def maxRectangleArea(heights: List[int]) -> int: Calculate the maximum rectangular area that can be formed within a skyline of building heights. >>> maxRectangleArea([1, 2, 3]) == 4 >>> maxRectangleArea([5]) == 5 >>> maxRectangleArea([2, 2, 2, 2]) == 8 >>> maxRectangleArea([2, 1, 5, 6, 2, 3]) == 10 >>> maxRectangleArea([5, 4, 3, 2, 1]) == 9 >>> maxRectangleArea([1, 2, 3, 4, 5]) == 9 >>> maxRectangleArea([]) == 0 >>> maxRectangleArea([0, 0, 0, 0]) == 0 pass","solution":"def maxRectangleArea(heights): Calculate the maximum rectangular area in a histogram. Args: - heights (List[int]): List of integers representing the heights of the buildings. Returns: - int: The maximum rectangular area. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"from typing import List def max_subarrays_with_same_sum(arr: List[int], k: int) -> int: Returns the maximum number of subarrays of length \`k\` that have the same sum. >>> max_subarrays_with_same_sum([1, 2, 2, 3, 1, 2], 2) 2 >>> max_subarrays_with_same_sum([1, 2, 3], 4) 0 >>> max_subarrays_with_same_sum([1, 1, 1, 1, 1, 1], 1) 6 >>> max_subarrays_with_same_sum([2, 2, 2, 2, 2, 2], 2) 5 >>> max_subarrays_with_same_sum([1, 2, 1, 2, 1, 2, 1, 2], 3) 3 >>> max_subarrays_with_same_sum([-1, -1, -1, -1, -1], 2) 4","solution":"from collections import defaultdict def max_subarrays_with_same_sum(arr, k): Returns the maximum number of subarrays of length \`k\` that have the same sum. n = len(arr) if n < k: return 0 # Dictionary to count the sums of the subarrays sum_count = defaultdict(int) # Calculate the sum of the first \`k\` elements current_sum = sum(arr[:k]) sum_count[current_sum] += 1 # Iterate over the remaining elements to count subarrays for i in range(k, n): current_sum += arr[i] - arr[i - k] sum_count[current_sum] += 1 # Find the maximum count in the dictionary return max(sum_count.values())"},{"question":"def find_peaks(arr): Finds and returns all the peak elements in the array. An element arr[i] is called a peak if it is greater than or equal to its neighbors. Formally, an element arr[i] is a peak if and only if (i == 0 or arr[i] >= arr[i-1]) and (i == n-1 or arr[i] >= arr[i+1]). >>> find_peaks([]) == [] >>> find_peaks([1]) == [1] >>> find_peaks([3, 2, 1]) == [3] >>> find_peaks([5, 5, 5, 5, 5]) == [5, 5, 5, 5, 5] >>> find_peaks([0, 2, 1, 3, 0, 5, 4, 6, 5]) == [2, 3, 5, 6] >>> find_peaks([3, 1, 2]) == [3, 2] >>> find_peaks([1, 2, 3, 4, 5]) == [5] >>> find_peaks([5, 4, 3, 2, 1]) == [5]","solution":"def find_peaks(arr): Finds and returns all the peak elements in the array. A peak element is one that is greater than or equal to its neighbors. peaks = [] if not arr: # if arr is empty, return empty list return peaks n = len(arr) for i in range(n): if (i == 0 or arr[i] >= arr[i-1]) and (i == n-1 or arr[i] >= arr[i+1]): peaks.append(arr[i]) return peaks"},{"question":"from typing import List def trap(height: List[int]) -> int: Given a list of non-negative integers representing the heights of walls, this function returns the total amount of water that can be trapped between the walls. Parameters: height (list of int): The list of heights of the walls. Returns: int: The total units of water trapped. Example: >>> trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap([2, 0, 2]) 2 def test_trap(): assert trap([]) == 0 assert trap([1, 2, 3, 4, 5]) == 0 assert trap([5, 4, 3, 2, 1]) == 0 assert trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 assert trap([0]) == 0 assert trap([1]) == 0 assert trap([2, 0, 2]) == 2 assert trap([3, 0, 0, 2, 0, 4]) == 10 assert trap([5,5,1,7,1,1,5,2,7,6]) == 23 assert trap([4, 2, 0, 3, 2, 5]) == 9","solution":"def trap(height): Given a list of non-negative integers representing the heights of walls, this function returns the total amount of water that can be trapped between the walls. Parameters: height (list of int): The list of heights of the walls. Returns: int: The total units of water trapped. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"def floating_match(patterns, text): Return a boolean array indicating whether each pattern is a floating match for any substring of the text. :param patterns: List of strings :param text: String :return: List of booleans pass # Unit tests def test_pattern_floating_match(): text = \\"abcde\\" patterns = [\\"abc\\", \\"ace\\", \\"bd\\", \\"aeb\\"] assert floating_match(patterns, text) == [True, True, True, False] def test_pattern_with_empty_text(): text = \\"\\" patterns = [\\"a\\", \\"b\\", \\"\\"] assert floating_match(patterns, text) == [False, False, True] def test_empty_patterns(): text = \\"abcde\\" patterns = [] assert floating_match(patterns, text) == [] def test_pattern_exact_match(): text = \\"abcabc\\" patterns = [\\"abc\\", \\"cab\\", \\"bca\\", \\"a\\", \\"ab\\"] assert floating_match(patterns, text) == [True, True, True, True, True] def test_no_patterns_match(): text = \\"abcdef\\" patterns = [\\"z\\", \\"gh\\", \\"xz\\"] assert floating_match(patterns, text) == [False, False, False] def test_special_characters(): text = \\"a!b@c#de\\" patterns = [\\"!@\\", \\"#\\", \\"a!e\\"] assert floating_match(patterns, text) == [True, True, True]","solution":"def floating_match(patterns, text): Return a boolean array indicating whether each pattern is a floating match for any substring of the text. :param patterns: List of strings :param text: String :return: List of booleans def is_subsequence(pattern, text): Helper function to check if pattern is a subsequence of text. it = iter(text) return all(char in it for char in pattern) result = [] for pattern in patterns: result.append(is_subsequence(pattern, text)) return result"},{"question":"class Node: def __init__(self, val=None, children=None): self.val = val self.children = children if children is not None else [] def level_order(root): Returns the level order traversal of an n-ary tree. :param root: Root node of the n-ary tree. :return: List of lists, where each list contains the values of nodes at that level. >>> level_order(None) [] >>> root = Node(1) >>> level_order(root) [[1]] >>> root = Node(1, [ >>> Node(2), >>> Node(3, [ >>> Node(6), >>> Node(7) >>> ]), >>> Node(4, [ >>> Node(8), >>> Node(9) >>> ]), >>> Node(5) >>> ]) >>> level_order(root) [[1], [2, 3, 4, 5], [6, 7, 8, 9]] >>> root = Node(1, [ >>> Node(2), >>> Node(3), >>> Node(4) >>> ]) >>> level_order(root) [[1], [2, 3, 4]] >>> root = Node(1, [ >>> Node(2), >>> Node(3, [ >>> Node(6) >>> ]), >>> Node(4, [ >>> Node(7, [ >>> Node(9) >>> ]), >>> Node(8) >>> ]) >>> ]) >>> level_order(root) [[1], [2, 3, 4], [6, 7, 8], [9]]","solution":"class Node: def __init__(self, val=None, children=None): self.val = val self.children = children if children is not None else [] def level_order(root): Returns the level order traversal of an n-ary tree. :param root: Root node of the n-ary tree. :return: List of lists, where each list contains the values of nodes at that level. if not root: return [] results, queue = [], [root] while queue: level = [] next_queue = [] for node in queue: level.append(node.val) next_queue.extend(node.children) results.append(level) queue = next_queue return results"},{"question":"def reduce_consecutive_characters(s: str, k: int) -> str: Reduces every character that appears more than \`k\` times consecutively to exactly \`k\` occurrences. Parameters: s (str): Input string consisting of lowercase letters. k (int): Maximum allowed consecutive occurrences of any character. Returns: str: The modified string after reduction. >>> reduce_consecutive_characters(\\"abcdef\\", 2) 'abcdef' >>> reduce_consecutive_characters(\\"aaaabbbb\\", 1) 'ab' >>> reduce_consecutive_characters(\\"aabbccddeeeeffff\\", 2) 'aabbccddeeff' >>> reduce_consecutive_characters(\\"aaaa\\", 3) 'aaa' >>> reduce_consecutive_characters(\\"aabbaa\\", 2) 'aabbaa' >>> reduce_consecutive_characters(\\"abcabcabc\\", 3) 'abcabcabc'","solution":"def reduce_consecutive_characters(s, k): Reduces every character that appears more than \`k\` times consecutively to exactly \`k\` occurrences. Parameters: s (str): Input string consisting of lowercase letters. k (int): Maximum allowed consecutive occurrences of any character. Returns: str: The modified string after reduction. result = [] count = 1 for i in range(1, len(s) + 1): if i < len(s) and s[i] == s[i - 1]: count += 1 else: result.append(s[i - 1] * min(count, k)) count = 1 return ''.join(result)"},{"question":"def is_prime(n: int) -> bool: Check if a number n is a prime number. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(29) True def primes_from_list(lst: List[int]) -> List[int]: Returns a list of prime numbers from the given list. >>> primes_from_list([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) [2, 3, 5, 7] >>> primes_from_list([11, 13, 17, 19, 23, 29, 31, 37, 41]) [11, 13, 17, 19, 23, 29, 31, 37, 41] >>> primes_from_list([4, 6, 8, 10, 12]) [] >>> primes_from_list([0, -1, -3, -4, 5]) [5] >>> primes_from_list([]) []","solution":"def is_prime(n): Check if a number n is a prime number. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def primes_from_list(lst): Returns a list of prime numbers from the given list. return [num for num in lst if is_prime(num)]"},{"question":"def find_three_elements_sum_to_x(arr, x): Given an array of integers arr and an integer x, return True if there are three elements in arr that sum up to x, else return False. >>> find_three_elements_sum_to_x([1, 4, 45, 6, 10, 8], 22) == True >>> find_three_elements_sum_to_x([-1, -4, 1, 3, 2, 0], 0) == True >>> find_three_elements_sum_to_x([1, 2, 3, 4, 5, 6], 15) == True >>> find_three_elements_sum_to_x([1, 2, 3, 4, 5, 6], 100) == False >>> find_three_elements_sum_to_x([1, 4, 45, 6, 10, 8], 100) == False >>> find_three_elements_sum_to_x([], 10) == False >>> find_three_elements_sum_to_x([1], 10) == False >>> find_three_elements_sum_to_x([1, 2], 10) == False >>> find_three_elements_sum_to_x([1, 2, 3], 6) == True >>> find_three_elements_sum_to_x([1, 0, -1], 0) == True","solution":"def find_three_elements_sum_to_x(arr, x): Given an array of integers arr and an integer x, returns true if there are three elements in arr that sum up to x, else false. arr.sort() # First, sort the array n = len(arr) for i in range(n - 2): left, right = i + 1, n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == x: return True elif current_sum < x: left += 1 else: right -= 1 return False"},{"question":"from typing import List def findAnagrams(s: str, dict: List[str]) -> List[int]: Find all the starting indices of dict's words' anagrams in s. >>> findAnagrams(\\"cbaebabacd\\", [\\"abc\\", \\"bac\\"]) [0, 6] >>> findAnagrams(\\"abab\\", [\\"ab\\"]) [0, 1, 2] >>> findAnagrams(\\"\\", [\\"abc\\"]) [] >>> findAnagrams(\\"abcdefgh\\", [\\"xyz\\"]) []","solution":"from typing import List from collections import Counter def findAnagrams(s: str, dict: List[str]) -> List[int]: res = [] dict_counter = [Counter(word) for word in dict] word_length = len(dict[0]) for i in range(len(s) - word_length + 1): substr = s[i:i+word_length] substr_counter = Counter(substr) if any(substr_counter == d_counter for d_counter in dict_counter): res.append(i) return res"},{"question":"def h_index(citations: List[int]) -> int: Returns the h-index for a given list of citations. The h-index is defined as the maximum value of h such that there are h papers with at least h citations each. :param citations: List[int] - a list of integers representing the number of citations of each paper :return: int - the h-index >>> h_index([3, 0, 6, 1, 5]) 3 >>> h_index([0, 0, 0, 0, 0]) 0 >>> h_index([5, 5, 5, 5, 5]) 5 >>> h_index([1, 2, 3, 4, 5]) 3 >>> h_index([10]) 1 >>> h_index([10, 8]) 2","solution":"def h_index(citations): Returns the h-index for a given list of citations. The h-index is defined as the maximum value of h such that there are h papers with at least h citations each. :param citations: List[int] - a list of integers representing the number of citations of each paper :return: int - the h-index citations.sort(reverse=True) h = 0 for i, c in enumerate(citations): if c >= i + 1: h = i + 1 else: break return h"},{"question":"from typing import List def shortest_substring_with_all_distinct_chars(s: str) -> int: Determine the length of the shortest substring of \`s\` that contains all the distinct characters present in the entire string \`s\`. If \`s\` contains no characters, return \`0\`. >>> shortest_substring_with_all_distinct_chars(\\"abac\\") 3 >>> shortest_substring_with_all_distinct_chars(\\"\\") 0 >>> shortest_substring_with_all_distinct_chars(\\"a\\") 1 >>> shortest_substring_with_all_distinct_chars(\\"aaaa\\") 1 >>> shortest_substring_with_all_distinct_chars(\\"abcdef\\") 6 >>> shortest_substring_with_all_distinct_chars(\\"qwerty\\") 6 >>> shortest_substring_with_all_distinct_chars(\\"aabcdbc\\") 4 >>> shortest_substring_with_all_distinct_chars(\\"aabcbc\\") 3 >>> shortest_substring_with_all_distinct_chars(\\"abcabcabc\\") 3","solution":"def shortest_substring_with_all_distinct_chars(s): from collections import defaultdict if not s: return 0 n = len(s) distinct_chars = set(s) required_char_count = len(distinct_chars) left = 0 right = 0 min_length = float('inf') current_char_count = defaultdict(int) formed = 0 while right < n: char = s[right] current_char_count[char] += 1 if current_char_count[char] == 1: formed += 1 while left <= right and formed == required_char_count: if right - left + 1 < min_length: min_length = right - left + 1 char = s[left] current_char_count[char] -= 1 if current_char_count[char] == 0: formed -= 1 left += 1 right += 1 return min_length"},{"question":"from typing import List def shortest_path(grid: List[List[int]]) -> int: Finds the shortest path from the top-left to the bottom-right corner of the grid by only traveling through roads (cells with value 2). Returns the length of the path or -1 if it's not possible to reach the destination. >>> shortest_path([ ... [2, 1, 0], ... [0, 1, 2], ... [2, 0, 0] ... ]) == -1 >>> shortest_path([ ... [2, 2, 2], ... [2, 1, 2], ... [2, 2, 2] ... ]) == 4 >>> shortest_path([ ... [2] ... ]) == 0 >>> shortest_path([ ... [0] ... ]) == -1 >>> shortest_path([ ... [2, 2, 1, 0, 2], ... [2, 1, 1, 2, 2], ... [2, 2, 2, 2, 2], ... [1, 1, 1, 1, 2], ... [2, 2, 2, 2, 2] ... ]) == 8 >>> shortest_path([ ... [0, 1, 0], ... [1, 0, 1], ... [0, 1, 0] ... ]) == -1 >>> shortest_path([ ... [0, 2, 2], ... [2, 2, 2], ... [2, 2, 1] ... ]) == -1 pass","solution":"from collections import deque def shortest_path(grid): Finds the shortest path from the top-left to the bottom-right corner of the grid by only traveling through roads (cells with value 2). Returns the length of the path or -1 if it's not possible to reach the destination. if not grid or grid[0][0] != 2 or grid[-1][-1] != 2: return -1 m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if (x, y) == (m-1, n-1): return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 2 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"def max_number_of_different_candies(arr: List[int]) -> int: Returns the maximum number of different kinds of candies Alice can eat by following the rules. >>> max_number_of_different_candies([1, 1, 1, 1, 1, 1]) == 1 >>> max_number_of_different_candies([1, 2, 3, 4, 5, 6]) == 3 >>> max_number_of_different_candies([1, 1, 2, 2, 3, 3]) == 3 >>> max_number_of_different_candies([1, 2, 3, 4, 5, 6, 7, 8]) == 4 >>> max_number_of_different_candies([1, 2, 2, 3, 3, 4]) == 3","solution":"def max_number_of_different_candies(arr): Returns the maximum number of different kinds of candies Alice can eat by following the rules. unique_candies = set(arr) max_possible_candies = len(arr) // 2 return min(len(unique_candies), max_possible_candies)"},{"question":"def word_break(s: str, wordDict: set) -> bool: Determine if the string s can be segmented into a space-separated sequence of one or more dictionary words. >>> word_break(\\"leetcode\\", {\\"leet\\", \\"code\\"}) True >>> word_break(\\"applepenapple\\", {\\"apple\\", \\"pen\\"}) True >>> word_break(\\"catsandog\\", {\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"}) False >>> word_break(\\"\\", {\\"leet\\", \\"code\\"}) True >>> word_break(\\"hello\\", {\\"cat\\", \\"dog\\"}) False >>> word_break(\\"a\\", {\\"a\\"}) True >>> word_break(\\"appleapple\\", {\\"apple\\"}) True","solution":"def word_break(s, wordDict): Determine if the string s can be segmented into a space-separated sequence of one or more dictionary words. Parameters: s (str): The string to be segmented. wordDict (set): The set of words to be used for segmentation. Returns: bool: True if the string can be segmented, False otherwise. dp = [False] * (len(s) + 1) dp[0] = True # an empty string can always be segmented for i in range(1, len(s) + 1): for j in range(i): if dp[j] and s[j:i] in wordDict: dp[i] = True break return dp[len(s)]"},{"question":"def findSubstring(s: str, words: List[str]) -> List[int]: Given a string s and an array of strings words, return the starting index of each concatenated substring in s. The output should be an array of starting indices in ascending order. If no such starting index exists, return an empty array. >>> findSubstring(\\"barfoothefoobarman\\", [\\"foo\\", \\"bar\\"]) [0, 9] >>> findSubstring(\\"wordgoodgoodgoodbestword\\", [\\"word\\",\\"good\\",\\"best\\",\\"word\\"]) [] >>> findSubstring(\\"wordgoodgoodgoodbestword\\", [\\"good\\"]) [4, 8, 12] >>> findSubstring(\\"\\", [\\"foo\\",\\"bar\\"]) [] >>> findSubstring(\\"barfoothefoobarman\\", []) [] >>> findSubstring(\\"short\\", [\\"longerword\\"]) [] >>> findSubstring(\\"randomstring\\", [\\"foo\\",\\"barbaz\\"]) []","solution":"def findSubstring(s, words): from collections import Counter if not s or not words or not words[0]: return [] word_length = len(words[0]) num_words = len(words) total_length = word_length * num_words word_count = Counter(words) result = [] for i in range(len(s) - total_length + 1): seen = Counter() for j in range(num_words): word_start = i + j * word_length word = s[word_start:word_start + word_length] if word not in word_count: break seen[word] += 1 if seen[word] > word_count[word]: break if seen == word_count: result.append(i) return result"},{"question":"def is_palindrome(s): Helper function to check if a given string is a palindrome. return s == s[::-1] def can_split_into_two_palindromes(s: str) -> bool: Given a string 's', split 's' into at most two palindromic substrings. Return 'true' if it is possible to split 's' such that both substrings are palindromes and 'false' otherwise. A string is a palindrome if it reads the same forward and backward. >>> can_split_into_two_palindromes(\\"abba\\") == True >>> can_split_into_two_palindromes(\\"racecar\\") == True >>> can_split_into_two_palindromes(\\"abcd\\") == False >>> can_split_into_two_palindromes(\\"aabbcc\\") == False >>> can_split_into_two_palindromes(\\"ababa\\") == True >>> can_split_into_two_palindromes(\\"aabbbaa\\") == True >>> can_split_into_two_palindromes(\\"noonb\\") == True >>> can_split_into_two_palindromes(\\"a\\") == True >>> can_split_into_two_palindromes(\\"aa\\") == True >>> can_split_into_two_palindromes(\\"ab\\") == True >>> can_split_into_two_palindromes(\\"\\") == True","solution":"def is_palindrome(s): Helper function to check if a given string is a palindrome. return s == s[::-1] def can_split_into_two_palindromes(s): Checks if the string 's' can be split into at most two palindromic substrings. n = len(s) for i in range(1, n): # We iterate from 1 to n-1 to get all possible splits if is_palindrome(s[:i]) and is_palindrome(s[i:]): return True return is_palindrome(s) # Check if the entire string itself is a palindrome # Example usage: # print(can_split_into_two_palindromes(\\"ababa\\")) # True # print(can_split_into_two_palindromes(\\"abcd\\")) # False"},{"question":"def max_items_within_budget(prices: List[int], budget: int) -> int: Determine the maximum number of items that can be purchased without exceeding the budget. :param prices: List of integers representing the prices of items. :param budget: Integer representing the budget limit. :return: Integer representing the maximum number of items that can be purchased. >>> max_items_within_budget([1, 3, 2, 5, 4], 7) 3 >>> max_items_within_budget([10, 2, 8, 6, 7], 20) 3 >>> max_items_within_budget([5, 5, 5, 5, 5], 10) 2 >>> max_items_within_budget([1, 2, 3], 0) 0 >>> max_items_within_budget([1, 2, 3, 4, 5], 15) 5 >>> max_items_within_budget([1], 1) 1 >>> max_items_within_budget([], 10) 0 >>> max_items_within_budget([4, 5, 6], 3) 0","solution":"def max_items_within_budget(prices, budget): Returns the maximum number of items that can be purchased without exceeding the budget. :param prices: List of integers representing the prices of items. :param budget: Integer representing the budget limit. :return: Integer representing the maximum number of items that can be purchased. prices.sort() total_cost = 0 items_count = 0 for price in prices: if total_cost + price <= budget: total_cost += price items_count += 1 else: break return items_count"},{"question":"def replace_asterisks(s: str) -> str: Replaces each '*' in the string with a lowercase letter such that the resulting string does not contain any consecutive repeated letters. >>> result = replace_asterisks(\\"a*\\") >>> '*' not in result and \\"aa\\" not in result True >>> result = replace_asterisks(\\"*a\\") >>> '*' not in result and \\"aa\\" not in result True >>> result = replace_asterisks(\\"ab*cd*ef\\") >>> '*' not in result and \\"aa\\" not in result True >>> result = replace_asterisks(\\"*a*b*c*\\") >>> '*' notnia else. Solution: def replace_asterisks(s: str) -> str: Replaces each '*' in the string with a lowercase letter such that the resulting string does not contain any consecutive repeated letters. n = len(s) s = list(s) for i in range(n): if s[i] == '*': for c in 'abcdefghijklmnopqrstuvwxyz': if (i > 0 and s[i-1] == c) or (i < n-1 and s[i+1] == c): continue s[i] = c break return ''.join(s) from solution import replace_asterisks def test_single_asterisk(): assert replace_asterisks(\\"a*\\") != \\"aa\\" assert replace_asterisks(\\"*a\\") != \\"aa\\" def test_multiple_asterisks(): result = replace_asterisks(\\"ab*cd*ef\\") assert '*' not in result assert \\"aa\\" not in result result = replace_asterisks(\\"*a*b*c*\\") assert '*' not in result assert \\"aa\\" not in result is a matrix where the first dimension has size 6 and the second dimension has a size equal to the length of each row in v_eq. Thus, the resulting matrix dimensions will be \`[6 x len(v_eq[0])]\`. In this example problem, we don't know the exact size of the second dimension because we don't have the value of \`v_eq\`, but it's required that you derive the general form based on the variable \`v_eq\`. Here's the completion task in the required format.","solution":"def replace_asterisks(s): Replaces each '*' in the string with a lowercase letter such that the resulting string does not contain any consecutive repeated letters. n = len(s) s = list(s) for i in range(n): if s[i] == '*': for c in 'abcdefghijklmnopqrstuvwxyz': if (i > 0 and s[i-1] == c) or (i < n-1 and s[i+1] == c): continue s[i] = c break return ''.join(s)"},{"question":"def find_consecutive_sequences(nums: List[int]) -> List[List[int]]: Write a function that takes a list of integers and returns a list of lists where each sublist represents a sequence of consecutive integers from the original list. >>> find_consecutive_sequences([1, 2, 3, 6, 7, 8, 10, 11]) [[1, 2, 3], [6, 7, 8], [10, 11]] >>> find_consecutive_sequences([4, 5, 10, 11, 12, 15]) [[4, 5], [10, 11, 12], [15]] >>> find_consecutive_sequences([10, 11, 15, 16, 18, 19, 20]) [[10, 11], [15, 16], [18, 19, 20]] >>> find_consecutive_sequences([1, 3, 5, 7]) [[1], [3], [5], [7]] >>> find_consecutive_sequences([]) [] >>> find_consecutive_sequences([5]) [[5]] >>> find_consecutive_sequences([0]) [[0]] >>> find_consecutive_sequences([1, 2, 3, 4, 5]) [[1, 2, 3, 4, 5]] pass","solution":"def find_consecutive_sequences(nums): if not nums: return [] sequences = [] current_sequence = [nums[0]] for i in range(1, len(nums)): if nums[i] == nums[i - 1] + 1: current_sequence.append(nums[i]) else: sequences.append(current_sequence) current_sequence = [nums[i]] sequences.append(current_sequence) # Add the last sequence return sequences"},{"question":"def length_of_longest_substring(word: str) -> int: Returns the length of the longest substring with all unique characters. Parameters: word (str): Input string Returns: int: Length of the longest substring with all unique characters >>> length_of_longest_substring('') == 0 >>> length_of_longest_substring('abcde') == 5 >>> length_of_longest_substring('aaaa') == 1 >>> length_of_longest_substring('abcabcbb') == 3 >>> length_of_longest_substring('abcd1234abcd') == 8 >>> length_of_longest_substring('a') == 1 >>> length_of_longest_substring('abccdefgh') == 6","solution":"def length_of_longest_substring(word): Returns the length of the longest substring with all unique characters. Parameters: word (str): Input string Returns: int: Length of the longest substring with all unique characters if not word: return 0 char_index = {} max_length = 0 start = 0 for i, char in enumerate(word): if char in char_index and char_index[char] >= start: start = char_index[char] + 1 char_index[char] = i max_length = max(max_length, i - start + 1) return max_length"},{"question":"from typing import List def shortest_distance_from_empty_to_all_houses(grid: List[List[int]]) -> int: Find the shortest distance from an empty cell to reach all houses. Parameters: grid (List[List[int]]): A matrix representing cells (\`0\` for empty, \`1\` for house, \`2\` for obstacle) Returns: int: The minimum distance from an empty cell to all houses, or -1 if not possible. Examples: >>> grid = [ ... [1, 0, 2, 0, 1], ... [0, 0, 0, 0, 0], ... [0, 0, 1, 0, 0] ... ] >>> shortest_distance_from_empty_to_all_houses(grid) 7 >>> grid = [ ... [1, 0], ... [0, 0] ... ] >>> shortest_distance_from_empty_to_all_houses(grid) 1 >>> grid = [ ... [0, 0], ... [0, 0] ... ] >>> shortest_distance_from_empty_to_all_houses(grid) -1 >>> grid = [ ... [2, 2, 2], ... [2, 1, 2], ... [2, 2, 2] ... ] >>> shortest_distance_from_empty_to_all_houses(grid) -1 >>> grid = [ ... [1, 2], ... [2, 1] ... ] >>> shortest_distance_from_empty_to_all_houses(grid) -1","solution":"from collections import deque from itertools import product def shortest_distance_from_empty_to_all_houses(grid): def bfs(start_row, start_col): visited = [[False] * len(grid[0]) for _ in range(len(grid))] distance = [[0] * len(grid[0]) for _ in range(len(grid))] queue = deque([(start_row, start_col, 0)]) visit_count = 0 while queue: row, col, dist = queue.popleft() if visited[row][col]: continue visited[row][col] = True distance[row][col] = dist for d_row, d_col in [(0, 1), (1, 0), (0, -1), (-1, 0)]: n_row, n_col = row + d_row, col + d_col if 0 <= n_row < len(grid) and 0 <= n_col < len(grid[0]) and not visited[n_row][n_col] and grid[n_row][n_col] != 2: queue.append((n_row, n_col, dist + 1)) return [[distance[r][c] for c in range(len(grid[0]))] for r in range(len(grid))] house_count = sum(grid[r][c] == 1 for r, c in product(range(len(grid)), range(len(grid[0])))) if house_count == 0: return -1 # No houses to consider dist_sum = [[0] * len(grid[0]) for _ in range(len(grid))] house_reach = [[0] * len(grid[0]) for _ in range(len(grid))] for r, c in product(range(len(grid)), range(len(grid[0]))): if grid[r][c] == 1: # BFS from each house house_distances = bfs(r, c) for i, j in product(range(len(grid)), range(len(grid[0]))): if grid[i][j] == 0 and house_distances[i][j] != 0: dist_sum[i][j] += house_distances[i][j] house_reach[i][j] += 1 min_dist = float('inf') for r, c in product(range(len(grid)), range(len(grid[0]))): if grid[r][c] == 0 and house_reach[r][c] == house_count: min_dist = min(min_dist, dist_sum[r][c]) return min_dist if min_dist != float('inf') else -1"},{"question":"def merge_strings(s1: str, s2: str) -> str: Merge two strings s1 and s2 into a new string by following these conditions: 1. You start with an empty string \`s\`. 2. You choose one of the two strings (\`s1\` or \`s2\`) and append the next character from this string to \`s\`. 3. Once you switch from appending characters from \`s1\` to \`s2\` (or vice versa), you cannot switch back again. The function should return the lexicographically smallest string \`s\` possible by merging \`s1\` and \`s2\` following these rules. >>> merge_strings(\\"abc\\", \\"xyz\\") 'abcxyz' >>> merge_strings(\\"ace\\", \\"bdf\\") 'abcdef' >>> merge_strings(\\"abc\\", \\"abd\\") 'aabbcd' >>> merge_strings(\\"\\", \\"abc\\") 'abc' >>> merge_strings(\\"abc\\", \\"\\") 'abc' >>> merge_strings(\\"kkk\\", \\"a\\") 'akkk' >>> merge_strings(\\"k\\", \\"k\\") 'kk' pass # Add your implementation here","solution":"def merge_strings(s1, s2): n1, n2 = len(s1), len(s2) i, j = 0, 0 merged_string = [] while i < n1 and j < n2: if s1[i:] <= s2[j:]: merged_string.append(s1[i]) i += 1 else: merged_string.append(s2[j]) j += 1 if i < n1: merged_string.extend(s1[i:]) if j < n2: merged_string.extend(s2[j:]) return ''.join(merged_string)"},{"question":"from typing import List, Tuple def min_area_rect(points: List[Tuple[int, int]]) -> int: Returns the area of the smallest rectangle that can be formed by any four of these points such that the sides of the rectangle are parallel to the x and y axes. If no such rectangle exists, returns 0. >>> min_area_rect([(0, 0), (1, 1)]) 0 >>> min_area_rect([(0, 0), (0, 1), (1, 0), (1, 1)]) 1 >>> min_area_rect([(0, 0), (0, 2), (3, 0), (3, 2)]) 6 >>> min_area_rect([(1, 1), (1, 3), (3, 3), (3, 1), (2, 2), (4, 4), (4, 1), (1, 4)]) 4 >>> min_area_rect([(0, 1), (2, 3), (1, 4), (3, 2)]) 0 >>> min_area_rect([(1, 1), (1, 3), (3, 3), (3, 1), (2, 2), (4, 4), (4, 1), (1, 4), (2, 3), (2, 1)]) 2","solution":"def min_area_rect(points): Returns the area of the smallest rectangle that can be formed by any four of these points such that the sides of the rectangle are parallel to the x and y axes. If no such rectangle exists, returns 0. if len(points) < 4: return 0 point_set = set(points) min_area = float('inf') found = False for i in range(len(points)): for j in range(i + 1, len(points)): (x1, y1) = points[i] (x2, y2) = points[j] if x1 != x2 and y1 != y2: # need to check for diagonal points if (x1, y2) in point_set and (x2, y1) in point_set: area = abs((x2 - x1) * (y2 - y1)) min_area = min(min_area, area) found = True return min_area if found else 0"},{"question":"def sum_matrix(mat): Returns a new matrix res where res[i][j] is the sum of elements in the submatrix from (0,0) to (i,j) for a given m x n matrix. >>> sum_matrix([[5]]) == [[5]] True >>> sum_matrix([[1, 2],[3, 4]]) == [[1, 3],[4, 10]] True >>> sum_matrix([[1, 2, 3],[4, 5, 6],[7, 8, 9]]) == [[1, 3, 6],[5, 12, 21],[12, 27, 45]] True >>> sum_matrix([[0, 0, 0],[0, 0, 0],[0, 0, 0]]) == [[0, 0, 0],[0, 0, 0],[0, 0, 0]] True >>> sum_matrix([[-1, -2, -3],[-4, -5, -6],[-7, -8, -9]]) == [[-1, -3, -6],[-5, -12, -21],[-12, -27, -45]] True","solution":"def sum_matrix(mat): Returns a new matrix res where res[i][j] is the sum of elements in the submatrix from (0,0) to (i,j) for a given m x n matrix. m = len(mat) n = len(mat[0]) res = [[0] * n for _ in range(m)] for i in range(m): for j in range(n): res[i][j] = mat[i][j] if i > 0: res[i][j] += res[i - 1][j] if j > 0: res[i][j] += res[i][j - 1] if i > 0 and j > 0: res[i][j] -= res[i - 1][j - 1] return res"},{"question":"def first_non_repeating_char(s: str) -> str: Given a string \`str\` consisting of lowercase English letters, return the first non-repeating character in it. If there are no non-repeating characters, return an empty string. >>> first_non_repeating_char(\\"swiss\\") == \\"w\\" True >>> first_non_repeating_char(\\"aabbcc\\") == \\"\\" True >>> first_non_repeating_char(\\"a\\") == \\"a\\" True >>> first_non_repeating_char(\\"abcdef\\") == \\"a\\" True >>> first_non_repeating_char(\\"abac\\") == \\"b\\" True >>> first_non_repeating_char(\\"aabbc\\") == \\"c\\" True","solution":"def first_non_repeating_char(s): Returns the first non-repeating character in the string s. If there is no non-repeating character, returns an empty string. char_count = {} # Count the occurrences of each character for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find the first character with a count of 1 for char in s: if char_count[char] == 1: return char return \\"\\" # Example test case s = \\"swiss\\" print(first_non_repeating_char(s)) # Output: \\"w\\""},{"question":"import heapq from typing import List def kthSmallest(matrix: List[List[int]], k: int) -> int: Given a 2D integer array \`matrix\`, where each of the rows is sorted in ascending order, find the \`k-th smallest\` element in the matrix. >>> kthSmallest([[1, 5, 9], [10, 11, 13], [12, 13, 15]], 8) 13 >>> kthSmallest([[1, 2], [1, 3]], 2) 1","solution":"import heapq def kthSmallest(matrix, k): n = len(matrix) min_heap = [] # Initialize the heap with the first element of each row for r in range(min(n, k)): heapq.heappush(min_heap, (matrix[r][0], r, 0)) # Extract-min k times while k: element, r, c = heapq.heappop(min_heap) if c + 1 < n: heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1)) k -= 1 return element"},{"question":"def merge_sorted_arrays(nums1: List[int], nums2: List[int]) -> List[int]: Merges two sorted arrays into one sorted array. >>> merge_sorted_arrays([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_arrays([], []) [] >>> merge_sorted_arrays([1, 2, 3], []) [1, 2, 3] >>> merge_sorted_arrays([], [4, 5, 6]) [4, 5, 6] >>> merge_sorted_arrays([1, 2, 2], [2, 3, 3]) [1, 2, 2, 2, 3, 3] >>> merge_sorted_arrays([-3, -2, -1], [-5, -4, 0]) [-5, -4, -3, -2, -1, 0] >>> merge_sorted_arrays([1, 4, 7], [2, 5, 8]) [1, 2, 4, 5, 7, 8]","solution":"def merge_sorted_arrays(nums1, nums2): Merges two sorted arrays into one sorted array without using extra memory. Parameters: nums1 (list of int): First sorted array. nums2 (list of int): Second sorted array. Returns: list of int: Merged sorted array. i, j = 0, 0 merged_array = [] # Traverse both arrays and merge them into a single sorted array while i < len(nums1) and j < len(nums2): if nums1[i] <= nums2[j]: merged_array.append(nums1[i]) i += 1 else: merged_array.append(nums2[j]) j += 1 # Append remaining elements from nums1 while i < len(nums1): merged_array.append(nums1[i]) i += 1 # Append remaining elements from nums2 while j < len(nums2): merged_array.append(nums2[j]) j += 1 return merged_array"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def min_processing_time(root: TreeNode) -> int: Returns the minimum total processing time required to traverse from the root to any leaf node in the binary tree. >>> root = TreeNode(5) >>> min_processing_time(root) 5 >>> root = TreeNode(1, TreeNode(2, TreeNode(3))) >>> min_processing_time(root) 6 >>> root = TreeNode(1, None, TreeNode(2, None, TreeNode(3))) >>> min_processing_time(root) 6 >>> root = TreeNode(1, TreeNode(2), TreeNode(3)) >>> min_processing_time(root) 3 >>> root = TreeNode(1, ... TreeNode(2, TreeNode(4)), ... TreeNode(3, TreeNode(5), TreeNode(6))) >>> min_processing_time(root) 7 >>> root = TreeNode(4, ... TreeNode(2, TreeNode(1)), ... TreeNode(7, None, TreeNode(8))) >>> min_processing_time(root) 7","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def min_processing_time(root: TreeNode) -> int: Returns the minimum total processing time required to traverse from the root to any leaf node in the binary tree. if not root: return 0 if not root.left and not root.right: return root.value left_time = right_time = float('inf') if root.left: left_time = min_processing_time(root.left) if root.right: right_time = min_processing_time(root.right) return root.value + min(left_time, right_time)"},{"question":"def complex_number_multiply(num1: str, num2: str) -> str: Multiplies two complex numbers given as strings and returns the result as a string. >>> complex_number_multiply(\\"1+1i\\", \\"1+1i\\") \\"0+2i\\" >>> complex_number_multiply(\\"1+-1i\\", \\"1+-1i\\") \\"0+-2i\\" >>> complex_number_multiply(\\"1+0i\\", \\"0+1i\\") \\"0+1i\\" >>> complex_number_multiply(\\"-1+-1i\\", \\"-1+-1i\\") \\"0+2i\\" >>> complex_number_multiply(\\"0+1i\\", \\"0+1i\\") \\"-1+0i\\" >>> complex_number_multiply(\\"0+0i\\", \\"0+0i\\") \\"0+0i\\" >>> complex_number_multiply(\\"3+2i\\", \\"1+7i\\") \\"-11+23i\\" >>> complex_number_multiply(\\"-3+2i\\", \\"-1+7i\\") \\"-11+-23i\\" >>> complex_number_multiply(\\"0+1i\\", \\"1+0i\\") \\"0+1i\\" >>> complex_number_multiply(\\"1+0i\\", \\"1+0i\\") \\"1+0i\\" >>> complex_number_multiply(\\"1+1i\\", \\"1+0i\\") \\"1+1i\\"","solution":"def complex_number_multiply(num1, num2): Multiplies two complex numbers given as strings and returns the result as a string. def parse_complex_number(num): a, b = num[:-1].split('+') return int(a), int(b) a1, b1 = parse_complex_number(num1) a2, b2 = parse_complex_number(num2) real_part = a1 * a2 - b1 * b2 imaginary_part = a1 * b2 + b1 * a2 return f\\"{real_part}+{imaginary_part}i\\""},{"question":"def max_subarray_sum(nums): Returns the maximum sum of elements in any contiguous subarray. If the array contains only negative numbers, the largest element is returned. Utilizes Kadane's Algorithm. >>> max_subarray_sum([5]) 5 >>> max_subarray_sum([-1]) -1 >>> max_subarray_sum([1, 2, 3, 4, 5]) 15 >>> max_subarray_sum([-1, -2, -3, -4, -5]) -1 >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([]) Traceback (most recent call last): ... ValueError: Input array cannot be empty >>> max_subarray_sum([5, 4, -1, 7, 8]) 23 >>> max_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]) 7 >>> max_subarray_sum([-2, -3, 4, -1, 2, 1, -5, 4]) 6","solution":"def max_subarray_sum(nums): Returns the maximum sum of elements in any contiguous subarray. If the array contains only negative numbers, the largest element is returned. Utilizes Kadane's Algorithm. if not nums: raise ValueError(\\"Input array cannot be empty\\") current_sum = max_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"import heapq from typing import List class RoomAllocator: def __init__(self, events: List[List[int]]): Initializes the RoomAllocator with a list of events. :param events: A list of events represented by their start and end times. self.events = events def minimumRoomsRequired(self) -> int: Returns the minimum number of rooms required to accommodate all events without overlap. Example: >>> RoomAllocator([]).minimumRoomsRequired() 0 >>> RoomAllocator([[1, 2]]).minimumRoomsRequired() 1 >>> RoomAllocator([[1, 2], [3, 4], [5, 6]]).minimumRoomsRequired() 1 >>> RoomAllocator([[1, 4], [2, 5], [3, 6]]).minimumRoomsRequired() 3","solution":"import heapq class RoomAllocator: def __init__(self, events): self.events = events def minimumRoomsRequired(self): if not self.events: return 0 # Sort events by their start time self.events.sort(key=lambda x: x[0]) # Initialize a min-heap min_heap = [] # Add the end time of the first event heapq.heappush(min_heap, self.events[0][1]) # Iterate over the remaining events for i in range(1, len(self.events)): # If the current event starts after the earliest ending event, they can share the room if self.events[i][0] >= min_heap[0]: heapq.heappop(min_heap) # Allocate the current event to a room (either a new one or reuse an existing one) heapq.heappush(min_heap, self.events[i][1]) # The size of the heap will be the number of rooms required return len(min_heap)"},{"question":"def first_special_character_index(s: str) -> int: Returns the index of the first special character in s. A special character appears exactly once in the string. If there are no special characters, returns -1. >>> first_special_character_index(\\"abcd\\") 0 >>> first_special_character_index(\\"aabbccdde\\") 8 >>> first_special_character_index(\\"aabbccdd\\") -1 >>> first_special_character_index(\\"abcdeffg\\") 0 >>> first_special_character_index(\\"a\\") 0 >>> first_special_character_index(\\"\\") -1 >>> first_special_character_index(\\"aaaaa\\") -1 >>> first_special_character_index(\\"aabbcde\\") 4 # Your code here","solution":"def first_special_character_index(s): Returns the index of the first special character in s. If there are no special characters, returns -1. # Dictionary to store the frequency of each character frequency = {} # Count the frequency of each character in the string for char in s: if char in frequency: frequency[char] += 1 else: frequency[char] = 1 # Find the first character with frequency of 1 for index, char in enumerate(s): if frequency[char] == 1: return index # If no special character is found, return -1 return -1"},{"question":"def skyline(heights: List[int]) -> int: Determine the total number of distinct building heights that are visible when looking at the cityscape from the left. Args: heights (List[int]): A list of building heights. Returns: int: The number of distinct heights in the skyline. >>> skyline([]) 0 >>> skyline([5]) 1 >>> skyline([1, 1, 1, 1]) 1 >>> skyline([1, 2, 3, 4, 5]) 5 >>> skyline([3, 1, 4, 1, 5, 9, 2]) 6 >>> skyline([1, 2, 2, 3, 3, 1, 4, 5, 4]) 5","solution":"def skyline(heights): Returns the total number of distinct heights in the skyline viewed from left to right. # Use a set to keep track of distinct heights distinct_heights = set() for height in heights: distinct_heights.add(height) return len(distinct_heights)"},{"question":"def max_balanced_strings(s: str) -> int: Given a string \`s\` consisting of lowercase English letters, returns the maximum number of balanced strings that can be formed. A balanced string is considered if it has equal numbers of the letters 'a', 'b', and 'c'. >>> max_balanced_strings(\\"abcabcabc\\") == 3 >>> max_balanced_strings(\\"aaa\\") == 0 >>> max_balanced_strings(\\"abc\\") == 1 >>> max_balanced_strings(\\"aaabbbcccabc\\") == 4 >>> max_balanced_strings(\\"aabbcc\\") == 2 >>> max_balanced_strings(\\"aaaabbbbcccc\\") == 4","solution":"def max_balanced_strings(s): This function returns the maximum number of balanced strings that can be formed from \`s\`. A balanced string has equal numbers of the letters 'a', 'b', and 'c'. count_a = s.count('a') count_b = s.count('b') count_c = s.count('c') return min(count_a, count_b, count_c)"},{"question":"from typing import List def max_ones_after_flip(nums: List[int]) -> int: Returns the maximum number of 1s after performing one subarray flip on nums. >>> max_ones_after_flip([1, 0, 0, 1, 0]) 4 >>> max_ones_after_flip([0, 0, 0, 0, 0]) 5 >>> max_ones_after_flip([1, 1, 1, 1, 1]) 5 >>> max_ones_after_flip([0, 1, 0, 1, 1]) 4 >>> max_ones_after_flip([1, 0, 1, 0, 1]) 4 >>> max_ones_after_flip([1, 0, 1, 0, 0, 1, 0]) 5 >>> max_ones_after_flip([1]) 1 >>> max_ones_after_flip([0]) 1 >>> max_ones_after_flip([1, 1, 1, 0, 1, 1]) 6 >>> max_ones_after_flip([0, 0, 1, 0, 0]) 4","solution":"def max_ones_after_flip(nums): Returns the maximum number of 1s after performing one subarray flip on nums. total_ones = sum(nums) max_flip_gain = cur_flip_gain = 0 for num in nums: cur_flip_gain += 1 if num == 0 else -1 if cur_flip_gain < 0: cur_flip_gain = 0 max_flip_gain = max(max_flip_gain, cur_flip_gain) return total_ones + max_flip_gain"},{"question":"def longest_subsequence(arr: List[int], k: int) -> int: Returns the length of the longest subsequence such that the absolute difference between any two consecutive elements is less than or equal to k. >>> longest_subsequence([3, 10, 2, 1, 20], 4) == 3 >>> longest_subsequence([5], 2) == 1 >>> longest_subsequence([7, 7, 7, 7], 0) == 4 >>> longest_subsequence([1, 2, 3, 4, 5], 1) == 5 >>> longest_subsequence([1, 10, 20], 1) == 1 >>> longest_subsequence([4, 6, 5, 9, 7, 10], 3) == 5 >>> longest_subsequence([1, 3, 2, 4, 1], 2) == 4","solution":"def longest_subsequence(arr, k): Returns the length of the longest subsequence such that the absolute difference between any two consecutive elements is less than or equal to k. n = len(arr) dp = [1] * n # dp[i] will store the length of the longest subsequence ending at index i for i in range(1, n): for j in range(i): if abs(arr[i] - arr[j]) <= k: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def getTotalImportance(n: int, manager: List[int], importance: List[int], id: int) -> int: Calculate the total importance value of an employee and all their subordinates. :param n: The number of employees. :param manager: A list where manager[i] is the ID of the manager for employee i. :param importance: A list where importance[i] is the importance value of employee i. :param id: The ID of the employee whose total importance value is to be calculated. :return: The total importance value of the given employee and their subordinates. >>> getTotalImportance(5, [-1, 0, 0, 1, 1], [100, 5, 10, 3, 2], 0) 120 >>> getTotalImportance(6, [-1, 0, 0, 2, 2, 3], [100, 5, 10, 15, 3, 1], 2) 29","solution":"def getTotalImportance(n, manager, importance, id): from collections import defaultdict, deque # Create an adjacency list to represent the hierarchy subordinates = defaultdict(list) for i in range(n): if manager[i] != -1: subordinates[manager[i]].append(i) # Do a breadth-first search to calculate the total importance total_importance = 0 queue = deque([id]) while queue: current_id = queue.popleft() total_importance += importance[current_id] for subordinate in subordinates[current_id]: queue.append(subordinate) return total_importance"},{"question":"def rotate(nums: List[int], k: int) -> List[int]: Rotates the array nums to the right by k steps. Args: nums: List[int] - the array to be rotated k: int - number of steps to rotate the array Returns: List[int] - the rotated array >>> rotate([1, 2, 3], 1) [3, 1, 2] >>> rotate([1, 2, 3], 2) [2, 3, 1] >>> rotate([1, 2, 3], 3) [1, 2, 3] >>> rotate([1, 2, 3, 4, 5, 6], 10) [3, 4, 5, 6, 1, 2] >>> rotate([1, 2, 3, 4], 0) [1, 2, 3, 4] >>> rotate([1, 2, 3, 4, 5, 6, 7, 8, 9], 3) [7, 8, 9, 1, 2, 3, 4, 5, 6] >>> rotate([1], 10) [1] >>> rotate([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5]","solution":"def rotate(nums, k): Rotates the array nums to the right by k steps. Args: nums: List[int] - the array to be rotated k: int - number of steps to rotate the array Returns: List[int] - the rotated array n = len(nums) k = k % n # Normalize k to ensure it falls within the array length return nums[-k:] + nums[:-k]"},{"question":"def kth_smallest(matrix: List[List[int]], k: int) -> int: Returns the k-th smallest number in a 2D matrix where each row and column are sorted in non-decreasing order. Args: matrix (List[List[int]]): 2D list of integers sorted in non-decreasing order both row and column wise. k (int): The k-th position to find. Returns: int: The k-th smallest number in the matrix. >>> kth_smallest([[1, 5, 9], [10, 11, 13], [12, 13, 15]], 8) 13 >>> kth_smallest([[1, 2], [1, 3]], 2) 1 >>> kth_smallest([[1, 3, 5], [6, 7, 12], [11, 14, 14]], 5) 7 >>> kth_smallest([[5]], 1) 5 >>> kth_smallest([[2, 3, 8], [4, 5, 9], [6, 7, 10]], 6) 7","solution":"import heapq def kth_smallest(matrix, k): Returns the k-th smallest number in a 2D matrix where each row and column are sorted. :param matrix: List[List[int]] - 2D list of integers sorted in non-decreasing order both row and column wise. :param k: int - The k-th position to find. :return: int - The k-th smallest number in the matrix. n = len(matrix) # Min-heap to keep track of the smallest elements min_heap = [] for r in range(min(k, n)): # We only take the first k rows in consideration, as any more rows have no effect on the answer heapq.heappush(min_heap, (matrix[r][0], r, 0)) # Extract min k-1 times for i in range(k-1): num, r, c = heapq.heappop(min_heap) if c + 1 < n: heapq.heappush(min_heap, (matrix[r][c+1], r, c+1)) # The k-th smallest will be at the root of the min-heap return heapq.heappop(min_heap)[0]"},{"question":"def max_rectangle_area(heights: List[int]) -> int: Given an array of integers where each integer represents the height of a building in a skyline, determine the maximum area of a rectangle that can be formed using any number of contiguous buildings. The height of the rectangle is determined by the shortest building in the selected range. The width of the rectangle is the number of buildings in the selected range. >>> max_rectangle_area([5]) == 5 >>> max_rectangle_area([1, 2, 3, 4, 5]) == 9 >>> max_rectangle_area([5, 4, 3, 2, 1]) == 9 >>> max_rectangle_area([2, 1, 5, 6, 2, 3]) == 10 >>> max_rectangle_area([3, 3, 3, 3, 3]) == 15 >>> max_rectangle_area([]) == 0 >>> max_rectangle_area([5, 6, 3, 6, 5]) == 15","solution":"def max_rectangle_area(heights): Returns the maximum area of a rectangle that can be formed using any number of contiguous buildings. :param heights: List[int] represents the heights of the buildings. :return: int, the maximum rectangle area. max_area = 0 stack = [] for index, height in enumerate(heights): start_index = index while stack and stack[-1][1] > height: start_index, h = stack.pop() max_area = max(max_area, h * (index - start_index)) stack.append((start_index, height)) while stack: start_index, height = stack.pop() max_area = max(max_area, height * (len(heights) - start_index)) return max_area"},{"question":"class ArrayTransformer: Initializes the object with the integer array nums. >>> transformer = ArrayTransformer([1, 2, 3, 4, 5]) Reverses the elements of the array from index l to r inclusive. Indexing is 0-based. >>> transformer.reverseSubarray(1, 3) >>> transformer.getArray() [1, 4, 3, 2, 5] Increments each element of the array from index l to r inclusive by inc. Indexing is 0-based. >>> transformer.incrementSubarray(0, 2, 3) >>> transformer.getArray() [4, 5, 6, 4, 5] Multiplies each element of the array from index l to r inclusive by m. Indexing is 0-based. >>> transformer.multiplySubarray(2, 4, 2) >>> transformer.getArray() [1, 2, 6, 8, 10] Returns the current state of the array. >>> transformer.getArray() [1, 2, 3, 4, 5] >>> transformer.incrementSubarray(0, 4, 2) >>> transformer.getArray() [3, 4, 5, 6, 7] def __init__(self, nums): pass def reverseSubarray(self, l, r): pass def incrementSubarray(self, l, r, inc): pass def multiplySubarray(self, l, r, m): pass def getArray(self): pass","solution":"class ArrayTransformer: def __init__(self, nums): self.nums = nums def reverseSubarray(self, l, r): self.nums[l:r+1] = self.nums[l:r+1][::-1] def incrementSubarray(self, l, r, inc): for i in range(l, r+1): self.nums[i] += inc def multiplySubarray(self, l, r, m): for i in range(l, r+1): self.nums[i] *= m def getArray(self): return self.nums"},{"question":"def minimum_time_required(tasks: List[int], cooldown: int) -> int: Calculate the minimum time required to complete all the given tasks with cooldown period. :param tasks: List of tasks (can be repeated) :param cooldown: An integer representing the cooldown period :return: Minimum time required to complete all tasks >>> minimum_time_required([1, 2, 1, 3, 1], 2) == 7 >>> minimum_time_required([1, 2, 1, 3, 1], 0) == 5 >>> minimum_time_required([1], 2) == 1 >>> minimum_time_required([1, 2, 3, 4], 2) == 4 >>> minimum_time_required([1, 1, 1, 1], 2) == 10 >>> minimum_time_required([], 2) == 0 >>> minimum_time_required([1, 2, 3], 5) == 3 >>> minimum_time_required([1, 1, 1, 2], 0) == 4","solution":"def minimum_time_required(tasks, cooldown): Calculate the minimum time required to complete all the given tasks with cooldown period. :param tasks: List of tasks (can be repeated) :param cooldown: An integer representing the cooldown period :return: Minimum time required to complete all tasks last_occurrence = {} time = 0 for task in tasks: if task in last_occurrence and time - last_occurrence[task] <= cooldown: time = last_occurrence[task] + cooldown + 1 last_occurrence[task] = time time += 1 return time"},{"question":"def maxSideLength(grid: List[List[int]], threshold: int) -> int: Given a 2D matrix \`grid\` of size \`m x n\` and an integer \`threshold\`, return the maximum possible side length of a square with a sum less than or equal to the \`threshold\` that can be obtained from this matrix. >>> maxSideLength([[1, 1, 3, 2, 4, 3, 2], [1, 1, 3, 2, 4, 3, 2], [1, 1, 3, 2, 4, 3, 2]], 8) 2 >>> maxSideLength([[2, 2, 2, 2], [2, 2, 2, 2], [2, 2, 2, 2], [2, 2, 2, 2]], 16) 2 >>> maxSideLength([[2, 2], [2, 2]], 8) 2 >>> maxSideLength([[2, 2, 2], [2, 2, 2], [2, 2, 2]], 4) 1 >>> maxSideLength([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9) 3","solution":"def maxSideLength(grid, threshold): Returns the maximum side length of a square with a sum less than or equal to the threshold. m, n = len(grid), len(grid[0]) def get_prefix_sum_matrix(matrix): Helper function to compute prefix sums for the given matrix rows, cols = len(matrix), len(matrix[0]) prefix_sum = [[0] * (cols + 1) for _ in range(rows + 1)] for r in range(1, rows + 1): for c in range(1, cols + 1): prefix_sum[r][c] = (matrix[r - 1][c - 1] + prefix_sum[r - 1][c] + prefix_sum[r][c - 1] - prefix_sum[r - 1][c - 1]) return prefix_sum def get_sum_from_prefix_sum(prefix_sum, r1, c1, r2, c2): Helper function to get sum from (r1, c1) to (r2, c2) using prefix sums return (prefix_sum[r2 + 1][c2 + 1] - prefix_sum[r1][c2 + 1] - prefix_sum[r2 + 1][c1] + prefix_sum[r1][c1]) prefix_sum = get_prefix_sum_matrix(grid) max_length = 0 # Try every possible length until max possible square within bounds for length in range(1, min(m, n) + 1): found = False for i in range(m - length + 1): for j in range(n - length + 1): if get_sum_from_prefix_sum(prefix_sum, i, j, i + length - 1, j + length - 1) <= threshold: max_length = length found = True break if found: break return max_length"},{"question":"def assign_grades(scores: List[int]) -> List[str]: Given a list of scores, return a list of corresponding grades. >>> assign_grades([95, 100, 99, 90]) ['A', 'A', 'A', 'A'] >>> assign_grades([59, 60, 70, 80, 90]) ['F', 'D', 'C', 'B', 'A'] >>> assign_grades([89, 79, 69, 59]) ['B', 'C', 'D', 'F'] >>> assign_grades([]) [] >>> assign_grades([85, 72, 91, 55, 68]) ['B', 'C', 'A', 'F', 'D']","solution":"def assign_grades(scores): Given a list of scores, returns a list of corresponding grades. Parameters: scores (list of int): List of integer scores. Returns: list of str: List of corresponding letter grades. grades = [] for score in scores: if score >= 90: grades.append('A') elif score >= 80: grades.append('B') elif score >= 70: grades.append('C') elif score >= 60: grades.append('D') else: grades.append('F') return grades"},{"question":"def find_max_average(nums: List[int], k: int) -> float: Returns the maximum average of any subarray of length k. Parameters: nums (list of int): List of integers representing points scored in different games. k (int): Length of the subarray. Returns: float: Maximum average of any subarray of length k. >>> abs(find_max_average([1, 12, -5, -6, 50, 3], 4) - 12.75) < 1e-5 True >>> abs(find_max_average([5, 6, 7, 8, 9, 10], 3) - 9.0) < 1e-5 True >>> abs(find_max_average([-1, -2, -3, -4, -5, -6], 2) - (-1.5)) < 1e-5 True >>> abs(find_max_average([1, -1, 1, -1, 1, -1], 2) - 0.0) < 1e-5 True >>> abs(find_max_average([2, 3, 4, 1, 5], 5) - 3.0) < 1e-5 True >>> abs(find_max_average([4, 5, 6], 1) - 6.0) < 1e-5 True","solution":"def find_max_average(nums, k): Returns the maximum average of any subarray of length k. Parameters: nums (list of int): List of integers representing points scored in different games. k (int): Length of the subarray. Returns: float: Maximum average of any subarray of length k. n = len(nums) max_sum = current_sum = sum(nums[:k]) for i in range(k, n): current_sum = current_sum + nums[i] - nums[i - k] max_sum = max(max_sum, current_sum) return max_sum / k"},{"question":"from typing import List def minimum_subset_difference(nums: List[int]) -> int: Splits the array into two subsets of equal size such that the difference between the sums is minimized. Returns the minimum possible difference between the sums of the two subsets. >>> minimum_subset_difference([1, 6, 11, 5]) 1 >>> minimum_subset_difference([10, 10, 10, 10]) 0 >>> minimum_subset_difference([3, 1, 4, 2, 2, 1]) 1 >>> minimum_subset_difference([10, 20, 15, 5, 25, 30]) 5 >>> minimum_subset_difference([1, 2]) 1 >>> minimum_subset_difference([1, 1, 1, 1, 1, 1]) 0","solution":"from itertools import combinations def minimum_subset_difference(nums): Splits the array into two subsets of equal size such that the difference between the sums is minimized. Returns the minimum possible difference between the sums of the two subsets. n = len(nums) total_sum = sum(nums) half_n = n // 2 all_combinations = list(combinations(nums, half_n)) min_diff = float('inf') for subset in all_combinations: subset_sum = sum(subset) other_subset_sum = total_sum - subset_sum diff = abs(subset_sum - other_subset_sum) if diff < min_diff: min_diff = diff return min_diff"},{"question":"def buildings_with_sunset_view(buildings): Given a list of integers representing the heights of buildings on a 2D city skyline, return the indices of buildings that have an unobstructed view of the sunset. A building has an unobstructed view of the sunset if it is not blocked by any taller or equally tall building to its right. The buildings are given in left-to-right order in the list, so the rightmost building always has an unobstructed view. Assume the buildings can be of varying heights and the list can be empty. For an empty list, return an empty list of indices. :param buildings: List of integers representing the heights of buildings. :return: List of indices of buildings with unobstructed sunset view. >>> buildings_with_sunset_view([]) == [] >>> buildings_with_sunset_view([5]) == [0] >>> buildings_with_sunset_view([3, 3, 3, 3]) == [3] >>> buildings_with_sunset_view([1, 2, 3, 4, 5]) == [4] >>> buildings_with_sunset_view([5, 4, 3, 2, 1]) == [0, 1, 2, 3, 4] >>> buildings_with_sunset_view([3, 7, 8, 3, 6, 1]) == [2, 4, 5]","solution":"def buildings_with_sunset_view(buildings): Returns the indices of buildings that have an unobstructed view of the sunset. :param buildings: List of integers representing the heights of buildings. :return: List of indices of buildings with unobstructed sunset view. n = len(buildings) if n == 0: return [] result = [n-1] # The rightmost building always has an unobstructed view. tallest = buildings[n-1] for i in range(n-2, -1, -1): if buildings[i] > tallest: result.append(i) tallest = buildings[i] return result[::-1]"},{"question":"def max_candies_per_friend(candies: List[int], k: int) -> int: Returns the maximum number of candies each friend can receive. :param candies: List[int] - List of integers where candies[i] is the number of candies of the ith type. :param k: int - The number of friends. :return: int - The maximum number of candies each friend can receive of each type. Example usage: >>> max_candies_per_friend([10, 20, 30], 2) 5 >>> max_candies_per_friend([0, 0, 0], 5) 0 >>> max_candies_per_friend([15, 9, 12], 1) 9 >>> max_candies_per_friend([5, 5, 5], 2) 2 >>> max_candies_per_friend([100, 200, 300], 50) 2 >>> max_candies_per_friend([1000, 2000, 3000], 1000) 1 >>> max_candies_per_friend([4, 5, 6], 10) 0 >>> max_candies_per_friend([15], 3) 5 >>> max_candies_per_friend([1000000000, 2000000000, 3000000000], 500000000) 2","solution":"def max_candies_per_friend(candies, k): Returns the maximum number of candies each friend can receive. :param candies: List[int] - List of integers where candies[i] is the number of candies of the ith type. :param k: int - The number of friends. :return: int - The maximum number of candies each friend can receive of each type. # Initialize the maximum number of candies per friend to a large number max_candies = float('inf') # For each type of candy, calculate the maximum number per friend by dividing # by the number of friends, update the minimum value found. for candy_count in candies: max_candies = min(max_candies, candy_count // k) return max_candies"},{"question":"def has_distinct_subarray(nums: List[int], k: int) -> bool: Determines if there is any continuous subarray of length \`k\` that contains only distinct elements. >>> has_distinct_subarray([1, 2, 3, 4], 3) True >>> has_distinct_subarray([1, 2, 2, 4], 3) False >>> has_distinct_subarray([1, 2, 3, 4, 5], 5) True >>> has_distinct_subarray([1, 2, 3, 4, 4], 4) False >>> has_distinct_subarray([1, 1, 1, 1], 1) True >>> has_distinct_subarray([1, 1, 1, 1], 2) False >>> has_distinct_subarray([], 1) False >>> has_distinct_subarray([1], 1) True >>> has_distinct_subarray([1, 2, 3], 4) False","solution":"def has_distinct_subarray(nums, k): Determines if there is any continuous subarray of length \`k\` that contains only distinct elements. :param nums: List[int], List of integers :param k: int, Length of the subarray to check :return: bool, True if a subarray of length k with distinct elements exists, False otherwise n = len(nums) if k > n: return False window = set() for i in range(k): if nums[i] in window: return False window.add(nums[i]) for i in range(k, n): window.remove(nums[i - k]) if nums[i] in window: return False window.add(nums[i]) return True"},{"question":"class BinaryTreeOperations: Implements operations on a binary tree which is represented using level-order format. def __init__(self, nodeValues): Initializes the binary tree with a list of node values in level-order format. def sumValues(self, targetLevel): Sum the values of all nodes at the specified targetLevel in the tree. def incrementSubtree(self, node, value): Increment all values in the subtree rooted at the given node by the specified value. # Unit Test def test_sumValues(): operations = BinaryTreeOperations([1, 2, 3, 4, 5, 6, 7]) assert operations.sumValues(0) == 1 # only root assert operations.sumValues(1) == 5 # 2 + 3 assert operations.sumValues(2) == 22 # 4 + 5 + 6 + 7 def test_incrementSubtree(): operations = BinaryTreeOperations([1, 2, 3, 4, 5, 6, 7]) operations.incrementSubtree(1, 1) assert operations.tree == [1, 3, 3, 5, 6, 6, 7] operations.incrementSubtree(0, 1) assert operations.tree == [2, 4, 4, 6, 7, 7, 8] operations.incrementSubtree(3, -2) assert operations.tree == [2, 4, 4, 4, 7, 7, 8] def test_invalid_incrementSubtree(): operations = BinaryTreeOperations([1, 2, 3, 4, 5, 6, 7]) operations.incrementSubtree(-1, 1) # invalid, should not change anything assert operations.tree == [1, 2, 3, 4, 5, 6, 7] operations.incrementSubtree(10, 1) # invalid, should not change anything assert operations.tree == [1, 2, 3, 4, 5, 6, 7]","solution":"class BinaryTreeOperations: def __init__(self, nodeValues): Initializes the binary tree with a list of node values in level-order format. self.tree = nodeValues def sumValues(self, targetLevel): Sum the values of all nodes at the specified targetLevel in the tree. start_index = (2**targetLevel) - 1 end_index = (2**(targetLevel + 1)) - 1 return sum(self.tree[start_index:end_index]) def incrementSubtree(self, node, value): Increment all values in the subtree rooted at the given node by the specified value. if node < 0 or node >= len(self.tree): return q = [node] while q: current = q.pop(0) self.tree[current] += value left_child = 2 * current + 1 right_child = 2 * current + 2 if left_child < len(self.tree): q.append(left_child) if right_child < len(self.tree): q.append(right_child)"},{"question":"from typing import List def count_vowel_substrings(s: str) -> int: Returns the total number of substrings of s that start and end with a vowel. >>> count_vowel_substrings(\\"aeiou\\") 15 >>> count_vowel_substrings(\\"bcdfg\\") 0 >>> count_vowel_substrings(\\"abcdei\\") 6 >>> count_vowel_substrings(\\"a\\") 1 >>> count_vowel_substrings(\\"aa\\") 3","solution":"def count_vowel_substrings(s): Returns the total number of substrings of s that start and end with a vowel. vowels = set('aeiou') n = len(s) count = 0 for i in range(n): if s[i] in vowels: for j in range(i, n): if s[j] in vowels: count += 1 return count"},{"question":"from typing import List def numDistinctIslands(grid: List[List[int]]) -> int: Return the number of distinct islands in the given binary matrix grid. An island is a group of connected '1's (land cells) separated by '0's (sea cells). Islands are considered the same if they can be translated (not rotated or reflected) to match another. >>> numDistinctIslands([[1, 1, 0, 0, 0], [1, 1, 0, 0, 1], [0, 0, 0, 1, 1], [0, 1, 0, 0, 0]]) 3 >>> numDistinctIslands([[1, 1, 0, 0], [1, 0, 0, 0], [0, 0, 1, 1], [0, 1, 1, 0]]) 2 >>> numDistinctIslands([[1, 1, 1], [1, 0, 0], [1, 1, 1], [0, 0, 0]]) 1 >>> numDistinctIslands([[0, 0, 0, 0], [0, 1, 0, 1], [1, 1, 0, 0], [0, 0, 1, 1]]) 3 >>> numDistinctIslands([[1]]) 1 >>> numDistinctIslands([[0]]) 0 pass","solution":"def numDistinctIslands(grid): def dfs(x, y, origin): stack = [(x, y)] shape = set() while stack: i, j = stack.pop() if (i, j) not in visited: visited.add((i, j)) shape.add((i - origin[0], j - origin[1])) for di, dj in directions: ni, nj = i + di, j + dj if 0 <= ni < m and 0 <= nj < n and grid[ni][nj] == 1: stack.append((ni, nj)) return frozenset(shape) m, n = len(grid), len(grid[0]) visited = set() directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] unique_islands = set() for i in range(m): for j in range(n): if grid[i][j] == 1 and (i, j) not in visited: island_shape = dfs(i, j, (i, j)) if island_shape: unique_islands.add(island_shape) return len(unique_islands)"},{"question":"from typing import List def two_sum(nums: List[int], target: int) -> List[int]: Given a list of \`n\` integers \`nums\` and an integer \`target\`, return the indices of the two numbers such that they add up to \`target\`. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order. Args: nums -- list of integers target -- integer target sum Returns: List of two integers representing the indices >>> two_sum([2, 7, 11, 15], 9) == [0, 1] >>> two_sum([3, 2, 4], 6) == [1, 2] >>> two_sum([3, 3], 6) == [0, 1] >>> two_sum([-1, -2, -3, -4, -5], -8) == [2, 4] >>> two_sum([-1, 2, 3, -4, -5], -6) == [0, 4] >>> two_sum([0, 4, 3, 0], 0) == [0, 3] >>> two_sum([1, 3, 4, 2], 6) == [2, 3]","solution":"from typing import List def two_sum(nums: List[int], target: int) -> List[int]: Returns the indices of the two numbers that add up to the target. Args: nums -- list of integers target -- integer target sum Returns: List of two integers representing the indices num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i # Example usage: # result = two_sum([2, 7, 11, 15], 9) # print(result) # Output: [0, 1]"},{"question":"def unique_paths(m: int, n: int) -> int: Determine the number of unique paths that the robot can take to reach the bottom-right corner of the grid. >>> unique_paths(1, 1) 1 >>> unique_paths(2, 2) 2 >>> unique_paths(3, 3) 6 >>> unique_paths(3, 2) 3 >>> unique_paths(4, 4) 20 >>> unique_paths(10, 10) 48620","solution":"def unique_paths(m, n): Returns the number of unique paths from the top-left corner to the bottom-right corner of a m x n grid. Parameters: m (int): The number of rows in the grid. n (int): The number of columns in the grid. Returns: int: The number of unique paths. # Create a 2D array with m rows and n columns filled with 1s dp = [[1] * n for _ in range(m)] # Iterate through the array updating the number of ways to get to each cell for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[-1][-1]"},{"question":"def find_duplicates(nums: List[int]) -> List[int]: Returns a list of integers that appear exactly twice in the input list nums. The function should have a time complexity of O(n) and a space complexity of O(1) excluding the output list. >>> find_duplicates([1, 2, 3, 1, 2, 4]) [1, 2] >>> find_duplicates([4, 3, 2, 7, 8, 2, 3, 1]) [2, 3] >>> find_duplicates([1]) [] >>> find_duplicates([1, 2, 3, 4]) [] >>> find_duplicates([1, 1, 2, 2, 3, 3, 4, 4]) [1, 2, 3, 4]","solution":"def find_duplicates(nums): Returns a list of integers that appear exactly twice in the input list nums. result = [] for num in nums: index = abs(num) - 1 if nums[index] < 0: result.append(index + 1) nums[index] = -nums[index] return result"},{"question":"def number_of_arithmetic_slices(nums: List[int]) -> int: Returns the total number of arithmetic slices in the array. An arithmetic slice is defined as a sequence of at least three elements where the difference between consecutive elements is constant. >>> number_of_arithmetic_slices([1, 2, 3, 4]) == 3 >>> number_of_arithmetic_slices([1, 3, 5, 7, 9]) == 6 >>> number_of_arithmetic_slices([1, 3, 5, 8, 10]) == 1 >>> number_of_arithmetic_slices([1, 2, 3, 4, 5, 6, 7]) == 15 >>> number_of_arithmetic_slices([1, 2]) == 0 >>> number_of_arithmetic_slices([]) == 0 >>> number_of_arithmetic_slices([3, 6, 9, 12]) == 3 >>> number_of_arithmetic_slices([1, 101, 201, 301, 401]) == 6","solution":"def number_of_arithmetic_slices(nums): Returns the total number of arithmetic slices in the array. n = len(nums) if n < 3: return 0 total_slices = 0 current_slices = 0 for i in range(2, n): if nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]: current_slices += 1 total_slices += current_slices else: current_slices = 0 return total_slices"},{"question":"def can_form_string_from_words(s: str, words: List[str]) -> bool: Determines if the string s can be formed by concatenating all words in words exactly once. :param s: Input string to check :param words: List of words to form the string :return: True if the string can be formed, False otherwise >>> can_form_string_from_words(\\"abcdef\\", [\\"abc\\", \\"def\\"]) True >>> can_form_string_from_words(\\"abcdefg\\", [\\"abc\\", \\"def\\"]) False >>> can_form_string_from_words(\\"abcde\\", [\\"abc\\", \\"def\\"]) False >>> can_form_string_from_words(\\"defabc\\", [\\"abc\\", \\"def\\"]) True >>> can_form_string_from_words(\\"abcdff\\", [\\"abc\\", \\"def\\"]) False >>> can_form_string_from_words(\\"abc\\", [\\"abc\\"]) True >>> can_form_string_from_words(\\"abcabc\\", [\\"abc\\", \\"abc\\"]) True >>> can_form_string_from_words(\\"Abcdef\\", [\\"abc\\", \\"def\\"]) False","solution":"def can_form_string_from_words(s, words): Determines if the string s can be formed by concatenating all words in words exactly once. :param s: Input string to check :param words: List of words to form the string :return: True if the string can be formed, False otherwise from collections import Counter # Create a counter of characters in the input string s_counter = Counter(s) # Create a counter of characters from the concatenation of all words words_counter = Counter(''.join(words)) # Compare both counters return s_counter == words_counter"},{"question":"def maximum_product_of_three(nums: List[int]) -> int: Given an integer array \`nums\`, return the largest product that can be obtained from three of its elements. >>> maximum_product_of_three([1, 2, 3, 4]) 24 >>> maximum_product_of_three([-10, -10, 5, 2]) 500 >>> maximum_product_of_three([-1, -2, -3, -4]) -6 >>> maximum_product_of_three([10, 20, 30, 5, -10, -20, -5, 100]) 60000 >>> maximum_product_of_three([1, 2, 3, -1000]) 6 >>> maximum_product_of_three([0, 0, 0, 0]) 0 >>> maximum_product_of_three([1000, 100, 10, 1]) 1000000","solution":"def maximum_product_of_three(nums): Returns the largest product that can be obtained from three elements in the nums array. nums.sort() return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])"},{"question":"def pacificAtlantic(grid: List[List[int]]) -> List[Tuple[int, int]]: Find all cells from which water can flow to both the top/left ocean and the bottom/right ocean. >>> pacificAtlantic([ ... [1, 2, 2, 3, 5], ... [3, 2, 3, 4, 4], ... [2, 4, 5, 3, 1], ... [6, 7, 1, 4, 5], ... [5, 1, 1, 2, 4] ... ]) [(0, 4), (1, 3), (1, 4), (2, 2), (3, 0), (3, 1), (4, 0)] >>> pacificAtlantic([[1]]) [(0, 0)] >>> pacificAtlantic([]) [] >>> pacificAtlantic([ ... [1, 1], ... [1, 1] ... ]) [(0, 0), (0, 1), (1, 0), (1, 1)]","solution":"def pacificAtlantic(grid): if not grid or not grid[0]: return [] n, m = len(grid), len(grid[0]) # Initialize sets to keep track of reachable cells for each ocean pacific_reachable = set() atlantic_reachable = set() def dfs(r, c, reachable_set, prev_height): if ((r, c) in reachable_set or r < 0 or r >= n or c < 0 or c >= m or grid[r][c] < prev_height): return reachable_set.add((r, c)) for dr, dc in ((0, 1), (1, 0), (0, -1), (-1, 0)): dfs(r + dr, c + dc, reachable_set, grid[r][c]) for i in range(n): dfs(i, 0, pacific_reachable, grid[i][0]) dfs(i, m - 1, atlantic_reachable, grid[i][m - 1]) for j in range(m): dfs(0, j, pacific_reachable, grid[0][j]) dfs(n - 1, j, atlantic_reachable, grid[n - 1][j]) return list(pacific_reachable & atlantic_reachable)"},{"question":"from typing import List from collections import Counter def can_obtain_s2_by_shuffling_s1(s1: str, s2: str) -> bool: Check if it is possible to obtain s2 by shuffling the characters in s1 and optionally removing some characters. Parameters: - s1: str : a string of lowercase English letters - s2: str : a string of lowercase English letters Returns: - bool: True if it is possible to obtain s2, otherwise False Examples: >>> can_obtain_s2_by_shuffling_s1(\\"abppplee\\", \\"apple\\") True >>> can_obtain_s2_by_shuffling_s1(\\"abcdeeee\\", \\"bee\\") True >>> can_obtain_s2_by_shuffling_s1(\\"abc\\", \\"aac\\") False >>> can_obtain_s2_by_shuffling_s1(\\"apple\\", \\"apple\\") True >>> can_obtain_s2_by_shuffling_s1(\\"abc\\", \\"\\") True >>> can_obtain_s2_by_shuffling_s1(\\"\\", \\"abc\\") False","solution":"from collections import Counter def can_obtain_s2_by_shuffling_s1(s1, s2): Check if it is possible to obtain s2 by shuffling the characters in s1 and optionally removing some characters. Parameters: - s1: str : a string of lowercase English letters - s2: str : a string of lowercase English letters Returns: - bool: True if it is possible to obtain s2, otherwise False counter_s1 = Counter(s1) counter_s2 = Counter(s2) for char in counter_s2: if counter_s2[char] > counter_s1[char]: return False return True"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def swap_pairs(head): Swap every two adjacent nodes in a linked list and return its head. >>> def list_to_linked_list(lst): ... dummy = ListNode(0) ... current = dummy ... for value in lst: ... current.next = ListNode(value) ... current = current.next ... return dummy.next >>> def linked_list_to_list(head): ... lst = [] ... while head: ... lst.append(head.val) ... head = head.next ... return lst >>> head = list_to_linked_list([1, 2, 3, 4]) >>> linked_list_to_list(swap_pairs(head)) [2, 1, 4, 3] >>> head = list_to_linked_list([1, 2, 3]) >>> linked_list_to_list(swap_pairs(head)) [2, 1, 3] >>> head = list_to_linked_list([1, 2]) >>> linked_list_to_list(swap_pairs(head)) [2, 1] >>> head = list_to_linked_list([1]) >>> linked_list_to_list(swap_pairs(head)) [1] >>> head = list_to_linked_list([]) >>> linked_list_to_list(swap_pairs(head)) []","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def swap_pairs(head): Swap every two adjacent nodes in a linked list and return its head. dummy = ListNode(0) dummy.next = head current = dummy while current.next and current.next.next: first = current.next second = current.next.next # Swap nodes first.next = second.next second.next = first current.next = second # Move to the next pair current = first return dummy.next"},{"question":"def count_even_sum_pairs(nums): Returns the number of unique pairs (i, j) such that nums[i] + nums[j] is an even number and i < j. pass # Example test cases if __name__ == \\"__main__\\": print(count_even_sum_pairs([])) # 0 print(count_even_sum_pairs([2, 4, 6, 8])) # 6 print(count_even_sum_pairs([1, 3, 5, 7])) # 6 print(count_even_sum_pairs([1, 2, 3, 4])) # 2 print(count_even_sum_pairs([-1, -2, -3, -4])) # 2 print(count_even_sum_pairs([1])) # 0 print(count_even_sum_pairs([2, 4])) # 1 print(count_even_sum_pairs([1, 2])) # 0","solution":"def count_even_sum_pairs(nums): Returns the number of unique pairs (i, j) such that nums[i] + nums[j] is an even number and i < j. n = len(nums) count = 0 for i in range(n): for j in range(i + 1, n): if (nums[i] + nums[j]) % 2 == 0: count += 1 return count"},{"question":"def generate_pascals_triangle_row(n: int) -> List[int]: Given an integer \`n\`, generate the \`nth\` row of Pascal's Triangle. >>> generate_pascals_triangle_row(0) [1] >>> generate_pascals_triangle_row(1) [1, 1] >>> generate_pascals_triangle_row(2) [1, 2, 1] >>> generate_pascals_triangle_row(3) [1, 3, 3, 1] >>> generate_pascals_triangle_row(4) [1, 4, 6, 4, 1] >>> generate_pascals_triangle_row(5) [1, 5, 10, 10, 5, 1] pass","solution":"def generate_pascals_triangle_row(n): Returns the nth row of Pascal's Triangle. if n == 0: return [1] row = [1] for k in range(1, n + 1): next_value = row[-1] * (n - k + 1) // k row.append(next_value) return row"},{"question":"def find_visible_buildings(heights: List[int]) -> List[int]: Returns a list of indices of all visible buildings arranged in ascending order. A building is visible if its height is greater than all buildings to its right. Parameters: heights (list[int]): List of heights of the buildings. Returns: list[int]: List of indices of visible buildings sorted in ascending order. >>> find_visible_buildings([]) == [] True >>> find_visible_buildings([5]) == [0] True >>> find_visible_buildings([3, 3, 3, 3]) == [3] True >>> find_visible_buildings([1, 2, 3, 4]) == [3] True >>> find_visible_buildings([4, 3, 2, 1]) == [0, 1, 2, 3] True >>> find_visible_buildings([4, 2, 5, 1, 3]) == [2, 4] True >>> find_visible_buildings([4, 2, 3, 1]) == [0, 2, 3] True","solution":"def find_visible_buildings(heights): Returns a list of indices of all visible buildings arranged in ascending order. A building is visible if its height is greater than all buildings to its right. Parameters: heights (list[int]): List of heights of the buildings. Returns: list[int]: List of indices of visible buildings sorted in ascending order. if not heights: return [] visible_indices = [] max_height = heights[-1] visible_indices.append(len(heights) - 1) # the last building is always visible # Traverse the heights array in reverse order (right to left) for i in range(len(heights) - 2, -1, -1): if heights[i] > max_height: visible_indices.append(i) max_height = heights[i] return sorted(visible_indices)"},{"question":"def min_operations_to_single_char(s: str) -> int: Returns the minimum number of operations needed to make the string \`s\` contain exactly one distinct character. Args: s (str): The input string consisting of only lowercase English letters. Returns: int: The minimum number of operations needed. pass # Unit Tests def test_all_same_characters(): assert min_operations_to_single_char(\\"aaa\\") == 0 assert min_operations_to_single_char(\\"bbbbbbb\\") == 0 def test_all_different_characters(): assert min_operations_to_single_char(\\"abcd\\") == 3 assert min_operations_to_single_char(\\"xyz\\") == 2 def test_mixed_characters(): assert min_operations_to_single_char(\\"aabccc\\") == 3 assert min_operations_to_single_char(\\"abbbaac\\") == 4 def test_single_character(): assert min_operations_to_single_char(\\"a\\") == 0 def test_two_characters(): assert min_operations_to_single_char(\\"ab\\") == 1 assert min_operations_to_single_char(\\"aaab\\") == 1 assert min_operations_to_single_char(\\"bbba\\") == 1","solution":"def min_operations_to_single_char(s): Returns the minimum number of operations needed to make the string \`s\` contain exactly one distinct character. Args: s (str): The input string consisting of only lowercase English letters. Returns: int: The minimum number of operations needed. from collections import Counter # Get the frequency counts of each character in the string char_count = Counter(s) # Find the character with the maximum frequency max_freq = max(char_count.values()) # Minimum operations needed will be the total length of the string # minus the maximum frequency of any single character return len(s) - max_freq"},{"question":"def number_of_arithmetic_subarrays(nums: List[int]) -> int: Given an integer array \`nums\`, return the number of arithmetic subarrays of \`nums\`. A subarray \`nums[i..j]\` is arithmetic if the difference between any two consecutive elements is the same. A subarray is a contiguous sequence of elements within the array. A single element subarray is not considered arithmetic. >>> number_of_arithmetic_subarrays([1, 2, 3, 4]) == 3 >>> number_of_arithmetic_subarrays([7, 7, 7, 7]) == 3 >>> number_of_arithmetic_subarrays([1, 1, 2, 5, 7]) == 0 >>> number_of_arithmetic_subarrays([1, 3, 5, 7, 9]) == 6 >>> number_of_arithmetic_subarrays([1, 2, 3, 8, 9, 10]) == 2 >>> number_of_arithmetic_subarrays([1, 2]) == 0 >>> number_of_arithmetic_subarrays([1, 2, 4]) == 0 >>> number_of_arithmetic_subarrays([]) == 0 >>> number_of_arithmetic_subarrays([5]) == 0","solution":"def number_of_arithmetic_subarrays(nums): def count_arithmetic_slices(A): n = len(A) if n < 3: return 0 count = 0 dp = [0] * n for i in range(2, n): if A[i] - A[i-1] == A[i-1] - A[i-2]: dp[i] = dp[i-1] + 1 count += dp[i] return count return count_arithmetic_slices(nums)"},{"question":"def min_swaps_to_alternate(s: str) -> int: Returns the minimum number of swaps required to make the binary string s alternating. If it is not possible to make the string alternating, returns -1. >>> min_swaps_to_alternate(\\"111000\\") == 1 >>> min_swaps_to_alternate(\\"010\\") == 0 >>> min_swaps_to_alternate(\\"1110\\") == -1 >>> min_swaps_to_alternate(\\"1001\\") == 1 >>> min_swaps_to_alternate(\\"1100\\") == 1 >>> min_swaps_to_alternate(\\"\\") == 0 >>> min_swaps_to_alternate(\\"0\\") == 0 >>> min_swaps_to_alternate(\\"1\\") == 0","solution":"def min_swaps_to_alternate(s): Returns the minimum number of swaps required to make the binary string s alternating. If it is not possible to make the string alternating, returns -1. n = len(s) # Case for alternating pattern starting with '0' count0 = count1 = 0 for i in range(n): if i % 2 == 0: if s[i] != '0': count0 += 1 if s[i] != '1': count1 += 1 else: if s[i] != '1': count0 += 1 if s[i] != '0': count1 += 1 # Checking if it's possible to make the alternating string if count0 % 2 != 0 and count1 % 2 != 0: return -1 if count0 % 2 == 0 and count1 % 2 != 0: return count0 // 2 if count0 % 2 != 0 and count1 % 2 == 0: return count1 // 2 return min(count0 // 2, count1 // 2)"},{"question":"def minimize_height_difference(heights: List[int], k: int) -> int: Returns the minimum possible difference between the maximum and minimum heights of the buildings after at most k operations. >>> minimize_height_difference([1, 3, 5], 2) 2 >>> minimize_height_difference([4, 4, 4], 1) 0 >>> minimize_height_difference([], 5) 0 >>> minimize_height_difference([1, 3, 5], 0) 4 >>> minimize_height_difference([10], 3) 0 >>> minimize_height_difference([5, 10, 15], 100) 0","solution":"def minimize_height_difference(heights, k): Returns the minimum possible difference between the maximum and minimum heights of the buildings after at most k operations. if not heights: return 0 n = len(heights) heights.sort() min_diff = heights[-1] - heights[0] for i in range(1, n): if heights[i] - heights[i-1] > 1 and k > 0: min_diff -= 1 k -= 1 return max(0, min_diff - k)"},{"question":"def make_smallest_lexicographic_string(s: str) -> str: You are given a string \`s\` consisting only of characters 'a', 'b', and 'c'. You can choose any two adjacent characters and swap them. Your goal is to make the string \`s\` lexicographically smallest possible. Return the lexicographically smallest string you can make with the given swaps. Note that a string \`x\` is lexicographically smaller than a string \`y\` if \`x\` comes before \`y\` in dictionary order. >>> make_smallest_lexicographic_string(\\"abc\\") \\"abc\\" >>> make_smallest_lexicographic_string(\\"cba\\") \\"abc\\" >>> make_smallest_lexicographic_string(\\"a\\") \\"a\\" >>> make_smallest_lexicographic_string(\\"bac\\") \\"abc\\" >>> make_smallest_lexicographic_string(\\"cab\\") \\"abc\\" >>> make_smallest_lexicographic_string(\\"bca\\") \\"abc\\" >>> make_smallest_lexicographic_string(\\"aabbcc\\") \\"aabbcc\\" >>> make_smallest_lexicographic_string(\\"bbaacc\\") \\"aabbcc\\" >>> make_smallest_lexicographic_string(\\"cccbbb\\") \\"bbbccc\\"","solution":"def make_smallest_lexicographic_string(s): Returns the lexicographically smallest string possible by swapping any two adjacent characters. arr = list(s) n = len(arr) for i in range(n - 1): for j in range(n - 1 - i): if arr[j] > arr[j + 1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] return ''.join(arr)"},{"question":"from typing import List def remove_duplicates(nums: List[int]) -> int: Removes duplicates in a sorted array such that each unique element appears at most twice. Modifies the input nums in-place and returns length of the modified array. >>> nums = [1, 1, 1, 2, 2, 3] >>> remove_duplicates(nums) 5 >>> nums[:5] [1, 1, 2, 2, 3]","solution":"def remove_duplicates(nums): Removes duplicates in a sorted array such that each unique element appears at most twice. Modifies the input nums in-place and returns length of the modified array. if not nums: return 0 # Maximum number of occurrences allowed for each element max_occurrences = 2 # Index of the next position to place the verified number insert_position = 1 # Count occurrences of current number count = 1 for i in range(1, len(nums)): if nums[i] == nums[i - 1]: if count < max_occurrences: nums[insert_position] = nums[i] insert_position += 1 count += 1 else: nums[insert_position] = nums[i] insert_position += 1 count = 1 return insert_position"},{"question":"def pacific_atlantic(matrix): Return a list of grid coordinates where water can flow to both the Pacific and Atlantic oceans. >>> pacific_atlantic([ [1, 2, 2, 3, 5], [3, 2, 3, 4, 4], [2, 4, 5, 3, 1], [6, 7, 1, 4, 5], [5, 1, 1, 2, 4] ]) [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]] >>> pacific_atlantic([]) [] >>> pacific_atlantic([[1]]) [[0, 0]] >>> pacific_atlantic([ [1, 1], [1, 1] ]) [[0,0],[0,1],[1,0],[1,1]]","solution":"def pacific_atlantic(matrix): if not matrix or not matrix[0]: return [] rows, cols = len(matrix), len(matrix[0]) pacific_reachable = [[False for _ in range(cols)] for _ in range(rows)] atlantic_reachable = [[False for _ in range(cols)] for _ in range(rows)] def dfs(i, j, reachable, ocean_name=\\"\\"): reachable[i][j] = True directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] for direction in directions: x, y = i + direction[0], j + direction[1] if 0 <= x < rows and 0 <= y < cols and not reachable[x][y] and matrix[x][y] >= matrix[i][j]: dfs(x, y, reachable, ocean_name) for i in range(rows): dfs(i, 0, pacific_reachable, \\"Pacific\\") dfs(i, cols - 1, atlantic_reachable, \\"Atlantic\\") for j in range(cols): dfs(0, j, pacific_reachable, \\"Pacific\\") dfs(rows - 1, j, atlantic_reachable, \\"Atlantic\\") result = [] for i in range(rows): for j in range(cols): if pacific_reachable[i][j] and atlantic_reachable[i][j]: result.append([i, j]) return sorted(result)"},{"question":"def findLongestValidSubstring(s: str) -> int: Returns the length of the longest valid substring without repeating characters. :param s: A string consisting of lowercase English letters. :return: An integer representing the length of the longest valid substring. >>> findLongestValidSubstring('') == 0 >>> findLongestValidSubstring('a') == 1 >>> findLongestValidSubstring('abcdef') == 6 >>> findLongestValidSubstring('aaaaaa') == 1 >>> findLongestValidSubstring('abcabcbb') == 3 >>> findLongestValidSubstring('bbbbb') == 1 >>> findLongestValidSubstring('pwwkew') == 3 >>> findLongestValidSubstring('dvdf') == 3 >>> findLongestValidSubstring('aab') == 2 >>> findLongestValidSubstring('abac') == 3 >>> findLongestValidSubstring('tmmzuxt') == 5","solution":"def findLongestValidSubstring(s): Returns the length of the longest valid substring without repeating characters. :param s: A string consisting of lowercase English letters. :return: An integer representing the length of the longest valid substring. char_index_map = {} longest = 0 start = 0 for end, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = end longest = max(longest, end - start + 1) return longest"},{"question":"def largest_island(grid): Returns the size of the largest island in the given grid. def dfs(grid, i, j): # depth-first search to explore the grid pass max_island_size = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: # Calculate the size of each island island_size = dfs(grid, i, j) # Update the maximum island size found max_island_size = max(max_island_size, island_size) return max_island_size # Example tests def test_single_island(): grid = [ [1, 1, 0, 0, 0], [1, 1, 0, 1, 1], [0, 0, 0, 1, 0], [0, 0, 0, 0, 1], [1, 1, 0, 0, 1] ] assert largest_island(grid) == 4 def test_multiple_islands(): grid = [ [1, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0], [0, 0, 1, 1, 1] ] assert largest_island(grid) == 3 def test_no_island(): grid = [ [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0] ] assert largest_island(grid) == 0 def test_entire_grid_is_one_island(): grid = [ [1, 1], [1, 1] ] assert largest_island(grid) == 4 def test_disjoint_islands(): grid = [ [1, 0, 0, 1, 0], [0, 0, 0, 0, 0], [0, 1, 0, 0, 1], [1, 0, 0, 1, 0] ] assert largest_island(grid) == 1","solution":"def largest_island(grid): Returns the size of the largest island in the given grid. def dfs(grid, i, j): # If out of bounds or at water cell, return 0 if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0: return 0 # Mark the cell as visited grid[i][j] = 0 size = 1 # Explore all four directions size += dfs(grid, i + 1, j) size += dfs(grid, i - 1, j) size += dfs(grid, i, j + 1) size += dfs(grid, i, j - 1) return size max_island_size = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: # Calculate the size of each island island_size = dfs(grid, i, j) # Update the maximum island size found max_island_size = max(max_island_size, island_size) return max_island_size"},{"question":"def is_possible_path(grid: List[List[int]]) -> bool: Given a binary matrix \`grid\` of size \`m x n\`, this function checks if there exists a path from any cell in the first row to any cell in the last row following the conditions specified. Conditions: - You can only move to an adjacent cell in the next row. - Return \`true\` if such a path exists, otherwise return \`false\`. >>> is_possible_path([ ... [1, 0, 0], ... [0, 1, 0], ... [0, 0, 1] ... ]) == True >>> is_possible_path([ ... [1, 0, 0], ... [0, 0, 1], ... [1, 0, 0] ... ]) == False >>> is_possible_path([ ... [1] ... ]) == True >>> is_possible_path([ ... [0] ... ]) == False >>> is_possible_path([ ... [] ... ]) == False from typing import List def test_simple_case(): grid = [ [1, 0, 0], [0, 1, 0], [0, 0, 1] ] assert is_possible_path(grid) == True def test_no_path(): grid = [ [1, 0, 0], [0, 0, 1], [1, 0, 0] ] assert is_possible_path(grid) == False def test_multiple_path_options(): grid = [ [1, 1, 1], [1, 1, 1], [1, 1, 1] ] assert is_possible_path(grid) == True def test_one_row_grid(): grid = [ [1, 0, 1] ] assert is_possible_path(grid) == True def test_edge_case_empty_grid(): grid = [] assert is_possible_path(grid) == False def test_no_ones_in_grid(): grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert is_possible_path(grid) == False def test_single_column_grid(): grid = [ [1], [1], [1] ] assert is_possible_path(grid) == True def test_single_column_without_path(): grid = [ [1], [0], [1] ] assert is_possible_path(grid) == False def test_complex_path(): grid = [ [1, 0, 1], [1, 1, 0], [0, 1, 1] ] assert is_possible_path(grid) == True","solution":"def is_possible_path(grid): Given a binary matrix \`grid\`, this function checks if there exists a path from any cell in the first row to any cell in the last row following the conditions. if not grid: return False m, n = len(grid), len(grid[0]) if m == 1: # If there's only one row, check if there's any 1 in that row. return any(grid[0]) # Initialize the possible paths with the first row cells that are 1 possible_paths = set(idx for idx, val in enumerate(grid[0]) if val == 1) # Traverse the grid row by row for i in range(1, m): next_paths = set() for j in possible_paths: for k in range(max(j-1, 0), min(j+2, n)): if grid[i][k] == 1: next_paths.add(k) possible_paths = next_paths if not possible_paths: return False return bool(possible_paths)"},{"question":"def unobstructed_buildings(heights: List[int], threshold: int) -> List[bool]: Returns a list where each element represents if the corresponding building is unobstructed. A building is unobstructed if it is taller than the threshold and has no taller building to its right. :param heights: List of integers representing heights of buildings :param threshold: Integer threshold :return: List of boolean values >>> unobstructed_buildings([2, 3, 1, 5, 2], 5) [False, False, False, False, False] >>> unobstructed_buildings([6, 7, 8, 9, 10], 5) [False, False, False, False, True] >>> unobstructed_buildings([1, 5, 3, 6, 4, 7], 4) [False, False, False, False, False, True] >>> unobstructed_buildings([5, 5, 5, 6], 5) [False, False, False, True] >>> unobstructed_buildings([10], 9) [True]","solution":"def unobstructed_buildings(heights, threshold): Returns a list where each element represents if the corresponding building is unobstructed. A building is unobstructed if it is taller than the threshold and has no taller building to its right. :param heights: List of integers representing heights of buildings :param threshold: Integer threshold :return: List of boolean values n = len(heights) result = [False] * n max_right = 0 for i in range(n-1, -1, -1): if heights[i] > threshold and heights[i] > max_right: result[i] = True max_right = max(max_right, heights[i]) return result"},{"question":"def can_reorganize_books(books: List[Tuple[int, str]]) -> bool: Determines if books can be reorganized so that no two books of the same genre are adjacent. Parameters: books (list of tuples): List of tuples where each tuple contains a bookID and a genre. Returns: bool: True if books can be reorganized, otherwise False. >>> can_reorganize_books([]) True >>> can_reorganize_books([(1, 'A')]) True >>> can_reorganize_books([(1, 'A'), (2, 'A'), (3, 'B')]) True >>> can_reorganize_books([(1, 'A'), (2, 'B'), (3, 'C')]) True >>> can_reorganize_books([(1, 'A'), (2, 'A'), (3, 'A'), (4, 'B')]) False >>> can_reorganize_books([(1, 'A'), (2, 'A'), (3, 'A'), (4, 'A')]) False >>> can_reorganize_books([(i, 'A') for i in range(20)] + [(i, 'B') for i in range(20)]) True","solution":"from collections import Counter import heapq def can_reorganize_books(books): Determines if books can be reorganized so that no two books of the same genre are adjacent. Parameters: books (list of tuples): List of tuples where each tuple contains a bookID and a genre. Returns: bool: True if books can be reorganized, otherwise False. if not books: return True # Count frequency of each genre genre_count = Counter([genre for _, genre in books]) # Convert counts to a max-heap max_heap = [(-count, genre) for genre, count in genre_count.items()] heapq.heapify(max_heap) prev_count, prev_genre = 0, None while max_heap: count, genre = heapq.heappop(max_heap) # Place the previous genre back into the max heap if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_genre)) # Add the current genre to the result (hypothetical placement) prev_count, prev_genre = count + 1, genre return (prev_count == 0)"},{"question":"def length_of_LIS(nums: List[int]) -> int: Returns the length of the longest increasing subsequence in the array nums. >>> length_of_LIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4 >>> length_of_LIS([1, 2, 3, 4, 5]) == 5 >>> length_of_LIS([5, 4, 3, 2, 1]) == 1 >>> length_of_LIS([3, 10, 2, 1, 20]) == 3 >>> length_of_LIS([10]) == 1 >>> length_of_LIS([]) == 0","solution":"def length_of_LIS(nums): Returns the length of the longest increasing subsequence in the array nums. if not nums: return 0 n = len(nums) dp = [1] * n # dp[i] represents the length of LIS ending at index i for i in range(1, n): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def count_subarrays_with_product_less_than_k(nums: List[int], k: int) -> int: Count the number of subarrays whose product of elements is less than k. :param nums: A list of integers :param k: An integer threshold :return: The count of subarrays whose product of elements is less than k >>> count_subarrays_with_product_less_than_k([10, 5, 2, 6], 100) 8 >>> count_subarrays_with_product_less_than_k([1, 2, 3], 0) 0 >>> count_subarrays_with_product_less_than_k([1], 2) 1 >>> count_subarrays_with_product_less_than_k([10], 10) 0 >>> count_subarrays_with_product_less_than_k([1, 2, 3], 10) 6 >>> count_subarrays_with_product_less_than_k([1, 2, 2], 10) 6 >>> count_subarrays_with_product_less_than_k([1, 2, 3, 4], 10) 7 >>> count_subarrays_with_product_less_than_k([1, 2, 3, 4], 50) 10","solution":"def count_subarrays_with_product_less_than_k(nums, k): Returns the count of subarrays whose product of elements is less than k. if k <= 1: return 0 count = 0 product = 1 left = 0 for right in range(len(nums)): product *= nums[right] while product >= k and left <= right: product //= nums[left] left += 1 count += (right - left + 1) return count"},{"question":"def minPathSum(grid): Returns the minimum path sum from top-left to bottom-right in a given grid. >>> minPathSum([[5]]) == 5 >>> minPathSum([[1, 2], [1, 1]]) == 3 >>> minPathSum([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) == 7 >>> minPathSum([[10, 100], [1, 10]]) == 21 >>> grid = [ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1], ... [2, 3, 4], ... [1, 1, 1] ... ] >>> minPathSum(grid) == 11","solution":"def minPathSum(grid): Returns the minimum path sum from top-left to bottom-right in a given grid. if not grid or not grid[0]: return 0 n, m = len(grid), len(grid[0]) # Initialize dp array with the same dimensions as grid dp = [[0] * m for _ in range(n)] # Set the initial point (top-left corner) dp[0][0] = grid[0][0] # Fill the first row for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp array for i in range(1, n): for j in range(1, m): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The bottom-right corner will contain the minimum path sum return dp[n-1][m-1]"},{"question":"def can_see_buildings(heights): Returns the number of buildings visible sequentially from the left side. >>> can_see_buildings([1, 2, 3, 4, 5]) == 5 >>> can_see_buildings([]) == 0 >>> can_see_buildings([1]) == 1 >>> can_see_buildings([5, 3, 4, 1, 6]) == 2 >>> can_see_buildings([3, 3, 3, 3]) == 1","solution":"def can_see_buildings(heights): Returns the number of buildings visible sequentially from the left side. count = 0 current_max_height = 0 for height in heights: if height > current_max_height: count += 1 current_max_height = height return count"},{"question":"def partitionDisjoint(nums: List[int]) -> int: Given an array nums, partition the array into two subarrays left and right such that every element in left is less than or equal to every element in right. Both left and right must be non-empty, and left should have the smallest possible size. Returns the length of left after partitioning. >>> partitionDisjoint([5, 0, 3, 8, 6]) == 3 >>> partitionDisjoint([1, 1, 1, 0, 6, 12]) == 4 >>> partitionDisjoint([1, 2]) == 1 >>> partitionDisjoint([2, 1]) == 1 >>> partitionDisjoint([1, 1, 1, 1]) == 1 >>> partitionDisjoint([1, 2, 3, 4, 5]) == 1 >>> partitionDisjoint([5, 4, 3, 2, 1]) == 4","solution":"def partitionDisjoint(nums): Given an array nums, partition the array into two subarrays left and right such that every element in left is less than or equal to every element in right. Returns the length of left after partitioning. max_left = nums[0] max_seen = nums[0] partition_idx = 0 for i in range(1, len(nums) - 1): max_seen = max(max_seen, nums[i]) if nums[i] < max_left: max_left = max_seen partition_idx = i return partition_idx + 1"},{"question":"def closest_element_position(mat: List[List[int]], target: int) -> Tuple[int, int]: Given a matrix \`mat\` and an integer \`target\`, return the position of the element in \`mat\` that is closest to \`target\`. If there are multiple elements with the same minimum distance to the target, return the position of the one that appears first in reading order (i.e., top to bottom, left to right). If the matrix is empty, return (-1, -1). def test_closest_element_position_single_element(): assert closest_element_position([[5]], 7) == (0, 0) def test_closest_element_position_multiple_elements_different_values(): mat = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert closest_element_position(mat, 5) == (1, 1) assert closest_element_position(mat, 0) == (0, 0) def test_closest_element_position_multiple_elements_same_distance(): mat = [ [1, 3, 3], [2, 2, 8] ] # Closest elements to 1 are (1, 0) and (0, 1); it should return the first one (in reading order) assert closest_element_position(mat, 1) == (0, 0) # Closest elements to 7 are (1, 2) and (0, 2); it should return the first one (in reading order) assert closest_element_position(mat, 7) == (1, 2) def test_closest_element_position_empty_matrix(): assert closest_element_position([], 5) == (-1, -1) def test_closest_element_position_all_elements_same(): mat = [ [7, 7], [7, 7] ] assert closest_element_position(mat, 7) == (0, 0) def test_closest_element_position_target_not_in_matrix(): mat = [ [10, 20, 30], [40, 50, 60] ] assert closest_element_position(mat, 0) == (0, 0) assert closest_element_position(mat, 100) == (1, 2)","solution":"def closest_element_position(mat, target): Returns the position of the element in mat that is closest to target. If multiple elements have the same minimum distance, return the first one in reading order (top to bottom, left to right). If the matrix is empty, return (-1, -1). :param mat: List[List[int]], the input matrix :param target: int, the target value :return: Tuple[int, int], position of the closest element in the matrix if not mat or not mat[0]: return (-1, -1) closest_pos = (-1, -1) min_dist = float('inf') for i in range(len(mat)): for j in range(len(mat[0])): dist = abs(mat[i][j] - target) if dist < min_dist: min_dist = dist closest_pos = (i, j) return closest_pos"},{"question":"def contains_nearby_almost_duplicate(nums: List[int], k: int, t: int) -> bool: Determine if there are two distinct indices i and j in the array such that abs(nums[i] - nums[j]) <= t and abs(i - j) <= k. >>> contains_nearby_almost_duplicate([1, 2, 3, 1], 3, 0) == True >>> contains_nearby_almost_duplicate([1, 2, 3, 4, 5], 3, 0) == False >>> contains_nearby_almost_duplicate([1, 5, 9, 13], 3, 4) == True >>> contains_nearby_almost_duplicate([1, 0, 1, 2], 1, 2) == True >>> contains_nearby_almost_duplicate([], 1, 1) == False >>> contains_nearby_almost_duplicate([1], 1, 1) == False >>> contains_nearby_almost_duplicate([-1, -1], 1, 0) == True >>> contains_nearby_almost_duplicate([2**31 - 1, 2**31 - 1], 1, 0) == True >>> contains_nearby_almost_duplicate([1, 2, 3, 4, 5], 0, 0) == False >>> contains_nearby_almost_duplicate([1, 2, 3, 4, 5], 3, -1) == False","solution":"def contains_nearby_almost_duplicate(nums, k, t): Determine if there are two distinct indices i and j in the array such that abs(nums[i] - nums[j]) <= t and abs(i - j) <= k. Args: nums: List[int] - List of integers. k: int - Maximum index difference. t: int - Maximum value difference. Returns: bool - True if such indices exist, otherwise False. if t < 0 or k <= 0: return False num_dict = {} for i, num in enumerate(nums): bucket = num // (t + 1) if bucket in num_dict: return True if bucket - 1 in num_dict and abs(num - num_dict[bucket - 1]) <= t: return True if bucket + 1 in num_dict and abs(num - num_dict[bucket + 1]) <= t: return True num_dict[bucket] = num if i >= k: del num_dict[nums[i - k] // (t + 1)] return False"},{"question":"def maximum_sum_subarray_with_one_deletion(nums, k): Returns the maximum sum of a non-empty subarray with at most one deletion of an element. >>> maximum_sum_subarray_with_one_deletion([1, 2, 3, 4, 5], 1) == 15 >>> maximum_sum_subarray_with_one_deletion([1, -2, 0, 3], 1) == 4 >>> maximum_sum_subarray_with_one_deletion([1, -2, -2, 3], 1) == 3 >>> maximum_sum_subarray_with_one_deletion([-1, -2, -3, -4], 1) == -1 >>> maximum_sum_subarray_with_one_deletion([5], 1) == 5 >>> maximum_sum_subarray_with_one_deletion([], 1) == 0 >>> maximum_sum_subarray_with_one_deletion([3, -1, 4, -1, 2, -2, 1], 1) == 8 >>> maximum_sum_subarray_with_one_deletion([1, -2, 5, -2, 3], 1) == 8","solution":"def maximum_sum_subarray_with_one_deletion(nums, k): Returns the maximum sum of a non-empty subarray with at most one deletion of an element. if not nums: return 0 n = len(nums) if n == 1: return nums[0] # Initialize forward and backward arrays to store maximum subarray sums forward = [0] * n backward = [0] * n # Calculate the maximum sum subarrays ending at each index forward[0] = nums[0] for i in range(1, n): forward[i] = max(nums[i], forward[i - 1] + nums[i]) # Calculate the maximum sum subarrays starting at each index backward[n - 1] = nums[n - 1] for i in range(n - 2, -1, -1): backward[i] = max(nums[i], backward[i + 1] + nums[i]) # Find the maximum sum subarray with at most one deletion max_sum = max(forward) for i in range(1, n - 1): max_sum = max(max_sum, forward[i - 1] + backward[i + 1]) return max_sum"},{"question":"def kth_smallest(arr: List[int], k: int) -> int: Returns the k-th smallest element in the array 'arr'. >>> kth_smallest([3, 2, 1, 5, 6, 4], 2) 2 >>> kth_smallest([3, 2, 3, 1, 2, 4, 5, 5, 6], 4) 3 >>> kth_smallest([1], 1) 1 >>> kth_smallest([2, 2, 2, 2], 3) 2 >>> kth_smallest([3, -1, -4, 2, -6], 3) -1 >>> kth_smallest([3, 1, 2, 4, 5, 6], 6) 6 >>> kth_smallest([7, 6, 5, 4, 3, 2, 1], 5) 5","solution":"def kth_smallest(arr, k): Returns the k-th smallest element in the array 'arr'. arr_sorted = sorted(arr) return arr_sorted[k-1]"},{"question":"def has_cycle(edges: List[List[int]], n: int) -> bool: Function to detect cycle in an undirected graph. :param edges: List of edges where each edge is represented as a pair of nodes [u, v]. :param n: Number of nodes in the graph. :return: True if there is a cycle, otherwise False. >>> has_cycle([[0, 1], [1, 2], [2, 3]], 4) False >>> has_cycle([[0, 1], [1, 2], [2, 0]], 3) True >>> has_cycle([[0, 1], [2, 3]], 4) False >>> has_cycle([[0, 1], [1, 2], [2, 0], [3, 4]], 5) True >>> has_cycle([], 1) False >>> has_cycle([], 2) False","solution":"def find_parent(parent, i): if parent[i] == -1: return i if parent[i] != -1: return find_parent(parent, parent[i]) def union(parent, x, y): x_set = find_parent(parent, x) y_set = find_parent(parent, y) if x_set != y_set: parent[x_set] = y_set def has_cycle(edges, n): Function to detect cycle in an undirected graph. :param edges: List of edges where each edge is represented as a pair of nodes [u, v]. :param n: Number of nodes in the graph. :return: True if there is a cycle, otherwise False. parent = [-1]*(n) for edge in edges: x = find_parent(parent, edge[0]) y = find_parent(parent, edge[1]) if x == y: return True union(parent, x, y) return False"},{"question":"def minimized_largest_sum(arr: List[int], k: int) -> int: Partition the array into k subsets such that the sum of integers in each subset is maximized. Return the minimized sum of the largest subset. >>> minimized_largest_sum([1, 2, 3, 4, 5], 2) == 9 >>> minimized_largest_sum([1, 2, 3, 4, 5], 3) == 6 >>> minimized_largest_sum([1, 2, 3, 4, 5], 1) == 15 >>> minimized_largest_sum([10, 20, 30], 2) == 30 >>> minimized_largest_sum([7, 2, 5, 10, 8], 2) == 18 >>> minimized_largest_sum([7, 2, 5, 10, 8], 3) == 14 >>> minimized_largest_sum([1, 1, 1, 1, 1], 5) == 1","solution":"def can_partition(nums, k, max_sum): # This helper function checks if we can partition the array into \`k\` or fewer parts # so that no part has a sum greater than \`max_sum\`. current_sum = 0 required_parts = 1 for num in nums: if current_sum + num > max_sum: required_parts += 1 current_sum = num if required_parts > k: return False else: current_sum += num return True def minimized_largest_sum(arr, k): low = max(arr) high = sum(arr) while low < high: mid = (low + high) // 2 if can_partition(arr, k, mid): high = mid else: low = mid + 1 return low"},{"question":"def gcd(a: int, b: int) -> int: Returns the greatest common divisor (GCD) of a and b using the Euclidean algorithm. >>> gcd(48, 18) 6 >>> gcd(0, 5) 5 >>> gcd(-48, -18) 6 >>> gcd(21, 7) 7 def test_gcd_positive_numbers(): assert gcd(48, 18) == 6 assert gcd(56, 98) == 14 def test_gcd_with_zero(): assert gcd(0, 5) == 5 assert gcd(5, 0) == 5 assert gcd(0, 0) == 0 def test_gcd_negative_numbers(): assert gcd(-48, -18) == 6 assert gcd(48, -18) == 6 assert gcd(-48, 18) == 6 def test_gcd_one_number_is_multiple_of_other(): assert gcd(21, 7) == 7 assert gcd(7, 21) == 7","solution":"def gcd(a, b): Returns the greatest common divisor (GCD) of a and b using the Euclidean algorithm. while b != 0: a, b = b, a % b return abs(a)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def right_side_view(root): Given a binary tree, return the right side view of the tree. Args: root (TreeNode): the root of the binary tree. Returns: List[int]: list of values visible from the right side of the tree. >>> right_side_view(None) [] >>> root = TreeNode(1) >>> right_side_view(root) [1] >>> root = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, None, TreeNode(6))) >>> right_side_view(root) [1, 3, 6] >>> root = TreeNode(1, TreeNode(2, None, TreeNode(3)), None) >>> right_side_view(root) [1, 2, 3] >>> root = TreeNode(1, None, TreeNode(2, None, TreeNode(3))) >>> right_side_view(root) [1, 2, 3]","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def right_side_view(root): Returns the right side view of the binary tree rooted at 'root'. if not root: return [] from collections import deque queue = deque([(root, 0)]) right_view = [] max_level = -1 while queue: node, level = queue.popleft() if level > max_level: right_view.append(node.val) max_level = level if node.right: queue.append((node.right, level + 1)) if node.left: queue.append((node.left, level + 1)) return right_view"},{"question":"def can_form_consecutive_sequence(nums: List[int]) -> bool: Given an integer array nums, return true if the array can be rearranged to form a consecutive sequence of numbers without any gaps, or false otherwise. Examples: >>> can_form_consecutive_sequence([1, 2, 3, 4, 5]) True >>> can_form_consecutive_sequence([5, 4, 3, 2, 1]) True >>> can_form_consecutive_sequence([1, 2, 4, 5]) False >>> can_form_consecutive_sequence([1, 3, 4, 5]) False >>> can_form_consecutive_sequence([]) False >>> can_form_consecutive_sequence([1, 2, 2, 3]) False >>> can_form_consecutive_sequence([-3, -2, -1]) True >>> can_form_consecutive_sequence([-3, -1, 0]) False","solution":"def can_form_consecutive_sequence(nums): Returns True if the array can be rearranged to form a consecutive sequence of numbers without any gaps. if not nums: return False min_num = min(nums) max_num = max(nums) expected_length = max_num - min_num + 1 return expected_length == len(nums) and len(set(nums)) == len(nums)"},{"question":"def two_product(arr: List[int], target: int) -> bool: Determines if there are exactly two different elements in the array whose product is equal to the target. :param arr: List[int] - the list of positive integers :param target: int - the target product :return: bool - True if such elements exist, False otherwise >>> two_product([2, 4, 3, 6], 12) == True >>> two_product([1, 5, 3, 9, 15], 45) == True >>> two_product([2, 4, 3, 6], 10) == False","solution":"def two_product(arr, target): Determines if there are exactly two different elements in the array whose product is equal to the target. :param arr: List[int] - the list of positive integers :param target: int - the target product :return: bool - True if such elements exist, False otherwise seen = set() for num in arr: if num == 0 and target == 0: continue if target % num == 0: complement = target // num if complement in seen: return True seen.add(num) return False"},{"question":"def min_subarray_len(target: int, nums: List[int]) -> int: Returns the shortest subarray with a sum that is at least target. If there is no such subarray, return 0 instead. >>> min_subarray_len(7, [2, 3, 1, 2, 4, 3]) == 2 # [4, 3] >>> min_subarray_len(100, [2, 3, 1, 2, 4, 3]) == 0 # No subarray meets the target >>> min_subarray_len(4, [1, 4, 4]) == 1 # [4] >>> min_subarray_len(15, [1, 2, 3, 4, 5]) == 5 # Entire array >>> min_subarray_len(11, [1, 2, 3, 4, 5, 6]) == 2 # [5, 6] >>> min_subarray_len(10, [5, 5, 5, 5, 5]) == 2 # [5, 5] >>> min_subarray_len(7, []) == 0 # No elements in array >>> min_subarray_len(10, [5]) == 0 # Single element less than target >>> min_subarray_len(5, [5]) == 1 # Single element equal to target","solution":"def min_subarray_len(target, nums): n = len(nums) min_len = float('inf') current_sum = 0 left = 0 for right in range(n): current_sum += nums[right] while current_sum >= target: min_len = min(min_len, right - left + 1) current_sum -= nums[left] left += 1 return min_len if min_len != float('inf') else 0"},{"question":"def shift_letters(s: str, k: int) -> str: Shifts all the letters in the string s by k positions in the alphabet. Digits remain unchanged. Parameters: s (str): The input string containing letters and digits. k (int): The number of positions to shift the letters. Returns: str: The transformed string. >>> shift_letters('abc123', 1) 'bcd123' >>> shift_letters('xyz', 3) 'abc' >>> shift_letters('XYZ', 3) 'ABC' >>> shift_letters('a1b2', 2) 'c1d2' >>> shift_letters('AaBb', 1) 'BbCc' >>> shift_letters('abc', 27) 'bcd' >>> shift_letters('ABC', 27) 'BCD' >>> shift_letters('NoChange123', 0) 'NoChange123' >>> shift_letters('abc', -1) 'zab' >>> shift_letters('XYZ', -1) 'WXY' >>> shift_letters('abc', -27) 'zab' >>> shift_letters('XYZ', -27) 'WXY'","solution":"def shift_letters(s, k): Shifts all the letters in the string s by k positions in the alphabet. Digits remain unchanged. Parameters: s (str): The input string containing letters and digits. k (int): The number of positions to shift the letters. Returns: str: The transformed string. def shift_character(c, k): if c.isalpha(): if c.islower(): return chr((ord(c) - ord('a') + k) % 26 + ord('a')) else: return chr((ord(c) - ord('A') + k) % 26 + ord('A')) return c return ''.join(shift_character(c, k) for c in s)"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def oddEvenList(head): Reorder a linked list to arrange nodes with odd indices followed by nodes with even indices. >>> def create_linked_list(elements): >>> head = ListNode(elements[0]) >>> current = head >>> for elem in elements[1:]: >>> current.next = ListNode(elem) >>> current = current.next >>> return head >>> def linked_list_to_list(head): >>> result = [] >>> while head: >>> result.append(head.val) >>> head = head.next >>> return result >>> head = create_linked_list([1, 2, 3, 4, 5]) >>> new_head = oddEvenList(head) >>> print(linked_list_to_list(new_head)) # Output: [1, 3, 5, 2, 4] >>> head = create_linked_list([2, 1, 3, 5, 6, 4, 7]) >>> new_head = oddEvenList(head) >>> print(linked_list_to_list(new_head)) # Output: [2, 3, 6, 7, 1, 5, 4]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def oddEvenList(head): if not head or not head.next: return head odd = head even = head.next even_head = even while even and even.next: odd.next = even.next odd = odd.next even.next = odd.next even = even.next odd.next = even_head return head"},{"question":"def remove_elements(nums, indices): Removes elements from nums at the indices specified in indices list. Parameters: nums (list of int): The array of numbers from which elements will be removed. indices (list of int): The array of indices specifying which elements to remove. Returns: list of int: The array after specified elements have been removed. Example: >>> remove_elements([1, 2, 3, 4, 5], [1, 3]) [1, 3, 5] >>> remove_elements([10, 20, 30, 40, 50], [4, 3, 2, 1, 0]) [] >>> remove_elements([7, 8, 9], []) [7, 8, 9] >>> remove_elements([5, 10, 15, 20, 25], [4, 2, 1]) [5, 20] >>> remove_elements([11, 22, 33], [1]) [11, 33]","solution":"def remove_elements(nums, indices): Removes elements from nums at the indices specified in indices list. Parameters: nums (list of int): The array of numbers from which elements will be removed. indices (list of int): The array of indices specifying which elements to remove. Returns: list of int: The array after specified elements have been removed. indices.sort(reverse=True) for index in indices: nums.pop(index) return nums"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def getNodeNumbers(root): Given a binary tree, return an array of size two. The first element of the array should be the count of leaf nodes (nodes with no children) in the tree, and the second element should be the count of internal nodes (nodes that have at least one child). If the tree is empty (i.e., root is null), return [0, 0]. >>> root = TreeNode(1) >>> getNodeNumbers(root) [1, 0] >>> root.left = TreeNode(2) >>> getNodeNumbers(root) [1, 1] >>> root.right = TreeNode(3) >>> getNodeNumbers(root) [2, 1]","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def getNodeNumbers(root): Returns an array where the first element is the count of leaf nodes and the second element is the count of internal nodes. if not root: return [0, 0] def count_nodes(node): if not node.left and not node.right: return (1, 0) leaves = 0 internals = 1 if node.left: left_leaves, left_internals = count_nodes(node.left) leaves += left_leaves internals += left_internals if node.right: right_leaves, right_internals = count_nodes(node.right) leaves += right_leaves internals += right_internals return (leaves, internals) return list(count_nodes(root))"},{"question":"from typing import List def two_sum(nums: List[int], target: int) -> List[int]: Find the indices of two distinct elements in the array that sum up to a given target. >>> set(two_sum([2, 7, 11, 15], 9)) == {0, 1} >>> set(two_sum([-3, 4, 3, 90], 0)) == {0, 2} >>> set(two_sum([1, 2, 3, 4, 4], 8)) == {3, 4} >>> set(two_sum([2, 5, 5, 11], 10)) == {1, 2} >>> two_sum([], 5) is None >>> two_sum([1, 2, 3], 7) is None","solution":"def two_sum(nums, target): Returns indices of the two numbers such that they add up to the target. :param nums: List[int] - List of integers :param target: int - Target sum :return: List[int] - Indices of the two numbers that add up to target num_to_index = {} for index, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], index] num_to_index[num] = index"},{"question":"def max_good_strings(s: str) -> int: Returns the maximum number of good strings (non-empty) that can be obtained by deleting some (possibly none, but not all) characters from s. Each good string is a non-empty subsequence of s. >>> max_good_strings(\\"a\\") == 1 >>> max_good_strings(\\"abcde\\") == 5 >>> max_good_strings(\\"aaaa\\") == 1 >>> max_good_strings(\\"ababab\\") == 6 >>> max_good_strings(\\"aabac\\") == 4 >>> max_good_strings(\\"\\") == 0 >>> max_good_strings(\\"aabba\\") == 3","solution":"def max_good_strings(s): Returns the maximum number of good strings (non-empty) that can be obtained by deleting some (possibly none, but not all) characters from s. Each good string is a non-empty subsequence of s. if not s: return 0 count = 1 # Since we always have at least one good string (the string itself if we delete none) for i in range(1, len(s)): if s[i] != s[i-1]: count += 1 return count"},{"question":"def count_chars(words: List[str], chars: str) -> int: Returns the sum of the lengths of all strings in words that can be formed by chars. >>> count_chars([\\"cat\\",\\"bt\\",\\"hat\\",\\"tree\\"], \\"atach\\") 6 >>> count_chars([\\"hello\\",\\"world\\"], \\"abcd\\") 0 >>> count_chars([\\"hello\\",\\"world\\"], \\"helloworld\\") 10 >>> count_chars([\\"apple\\",\\"orange\\",\\"banana\\"], \\"applena\\") 5 >>> count_chars([], \\"abcd\\") 0 >>> count_chars([\\"a\\", \\"b\\", \\"c\\"], \\"\\") 0 >>> count_chars([\\"longword\\"], \\"short\\") 0 >>> count_chars([\\"dog\\"], \\"dogo\\") 3","solution":"from collections import Counter def count_chars(words, chars): Returns the sum of the lengths of all strings in words that can be formed by chars. chars_count = Counter(chars) total_length = 0 for word in words: word_count = Counter(word) can_form = True for letter, count in word_count.items(): if chars_count[letter] < count: can_form = False break if can_form: total_length += len(word) return total_length"},{"question":"from typing import List from collections import Counter def can_form_palindrome_with_k_distinct(s: str, k: int) -> bool: Determine if it is possible to rearrange the characters of the string to form a palindrome with exactly k distinct characters. :param s: the input string :param k: the number of distinct characters desired in the palindrome :return: True if such a palindrome can be formed, False otherwise >>> can_form_palindrome_with_k_distinct(\\"aabbcc\\", 3) True >>> can_form_palindrome_with_k_distinct(\\"aabbcc\\", 2) True >>> can_form_palindrome_with_k_distinct(\\"aabbc\\", 2) True >>> can_form_palindrome_with_k_distinct(\\"abc\\", 2) False >>> can_form_palindrome_with_k_distinct(\\"aabbcc\\", 4) False >>> can_form_palindrome_with_k_distinct(\\"a\\", 1) True >>> can_form_palindrome_with_k_distinct(\\"a\\", 2) False >>> can_form_palindrome_with_k_distinct(\\"aaa\\", 1) True >>> can_form_palindrome_with_k_distinct(\\"aaa\\", 2) False >>> can_form_palindrome_with_k_distinct(\\"\\", 0) True >>> can_form_palindrome_with_k_distinct(\\"\\", 1) False","solution":"from collections import Counter def can_form_palindrome_with_k_distinct(s, k): Determine if it is possible to rearrange the characters of the string to form a palindrome with exactly k distinct characters. :param s: the input string :param k: the number of distinct characters desired in the palindrome :return: True if such a palindrome can be formed, False otherwise if k > len(s): return False character_count = Counter(s) odd_count = sum(1 for count in character_count.values() if count % 2 != 0) return odd_count <= 1 and len(character_count) >= k"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def deepest_leaves_sum(root): Returns the sum of node values that are located at the deepest level of the tree. Args: root (TreeNode): The root of the binary tree. Returns: int: Sum of deepest level node values. Example: >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> root.left.left.left = TreeNode(8) >>> root.right.right.right = TreeNode(9) >>> deepest_leaves_sum(root) 17 >>> root = None >>> deepest_leaves_sum(root) 0 >>> root = TreeNode(1) >>> deepest_leaves_sum(root) 1 # Your code here","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def deepest_leaves_sum(root): Returns the sum of node values that are located at the deepest level of the tree. Args: root (TreeNode): The root of the binary tree. Returns: int: Sum of deepest level node values. if not root: return 0 queue = deque([root]) level_sum = 0 while queue: level_sum = 0 level_length = len(queue) for _ in range(level_length): node = queue.popleft() level_sum += node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) return level_sum"},{"question":"import heapq from typing import List, Tuple def dijkstra(graph: List[List[Tuple[int, int]]], source: int) -> List[float]: Returns the shortest path from the source to all other nodes in the graph using Dijkstra's algorithm. :param graph: List[List[Tuple[int, int]]], adjacency list of the graph where graph[i] contains pairs [j, w] representing an edge from node \`i\` to node \`j\` with weight \`w\`. :param source: int, the source node :return: List[float], the shortest distance from the source node to each node. If a node is unreachable, the distance will be float('inf') >>> dijkstra([[(1, 1), (2, 4)], [(2, 2), (3, 5)], [(3, 1)], []], 0) [0, 1, 3, 4] >>> dijkstra([[(1, 2)], [(2, 3)], [], [(2, 1)]], 0) [0, 2, 5, float('inf')] >>> dijkstra([[]], 0) [0] >>> dijkstra([[(1, 4)], [], [(3, 1)], []], 0) [0, 4, float('inf'), float('inf')] >>> dijkstra([[(1, 1000)], [(2, 1000)], [(3, 1000)], []], 0) [0, 1000, 2000, 3000]","solution":"import heapq def dijkstra(graph, source): Returns the shortest path from source to all other nodes in the graph using Dijkstra's algorithm. :param graph: List[List[Tuple[int, int]]], adjacency list of the graph where graph[i] contains pairs [j, w] representing an edge from node \`i\` to node \`j\` with weight \`w\`. :param source: int, the source node :return: List[float], the shortest distance from the source node to each node. If a node is unreachable, the distance will be float('inf') n = len(graph) dist = [float('inf')] * n dist[source] = 0 priority_queue = [(0, source)] # (distance, node) while priority_queue: current_dist, current_node = heapq.heappop(priority_queue) # If the distance in the priority queue is greater than the known distance, skip processing if current_dist > dist[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_dist + weight # Only consider this new path if it's better if distance < dist[neighbor]: dist[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return dist"},{"question":"def maxCoins(nums: List[int]) -> int: Find the maximum number of points obtained by bursting balloons. :param nums: List[int] - list of balloon values :return: int - maximum points obtained from solution import maxCoins def test_maxCoins(): assert maxCoins([3,1,5,8]) == 167 assert maxCoins([1,2,3,4]) == 40 assert maxCoins([7,9]) == 81 assert maxCoins([]) == 0","solution":"def maxCoins(nums): Find the maximum number of points obtained by bursting balloons. :param nums: List[int] - list of balloon values :return: int - maximum points obtained n = len(nums) nums = [1] + nums + [1] dp = [[0] * (n + 2) for _ in range(n + 2)] for length in range(1, n + 1): for left in range(1, n - length + 2): right = left + length - 1 for k in range(left, right + 1): dp[left][right] = max(dp[left][right], nums[left - 1] * nums[k] * nums[right + 1] + dp[left][k - 1] + dp[k + 1][right]) return dp[1][n]"},{"question":"from typing import List def max_identical_substrings(s: str, indices: List[int], length: int) -> int: Calculate the maximum count of identical substrings. Parameters: s (str): The given string. indices (list of int): List of starting positions for substrings. length (int): Length of each substring. Returns: int: The maximum count of identical substrings. Examples: >>> max_identical_substrings(\\"abcdefg\\", [0, 2, 4], 2) 1 >>> max_identical_substrings(\\"aaaaaa\\", [0, 1, 2, 3], 2) 4 >>> max_identical_substrings(\\"ababc\\", [0, 2, 3], 2) 2 >>> max_identical_substrings(\\"a\\", [0], 1) 1 >>> max_identical_substrings(\\"abcdabcd\\", [0, 4, 1], 3) 2 >>> max_identical_substrings(\\"abcabcabc\\", [0, 3, 6], 3) 3","solution":"def max_identical_substrings(s, indices, length): Calculate the maximum count of identical substrings. Parameters: s (str): The given string. indices (list of int): List of starting positions for substrings. length (int): Length of each substring. Returns: int: The maximum count of identical substrings. substring_count = {} for index in indices: substring = s[index:index + length] if substring in substring_count: substring_count[substring] += 1 else: substring_count[substring] = 1 # Return the highest count found among the substrings max_count = max(substring_count.values()) if substring_count else 0 return max_count"},{"question":"def max_visible_buildings(heights: List[int]) -> int: Given an array of integers \`heights\` representing the heights of buildings situated in a street, arrange the buildings in such a way that they form a skyline viewed from the street. The goal is to maximize the number of buildings that can be seen from the street. A building \`i\` of height \`heights[i]\` can be seen if and only if there is no building \`j\` with \`j < i\` and \`heights[j] >= heights[i]\`. Return the maximum number of buildings that can be seen from the street in such an arrangement. Note that you are allowed to rearrange the buildings in the \`heights\` array to achieve the desired outcome. >>> max_visible_buildings([2, 2, 2, 2]) 4 >>> max_visible_buildings([1, 2, 3, 4, 5]) 5 >>> max_visible_buildings([5, 4, 3, 2, 1]) 5 >>> max_visible_buildings([3, 1, 4, 5, 2]) 5 >>> max_visible_buildings([10]) 1","solution":"def max_visible_buildings(heights): Returns the maximum number of buildings that can be seen from the street by arranging the buildings in such a way that maximizes visibility. # Sort the buildings in ascending order to arrange them for maximum visibility heights.sort() return len(heights)"},{"question":"from typing import List import bisect def findLongestSubsequence(nums: List[int]) -> int: Returns the length of the longest strictly increasing subsequence in nums. >>> findLongestSubsequence([]) == 0 >>> findLongestSubsequence([10]) == 1 >>> findLongestSubsequence([1, 2, 3, 4, 5]) == 5 >>> findLongestSubsequence([5, 4, 3, 2, 1]) == 1 >>> findLongestSubsequence([10, 9, 2, 5, 3, 7, 101, 18]) == 4 >>> findLongestSubsequence([5, 5, 5, 5, 5]) == 1 >>> findLongestSubsequence([0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]) == 6","solution":"import bisect def findLongestSubsequence(nums): Returns the length of the longest strictly increasing subsequence in nums. if not nums: return 0 lis = [] for num in nums: pos = bisect.bisect_left(lis, num) if pos == len(lis): lis.append(num) else: lis[pos] = num return len(lis)"},{"question":"def findMaxLength(arr: List[int]) -> int: Given an integer array arr, find the maximum length of a subarray with equal number of 0s and 1s. >>> findMaxLength([0, 1]) == 2 >>> findMaxLength([0, 1, 0]) == 2 >>> findMaxLength([0, 1, 1, 0]) == 4 >>> findMaxLength([1, 1, 1, 1]) == 0 >>> findMaxLength([0, 0, 0, 0]) == 0 >>> findMaxLength([0, 1, 0, 1, 0, 1, 1, 0, 0, 1]) == 10 >>> findMaxLength([1, 0, 1, 0, 1, 1, 0, 0]) == 8 >>> findMaxLength([0, 1, 1, 0, 1, 0, 0]) == 6 >>> findMaxLength([1, 0, 1, 0, 1, 0, 0, 1]) == 8 >>> findMaxLength([1, 1, 0, 0, 1]) == 4 >>> findMaxLength([0, 0, 1, 1, 0, 1]) == 6","solution":"def findMaxLength(nums): Find the maximum length of a subarray with equal number of 0s and 1s. count_map = {0: -1} # Initialize the count map with an initial count of 0 at index -1 max_length = 0 count = 0 for i, num in enumerate(nums): count = count + 1 if num == 1 else count - 1 if count in count_map: max_length = max(max_length, i - count_map[count]) else: count_map[count] = i return max_length"},{"question":"from typing import List def max_subarray_len_circular(arr: List[int], k: int) -> int: Returns the maximum length of a contiguous subarray that sums up to a given target \`k\` in a circular array. If no such subarray exists, returns -1. >>> max_subarray_len_circular([3, 1, 2, 1, 1, 3], 6) 3 >>> max_subarray_len_circular([2, 1, 1, 1, 1, 1], 4) 4 >>> max_subarray_len_circular([1, 2, 3, 4, 5], 20) -1 >>> max_subarray_len_circular([5, 1, 2, 3, 4], 15) 5 >>> max_subarray_len_circular([7], 7) 1 >>> max_subarray_len_circular([7], 5) -1 >>> max_subarray_len_circular([1, 2, 3, 2, 2, 3], 6) 3 >>> max_subarray_len_circular([3, 3, 3, 3, 3], 9) 3 >>> max_subarray_len_circular([3, 3, 3, 3, 3], 6) 2 >>> max_subarray_len_circular([3, -1, 2, 1, 1, -3, 4], 4) 6 >>> max_subarray_len_circular([3, -1, 2, 1, 1, -3, 4], 5) 5","solution":"def max_subarray_len_circular(arr, k): Returns the maximum length of a contiguous subarray that sums up to a given target \`k\` in a circular array. If no such subarray exists, returns -1. n = len(arr) max_len = -1 def subarray_sum(arr, k): curr_sum = 0 sum_dict = {0: -1} max_len = -1 for i in range(len(arr)): curr_sum += arr[i] if (curr_sum - k) in sum_dict: max_len = max(max_len, i - sum_dict[curr_sum - k]) if curr_sum not in sum_dict: sum_dict[curr_sum] = i return max_len # Check the normal array once max_len = max(max_len, subarray_sum(arr, k)) # Check the circular part total_sum = sum(arr) if total_sum >= k: inv_k = total_sum - k inv_subarray_len = subarray_sum([-x for x in arr], inv_k) if inv_subarray_len != -1: max_len = max(max_len, n - inv_subarray_len) return max_len"},{"question":"def is_valid_parenthesis_sequence(s: str) -> bool: Determines if a given string s is a valid parenthesis sequence. A string is considered a valid parenthesis sequence if every opening parenthesis '(' has a corresponding closing parenthesis ')', and the pairs of parentheses are properly nested. Parameters: s (str): The input string containing parentheses. Returns: bool: True if the string is a valid parenthesis sequence, False otherwise. pass def test_valid_parenthesis_sequence(): assert is_valid_parenthesis_sequence(\\"()\\") == True assert is_valid_parenthesis_sequence(\\"(()(()))\\") == True def test_invalid_parenthesis_sequence(): assert is_valid_parenthesis_sequence(\\"(()\\") == False assert is_valid_parenthesis_sequence(\\")(\\") == False assert is_valid_parenthesis_sequence(\\"(())(\\") == False def test_empty_string(): assert is_valid_parenthesis_sequence(\\"\\") == True def test_no_parentheses(): assert is_valid_parenthesis_sequence(\\"abc\\") == True def test_mixed_characters(): assert is_valid_parenthesis_sequence(\\"(a+b) * (c/d)\\") == True assert is_valid_parenthesis_sequence(\\"((a+b))\\") == True assert is_valid_parenthesis_sequence(\\"(a+b)) * (c/d)\\") == False assert is_valid_parenthesis_sequence(\\"((a+b) * (c/d)\\") == False","solution":"def is_valid_parenthesis_sequence(s): Determines if a given string s is a valid parenthesis sequence. A string is considered a valid parenthesis sequence if every opening parenthesis '(' has a corresponding closing parenthesis ')', and the pairs of parentheses are properly nested. Parameters: s (str): The input string containing parentheses. Returns: bool: True if the string is a valid parenthesis sequence, False otherwise. stack = [] for char in s: if char == '(': stack.append('(') elif char == ')': if stack and stack[-1] == '(': stack.pop() else: return False return len(stack) == 0"},{"question":"def construct_permutation(n: int, k: int) -> List[int]: Constructs a permutation of numbers from 1 to n where the absolute difference between any two adjacent elements is at most k. Returns the permutation or an empty list if no such permutation exists. >>> construct_permutation(4, 3) # Example of a valid permutation: [1, 2, 3, 4] >>> construct_permutation(5, 6) # Example of an invalid case: []","solution":"def construct_permutation(n, k): Constructs a permutation of numbers from 1 to n where the absolute difference between any two adjacent elements is at most k. Returns the permutation or an empty list if no such permutation exists. if k < 1 or k >= n: return [] permutation = [] for i in range(1, n+1): permutation.append(i) return permutation"},{"question":"from typing import List def can_be_balanced(s: str) -> bool: Determine if it is possible to make the string balanced by performing at most one removal. A string is considered balanced if the number of occurrences of each character is even. >>> can_be_balanced(\\"aabbcc\\") == True >>> can_be_balanced(\\"aaabbbccc\\") == False >>> can_be_balanced(\\"aabbccdde\\") == True >>> can_be_balanced(\\"a\\") == True >>> can_be_balanced(\\"aabbccd\\") == True >>> can_be_balanced(\\"aaabbbcccddd\\") == False >>> can_be_balanced(\\"\\") == True","solution":"def can_be_balanced(s): from collections import Counter count = Counter(s) num_odds = sum(1 for char_count in count.values() if char_count % 2 != 0) return num_odds <= 1 # Example usage # print(can_be_balanced(\\"aabbcc\\")) # Expected Output: True # print(can_be_balanced(\\"aaabbbccc\\")) # Expected Output: False # print(can_be_balanced(\\"aabbccdde\\")) # Expected Output: True # print(can_be_balanced(\\"a\\")) # Expected Output: True"},{"question":"def is_palindrome_permutation(s: str) -> bool: Determine if a string is a valid palindrome permutation. >>> is_palindrome_permutation('aabbcc') True >>> is_palindrome_permutation('aabbc') True >>> is_palindrome_permutation('aabbcd') False >>> is_palindrome_permutation('a') True >>> is_palindrome_permutation('') True >>> is_palindrome_permutation('abc') False >>> is_palindrome_permutation('racecar') True","solution":"def is_palindrome_permutation(s): Determine if a string is a valid palindrome permutation. :param s: String containing only lowercase alphabets. :return: True if the string is a valid palindrome permutation, False otherwise. from collections import Counter # Count the frequency of each character char_counts = Counter(s) # Determine how many characters have an odd count odd_count = sum(1 for count in char_counts.values() if count % 2 != 0) # A valid palindrome permutation can have at most one character with an odd count return odd_count <= 1"},{"question":"def min_removals_to_make_valid(arr: str) -> int: Computes the minimum number of parentheses that need to be removed to make the string valid. Parameters: arr (str): A string consisting of parentheses ('(' and ')'). Returns: int: The minimum number of removals required to make the string valid. # Your implementation here # Unit tests def test_min_removals_to_make_valid_balanced(): assert min_removals_to_make_valid(\\"()()\\") == 0 def test_min_removals_to_make_valid_one_unmatched(): assert min_removals_to_make_valid(\\"()())()\\") == 1 assert min_removals_to_make_valid(\\"(()\\") == 1 def test_min_removals_to_make_valid_multiple_unmatched(): assert min_removals_to_make_valid(\\")()(\\") == 2 assert min_removals_to_make_valid(\\"((()))())\\") == 1 def test_min_removals_to_make_valid_all_valid(): assert min_removals_to_make_valid(\\"\\") == 0 assert min_removals_to_make_valid(\\"()()()()()\\") == 0 def test_min_removals_to_make_valid_long_string(): assert min_removals_to_make_valid(\\"((())())()(())(())\\") == 0 assert min_removals_to_make_valid(\\"((()()()())\\") == 1 assert min_removals_to_make_valid(\\"()())(()())(()\\") == 2","solution":"def min_removals_to_make_valid(arr): Computes the minimum number of parentheses that need to be removed to make the string valid. Parameters: arr (str): A string consisting of parentheses ('(' and ')'). Returns: int: The minimum number of removals required to make the string valid. # Initialization of required variables balance = 0 # Balance between '(' and ')' removals = 0 # Minimum removals required to balance the string # Iterate through the characters in the string for char in arr: if char == '(': balance += 1 # Increment balance for open parenthesis elif char == ')': if balance == 0: # If balance is 0 and we encounter a closing parenthesis, # it means it's an unmatched closing parenthesis. removals += 1 else: # If there's already an open parenthesis to match with, # decrement the balance. balance -= 1 # Sum of unmatched open and closing parentheses is the result return removals + balance"},{"question":"def count_pairs(nums, d): Returns the number of pairs (i, j) where i < j such that nums[j] - nums[i] == d. :param nums: List of integers. :param d: A non-negative integer. :return: Count of such pairs.","solution":"def count_pairs(nums, d): Returns the number of pairs (i, j) where i < j such that nums[j] - nums[i] == d. :param nums: List of integers. :param d: A non-negative integer. :return: Count of such pairs. count = 0 n = len(nums) for i in range(n): for j in range(i+1, n): if nums[j] - nums[i] == d: count += 1 return count"},{"question":"def max_profit(prices: List[int]) -> int: Returns the maximum profit that can be achieved from buying and selling on different days. If no profit can be achieved, returns 0. >>> max_profit([5]) 0 >>> max_profit([7, 6, 4, 3, 1]) 0 >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([1, 2, 3, 4, 5]) 4 >>> max_profit([9, 7, 4, 3, 8, 10]) 7 >>> max_profit([]) 0","solution":"def max_profit(prices): Returns the maximum profit that can be achieved from buying and selling on different days. If no profit can be achieved, returns 0. :param prices: List of stock prices. :type prices: List[int] :return: Maximum profit. :rtype: int # Base case: If the prices list is empty or contains only one element, no profit can be made if not prices or len(prices) < 2: return 0 min_price = prices[0] # Initialize with the first price max_profit = 0 # Initialize max profit to 0 # Iterate over the prices starting from the second element for price in prices[1:]: # Calculate the potential profit for the current price profit = price - min_price # Update the max profit if the current profit is higher if profit > max_profit: max_profit = profit # Update the min price if the current price is lower if price < min_price: min_price = price return max_profit"},{"question":"def longest_subarray_with_diff(nums, k): Returns the length of the longest subarray where the difference between the maximum and minimum elements is less than or equal to k. >>> longest_subarray_with_diff([10, 1, 2, 4, 7, 2], 5) 4 >>> longest_subarray_with_diff([4, 2, 2, 2, 4, 4, 2, 2], 0) 3 >>> longest_subarray_with_diff([1], 0) 1 >>> longest_subarray_with_diff([1, 3, 6, 7, 9, 10], 100) 6 >>> longest_subarray_with_diff([], 5) 0","solution":"from collections import deque def longest_subarray_with_diff(nums, k): Returns the length of the longest subarray where the difference between the maximum and minimum elements is less than or equal to k. if not nums: return 0 max_deque, min_deque = deque(), deque() left = 0 max_length = 0 for right, num in enumerate(nums): while max_deque and nums[max_deque[-1]] <= num: max_deque.pop() max_deque.append(right) while min_deque and nums[min_deque[-1]] >= num: min_deque.pop() min_deque.append(right) while nums[max_deque[0]] - nums[min_deque[0]] > k: left += 1 if max_deque[0] < left: max_deque.popleft() if min_deque[0] < left: min_deque.popleft() max_length = max(max_length, right - left + 1) return max_length"},{"question":"def maximal_square_area(grid): You are given an \`n x n\` 2D matrix \`grid\` representing an image where each cell can have a value of 0 or 1. A \`1\` in the matrix represents a part of an object, and a \`0\` represents empty space. Your task is to find the largest square containing only 1's and return the area of that square. >>> grid1 = [ ... [1, 0, 1, 0, 0], ... [1, 0, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 0, 0, 1, 0] ... ] >>> maximal_square_area(grid1) 4 >>> grid2 = [ ... [0, 1], ... [1, 0] ... ] >>> maximal_square_area(grid2) 1 >>> grid3 = [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ] >>> maximal_square_area(grid3) 0 >>> grid4 = [ ... [1, 1, 1, 1], ... [1, 1, 1, 1], ... [1, 1, 1, 1], ... [1, 1, 1, 1] ... ] >>> maximal_square_area(grid4) 16 >>> grid5 = [ ... [1] ... ] >>> maximal_square_area(grid5) 1 >>> grid6 = [ ... [0] ... ] >>> maximal_square_area(grid6) 0 >>> maximal_square_area([]) 0 >>> maximal_square_area([[]]) 0","solution":"def maximal_square_area(grid): if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) dp = [[0] * cols for _ in range(rows)] max_side = 0 for i in range(rows): for j in range(cols): if grid[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side * max_side"},{"question":"from typing import List def count_rectangles(points: List[List[int]]) -> int: Count the number of rectangles that can be formed using given points on a 2D plane. Rectangles must be axis-aligned. :param points: List of [x, y] coordinates :return: Number of rectangles that can be formed from solution import count_rectangles def test_no_rectangles(): assert count_rectangles([[1, 1], [2, 2], [3, 3]]) == 0 def test_one_rectangle(): assert count_rectangles([[1, 1], [1, 2], [2, 1], [2, 2]]) == 1 def test_multiple_rectangles(): assert count_rectangles([[1, 1], [1, 2], [1, 3], [2, 1], [2, 2], [2, 3], [3, 1], [3, 2], [3, 3]]) == 9 def test_large_input(): points = [[0, 0], [0, 1], [1, 0], [1, 1], [2, 0], [2, 1]] assert count_rectangles(points) == 3 def test_no_points(): assert count_rectangles([]) == 0 def test_single_line(): assert count_rectangles([[1, 1], [1, 2], [1, 3], [1, 4]]) == 0 def test_square(): assert count_rectangles([[0, 0], [0, 1], [1, 0], [1, 1], [0, 2], [1, 2]]) == 3","solution":"def count_rectangles(points): Count the number of rectangles that can be formed using given points on a 2D plane. Rectangles must be axis-aligned. :param points: List of [x, y] coordinates :return: Number of rectangles that can be formed from collections import defaultdict # Dictionary to maintain a set of all y-coordinates for every x-coordinate x_dict = defaultdict(set) # Fill the dictionary for x, y in points: x_dict[x].add(y) count = 0 # List of all x coordinates sorted x_keys = sorted(x_dict.keys()) n = len(x_keys) # Iterate over pairs of x-coordinates for i in range(n): for j in range(i + 1, n): x1, x2 = x_keys[i], x_keys[j] # Find the common y-coordinates between vertical lines (x1, y) and (x2, y) common_y = x_dict[x1].intersection(x_dict[x2]) # If there are at least two common y-coordinates, calculate combinations if len(common_y) >= 2: # Number of ways to pick 2 out of len(common_y) num_y = len(common_y) count += (num_y * (num_y - 1)) // 2 return count"},{"question":"def max_number_of_substrings(s: str) -> int: Calculate the maximum number of non-overlapping substrings with consecutive identical characters in the given string. >>> max_number_of_substrings(\\"a\\") 1 >>> max_number_of_substrings(\\"abc\\") 3 >>> max_number_of_substrings(\\"aaa\\") 1 >>> max_number_of_substrings(\\"aaabb\\") 2 >>> max_number_of_substrings(\\"aaabbb\\") 2 >>> max_number_of_substrings(\\"aabba\\") 3 >>> max_number_of_substrings(\\"\\") 0 >>> max_number_of_substrings(\\"a\\" * 1000 + \\"b\\" * 1000 + \\"c\\" * 1000) 3","solution":"def max_number_of_substrings(s): if not s: return 0 count = 1 for i in range(1, len(s)): if s[i] != s[i-1]: count += 1 return count"},{"question":"def max_strawberries(matrix): Returns the maximum number of strawberries that can be collected by drawing a single straight line horizontally or vertically. :param matrix: List[List[str]] - the grid representing the field :return: int - the maximum number of strawberries that can be collected pass from max_strawberries import max_strawberries def test_example_case(): matrix = [ ['S', '.', 'S'], ['.', 'S', '.'], ['S', 'S', '.'] ] assert max_strawberries(matrix) == 2 def test_empty_matrix(): matrix = [] assert max_strawberries(matrix) == 0 def test_single_row(): matrix = [['S', '.', 'S', 'S']] assert max_strawberries(matrix) == 3 def test_single_column(): matrix = [['S'], ['.'], ['S'], ['S']] assert max_strawberries(matrix) == 3 def test_no_strawberries(): matrix = [['.', '.', '.']] assert max_strawberries(matrix) == 0 def test_all_strawberries(): matrix = [['S', 'S'], ['S', 'S']] assert max_strawberries(matrix) == 2 def test_large_matrix(): matrix = [ ['.','.','S','.','.'], ['S','.','.','S','S'], ['S','.','.','.','.'], ['.','S','S','.','.'] ] assert max_strawberries(matrix) == 3","solution":"def max_strawberries(matrix): Returns the maximum number of strawberries that can be collected by drawing a single straight line horizontally or vertically. :param matrix: List[List[str]] - the grid representing the field :return: int - the maximum number of strawberries that can be collected if not matrix or not matrix[0]: return 0 max_strawberries = 0 # Check rows for row in matrix: max_strawberries = max(max_strawberries, row.count('S')) # Check columns for col in range(len(matrix[0])): col_count = sum(matrix[row][col] == 'S' for row in range(len(matrix))) max_strawberries = max(max_strawberries, col_count) return max_strawberries"},{"question":"from typing import List def max_items(costs: List[int], B: int) -> int: Returns the maximum number of unique items that can be bought with a given budget B. Arguments: costs -- list of integers, where each integer represents the cost of an item B -- an integer representing the budget Returns: The maximum number of unique items that can be bought without exceeding the budget B.","solution":"from typing import List def max_items(costs: List[int], B: int) -> int: Returns the maximum number of unique items that can be bought with a given budget B. Arguments: costs -- list of integers, where each integer represents the cost of an item B -- an integer representing the budget Returns: The maximum number of unique items that can be bought without exceeding the budget B. costs.sort() total_cost = 0 items_bought = 0 for cost in costs: if total_cost + cost <= B: total_cost += cost items_bought += 1 else: break return items_bought"},{"question":"from typing import List def find_pair_with_sum(nums: List[int], target: int) -> List[int]: Finds a pair of integers in the provided list such that their sum is equal to the target number. Returns the indices of the two numbers if such a pair exists, otherwise returns an empty list. >>> find_pair_with_sum([2, 7, 11, 15], 9) [0, 1] >>> find_pair_with_sum([1, 2, 3, 4], 8) [] >>> find_pair_with_sum([1, 2, 2, 3], 4) [1, 2] >>> find_pair_with_sum([-1, -2, -3, -4], -5) [1, 2] >>> find_pair_with_sum([-1, 2, 3, -4], -5) [0, 3]","solution":"def find_pair_with_sum(nums, target): Finds a pair of integers in the provided list such that their sum is equal to the target number. Returns the indices of the two numbers if such a pair exists, otherwise returns an empty list. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i return []"},{"question":"def minimum_communication_time(n: int, edges: List[Tuple[int, int, int]]) -> int: Determine the minimum total communication time to enable all departments to communicate with each other. Parameters: n (int): The number of departments. edges (List[Tuple[int, int, int]]): A list of tuples representing cables, each tuple contains two departments and the time delay. Returns: int: The minimum communication time, or -1 if it's impossible for all departments to communicate. Examples: >>> minimum_communication_time(4, [(0, 1, 1), (1, 2, 2), (2, 3, 1), (0, 3, 4)]) 4 >>> minimum_communication_time(4, [(0, 1, 1), (1, 2, 2)]) -1 >>> minimum_communication_time(1, []) 0 >>> minimum_communication_time(2, [(0, 1, 10)]) 10 >>> minimum_communication_time(3, [(0, 1, 5), (0, 2, 10), (1, 2, 1)]) 6 >>> minimum_communication_time(3, [(0, 1, 1), (1, 2, 1), (0, 2, 1), (0, 1, 2)]) 2","solution":"def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) def union(parent, rank, x, y): rootX = find(parent, x) rootY = find(parent, y) if rank[rootX] < rank[rootY]: parent[rootX] = rootY elif rank[rootX] > rank[rootY]: parent[rootY] = rootX else: parent[rootY] = rootX rank[rootX] += 1 def minimum_communication_time(n, edges): if n == 1: return 0 edges.sort(key=lambda edge: edge[2]) parent = [i for i in range(n)] rank = [0] * n min_time = 0 edge_count = 0 for edge in edges: a, b, t = edge rootA = find(parent, a) rootB = find(parent, b) if rootA != rootB: union(parent, rank, rootA, rootB) min_time += t edge_count += 1 if edge_count == n - 1: break if edge_count != n - 1: return -1 return min_time"},{"question":"from typing import List def subtree_sizes(n: int, parents: List[int]) -> List[int]: Return an array \`answers\` of size \`n\` where \`answers[i]\` is the number of nodes in the subtree rooted at node \`i\`, including \`i\` itself. >>> subtree_sizes(1, [-1]) [1] >>> subtree_sizes(2, [-1, 0]) [2, 1] >>> subtree_sizes(3, [-1, 0, 1]) [3, 2, 1] >>> subtree_sizes(3, [-1, 0, 0]) [3, 1, 1] >>> subtree_sizes(5, [-1, 0, 0, 1, 1]) [5, 3, 1, 1, 1] >>> subtree_sizes(5, [-1, 0, 0, 2, 2]) [5, 1, 3, 1, 1] >>> subtree_sizes(6, [-1, 0, 1, 1, 2, 2]) [6, 5, 3, 1, 1, 1] >>> subtree_sizes(6, [-1, 0, 0, 2, 2, 4]) [6, 1, 4, 1, 2, 1] >>> subtree_sizes(6, [-1, 0, 1, 2, 3, 4]) [6, 5, 4, 3, 2, 1] >>> subtree_sizes(4, [-1, 0, 1, 1]) [4, 3, 1, 1] >>> subtree_sizes(5, [-1, 0, 1, 2, 2]) [5, 4, 3, 1, 1] >>> subtree_sizes(7, [-1, 0, 0, 1, 1, 1, 2]) [7, 4, 2, 1, 1, 1, 1] >>> subtree_sizes(9, [-1, 0, 0, 1, 1, 1, 2, 2, 2]) [9, 4, 4, 1, 1, 1, 1, 1, 1]","solution":"def subtree_sizes(n, parents): from collections import defaultdict # Create an adjacency list for the tree children = defaultdict(list) for child, parent in enumerate(parents): if parent != -1: children[parent].append(child) def dfs(node): size = 1 # include the current node for child in children[node]: size += dfs(child) answer[node] = size return size answer = [0] * n dfs(0) # Start DFS traversal from the root node (0) return answer"},{"question":"def maximum_difference(nums): Returns the maximum difference between two elements nums[i] and nums[j] such that i < j. Returns -1 if no such elements exist. >>> maximum_difference([7, 1, 5, 4]) 4 >>> maximum_difference([9, 4, 3, 2]) -1 >>> maximum_difference([1, 5, 3, 19, 18, 25]) 24 >>> maximum_difference([30, 10, 8, 2]) -1 >>> maximum_difference([1, 1, 1, 1]) -1 >>> maximum_difference([1, 2, 2, 2, 2]) 1 >>> maximum_difference([-10, -20, -30, -40]) -1 >>> maximum_difference([-30, -20, -10, 0, 10]) 40 >>> maximum_difference([]) -1 >>> maximum_difference([1]) -1 >>> maximum_difference([1, 2]) 1 >>> maximum_difference([2, 1]) -1 pass","solution":"def maximum_difference(nums): Returns the maximum difference between two elements nums[i] and nums[j] such that i < j. Returns -1 if no such elements exist. if not nums or len(nums) < 2: return -1 min_value = nums[0] max_diff = -1 for j in range(1, len(nums)): if nums[j] > min_value: max_diff = max(max_diff, nums[j] - min_value) min_value = min(min_value, nums[j]) return max_diff"},{"question":"from typing import List def maxHungryPeople(grid: List[List[int]]) -> int: Return the maximum number of people that can be placed in the restaurants by selecting non-overlapping subgrids. >>> maxHungryPeople([ ... [1, 2], ... [3, 4] ... ]) 10 >>> maxHungryPeople([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 45 >>> maxHungryPeople([ ... [0, 2, 3], ... [4, 0, 6], ... [0, 8, 9] ... ]) 32 >>> maxHungryPeople([ ... [1, 2, 0], ... [4, 0, 6], ... [7, 8, 0] ... ]) 28 >>> maxHungryPeople([ ... [1, 2, 3, 4] ... ]) 10 >>> maxHungryPeople([ ... [1], ... [2], ... [3], ... [4] ... ]) 10","solution":"from typing import List def maxHungryPeople(grid: List[List[int]]) -> int: def helper(dp: List[List[int]]) -> int: max_sum = 0 for row in dp: max_sum += sum(row) return max_sum m, n = len(grid), len(grid[0]) dp = [[grid[i][j] for j in range(n)] for i in range(m)] total_people = 0 for i in range(m): for j in range(n): if (i == 0 or j == 0 or dp[i-1][j] == 0 or dp[i][j-1] == 0): total_people += grid[i][j] dp[i][j] = 0 else: dp2 = [[0] * n for _ in range(m)] for x in range(i, m): for y in range(j, n): dp2[x][y] = min(dp2[x-1][y] if x > 0 else grid[x][y], dp2[x][y-1] if y > 0 else grid[x][y], grid[x][y]) if (x > 0 and y > 0) else grid[x][y] subgrid_people = helper(dp2) total_people = max(total_people, subgrid_people) return total_people"},{"question":"def sum_of_digits(num: int) -> int: Returns the sum of the digits of a number until it becomes a single-digit number. >>> sum_of_digits(38) 2 >>> sum_of_digits(123456789) 9 pass","solution":"def sum_of_digits(num): Returns the sum of the digits of a number until it becomes a single-digit number. while num >= 10: num = sum(int(digit) for digit in str(num)) return num"},{"question":"def longest_substring_with_goodness_k(s: str, k: int) -> int: Find the length of the longest substring with goodness exactly k. A substring is defined as any contiguous sequence of characters within the string. The \\"goodness\\" of a substring is defined as the number of distinct characters in that substring. :param s: A string consisting only of lowercase English letters. :param k: An integer representing the required goodness. :return: The length of the longest substring with goodness exactly k, or -1 if no such substring exists. >>> longest_substring_with_goodness_k(\\"aabacbebebe\\", 3) == 7 >>> longest_substring_with_goodness_k(\\"aabbcc\\", 2) == 4 >>> longest_substring_with_goodness_k(\\"aabbcc\\", 3) == 6 >>> longest_substring_with_goodness_k(\\"abcabcabc\\", 2) == 2 >>> longest_substring_with_goodness_k(\\"abcabcabc\\", 4) == -1 >>> longest_substring_with_goodness_k(\\"aaaaa\\", 1) == 5 >>> longest_substring_with_goodness_k(\\"\\", 1) == -1 >>> longest_substring_with_goodness_k(\\"aabacbebebe\\", 0) == -1 >>> longest_substring_with_goodness_k(\\"a\\", 1) == 1 >>> longest_substring_with_goodness_k(\\"a\\", 2) == -1","solution":"def longest_substring_with_goodness_k(s, k): Find the length of the longest substring with goodness exactly k. :param s: A string consisting only of lowercase English letters. :param k: An integer representing the required goodness. :return: The length of the longest substring with goodness exactly k, or -1 if no such substring exists. from collections import defaultdict n = len(s) if n == 0 or k == 0: return -1 left = 0 char_count = defaultdict(int) distinct_count = 0 max_length = -1 for right in range(n): if char_count[s[right]] == 0: distinct_count += 1 char_count[s[right]] += 1 while distinct_count > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: distinct_count -= 1 left += 1 if distinct_count == k: max_length = max(max_length, right - left + 1) return max_length if max_length != -1 else -1"},{"question":"from typing import List, Tuple def two_sum(nums: List[int], target: int) -> Tuple[int, int]: Given an array of integers and a target value, determine if there are two numbers in the array that add up to the target value. Return the indices of the two numbers in the form of a tuple (index1, index2). If no such pair exists, return an empty tuple. >>> two_sum([2, 7, 11, 15], 9) == (0, 1) >>> two_sum([2, 7, 11, 15], 10) == () >>> two_sum([1, 2, 3, 4, 5], 8) == (2, 4) >>> two_sum([3, 3], 6) == (0, 1) >>> two_sum([-1, -2, -3, -4, -5], -8) == (2, 4)","solution":"def two_sum(nums, target): Given an array of integers and a target value, determine if there are two numbers in the array that add up to the target value. Return the indices of the two numbers in the form of a tuple (index1, index2). If no such pair exists, return an empty tuple. :param nums: List[int], a list of integers :param target: int, the target sum :return: tuple, the indices of the two numbers that sum up to the target num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return (num_to_index[complement], i) num_to_index[num] = i return ()"},{"question":"def longestSubstringWithTwoDistinct(s: str) -> int: Given a string \`s\` consisting of only lowercase letters, return the length of the longest contiguous substring that contains at most two distinct characters. >>> longestSubstringWithTwoDistinct('ab') == 2 >>> longestSubstringWithTwoDistinct('aaaa') == 4 >>> longestSubstringWithTwoDistinct('abc') == 2 >>> longestSubstringWithTwoDistinct('eceba') == 3 >>> longestSubstringWithTwoDistinct('') == 0 >>> longestSubstringWithTwoDistinct('abcabcabc') == 2 >>> longestSubstringWithTwoDistinct('abcd') == 2","solution":"def longestSubstringWithTwoDistinct(s): Returns the length of the longest contiguous substring that contains at most two distinct characters. if len(s) == 0: return 0 left = 0 max_length = 0 char_map = {} for right in range(len(s)): char_map[s[right]] = char_map.get(s[right], 0) + 1 while len(char_map) > 2: char_map[s[left]] -= 1 if char_map[s[left]] == 0: del char_map[s[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"from typing import List from collections import Counter def is_subset(a: Counter, b: Counter) -> bool: Checks if string b is a subset of string a. pass def wordSubsets(words1: List[str], words2: List[str]) -> List[str]: Returns an array of all the strings in words1 which are subsets of all the strings in words2. >>> wordSubsets([\\"amazon\\", \\"apple\\", \\"facebook\\", \\"google\\", \\"leetcode\\"], [\\"e\\", \\"o\\"]) [\\"facebook\\", \\"google\\", \\"leetcode\\"] >>> wordSubsets([], [\\"e\\", \\"o\\"]) [] >>> wordSubsets([\\"amazon\\", \\"apple\\", \\"facebook\\", \\"google\\", \\"leetcode\\"], []) [\\"amazon\\", \\"apple\\", \\"facebook\\", \\"google\\", \\"leetcode\\"] >>> wordSubsets([\\"amazon\\", \\"apple\\", \\"facebook\\", \\"google\\", \\"leetcode\\"], [\\"z\\", \\"x\\"]) [] >>> wordSubsets([\\"amazing\\", \\"zebra\\", \\"alpha\\", \\"beta\\"], [\\"a\\", \\"z\\"]) [\\"amazing\\", \\"zebra\\"] >>> wordSubsets([\\"amazon\\", \\"apple\\", \\"facebook\\", \\"google\\", \\"leetcode\\"], [\\"l\\", \\"e\\", \\"t\\"]) [\\"leetcode\\"] pass","solution":"from collections import Counter def is_subset(a, b): Checks if string b is a subset of string a. counter_a = Counter(a) counter_b = Counter(b) for char, count in counter_b.items(): if counter_a[char] < count: return False return True def wordSubsets(words1, words2): Returns an array of all the strings in words1 which are subsets of all the strings in words2. def merge_max_count(words): merged_count = Counter() for word in words: word_count = Counter(word) for char, count in word_count.items(): merged_count[char] = max(merged_count[char], count) return merged_count words2_count = merge_max_count(words2) result = [] for word in words1: if is_subset(word, words2_count): result.append(word) return result"},{"question":"from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def deepest_leaves_sum(root: Optional[TreeNode]) -> int: Return the sum of the values of the deepest leaves in the binary tree. >>> root = TreeNode(1, TreeNode(2, TreeNode(4)), TreeNode(3)) >>> deepest_leaves_sum(root) 4 >>> root = None >>> deepest_leaves_sum(root) 0 def test_deepest_leaves_sum(): root = TreeNode(1) assert deepest_leaves_sum(root) == 1 root = TreeNode(1, TreeNode(2), TreeNode(3)) assert deepest_leaves_sum(root) == 2 + 3 root = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, right=TreeNode(6, right=TreeNode(7)))) assert deepest_leaves_sum(root) == 7 assert deepest_leaves_sum(None) == 0 root = TreeNode(1, TreeNode(2, TreeNode(4, TreeNode(7))), TreeNode(3)) assert deepest_leaves_sum(root) == 7 root = TreeNode( 1, TreeNode(2, TreeNode(4, TreeNode(7)), TreeNode(5)), TreeNode(3, TreeNode(6, TreeNode(8), TreeNode(9))) ) assert deepest_leaves_sum(root) == 7 + 8 + 9","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def deepest_leaves_sum(root): if not root: return 0 queue = deque([root]) while queue: level_sum = 0 for _ in range(len(queue)): node = queue.popleft() level_sum += node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) return level_sum"},{"question":"def longestUniqueSubarray(nums: List[int]) -> int: Returns the length of the longest subarray with all unique elements. >>> longestUniqueSubarray([]) 0 >>> longestUniqueSubarray([1]) 1 >>> longestUniqueSubarray([1, 2, 3, 4, 5]) 5 >>> longestUniqueSubarray([1, 1, 1, 1]) 1 >>> longestUniqueSubarray([1, 2, 1, 3, 4, 2]) 4 >>> longestUniqueSubarray([1, 2, 1, 2, 3, 4]) 4 >>> longestUniqueSubarray(list(range(10000)) + [1, 2, 3]) 10000","solution":"def longestUniqueSubarray(nums): Returns the length of the longest subarray with all unique elements. if not nums: return 0 seen = {} max_length = 0 start = 0 for end, value in enumerate(nums): if value in seen: start = max(start, seen[value] + 1) seen[value] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def largestBSTSubtree(root: TreeNode) -> int: Find the size of the largest subtree (by number of nodes) that is a valid Binary Search Tree (BST) in the given binary tree. >>> root = TreeNode(2) >>> root.left = TreeNode(1) >>> root.right = TreeNode(3) >>> largestBSTSubtree(root) 3 >>> root = TreeNode(2) >>> root.left = TreeNode(3) >>> root.right = TreeNode(1) >>> largestBSTSubtree(root) 1 >>> largestBSTSubtree(None) 0","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def largestBSTSubtree(root: TreeNode) -> int: def helper(node): if not node: # A base case where the subtree is empty, considered a valid BST with size 0 return 0, float('inf'), float('-inf'), 0 l_size, l_min, l_max, l_bst_size = helper(node.left) r_size, r_min, r_max, r_bst_size = helper(node.right) if l_max < node.val < r_min: # If current node is forming a BST with its left and right subtrees size = 1 + l_size + r_size return size, min(node.val, l_min), max(node.val, r_max), size return 1 + l_size + r_size, float('-inf'), float('inf'), max(l_bst_size, r_bst_size) return helper(root)[3]"},{"question":"def max_total_profit(profits, workers, staff): Determine the maximum total profit the company can achieve given the profits and worker requirements of projects, and the available staff skill levels. Each staff member can work on at most one project and can only work on projects that require a number of workers less than or equal to their skill level. >>> max_total_profit([10, 20, 30], [1, 2, 3], [3, 2, 1]) == 60 >>> max_total_profit([10, 20, 30], [5, 6, 7], [3, 2, 1]) == 0 >>> max_total_profit([10, 20, 30], [1, 2, 3], [3]) == 30 >>> max_total_profit([10, 20, 30, 40], [1, 2, 3, 4], [2, 2, 1, 1]) == 30 >>> max_total_profit([10, 20, 30, 40], [1, 2, 3, 4], [5, 5, 5, 5]) == 100","solution":"def max_total_profit(profits, workers, staff): projects = sorted(zip(profits, workers), key=lambda x: (-x[0], x[1])) available_staff = sorted(staff, reverse=True) total_profit = 0 for profit, worker_required in projects: for i in range(len(available_staff)): if available_staff[i] >= worker_required: total_profit += profit available_staff.pop(i) break return total_profit"},{"question":"def maximalSquare(matrix: List[List[int]]) -> int: Given a 2D integer array matrix representing a grid of m x n dimensions, where each cell contains either 0 (empty) or 1 (occupied), find the size of the largest square containing only 1s and return its area. >>> maximalSquare([]) == 0 >>> maximalSquare([[0,0],[0,0]]) == 0 >>> maximalSquare([[1]]) == 1 >>> maximalSquare([[1,0,1,0],[1,0,1,1],[1,1,1,1],[0,1,1,0]]) == 4 >>> maximalSquare([[1,1],[1,1]]) == 4 >>> maximalSquare([[1,0,1,0,0],[1,0,1,1,1],[1,1,1,1,1],[1,0,0,1,0]]) == 4 pass","solution":"def maximalSquare(matrix): if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) dp = [[0] * n for _ in range(m)] max_side = 0 for i in range(m): for j in range(n): if matrix[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 # first row or first column else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side * max_side"},{"question":"def maximalSquare(matrix: List[List[int]]) -> int: Given a matrix of integers where each element represents the height at that point, find the size of the largest square containing only 1s and return its area. A square consists of 1s if and only if all the cells within that square are 1. >>> maximalSquare([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) == 0 >>> maximalSquare([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) == 1 >>> maximalSquare([ ... [1, 1, 0], ... [1, 1, 0], ... [0, 0, 1] ... ]) == 4 >>> maximalSquare([ ... [1, 1, 1, 1], ... [1, 1, 1, 1], ... [1, 1, 1, 1], ... [1, 1, 1, 1] ... ]) == 16 >>> maximalSquare([ ... [1, 0, 1, 0, 0], ... [1, 0, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 0, 0, 1, 0] ... ]) == 4 >>> maximalSquare([]) == 0","solution":"def maximalSquare(matrix): if not matrix or not matrix[0]: return 0 rows, cols = len(matrix), len(matrix[0]) dp = [[0] * cols for _ in range(rows)] max_side = 0 for i in range(rows): for j in range(cols): if matrix[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side ** 2"},{"question":"def longest_substring_with_same_char(s: str, n: int) -> int: Returns the length of the longest substring containing the same character after performing at most n operations. >>> longest_substring_with_same_char(\\"ABAB\\", 2) 4 >>> longest_substring_with_same_char(\\"A\\", 1) 1 >>> longest_substring_with_same_char(\\"ABCDE\\", 1) 2 >>> longest_substring_with_same_char(\\"AAAA\\", 0) 4 >>> longest_substring_with_same_char(\\"AAABB\\", 2) 5 >>> longest_substring_with_same_char(\\"AABABBA\\", 1) 4 >>> longest_substring_with_same_char(\\"ABCDEF\\", 10) 6","solution":"def longest_substring_with_same_char(s, n): Returns the length of the longest substring containing the same character after performing at most n operations. from collections import Counter max_len = 0 start = 0 freq = Counter() max_count = 0 for end in range(len(s)): freq[s[end]] += 1 max_count = max(max_count, freq[s[end]]) if (end - start + 1) - max_count > n: freq[s[start]] -= 1 start += 1 max_len = max(max_len, end - start + 1) return max_len"},{"question":"def find_pairs_with_sum(arr: List[int], x: int) -> List[Tuple[int, int]]: Return a list of pairs in the array whose sum is equal to x. Examples: >>> find_pairs_with_sum([1, 2, 3, 4, 3], 6) [(2, 4), (3, 3)] >>> find_pairs_with_sum([0, -1, 2, -3, 1], -2) [(-3, 1)] >>> find_pairs_with_sum([1, 2, 3, 4, 5], 10) [] >>> find_pairs_with_sum([1, 5, 7, -1, 5], 6) [(-1, 7), (1, 5)] >>> find_pairs_with_sum([1, 1, 1, 1], 2) [(1, 1)]","solution":"def find_pairs_with_sum(arr, x): Return a list of pairs in the array whose sum is equal to x. pairs = set() seen = set() for number in arr: target = x - number if target in seen: pairs.add((min(number, target), max(number, target))) seen.add(number) return sorted(list(pairs))"},{"question":"from typing import List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def generate_trees(n: int) -> List[TreeNode]: Given an integer \`n\`, return all the structurally unique BST's (binary search trees) which has exactly \`n\` nodes of unique values from \`1\` to \`n\`. Return the result in any order. >>> trees = generate_trees(3) >>> len(trees) 5 >>> trees = generate_trees(0) >>> len(trees) 0 >>> trees = generate_trees(1) >>> len(trees) 1 >>> trees[0].val 1 >>> trees[0].left None >>> trees[0].right None >>> trees = generate_trees(2) >>> len(trees) 2 >>> trees[0].val 1 >>> trees[0].right.val 2 >>> trees[0].left None >>> trees[1].val 2 >>> trees[1].left.val 1 >>> trees[1].right None","solution":"from typing import List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def generate_trees(n: int) -> List[TreeNode]: if n == 0: return [] def build_trees(start, end): if start > end: return [None] all_trees = [] for i in range(start, end + 1): left_trees = build_trees(start, i - 1) right_trees = build_trees(i + 1, end) for L in left_trees: for R in right_trees: current_tree = TreeNode(i) current_tree.left = L current_tree.right = R all_trees.append(current_tree) return all_trees return build_trees(1, n)"},{"question":"def get_maximum_final_element(nums: List[int]) -> int: Returns the maximum possible value of the final element after repeatedly picking any two elements and replacing them with their sum. >>> get_maximum_final_element([5]) 5 >>> get_maximum_final_element([1, 2]) 3 >>> get_maximum_final_element([1, 2, 3, 4, 5]) 15 >>> get_maximum_final_element([-1, -2, 3, 4, 5]) 9 >>> get_maximum_final_element([-1, -2, -3, -4, -5]) -15 >>> get_maximum_final_element([1000000, 2000000, 3000000]) 6000000","solution":"def get_maximum_final_element(nums): Returns the maximum possible value of the final element after repeatedly picking any two elements and replacing them with their sum. return sum(nums)"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a string expression containing only non-negative integers, addition (+), subtraction (-) and multiplication (*) operators. The expression is evaluated based on operator precedence. >>> evaluate_expression(\\"2+3\\") == 5 >>> evaluate_expression(\\"5-2\\") == 3 >>> evaluate_expression(\\"4*3\\") == 12 >>> evaluate_expression(\\"3+2*2\\") == 7 >>> evaluate_expression(\\"5-2*2\\") == 1 >>> evaluate_expression(\\"3+5*2-4\\") == 9 >>> evaluate_expression(\\"2+3+4+5\\") == 14 >>> evaluate_expression(\\"3*3*3\\") == 27 >>> evaluate_expression(\\"10-3-2-1\\") == 4 >>> evaluate_expression(\\"7\\") == 7 >>> evaluate_expression(\\"9*5\\") == 45 >>> evaluate_expression(\\"8-3\\") == 5 >>> evaluate_expression(\\"6+2\\") == 8","solution":"def evaluate_expression(expression): Evaluates a string expression containing only non-negative integers, addition (+), subtraction (-) and multiplication (*) operators. The expression is evaluated based on operator precedence. def helper(s, idx): stack = [] num = 0 sign = '+' while idx < len(s): char = s[idx] if char.isdigit(): num = num * 10 + int(char) if char in \\"+-*\\": if sign == '+': stack.append(num) elif sign == '-': stack.append(-num) elif sign == '*': stack.append(stack.pop() * num) sign = char num = 0 idx += 1 if sign == '+': stack.append(num) elif sign == '-': stack.append(-num) elif sign == '*': stack.append(stack.pop() * num) return sum(stack) return helper(expression, 0)"},{"question":"from collections import deque def word_ladder_length(start: str, target: str, words: list) -> int: Returns the length of the shortest transformation sequence from start to target word. If no such sequence exists, return 0. def test_word_ladder_success(): words = [\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\",\\"cog\\"] start = \\"hit\\" target = \\"cog\\" assert word_ladder_length(start, target, words) == 5 def test_word_ladder_single_transformation(): words = [\\"hot\\",\\"dot\\",\\"dog\\"] start = \\"hit\\" target = \\"dot\\" assert word_ladder_length(start, target, words) == 3 def test_word_ladder_unreachable(): words = [\\"hot\\",\\"dot\\",\\"dog\\"] start = \\"hit\\" target = \\"cog\\" assert word_ladder_length(start, target, words) == 0 def test_word_ladder_empty_words(): words = [] start = \\"hit\\" target = \\"cog\\" assert word_ladder_length(start, target, words) == 0 def test_word_ladder_no_start_in_words(): words = [\\"hot\\",\\"dot\\",\\"dog\\"] start = \\"abc\\" target = \\"hot\\" assert word_ladder_length(start, target, words) == 0 def test_word_ladder_direct_connection(): words = [\\"hit\\",\\"hot\\"] start = \\"hit\\" target = \\"hot\\" assert word_ladder_length(start, target, words) == 2 if __name__ == \\"__main__\\": test_word_ladder_success() test_word_ladder_single_transformation() test_word_ladder_unreachable() test_word_ladder_empty_words() test_word_ladder_no_start_in_words() test_word_ladder_direct_connection()","solution":"from collections import deque def word_ladder_length(start: str, target: str, words: list) -> int: Returns the length of the shortest transformation sequence from start to target word. If no such sequence exists, return 0. if target not in words: return 0 word_set = set(words) queue = deque([(start, 1)]) # Each element in the queue is a tuple (current_word, current_length) while queue: current_word, current_length = queue.popleft() if current_word == target: return current_length # Try changing each character in the current word to every possible lowercase letter for i in range(len(current_word)): for c in 'abcdefghijklmnopqrstuvwxyz': next_word = current_word[:i] + c + current_word[i+1:] if next_word in word_set: word_set.remove(next_word) queue.append((next_word, current_length + 1)) return 0"},{"question":"class TransactionSystem: A system to manage and monitor transactions. >>> ts = TransactionSystem([100, -50, 200]) >>> ts.currentBalance() 250 >>> ts.addTransaction(50) >>> ts.currentBalance() 300 >>> ts.maxTransaction() 200 >>> ts.addTransaction(300) >>> ts.maxTransaction() 300 def __init__(self, transactions): Initializes the system with the given list of transactions. pass def addTransaction(self, amount): Adds a new transaction to the end of the transactions list. pass def currentBalance(self): Returns the current balance which is the sum of all transactions in the list. pass def maxTransaction(self): Returns the maximum transaction amount recorded. pass","solution":"class TransactionSystem: def __init__(self, transactions): Initializes the system with the given list of transactions. self.transactions = transactions def addTransaction(self, amount): Adds a new transaction to the end of the transactions list. self.transactions.append(amount) def currentBalance(self): Returns the current balance which is the sum of all transactions in the list. return sum(self.transactions) def maxTransaction(self): Returns the maximum transaction amount recorded. return max(self.transactions)"},{"question":"from typing import List def max_points(points: List[int]) -> int: Calculate the maximum number of points that can be accumulated by optimally choosing to spend or discard tokens according to the given rules. Args: points (List[int]): An array of integers where points[i] represents the number of points gained from spending the token at position i. Returns: int: The maximum points that can be accumulated. Examples: >>> max_points([1, 2, 3, 1]) 4 >>> max_points([2, 7, 9, 3, 1]) 12 >>> max_points([2, 1, 4, 5, 3, 1, 1, 3]) 12 >>> max_points([]) 0 >>> max_points([5]) 5 >>> max_points([10]) 10 >>> max_points([5, 10]) 10 >>> max_points([10, 5]) 10 >>> max_points([100, 1, 100, 1, 100, 1]) 300 >>> max_points([10, 10, 10, 10, 10]) 30","solution":"def max_points(points): n = len(points) if n == 0: return 0 elif n == 1: return points[0] dp = [0] * n dp[0] = points[0] if n > 1: dp[1] = max(points[0], points[1]) for i in range(2, n): dp[i] = max(dp[i - 1], points[i] + dp[i - 2]) return dp[-1]"},{"question":"def find_word_indices(s: str, dict: List[str]) -> List[int]: Returns a list of starting indices of each word from the dictionary in the string s in ascending order. >>> find_word_indices(\\"thisisateststring\\", [\\"test\\"]) [7] >>> find_word_indices(\\"thisisateststring\\", [\\"test\\", \\"this\\"]) [0, 7] >>> find_word_indices(\\"thisisateststring\\", [\\"hello\\", \\"world\\"]) [] >>> find_word_indices(\\"foobarbaz\\", [\\"foo\\", \\"bar\\", \\"baz\\"]) [0, 3, 6] >>> find_word_indices(\\"abababab\\", [\\"ab\\"]) [0, 2, 4, 6] >>> find_word_indices(\\"prefixmatchsuffix\\", [\\"pre\\", \\"prefix\\"]) [0, 0]","solution":"def find_word_indices(s, dict): Returns a list of starting indices of each word from the dictionary in the string s. indices = [] for word in dict: start = 0 while True: start = s.find(word, start) if start == -1: break indices.append(start) start += 1 # Move past the last found word's start position return sorted(indices)"},{"question":"def maximalRectangle(matrix: List[List[int]]) -> int: Given a 2D binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area. >>> maximalRectangle([ ... [1, 0, 1, 0, 0], ... [1, 0, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 0, 0, 1, 0] ... ]) == 6 >>> maximalRectangle([ ... [0, 0], ... [0, 0] ... ]) == 0 >>> maximalRectangle([ ... [1, 1], ... [1, 1] ... ]) == 4 >>> maximalRectangle([ ... [1, 0, 1, 1, 1] ... ]) == 3 >>> maximalRectangle([ ... [1], ... [1], ... [0], ... [1], ... [1] ... ]) == 2 >>> maximalRectangle([]) == 0 >>> maximalRectangle([ ... [1, 0, 1], ... [1, 1, 1] ... ]) == 3 # Your code here","solution":"def maximalRectangle(matrix): Given a 2D binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area. if not matrix or not matrix[0]: return 0 max_area = 0 num_cols = len(matrix[0]) heights = [0] * num_cols for row in matrix: for j in range(num_cols): heights[j] = heights[j] + 1 if row[j] == 1 else 0 max_area = max(max_area, largestRectangleArea(heights)) return max_area def largestRectangleArea(heights): Helper function to compute the largest rectangle area in a histogram. stack = [] max_area = 0 heights.append(0) for i in range(len(heights)): while stack and heights[i] < heights[stack[-1]]: h = heights[stack.pop()] w = i if not stack else i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) heights.pop() return max_area"},{"question":"def count_buildings_with_sunset_view(heights): Returns the number of buildings that can see the sunset. >>> count_buildings_with_sunset_view([]) == 0 >>> count_buildings_with_sunset_view([5]) == 1 >>> count_buildings_with_sunset_view([5, 3]) == 2 >>> count_buildings_with_sunset_view([3, 5]) == 1 >>> count_buildings_with_sunset_view([4, 3, 2]) == 3 >>> count_buildings_with_sunset_view([4, 5, 2]) == 2 >>> count_buildings_with_sunset_view([4, 3, 5]) == 1 >>> count_buildings_with_sunset_view([1, 2, 3, 4, 5]) == 1 >>> count_buildings_with_sunset_view([5, 4, 3, 2, 1]) == 5 >>> count_buildings_with_sunset_view([3, 4, 3, 2, 5, 3, 2]) == 3","solution":"def count_buildings_with_sunset_view(heights): Returns the number of buildings that can see the sunset. count = 0 max_height_so_far = 0 # Traverse the heights from right to left for height in reversed(heights): if height > max_height_so_far: count += 1 max_height_so_far = height return count"},{"question":"def longest_increasing_path(matrix: List[List[int]]) -> int: Find the length of the longest path in the matrix where each step increases the value of the previous step. >>> longest_increasing_path([]) 0 >>> longest_increasing_path([[]]) 0 >>> longest_increasing_path([[1]]) 1 >>> longest_increasing_path([ ... [3, 3, 3], ... [3, 3, 3], ... [3, 3, 3] ... ]) 1 >>> longest_increasing_path([ ... [9, 9, 4], ... [6, 6, 8], ... [2, 1, 1] ... ]) 4 >>> longest_increasing_path([ ... [3, 4, 5], ... [3, 2, 6], ... [2, 2, 1] ... ]) 4 >>> longest_increasing_path([ ... [7, 6, 1], ... [2, 7, 6], ... [1, 5, 4] ... ]) 3","solution":"def longest_increasing_path(matrix): Finds the length of the longest path in the matrix where each step increases the value of the previous step. You can move up, down, left, or right from a cell. :param matrix: List[List[int]] :return: int if not matrix or not matrix[0]: return 0 n = len(matrix) m = len(matrix[0]) dp = [[-1 for _ in range(m)] for _ in range(n)] def dfs(i, j): if dp[i][j] != -1: return dp[i][j] directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] max_length = 1 for di, dj in directions: ni, nj = i + di, j + dj if 0 <= ni < n and 0 <= nj < m and matrix[ni][nj] > matrix[i][j]: max_length = max(max_length, 1 + dfs(ni, nj)) dp[i][j] = max_length return dp[i][j] longest_path = 0 for i in range(n): for j in range(m): longest_path = max(longest_path, dfs(i, j)) return longest_path"},{"question":"from collections import Counter def min_removals_to_limit_frequency(s: str, k: int) -> int: Returns the minimum number of characters to remove from the string \`s\` so that the frequency of each distinct character is at most \`k\`. >>> min_removals_to_limit_frequency(\\"aabbbc\\", 3) == 0 >>> min_removals_to_limit_frequency(\\"abcd\\", 1) == 0 >>> min_removals_to_limit_frequency(\\"aaa\\", 1) == 2 >>> min_removals_to_limit_frequency(\\"bbbb\\", 2) == 2 >>> min_removals_to_limit_frequency(\\"aabbccc\\", 2) == 1 >>> min_removals_to_limit_frequency(\\"aabbcc\\", 1) == 3 >>> min_removals_to_limit_frequency(\\"\\", 1) == 0 >>> min_removals_to_limit_frequency(\\"aabbbc\\", 10) == 0 >>> min_removals_to_limit_frequency(\\"aaaaa\\", 10) == 0","solution":"from collections import Counter def min_removals_to_limit_frequency(s, k): Returns the minimum number of characters to remove from the string \`s\` so that the frequency of each distinct character is at most \`k\`. freq = Counter(s) removals = 0 for char, count in freq.items(): if count > k: removals += count - k return removals"},{"question":"def longest_prefix(s: str, words: List[str]) -> str: Returns the longest string from the list words that is a prefix of s. If there is a tie, returns the string that appears earlier in words. :param s: The main string. :param words: A list of words which are prefixes of s. :return: The longest prefix from words that is a prefix of s. >>> longest_prefix(\\"testing\\", [\\"test\\", \\"testing\\", \\"tes\\"]) == \\"testing\\" >>> longest_prefix(\\"testing\\", [\\"tes\\", \\"te\\", \\"t\\"]) == \\"tes\\" >>> longest_prefix(\\"example\\", [\\"x\\", \\"ex\\", \\"e\\"]) == \\"ex\\" >>> longest_prefix(\\"sample\\", [\\"a\\", \\"b\\", \\"c\\"]) == \\"\\" >>> longest_prefix(\\"prefix\\", [\\"pre\\", \\"pref\\", \\"p\\"]) == \\"pref\\" >>> longest_prefix(\\"\\", [\\"a\\", \\"b\\", \\"c\\"]) == \\"\\" >>> longest_prefix(\\"sample\\", []) == \\"\\" pass","solution":"def longest_prefix(s, words): Returns the longest string from the list words that is a prefix of s. If there is a tie, returns the string that appears earlier in words. :param s: The main string. :param words: A list of words which are prefixes of s. :return: The longest prefix from words that is a prefix of s. longest = \\"\\" for word in words: if s.startswith(word): if len(word) > len(longest): longest = word return longest"},{"question":"def is_prefix_string(s: str, words: List[str]) -> bool: Determines if s is a prefix string of any string in words. >>> is_prefix_string(\\"pre\\", [\\"prefix\\", \\"substring\\", \\"test\\"]) == True >>> is_prefix_string(\\"s\\", [\\"prefix\\", \\"substring\\", \\"suffix\\"]) == True >>> is_prefix_string(\\"nonexistent\\", [\\"prefix\\", \\"substring\\", \\"suffix\\"]) == False >>> is_prefix_string(\\"\\", [\\"prefix\\", \\"substring\\", \\"suffix\\"]) == False >>> is_prefix_string(\\"pre\\", []) == False >>> is_prefix_string(\\"prefix\\", [\\"prefix\\", \\"substring\\", \\"suffix\\"]) == True >>> is_prefix_string(\\"abcd\\", [\\"prefix\\", \\"substring\\", \\"suffix\\"]) == False","solution":"def is_prefix_string(s, words): Determines if s is a prefix string of any string in words. Args: s (str): The potential prefix string. words (list of str): The list of strings to check against. Returns: bool: True if s is a prefix string of any string in words, False otherwise. if not s or not words: return False for word in words: if word.startswith(s): return True return False"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root: TreeNode) -> bool: Determine if the BST is height-balanced. >>> is_balanced(None) True >>> is_balanced(TreeNode(1)) True >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> is_balanced(root) True","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root): Determine if the BST is height-balanced. def check_height(node): if not node: return 0, True left_height, left_balanced = check_height(node.left) right_height, right_balanced = check_height(node.right) if not left_balanced or not right_balanced: return 0, False if abs(left_height - right_height) > 1: return 0, False return max(left_height, right_height) + 1, True _, balanced = check_height(root) return balanced"},{"question":"def has_pair_with_sum(arr: List[int], target: int) -> bool: Write a function that takes an array of integers and a target integer as input, and returns whether there are two distinct numbers in the array that add up to the target integer. The function should return true if such a pair exists, and false otherwise. The same element cannot be used twice. >>> has_pair_with_sum([1, 2, 3, 4, 5], 8) True >>> has_pair_with_sum([1, 2, 5], 10) False >>> has_pair_with_sum([1, 9], 10) True >>> has_pair_with_sum([3, 3, 3, 3], 6) True >>> has_pair_with_sum([10, 15, 3, 7], 17) True >>> has_pair_with_sum([1, 1, 1, 1], 2) True >>> has_pair_with_sum([1000000, 500000, 500000], 1000000) True","solution":"def has_pair_with_sum(arr, target): Returns whether there are two distinct numbers in the array that add up to the target integer. seen_numbers = set() for num in arr: complement = target - num if complement in seen_numbers: return True seen_numbers.add(num) return False"},{"question":"from typing import List def can_form_pattern(s: str, p: str) -> bool: Determines if it's possible to rearrange the characters of 's' such that 'p' appears as a substring in the rearranged string. >>> can_form_pattern(\\"abcabc\\", \\"bca\\") == True >>> can_form_pattern(\\"pattern\\", \\"pattern\\") == True >>> can_form_pattern(\\"abcdabc\\", \\"bad\\") == True >>> can_form_pattern(\\"abc\\", \\"abcd\\") == False >>> can_form_pattern(\\"aabbcc\\", \\"aaa\\") == False >>> can_form_pattern(\\"aabcabc\\", \\"aac\\") == True","solution":"def can_form_pattern(s, p): Determines if it's possible to rearrange the characters of 's' such that 'p' appears as a substring in the rearranged string. :param s: string consisting of lowercase English letters :param p: pattern string consisting of lowercase English letters :return: True if it's possible to rearrange 's' to contain 'p' as a substring, False otherwise from collections import Counter s_counter = Counter(s) p_counter = Counter(p) for char, count in p_counter.items(): if s_counter[char] < count: return False return True"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_nth_from_end(head, n): Removes the nth node from the end of the list and returns its head. >>> linked_list_to_list(remove_nth_from_end(list_to_linked_list([1, 2, 3, 4, 5]), 2)) [1, 2, 3, 5] >>> linked_list_to_list(remove_nth_from_end(list_to_linked_list([1, 2, 3, 4, 5]), 6)) [2, 3, 4, 5] >>> linked_list_to_list(remove_nth_from_end(list_to_linked_list([1]), 1)) [] >>> linked_list_to_list(remove_nth_from_end(list_to_linked_list([]), 1)) [] >>> linked_list_to_list(remove_nth_from_end(list_to_linked_list([1, 2, 3]), 1)) [1, 2] def linked_list_to_list(head): result = [] while head: result.append(head.val) head = head.next return result def list_to_linked_list(l): dummy = ListNode(0) current = dummy for val in l: current.next = ListNode(val) current = current.next return dummy.next","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_nth_from_end(head, n): Removes the nth node from the end of the list and returns its head. if not head: return None dummy = ListNode(0) dummy.next = head first = second = dummy # Advance first pointer by n+1 steps to maintain the gap for _ in range(n + 1): if first: first = first.next # Move both pointers until first reaches the end while first: first = first.next second = second.next # Remove the nth node from end if second.next: second.next = second.next.next return dummy.next"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_sort_list(head: ListNode) -> ListNode: Given the head of a singly linked list, return the list after sorting it in ascending order, using O(n log n) time complexity and O(1) space complexity. pass","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_sort_list(head): if not head or not head.next: return head # Helper function to find the middle of the linked list def find_middle(node): slow = fast = node prev = None while fast and fast.next: prev = slow slow = slow.next fast = fast.next.next if prev: prev.next = None # Split the list into two halves return slow # Helper function to merge two sorted linked list def merge(l1, l2): dummy = ListNode() tail = dummy while l1 and l2: if l1.val < l2.val: tail.next = l1 l1 = l1.next else: tail.next = l2 l2 = l2.next tail = tail.next tail.next = l1 if l1 else l2 return dummy.next middle = find_middle(head) left = merge_sort_list(head) right = merge_sort_list(middle) return merge(left, right)"},{"question":"class DirectorySystem: def __init__(self): Initializes the directory system object. pass def createPath(self, path): Creates a new path in the file system. If a directory already exists in the path, it should not be created again. pass def isPathExist(self, path): Checks if a given path exists in the file system. pass def test_createPath_and_isPathExist(): ds = DirectorySystem() ds.createPath(\\"/a\\") assert ds.isPathExist(\\"/a\\") == True assert ds.isPathExist(\\"/a/b\\") == False ds.createPath(\\"/a/b\\") assert ds.isPathExist(\\"/a/b\\") == True ds.createPath(\\"/c/d/e\\") assert ds.isPathExist(\\"/c\\") == True assert ds.isPathExist(\\"/c/d\\") == True assert ds.isPathExist(\\"/c/d/e\\") == True assert ds.isPathExist(\\"/c/d/e/f\\") == False def test_empty_directory_system(): ds = DirectorySystem() assert ds.isPathExist(\\"/\\") == False assert ds.isPathExist(\\"/nonexistent\\") == False def test_redundant_createPath_calls(): ds = DirectorySystem() ds.createPath(\\"/x/y\\") ds.createPath(\\"/x/y\\") assert ds.isPathExist(\\"/x\\") == True assert ds.isPathExist(\\"/x/y\\") == True ds.createPath(\\"/x/y/z\\") assert ds.isPathExist(\\"/x/y/z\\") == True assert ds.isPathExist(\\"/x/y\\") == True ds.createPath(\\"/x/y\\") assert ds.isPathExist(\\"/x/y/z\\") == True","solution":"class DirectorySystem: def __init__(self): self.paths = set() def createPath(self, path): Create a new directory path in the file system. If a directory already exists in the path, it should not be created again. directories = path.split('/') for i in range(1, len(directories) + 1): self.paths.add('/'.join(directories[:i])) def isPathExist(self, path): Check if a given path exists in the file system. return path in self.paths"},{"question":"def reverse_integer(num: int) -> int: Reverses the digits of the input integer \`num\`. If the reversed integer is outside the 32-bit signed integer range [-2^31, 2^31 - 1], returns 0. >>> reverse_integer(123) 321 >>> reverse_integer(-123) -321 >>> reverse_integer(1200) 21 >>> reverse_integer(1534236469) 0 >>> reverse_integer(-1534236469) 0 >>> reverse_integer(0) 0 >>> reverse_integer(5) 5 >>> reverse_integer(-8) -8","solution":"def reverse_integer(num): Reverses the digits of the input integer num. If the reversed integer is outside the 32-bit signed integer range [-2^31, 2^31 - 1], returns 0. INT_MIN, INT_MAX = -2**31, 2**31 - 1 # Handle negative numbers negative = num < 0 num = abs(num) # Reverse the digits reversed_num = 0 while num != 0: digit = num % 10 num //= 10 # Check for overflow before multiplication if reversed_num > (INT_MAX - digit) // 10: return 0 reversed_num = reversed_num * 10 + digit return -reversed_num if negative else reversed_num"},{"question":"def replace_question_marks(s: str) -> str: Given a string \`s\` consisting of alphabetic characters and the question mark character \`?\`, replace every question mark with a lower-case letter ('a' to 'z') such that no two adjacent characters are the same. Return the final string after all replacements. If there are multiple valid strings possible, return any of them. >>> replace_question_marks(\\"abc\\") == \\"abc\\" >>> replace_question_marks(\\"a?c\\") in [\\"abc\\", \\"azc\\"] >>> replace_question_marks(\\"a?\\") in [\\"ab\\", \\"az\\"] >>> all(ch != \\"?\\" and result[i] != result[i+1] for i, ch in enumerate(result := replace_question_marks(\\"a??c\\")) if i != len(result) - 1) >>> all(ch != \\"?\\" and result[i] != result[i+1] for i, ch in enumerate(result := replace_question_marks(\\"a???c\\")) if i != len(result) - 1) >>> n = 5 >>> all(result[i] != result[i+1] for i in range(n - 1) for result in [replace_question_marks(\\"?\\" * n)])","solution":"def replace_question_marks(s): Replaces every question mark in the string \`s\` such that no two adjacent characters are the same. :param s: string containing alphabetic characters and question marks :return: modified string with question marks replaced and no two adjacent characters being the same n = len(s) s = list(s) # Convert string to a list for easier mutation for i in range(n): if s[i] == '?': for c in 'abcdefghijklmnopqrstuvwxyz': if (i > 0 and s[i-1] == c) or (i < n - 1 and s[i+1] == c): continue s[i] = c break return ''.join(s)"},{"question":"from typing import List class MedianFinder: Implement a data structure that maintains a collection of integers and supports the following operations: - MedianFinder(): Initializes the MedianFinder object. - addNum(int num): Adds the integer \`num\` to the data structure. - findMedian(): Returns the median of all elements so far. The median is the middle element if the number of elements is odd, or the average of the two middle elements if the number of elements is even. >>> medianFinder = MedianFinder() >>> medianFinder.addNum(1) >>> medianFinder.addNum(3) >>> medianFinder.addNum(2) >>> medianFinder.findMedian() 2 >>> medianFinder = MedianFinder() >>> medianFinder.addNum(1) >>> medianFinder.addNum(2) >>> medianFinder.findMedian() 1.5 >>> medianFinder.addNum(3) >>> medianFinder.findMedian() 2 >>> medianFinder.addNum(4) >>> medianFinder.findMedian() 2.5 def __init__(self): Initialize your data structure here. pass def addNum(self, num: int) -> None: Add a number to the data structure. pass def findMedian(self) -> float: Find and return the median of the numbers added so far. pass","solution":"import heapq class MedianFinder: def __init__(self): Initialize two heaps. self.max_heap = [] # max-heap for the lower half self.min_heap = [] # min-heap for the upper half def addNum(self, num: int) -> None: Adds the integer \`num\` to the data structure. heapq.heappush(self.max_heap, -num) if self.max_heap and self.min_heap and (-self.max_heap[0] > self.min_heap[0]): val = -heapq.heappop(self.max_heap) heapq.heappush(self.min_heap, val) if len(self.max_heap) > len(self.min_heap) + 1: val = -heapq.heappop(self.max_heap) heapq.heappush(self.min_heap, val) if len(self.min_heap) > len(self.max_heap): val = heapq.heappop(self.min_heap) heapq.heappush(self.max_heap, -val) def findMedian(self) -> float: Returns the median of all elements so far. if len(self.max_heap) > len(self.min_heap): return -self.max_heap[0] return (-self.max_heap[0] + self.min_heap[0]) / 2.0"},{"question":"def rotate(nums, k): Given an array of integers \`nums\` and an integer \`k\`, rotate the array to the right by \`k\` steps, where \`k\` is non-negative. The rotation should be done in-place, meaning you cannot use extra space for another array. Parameters: nums (list): The list of integers to be rotated. k (int): The number of steps to rotate the array. Returns: list: The rotated list. >>> rotate([1, 2, 3, 4, 5], 1) [5, 1, 2, 3, 4] >>> rotate([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5] >>> rotate([1, 2, 3, 4, 5], 0) [1, 2, 3, 4, 5] >>> rotate([1, 2, 3, 4, 5], 6) [5, 1, 2, 3, 4] >>> rotate([1, 2, 3, 4, 5], 11) [5, 1, 2, 3, 4]","solution":"def rotate(nums, k): Rotates the array to the right by k steps. Parameters: nums (list): The list of integers to be rotated. k (int): The number of steps to rotate the array. Returns: list: The rotated list. n = len(nums) k = k % n # Handle cases where k is greater than the length of nums nums[:] = nums[-k:] + nums[:-k] return nums"},{"question":"def min_students_to_move(heights: List[int]) -> int: Returns the minimum number of students that need to be moved to form a new line where each student is taller than the one in front. >>> min_students_to_move([1, 2, 3, 4, 5]) == 0 >>> min_students_to_move([5, 4, 3, 2, 1]) == 4 >>> min_students_to_move([1]) == 0 >>> min_students_to_move([]) == 0 >>> min_students_to_move([3, 1, 2, 5, 4]) == 2 >>> min_students_to_move([1, 3, 2, 3, 5, 4]) == 2","solution":"def min_students_to_move(heights): Returns the minimum number of students that need to be moved to form a new line where each student is taller than the one in front. # Function to find the length of longest increasing subsequence def length_of_LIS(heights): if not heights: return 0 dp = [] for height in heights: idx = binary_search(dp, height) if idx == len(dp): dp.append(height) else: dp[idx] = height return len(dp) # Binary search helper function def binary_search(dp, height): lo, hi = 0, len(dp) while lo < hi: mid = (lo + hi) // 2 if dp[mid] < height: lo = mid + 1 else: hi = mid return lo # Longest increasing subsequence length lis_length = length_of_LIS(heights) # Minimum moves are the number of students minus length of LIS return len(heights) - lis_length"},{"question":"from typing import List def mth_most_frequent(words: List[str], m: int) -> str: Given an array of strings \`words\` and an integer \`m\`, find the **mth** most frequent string in \`words\`. If there are multiple strings with the same frequency, return the one which comes first lexicographically. If \`m\` exceeds the number of distinct strings, return an empty string. >>> mth_most_frequent([\\"apple\\", \\"banana\\", \\"apple\\", \\"apple\\", \\"banana\\", \\"orange\\"], 1) == \\"apple\\" >>> mth_most_frequent([\\"apple\\", \\"banana\\", \\"apple\\", \\"apple\\", \\"banana\\", \\"orange\\"], 2) == \\"banana\\" >>> mth_most_frequent([\\"apple\\", \\"banana\\", \\"apple\\", \\"apple\\", \\"banana\\", \\"orange\\"], 3) == \\"orange\\" >>> mth_most_frequent([\\"apple\\", \\"banana\\", \\"cat\\", \\"cat\\", \\"dog\\", \\"elephant\\"], 1) == \\"cat\\" >>> mth_most_frequent([\\"apple\\", \\"banana\\", \\"cat\\", \\"cat\\", \\"dog\\", \\"elephant\\"], 2) == \\"apple\\" >>> mth_most_frequent([\\"apple\\", \\"banana\\", \\"cat\\", \\"cat\\", \\"dog\\", \\"elephant\\"], 3) == \\"banana\\" >>> mth_most_frequent([\\"apple\\", \\"banana\\", \\"apple\\"], 4) == \\"\\" >>> mth_most_frequent([\\"a\\", \\"b\\", \\"a\\", \\"b\\"], 1) == 'a' >>> mth_most_frequent([\\"a\\", \\"b\\", \\"c\\", \\"a\\", \\"b\\"], 2) == 'b' >>> mth_most_frequent([\\"a\\", \\"A\\", \\"a\\", \\"A\\", \\"b\\", \\"B\\"], 1) == \\"A\\" >>> mth_most_frequent([\\"a\\", \\"A\\", \\"a\\", \\"A\\", \\"b\\", \\"B\\"], 2) == \\"a\\"","solution":"from collections import Counter def mth_most_frequent(words, m): Returns the mth most frequent string in words. If there are multiple strings with the same frequency, return the one which comes first lexicographically. If m exceeds the number of distinct strings, return an empty string. # Count the frequencies of each word frequency = Counter(words) # Create a sorted list of tuples (-frequency, word) to sort first by frequency descending, then lexicographically freq_sorted = sorted(frequency.items(), key=lambda x: (-x[1], x[0])) # Check if m exceeds the number of distinct strings if m > len(freq_sorted): return \\"\\" else: return freq_sorted[m-1][0]"},{"question":"def smallest_lexicographical_string(s: str) -> str: Returns the lexicographically smallest string that can be constructed by choosing each character at most once from the input string \`s\`. pass # Unit Test def test_smallest_lexicographical_string_single_char(): assert smallest_lexicographical_string(\\"a\\") == \\"a\\" def test_smallest_lexicographical_string_all_unique(): assert smallest_lexicographical_string(\\"abc\\") == \\"abc\\" def test_smallest_lexicographical_string_duplicates(): assert smallest_lexicographical_string(\\"bcabc\\"\`, which should return the string \`\\"abc\\"\`. def test_smallest_lexicographical_string_single_char(): assert smallest_lexicographical_string(\\"a\\") == \\"a\\" def test_smallest_lexicographical_string_all_unique(): assert smallest_lexicographical_string(\\"abc\\") == \\"abc\\" def test_smallest_lexicographical_string_duplicates(): assert smallest_lexicographical_string(\\"bcabc\\") == \\"abc\\" def test_smallest_lexicographical_string_multiple_chars(): assert smallest_lexicographical_string(\\"cbcadec\\") == \\"abcde\\" def test_smallest_lexicographical_string_reversed(): assert smallest_lexicographical_string(\\"zyxwvutsrqponmlkjihgfedcba\\") == \\"abcdefghijklmnopqrstuvwxyz\\" def test_smallest_lexicographical_string_all_same_char(): assert smallest_lexicographical_string(\\"aaaa\\") == \\"a\\" def test_smallest_lexicographical_string_empty_string(): assert smallest_lexicographical_string(\\"\\") == \\"\\"","solution":"def smallest_lexicographical_string(s): Returns the lexicographically smallest string that can be constructed by choosing each character at most once from the input string \`s\`. # Create a sorted set of characters from the input string unique_sorted_chars = sorted(set(s)) # Join the characters to form the resulting string return ''.join(unique_sorted_chars)"},{"question":"def findWords(board: List[List[str]], words: List[str]) -> List[str]: Find all the words from the list that can be formed by a sequence of adjacent letters on the board. Words must be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are those horizontally, vertically, or diagonally neighboring. The same letter cell may not be used more than once in a word. Return the words in any order. >>> board = [ ... ['o', 'a', 'a', 'n'], ... ['e', 't', 'a', 'e'], ... ['i', 'h', 'k', 'r'], ... ['i', 'f', 'l', 'v'] ... ] >>> words = [\\"oath\\", \\"pea\\", \\"eat\\", \\"rain\\"] >>> findWords(board, words) [\\"oath\\", \\"eat\\"] from solution import findWords def test_find_words_example(): board = [ ['o', 'a', 'a', 'n'], ['e', 't', 'a', 'e'], ['i', 'h', 'k', 'r'], ['i', 'f', 'l', 'v'] ] words = [\\"oath\\", \\"pea\\", \\"eat\\", \\"rain\\"] result = findWords(board, words) assert set(result) == set([\\"oath\\", \\"eat\\"]) def test_find_words_no_match(): board = [ ['o', 'a', 'a', 'n'], ['e', 't', 'a', 'e'], ['i', 'h', 'k', 'r'], ['i', 'f', 'l', 'v'] ] words = [\\"xyz\\", \\"abcd\\"] result = findWords(board, words) assert result == [] def test_find_words_single_character_board(): board = [['a']] words = [\\"a\\", \\"b\\"] result = findWords(board, words) assert result == [\\"a\\"] def test_find_words_multiple_occurrences(): board = [ [\\"a\\", \\"a\\", \\"a\\"], [\\"a\\", \\"a\\", \\"a\\"], [\\"a\\", \\"a\\", \\"a\\"] ] words = [\\"aaaa\\", \\"aaaaa\\"] result = findWords(board, words) assert set(result) == set([\\"aaaa\\", \\"aaaaa\\"]) def test_find_words_empty_board(): board = [] words = [\\"word\\"] result = findWords(board, words) assert result == [] def test_find_words_empty_words(): board = [ ['o', 'a', 'a', 'n'], ['e', 't', 'a', 'e'], ['i', 'h', 'k', 'r'], ['i', 'f', 'l', 'v'] ] words = [] result = findWords(board, words) assert result == []","solution":"def findWords(board, words): def backtrack(x, y, word, path): if not word: return True if x < 0 or y < 0 or x >= len(board) or y >= len(board[0]): return False if (x, y) in path or board[x][y] != word[0]: return False path.add((x, y)) res = False for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, 1), (1, 1), (-1, -1), (1, -1)]: res = backtrack(x + dx, y + dy, word[1:], path) if res: break path.remove((x, y)) return res found_words = [] for word in words: if any(backtrack(x, y, word, set()) for x in range(len(board)) for y in range(len(board[0]))): found_words.append(word) return found_words"},{"question":"from typing import List class RangeArray: def __init__(self, nums: List[int]): Initializes the object with the integer array nums. self.nums = nums def addRange(self, l: int, r: int, x: int): Adds the integer x to all elements in the subarray defined by [l, r] (0-indexed). pass def maxRange(self, l: int, r: int) -> int: Returns the maximum element in the subarray defined by [l, r] (0-indexed). pass # Test Cases def test_range_array_initialization(): nums = [1, 2, 3, 4, 5] ra = RangeArray(nums) assert ra.nums == [1, 2, 3, 4, 5] def test_addRange_single_element(): nums = [1, 2, 3, 4, 5] ra = RangeArray(nums) ra.addRange(2, 2, 3) assert ra.nums == [1, 2, 6, 4, 5] def test_addRange_full_range(): nums = [1, 2, 3, 4, 5] ra = RangeArray(nums) ra.addRange(0, 4, 1) assert ra.nums == [2, 3, 4, 5, 6] def test_addRange_partial_range(): nums = [1, 2, 3, 4, 5] ra = RangeArray(nums) ra.addRange(1, 3, 2) assert ra.nums == [1, 4, 5, 6, 5] def test_maxRange_single_element(): nums = [1, 2, 3, 4, 5] ra = RangeArray(nums) assert ra.maxRange(2, 2) == 3 def test_maxRange_full_range(): nums = [1, 2, 3, 4, 5] ra = RangeArray(nums) assert ra.maxRange(0, 4) == 5 def test_maxRange_partial_range(): nums = [1, 2, 3, 4, 5] ra = RangeArray(nums) ra.addRange(1, 3, 2) assert ra.maxRange(1, 3) == 6 def test_combined_operations(): nums = [1, 2, 3, 4, 5] ra = RangeArray(nums) ra.addRange(1, 3, 2) ra.addRange(0, 1, 3) assert ra.nums == [4, 7, 5, 6, 5] assert ra.maxRange(1, 4) == 7","solution":"class RangeArray: def __init__(self, nums): Initializes the object with the integer array nums. self.nums = nums def addRange(self, l, r, x): Adds the integer x to all elements in the subarray defined by [l, r]. for i in range(l, r + 1): self.nums[i] += x def maxRange(self, l, r): Returns the maximum element in the subarray defined by [l, r]. return max(self.nums[l:r + 1])"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def good_view_count(root): Returns the count of nodes that have a good view from the root. >>> tree_data = [3, 1, 4, 3, None, 1, 5] >>> root = build_tree(tree_data) >>> good_view_count(root) 4 >>> tree_data = [2, None, 3, None, 4, None, 5, None, 6] >>> root = build_tree(tree_data) >>> good_view_count(root) 5 # Write your code here","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def good_view_count(root): Returns the count of nodes that have a good view from the root. def dfs(node, max_val): if not node: return 0 # A node is considered having a good view if its value is >= max value seen so far good_view = 1 if node.val >= max_val else 0 # Update the max value seen so far max_val = max(max_val, node.val) # Explore left and right children good_view += dfs(node.left, max_val) good_view += dfs(node.right, max_val) return good_view return dfs(root, root.val) if root else 0"},{"question":"def largest_rectangle_area(heights): Calculates the area of the largest rectangle that can be formed in the skyline. :param heights: List[int] - A list of integers representing the heights of buildings. :return: int - The maximum rectangle area possible. pass # Tests def test_largest_rectangle_area_single_building(): assert largest_rectangle_area([5]) == 5 def test_largest_rectangle_area_equal_heights(): assert largest_rectangle_area([2, 2, 2, 2]) == 8 def test_largest_rectangle_area_increasing_heights(): assert largest_rectangle_area([1, 2, 3, 4, 5]) == 9 def test_largest_rectangle_area_decreasing_heights(): assert largest_rectangle_area([5, 4, 3, 2, 1]) == 9 def test_largest_rectangle_area_mixed_heights(): assert largest_rectangle_area([2, 1, 5, 6, 2, 3]) == 10 def test_largest_rectangle_area_complex_case(): assert largest_rectangle_area([3, 6, 5, 7, 4, 8, 1, 0]) == 20 def test_largest_rectangle_area_empty(): assert largest_rectangle_area([]) == 0 def test_largest_rectangle_area_all_zeroes(): assert largest_rectangle_area([0, 0, 0, 0]) == 0 def test_largest_rectangle_area_large_width(): assert largest_rectangle_area([1] * 1000) == 1000","solution":"def largest_rectangle_area(heights): Calculates the area of the largest rectangle that can be formed in the skyline. :param heights: List[int] - A list of integers representing the heights of buildings. :return: int - The maximum rectangle area possible. # Initialize stack and max_area stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def can_complete_tasks(tasks: List[List[int]]) -> bool: Determines if it is possible to complete all tasks without any task exceeding its deadline. :param tasks: List of tasks, where each task is represented by [duration, deadline] :return: Boolean, True if all tasks can be completed within their deadlines, False otherwise. >>> can_complete_tasks([[3, 9], [2, 5], [1, 6]]) == True >>> can_complete_tasks([[10, 2], [2, 5], [1, 6]]) == False >>> can_complete_tasks([[3, 3], [2, 5], [1, 6]]) == True >>> can_complete_tasks([[1, 5], [2, 5], [2, 5]]) == True >>> can_complete_tasks([[4, 8], [2, 4], [1, 3]]) == True >>> can_complete_tasks([]) == True","solution":"def can_complete_tasks(tasks): Determines if it is possible to complete all tasks without any task exceeding its deadline. :param tasks: List of tasks, where each task is represented by [duration, deadline] :return: Boolean, True if all tasks can be completed within their deadlines, False otherwise. # Sort tasks by their deadlines tasks.sort(key=lambda x: x[1]) current_time = 0 for duration, deadline in tasks: current_time += duration if current_time > deadline: return False return True"},{"question":"def max_subarrays(nums: List[int], k: int) -> int: Returns the maximum number of contiguous subarrays such that the difference between the number of \`1\`s and \`0\`s in each subarray is at most \`k\`. >>> max_subarrays([1], 1) == 1 >>> max_subarrays([0], 1) == 1 >>> max_subarrays([1, 1, 1, 1], 1) == 4 >>> max_subarrays([0, 0, 0, 0], 1) == 4 >>> max_subarrays([1, 0, 1, 0], 1) == 4 >>> max_subarrays([1, 1, 0, 0, 1, 0, 0, 1, 1], 1) == 9 >>> max_subarrays([1, 0, 1, 0, 0, 1, 1, 0], 2) == 8 >>> max_subarrays([1, 0, 1, 0, 0, 1, 0], 0) == 7 pass","solution":"def max_subarrays(nums, k): Returns the maximum number of contiguous subarrays such that the difference between the number of \`1\`s and \`0\`s in each subarray is at most \`k\`. n = len(nums) count1 = 0 count0 = 0 max_subarrays_count = 0 start = 0 # Starting index of current subarray for end in range(n): if nums[end] == 1: count1 += 1 elif nums[end] == 0: count0 += 1 # If the current subarray difference exceeds k, move the start forward while abs(count1 - count0) > k: if nums[start] == 1: count1 -= 1 elif nums[start] == 0: count0 -= 1 start += 1 # We found a subarray with the difference within k max_subarrays_count += 1 return max_subarrays_count"},{"question":"def numIslands(grid): Given a grid represented as a 2D matrix of characters (a grid of '0's and '1's), where '1' represents land and '0' represents water, find the number of distinct islands in the grid. An island is formed by connecting '1's horizontally or vertically and is completely surrounded by water (or the edges of the grid). >>> numIslands([ ['1','1','0','0','0'], ['1','1','0','0','0'], ['0','0','1','0','0'], ['0','0','0','1','1'] ]) 3 >>> numIslands([ ['0','0','0'], ['0','0','0'], ['0','0','0'], ]) 0 >>> numIslands([ ['1','1','1'], ['1','1','1'], ['1','1','1'], ]) 1 >>> numIslands([]) 0 >>> numIslands([ ['0','1','0'], ['1','0','1'], ['0','1','0'] ]) 4 pass","solution":"def numIslands(grid): if not grid: return 0 rows = len(grid) cols = len(grid[0]) islands_count = 0 def dfs(x, y): if x < 0 or y < 0 or x >= rows or y >= cols or grid[x][y] != '1': return grid[x][y] = '0' dfs(x + 1, y) dfs(x - 1, y) dfs(x, y + 1) dfs(x, y - 1) for i in range(rows): for j in range(cols): if grid[i][j] == '1': islands_count += 1 dfs(i, j) return islands_count"},{"question":"def longest_common_subsequence_substring(s1, s2): Returns the length of the longest subsequence which is a common substring of both s1 and s2. >>> longest_common_subsequence_substring(\\"abcde\\", \\"ace\\") 1 >>> longest_common_subsequence_substring(\\"abc\\", \\"abc\\") 3 >>> longest_common_subsequence_substring(\\"abc\\", \\"bcd\\") 2 >>> longest_common_subsequence_substring(\\"abcdefg\\", \\"cdef\\") 4 >>> longest_common_subsequence_substring(\\"abc\\", \\"def\\") 0 >>> longest_common_subsequence_substring(\\"a\\", \\"a\\") 1 >>> longest_common_subsequence_substring(\\"a\\", \\"b\\") 0 >>> longest_common_subsequence_substring(\\"abcxyz123\\", \\"xyz\\") 3 >>> longest_common_subsequence_substring(\\"aaa\\", \\"aa\\") 2","solution":"def longest_common_subsequence_substring(s1, s2): Returns the length of the longest subsequence which is a common substring of both s1 and s2. n = len(s1) m = len(s2) dp = [[0] * (m + 1) for _ in range(n + 1)] result = 0 for i in range(1, n + 1): for j in range(1, m + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 result = max(result, dp[i][j]) else: dp[i][j] = 0 return result"},{"question":"def rotate(matrix: List[List[int]]) -> List[List[int]]: Rotates the given n x n 2D matrix by 90 degrees clockwise in-place. :param matrix: List[List[int]] - a 2D list representing the matrix :return: List[List[int]] - the rotated matrix >>> rotate([[1, 2], [3, 4]]) [[3, 1], [4, 2]] >>> rotate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] from typing import List def test_rotate_2x2_matrix(): matrix = [[1, 2], [3, 4]] expected = [[3, 1], [4, 2]] assert rotate(matrix) == expected def test_rotate_3x3_matrix(): matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] expected = [[7, 4, 1], [8, 5, 2], [9, 6, 3]] assert rotate(matrix) == expected def test_rotate_4x4_matrix(): matrix = [[ 5, 1, 9, 11], [ 2, 4, 8, 10], [13, 3, 6, 7], [15, 14, 12, 16]] expected = [[15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11]] assert rotate(matrix) == expected def test_rotate_1x1_matrix(): matrix = [[1]] expected = [[1]] assert rotate(matrix) == expected def test_rotate_5x5_matrix(): matrix = [[ 1, 2, 3, 4, 5], [ 6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25]] expected = [[21, 16, 11, 6, 1], [22, 17, 12, 7, 2], [23, 18, 13, 8, 3], [24, 19, 14, 9, 4], [25, 20, 15, 10, 5]] assert rotate(matrix) == expected","solution":"def rotate(matrix): Rotates the given n x n 2D matrix by 90 degrees clockwise in-place. :param matrix: List[List[int]] - a 2D list representing the matrix :return: List[List[int]] - the rotated matrix n = len(matrix) # Step 1: Transpose the matrix (swap rows and columns) for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Step 2: Reverse each row to get the rotated matrix for i in range(n): matrix[i].reverse() return matrix"},{"question":"def min_stacks_to_remove(stacks): Returns the minimum number of stacks that need to be removed to make the rest of the stacks have the same height. Parameters: stacks (list of int): A list of non-negative integers representing the heights of the stacks. Returns: int: Minimum number of stacks to remove. pass # Unit Tests def test_case_1(): assert min_stacks_to_remove([5, 3, 4, 2, 1, 3]) == 4 def test_case_2(): assert min_stacks_to_remove([1, 2, 3, 2, 2, 2, 3]) == 3 def test_case_3(): assert min_stacks_to_remove([]) == 0 def test_case_4(): assert min_stacks_to_remove([5, 5, 5, 5, 5]) == 0 def test_case_5(): assert min_stacks_to_remove([1, 2, 3, 4, 5]) == 4 def test_case_6(): assert min_stacks_to_remove([2, 2, 2, 1]) == 1 def test_case_7(): assert min_stacks_to_remove([3, 3, 3, 3, 2, 2, 1, 1]) == 4 def test_case_8(): assert min_stacks_to_remove([1, 1, 1, 2, 2, 3]) == 3","solution":"def min_stacks_to_remove(stacks): Returns the minimum number of stacks that need to be removed to make the rest of the stacks have the same height. Parameters: stacks (list of int): A list of non-negative integers representing the heights of the stacks. Returns: int: Minimum number of stacks to remove. from collections import Counter if not stacks: return 0 height_count = Counter(stacks) max_freq = max(height_count.values()) return len(stacks) - max_freq"},{"question":"def valid_tree(n: int, edges: List[Tuple[int, int]]) -> bool: Determines if the given graph is a valid tree. Parameters: - n (int): The number of nodes. - edges (List[Tuple[int, int]]): The edges of the graph. Returns: - bool: True if the graph is a valid tree, otherwise False. >>> valid_tree(5, [(0, 1), (0, 2), (0, 3), (1, 4)]) True >>> valid_tree(4, [(0, 1), (1, 2), (2, 3), (1, 3)]) False >>> valid_tree(4, [(0, 1), (2, 3)]) False >>> valid_tree(1, []) True >>> valid_tree(2, [(0, 1)]) True >>> valid_tree(3, [(0, 1)]) False","solution":"def valid_tree(n, edges): Determines if the given graph is a valid tree. Parameters: - n (int): The number of nodes. - edges (List[Tuple[int, int]]): The edges of the graph. Returns: - bool: True if the graph is a valid tree, otherwise False. if len(edges) != n - 1: return False parent = list(range(n)) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootY] = rootX for u, v in edges: union(u, v) root = find(0) for i in range(1, n): if find(i) != root: return False return True"},{"question":"def minTimeToCompleteTasks(tasks: List[int], k: int) -> int: Returns the minimum amount of time required to complete all the tasks with k workers. >>> minTimeToCompleteTasks([4], 1) 4 >>> minTimeToCompleteTasks([3, 1, 2, 1], 2) 4 >>> minTimeToCompleteTasks([], 5) 0 >>> minTimeToCompleteTasks([2, 1, 2], 5) 2","solution":"def minTimeToCompleteTasks(tasks, k): Returns the minimum amount of time required to complete all the tasks with k workers. from heapq import heapify, heappop, heappush if not tasks: return 0 if k >= len(tasks): return max(tasks) tasks.sort(reverse=True) heap = [0] * k # represents time each worker has worked for task in tasks: heappush(heap, heappop(heap) + task) return max(heap)"},{"question":"def reduce_string(s: str) -> str: Reduces the string \`s\` to the shortest possible length such that the final string is lexicographically smallest among all possible outcomes. >>> reduce_string('a') == 'a' >>> reduce_string('z') == 'z' >>> reduce_string('az') == 'a' >>> reduce_string('ba') == 'a' >>> reduce_string('cc') == 'c' >>> reduce_string('abc') == 'a' >>> reduce_string('xyz') == 'x' >>> reduce_string('aaabbbccc') == 'a' >>> reduce_string('cab') == 'a' >>> reduce_string('fcab') == 'a' >>> reduce_string('abacaba') == 'a' >>> reduce_string('bcaabc') == 'a' >>> reduce_string('bdcbdc') == 'b' >>> reduce_string('abcdab') == 'a'","solution":"def reduce_string(s): Reduces the string \`s\` to the shortest possible length such that the final string is lexicographically smallest among all possible outcomes. while len(s) > 1: min_pair_index = 0 min_pair_value = s[min_pair_index] + s[min_pair_index+1] for i in range(1, len(s) - 1): current_pair_value = s[i] + s[i+1] if current_pair_value < min_pair_value: min_pair_value = current_pair_value min_pair_index = i min_pair_char = min(s[min_pair_index], s[min_pair_index + 1]) s = s[:min_pair_index] + min_pair_char + s[min_pair_index + 2:] return s"},{"question":"from typing import List, Tuple def unique_permutations(nums: List[int]) -> List[Tuple[int]]: Returns all unique permutations of the given list of numbers. Args: nums (List[int]): A list of integers which might contain duplicates. Returns: List[Tuple[int]]: A list of tuples representing all unique permutations. Example: >>> unique_permutations([1, 2, 3]) [(1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)] >>> unique_permutations([1, 1, 2]) [(1, 1, 2), (1, 2, 1), (2, 1, 1)]","solution":"from itertools import permutations def unique_permutations(nums): Returns all unique permutations of the given list of numbers. perms = set(permutations(nums)) return list(perms)"},{"question":"def minTimeRequired(tasks, k): Returns the minimum possible time required to complete all tasks by k workers. >>> minTimeRequired([3, 2, 3], 3) == 3 >>> minTimeRequired([1, 2, 4, 7, 8], 2) == 11 >>> minTimeRequired([3, 3, 3, 3, 3], 3) == 6 >>> minTimeRequired([3, 2, 3], 10) == 3 >>> minTimeRequired([10, 10, 10, 10, 10], 2) == 30 >>> minTimeRequired([5], 1) == 5","solution":"def minTimeRequired(tasks, k): Returns the minimum possible time required to complete all tasks by k workers. def canFinishInTime(tasks, k, max_time): workers = [0] * k for task in tasks: workers.sort() if workers[0] + task > max_time: return False workers[0] += task return True tasks.sort(reverse=True) left, right = max(tasks), sum(tasks) while left < right: mid = (left + right) // 2 if canFinishInTime(tasks, k, mid): right = mid else: left = mid + 1 return left"},{"question":"import heapq from typing import List def find_kth_largest(arr: List[int], k: int) -> int: Returns the k-th largest element in the given array using a min-heap. :param arr: List[int] - the list of integers :param k: int - the k-th largest element to find :return: int - the k-th largest element >>> find_kth_largest([3, 2, 1, 5, 6, 4], 2) 5 >>> find_kth_largest([3, 2, 3, 1, 2, 4, 5, 5, 6], 1) 6 >>> find_kth_largest([3, 2, 3, 1, 2, 4, 5, 5, 6], 9) 1 >>> find_kth_largest([1, 2, 2, 3, 3, 4, 4, 5, 6, 7, 8, 9, 10], 5) 6 >>> find_kth_largest([1], 1) 1 >>> find_kth_largest([1, 2, 3, 4, 5], 6) Traceback (most recent call last): ... ValueError: k should be less than or equal to the length of the array.","solution":"import heapq def find_kth_largest(arr, k): Returns the k-th largest element in the given array using a min-heap. :param arr: List[int] - the list of integers :param k: int - the k-th largest element to find :return: int - the k-th largest element if k > len(arr): raise ValueError(\\"k should be less than or equal to the length of the array.\\") # Using a min-heap to keep track of the k largest elements min_heap = arr[:k] heapq.heapify(min_heap) for num in arr[k:]: if num > min_heap[0]: heapq.heappop(min_heap) heapq.heappush(min_heap, num) return min_heap[0]"},{"question":"def remove_duplicates(s: str) -> str: Removes all duplicate characters such that each character only appears once in the order of their first occurrence in the string. :param s: Input string consisting of lowercase English letters. :return: Resulting string with duplicate characters removed. >>> remove_duplicates(\\"banana\\") == \\"ban\\" >>> remove_duplicates(\\"thequickbrownfoxjumpsoverthelazydog\\") == \\"thequickbrownfxjmpsvlazydg\\" >>> remove_duplicates(\\"aabbccddeeff\\") == \\"abcdef\\" >>> remove_duplicates(\\"aaaaaa\\") == \\"a\\" >>> remove_duplicates(\\"z\\") == \\"z\\" >>> remove_duplicates(\\"\\") == \\"\\" >>> remove_duplicates(\\"abcdef\\") == \\"abcdef\\"","solution":"def remove_duplicates(s): Removes all duplicate characters such that each character only appears once in the order of their first occurrence in the string. :param s: Input string consisting of lowercase English letters. :return: Resulting string with duplicate characters removed. seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) return ''.join(result)"},{"question":"def can_form_polygon(nums: List[int]) -> bool: Given an integer array representing a series of heights, determine whether a selection of 2 or more of these heights can form a polygon. To form a valid polygon, the sum of the lengths of any 2 sides must be greater than the length of the remaining side. Returns a boolean indicating whether such a selection is possible. >>> can_form_polygon([2, 2, 3]) True >>> can_form_polygon([4, 6, 8]) True >>> can_form_polygon([5, 10]) False >>> can_form_polygon([3, 6, 9]) False >>> can_form_polygon([1, 2, 3, 4, 10]) True >>> can_form_polygon([1, 2, 8, 9, 10]) True >>> can_form_polygon([]) False >>> can_form_polygon([1]) False >>> can_form_polygon([10, 20]) False","solution":"def can_form_polygon(nums): Determines if a selection of 2 or more heights can form a polygon. Args: nums (list of ints): The heights/side lengths. Returns: bool: True if a selection can form a polygon, otherwise False. n = len(nums) if n < 3: return False nums.sort() for i in range(n - 2): if nums[i] + nums[i + 1] > nums[i + 2]: return True return False"},{"question":"def min_subarray_len(arr: List[int], k: int) -> int: Returns the smallest length of a contiguous subarray with a sum greater than or equal to k. If no such subarray exists, returns -1. >>> min_subarray_len([2, 3, 1, 2, 4, 3], 7) 2 >>> min_subarray_len([1, 1, 1, 1, 1], 10) -1 >>> min_subarray_len([1, 2, 3, 4, 5], 15) 5 >>> min_subarray_len([1, 2, 3, 7], 7) 1 >>> min_subarray_len([5, 1, 3, 5, 10, 7, 4, 9, 2, 8], 15) 2","solution":"def min_subarray_len(arr, k): Returns the smallest length of a contiguous subarray with a sum greater than or equal to k. If no such subarray exists, returns -1. n = len(arr) min_len = float('inf') current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum >= k: min_len = min(min_len, end - start + 1) current_sum -= arr[start] start += 1 return min_len if min_len != float('inf') else -1"},{"question":"def shift_letters(word: str) -> str: Returns a new string where each character in the original string is replaced by its next character in the English alphabet. The next character after 'z' is 'a'. :param word: The original string containing only lowercase alphabetic characters. :return: The shifted string with each character replaced by its next character in the alphabet. >>> shift_letters(\\"abcd\\") \\"bcde\\" >>> shift_letters(\\"xyz\\") \\"yza\\" >>> shift_letters(\\"zzzz\\") \\"aaaa\\" >>> shift_letters(\\"\\") \\"\\" >>> shift_letters(\\"a\\") \\"b\\" >>> shift_letters(\\"z\\") \\"a\\"","solution":"def shift_letters(word): Returns a new string where each character in the original string is replaced by its next character in the English alphabet. The next character after 'z' is 'a'. shifted_word = \\"\\" for char in word: if char == 'z': shifted_word += 'a' else: shifted_word += chr(ord(char) + 1) return shifted_word"},{"question":"def max_sum_subarray(arr: List[int], k: int) -> int: Returns the maximum sum of any contiguous subarray of size exactly \`k\`. If \`k\` is greater than the length of the array, returns 0. >>> max_sum_subarray([2, 1, 5, 1, 3, 2], 3) 9 >>> max_sum_subarray([2, 1, 5], 4) 0 >>> max_sum_subarray([2, 2, 2, 2, 2], 2) 4 >>> max_sum_subarray([2, 2, 2, 2, 2], 1) 2 >>> max_sum_subarray([2, 1, 5, 1, 3, 2], 6) 14 >>> max_sum_subarray([2, 1, 5, 1, 3, 2], 0) 0 >>> max_sum_subarray([], 3) 0","solution":"def max_sum_subarray(arr, k): Returns the maximum sum of any contiguous subarray of size exactly \`k\`. If \`k\` is greater than the length of the array, returns 0. n = len(arr) if k > n: return 0 # Calculate the sum of the first \`k\` elements max_sum = current_sum = sum(arr[:k]) # Slide the window over the array by subtracting the element that goes out of the window # and adding the element that comes into the window for i in range(k, n): current_sum += arr[i] - arr[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_depth(root: TreeNode) -> int: Returns the maximum depth of the binary tree rooted at 'root'. >>> single_node = TreeNode(1) >>> max_depth(single_node) 1 >>> max_depth(None) 0 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> max_depth(root) 3 >>> root = TreeNode(1) >>> root.right = TreeNode(2) >>> root.right.right = TreeNode(3) >>> root.right.right.right = TreeNode(4) >>> max_depth(root) 4 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(3) >>> max_depth(root) 3","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_depth(root): Returns the maximum depth of the binary tree rooted at 'root'. if root is None: return 0 else: left_depth = max_depth(root.left) right_depth = max_depth(root.right) return max(left_depth, right_depth) + 1"},{"question":"def find_unsorted_subarray(arr): Given an integer array arr, find the length of the shortest contiguous subarray, that when sorted, makes the array non-decreasing. The input array may contain duplicates, and you need to return the length of the shortest such subarray. >>> find_unsorted_subarray([2, 6, 4, 8, 10, 9, 15]) 5 >>> find_unsorted_subarray([1, 2, 3, 4, 5]) 0 >>> find_unsorted_subarray([5, 4, 3, 2, 1]) 5 >>> find_unsorted_subarray([1]) 0 >>> find_unsorted_subarray([1, 2]) 0 >>> find_unsorted_subarray([2, 1]) 2 >>> find_unsorted_subarray([2, 1, 2, 2, 2]) 2 >>> find_unsorted_subarray([1, 1, 1, 1, 1]) 0","solution":"def find_unsorted_subarray(arr): n = len(arr) if n <= 1: return 0 start, end = -1, -1 max_seen = -float('inf') min_seen = float('inf') for i in range(n): max_seen = max(max_seen, arr[i]) if arr[i] < max_seen: end = i for i in range(n-1, -1, -1): min_seen = min(min_seen, arr[i]) if arr[i] > min_seen: start = i if start == -1 or end == -1: return 0 return end - start + 1"},{"question":"def final_string_length(s: str) -> int: Determine the length of the final string after performing any number of moves where we can remove any two adjacent characters if they are different. Parameters: s (str): The input string containing characters 'a', 'b', and 'c'. Returns: int: The length of the final string. >>> final_string_length(\\"\\") == 0 >>> final_string_length(\\"a\\") == 1 >>> final_string_length(\\"ab\\") == 0 >>> final_string_length(\\"aaa\\") == 3 >>> final_string_length(\\"abccba\\") == 0","solution":"def final_string_length(s): Determine the length of the final string after performing any number of moves where we can remove any two adjacent characters if they are different. Parameters: s (str): The input string containing characters 'a', 'b', and 'c'. Returns: int: The length of the final string. stack = [] for char in s: if stack and stack[-1] != char: stack.pop() # remove the adjacent different character else: stack.append(char) return len(stack)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kth_smallest(root: TreeNode, k: int) -> int: Returns the kth smallest element in the BST. >>> root = TreeNode(2) >>> root.left = TreeNode(1) >>> root.right = TreeNode(3) >>> kth_smallest(root, 1) 1 >>> root = TreeNode(5) >>> root.left = TreeNode(3) >>> root.right = TreeNode(7) >>> root.left.left = TreeNode(2) >>> root.left.right = TreeNode(4) >>> root.left.left.left = TreeNode(1) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(8) >>> kth_smallest(root, 3) 3","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kth_smallest(root, k): Returns the kth smallest element in the BST. # Helper function to perform in-order traversal def in_order_traversal(node): if not node: return yield from in_order_traversal(node.left) yield node.val yield from in_order_traversal(node.right) generator = in_order_traversal(root) for _ in range(k - 1): next(generator) return next(generator)"},{"question":"def largest_island(grid: List[List[int]]) -> int: Given a 2D array grid representing an N x N grid filled with 0s and 1s, where 1 represents land and 0 represents water, find the largest island that can be formed by flipping exactly one 0 to 1. An island is considered to be formed by connected 1s horizontally or vertically. Assume there is at least one 0 in the grid. Return the size of the largest island that can be formed. >>> largest_island([ ... [1, 0], ... [0, 1] ... ]) 3 >>> largest_island([ ... [1, 1], ... [1, 0] ... ]) 4 >>> largest_island([ ... [1, 0, 0], ... [0, 1, 0], ... [0, 0, 1] ... ]) 3 >>> largest_island([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 0] ... ]) 9 >>> largest_island([ ... [1, 1, 0, 0], ... [1, 0, 1, 0], ... [0, 1, 0, 1], ... [0, 0, 1, 1] ... ]) 6 >>> largest_island([ ... [1, 1, 1], ... [1, 0, 1], ... [1, 1, 1] ... ]) 9 >>> largest_island([ ... [1] ... ]) 1 >>> largest_island([ ... [0] ... ]) 1","solution":"def largest_island(grid): from collections import defaultdict, deque def get_neighbors(x, y): for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]): yield nx, ny def bfs(x, y, island_idx): queue = deque([(x, y)]) grid[x][y] = island_idx size = 1 while queue: cx, cy = queue.popleft() for nx, ny in get_neighbors(cx, cy): if grid[nx][ny] == 1: grid[nx][ny] = island_idx queue.append((nx, ny)) size += 1 return size n = len(grid) island_sizes = defaultdict(int) island_index = 2 # Find all islands and mark them with index > 1 for i in range(n): for j in range(n): if grid[i][j] == 1: island_sizes[island_index] = bfs(i, j, island_index) island_index += 1 if not island_sizes: return 1 max_island_size = max(island_sizes.values()) # Try flipping each 0 and calculate the size of the resulting island for i in range(n): for j in range(n): if grid[i][j] == 0: seen_islands = set() possible_size = 1 # the flipped 0 itself for nx, ny in get_neighbors(i, j): if grid[nx][ny] > 1 and grid[nx][ny] not in seen_islands: seen_islands.add(grid[nx][ny]) possible_size += island_sizes[grid[nx][ny]] max_island_size = max(max_island_size, possible_size) return max_island_size"},{"question":"def longest_peak_subarray(arr: List[int]) -> int: Returns the length of the longest peak subarray in arr. >>> longest_peak_subarray([1, 2, 3, 4, 5]) 0 >>> longest_peak_subarray([5, 4, 3, 2, 1]) 0 >>> longest_peak_subarray([1, 3, 2]) 3 >>> longest_peak_subarray([1, 2, 3, 4, 3, 2, 1]) 7 >>> longest_peak_subarray([1, 3, 2, 4, 6, 4, 2, 5, 2]) 5 >>> longest_peak_subarray([1, 2, 3, 2, 1, 5, 4, 3, 4, 3, 2, 1]) 5 >>> longest_peak_subarray([]) 0 >>> longest_peak_subarray([2, 2, 2, 2, 2]) 0","solution":"def longest_peak_subarray(arr): Returns the length of the longest peak subarray in arr. if not arr: return 0 n = len(arr) max_len = 0 for i in range(1, n - 1): # Check if arr[i] is a peak if arr[i - 1] < arr[i] > arr[i + 1]: # Initialize left and right pointers to find the extent of the peak left, right = i - 1, i + 1 # Move left pointer to the left as long as the current number is greater than the next one while left > 0 and arr[left - 1] < arr[left]: left -= 1 # Move right pointer to the right as long as the current number is greater than the previous one while right < n - 1 and arr[right] > arr[right + 1]: right += 1 # Calculate the length of the peak subarray max_len = max(max_len, right - left + 1) return max_len"},{"question":"def min_moves_to_sort(height): Returns the minimum number of moves required to sort the array in non-decreasing order. >>> min_moves_to_sort([1, 2, 3, 4]) == 0 >>> min_moves_to_sort([5, 5, 5, 5]) == 0 >>> min_moves_to_sort([4, 3, 2, 1]) == 3 >>> min_moves_to_sort([3, 2, 1]) == 2 >>> min_moves_to_sort([3, 1, 2, 4]) == 1 >>> min_moves_to_sort([5, 1, 4, 2, 3]) == 2 >>> min_moves_to_sort([1]) == 0 >>> min_moves_to_sort([4, 3, 3, 2, 1]) == 3 >>> min_moves_to_sort([1, 2, 2, 2]) == 0","solution":"def min_moves_to_sort(height): Returns the minimum number of moves required to sort the array in non-decreasing order. n = len(height) # Create a sorted version of the array sorted_height = sorted(height) # Find the length of the longest subsequence that is already in order dp = [0] * n for i in range(n): for j in range(i): if height[i] >= height[j]: dp[i] = max(dp[i], dp[j] + 1) dp[i] = max(dp[i], 1) longest_subsequence = max(dp) # The minimum number of moves required is the total number of elements minus the length of this subsequence return n - longest_subsequence"},{"question":"def transform_string(s: str, k: int) -> str: Converts the string such that the first k characters are moved to the end. If k is greater than the length of the string, the resultant string is the same as the original string. Parameters: s (str): The original string k (int): The number of characters to move from the start to the end Returns: str: Transformed string. Test Cases: >>> transform_string(\\"abcdef\\", 2) 'cdefab' >>> transform_string(\\"hello\\", 3) 'lohel' >>> transform_string(\\"hello\\", 5) 'hello' >>> transform_string(\\"world\\", 5) 'world' >>> transform_string(\\"abc\\", 5) 'abc' >>> transform_string(\\"xyz\\", 10) 'xyz' >>> transform_string(\\"example\\", 0) 'example' >>> transform_string(\\"\\", 3) '' >>> transform_string(\\"\\", 0) ''","solution":"def transform_string(s, k): Converts the string such that the first k characters are moved to the end. If k is greater than the length of the string, the resultant string is the same as the original string. :param s: The original string :param k: The number of characters to move from the start to the end :return: Transformed string if k > len(s): return s return s[k:] + s[:k]"},{"question":"from typing import List def isCyclic(graph: List[List[int]]) -> bool: Determine if a directed graph contains a cycle. >>> isCyclic([[1], [2], [0]]) True >>> isCyclic([[1], [2], [3], []]) False >>> isCyclic([[1], [2], [0], [5], [3]]) True >>> isCyclic([[1], [2], [], [4], []]) False >>> isCyclic([]) False >>> isCyclic([[]]) False >>> isCyclic([[0]]) True >>> isCyclic([[1, 3], [2, 3], [3, 4], [1], [2]]) True >>> isCyclic([[1, 3], [2, 3], [4], [], []]) False","solution":"from typing import List def isCyclic(graph: List[List[int]]) -> bool: def dfs(v): if visited[v] == 2: # Processed return False if visited[v] == 1: # In current path return True visited[v] = 1 # Mark the current node as visited for neighbor in graph[v]: if dfs(neighbor): return True visited[v] = 2 # Mark the current node as processed return False n = len(graph) visited = [0] * n # 0: not visited, 1: in current path, 2: processed for i in range(n): if not visited[i]: # If not visited yet if dfs(i): return True return False"},{"question":"def min_palindrome_partitions(s: str) -> int: Given a string \`s\`, partition \`s\` into as few strings as possible such that each string is a palindrome. Parameters: s (str): The input string. Returns: int: The minimum number of palindrome substring partitions needed. Examples: >>> min_palindrome_partitions(\\"aab\\") 1 >>> min_palindrome_partitions(\\"a\\") 0 def test_min_palindrome_partitions_single_character(): assert min_palindrome_partitions(\\"a\\") == 0 def test_min_palindrome_partitions_simple(): assert min_palindrome_partitions(\\"aab\\") == 1 def test_min_palindrome_partitions_longer(): assert min_palindrome_partitions(\\"ababbbabbababa\\") == 3 def test_min_palindrome_partitions_already_palindrome(): assert min_palindrome_partitions(\\"racecar\\") == 0 def test_min_palindrome_partitions_no_palindrome(): assert min_palindrome_partitions(\\"abcdef\\") == 5 def test_min_palindrome_partitions_empty_string(): assert min_palindrome_partitions(\\"\\") == 0 def test_min_palindrome_partitions_multiple_solutions(): assert min_palindrome_partitions(\\"aabb\\") == 1 assert min_palindrome_partitions(\\"banana\\") == 1","solution":"def min_palindrome_partitions(s): Returns the minimum number of palindrome partitions needed. n = len(s) if n == 0: return 0 # Initialize dp and palindrome matrix dp = [0] * (n + 1) dp[0] = -1 is_palindrome = [[False] * n for _ in range(n)] for end in range(n): for start in range(end + 1): if s[start] == s[end] and (end - start <= 2 or is_palindrome[start + 1][end - 1]): is_palindrome[start][end] = True for i in range(1, n + 1): min_cuts = float('inf') for j in range(i): if is_palindrome[j][i - 1]: min_cuts = min(min_cuts, dp[j] + 1) dp[i] = min_cuts return dp[n]"},{"question":"def reorder_log_entries(log_entries: List[str]) -> List[str]: Reorders the log entries such that alphabetical content logs come before numerical content logs. Alphabetical logs are ordered lexicographically by content, and by their identifiers in case of ties. Numerical logs maintain their original order. >>> reorder_log_entries([ \\"a1 9 2 3 1\\", \\"g1 act car\\", \\"zo4 4 7\\", \\"ab1 off key dog\\", \\"a8 act zoo\\" ]) [\\"g1 act car\\", \\"a8 act zoo\\", \\"ab1 off key dog\\", \\"a1 9 2 3 1\\", \\"zo4 4 7\\"] >>> reorder_log_entries([\\"a1 apple\\", \\"b2 banana\\", \\"c3 carrot\\"]) [\\"a1 apple\\", \\"b2 banana\\", \\"c3 carrot\\"] >>> reorder_log_entries([\\"a1 123\\", \\"b2 456\\", \\"c3 789\\"]) [\\"a1 123\\", \\"b2 456\\", \\"c3 789\\"] >>> reorder_log_entries([\\"a1 1 2 3\\", \\"b2 act zoo\\", \\"c3 2 3 4\\", \\"d4 zoo act\\"]) [\\"b2 act zoo\\", \\"d4 zoo act\\", \\"a1 1 2 3\\", \\"c3 2 3 4\\"] >>> reorder_log_entries([ \\"a1 act car\\", \\"g1 act car\\", \\"k1 act car\\", \\"b2 9 9 9\\", \\"c3 8 8 8\\" ]) [\\"a1 act car\\", \\"g1 act car\\", \\"k1 act car\\", \\"b2 9 9 9\\", \\"c3 8 8 8\\"] >>> reorder_log_entries([]) []","solution":"def reorder_log_entries(log_entries): Reorders the log entries such that alphabetical content logs come before numerical content logs. Alphabetical logs are ordered lexicographically by content, and by their identifiers in case of ties. Numerical logs maintain their original order. alpha_logs = [] num_logs = [] for log in log_entries: identifier, content = log.split(\\" \\", 1) if content.replace(\\" \\", \\"\\").isnumeric(): num_logs.append(log) else: alpha_logs.append((content, identifier, log)) # Sort alphabetic logs by content and identifier alpha_logs.sort(key=lambda x: (x[0], x[1])) # Extract the ordered logs ordered_logs = [log[2] for log in alpha_logs] + num_logs return ordered_logs"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def constructMaximumBinaryTree(nums: List[int]) -> TreeNode: Given an array of integers \`nums\`, construct a binary tree where each node's value is the maximum value in \`nums\`, with left and right subtrees recursively constructed from the remaining elements. >>> root = constructMaximumBinaryTree([3]) >>> tree_to_list(root) [3] >>> root = constructMaximumBinaryTree([1, 2, 3, 4, 5]) >>> tree_to_list(root) [5, 4, 3, 2, 1] >>> root = constructMaximumBinaryTree([5, 4, 3, 2, 1]) >>> tree_to_list(root) [5, 4, 3, 2, 1] >>> root = constructMaximumBinaryTree([3, 2, 1, 6, 0, 5]) >>> tree_to_list(root) [6, 3, 2, 1, 5, 0] >>> root = constructMaximumBinaryTree([]) >>> tree_to_list(root) [] # Unit tests def tree_to_list(root): Helper function to convert tree to list for easy comparison in tests. if not root: return [] result = [root.val] left_subtree = tree_to_list(root.left) if root.left else [] right_subtree = tree_to_list(root.right) if root.right else [] result.extend(left_subtree) result.extend(right_subtree) return result def test_constructMaximumBinaryTree_single_element(): nums = [3] root = constructMaximumBinaryTree(nums) assert tree_to_list(root) == [3] def test_constructMaximumBinaryTree_sorted_ascending(): nums = [1, 2, 3, 4, 5] root = constructMaximumBinaryTree(nums) assert tree_to_list(root) == [5, 4, 3, 2, 1] def test_constructMaximumBinaryTree_sorted_descending(): nums = [5, 4, 3, 2, 1] root = constructMaximumBinaryTree(nums) assert tree_to_list(root) == [5, 4, 3, 2, 1] def test_constructMaximumBinaryTree_mixed_elements(): nums = [3, 2, 1, 6, 0, 5] root = constructMaximumBinaryTree(nums) assert tree_to_list(root) == [6, 3, 2, 1, 5, 0] def test_constructMaximumBinaryTree_empty_list(): nums = [] root = constructMaximumBinaryTree(nums) assert root is None","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def constructMaximumBinaryTree(nums): if not nums: return None max_value = max(nums) max_index = nums.index(max_value) root = TreeNode(val=max_value) root.left = constructMaximumBinaryTree(nums[:max_index]) root.right = constructMaximumBinaryTree(nums[max_index + 1:]) return root"},{"question":"def longest_arith_seq_length(nums: List[int], difference: int) -> int: Returns the length of the longest arithmetic sequence that can be formed with a given common difference. >>> longest_arith_seq_length([1, 2, 3, 4], 1) 4 >>> longest_arith_seq_length([1, 3, 5, 7], 2) 4 >>> longest_arith_seq_length([5, 3, 1, -1], -2) 4 >>> longest_arith_seq_length([5, 2, -1, -4], -3) 4 >>> longest_arith_seq_length([1, 5, 9, 14], 1) 1 >>> longest_arith_seq_length([1, 10, 20, 30], 15) 1 >>> longest_arith_seq_length([2, 2, 2, 2], 0) 4 >>> longest_arith_seq_length([1, 1, 2, 2, 3, 3], 1) 3 >>> longest_arith_seq_length([], 5) 0 >>> longest_arith_seq_length([1], 2) 1 >>> longest_arith_seq_length([10], -3) 1","solution":"def longest_arith_seq_length(nums, difference): Returns the length of the longest arithmetic sequence that can be formed with a given common difference. :param nums: List of positive integers :param difference: Integer, the common difference :return: Integer, length of the longest arithmetic sequence if not nums: return 0 dp = {} max_length = 0 for num in nums: if num - difference in dp: dp[num] = dp[num - difference] + 1 else: dp[num] = 1 max_length = max(max_length, dp[num]) return max_length"},{"question":"def kth_smallest_distance(heights: List[int], k: int) -> int: Returns the k-th smallest distance between any two distinct heights in the array. The distance is defined as the absolute difference between two heights. >>> kth_smallest_distance([1, 3, 4, 7], 3) == 3 >>> kth_smallest_distance([1, 3, 3, 7], 2) == 2 >>> kth_smallest_distance([1, 5, 9], 1) == 4 >>> kth_smallest_distance([5, 5, 5, 5], 1) == 0 >>> kth_smallest_distance([], 1) == IndexError","solution":"def kth_smallest_distance(heights, k): Returns the k-th smallest distance between any two distinct heights in the array. The distance is defined as the absolute difference between two heights. from itertools import combinations import heapq # Generate all unique pair distances distances = [] for a, b in combinations(heights, 2): distances.append(abs(a - b)) # Use a min-heap to get the k-th smallest element return heapq.nsmallest(k, distances)[-1]"},{"question":"from collections import defaultdict, deque from typing import List def can_finish_tasks(num_tasks: int, prerequisites: List[List[int]]) -> List[int]: Determine if you can finish all tasks given the list of prerequisites. :param num_tasks: Number of tasks (labeled from 0 to n-1) :param prerequisites: List of pairs [a, b] meaning task a should be completed before task b. :return: List of tasks in the order they can be completed or empty list if not possible. pass def test_can_finish_tasks_empty_prerequisites(): assert can_finish_tasks(3, []) == [0, 1, 2] def test_can_finish_tasks_simple_case(): assert can_finish_tasks(2, [[1, 0]]) == [0, 1] def test_can_finish_tasks_complex_case(): assert can_finish_tasks(4, [[1, 0], [2, 0], [3, 1], [3, 2]]) == [0, 1, 2, 3] or [0, 2, 1, 3] def test_can_finish_tasks_with_cycle(): assert can_finish_tasks(4, [[1, 0], [2, 1], [3, 2], [1, 3]]) == [] def test_can_finish_tasks_multiple_sources(): assert can_finish_tasks(3, [[1, 0], [2, 0]]) == [0, 1, 2] or [0, 2, 1] def test_can_finish_tasks_no_dependencies(): assert can_finish_tasks(5, []) == [0, 1, 2, 3, 4] def test_can_finish_tasks_one_task(): assert can_finish_tasks(1, []) == [0] def test_can_finish_tasks_self_dependency(): assert can_finish_tasks(1, [[0, 0]]) == []","solution":"from collections import defaultdict, deque def can_finish_tasks(num_tasks, prerequisites): Determine if you can finish all tasks given the list of prerequisites. :param num_tasks: Number of tasks (labeled from 0 to n-1) :param prerequisites: List of pairs [a, b] meaning task a should be completed before task b. :return: List of tasks in the order they can be completed or empty list if not possible. graph = defaultdict(list) in_degree = [0] * num_tasks for dest, src in prerequisites: graph[src].append(dest) in_degree[dest] += 1 queue = deque([i for i in range(num_tasks) if in_degree[i] == 0]) order = [] while queue: node = queue.popleft() order.append(node) for neigh in graph[node]: in_degree[neigh] -= 1 if in_degree[neigh] == 0: queue.append(neigh) if len(order) == num_tasks: return order else: return []"},{"question":"def min_spanning_tree(n, edges, x): You are given a weighted, undirected graph represented by an integer \`n\` which is the number of nodes (from \`0\` to \`n-1\`), and an array \`edges\` where each \`edges[i] = [node1, node2, weight]\` represents an edge between \`node1\` and \`node2\` with a given \`weight\`. Additionally, you are given an integer \`x\`. You can increase the weight of existing edges by \`x\` units. Return the minimum possible total weight of a spanning tree for the graph after the optimal increase in weights for the edges. A spanning tree of a graph is a connected subgraph that includes all the nodes of the original graph and has no cycles. >>> min_spanning_tree(4, [[0, 1, 1], [1, 2, 1], [2, 3, 1], [0, 3, 1], [0, 2, 2]], 0) 3 >>> min_spanning_tree(4, [[0, 1, 1], [1, 2, 1], [2, 3, 1], [0, 3, 1], [0, 2, 2]], 1) 6 >>> min_spanning_tree(2, [[0, 1, 3]], 5) 8 >>> min_spanning_tree(1, [], 10) 0","solution":"import heapq from collections import defaultdict def min_spanning_tree(n, edges, x): def increase_weights(edges, x): return [(w + x, u, v) for u, v, w in edges] def kruskal(n, edges): parent = list(range(n)) rank = [0] * n def find(u): if parent[u] != u: parent[u] = find(parent[u]) return parent[u] def union(u, v): root_u = find(u) root_v = find(v) if root_u != root_v: if rank[root_u] > rank[root_v]: parent[root_v] = root_u elif rank[root_u] < rank[root_v]: parent[root_u] = root_v else: parent[root_v] = root_u rank[root_u] += 1 return True return False edges_sorted = sorted(edges) weight_sum = 0 size = 0 for w, u, v in edges_sorted: if union(u, v): weight_sum += w size += 1 if size == n - 1: break return weight_sum increased_edges = increase_weights(edges, x) return kruskal(n, increased_edges)"},{"question":"def longest_repeating_substring(s: str) -> int: Returns the length of the longest substring consisting of a single, repeating character. >>> longest_repeating_substring(\\"\\") == 0 >>> longest_repeating_substring(\\"a\\") == 1 >>> longest_repeating_substring(\\"aaabbccddeeee\\") == 4 >>> longest_repeating_substring(\\"abcdef\\") == 1 >>> longest_repeating_substring(\\"aaaaaa\\") == 6 >>> longest_repeating_substring(\\"aabbbaaacccddd\\") == 3 >>> longest_repeating_substring(\\"abcdddefff\\") == 3 >>> longest_repeating_substring(\\"abcddd\\") == 3","solution":"def longest_repeating_substring(s): Returns the length of the longest substring consisting of a single, repeating character. if not s: return 0 max_length = 1 current_length = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"def sum_submatrix(matrix, queries): Returns a list of sums of integers in the submatrices defined by the queries. Parameters: matrix (List[List[int]]): 2D array of integers queries (List[List[int]]): List of queries, each query is of the form [x1, y1, x2, y2] Returns: List[int]: List of sums for each query >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> queries = [[1, 1, 1, 1]] >>> sum_submatrix(matrix, queries) [5] >>> queries = [[0, 0, 2, 2]] >>> sum_submatrix(matrix, queries) [45] >>> queries = [[0, 0, 2, 0]] >>> sum_submatrix(matrix, queries) [12] >>> queries = [[0, 0, 0, 2]] >>> sum_submatrix(matrix, queries) [6] >>> queries = [ ... [0, 0, 1, 1], ... [1, 1, 2, 2], ... [0, 0, 2, 2] ... ] >>> sum_submatrix(matrix, queries) [12, 28, 45] pass","solution":"def sum_submatrix(matrix, queries): Returns a list of sums of integers in the submatrices defined by the queries. Parameters: matrix (List[List[int]]): 2D array of integers queries (List[List[int]]): List of queries, each query is of the form [x1, y1, x2, y2] Returns: List[int]: List of sums for each query results = [] for x1, y1, x2, y2 in queries: submatrix_sum = 0 for i in range(x1, x2 + 1): for j in range(y1, y2 + 1): submatrix_sum += matrix[i][j] results.append(submatrix_sum) return results"},{"question":"def search_rotated_array(nums, target): Search for the target in a rotated array and return its index, or -1 if it does not exist. >>> search_rotated_array([4,5,6,7,0,1,2], 0) 4 >>> search_rotated_array([4,5,6,7,0,1,2], 3) -1 >>> search_rotated_array([1], 0) -1 >>> search_rotated_array([1], 1) 0 >>> search_rotated_array([1, 3], 3) 1 >>> search_rotated_array([5,1,3], 5) 0 >>> search_rotated_array([], 5) -1 >>> search_rotated_array([3,4,5,1,2], 1) 3 >>> search_rotated_array([3,4,5,1,2], 4) 1 >>> search_rotated_array([2,3,4,5,6,7,8,9,1], 6) 4 >>> search_rotated_array([6, 7, 0, 1, 2, 3, 4, 5], 6) 0","solution":"def search_rotated_array(nums, target): Search for the target in a rotated array and return its index, or -1 if it does not exist. if not nums: return -1 left, right = 0, len(nums) - 1 while left <= right: mid = left + (right - left) // 2 if nums[mid] == target: return mid # Check if the left side is sorted if nums[left] <= nums[mid]: if nums[left] <= target < nums[mid]: right = mid - 1 else: left = mid + 1 # Otherwise, the right side must be sorted else: if nums[mid] < target <= nums[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"def count_unique_pairs(nums, k): Returns the number of unique pairs (i, j) where i != j and nums[i] + nums[j] == k. >>> count_unique_pairs([1, 2, 3, 4, 3], 6) == 2 >>> count_unique_pairs([1, 2, 3, 4], 10) == 0 >>> count_unique_pairs([1, -2, 3, 4, -1], 2) == 2 >>> count_unique_pairs([0, 0, 0, 0], 0) == 1 >>> count_unique_pairs([1, 1, 1, 1], 2) == 1","solution":"def count_unique_pairs(nums, k): Returns the number of unique pairs (i, j) where i != j and nums[i] + nums[j] == k. seen = set() pair_set = set() for num in nums: complement = k - num if complement in seen: pair = tuple(sorted((num, complement))) pair_set.add(pair) seen.add(num) return len(pair_set)"},{"question":"def has_pair_with_difference(arr: List[int], x: int) -> bool: Determines if there are two distinct indices i and j such that the absolute difference between arr[i] and arr[j] is less than or equal to x and j > i. :param arr: List of integers :param x: Integer threshold for the absolute difference :return: Boolean indicating if such a pair exists >>> has_pair_with_difference([1, 2, 3, 4], 2) True >>> has_pair_with_difference([1, 3, 6, 8], 1) False >>> has_pair_with_difference([1, 5, 9, 14], 4) True >>> has_pair_with_difference([3, 3, 3, 3], 0) True >>> has_pair_with_difference([10, 20, 30], 5) False >>> has_pair_with_difference([], 1) False >>> has_pair_with_difference([1], 1) False","solution":"def has_pair_with_difference(arr, x): Determines if there are two distinct indices i and j such that the absolute difference between arr[i] and arr[j] is less than or equal to x and j > i. :param arr: List of integers :param x: Integer threshold for the absolute difference :return: Boolean indicating if such a pair exists n = len(arr) for i in range(n): for j in range(i + 1, n): if abs(arr[i] - arr[j]) <= x: return True return False"},{"question":"def convert(s: str, numRows: int) -> str: Convert string to its zigzag pattern representation and read line by line. >>> convert(\\"PAYPALISHIRING\\", 3) 'PAHNAPLSIIGYIR' >>> convert(\\"PAYPALISHIRING\\", 4) 'PINALSIGYAHRPI' >>> convert(\\"A\\", 1) 'A' def test_convert_example1(): assert convert(\\"PAYPALISHIRING\\", 3) == \\"PAHNAPLSIIGYIR\\" def test_convert_example2(): assert convert(\\"PAYPALISHIRING\\", 4) == \\"PINALSIGYAHRPI\\" def test_convert_example3(): assert convert(\\"A\\", 1) == \\"A\\" def test_convert_single_character(): assert convert(\\"B\\", 5) == \\"B\\" def test_convert_multiple_character_single_row(): assert convert(\\"HELLO\\", 1) == \\"HELLO\\" def test_convert_numrows_greater_than_length(): assert convert(\\"HI\\", 5) == \\"HI\\" def test_convert_even_length_string(): assert convert(\\"ABCDEFGH\\", 3) == \\"AEBDFHCG\\"","solution":"def convert(s, numRows): if numRows == 1 or numRows >= len(s): return s rows = [''] * numRows direction = -1 row = 0 for char in s: rows[row] += char if row == 0 or row == numRows - 1: direction *= -1 row += direction return ''.join(rows)"},{"question":"def kth_smallest_after_reverse(nums: List[int], k: int) -> int: Find the k-th smallest number possible after reversing a contiguous subarray. Args: nums: List of integers. k: The k-th position smallest number to find. Returns: int: The k-th smallest number in any possible post-reversal array. >>> kth_smallest_after_reverse([4, 2, 3, 1], 3) == 3 >>> kth_smallest_after_reverse([10], 1) == 10 >>> kth_smallest_after_reverse([1, 2, 3, 4, 5], 2) == 2 >>> kth_smallest_after_reverse([5, 4, 3, 2, 1], 4) == 4 >>> kth_smallest_after_reverse([1, 3, 1, 1, 2], 3) == 1 >>> kth_smallest_after_reverse([1, 2, 3, 4, 5], 0) raises ValueError >>> kth_smallest_after_reverse([1, 2, 3, 4, 5], 6) raises ValueError","solution":"def kth_smallest_after_reverse(nums, k): Find the k-th smallest number possible after reversing a contiguous subarray. Args: nums: List of integers. k: The k-th position smallest number to find. Returns: int: The k-th smallest number in any possible post-reversal array. n = len(nums) if n == 0 or k <= 0 or k > n: raise ValueError(\\"Invalid input values\\") # If we can reverse any sub-array, the list of achievable numbers is # determined by sorting the entire input list. sorted_nums = sorted(nums) return sorted_nums[k-1]"},{"question":"def count_distinct_palindromic_substrings(s): Returns the count of distinct palindromic substrings in the given string. >>> count_distinct_palindromic_substrings(\\"a\\") 1 >>> count_distinct_palindromic_substrings(\\"abc\\") 3 >>> count_distinct_palindromic_substrings(\\"ababa\\") 5 >>> count_distinct_palindromic_substrings(\\"aaa\\") 3 >>> count_distinct_palindromic_substrings(\\"ab\\") 2 >>> count_distinct_palindromic_substrings(\\"xyz\\") 3 >>> count_distinct_palindromic_substrings(\\"racecar\\") 7 >>> count_distinct_palindromic_substrings(\\"\\") 0","solution":"def count_distinct_palindromic_substrings(s): Returns the count of distinct palindromic substrings in the given string. :param s: input string :type s: str :return: count of distinct palindromic substrings :rtype: int unique_palindromes = set() n = len(s) # Function to expand around center and add palindromes to the set def expand_around_center(left, right): while left >= 0 and right < n and s[left] == s[right]: unique_palindromes.add(s[left:right+1]) left -= 1 right += 1 for i in range(n): # Odd length palindromes expand_around_center(i, i) # Even length palindromes expand_around_center(i, i + 1) return len(unique_palindromes)"},{"question":"from typing import List def count_valid_subsequences(nums: List[int], target: int, k: int) -> int: Returns the number of distinct valid subsequences of length k in nums that sum up to target. Args: nums (list of int): List of integers. target (int): The target sum of the subsequence. k (int): The length of the subsequence. Returns: int: The number of distinct valid subsequences. >>> count_valid_subsequences([1, 2, 3, 4, 5], 5, 2) == 2 >>> count_valid_subsequences([1, 1, 1, 1, 1], 2, 2) == 10 >>> count_valid_subsequences([1, 2, 3, 4, 5], 15, 3) == 0 >>> count_valid_subsequences([1, 2, 3], 6, 2) == 0 >>> count_valid_subsequences([1, 2], 3, 2) == 1 >>> count_valid_subsequences([1, 1, 2], 3, 2) == 2 >>> count_valid_subsequences([], 0, 0) == 1 >>> count_valid_subsequences([1, 2, 3, 4, 5], 12, 3) == 1","solution":"from itertools import combinations def count_valid_subsequences(nums, target, k): Returns the number of distinct valid subsequences of length k in nums that sum up to target. Args: nums (list of int): List of integers. target (int): The target sum of the subsequence. k (int): The length of the subsequence. Returns: int: The number of distinct valid subsequences. # Generate all combinations of nums of length k subsequences = combinations(nums, k) # Count those that sum to target valid_count = sum(1 for subseq in subsequences if sum(subseq) == target) return valid_count"},{"question":"def restore_string(s, indices): Restores the given string 's' to its original order based on the indices array. :param s: A shuffled string. :param indices: A list of indices indicating the original positions of the characters in 's'. :return: The original string in the correct order. >>> restore_string(\\"aiohn\\", [3,1,4,2,0]) == \\"nihao\\" >>> restore_string(\\"aaaaa\\", [0, 1, 2, 3, 4]) == \\"aaaaa\\" >>> restore_string(\\"\\", []) == \\"\\" >>> restore_string(\\"x\\", [0]) == \\"x\\" >>> restore_string(\\"abcde\\", [4, 3, 2, 1, 0]) == \\"edcba\\"","solution":"def restore_string(s, indices): Restores the given string 's' to its original order based on the indices array. :param s: A shuffled string. :param indices: A list of indices indicating the original positions of the characters in 's'. :return: The original string in the correct order. n = len(s) restored = [''] * n for i, index in enumerate(indices): restored[index] = s[i] return ''.join(restored)"},{"question":"def find_max_equal_substring_length(s: str) -> int: Finds the maximum length of a substring that contains an equal number of 'a' and 'b'. Parameters: s (str): The input string containing only 'a' and 'b' characters. Returns: int: The length of the longest substring with equal number of 'a' and 'b', or 0 if no such substring exists. >>> find_max_equal_substring_length(\\"aabb\\") == 4 >>> find_max_equal_substring_length(\\"aabbb\\") == 4 >>> find_max_equal_substring_length(\\"abba\\") == 4 >>> find_max_equal_substring_length(\\"ababab\\") == 6 >>> find_max_equal_substring_length(\\"aaaaabbbbbb\\") == 10 >>> find_max_equal_substring_length(\\"aaa\\") == 0 >>> find_max_equal_substring_length(\\"bbb\\") == 0 >>> find_max_equal_substring_length(\\"ababaa\\") == 4 >>> find_max_equal_substring_length(\\"\\") == 0 >>> find_max_equal_substring_length(\\"ab\\") == 2 >>> find_max_equal_substring_length(\\"baba\\") == 4","solution":"def find_max_equal_substring_length(s): Finds the maximum length of a substring that contains an equal number of 'a' and 'b'. Parameters: s (str): The input string containing only 'a' and 'b' characters. Returns: int: The length of the longest substring with equal number of 'a' and 'b', or 0 if no such substring exists. max_length = 0 count_map = {0: -1} # Dictionary to store the first occurrence of each balance balance = 0 # Current balance of 'a' and 'b' for i, char in enumerate(s): if char == 'a': balance += 1 elif char == 'b': balance -= 1 if balance in count_map: max_length = max(max_length, i - count_map[balance]) else: count_map[balance] = i return max_length"},{"question":"def min_operations_to_transform(s: str, t: str) -> int: Given two strings \`s\` and \`t\`, determine if \`s\` can be transformed into \`t\` by performing zero or more operations. In each operation, you can either: 1. Insert any character at any position in \`s\`. 2. Delete any character from \`s\`. 3. Replace any character in \`s\` with any character. Return the minimum number of operations required to transform \`s\` into \`t\`. >>> min_operations_to_transform(\\"kitten\\", \\"sitting\\") 3 >>> min_operations_to_transform(\\"flaw\\", \\"lawn\\") 2","solution":"def min_operations_to_transform(s, t): Returns the minimum number of operations required to transform string s into string t. The allowed operations are insertions, deletions, and replacements. :param s: The input string to be transformed :param t: The target string :return: Minimum number of operations m, n = len(s), len(t) # Creating a 2D array to store the minimum operations for each substring transformation. dp = [[0] * (n + 1) for _ in range(m + 1)] # Base cases: transforming empty string to t and vice versa for i in range(m + 1): dp[i][0] = i for j in range(n + 1): dp[0][j] = j for i in range(1, m + 1): for j in range(1, n + 1): if s[i-1] == t[j-1]: dp[i][j] = dp[i-1][j-1] else: # Minimum of replace, delete or insert operation dp[i][j] = 1 + min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) return dp[m][n]"},{"question":"from typing import List def largest_island(grid: List[List[int]]) -> int: Returns the size of the largest island possible after performing exactly one operation (changing a zero to a one) in a given grid of 0s and 1s where 1 represents land and 0 represents water. >>> largest_island([[1]]) 1 >>> largest_island([[1, 1], [1, 1]]) 4 >>> largest_island([[0, 0], [0, 0]]) 1 >>> largest_island([[1, 0], [0, 1]]) 3 >>> largest_island([[1, 1, 0], [0, 1, 1], [0, 0, 0]]) 5 >>> largest_island([[1, 1, 0], [1, 0, 0], [1, 0, 1]]) 6","solution":"def largest_island(grid): Returns the size of the largest island possible after performing exactly one operation to convert a 0 to a 1. def dfs(grid, i, j, visited, identifier): if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != 1 or visited[i][j]: return 0 visited[i][j] = True grid[i][j] = identifier return 1 + dfs(grid, i+1, j, visited, identifier) + dfs(grid, i-1, j, visited, identifier) + dfs(grid, i, j+1, visited, identifier) + dfs(grid, i, j-1, visited, identifier) n, m = len(grid), len(grid[0]) visited = [[False]*m for _ in range(n)] identifier = 2 island_size = {} # Step 1: Mark different islands with different identifiers and calculate their sizes. for i in range(n): for j in range(m): if grid[i][j] == 1 and not visited[i][j]: island_size[identifier] = dfs(grid, i, j, visited, identifier) identifier += 1 max_size = max(island_size.values(), default=0) # Step 2: Try converting each 0 to 1 and calculate potential island size. for i in range(n): for j in range(m): if grid[i][j] == 0: seen = set() potential_size = 1 # Changing this 0 to 1 for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]: if 0 <= x < n and 0 <= y < m and grid[x][y] > 1: seen.add(grid[x][y]) for id in seen: potential_size += island_size[id] max_size = max(max_size, potential_size) return max_size"},{"question":"def count_subarrays_with_sum(arr: List[int], m: int) -> int: Count the number of contiguous subarrays of arr that have a sum equal to m. >>> count_subarrays_with_sum([1, 2, 3], 3) 2 # subarrays: [3], [1,2] >>> count_subarrays_with_sum([1, 2, 3], 7) 0 >>> count_subarrays_with_sum([1, 1, 1], 2) 2 # subarrays: [1,1] (twice) >>> count_subarrays_with_sum([1, 2, 3], 6) 1 # subarray: [1,2,3] >>> count_subarrays_with_sum([], 0) 0 >>> count_subarrays_with_sum([-1, -1, 1], -2) 1 # subarray: [-1, -1] >>> count_subarrays_with_sum([0, 0, 0], 0) 6 # subarrays: [0], [0], [0], [0,0], [0,0], [0,0,0]","solution":"def count_subarrays_with_sum(arr, m): Returns the number of contiguous subarrays whose sum equals m. :param arr: List[int] - list of integers :param m: int - the target sum for the subarrays :return: int - number of contiguous subarrays with sum equal to m count = 0 prefix_sum = 0 prefix_sum_counts = {0: 1} for num in arr: prefix_sum += num if prefix_sum - m in prefix_sum_counts: count += prefix_sum_counts[prefix_sum - m] if prefix_sum in prefix_sum_counts: prefix_sum_counts[prefix_sum] += 1 else: prefix_sum_counts[prefix_sum] = 1 return count"},{"question":"from typing import List def k_frequent_elements(nums: List[int], k: int) -> List[int]: Return an array of all unique \\"k-frequent elements\\". An element \`x\` from the array is said to be a \\"k-frequent element\\" if it appears at least \`k\` times in the array. The output array should be sorted in ascending order. >>> k_frequent_elements([1, 2, 3, 4, 5], 2) [] >>> k_frequent_elements([1, 1, 2, 2, 3, 3, 4, 4, 1], 3) [1] >>> k_frequent_elements([1, 2, 2, 3, 3, 3, 4, 4, 4, 4], 2) [2, 3, 4] >>> k_frequent_elements([1, 1, 2, 2, 3, 3, 4, 4], 2) [1, 2, 3, 4] >>> k_frequent_elements([1, 2, 2, 2, 3, 1, 1, 4], 3) [1, 2]","solution":"from collections import Counter def k_frequent_elements(nums, k): Returns an array of all unique k-frequent elements. # Count the frequency of each element in the array frequency = Counter(nums) # Collect elements that have a frequency of at least k k_frequent = [element for element, count in frequency.items() if count >= k] # Return the sorted list of k-frequent elements return sorted(k_frequent)"},{"question":"from typing import List def max_unique_items(nums: List[int], k: int) -> int: Returns the maximum number of unique items you can choose such that the total number of items chosen does not exceed k. Parameters: nums (List[int]): A list of positive integers representing the quantities of different items. k (int): The maximum total number of items that can be chosen. Returns: int: The maximum number of unique items that can be chosen without exceeding the total number k. >>> max_unique_items([1, 2, 3, 4], 5) 2 >>> max_unique_items([1, 1, 1, 1], 2) 2 >>> max_unique_items([5, 3, 9, 1], 8) 2 >>> max_unique_items([1, 2, 3, 4, 5], 15) 5 >>> max_unique_items([5, 3, 9, 1], 25) 4 >>> max_unique_items([10, 10, 10], 5) 0 >>> max_unique_items([1, 2, 5, 9, 10], 15) 3 >>> max_unique_items([1], 1) 1 >>> max_unique_items([], 10) 0 >>> max_unique_items([2, 2, 2], 4) 2","solution":"def max_unique_items(nums, k): Returns the maximum number of unique items you can choose such that the total number of items chosen does not exceed k. Parameters: nums (List[int]): A list of positive integers representing the quantities of different items. k (int): The maximum total number of items that can be chosen. Returns: int: The maximum number of unique items that can be chosen without exceeding the total number k. # Sort the quantities in ascending order to pick the smallest first nums.sort() total_items = 0 unique_items = 0 for qty in nums: if total_items + qty <= k: total_items += qty unique_items += 1 else: break return unique_items"},{"question":"def max_meetings(meetings: List[List[int]]) -> int: Returns the maximum number of meetings that can be attended without overlaps. Parameters: meetings (list of lists): A list of meetings where each meeting is represented by a list of two integers [start, end]. Returns: int: Maximum number of non-overlapping meetings that can be attended. >>> max_meetings([[1, 2]]) 1 >>> max_meetings([[1, 2], [3, 4], [5, 6]]) 3 >>> max_meetings([[1, 5], [2, 3], [4, 6]]) 2 >>> max_meetings([[1, 3], [2, 4], [3, 5], [4, 6]]) 2 >>> max_meetings([[1, 2], [1, 2], [1, 2]]) 1 >>> max_meetings([[1, 10], [2, 3], [7, 9], [11, 12]]) 3","solution":"def max_meetings(meetings): Returns the maximum number of meetings that can be attended without overlaps. Parameters: meetings (list of lists): A list of meetings where each meeting is represented by a list of two integers [start, end]. Returns: int: Maximum number of non-overlapping meetings that can be attended. # Sort meetings by their end times meetings.sort(key=lambda x: x[1]) last_end_time = float('-inf') count = 0 for meeting in meetings: if meeting[0] > last_end_time: count += 1 last_end_time = meeting[1] return count"},{"question":"def to_goat_latin(sentence: str) -> str: Convert a sentence to Goat Latin. Args: sentence (str): The sentence to convert. Returns: str: The sentence in Goat Latin. Examples: >>> to_goat_latin(\\"I speak Goat Latin\\") \\"Imaa peaksmaaa oatGmaaaa atinLmaaaaa\\"","solution":"def to_goat_latin(sentence): Convert a sentence to Goat Latin. Args: sentence (str): The sentence to convert. Returns: str: The sentence in Goat Latin. vowels = {'a', 'e', 'i', 'o', 'u'} words = sentence.split() goat_latin_words = [] for i, word in enumerate(words): if word[0].lower() in vowels: goat_word = word + \\"ma\\" else: goat_word = word[1:] + word[0] + \\"ma\\" goat_word += \\"a\\" * (i + 1) goat_latin_words.append(goat_word) return \\" \\".join(goat_latin_words)"},{"question":"from typing import List def max_sum_subarray(arr: List[int], k: int) -> int: Returns the maximum sum of a subarray of length k. If there are multiple subarrays with the same maximum sum, the sum of the subarray that appears first is returned. :param arr: List[int] - List of integers :param k: int - Length of the subarray :return: int - Maximum sum of subarray of length k >>> max_sum_subarray([1, 2, 3, 1, 4, 5], 3) 10 >>> max_sum_subarray([-1, -2, -3, -4, -5], 2) -3 >>> max_sum_subarray([], 3) 0","solution":"def max_sum_subarray(arr, k): Returns the maximum sum of a subarray of length k. If there are multiple subarrays with the same maximum sum, the sum of the subarray that appears first is returned. :param arr: List[int] - List of integers :param k: int - Length of the subarray :return: int - Maximum sum of subarray of length k if not arr or k <= 0 or k > len(arr): return 0 max_sum = current_sum = sum(arr[:k]) for i in range(k, len(arr)): current_sum = current_sum - arr[i - k] + arr[i] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"from typing import List def rob(nums: List[int]) -> int: You are given a list of \`n\` non-negative integers representing the amount of money of each house. You are a thief planning to rob houses along this street. However, you cannot rob two adjacent houses because the police will be alerted. Implement a function \`rob(nums: List[int]) -> int\` that returns the maximum amount of money you can rob tonight without alerting the police. >>> rob([5]) 5 >>> rob([1, 2]) 2 >>> rob([2, 3, 1]) 3 >>> rob([3, 2, 5]) 8 >>> rob([2, 7, 9, 3, 1]) 12 >>> rob([2, 1, 1, 2]) 4 >>> rob([10, 0, 0, 10, 0, 10, 10]) 30 >>> rob([]) 0 >>> rob([1, 2, 3, 4, 5]) 9 >>> rob([10, 10, 10, 10, 10]) 30","solution":"from typing import List def rob(nums: List[int]) -> int: n = len(nums) if n == 0: return 0 if n == 1: return nums[0] dp = [0] * n dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + nums[i]) return dp[-1]"},{"question":"def length_of_LIS(arr: List[int]) -> int: Returns the length of the longest increasing subsequence in arr. >>> length_of_LIS([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> length_of_LIS([]) 0 >>> length_of_LIS([1]) 1 >>> length_of_LIS([5, 4, 3, 2, 1]) 1 >>> length_of_LIS([1, 2, 3, 4, 5]) 5 >>> length_of_LIS([3, 10, 2, 1, 20]) 3 >>> length_of_LIS([3, 2]) 1 >>> length_of_LIS([50, 3, 10, 7, 40, 80]) 4 >>> length_of_LIS([4, 4, 4, 4, 4]) 1","solution":"def length_of_LIS(arr): Returns the length of the longest increasing subsequence in arr. if not arr: return 0 n = len(arr) lis = [1] * n for i in range(1, n): for j in range(i): if arr[i] > arr[j]: lis[i] = max(lis[i], lis[j] + 1) return max(lis)"},{"question":"def findAllRoutes(graph: dict, start: str, end: str) -> list: Implement a function \`findAllRoutes\` that, given a directed acyclic graph (DAG) represented by an adjacency list, finds all possible routes from a specified start node to an end node. The function should return a list of these routes, with each route represented as a list of nodes, sorted in lexicographical order. Args: graph (dict): A dictionary representing the adjacency list of the graph. start (str): The starting node of the routes. end (str): The ending node of the routes. Returns: list: A list of all possible routes from start to end, each route being a list of nodes. >>> findAllRoutes({'A': ['B', 'C'], 'B': ['D'], 'C': ['D'], 'D': []}, 'A', 'D') [['A', 'B', 'D'], ['A', 'C', 'D']] >>> findAllRoutes({'A': ['B'], 'B': ['C'], 'C': []}, 'A', 'D') [] >>> findAllRoutes({'A': []}, 'A', 'A') [['A']]","solution":"def findAllRoutes(graph, start, end): def dfs(current, path): if current == end: routes.append(path) return for neighbor in sorted(graph.get(current, [])): dfs(neighbor, path + [neighbor]) routes = [] dfs(start, [start]) return routes"},{"question":"def merge(nums1, m, nums2, n): Merges two sorted arrays into one sorted array in-place. Args: nums1 (List[int]): First sorted array with a size of m + n, where the first m elements are initialized, and the rest are 0. m (int): Number of initialized elements in nums1. nums2 (List[int]): Second sorted array with n elements. n (int): Number of elements in nums2. Returns: None: The result is stored in nums1.","solution":"def merge(nums1, m, nums2, n): Merges two sorted arrays into one sorted array in-place. Args: nums1 (List[int]): First sorted array with a size of m + n, where the first m elements are initialized, and the rest are 0. m (int): Number of initialized elements in nums1. nums2 (List[int]): Second sorted array with n elements. n (int): Number of elements in nums2. Returns: None: The result is stored in nums1. # Last index of nums1 to start merging from last = m + n - 1 # Merge in reverse order while m > 0 and n > 0: if nums1[m - 1] > nums2[n - 1]: nums1[last] = nums1[m - 1] m -= 1 else: nums1[last] = nums2[n - 1] n -= 1 last -= 1 # Fill nums1 with remaining elements from nums2 if any while n > 0: nums1[last] = nums2[n - 1] n -= 1 last -= 1"},{"question":"def longest_increasing_sequence(nums: List[int]) -> int: Given an array of integers \`nums\` representing the number of consonants in each segment of text, find the length of the longest increasing sequence of segments where each segment has an increasing number of consonants. Args: nums (List[int]): An array of integers representing the number of consonants in each segment. Returns: int: The length of the longest increasing sequence of segments with increasing consonant counts. Examples: >>> longest_increasing_sequence([1, 2, 3, 1, 2, 3, 4]) 4 >>> longest_increasing_sequence([1, 2, 3, 4, 5]) 5 >>> longest_increasing_sequence([5, 4, 3, 2, 1]) 1 >>> longest_increasing_sequence([3, 10, 2, 1, 20]) 3 >>> longest_increasing_sequence([1]) 1 >>> longest_increasing_sequence([4, 4, 4, 4]) 1 >>> longest_increasing_sequence([]) 0","solution":"def longest_increasing_sequence(nums): Returns the length of the longest increasing sequence of segments with increasing consonant counts. if not nums: return 0 n = len(nums) lis = [1] * n # Initialize LIS values for all indexes as 1 # Compute optimized LIS values in bottom-up manner for i in range(1, n): for j in range(0, i): if nums[i] > nums[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 # Return maximum value in lis return max(lis)"},{"question":"from typing import List def count_unique_elements(arr: List[int], k: int) -> List[int]: Given an array of integers \`arr\` of length \`n\` and an integer \`k\`, determine the number of unique elements in each subarray of length \`k\` of \`arr\`. A subarray is a contiguous segment of the array. The function should return an array \`result\` of length \`n - k + 1\` where \`result[i]\` stores the number of unique elements in the subarray starting at index \`i\`. >>> count_unique_elements([1, 2, 2, 1, 3], 3) [2, 2, 3] >>> count_unique_elements([1, 2, 3, 4, 5], 3) [3, 3, 3] >>> count_unique_elements([1, 1, 1, 1, 1], 2) [1, 1, 1, 1] >>> count_unique_elements([1, 2, 1, 3, 1, 4], 4) [3, 3, 3] >>> count_unique_elements([1, 2], 3) [] >>> count_unique_elements([1, 2, 3], 3) [3]","solution":"def count_unique_elements(arr, k): Returns an array where each element is the number of unique elements in the subarray of length k starting at that index. from collections import defaultdict n = len(arr) if k > n: return [] result = [] current_count_map = defaultdict(int) unique_count = 0 # Initialize the first window for i in range(k): if current_count_map[arr[i]] == 0: unique_count += 1 current_count_map[arr[i]] += 1 result.append(unique_count) # Slide the window for i in range(k, n): # remove the exiting element from the window element_to_remove = arr[i - k] current_count_map[element_to_remove] -= 1 if current_count_map[element_to_remove] == 0: unique_count -= 1 # add the new element to the window new_element = arr[i] if current_count_map[new_element] == 0: unique_count += 1 current_count_map[new_element] += 1 result.append(unique_count) return result"},{"question":"from typing import List from collections import defaultdict class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class Solution: def findDuplicateSubtrees(self, root: TreeNode) -> List[TreeNode]: Find all duplicate subtrees in the binary tree. Each subtree must have the same structure and values. Returns a list of TreeNode objects representing the roots of the duplicate subtrees. pass def test_findDuplicateSubtrees_empty_tree(): sol = Solution() assert sol.findDuplicateSubtrees(None) == [] def test_findDuplicateSubtrees_single_node(): sol = Solution() root = TreeNode(1) assert sol.findDuplicateSubtrees(root) == [] def test_findDuplicateSubtrees_all_unique(): sol = Solution() root = TreeNode(1, TreeNode(2), TreeNode(3)) assert sol.findDuplicateSubtrees(root) == [] def test_findDuplicateSubtrees_with_duplicates(): sol = Solution() # Tree structure: # 1 # / # 2 3 # / / # 4 2 4 # / # 4 node4_1 = TreeNode(4) node2_1 = TreeNode(2, left=node4_1) node2_2 = TreeNode(2, left=TreeNode(4)) node3 = TreeNode(3, left=node2_2, right=TreeNode(4)) root = TreeNode(1, left=node2_1, right=node3) result = sol.findDuplicateSubtrees(root) result_vals = sorted([node.val for node in result]) assert result_vals == [2, 4]","solution":"from typing import List, Optional from collections import defaultdict class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class Solution: def findDuplicateSubtrees(self, root: TreeNode) -> List[TreeNode]: def traverse(node): if not node: return '#' serial = \\"{},{},{}\\".format(node.val, traverse(node.left), traverse(node.right)) trees[serial].append(node) return serial trees = defaultdict(list) traverse(root) return [nodes[0] for nodes in trees.values() if len(nodes) > 1]"},{"question":"def canArrange(nums: List[int], k: int) -> bool: Determine if we can partition the array into pairs such that the sum of each pair is divisible by k. >>> canArrange([1, 2, 3, 4, 5, 10, 6, 7, 8, 9], 5) == True >>> canArrange([1, 2, 3, 4, 5, 6], 7) == True >>> canArrange([2, 2, 2, 2], 4) == True >>> canArrange([1, 1, 1, 1], 2) == True >>> canArrange([1, 2, 3, 4, 5, 6], 10) == False >>> canArrange([1, 2, 3, 4, 6], 5) == False >>> canArrange([1, 2, 2, 2], 3) == False >>> canArrange([1, 2, 3], 7) == False","solution":"def canArrange(nums, k): Determine if we can partition the array into pairs such that the sum of each pair is divisible by k. Args: nums: List of integers. k: Integer. Returns: bool: True if partitioning is possible, False otherwise. # Calculate frequency of remainders when nums elements are divided by k remainder_counts = [0] * k for num in nums: remainder = num % k remainder_counts[remainder] += 1 # Check pairs from both sides of the remainder array if remainder_counts[0] % 2 != 0: return False for i in range(1, k // 2 + 1): if remainder_counts[i] != remainder_counts[k - i]: return False return True"},{"question":"def max_non_consecutive_sum(nums: List[int]) -> int: Returns the maximum sum of non-consecutive elements in the list \`nums\`. >>> max_non_consecutive_sum([3, 2, 5, 10, 7]) 15 >>> max_non_consecutive_sum([]) 0 >>> max_non_consecutive_sum([5]) 5 >>> max_non_consecutive_sum([4, 1]) 4 >>> max_non_consecutive_sum([1, 2, 3, 4, 5]) 9 >>> max_non_consecutive_sum([5, 1, 5, 1, 5]) 15 >>> max_non_consecutive_sum([3, 3, 3, 3, 3]) 9 >>> max_non_consecutive_sum([100, 1000, 100, 1000, 100]) 2000","solution":"def max_non_consecutive_sum(nums): Returns the maximum sum of non-consecutive elements in the list \`nums\`. if not nums: return 0 include = 0 exclude = 0 for num in nums: # Current number is included, previous excluded new_include = exclude + num # Current number is excluded, take the maximum of the previous include and exclude exclude = max(include, exclude) include = new_include # Return the maximum of including or excluding last element return max(include, exclude)"},{"question":"def max_distinct_characters(s: str, k: int) -> int: Determine the maximum number of distinct characters that can be obtained by deleting exactly k characters from the string s. >>> max_distinct_characters(\\"abcabc\\", 3) == 2 >>> max_distinct_characters(\\"aabbcc\\", 2) == 2 >>> max_distinct_characters(\\"abcdef\\", 1) == 5 >>> max_distinct_characters(\\"aaabbb\\", 3) == 1 >>> max_distinct_characters(\\"zxyabc\\", 0) == 6 >>> max_distinct_characters(\\"a\\", 1) == 0 >>> max_distinct_characters(\\"aaaaaaa\\", 7) == 0 >>> max_distinct_characters(\\"qwerty\\", 0) == 6 >>> max_distinct_characters(\\"aaaa\\", 0) == 1","solution":"from collections import Counter def max_distinct_characters(s, k): Returns the maximum number of distinct characters after deleting exactly k characters from the string s. # Calculate the frequency of each character frequency = Counter(s) # Sort character counts in ascending order frequencies_sorted = sorted(frequency.values()) # Initialize the number of deletions and distinct characters deletions = 0 distinct_chars = len(frequencies_sorted) # Remove the k characters by reducing the lowest frequency characters first for freq in frequencies_sorted: if deletions + freq <= k: deletions += freq distinct_chars -= 1 else: break return distinct_chars"},{"question":"def min_operations_to_convert(words, target): Calculate the minimum number of operations required to convert any string in the words list into the target string. The operation allowed is changing one character to another. If it is not possible to convert any string in words to target, returns -1. :param words: List of strings :param target: The target string :return: Minimum number of operations or -1 if conversion is not possible from solution import min_operations_to_convert def test_identical_strings(): words = [\\"match\\", \\"patch\\"] target = \\"match\\" assert min_operations_to_convert(words, target) == 0 def test_single_character_change(): words = [\\"ab\\", \\"cd\\", \\"ef\\"] target = \\"cf\\" assert min_operations_to_convert(words, target) == 1 def test_multiple_character_changes(): words = [\\"abcdef\\", \\"ghijkl\\"] target = \\"abzdef\\" assert min_operations_to_convert(words, target) == 1 def test_no_possible_conversion(): words = [\\"apple\\", \\"orange\\"] target = \\"orange\\" words_different_length = [\\"short\\", \\"medium\\"] target_another_length = \\"longest\\" assert min_operations_to_convert(words, target) == 0 assert min_operations_to_convert(words_different_length, target_another_length) == -1 def test_empty_words_list(): words = [] target = \\"anything\\" assert min_operations_to_convert(words, target) == -1 def test_empty_target_string(): words = [\\"nonempty\\", \\"empty\\"] target = \\"\\" assert min_operations_to_convert(words, target) == -1 def test_single_letter_words(): words = [\\"a\\", \\"b\\", \\"c\\"] target = \\"d\\" assert min_operations_to_convert(words, target) == 1","solution":"def min_operations_to_convert(words, target): Calculate the minimum number of operations required to convert any string in the words list into the target string. The operation allowed is changing one character to another. If it is not possible to convert any string in words to target, returns -1. :param words: List of strings :param target: The target string :return: Minimum number of operations or -1 if conversion is not possible def operations_count(word, target): Calculate the number of operations to convert word to target. :param word: Source word :param target: Target word :return: Number of operations or -1 if lengths differ if len(word) != len(target): return -1 return sum(1 for w_char, t_char in zip(word, target) if w_char != t_char) min_operations = float('inf') for word in words: ops = operations_count(word, target) if ops != -1: min_operations = min(min_operations, ops) return min_operations if min_operations != float('inf') else -1"},{"question":"class Node: def __init__(self, val=0, left=None, right=None, next=None): self.val = val self.left = left self.right = right self.next = next def connect(root: 'Node') -> 'Node': Given a binary tree, connect all nodes at the same level from left to right using next pointers. The function modifies the tree in place and returns the root node after connecting the next pointers. Each node in the tree has a \`next\` pointer, initially set to \`NULL\`. The next pointers should be populated to point to their next right node. If there is no next node on the same level, the next pointer should be set to \`NULL\`. The binary tree should be represented using a \`Node\` class which has the following structure: class Node: def __init__(self, val=0, left=None, right=None, next=None): self.val = val self.left = left self.right = right self.next = next You may assume that the tree is a perfect binary tree (i.e., all leaves are at the same level, and every parent has two children). The algorithm should run in O(n) time complexity and use constant extra space. >>> root = Node(1, Node(2), Node(3)) >>> connect(root) <__main__.Node object at ...> # Your code here","solution":"class Node: def __init__(self, val=0, left=None, right=None, next=None): self.val = val self.left = left self.right = right self.next = next def connect(root: 'Node') -> 'Node': if not root: return root leftmost = root while leftmost.left: head = leftmost while head: head.left.next = head.right if head.next: head.right.next = head.next.left head = head.next leftmost = leftmost.left return root"},{"question":"from typing import List def partition(nums: List[int], left: int, right: int, pivot_index: int) -> int: pivot_value = nums[pivot_index] nums[pivot_index], nums[right] = nums[right], nums[pivot_index] # Move pivot to end store_index = left for i in range(left, right): if nums[i] < pivot_value: nums[store_index], nums[i] = nums[i], nums[store_index] store_index += 1 nums[right], nums[store_index] = nums[store_index], nums[right] # Move pivot to its final place return store_index def quickselect(nums: List[int], left: int, right: int, k: int) -> int: if left == right: # If the list contains only one element return nums[left] pivot_index = random.randint(left, right) pivot_index = partition(nums, left, right, pivot_index) if k == pivot_index: return nums[k] elif k < pivot_index: return quickselect(nums, left, pivot_index - 1, k) else: return quickselect(nums, pivot_index + 1, right, k) def find_kth_smallest(nums: List[int], k: int) -> int: Return the k-th smallest element in the array. >>> find_kth_smallest([3, 2, 1, 5, 6, 4], 2) 2 >>> find_kth_smallest([3, 2, 3, 1, 2, 4, 5, 5, 6], 4) 3 return quickselect(nums, 0, len(nums) - 1, k - 1)","solution":"import random def partition(nums, left, right, pivot_index): pivot_value = nums[pivot_index] nums[pivot_index], nums[right] = nums[right], nums[pivot_index] # Move pivot to end store_index = left for i in range(left, right): if nums[i] < pivot_value: nums[store_index], nums[i] = nums[i], nums[store_index] store_index += 1 nums[right], nums[store_index] = nums[store_index], nums[right] # Move pivot to its final place return store_index def quickselect(nums, left, right, k): if left == right: # If the list contains only one element return nums[left] pivot_index = random.randint(left, right) pivot_index = partition(nums, left, right, pivot_index) if k == pivot_index: return nums[k] elif k < pivot_index: return quickselect(nums, left, pivot_index - 1, k) else: return quickselect(nums, pivot_index + 1, right, k) def find_kth_smallest(nums, k): Return the k-th smallest element in the array. return quickselect(nums, 0, len(nums) - 1, k - 1)"},{"question":"def longest_valid_string_length(s: str) -> int: Given a string \`s\` containing only the characters 'a' and 'b', this function returns the length of the longest string that can be formed by deleting characters such that no three consecutive characters are the same. Parameters: s (str): Input string containing only 'a' and 'b' Returns: int: Length of the longest valid string >>> longest_valid_string_length(\\"aaabbb\\") 4 >>> longest_valid_string_length(\\"aaaa\\") 2 >>> longest_valid_string_length(\\"ababab\\") 6 >>> longest_valid_string_length(\\"aabbaabbaa\\") 10 >>> longest_valid_string_length(\\"\\") 0 >>> longest_valid_string_length(\\"aabbaa\\") 6 >>> longest_valid_string_length(\\"aabbaabb\\") 8","solution":"def longest_valid_string_length(s): Given a string s containing only the characters 'a' and 'b', this function returns the length of the longest string that can be formed by deleting characters such that no three consecutive characters are the same. Parameters: s (str): Input string containing only 'a' and 'b' Returns: int: Length of the longest valid string if not s: return 0 count = 1 prev_char = s[0] result = 1 for i in range(1, len(s)): if s[i] == prev_char: count += 1 if count <= 2: result += 1 else: count = 1 result += 1 prev_char = s[i] return result"},{"question":"def can_partition_into_equal_sum_pairs(nums): Determine if the array can be partitioned into pairs with equal sums. Args: nums (list): list of integers where each integer appears exactly twice. Returns: bool: True if such partitioning is possible, False otherwise. >>> can_partition_into_equal_sum_pairs([1, 1, 2, 2]) True >>> can_partition_into_equal_sum_pairs([1, 1, 2, 2, 3, 3, 4, 4]) True >>> can_partition_into_equal_sum_pairs([1, 2, 2]) False >>> can_partition_into_equal_sum_pairs([1, 1, 2, 2, 3, 3, 4, 4, 5, 5]) True >>> can_partition_into_equal_sum_pairs([1, 2, 2, 3, 3, 4, 4, 5, 5, 5]) False","solution":"def can_partition_into_equal_sum_pairs(nums): Determine if the array can be partitioned into pairs with equal sums. Args: nums (list): list of integers where each integer appears exactly twice. Returns: bool: True if such partitioning is possible, False otherwise. import collections count = collections.Counter(nums) # Check if we can form pairs if any(v % 2 != 0 for v in count.values()): return False # Each element appears exactly twice, so we can form n pairs where each pair # has identical elements. They all will have sum 2*x, where x is any element in range [1, n]. return True"},{"question":"class LibrarySystem: A library system that manages a list of book borrowings. Methods: borrowBook(userId: int, bookId: int, borrowTime: int) -> None: Logs that a user with ID \`userId\` borrowed a book with ID \`bookId\` at time \`borrowTime\`. returnBook(userId: int, bookId: int, returnTime: int) -> None: Logs that a user with ID \`userId\` returned a book with ID \`bookId\` at time \`returnTime\`. getAverageBorrowTime(bookId: int) -> float: Returns the average time a book with ID \`bookId\` is borrowed. >>> library = LibrarySystem() >>> library.borrowBook(1, 101, 10) >>> library.returnBook(1, 101, 20) >>> library.getAverageBorrowTime(101) 10.0 >>> library.borrowBook(1, 101, 10) >>> library.returnBook(1, 101, 20) >>> library.borrowBook(2, 101, 30) >>> library.returnBook(2, 101, 50) >>> library.getAverageBorrowTime(101) 15.0 >>> library.getAverageBorrowTime(102) 0.0 >>> library.borrowBook(1, 101, 10) >>> library.returnBook(1, 101, 20) >>> library.borrowBook(2, 102, 30) >>> library.returnBook(2, 102, 50) >>> library.getAverageBorrowTime(101) 10.0 >>> library.getAverageBorrowTime(102) 20.0","solution":"class LibrarySystem: def __init__(self): self.borrow_records = {} self.return_records = {} self.total_borrow_times = {} self.borrow_counts = {} def borrowBook(self, userId, bookId, borrowTime): if bookId not in self.borrow_records: self.borrow_records[bookId] = {} self.borrow_records[bookId][userId] = borrowTime def returnBook(self, userId, bookId, returnTime): if bookId in self.borrow_records and userId in self.borrow_records[bookId]: borrowTime = self.borrow_records[bookId][userId] borrow_duration = returnTime - borrowTime if bookId not in self.total_borrow_times: self.total_borrow_times[bookId] = 0 self.borrow_counts[bookId] = 0 self.total_borrow_times[bookId] += borrow_duration self.borrow_counts[bookId] += 1 del self.borrow_records[bookId][userId] def getAverageBorrowTime(self, bookId): if bookId in self.total_borrow_times and self.borrow_counts[bookId] > 0: return self.total_borrow_times[bookId] / self.borrow_counts[bookId] return 0.0"},{"question":"from typing import List def reorderLogFiles(logs: List[str]) -> List[str]: Reorder the logs so that all the letter-logs come before any digit-log. The letter-logs are sorted lexicographically by their content, and within content by their identifiers if the content is the same. The digit-logs should maintain their relative ordering. >>> reorderLogFiles([\\"dig1 8 1 5 1\\", \\"let1 art can\\", \\"dig2 3 6\\", \\"let2 own kit dig\\", \\"let3 art zero\\"]) [\\"let1 art can\\", \\"let3 art zero\\", \\"let2 own kit dig\\", \\"dig1 8 1 5 1\\", \\"dig2 3 6\\"] >>> reorderLogFiles([\\"let1 abc def\\", \\"let2 ghi jkl\\", \\"let3 mno pqr\\", \\"let4 stu vwx\\"]) [\\"let1 abc def\\", \\"let2 ghi jkl\\", \\"let3 mno pqr\\", \\"let4 stu vwx\\"] >>> reorderLogFiles([\\"dig1 8 1 5 1\\", \\"dig2 3 6\\", \\"dig3 2 4\\", \\"dig4 9 7\\"]) [\\"dig1 8 1 5 1\\", \\"dig2 3 6\\", \\"dig3 2 4\\", \\"dig4 9 7\\"] >>> reorderLogFiles([\\"let1 abc def\\", \\"let2 abc def\\", \\"let3 abc def\\"]) [\\"let1 abc def\\", \\"let2 abc def\\", \\"let3 abc def\\"] >>> reorderLogFiles([]) []","solution":"from typing import List def reorderLogFiles(logs: List[str]) -> List[str]: def get_key(log: str): identifier, content = log.split(' ', 1) if content[0].isdigit(): return (1,) else: return (0, content, identifier) return sorted(logs, key=get_key)"},{"question":"def max_area(height: List[int]) -> int: Returns the maximum area of water a container can store given an array of heights. >>> max_area([1,8,6,2,5,4,8,3,7]) == 49 >>> max_area([4,4,4,4,4,4]) == 20 >>> max_area([2, 3]) == 2 >>> max_area([5, 4, 3, 2, 1]) == 6 >>> max_area([1, 2, 3, 4, 5]) == 6 >>> max_area([5]) == 0 >>> max_area([1, 1000]) == 1","solution":"def max_area(height): Returns the maximum area of water a container can store given an array of heights. :param height: list of integers representing heights of vertical lines :return: integer representing maximum amount of water the container can store max_water = 0 left = 0 right = len(height) - 1 while left < right: # Calculate area with the current left and right lines width = right - left current_height = min(height[left], height[right]) current_area = width * current_height # Update max_water if current_area is larger max_water = max(max_water, current_area) # Move the pointer that's at the shorter line if height[left] < height[right]: left += 1 else: right -= 1 return max_water"},{"question":"class WordDictionary: Class \`WordDictionary\` to support addition of new words and searching for a word in the data structure. Methods: - __init__() : Initializes the data structure. - addWord(word: str) : Adds a word to the data structure. - search(word: str) : Returns \`true\` if the word is in the data structure. The \`.\` character can represent any one letter. >>> wd = WordDictionary() >>> wd.addWord(\\"bad\\") >>> wd.addWord(\\"dad\\") >>> wd.addWord(\\"mad\\") >>> wd.search(\\"pad\\") == False >>> wd.search(\\"bad\\") == True >>> wd.search(\\".ad\\") == True >>> wd.search(\\"b..\\") == True def __init__(self): pass def addWord(self, word: str) -> None: pass def search(self, word: str) -> bool: pass def test_add_and_search_exact(): wd = WordDictionary() wd.addWord(\\"test\\") assert wd.search(\\"test\\") == True def test_add_and_search_with_dot(): wd = WordDictionary() wd.addWord(\\"test\\") assert wd.search(\\"t.st\\") == True assert wd.search(\\".est\\") == True assert wd.search(\\"te..\\") == True assert wd.search(\\"....\\") == True def test_add_and_search_nonexistent(): wd = WordDictionary() wd.addWord(\\"test\\") assert wd.search(\\"nope\\") == False assert wd.search(\\"t..t.\\") == False def test_add_multiple_and_search(): wd = WordDictionary() wd.addWord(\\"bad\\") wd.addWord(\\"dad\\") wd.addWord(\\"mad\\") assert wd.search(\\"pad\\") == False assert wd.search(\\"bad\\") == True assert wd.search(\\".ad\\") == True assert wd.search(\\"b..\\") == True","solution":"class WordDictionary: def __init__(self): self.words = [] def addWord(self, word: str) -> None: self.words.append(word) def search(self, word: str) -> bool: import re for w in self.words: if re.fullmatch(word, w): return True return False"},{"question":"def find_farms(grid: List[List[int]]) -> List[List[List[int]]]: Returns the list of coordinates representing the top-left and bottom-right corners of each farm in the given 2D grid. >>> find_farms([[1, 1, 0], [1, 1, 0], [0, 0, 0]]) == [[[0, 0], [1, 1]]] >>> find_farms([[1, 0, 0], [0, 1, 1], [0, 1, 0]]) == [[[0, 0], [0, 0]], [[1, 1], [2, 2]]] >>> find_farms([[0, 0], [0, 0]]) == [] >>> find_farms([[1, 0, 1], [0, 0, 0], [1, 0, 1]]) == [[[0, 0], [0, 0]], [[0, 2], [0, 2]], [[2, 0], [2, 0]], [[2, 2], [2, 2]]] >>> find_farms([[1, 1], [1, 1]]) == [[[0, 0], [1, 1]]]","solution":"def find_farms(grid): Returns the list of coordinates representing the top-left and bottom-right corners of each farm in the given 2D grid. def dfs(x, y): stack = [(x, y)] top_left = (x, y) bottom_right = (x, y) while stack: cx, cy = stack.pop() if (cx, cy) not in visited: visited.add((cx, cy)) top_left = (min(top_left[0], cx), min(top_left[1], cy)) bottom_right = (max(bottom_right[0], cx), max(bottom_right[1], cy)) for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]: nx, ny = cx + dx, cy + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 1 and (nx, ny) not in visited: stack.append((nx, ny)) return top_left, bottom_right m, n = len(grid), len(grid[0]) visited = set() farms = [] for i in range(m): for j in range(n): if grid[i][j] == 1 and (i, j) not in visited: top_left, bottom_right = dfs(i, j) farms.append([list(top_left), list(bottom_right)]) return farms"},{"question":"class MatrixModifier: A class to check if it's possible to make all elements of a matrix equal to a target value with a given maximum number of operations. Attributes: mat: The matrix of integers. k: The maximum number of allowed operations. target: The target integer to which all matrix elements should be equal. def __init__(self, mat: List[List[int]], k: int, target: int): Initializes the MatrixModifier with the given matrix, maximum number of allowed operations, and target integer def isPossible(self) -> bool: Returns True if it is possible to make all elements of mat equal to target with at most k operations, otherwise False. from solution import MatrixModifier def test_isPossible_true_case(): mm = MatrixModifier([[1, 2], [3, 4]], 10, 5) assert mm.isPossible() == True def test_isPossible_false_case(): mm = MatrixModifier([[1, 2], [3, 4]], 3, 5) assert mm.isPossible() == False def test_isPossible_exact_operations(): mm = MatrixModifier([[1, 1], [1, 1]], 8, 3) assert mm.isPossible() == True def test_isPossible_no_operations_needed(): mm = MatrixModifier([[5, 5], [5, 5]], 0, 5) assert mm.isPossible() == True def test_isPossible_single_element(): mm = MatrixModifier([[1]], 4, 5) assert mm.isPossible() == True def test_isPossible_large_matrix(): mm = MatrixModifier([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 100, 12) assert mm.isPossible() == True","solution":"class MatrixModifier: def __init__(self, mat, k, target): self.mat = mat self.k = k self.target = target def isPossible(self): operations_needed = 0 for row in self.mat: for elem in row: if elem < self.target: operations_needed += (self.target - elem) if operations_needed > self.k: return False return True"},{"question":"def rearrange_array(arr: List[int], k: int) -> List[int]: Rearrange the elements of arr in such a way that the sum of every k consecutive elements is maximized. If there are multiple possible rearrangements, return the lexicographically smallest one. Parameters: arr (list of int): The array of integers to rearrange. k (int): The number of consecutive elements to consider for sum maximization. Returns: list of int: The rearranged array. >>> rearrange_array([4, 3, 2, 1], 1) [4, 3, 2, 1] >>> rearrange_array([1, 2, 3, 4], 2) [4, 3, 2, 1] >>> rearrange_array([9, 8, 5, 2, 1, 7, 6], 3) [9, 8, 7, 6, 5, 2, 1] >>> rearrange_array([-1, -2, -3, -4], 2) [-1, -2, -3, -4] >>> rearrange_array([3, 1, 2, 1, 2], 2) [3, 2, 2, 1, 1] >>> rearrange_array([1, 2, 3, 4, 5, 6], 3) [6, 5, 4, 3, 2, 1]","solution":"def rearrange_array(arr, k): Rearrange the elements of arr in such a way that the sum of every k consecutive elements is maximized. If there are multiple possible rearrangements, return the lexicographically smallest one. Parameters: arr (list of int): The array of integers to rearrange. k (int): The number of consecutive elements to consider for sum maximization. Returns: list of int: The rearranged array. # Sort the array in decreasing order to maximize the sum of consecutive k elements arr.sort(reverse=True) return arr"},{"question":"def max_in_windows(arr: List[int], window_size: int) -> List[int]: Returns a list where the i-th element is the maximum value of the subarray of \`arr\` that starts at the i-th index and has length \`window_size\`. Parameters: - arr: List[int] : List of integers. - window_size: int : Size of the window. Returns: - List[int] : List of maximum values for each subarray of size \`window_size\`. >>> max_in_windows([1, 3, 2, 5, 4, 6], 3) == [3, 5, 5, 6] >>> max_in_windows([1, 2, 3, 4], 1) == [1, 2, 3, 4] >>> max_in_windows([4, 3, 2, 5], 4) == [5] >>> max_in_windows([2, 2, 2, 2], 2) == [2, 2, 2] >>> max_in_windows([5, 4, 3, 2, 1], 3) == [5, 4, 3] >>> max_in_windows([1, 2, 3, 4, 5], 2) == [2, 3, 4, 5]","solution":"def max_in_windows(arr, window_size): Returns a list where the i-th element is the maximum value of the subarray of \`arr\` that starts at the i-th index and has length \`window_size\`. If the \`window_size\` exceeds the boundaries of the array for any starting index, it is considered only up to the last element of the array. Parameters: - arr: List[int] : List of integers. - window_size: int : Size of the window. Returns: - List[int] : List of maximum values for each subarray of size \`window_size\`. result = [] for i in range(len(arr) - window_size + 1): max_value = max(arr[i:i + window_size]) result.append(max_value) return result"},{"question":"def same_final_position(s1: str, s2: str) -> bool: Determine if two sequences of moves s1 and s2 end up at the same final position. >>> same_final_position('UDLR', 'LRUD') True >>> same_final_position('UUDDLRR', 'UDLR') False >>> same_final_position('UUU', 'DDD') False >>> same_final_position('LLRR', 'RRLL') True >>> same_final_position('UDUDUD', 'DUDUDU') True >>> same_final_position('LDRU', 'RRD') False >>> same_final_position('UUDDLLRR', 'LRUDLRUD') True","solution":"def final_position(s): Calculates the final position after performing the moves in s. x, y = 0, 0 for move in s: if move == 'U': y += 1 elif move == 'D': y -= 1 elif move == 'L': x -= 1 elif move == 'R': x += 1 return (x, y) def same_final_position(s1, s2): Determines if two sequences of moves s1 and s2 end up at the same final position. return final_position(s1) == final_position(s2)"},{"question":"def max_distance(matrix: list[list[int]]) -> int: Finds the maximum distance between any two distinct cells in the matrix such that the value in the first cell is greater than the value in the second cell. Distance is defined as the absolute difference between two cell values. Parameters: matrix (list of list of ints): The m x n integer matrix. Returns: int: The maximum distance achievable. # Unit tests def test_basic_case(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert max_distance(matrix) == 8 def test_negative_numbers(): matrix = [ [-1, -2, -3], [-4, -5, -6] ] assert max_distance(matrix) == 5 def test_mixed_numbers(): matrix = [ [1, -2, 3], [-4, 5, -6], [7, -8, 9] ] assert max_distance(matrix) == 17 def test_single_row(): matrix = [[5, 3, 2, 8, 10]] assert max_distance(matrix) == 8 def test_single_column(): matrix = [[1], [2], [3], [4], [5], [6]] assert max_distance(matrix) == 5","solution":"def max_distance(matrix): Finds the maximum distance between any two distinct cells in the matrix such that the value in the first cell is greater than the value in the second cell. Distance is defined as the absolute difference between two cell values. Parameters: matrix (list of list of ints): The m x n integer matrix. Returns: int: The maximum distance achievable. max_val = float('-inf') min_val = float('inf') for row in matrix: for val in row: if val > max_val: max_val = val if val < min_val: min_val = val return max_val - min_val"},{"question":"def sort_string(s: str) -> str: Sorts the letters in the string s while retaining the positions of special characters. >>> sort_string(\\"ac#b\\") 'ab#c' >>> sort_string(\\"cba\\") 'abc' >>> sort_string(\\"#@\\") '#@' >>> sort_string(\\"zyx#%^@\\") 'xyz#%^@' >>> sort_string(\\"\\") '' >>> sort_string(\\"bac\\") 'abc' >>> sort_string(\\"aaa\\") 'aaa' >>> sort_string(\\"#bac#\\") '#abc# def sort_string(s: str) -> str: Sorts the letters in the string s while retaining the positions of special characters. >>> sort_string(\\"ac#b\\") == \\"ab#c\\" >>> sort_string(\\"cba\\") == \\"abc\\" >>> sort_string(\\"#@\\") == \\"#@\\" >>> sort_string(\\"zyx#%^@\\") == \\"xyz#%^@\\" >>> sort_string(\\"\\") == \\"\\" >>> sort_string(\\"bac\\") == \\"abc\\" >>> sort_string(\\"aaa\\") == \\"aaa\\" >>> sort_string(\\"#bac#\\") == \\"#abc#\\"","solution":"def sort_string(s): Sorts the letters in the string s while retaining the positions of special characters. letters = [char for char in s if char.isalpha()] letters.sort() result = [] letter_idx = 0 for char in s: if char.isalpha(): result.append(letters[letter_idx]) letter_idx += 1 else: result.append(char) return ''.join(result)"},{"question":"def length_of_longest_substring_two_distinct(s: str) -> int: Returns the length of the longest substring containing at most two distinct characters. >>> length_of_longest_substring_two_distinct(\\"aaaa\\") == 4 >>> length_of_longest_substring_two_distinct(\\"aab\\") == 3 >>> length_of_longest_substring_two_distinct(\\"eceba\\") == 3 >>> length_of_longest_substring_two_distinct(\\"abcabcabcabc\\") == 2 >>> length_of_longest_substring_two_distinct(\\"abaccc\\") == 4 >>> length_of_longest_substring_two_distinct(\\"ababffzzeee\\") == 5 >>> length_of_longest_substring_two_distinct(\\"\\") == 0 pass from solution import length_of_longest_substring_two_distinct def test_single_character(): assert length_of_longest_substring_two_distinct(\\"aaaa\\") == 4 def test_two_distinct_characters(): assert length_of_longest_substring_two_distinct(\\"aab\\") == 3 def test_multiple_characters(): assert length_of_longest_substring_two_distinct(\\"eceba\\") == 3 def test_long_string(): assert length_of_longest_substring_two_distinct(\\"abcabcabcabc\\") == 2 def test_edge_cases(): assert length_of_longest_substring_two_distinct(\\"abaccc\\") == 4 assert length_of_longest_substring_two_distinct(\\"ababffzzeee\\") == 5 assert length_of_longest_substring_two_distinct(\\"\\") == 0","solution":"def length_of_longest_substring_two_distinct(s): Returns the length of the longest substring containing at most two distinct characters. if len(s) < 3: return len(s) left = 0 right = 0 max_length = 2 char_map = {} while right < len(s): char_map[s[right]] = right right += 1 if len(char_map) > 2: del_idx = min(char_map.values()) del char_map[s[del_idx]] left = del_idx + 1 max_length = max(max_length, right - left) return max_length"},{"question":"def count_low_high_pairs(arr): Returns the count of low-high pairs in the given array. A pair (i, j) is defined as low-high if i < j and arr[i] < arr[j]. >>> count_low_high_pairs([]) == 0 >>> count_low_high_pairs([1]) == 0 >>> count_low_high_pairs([1, 2]) == 1 >>> count_low_high_pairs([2, 1]) == 0 >>> count_low_high_pairs([1, 2, 3, 4]) == 6 >>> count_low_high_pairs([4, 3, 2, 1]) == 0 >>> count_low_high_pairs([1, 3, 2, 4]) == 5 >>> count_low_high_pairs([1, 1, 1, 2]) == 3 >>> count_low_high_pairs([1, 1, 1, 1]) == 0","solution":"def count_low_high_pairs(arr): Returns the count of low-high pairs in the given array. A pair (i, j) is defined as low-high if i < j and arr[i] < arr[j]. n = len(arr) count = 0 for i in range(n - 1): for j in range(i + 1, n): if arr[i] < arr[j]: count += 1 return count"},{"question":"def longest_good_days(hours: List[int]) -> int: Returns the length of the longest duration of consecutive good days. A good day is when hours worked is more than 8. Parameters: hours (list of int): List representing hours worked each day. Returns: int: The length of the longest duration of consecutive good days. Examples: >>> longest_good_days([9, 10, 11]) == 3 >>> longest_good_days([8, 7, 6]) == 0 >>> longest_good_days([9, 7, 9, 10, 8, 11]) == 2 >>> longest_good_days([]) == 0 >>> longest_good_days([9]) == 1 >>> longest_good_days([7]) == 0 >>> longest_good_days([9, 7, 10, 8, 11, 5, 12]) == 1 >>> longest_good_days([9, 10, 7, 9, 10, 11, 8, 9, 10, 13]) == 3","solution":"def longest_good_days(hours): Returns the length of the longest duration of consecutive good days. A good day is when hours worked is more than 8. Parameters: hours (list of int): List representing hours worked each day. Returns: int: The length of the longest duration of consecutive good days. max_length = 0 current_length = 0 for hour in hours: if hour > 8: current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 return max_length"},{"question":"from typing import List, Tuple def can_reach_exit(maze: List[List[int]], entrance: Tuple[int, int], exit: Tuple[int, int]) -> bool: Determine if there is a path from the entrance to the exit in a maze. >>> can_reach_exit([[0, 1, 0], [0, 0, 0], [1, 1, 0]], (0, 0), (2, 2)) True >>> can_reach_exit([[0, 1, 0], [1, 1, 0], [1, 1, 0]], (0, 0), (2, 2)) False >>> can_reach_exit([[0, 1, 0], [0, 0, 0], [1, 1, 0]], (0, 0), (0, 0)) True >>> can_reach_exit([[0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [1, 1, 1, 1, 0], [0, 0, 0, 0, 0]], (0, 0), (4, 4)) True >>> can_reach_exit([[0, 1, 0, 0, 0], [0, 1, 1, 1, 0], [0, 1, 0, 1, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0]], (0, 0), (4, 4)) False","solution":"from typing import List, Tuple def can_reach_exit(maze: List[List[int]], entrance: Tuple[int, int], exit: Tuple[int, int]) -> bool: rows, cols = len(maze), len(maze[0]) visited = [[False] * cols for _ in range(rows)] def dfs(r, c): if (r, c) == exit: return True if r < 0 or r >= rows or c < 0 or c >= cols or maze[r][c] == 1 or visited[r][c]: return False visited[r][c] = True # Explore neighbors: up, down, left, right if dfs(r - 1, c) or dfs(r + 1, c) or dfs(r, c - 1) or dfs(r, c + 1): return True return False return dfs(entrance[0], entrance[1])"},{"question":"def longest_subarray_with_diff(arr, k): Returns the length of the longest subarray where the difference between the largest and the smallest elements is less than or equal to k. >>> longest_subarray_with_diff([1, 2, 3, 4], 2) == 3 >>> longest_subarray_with_diff([10, 1, 2], 0) == 1 >>> longest_subarray_with_diff([5, 5, 5, 5], 0) == 4 >>> longest_subarray_with_diff([1, 2, 3, 4, 5, 6], 10) == 6 >>> longest_subarray_with_diff([3], 5) == 1 >>> longest_subarray_with_diff([8, 3, 5, 7, 10, 12], 4) == 3 >>> longest_subarray_with_diff([9, 8, 7, 1, 2, 3, 4, 5, 6], 2) == 3","solution":"def longest_subarray_with_diff(arr, k): Returns the length of the longest subarray where the difference between the largest and the smallest elements is less than or equal to k. from collections import deque max_len = 0 min_queue = deque() # Deque to store indices of elements in increasing order max_queue = deque() # Deque to store indices of elements in decreasing order left = 0 for right in range(len(arr)): while min_queue and arr[min_queue[-1]] >= arr[right]: min_queue.pop() while max_queue and arr[max_queue[-1]] <= arr[right]: max_queue.pop() min_queue.append(right) max_queue.append(right) while arr[max_queue[0]] - arr[min_queue[0]] > k: left += 1 if min_queue[0] < left: min_queue.popleft() if max_queue[0] < left: max_queue.popleft() max_len = max(max_len, right - left + 1) return max_len"},{"question":"def rotate(nums: List[int], k: int) -> List[int]: Rotates the list nums to the right by k steps. >>> rotate([1, 2, 3, 4, 5], 0) [1, 2, 3, 4, 5] >>> rotate([1, 2, 3, 4, 5], 1) [5, 1, 2, 3, 4] >>> rotate([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5] >>> rotate([1, 2, 3, 4, 5], 7) [4, 5, 1, 2, 3] >>> rotate(list(range(1, 11)), 3) [8, 9, 10, 1, 2, 3, 4, 5, 6, 7] >>> rotate([-1, -100, 3, 99], 2) [3, 99, -1, -100]","solution":"def rotate(nums, k): Rotates the list nums to the right by k steps. Parameters: nums (list of int): The list of integers to rotate. k (int): The number of steps to rotate the list. Returns: list of int: The rotated list. n = len(nums) k = k % n # Handle cases where k is greater than the size of the list return nums[-k:] + nums[:-k]"},{"question":"def trap_rainwater(heights: List[int]) -> int: Calculate the total amount of rainwater trapped between buildings represented by their heights. >>> trap_rainwater([]) == 0 >>> trap_rainwater([1, 1, 1, 1]) == 0 >>> trap_rainwater([1, 2, 3, 4]) == 0 >>> trap_rainwater([4, 3, 2, 1]) == 0 >>> trap_rainwater([2, 0, 2]) == 2 >>> trap_rainwater([3, 0, 2, 0, 4]) == 7 >>> trap_rainwater([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 >>> trap_rainwater([4]) == 0 >>> trap_rainwater([0]) == 0","solution":"def trap_rainwater(heights): if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i-1], heights[i]) right_max[n-1] = heights[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) water_trapped = 0 for i in range(n): water_trapped += max(0, min(left_max[i], right_max[i]) - heights[i]) return water_trapped"},{"question":"def max_activities_within_slot(start, end, time, duration): Returns the maximum number of activities that can be fully completed within the given time slot. :param start: List of start times of activities. :param end: List of end times of activities. :param time: The starting time of the slot. :param duration: The duration of the slot. :return: Maximum number of activities that can be fully completed within the slot. >>> max_activities_within_slot([1, 2, 3], [2, 3, 4], 0, 10) 3 >>> max_activities_within_slot([1, 2, 3], [4, 5, 6], 5, 2) 0 >>> max_activities_within_slot([1, 5, 8, 10], [4, 7, 9, 11], 5, 5) 2 >>> max_activities_within_slot([0, 5, 10], [5, 10, 15], 0, 10) 2 >>> max_activities_within_slot([1, 3, 5, 7], [1, 3, 5, 7], 0, 10) 4 >>> max_activities_within_slot([], [], 0, 10) 0","solution":"def max_activities_within_slot(start, end, time, duration): Returns the maximum number of activities that can be fully completed within the given time slot. :param start: List of start times of activities. :param end: List of end times of activities. :param time: The starting time of the slot. :param duration: The duration of the slot. :return: Maximum number of activities that can be fully completed within the slot. count = 0 slot_end = time + duration for s, e in zip(start, end): if time <= s and e <= slot_end: count += 1 return count"},{"question":"def num_decodings(s: str) -> int: Given a string \`s\` that consists of only digits, return the number of unique ways to decode it. 1 maps to 'A', 2 maps to 'B', ..., 26 maps to 'Z'. A character can only be decoded if it forms a valid single digit or two-digit number within this range. >>> num_decodings(\\"\\") 0 >>> num_decodings(\\"1\\") 1 >>> num_decodings(\\"10\\") 1 >>> num_decodings(\\"12\\") 2 >>> num_decodings(\\"226\\") 3 >>> num_decodings(\\"06\\") 0 >>> num_decodings(\\"111111111111111111111111111111111111111111111\\") 1836311903","solution":"def num_decodings(s): if not s: return 0 n = len(s) dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 if s[0] != '0' else 0 for i in range(2, n + 1): one_digit = int(s[i - 1:i]) two_digits = int(s[i - 2:i]) if 1 <= one_digit <= 9: dp[i] += dp[i - 1] if 10 <= two_digits <= 26: dp[i] += dp[i - 2] return dp[n]"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def build_tree(nodes): if not nodes: return None root = TreeNode(nodes[0]) queue = [root] idx = 1 while queue and idx < len(nodes): node = queue.pop(0) if nodes[idx] != -1: node.left = TreeNode(nodes[idx]) queue.append(node.left) idx += 1 if idx < len(nodes) and nodes[idx] != -1: node.right = TreeNode(nodes[idx]) queue.append(node.right) idx += 1 return root def find_lca(root, node1, node2): if not root: return None if root.val == node1 or root.val == node2: return root left = find_lca(root.left, node1, node2) right = find_lca(root.right, node1, node2) if left and right: return root return left if left else right def lowest_common_ancestor(nodes, node1, node2): Find the lowest common ancestor of two nodes in a binary tree. >>> lowest_common_ancestor([3, 5, 1, 6, 2, 0, 8, -1, -1, 7, 4], 5, 1) == 3 >>> lowest_common_ancestor([3, 5, 1, 6, 2, 0, 8, -1, -1, 7, 4], 5, 4) == 5 >>> lowest_common_ancestor([1, 2], 1, 2) == 1 >>> lowest_common_ancestor([6, 2, 8, 0, 4, 7, 9, -1, -1, 3, 5], 2, 8) == 6 >>> lowest_common_ancestor([6, 2, 8, 0, 4, 7, 9, -1, -1, 3, 5], 0, 5) == 2","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def build_tree(nodes): if not nodes: return None root = TreeNode(nodes[0]) queue = [root] idx = 1 while queue and idx < len(nodes): node = queue.pop(0) if nodes[idx] != -1: node.left = TreeNode(nodes[idx]) queue.append(node.left) idx += 1 if idx < len(nodes) and nodes[idx] != -1: node.right = TreeNode(nodes[idx]) queue.append(node.right) idx += 1 return root def find_lca(root, node1, node2): if not root: return None if root.val == node1 or root.val == node2: return root left = find_lca(root.left, node1, node2) right = find_lca(root.right, node1, node2) if left and right: return root return left if left else right def lowest_common_ancestor(nodes, node1, node2): root = build_tree(nodes) lca_node = find_lca(root, node1, node2) return lca_node.val"},{"question":"def one_bit_flip(num1: int, num2: int) -> bool: Returns true if num1 can be converted to num2 by flipping exactly one bit, false otherwise. Arguments: num1: int -- the first input non-negative integer num2: int -- the second input non-negative integer Returns: bool >>> one_bit_flip(14, 15) True >>> one_bit_flip(14, 13) False >>> one_bit_flip(10, 10) False >>> one_bit_flip(8, 0) True >>> one_bit_flip(8192, 8193) True","solution":"def one_bit_flip(num1, num2): Returns true if num1 can be converted to num2 by flipping exactly one bit, false otherwise. Arguments: num1: int -- the first input non-negative integer num2: int -- the second input non-negative integer Returns: bool # XOR the numbers to find the differing bits xor_result = num1 ^ num2 # Return True if the xor result is a power of 2 (only one bit is different) return xor_result != 0 and (xor_result & (xor_result - 1)) == 0"},{"question":"def minDistance(word1: str, word2: str) -> int: Returns the minimum number of operations required to convert word1 to word2. Allowed operations: - Insert a character - Delete a character - Replace a character >>> minDistance(\\"abc\\", \\"abc\\") == 0 >>> minDistance(\\"abc\\", \\"abcd\\") == 1 >>> minDistance(\\"abcd\\", \\"abc\\") == 1 >>> minDistance(\\"abc\\", \\"abd\\") == 1 >>> minDistance(\\"horse\\", \\"ros\\") == 3 >>> minDistance(\\"intention\\", \\"execution\\") == 5 >>> minDistance(\\"\\", \\"abc\\") == 3 >>> minDistance(\\"abc\\", \\"\\") == 3","solution":"def minDistance(word1: str, word2: str) -> int: Returns the minimum number of operations required to convert word1 to word2. Allowed operations: - Insert a character - Delete a character - Replace a character m, n = len(word1), len(word2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j elif j == 0: dp[i][j] = i elif word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) return dp[m][n]"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"abcabcbb\\") == 3 >>> length_of_longest_substring(\\"abcdef\\") == 6 >>> length_of_longest_substring(\\"aaaaaa\\") == 1 >>> length_of_longest_substring(\\"aab\\") == 2 >>> length_of_longest_substring(\\"\\") == 0 >>> length_of_longest_substring(\\"abba\\") == 2 >>> length_of_longest_substring(\\"dvdf\\") == 3 >>> length_of_longest_substring(\\"abcabcbb\\" * 1000) == 3","solution":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. n = len(s) seen = {} max_len = 0 start = 0 for end in range(n): if s[end] in seen: start = max(start, seen[s[end]] + 1) seen[s[end]] = end max_len = max(max_len, end - start + 1) return max_len"},{"question":"def can_transform(s: str, t: str) -> bool: Returns true if it's possible to make string s equal to string t by replacing at most one character in s with another lowercase English letter, otherwise false. :param s: str - the original string :param t: str - the target string :return: bool - whether it's possible to transform s into t with at most one replacement >>> can_transform(\\"abc\\", \\"abc\\") == True >>> can_transform(\\"abc\\", \\"abd\\") == True >>> can_transform(\\"abcd\\", \\"abed\\") == True >>> can_transform(\\"abc\\", \\"xyz\\") == False >>> can_transform(\\"hello\\", \\"jzllo\\") == False >>> can_transform(\\"hello\\", \\"hello\\") == True >>> can_transform(\\"\\", \\"\\") == True >>> can_transform(\\"a\\", \\"b\\") == True >>> can_transform(\\"a\\", \\"a\\") == True >>> can_transform(\\"abcd\\", \\"abcf\\") == True >>> can_transform(\\"abc\\", \\"abx\\") == True >>> can_transform(\\"a\\", \\"ab\\") == False","solution":"def can_transform(s, t): Returns true if it's possible to make string s equal to string t by replacing at most one character in s with another lowercase English letter, otherwise false. :param s: str - the original string :param t: str - the target string :return: bool - whether it's possible to transform s into t with at most one replacement if len(s) != len(t): return False # Count the number of differences diff_count = 0 for sc, tc in zip(s, t): if sc != tc: diff_count += 1 if diff_count > 1: return False # If there is 0 or 1 difference, it's possible; otherwise, it's not return diff_count <= 1"},{"question":"def knapsack(weights: List[int], maxCapacity: int) -> int: Calculate the maximum weight that can be achieved with the given constraints. >>> knapsack([1, 3, 4, 5], 7) 7 >>> knapsack([1, 3, 4, 5], 6) 6 >>> knapsack([1, 3, 4, 5], 10) 10","solution":"def knapsack(weights, maxCapacity): n = len(weights) # DP array to store the maximum weight that can be achieved without exceeding the capacity i dp = [0] * (maxCapacity + 1) # Iterate through each weight for weight in weights: # Update the dp array from back to front to avoid overwriting for capacity in range(maxCapacity, weight - 1, -1): dp[capacity] = max(dp[capacity], dp[capacity - weight] + weight) return dp[maxCapacity]"},{"question":"def longest_repeated_subsequence_length(s1: str, s2: str) -> int: Find the length of the longest repeated subsequence between two strings. Parameters: s1 (str): The first string. s2 (str): The second string. Returns: int: The length of the longest repeated subsequence. Examples: >>> longest_repeated_subsequence_length(\\"aabb\\", \\"aabb\\") 2 >>> longest_repeated_subsequence_length(\\"abc\\", \\"abc\\") 0 >>> longest_repeated_subsequence_length(\\"aab\\", \\"aab\\") 1 >>> longest_repeated_subsequence_length(\\"axxxy\\", \\"axxxy\\") 2 >>> longest_repeated_subsequence_length(\\"aabebcdd\\", \\"aabebcdd\\") 3 >>> longest_repeated_subsequence_length(\\"\\", \\"\\") 0 >>> longest_repeated_subsequence_length(\\"abcd\\", \\"abcd\\") 0","solution":"def longest_repeated_subsequence_length(s1, s2): Find the length of the longest repeated subsequence between two strings. Parameters: s1 (str): The first string. s2 (str): The second string. Returns: int: The length of the longest repeated subsequence. n, m = len(s1), len(s2) # Create and initialize the DP array dp = [[0] * (m + 1) for _ in range(n + 1)] # Fill dp array for i in range(1, n + 1): for j in range(1, m + 1): if s1[i - 1] == s2[j - 1] and i != j: dp[i][j] = 1 + dp[i - 1][j - 1] else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[n][m]"},{"question":"def minMeetingRooms(meetingTimeRanges: List[List[int]]) -> int: Returns the minimum number of meeting rooms required to accommodate all the meetings. >>> minMeetingRooms([]) == 0 >>> minMeetingRooms([[1, 2]]) == 1 >>> minMeetingRooms([[1, 2], [3, 4]]) == 1 >>> minMeetingRooms([[1, 4], [2, 5], [3, 6]]) == 3 >>> minMeetingRooms([[1, 4], [2, 5], [5, 6]]) == 2 >>> minMeetingRooms([[1, 4], [2, 3], [3, 6], [5, 7], [8, 9]]) == 2","solution":"def minMeetingRooms(meetingTimeRanges): Returns the minimum number of meeting rooms required to accommodate all the meetings. if not meetingTimeRanges: return 0 starts = sorted([i[0] for i in meetingTimeRanges]) ends = sorted([i[1] for i in meetingTimeRanges]) start_pointer, end_pointer = 0, 0 used_rooms = 0 max_rooms = 0 while start_pointer < len(meetingTimeRanges): if starts[start_pointer] < ends[end_pointer]: used_rooms += 1 start_pointer += 1 else: used_rooms -= 1 end_pointer += 1 max_rooms = max(max_rooms, used_rooms) return max_rooms"},{"question":"from typing import List def maximize_worker2_points(heights: List[int], k: int) -> int: Returns the maximum points that worker 2 can collect. :param heights: List[int]: List of building heights. :param k: int: Maximum height difference worker 2 can jump. :return: int: Maximum points worker 2 can collect. # Unit tests def test_case_1(): heights = [1, 2, 3, 4, 5] k = 2 assert maximize_worker2_points(heights, k) == 0 def test_case_2(): heights = [10, 15, 20, 10, 5] k = 5 assert maximize_worker2_points(heights, k) == 0 def test_case_3(): heights = [5, 5, 5, 5] k = 0 assert maximize_worker2_points(heights, k) == 0 def test_case_4(): heights = [3, 1, 4, 1, 5, 9, 2] k = 1 assert maximize_worker2_points(heights, k) == 0 def test_case_5(): heights = [0, 0, 0, 0] k = 10 assert maximize_worker2_points(heights, k) == 0","solution":"def maximize_worker2_points(heights, k): Returns the maximum points that worker 2 can collect. :param heights: List[int]: List of building heights. :param k: int: Maximum height difference worker 2 can jump. :return: int: Maximum points worker 2 can collect. if not heights: return 0 n = len(heights) # Worker 1 will move from start to end, modifying heights array for i in range(n): heights[i] = 0 # Worker 2 will try to maximize points starting from each building def worker2_collects_points(start_idx): max_points = 0 points = 0 for i in range(start_idx, n): points += heights[i] max_points = max(max_points, points) for j in range(i + 1, n): if abs(heights[i] - heights[j]) <= k: max_points = max(max_points, points + worker2_collects_points(j)) return max_points return worker2_collects_points(0)"},{"question":"def reverseKGroup(arr: List[int], k: int) -> List[int]: Reverse the given list in groups of k elements. If there are fewer than k elements remaining, they are left as they are. >>> reverseKGroup([1, 2, 3, 4, 5], 2) [2, 1, 4, 3, 5] >>> reverseKGroup([1, 2, 3, 4, 5, 6, 7], 3) [3, 2, 1, 6, 5, 4, 7] >>> reverseKGroup([1, 2, 3, 4, 5], 3) [3, 2, 1, 4, 5] >>> reverseKGroup([1], 2) [1] >>> reverseKGroup([1], 1) [1] >>> reverseKGroup([1, 2, 3, 4], 4) [4, 3, 2, 1] >>> reverseKGroup([1, 2, 3], 5) [1, 2, 3] >>> reverseKGroup([], 3) []","solution":"def reverseKGroup(arr, k): Reverses the given list in groups of k elements. If there are fewer than k elements remaining, they are left as they are. if k <= 1 or not arr: return arr result = [] length = len(arr) for i in range(0, length, k): if i + k <= length: result.extend(arr[i:i+k][::-1]) else: result.extend(arr[i:]) return result"},{"question":"def longest_heatwave(temps: List[int]) -> int: Finds the length of the longest heatwave in the given list of temperatures. A heatwave is a period of at least three consecutive days where the temperature on each day is higher than the previous day. Parameters: temps (list of int): List of daily temperatures. Returns: int: Length of the longest heatwave. Returns 0 if no heatwave is present. >>> longest_heatwave([30, 31, 32, 33, 34]) 5 >>> longest_heatwave([30, 31, 30, 32, 33, 31, 32, 33, 34]) 4 >>> longest_heatwave([30, 30, 30, 30, 30]) 0 >>> longest_heatwave([30, 31, 32]) 3 >>> longest_heatwave([30, 31]) 0 >>> longest_heatwave([30]) 0","solution":"def longest_heatwave(temps): Finds the length of the longest heatwave in the given list of temperatures. A heatwave is a period of at least three consecutive days where the temperature on each day is higher than the previous day. Parameters: temps (list of int): List of daily temperatures. Returns: int: Length of the longest heatwave. Returns 0 if no heatwave is present. n = len(temps) if n < 3: return 0 max_length = 0 current_length = 1 for i in range(1, n): if temps[i] > temps[i - 1]: current_length += 1 if current_length >= 3: max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"def rearrange_array(arr, x): Rearranges the elements of arr such that all elements less than x come before elements greater than or equal to x, while preserving the relative order of the elements in each partition. >>> rearrange_array([1, 2, 3], 5) == [1, 2, 3] >>> rearrange_array([5, 6, 7], 5) == [5, 6, 7] >>> rearrange_array([4, 2, 1, 5, 3, 6], 4) == [2, 1, 3, 4, 5, 6] >>> rearrange_array([7, 2, 5, 1, 8], 4) == [2, 1, 7, 5, 8] >>> rearrange_array([], 3) == [] >>> rearrange_array([2], 3) == [2] >>> rearrange_array([3], 3) == [3] >>> rearrange_array([4], 3) == [4]","solution":"def rearrange_array(arr, x): Rearranges the elements of arr such that all elements less than x come before elements greater than or equal to x, while preserving the relative order of the elements in each partition. less_than_x = [el for el in arr if el < x] greater_or_equal_x = [el for el in arr if el >= x] return less_than_x + greater_or_equal_x"},{"question":"def reconstruct_array(nums: List[int]) -> List[int]: Reconstruct the original array based on the given subarray sums. Args: nums (List[int]): A list representing the maximum subarray sum for any subarray that starts at index 0 and ends at each index \`i\`. Returns: List[int]: The reconstructed original array. >>> reconstruct_array([2, 5, 6, 10]) [2, 3, 1, 4] >>> reconstruct_array([5]) [5] >>> reconstruct_array([3, 8]) [3, 5] >>> reconstruct_array([1, 4, 9, 16]) [1, 3, 5, 7] >>> reconstruct_array([0, 0, 0, 0]) [0, 0, 0, 0]","solution":"def reconstruct_array(nums): Reconstruct the original array based on the given subarray sums. Args: nums (List[int]): A list representing the maximum subarray sum for any subarray that starts at index 0 and ends at each index \`i\`. Returns: List[int]: The reconstructed original array. arr = [nums[0]] for i in range(1, len(nums)): arr.append(nums[i] - nums[i - 1]) return arr"},{"question":"def server_active_time(logs): Calculate the total active time for each server from the logs. Args: logs (list of tuples): A list of logs where each log is a tuple (serverId, timestamp, action). Returns: list of tuples: A list of tuples where each tuple contains (serverId, totalActiveTime) sorted by serverId. >>> server_active_time([(1, 1, 'start'), (1, 4, 'end')]) == [(1, 3)] >>> server_active_time([(1, 1, 'start'), (1, 4, 'end'), (1, 5, 'start'), (1, 10, 'end')]) == [(1, 8)] >>> server_active_time([(1, 1, 'start'), (1, 4, 'end'), (2, 2, 'start'), (2, 6, 'end')]) == [(1, 3), (2, 4)] >>> server_active_time([(1, 1, 'start'), (2, 2, 'start'), (1, 4, 'end'), (2, 6, 'end')]) == [(1, 3), (2, 4)] >>> server_active_time([]) == [] >>> server_active_time([(1, 1, 'start'), (1, 4, 'end'), (1, 3, 'start'), (1, 8, 'end')]) == [(1, 8)]","solution":"from collections import defaultdict def server_active_time(logs): Calculate the total active time for each server from the logs. Args: logs (list of tuples): A list of logs where each log is a tuple (serverId, timestamp, action). Returns: list of tuples: A list of tuples where each tuple contains (serverId, totalActiveTime) sorted by serverId. active_times = defaultdict(int) # Dictionary to hold total active time for each server start_times = {} # Dictionary to hold the most recent start time for each server for serverId, timestamp, action in logs: if action == 'start': start_times[serverId] = timestamp elif action == 'end' and serverId in start_times: active_times[serverId] += (timestamp - start_times[serverId]) del start_times[serverId] result = sorted(active_times.items()) return result"},{"question":"class StringModifier: def __init__(self, s: str): Initializes a StringModifier object with the string s. >>> sm = StringModifier(\\"hello\\") >>> sm.distinct_count() # 4 (h, e, l, o) pass def insert(self, i: int, c: str): Inserts the character c at the position i in the string. >>> sm = StringModifier(\\"hello\\") >>> sm.insert(2, 'a') >>> sm.distinct_count() # 5 (h, e, l, o, a) pass def delete(self, i: int): Deletes the character at the position i in the string. >>> sm = StringModifier(\\"hello\\") >>> sm.delete(1) >>> sm.distinct_count() # 3 (h, l, o) pass def distinct_count(self) -> int: Returns the number of distinct characters currently present in the string. >>> sm = StringModifier(\\"hello\\") >>> sm.distinct_count() # 4 (h, e, l, o) pass def test_initial_distinct_count(): sm = StringModifier(\\"hello\\") assert sm.distinct_count() == 4 def test_insert_operation(): sm = StringModifier(\\"hello\\") sm.insert(2, 'a') assert sm.distinct_count() == 5 # distinct characters are h, e, l, o, a def test_delete_operation(): sm = StringModifier(\\"hello\\") sm.delete(4) # removes 'o' assert sm.distinct_count() == 3 # distinct characters are h, e, l def test_insert_and_delete_operations(): sm = StringModifier(\\"hello\\") sm.insert(1, 'e') assert sm.distinct_count() == 4 # distinct characters are h, e, l, o sm.delete(1) # removes 'e' (inserted one) assert sm.distinct_count() == 4 # distinct characters are h, e, l, o (unchanged) def test_insert_new_distinct_character(): sm = StringModifier(\\"hello\\") sm.insert(1, 'z') assert sm.distinct_count() == 5 # distinct characters are h, e, l, o, z def test_delete_leading_character(): sm = StringModifier(\\"hello\\") sm.delete(0) # removes 'h' assert sm.distinct_count() == 3 # distinct characters are e, l, o","solution":"class StringModifier: def __init__(self, s: str): self.string = list(s) self.char_set = set(s) def insert(self, i: int, c: str): self.string.insert(i, c) self.char_set = set(self.string) def delete(self, i: int): del self.string[i] self.char_set = set(self.string) def distinct_count(self) -> int: return len(self.char_set)"},{"question":"from typing import List def count_occurrences(arr: List[int], x: int) -> int: Returns the number of occurrences of x in the sorted array arr. If x is not present in the array, returns 0. The solution runs in O(log n) time. >>> count_occurrences([1, 2, 3, 3, 3, 4, 5], 3) 3 >>> count_occurrences([1, 2, 3, 3, 3, 4, 5], 6) 0 >>> count_occurrences([1, 1, 1, 1, 1], 1) 5 >>> count_occurrences([], 1) 0 >>> count_occurrences([1, 2, 2, 2, 3, 4, 5], 2) 3 >>> count_occurrences([1, 2, 3, 4, 5], 5) 1 >>> count_occurrences([1, 2, 3, 4, 5], 1) 1 >>> count_occurrences([1, 2, 3, 4, 5], 0) 0 >>> count_occurrences([1, 3, 5, 7, 9], 2) 0 >>> count_occurrences([1, 3, 5, 7, 9], 9) 1 >>> count_occurrences([1, 3, 5, 7, 9], 1) 1 >>> count_occurrences([3, 3, 3, 3, 3], 3) 5 >>> count_occurrences([3, 3, 3, 3, 3], 4) 0 # Your code here","solution":"from bisect import bisect_left, bisect_right def count_occurrences(arr, x): Returns the number of occurrences of x in the sorted array arr. If x is not present in the array, returns 0. The solution runs in O(log n) time. left_index = bisect_left(arr, x) right_index = bisect_right(arr, x) return right_index - left_index"},{"question":"def max_jumps(arr, d): Given an integer array arr and a positive integer d, return the maximum number of indices you can visit starting from any index. A jump from index i to index j is allowed if: - j - i <= d, and arr[i] > arr[j] (for jumps to the right) - i - j <= d, and arr[i] > arr[j] (for jumps to the left) Args: arr (List[int]): The array of integers. d (int): The maximum allowed jump distance. Returns: int: The maximum number of indices that can be visited starting from any index. >>> max_jumps([6, 4, 14, 6, 8, 13, 9, 7, 10, 6, 12], 2) 4 >>> max_jumps([3, 3, 3, 3, 3], 3) 1 >>> max_jumps([7, 6, 5, 4, 3, 2, 1], 1) 7 >>> max_jumps([7, 1, 7, 1, 7, 1], 2) 2 >>> max_jumps([66], 1) 1","solution":"def max_jumps(arr, d): def dfs(i): if dp[i] != -1: return dp[i] res = 1 for j in range(i+1, min(i+d+1, n)): if arr[i] > arr[j]: res = max(res, 1 + dfs(j)) else: break for j in range(i-1, max(i-d-1, -1), -1): if arr[i] > arr[j]: res = max(res, 1 + dfs(j)) else: break dp[i] = res return res n = len(arr) dp = [-1] * n max_visits = 1 for i in range(n): max_visits = max(max_visits, dfs(i)) return max_visits"},{"question":"from typing import List from collections import Counter def can_form_palindrome_with_k_length(s: str, k: int) -> bool: Determines if the characters of string s can be rearranged to form a palindromic subsequence of length at least k. Parameters: s (str): The input string consisting of lowercase English letters. k (int): The required length of the longest palindromic subsequence. Returns: bool: True if it is possible to rearrange to form such a subsequence, False otherwise. pass def test_can_form_palindrome_with_k_length(): assert can_form_palindrome_with_k_length(\\"abccba\\", 6) == True assert can_form_palindrome_with_k_length(\\"aabbcc\\", 4) == True assert can_form_palindrome_with_k_length(\\"aaabbb\\", 5) == True assert can_form_palindrome_with_k_length(\\"abcdef\\", 3) == False assert can_form_palindrome_with_k_length(\\"a\\", 1) == True assert can_form_palindrome_with_k_length(\\"aaaaaaa\\", 7) == True assert can_form_palindrome_with_k_length(\\"abcdefghijk\\", 7) == False","solution":"from collections import Counter def can_form_palindrome_with_k_length(s, k): Determines if the characters of string s can be rearranged to form a palindromic subsequence of length at least k. Parameters: s (str): The input string consisting of lowercase English letters. k (int): The required length of the longest palindromic subsequence. Returns: bool: True if it is possible to rearrange to form such a subsequence, False otherwise. char_count = Counter(s) odd_count = sum(count % 2 for count in char_count.values()) # Length of the longest palindromic subsequence is the total length minus the number of odd occurrences + 1 if any odd exists max_palindrome_length = len(s) - odd_count + (1 if odd_count > 0 else 0) return max_palindrome_length >= k"},{"question":"from typing import List def three_sum(arr: List[int]) -> List[List[int]]: Returns a list of all unique triplets in the array that sum up to zero. Each triplet must be sorted in ascending order, and the list should not contain duplicate triplets. >>> three_sum([-1, 0, 1, 2, -1, -4]) == [[-1, -1, 2], [-1, 0, 1]] >>> three_sum([1, 2, 3, 4, 5]) == [] >>> three_sum([0, 0, 0, 0]) == [[0, 0, 0]] >>> three_sum([-2, -1, 1, 2, 0]) == [[-2, 0, 2], [-1, 0, 1]] >>> three_sum([3, -2, 1, -1, 2, -1, -1, 0]) == [[-2, -1, 3], [-2, 0, 2], [-1, -1, 2], [-1, 0, 1]]","solution":"def three_sum(arr): Returns a list of all unique triplets in the array that sum up to zero. Each triplet must be sorted in ascending order, and the list should not contain duplicate triplets. arr.sort() n = len(arr) triplets = [] for i in range(n-2): if i > 0 and arr[i] == arr[i-1]: continue left, right = i + 1, n - 1 while left < right: total = arr[i] + arr[left] + arr[right] if total == 0: triplet = [arr[i], arr[left], arr[right]] triplets.append(triplet) while left < right and arr[left] == triplet[1]: left += 1 while left < right and arr[right] == triplet[2]: right -= 1 elif total < 0: left += 1 else: right -= 1 return triplets"},{"question":"def find_combinations(arr, target_sum): Finds all unique combinations in arr where the sum of the numbers equals target_sum. Each number in arr can only be used once in the combination. :param arr: List of integers :param target_sum: Target sum for the combinations :return: List of unique combinations where the sum equals target_sum >>> find_combinations([10, 1, 2, 7, 6, 1, 5], 8) [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]] >>> find_combinations([2, 4, 6, 8], 3) [] >>> find_combinations([5], 5) [[5]] >>> find_combinations([5], 10) [] >>> find_combinations([2, 3, 6, 7], 7) [[7]] >>> find_combinations([1, 1, 1, 2, 2], 3) [[1, 1, 1], [1, 2]] >>> find_combinations([], 0) [[]] >>> find_combinations([], 5) []","solution":"def find_combinations(arr, target_sum): Finds all unique combinations in arr where the sum of the numbers equals target_sum. Each number in arr can only be used once in the combination. :param arr: List of integers :param target_sum: Target sum for the combinations :return: List of unique combinations where the sum equals target_sum arr.sort() results = [] def backtrack(start, path, remaining_sum): if remaining_sum == 0: results.append(path[:]) return for i in range(start, len(arr)): if i > start and arr[i] == arr[i - 1]: continue # skip duplicates if arr[i] > remaining_sum: break # no need to continue if the number is greater than the remaining sum path.append(arr[i]) backtrack(i + 1, path, remaining_sum - arr[i]) path.pop() backtrack(0, [], target_sum) return results"},{"question":"def min_difference_candies(candies: List[int]) -> int: You are given a list of non-negative integers 'candies' where each integer represents the number of candies in a pile. In one move, you can choose any pile and remove one candy from it. After making the move, if the pile becomes empty, you must remove the pile from the list. You want to divide the candies into two groups such that the difference in total number of candies between the two groups is minimized. Return the minimum possible difference between the sums of the two groups after dividing the candies. >>> min_difference_candies([7]) 7 >>> min_difference_candies([10, 5]) 5 >>> min_difference_candies([1, 2, 3]) 0 >>> min_difference_candies([2, 3, 5, 7]) 1 >>> min_difference_candies([1, 1, 1, 1, 1, 1]) 0","solution":"def min_difference_candies(candies): Returns the minimum possible difference between the sums of two groups after dividing the candies. total_candies = sum(candies) target = total_candies // 2 dp = [0] * (target + 1) for candy in candies: for j in range(target, candy - 1, -1): dp[j] = max(dp[j], dp[j - candy] + candy) group1 = dp[target] group2 = total_candies - group1 return abs(group1 - group2)"},{"question":"from typing import Optional class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def levelOrder(root: Optional[TreeNode]) -> str: Given a binary tree, perform a level-order traversal. Each level of the tree should be printed on a new line. Examples: >>> root = TreeNode(3) >>> root.left = TreeNode(9) >>> root.right = TreeNode(20) >>> root.right.left = TreeNode(15) >>> root.right.right = TreeNode(7) >>> levelOrder(root) '3n9 20n15 7' >>> root = TreeNode(1) >>> levelOrder(root) '1'","solution":"from collections import deque class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def levelOrder(root): if not root: return \\"\\" queue = deque([root]) result = [] while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.popleft() if node: current_level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) if current_level: result.append(\\" \\".join(map(str, current_level))) return \\"n\\".join(result)"},{"question":"def find_duplicates_and_missing(nums: List[int]) -> List[int]: Finds the two numbers that are missing and the two numbers that appear twice in the given array nums which has elements in the range [1, n] and length n. Args: nums: List[int] - an array of integers with two duplicates and two missing numbers Returns: List[int] - a list of four integers [dup1, dup2, missing1, missing2] >>> find_duplicates_and_missing([1, 2, 3, 4, 4, 6, 2, 8]) == [2, 4, 5, 7] >>> find_duplicates_and_missing([1, 3, 3, 4, 5, 6, 6, 8]) == [3, 6, 2, 7] >>> find_duplicates_and_missing([1, 2, 2, 4, 5, 5, 7, 8]) == [2, 5, 3, 6] >>> find_duplicates_and_missing([1, 1, 3, 4, 4, 6, 7, 8]) == [1, 4, 2, 5]","solution":"def find_duplicates_and_missing(nums): Finds the two numbers that are missing and the two numbers that appear twice in the given array nums which has elements in the range [1, n] and length n. Args: nums: List[int] - an array of integers with two duplicates and two missing numbers Returns: List[int] - a list of four integers [dup1, dup2, missing1, missing2] n = len(nums) num_count = [0] * (n + 1) for num in nums: num_count[num] += 1 duplicates = [] missing = [] for i in range(1, n + 1): if num_count[i] == 0: missing.append(i) elif num_count[i] == 2: duplicates.append(i) return duplicates + missing"},{"question":"def count_divisible_triplets(arr, n, d): Find the number of triplets (i, j, k) such that 0 <= i < j < k < n and arr[i] + arr[j] + arr[k] is divisible by d. Return the count of such triplets modulo 10^9 + 7. >>> count_divisible_triplets([1, 2, 3, 4, 5], 5, 3) 4 >>> count_divisible_triplets([1, 1, 1], 3, 5) 0 >>> count_divisible_triplets([2, 2, 2, 2, 2], 5, 3) 10 >>> count_divisible_triplets([1] * 100, 100, 3) 161700 >>> count_divisible_triplets([1, 2, 3, 4, 5, 6], 6, 100) 0","solution":"def count_divisible_triplets(arr, n, d): MOD = 10**9 + 7 count = 0 for i in range(n-2): for j in range(i+1, n-1): for k in range(j+1, n): if (arr[i] + arr[j] + arr[k]) % d == 0: count = (count + 1) % MOD return count"},{"question":"def trapRainWater(height: List[int]) -> int: Calculate the total amount of rainwater trapped between buildings of different heights. Args: height (List[int]): a list of non-negative integers representing the height of buildings. Returns: int: total amount of trapped rainwater. Examples: >>> trapRainWater([4, 2, 0, 3, 2, 5]) 9 >>> trapRainWater([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trapRainWater([]) 0 >>> trapRainWater([3, 3, 3, 3]) 0 >>> trapRainWater([3, 0, 3]) 3","solution":"def trapRainWater(height): Calculate the total amount of rainwater trapped between buildings of different heights. Args: height (List[int]): a list of non-negative integers representing the height of buildings. Returns: int: total amount of trapped rainwater. if not height: return 0 n = len(height) left_max = [0] * n # Array to store the maximum height to the left of the current position right_max = [0] * n # Array to store the maximum height to the right of the current position # Fill the left_max array left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) # Fill the right_max array right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) # Calculate the total trapped rainwater total_water = 0 for i in range(n): total_water += min(left_max[i], right_max[i]) - height[i] return total_water"},{"question":"def modifyArrayNoAdjacentSame(arr): Modify the array such that no two adjacent elements have the same value. :param arr: List[int] - The input array :return: List[int] - Modified array or empty array if not possible >>> modifyArrayNoAdjacentSame([]) == [] >>> modifyArrayNoAdjacentSame([1]) == [1] >>> modifyArrayNoAdjacentSame([1, 2, 1, 2]) == [1, 2, 1, 2] >>> modifyArrayNoAdjacentSame([1, 1, 2, 2]) in [[1, 2, 1, 2], [2, 1, 2, 1]] >>> modifyArrayNoAdjacentSame([1, 1, 1, 2]) == [] >>> all(modifyArrayNoAdjacentSame([1]*3 + [2]*3 + [3]*3)[i] != modifyArrayNoAdjacentSame([1]*3 + [2]*3 + [3]*3)[i-1] for i in range(1, 9)) >>> result = modifyArrayNoAdjacentSame([1,2,3,4,4,4]) >>> result == [] or all(result[i] != result[i+1] for i in range(len(result)-1))","solution":"def modifyArrayNoAdjacentSame(arr): Modify the array such that no two adjacent elements have the same value. :param arr: List[int] - The input array :return: List[int] - Modified array or empty array if not possible from collections import Counter import heapq if not arr: return [] count = Counter(arr) max_count = max(count.values()) half = (len(arr) + 1) // 2 if max_count > half: return [] max_heap = [(-value, key) for key, value in count.items()] heapq.heapify(max_heap) prev_value, prev_key = 0, '' result = [] while max_heap: value, key = heapq.heappop(max_heap) result.append(key) if prev_value < 0: heapq.heappush(max_heap, (prev_value, prev_key)) prev_value = value + 1 prev_key = key return result"},{"question":"from collections import deque def shortest_path_length(n, edges, k): Determine if there exist two distinct nodes in the graph such that the shortest path between them is exactly k edges. >>> shortest_path_length(4, [[0, 1], [1, 2], [1, 3]], 2) True >>> shortest_path_length(6, [[0, 1], [0, 2], [0, 3], [0, 4], [0, 5]], 1) True >>> shortest_path_length(4, [[0, 1], [1, 2], [1, 3]], 3) False >>> shortest_path_length(4, [[0, 1], [1, 2], [2, 3]], 4) False >>> shortest_path_length(1, [], 1) False >>> shortest_path_length(4, [[0, 1], [2, 3]], 2) False >>> shortest_path_length(4, [[0, 1], [1, 2], [2, 3], [3, 0]], 2) True","solution":"from collections import deque def shortest_path_length(n, edges, k): # Create adjacency list graph = {i: [] for i in range(n)} for u, v in edges: graph[u].append(v) graph[v].append(u) # BFS helper function to find shortest path lengths from a starting node def bfs(start): distances = [-1] * n distances[start] = 0 queue = deque([start]) while queue: node = queue.popleft() distance = distances[node] for neighbor in graph[node]: if distances[neighbor] == -1: # not visited distances[neighbor] = distance + 1 queue.append(neighbor) return distances # Check all pairs of nodes for i in range(n): distances = bfs(i) if k in distances: return True return False"},{"question":"def get_island_coordinates(grid): Given a 2D grid representing a binary matrix where 0 represents water and 1 represents land, find a list of coordinates (row, col) of all the 1s in the island before it is flipped. An island is a group of connected 1s (horizontal or vertical) surrounded by water. The grid is completely surrounded by water, and there is exactly one island in the grid. >>> get_island_coordinates([ ... [0, 0, 0, 0], ... [0, 1, 1, 0], ... [0, 1, 0, 0], ... [0, 0, 0, 0] ... ]) == [(1, 1), (1, 2), (2, 1)] >>> get_island_coordinates([ ... [0, 0, 0, 0, 0], ... [0, 1, 1, 1, 0], ... [0, 1, 1, 1, 0], ... [0, 0, 0, 0, 0] ... ]) == [(1, 1), (1, 2), (1, 3), (2, 1), (2, 2), (2, 3)] >>> get_island_coordinates([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) == [(1, 1)] >>> get_island_coordinates([ ... [0, 0, 0, 0], ... [0, 1, 0, 1], ... [0, 0, 0, 0], ... [0, 1, 0, 0] ... ]) == [(1, 1)] >>> get_island_coordinates([ ... [1, 1], ... [1, 1] ... ]) == [(0, 0), (0, 1), (1, 0), (1, 1)]","solution":"def get_island_coordinates(grid): Returns the list of coordinates of all '1's in the island. def dfs(r, c): if r < 0 or r >= len(grid) or c < 0 or c >= len(grid[0]) or grid[r][c] == 0: return grid[r][c] = 0 # Mark as visited coordinates.append((r, c)) dfs(r + 1, c) dfs(r - 1, c) dfs(r, c + 1) dfs(r, c - 1) coordinates = [] found_island = False for i in range(len(grid)): if found_island: break for j in range(len(grid[0])): if grid[i][j] == 1: dfs(i, j) found_island = True break return coordinates"},{"question":"def max_files_loaded(arr, maxFiles, maxSize): Returns the maximum number of files that can be loaded into the system without exceeding the maximum file count or the maximum size capacity. :param arr: List of integers representing the sizes of each file. :param maxFiles: Integer representing the maximum number of files that can be loaded. :param maxSize: Integer representing the maximum size capacity of the system. :return: Integer representing the maximum number of files that can be loaded. pass # Your implementation here def test_max_files_loaded_all_files_fit(): arr = [1, 2, 3] maxFiles = 5 maxSize = 10 assert max_files_loaded(arr, maxFiles, maxSize) == 3 def test_max_files_loaded_limited_by_max_files(): arr = [1, 2, 3, 4, 5] maxFiles = 3 maxSize = 15 assert max_files_loaded(arr, maxFiles, maxSize) == 3 def test_max_files_loaded_limited_by_max_size(): arr = [3, 1, 4, 2, 2] maxFiles = 10 maxSize = 7 assert max_files_loaded(arr, maxFiles, maxSize) == 3 def test_max_files_loaded_no_files(): arr = [] maxFiles = 5 maxSize = 10 assert max_files_loaded(arr, maxFiles, maxSize) == 0 def test_max_files_loaded_zero_maxFiles(): arr = [1, 2, 3, 4, 5] maxFiles = 0 maxSize = 10 assert max_files_loaded(arr, maxFiles, maxSize) == 0 def test_max_files_loaded_zero_maxSize(): arr = [1, 2, 3, 4, 5] maxFiles = 5 maxSize = 0 assert max_files_loaded(arr, maxFiles, maxSize) == 0 def test_max_files_loaded_exactly_max_files_and_size(): arr = [1, 2, 3, 4] maxFiles = 4 maxSize = 10 assert max_files_loaded(arr, maxFiles, maxSize) == 4","solution":"def max_files_loaded(arr, maxFiles, maxSize): Returns the maximum number of files that can be loaded into the system without exceeding the maximum file count or the maximum size capacity. :param arr: List of integers representing the sizes of each file. :param maxFiles: Integer representing the maximum number of files that can be loaded. :param maxSize: Integer representing the maximum size capacity of the system. :return: Integer representing the maximum number of files that can be loaded. arr.sort() file_count = 0 current_size = 0 for size in arr: if file_count < maxFiles and current_size + size <= maxSize: file_count += 1 current_size += size else: break return file_count"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseKGroup(head: ListNode, k: int) -> ListNode: Given a linked list, reverse the nodes of the list k at a time, where k is a positive integer and k is less than or equal to the length of the list. The function should return the modified list after reversing every k nodes. If the number of nodes is not a multiple of k, then the remaining nodes at the end should remain as is. >>> reverseKGroup(list_to_linked_list([1, 2, 3, 4, 5]), 2) [2, 1, 4, 3, 5] >>> reverseKGroup(list_to_linked_list([1, 2, 3, 4, 5]), 3) [3, 2, 1, 4, 5] >>> reverseKGroup(list_to_linked_list([1]), 1) [1] >>> reverseKGroup(list_to_linked_list([1, 2]), 2) [2, 1] >>> reverseKGroup(list_to_linked_list([1, 2, 3, 4, 5, 6]), 4) [4, 3, 2, 1, 5, 6]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseKGroup(head, k): def reverseLinkedList(head, k): prev, curr = None, head while k: next_node, curr.next = curr.next, prev prev, curr = curr, next_node k -= 1 return prev count, node = 0, head while node and count < k: node = node.next count += 1 if count == k: reversed_head = reverseLinkedList(head, k) head.next = reverseKGroup(node, k) return reversed_head return head"},{"question":"def delete_chars(document: str, to_delete: List[int]) -> str: Returns a string after removing characters at the specified positions in \`to_delete\`. Parameters: document (str): The original string from which characters are to be removed. to_delete (list of int): The indices of characters in \`document\` that need to be removed. Returns: str: The resulting string after deletion. >>> delete_chars(\\"abcdef\\", [0, 2, 4]) == \\"bdf\\" >>> delete_chars(\\"hello world\\", [5]) == \\"helloworld\\" >>> delete_chars(\\"hello world\\", [10]) == \\"hello worl\\" >>> delete_chars(\\"random string\\", []) == \\"random string\\" >>> delete_chars(\\"sample\\", [10, 11]) == \\"sample\\" >>> delete_chars(\\"abcdef\\", [0, 1, 2, 3, 4, 5]) == \\"\\" >>> delete_chars(\\"a\\", [0]) == \\"\\" >>> delete_chars(\\"a\\", []) == \\"a\\" >>> delete_chars(\\"test\\", [3]) == \\"tes\\" >>> delete_chars(\\"test\\", [0, 1, 2, 3]) == \\"\\" >>> large_str = \\"a\\" * 1000 >>> indices = list(range(1000)) >>> delete_chars(large_str, indices) == \\"\\"","solution":"def delete_chars(document, to_delete): Returns a string after removing characters at the specified positions in \`to_delete\`. Parameters: document (str): The original string from which characters are to be removed. to_delete (list of int): The indices of characters in \`document\` that need to be removed. Returns: str: The resulting string after deletion. # Convert document to a list because string is immutable document_list = list(document) # Iterate over the indices in reverse order to keep indices consistent for index in reversed(to_delete): if 0 <= index < len(document_list): del document_list[index] # Join the list back into a string return ''.join(document_list)"},{"question":"def trap_rain_water(heights): Computes the total amount of rainwater that can be trapped given the heights of the buildings. :param heights: List[int] - An array where each element represents the height of a building. :return: int - The total amount of trapped rainwater. >>> trap_rain_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap_rain_water([]) 0 >>> trap_rain_water([3, 3, 3, 3, 3]) 0 >>> trap_rain_water([1, 2, 3, 4, 5]) 0 >>> trap_rain_water([5, 4, 3, 2, 1]) 0 >>> trap_rain_water([3, 0, 2]) 2 >>> trap_rain_water([4, 2, 0, 3, 2, 5]) 9 pass","solution":"def trap_rain_water(heights): Computes the total amount of rainwater that can be trapped given the heights of the buildings. :param heights: List[int] - An array where each element represents the height of a building. :return: int - The total amount of trapped rainwater. if not heights: return 0 left = 0 right = len(heights) - 1 left_max = heights[left] right_max = heights[right] trapped_water = 0 while left < right: if left_max < right_max: left += 1 left_max = max(left_max, heights[left]) trapped_water += left_max - heights[left] else: right -= 1 right_max = max(right_max, heights[right]) trapped_water += right_max - heights[right] return trapped_water"},{"question":"def count_passwords(n: int, k: int) -> int: Returns the total number of distinct passwords of length \`n\` that can be formed using \`k\` distinct digits with no two adjacent digits being the same. >>> count_passwords(1, 10) 10 >>> count_passwords(1, 5) 5 >>> count_passwords(2, 10) 90 >>> count_passwords(2, 5) 20 >>> count_passwords(3, 10) 810 >>> count_passwords(3, 5) 80 >>> count_passwords(4, 10) 7290 >>> count_passwords(4, 5) 320 >>> count_passwords(10, 2) 2 >>> count_passwords(5, 10) 65610 pass","solution":"def count_passwords(n, k): Returns the total number of distinct passwords of length \`n\` that can be formed using \`k\` distinct digits with no two adjacent digits being the same. if n == 1: return k dp = [0] * n dp[0] = k dp[1] = k * (k - 1) for i in range(2, n): dp[i] = (k - 1) * dp[i - 1] return dp[-1]"},{"question":"def trap_rainwater(height: List[int]) -> int: Calculate the total amount of rainwater trapped among bars in a histogram. >>> trap_rainwater([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trap_rainwater([0,1,2,3,4,5]) 0 >>> trap_rainwater([2,2,2,2]) 0 >>> trap_rainwater([3,0,2,0,4]) 7 >>> trap_rainwater([7]) 0 >>> trap_rainwater([]) 0","solution":"def trap_rainwater(height): Calculate the total amount of rainwater trapped. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n water_trapped = 0 # Fill left_max array left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i-1], height[i]) # Fill right_max array right_max[n-1] = height[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], height[i]) # Calculate the accumulated water for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def widthOfBinaryTree(root: TreeNode) -> int: Given a binary tree, return the maximum width of the binary tree. The maximum width of a tree is the maximum width among all levels. The width of one level is defined as the length between the end-nodes (the leftmost and rightmost non-null nodes), where the null nodes between the end-nodes are also counted into the length calculation. >>> root = TreeNode(1) >>> root.left = TreeNode(3) >>> root.right = TreeNode(2) >>> widthOfBinaryTree(root) 2 >>> root = TreeNode(1) >>> root.left = TreeNode(3, TreeNode(5, TreeNode(6))) >>> root.right = TreeNode(2, None, TreeNode(9, None, TreeNode(7))) >>> widthOfBinaryTree(root) 8","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def widthOfBinaryTree(root): if not root: return 0 maxWidth = 0 queue = deque([(root, 0)]) while queue: level_length = len(queue) _, first_index = queue[0] for i in range(level_length): node, index = queue.popleft() if node.left: queue.append((node.left, 2 * index)) if node.right: queue.append((node.right, 2 * index + 1)) _, last_index = queue[-1] if queue else (None, 0) maxWidth = max(maxWidth, last_index - first_index + 1) return maxWidth"},{"question":"def can_make_equal(s: str, t: str) -> bool: Determines if string s can be made equal to string t by swapping any two characters within s. Parameters: s (str): The initial string. t (str): The target string. Returns: bool: True if s can be made equal to t, False otherwise. >>> can_make_equal(\\"abc\\", \\"abc\\") True >>> can_make_equal(\\"listen\\", \\"silent\\") True >>> can_make_equal(\\"abc\\", \\"abcd\\") False >>> can_make_equal(\\"abc\\", \\"def\\") False >>> can_make_equal(\\"aabbcc\\", \\"bbaacc\\") True >>> can_make_equal(\\"\\", \\"\\") True >>> can_make_equal(\\"a\\", \\"b\\") False >>> can_make_equal(\\"a\\", \\"a\\") True","solution":"def can_make_equal(s, t): Determines if string s can be made equal to string t by swapping any two characters within s. Parameters: s (str): The initial string. t (str): The target string. Returns: bool: True if s can be made equal to t, False otherwise. # If lengths are different, they can't be made equal by any number of swaps if len(s) != len(t): return False # If both strings have the same character counts, they can be made equal return sorted(s) == sorted(t)"},{"question":"def smallestStringWithSwaps(s: str, n: int) -> str: Return the lexicographically smallest string that can be achieved by applying at most n swap operations. >>> smallestStringWithSwaps(\\"abc\\", 0) 'abc' >>> smallestStringWithSwaps(\\"cba\\", 1) 'abc' >>> smallestStringWithSwaps(\\"dcab\\", 2) 'abcd' >>> smallestStringWithSwaps(\\"dcab\\", 4) 'abcd' >>> smallestStringWithSwaps(\\"\\", 1) '' >>> smallestStringWithSwaps(\\"a\\", 1) 'a' >>> smallestStringWithSwaps(\\"aaaa\\", 2) 'aaaa'","solution":"from heapq import heappop, heappush def smallestStringWithSwaps(s, n): Return the lexicographically smallest string that can be achieved by applying at most n swap operations. :param s: Input string :param n: Maximum number of swap operations :return: Lexicographically smallest string possible with at most n swaps. if n == 0 or not s: return s # We use a min heap to get the smallest characters first min_heap = [] for char in s: heappush(min_heap, char) result = [] count = 0 for i in range(len(s)): smallest_char = heappop(min_heap) if s[i] != smallest_char and count < n: count += 1 result.append(smallest_char) return ''.join(result)"},{"question":"def count_lonely_people(nums: List[int], k: int) -> int: Returns the total number of lonely people in the array nums for the given value of k. >>> count_lonely_people([1, 0, 0, 1, 0, 0, 1], 2) 3 >>> count_lonely_people([1, 1, 1, 1, 1], 1) 0 >>> count_lonely_people([1, 0, 1, 0, 1, 0, 1], 1) 4 >>> count_lonely_people([1, 0, 0, 0, 1], 2) 2 >>> count_lonely_people([0, 0, 0, 0, 0], 2) 0 >>> count_lonely_people([1, 0, 1, 0, 0], 1) 2 >>> count_lonely_people([1], 1) 1","solution":"def count_lonely_people(nums, k): Returns the total number of lonely people in the array nums for the given value of k. total_lonely_people = 0 n = len(nums) i = 0 while i < n: if nums[i] == 1: left_bound = max(0, i - k) right_bound = min(n - 1, i + k) if (left_bound == i or nums[left_bound:i].count(1) == 0) and (right_bound == i or nums[i+1:right_bound+1].count(1) == 0): total_lonely_people += 1 i = right_bound + 1 else: i += 1 return total_lonely_people"},{"question":"def num_ways_to_form_target(words: List[str], target: str) -> int: Returns the number of distinct ways to form the target string using the given words. Args: words (List[str]): The list of strings to use to form the target. target (str): The target string to form. Returns: int: The number of distinct ways to form the target string modulo 10^9 + 7. >>> num_ways_to_form_target([\\"acca\\",\\"bbbb\\",\\"caca\\"], \\"aba\\") 6 >>> num_ways_to_form_target([\\"abba\\",\\"baab\\"], \\"bab\\") 4 >>> num_ways_to_form_target([\\"abcd\\"], \\"abcd\\") 1 >>> num_ways_to_form_target([\\"abcd\\"], \\"dcba\\") 0 >>> num_ways_to_form_target([\\"aabb\\",\\"baab\\"], \\"baab\\") 4 >>> num_ways_to_form_target([\\"aaabbb\\"], \\"ab\\") 9","solution":"def num_ways_to_form_target(words, target): Returns the number of distinct ways to form the target string using the given words. Args: words (List[str]): The list of strings to use to form the target. target (str): The target string to form. Returns: int: The number of distinct ways to form the target string modulo 10^9 + 7. MOD = 10**9 + 7 m = len(words[0]) n = len(target) # Precompute the frequency of each character at each position freq = [[0] * 26 for _ in range(m)] for word in words: for i, char in enumerate(word): freq[i][ord(char) - ord('a')] += 1 # Initialize dp array dp = [0] * (n + 1) dp[0] = 1 # Compute number of ways to form the target for j in range(1, m + 1): for i in range(n, 0, -1): if i <= j: dp[i] = (dp[i] + dp[i - 1] * freq[j - 1][ord(target[i - 1]) - ord('a')]) % MOD return dp[n]"},{"question":"def is_subsequence(text: str, word: str) -> bool: Helper function to check if a word is a subsequence of text. it = iter(text) return all(char in it for char in word) def subsequences_check(text: str, words: List[str]) -> List[bool]: For each word in words, determine if it is a subsequence of text. Args: text (str): The main text string. words (list of str): List of words to check. Returns: list of bool: List of booleans where each boolean indicates if the corresponding word is a subsequence of text.","solution":"def is_subsequence(text, word): Helper function to check if a word is a subsequence of text. it = iter(text) return all(char in it for char in word) def subsequences_check(text, words): For each word in words, determine if it is a subsequence of text. Args: text (str): The main text string. words (list of str): List of words to check. Returns: list of bool: List of booleans where each boolean indicates if the corresponding word is a subsequence of text. return [is_subsequence(text, word) for word in words]"},{"question":"def smallest_difference_subarray(nums: List[int], k: int) -> int: Returns the smallest difference between the highest and lowest of the k consecutive integers that you can find in the list nums. If it is not possible to find k consecutive integers in the list, return -1. >>> smallest_difference_subarray([3, 11, 22, 1, 5, 7, 10], 3) 4 >>> smallest_difference_subarray([3, 11, 22], 4) -1 >>> smallest_difference_subarray([3, 11, 22], 1) 0 >>> smallest_difference_subarray([3, 8, 6], 3) 5 >>> smallest_difference_subarray([3, 11, 22, 1, 5, 7, 10], 4) 6 >>> smallest_difference_subarray([1, 2, 3, 4, 5], 2) 1 >>> smallest_difference_subarray([5, 4, 3, 2, 1], 2) 1 >>> smallest_difference_subarray([5, 5, 5, 5], 2) 0","solution":"def smallest_difference_subarray(nums, k): Returns the smallest difference between the highest and lowest of the k consecutive integers that you can find in the list nums. If it is not possible to find k consecutive integers in the list, return -1. if len(nums) < k: return -1 nums_sorted = sorted(nums) min_diff = float('inf') for i in range(len(nums_sorted) - k + 1): diff = nums_sorted[i + k - 1] - nums_sorted[i] if diff < min_diff: min_diff = diff return min_diff"},{"question":"def unique_paths(x: int, y: int) -> int: Returns the number of distinct paths from (0, 0) to (x, y) using only steps that move right or up. >>> unique_paths(0, 0) 1 >>> unique_paths(2, 3) 10 >>> unique_paths(3, 2) 10 >>> unique_paths(3, 3) 20 >>> unique_paths(4, 4) 70 >>> unique_paths(2, 5) 21 >>> unique_paths(5, 2) 21","solution":"def unique_paths(x, y): Returns the number of distinct paths from (0, 0) to (x, y) using only steps that move right or up. # Create a 2D table to store results of subproblems dp = [[0]*(y+1) for _ in range(x+1)] # There is only one way to reach any cell in the first row or first column for i in range(x+1): dp[i][0] = 1 for j in range(y+1): dp[0][j] = 1 # Fill the dp table for i in range(1, x+1): for j in range(1, y+1): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[x][y]"},{"question":"from typing import List def three_sum(nums: List[int]) -> List[List[int]]: Given an array of n integers, return an array of all the unique triplets such that they sum to zero. Args: nums : List[int] List of integers Returns: List[List[int]] List of unique triplets Example: >>> three_sum([-1, 0, 1, 2, -1, -4]) [[-1, -1, 2], [-1, 0, 1]] from solution import three_sum def test_three_sum_with_example_case(): result = three_sum([-1, 0, 1, 2, -1, -4]) expected = [[-1, -1, 2], [-1, 0, 1]] result_sorted = sorted([sorted(triplet) for triplet in result]) expected_sorted = sorted([sorted(triplet) for triplet in expected]) assert result_sorted == expected_sorted def test_three_sum_with_no_triplets(): assert three_sum([1, 2, 3, 4, 5]) == [] def test_three_sum_with_all_negative_numbers(): assert three_sum([-1,ython def three_sum(nums: List[int]) -> List[List[int]]: Given an array of n integers, return an array of all the unique triplets such that they sum to zero. Args: nums : List[int] List of integers Returns: List[List[int]] List of unique triplets Example: >>> three_sum([-1, 0, 1, 2, -1, -4]) [[-1, -1, 2], [-1, 0, 1]] from solution import three_sum def test_three_sum_with_example_case(): result = three_sum([-1, 0, 1, 2, -1, -4]) expected = [[-1, -1, 2], [-1, 0, 1]] result_sorted = sorted([sorted(triplet) for triplet in result]) expected_sorted = sorted([sorted(triplet) for triplet in expected]) assert result_sorted == expected_sorted def test_three_sum_with_no_triplets(): assert three_sum([1, 2, 3, 4, 5]) == [] def test_three_sum_with_zero(array): for i in range(5): print(array[i], end=\\" \\") # Test Cases def test_print_first_five_elements_or_fill_up_with_zero(): import io import sys capturedOutput = io.StringIO() sys.stdout = capturedOutput print_first_five_elements_or_fill_up_with_zero([1, 2, 3]) sys.stdout = sys.__stdout__ assert capturedOutput.getvalue() == \\"1 2 3 0 0 \\" capturedOutput = io.StringIO() sys.stdout = capturedOutput print_first_five_elements_or_fill_up_with_zero([1, 2, 3, 4, 5, 6]) sys.stdout = sys.__stdout__ assert capturedOutput.getvalue() == \\"1 2 3 4 5 \\" capturedOutput = io.StringIO() sys.stdout = capturedOutput print_first_five_elements_or_fill_up_with_zero([0, 0, 0, 0, 0]) sys.stdout = sys.__stdout__ assert capturedOutput.getvalue() == \\"0 0 0 0 0 \\" Solution: def print_first_five_elements_or_fill_up_with_zero(array): for i in range(5): if i < len(array): print(array[i], end=\\" \\") else: print(0, end=\\" \\")","solution":"def three_sum(nums): Given an array of n integers, return an array of all the unique triplets such that they sum to zero. Args: nums : List[int] List of integers Returns: List[List[int]] List of unique triplets Example: >>> three_sum([-1, 0, 1, 2, -1, -4]) [[-1, -1, 2], [-1, 0, 1]] nums.sort() # Sort the array to use two-pointer approach result = [] n = len(nums) for i in range(n): if i > 0 and nums[i] == nums[i - 1]: continue # Skip the duplicate values for the first number of the triplet left, right = i + 1, n - 1 while left < right: total = nums[i] + nums[left] + nums[right] if total == 0: result.append([nums[i], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 # Skip duplicates for the second number of the triplet while left < right and nums[right] == nums[right - 1]: right -= 1 # Skip duplicates for the third number of the triplet left += 1 right -= 1 elif total < 0: left += 1 else: right -= 1 return result"},{"question":"def count_nodes_with_one_child(s: str) -> int: Counts the number of nodes with exactly one child in a binary tree serialized as a level-order traversal string. >>> count_nodes_with_one_child(\\"#\\") == 0 >>> count_nodes_with_one_child(\\"1 # #\\") == 0 >>> count_nodes_with_one_child(\\"1 2 # # #\\") == 1 >>> count_nodes_with_one_child(\\"1 2 3 4 5 6 7 # # # # # # # #\\") == 0 >>> count_nodes_with_one_child(\\"1 2 3 # 4 5 # # # # 6 # # # #\\") == 3 >>> count_nodes_with_one_child(\\"1 2 3 4 # 6 7 # # # # # 8 9 # # #\\") == 3","solution":"def count_nodes_with_one_child(s): Counts the number of nodes with exactly one child in a binary tree serialized as a level-order traversal string. nodes = s.split() if not nodes or nodes[0] == '#': return 0 queue = [] index = 0 count = 0 queue.append(nodes[index]) index += 1 while queue and index < len(nodes): current = queue.pop(0) left_child = nodes[index] if index < len(nodes) else '#' index += 1 right_child = nodes[index] if index < len(nodes) else '#' index += 1 # Check if the current node has exactly one child if (left_child == '#' and right_child != '#') or (left_child != '#' and right_child == '#'): count += 1 if left_child != '#': queue.append(left_child) if right_child != '#': queue.append(right_child) return count"},{"question":"def has_pair_with_difference(nums: List[int], n: int) -> bool: Determines if there exist two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is exactly n. :param nums: List of integers :param n: Integer :return: Boolean value indicating the existence of such a pair >>> has_pair_with_difference([1, 5, 3, 4, 2], 2) == True >>> has_pair_with_difference([10, 2, 6, 4, 8], 4) == True >>> has_pair_with_difference([1, 2, 3, 4, 5], 10) == False >>> has_pair_with_difference([1, 2, 2, 3], 1) == True >>> has_pair_with_difference([100, 200, 300], 200) == True >>> has_pair_with_difference([1], 1) == False >>> has_pair_with_difference([], 5) == False","solution":"def has_pair_with_difference(nums, n): Determines if there exist two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is exactly n. :param nums: List of integers :param n: Integer :return: Boolean value indicating the existence of such a pair num_set = set(nums) for num in nums: if (num + n in num_set) or (num - n in num_set): return True return False"},{"question":"class HouseRobber: Determine the maximum amount of money you can rob tonight without alerting the police. The constraint is that you cannot rob two adjacent houses. >>> hr = HouseRobber([5]) >>> hr.rob() == 5 >>> hr = HouseRobber([1, 2]) >>> hr.rob() == 2 >>> hr = HouseRobber([2, 7, 9, 3, 1]) >>> hr.rob() == 12 >>> hr = HouseRobber([]) >>> hr.rob() == 0 >>> hr = HouseRobber([3, 3, 3, 3]) >>> hr.rob() == 6 >>> hr = HouseRobber([2, 1, 1, 2]) >>> hr.rob() == 4","solution":"class HouseRobber: def __init__(self, houses): self.houses = houses def rob(self): if not self.houses: return 0 n = len(self.houses) if n == 1: return self.houses[0] dp = [0] * n dp[0] = self.houses[0] if n > 1: dp[1] = max(self.houses[0], self.houses[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + self.houses[i]) return dp[-1]"},{"question":"class ListNode: def __init__(self, x): self.val = x self.next = None def has_cycle(head: ListNode) -> bool: Returns True if there is a cycle in the linked list, otherwise returns False. pass def test_no_cycle(): # Create linked list: 1 -> 2 -> 3 -> 4 -> 5 head = ListNode(1) head.next = ListNode(2) head.next.next = ListNode(3) head.next.next.next = ListNode(4) head.next.next.next.next = ListNode(5) assert not has_cycle(head) def test_cycle(): # Create linked list with a cycle: 1 -> 2 -> 3 -> 4 -> 5 -> back to 3 head = ListNode(1) second = ListNode(2) third = ListNode(3) fourth = ListNode(4) fifth = ListNode(5) head.next = second second.next = third third.next = fourth fourth.next = fifth fifth.next = third # Create cycle here assert has_cycle(head) def test_empty_list(): # Test Empty List head = None assert not has_cycle(head) def test_single_node_no_cycle(): # Single node without cycle head = ListNode(1) assert not has_cycle(head) def test_single_node_with_cycle(): # Single node with cycle (points to itself) head = ListNode(1) head.next = head assert has_cycle(head) def test_two_nodes_with_cycle(): # Two nodes with a cycle head = ListNode(1) second = ListNode(2) head.next = second second.next = head # Create cycle here assert has_cycle(head) def test_two_nodes_without_cycle(): # Two nodes without a cycle head = ListNode(1) second = ListNode(2) head.next = second assert not has_cycle(head)","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def has_cycle(head): Returns True if there is a cycle in the linked list, otherwise returns False. slow = head fast = head while fast is not None and fast.next is not None: slow = slow.next fast = fast.next.next if slow == fast: return True return False"},{"question":"def rob(nums: List[int]) -> int: Calculate the maximum amount of money the thief can rob without triggering the alarm. >>> rob([]) == 0 >>> rob([50]) == 50 >>> rob([20, 30]) == 30 >>> rob([20, 30, 10]) == 30 >>> rob([20, 10, 30]) == 50 >>> rob([2, 7, 9, 3, 1]) == 12 >>> rob([10, 1, 1, 10, 1]) == 20 >>> rob([6, 7, 1, 30, 8, 2, 4]) == 41 >>> rob([1000, 2000, 3000, 1000, 2000]) == 6000 >>> rob([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 30","solution":"def rob(nums): Calculate the maximum amount of money the thief can rob without triggering the alarm. :param nums: List[int] - A list of integers representing the amount of money in each house along a street. :return: int - The maximum amount of money that can be robbed. if not nums: return 0 if len(nums) == 1: return nums[0] prev1, prev2 = 0, 0 for num in nums: temp = prev1 prev1 = max(prev2 + num, prev1) prev2 = temp return prev1"},{"question":"from collections import deque from typing import List def longest_subarray_with_limit(nums: List[int], limit: int) -> int: Finds the length of the longest subarray where the difference between the maximum and minimum elements is less than or equal to a given limit. >>> longest_subarray_with_limit([8, 2, 4, 7], 4) 2 >>> longest_subarray_with_limit([10, 1, 2, 4, 7, 2], 5) 4 >>> longest_subarray_with_limit([4, 2, 2, 2, 4, 4, 2, 2], 0) 3 >>> longest_subarray_with_limit([1, 2, 3, 4, 5], 4) 5 >>> longest_subarray_with_limit([1, 2, 3, 4, 5], 0) 1 >>> longest_subarray_with_limit([100], 10) 1 >>> longest_subarray_with_limit([7, 7, 7, 7, 7], 0) 5","solution":"from collections import deque def longest_subarray_with_limit(nums, limit): Finds the length of the longest subarray where the difference between the maximum and minimum elements is less than or equal to a given limit. min_deque = deque() max_deque = deque() left = 0 max_len = 0 for right in range(len(nums)): while min_deque and nums[right] < nums[min_deque[-1]]: min_deque.pop() while max_deque and nums[right] > nums[max_deque[-1]]: max_deque.pop() min_deque.append(right) max_deque.append(right) while nums[max_deque[0]] - nums[min_deque[0]] > limit: left += 1 if min_deque[0] < left: min_deque.popleft() if max_deque[0] < left: max_deque.popleft() max_len = max(max_len, right - left + 1) return max_len"},{"question":"def min_max_distance_to_heater(houses, k): This function finds the minimized maximum distance that any house has to a heater. Parameters: - houses: List[int], a list of positions of the houses on a number line. - k: int, the number of heaters to be placed. Returns: - int: the minimized maximum distance from any house to a heater. # Test cases def test_min_max_distance_basic(): houses = [1, 2, 3, 4, 5] k = 1 assert min_max_distance_to_heater(houses, k) == 2 def test_min_max_distance_multiple_heaters(): houses = [1, 2, 3, 4, 5] k = 2 assert min_max_distance_to_heater(houses, k) == 1 def test_min_max_distance_far_houses(): houses = [1, 1000, 2000, 3000, 4000] k = 2 assert min_max_distance_to_heater(houses, k) == 1000 def test_min_max_distance_single_house(): houses = [1] k = 1 assert min_max_distance_to_heater(houses, k) == 0 def test_min_max_distance_all_houses_same_position(): houses = [5, 5, 5, 5] k = 2 assert min_max_distance_to_heater(houses, k) == 0 def test_min_max_distance_single_heater_many_houses(): houses = [1, 2, 4, 8, 9] k = 1 assert min_max_distance_to_heater(houses, k) == 4 def test_min_max_distance_heaters_more_than_houses(): houses = [1, 2, 3] k = 4 assert min_max_distance_to_heater(houses, k) == 0","solution":"def min_max_distance_to_heater(houses, k): This function finds the minimized maximum distance that any house has to a heater. Parameters: - houses: List[int], an list of positions of the houses on a number line. - k: int, the number of heaters to be placed. Returns: - int: the minimized maximum distance from any house to a heater. houses.sort() def can_place_heaters(dist): heaters = 1 last_heater = houses[0] for i in range(1, len(houses)): if houses[i] - last_heater > dist * 2: heaters += 1 last_heater = houses[i] if heaters > k: return False return True left, right = 0, (houses[-1] - houses[0]) // 2 + 1 while left < right: mid = (left + right) // 2 if can_place_heaters(mid): right = mid else: left = mid + 1 return left"},{"question":"def max_balanced_substrings(s: str) -> int: Returns the maximum number of balanced substrings that can be obtained from the input string. A balanced string contains an equal number of 'a's and 'b's. Parameters: s (str): The input string consisting of letters 'a' and 'b' only. Returns: int: The maximum number of balanced substrings. >>> max_balanced_substrings(\\"aabbab\\") 2 >>> max_balanced_substrings(\\"ab\\") 1 >>> max_balanced_substrings(\\"aaaa\\") 0 >>> max_balanced_substrings(\\"bbbb\\") 0 >>> max_balanced_substrings(\\"ababab\\") 3 >>> max_balanced_substrings(\\"aabbabb\\") 2 >>> max_balanced_substrings(\\"aaaaaabbbbbb\\") 1 >>> max_balanced_substrings(\\"abababab\\") 4","solution":"def max_balanced_substrings(s): Returns the maximum number of balanced substrings that can be obtained from the input string. Parameters: s (str): The input string consisting of letters 'a' and 'b' only. Returns: int: The maximum number of balanced substrings. countA = 0 countB = 0 balanced_count = 0 for char in s: if char == 'a': countA += 1 elif char == 'b': countB += 1 if countA == countB: balanced_count += 1 countA = 0 countB = 0 return balanced_count"},{"question":"def contains_duplicates(nums: List[int]) -> bool: Given a list of integers, determine if the list contains any duplicates. If any value appears at least twice in the list, return \`True\`. If every element is distinct, return \`False\`. >>> contains_duplicates([1, 2, 3, 1]) == True >>> contains_duplicates([1, 2, 3, 4]) == False >>> contains_duplicates([]) == False >>> contains_duplicates([1]) == False >>> contains_duplicates([1, 1, 1, 1]) == True >>> contains_duplicates([-1, -2, -3, -1]) == True >>> contains_duplicates([1, -2, 3, -1, 1]) == True","solution":"def contains_duplicates(nums): Returns True if any value appears at least twice in the list, otherwise False. return len(nums) != len(set(nums))"},{"question":"from typing import List def maximum_area_histogram(heights: List[int]) -> int: Determine the maximum rectangular area that can be formed using contiguous buildings. The width of each building is 1 unit. Heights is a list of integers representing the heights of buildings. >>> maximum_area_histogram([2, 1, 5, 6, 2, 3]) 10 >>> maximum_area_histogram([2, 4]) 4 >>> maximum_area_histogram([4, 2, 0, 3, 2, 5]) 6 >>> maximum_area_histogram([6, 2, 5, 4, 5, 1, 6]) 12 >>> maximum_area_histogram([1, 2, 3, 4, 5]) 9 >>> maximum_area_histogram([]) 0 >>> maximum_area_histogram([5]) 5 >>> maximum_area_histogram([0]) 0","solution":"def maximum_area_histogram(heights): Returns the maximum rectangular area that can be formed using contiguous buildings. :param heights: List[int] :return: int stack = [] max_area = 0 index = 0 while index < len(heights): # If this building is higher than the one on the stack, push it to the stack if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: # Pop the top top_of_stack = stack.pop() # Calculate the area with heights[top_of_stack] as the smallest (or minimum height) bar 'h' area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) # Update max_area, if needed max_area = max(max_area, area) # Now pop the remaining buildings from stack and calculate area with every popped stack while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def encode_string(s: str) -> str: Encodes the input string by replacing each character with its 1-based index in the alphabet. :param s: The original string with only lowercase letters. :return: The encoded string. >>> encode_string(\\"\\") == \\"\\" >>> encode_string(\\"a\\") == \\"1\\" >>> encode_string(\\"abc\\") == \\"123\\" >>> encode_string(\\"hello\\") == \\"85121215\\" # Write your implementation here # Unit Tests def test_encode_empty_string(): assert encode_string(\\"\\") == \\"\\" def test_encode_single_character(): assert encode_string(\\"a\\") == \\"1\\" assert encode_string(\\"z\\") == \\"26\\" def test_encode_multiple_characters(): assert encode_string(\\"abc\\") == \\"123\\" assert encode_string(\\"xyz\\") == \\"242526\\" def test_encode_repeated_characters(): assert encode_string(\\"aaa\\") == \\"111\\" assert encode_string(\\"zzz\\") == \\"262626\\" def test_encode_mixed_characters(): assert encode_string(\\"hello\\") == \\"85121215\\" assert encode_string(\\"encode\\") == \\"51431545\\"","solution":"def encode_string(s): Encodes the input string by replacing each character with its 1-based index in the alphabet. :param s: The original string with only lowercase letters. :return: The encoded string. encoded = [] for char in s: # Calculate the 1-based index of each character (a -> 1, b -> 2, ..., z -> 26) position = ord(char) - ord('a') + 1 encoded.append(str(position)) return ''.join(encoded)"},{"question":"def minDistance(word1: str, word2: str) -> int: Returns the minimum number of operations required to convert word1 to word2. Operations allowed: insert a character, delete a character, replace a character. Args: word1 (str): The original word. word2 (str): The word to convert to. Returns: int: Minimum number of operations required. Examples: >>> minDistance(\\"horse\\", \\"ros\\") 3 >>> minDistance(\\"intention\\", \\"execution\\") 5","solution":"def minDistance(word1, word2): Returns the minimum number of operations required to convert word1 to word2. m, n = len(word1), len(word2) # Initialize a (m+1) x (n+1) matrix dp where dp[i][j] represents the minimum distance dp = [[0] * (n+1) for _ in range(m+1)] # Fill the base cases for i in range(1, m+1): dp[i][0] = i for j in range(1, n+1): dp[0][j] = j # Fill the dp matrix for i in range(1, m+1): for j in range(1, n+1): if word1[i-1] == word2[j-1]: dp[i][j] = dp[i-1][j-1] else: dp[i][j] = 1 + min(dp[i-1][j], # Delete dp[i][j-1], # Insert dp[i-1][j-1]) # Replace return dp[m][n]"},{"question":"from typing import List def can_reach_last_building(heights: List[int], k: int) -> bool: Determine if it's possible to reach the last building from the first building. Parameters: heights (List[int]): List of integers representing the heights of buildings. k (int): Maximum number of steps you can jump. Returns: bool: True if it's possible to reach the last building, False otherwise. pass # Example test cases def test_single_building(): assert can_reach_last_building([4], 2) == True def test_basic_scenario(): assert can_reach_last_building([1, 2, 3, 4, 2, 1], 3) == False def test_large_jump(): assert can_reach_last_building([1, 1, 1, 1, 1], 4) == True def test_exact_jump(): assert can_reach_last_building([3, 2, 2, 3, 1], 2) == True def test_not_possible_to_reach(): assert can_reach_last_building([3, 4, 2, 1, 5], 2) == False def test_equal_height_old_to_new_jump(): assert can_reach_last_building([3, 3, 3, 3, 3], 2) == True def test_all_buildings_taller(): assert can_reach_last_building([1, 5, 5, 5, 1], 3) == False def test_mixed_height_buildings_possible(): assert can_reach_last_building([3, 2, 1, 1, 1], 4) == True","solution":"def can_reach_last_building(heights, k): Determine if it's possible to reach the last building from the first building. Parameters: heights (List[int]): List of integers representing the heights of buildings. k (int): Maximum number of steps you can jump. Returns: bool: True if it's possible to reach the last building, False otherwise. n = len(heights) if n == 1: return True reachable = [False] * n reachable[0] = True for i in range(n): if reachable[i]: for j in range(1, k+1): if i + j < n and heights[i + j] <= heights[i]: reachable[i + j] = True return reachable[-1]"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_at_distance_k(root, k): Returns the sum of all nodes that are at distance k from the root. :param root: TreeNode - the root of the binary tree :param k: int - the distance from the root :return: int - the sum of all nodes at distance k >>> root = TreeNode(1) >>> sum_at_distance_k(root, 0) 1 >>> sum_at_distance_k(root, 1) 0 >>> root = TreeNode(1, TreeNode(2), TreeNode(3)) >>> sum_at_distance_k(root, 1) 5 >>> sum_at_distance_k(root, 2) 0 >>> root = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, TreeNode(6), TreeNode(7))) >>> sum_at_distance_k(root, 2) 22 >>> sum_at_distance_k(root, 1) 5 >>> root = TreeNode(1, TreeNode(2, TreeNode(4)), TreeNode(3)) >>> sum_at_distance_k(root, 2) 4 >>> sum_at_distance_k(root, 1) 5 >>> root = None >>> sum_at_distance_k(root, 0) 0 >>> sum_at_distance_k(root, 1) 0","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_at_distance_k(root, k): Returns the sum of all nodes that are at distance k from the root. :param root: TreeNode - the root of the binary tree :param k: int - the distance from the root :return: int - the sum of all nodes at distance k if root is None: return 0 if k == 0: return root.val left_sum = sum_at_distance_k(root.left, k - 1) right_sum = sum_at_distance_k(root.right, k - 1) return left_sum + right_sum"},{"question":"def checkPossibility(nums: List[int]) -> bool: Determine if the array could become non-decreasing by modifying at most one element. Parameters: nums (list of int): The input integer array in non-decreasing order. Returns: bool: True if it's possible to make the array non-decreasing by modifying at most one element, otherwise False. Examples: >>> checkPossibility([1, 2, 3, 4, 5]) True >>> checkPossibility([4, 2, 3]) True >>> checkPossibility([4, 2, 1]) False >>> checkPossibility([1, 3, 5, 2, 6, 4]) False >>> checkPossibility([2, 3, 3, 2, 4]) True","solution":"def checkPossibility(nums): Determine if the array could become non-decreasing by modifying at most one element. Parameters: nums (list of int): The input integer array in non-decreasing order. Returns: bool: True if it's possible to make the array non-decreasing by modifying at most one element, otherwise False. count_decrease = 0 for i in range(1, len(nums)): if nums[i] < nums[i - 1]: count_decrease += 1 if count_decrease > 1: return False if i == 1 or nums[i - 2] <= nums[i]: nums[i - 1] = nums[i] else: nums[i] = nums[i - 1] return True"},{"question":"def rearrange_string(s: str) -> str: Rearranges the string such that all 'a' characters are moved to the left, all 'c' characters are moved to the right, and all 'b' characters are in the middle. :param s: A string consisting of characters 'a', 'b', and 'c' :return: The rearranged string >>> rearrange_string(\\"abcabc\\") 'aabbcc' >>> rearrange_string(\\"aaa\\") 'aaa' >>> rearrange_string(\\"bbb\\") 'bbb' >>> rearrange_string(\\"ccc\\") 'ccc' >>> rearrange_string(\\"cacbab\\") 'aabbcc' >>> rearrange_string(\\"\\") '' >>> rearrange_string(\\"bbcc\\") 'bbcc' >>> rearrange_string(\\"aacc\\") 'aacc' >>> rearrange_string(\\"aabb\\") 'aabb'","solution":"def rearrange_string(s): Rearranges the string such that all 'a' characters are moved to the left, all 'c' characters are moved to the right, and all 'b' characters are in the middle. :param s: A string consisting of characters 'a', 'b', and 'c' :return: The rearranged string a_count = s.count('a') b_count = s.count('b') c_count = s.count('c') return 'a' * a_count + 'b' * b_count + 'c' * c_count"},{"question":"def count_substrings(s: str, n: int) -> int: Given a string \`s\` and an integer \`n\`, return the number of substrings of \`s\` whose length is exactly \`n\` and contains at most one distinct character. >>> count_substrings(\\"aaabbbccc\\", 3) 3 >>> count_substrings(\\"aaaaaa\\", 2) 5 >>> count_substrings(\\"abcabcabc\\", 2) 0 >>> count_substrings(\\"abbcccddddeeeee\\", 5) 1 >>> count_substrings(\\"abcdef\\", 2) 0 >>> count_substrings(\\"aaaaaa\\", 6) 1","solution":"def count_substrings(s, n): Returns the number of substrings of length n with at most one distinct character. :param s: Input string :param n: Length of the desired substrings :return: Number of substrings meeting the criteria count = 0 length = len(s) for i in range(length - n + 1): substring = s[i:i+n] distinct_chars = set(substring) if len(distinct_chars) <= 1: count += 1 return count"},{"question":"from typing import List def shortestPathWithOneBreak(maze: List[List[int]]) -> int: Given a 2D grid representing a maze of dimensions \`m x n\`, where each cell can either be an empty space \`'0'\` or a wall \`'1'\`. Find the length of the shortest path from the top-left corner to the bottom-right corner with at most one wall break allowed. Args: maze (List[List[int]]): 2D grid representing the maze Returns: int: The length of the shortest path from start to destination, if there is no path return -1 >>> shortestPathWithOneBreak([[0, 0, 0], [1, 1, 0], [0, 0, 0]]) 5 >>> shortestPathWithOneBreak([[0, 1, 0], [1, 0, 0], [0, 0, 0]]) 5 >>> shortestPathWithOneBreak([[0, 1, 1], [1, 0, 1], [1, 1, 0]]) -1 >>> shortestPathWithOneBreak([[0, 0, 0, 1, 0], [1, 1, 0, 1, 0], [0, 0, 0, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0]]) 9 >>> shortestPathWithOneBreak([[0, 1], [1, 0]]) 3","solution":"from collections import deque def shortestPathWithOneBreak(maze): Returns the length of the shortest path from the start to the destination, where one wall can be broken to aid in creating the path. If there is no path, returns -1. if not maze or not maze[0]: return -1 m, n = len(maze), len(maze[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # BFS queue: (x, y, wall_breaks, path_length) queue = deque([(0, 0, 0, 1)]) # Visited array with wall breaking state visited = [[[False]*2 for _ in range(n)] for _ in range(m)] visited[0][0][0] = True while queue: x, y, wall_breaks, path_length = queue.popleft() if x == m-1 and y == n-1: return path_length for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n: # If encountered wall and wall breaking still available if maze[nx][ny] == 1 and wall_breaks == 0 and not visited[nx][ny][1]: visited[nx][ny][1] = True queue.append((nx, ny, 1, path_length + 1)) # If encountered empty space elif maze[nx][ny] == 0 and not visited[nx][ny][wall_breaks]: visited[nx][ny][wall_breaks] = True queue.append((nx, ny, wall_breaks, path_length + 1)) return -1"},{"question":"class Node: def __init__(self, val, next=None, random=None): self.val = val self.next = next self.random = random def copyRandomList(head): Construct a deep copy of a linked list with random pointers. The function takes the head of the linked list and returns the head of the deep copied list. pass # Unit tests def test_copyRandomList_empty(): assert copyRandomList(None) is None def test_copyRandomList_single_node(): node = Node(1) copy = copyRandomList(node) assert copy.val == 1 assert copy.next is None assert copy.random is None def test_copyRandomList_two_nodes_with_no_random(): node1 = Node(1) node2 = Node(2) node1.next = node2 copy = copyRandomList(node1) assert copy.val == 1 assert copy.next.val == 2 assert copy.next.next is None assert copy.random is None assert copy.next.random is None def test_copyRandomList_two_nodes_with_random(): node1 = Node(1) node2 = Node(2) node1.next = node2 node1.random = node2 node2.random = node2 copy = copyRandomList(node1) assert copy.val == 1 assert copy.next.val == 2 assert copy.next.next is None assert copy.random.val == 2 assert copy.next.random.val == 2 def test_copyRandomList_complex_case(): node1 = Node(1) node2 = Node(2) node3 = Node(3) node1.next = node2 node2.next = node3 node1.random = node3 node2.random = node1 node3.random = node2 copy = copyRandomList(node1) assert copy.val == 1 assert copy.next.val == 2 assert copy.next.next.val == 3 assert copy.next.next.next is None assert copy.random.val == 3 assert copy.next.random.val == 1 assert copy.next.next.random.val == 2","solution":"class Node: def __init__(self, val, next=None, random=None): self.val = val self.next = next self.random = random def copyRandomList(head): if not head: return None # Step 1: Create a new node for each original node and insert it right after the original node. current = head while current: new_node = Node(current.val, current.next) current.next = new_node current = new_node.next # Step 2: Set the random pointers for the new nodes. current = head while current: if current.random: current.next.random = current.random.next current = current.next.next # Step 3: Restore the original list and extract the copy list. current = head copy_head = head.next while current: copy = current.next current.next = copy.next if copy.next: copy.next = copy.next.next current = current.next return copy_head"},{"question":"def max_chocolates(arr): Returns the maximum number of chocolates that can be eaten from non-adjacent boxes. >>> max_chocolates([]) == 0 >>> max_chocolates([5]) == 5 >>> max_chocolates([10]) == 10 >>> max_chocolates([5, 10]) == 10 >>> max_chocolates([10, 5]) == 10 >>> max_chocolates([5, 5]) == 5 >>> max_chocolates([1, 2, 3]) == 4 # take 1 and 3 >>> max_chocolates([2, 1, 4, 5, 1]) == 7 # take 2, 5 >>> max_chocolates([5, 1, 5, 1, 5]) == 15 # take all 5s >>> max_chocolates([10, 1, 10, 1, 10]) == 30 # take all 10s >>> max_chocolates([3, 2, 7, 10]) == 13 # take 3 and 10 >>> max_chocolates([3, 2, 5, 10, 7]) == 15 # take 3, 10, or 2, 10","solution":"def max_chocolates(arr): Returns the maximum number of chocolates that can be eaten from non-adjacent boxes. n = len(arr) if n == 0: return 0 if n == 1: return arr[0] # dp[i] will store the maximum chocolates that can be eaten from 0 to i dp = [0] * n # base cases dp[0] = arr[0] if n > 1: dp[1] = max(arr[0], arr[1]) # fill the dp array for i in range(2, n): dp[i] = max(dp[i-1], arr[i] + dp[i-2]) return dp[-1]"},{"question":"def count_smaller_numbers_after_self(arr): Returns an array of counts of smaller numbers after each element in the given array. Args: arr (List[int]): input list of integers. Returns: List[int]: a list of counts of smaller numbers after each element in the input list. >>> count_smaller_numbers_after_self([5, 2, 6, 1]) == [2, 1, 1, 0] >>> count_smaller_numbers_after_self([5, 2, 6, 2, 1]) == [3, 1, 2, 1, 0] >>> count_smaller_numbers_after_self([1, 1, 1, 1]) == [0, 0, 0, 0] >>> count_smaller_numbers_after_self([1, 2, 3, 4]) == [0, 0, 0, 0] >>> count_smaller_numbers_after_self([4, 3, 2, 1]) == [3, 2, 1, 0] >>> count_smaller_numbers_after_self([1]) == [0] >>> count_smaller_numbers_after_self([]) == []","solution":"def count_smaller_numbers_after_self(arr): Returns an array of counts of smaller numbers after each element in the given array. Args: arr (List[int]): input list of integers. Returns: List[int]: a list of counts of smaller numbers after each element in the input list. result = [] for i in range(len(arr)): count = 0 for j in range(i + 1, len(arr)): if arr[j] < arr[i]: count += 1 result.append(count) return result"},{"question":"def max_sum_of_binaries(binary_list): Given a list of binary strings, find and return the maximum sum of two distinct binary numbers when converted to decimals. Parameters: binary_list (list): A list of binary string numbers. Returns: int: The maximum decimal sum of two distinct binary numbers. >>> max_sum_of_binaries(['10', '11', '1']) == int('10', 2) + int('11', 2) >>> max_sum_of_binaries(['110', '101', '100']) == int('110', 2) + int('101', 2) >>> max_sum_of_binaries(['1', '1', '1']) == int('1', 2) + int('1', 2) >>> max_sum_of_binaries(['0', '0', '0']) == int('0', 2) + int('0', 2) >>> max_sum_of_binaries(['1111', '1', '10']) == int('1111', 2) + int('10', 2) >>> max_sum_of_binaries(['110', '101']) == int('110', 2) + int('101', 2)","solution":"def max_sum_of_binaries(binary_list): Given a list of binary strings, find and return the maximum sum of two distinct binary numbers when converted to decimals. Parameters: binary_list (list): A list of binary string numbers. Returns: int: The maximum decimal sum of two distinct binary numbers. # Convert the binary strings to decimal integers decimal_numbers = [int(b, 2) for b in binary_list] # Sort the decimal numbers in descending order decimal_numbers.sort(reverse=True) # The maximum sum will be the sum of the two largest distinct numbers return decimal_numbers[0] + decimal_numbers[1] # Take the top two numbers and sum them"},{"question":"def shortest_distance_to_char(s: str, c: str) -> List[int]: Returns an array of shortest distances from each character in s to the character c. >>> shortest_distance_to_char(\\"loveleetcode\\", 'e') [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0] >>> shortest_distance_to_char(\\"aaaabaaa\\", 'b') [4, 3, 2, 1, 0, 1, 2, 3] >>> shortest_distance_to_char(\\"abcd\\", 'z') [] >>> shortest_distance_to_char(\\"aaaaa\\", 'a') [0, 0, 0, 0, 0] >>> shortest_distance_to_char(\\"\\", 'a') [] >>> shortest_distance_to_char(\\"a\\", 'a') [0] >>> shortest_distance_to_char(\\"a\\", 'b') []","solution":"def shortest_distance_to_char(s, c): Returns an array of shortest distances from each character in s to the character c. if c not in s: return [] prev = float('-inf') result = [] # First pass to find the shortest distance to previous occurrences of c for i in range(len(s)): if s[i] == c: prev = i result.append(i - prev) prev = float('inf') # Second pass to find the shortest distance to next occurrences of c for i in range(len(s) - 1, -1, -1): if s[i] == c: prev = i result[i] = min(result[i], prev - i) return result"},{"question":"def find_pairs_with_sum(nums: List[int], k: int) -> List[List[int]]: Given a list of unique integers nums, find all pairs of numbers that sum up to a given target k. Each pair should be represented as an array of the two integers in non-descending order. The solution should not contain duplicate pairs. Return a list of the pairs in any order. >>> find_pairs_with_sum([1, 2, 3, 4, 5], 5) [[1, 4], [2, 3]] >>> find_pairs_with_sum([1, 2, 3, 4, 6], 7) [[1, 6], [3, 4]] >>> find_pairs_with_sum([1, 2, 3, 4], 10) [] >>> find_pairs_with_sum([-1, 0, 1, 2, -2], 0) [[-2, 2], [-1, 1]] >>> find_pairs_with_sum([1], 2) [] >>> find_pairs_with_sum([], 0) [] >>> find_pairs_with_sum([1, 2, 2, 3, 4], 5) [[1, 4], [2, 3]]","solution":"def find_pairs_with_sum(nums, k): nums_dict = {} pairs = set() for num in nums: complement = k - num if complement in nums_dict: pairs.add(tuple(sorted((num, complement)))) nums_dict[num] = True return [list(pair) for pair in pairs]"},{"question":"def students_to_move(heights: List[int]) -> List[int]: Given a 0-indexed integer array heights representing the heights of students in a line, return a list of integers representing the positions of students that need to move such that each student's height is taller than the student in front of them after rearrangement. >>> students_to_move([1, 2, 3, 4, 5]) == [] >>> students_to_move([1, 3, 2, 4, 5]) == [2] >>> students_to_move([5, 1, 2, 4, 3]) == [1, 4] >>> students_to_move([5]) == [] >>> students_to_move([5, 4, 3, 2, 1]) == [1, 2, 3, 4] >>> students_to_move([]) == [] >>> students_to_move([1, 2, 2, 3, 4]) == [] >>> students_to_move([1, 2, 3, 2, 4, 5]) == [3]","solution":"def students_to_move(heights): Returns a list of indices of students that need to move to achieve non-decreasing arrangement. result = [] for i in range(1, len(heights)): if heights[i] < heights[i - 1]: result.append(i) return result"},{"question":"def longest_subsequence(nums: List[int]) -> int: Given a list of integers, return the length of the longest subsequence such that every pair of consecutive elements in the subsequence has an absolute difference of at most 1. >>> longest_subsequence([]) 0 >>> longest_subsequence([1]) 1 >>> longest_subsequence([3, 3, 3, 3]) 4 >>> longest_subsequence([1, 2, 2, 3]) 4 >>> longest_subsequence([1, 2, 2, 3, 4, 4, 4, 5, 6]) 6 >>> longest_subsequence([10, 12, 14, 15]) 2","solution":"def longest_subsequence(nums): if not nums: return 0 counts = {} max_length = 0 for num in nums: if num in counts: counts[num] += 1 else: counts[num] = 1 for num in counts: length = counts[num] if num - 1 in counts: length += counts[num - 1] if num + 1 in counts: length += counts[num + 1] max_length = max(max_length, length) return max_length"},{"question":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def levelOrderTraversal(root): Performs a level-order traversal (breadth-first search) of a binary tree. Args: root (TreeNode): The root of the binary tree. Returns: List[List[int]]: A list of lists, where each inner list contains the values of the nodes at that level, from left to right. >>> levelOrderTraversal(TreeNode(1)) == [[1]] >>> levelOrderTraversal(None) == [] >>> levelOrderTraversal(TreeNode(1, TreeNode(2), TreeNode(3))) == [[1], [2, 3]] >>> levelOrderTraversal(TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, None, TreeNode(6)))) == [[1], [2, 3], [4, 5, 6]] >>> levelOrderTraversal(TreeNode(1, TreeNode(2, TreeNode(3, TreeNode(4))))) == [[1], [2], [3], [4]]","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def levelOrderTraversal(root): Performs a level-order traversal (breadth-first search) of a binary tree. if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) level_values = [] for _ in range(level_size): node = queue.popleft() level_values.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_values) return result"},{"question":"def combination_sum2(candidates, target): Given a list of positive integers, \`candidates\`, and a target positive integer, \`target\`, return a list of all unique combinations of \`candidates\` where the chosen numbers sum to \`target\`. Each number in \`candidates\` may only be used once in each combination. Numbers in each combination must be in non-decreasing order, and the combinations themselves must be sorted in lexicographic order. >>> combination_sum2([10, 1, 2, 7, 6, 1, 5], 8) [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]] >>> combination_sum2([2, 4, 6], 3) [] >>> combination_sum2([5], 5) [[5]] >>> combination_sum2([2, 3, 6, 7], 7) [[7]] >>> combination_sum2([2, 5, 2, 1, 2], 5) [[1, 2, 2], [5]]","solution":"def combination_sum2(candidates, target): Given a list of positive integers, \`candidates\`, and a target positive integer, \`target\`, return a list of all unique combinations of \`candidates\` where the chosen numbers sum to \`target\`. Each number in \`candidates\` may only be used once in each combination. Numbers in each combination must be in non-decreasing order, and the combinations themselves must be sorted in lexicographic order. candidates.sort() result = [] def backtrack(start, path, target): if target == 0: result.append(path) return if target < 0: return for i in range(start, len(candidates)): if i > start and candidates[i] == candidates[i - 1]: continue backtrack(i + 1, path + [candidates[i]], target - candidates[i]) backtrack(0, [], target) return result"},{"question":"def count_wealthy_rows_and_columns(mat): Returns the count of rows and columns that contain at least one 1. >>> count_wealthy_rows_and_columns([ [0, 0, 0], [0, 0, 0], [0, 0, 0] ]) 0 >>> count_wealthy_rows_and_columns([ [1, 1, 1], [1, 1, 1], [1, 1, 1] ]) 6 >>> count_wealthy_rows_and_columns([ [0, 1, 0], [0, 0, 0], [1, 0, 0] ]) 4 >>> count_wealthy_rows_and_columns([ [0, 0, 0], [0, 1, 0], [0, 0, 0] ]) 2 >>> count_wealthy_rows_and_columns([ [1, 0, 0], [0, 1, 0], [0, 0, 1] ]) 6 >>> count_wealthy_rows_and_columns([ [0, 0, 0], [0, 0, 0], [0, 1, 0] ]) 2 >>> count_wealthy_rows_and_columns([ [0, 0, 0], [1, 0, 0], [0, 0, 0] ]) 2","solution":"def count_wealthy_rows_and_columns(mat): Returns the count of rows and columns that contain at least one 1. n = len(mat) wealthy_rows = 0 wealthy_columns = 0 # Counting wealthy rows for row in mat: if 1 in row: wealthy_rows += 1 # Counting wealthy columns for col in range(n): for row in range(n): if mat[row][col] == 1: wealthy_columns += 1 break return wealthy_rows + wealthy_columns"},{"question":"def smallest_rectangle_containing_black_pixels(grid: List[List[int]]) -> List[int]: Given a binary matrix grid, finds the smallest sub-rectangle that contains all the black pixels. Args: grid (List[List[int]]): 0-indexed n x n binary matrix representing an image. Returns: List[int]: A list [r1, c1, r2, c2], the coordinates of the smallest sub-rectangle containing all black pixels. >>> smallest_rectangle_containing_black_pixels([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) [] >>> smallest_rectangle_containing_black_pixels([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) [1, 1, 1, 1] >>> smallest_rectangle_containing_black_pixels([ ... [0, 0, 0], ... [1, 1, 1], ... [0, 0, 0] ... ]) [1, 0, 1, 2] >>> smallest_rectangle_containing_black_pixels([ ... [0, 1, 0], ... [0, 1, 0], ... [0, 1, 0] ... ]) [0, 1, 2, 1] >>> smallest_rectangle_containing_black_pixels([ ... [0, 0, 0, 0], ... [0, 1, 0, 0], ... [0, 1, 1, 0], ... [0, 0, 0, 0] ... ]) [1, 1, 2, 2]","solution":"def smallest_rectangle_containing_black_pixels(grid): Given a binary matrix grid, finds the smallest sub-rectangle that contains all the black pixels. Args: grid (List[List[int]]): 0-indexed n x n binary matrix representing an image. Returns: List[int]: A list [r1, c1, r2, c2], the coordinates of the smallest sub-rectangle containing all black pixels. n = len(grid) min_row, min_col = n, n max_row, max_col = -1, -1 for r in range(n): for c in range(n): if grid[r][c] == 1: min_row = min(min_row, r) max_row = max(max_row, r) min_col = min(min_col, c) max_col = max(max_col, c) if min_row == n: return [] return [min_row, min_col, max_row, max_col]"},{"question":"def max_widgets(widgets: List[int], cooldown: int) -> int: Returns the maximum number of widgets that can be produced considering the cooldown constraints. Parameters: widgets (List[int]): List of production efficiencies of the machines. cooldown (int): Cooldown period after each use of a machine. Returns: int: Maximum number of widgets that can be produced. >>> max_widgets([5], 0) 5 >>> max_widgets([5], 1) 5 >>> max_widgets([5], 2) 5 >>> max_widgets([7, 7, 7], 1) 21 >>> max_widgets([7, 7, 7], 2) 21 >>> max_widgets([3, 5, 7], 1) 15 >>> max_widgets([2, 4, 6, 8], 3) 20 >>> max_widgets([1, 2, 3], 100) 6 >>> max_widgets([10, 20, 30], 50) 60","solution":"def max_widgets(widgets, cooldown): Returns the maximum number of widgets that can be produced considering the cooldown constraints. Parameters: widgets (List[int]): List of production efficiencies of the machines. cooldown (int): Cooldown period after each use of a machine. Returns: int: Maximum number of widgets that can be produced. if cooldown < 0: raise ValueError(\\"Cooldown period must be non-negative.\\") # The best way to solve this is to use each machine once and then follow the cooldown period. # Since t is large, we are focusing on the pattern and not the exact value of t. # The sum of widgets produced in a cycle of (cooldown + 1) periods where each machine is used once in each cycle. total_widgets = sum(widgets) # In each cycle of \`cooldown + 1\` periods, each machine will be used once to produce their widgets. return total_widgets # Example usage: # widgets = [3, 5, 7] # cooldown = 2 # print(max_widgets(widgets, cooldown)) # Expected output: 15"},{"question":"def max_bands(bands: List[Tuple[int, int]], duration: int) -> int: Find the maximum number of non-overlapping bands that can perform in the given duration. :param bands: List of tuples where each tuple contains (start, end) time. :param duration: Total duration of the festival. :return: Maximum number of non-overlapping bands. >>> max_bands([], 10) 0 >>> max_bands([(1, 5)], 10) 1 >>> max_bands([(1, 15)], 10) 0 >>> max_bands([(1, 4), (5, 8), (9, 12)], 12) 3 >>> max_bands([(1, 4), (3, 6), (5, 8)], 10) 2 >>> max_bands([(1, 3), (2, 5), (4, 6), (7, 9)], 9) 3 >>> max_bands([(1, 5), (2, 5), (3, 5)], 5) 1","solution":"def max_bands(bands, duration): Find the maximum number of non-overlapping bands that can perform in the given duration. :param bands: List of tuples where each tuple contains (start, end) time. :param duration: Total duration of the festival. :return: Maximum number of non-overlapping bands. # Sort the bands based on their end times bands.sort(key=lambda x: x[1]) # Initialize variables to track the end time of the last selected band and the count of bands last_end_time = -1 count = 0 # Iterate through the sorted bands list for start, end in bands: # If the current band's start time is after the last selected band's end time if start > last_end_time and end <= duration: # Select this band last_end_time = end count += 1 return count"},{"question":"def largestRectangleArea(heights: List[int]) -> int: Calculate the largest rectangular area in a histogram given a list of building heights. >>> largestRectangleArea([]) 0 >>> largestRectangleArea([5]) 5 >>> largestRectangleArea([2, 2, 2, 2]) 8 >>> largestRectangleArea([1, 2, 3, 4, 5]) 9 >>> largestRectangleArea([5, 4, 3, 2, 1]) 9 >>> largestRectangleArea([2, 1, 5, 6, 2, 3]) 10","solution":"def largestRectangleArea(heights): Calculate the largest rectangular area in a histogram. :param heights: List of heights of the histogram's bars. :type heights: List[int] :return: The largest rectangular area. :rtype: int stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index) max_area = max(max_area, area) return max_area"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_of_leaves_at_min_depth(root: TreeNode) -> int: Returns the sum of all leaf nodes that are at the minimum depth of the tree. The minimum depth is defined as the shortest distance from the root node to any leaf node. >>> sum_of_leaves_at_min_depth(None) == 0 >>> root = TreeNode(1) >>> sum_of_leaves_at_min_depth(root) == 1 >>> root = TreeNode(1, TreeNode(2), TreeNode(3)) >>> sum_of_leaves_at_min_depth(root) == 5 >>> root = TreeNode(1, TreeNode(2, TreeNode(4)), TreeNode(3, TreeNode(5), TreeNode(6))) >>> sum_of_leaves_at_min_depth(root) == 15 >>> root = TreeNode(1, TreeNode(2, TreeNode(4)), TreeNode(3, TreeNode(5))) >>> sum_of_leaves_at_min_depth(root) == 9 >>> root = TreeNode(1, TreeNode(2), TreeNode(3, TreeNode(4, TreeNode(6), TreeNode(7)), TreeNode(5))) >>> sum_of_leaves_at_min_depth(root) == 2","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sumOfLeavesAtMinDepth(root): if not root: return 0 from collections import deque queue = deque([(root, 0)]) min_depth = float('inf') sum_leaves = 0 while queue: node, depth = queue.popleft() if not node.left and not node.right: if depth < min_depth: min_depth = depth sum_leaves = node.val elif depth == min_depth: sum_leaves += node.val if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1)) return sum_leaves"},{"question":"def min_operations_to_empty_string(s: str, k: int) -> int: Returns the minimum number of operations required to make the string empty by removing substrings containing at most one distinct character. >>> min_operations_to_empty_string(\\"\\", 1) 0 >>> min_operations_to_empty_string(\\"a\\", 1) 1 >>> min_operations_to_empty_string(\\"aaa\\", 3) 1 >>> min_operations_to_empty_string(\\"aaabb\\", 2) 3 >>> min_operations_to_empty_string(\\"aaabbb\\", 2) 4 >>> min_operations_to_empty_string(\\"abc\\", 10) 3 >>> min_operations_to_empty_string(\\"aaa\\", 1) 3 >>> min_operations_to_empty_string(\\"aabac\\", 1) 5","solution":"def min_operations_to_empty_string(s, k): Returns the minimum number of operations required to make the string empty by removing substrings containing at most one distinct character. current_char = '' count = 0 operations = 0 for char in s: if char == current_char: count += 1 else: # Increment operations for the previous substring if count > 0: operations += (count + k - 1) // k current_char = char count = 1 # Add operations for the last substring if count > 0: operations += (count + k - 1) // k return operations"},{"question":"def can_partition_into_three_equal_sum_subarrays(arr): Determines if the array can be partitioned into three contiguous subarrays with equal sum. Parameters: arr (list): The input array of integers. Returns: bool: True if the array can be partitioned into three equal sum subarrays, False otherwise. >>> can_partition_into_three_equal_sum_subarrays([0, 2, 1, -6, 6, -7, 9, 1, 2, 0, 1]) True >>> can_partition_into_three_equal_sum_subarrays([0, 2, 1, -6, 6, 7, 9, -1, 2, 0, 1]) False Test cases: >>> can_partition_into_three_equal_sum_subarrays([3, 3, 3, 3]) False >>> can_partition_into_three_equal_sum_subarrays([1, 1, 1]) True >>> can_partition_into_three_equal_sum_subarrays([1, 1, 1, 1]) False >>> can_partition_into_three_equal_sum_subarrays([]) False >>> can_partition_into_three_equal_sum_subarrays([1, 2, 3, 4, 5, 6]) False >>> can_partition_into_three_equal_sum_subarrays([0, 0, 0, 0, 0]) True >>> can_partition_into_three_equal_sum_subarrays([1000000000, -1000000000, 0, 1000000000, -1000000000, 0]) True","solution":"def can_partition_into_three_equal_sum_subarrays(arr): Determines if the array can be partitioned into three contiguous subarrays with equal sum. Parameters: arr (list): The input array of integers. Returns: bool: True if the array can be partitioned into three equal sum subarrays, False otherwise. total_sum = sum(arr) if total_sum % 3 != 0: return False target_sum = total_sum // 3 subarray_sum = 0 count = 0 for num in arr: subarray_sum += num if subarray_sum == target_sum: count += 1 subarray_sum = 0 return count >= 3"},{"question":"def num_decodings(s: str) -> int: Given a string \`s\` that consists of only digits, return the number of ways to decode it assuming the following mapping: '1' -> 'A', '2' -> 'B', ..., '26' -> 'Z'. Note that the input string '0' does not represent any valid character and should be handled accordingly. >>> num_decodings(\\"1\\") == 1 >>> num_decodings(\\"9\\") == 1 >>> num_decodings(\\"0\\") == 0 >>> num_decodings(\\"12\\") == 2 # \\"AB\\" and \\"L\\" >>> num_decodings(\\"26\\") == 2 # \\"BF\\" and \\"Z\\" >>> num_decodings(\\"10\\") == 1 # \\"J\\" >>> num_decodings(\\"27\\") == 1 # \\"BG\\" >>> num_decodings(\\"226\\") == 3 # \\"BZ\\", \\"VF\\", \\"BBF\\" >>> num_decodings(\\"1234\\") == 3 # \\"ABCD\\", \\"LCD\\", \\"AWD\\" >>> num_decodings(\\"101\\") == 1 # \\"JA\\" >>> num_decodings(\\"\\") == 0 >>> num_decodings(\\"011\\") == 0 # Invalid string starting with '0' >>> num_decodings(\\"301\\") == 0 # Invalid two digit decoding includes '30' >>> num_decodings(\\"110\\") == 1 # \\"KA\\"","solution":"def num_decodings(s): Returns the number of ways to decode a string of digits with the given mapping. if not s or s[0] == '0': return 0 n = len(s) dp = [0] * (n + 1) dp[0] = dp[1] = 1 for i in range(2, n + 1): one_digit = int(s[i-1]) two_digits = int(s[i-2:i]) if 1 <= one_digit <= 9: dp[i] += dp[i-1] if 10 <= two_digits <= 26: dp[i] += dp[i-2] return dp[n]"},{"question":"def count_buildings_with_sunlight(arr: List[int]) -> int: Returns the number of buildings that will get sunlight. :param arr: List of integers representing the heights of buildings. :return: Integer representing the count of buildings receiving sunlight. >>> count_buildings_with_sunlight([3, 2, 5, 4, 6]) 3 >>> count_buildings_with_sunlight([1, 2, 3, 4, 5]) 5 >>> count_buildings_with_sunlight([5, 4, 3, 2, 1]) 1 >>> count_buildings_with_sunlight([5]) 1 >>> count_buildings_with_sunlight([3, 3, 3, 4, 4, 4, 5, 5, 5]) 3 >>> count_buildings_with_sunlight([]) 0","solution":"def count_buildings_with_sunlight(arr): Returns the number of buildings that will get sunlight. :param arr: List of integers representing the heights of buildings. :return: Integer representing the count of buildings receiving sunlight. if not arr: return 0 max_height = arr[0] count = 1 for height in arr[1:]: if height > max_height: count += 1 max_height = height return count"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def rightSideView(root): Given the root of a binary tree, returns the right side view of the tree. >>> rightSideView(None) [] >>> rightSideView(TreeNode(1)) [1]","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def rightSideView(root): Given the root of a binary tree, returns the right side view of the tree. if not root: return [] right_view = [] queue = [(root, 0)] while queue: node, level = queue.pop(0) if len(right_view) == level: right_view.append(node.val) else: right_view[level] = node.val if node.left: queue.append((node.left, level + 1)) if node.right: queue.append((node.right, level + 1)) return right_view"},{"question":"def count_inversions(nums: List[int]) -> int: Returns the number of inversions in the list nums. An inversion is a pair of indices (i, j) such that i < j and nums[i] > nums[j]. >>> count_inversions([1, 2, 3, 4, 5]) 0 >>> count_inversions([1, 3, 2, 4, 5]) 1 >>> count_inversions([2, 4, 1, 3, 5]) 3 >>> count_inversions([5, 4, 3, 2, 1]) 10 >>> count_inversions([1, 1, 1, 1, 1]) 0 >>> count_inversions([3, 3, 1, 2, 2, 1]) 10 >>> count_inversions([]) 0","solution":"def count_inversions(nums): Returns the number of inversions in the list nums. def merge_and_count(arr, temp_arr, left, mid, right): i = left # Starting index for left subarray j = mid + 1 # Starting index for right subarray k = left # Starting index to be sorted inv_count = 0 # Conditions are checked to ensure that i doesn't exceed mid and j doesn't exceed right while i <= mid and j <= right: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: # There are mid - i inversions because all elements left to i in the left subarray # are greater than arr[j] temp_arr[k] = arr[j] inv_count += (mid-i + 1) j += 1 k += 1 # Copy the remaining elements of left subarray, if any while i <= mid: temp_arr[k] = arr[i] i += 1 k += 1 # Copy the remaining elements of right subarray, if any while j <= right: temp_arr[k] = arr[j] j += 1 k += 1 # Copy the sorted subarray into Original array for i in range(left, right + 1): arr[i] = temp_arr[i] return inv_count def merge_sort_and_count(arr, temp_arr, left, right): inv_count = 0 if left < right: mid = (left + right)//2 inv_count += merge_sort_and_count(arr, temp_arr, left, mid) inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right) inv_count += merge_and_count(arr, temp_arr, left, mid, right) return inv_count return merge_sort_and_count(nums, [0]*len(nums), 0, len(nums)-1)"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def buildTree(preorder, inorder): Reconstructs a binary tree from its preorder and inorder traversal sequences. :param preorder: List[int] - The preorder traversal sequence :param inorder: List[int] - The inorder traversal sequence :return: TreeNode - The root of the reconstructed binary tree pass def tree_to_list_preorder(root): Helper function to convert a tree to a list using preorder traversal. if not root: return [] return [root.value] + tree_to_list_preorder(root.left) + tree_to_list_preorder(root.right) def test_build_tree(): # Test case 1 preorder = [3, 9, 20, 15, 7] inorder = [9, 3, 15, 20, 7] root = buildTree(preorder, inorder) assert tree_to_list_preorder(root) == preorder # Test case 2 preorder = [1, 2, 4, 5, 3, 6, 7] inorder = [4, 2, 5, 1, 6, 3, 7] root = buildTree(preorder, inorder) assert tree_to_list_preorder(root) == preorder # Test case 3: Single node preorder = [1] inorder = [1] root = buildTree(preorder, inorder) assert tree_to_list_preorder(root) == preorder # Test case 4: Empty tree preorder = [] inorder = [] root = buildTree(preorder, inorder) assert tree_to_list_preorder(root) == preorder # Test case 5: Complex tree preorder = [1, 2, 4, 10, 5, 3, 6, 7] inorder = [10, 4, 2, 5, 1, 6, 3, 7] root = buildTree(preorder, inorder) assert tree_to_list_preorder(root) == preorder","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def buildTree(preorder, inorder): Reconstructs a binary tree from its preorder and inorder traversal sequences. :param preorder: List[int] - The preorder traversal sequence :param inorder: List[int] - The inorder traversal sequence :return: TreeNode - The root of the reconstructed binary tree if not preorder or not inorder: return None # Build a map of value -> index for inorder sequence for quick lookup inorder_index_map = {value: index for index, value in enumerate(inorder)} # Recursive helper function to construct the tree def helper(pre_left, pre_right, in_left, in_right): if pre_left > pre_right or in_left > in_right: return None # Root value is the first element in the current preorder segment root_value = preorder[pre_left] root = TreeNode(root_value) # Index of the root value in the inorder sequence in_root_index = inorder_index_map[root_value] # Number of nodes in the left subtree left_subtree_size = in_root_index - in_left # Construct left and right subtrees root.left = helper(pre_left + 1, pre_left + left_subtree_size, in_left, in_root_index - 1) root.right = helper(pre_left + left_subtree_size + 1, pre_right, in_root_index + 1, in_right) return root return helper(0, len(preorder) - 1, 0, len(inorder) - 1)"},{"question":"def minimumBombs(grid: List[List[int]]) -> int: Returns the minimum number of bombs required to destroy all enemy units on the map. >>> minimumBombs([[0, 1], [0, 0]]) 1 >>> minimumBombs([[1, 1], [1, 0]]) 1 >>> minimumBombs([[1, 0, 1], [0, 1, 0], [1, 0, 1]]) 5 >>> minimumBombs([[0, 0], [0, 0]]) 0 >>> minimumBombs([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]) 1","solution":"def minimumBombs(grid): from collections import deque def bfs(r, c): directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] queue = deque([(r, c)]) visited.add((r, c)) while queue: x, y = queue.popleft() for dr, dc in directions: nr, nc = x + dr, y + dc if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and (nr, nc) not in visited and grid[nr][nc] == 1: visited.add((nr, nc)) queue.append((nr, nc)) visited = set() bombs = 0 for r in range(len(grid)): for c in range(len(grid[0])): if grid[r][c] == 1 and (r, c) not in visited: bombs += 1 bfs(r, c) return bombs"},{"question":"def max_bitwise_and(nums: List[int]) -> int: Returns the maximum bitwise AND value of any contiguous subarray of nums. >>> max_bitwise_and([5]) 5 >>> max_bitwise_and([0, 0, 0]) 0 >>> max_bitwise_and([5, 3, 7, 1, 4]) 7 >>> max_bitwise_and([12, 15, 7, 3, 2, 14, 11]) 15 >>> max_bitwise_and([1, 2, 3, 4, 5, 6, 7]) 7 >>> max_bitwise_and([7, 6, 5, 4, 3, 2, 1]) 7 >>> max_bitwise_and([7, 7, 7, 7]) 7 >>> max_bitwise_and([8, 1, 2, 6, 3, 4, 5]) 8","solution":"def max_bitwise_and(nums): Returns the maximum bitwise AND value of any contiguous subarray of nums. if not nums: return 0 max_and = 0 for i in range(len(nums)): current_and = nums[i] max_and = max(max_and, current_and) for j in range(i + 1, len(nums)): current_and &= nums[j] max_and = max(max_and, current_and) if current_and == 0: break return max_and"},{"question":"def aliceWins(nums): Determine if Alice wins the game given the initial piles of stones. Parameters: nums (list): A list of integers representing the number of stones in each pile. Returns: bool: True if Alice wins, False if Bob wins. Example: >>> aliceWins([3, 4, 5, 6]) True >>> aliceWins([1, 1, 1, 1]) True","solution":"def aliceWins(nums): Determine if Alice wins the game given the initial piles of stones. Parameters: nums (list): A list of integers representing the number of stones in each pile. Returns: bool: True if Alice wins, False if Bob wins. # Since n is even and Alice always goes first, Alice can always force a win by # mirroring Bob's moves. Essentially the strategy involves always taking stones # from the same piles Bob takes stones from in the last round. # The result is always determined by the fact that n is even and Alice starts. return True"},{"question":"from typing import List def min_keys_to_form_string(words: List[str], s: str) -> int: You are given an array of strings \`words\` and a string \`s\`. Each string in \`words\` can be thought of as a key, where the string \`s\` is created by concatenating exactly one or more keys from \`words\` in any order. Return the minimum number of keys needed to form the string \`s\` using elements from \`words\`. If it is not possible to form \`s\` from \`words\`, return \`-1\`. >>> min_keys_to_form_string([\\"ab\\", \\"bc\\", \\"cd\\"], \\"abcd\\") 2 >>> min_keys_to_form_string([\\"ab\\", \\"bc\\", \\"cd\\"], \\"abc\\") -1 >>> min_keys_to_form_string([\\"a\\", \\"ab\\", \\"bc\\"], \\"abc\\") 2 >>> min_keys_to_form_string([\\"hello\\"], \\"hello\\") 1 >>> min_keys_to_form_string([\\"a\\", \\"b\\", \\"ab\\"], \\"ab\\") 1 >>> min_keys_to_form_string([\\"a\\", \\"b\\", \\"ab\\"], \\"abc\\") -1 >>> min_keys_to_form_string([\\"a\\", \\"b\\"], \\"\\") 0","solution":"def min_keys_to_form_string(words, s): from collections import Counter import sys def dp(target): if target in memo: return memo[target] target_count = Counter(target) ans = sys.maxsize for word in words: if all(target_count[char] >= count for char, count in Counter(word).items()): new_target = '' for char, count in target_count.items(): if count > Counter(word)[char]: new_target += char * (count - Counter(word)[char]) ans = min(ans, dp(new_target) + 1) memo[target] = ans return ans # Memoization dictionary memo = {} memo[''] = 0 result = dp(s) return result if result != sys.maxsize else -1"},{"question":"def find_duplicate(nums: List[int]) -> int: Finds and returns the duplicate number in the list nums. Args: nums (list): A list of integers with n+1 elements where each element is an integer from 1 to n. Returns: int: The duplicate integer in the list. # Find the intersection point of two runners. # Find the entrance to the cycle.","solution":"def find_duplicate(nums): Finds and returns the duplicate number in the list nums. Args: nums (list): A list of integers with n+1 elements where each element is an integer from 1 to n. Returns: int: The duplicate integer in the list. slow = nums[0] fast = nums[0] # Phase 1: Finding the intersection point of two runners. while True: slow = nums[slow] fast = nums[nums[fast]] if slow == fast: break # Phase 2: Finding the entrance to the cycle. slow = nums[0] while slow != fast: slow = nums[slow] fast = nums[fast] return slow"},{"question":"from typing import List def min_jumps(nums: List[int]) -> int: Determine the minimum number of jumps needed to reach the last position starting from the first position in the array. >>> min_jumps([2, 3, 1, 1, 4]) 2 >>> min_jumps([0]) 0 >>> min_jumps([3, 2, 1, 0, 4]) -1 >>> min_jumps([1, 0]) 1 >>> min_jumps([1, 4, 3, 2, 6, 7]) 2 >>> min_jumps([1, 2, 1, 1, 1]) 3 >>> min_jumps([1, 2, 3, 0, 0, 0, 0]) -1","solution":"def min_jumps(nums): Determine the minimum number of jumps needed to reach the last position starting from the first position in the array. if not nums or len(nums) == 1: return 0 n = len(nums) jumps = 0 current_end = 0 farthest = 0 for i in range(n - 1): farthest = max(farthest, i + nums[i]) if i == current_end: jumps += 1 current_end = farthest if current_end >= n - 1: return jumps return -1 if current_end < n - 1 else jumps"},{"question":"from typing import List, Tuple def find_longest_run_and_boundaries(arr: List[int]) -> Tuple[int, List[int]]: Finds the length of the longest run and the list of run-boundaries in the given array. A run is defined as a contiguous subsequence of the same number appearing multiple times in sequence. A run-boundary is the index position where a new run starts. Parameters: arr (List[int]): The input array of integers. Returns: tuple: A tuple containing the length of the longest run and the list of run-boundaries. pass # Unit tests def test_empty_array(): assert find_longest_run_and_boundaries([]) == (0, []) def test_single_element_array(): assert find_longest_run_and_boundaries([1]) == (1, [0]) def test_no_repeated_elements(): assert find_longest_run_and_boundaries([1, 2, 3, 4]) == (1, [0, 1, 2, 3]) def test_all_same_elements(): assert find_longest_run_and_boundaries([2, 2, 2, 2]) == (4, [0]) def test_mixed_elements(): assert find_longest_run_and_boundaries([1, 2, 2, 3, 3, 3, 2]) == (3, [0, 1, 3, 6]) def test_longest_run_at_start(): assert find_longest_run_and_boundaries([4, 4, 4, 2, 3, 3, 2]) == (3, [0, 3, 4, 6]) def test_longest_run_at_end(): assert find_longest_run_and_boundaries([1, 2, 1, 1, 1, 1]) == (4, [0, 1, 2]) def test_multiple_runs_same_length(): assert find_longest_run_and_boundaries([1, 1, 2, 2, 3, 3]) == (2, [0, 2, 4])","solution":"def find_longest_run_and_boundaries(arr): Finds the length of the longest run and the list of run-boundaries in the given array. A run is defined as a contiguous subsequence of the same number appearing multiple times in sequence. A run-boundary is the index position where a new run starts. Parameters: arr (List[int]): The input array of integers. Returns: tuple: A tuple containing the length of the longest run and the list of run-boundaries. if not arr: return 0, [] max_length = 1 current_length = 1 boundaries = [0] for i in range(1, len(arr)): if arr[i] == arr[i-1]: current_length += 1 else: if current_length > max_length: max_length = current_length current_length = 1 boundaries.append(i) if current_length > max_length: max_length = current_length return max_length, boundaries"},{"question":"def max_sum_of_k_subarrays(nums, k): Returns the maximum possible value of the sum of the maximum element from each subarray when split into exactly k subarrays. pass def test_example1(): nums = [1, 2, 3, 4, 5, 6] k = 3 result = max_sum_of_k_subarrays(nums, k) assert result == 15 # Split should be [1, 2, 3] + [4] + [5, 6] def test_example2(): nums = [5, 3, 2, 6, 2] k = 2 result = max_sum_of_k_subarrays(nums, k) assert result == 11 # Split should be [5, 3, 2] + [6, 2] def test_single_element(): nums = [10] k = 1 result = max_sum_of_k_subarrays(nums, k) assert result == 10 # Single element def test_all_same_elements(): nums = [4, 4, 4, 4] k = 2 result = max_sum_of_k_subarrays(nums, k) assert result == 8 # Split should be [4, 4] + [4, 4], but since they are identical, max sum is the same regardless of split def test_large_k(): nums = [1, 4, 2, 5, 3] k = 5 result = max_sum_of_k_subarrays(nums, k) assert result == 15 # Each element in its own subarray def test_k_equals_length(): nums = [2, 7, 1, 8, 9] k = 5 result = max_sum_of_k_subarrays(nums, k) assert result == 27 # Each element in its own subarray","solution":"def max_sum_of_k_subarrays(nums, k): Returns the maximum possible value of the sum of the maximum element from each subarray when split into exactly k subarrays. n = len(nums) # Special case: If k equals the length of the list if k == n: return sum(nums) # Use dynamic programming to keep track of the max values dp = [[0] * (k + 1) for _ in range(n)] for i in range(n): dp[i][1] = max(nums[:i+1]) for subarray_count in range(2, k + 1): for i in range(subarray_count - 1, n): current_max, max_sum = float('-inf'), float('-inf') for j in range(i, subarray_count - 2, -1): current_max = max(current_max, nums[j]) max_sum = max(max_sum, (dp[j-1][subarray_count-1] if j > 0 else 0) + current_max) dp[i][subarray_count] = max_sum return dp[n-1][k]"},{"question":"def max_depth(s: str) -> int: Returns the maximum depth of nested brackets in the string s. >>> max_depth(\\"(a)(b)(c)\\") 1 >>> max_depth(\\"((a)b(c))\\") 2 >>> max_depth(\\"(a((b)c))\\") 3 >>> max_depth(\\"abcd\\") 0 >>> max_depth(\\"(a(bc(de(fg)h)(ij))k)\\") 4 >>> max_depth(\\"(a(b))\\") 2","solution":"def max_depth(s): Returns the maximum depth of nested brackets in the string s. max_depth = 0 current_depth = 0 for char in s: if char == '(': current_depth += 1 if current_depth > max_depth: max_depth = current_depth elif char == ')': current_depth -= 1 return max_depth"},{"question":"def max_sum_with_operation(arr: List[int], d: int) -> int: Given an integer array \`arr\` and an integer \`d\`, you can perform the following operation on the array at most once: choose any subarray of \`arr\` and increment each element of that subarray by \`d\`. Return the maximum possible sum of the array that can be obtained by performing this operation. If no operation is performed, return the sum of the original array. >>> max_sum_with_operation([1, 2, 3], 0) 6 >>> max_sum_with_operation([5], 2) 7 >>> max_sum_with_operation([1, 2, 3], 1) 9 >>> max_sum_with_operation([-1, -1, -1], 1) 0 >>> max_sum_with_operation([1, -2, 3], 1) 5 >>> max_sum_with_operation([1, 2, 3], 100) 306 >>> max_sum_with_operation([1, 2, 3], -1) 6","solution":"def max_sum_with_operation(arr, d): Returns maximum possible sum of the array after optionally incrementing a subarray's elements by \`d\`. Parameters: arr (list of int): The array of integers. d (int): The increment value. Returns: int: The maximum possible sum of the array. n = len(arr) current_sum = sum(arr) if d <= 0: return current_sum max_increment = 0 for start in range(n): increment_sum = 0 for end in range(start, n): increment_sum += d max_increment = max(max_increment, increment_sum) return current_sum + max_increment"},{"question":"import heapq class MedianFinder: Design a class that allows the addition of a stream of integers and calculates the median of all integers seen so far. - MedianFinder() initializes the data structure. - void addNum(int num) adds the integer num to the data stream. - double findMedian() returns the median of all integers added so far. >>> mf = MedianFinder() >>> mf.addNum(1) >>> mf.findMedian() 1 >>> mf.addNum(2) >>> mf.findMedian() 1.5 >>> mf.addNum(3) >>> mf.findMedian() 2 >>> mf.addNum(4) >>> mf.findMedian() 2.5 def __init__(self): pass def addNum(self, num: int): pass def findMedian(self) -> float: pass","solution":"import heapq class MedianFinder: def __init__(self): Initializes the MedianFinder object. # max heap to store the smaller half of the numbers self.small = [] # min heap to store the larger half of the numbers self.large = [] def addNum(self, num: int): Adds an integer num to the data stream. # Add to max heap (largest of the small half) heapq.heappush(self.small, -num) # Balance the heaps by ensuring that every number in the large heap # is greater than every number in the small heap if self.small and self.large and (-self.small[0] > self.large[0]): heapq.heappush(self.large, -heapq.heappop(self.small)) # Balance the sizes of the two heaps if len(self.small) > len(self.large) + 1: heapq.heappush(self.large, -heapq.heappop(self.small)) if len(self.large) > len(self.small): heapq.heappush(self.small, -heapq.heappop(self.large)) def findMedian(self) -> float: Finds and returns the median of all integers added so far. # If both heaps are of equal size, the median is the average of the two middle elements if len(self.small) == len(self.large): return (-self.small[0] + self.large[0]) / 2.0 # If the heaps are of unequal size, the median is the middle element else: return -self.small[0]"},{"question":"class CustomQueue: CustomQueue simulates a queue-like structure with range sum query support. Operations: - CustomQueue(int capacity): Initializes the queue with a fixed capacity. - void enqueue(int value): Adds the value to the end of the queue if it is not full. - int dequeue(): Removes the element from the front of the queue and returns it. Returns -1 if the queue is empty. - int rangeSum(int start, int end): Returns the sum of the elements in the queue from index start to index end inclusive. >>> cq = CustomQueue(3) >>> cq.dequeue() == -1 # queue is empty now, should return -1 def test_range_sum(): cq = CustomQueue(5) cq.enqueue(1) cq.enqueue(2) cq.enqueue(3) cq.enqueue(4) assert cq.rangeSum(0, 2) == 6 # range sum from index 0 to 2, should return 1+2+3 = 6 assert cq.rangeSum(1, 3) == 9 # range sum from index 1 to 3, should return 2+3+4 = 9 assert cq.rangeSum(2, 2) == 3 # range sum from index 2 to 2, should return 3 assert cq.rangeSum(0, 4) == -1 # out of range, should return -1 def test_enqueue_full_capacity(): cq = CustomQueue(2) cq.enqueue(1) cq.enqueue(2) cq.enqueue(3) # This enqueue should be ignored as the queue is full assert cq.rangeSum(0, 1) == 3 # only 1 and 2 should be in the queue, sum = 3 def test_rangeSum_empty_queue(): cq = CustomQueue(3) assert cq.rangeSum(0, 2) == -1 # queue is empty, out of range, should return -1","solution":"class CustomQueue: def __init__(self, capacity): self.capacity = capacity self.queue = [] def enqueue(self, value): if len(self.queue) < self.capacity: self.queue.append(value) def dequeue(self): if self.queue: return self.queue.pop(0) return -1 def rangeSum(self, start, end): if 0 <= start <= end < len(self.queue): return sum(self.queue[start:end+1]) return -1"},{"question":"def max_land_cells(grid, k): Returns the maximum number of land cells you can obtain on the grid after placing exactly k bridges. Arguments: grid -- 2D list representing the map where 1 represents land, 0 represents water k -- integer representing the number of bridges >>> max_land_cells([[1, 0], [0, 1]], 2) 4 >>> max_land_cells([[1, 1], [1, 1]], 2) 4 >>> max_land_cells([[1, 1, 0]], 1) 5 >>> max_land_cells([[1, 0, 0], [0, 0, 0], [0, 0, 1]], 1) 3 >>> max_land_cells([[1, 1, 0, 0], [0, 0, 1, 0], [1, 0, 0, 0]], 10) 12","solution":"def max_land_cells(grid, k): Returns the maximum number of land cells after placing k bridges. m, n = len(grid), len(grid[0]) def dfs(x, y): if x < 0 or x >= m or y < 0 or y >= n or visited[x][y] or grid[x][y] == 0: return 0 visited[x][y] = True land = 1 land += dfs(x + 1, y) land += dfs(x - 1, y) land += dfs(x, y + 1) land += dfs(x, y - 1) return land # Find all land cells initially connected and their sizes visited = [[False for _ in range(n)] for _ in range(m)] land_sizes = [] for i in range(m): for j in range(n): if grid[i][j] == 1 and not visited[i][j]: size = dfs(i, j) land_sizes.append(size) # Sort the land size in descending order land_sizes.sort(reverse=True) # Calculate the initial number of land cells initial_land_cells = sum(land_sizes) # Add k to the initial land areas max_land = initial_land_cells + k return min(max_land, m * n)"},{"question":"def min_moves(nums, k): Returns the minimum number of moves required to make all the elements of nums equal, with the constraint that we can perform at most k moves on any single element. >>> min_moves([1, 2, 3], 2) == 2 >>> min_moves([1, 10, 2, 9], 5) == 16 >>> min_moves([1, 2, 3, 100], 3) == -1 >>> min_moves([5, 5, 5, 5], 1) == 0 >>> min_moves([1, 2, 3, 4], 5) == 4","solution":"def min_moves(nums, k): Returns the minimum number of moves required to make all the elements of nums equal, with the constraint that we can perform at most k moves on any single element. # Find the median of the sorted array nums_sorted = sorted(nums) median = nums_sorted[len(nums_sorted) // 2] # Calculate the move count by the difference with the median move_count = sum(abs(num - median) for num in nums_sorted) # Ensure we do not exceed the individual move limit \`k\` if move_count > k * len(nums): return -1 return move_count"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def find_bottom_left_value(root): Find the leftmost value in the last row of the binary tree. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.right.left = TreeNode(5) >>> root.right.right = TreeNode(6) >>> root.right.left.left = TreeNode(7) >>> find_bottom_left_value(root) 7 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> find_bottom_left_value(root) 4 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(3) >>> root.left.left.left = TreeNode(4) >>> find_bottom_left_value(root) 4 >>> root = TreeNode(1) >>> root.right = TreeNode(2) >>> root.right.right = TreeNode(3) >>> root.right.right.right = TreeNode(4) >>> find_bottom_left_value(root) 4","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def find_bottom_left_value(root): Find the leftmost value in the last row of the binary tree. if not root: return None from collections import deque queue = deque([root]) leftmost_value = root.val while queue: num_nodes = len(queue) for i in range(num_nodes): node = queue.popleft() if i == 0: leftmost_value = node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) return leftmost_value"},{"question":"def singleNumber(nums: List[int]) -> int: Returns the integer that appears exactly once in the array. >>> singleNumber([4, 1, 2, 1, 2]) 4 >>> singleNumber([5]) 5 >>> singleNumber([30000, 20000, 30000]) 20000 >>> singleNumber([-1, -2, -1]) -2 >>> singleNumber([-3, 3, -3, 1, 2, 1, 2]) 3 >>> singleNumber([7, 8, 7, 9, 10, 10, 8]) 9","solution":"def singleNumber(nums): Returns the integer that appears exactly once in the list nums. unique_number = 0 for num in nums: unique_number ^= num return unique_number"},{"question":"import math def remaining_volume(h: float, r: float, theta: float) -> float: Calculate the remaining volume of liquid in a cylindrical container when it is tilted. Parameters: h (float): Height of the cylinder r (float): Radius of the cylinder base theta (float): Tilt angle in degrees Returns: float: Remaining volume of liquid in the container >>> math.isclose(remaining_volume(10, 2, 0), math.pi * 2**2 * 10, rel_tol=1e-5) True >>> math.isclose(remaining_volume(10, 2, 45), math.pi * 2**2 * 10, rel_tol=1e-5) True >>> math.isclose(remaining_volume(10, 2, 90), math.pi * 2**2 * 10, rel_tol=1e-5) True >>> remaining_volume(0, 2, 45) == 0 True >>> remaining_volume(10, 0, 45) == 0 True","solution":"import math def remaining_volume(h, r, theta): Calculate the remaining volume of liquid in a cylindrical container when it is tilted. Parameters: h (float): Height of the cylinder r (float): Radius of the cylinder base theta (float): Tilt angle in degrees Returns: float: Remaining volume of liquid in the container # Calculate the volume of the cylinder volume = math.pi * r * r * h return volume"},{"question":"class ConferenceRoom: A class to handle reservations for a conference room. def __init__(self): Initializes the reservation system. def reserve(self, start, end): Reserves the conference room for a meeting from start time to end time (half-open interval [start, end]). Returns True if the room can be reserved without any conflicts, otherwise returns False. >>> room = ConferenceRoom() >>> room.reserve(10, 20) True >>> room.reserve(15, 25) False >>> room.reserve(20, 30) True >>> room.reserve(10, 40) True >>> room.reserve(20, 30) False >>> room.reserve(10, 40) False >>> room.reserve(0, 10) True >>> room.reserve(20, 30) True >>> room.reserve(40, 50) True >>> room.reserve(55, 65) False","solution":"class ConferenceRoom: def __init__(self): Initializes the reservation system. self.reservations = [] def reserve(self, start, end): Reserves the conference room for a meeting from start time to end time (half-open interval [start, end]). Returns True if the room can be reserved without any conflicts, otherwise returns False. for reserved_start, reserved_end in self.reservations: if not (end <= reserved_start or start >= reserved_end): return False self.reservations.append((start, end)) return True"},{"question":"def maxSumSubmatrix(mat, k): Returns the maximum sum of a k x k submatrix within the given matrix 'mat'. If such submatrix does not exist, return 0. pass # Unit tests def test_maxSumSubmatrix_basic(): mat = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] k = 2 assert maxSumSubmatrix(mat, k) == 28 # Submatrix [[5, 6], [8, 9]] def test_maxSumSubmatrix_edge_cases(): mat = [] k = 2 assert maxSumSubmatrix(mat, k) == 0 mat = [[1]] k = 2 assert maxSumSubmatrix(mat, k) == 0 def test_maxSumSubmatrix_single_element_submatrix(): mat = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] k = 1 assert maxSumSubmatrix(mat, k) == 9 # Submatrix [[9]] def test_maxSumSubmatrix_whole_matrix(): mat = [ [1, 2], [3, 4] ] k = 2 assert maxSumSubmatrix(mat, k) == 10 # Submatrix [[1, 2], [3, 4]] def test_maxSumSubmatrix_large_k(): mat = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] k = 3 assert maxSumSubmatrix(mat, k) == 45 # Submatrix [[1, 2, 3], [4, 5, 6], [7, 8, 9]] def test_maxSumSubmatrix_in_the_middle(): mat = [ [1, 1, 1, 1], [1, 5, 5, 1], [1, 5, 5, 1], [1, 1, 1, 1] ] k = 2 assert maxSumSubmatrix(mat, k) == 20 # Submatrix [[5, 5], [5, 5]]","solution":"def maxSumSubmatrix(mat, k): Returns the maximum sum of a k x k submatrix within the given matrix 'mat'. If such submatrix does not exist, return 0. n = len(mat) if n == 0: return 0 m = len(mat[0]) if k > n or k > m: return 0 max_sum = 0 for i in range(n - k + 1): for j in range(m - k + 1): current_sum = 0 for p in range(i, i + k): for q in range(j, j + k): current_sum += mat[p][q] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def add_two_numbers(l1, l2): You are given a singly linked list where each node contains a single digit from 0 to 9. The digits are stored such that the most significant digit is at the head of the list. Write a function to add two such linked lists and return the resulting singly linked list, where the most significant digit is again at the head of the list. The function should return the sum of the two numbers as a linked list in the same format. >>> l1 = list_to_linked_list([7, 2, 4, 3]) >>> l2 = list_to_linked_list([5, 6, 4]) >>> result = add_two_numbers(l1, l2) >>> linked_list_to_list(result) == [7, 8, 0, 7] >>> l1 = list_to_linked_list([2, 4, 3]) >>> l2 = list_to_linked_list([5, 6, 4]) >>> result = add_two_numbers(l1, l2) >>> linked_list_to_list(result) == [8, 0, 7] >>> l1 = list_to_linked_list([0]) >>> l2 = list_to_linked_list([0]) >>> result = add_two_numbers(l1, l2) >>> linked_list_to_list(result) == [0] >>> l1 = list_to_linked_list([9, 9, 9, 9]) >>> l2 = list_to_linked_list([1]) >>> result = add_two_numbers(l1, l2) >>> linked_list_to_list(result) == [1, 0, 0, 0, 0] >>> l1 = list_to_linked_list([9, 9, 9, 9]) >>> l2 = list_to_linked_list([9, 9, 9, 9]) >>> result = add_two_numbers(l1, l2) >>> linked_list_to_list(result) == [1, 9, 9, 9, 8]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def add_two_numbers(l1, l2): # Helper function to reverse a LinkedList def reverse_list(head): prev = None current = head while current: next_node = current.next current.next = prev prev = current current = next_node return prev # Helper function to add two reversed linked lists def add_reversed_lists(l1, l2): dummy_head = ListNode(0) current = dummy_head carry = 0 while l1 or l2 or carry: val1 = l1.val if l1 else 0 val2 = l2.val if l2 else 0 sum_val = val1 + val2 + carry carry = sum_val // 10 new_node = ListNode(sum_val % 10) current.next = new_node current = new_node if l1: l1 = l1.next if l2: l2 = l2.next return dummy_head.next # Reverse both lists to simplify addition l1_reversed = reverse_list(l1) l2_reversed = reverse_list(l2) # Add reversed lists result_reversed = add_reversed_lists(l1_reversed, l2_reversed) # Reverse the result back to correct order result = reverse_list(result_reversed) return result"},{"question":"from typing import List class TaskScheduler: A class used to represent a Task Scheduler with cooling interval. Attributes ---------- tasks : List[str] a list of tasks represented by strings n : int a positive integer representing the cooling interval between two same tasks Methods ------- leastInterval(): Returns the minimum number of intervals needed to execute all tasks. def __init__(self, tasks: List[str], n: int): Initializes the TaskScheduler with tasks and cooling interval n. Args: tasks: List of strings where each string is a task. n: Integer representing the cooling interval. self.tasks = tasks self.n = n def leastInterval(self) -> int: Returns the minimum number of intervals needed to execute all tasks. >>> scheduler = TaskScheduler([\\"A\\", \\"A\\", \\"A\\", \\"B\\", \\"B\\", \\"C\\"], 2) >>> scheduler.leastInterval() 7 >>> scheduler = TaskScheduler([\\"A\\", \\"A\\", \\"A\\", \\"B\\", \\"B\\", \\"B\\"], 0) >>> scheduler.leastInterval() 6 pass","solution":"from collections import Counter class TaskScheduler: def __init__(self, tasks, n): Initializes the TaskScheduler with tasks and cooling interval n. Args: tasks: List of strings where each string is a task. n: Integer representing the cooling interval. self.tasks = tasks self.n = n def leastInterval(self): Returns the minimum number of intervals needed to execute all tasks. task_counts = Counter(self.tasks) max_count = max(task_counts.values()) max_count_tasks = sum(1 for count in task_counts.values() if count == max_count) part_count = max_count - 1 part_length = self.n - (max_count_tasks - 1) empty_slots = part_count * part_length available_tasks = len(self.tasks) - (max_count * max_count_tasks) idles = max(0, empty_slots - available_tasks) return len(self.tasks) + idles"},{"question":"from typing import List def rearrange_string(s: str) -> str: You are given a string \`s\` consisting of lower case English letters that you need to encrypt. The encryption process involves rearranging each letter in the string such that no two adjacent letters are the same. If it is impossible to rearrange the string in such a way, return an empty string. Otherwise, return the rearranged string. >>> rearrange_string(\\"aab\\") in [\\"aba\\", \\"bab\\"] True >>> rearrange_string(\\"aaab\\") '' >>> rearrange_string(\\"a\\") 'a' >>> rearrange_string(\\"ab\\") 'ab' >>> rearrange_string(\\"aa\\") '' >>> rearrange_string(\\"aaabbc\\") in [\\"ababac\\", \\"abacab\\"] True >>> rearrange_string(\\"aaabb\\") 'ababa' >>> rearrange_string(\\"abcdefgh\\") 'abcdefgh' >>> rearrange_string(\\"aaa\\") ''","solution":"import heapq from collections import Counter def rearrange_string(s): counter = Counter(s) max_heap = [(-count, char) for char, count in counter.items()] heapq.heapify(max_heap) prev_count, prev_char = 0, '' result = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) prev_count, prev_char = count + 1, char if len(result) != len(s): return \\"\\" return \\"\\".join(result)"},{"question":"def min_operations_to_divisible(grid: List[List[int]], k: int) -> int: Return the minimum number of operations required to make every element of grid divisible by k. >>> min_operations_to_divisible([[4, 8], [12, 16]], 4) == 0 >>> min_operations_to_divisible([[5]], 3) == 1 >>> min_operations_to_divisible([[2, 3], [4, 5]], 3) == 3 >>> min_operations_to_divisible([[2, 5], [7, 10]], 10) == 10 >>> min_operations_to_divisible([[3, 6], [9, 14]], 7) == 6","solution":"def min_operations_to_divisible(grid, k): m, n = len(grid), len(grid[0]) operations = 0 for i in range(m): for j in range(n): remainder = grid[i][j] % k if remainder != 0: operations += min(remainder, k - remainder) return operations"},{"question":"from typing import List def find_first_occurrence(nums: List[int], target: int) -> int: Returns the index of the first occurrence of target in nums. If target is not present, returns -1. >>> find_first_occurrence([1, 2, 2, 3, 4], 2) 1 >>> find_first_occurrence([1, 2, 3, 4, 5], 5) 4 >>> find_first_occurrence([1, 2, 3, 3, 4, 5], 3) 2 >>> find_first_occurrence([1, 2, 3, 4, 5], 6) -1 >>> find_first_occurrence([1, 1, 1, 2, 3, 3, 4], 1) 0 >>> find_first_occurrence([], 3) -1 >>> find_first_occurrence([3], 3) 0 >>> find_first_occurrence([4], 3) -1","solution":"def find_first_occurrence(nums, target): Returns the index of the first occurrence of target in nums. If target is not present, returns -1. left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] < target: left = mid + 1 elif nums[mid] > target: right = mid - 1 else: if mid == 0 or nums[mid - 1] != target: return mid right = mid - 1 return -1"},{"question":"def lexicographically_smallest_array(arr: List[int], d: int) -> List[int]: Given an integer array \`arr\` of length \`n\` and an integer \`d\`, perform the following operation exactly \`d\` times: select any element at an even index, swap it with the element immediately next to it (which would be at an odd index). If there is no element next to the even index element (i.e., if it is the last element in the array and its index is even), avoid making a move. Return the lexicographically smallest array possible after performing the operation exactly \`d\` times. Parameters: arr (List[int]): The input list of integers. d (int): The number of swaps to perform. Returns: List[int]: The lexicographically smallest list after \`d\` swaps. Examples: >>> lexicographically_smallest_array([4, 2, 3, 1], 1) [2, 4, 1, 3] >>> lexicographically_smallest_array([4, 2, 3, 1], 2) [2, 4, 1, 3]","solution":"def lexicographically_smallest_array(arr, d): n = len(arr) def perform_swap(): for i in range(0, n - 1, 2): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] # Perform the swap operation exactly \`d\` times for _ in range(d): perform_swap() return arr"},{"question":"def can_be_sorted_with_k_operations(nums: List[int], k: int) -> bool: Determines if the array can be sorted in non-decreasing order with exactly k or fewer operations. >>> can_be_sorted_with_k_operations([1, 2, 3, 4], 3) == True >>> can_be_sorted_with_k_operations([3, 4, 1, 2], 2) == True >>> can_be_sorted_with_k_operations([3, 4, 1, 2], 1) == False >>> can_be_sorted_with_k_operations([4, 3, 2, 1], 4) == False >>> can_be_sorted_with_k_operations([1, 2, 3], 0) == True >>> can_be_sorted_with_k_operations([4, 1, 2, 3], 2) == False pass","solution":"def can_be_sorted_with_k_operations(nums, k): Determines if the array can be sorted in non-decreasing order with exactly k or fewer operations. n = len(nums) # Check if already sorted if nums == sorted(nums): return True # Generate all possible rotations for i in range(n): rotated = nums[-i:] + nums[:-i] if rotated == sorted(nums): return True if i <= k else False return False"},{"question":"from typing import Tuple def minimize_longest_split_length(s: str, k: int) -> int: Splits the string \`s\` into \`k\` contiguous strings such that the length of the longest string is minimized. Args: s (str): The input string to be split. k (int): The number of splits. Returns: int: The length of the minimized longest string after splitting. pass Unit Test: from solution import minimize_longest_split_length def test_minimize_longest_split_length_basic(): assert minimize_longest_split_length(\\"abcdefghij\\", 3) == 4 def test_minimize_longest_split_length_two_parts(): assert minimize_longest_split_length(\\"abcdefghij\\", 2) == 5 def test_minimize_longest_split_length_full_split(): assert minimize_longest_split_length(\\"abcdefghij\\", 10) == 1 def test_minimize_longest_split_length_less_splits(): assert minimize_longest_split_length(\\"aabbcc\\", 1) == 6 def test_minimize_longest_split_length_equal_splits(): assert minimize_longest_split_length(\\"aabbcc\\", 3) == 2","solution":"def minimize_longest_split_length(s, k): Splits the string \`s\` into \`k\` contiguous strings such that the length of the longest string is minimized. Args: s (str): The input string to be split. k (int): The number of splits. Returns: int: The length of the minimized longest string after splitting. def can_split(mid): count = 1 current_length = 0 for char in s: if current_length + 1 > mid: count += 1 current_length = 0 current_length += 1 return count <= k left, right = max(len(s) // k, len(s) % k), len(s) while left < right: mid = (left + right) // 2 if can_split(mid): right = mid else: left = mid + 1 return left"},{"question":"def largest_square_submatrix(mat: List[List[int]]) -> int: Return the size \`k\` of the largest square submatrix of \`1\`s present in the given matrix. >>> largest_square_submatrix([]) == 0 >>> largest_square_submatrix([[0]]) == 0 >>> largest_square_submatrix([[1]]) == 1 >>> largest_square_submatrix([[1, 0], [0, 1]]) == 1 >>> largest_square_submatrix([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) == 3 >>> largest_square_submatrix([[0, 1, 1], [1, 1, 1], [1, 1, 1]]) == 2 >>> largest_square_submatrix([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) == 0 >>> largest_square_submatrix([[1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0]]) == 2","solution":"def largest_square_submatrix(mat): if not mat or not mat[0]: return 0 rows, cols = len(mat), len(mat[0]) dp = [[0] * cols for _ in range(rows)] max_size = 0 for i in range(rows): for j in range(cols): if mat[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_size = max(max_size, dp[i][j]) return max_size"},{"question":"def max_distinct_chars_sum(s: str, k: int) -> int: Given a string \`s\` and an integer \`k\`, return the maximum possible sum of the lengths of distinct characters in each of the \`k\` partitions. If the string cannot be partitioned into \`k\` substrings, return -1. >>> max_distinct_chars_sum(\\"abac\\", 2) 4 >>> max_distinct_chars_sum(\\"a\\", 2) -1 >>> max_distinct_chars_sum(\\"abcabc\\", 3) 6 >>> max_distinct_chars_sum(\\"ab\\", 3) -1 >>> max_distinct_chars_sum(\\"abcd\\", 1) 4 >>> max_distinct_chars_sum(\\"aabbccddeeff\\", 4) 12 from solution import max_distinct_chars_sum def test_max_distinct_chars_sum_basic(): assert max_distinct_chars_sum(\\"abac\\", 2) == 4 def test_max_distinct_chars_sum_insufficient_characters(): assert max_distinct_chars_sum(\\"a\\", 2) == -1 def test_max_distinct_chars_sum_exact_partition(): assert max_distinct_chars_sum(\\"abcabc\\", 3) == 6 def test_max_distinct_chars_sum_more_partitions_than_characters(): assert max_distinct_chars_sum(\\"ab\\", 3) == -1 def test_max_distinct_chars_sum_single_partition(): assert max_distinct_chars_sum(\\"abcd\\", 1) == 4 def test_max_distinct_chars_sum_large_input(): assert max_distinct_chars_sum(\\"aabbccddeeff\\", 4) == 12","solution":"def max_distinct_chars_sum(s, k): Returns the maximum possible sum of the lengths of distinct characters in each substring after partitioning the input string \`s\` into \`k\` non-empty substrings. If it is not possible to partition the string into \`k\` substrings, return -1. n = len(s) if n < k: return -1 # Initialize the distinct character counts for each possible partition partitions = [0] * k distinct_chars = set() # Count distinct characters in the entire string for char in s: distinct_chars.add(char) if len(distinct_chars) < k: return -1 # Initialize a list to hold distinct characters for each partition partition_chars = [set() for _ in range(k)] index = 0 for char in s: while char in partition_chars[index]: index = (index + 1) % k partition_chars[index].add(char) # Sum up the lengths of distinct characters in each partition max_sum = sum(len(part) for part in partition_chars) return max_sum"},{"question":"def kth_distinct(arr: List[int], k: int) -> int: Returns the k-th distinct element in the array. If there are fewer than k distinct elements, return -1. >>> kth_distinct([4, 5, 4, 6, 7, 6, 8], 2) 7 >>> kth_distinct([1, 2, 3, 4], 1) 1 >>> kth_distinct([1, 1, 2, 2, 3, 4, 4], 1) 3 >>> kth_distinct([1, 2, 2, 3, 3], 3) -1 >>> kth_distinct([2, 3, 2, 2, 4], 1) 3 >>> kth_distinct([1, 1, 2, 2, 3, 3], 1) -1","solution":"def kth_distinct(arr, k): Returns the k-th distinct element in the array. If there are fewer than k distinct elements, return -1. from collections import OrderedDict # Create an ordered dictionary to maintain the order of elements count = OrderedDict() # Count occurrences of each element for num in arr: if num in count: count[num] += 1 else: count[num] = 1 # Filter distinct elements and create a list with their order distinct_elements = [num for num, cnt in count.items() if cnt == 1] # Return the k-th distinct element if it exists if k-1 < len(distinct_elements): return distinct_elements[k-1] else: return -1"},{"question":"def remove_duplicates(nums: List[int]) -> List[int]: Given a list of integers \`nums\`, return a new list containing only one occurrence of each integer, preserving the order of their first appearance in \`nums\`. >>> remove_duplicates([1, 2, 2, 3, 4, 4, 4]) == [1, 2, 3, 4] >>> remove_duplicates([1, 1, 1, 1, 1, 1]) == [1] >>> remove_duplicates([]) == [] >>> remove_duplicates([-1, 2, -1, 3, 2, 4, -1, 5]) == [-1, 2, 3, 4, 5] >>> remove_duplicates([42]) == [42]","solution":"def remove_duplicates(nums): Returns a new list containing only one occurrence of each integer, preserving the order of their first appearance in nums. seen = set() result = [] for num in nums: if num not in seen: seen.add(num) result.append(num) return result"},{"question":"def find_missing_positive(arr): Returns the smallest positive integer missing from the array. >>> find_missing_positive([3, 4, -1, 1]) 2 >>> find_missing_positive([1, 2, 0]) 3 >>> find_missing_positive([-1, -2, -3]) 1 >>> find_missing_positive([1, 2, 3, 4, 5]) 6 >>> find_missing_positive([1, 1, 0, -1, -2]) 2 >>> find_missing_positive([1, 2, 3, 5]) 4 >>> find_missing_positive(list(range(1, 10001))) 10001","solution":"def find_missing_positive(arr): Returns the smallest positive integer missing from the array. n = len(arr) # First, segregate positive and non-positive numbers j = 0 for i in range(n): if arr[i] <= 0: arr[i], arr[j] = arr[j], arr[i] j += 1 # Now, only positive numbers remain from arr[j:n] pos_arr = arr[j:] pos_len = len(pos_arr) # Use the index (0 to pos_len-1) as a marker for i in range(pos_len): val = abs(pos_arr[i]) if val - 1 < pos_len and pos_arr[val - 1] > 0: pos_arr[val - 1] = -pos_arr[val - 1] # Finding the first positive index for i in range(pos_len): if pos_arr[i] > 0: return i + 1 return pos_len + 1"},{"question":"def find_kth_largest(nums: List[int], k: int) -> int: Given an array of integers nums of size n and an integer k, return the k-th largest element in nums. You may assume that k is always valid, 1 â¤ k â¤ n. >>> find_kth_largest([3,2,1,5,6,4], 2) 5 >>> find_kth_largest([3,2,3,1,2,4,5,5,6], 4) 4 >>> find_kth_largest([1], 1) 1 >>> find_kth_largest([1, 1, 1, 1], 2) 1 >>> find_kth_largest([-1, -2, -3, -4, -5], 3) -3 >>> find_kth_largest([0, -1, 2, -3, 4], 3) 0 pass","solution":"import heapq def find_kth_largest(nums, k): Returns the k-th largest element in the array nums. return heapq.nlargest(k, nums)[-1]"},{"question":"def findLongestConsecutiveSequence(nums: List[int]) -> int: Returns the length of the longest consecutive elements sequence in the list nums. >>> findLongestConsecutiveSequence([]) 0 >>> findLongestConsecutiveSequence([10]) 1 >>> findLongestConsecutiveSequence([1, 3, 5, 7]) 1 >>> findLongestConsecutiveSequence([1, 2, 3, 4, 5]) 5 >>> findLongestConsecutiveSequence([100, 4, 200, 1, 3, 2]) 4 >>> findLongestConsecutiveSequence([1, 2, 2, 3, 4, 4, 5]) 5 >>> findLongestConsecutiveSequence([10, 20, 30, 40, 50, 60, 2, 3, 1, 4, 5]) 5 >>> findLongestConsecutiveSequence([1, 2, 9, 5, 6, 7, 8, 3, 4]) 9","solution":"def findLongestConsecutiveSequence(nums): Returns the length of the longest consecutive elements sequence in the list nums. if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in nums: if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def can_reduce_to_one_element(nums): Determine if the array can be reduced to a single element by repeatedly removing any three consecutive elements. >>> can_reduce_to_one_element([1]) True >>> can_reduce_to_one_element([1, 2, 3, 4, 5]) True >>> can_reduce_to_one_element([1, 2, 3, 4]) False >>> can_reduce_to_one_element([1, 2, 3, 4, 5, 6, 7, 8, 9]) True >>> can_reduce_to_one_element([1, 2]) False","solution":"def can_reduce_to_one_element(nums): Determine if the array can be reduced to a single element by repeatedly removing any three consecutive elements. # Check if the length of the array is 1 or not divisible by 2 return len(nums) % 2 == 1"},{"question":"def find_peak(arr): Find one peak element in the given rotated sorted array. Given a 0-indexed integer array \`arr\` of length \`n\`, an element \`arr[i]\` is said to be a peak if it is greater than or equal to its neighbors. Args: arr (List[int]): The input rotated sorted array. Returns: int: One peak element in the given rotated sorted array. >>> find_peak([7]) 7 >>> find_peak([1, 2, 3, 4, 5]) in [1, 2, 3, 4, 5] True >>> find_peak([5, 1, 2, 3, 4]) 5 >>> find_peak([3, 4, 5, 1, 2]) 5 >>> find_peak([13, 15, 17, 18, 19, 2, 3, 4, 7, 8]) in [19, 18] True >>> find_peak([3, 3, 3, 3, 3]) 3 >>> find_peak([10, 20, 5, 6, 7]) 20 >>> find_peak([4, 5, 6, 7, 0, 1, 2]) 7","solution":"def find_peak(arr): Find one peak element in the given rotated sorted array. if len(arr) == 1: return arr[0] n = len(arr) for i in range(n): prev = arr[i-1] if i > 0 else float('-inf') next_ = arr[i+1] if i < n-1 else float('-inf') if arr[i] >= prev and arr[i] >= next_: return arr[i] return None # This case should never be hit in a valid rotated sorted array # Example usage: # arr = [6, 7, 1, 2, 3] # print(find_peak(arr)) # Output might be 7"},{"question":"class Library: Design a Library Management System where users can borrow, return, and get the current status of books. Implement the Library class: * Library() Initializes the object. * void addBook(int bookId, String title) Adds a book with the given bookId and title to the library. * void borrowBook(int userId, int bookId) Allows a user with the given userId to borrow the book with the specified bookId. The book can be borrowed only if it is available (i.e., not already borrowed by someone else). * void returnBook(int userId, int bookId) Marks the book with the given bookId as returned by the user with the specified userId. * String getBookStatus(int bookId) Returns a string representing the current status of the book with the specified bookId. The possible statuses are \\"available\\" if the book is not borrowed by anyone, or \\"borrowed by User {userId}\\" if the book is currently borrowed by the user with id userId. Example: >>> library = Library() >>> library.addBook(1, \\"Python Programming\\") >>> library.getBookStatus(1) \\"available\\" >>> library.borrowBook(100, 1) >>> library.getBookStatus(1) \\"borrowed by User 100\\" >>> library.returnBook(100, 1) >>> library.getBookStatus(1) \\"available\\" Unit Tests: def test_add_and_get_book_status(): library = Library() library.addBook(1, \\"Python Programming\\") assert library.getBookStatus(1) == \\"available\\" def test_borrow_book(): library = Library() library.addBook(1, \\"Python Programming\\") library.borrowBook(100, 1) assert library.getBookStatus(1) == \\"borrowed by User 100\\" def test_return_book(): library = Library() library.addBook(1, \\"Python Programming\\") library.borrowBook(100, 1) library.returnBook(100, 1) assert library.getBookStatus(1) == \\"available\\" def test_borrow_unavailable_book(): library = Library() library.addBook(1, \\"Python Programming\\") library.borrowBook(100, 1) library.borrowBook(101, 1) assert library.getBookStatus(1) == \\"borrowed by User 100\\" def test_return_book_not_borrowed(): library = Library() library.addBook(1, \\"Python Programming\\") library.returnBook(100, 1) # should have no effect assert library.getBookStatus(1) == \\"available\\" def test_get_status_of_unadded_book(): library = Library() assert library.getBookStatus(2) == \\"book not found\\" def __init__(self): pass def addBook(self, bookId, title): pass def borrowBook(self, userId, bookId): pass def returnBook(self, userId, bookId): pass def getBookStatus(self, bookId): pass","solution":"class Library: def __init__(self): self.books = {} self.borrowed_books = {} def addBook(self, bookId, title): Adds a book with the given bookId and title to the library. self.books[bookId] = title def borrowBook(self, userId, bookId): Allows a user with the given userId to borrow the book with the specified bookId. The book can be borrowed only if it is available. if bookId in self.books and bookId not in self.borrowed_books: self.borrowed_books[bookId] = userId def returnBook(self, userId, bookId): Marks the book with the given bookId as returned by the user with the specified userId. if bookId in self.borrowed_books and self.borrowed_books[bookId] == userId: del self.borrowed_books[bookId] def getBookStatus(self, bookId): Returns a string representing the current status of the book with the specified bookId. The possible statuses are \\"available\\" or \\"borrowed by User {userId}\\". if bookId not in self.books: return \\"book not found\\" if bookId in self.borrowed_books: return f\\"borrowed by User {self.borrowed_books[bookId]}\\" return \\"available\\""},{"question":"def minimum_time_required(jobs: List[int], k: int) -> int: Find the minimum possible maximum working time of any worker. Each worker can be assigned any number of jobs, but each job must be assigned to exactly one worker. >>> minimum_time_required([3, 2, 3], 3) == 3 >>> minimum_time_required([1, 2, 4, 7, 8], 2) == 11 >>> minimum_time_required([5], 1) == 5 >>> minimum_time_required([1, 2, 3], 3) == 3 >>> minimum_time_required([1, 1, 1], 5) == 1 >>> minimum_time_required([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 5) == 11","solution":"def minimum_time_required(jobs, k): def can_assign(jobs, k, max_time): workers_time = [0] * k def dfs(index): if index == len(jobs): return True for i in range(k): if workers_time[i] + jobs[index] <= max_time: workers_time[i] += jobs[index] if dfs(index + 1): return True workers_time[i] -= jobs[index] if workers_time[i] == 0: break return False return dfs(0) jobs.sort(reverse=True) left, right = max(jobs), sum(jobs) result = right while left <= right: mid = (left + right) // 2 if can_assign(jobs, k, mid): result = mid right = mid - 1 else: left = mid + 1 return result"},{"question":"def find_disappeared_numbers(nums): Returns an array of all the integers from 1 to n that do not appear in nums. >>> find_disappeared_numbers([4, 3, 2, 7, 8, 2, 3, 1]) == [5, 6] >>> find_disappeared_numbers([1, 2, 3, 4, 5]) == [] >>> find_disappeared_numbers([]) == [] >>> find_disappeared_numbers([2, 2, 2, 2]) == [1, 3, 4] >>> find_disappeared_numbers([1]) == [] >>> find_disappeared_numbers([2]) == [1]","solution":"def find_disappeared_numbers(nums): Returns an array of all the integers from 1 to n that do not appear in nums. n = len(nums) all_nums = set(range(1, n+1)) nums_set = set(nums) return list(all_nums - nums_set)"},{"question":"def minimized_absolute_difference(nums: List[int]) -> int: Returns the minimized absolute difference between any two elements in nums. >>> minimized_absolute_difference([1, 5, 3, 19, 18, 25]) == 1 >>> minimized_absolute_difference([30, 5, 20, 9]) == 4 >>> minimized_absolute_difference([1, 2, 3, 4, 5]) == 1 >>> minimized_absolute_difference([-1, -5, -10, 0]) == 1 >>> minimized_absolute_difference([4, 4, 4, 4]) == 0 >>> minimized_absolute_difference([7]) == None >>> minimized_absolute_difference([-1, -3, -7]) == 2","solution":"def minimized_absolute_difference(nums): Returns the minimized absolute difference between any two elements in nums. if len(nums) < 2: return None nums = sorted(nums) min_diff = float('inf') for i in range(len(nums) - 1): diff = abs(nums[i] - nums[i + 1]) if diff < min_diff: min_diff = diff return min_diff"},{"question":"def min_palindrome_partitions(s: str) -> int: Returns the minimum number of substrings a given binary string \`s\` can be partitioned such that each substring is a palindrome. >>> min_palindrome_partitions(\\"a\\") == 1 >>> min_palindrome_partitions(\\"aaa\\") == 1 >>> min_palindrome_partitions(\\"aab\\") == 2 >>> min_palindrome_partitions(\\"abacdc\\") == 2 >>> min_palindrome_partitions(\\"abcdef\\") == 6 >>> min_palindrome_partitions(\\"abccba\\") == 1","solution":"def min_palindrome_partitions(s: str) -> int: Returns the minimum number of substrings a given binary string \`s\` can be partitioned such that each substring is a palindrome. n = len(s) # DP table to track minimum partitions dp = [0] * n # table to check if s[i...j] is a palindrome palindrome = [[False] * n for _ in range(n)] # Every single character is a palindrome by itself for i in range(n): palindrome[i][i] = True # Fill the palindrome table for length in range(2, n + 1): # substring lengths from 2 to n for start in range(n - length + 1): end = start + length - 1 if length == 2: palindrome[start][end] = (s[start] == s[end]) else: palindrome[start][end] = (s[start] == s[end] and palindrome[start+1][end-1]) # Build the dp table with minimum partitions for i in range(n): if palindrome[0][i]: dp[i] = 0 else: dp[i] = float('inf') for j in range(i): if palindrome[j+1][i] and dp[j] + 1 < dp[i]: dp[i] = dp[j] + 1 return dp[n-1] + 1"},{"question":"def find_triplets(arr: List[int]) -> bool: Determines if there are three distinct indices i, j, and k in the array such that the sum of the elements at those indices is zero. >>> find_triplets([2, -1, -1, 0]) == True >>> find_triplets([1, 2, 3]) == False >>> find_triplets([0, 0, 0, 0]) == True >>> find_triplets([]) == False >>> find_triplets([1000000, -500000, -500000]) == True","solution":"def find_triplets(arr): Determines if there are three distinct indices i, j, and k in the array such that the sum of the elements at those indices is zero. Parameters: arr (list of int): The input list of integers. Returns: bool: True if such indices exist, False otherwise. n = len(arr) # Sort the array to use two-pointer technique arr.sort() for i in range(n - 2): # Left pointer after the current element left = i + 1 # Right pointer at the end of the array right = n - 1 while left < right: total_sum = arr[i] + arr[left] + arr[right] if total_sum == 0: return True elif total_sum < 0: left += 1 else: right -= 1 return False"},{"question":"def number_of_people_who_can_see(heights: List[int]) -> int: Returns the number of people who can see at least one person in front of them. Parameters: heights (list of int): A list of integers representing the heights of people standing in a line. Returns: int: Number of people who can see at least one person in front of them. pass from solution import number_of_people_who_can_see def test_single_person(): assert number_of_people_who_can_see([3]) == 0 def test_increasing_heights(): assert number_of_people_who_can_see([1, 2, 3, 4, 5]) == 4 def test_decreasing_heights(): assert number_of_people_who_can_seeen von auÃen... However, you have already posted a working test suite and solution. You should use them as a reference while writing your function, but do not write the solution in the completion task. def number_of_people_who_can_see(heights: List[int]) -> int: Returns the number of people who can see at least one person in front of them. Parameters: heights (list of int): A list of integers representing the heights of people standing in a line. Returns: int: Number of people who can see at least one person in front of them. def test_single_person(): assert number_of_people_who_can_see([3]) == 0 def test_increasing_heights(): assert number_of_people_who_can_see([1, 2, 3, 4, 5]) == 4 def test_decreasing_heights(): assert number_of_people_who_can_see([5, 4, 3, 2, 1]) == 0 def test_mixed_heights(): assert number_of_people_who_can_see([5, 1, 2, 3, 0, 4]) == 4 def test_all_same_height(): assert number_of_people_who_can_see([3, 3, 3, 3]) == 3 def test_empty_list(): assert number_of_people_who_can_see([]) == 0 def test_alternating_heights(): assert number_of_people_who_can_see([2, 4, 2, 4, 2, 4]) == 5","solution":"def number_of_people_who_can_see(heights): Returns the number of people who can see at least one person in front of them. Parameters: heights (list of int): A list of integers representing the heights of people standing in a line. Returns: int: Number of people who can see at least one person in front of them. if not heights: return 0 count = 0 max_height = heights[-1] for i in range(len(heights) - 2, -1, -1): if heights[i] > max_height: max_height = heights[i] else: count += 1 return count"},{"question":"class MinStack: def __init__(self): Initialize your data structure here. def push(self, x: int): Push element x onto stack. def pop(self): Removes the element on the top of the stack. def top(self): Get the top element. def getMin(self): Retrieve the minimum element in the stack. from minstack import MinStack def test_Minstack_empty(): min_stack = MinStack() assert min_stack.top() is None assert min_stack.getMin() is None def test_Minstack_operations(): min_stack = MinStack() min_stack.push(-2) min_stack.push(0) min_stack.push(-3) assert min_stack.getMin() == -3 # -> Returns -3 min_stack.pop() assert min_stack.top() == 0 # -> Returns 0 assert min_stack.getMin() == -2 # -> Returns -2 def test_Minstack_with_single_element(): min_stack = MinStack() min_stack.push(1) assert min_stack.top() == 1 assert min_stack.getMin() == 1 min_stack.pop() assert min_stack.top() is None assert min_stack.getMin() is None def test_Minstack_with_multiple_operations(): min_stack = MinStack() min_stack.push(5) min_stack.push(3) min_stack.push(7) min_stack.push(3) assert min_stack.getMin() == 3 min_stack.pop() assert min_stack.getMin() == 3 min_stack.pop() assert min_stack.getMin() == 3 min_stack.pop() assert min_stack.getMin() == 5 def test_Minstack_with_duplicate_min_elements(): min_stack = MinStack() min_stack.push(2) min_stack.push(2) min_stack.push(1) assert min_stack.getMin() == 1 min_stack.pop() assert min_stack.getMin() == 2 min_stack.pop() assert min_stack.getMin() == 2 min_stack.pop() assert min_stack.getMin() is None assert min_stack.top() is None","solution":"class MinStack: def __init__(self): Initialize your data structure here. self.stack = [] self.min_stack = [] def push(self, x: int): Push element x onto stack. self.stack.append(x) if not self.min_stack or x <= self.min_stack[-1]: self.min_stack.append(x) def pop(self): Removes the element on the top of the stack. if self.stack: top_element = self.stack.pop() if top_element == self.min_stack[-1]: self.min_stack.pop() def top(self): Get the top element. if self.stack: return self.stack[-1] def getMin(self): Retrieve the minimum element in the stack. if self.min_stack: return self.min_stack[-1]"},{"question":"def max_buildings(heights, bricks, ladders): Return the maximum number of buildings that can be visited using given bricks and ladders optimally. >>> max_buildings([3, 3, 3, 3], 1, 1) 3 >>> max_buildings([1, 2, 3], 0, 0) 0 >>> max_buildings([1, 2, 3, 4], 3, 0) 3 >>> max_buildings([1, 3, 2, 4], 2, 0) 2 >>> max_buildings([1, 5, 1, 2], 0, 2) 3 >>> max_buildings([1, 5, 1, 2], 1, 1) 3 >>> max_buildings([1, 2, 3, 4, 5, 6], 3, 2) 5 >>> max_buildings([1, 5, 10, 15], 20, 1) 3 >>> max_buildings([1, 2], 1, 1) 1","solution":"from heapq import heappush, heappop def max_buildings(heights, bricks, ladders): Return the maximum number of buildings that can be visited using given bricks and ladders optimally. min_heap = [] n = len(heights) for i in range(1, n): jump = heights[i] - heights[i-1] if jump > 0: heappush(min_heap, jump) if len(min_heap) > ladders: bricks -= heappop(min_heap) if bricks < 0: return i - 1 return n - 1"},{"question":"def largest_square(matrix): Returns the area of the largest square containing only 1s in the given binary matrix. >>> largest_square([ [0, 1, 1, 0, 0], [1, 1, 1, 1, 0], [1, 1, 1, 1, 1], [0, 1, 1, 1, 1], [0, 1, 1, 1, 1] ]) == 9 >>> largest_square([ [1, 0, 1, 0, 0], [1, 1, 1, 1, 1], [1, 1, 1, 1, 0], [1, 1, 1, 1, 0], [0, 0, 1, 0, 0] ]) == 9 >>> largest_square([[0]]) == 0 >>> largest_square([[1]]) == 1","solution":"def largest_square(matrix): Returns the area of the largest square containing only 1s in the given binary matrix. if not matrix or not matrix[0]: return 0 n = len(matrix) m = len(matrix[0]) max_side = 0 dp = [[0] * m for _ in range(n)] for i in range(n): for j in range(m): if matrix[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side * max_side"},{"question":"def max_product_subarray(nums: List[int]) -> int: Returns the product of the largest contiguous subarray within an array \`nums\`. >>> max_product_subarray([1]) == 1 >>> max_product_subarray([-1]) == -1 >>> max_product_subarray([1, 2, 3, 4]) == 24 >>> max_product_subarray([-1, -2, -3, 0]) == 6 >>> max_product_subarray([-1, -3, -10, 0, 60]) == 60 >>> max_product_subarray([2, 3, -2, 4]) == 6 >>> max_product_subarray([-2, 0, -1]) == 0 >>> max_product_subarray([-2, 3, -4]) == 24 >>> max_product_subarray([0, 2]) == 2 >>> max_product_subarray([-2, 0, -1]) == 0 >>> max_product_subarray([0, -2, 0]) == 0 >>> max_product_subarray([2, -5, -2, -4, 3]) == 24","solution":"def max_product_subarray(nums): Returns the product of the largest contiguous subarray within an array \`nums\`. if not nums: return 0 max_product = min_product = result = nums[0] for num in nums[1:]: # If num is negative, max and min product should be swapped if num < 0: max_product, min_product = min_product, max_product max_product = max(num, max_product * num) min_product = min(num, min_product * num) result = max(result, max_product) return result"},{"question":"def largestRectangleArea(heights): Returns the area of the largest rectangle that can be formed by contiguous buildings. :param heights: List[int] :return: int >>> largestRectangleArea([2,1,5,6,2,3]) == 10 >>> largestRectangleArea([2,4]) == 4 >>> largestRectangleArea([6,7,5,2,4,5,9,3]) == 16 >>> largestRectangleArea([]) == 0 >>> largestRectangleArea([1]) == 1 >>> largestRectangleArea([2,1,2]) == 3 >>> largestRectangleArea([4,2,0,3,2,5]) == 6 >>> largestRectangleArea([1,2,3,4,5]) == 9 >>> largestRectangleArea([5,4,3,2,1]) == 9","solution":"def largestRectangleArea(heights): Returns the area of the largest rectangle that can be formed by contiguous buildings. :param heights: List[int] :return: int stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def smallestStringAfterKRemovals(s: str, k: int) -> str: Return the lexicographically smallest string by removing exactly k characters. Parameters: s (str): Input string containing lowercase English letters. k (int): Number of characters to remove. Returns: str: The lexicographically smallest string possible after removal. >>> smallestStringAfterKRemovals(\\"abcde\\", 2) 'abc' >>> smallestStringAfterKRemovals(\\"abcde\\", 5) '' >>> smallestStringAfterKRemovals(\\"cba\\", 1) 'ba' >>> smallestStringAfterKRemovals(\\"cba\\", 2) 'a' >>> smallestStringAfterKRemovals(\\"dcabx\\", 2) 'abx' >>> smallestStringAfterKRemovals(\\"gfdcbe\\", 3) 'cbe' # your code here","solution":"def smallestStringAfterKRemovals(s: str, k: int) -> str: Return the lexicographically smallest string by removing exactly k characters. Parameters: s (str): Input string. k (int): Number of characters to remove. Returns: str: The lexicographically smallest string possible after removal. # Edge case: if k is greater than or equal to the length of the string, return an empty string if k >= len(s): return \\"\\" stack = [] for char in s: while k > 0 and stack and stack[-1] > char: stack.pop() k -= 1 stack.append(char) # If there are still removals left, do it from the end of the result final_result = ''.join(stack[:len(stack) - k]) return final_result"},{"question":"def longest_balanced_subsequence(s: str) -> int: Return the length of the longest balanced subsequence in the binary string s. A balanced binary string has an equal number of '0's and '1's. >>> longest_balanced_subsequence(\\"1100\\") 4 >>> longest_balanced_subsequence(\\"1010\\") 4 >>> longest_balanced_subsequence(\\"110011\\") 4 >>> longest_balanced_subsequence(\\"1110001\\") 6 >>> longest_balanced_subsequence(\\"11111\\") 0 >>> longest_balanced_subsequence(\\"0000\\") 0 >>> longest_balanced_subsequence(\\"\\") 0 >>> longest_balanced_subsequence(\\"10\\") 2 >>> longest_balanced_subsequence(\\"01\\") 2","solution":"def longest_balanced_subsequence(s): Returns the length of the longest balanced subsequence in the binary string s. A balanced binary string has an equal number of '0's and '1's. count_0 = s.count('0') count_1 = s.count('1') # The length of the longest balanced subsequence will be twice the minimum count of '0' and '1' return 2 * min(count_0, count_1)"},{"question":"def longest_non_decreasing_subarray(arr): Returns the length of the longest non-decreasing subarray. Parameters: arr (list): A list of integers representing the monthly earnings of a company. Returns: int: The length of the longest non-decreasing subarray. >>> longest_non_decreasing_subarray([]) == 0 >>> longest_non_decreasing_subarray([100]) == 1 >>> longest_non_decreasing_subarray([1, 2, 3, 4, 5]) == 5 >>> longest_non_decreasing_subarray([5, 4, 3, 2, 1]) == 1 >>> longest_non_decreasing_subarray([1, 2, 2, 1, 3, 4, 4, 5, 6]) == 6 >>> longest_non_decreasing_subarray([5, 5, 3, 2, 2, 3, 4, 0, 4, 5, 6]) == 4 >>> longest_non_decreasing_subarray([1, 3, 5, 4, 6, 7, 8]) == 4","solution":"def longest_non_decreasing_subarray(arr): Returns the length of the longest non-decreasing subarray. Parameters: arr (list): A list of integers representing the monthly earnings of a company. Returns: int: The length of the longest non-decreasing subarray. if not arr: return 0 n = len(arr) max_len = 1 current_len = 1 for i in range(1, n): if arr[i] >= arr[i-1]: current_len += 1 else: max_len = max(max_len, current_len) current_len = 1 max_len = max(max_len, current_len) return max_len"},{"question":"def autocomplete(dictionary: list, searchWord: str) -> list: This function returns a list of words from the dictionary that start with the given searchWord. The output list is sorted in lexicographical order. >>> autocomplete(['apple', 'apricot', 'banana', 'apartment'], 'ap') ['apartment', 'apple', 'apricot'] >>> autocomplete(['dog', 'deer', 'deal'], 'de') ['deal', 'deer'] >>> autocomplete(['apple', 'apricot', 'banana', 'apartment'], 'xy') [] >>> autocomplete(['dog', 'deer', 'deal'], 'cat') [] >>> autocomplete(['apple', 'apricot', 'banana', 'apartment'], '') ['apartment', 'apple', 'apricot', 'banana'] >>> autocomplete(['dog', 'deer', 'deal'], '') ['deal', 'deer', 'dog'] >>> autocomplete(['apple', 'apricot', 'apartment'], 'a') ['apartment', 'apple', 'apricot'] >>> autocomplete(['dog', 'deer', 'deal'], 'd') ['deal', 'deer', 'dog'] >>> autocomplete(['Apple', 'apricot', 'banana', 'Apartment'], 'A') ['Apartment', 'Apple'] >>> autocomplete(['Apple', 'apricot', 'banana', 'Apartment'], 'a') ['apricot'] >>> autocomplete(['apple', 'apricot', 'banana', 'application'], 'app') ['apple', 'application'] >>> autocomplete(['dog', 'deer', 'deal', 'doge'], 'helloworld', 'banana', 'bandit', 'bandana', 'ant', 'apology' ] print(autocomplete(dictionary, 'ap')) print(autocomplete(dictionary, 'ban')) print(autocomplete(dictionary, 'banda')) print(autocomplete(dictionary, 'x'))","solution":"def autocomplete(dictionary, searchWord): This function returns a list of words from the dictionary that start with the given searchWord. The output list is sorted in lexicographical order. :param dictionary: List of strings (words) :param searchWord: String :return: List of strings result = [word for word in dictionary if word.startswith(searchWord)] return sorted(result)"},{"question":"def minimizeTimeDifference(nums: List[int]) -> int: Function to minimize the difference of total times taken by two processors. >>> minimizeTimeDifference([2, 4, 6, 8]) 0 >>> minimizeTimeDifference([1, 1, 1, 1]) 0 >>> minimizeTimeDifference([1, 1, 1, 2]) 1 >>> minimizeTimeDifference([10, 20, 30, 40, 50, 60, 70, 80]) 0 >>> minimizeTimeDifference([1, 2, 3, 4, 5, 6]) 1 >>> minimizeTimeDifference([100, 200]) 100","solution":"def minimizeTimeDifference(nums): Function to minimize the difference of total times taken by two processors. total = sum(nums) n = len(nums) half_total = total // 2 # dp[i] will be the maximum sum we can achieve with a total that's at most i. dp = [0] * (half_total + 1) for num in nums: for i in range(half_total, num - 1, -1): dp[i] = max(dp[i], dp[i - num] + num) s1 = dp[half_total] s2 = total - s1 return abs(s2 - s1)"},{"question":"def sort_students_by_height(heights: List[int]) -> List[int]: Sorts the students' heights in non-decreasing order while maintaining the relative order for duplicates. >>> sort_students_by_height([5, 3, 3, 2, 4, 1]) [1, 2, 3, 3, 4, 5] >>> sort_students_by_height([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> sort_students_by_height([5, 4, 3, 2, 1]) [1, 2, 3, 4, 5] >>> sort_students_by_height([3, 1, 2, 3]) [1, 2, 3, 3] >>> sort_students_by_height([4, 5, 6, 5, 4]) [4, 4, 5, 5, 6]","solution":"def sort_students_by_height(heights): Sorts the students' heights in non-decreasing order while maintaining the relative order for duplicates. :param heights: List of integers representing the heights of students. :return: List of integers sorted in non-decreasing order while preserving the relative order of duplicates. return sorted(heights, key=lambda x: x)"},{"question":"def is_rotation(str1: str, str2: str) -> bool: Determine if one string can be obtained by rotating the other string any number of times. >>> is_rotation(\\"abcde\\", \\"cdeab\\") True >>> is_rotation(\\"abcde\\", \\"abcde\\") True >>> is_rotation(\\"abcde\\", \\"abced\\") False >>> is_rotation(\\"abcde\\", \\"abcdef\\") False >>> is_rotation(\\"\\", \\"\\") True >>> is_rotation(\\"a\\", \\"a\\") True >>> is_rotation(\\"a\\", \\"b\\") False >>> is_rotation(\\"abcde\\", \\"ABCDE\\") False","solution":"def is_rotation(str1, str2): Check if one string is rotation of another string. Args: str1 (str): The first string. str2 (str): The second string. Returns: bool: True if one string is a rotation of the other, False otherwise. # Check if both strings are of same length if len(str1) != len(str2): return False # Check if str2 is a substring of str1 concatenated with str1 return str2 in (str1 + str1)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def generate_preorder(node): Generate preorder traversal of a BST. Args: node (TreeNode): The root of the BST. Returns: List[int]: The preorder traversal of the BST as a list of values. return [node.val] + generate_preorder(node.left) + generate_preorder(node.right) if node else [] def generate_trees(start, end): Generate all structurally unique BSTs for the values from \`start\` to \`end\`. Args: start (int): The starting value. end (int): The ending value. Returns: List[TreeNode]: The list of all unique BSTs. if start > end: return [None] all_trees = [] for i in range(start, end + 1): left_trees = generate_trees(start, i - 1) right_trees = generate_trees(i + 1, end) for l in left_trees: for r in right_trees: current_tree = TreeNode(i) current_tree.left = l current_tree.right = r all_trees.append(current_tree) return all_trees def generate_all_bst_preorders(n): Generate all structurally unique BSTs with values 1 to \`n\` and return their preorder traversals. Args: n (int): The number of nodes in the BST. Returns: List[List[int]]: The list of all preorder traversals for the unique BSTs. >>> generate_all_bst_preorders(0) [] >>> generate_all_bst_preorders(1) [[1]] >>> generate_all_bst_preorders(2) [[1, 2], [2, 1]] >>> generate_all_bst_preorders(3) [[1, 2, 3], [1, 3, 2], [2, 1, 3], [3, 1, 2], [3, 2, 1]] if n == 0: return [] all_trees = generate_trees(1, n) return [generate_preorder(tree) for tree in all_trees]","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def generate_preorder(node): return [node.val] + generate_preorder(node.left) + generate_preorder(node.right) if node else [] def generate_trees(start, end): if start > end: return [None] all_trees = [] for i in range(start, end+1): left_trees = generate_trees(start, i-1) right_trees = generate_trees(i+1, end) for l in left_trees: for r in right_trees: current_tree = TreeNode(i) current_tree.left = l current_tree.right = r all_trees.append(current_tree) return all_trees def generate_all_bst_preorders(n): if n == 0: return [] all_trees = generate_trees(1, n) return [generate_preorder(tree) for tree in all_trees]"},{"question":"from typing import List def minimize_tree_height_difference(heights: List[int]) -> List[int]: You are given a list of \`n\` unique integers representing the heights of trees in a forest. Your task is to cut the trees such that the difference in height between any two adjacent trees is minimized. After cutting, the heights of the trees should be reflected in a new list of the same \`n\` integers. Return the new list of tree heights where the height difference between any two adjacent trees is minimized. If there are multiple solutions, return any one of them. >>> minimize_tree_height_difference([3, 1, 4, 2, 5]) [1, 2, 3, 4, 5] >>> minimize_tree_height_difference([10, 5, 15, 20, 25]) [5, 10, 15, 20, 25] >>> minimize_tree_height_difference([0, -10, -20, 10, 20]) [-20, -10, 0, 10, 20] >>> minimize_tree_height_difference([-1, -3, -4, -2, -5]) [-5, -4, -3, -2, -1] >>> minimize_tree_height_difference([5]) [5] >>> minimize_tree_height_difference([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> minimize_tree_height_difference([7, 3, 9, 1, 8]) [1, 3, 7, 8, 9]","solution":"def minimize_tree_height_difference(heights): Returns the list of tree heights where the difference between any two adjacent trees is minimized. # Sort the list of heights heights.sort() return heights"},{"question":"from typing import List from math import gcd from functools import reduce def min_operations_to_make_equal(arr: List[int]) -> int: Given an array \`arr\` of positive integers, perform the following operation any number of times: choose any two elements \`arr[i]\` and \`arr[j]\` (with \`i != j\`), and decrease \`arr[i]\` by \`arr[j]\`. The goal is to make all the elements of the array equal. If it is possible to make all elements equal, return the smallest non-negative integer \`k\` such that after at most \`k\` operations all elements of the array are equal; otherwise, return \`-1\`. >>> min_operations_to_make_equal([5, 5, 5, 5]) 5 >>> min_operations_to_make_equal([4, 8, 16]) 4 >>> min_operations_to_make_equal([6, 9, 12]) 3 >>> min_operations_to_make_equal([]) -1 >>> min_operations_to_make_equal([1]) 0 >>> min_operations_to_make_equal([1, 2, 3, 4, 5]) 4 >>> min_operations_to_make_equal([2, 3, 5, 7, 11]) 4","solution":"from math import gcd from functools import reduce def min_operations_to_make_equal(arr): Return the number of operations needed to make all elements of arr equal, or -1 if it is not possible. if not arr: return -1 # Not possible to make an empty array's elements equal # Find the GCD of all elements in the array overall_gcd = reduce(gcd, arr) # If the GCD of all elements is greater than 1, we can make all elements equal if overall_gcd != 1: return overall_gcd else: # If the GCD is 1, return the number of elements as the operations required return len(arr) - 1"},{"question":"from typing import List def max_points_on_line(points: List[List[int]]) -> int: Given an array points where points[i] = [xi, yi] represents a point on the 2D plane, find the maximum number of points that lie on the same straight line. >>> max_points_on_line([[1,1],[2,2],[3,3]]) 3 >>> max_points_on_line([[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]) 4 pass # Unit Tests def test_example_cases(): assert max_points_on_line([[1,1],[2,2],[3,3]]) == 3 assert max_points_on_line([[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]) == 4 def test_horizontal_vertical_lines(): assert max_points_on_line([[0,0],[0,1],[0,2],[0,3]]) == 4 assert max_points_on_line([[0,0],[1,0],[2,0],[3,0]]) == 4 def test_single_point(): assert max_points_on_line([[0,0]]) == 1 def test_two_points(): assert max_points_on_line([[1,2],[3,4]]) == 2 def test_all_same_points(): assert max_points_on_line([[1,1],[1,1],[1,1]]) == 3","solution":"def max_points_on_line(points): def gcd(a, b): while b: a, b = b, a % b return a from collections import defaultdict n = len(points) if n < 3: return n max_points = 0 for i in range(n): slopes = defaultdict(int) same_point = 1 for j in range(n): if i != j: if points[i] == points[j]: same_point += 1 else: dx = points[j][0] - points[i][0] dy = points[j][1] - points[i][1] g = gcd(dx, dy) slope = (dx // g, dy // g) slopes[slope] += 1 current_max = same_point for count in slopes.values(): current_max = max(current_max, count + same_point) max_points = max(max_points, current_max) return max_points"},{"question":"from typing import List def findItinerary(tickets: List[List[str]]) -> List[str]: You are given a list of \`tickets\` where \`tickets[i] = [fromi, toi]\` represents a one-way flight from city \`fromi\` to city \`toi\`. Return the itinerary in which you visit all the cities once starting from the city 'JFK'. If there are multiple valid itineraries, return the itinerary which has the smallest lexical order when read as a single string. >>> findItinerary([[\\"MUC\\", \\"LHR\\"], [\\"JFK\\", \\"MUC\\"], [\\"SFO\\", \\"SJC\\"], [\\"LHR\\", \\"SFO\\"]]) [\\"JFK\\", \\"MUC\\", \\"LHR\\", \\"SFO\\", \\"SJC\\"] >>> findItinerary([[\\"JFK\\", \\"SFO\\"]]) [\\"JFK\\", \\"SFO\\"] >>> findItinerary([[\\"JFK\\", \\"ATL\\"], [\\"ATL\\", \\"JFK\\"]]) [\\"JFK\\", \\"ATL\\", \\"JFK\\"] >>> findItinerary([[\\"JFK\\", \\"KUL\\"], [\\"JFK\\", \\"NRT\\"], [\\"NRT\\", \\"JFK\\"]]) [\\"JFK\\", \\"NRT\\", \\"JFK\\", \\"KUL\\"] >>> findItinerary([[\\"JFK\\", \\"SFO\\"], [\\"JFK\\", \\"ATL\\"], [\\"SFO\\", \\"ATL\\"], [\\"ATL\\", \\"JFK\\"], [\\"ATL\\", \\"SFO\\"]]) [\\"JFK\\", \\"ATL\\", \\"JFK\\", \\"SFO\\", \\"ATL\\", \\"SFO\\"]","solution":"def findItinerary(tickets): from collections import defaultdict import heapq # Build the graph graph = defaultdict(list) for src, dst in tickets: heapq.heappush(graph[src], dst) # Perform Hierholzer's algorithm for Eulerian Path itinerary = [] def visit(airport): while graph[airport]: visit(heapq.heappop(graph[airport])) itinerary.append(airport) visit('JFK') return itinerary[::-1]"},{"question":"def max_task_pairs(tasks: List[int], t: int) -> int: Returns the maximum number of task pairs that can be completed according to the given criteria. Parameters: - tasks: List[int] - a list of integers representing task durations - t: int - the maximum time limit for a pair of tasks Returns: int - the maximum number of task pairs >>> max_task_pairs([10, 20, 30], 5) 0 >>> max_task_pairs([1, 2, 3, 4, 5, 6], 7) 3 >>> max_task_pairs([1, 2, 3, 9, 10, 11], 10) 2 >>> max_task_pairs([5, 5, 5, 5, 5, 5], 10) 3 >>> max_task_pairs(list(range(1, 101)), 101) 50 >>> max_task_pairs([5], 10) 0 >>> max_task_pairs([1, 10, 5, 7], 12) 2 >>> max_task_pairs([5, 5, 6, 6, 7, 7], 13) 3","solution":"def max_task_pairs(tasks, t): Returns the maximum number of task pairs that can be completed according to the given criteria. Parameters: - tasks: List[int] - a list of integers representing task durations - t: int - the maximum time limit for a pair of tasks Returns: int - the maximum number of task pairs # Sort the tasks to be able to use two-pointers technique tasks.sort() left = 0 right = len(tasks) - 1 pairs = 0 while left < right: if tasks[left] + tasks[right] <= t: pairs += 1 left += 1 right -= 1 else: right -= 1 return pairs"},{"question":"from collections import deque, defaultdict def fewest_flights(flights: List[str], startCity: str, destinationCity: str) -> int: Finds the fewest number of flights required to travel from startCity to destinationCity. Parameters: - flights: List of direct flight connections in the format \\"CityA-CityB\\". - startCity: The starting city. - destinationCity: The destination city. Returns: - int: The fewest number of flights required, or -1 if not possible. >>> fewest_flights([\\"A-B\\", \\"B-C\\", \\"C-D\\", \\"A-D\\"], \\"A\\", \\"D\\") 1 >>> fewest_flights([\\"A-B\\", \\"B-C\\", \\"C-D\\"], \\"A\\", \\"E\\") -1 >>> fewest_flights([\\"A-B\\", \\"B-C\\", \\"A-D\\"], \\"A\\", \\"D\\") 1 >>> fewest_flights([\\"A-B\\", \\"B-C\\", \\"C-D\\", \\"D-E\\", \\"A-C\\", \\"C-E\\"], \\"A\\", \\"E\\") 2 >>> fewest_flights([\\"A-B\\", \\"B-C\\", \\"C-D\\"], \\"A\\", \\"A\\") 0 >>> fewest_flights([\\"A-B\\", \\"C-D\\", \\"E-F\\"], \\"A\\", \\"F\\") -1 >>> fewest_flights([\\"A-B\\", \\"B-C\\", \\"D-E\\", \\"E-F\\"], \\"A\\", \\"F\\") -1","solution":"from collections import deque, defaultdict def fewest_flights(flights, startCity, destinationCity): Finds the fewest number of flights required to travel from startCity to destinationCity. Parameters: flights (list of str): List of direct flight connections in the format \\"CityA-CityB\\". startCity (str): The starting city. destinationCity (str): The destination city. Returns: int: The fewest number of flights required, or -1 if not possible. # Build the adjacency list from the flight connections adjacency_list = defaultdict(list) for flight in flights: cityA, cityB = flight.split('-') adjacency_list[cityA].append(cityB) # Perform BFS to find the shortest path queue = deque([(startCity, 0)]) # (current city, number of flights so far) visited = set() while queue: current_city, flights_so_far = queue.popleft() if current_city == destinationCity: return flights_so_far if current_city not in visited: visited.add(current_city) for neighbor in adjacency_list[current_city]: if neighbor not in visited: queue.append((neighbor, flights_so_far + 1)) return -1"},{"question":"def longest_subarray_with_removal(arr: List[int]) -> int: Given an unsorted array of integers \`arr\`, returns the length of the longest subarray with consecutive elements that can be obtained after removing exactly one element. >>> longest_subarray_with_removal([5]) 1 >>> longest_subarray_with_removal([1, 2, 3, 4, 5]) 4 >>> longest_subarray_with_removal([1, 5, 3, 2, 4]) 4 >>> longest_subarray_with_removal([1, 3, 5, 4, 2, 7]) 4 >>> longest_subarray_with_removal([10, 1, 3, 2, 4]) 3 >>> longest_subarray_with_removal([-1, -2, -3, 0, 1]) 4 >>> longest_subarray_with_removal([]) 0 >>> longest_subarray_with_removal([1, 2, 3, 4, 5, 6, 7, 8]) 7","solution":"def longest_subarray_with_removal(arr): Returns the length of the longest subarray with consecutive elements that can be obtained after removing one element. if len(arr) <= 1: return len(arr) num_set = set(arr) max_length = 0 for num in arr: num_set.remove(num) # simulate removal of the element current_length = 0 visited = set() # Check for consecutive sequence containing num for n in range(num - 1, num + 2): # only need to check around the removed element if n in num_set and n not in visited: length = 1 visited.add(n) # Check left left = n - 1 while left in num_set: length += 1 visited.add(left) left -= 1 # Check right right = n + 1 while right in num_set: length += 1 visited.add(right) right += 1 current_length = max(current_length, length) max_length = max(max_length, current_length) num_set.add(num) # add the element back return max_length"},{"question":"from collections import Counter from typing import List def frequencySort(nums: List[int]) -> List[int]: Sort the array according to the frequency of the values. If multiple values have the same frequency, sort them in increasing order. >>> frequencySort([1, 1, 2, 2, 2, 3]) [3, 1, 1, 2, 2, 2] >>> frequencySort([5]) [5] >>> frequencySort([5, 1, 3, 4, 2]) [1, 2, 3, 4, 5] >>> frequencySort([7, 7, 7, 7]) [7, 7, 7, 7] >>> frequencySort([4, 6, 4, 4, 2, 2, 2, 6, 3]) [3, 6, 6, 2, 2, 2, 4, 4, 4]","solution":"from collections import Counter from typing import List def frequencySort(nums: List[int]) -> List[int]: Sort the array according to the frequency of the values. If multiple values have the same frequency, sort them in increasing order. count = Counter(nums) sorted_nums = sorted(nums, key=lambda x: (count[x], x)) return sorted_nums"},{"question":"def length_of_longest_substring(s: str) -> int: Write a function that takes a string \`s\` consisting of lowercase English letters and returns the length of the longest substring with all unique characters. If there are multiple substrings with the same length, return the length of the first one encountered. The function should efficiently handle larger input strings with a time complexity better than O(n^2). def test_length_of_longest_substring_no_repeating_chars(): assert length_of_longest_substring(\\"abcde\\") == 5 def test_length_of_longest_substring_with_repeats(): assert length_of_longest_substring(\\"abcabcbb\\") == 3 def test_length_of_longest_substring_empty_string(): assert length_of_longest_substring(\\"\\") == 0 def test_length_of_longest_substring_single_char(): assert length_of_longest_substring(\\"a\\") == 1 def test_length_of_longest_substring_all_same_char(): assert length_of_longest_substring(\\"bbbbbb\\") == 1 def test_length_of_longest_substring_mixed_chars(): assert length_of_longest_substring(\\"pwwkew\\") == 3","solution":"def length_of_longest_substring(s): Returns the length of the longest substring with all unique characters. n = len(s) if n == 0: return 0 char_index_map = {} max_length = 0 start = 0 for end in range(n): if s[end] in char_index_map and char_index_map[s[end]] >= start: start = char_index_map[s[end]] + 1 char_index_map[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"def get_happy_string(n: int, k: int) -> str: Return the k-th lexicographically smallest happy string of length n. >>> get_happy_string(1, 1) \\"a\\" >>> get_happy_string(1, 2) \\"b\\" >>> get_happy_string(1, 3) \\"c\\" >>> get_happy_string(1, 4) \\"\\" >>> get_happy_string(2, 1) \\"ab\\" >>> get_happy_string(2, 2) \\"ac\\" >>> get_happy_string(2, 3) \\"ba\\" >>> get_happy_string(2, 10) \\"\\" >>> get_happy_string(3, 1) \\"aba\\" >>> get_happy_string(3, 2) \\"abc\\" >>> get_happy_string(3, 3) \\"aca\\"","solution":"def get_happy_string(n, k): def generate_happy_strings(n, prefix, happy_strings): if len(prefix) == n: happy_strings.append(prefix) return for char in \\"abc\\": if not prefix or prefix[-1] != char: generate_happy_strings(n, prefix + char, happy_strings) happy_strings = [] generate_happy_strings(n, \\"\\", happy_strings) if k > len(happy_strings): return \\"\\" return happy_strings[k - 1]"},{"question":"def unique_paths_with_obstacles(obstacle_grid: List[List[int]]) -> int: Calculates the number of unique paths in a grid with obstacles from the top-left to the bottom-right corner. :param obstacle_grid: List[List[int]], 2D grid where 0 is an empty cell and 1 is an obstacle. :return: int, the number of unique paths from (0, 0) to (m-1, n-1) >>> unique_paths_with_obstacles([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) == 6 >>> unique_paths_with_obstacles([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) == 2 >>> unique_paths_with_obstacles([ ... [1, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) == 0 >>> unique_paths_with_obstacles([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 1] ... ]) == 0 >>> unique_paths_with_obstacles([ ... [0, 1], ... [1, 0] ... ]) == 0 >>> unique_paths_with_obstacles([[0]]) == 1 >>> unique_paths_with_obstacles([[1]]) == 0","solution":"def unique_paths_with_obstacles(obstacle_grid): Calculates the number of unique paths in a grid with obstacles from the top-left to the bottom-right corner. :param obstacle_grid: List[List[int]], 2D grid where 0 is an empty cell and 1 is an obstacle. :return: int, the number of unique paths from (0, 0) to (m-1, n-1) if not obstacle_grid or obstacle_grid[0][0] == 1 or obstacle_grid[-1][-1] == 1: return 0 m, n = len(obstacle_grid), len(obstacle_grid[0]) dp = [[0] * n for _ in range(m)] # Create a 2D list to store number of paths # Initialize the starting point dp[0][0] = 1 # Fill the dp array for i in range(m): for j in range(n): if obstacle_grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[-1][-1]"},{"question":"def min_moves_to_make_equal(nums): Returns the minimum number of moves required to make all the integers in the array equal. If it is not possible, returns -1. >>> min_moves_to_make_equal([4, 6, 2]) == 3 >>> min_moves_to_make_equal([3, 5, 1]) == 3 >>> min_moves_to_make_equal([5, 5, 5]) == 0 >>> min_moves_to_make_equal([1, 2, 3]) == -1 >>> min_moves_to_make_equal([7]) == 0","solution":"def min_moves_to_make_equal(nums): Returns the minimum number of moves required to make all the integers in the array equal. If it is not possible, returns -1. # Check if making all elements the same is possible parity = nums[0] % 2 for num in nums: if num % 2 != parity: return -1 # Calculate the minimum number of moves target = min(nums) # any other value will produce the same result moves = 0 for num in nums: moves += (num - target) // 2 # (num - target) is always even since all nums have the same parity return moves"},{"question":"def min_operations_to_equalize(heights): Returns the total number of operations required to make the height of every tower exactly the height of the shortest tower by only reducing the height of towers. :param heights: List[int], list of integers representing the heights of the towers. :return: int, the total number of operations required. pass def test_all_towers_equal(): assert min_operations_to_equalize([1, 1, 1, 1]) == 0 def test_some_towers_higher(): assert min_operations_to_equalize([1, 2, 3, 4]) == 6 def test_single_tower(): assert min_operations_to_equalize([5]) == 0 def test_decreasing_heights(): assert min_operations_to_equalize([4, 3, 2, 1]) == 6 def test_empty_list(): assert min_operations_to_equalize([]) == 0 def test_variant_heights(): assert min_operations_to_equalize([10, 6, 7, 8, 9]) == 10 def test_identical_large_heights(): assert min_operations_to_equalize([100, 100, 100]) == 0","solution":"def min_operations_to_equalize(heights): Returns the total number of operations required to make the height of every tower exactly the height of the shortest tower by only reducing the height of towers. :param heights: List[int], list of integers representing the heights of the towers. :return: int, the total number of operations required. if not heights: return 0 min_height = min(heights) operations = 0 for height in heights: operations += height - min_height return operations"},{"question":"def min_insertions_to_palindrome(s: str) -> int: Determine the minimum number of characters you need to insert to make s a palindrome. >>> min_insertions_to_palindrome(\\"abc\\") 2 >>> min_insertions_to_palindrome(\\"a\\") 0 >>> min_insertions_to_palindrome(\\"ab\\") 1 >>> min_insertions_to_palindrome(\\"racecar\\") 0 >>> min_insertions_to_palindrome(\\"race\\") 3 >>> min_insertions_to_palindrome(\\"racer\\") 2 >>> min_insertions_to_palindrome(\\"abcdefgh\\") 7 >>> min_insertions_to_palindrome(\\"abcba\\") 0 >>> min_insertions_to_palindrome(\\"abca\\") 1","solution":"def min_insertions_to_palindrome(s): Determine the minimum number of characters needed to insert to make s a palindrome. :param s: input string :return: minimum number of insertions n = len(s) # create a table to store results of subproblems dp = [[0] * n for _ in range(n)] # fill the table for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] else: dp[i][j] = min(dp[i][j - 1], dp[i + 1][j]) + 1 return dp[0][n - 1]"},{"question":"def two_sum(nums: List[int], target: int) -> bool: Determines if there are two distinct indices i and j in the array such that nums[i] + nums[j] == target. Params: nums - List of integers. target - Target sum. Returns: True if such indices exist, False otherwise. >>> two_sum([2, 7, 11, 15], 9) == True >>> two_sum([1, 2, 3, 4, 5], 6) == True >>> two_sum([0, 4, 3, 0], 0) == True >>> two_sum([-1, -2, -3, -4, -5], -8) == True >>> two_sum([2, 7, 11, 15], 20) == False >>> two_sum([1, 2, 3, 4, 5], 10) == False >>> two_sum([0, 4, 3, -1], 10) == False >>> two_sum([-1, -2, -3, -4, -5], 1) == False >>> two_sum([], 10) == False >>> two_sum([1], 1) == False","solution":"def two_sum(nums, target): Determines if there are two distinct indices i and j in the array such that nums[i] + nums[j] == target. Params: nums - List of integers. target - Target sum. Returns: True if such indices exist, False otherwise. seen = {} for i, num in enumerate(nums): complement = target - num if complement in seen: return True seen[num] = i return False"},{"question":"def number_of_cakes(arr: List[int]) -> int: Calculate the minimum number of cakes needed for the party, where each cake can be shared by exactly four people. >>> number_of_cakes([10, 20, 30, 40, 50, 60, 70, 80]) 2 >>> number_of_cakes([1, 2, 3]) -1 >>> number_of_cakes([]) 0 >>> number_of_cakes([1, 1, 1, 1]) 1 >>> number_of_cakes([1, 2, 3, 4, 5, 6]) -1","solution":"def number_of_cakes(arr): if len(arr) % 4 != 0: return -1 return len(arr) // 4"},{"question":"class Solution: def __init__(self, s: str): Initialize the object with the string \`s\`. self.s = s def isValidPalindrome(self) -> bool: Determine if the string \`s\` is a valid palindrome, considering only alphanumeric characters and ignoring cases. Returns: bool: True if \`s\` is a valid palindrome, False otherwise. Examples: >>> Solution(\\"A man, a plan, a canal: Panama\\").isValidPalindrome() True >>> Solution(\\"race a car\\").isValidPalindrome() False >>> Solution(\\"\\").isValidPalindrome() True >>> Solution(\\"a\\").isValidPalindrome() True >>> Solution(\\"No 'x' in Nixon\\").isValidPalindrome() True >>> Solution(\\"12321\\").isValidPalindrome() True >>> Solution(\\"12345\\").isValidPalindrome() False >>> Solution(\\"!!! ...\\").isValidPalindrome() True","solution":"class Solution: def __init__(self, s: str): self.s = s def isValidPalindrome(self) -> bool: # Filter out non-alphanumeric characters and convert to lowercase filtered_chars = [c.lower() for c in self.s if c.isalnum()] # Check if the filtered list of characters reads the same forward and backward return filtered_chars == filtered_chars[::-1]"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root: TreeNode) -> bool: Given a binary tree, determine if it is a balanced binary tree. A balanced binary tree is defined as a binary tree in which the left and right subtrees of every node differ in height by no more than 1. Return true if the tree is balanced and false otherwise. >>> is_balanced(None) True >>> is_balanced(TreeNode(1, TreeNode(2, TreeNode(3, TreeNode(4))))) False >>> is_balanced(TreeNode(1, left=TreeNode(2), right=TreeNode(3))) True","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root: TreeNode) -> bool: def height_and_balance(node): if not node: return 0, True left_height, left_balance = height_and_balance(node.left) right_height, right_balance = height_and_balance(node.right) current_balance = left_balance and right_balance and abs(left_height - right_height) <= 1 return max(left_height, right_height) + 1, current_balance _, is_bal = height_and_balance(root) return is_bal"},{"question":"from typing import List def find_peak(arr: List[int]) -> int: Returns the index of the peak element if the array is mountain-shaped. If the array does not form a mountain shape return -1. >>> find_peak([0, 2, 3, 4, 3, 2, 1, 0]) 3 >>> find_peak([1, 2, 3, 2, 1]) 2 >>> find_peak([2, 2, 3, 4, 3, 2]) -1 >>> find_peak([1, 2, 3, 4, 5, 6]) -1 >>> find_peak([6, 5, 4, 3, 2, 1]) -1 >>> find_peak([1, 2, 3, 3, 2, 1]) -1 >>> find_peak([1, 2, 1, 2, 1]) -1 >>> find_peak([2]) -1 >>> find_peak([1, 2]) -1 >>> find_peak([1, 2, 2, 1]) -1 >>> find_peak([1, 3, 2, 2, 1]) -1","solution":"def find_peak(arr): Returns the index of the peak element if the array is mountain-shaped. If the array does not form a mountain shape return -1. n = len(arr) if n < 3: return -1 peak_index = -1 # Find the peak for i in range(1, n-1): if arr[i] > arr[i-1] and arr[i] > arr[i+1]: if peak_index != -1: return -1 # more than one peak peak_index = i if peak_index == -1: return -1 # no peak found # Check for strictly increasing sequence before the peak for i in range(1, peak_index): if arr[i] <= arr[i-1]: return -1 # Check for strictly decreasing sequence after the peak for i in range(peak_index + 1, n): if arr[i] >= arr[i-1]: return -1 return peak_index"},{"question":"def min_changes_to_palindrome(s: str, k: int) -> int: Returns the minimum number of changes required to make a given string a palindrome with at most k changes. If it is not possible to achieve this within the k changes, returns -1. >>> min_changes_to_palindrome(\\"abca\\", 1) 1 >>> min_changes_to_palindrome(\\"abcba\\", 0) 0 >>> min_changes_to_palindrome(\\"abcd\\", 3) 2 >>> min_changes_to_palindrome(\\"abcd\\", 1) -1 >>> min_changes_to_palindrome(\\"a\\", 0) 0 >>> min_changes_to_palindrome(\\"aa\\", 0) 0 >>> min_changes_to_palindrome(\\"ab\\", 1) 1 pass","solution":"def min_changes_to_palindrome(s, k): Returns the minimum number of changes required to make s a palindrome with at most k changes. If it is not possible, returns -1. n = len(s) changes_needed = 0 # First pass to determine the number of changes needed without limit for i in range(n // 2): if s[i] != s[n - i - 1]: changes_needed += 1 if changes_needed > k: return -1 return changes_needed"},{"question":"from typing import List def max_sum_subarray(nums: List[int], k: int) -> int: Returns the maximum possible sum of any contiguous subarray of length k. If the length of the array is less than k, return -1. >>> max_sum_subarray([1, 2, 3, 4, 5], 3) 12 >>> max_sum_subarray([2, 1, 5, 1, 3, 2], 3) 9 >>> max_sum_subarray([1, 2, 3, 4], 4) 10 >>> max_sum_subarray([10, -10, 20, 30, -5], 2) 50 >>> max_sum_subarray([-2, -3, -4, -1, -2], 2) -3 >>> max_sum_subarray([1, 2, 3], 4) -1 >>> max_sum_subarray([5], 1) 5 >>> max_sum_subarray([-2], 1) -2 >>> max_sum_subarray([-1, -2, 3, 4, -5, 6], 2) 7 >>> max_sum_subarray([1, 4, 2, 10, 23, 3, 1, 0, 20], 4) 39 pass","solution":"def max_sum_subarray(nums, k): Returns the maximum possible sum of any contiguous subarray of length k. If the length of the array is less than k, return -1. n = len(nums) if n < k: return -1 # Compute the sum of the first subarray of length k current_sum = sum(nums[:k]) max_sum = current_sum # Slide the window over the array for i in range(k, n): current_sum += nums[i] - nums[i - k] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def decode_rle(s: str) -> str: Decodes a run-length encoded string. :param s: Encoded string in the format <count><char>. :return: Decoded string. >>> decode_rle(\\"3a2b4c\\") \\"aaabbcccc\\" >>> decode_rle(\\"1a\\") \\"a\\" >>> decode_rle(\\"10z\\") \\"zzzzzzzzzz\\" >>> decode_rle(\\"1a2b3c4d\\") \\"abbcccdddd\\" >>> decode_rle(\\"12a1b13c\\") \\"aaaaaaaaaaaabccccccccccccc\\" >>> decode_rle(\\"2a10b2c\\") \\"aabbbbbbbbbbcc\\"","solution":"def decode_rle(s): Decodes a run-length encoded string. :param s: Encoded string in the format <count><char>. :return: Decoded string. decoded_string = \\"\\" i = 0 while i < len(s): count = 0 # Extract the number while s[i].isdigit(): count = count * 10 + int(s[i]) i += 1 # Append the character 'count' number of times if i < len(s): decoded_string += s[i] * count i += 1 return decoded_string"},{"question":"def stoneGame(piles: List[int]) -> bool: Determines if Alice will win the stone game given her starting turn. :param piles: List[int], the values of the coins in the line :return: bool, True if Alice will win, False if Bob will win >>> stoneGame([5, 3, 4, 5]) True >>> stoneGame([3, 9, 1, 2]) True >>> stoneGame([1, 2, 3, 4, 5, 6, 7, 8]) True >>> stoneGame([5, 5, 5, 5]) True >>> stoneGame([1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000]) True >>> stoneGame([1, 2]) True","solution":"def stoneGame(piles): Determines if Alice will win the stone game given her starting turn. :param piles: List[int], the values of the coins in the line :return: bool, True if Alice will win, False if Bob will win # Since the number of coins is even and both players are playing optimally, # Alice will always win if she picks first. return True"},{"question":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_bottom_left_value(root: TreeNode) -> int: Given a binary tree, find the leftmost value in the last row of the tree. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> find_bottom_left_value(root) == 4","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_bottom_left_value(root): This function returns the leftmost value in the last row of the binary tree. We use a level-order traversal (BFS) to ensure we visit all nodes level-by-level. if not root: return None queue = deque([root]) leftmost_value = 0 while queue: num_nodes = len(queue) for i in range(num_nodes): node = queue.popleft() if i == 0: leftmost_value = node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) return leftmost_value"},{"question":"class StockProfit: def __init__(self, prices): Initializes the object with the array of stock prices. self.prices = prices def maxProfit(self): Returns the maximum profit achievable with at most two trades. >>> StockProfit([]).maxProfit() 0 >>> StockProfit([100]).maxProfit() 0 >>> StockProfit([1, 2]).maxProfit() 1 >>> StockProfit([3, 3, 5, 0, 0, 3, 1, 4]).maxProfit() 6 >>> StockProfit([7, 6, 4, 3, 1]).maxProfit() 0 >>> StockProfit([1, 2, 3, 4, 5, 0, 2, 3, 1, 4]).maxProfit() 8 >>> StockProfit([1, 2, 4, 2, 5, 7, 2, 4, 9, 0]).maxProfit() 13","solution":"class StockProfit: def __init__(self, prices): Initializes the object with the array of stock prices. self.prices = prices def maxProfit(self): Returns the maximum profit achievable with at most two trades. if not self.prices or len(self.prices) < 2: return 0 # Create DP tables to store profits n = len(self.prices) profit = [[0 for _ in range(n)] for _ in range(3)] for k in range(1, 3): max_so_far = float('-inf') for i in range(1, n): max_so_far = max(max_so_far, profit[k-1][i-1] - self.prices[i-1]) profit[k][i] = max(profit[k][i-1], self.prices[i] + max_so_far) return profit[2][-1]"},{"question":"def is_monotonic(arr: List[int]) -> bool: Checks if the array is monotonic (either entirely non-increasing or non-decreasing). >>> is_monotonic([1, 2, 2, 3]) == True >>> is_monotonic([4, 3, 3, 2, 1]) == True >>> is_monotonic([1, 3, 2]) == False >>> is_monotonic([]) == True >>> is_monotonic([1]) == True >>> is_monotonic([7, 7, 7, 7]) == True >>> is_monotonic([1, 1, 1, 2, 2, 2, 3, 3, 3]) == True >>> is_monotonic([3, 2, 1, 1, 1, 1, 0, 0, -1]) == True >>> is_monotonic([1, 2, 3, 3, 2]) == False >>> is_monotonic([3, 2, 1, 2, 3]) == False # Your implementation goes here","solution":"def is_monotonic(arr): Checks if the array is monotonic (either entirely non-increasing or non-decreasing). if len(arr) <= 1: return True increasing = decreasing = True for i in range(1, len(arr)): if arr[i] > arr[i - 1]: decreasing = False if arr[i] < arr[i - 1]: increasing = False if not increasing and not decreasing: return False return increasing or decreasing"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def in_order_traversal(root): Returns the list of values for the nodes encountered during an in-order traversal of the binary tree. >>> root = TreeNode(1, None, TreeNode(2, TreeNode(3), None)) >>> in_order_traversal(root) [1, 3, 2] >>> root = TreeNode(3, TreeNode(2, TreeNode(1), None), None) >>> in_order_traversal(root) [1, 2, 3] >>> root = TreeNode(1) >>> in_order_traversal(root) [1] >>> in_order_traversal(None) [] >>> root = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3)) >>> in_order_traversal(root) [4, 2, 5, 1, 3]","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def in_order_traversal(root): Returns the list of values for the nodes encountered during an in-order traversal of the binary tree. result = [] def helper(node): if not node: return helper(node.left) result.append(node.value) helper(node.right) helper(root) return result"},{"question":"def min_deletions_to_avoid_repeating_chars(s: str, m: int) -> int: Return the minimum number of deletions required so that no character in the string appears more than \`m\` times consecutively. >>> min_deletions_to_avoid_repeating_chars(\\"aabb\\", 2) 0 >>> min_deletions_to_avoid_repeating_chars(\\"abcabc\\", 1) 0 >>> min_deletions_to_avoid_repeating_chars(\\"aaabb\\", 2) 1 >>> min_deletions_to_avoid_repeating_chars(\\"aaaaa\\", 2) 3 >>> min_deletions_to_avoid_repeating_chars(\\"aaaabbbbb\\", 2) 5 >>> min_deletions_to_avoid_repeating_chars(\\"aaaabbbb\\", 4) 0 >>> min_deletions_to_avoid_repeating_chars(\\"aaaabbbb\\", 5) 0 >>> min_deletions_to_avoid_repeating_chars(\\"aaabbb\\", 1) 4 >>> min_deletions_to_avoid_repeating_chars(\\"aaabbbccc\\", 2) 3","solution":"def min_deletions_to_avoid_repeating_chars(s, m): deletions = 0 i = 0 while i < len(s): count = 1 while i + 1 < len(s) and s[i] == s[i + 1]: count += 1 i += 1 if count > m: deletions += count - m i += 1 return deletions"},{"question":"from typing import List def best_performer_in_subtree(manager: List[int], performance: List[int]) -> List[int]: Returns an array \`best_performer\` of length \`n\` such that \`best_performer[i]\` contains the ID of the employee in the subtree rooted at \`i\` (including \`i\` itself) who has the highest performance score. >>> best_performer_in_subtree([-1, 0, 0, 1, 1, 2, 2], [5, 3, 3, 2, 4, 1, 6]) [6, 4, 6, 3, 4, 5, 6] >>> best_performer_in_subtree([-1], [5]) [0] >>> best_performer_in_subtree([-1, 0, 0, 1, 1, 2, 2], [3, 3, 3, 3, 3, 3, 3]) [0, 1, 2, 3, 4, 5, 6] >>> best_performer_in_subtree([-1, 0, 0, 1, 1, 2, 2], [10, 3, 2, 4, 4, 1, 2]) [0, 3, 2, 3, 4, 5, 6] >>> best_performer_in_subtree([-1, 0, 0, 1, 1, 2, 2], [1, 2, 3, 4, 5, 6, 7]) [6, 4, 6, 3, 4, 5, 6]","solution":"from typing import List import collections def best_performer_in_subtree(manager: List[int], performance: List[int]) -> List[int]: n = len(manager) tree = collections.defaultdict(list) # Build the tree for i in range(1, n): tree[manager[i]].append(i) def dfs(node): best = node # Traverse all children for child in tree[node]: candidate = dfs(child) if (performance[candidate] > performance[best]) or (performance[candidate] == performance[best] and candidate < best): best = candidate result[node] = best return best result = [0] * n dfs(0) return result"},{"question":"def longest_common_subsequence(word1: str, word2: str) -> int: Returns the length of the longest common subsequence of word1 and word2. >>> longest_common_subsequence(\\"abcde\\", \\"ace\\") 3 >>> longest_common_subsequence(\\"abc\\", \\"abc\\") 3 >>> longest_common_subsequence(\\"abc\\", \\"def\\") 0 >>> longest_common_subsequence(\\"\\", \\"abc\\") 0 >>> longest_common_subsequence(\\"abc\\", \\"\\") 0 >>> longest_common_subsequence(\\"\\", \\"\\") 0 >>> longest_common_subsequence(\\"a\\", \\"a\\") 1 >>> longest_common_subsequence(\\"a\\", \\"b\\") 0 >>> longest_common_subsequence(\\"abcdefg\\", \\"bdf\\") 3 >>> longest_common_subsequence(\\"oxcpqrsvwf\\", \\"shmtulqrypy\\") 2","solution":"def longest_common_subsequence(word1, word2): Returns the length of the longest common subsequence between word1 and word2. m, n = len(word1), len(word2) # Create a 2D array to store lengths of longest common subsequence. dp = [[0] * (n + 1) for _ in range(m + 1)] # Build the dp array from bottom up. for i in range(1, m + 1): for j in range(1, n + 1): if word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"def min_path_sum(grid: List[List[int]]) -> int: Given a 2D grid, find the minimum cost path from top-left to bottom-right. You can only move down or right at any point in time. :param grid: List[List[int]], a 2D list representing the grid :return: int, the minimum cost to reach the bottom-right corner >>> min_path_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 21 >>> min_path_sum([[1, 2, 3, 4, 5]]) == 15 >>> min_path_sum([[1], [2], [3], [4], [5]]) == 15 >>> min_path_sum([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) == 7 >>> min_path_sum([]) == 0 >>> min_path_sum([[]]) == 0","solution":"def min_path_sum(grid): Given a 2D grid, find the minimum cost path from top-left to bottom-right. You can only move down or right at any point in time. :param grid: List[List[int]], a 2D list representing the grid :return: int, the minimum cost to reach the bottom-right corner if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Initialize the cost grid with the same dimensions as the input grid. cost = [[0] * n for _ in range(m)] # Initial cell cost[0][0] = grid[0][0] # Initialize the first column of the cost grid. for i in range(1, m): cost[i][0] = cost[i-1][0] + grid[i][0] # Initialize the first row of the cost grid. for j in range(1, n): cost[0][j] = cost[0][j-1] + grid[0][j] # Fill in the remaining cells of the cost grid. for i in range(1, m): for j in range(1, n): cost[i][j] = min(cost[i-1][j], cost[i][j-1]) + grid[i][j] return cost[m-1][n-1]"},{"question":"def min_length(s: str) -> int: Returns the length of the shortest possible string after performing the delete operation on any two adjacent characters if they are different. pass # Unit tests def test_min_length_empty_string(): assert min_length(\\"\\") == 0 def test_min_length_example1(): assert min_length(\\"ab\\") == 0 def test_min_length_example2(): assert min_length(\\"aab\\") == 1 def test_min_length_example3(): assert min_length(\\"abba\\") == 0 def test_min_length_example4(): assert min_length(\\"ababab\\") == 0 def test_min_length_example5(): assert min_length(\\"aaaa\\") == 4 def test_min_length_single_char(): assert min_length(\\"a\\") == 1 assert min_length(\\"b\\") == 1","solution":"def min_length(s: str) -> int: Returns the length of the shortest possible string after performing the delete operation on any two adjacent characters if they are different. stack = [] for char in s: if stack and stack[-1] != char: stack.pop() else: stack.append(char) return len(stack)"},{"question":"class SparseVector: def __init__(self, nums): Initialize the SparseVector with an array of integers. Instead of storing 0's, only store non-zero elements in a dictionary. def dotProduct(self, vec): Return the dot product of two sparse vectors. Dot product is the sum of products of corresponding elements. from solution import SparseVector def test_dot_product_with_no_overlap(): v1 = SparseVector([1, 0, 0, 2, 3]) v2 = SparseVector([0, 3, 0, 4, 0]) assert v1.dotProduct(v2) == 8 def test_dot_product_with_full_overlap(): v1 = SparseVector([1, 0, 0, 2, 3]) v2 = SparseVector([1, 0, 0, 3, 4]) assert v1.dotProduct(v2) == 19 def test_dot_product_with_zeros(): v1 = SparseVector([0, 0, 0, 0, 0]) v2 = SparseVector([0, 0, 0, 0, 0]) assert v1.dotProduct(v2) == 0 def test_dot_product_with_one_empty_vector(): v1 = SparseVector([1, 0, 0, 2, 3]) v2 = SparseVector([0, 0, 0, 0, 0]) assert v1.dotProduct(v2) == 0 def test_dot_product_with_alternating_values(): v1 = SparseVector([1, 0, 2, 0, 3]) v2 = SparseVector([0, 4, 0, 5, 0]) assert v1.dotProduct(v2) == 0","solution":"class SparseVector: def __init__(self, nums): Initialize the SparseVector with an array of integers. Instead of storing 0's, only store non-zero elements in a dictionary. self.non_zero_elements = {i: num for i, num in enumerate(nums) if num != 0} def dotProduct(self, vec): Return the dot product of two sparse vectors. Dot product is the sum of products of corresponding elements. result = 0 for idx, value in self.non_zero_elements.items(): if idx in vec.non_zero_elements: result += value * vec.non_zero_elements[idx] return result"},{"question":"class TreeNode: def __init__(self, id): self.id = id self.children = [] def find_lcm(root: TreeNode, id1: int, id2: int) -> TreeNode: Given the root of an n-ary tree representing a hierarchical department structure, find the lowest common manager (LCM) between two given department IDs id1 and id2. >>> root = TreeNode(1) >>> root.children = [TreeNode(2), TreeNode(3), TreeNode(4)] >>> root.children[0].children = [TreeNode(5), TreeNode(6)] >>> root.children[1].children = [TreeNode(7)] >>> root.children[2].children = [TreeNode(8), TreeNode(9)] >>> find_lcm(root, 5, 9).id 1 >>> find_lcm(root, 2, 6).id 2 >>> find_lcm(root, 5, 6).id 2 >>> find_lcm(root, 5, 7).id 1 >>> find_lcm(root, 1, 5).id 1","solution":"class TreeNode: def __init__(self, id): self.id = id self.children = [] def find_lcm(root, id1, id2): if not root: return None if root.id == id1 or root.id == id2: return root count = 0 temp = None for child in root.children: res = find_lcm(child, id1, id2) if res: count += 1 temp = res if count == 2: return root return temp"},{"question":"def find_minimum_platforms(arrival, departure): Returns the minimum number of platforms required for the given arrival and departure times. >>> find_minimum_platforms([900, 940, 950, 1100, 1500, 1800], [910, 1200, 1120, 1130, 1900, 2000]) == 3 >>> find_minimum_platforms([900, 940], [910, 950]) == 1 >>> find_minimum_platforms([900], [910]) == 1 >>> find_minimum_platforms([900, 1100], [1000, 1200]) == 1 >>> find_minimum_platforms([900, 1100, 1235], [1005, 1205, 1240]) == 1 >>> find_minimum_platforms([1000, 1015, 1030], [1030, 1045, 1100]) == 3 pass","solution":"def find_minimum_platforms(arrival, departure): Returns the minimum number of platforms required for the given arrival and departure times. # Sort both the arrays arrival.sort() departure.sort() n = len(arrival) platform_needed = 1 result = 1 i = 1 # Pointer to the next arrival event j = 0 # Pointer to the next departure event while i < n and j < n: # If next event in the sorted order is arrival, increment count of platforms needed if arrival[i] <= departure[j]: platform_needed += 1 i += 1 # Else decrement count of platforms needed else: platform_needed -= 1 j += 1 # Update result if needed if platform_needed > result: result = platform_needed return result"},{"question":"def smallestStringWithSwaps(s: str, pairs: List[List[int]]) -> str: Given a string \`s\` and an array of pairs of indices in the string \`pairs\` where pairs[i] = [a, b] represents a swap operation that can be performed on the characters at indices \`a\` and \`b\`, return the lexicographically smallest string that \`s\` can be transformed into after using the swap operations any number of times. >>> smallestStringWithSwaps(\\"dcab\\", [[0,3]]) == \\"bcad\\" >>> smallestStringWithSwaps(\\"dcab\\", [[0,3], [1,2]]) == \\"bacd\\" >>> smallestStringWithSwaps(\\"dcab\\", [[0,3], [1,2], [0,2]]) == \\"abcd\\" >>> smallestStringWithSwaps(\\"dcab\\", []) == \\"dcab\\" >>> smallestStringWithSwaps(\\"cba\\", [[0, 1], [1, 2], [0, 2]]) == \\"abc\\"","solution":"def smallestStringWithSwaps(s, pairs): from collections import defaultdict parent = list(range(len(s))) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootY] = rootX for a, b in pairs: union(a, b) components = defaultdict(list) for i, p in enumerate(parent): components[find(p)].append(i) res = list(s) for indices in components.values(): chars = sorted(res[i] for i in indices) for idx, char in zip(sorted(indices), chars): res[idx] = char return ''.join(res)"},{"question":"def maxEvents(events): Returns the maximum number of events one can attend from a given list of events. :param events: List of lists, where each sublist contains two integers [startDayi, endDayi] representing the start and end day of an event. :return: Maximum number of events that can be attended if only one event can be attended per day. >>> maxEvents([[1, 2]]) 1 >>> maxEvents([[1, 2], [3, 4], [5, 6]]) 3 >>> maxEvents([[1, 3], [2, 5], [3, 7]]) 3 >>> maxEvents([[1, 1], [1, 1], [1, 1]]) 1 >>> maxEvents([[1, 4], [1, 1], [3, 5], [2, 2]]) 4 >>> maxEvents([[1, 100], [1, 2], [2, 3], [3, 4]]) 4 >>> maxEvents([[1, 2], [2, 3], [3, 4], [1, 4]]) 4","solution":"def maxEvents(events): Returns the maximum number of events one can attend from a given list of events. :param events: List of lists, where each sublist contains two integers [startDayi, endDayi] representing the start and end day of an event. :return: Maximum number of events that can be attended if only one event can be attended per day. events.sort(key=lambda x: x[1]) # Sort events by their end days attended_days = set() max_events = 0 for start, end in events: for day in range(start, end + 1): if day not in attended_days: attended_days.add(day) max_events += 1 break return max_events"},{"question":"def closed_island(grid): Returns the number of closed islands in the given matrix grid. A closed island is surrounded by 1's on all four sides (including diagonals) and can only contain 0's inside. Any 0 on the border of the grid is not considered an island. >>> closed_island([[1, 1, 0, 1, 1, 1], [1, 0, 0, 1, 0, 1], [1, 1, 1, 1, 0, 1], [1, 1, 0, 1, 1, 1]]) == 1 >>> closed_island([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) == 0 >>> closed_island([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) == 0 >>> closed_island([[1, 0, 1, 0, 1]]) == 0 >>> closed_island([[1], [0], [1]]) == 0 >>> closed_island([[1, 1, 0, 1, 1, 1], [1, 0, 0, 1, 0, 1], [1, 1, 1, 1, 1, 1], [1, 0, 0, 1, 1, 1], [1, 1, 1, 1, 1, 1]]) == 2","solution":"def closed_island(grid): Returns the number of closed islands in the given matrix grid. A closed island is surrounded by 1's on all four sides and can only contain 0's inside. def dfs(i, j): if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]): return False # This means we reached the border (not a closed island) if grid[i][j] == 1: return True # This means this part is surrounded # Mark the part of the grid as visited by changing 0 to 1 grid[i][j] = 1 # Check in all four directions top = dfs(i-1, j) bottom = dfs(i+1, j) left = dfs(i, j-1) right = dfs(i, j+1) # If all four directions are surrounded then it's a closed island return top and bottom and left and right closed_islands_count = 0 # Iterate through the grid for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 0: # Start a DFS if it's part of an island if dfs(i, j): # If it's a closed island increment the count closed_islands_count += 1 return closed_islands_count"},{"question":"def longest_subsequence_length(sequence: str, words: List[str]) -> int: Given a string \`sequence\` and an array of strings \`words\`, find the length of the longest string in \`words\` that is a subsequence of \`sequence\`. A subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements. Implement a function that returns this length. If no word in \`words\` is a subsequence of \`sequence\`, return \`0\`. >>> longest_subsequence_length(\\"abc\\", [\\"def\\", \\"ghi\\"]) 0 >>> longest_subsequence_length(\\"abcde\\", [\\"a\\", \\"ac\\", \\"ace\\"]) 3 >>> longest_subsequence_length(\\"abcde\\", [\\"a\\", \\"b\\", \\"cde\\", \\"ace\\"]) 3 >>> longest_subsequence_length(\\"\\", [\\"a\\", \\"b\\", \\"c\\"]) 0 >>> longest_subsequence_length(\\"abc\\", []) 0 >>> longest_subsequence_length(\\"abcde\\", [\\"abcde\\", \\"abcd\\", \\"abc\\", \\"ab\\", \\"a\\"]) 5 >>> longest_subsequence_length(\\"abcdefg\\", [\\"abf\\", \\"acf\\", \\"abcg\\"]) 4","solution":"def is_subsequence(seq, word): Helper function to check if 'word' is a subsequence of 'seq'. it = iter(seq) return all(char in it for char in word) def longest_subsequence_length(sequence, words): Returns the length of the longest string in 'words' that is a subsequence of 'sequence'. If no word is a subsequence of 'sequence', returns 0. max_length = 0 for word in words: if is_subsequence(sequence, word): max_length = max(max_length, len(word)) return max_length"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Given an integer array 'nums' of size 'n', return an array of size 'n' where the value at each index 'i' is equal to the product of all elements in the input array except 'nums[i]'. Runs in O(n) time and uses O(1) extra space (excluding the output array). Division is not allowed in this solution. >>> product_except_self([1]) [1] >>> product_except_self([1, 2]) [2, 1] >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([1, 2, 0, 4]) [0, 0, 8, 0] >>> product_except_self([0, 0]) [0, 0] >>> product_except_self([1, -2, 3, -4]) [24, -12, 8, -6] >>> product_except_self([-1, 2, 0, -4]) [0, 0, 8, 0]","solution":"def product_except_self(nums): Returns an array where each element at index i is the product of all elements in the input array except nums[i]. The function runs in O(n) time and uses O(1) extra space (excluding the output array). Division is not used in this solution. n = len(nums) result = [1] * n # Traverse from left to right left_product = 1 for i in range(n): result[i] = left_product left_product *= nums[i] # Traverse from right to left right_product = 1 for i in reversed(range(n)): result[i] *= right_product right_product *= nums[i] return result"},{"question":"def min_playgrounds(start: List[int], end: List[int]) -> int: Determine the minimum number of playgrounds required such that no child's playtime overlaps with another. Parameters: start (List[int]): Start times of the children. end (List[int]): End times of the children. Returns: int: Minimum number of playgrounds required. >>> min_playgrounds([1, 3, 5], [2, 4, 6]) 1 >>> min_playgrounds([1, 2, 3], [4, 5, 6]) 3 >>> min_playgrounds([1, 2, 4], [3, 5, 6]) 2 >>> min_playgrounds([1, 2], [10, 3]) 2 >>> min_playgrounds([1], [2]) 1 >>> min_playgrounds([1, 2, 3, 5], [4, 6, 8, 7]) 3 >>> min_playgrounds([1, 1, 1], [2, 2, 2]) 3 >>> min_playgrounds([6, 1, 4, 2], [7, 3, 5, 8]) 2 pass","solution":"def min_playgrounds(start, end): Determine the minimum number of playgrounds required such that no child's playtime overlaps with another. Parameters: start (List[int]): Start times of the children. end (List[int]): End times of the children. Returns: int: Minimum number of playgrounds required. events = [] for s in start: events.append((s, 1)) # 1 indicates a start event for e in end: events.append((e, -1)) # -1 indicates an end event events.sort() # Sort events primarily by time max_playgrounds = 0 current_playgrounds = 0 for event in events: current_playgrounds += event[1] max_playgrounds = max(max_playgrounds, current_playgrounds) return max_playgrounds"},{"question":"def longest_warm_period(temperature: List[int]) -> int: Returns the length of the longest warm period. The longest warm period is defined as the longest consecutive sequence of days where the temperature strictly increases. >>> longest_warm_period([10]) == 1 >>> longest_warm_period([20, 20, 20]) == 1 >>> longest_warm_period([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 10 >>> longest_warm_period([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) == 1 >>> longest_warm_period([1, 2, 3, 1, 2, 3, 4, 1]) == 4 >>> longest_warm_period([1, 2, 3, 1, 2, 3, 1]) == 3 >>> longest_warm_period([5, 5, 5, 5, 5]) == 1 >>> longest_warm_period([1, 2, 1, 2, 1, 2, 1, 2]) == 2 >>> longest_warm_period([]) == 0 # Your code here","solution":"def longest_warm_period(temperature): Returns the length of the longest warm period. if not temperature: return 0 max_length = 0 current_length = 1 for i in range(1, len(temperature)): if temperature[i] > temperature[i - 1]: current_length += 1 else: if current_length > max_length: max_length = current_length current_length = 1 if current_length > max_length: max_length = current_length return max_length"},{"question":"def is_valid_word_segment(s: str, n: int) -> bool: You are given a string \`s\` containing only digits and an integer \`n\`. You need to split the string \`s\` into exactly \`n\` segments such that each segment represents a valid English word (e.g., \\"one\\", \\"two\\", \\"three\\"). Return whether it is possible to split the string in such a manner. Note that the same word can be used multiple times in different segments, and each digit must belong to exactly one segment. >>> is_valid_word_segment(\\"onetwothree\\", 3) True >>> is_valid_word_segment(\\"onetwoone\\", 3) True >>> is_valid_word_segment(\\"onetwothree\\", 2) False >>> is_valid_word_segment(\\"fourfive\\", 3) False >>> is_valid_word_segment(\\"zero\\", 1) True >>> is_valid_word_segment(\\"nine\\", 1) True >>> is_valid_word_segment(\\"\\", 0) True >>> is_valid_word_segment(\\"\\", 1) False >>> is_valid_word_segment(\\"eleven\\", 1) False >>> is_valid_word_segment(\\"thirteen\\", 1) False pass # your code here","solution":"def is_valid_word_segment(s, n): digit_word_map = { \\"0\\": \\"zero\\", \\"1\\": \\"one\\", \\"2\\": \\"two\\", \\"3\\": \\"three\\", \\"4\\": \\"four\\", \\"5\\": \\"five\\", \\"6\\": \\"six\\", \\"7\\": \\"seven\\", \\"8\\": \\"eight\\", \\"9\\": \\"nine\\" } def can_form_words(s, n): if n == 0: return s == \\"\\" for length in range(1, len(s) + 1): if s[:length] in digit_word_map.values() and can_form_words(s[length:], n - 1): return True return False return can_form_words(s, n)"},{"question":"from collections import Counter def find_anagrams(s, p): Finds all start indices of p's anagrams in s. Parameters: s (str): The main string. p (str): The pattern string. Returns: list: A list of starting indices of anagrams of p in s. >>> find_anagrams(\\"cbaebabacd\\", \\"abc\\") [0, 6] >>> find_anagrams(\\"abcdefgh\\", \\"xyz\\") [] >>> find_anagrams(\\"abab\\", \\"ab\\") [0, 1, 2] >>> find_anagrams(\\"aaaaa\\", \\"a\\") [0, 1, 2, 3, 4] >>> find_anagrams(\\"cbaEbABacD\\".lower(), \\"abc\\".lower()) [0, 6]","solution":"from collections import Counter def find_anagrams(s, p): Finds all start indices of p's anagrams in s. Parameters: s (str): The main string. p (str): The pattern string. Returns: list: A list of starting indices of anagrams of p in s. p_counter = Counter(p) s_counter = Counter(s[:len(p) - 1]) result = [] for i in range(len(p) - 1, len(s)): start_index = i - len(p) + 1 s_counter[s[i]] += 1 if s_counter == p_counter: result.append(start_index) s_counter[s[start_index]] -= 1 if s_counter[s[start_index]] == 0: del s_counter[s[start_index]] return result"},{"question":"def nim_game(arr: List[int]) -> bool: Returns True if the first player has a winning strategy in the Nim game, otherwise returns False. >>> nim_game([1]) True >>> nim_game([0]) False >>> nim_game([1, 1]) False >>> nim_game([1, 2]) True >>> nim_game([1, 1, 1]) True >>> nim_game([1, 2, 3]) False >>> nim_game([4, 5, 6, 7]) False >>> nim_game([4, 2, 5, 6]) True >>> nim_game([0, 0, 0]) False >>> nim_game([10**6, 10**6 - 1]) True >>> nim_game([10**9, 10**9]) False","solution":"def nim_game(arr): Returns True if the first player has a winning strategy in the Nim game, otherwise returns False. xor_sum = 0 for pile in arr: xor_sum ^= pile return xor_sum != 0"},{"question":"def longest_consecutive(nums): Returns the length of the longest consecutive elements sequence in the unsorted array. Example: >>> longest_consecutive([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive([]) 0 >>> longest_consecutive([1]) 1 >>> longest_consecutive([10, 5, 12, 6, 3, 4, 11, 8, 7, 9]) 10 >>> longest_consecutive([2, 2, 1, 1, 3, 3, 4, 4]) 4 >>> longest_consecutive([50, 3, 2, 1, 100, 200]) 3 >>> longest_consecutive([-1, -2, -3, 0, 1]) 5","solution":"def longest_consecutive(nums): Returns the length of the longest consecutive elements sequence in the unsorted array. if not nums: return 0 num_set = set(nums) max_length = 0 for num in num_set: if num - 1 not in num_set: # Check if it's the start of a sequence current_num = num current_length = 1 while current_num + 1 in num_set: current_num += 1 current_length += 1 max_length = max(max_length, current_length) return max_length"},{"question":"def rob(nums: List[int]) -> int: Returns the maximum amount of money the thief can rob without robbing two consecutive houses. >>> rob([]) == 0 >>> rob([50]) == 50 >>> rob([10, 20]) == 20 >>> rob([10, 20, 30]) == 40 >>> rob([2, 7, 9, 3, 1]) == 12 >>> rob([6, 7, 1, 30, 8, 2, 4]) == 41 >>> rob([5, 5, 5, 5, 5]) == 15","solution":"def rob(nums): Returns the maximum amount of money the thief can rob without robbing two consecutive houses. if not nums: return 0 if len(nums) == 1: return nums[0] # Initialize variables to track the maximum amount of money prev = 0 current = 0 for num in nums: temp = current current = max(current, prev + num) prev = temp return current"},{"question":"def longest_substring_with_changes(s: str, k: int) -> int: Returns the length of the longest substring containing only one unique character after performing up to k changes. >>> longest_substring_with_changes(\\"aabccbb\\", 2) 5 >>> longest_substring_with_changes(\\"abbcb\\", 1) 4 >>> longest_substring_with_changes(\\"abccde\\", 1) 3 >>> longest_substring_with_changes(\\"aaaa\\", 2) 4 >>> longest_substring_with_changes(\\"\\", 2) 0 >>> longest_substring_with_changes(\\"a\\", 1) 1 >>> longest_substring_with_changes(\\"abc\\", 0) 1 >>> longest_substring_with_changes(\\"aaaaaa\\", 2) 6 >>> longest_substring_with_changes(\\"abbaa\\", 2) 5 >>> longest_substring_with_changes(\\"aabbab\\", 2) 5","solution":"def longest_substring_with_changes(s, k): Returns the length of the longest substring containing only one unique character after performing up to k changes. from collections import defaultdict n = len(s) if n == 0: return 0 left = 0 max_len = 0 max_count = 0 char_count = defaultdict(int) for right in range(n): char_count[s[right]] += 1 max_count = max(max_count, char_count[s[right]]) if (right - left + 1 - max_count) > k: char_count[s[left]] -= 1 left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"def get_smallest_string(s: str, k: int) -> str: Returns the lexicographically smallest string that can be obtained by performing at most k adjacent swaps. >>> get_smallest_string(\\"dcab\\", 1) \\"cdab\\" >>> get_smallest_string(\\"dcab\\", 3) \\"abcd\\" >>> get_smallest_string(\\"dcab\\", 0) \\"dcab\\" >>> get_smallest_string(\\"geeks\\", 5) \\"eegks\\" >>> get_smallest_string(\\"aabbcc\\", 2) \\"aabbcc\\" >>> get_smallest_string(\\"aabbcc\\", 4) \\"aabbcc\\" >>> get_smallest_string(\\"bdca\\", 10) \\"abcd\\" >>> get_smallest_string(\\"edcba\\", 4) \\"abcde\\"","solution":"def get_smallest_string(s, k): Returns the lexicographically smallest string that can be obtained by performing at most k adjacent swaps. if k >= len(s) - 1: return ''.join(sorted(s)) s = list(s) # convert string to list for easier operations for i in range(len(s)): pos = i for j in range(i + 1, min(i + k + 1, len(s))): if s[j] < s[pos]: pos = j for j in range(pos, i, -1): s[j], s[j - 1] = s[j - 1], s[j] k -= 1 if k == 0: return ''.join(s) return ''.join(s)"},{"question":"from typing import List def maxProfitWithTwoTransactions(prices: List[int]) -> int: Compute the maximum possible profit by buying and selling the stock at most twice. >>> maxProfitWithTwoTransactions([3,3,5,0,0,3,1,4]) 6 >>> maxProfitWithTwoTransactions([]) 0 >>> maxProfitWithTwoTransactions([3]) 0 >>> maxProfitWithTwoTransactions([7, 6, 4, 3, 1]) 0 >>> maxProfitWithTwoTransactions([1, 2, 3, 4, 5, 6]) 5 >>> maxProfitWithTwoTransactions([1, 2, 4, 2, 5, 7, 2, 4, 9, 0]) 13","solution":"def maxProfitWithTwoTransactions(prices): Function to calculate the maximum profit with at most two transactions. if not prices: return 0 n = len(prices) # Forward traversal to find max profit till each day with one transaction left_profits = [0] * n min_price = prices[0] for i in range(1, n): min_price = min(min_price, prices[i]) left_profits[i] = max(left_profits[i-1], prices[i] - min_price) # Backward traversal to find max profit from each day onwards with one transaction right_profits = [0] * n max_price = prices[-1] for i in range(n-2, -1, -1): max_price = max(max_price, prices[i]) right_profits[i] = max(right_profits[i+1], max_price - prices[i]) # Combine the two results to find the maximum profit with at most two transactions max_profit = 0 for i in range(n): max_profit = max(max_profit, left_profits[i] + right_profits[i]) return max_profit"},{"question":"def sum_previous_k_elements(arr1: List[int], k: int) -> List[int]: Given an array \`arr1\` of integers and an integer \`k\`, return an array \`arr2\` where each element in \`arr2\` is the sum of the previous \`k\` elements in \`arr1\`. If there are fewer than \`k\` elements before an element, sum all the available elements. >>> sum_previous_k_elements([1, 2, 3, 4, 5], 3) [1, 3, 6, 9, 12] >>> sum_previous_k_elements([1, 2, 3, 4, 5], 1) [1, 2, 3, 4, 5] >>> sum_previous_k_elements([1, 2, 3, 4, 5], 2) [1, 3, 5, 7, 9] >>> sum_previous_k_elements([-1, -2, -3, -4, -5], 3) [-1, -3, -6, -9, -12] >>> sum_previous_k_elements([0, 0, 0, 0], 2) [0, 0, 0, 0] >>> sum_previous_k_elements([10], 3) [10] >>> sum_previous_k_elements([5, 10, 15], 5) [5, 15, 30]","solution":"def sum_previous_k_elements(arr1, k): Returns an array where each element is the sum of the previous \`k\` elements in \`arr1\`. If there are fewer than \`k\` elements before an element, sum all available elements. arr2 = [] for i in range(len(arr1)): start_index = max(0, i - k + 1) arr2.append(sum(arr1[start_index:i+1])) return arr2"},{"question":"def longestUniqueSubstring(s: str) -> int: Returns the length of the longest substring with all unique characters. >>> longestUniqueSubstring(\\"abcdef\\") == 6 >>> longestUniqueSubstring(\\"abcabcbb\\") == 3 >>> longestUniqueSubstring(\\"bbbb\\") == 1 >>> longestUniqueSubstring(\\"\\") == 0 >>> longestUniqueSubstring(\\"pwwkew\\") == 3 >>> longestUniqueSubstring(\\"abcdabcbb\\") == 4 >>> longestUniqueSubstring(\\"abcbbxyz\\") == 4","solution":"def longestUniqueSubstring(s): Returns the length of the longest substring with all unique characters. n = len(s) if n == 0: return 0 max_length = 0 start = 0 char_index_map = {} for end in range(n): if s[end] in char_index_map: start = max(start, char_index_map[s[end]] + 1) char_index_map[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"def find_colleague(n: int, k: int) -> int: Returns the ID of the colleague holding the ball after k passes. Parameters: n (int): the number of colleagues k (int): the number of passes Returns: int: the ID of the colleague holding the ball >>> find_colleague(5, 0) 1 >>> find_colleague(5, 1) 2 >>> find_colleague(5, 7) 3 >>> find_colleague(5, 10) 1 >>> find_colleague(5, 11) 2 >>> find_colleague(4, 4) 1 >>> find_colleague(10, 1000000000) 1","solution":"def find_colleague(n, k): Returns the ID of the colleague holding the ball after k passes. Parameters: n (int): the number of colleagues k (int): the number of passes Returns: int: the ID of the colleague holding the ball return (k % n) + 1"},{"question":"from typing import List def max_rectangular_area(heights: List[int]) -> int: Calculate the maximum rectangular area using the heights of buildings. >>> max_rectangular_area([2, 1, 5, 6, 2, 3]) == 10 >>> max_rectangular_area([2, 4]) == 4 >>> max_rectangular_area([1, 1, 1, 1, 1, 1]) == 6 >>> max_rectangular_area([6, 5, 4, 3, 2, 1]) == 12 >>> max_rectangular_area([1, 2, 3, 4, 5, 6]) == 12 >>> max_rectangular_area([1]) == 1 >>> max_rectangular_area([]) == 0","solution":"def max_rectangular_area(heights): Calculate the maximum rectangular area using the heights of buildings. Parameters: heights (list): List of integers representing the heights of buildings Returns: int: Maximum area for rectangular block stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def count_pairs(nums: List[int], target: int) -> int: Return the number of different pairs (i, j) such that nums[i] + nums[j] == target and i < j. Args: nums (List[int]): A list of integers. target (int): The target sum. Returns: int: The number of valid pairs. Examples: >>> count_pairs([1, 2, 3, 4, 5], 5) 2 >>> count_pairs([1, 2, 3, 4, 5], 10) 0 >>> count_pairs([2, 2, 2, 2], 4) 6 >>> count_pairs([-1, -2, -3, -4, -5], -8) 1 >>> count_pairs([-1, 2, 9, -2, 1, 3], 1) 2","solution":"def count_pairs(nums, target): Returns the number of different pairs (i, j) such that nums[i] + nums[j] == target and i < j. count = 0 num_dict = {} for num in nums: complement = target - num if complement in num_dict: count += num_dict[complement] if num in num_dict: num_dict[num] += 1 else: num_dict[num] = 1 return count"},{"question":"def can_finish(num_courses: int, prerequisites: List[List[int]]) -> bool: Determine if you can finish all courses given the number of courses and the prerequisites. >>> can_finish(2, []) == True >>> can_finish(2, [[1, 0], [0, 1]]) == False >>> can_finish(2, [[1, 0]]) == True >>> can_finish(4, [[1, 0], [2, 1], [3, 2], [0, 3]]) == False >>> can_finish(5, [[1, 0], [2, 1], [3, 2]]) == True >>> can_finish(5, [[1, 0], [2, 1], [2, 0]]) == True >>> can_finish(6, [[1, 0], [4, 3], [5, 4]]) == True","solution":"def can_finish(num_courses, prerequisites): from collections import defaultdict, deque # Create an adjacency list to represent the graph graph = defaultdict(list) indegree = [0] * num_courses # Build the graph and compute indegree of each vertex for ai, bi in prerequisites: graph[bi].append(ai) indegree[ai] += 1 # Initialize queue with all courses having no prerequisites queue = deque([i for i in range(num_courses) if indegree[i] == 0]) visited_courses = 0 while queue: course = queue.popleft() visited_courses += 1 for neighbor in graph[course]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) return visited_courses == num_courses"},{"question":"def minimum_cost_to_empty_array(nums: List[int]) -> int: Calculate the minimum total cost to make the array nums empty by removing elements with specific cost calculated per the problem's rules. :param nums: List[int] - list of integers :return: int - minimum total cost >>> minimum_cost_to_empty_array([1, 2, 3]) == 6 >>> minimum_cost_to_empty_array([3, 3, 3]) == 18 >>> minimum_cost_to_empty_array([2, 1, 2, 3, 2]) == 12 >>> minimum_cost_to_empty_array([5]) == 5 >>> minimum_cost_to_empty_array([]) == 0","solution":"def minimum_cost_to_empty_array(nums): Calculate the minimum total cost to make the array nums empty by removing elements with specific cost calculated per the problem's rules. :param nums: List[int] - list of integers :return: int - minimum total cost from collections import Counter element_count = Counter(nums) cost = 0 for element, count in element_count.items(): # The cost is the sum of the arithmetic progression: # element * 1 + element * 2 + ... + element * count # which equals element * (1 + 2 + ... + count) subtotal = element * sum(range(1, count + 1)) cost += subtotal return cost"},{"question":"from typing import List def distributeTasks(tasks: List[int], n: int) -> int: Distribute the tasks among the workers such that the maximum time taken by any worker to complete their assigned tasks is minimized. >>> distributeTasks([1, 2, 3, 4, 5], 2) 9 >>> distributeTasks([2, 2, 2, 2, 2, 2], 3) 4 >>> distributeTasks([1, 2, 3, 4, 5], 1) 15 >>> distributeTasks([1, 2, 3], 3) 3 >>> distributeTasks([10, 7, 8, 12, 6], 3) 18 >>> distributeTasks([5, 5, 5, 5], 2) 10","solution":"def canDistributeWithinTime(tasks, n, maxTime): # Helper function to check if tasks can be distributed within given maxTime current_time = 0 workers_used = 1 for task in tasks: if current_time + task <= maxTime: current_time += task else: workers_used += 1 if workers_used > n: return False current_time = task return True def distributeTasks(tasks, n): if n >= len(tasks): return max(tasks) low, high = max(tasks), sum(tasks) best_time = high while low <= high: mid = (low + high) // 2 if canDistributeWithinTime(tasks, n, mid): best_time = mid high = mid - 1 else: low = mid + 1 return best_time"},{"question":"from typing import List def spiralOrder(matrix: List[List[int]]) -> List[int]: Returns all elements of the matrix in spiral order. >>> spiralOrder([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [1, 2, 3, 6, 9, 8, 7, 4, 5] >>> spiralOrder([ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16] ... ]) [1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10] >>> spiralOrder([[1, 2, 3, 4]]) [1, 2, 3, 4] >>> spiralOrder([ ... [1], ... [2], ... [3], ... [4] ... ]) [1, 2, 3, 4] >>> spiralOrder([]) [] >>> spiralOrder([ ... [1, 2], ... [3, 4] ... ]) [1, 2, 4, 3]","solution":"def spiralOrder(matrix): Returns all elements of the matrix in spiral order. if not matrix or not matrix[0]: return [] m, n = len(matrix), len(matrix[0]) result = [] left, right, top, bottom = 0, n-1, 0, m-1 while left <= right and top <= bottom: for j in range(left, right + 1): result.append(matrix[top][j]) for i in range(top + 1, bottom + 1): result.append(matrix[i][right]) if top < bottom: for j in range(right - 1, left - 1, -1): result.append(matrix[bottom][j]) if left < right: for i in range(bottom - 1, top, -1): result.append(matrix[i][left]) left += 1 right -= 1 top += 1 bottom -= 1 return result"},{"question":"from typing import List from collections import deque def orangesRotting(grid: List[List[int]]) -> int: Returns the minimum number of minutes that must elapse until no fresh orange is left. If this is impossible, returns -1. >>> grid = [ ... [2, 1, 1], ... [1, 1, 0], ... [0, 1, 1] ... ] >>> orangesRotting(grid) 4 >>> grid = [ ... [2, 1, 1], ... [0, 1, 1], ... [1, 0, 1] ... ] >>> orangesRotting(grid) -1 >>> grid = [ ... [0, 2] ... ] >>> orangesRotting(grid) 0","solution":"from collections import deque def orangesRotting(grid): Returns the minimum number of minutes that must elapse until no fresh orange is left. If this is impossible, returns -1. rows, cols = len(grid), len(grid[0]) queue = deque() fresh_oranges = 0 # Initialize the queue with all rotten oranges for r in range(rows): for c in range(cols): if grid[r][c] == 2: queue.append((r, c)) elif grid[r][c] == 1: fresh_oranges += 1 # Directions for 4-adjacency: up, down, left, right directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] # If there are no fresh oranges, return 0 immediately if fresh_oranges == 0: return 0 # Perform BFS to rot adjacent fresh oranges minutes_passed = -1 while queue: minutes_passed += 1 for _ in range(len(queue)): r, c = queue.popleft() for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 1: grid[nr][nc] = 2 fresh_oranges -= 1 queue.append((nr, nc)) # If there are still fresh oranges left, return -1 if fresh_oranges > 0: return -1 return minutes_passed"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def lowest_common_ancestor(root: TreeNode, p: int, q: int) -> int: Given a binary tree, find the lowest common ancestor of two given nodes. The lowest common ancestor is defined as the deepest node that has both p and q as descendants (where we allow a node to be a descendant of itself). Return the value of the lowest common ancestor, or -1 if one or both nodes do not exist in the tree. >>> root = TreeNode(3) >>> root.left = TreeNode(5) >>> root.right = TreeNode(1) >>> root.left.left = TreeNode(6) >>> root.left.right = TreeNode(2) >>> root.left.right.left = TreeNode(7) >>> root.left.right.right = TreeNode(4) >>> root.right.left = TreeNode(0) >>> root.right.right = TreeNode(8) >>> lowest_common_ancestor(root, 5, 1) 3 >>> lowest_common_ancestor(root, 6, 4) 5 >>> lowest_common_ancestor(root, 7, 8) 3 >>> lowest_common_ancestor(root, 6, 2) 5 >>> lowest_common_ancestor(root, 0, 8) 1 >>> lowest_common_ancestor(root, 5, 10) -1 >>> lowest_common_ancestor(root, 100, 200) -1 >>> lowest_common_ancestor(root, 5, 4) 5 >>> lowest_common_ancestor(root, 3, 6) 3","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def find_lca(root, p, q): Finds the lowest common ancestor of two nodes p and q in the binary tree with root. Returns the value of the LCA, or -1 if one or both nodes do not exist in the tree. if root is None: return None if root.value == p or root.value == q: return root left = find_lca(root.left, p, q) right = find_lca(root.right, p, q) if left and right: return root return left if left else right def node_exists(root, value): if root is None: return False if root.value == value: return True return node_exists(root.left, value) or node_exists(root.right, value) def lowest_common_ancestor(root, p, q): if not node_exists(root, p) or not node_exists(root, q): return -1 lca_node = find_lca(root, p, q) return lca_node.value if lca_node else -1"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BSTIterator: Implement an iterator over a binary search tree (BST). The iterator should return the next smallest number in the BST in O(1) average time complexity. Methods: - BSTIterator(TreeNode root): Initializes an object of the BSTIterator class with the root of the tree. - int next(): Returns the next smallest number in the BST. - boolean hasNext(): Returns true if there exists a number in the traversal to be returned, otherwise false. def __init__(self, root: TreeNode): pass def next(self) -> int: pass def hasNext(self) -> bool: pass import pytest def test_bst_iterator(): # Construct the BST manually for the test case. # 7 # / # 3 15 # / # 9 20 root = TreeNode(7) root.left = TreeNode(3) root.right = TreeNode(15) root.right.left = TreeNode(9) root.right.right = TreeNode(20) it = BSTIterator(root) assert it.next() == 3 assert it.next() == 7 assert it.hasNext() == True assert it.next() == 9 assert it.hasNext() == True assert it.next() == 15 assert it.hasNext() == True assert it.next() == 20 assert it.hasNext() == False def test_empty_tree(): root = None it = BSTIterator(root) assert it.hasNext() == False def test_single_node(): root = TreeNode(42) it = BSTIterator(root) assert it.hasNext() == True assert it.next() == 42 assert it.hasNext() == False def test_degenerate_tree(): # A degenerate tree equal to a linked list # 4 # # 5 # # 6 root = TreeNode(4) root.right = TreeNode(5) it = BSTIterator(root) assert it.next() == 4 assert it.next() == 5 assert it.hasNext() == True assert it.next() == 6 assert it.hasNext() == False","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BSTIterator: def __init__(self, root: TreeNode): self.stack = [] self._leftmost_inorder(root) def _leftmost_inorder(self, root): while root: self.stack.append(root) root = root.left def next(self) -> int: top_node = self.stack.pop() if top_node.right: self._leftmost_inorder(top_node.right) return top_node.val def hasNext(self) -> bool: return len(self.stack) > 0"},{"question":"def plus_one(nums: List[int]) -> List[int]: Given a list of integers representing the digits of a number, adds 1 to the number and returns the digits of the resulting number as a list. >>> plus_one([1, 2, 3]) [1, 2, 4] >>> plus_one([1, 2, 9]) [1, 3, 0] >>> plus_one([9, 9, 9]) [1, 0, 0, 0] >>> plus_one([0]) [1] >>> plus_one([9]) [1, 0] >>> plus_one([1, 8, 9, 9]) [1, 9, 0, 0] >>> plus_one([1, 2, 8]) [1, 2, 9]","solution":"def plus_one(nums): Given a list of integers representing the digits of a number, adds 1 to the number and returns the digits of the resulting number as a list. n = len(nums) carry = 1 for i in range(n - 1, -1, -1): new_digit = nums[i] + carry if new_digit == 10: nums[i] = 0 else: nums[i] = new_digit carry = 0 break if carry == 1: nums.insert(0, 1) return nums"},{"question":"def maxRob(nums): Returns the maximum amount of money that can be robbed in a circular arrangement of houses. >>> maxRob([5]) == 5 >>> maxRob([2, 3]) == 3 >>> maxRob([2, 3, 2]) == 3 >>> maxRob([1, 2, 3, 1]) == 4 >>> maxRob([200, 3, 140, 20, 200]) == 340 >>> maxRob([0, 0, 0, 0, 0]) == 0 >>> maxRob([10, 10, 10, 10, 10, 10]) == 30 >>> maxRob([1, 2, 3, 4, 5, 6]) == 12 >>> maxRob([6, 5, 4, 3, 2, 1]) == 12","solution":"def rob_linear(nums): Returns the maximum amount of money that can be robbed in a linear arrangement of houses. prev, curr = 0, 0 for num in nums: prev, curr = curr, max(curr, prev + num) return curr def maxRob(nums): Returns the maximum amount of money that can be robbed in a circular arrangement of houses. if not nums: return 0 if len(nums) == 1: return nums[0] return max(rob_linear(nums[:-1]), rob_linear(nums[1:]))"},{"question":"def min_time_to_complete_tasks(nums: List[int], k: int) -> int: Returns the least amount of time required to complete all tasks when tasks are distributed optimally among k workers. :param nums: List of integers representing task times. :param k: Integer representing number of workers. :return: Integer representing the minimum time required. >>> min_time_to_complete_tasks([3, 2, 3], 3) 3 >>> min_time_to_complete_tasks([1, 2, 3, 4, 5], 1) 15 >>> min_time_to_complete_tasks([7, 2, 5, 10, 8], 2) 18 >>> min_time_to_complete_tasks([1, 2, 3], 3) 3 >>> min_time_to_complete_tasks([5, 7, 2], 5) 7 >>> min_time_to_complete_tasks([5, 8, 9, 10], 4) 10 pass","solution":"def min_time_to_complete_tasks(nums, k): Returns the least amount of time required to complete all tasks when tasks are distributed optimally among k workers. :param nums: List of integers representing task times. :param k: Integer representing number of workers. :return: Integer representing the minimum time required. def can_complete_in_time(limit): workers_count = 1 current_sum = 0 for time in nums: if current_sum + time <= limit: current_sum += time else: workers_count += 1 current_sum = time if workers_count > k: return False return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if can_complete_in_time(mid): right = mid else: left = mid + 1 return left"},{"question":"from typing import List def max_sum_subarray_with_n_distinct(arr: List[int], n: int) -> int: Returns the maximum possible sum of a subarray with at most n distinct elements. Parameters: arr (List[int]): List of integers representing the array. n (int): Maximum number of distinct elements allowed in the subarray. Returns: int: Maximum possible sum of the subarray with at most n distinct elements. Examples: >>> max_sum_subarray_with_n_distinct([1, 2, 1, 2, 3], 2) 6 >>> max_sum_subarray_with_n_distinct([1, 2, 3, 4, 5], 5) 15 >>> max_sum_subarray_with_n_distinct([1, 2, 3, 4, 5], 0) 0 >>> max_sum_subarray_with_n_distinct([], 3) 0 >>> max_sum_subarray_with_n_distinct([10], 1) 10 >>> max_sum_subarray_with_n_distinct([4, 2, 4, 2, 4], 2) 16 >>> max_sum_subarray_with_n_distinct([1, 2, 3, 1, 2, 3, 4, 5], 3) 12 >>> max_sum_subarray_with_n_distinct([1, 2, 3, 4, 5], 10) 15 >>> max_sum_subarray_with_n_distinct([5, 5, 5, 5, 5], 1) 25","solution":"def max_sum_subarray_with_n_distinct(arr, n): Returns the maximum possible sum of a subarray with at most n distinct elements. from collections import defaultdict if not arr or n == 0: return 0 max_sum = 0 current_sum = 0 left = 0 freq = defaultdict(int) for right in range(len(arr)): freq[arr[right]] += 1 current_sum += arr[right] while len(freq) > n: freq[arr[left]] -= 1 current_sum -= arr[left] if freq[arr[left]] == 0: del freq[arr[left]] left += 1 max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def minSwapsToSort(arr: List[int], k: int) -> int: Returns the minimum number of swaps required to sort the array in ascending order. >>> minSwapsToSort([1, 2, 3, 4, 5], 1) == 0 >>> minSwapsToSort([2, 1, 3, 4, 5], 1) == 1 >>> minSwapsToSort([3, 1, 2, 4, 5], 1) == 2 >>> minSwapsToSort([2, 2, 1, 1, 3], 1) == 2 >>> minSwapsToSort([4, 3, 1, 2], 1) == 3 pass","solution":"def minSwapsToSort(arr, k): Returns the minimum number of swaps required to sort the array in ascending order. n = len(arr) sorted_arr_with_indices = sorted([(value, idx) for idx, value in enumerate(arr)]) visited = [False] * n swaps = 0 for i in range(n): if visited[i] or sorted_arr_with_indices[i][1] == i: continue cycle_size = 0 x = i while not visited[x]: visited[x] = True x = sorted_arr_with_indices[x][1] cycle_size += 1 if cycle_size > 0: swaps += cycle_size - 1 return swaps"},{"question":"from typing import List def min_groups(strings: List[str]) -> int: Returns the minimum number of groups so that no string in one group is a prefix of another string in the same group. >>> min_groups([\\"a\\", \\"b\\", \\"c\\"]) 1 >>> min_groups([\\"a\\", \\"ab\\", \\"abc\\"]) 3 >>> min_groups([\\"a\\", \\"b\\", \\"ab\\", \\"abc\\", \\"bc\\"]) 3 >>> min_groups([\\"cat\\", \\"dog\\", \\"apple\\"]) 1 >>> min_groups([\\"a\\", \\"aa\\", \\"aaa\\", \\"ab\\", \\"abc\\", \\"abcd\\", \\"b\\", \\"ba\\", \\"bac\\"]) 4 >>> min_groups([]) 0","solution":"def min_groups(strings): Returns the minimum number of groups so that no string in one group is a prefix of another string in the same group. # Sort strings by length, then lexicographically strings.sort(key=lambda s: (len(s), s)) groups = [] for s in strings: placed = False for group in groups: if not any(g.startswith(s) or s.startswith(g) for g in group): group.append(s) placed = True break if not placed: groups.append([s]) return len(groups)"},{"question":"def can_distribute_stones(nums): Returns True if it is possible to evenly distribute stones across all piles, False otherwise. >>> can_distribute_stones([4, 4, 4, 4]) == True >>> can_distribute_stones([1, 2, 3, 4]) == False >>> can_distribute_stones([2, 4, 6, 8]) == True >>> can_distribute_stones([10]) == True >>> can_distribute_stones([1, 1, 1, 2]) == False","solution":"def can_distribute_stones(nums): Returns True if it is possible to evenly distribute stones across all piles, False otherwise. total_stones = sum(nums) # If total stones are not divisible by the number of piles, we can't distribute them evenly if total_stones % len(nums) != 0: return False return True"},{"question":"def min_operations_to_reach_k(arr, k): Given an array 'arr' of integers and an integer 'k', this function returns the minimum number of operations needed to make every element of the array at least 'k'. An operation consists of choosing a subarray and incrementing every element in that subarray by 1. Parameters: arr (list of int): The input array of integers. k (int): The threshold value that each element in the array must reach or exceed. Returns: int: The minimum number of operations needed. pass # Example unit tests def test_single_element_less_than_k(): assert min_operations_to_reach_k([1], 4) == 3 def test_single_element_equal_to_k(): assert min_operations_to_reach_k([4], 4) == 0 def test_single_element_greater_than_k(): assert min_operations_to_reach_k([5], 4) == 0 def test_multiple_elements_with_mixed_values(): assert min_operations_to_reach_k([1, 2, 5], 4) == 5 def test_all_elements_less_than_k(): assert min_operations_to_reach_k([1, 1, 1], 4) == 9 def test_all_elements_equal_to_k(): assert min_operations_to_reach_k([4, 4, 4], 4) == 0 def test_all_elements_greater_than_k(): assert min_operations_to_reach_k([5, 6, 7], 4) == 0 def test_large_array(): arr = [2] * 1000 assert min_operations_to_reach_k(arr, 3) == 1000","solution":"def min_operations_to_reach_k(arr, k): Given an array 'arr' of integers and an integer 'k', this function returns the minimum number of operations needed to make every element of the array at least 'k'. An operation consists of choosing a subarray and incrementing every element in that subarray by 1. Parameters: arr (list of int): The input array of integers. k (int): The threshold value that each element in the array must reach or exceed. Returns: int: The minimum number of operations needed. operations = 0 max_value = max(arr) # If maximum element is already >= k, calculate the additional operations needed for other elements. for num in arr: if num < k: operations += (k - num) return operations"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def hasCycle(head: ListNode) -> bool: Detects if a cycle exists in a linked list. :param head: ListNode, the head of the singly linked list. :return: bool, True if there is a cycle in the linked list, otherwise False. pass def test_no_cycle(): # List: 1 -> 2 -> 3 -> 4 node4 = ListNode(4) node3 = ListNode(3, node4) node2 = ListNode(2, node3) node1 = ListNode(1, node2) assert hasCycle(node1) == False def test_cycle_at_beginning(): # List: 1 -> 2 -> 3 -> 4 -> 1 (cycle) node1 = ListNode(1) node4 = ListNode(4, node1) node3 = ListNode(3, node4) node2 = ListNode(2, node3) node1.next = node2 assert hasCycle(node1) == True def test_cycle_in_middle(): # List: 1 -> 2 -> 3 -> 4 -> 2 (cycle) node1 = ListNode(1) node4 = ListNode(4) node3 = ListNode(3, node4) node2 = ListNode(2, node3) node1.next = node2 node4.next = node2 assert hasCycle(node1) == True def test_single_node_no_cycle(): # List: 1 node1 = ListNode(1) assert hasCycle(node1) == False def test_single_node_with_cycle(): # List: 1 -> 1 (cycle) node1 = ListNode(1) node1.next = node1 assert hasCycle(node1) == True","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def hasCycle(head): Detects if a cycle exists in a linked list. :param head: ListNode, the head of the singly linked list. :return: bool, True if there is a cycle in the linked list, otherwise False. if not head or not head.next: return False slow = head fast = head.next while slow != fast: if not fast or not fast.next: return False slow = slow.next fast = fast.next.next return True"},{"question":"def group_anagrams(words: List[str]) -> List[List[str]]: Given a list of strings \`words\`, group the anagrams together. Args: words: List of strings Returns: List of lists where each list contains all the anagrams grouped together, sorted lexicographically. Example: >>> group_anagrams([\\"bat\\", \\"tab\\", \\"eat\\", \\"tea\\", \\"tan\\", \\"nat\\"]) [[\\"bat\\", \\"tab\\"], [\\"eat\\", \\"tea\\"], [\\"nat\\", \\"tan\\"]] # Test cases def test_group_anagrams_basic(): assert group_anagrams([\\"bat\\", \\"tab\\", \\"eat\\", \\"tea\\", \\"tan\\", \\"nat\\"]) == [[\\"bat\\", \\"tab\\"], [\\"eat\\", \\"tea\\"], [\\"nat\\", \\"tan\\"]] def test_group_anagrams_single_word(): assert group_anagrams([\\"a\\"]) == [[\\"a\\"]] def test_group_anagrams_no_anagrams(): assert group_anagrams([\\"abc\\", \\"def\\", \\"ghi\\"]) == [[\\"abc\\"], [\\"def\\"], [\\"ghi\\"]] def test_group_anagrams_mixed_length(): assert group_anagrams([\\"ab\\", \\"ba\\", \\"abc\\", \\"cab\\", \\"bca\\", \\"dddd\\", \\"ddddd\\"]) == [[\\"ab\\", \\"ba\\"], [\\"abc\\", \\"bca\\", \\"cab\\"], [\\"dddd\\"], [\\"ddddd\\"]] def test_group_anagrams_empty_list(): assert group_anagrams([]) == []","solution":"def group_anagrams(words): Groups the anagrams together. Args: words: List of strings Returns: List of lists where each list contains all the anagrams grouped together, sorted lexicographically. from collections import defaultdict anagram_dict = defaultdict(list) for word in words: sorted_word = ''.join(sorted(word)) anagram_dict[sorted_word].append(word) result = [sorted(anagram_dict[key]) for key in anagram_dict] return sorted(result, key=lambda x: x[0])"},{"question":"from typing import List def numDistinctIslands(grid: List[List[int]]) -> int: Determine the number of distinct islands in the grid. An island is a group of connected \`1\`s (vertically or horizontally), and two islands are distinct if their shapes are different when translated. >>> numDistinctIslands([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) == 0 >>> numDistinctIslands([[0, 1, 0], [0, 1, 0], [0, 0, 0]]) == 1 >>> numDistinctIslands([[0, 1, 0, 0, 1, 0], [0, 1, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0]]) == 1 >>> numDistinctIslands([[0, 1, 0, 0, 0], [1, 0, 0, 1, 1], [0, 0, 0, 0, 0]]) == 2 >>> numDistinctIslands([[0]]) == 0 >>> numDistinctIslands([[1, 1], [1, 1]]) == 1 pass","solution":"def numDistinctIslands(grid): def dfs(x, y, direction): nonlocal shape if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] == 1: grid[x][y] = 0 shape.append(direction) dfs(x + 1, y, 'd') dfs(x - 1, y, 'u') dfs(x, y + 1, 'r') dfs(x, y - 1, 'l') shape.append('b') distinct_islands = set() for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: shape = [] dfs(i, j, 'o') distinct_islands.add(tuple(shape)) return len(distinct_islands)"},{"question":"def block_sums(arr, k): Returns an array containing the block sums of length k for the input array arr. >>> block_sums([1, 2, 3, 4, 5, 6], 3) [6, 9, 12, 15] >>> block_sums([4, 5, 6, 7], 1) [4, 5, 6, 7] >>> block_sums([4, 5, 6, 7], 4) [22] >>> block_sums([1, 2, 3, 4, 2], 3) [6, 9, 9] >>> block_sums([1, 2], 3) []","solution":"def block_sums(arr, k): Returns an array containing the block sums of length k for the input array arr. n = len(arr) # Initialize the result array result = [] # Calculate the block sums for i in range(n - k + 1): block_sum = sum(arr[i:i+k]) result.append(block_sum) return result"},{"question":"def min_operations_to_avoid_adjacent_duplicates(s: str) -> int: Determine the minimum number of operations required so that no two identical characters are adjacent. >>> min_operations_to_avoid_adjacent_duplicates(\\"aabb\\") 0 >>> min_operations_to_avoid_adjacent_duplicates(\\"a\\") 0 >>> min_operations_to_avoid_adjacent_duplicates(\\"aaaa\\") -1 >>> min_operations_to_avoid_adjacent_duplicates(\\"aabba\\") 0 >>> min_operations_to_avoid_adjacent_duplicates(\\"aaab\\") -1 >>> min_operations_to_avoid_adjacent_duplicates(\\"abcabc\\") 0","solution":"def min_operations_to_avoid_adjacent_duplicates(s): from collections import Counter char_count = Counter(s) max_freq = max(char_count.values()) n = len(s) if max_freq > (n + 1) // 2: return -1 return 0"},{"question":"def minimizeLateness(tasks: List[Tuple[int, int]]) -> List[int]: Schedules tasks to minimize the total lateness. Each task is represented as a pair of integers (duration, deadline). Parameters: - tasks: List of tuples where each tuple contains (duration, deadline). Returns: - List of indices representing the order of tasks to minimize total lateness. >>> tasks = [(3, 5), (2, 6), (1, 8)] >>> minimizeLateness(tasks) [0, 1, 2] >>> tasks = [(3, 5), (2, 6), (1, 4)] >>> minimizeLateness(tasks) [2, 0, 1] >>> tasks = [(3, 10), (2, 10), (1, 10)] >>> minimizeLateness(tasks) [0, 1, 2] >>> tasks = [] >>> minimizeLateness(tasks) []","solution":"from typing import List, Tuple def minimizeLateness(tasks: List[Tuple[int, int]]) -> List[int]: Schedules tasks to minimize the total lateness. Parameters: - tasks: List of tuples where each tuple contains (duration, deadline) Returns: - List of indices representing the order of tasks to minimize total lateness # Sort tasks by their deadlines (earliest deadline first). sorted_tasks_indices = sorted(range(len(tasks)), key=lambda x: tasks[x][1]) return sorted_tasks_indices"},{"question":"from collections import deque from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root: Optional[TreeNode]) -> List[List[int]]: Return the level order traversal of a binary tree. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> level_order_traversal(root) [[1], [2, 3], [4, 5, 6, 7]] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.right = TreeNode(4) >>> root.right.left = TreeNode(5) >>> level_order_traversal(root) [[1], [2, 3], [4, 5]]","solution":"from collections import deque from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root: Optional[TreeNode]) -> List[List[int]]: Returns the level order traversal of a binary tree. if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) level = [] for _ in range(level_size): node = queue.popleft() level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level) return result"},{"question":"def mostFrequentEven(nums: List[int]) -> int: Returns the most frequent even element in the array nums. If there is a tie for the most frequent, returns the smallest even element among the tied elements. If there are no even elements, returns -1. >>> mostFrequentEven([2]) == 2 >>> mostFrequentEven([1, 3, 5, 7]) == -1 >>> mostFrequentEven([2, 4, 4, 2, 6, 2]) == 2 >>> mostFrequentEven([4, 2, 4, 2]) == 2 >>> mostFrequentEven([4, 4, 4, 4, 8, 8, 8, 8, 2, 2]) == 4 >>> mostFrequentEven([1, 2, 2, 3, 4, 4]) == 2 >>> mostFrequentEven([3, 5, 5, 2, 6, 6, 3, 2, 8, 8, 8, 8, 8, 8]) == 8 >>> mostFrequentEven([6, 6, 4, 4]) == 4","solution":"def mostFrequentEven(nums): Returns the most frequent even element in the array nums. If there is a tie for the most frequent, returns the smallest even element among the tied elements. If there are no even elements, returns -1. from collections import Counter # Filter and count even numbers evens_count = Counter(num for num in nums if num % 2 == 0) if not evens_count: return -1 most_frequent_even = min((-count, num) for num, count in evens_count.items())[1] return most_frequent_even"},{"question":"def min_time_difference(tasks: List[int]) -> int: Given a list of task times, determine the minimum absolute difference in total completion time between the two machines when tasks are optimally assigned to either machine A or machine B. >>> min_time_difference([1, 2, 3, 4, 5]) 1 >>> min_time_difference([5]) 5 >>> min_time_difference([2, 2]) 0 >>> min_time_difference([3, 7]) 4 >>> min_time_difference([3, 1, 4, 2, 2]) 0 >>> min_time_difference([3, 3, 3, 3]) 0 >>> min_time_difference([10, 20, 30, 40, 50]) 10 >>> min_time_difference([]) 0","solution":"from itertools import combinations def min_time_difference(tasks): total_time = sum(tasks) target = total_time // 2 possible_sums = set([0]) for task in tasks: current_sums = list(possible_sums) for cur_sum in current_sums: new_sum = cur_sum + task possible_sums.add(new_sum) closest_sum = min(possible_sums, key=lambda x: abs(target - x)) machine_A_time = closest_sum machine_B_time = total_time - closest_sum return abs(machine_A_time - machine_B_time)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def largest_in_each_row(root: TreeNode) -> List[int]: Returns a list of the largest values in each row of the binary tree. >>> root = TreeNode(1) >>> root.left = TreeNode(3) >>> root.right = TreeNode(2) >>> root.left.left = TreeNode(5) >>> root.left.right = TreeNode(3) >>> root.right.right = TreeNode(9) >>> largest_in_each_row(root) [1, 3, 9] >>> root = TreeNode(1) >>> largest_in_each_row(root) [1] pass","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def largest_in_each_row(root): Returns a list of the largest values in each row of the binary tree. if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) max_value = float('-inf') for _ in range(level_size): node = queue.popleft() max_value = max(max_value, node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(max_value) return result"},{"question":"def smallest_unrepresentable_sum(nums: List[int]) -> int: Given an unsorted list of integers, find the smallest positive integer that cannot be represented as a sum of any subset of the list. >>> smallest_unrepresentable_sum([1, 2, 3, 8, 9]) 7 >>> smallest_unrepresentable_sum([1, 1, 1, 1, 1]) 6 >>> smallest_unrepresentable_sum([2, 3, 4, 5, 6, 7]) 1 >>> smallest_unrepresentable_sum([1, 2, 3, 4, 5]) 16 >>> smallest_unrepresentable_sum([10, 20, 30, 40]) 1 >>> smallest_unrepresentable_sum([1]) 2 >>> smallest_unrepresentable_sum([2]) 1 >>> smallest_unrepresentable_sum([1, 1, 1, 10]) 4 >>> smallest_unrepresentable_sum([]) 1","solution":"def smallest_unrepresentable_sum(nums): Given an unsorted list of integers, find the smallest positive integer that cannot be represented as a sum of any subset of the list. nums.sort() smallest_missing = 1 for num in nums: if num > smallest_missing: break smallest_missing += num return smallest_missing"},{"question":"def get_importance(manager, importance, id): Return the total importance value of the employees who are directly or indirectly managed by the employee with the given id. :param manager: List[int], manager[i] is the ID of the manager of the i-th employee :param importance: List[int], importance[i] is the importance value of the i-th employee :param id: int, the ID of the employee whose total importance we want to calculate :return: int >>> manager = [-1, 0, 0] >>> importance = [5, 3, 1] >>> id = 0 >>> get_importance(manager, importance, id) 9 >>> manager = [-1, 0, 0, 1] >>> importance = [5, 3, 1, 2] >>> id = 0 >>> get_importance(manager, importance, id) 11 >>> manager = [-1, 0, 0, 1] >>> importance = [5, 3, 1, 2] >>> id = 3 >>> get_importance(manager, importance, id) 2 >>> manager = [-1, 0, 1, 2] >>> importance = [5, 3, 2, 1] >>> id = 0 >>> get_importance(manager, importance, id) 11 >>> manager = [-1, 0, 0, 1, 1, 2] >>> importance = [6, 5, 4, 5, 3, 2] >>> id = 1 >>> get_importance(manager, importance, id) 13 >>> manager = [-1, 0, 0, 1, 1, 2] >>> importance = [6, 5, 4, 5, 3, 2] >>> id = 4 >>> get_importance(manager, importance, id) 3","solution":"def get_importance(manager, importance, id): Return the total importance value of the employees who are directly or indirectly managed by the employee with the given id. :param manager: List[int], manager[i] is the ID of the manager of the i-th employee :param importance: List[int], importance[i] is the importance value of the i-th employee :param id: int, the ID of the employee whose total importance we want to calculate :return: int from collections import defaultdict, deque n = len(manager) employee_to_subordinates = defaultdict(list) for i in range(n): if manager[i] != -1: employee_to_subordinates[manager[i]].append(i) total_importance = 0 queue = deque([id]) while queue: current = queue.popleft() total_importance += importance[current] for subordinate in employee_to_subordinates[current]: queue.append(subordinate) return total_importance"},{"question":"def minKnightMoves(n: int) -> int: Calculate the minimum number of moves the knight needs to reach the top-left square of the chessboard. Parameters: n (int): Size of the chessboard (n x n) Returns: int: Minimum number of moves required or -1 if it is not possible >>> minKnightMoves(1) 0 >>> minKnightMoves(2) -1 >>> minKnightMoves(3) (some non-negative integer) >>> minKnightMoves(4) (some non-negative integer) >>> minKnightMoves(5) (some non-negative integer) >>> minKnightMoves(8) (some non-negative integer) >>> minKnightMoves(10) (some non-negative integer)","solution":"from collections import deque def minKnightMoves(n: int) -> int: if n == 1: return 0 # Possible moves for a knight knight_moves = [ (2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2) ] # Initialize BFS start = (n - 1, n - 1) target = (0, 0) queue = deque([(start, 0)]) visited = set([start]) while queue: (x, y), moves = queue.popleft() if (x, y) == target: return moves for dx, dy in knight_moves: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited: visited.add((nx, ny)) queue.append(((nx, ny), moves + 1)) return -1"},{"question":"def find_longest_string(words: List[str]) -> str: Given a list of strings \`words\`, return the longest string in \`words\` that can be formed by deleting some characters of another string in \`words\` without reordering the remaining characters. If there are multiple possible results, return the one that's lexographically smallest. If no string in \`words\` can be formed by deleting characters from another string, return an empty string. >>> find_longest_string([\\"abc\\", \\"def\\", \\"ghi\\"]) \\"\\" >>> find_longest_string([\\"abc\\", \\"ab\\", \\"def\\", \\"d\\"]) \\"ab\\" >>> find_longest_string([]) \\"\\" >>> find_longest_string([\\"a\\", \\"b\\", \\"c\\"]) \\"\\" >>> find_longest_string([\\"abcdef\\", \\"abc\\", \\"def\\", \\"ab\\", \\"cd\\"]) \\"abc\\" >>> find_longest_string([\\"abc\\", \\"abd\\", \\"ab\\"]) \\"ab\\"","solution":"def find_longest_string(words): Returns the longest string in words that can be formed by deleting some characters of another string in words without reordering the remaining characters. If there are multiple possible results, returns the lexicographically smallest one. if not words: return \\"\\" def is_subsequence(x, y): it = iter(y) return all(c in it for c in x) longest = \\"\\" words.sort() for word in sorted(words, key=lambda x: (-len(x), x)): for potential in words: if word != potential and is_subsequence(word, potential): if len(word) > len(longest) or (len(word) == len(longest) and word < longest): longest = word break return longest"},{"question":"from typing import List def check_substring(s: str, n: int) -> bool: Determines if there exists a substring of \`s\` with length at least \`n\` that contains exactly \`n\` distinct characters. :param s: A string consisting of lowercase alphabets. :param n: An integer representing the number of distinct characters required. :return: Boolean indicating if such a substring exists. >>> check_substring(\\"abcabc\\", 3) True >>> check_substring(\\"aaaaa\\", 2) False >>> check_substring(\\"abc\\", 3) True >>> check_substring(\\"abc\\", 4) False >>> check_substring(\\"abcdeabcde\\", 5) True >>> check_substring(\\"\\", 1) False >>> check_substring(\\"a\\", 1) True","solution":"def check_substring(s, n): Determines if there exists a substring of \`s\` with length at least \`n\` that contains exactly \`n\` distinct characters. :param s: A string consisting of lowercase alphabets. :param n: An integer representing the number of distinct characters required. :return: Boolean indicating if such a substring exists. if n > len(s): return False distinct_counts = set() for i in range(len(s) - n + 1): substring = s[i:i+n] distinct_characters = set(substring) if len(distinct_characters) == n: return True distinct_counts.add(len(distinct_characters)) return False"},{"question":"from typing import List class CombinationSum: You are given a list of unique integers \`candidates\` and a target integer \`target\`. Return a list of all unique combinations of \`candidates\` where the chosen numbers sum to \`target\`. The same number from \`candidates\` may be chosen an unlimited number of times. >>> comb_sum = CombinationSum([2, 3, 6, 7], 7) >>> sorted(comb_sum.getCombinations()) [[2, 2, 3], [7]] >>> comb_sum = CombinationSum([2, 3, 5], 8) >>> sorted(comb_sum.getCombinations()) [[2, 2, 2, 2], [2, 3, 3], [3, 5]] >>> comb_sum = CombinationSum([2, 4, 6], 5) >>> comb_sum.getCombinations() [] >>> comb_sum = CombinationSum([2], 2) >>> comb_sum.getCombinations() [[2]] >>> comb_sum = CombinationSum([1, 2, 3], 4) >>> sorted(comb_sum.getCombinations()) [[1, 1, 1, 1], [1, 1, 2], [1, 3], [2, 2]] def __init__(self, candidates: List[int], target: int): pass def getCombinations(self) -> List[List[int]]: pass","solution":"from typing import List class CombinationSum: def __init__(self, candidates: List[int], target: int): self.candidates = candidates self.target = target def getCombinations(self) -> List[List[int]]: result = [] self.candidates.sort() def backtrack(start, path, target): if target < 0: return if target == 0: result.append(path) return for i in range(start, len(self.candidates)): candidate = self.candidates[i] backtrack(i, path + [candidate], target - candidate) backtrack(0, [], self.target) return result"},{"question":"class GoodNodesPathFinder: Class to find the longest path of good nodes in an n-ary tree. Args: n : int : number of nodes parents : List[int] : list of parent indices for each node values : List[int] : list of values denoting if the node is good (1) or bad (0) Example Usage: >>> n = 5 >>> parents = [-1, 0, 0, 1, 1] >>> values = [1, 1, 0, 1, 1] >>> finder = GoodNodesPathFinder(n, parents, values) >>> finder.getLongestGoodPath() == 3 # {0 -> 1 -> 3} def __init__(self, n, parents, values): pass def getLongestGoodPath(self): pass def test_example_1(): n = 5 parents = [-1, 0, 0, 1, 1] values = [1, 1, 0, 1, 1] finder = GoodNodesPathFinder(n, parents, values) assert finder.getLongestGoodPath() == 3 # {0 -> 1 -> 3} def test_example_2(): n = 4 parents = [-1, 0, 1, 2] values = [1, 0, 1, 1] finder = GoodNodesPathFinder(n, parents, values) assert finder.getLongestGoodPath() == 1 # {0} def test_all_bad_nodes(): n = 3 parents = [-1, 0, 0] values = [0, 0, 0] finder = GoodNodesPathFinder(n, parents, values) assert finder.getLongestGoodPath() == 0 # No good nodes def test_all_good_nodes(): n = 3 parents = [-1, 0, 0] values = [1, 1, 1] finder = GoodNodesPathFinder(n, parents, values) assert finder.getLongestGoodPath() == 2 # {0 -> 1} or {0 -> 2} def test_single_node(): n = 1 parents = [-1] values = [1] finder = GoodNodesPathFinder(n, parents, values) assert finder.getLongestGoodPath() == 1 # {0} def test_long_single_path(): n = 6 parents = [-1, 0, 1, 2, 3, 4] values = [1, 1, 0, 1, 1, 1] finder = GoodNodesPathFinder(n, parents, values) assert finder.getLongestGoodPath() == 2 # {0 -> 1} or {3 -> 4} or {4 -> 5}","solution":"class GoodNodesPathFinder: def __init__(self, n, parents, values): self.n = n self.parents = parents self.values = values self.tree = [[] for _ in range(n)] for i in range(1, n): self.tree[parents[i]].append(i) self.max_length = 0 def getLongestGoodPath(self): def dfs(node): if self.values[node] == 0: return 0 max_depth = 0 for child in self.tree[node]: depth = dfs(child) max_depth = max(max_depth, depth) self.max_length = max(self.max_length, max_depth + 1) return max_depth + 1 dfs(0) return self.max_length"},{"question":"def mask_email(email: str) -> str: Masks the given email address. The local part is the first letter, followed by a fixed number of asterisks, and then the last letter before the '@' symbol. For the domain part, only the first and last letter remain visible, with the middle letters being replaced by asterisks. >>> mask_email(\\"example@domain.com\\") \\"e*****e@d****n.com\\" >>> mask_email(\\"e@domain.com\\") \\"e@d****n.com\\" >>> mask_email(\\"example@d.com\\") \\"e*****e@d.com\\" >>> mask_email(\\"a@b.c\\") \\"a@b.c\\" >>> mask_email(\\"e.xample@domain.com\\") \\"e*****e@d****n.com\\" >>> mask_email(\\"ab@domain.com\\") \\"a*****b@d****n.com\\"","solution":"def mask_email(email): Masks the email address following the rules: Local part: First letter, fixed number of asterisks, and last letter before @. Domain part: First letter, asterisks, last letter, and the domain extension. local, domain = email.split('@') # Masking the local part if len(local) > 1: masked_local = local[0] + '*' * 5 + local[-1] else: masked_local = local # If the local part is too short to mask # Masking the domain part domain_name, domain_extension = domain.split('.') if len(domain_name) > 1: masked_domain = domain_name[0] + '*' * (len(domain_name) - 2) + domain_name[-1] + '.' + domain_extension else: masked_domain = domain # If the domain name is too short to mask return f\\"{masked_local}@{masked_domain}\\""},{"question":"def min_steps(nums: List[int], k: int) -> int: Returns the minimum number of steps required to make all elements in the list equal using exactly k steps. If it's not possible, return -1. >>> min_steps([1, 2, 3], 1) -1 >>> min_steps([1, 1, 1], 2) -1 >>> min_steps([1, 2, 3], 3) 3 >>> min_steps([1, 1, 1], 3) 3 >>> min_steps([4, 4, 4], 2) -1 >>> min_steps([1], 0) 0 >>> min_steps([1], 5) 5 >>> min_steps([100, 200, 300], 600) 600","solution":"def min_steps(nums, k): Returns the minimum number of steps required to make all elements in the list equal using exactly k steps. If it's not possible, return -1. n = len(nums) total_sum = sum(nums) max_element = max(nums) # Check if it's possible to distribute k steps evenly if (total_sum + k) % n != 0: return -1 target = (total_sum + k) // n if target < max_element: return -1 required_steps = sum(target - num for num in nums) return k if required_steps == k else -1"},{"question":"def min_path_sum(matrix): Given a matrix of integers where each element represents the cost of moving through that cell, returns the minimum cost to reach the bottom-right cell from the top-left cell. You can only move either right or down at any point in time. >>> matrix1 = [ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ] >>> min_path_sum(matrix1) 7 >>> matrix2 = [ ... [1, 2, 3], ... [4, 5, 6] ... ] >>> min_path_sum(matrix2) 12 >>> matrix3 = [] >>> min_path_sum(matrix3) 0 >>> matrix4 = [ ... [1, 2, 3] ... ] >>> min_path_sum(matrix4) 6 >>> matrix5 = [ ... [1], ... [2], ... [3] ... ] >>> min_path_sum(matrix5) 6 >>> matrix6 = [ ... [1000, 2000, 3000], ... [4000, 5000, 6000], ... [7000, 8000, 9000] ... ] >>> min_path_sum(matrix6) 21000","solution":"def min_path_sum(matrix): Given a matrix of integers where each element represents the cost of moving through that cell, returns the minimum cost to reach the bottom-right cell from the top-left cell. You can only move either right or down at any point in time. if not matrix or not matrix[0]: return 0 rows, cols = len(matrix), len(matrix[0]) dp = [[0] * cols for _ in range(rows)] dp[0][0] = matrix[0][0] for i in range(1, rows): dp[i][0] = dp[i - 1][0] + matrix[i][0] for j in range(1, cols): dp[0][j] = dp[0][j - 1] + matrix[0][j] for i in range(1, rows): for j in range(1, cols): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j] return dp[-1][-1]"},{"question":"def max_increasing_subsequence(nums1, nums2): Finds the maximum length of a subsequence in nums1 that can form a good pair with a subsequence in nums2. Parameters: nums1 (list of int): First list of integers. nums2 (list of int): Second list of integers. Returns: int: The length of the longest such subsequence. from solution import max_increasing_subsequence def test_example_case(): nums1 = [1, 3, 2, 5] nums2 = [3, 4, 1] assert max_increasing_subsequence(nums1, nums2) == 2 def test_all_elements_form_good_pairs(): nums1 = [1, 2, 3] nums2 = [4, 5, 6] assert max_increasing_subsequence(nums1, nums2) == 3 def test_no_good_pair(): nums1 = [3, 3, 3] nums2 = [2, 2, 2] assert max_increasing_subsequence(nums1, nums2) == 0 def test_partial_good_pairs(): nums1 = [1, 2, 3, 4] nums2 = [1, 1, 2, 2] assert max_increasing_subsequence(nums1, nums2) == 1 def test_empty_input(): nums1 = [] nums2 = [1, 2, 3] assert max_increasing_subsequence(nums1, nums2) == 0 nums1 = [1, 2, 3] nums2 = [] assert max_increasing_subsequence(nums1, nums2) == 0 nums1 = [] nums2 = [] assert max_increasing_subsequence(nums1, nums2) == 0 def test_duplications_in_input(): nums1 = [1, 2, 2, 3] nums2 = [2, 2, 3, 4] assert max_increasing_subsequence(nums1, nums2) == 3","solution":"def max_increasing_subsequence(nums1, nums2): Finds the maximum length of a subsequence in nums1 that can form a good pair with a subsequence in nums2. Parameters: nums1 (list of int): First list of integers. nums2 (list of int): Second list of integers. Returns: int: The length of the longest such subsequence. n, m = len(nums1), len(nums2) # dp[i][j] will store the length of the longest subsequence up to nums1[i] and nums2[j] dp = [[0] * (m + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, m + 1): if nums1[i - 1] < nums2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[n][m]"},{"question":"def right_rotate(nums: List[int], m: int) -> List[int]: Performs m right rotations on the array nums. >>> right_rotate([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> right_rotate([1, 2, 3, 4, 5], 7) [4, 5, 1, 2, 3] def test_right_rotate_no_rotations(): assert right_rotate([1, 2, 3, 4, 5], 0) == [1, 2, 3, 4, 5] def test_right_rotate_single_rotation(): assert right_rotate([1, 2, 3, 4, 5], 1) == [5, 1, 2, 3, 4] def test_right_rotate_two_rotations(): assert right_rotate([1, 2, 3, 4, 5], 2) == [4, 5, 1, 2, 3] def test_right_rotate_n_rotations(): assert right_rotate([1, 2, 3, 4, 5], 5) == [1, 2, 3, 4, 5] def test_right_rotate_more_than_n_rotations(): assert right_rotate([1, 2, 3, 4, 5], 7) == [4, 5, 1, 2, 3] def test_right_rotate_large_n(): assert right_rotate([1, 2, 3, 4, 5], 12) == [4, 5, 1, 2, 3] def test_right_rotate_different_lengths(): assert right_rotate([1, 2], 1) == [2, 1] assert right_rotate([1, 2, 3], 4) == [3, 1, 2]","solution":"def right_rotate(nums, m): Performs m right rotations on the array nums. n = len(nums) # Effective rotations needed is m mod n because rotating n times leads to the same array m = m % n return nums[-m:] + nums[:-m]"},{"question":"def min_operations_to_zero(n: int) -> int: Given an integer n, return the minimal number of operations to reduce it to zero. You can reduce the number by either 1 or any power of 2 in each operation. >>> min_operations_to_zero(1) 1 >>> min_operations_to_zero(4) 1 >>> min_operations_to_zero(8) 1 >>> min_operations_to_zero(10) 2 >>> min_operations_to_zero(15) 4 >>> min_operations_to_zero(31) 5","solution":"def min_operations_to_zero(n): Given an integer n, return the minimal number of operations to reduce it to zero. You can reduce the number by either 1 or any power of 2 in each operation. dp = [float('inf')] * (n + 1) dp[0] = 0 for i in range(1, n + 1): power = 1 while power <= i: dp[i] = min(dp[i], dp[i - power] + 1) power *= 2 return dp[n]"},{"question":"def is_possible_split(numList: List[int], k: int) -> bool: Determine if you can split numList into k continuous subsequences where each subsequence contains consecutive integers. >>> is_possible_split([1, 2, 3, 3, 4, 4, 5, 6], 4) == True >>> is_possible_split([1, 2, 3, 3, 4, 4, 5, 6], 3) == False >>> is_possible_split([1, 2, 3, 4, 5, 6, 7, 8, 9], 3) == True >>> is_possible_split([1, 2, 3, 3, 5, 4, 5, 6], 3) == False >>> is_possible_split([], 1) == False >>> is_possible_split([1], 1) == True >>> is_possible_split([1, 1, 1, 1], 4) == False","solution":"from collections import Counter from heapq import * def is_possible_split(numList, k): if not numList: return False if len(numList) % k != 0: return False count = Counter(numList) min_heap = list(count.keys()) heapify(min_heap) while min_heap: min_val = min_heap[0] for i in range(min_val, min_val + k): if count[i] == 0: return False count[i] -= 1 if count[i] == 0: heappop(min_heap) elif count[i] < 0: return False return True"},{"question":"import heapq from typing import List def eatenApples(arr: List[int], days: List[int]) -> int: Given an array of integers arr where arr[i] represents the number of apples on the i-th day and an array days of the same length where days[i] represents the number of days after the i-th day that the apples remain fresh, return the maximum number of apples you can eat if you can only eat one apple per day and you must eat the fresh apples before they rot. >>> eatenApples([1,2,3,5,2], [3,2,1,4,2]) == 7 >>> eatenApples([3,0,0,0,0,2], [3,0,0,0,0,2]) == 5 >>> eatenApples([0,0,0], [0,0,0]) == 0 >>> eatenApples([1,2,1,4,5], [0,0,0,0,0]) == 0 >>> eatenApples([1,1,1,1,1], [1,1,1,1,1]) == 5 >>> eatenApples([2,1,10], [2,10,1]) == 4","solution":"import heapq def eatenApples(arr, days): Given an array of integers arr where arr[i] represents the number of apples on the i-th day and an array days of the same length where days[i] represents the number of days after the i-th day that the apples remain fresh, return the maximum number of apples you can eat if you can only eat one apple per day and you must eat the fresh apples before they rot. n = len(arr) heap = [] day = 0 eaten_apples = 0 while day < n or heap: # Add new apples if day < n and arr[day] > 0: heapq.heappush(heap, (day + days[day], arr[day])) # Remove rotten apples while heap and heap[0][0] <= day: heapq.heappop(heap) # Eat an apple, if possible if heap: expire_day, count = heapq.heappop(heap) if count > 1: heapq.heappush(heap, (expire_day, count - 1)) eaten_apples += 1 day += 1 return eaten_apples"},{"question":"def generate_binary(n: int) -> List[str]: Generate all binary strings of length n that do not contain consecutive '1's. >>> generate_binary(0) == [] >>> generate_binary(1) == ['0', '1'] >>> generate_binary(2) == sorted(['00', '01', '10']) >>> generate_binary(3) == sorted(['000', '001', '010', '100', '101']) >>> generate_binary(4) == sorted(['0000', '0001', '0010', '0100', '0101', '1000', '1001', '1010']) pass","solution":"def generate_binary(n): Generate all binary strings of length n that do not contain consecutive '1's. if n == 0: return [] if n == 1: return ['0', '1'] prev_prev_list = ['0', '1'] # Solutions for length 1 prev_list = ['00', '01', '10'] # Solutions for length 2 if n == 2: return prev_list for _ in range(3, n + 1): curr_list = [] for num in prev_list: if num[-1] == '0': curr_list.append(num + '0') curr_list.append(num + '1') else: # num[-1] == '1' curr_list.append(num + '0') prev_prev_list = prev_list prev_list = curr_list return prev_list"},{"question":"def can_be_obtained_by_one_swap(str1: str, str2: str) -> bool: Determines if \`str2\` can be obtained by performing at most one swap of two characters in \`str1\`. >>> can_be_obtained_by_one_swap(\\"abc\\", \\"abc\\") True >>> can_be_obtained_by_one_swap(\\"ab\\", \\"ba\\") True >>> can_be_obtained_by_one_swap(\\"converse\\", \\"converes\\") True >>> can_be_obtained_by_one_swap(\\"converse\\", \\"covenres\\") False >>> can_be_obtained_by_one_swap(\\"abc\\", \\"abcd\\") False >>> can_be_obtained_by_one_swap(\\"aabb\\", \\"bbaa\\") False >>> can_be_obtained_by_one_swap(\\"abccba\\", \\"abccba\\") True","solution":"def can_be_obtained_by_one_swap(str1, str2): Returns True if str2 can be obtained by one swap of two characters in str1, otherwise returns False. if len(str1) != len(str2): return False # Find character mismatches between the strings mismatches = [(i, (char1, char2)) for i, (char1, char2) in enumerate(zip(str1, str2)) if char1 != char2] # If there are no mismatches, the strings are already identical if not mismatches: return True # There should be exactly two mismatches for a single swap to be possible if len(mismatches) != 2: return False # Check if swapping the mismatched characters in str1 will make it equal to str2 (i1, (char1_1, char2_1)), (i2, (char1_2, char2_2)) = mismatches return char1_1 == char2_2 and char1_2 == char2_1"},{"question":"def min_students_to_move(heights): Returns the minimum number of students that must move to line up in non-decreasing order of heights. >>> min_students_to_move([4, 3, 2, 1]) 4 >>> min_students_to_move([1, 2, 3, 4, 5]) 0 >>> min_students_to_move([1, 2, 5, 3, 4]) 3 >>> min_students_to_move([1]) 0 >>> min_students_to_move([2, 1]) 2 >>> min_students_to_move([1, 2]) 0 >>> min_students_to_move([1, 3, 2, 3, 5]) 2","solution":"def min_students_to_move(heights): Returns the minimum number of students that must move to line up in non-decreasing order of heights. sorted_heights = sorted(heights) count = 0 for i in range(len(heights)): if heights[i] != sorted_heights[i]: count += 1 return count"},{"question":"import heapq from collections import Counter from typing import List def reorganize_string(s: str) -> str: Rearrange the characters of the string such that two consecutive characters are not the same. If it is not possible, return an empty string. >>> reorganize_string(\\"aab\\") in [\\"aba\\", \\"baa\\"] True >>> reorganize_string(\\"aaab\\") == \\"\\" True >>> reorganize_string(\\"a\\") == \\"a\\" True >>> reorganize_string(\\"aa\\") == \\"\\" True >>> reorganize_string(\\"aabbcc\\").find('aa') == -1 and reorganize_string(\\"aabbcc\\").find('bb') == -1 and reorganize_string(\\"aabbcc\\").find('cc') == -1 True","solution":"import heapq from collections import Counter def reorganize_string(s): Rearrange the characters of the string such that two consecutive characters are not the same. If it is not possible, return an empty string. counter = Counter(s) max_heap = [(-count, char) for char, count in counter.items()] heapq.heapify(max_heap) prev_count, prev_char = 0, '' result = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) prev_count = count + 1 prev_char = char result_str = ''.join(result) if len(result_str) != len(s): return '' return result_str"},{"question":"import heapq def trap_rain_water(grid: List[List[int]]) -> int: Given a matrix grid of shape m x n consisting of non-negative integers representing a height map, compute the amount of water it can trap after raining. >>> trap_rain_water([]) 0 >>> trap_rain_water([[]]) 0 >>> trap_rain_water([[0]]) 0 >>> trap_rain_water([[1]]) 0 >>> trap_rain_water([[1,1], [1,1]]) 0 >>> trap_rain_water([[1, 1, 1], [1, 0, 1], [1, 1, 1]]) 1 >>> trap_rain_water([ ... [1, 4, 3, 1, 3, 2], ... [3, 2, 1, 3, 2, 4], ... [2, 3, 3, 2, 3, 1] ... ]) 4 >>> trap_rain_water([ ... [12, 13, 1, 12], ... [13, 4, 13, 12], ... [13, 8, 10, 12], ... [12, 13, 12, 12], ... [12, 13, 12, 12] ... ]) 14","solution":"import heapq def trap_rain_water(grid): if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) visited = [[False] * n for _ in range(m)] min_heap = [] # Add all the border cells to the min heap and mark them as visited for i in range(m): for j in (0, n-1): heapq.heappush(min_heap, (grid[i][j], i, j)) visited[i][j] = True for j in range(1, n-1): for i in (0, m-1): heapq.heappush(min_heap, (grid[i][j], i, j)) visited[i][j] = True total_water = 0 directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] while min_heap: height, x, y = heapq.heappop(min_heap) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]: visited[nx][ny] = True total_water += max(0, height - grid[nx][ny]) heapq.heappush(min_heap, (max(height, grid[nx][ny]), nx, ny)) return total_water"},{"question":"class Solution: def numDistinctIslands(self, grid: List[List[int]]) -> int: Count the total number of distinct islands in a 2D grid. Two islands are considered distinct if and only if one island's shape is different from the other (not including rotations and reflections). >>> Solution().numDistinctIslands([[1,1,0,0,0], [1,1,0,0,0], [0,0,0,1,1], [0,0,0,1,1]]) == 1 >>> Solution().numDistinctIslands([[1,1,0,0], [1,0,0,0], [0,0,0,1], [0,0,1,1]]) == 2 >>> Solution().numDistinctIslands([[1,0,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0]]) == 1 >>> Solution().numDistinctIslands([[0,0,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0]]) == 0 >>> Solution().numDistinctIslands([[1,1,1,1], [1,1,1,1], [1,1,1,1], [1,1,1,1]]) == 1","solution":"class Solution: def numDistinctIslands(self, grid): def dfs(grid, r, c, direction): if (r < 0 or r >= len(grid) or c < 0 or c >= len(grid[0]) or grid[r][c] == 0): return grid[r][c] = 0 shape.append(direction) dfs(grid, r+1, c, 'D') # Down dfs(grid, r-1, c, 'U') # Up dfs(grid, r, c+1, 'R') # Right dfs(grid, r, c-1, 'L') # Left shape.append('B') # Back, to mark end of a direction branch distinct_islands = set() for r in range(len(grid)): for c in range(len(grid[0])): if grid[r][c] == 1: shape = [] dfs(grid, r, c, 'S') # Start distinct_islands.add(tuple(shape)) return len(distinct_islands)"},{"question":"def count_underqualified_employees(skills): Returns the number of underqualified employees. Parameters: skills (list of list of int): 2D integer array representing skills of employees. Returns: int: Number of underqualified employees. >>> count_underqualified_employees([[3, 4], [5, 2], [1, 6]]) == 0 >>> count_underqualified_employees([[3, 4], [5, 6]]) == 1 >>> count_underqualified_employees([[4, 5, 6], [1, 2, 3], [7, 8, 9]]) == 2 >>> count_underqualified_employees([[7, 8, 9]]) == 0 >>> count_underqualified_employees([[4, 4, 4], [4, 4, 4], [4, 4, 4]]) == 0 >>> count_underqualified_employees([[1000, 2000, 3000], [1001, 2001, 3001], [999, 1999, 2999]]) == 2","solution":"def count_underqualified_employees(skills): Returns the number of underqualified employees. Parameters: skills (list of list of int): 2D integer array representing skills of employees. Returns: int: Number of underqualified employees. n = len(skills) m = len(skills[0]) underqualified_count = 0 for i in range(n): underqualified = False for j in range(n): if i != j: all_higher = True for k in range(m): if skills[j][k] <= skills[i][k]: all_higher = False break if all_higher: underqualified = True break if underqualified: underqualified_count += 1 return underqualified_count"},{"question":"def split_array_min_max_sum(arr: List[int], m: int) -> int: You are given a list of \`n\` integers \`arr\`, and you need to split this list into exactly \`m\` non-empty continuous subarrays. Write a function to minimize the maximum sum among these \`m\` subarrays. Return this minimum possible maximum sum. >>> split_array_min_max_sum([7, 2, 5, 10, 8], 2) 18 >>> split_array_min_max_sum([1, 2, 3, 4, 5], 5) 5 from typing import List def test_example_case(): assert split_array_min_max_sum([7, 2, 5, 10, 8], 2) == 18 def test_single_element_subarrays(): assert split_array_min_max_sum([1, 2, 3, 4, 5], 5) == 5 def test_two_elements_split(): assert split_array_min_max_sum([1, 2, 3, 4, 5], 3) == 6 def test_split_single_subarray(): assert split_array_min_max_sum([10, 20, 30, 40, 50], 1) == 150 def test_large_values(): assert split_array_min_max_sum([1, 4, 4], 3) == 4 def test_all_equal_elements(): assert split_array_min_max_sum([5, 5, 5, 5, 5], 2) == 15","solution":"def split_array_min_max_sum(arr, m): def can_split(max_sum): current_sum = 0 num_subarrays = 1 for num in arr: if current_sum + num > max_sum: num_subarrays += 1 current_sum = num if num_subarrays > m: return False else: current_sum += num return True left, right = max(arr), sum(arr) while left < right: mid = (left + right) // 2 if can_split(mid): right = mid else: left = mid + 1 return left"},{"question":"class Course: A university offers a system where students can enroll in courses online. Implement the \`Course\` class with the following functionalities: 1. \`Course(name: str, maxSeats: int)\`: Constructor to initialize a course with the given \`name\` and a maximum number of seats. 2. \`bool enrollStudent(studentId: int)\`: Enrolls a student by their \`studentId\` in the course if there is room. Returns \`true\` if the enrollment is successful, otherwise returns \`false\`. 3. \`bool removeStudent(studentId: int)\`: Removes a student from the course by their \`studentId\`. Returns \`true\` if the removal is successful, otherwise returns \`false\`. 4. \`List[int] getEnrolledStudents()\`: Returns a list of student IDs currently enrolled in the course. def test_enroll_student_success(): course = Course(\\"Math\\", 2) assert course.enrollStudent(1) == True assert course.enrollStudent(2) == True def test_enroll_student_failure(): course = Course(\\"Math\\", 1) course.enrollStudent(1) assert course.enrollStudent(2) == False def test_remove_student_success(): course = Course(\\"Math\\", 2) course.enrollStudent(1) assert course.removeStudent(1) == True def test_remove_student_failure(): course = Course(\\"Math\\", 2) assert course.removeStudent(1) == False def test_get_enrolled_students(): course = Course(\\"Math\\", 2) course.enrollStudent(1) course.enrollStudent(2) assert course.getEnrolledStudents() == [1, 2] def test_remove_nonexistent_student(): course = Course(\\"Math\\", 2) course.enrollStudent(1) assert course.removeStudent(2) == False assert course.getEnrolledStudents() == [1] def test_enroll_existing_student(): course = Course(\\"Math\\", 2) course.enrollStudent(1) assert course.enrollStudent(1) == False assert course.getEnrolledStudents() == [1]","solution":"class Course: def __init__(self, name: str, maxSeats: int): self.name = name self.maxSeats = maxSeats self.enrolledStudents = [] def enrollStudent(self, studentId: int) -> bool: if len(self.enrolledStudents) < self.maxSeats and studentId not in self.enrolledStudents: self.enrolledStudents.append(studentId) return True return False def removeStudent(self, studentId: int) -> bool: if studentId in self.enrolledStudents: self.enrolledStudents.remove(studentId) return True return False def getEnrolledStudents(self) -> list: return self.enrolledStudents"},{"question":"def shortest_distance(words: List[str], word1: str, word2: str) -> int: Find the shortest distance between two words in a list of words. Args: words (list): List of words in the sentence. word1 (str): First word. word2 (str): Second word. Returns: int: The shortest distance between the two words. Examples: >>> shortest_distance([\\"practice\\", \\"makes\\", \\"perfect\\", \\"coding\\", \\"makes\\"], \\"coding\\", \\"practice\\") 3 >>> shortest_distance([\\"practice\\", \\"makes\\", \\"perfect\\", \\"coding\\", \\"practice\\"], \\"makes\\", \\"perfect\\") 1","solution":"def shortest_distance(words, word1, word2): Find the shortest distance between two words in a list of words. Args: words (list): List of words in the sentence. word1 (str): First word. word2 (str): Second word. Returns: int: The shortest distance between the two words. # Initialize variables to store the latest positions of word1 and word2. index1, index2 = -1, -1 min_distance = float('inf') for index, word in enumerate(words): if word == word1: index1 = index elif word == word2: index2 = index # Calculate distance if both words have been seen if index1 != -1 and index2 != -1: min_distance = min(min_distance, abs(index1 - index2)) return min_distance"},{"question":"def length_of_longest_subarray(nums: List[int], k: int) -> int: Returns the length of the longest subarray with at most k distinct integers. >>> length_of_longest_subarray([1, 2, 1, 2, 3], 2) 4 >>> length_of_longest_subarray([1], 1) 1 >>> length_of_longest_subarray([1, 2, 3, 4, 5], 0) 0 >>> length_of_longest_subarray([1, 2, 3, 4, 5], 5) 5 >>> length_of_longest_subarray([1, 2, 2, 3, 4], 10) 5 >>> length_of_longest_subarray([1, 2, 1, 2, 3], 3) 5 >>> length_of_longest_subarray([1, 2, 3, 2, 2], 2) 4","solution":"def length_of_longest_subarray(nums, k): Returns the length of the longest subarray with at most k distinct integers. from collections import defaultdict n = len(nums) if n == 0 or k == 0: return 0 left = 0 right = 0 max_length = 0 distinct_count = 0 freq = defaultdict(int) while right < n: if freq[nums[right]] == 0: distinct_count += 1 freq[nums[right]] += 1 right += 1 while distinct_count > k: freq[nums[left]] -= 1 if freq[nums[left]] == 0: distinct_count -= 1 left += 1 max_length = max(max_length, right - left) return max_length"},{"question":"def can_convert(a: str, b: str) -> bool: Determine if string \`a\` can be converted to string \`b\` by performing deletions from \`a\` followed by insertions. >>> can_convert(\\"abcdef\\", \\"acf\\") True >>> can_convert(\\"abcdef\\", \\"abcdef\\") True >>> can_convert(\\"abcdef\\", \\"\\") True >>> can_convert(\\"\\", \\"abcdef\\") False >>> can_convert(\\"abcdef\\", \\"azc\\") False >>> can_convert(\\"abcdef\\", \\"ace\\") True >>> can_convert(\\"aabbcc\\", \\"abc\\") True >>> can_convert(\\"aabaccd\\", \\"abc\\") True >>> can_convert(\\"abc\\", \\"abcde\\") False","solution":"def can_convert(a, b): Checks if string \`a\` can be converted to string \`b\` by first performing deletions and then insertions. # Find the Longest Common Subsequence (LCS) of \`a\` and \`b\` m = len(a) n = len(b) LCS = [[0] * (n + 1) for _ in range(m + 1)] # Fill the LCS table for i in range(m + 1): for j in range(n + 1): if i == 0 or j == 0: LCS[i][j] = 0 elif a[i - 1] == b[j - 1]: LCS[i][j] = LCS[i - 1][j - 1] + 1 else: LCS[i][j] = max(LCS[i - 1][j], LCS[i][j - 1]) # Check if the longest common subsequence is equal to the length of b return LCS[m][n] == n"},{"question":"def min_operations_to_sort(arr, k): Returns the minimum number of operations required to sort the array using subarray reversals of length k. If it is impossible, returns -1. >>> min_operations_to_sort([1, 2, 3, 4], 2) == 0 >>> min_operations_to_sort([4, 3, 2, 1], 1) == -1 >>> min_operations_to_sort([4, 3, 2, 1], 4) == 1 >>> min_operations_to_sort([2, 1, 4, 3, 7, 6, 5], 3) == -1 >>> min_operations_to_sort([3, 1, 2, 5, 4], 2) == 3 >>> min_operations_to_sort([], 2) == 0 >>> min_operations_to_sort([1, 2, 3, 4, 5, 6], 3) == 0","solution":"def min_operations_to_sort(arr, k): Returns the minimum number of operations required to sort the array using subarray reversals of length k. If it is impossible, returns -1. if k == 1: return -1 if arr != sorted(arr) else 0 n = len(arr) sorted_arr = sorted(arr) if arr == sorted_arr: return 0 def can_be_sorted_with_reversals(array, k): for i in range(0, len(array) - k + 1, k // 2): sub_array = array[i:i + k] if sorted(sub_array) != sub_array: sub_array.reverse() if sorted(sub_array) == sub_array: array[i:i + k] = sub_array return True return False operations = 0 while arr != sorted_arr: if not can_be_sorted_with_reversals(arr, k): return -1 operations += 1 return operations"},{"question":"from typing import List, Dict def group_dates_by_year(dates: List[str]) -> Dict[int, List[str]]: Groups the given list of dates by year. Parameters: dates (List[str]): A list of dates in 'YYYY-MM-DD' format. Returns: Dict[int, List[str]]: A dictionary where keys are years and values are lists of dates for that year. >>> group_dates_by_year([\\"2020-01-01\\", \\"2019-12-31\\", \\"2020-06-15\\", \\"2021-01-01\\"]) {2020: [\\"2020-01-01\\", \\"2020-06-15\\"], 2019: [\\"2019-12-31\\"], 2021: [\\"2021-01-01\\"]} >>> group_dates_by_year([]) {} >>> group_dates_by_year([\\"2020-01-01\\"]) {2020: [\\"2020-01-01\\"]} >>> group_dates_by_year([\\"2020-01-01\\", \\"2020-06-15\\", \\"2020-12-30\\"]) {2020: [\\"2020-01-01\\", \\"2020-06-15\\", \\"2020-12-30\\"]} >>> group_dates_by_year([\\"2021-03-02\\", \\"2020-12-31\\", \\"2021-01-01\\", \\"2019-04-25\\", \\"2020-06-15\\"]) {2021: [\\"2021-01-01\\", \\"2021-03-02\\"], 2020: [\\"2020-06-15\\", \\"2020-12-31\\"], 2019: [\\"2019-04-25\\"]}","solution":"from typing import List, Dict def group_dates_by_year(dates: List[str]) -> Dict[int, List[str]]: Groups the given list of dates by year. Parameters: dates (List[str]): A list of dates in 'YYYY-MM-DD' format. Returns: Dict[int, List[str]]: A dictionary where keys are years and values are lists of dates for that year. date_dict = {} for date in dates: year = int(date[:4]) # Extract year from date string if year not in date_dict: date_dict[year] = [] date_dict[year].append(date) # Sort the dates for each year for year in date_dict: date_dict[year].sort() return date_dict"},{"question":"class SubsetXORChecker: Initialize the SubsetXORChecker with the array arr and check if there exists a non-empty subset with XOR equal to x. Parameters: arr (List[int]): List of integers. Methods: subsetXORSatisfies(x: int) -> bool: Check if there exists a non-empty subset of arr whose XOR is equal to x. >>> checker = SubsetXORChecker([1, 2, 3, 4]) >>> checker.subsetXORSatisfies(6) True >>> checker.subsetXORSatisfies(10) False def __init__(self, arr): self.arr = arr def subsetXORSatisfies(self, x): pass","solution":"class SubsetXORChecker: def __init__(self, arr): self.arr = arr def subsetXORSatisfies(self, x): n = len(self.arr) subset_count = 1 << n # There are 2^n subsets for a set of size n for i in range(1, subset_count): xor_sum = 0 for j in range(n): if i & (1 << j): # If the j-th bit of i is set, include arr[j] xor_sum ^= self.arr[j] if xor_sum == x: return True return False"},{"question":"from typing import List def evaluate_expression(expr: str) -> int: Evaluates a mathematical expression with non-negative integers and +, - operators. Parameters: expr (str): The expression to evaluate Returns: int: The result of the expression Examples: >>> evaluate_expression(\\"3+5-2+8-6\\") 8 >>> evaluate_expression(\\"10+20-5+15-10\\") 30 >>> evaluate_expression(\\"-2+3\\") 1 >>> evaluate_expression(\\"10-5-3-2\\") 0 >>> evaluate_expression(\\"3+5+7+9\\") 24 >>> evaluate_expression(\\"1+2-3+4-5+6\\") 5","solution":"def evaluate_expression(expr): Evaluates a mathematical expression with non-negative integers and +, - operators. Parameters: expr (str): The expression to evaluate Returns: int: The result of the expression # Split input based on '+' and '-' index = 0 length = len(expr) current_number = 0 result = 0 sign = 1 # Start with a positive sign while index < length: if expr[index].isdigit(): current_number = 0 while index < length and expr[index].isdigit(): current_number = current_number * 10 + int(expr[index]) index += 1 result += sign * current_number elif expr[index] == '+': sign = 1 index += 1 elif expr[index] == '-': sign = -1 index += 1 return result"},{"question":"def max_items(nums: List[int]) -> int: Determines the maximum number of items that can be collected without choosing two consecutive actions. >>> max_items([3, 2, 5, 10, 7]) 15 >>> max_items([]) 0 >>> max_items([5]) 5 >>> max_items([2, 3]) 3 >>> max_items([3, 2]) 3 >>> max_items([2, 7, 9, 3, 1]) 12 >>> max_items([5, 5, 10, 100, 10, 5]) 110 >>> max_items([1, 2, 3, 1]) 4","solution":"def max_items(nums): Determines the maximum number of items that can be collected without choosing two consecutive actions. if not nums: return 0 if len(nums) == 1: return nums[0] # Initialize dp array to store the maximum number of items that can be collected up to each index dp = [0] * len(nums) dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, len(nums)): dp[i] = max(dp[i-1], dp[i-2] + nums[i]) return dp[-1]"},{"question":"def word_break(s: str, wordDict: List[str]) -> List[str]: Given a string \`s\` and a dictionary of words \`wordDict\`, return all the sentences in which each word is a valid word from \`wordDict\`. The words in the sentences should be combined in the exact order as they appear in the string \`s\` and should not overlap. >>> word_break(\\"catsanddog\\", [\\"cat\\", \\"cats\\", \\"and\\", \\"sand\\", \\"dog\\"]) [\\"cats and dog\\", \\"cat sand dog\\"] >>> word_break(\\"pineapplepenapple\\", [\\"apple\\", \\"pen\\", \\"applepen\\", \\"pine\\", \\"pineapple\\"]) [\\"pine apple pen apple\\", \\"pineapple pen apple\\", \\"pine applepen apple\\"] >>> word_break(\\"word\\", [\\"word\\"]) [\\"word\\"] >>> word_break(\\"catsanddog\\", [\\"cat\\", \\"dog\\"]) [] >>> word_break(\\"pineapplepenapple\\", [\\"pine\\", \\"apple\\", \\"pen\\", \\"pineapple\\"]) [\\"pine apple pen apple\\", \\"pineapple pen apple\\"]","solution":"def word_break(s, wordDict): Given a string \`s\` and a dictionary of words \`wordDict\`, returns all the sentences in which each word is a valid word from \`wordDict\`. The words in the sentences should be combined in the exact order as they appear in the string \`s\` and should not overlap. :param s: Input string :param wordDict: List of valid words :return: List of all possible sentences word_set = set(wordDict) memo = {} def backtrack(start): if start in memo: return memo[start] if start == len(s): return [\\"\\"] sentences = [] for end in range(start + 1, len(s) + 1): word = s[start:end] if word in word_set: for sub_sentence in backtrack(end): if sub_sentence: sentences.append(word + \\" \\" + sub_sentence) else: sentences.append(word) memo[start] = sentences return sentences return backtrack(0)"},{"question":"from typing import List def sunset_views(heights: List[int]) -> List[int]: Returns the indices of the plants that can see the sunset. The function returns the indices of the plants that can see the sunset where taller plants block the view of the shorter plants to their right. The array of indices is returned in increasing order. >>> sunset_views([1]) [0] >>> sunset_views([1, 2, 3, 4, 5]) [4] >>> sunset_views([5, 4, 3, 2, 1]) [0, 1, 2, 3, 4] >>> sunset_views([4, 2, 3, 1, 5]) [4] >>> sunset_views([4, 3, 2, 3, 1]) [0, 3, 4] >>> sunset_views([3, 3, 3, 3, 4]) [4] >>> sunset_views([]) []","solution":"from typing import List def sunset_views(heights: List[int]) -> List[int]: Returns the indices of the plants that can see the sunset. n = len(heights) result = [] if n == 0: return result max_height = 0 for i in range(n - 1, -1, -1): if heights[i] > max_height: result.append(i) max_height = heights[i] return list(reversed(result))"},{"question":"def num_resource_islands(grid: List[List[str]]) -> int: Calculate the number of islands containing at least one resource ('X'). An island is defined as a group of '1's (land) connected vertically or horizontally. >>> num_resource_islands([ ['0', '0', '0'], ['0', '0', '0'], ['0', '0', '0'] ]) == 0 >>> num_resource_islands([ ['1', '1', '0'], ['1', 'X', '0'], ['0', '0', '0'] ]) == 1","solution":"def num_resource_islands(grid): if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) visited = [[False] * n for _ in range(m)] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def dfs(x, y): stack = [(x, y)] has_resource = False while stack: i, j = stack.pop() if grid[i][j] == 'X': has_resource = True for di, dj in directions: ni, nj = i + di, j + dj if 0 <= ni < m and 0 <= nj < n and not visited[ni][nj] and (grid[ni][nj] == '1' or grid[ni][nj] == 'X'): visited[ni][nj] = True stack.append((ni, nj)) return has_resource count = 0 for i in range(m): for j in range(n): if (grid[i][j] == '1' or grid[i][j] == 'X') and not visited[i][j]: visited[i][j] = True if dfs(i, j): count += 1 return count"},{"question":"def count_toggled_cells(m: int, n: int, toggles: List[Tuple[int, int, int]]) -> int: Returns the number of cells in the m x n matrix that end up with a value of 1. :param m: Number of rows in the matrix :param n: Number of columns in the matrix :param toggles: List of triples (row index, column index, number of times the cell is toggled) :return: Number of cells with value 1 >>> count_toggled_cells(3, 3, []) == 0 >>> count_toggled_cells(2, 2, [(0, 1, 1)]) == 1 >>> count_toggled_cells(2, 2, [(0, 1, 2)]) == 0 >>> count_toggled_cells(3, 3, [(1, 1, 3), (1, 1, 2)]) == 1 >>> count_toggled_cells(3, 3, [(0, 0, 1), (1, 1, 4), (2, 2, 3), (2, 0, 5)]) == 3 >>> count_toggled_cells(100, 100, [(i, j, 3) for i in range(100) for j in range(100)]) == 10000","solution":"def count_toggled_cells(m, n, toggles): Returns the number of cells in the m x n matrix that end up with a value of 1. :param m: Number of rows in the matrix :param n: Number of columns in the matrix :param toggles: List of triples (row index, column index, number of times the cell is toggled) :return: Number of cells with value 1 matrix = [[0 for _ in range(n)] for _ in range(m)] for toggle in toggles: row, col, times = toggle matrix[row][col] = (matrix[row][col] + times) % 2 count_ones = sum(cell for row in matrix for cell in row) return count_ones"},{"question":"def mySqrt(x: int) -> int: Given a non-negative integer x, return the square root of x rounded down to the nearest integer without using any built-in exponentiation functions or operators. >>> mySqrt(0) == 0 True >>> mySqrt(1) == 1 True >>> mySqrt(2) == 1 True >>> mySqrt(3) == 1 True >>> mySqrt(4) == 2 True >>> mySqrt(8) == 2 True >>> mySqrt(9) == 3 True >>> mySqrt(100) == 10 True >>> mySqrt(101) == 10 True >>> mySqrt(200) == 14 True >>> mySqrt(10000) == 100 True >>> mySqrt(20) == 4 True >>> mySqrt(15) == 3 True >>> mySqrt(99) == 9 True >>> mySqrt(2147483647) == 46340 True def test_mySqrt(): assert mySqrt(0) == 0 assert mySqrt(1) == 1 assert mySqrt(2) == 1 assert mySqrt(3) == 1 assert mySqrt(4) == 2 assert mySqrt(8) == 2 assert mySqrt(9) == 3 assert mySqrt(100) == 10 assert mySqrt(101) == 10 assert mySqrt(200) == 14 assert mySqrt(10000) == 100 assert mySqrt(20) == 4 assert mySqrt(15) == 3 assert mySqrt(99) == 9 assert mySqrt(2147483647) == 46340 try: mySqrt(-1) except ValueError as ve: assert str(ve) == \\"The input must be a non-negative integer.\\"","solution":"def mySqrt(x): Returns the square root of x rounded down to the nearest integer. if x < 0: raise ValueError(\\"The input must be a non-negative integer.\\") if x == 0: return 0 start, end = 1, x while start <= end: mid = (start + end) // 2 if mid * mid == x: return mid elif mid * mid < x: start = mid + 1 else: end = mid - 1 return end"},{"question":"def merge_intervals(intervals): Given a list of non-overlapping intervals, merge those intervals if they overlap. Each interval is represented as a tuple (start, end) where start is the starting point and end is the endpoint. The intervals are not guaranteed to be in any specific order. Return a new list of intervals such that no two intervals overlap and all overlapping intervals are merged into one. >>> merge_intervals([]) == [] >>> merge_intervals([(1, 2), (3, 4)]) == [(1, 2), (3, 4)] >>> merge_intervals([(1, 4), (2, 3)]) == [(1, 4)] >>> merge_intervals([(1, 3), (2, 5), (6, 8)]) == [(1, 5), (6, 8)] >>> merge_intervals([(1, 4), (2, 5), (7, 9), (8, 10)]) == [(1, 5), (7, 10)] >>> merge_intervals([(1, 4), (4, 5)]) == [(1, 5)] >>> merge_intervals([(6, 8), (1, 3), (2, 4)]) == [(1, 4), (6, 8)]","solution":"def merge_intervals(intervals): Merges a list of non-overlapping intervals if they overlap. Parameters: intervals (list of tuples): each tuple (start, end) represents an interval Returns: list of tuples: merged list of intervals if not intervals: return [] # Sort intervals based on the start value intervals.sort(key=lambda x: x[0]) merged = [intervals[0]] for current in intervals[1:]: last = merged[-1] if current[0] <= last[1]: # there is an overlap merged[-1] = (last[0], max(last[1], current[1])) # merge else: merged.append(current) return merged"},{"question":"def search_target_in_matrix(matrix, target): Search for all occurrences of target in a row-wise and column-wise sorted matrix. Args: matrix (List[List[int]]): 2D list of integers sorted row-wise and column-wise. target (int): The target integer to search for. Returns: List[List[int]]: List of [row, column] indices where target is found, or an empty list if target is not found. # Test cases def test_target_present_in_multiple_locations(): matrix = [ [1, 3, 5], [2, 4, 6], [3, 5, 7] ] target = 3 assert search_target_in_matrix(matrix, target) == [[0, 1], [2, 0]] def test_target_not_present(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] target = 10 assert search_target_in_matrix(matrix, target) == [] def test_target_present_single_location(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] target = 5 assert search_target_in_matrix(matrix, target) == [[1, 1]] def test_empty_matrix(): matrix = [] target = 1 assert search_target_in_matrix(matrix, target) == [] def test_single_element_matrix_target_present(): matrix = [[5]] target = 5 assert search_target_in_matrix(matrix, target) == [[0, 0]] def test_single_element_matrix_target_not_present(): matrix = [[5]] target = 3 assert search_target_in_matrix(matrix, target) == []","solution":"def search_target_in_matrix(matrix, target): Search for all occurrences of target in a row-wise and column-wise sorted matrix. Args: matrix (List[List[int]]): 2D list of integers sorted row-wise and column-wise. target (int): The target integer to search for. Returns: List[List[int]]: List of [row, column] indices where target is found, or an empty list if target is not found. if not matrix or not matrix[0]: return [] m, n = len(matrix), len(matrix[0]) i, j = 0, n - 1 result = [] while i < m and j >= 0: if matrix[i][j] == target: result.append([i, j]) i += 1 j -= 1 elif matrix[i][j] > target: j -= 1 else: i += 1 return result"},{"question":"from typing import List def can_partition(A: List[int]) -> bool: Determines if the array A can be partitioned into two subsets with equal sums. Args: A : List[int] - List of non-negative integers Returns: bool - True if the array can be partitioned into two subsets with equal sum, False otherwise. Examples: >>> can_partition([1, 5, 11, 5]) True >>> can_partition([1, 2, 3, 5]) False >>> can_partition([1]) False >>> can_partition([]) True >>> can_partition([10, 10]) True >>> can_partition([1, 2, 3, 7, 7, 10, 10]) True >>> can_partition([0, 0, 0, 0]) True >>> can_partition([0, 0, 0, 1]) False","solution":"def can_partition(A): Determines if the array A can be partitioned into two subsets with equal sums. Args: A : List[int] - List of non-negative integers Returns: bool - True if the array can be partitioned into two subsets with equal sum, False otherwise. total_sum = sum(A) # If the total sum is odd, it's not possible to partition into equal subsets if total_sum % 2 != 0: return False target_sum = total_sum // 2 # Initialize a boolean DP array dp = [False] * (target_sum + 1) dp[0] = True # Update dp array based on numbers in A for num in A: for i in range(target_sum, num - 1, -1): dp[i] = dp[i] or dp[i - num] return dp[target_sum]"},{"question":"def recommend_blocks(ratings: List[int], blockSize: int) -> List[List[int]]: Create overlapping blocks of ratings of length blockSize and return them in reverse order. If there are fewer than blockSize ratings remaining at the end, the final block will consist only of the remaining ratings. >>> recommend_blocks([5, 1, 9, 3, 7, 4], 3) [[3, 7, 4], [9, 3, 7], [1, 9, 3], [5, 1, 9]] >>> recommend_blocks([2, 4, 6, 8, 10], 2) [[10], [8, 10], [6, 8], [4, 6], [2, 4]] >>> recommend_blocks([2, 4, 6, 8, 10], 3) [[8, 10], [6, 8, 10], [4, 6, 8], [2, 4, 6]] >>> recommend_blocks([1, 2, 3, 4, 5, 6, 7, 8, 9], 3) [[7, 8, 9], [6, 7, 8], [5, 6, 7], [4, 5, 6], [3, 4, 5], [2, 3, 4], [1, 2, 3]] >>> recommend_blocks([1, 3, 5, 7, 9], 1) [[9], [7], [5], [3], [1]]","solution":"def recommend_blocks(ratings, blockSize): n = len(ratings) blocks = [] # Generate the blocks for i in range(n - blockSize + 1): blocks.append(ratings[i:i + blockSize]) # Add the final block if it's smaller than blockSize if n % blockSize != 0: remaining_block = ratings[-(n % blockSize):] blocks.append(remaining_block) # Return in reverse order return blocks[::-1]"},{"question":"def min_cost_path(grid: List[List[int]]) -> int: Returns the minimum cost to reach from the top-left corner to the bottom-right corner of the grid. >>> min_cost_path([[5]]) == 5 >>> min_cost_path([[1, 2], [5, 6]]) == 9 # 1 -> 2 -> 6 >>> min_cost_path([[1, 3], [1, 5]]) == 7 # 1 -> 1 -> 5 >>> min_cost_path([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) == 7 # 1 -> 3 -> 1 -> 1 -> 1 >>> min_cost_path([ ... [1, 2, 5], ... [3, 2, 1] ... ]) == 6 # 1 -> 2 -> 2 -> 1","solution":"def min_cost_path(grid): rows = len(grid) cols = len(grid[0]) # Create a 2D list to store the minimum cost to reach each cell cost = [[0 for _ in range(cols)] for _ in range(rows)] cost[0][0] = grid[0][0] # Initialize the first column for i in range(1, rows): cost[i][0] = cost[i-1][0] + grid[i][0] # Initialize the first row for j in range(1, cols): cost[0][j] = cost[0][j-1] + grid[0][j] # Populate the rest of the cost array for i in range(1, rows): for j in range(1, cols): cost[i][j] = min(cost[i-1][j], cost[i][j-1]) + grid[i][j] return cost[rows-1][cols-1]"},{"question":"def kthSmallest(nums: List[int], k: int) -> int: Return the k-th smallest element in the integer array nums. >>> kthSmallest([3, 1, 2, 4], 2) 2 >>> kthSmallest([3, -1, 2, 4, 0], 3) 2 >>> kthSmallest([3, 1, 3, 4, 2, 2], 4) 3 >>> kthSmallest([5], 1) 5 >>> kthSmallest([5, 3, 7, 9, 2], 5) 9","solution":"def kthSmallest(nums, k): Returns the k-th smallest element in the array nums. nums.sort() return nums[k-1]"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def deepestLeavesSum(root: TreeNode) -> int: Returns the sum of values of the deepest leaves in a binary tree. :param root: TreeNode :return: int from solution import TreeNode, deepestLeavesSum def test_deepestLeavesSum_single_node(): tree = TreeNode(1) assert deepestLeavesSum(tree) == 1 def test_deepestLeavesSum_three_layers(): tree = TreeNode(1, TreeNode(2), TreeNode(3)) assert deepestLeavesSum(tree) == 2 + 3 def test_deepestLeavesSum_complex_tree(): tree = TreeNode(1, TreeNode(2, TreeNode(4, TreeNode(7)), TreeNode(5)), TreeNode(3, None, TreeNode(6, None, TreeNode(8)))) assert deepestLeavesSum(tree) == 15 # Sum of 7 and 8 def test_deepestLeavesSum_one_side_tree(): tree = TreeNode(1, TreeNode(2, TreeNode(3, TreeNode(4, TreeNode(5))))) assert deepestLeavesSum(tree) == 5 def test_deepestLeavesSum_empty_tree(): assert deepestLeavesSum(None) == 0","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def deepestLeavesSum(root): Returns the sum of values of the deepest leaves in a binary tree. :param root: TreeNode :return: int if not root: return 0 from collections import deque max_depth = 0 leaves_sum = 0 queue = deque([(root, 0)]) while queue: node, depth = queue.popleft() if node.left is None and node.right is None: if depth > max_depth: max_depth = depth leaves_sum = node.val elif depth == max_depth: leaves_sum += node.val else: if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1)) return leaves_sum"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longest_univalue_path(root: TreeNode) -> int: Find the length of the longest path where each node in the path has the same value. >>> root = TreeNode(1) >>> longest_univalue_path(root) 0 >>> root = TreeNode(1) >>> root.left = TreeNode(1) >>> longest_univalue_path(root) 1 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> longest_univalue_path(root) 0 >>> root = TreeNode(1) >>> root.left = TreeNode(1) >>> root.right = TreeNode(1) >>> root.left.left = TreeNode(1) >>> root.left.right = TreeNode(1) >>> root.right.right = TreeNode(1) >>> longest_univalue_path(root) 4 >>> root = TreeNode(5) >>> root.left = TreeNode(4) >>> root.right = TreeNode(5) >>> root.left.left = TreeNode(1) >>> root.left.right = TreeNode(1) >>> root.right.right = TreeNode(5) >>> longest_univalue_path(root) 2 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> longest_univalue_path(root) 0","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longest_univalue_path(root): def helper(node): nonlocal longest if not node: return 0 left_length = helper(node.left) right_length = helper(node.right) left_univalue_path = left_length + 1 if node.left and node.left.val == node.val else 0 right_univalue_path = right_length + 1 if node.right and node.right.val == node.val else 0 longest = max(longest, left_univalue_path + right_univalue_path) return max(left_univalue_path, right_univalue_path) longest = 0 helper(root) return longest"},{"question":"def min_operations_to_equalize(heights): Returns the minimum number of operations needed to make all the heights in the array equal. >>> min_operations_to_equalize([3, 3, 3]) 0 >>> min_operations_to_equalize([1, 2, 3]) 3","solution":"def min_operations_to_equalize(heights): Returns the minimum number of operations needed to make all the heights in the array equal. if not heights: return 0 max_height = max(heights) min_height = min(heights) return sum(height - min_height for height in heights)"},{"question":"from typing import List def max_money(nums: List[int], conversion: List[int]) -> int: Returns the maximum amount of money that can be obtained by converting the resources on a single day. Parameters: nums (list): List of integers where nums[i] is the number of units of a resource on the i-th day. conversion (list): List of integers where conversion[i] is the rate on the i-th day. Returns: int: Maximum money obtainable. Examples: >>> max_money([1, 2, 3], [2, 3, 4]) 12 >>> max_money([10, 20, 30], [1, 2, 3]) 90 >>> max_money([5, 5, 5], [5, 5, 5]) 25 >>> max_money([1, 2, 3], [-1, 0, 1]) 3 >>> max_money([10, 0, 30], [-1, 0, 1]) 30 >>> max_money([0, 0, 0], [1, 2, 3]) 0 >>> max_money([1, 2, 0], [0, 2, 3]) 4 >>> max_money([4, 5, 6], [3, 0, 2]) 12 >>> max_money([], []) 0 >>> max_money([5], [2]) 10 >>> max_money([10], [10]) 100","solution":"def max_money(nums, conversion): Returns the maximum amount of money that can be obtained by converting the resources on a single day. Parameters: nums (list): List of integers where nums[i] is the number of units of a resource on the i-th day. conversion (list): List of integers where conversion[i] is the rate on the i-th day. Returns: int: Maximum money obtainable. max_profit = 0 for i in range(len(nums)): max_profit = max(max_profit, nums[i] * conversion[i]) return max_profit"},{"question":"def max_water_trapped(heights): Calculate the maximum amount of water that can be trapped between the pillars. Parameters: heights (list): A list of non-negative integers representing the height of the pillars. Returns: int: The maximum amount of water that can be trapped. >>> max_water_trapped([]) == 0 >>> max_water_trapped([1]) == 0 >>> max_water_trapped([1, 2]) == 0 >>> max_water_trapped([2, 2, 2]) == 0 >>> max_water_trapped([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 >>> max_water_trapped([4, 2, 0, 3, 2, 5]) == 9","solution":"def max_water_trapped(heights): Calculate the maximum amount of water that can be trapped between the pillars. Parameters: heights (list): A list of non-negative integers representing the height of the pillars. Returns: int: The maximum amount of water that can be trapped. if not heights or len(heights) < 3: return 0 left = 0 right = len(heights) - 1 left_max = heights[left] right_max = heights[right] max_water = 0 while left < right: if heights[left] < heights[right]: left += 1 left_max = max(left_max, heights[left]) max_water += max(0, left_max - heights[left]) else: right -= 1 right_max = max(right_max, heights[right]) max_water += max(0, right_max - heights[right]) return max_water"},{"question":"def smallest_lexicographic_string(s: str) -> str: Determine the lexicographically smallest string that can be obtained through any number of valid transformations which involve moving any number of letters from the end of the string to the beginning. Parameters: s (str): Input string consisting of lowercase English letters. Returns: str: Lexicographically smallest string possible. >>> smallest_lexicographic_string(\\"a\\") 'a' >>> smallest_lexicographic_string(\\"z\\") 'z' >>> smallest_lexicographic_string(\\"abc\\") 'abc' >>> smallest_lexicographic_string(\\"bca\\") 'abc' >>> smallest_lexicographic_string(\\"cab\\") 'abc' >>> smallest_lexicographic_string(\\"abab\\") 'abab' >>> smallest_lexicographic_string(\\"zxyabc\\") 'abczxy' >>> smallest_lexicographic_string(\\"\\") ''","solution":"def smallest_lexicographic_string(s: str) -> str: Find the lexicographically smallest string by moving letters from the end to the beginning. Parameters: s (str): Input string consisting of lowercase English letters. Returns: str: Lexicographically smallest string possible. if not s: return \\"\\" smallest_string = s for i in range(1, len(s)): transformed = s[i:] + s[:i] if transformed < smallest_string: smallest_string = transformed return smallest_string"},{"question":"def remove_duplicates(nums: List[int]) -> int: Remove duplicates from a sorted list in place and return the new length of the array. :param nums: List[int] - List of sorted integers :return: int - New length of the array without duplicates >>> nums = [] >>> remove_duplicates(nums) 0 >>> nums == [] True >>> nums = [1, 2, 3, 4, 5] >>> remove_duplicates(nums) 5 >>> nums[:5] == [1, 2, 3, 4, 5] True >>> nums = [1, 1, 1, 1, 1] >>> remove_duplicates(nums) 1 >>> nums[:1] == [1] True >>> nums = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4] >>> remove_duplicates(nums) 5 >>> nums[:5] == [0, 1, 2, 3, 4] True >>> nums = [1, 2] >>> remove_duplicates(nums) 2 >>> nums[:2] == [1, 2] True >>> nums = [1, 1, 2, 2, 3, 4, 4, 5, 6, 6, 7] >>> remove_duplicates(nums) 7 >>> nums[:7] == [1, 2, 3, 4, 5, 6, 7] True","solution":"def remove_duplicates(nums): Remove duplicates in place and return the new length of the array. :param nums: List[int] - List of sorted integers :return: int - New length of the array without duplicates if not nums: return 0 # Initialize the index for the next unique element. unique_index = 0 for i in range(1, len(nums)): if nums[i] != nums[unique_index]: unique_index += 1 nums[unique_index] = nums[i] # The new length is the number of unique elements. return unique_index + 1"},{"question":"def longest_common_subsequence(a: str, b: str) -> int: Returns the length of the longest subsequence that is common to both strings a and b. >>> longest_common_subsequence(\\"abcde\\", \\"ace\\") 3 >>> longest_common_subsequence(\\"abc\\", \\"abc\\") 3 >>> longest_common_subsequence(\\"abc\\", \\"def\\") 0 >>> longest_common_subsequence(\\"abcdef\\", \\"af\\") 2 >>> longest_common_subsequence(\\"xmjyauz\\", \\"mzjawxu\\") 4 >>> longest_common_subsequence(\\"\\", \\"abc\\") 0 >>> longest_common_subsequence(\\"abc\\", \\"\\") 0 >>> longest_common_subsequence(\\"\\", \\"\\") 0 >>> longest_common_subsequence(\\"AGGTAB\\", \\"GXTXAYB\\") 4","solution":"def longest_common_subsequence(a, b): Returns the length of the longest common subsequence between strings a and b. m, n = len(a), len(b) # Create a DP table to store the lengths of longest common subsequence. dp = [[0] * (n + 1) for _ in range(m + 1)] # Build the dp table for i in range(1, m + 1): for j in range(1, n + 1): if a[i - 1] == b[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"def merge_sorted_arrays(arr1, arr2): Merge two sorted arrays into a new sorted array without using any pre-built sorting functions. :param arr1: List[int] - A sorted array of integers :param arr2: List[int] - A sorted array of integers :return: List[int] - A new sorted array containing all elements from arr1 and arr2 pass # Unit test cases def test_merge_same_size_arrays(): arr1 = [1, 3, 5] arr2 = [2, 4, 6] assert merge_sorted_arrays(arr1, arr2) == [1, 2, 3, 4, 5, 6] def test_merge_different_size_arrays(): arr1 = [1, 3, 5, 7] arr2 = [2, 4, 6] assert merge_sorted_arrays(arr1, arr2) == [1, 2, 3, 4, 5, 6, 7] def test_merge_with_empty_array(): arr1 = [] arr2 = [1, 2, 3] assert merge_sorted_arrays(arr1, arr2) == [1, 2, 3] assert merge_sorted_arrays(arr2, arr1) == [1, 2, 3] def test_merge_with_negative_numbers(): arr1 = [-3, -2, -1] arr2 = [-5, -4, 0, 1] assert merge_sorted_arrays(arr1, arr2) == [-5, -4, -3, -2, -1, 0, 1] def test_merge_with_duplicates(): arr1 = [1, 2, 2, 3] arr2 = [2, 3, 4] assert merge_sorted_arrays(arr1, arr2) == [1, 2, 2, 2, 3, 3, 4]","solution":"def merge_sorted_arrays(arr1, arr2): Merge two sorted arrays into a new sorted array. :param arr1: List[int] - A sorted array of integers :param arr2: List[int] - A sorted array of integers :return: List[int] - A new sorted array containing all elements from arr1 and arr2 merged_array = [] i = 0 j = 0 while i < len(arr1) and j < len(arr2): if arr1[i] < arr2[j]: merged_array.append(arr1[i]) i += 1 else: merged_array.append(arr2[j]) j += 1 while i < len(arr1): merged_array.append(arr1[i]) i += 1 while j < len(arr2): merged_array.append(arr2[j]) j += 1 return merged_array"},{"question":"def next_permutation(arr: List[int]) -> List[int]: Modify the array to its lexicographically next permutation. If no such permutation exists, rearrange it to the smallest possible order. >>> next_permutation([1, 2, 3]) == [1, 3, 2] >>> next_permutation([3, 2, 1]) == [1, 2, 3] >>> next_permutation([1, 1, 5]) == [1, 5, 1] >>> next_permutation([1, 3, 2]) == [2, 1, 3] >>> next_permutation([2, 3, 1]) == [3, 1, 2] >>> next_permutation([1]) == [1] >>> next_permutation([]) == [] >>> next_permutation([5, 4, 7, 5, 3, 2]) == [5, 5, 2, 3, 4, 7] >>> next_permutation([1, 5, 8, 4, 7, 6, 5, 3, 1]) == [1, 5, 8, 5, 1, 3, 4, 6, 7]","solution":"def next_permutation(arr): Modify the array to its lexicographically next permutation. If no such permutation exists, rearrange it to the smallest possible order. n = len(arr) if n <= 1: return arr # Find the largest index k such that arr[k] < arr[k + 1] k = n - 2 while k >= 0 and arr[k] >= arr[k + 1]: k -= 1 if k >= 0: # Find the largest index l greater than k such that arr[k] < arr[l] l = n - 1 while l > k and arr[k] >= arr[l]: l -= 1 # Swap the value of arr[k] with that of arr[l] arr[k], arr[l] = arr[l], arr[k] # Reverse the sequence from arr[k + 1] up to the last element arr[k + 1:] = reversed(arr[k + 1:]) return arr"},{"question":"def num_decodings(s: str) -> int: Given a string s containing only digits, return the number of ways to decode it. The decoding rules are: 1. '1' can be decoded as 'A', '2' as 'B', ..., '26' as 'Z'. 2. A two-digit number like '10' or '27' must be treated as a single character if it falls within the range from '10' to '26'. >>> num_decodings(\\"\\") 0 >>> num_decodings(\\"1\\") 1 >>> num_decodings(\\"0\\") 0 >>> num_decodings(\\"226\\") 3 >>> num_decodings(\\"1234\\") 3","solution":"def num_decodings(s: str) -> int: if not s: return 0 n = len(s) dp = [0] * (n + 1) dp[0] = 1 for i in range(1, n + 1): if s[i - 1] != '0': dp[i] += dp[i - 1] if i > 1 and \\"10\\" <= s[i - 2:i] <= \\"26\\": dp[i] += dp[i - 2] return dp[n]"},{"question":"def largest_connected_group(grid: List[List[int]]) -> int: Return the size of the largest connected group of 1's in the grid. >>> largest_connected_group([[1]]) 1 >>> largest_connected_group([[0]]) 0 >>> largest_connected_group([[1, 0, 0], [0, 1, 0], [0, 0, 1]]) 1 >>> largest_connected_group([[1, 1, 0], [1, 0, 0], [0, 0, 0]]) 3 >>> largest_connected_group([[1, 1, 0, 1], [1, 1, 0, 0], [0, 1, 1, 1], [1, 0, 1, 1]]) 9 >>> largest_connected_group([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) 9 >>> largest_connected_group([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0","solution":"def largest_connected_group(grid): Returns the size of the largest connected group of 1's in the grid. def dfs(x, y): # Base case: if we're out of range or the cell is not a 1, return 0 if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == 0: return 0 # Mark the cell as visited by setting it to 0 grid[x][y] = 0 # Initialize the size of this connected group to 1 (the current cell) size = 1 # Recursively visit all adjacent cells (up, down, left, right) size += dfs(x - 1, y) size += dfs(x + 1, y) size += dfs(x, y - 1) size += dfs(x, y + 1) return size max_size = 0 # Iterate over all cells in the grid for i in range(len(grid)): for j in range(len(grid[i])): # If we find a 1, perform a DFS to find the size of the connected group if grid[i][j] == 1: max_size = max(max_size, dfs(i, j)) return max_size"},{"question":"import heapq class MedianFinder: You have been given a collection of integers representing an initial array, and you need to process a series of operations on this array. The operations include adding an integer to the array and finding the median of the current array in constant time. Implement the \`MedianFinder\` class: * \`MedianFinder()\`: Initializes the \`MedianFinder\` object. * \`void addNum(int num)\`: Adds an integer \`num\` to the data structure. * \`double findMedian()\`: Returns the median of all integers added so far. If the number of elements is odd, return the middle element; otherwise, return the average of the two middle elements. def __init__(self): Initialize your data structure here. self.small = [] # Max-heap (as min-heap with negative values) self.large = [] # Min-heap def addNum(self, num: int) -> None: Adds an integer num to the data structure. pass def findMedian(self) -> float: Returns the median of all integers added so far. pass def test_median_initial(): mf = MedianFinder() mf.addNum(1) assert mf.findMedian() == 1.0 mf.addNum(2) assert mf.findMedian() == 1.5 mf.addNum(3) assert mf.findMedian() == 2.0 def test_median_even_elements(): mf = MedianFinder() for num in [1, 2, 3, 4]: mf.addNum(num) assert mf.findMedian() == 2.5 def test_median_odd_elements(): mf = MedianFinder() for num in [5, 2, 8, 1, 3]: mf.addNum(num) # Sorted order: [1, 2, 3, 5, 8] assert mf.findMedian() == 3.0 def test_large_numbers(): mf = MedianFinder() for num in [10**6, 10**7, 10**8]: mf.addNum(num) assert mf.findMedian() == 10**7 def test_negative_numbers(): mf = MedianFinder() for num in [-3, -1, -2, -4, 0]: mf.addNum(num) # Sorted order: [-4, -3, -2, -1, 0] assert mf.findMedian() == -2.0 def test_mixed_numbers(): mf = MedianFinder() for num in [3, -1, 2, -4, 5]: mf.addNum(num) # Sorted order: [-4, -1, 2, 3, 5] assert mf.findMedian() == 2.0 def test_single_element(): mf = MedianFinder() mf.addNum(42) assert mf.findMedian() == 42.0","solution":"import heapq class MedianFinder: def __init__(self): Initialize your data structure here. self.small = [] # Max-heap (as min-heap with negative values) self.large = [] # Min-heap def addNum(self, num: int) -> None: if not self.large or num >= self.large[0]: heapq.heappush(self.large, num) else: heapq.heappush(self.small, -num) # Balance heaps if len(self.large) > len(self.small) + 1: heapq.heappush(self.small, -heapq.heappop(self.large)) elif len(self.small) > len(self.large): heapq.heappush(self.large, -heapq.heappop(self.small)) def findMedian(self) -> float: if len(self.large) > len(self.small): return float(self.large[0]) else: return (self.large[0] - self.small[0]) / 2.0"},{"question":"def max_first_element(arr): Given an array of integers \`arr\`, returns the maximum possible value of the array's first element after any number of right rotations. :param arr: List of integers :return: Maximum possible value of the array's first element pass # Unit Test def test_single_element(): assert max_first_element([1]) == 1 def test_all_positive_numbers(): assert max_first_element([5, 3, 1, 2, 4]) == 5 def test_all_negative_numbers(): assert max_first_element([-10, -20, -30]) == -10 def test_mixed_numbers(): assert max_first_element([-1, 7, 3, 5, -10]) == 7 def test_same_elements(): assert max_first_element([4, 4, 4, 4]) == 4 def test_large_numbers(): assert max_first_element([1000000, 2000000, 3000000, 4000000]) == 4000000","solution":"def max_first_element(arr): Returns the maximum possible value of the array's first element after any number of right rotations. :param arr: List of integers :return: Maximum possible value of the array's first element return max(arr)"},{"question":"def num_islands(board: List[List[int]]) -> int: Returns the number of islands in the given grid. >>> num_islands([]) == 0 >>> grid1 = [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0]] >>> num_islands(grid1) == 0 >>> grid2 = [ ... [1, 1, 0], ... [0, 1, 0], ... [0, 0, 0]] >>> num_islands(grid2) == 1 >>> grid3 = [ ... [1, 0, 1, 0], ... [0, 1, 0, 0], ... [1, 0, 0, 1], ... [0, 0, 1, 1]] >>> num_islands(grid3) == 5 >>> grid4 = [ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1]] >>> num_islands(grid4) == 1 >>> grid5 = [ ... [1, 0, 0], ... [0, 1, 0], ... [0, 0, 1]] >>> num_islands(grid5) == 3","solution":"def num_islands(board): Returns the number of islands in the given grid. if not board: return 0 def dfs(board, i, j): if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] == 0: return board[i][j] = 0 # Mark the cell as visited # Explore neighbors dfs(board, i - 1, j) dfs(board, i + 1, j) dfs(board, i, j - 1) dfs(board, i, j + 1) count = 0 for i in range(len(board)): for j in range(len(board[0])): if board[i][j] == 1: count += 1 dfs(board, i, j) return count"},{"question":"def single_number(nums: List[int]) -> int: Finds the single number that appears only once in the list where every other number appears exactly three times. >>> single_number([2, 2, 3, 2]) 3 >>> single_number([0, 1, 0, 1, 0, 1, 99]) 99 >>> single_number([-2, -2, 1, -2]) 1 >>> single_number([5, 5, 5, 7]) 7 >>> single_number([10] * 3000 + [1] * 3000 + [100] * 3000 + [-50, -50, -50] + [999]) 999 >>> single_number([-3, -3, -3, -99]) -99","solution":"def single_number(nums): Finds the single number that appears only once in the list where every other number appears exactly three times. ones, twos = 0, 0 for num in nums: ones = (ones ^ num) & ~twos twos = (twos ^ num) & ~ones return ones"},{"question":"def min_eating_speed(piles: List[int], H: int) -> int: Returns the minimum integer K such that it is possible to eat all the stones in the piles within H hours. Parameters: piles (List[int]): Array of integers where piles[i] is the number of stones in the i-th pile. H (int): Represents the number of hours you have to finish eating all the stones. Returns: int: The minimum integer K denoting the eating speed. >>> min_eating_speed([3, 6, 7, 11], 8) 4 >>> min_eating_speed([30, 11, 23, 4, 20], 5) 30 >>> min_eating_speed([1, 1, 1, 1, 1], 5) 1","solution":"def can_finish(piles, H, K): Helper function to determine if we can finish eating all piles with speed K in H hours. time = 0 for pile in piles: time += (pile + K - 1) // K # Equivalent to ceil(pile / K) return time <= H def min_eating_speed(piles, H): Returns the minimum integer K such that it is possible to eat all the stones in the piles within H hours. left, right = 1, max(piles) while left < right: mid = (left + right) // 2 if can_finish(piles, H, mid): right = mid else: left = mid + 1 return left"},{"question":"def length_of_longest_subarray(nums: List[int]) -> int: Returns the length of the longest subarray without repeating elements. >>> length_of_longest_subarray([]) == 0 >>> length_of_longest_subarray([1, 2, 3, 4, 5]) == 5 >>> length_of_longest_subarray([1, 1, 1, 1, 1]) == 1 >>> length_of_longest_subarray([1, 2, 3, 1, 2, 3, 4, 5]) == 5 >>> length_of_longest_subarray([1, 2, 2, 3, 4, 4, 5]) == 3","solution":"def length_of_longest_subarray(nums): Returns the length of the longest subarray without repeating elements. n = len(nums) if n == 0: return 0 longest = 0 start = 0 seen = {} for end in range(n): if nums[end] in seen and seen[nums[end]] >= start: start = seen[nums[end]] + 1 seen[nums[end]] = end longest = max(longest, end - start + 1) return longest"},{"question":"def rotate_array(arr: List[int], k: int) -> None: Rotates the array to the right by k steps in-place with O(1) extra space complexity. :param arr: List[int] - The array to be rotated :param k: int - The number of steps to rotate the array >>> arr = [1, 2, 3, 4, 5, 6, 7] >>> rotate_array(arr, 3) >>> arr == [5, 6, 7, 1, 2, 3, 4] >>> arr = [1, 2, 3, 4, 5, 6, 7] >>> rotate_array(arr, 0) >>> arr == [1, 2, 3, 4, 5, 6, 7] >>> arr = [1] >>> rotate_array(arr, 3) >>> arr == [1] >>> arr = [-1, -100, 3, 99] >>> rotate_array(arr, 2) >>> arr == [3, 99, -1, -100]","solution":"def rotate_array(arr, k): Rotates the array to the right by k steps. :param arr: List[int] - The array to be rotated :param k: int - The number of steps to rotate the array n = len(arr) k %= n # in case k is greater than the length of the array # Reverse the whole array arr.reverse() # Reverse the first k elements arr[:k] = arr[:k][::-1] # Reverse the remaining n - k elements arr[k:] = arr[k:][::-1]"},{"question":"def total_submerged_height(height: List[int], waterLevel: int) -> int: Returns the total submerged height of all the buildings given the height array and the water level. >>> total_submerged_height([4, 5, 7, 3], 5) 17 >>> total_submerged_height([1, 2, 3], 5) 6 >>> total_submerged_height([6, 7, 8], 5) 15 >>> total_submerged_height([5, 5, 5], 5) 15 >>> total_submerged_height([2, 8, 5, 3, 6], 5) 20 >>> total_submerged_height([], 5) 0 pass","solution":"def total_submerged_height(height, waterLevel): Returns the total submerged height of all the buildings given the height array and the water level. Parameters: height (list of int): List of building heights. waterLevel (int): The level of the water. Returns: int: The total submerged height. submerged_height_total = 0 for h in height: submerged_height_total += min(h, waterLevel) return submerged_height_total"},{"question":"import heapq from typing import List def minimumEffortPath(matrix: List[List[int]]) -> int: Returns the minimum effort required to move from the top-left to the bottom-right corner of the matrix. >>> minimumEffortPath([ [1, 2, 2], [3, 8, 2], [5, 3, 5] ]) 2 >>> minimumEffortPath([ [1, 2, 1], [2, 3, 2], [3, 4, 3] ]) 1 >>> minimumEffortPath([[0]]) 0 >>> minimumEffortPath([ [1000000, 1000000], [1000000, 0] ]) 1000000 >>> minimumEffortPath([ [1, 2, 2, 1], [2, 3, 3, 2], [3, 3, 3, 3], [4, 4, 4, 4] ]) 1","solution":"import heapq def minimumEffortPath(matrix): Returns the minimum effort required to move from the top-left to the bottom-right corner of the matrix. m, n = len(matrix), len(matrix[0]) visited = [[False] * n for _ in range(m)] efforts = [[float('inf')] * n for _ in range(m)] efforts[0][0] = 0 # Min-Heap to store (effort, row, column) heap = [(0, 0, 0)] # (effort, row, column) directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] while heap: effort, r, c = heapq.heappop(heap) if visited[r][c]: continue visited[r][c] = True if r == m - 1 and c == n - 1: return effort for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < m and 0 <= nc < n and not visited[nr][nc]: next_effort = max(effort, abs(matrix[nr][nc] - matrix[r][c])) if next_effort < efforts[nr][nc]: efforts[nr][nc] = next_effort heapq.heappush(heap, (next_effort, nr, nc)) return -1 # If no path is found, which won't happen as stated in the question"},{"question":"def deleteAndEarn(nums): Returns the maximum number of points that can be earned by performing tasks under the given constraints. >>> deleteAndEarn([3, 4, 2]) 6 >>> deleteAndEarn([10]) 10 >>> deleteAndEarn([]) 0 >>> deleteAndEarn([1, 2, 3]) 4 >>> deleteAndEarn([1, 1, 1, 2, 4, 5, 5, 5, 6]) 18 >>> deleteAndEarn([3, 3, 3, 3, 3]) 15 >>> deleteAndEarn([2, 2, 3, 3, 4, 4]) 12","solution":"def deleteAndEarn(nums): Returns the maximum number of points that can be earned by performing tasks under the given constraints. if not nums: return 0 max_num = max(nums) points = [0] * (max_num + 1) # Calculate the total number of points for each number in nums for num in nums: points[num] += num take, skip = 0, 0 for point in points: take_new = skip + point skip_new = max(take, skip) take, skip = take_new, skip_new return max(take, skip)"},{"question":"import random import bisect class Solution: def __init__(self, w): Initialize the solution with the weight array. :param w: List[int] - a list of integers where w[i] describes the weight of the i-th index pass def pickIndex(self): Randomly picks an index in proportion to its weight and returns the index. :return: int - the picked index pass def test_pickIndex_single_element(): sol = Solution([10]) results = [sol.pickIndex() for _ in range(100)] assert all(index == 0 for index in results), \\"All indexes should be 0 for single element weight\\" def test_pickIndex_even_distribution(): sol = Solution([1, 1, 1, 1]) results = [sol.pickIndex() for _ in range(1000)] counts = [results.count(i) for i in range(4)] assert all(200 <= count <= 300 for count in counts), \\"Each index should be picked approximately the same number of times\\" def test_pickIndex_uneven_distribution(): sol = Solution([1, 3]) results = [sol.pickIndex() for _ in range(1000)] count_index_0 = results.count(0) count_index_1 = results.count(1) assert 180 <= count_index_0 <= 300, \\"Index 0 should be picked about 1/4th of the times\\" assert 700 <= count_index_1 <= 870, \\"Index 1 should be picked about 3/4th of the times\\" def test_pickIndex_large_weights(): sol = Solution([1, 999]) results = [sol.pickIndex() for _ in range(1000)] count_index_0 = results.count(0) count_index_1 = results.count(1) assert 0 <= count_index_0 <= 30, \\"Index 0 should be picked about 1/1000th of the times\\" assert 970 <= count_index_1 <= 1000, \\"Index 1 should be picked about 999/1000th of the times\\"","solution":"import random import bisect class Solution: def __init__(self, w): self.prefix_sums = [] total = 0 for weight in w: total += weight self.prefix_sums.append(total) self.total_sum = total def pickIndex(self): target = self.total_sum * random.random() # Find the index using binary search return bisect.bisect_left(self.prefix_sums, target)"},{"question":"def merge(nums1: List[int], m: int, nums2: List[int], n: int) -> None: Merges two sorted arrays nums1 and nums2 in-place. The first m elements of nums1 contain the elements to be merged, and the last n elements of nums1 are set to 0 and should be ignored. nums2 contains n elements to be merged. >>> nums1 = [1, 2, 3, 0, 0, 0] >>> nums2 = [2, 5, 6] >>> merge(nums1, 3, nums2, 3) >>> nums1 [1, 2, 2, 3, 5, 6] >>> nums1 = [] >>> nums2 = [] >>> merge(nums1, 0, nums2, 0) >>> nums1 [] >>> nums1 = [1, 2, 3] >>> nums2 = [] >>> merge(nums1, 3, nums2, 0) >>> nums1 [1, 2, 3] >>> nums1 = [0, 0, 0] >>> nums2 = [2, 5, 6] >>> merge(nums1, 0, nums2, 3) >>>>>>>>> NUMBERS #n\\") test_example_case() test_both_empty_arrays() test_empty_nums2() test_empty_nums1() test_nums1_with_trailing_zeros() test_all_elements_equal() if __name__ == \\"__main__\\": run_tests()","solution":"def merge(nums1, m, nums2, n): Merges two sorted arrays nums1 and nums2 in-place. The first m elements of nums1 contain the elements to be merged, and the last n elements of nums1 are set to 0 and should be ignored. nums2 contains n elements to be merged. # Indexes for the last elements in nums1 and nums2 index1, index2 = m - 1, n - 1 # Index for the last position in the merged array merge_index = m + n - 1 while index2 >= 0: if index1 >= 0 and nums1[index1] > nums2[index2]: nums1[merge_index] = nums1[index1] index1 -= 1 else: nums1[merge_index] = nums2[index2] index2 -= 1 merge_index -= 1"},{"question":"def min_subarray_len(arr: List[int], k: int) -> int: Given an array \`arr\` consisting of \`n\` integers, and an integer \`k\`, find the minimal length of a contiguous subarray of which the sum is greater than or equal to \`k\`. If there is no such subarray, return \`-1\`. >>> min_subarray_len([2, 3, 1, 2, 4, 3], 7) 2 >>> min_subarray_len([1, 4, 4], 4) 1 >>> min_subarray_len([1, 1, 1, 1, 7], 7) 1 >>> min_subarray_len([1, 1, 1, 1, 1], 6) -1 >>> min_subarray_len([1, 2, 3, 4], 10) 4 >>> min_subarray_len([1, 2, 3, 4, 1, 1, 1, 1], 8) 3 >>> min_subarray_len([10], 5) 1 >>> min_subarray_len([5], 5) 1 >>> min_subarray_len([4], 5) -1","solution":"def min_subarray_len(arr, k): Returns the minimal length of a contiguous subarray with a sum >= k. If no such subarray exists, returns -1. n = len(arr) min_len = float('inf') current_sum = 0 start_index = 0 for end_index in range(n): current_sum += arr[end_index] while current_sum >= k: min_len = min(min_len, end_index - start_index + 1) current_sum -= arr[start_index] start_index += 1 return min_len if min_len != float('inf') else -1"},{"question":"def count_even_sum_pairs(arr): Returns the number of distinct pairs (i, j) such that arr[i] + arr[j] is even and 0 <= i < j < arr.length. >>> count_even_sum_pairs([1, 3, 5, 7]) 6 >>> count_even_sum_pairs([2, 4, 6, 8]) 6 >>> count_even_sum_pairs([1, 2, 3, 4, 5]) 4 >>> count_even_sum_pairs([1]) 0 >>> count_even_sum_pairs([2]) 0 >>> count_even_sum_pairs([]) 0","solution":"def count_even_sum_pairs(arr): Returns the number of distinct pairs (i, j) such that arr[i] + arr[j] is even and 0 <= i < j < arr.length. Parameters: arr (list of int): A list of integers. Returns: int: The number of pairs with an even sum. odd_count = sum(1 for x in arr if x % 2 != 0) even_count = len(arr) - odd_count # Pairs of even sum can be formed by: # 1. Two odd numbers # 2. Two even numbers def combination_count(n): return n * (n - 1) // 2 pairs = combination_count(odd_count) + combination_count(even_count) return pairs"},{"question":"def count_valid_parentheses(n: int) -> int: Given an integer \`n\`, find the total number of valid parentheses arrangements that can be made using \`n\` pairs of parentheses. >>> count_valid_parentheses(0) 1 >>> count_valid_parentheses(1) 1 >>> count_valid_parentheses(2) 2 >>> count_valid_parentheses(3) 5 >>> count_valid_parentheses(4) 14 >>> count_valid_parentheses(5) 42","solution":"def count_valid_parentheses(n): Returns the number of valid parentheses arrangements using n pairs of parentheses. This is essentially the nth Catalan number. if n == 0: return 1 catalan = [0] * (n + 1) catalan[0] = 1 for i in range(1, n + 1): catalan_i = 0 for j in range(i): catalan_i += catalan[j] * catalan[i - 1 - j] catalan[i] = catalan_i return catalan[n]"},{"question":"from typing import List def findSubstring(s: str, words: List[str]) -> List[int]: Find the starting indices of all concatenated substrings in s that are formed by combining each word in words exactly once and in any order. pass # Unit tests def test_findSubstring_example_1(): s = \\"barfoothefoobarman\\" words = [\\"foo\\", \\"bar\\"] assert findSubstring(s, words) == [0, 9] def test_findSubstring_example_2(): s = \\"wordgoodgoodgoodbestword\\" words = [\\"word\\", \\"good\\", \\"best\\", \\"word\\"] assert findSubstring(s, words) == [] def test_findSubstring_example_3(): s = \\"barfoofoobarthefoobarman\\" words = [\\"bar\\", \\"foo\\", \\"the\\"] assert findSubstring(s, words) == [6, 9, 12] def test_findSubstring_example_4(): s = \\"wordgoodgoodgoodbestword\\" words = [\\"word\\",\\"good\\",\\"best\\",\\"good\\"] assert findSubstring(s, words) == [8] def test_findSubstring_no_match(): s = \\"abcdefghij\\" words = [\\"klm\\", \\"nop\\"] assert findSubstring(s, words) == [] def test_findSubstring_empty_string(): s = \\"\\" words = [\\"abc\\", \\"def\\"] assert findSubstring(s, words) == [] def test_findSubstring_empty_words(): s = \\"beyond\\" words = [] assert findSubstring(s, words) == [] if __name__ == \\"__main__\\": test_findSubstring_example_1() test_findSubstring_example_2() test_findSubstring_example_3() test_findSubstring_example_4() test_findSubstring_no_match() test_findSubstring_empty_string() test_findSubstring_empty_words()","solution":"def findSubstring(s, words): Find the starting indices of all concatenated substrings in s that are formed by combining each word in words exactly once in any order. if not s or not words or not words[0]: return [] word_length = len(words[0]) num_words = len(words) total_length = word_length * num_words word_count = {} for word in words: if word in word_count: word_count[word] += 1 else: word_count[word] = 1 result = [] for i in range(word_length): left = i right = i current_count = {} while right + word_length <= len(s): word = s[right:right + word_length] right += word_length if word in word_count: if word in current_count: current_count[word] += 1 else: current_count[word] = 1 while current_count[word] > word_count[word]: left_word = s[left:left + word_length] current_count[left_word] -= 1 left += word_length if right - left == total_length: result.append(left) else: current_count.clear() left = right return sorted(result)"},{"question":"def encode_string(s: str) -> str: Encodes the string using the format number[character] for consecutive character groups. :param s: string input containing lowercase English letters :return: encoded string >>> encode_string(\\"aaabbbbcc\\") \\"3[a]4[b]2[c]\\" >>> encode_string(\\"aabcc\\") \\"2[a]b2[c]\\" >>> encode_string(\\"aabbcc\\") \\"2[a]2[b]2[c]\\" >>> encode_string(\\"abc\\") \\"abc\\"","solution":"def encode_string(s): Encodes the string using the format number[character] for consecutive character groups. :param s: string input containing lowercase English letters :return: encoded string if not s: return \\"\\" encoded_string = \\"\\" count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: if count > 1: encoded_string += f\\"{count}[{s[i - 1]}]\\" else: encoded_string += s[i - 1] count = 1 # Handle the last group if count > 1: encoded_string += f\\"{count}[{s[-1]}]\\" else: encoded_string += s[-1] return encoded_string"},{"question":"def min_abs_split_diff(arr: List[int]) -> int: Splits the array into two non-empty subarrays such that the absolute difference between the sums of the two subarrays is minimized. Returns the minimum absolute difference. >>> min_abs_split_diff([1, 2, 3, 4]) 2 >>> min_abs_split_diff([10, 5]) 5 >>> min_abs_split_diff([100, 200, 300, 400]) 200 >>> min_abs_split_diff([3, 3, 3, 3]) 0 >>> min_abs_split_diff([-1, -2, -3, -4]) 2 >>> min_abs_split_diff([-1, 2, -3, 4]) 0 pass","solution":"def min_abs_split_diff(arr): Splits the array into two non-empty subarrays such that the absolute difference between the sums of the two subarrays is minimized. Returns the minimum absolute difference. total_sum = sum(arr) n = len(arr) # To minimize the difference, we need to find a split that makes # one part sum close to half of the total sum. min_diff = float('inf') current_sum = 0 for i in range(n - 1): current_sum += arr[i] remaining_sum = total_sum - current_sum diff = abs(current_sum - remaining_sum) min_diff = min(min_diff, diff) return min_diff"},{"question":"def shortest_path(matrix, start, end): Find the shortest path between two cells in a matrix where some cells are blocked. :param matrix: List of lists representing the matrix :param start: Tuple representing the starting cell (row, col) :param end: Tuple representing the ending cell (row, col) :return: Length of the shortest path or -1 if no such path exists >>> matrix = [ ... [0, 0, 0], ... [0, -1, 0], ... [0, 0, 0] ... ] >>> shortest_path(matrix, (0, 0), (2, 2)) 4 >>> shortest_path(matrix, (0, 0), (1, 1)) -1 >>> matrix = [ ... [0, -1, 0], ... [0, -1, 0], ... [0, -1, 0] ... ] >>> shortest_path(matrix, (0, 0), (2, 2)) -1 >>> shortest_path(matrix, (0, 0), (0, 0)) 0 >>> matrix = [ ... [0, 0, -1, 0], ... [-1, 0, -1, 0], ... [0, 0, 0, 0], ... [0, -1, -1, 0] ... ] >>> shortest_path(matrix, (0, 0), (3, 3)) 6","solution":"from collections import deque def shortest_path(matrix, start, end): Find the shortest path between two cells in a matrix where some cells are blocked. :param matrix: List of lists representing the matrix :param start: Tuple representing the starting cell (row, col) :param end: Tuple representing the ending cell (row, col) :return: Length of the shortest path or -1 if no such path exists n = len(matrix) if matrix[start[0]][start[1]] == -1 or matrix[end[0]][end[1]] == -1: return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(start[0], start[1], 0)]) visited = set() visited.add(start) while queue: r, c, dist = queue.popleft() if (r, c) == end: return dist for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < n and 0 <= nc < n and (nr, nc) not in visited and matrix[nr][nc] != -1: queue.append((nr, nc, dist + 1)) visited.add((nr, nc)) return -1"},{"question":"def shortest_subarray_with_target_sum(arr: List[int], target: int) -> int: Given an array of integers \`arr\`, find and return the length of the shortest subarray with a sum equal to \`target\`. If there is no such subarray, return -1. >>> shortest_subarray_with_target_sum([1, 2, 3, 4, 1, 2, 3, 7], 7) == 1 >>> shortest_subarray_with_target_sum([1, 2, 3, 4, 1, 2, 3, 7], 8) == 3 >>> shortest_subarray_with_target_sum([1, 1, 1, 1], 6) == -1 >>> shortest_subarray_with_target_sum([1, 2, 3, 4, 5], 5) == 1 >>> shortest_subarray_with_target_sum([3, 1, 7, 1, 1, 1, 1, 1], 8) == 2 >>> shortest_subarray_with_target_sum([7], 7) == 1 >>> shortest_subarray_with_target_sum([5], 7) == -1 >>> shortest_subarray_with_target_sum([], 7) == -1 >>> shortest_subarray_with_target_sum([-1, -2, 3, 5, 1, -1], 3) == 1 >>> shortest_subarray_with_target_sum([-1, 2, -3, 4, -2], 1) == 2 pass","solution":"def shortest_subarray_with_target_sum(arr, target): from collections import defaultdict n = len(arr) min_length = float('inf') current_sum = 0 prefix_sum = defaultdict(lambda: float('inf')) prefix_sum[0] = -1 for i in range(n): current_sum += arr[i] if (current_sum - target) in prefix_sum: min_length = min(min_length, i - prefix_sum[current_sum - target]) if current_sum not in prefix_sum: prefix_sum[current_sum] = i return min_length if min_length != float('inf') else -1"},{"question":"def min_bonuses(scores: List[int]) -> int: Calculate the minimum number of bonus points the company must distribute based on performance evaluations. >>> min_bonuses([1, 2, 2]) 4 >>> min_bonuses([1, 3, 2, 2, 1]) 7","solution":"def min_bonuses(scores): n = len(scores) if n == 0: return 0 if n == 1: return 1 bonuses = [1] * n # First pass: ensure each employee has more bonuses than previous if their score is higher for i in range(1, n): if scores[i] > scores[i - 1]: bonuses[i] = bonuses[i - 1] + 1 # Second pass: ensure each employee has more bonuses than next if their score is higher for i in range(n - 2, -1, -1): if scores[i] > scores[i + 1]: bonuses[i] = max(bonuses[i], bonuses[i + 1] + 1) return sum(bonuses)"},{"question":"def longest_contiguous_subsequence_length(arr): Returns the length of the longest contiguous subsequence such that all elements in the subsequence are the same. Parameters: arr (list): A non-empty list of integers Returns: int: The length of the longest contiguous subsequence >>> longest_contiguous_subsequence_length([7]) 1 >>> longest_contiguous_subsequence_length([2, 2, 2, 2, 2]) 5 >>> longest_contiguous_subsequence_length([1, 2, 3, 4, 5]) 1 >>> longest_contiguous_subsequence_length([1, 2, 2, 2, 3, 3, 4]) 3 >>> longest_contiguous_subsequence_length([5, 5, 3, 3, 3, 4, 4, 4, 4]) 4 >>> longest_contiguous_subsequence_length([]) 0","solution":"def longest_contiguous_subsequence_length(arr): Returns the length of the longest contiguous subsequence such that all elements in the subsequence are the same. Parameters: arr (list): A non-empty list of integers Returns: int: The length of the longest contiguous subsequence if not arr: return 0 max_length = 1 current_length = 1 for i in range(1, len(arr)): if arr[i] == arr[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"def suggested_products(products: List[str], searchWord: str) -> List[List[str]]: Given a list of strings products and a string searchWord, return a list of lists of strings, where each sublist corresponds to the products in products that start with the prefix formed by progressively adding each character from searchWord. The products in each sublist should be sorted lexicographically and only the top 3 results should be included. If fewer than 3 products exist, include all of them. Return an empty sublist if no products exist for the given prefix. >>> suggested_products([\\"mobile\\", \\"mouse\\", \\"moneypot\\", \\"monitor\\", \\"mousepad\\"], \\"mouse\\") [[\\"mobile\\", \\"moneypot\\", \\"monitor\\"], [\\"mobile\\", \\"moneypot\\", \\"monitor\\"], [\\"mouse\\", \\"mousepad\\"], [\\"mouse\\", \\"mousepad\\"], [\\"mouse\\", \\"mousepad\\"]] >>> suggested_products([\\"apple\\", \\"banana\\", \\"cherry\\"], \\"z\\") [[]] >>> suggested_products([\\"apple\\", \\"banana\\", \\"appetizer\\", \\"app\\"], \\"app\\") [[\\"name\\"]] == [\\"{}\\"], [[\\"name\\"]] == DBAPI2.Cursor.description.<locals>.Column(\\"{}\\".format(Param(sparameter)))]], [ ], [ newtype(Param\\"No\\", [List[str]])), List[s]): pass return result","solution":"def suggested_products(products, searchWord): Given a list of strings products and a string searchWord, return a list of lists of strings, where each sublist corresponds to the products in products that start with the prefix formed by progressively adding each character from searchWord. products.sort() result = [] prefix = \\"\\" for char in searchWord: prefix += char matching_products = [product for product in products if product.startswith(prefix)] result.append(matching_products[:3]) return result"},{"question":"def min_steps_maze(grid) -> int: Determine the minimum number of steps required to move from 'S' to 'E' in a 2D grid maze. Args: grid (List[List[str]]): 2D grid of characters representing the maze. Returns: int: Minimum number of steps required to move from 'S' to 'E', or -1 if no valid path exists. >>> grid = [ ... ['S', '.', '.', '.', 'E'], ... ['#', '#', '#', '#', '#'], ... ['.', '.', '.', '.', '.'] ... ] >>> min_steps_maze(grid) 4 >>> grid = [ ... ['S', '#', '#', '#', 'E'], ... ['#', '#', '#', '#', '#'], ... ['.', '.', '.', '.', '.'] ... ] >>> min_steps_maze(grid) -1 >>> grid = [ ... ['S', '.', '#', '.', 'E'], ... ['#', '.', '#', '.', '#'], ... ['.', '.', '.', '.', '#'], ... ] >>> min_steps_maze(grid) 8","solution":"from collections import deque def min_steps_maze(grid): rows = len(grid) cols = len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Find starting point 'S' and end point 'E' for r in range(rows): for c in range(cols): if grid[r][c] == 'S': start = (r, c) if grid[r][c] == 'E': end = (r, c) # Set up the queue for BFS queue = deque([(start[0], start[1], 0)]) # (row, col, distance) visited = set() visited.add(start) while queue: r, c, dist = queue.popleft() if (r, c) == end: return dist for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] != '#' and (nr, nc) not in visited: visited.add((nr, nc)) queue.append((nr, nc, dist + 1)) return -1"},{"question":"def can_form_string(words: List[str], target_str: str) -> bool: Determines if the target_str can be formed by concatenating some of the strings (possibly repeated) from the array words. >>> can_form_string([\\"a\\"], \\"aaaa\\") True >>> can_form_string([\\"ab\\", \\"c\\"], \\"abcc\\") True >>> can_form_string([\\"a\\", \\"b\\", \\"c\\"], \\"abcd\\") False >>> can_form_string([\\"a\\", \\"b\\"], \\"\\") True >>> can_form_string([], \\"abc\\") False >>> can_form_string([\\"abc\\"], \\"abc\\") True >>> can_form_string([\\"ab\\", \\"abab\\"], \\"abababab\\") True >>> can_form_string([\\"ab\\", \\"bc\\"], \\"abbcabbc\\") True","solution":"def can_form_string(words, target_str): Determines if the target_str can be formed by concatenating some of the strings (possibly repeated) from the array words. :param words: List of strings. :param target_str: The target string. :return: Boolean indicating whether the target_str can be formed. str_length = len(target_str) dp = [False] * (str_length + 1) dp[0] = True for i in range(1, str_length + 1): for word in words: word_len = len(word) if i >= word_len and target_str[i - word_len:i] == word: dp[i] = dp[i] or dp[i - word_len] return dp[str_length]"},{"question":"def matches_pattern(pattern: str, inputStr: str) -> bool: Determine if inputStr matches the pattern where each question mark in the pattern can be replaced by any single lowercase letter. >>> matches_pattern(\\"abc\\", \\"abc\\") True >>> matches_pattern(\\"a?c\\", \\"abc\\") True >>> matches_pattern(\\"a?c\\", \\"axc\\") True >>> matches_pattern(\\"a?c\\", \\"abcd\\") False >>> matches_pattern(\\"a?cde\\", \\"abc\\") False >>> matches_pattern(\\"a?c\\", \\"abx\\") False >>> matches_pattern(\\"??c\\", \\"xxd\\") False >>> matches_pattern(\\"???\\", \\"abc\\") True >>> matches_pattern(\\"????\\", \\"abcd\\") True >>> matches_pattern(\\"???\\", \\"abcd\\") False","solution":"def matches_pattern(pattern, inputStr): Returns True if the inputStr matches the pattern, False otherwise. if len(pattern) != len(inputStr): return False for p_char, i_char in zip(pattern, inputStr): if p_char != '?' and p_char != i_char: return False return True"},{"question":"from typing import List def min_moves(grid: List[List[int]]) -> int: Given a square grid of size n, find the minimum number of moves required to reach the cell (n-1, n-1) from the cell (0, 0), or return -1 if there is no viable path. >>> grid = [ ... [1, 2, 3], ... [6, 5, 4], ... [7, 8, 9] ... ] >>> min_moves(grid) 4 >>> grid = [ ... [1, 2, 3], ... [6, 5, 4], ... [7, 8, 1] ... ] >>> min_moves(grid) -1 >>> grid = [ ... [1] ... ] >>> min_moves(grid) 0 >>> grid = [ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ] >>> min_moves(grid) 4 >>> grid = [ ... [1, 2, 3], ... [1, 1, 4], ... [1, 1, 5] ... ] >>> min_moves(grid) 4 >>> grid = [ ... [1, 3, 5, 7], ... [0, 2, 4, 8], ... [1, 3, 5, 6], ... [0, 2, 4, 8] ... ] >>> min_moves(grid) -1","solution":"from collections import deque def min_moves(grid): n = len(grid) # Directions for moving up, down, left, and right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # BFS initialization queue = deque([(0, 0, 0)]) # (row, column, moves) visited = set((0, 0)) while queue: x, y, moves = queue.popleft() # Check if we have reached the bottom-right corner if x == n - 1 and y == n - 1: return moves # Explore adjacent cells for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] >= grid[x][y]: visited.add((nx, ny)) queue.append((nx, ny, moves + 1)) # If there's no viable path return -1"},{"question":"from typing import List, Tuple def partition_labels(s: str) -> List[Tuple[int, int]]: Return the starting and ending indices of the smallest number of non-overlapping substrings such that each letter appears in at most one substring. >>> partition_labels(\\"ababcbacadefegdehijhklij\\") [(0, 8), (9, 15), (16, 23)] >>> partition_labels(\\"abcdef\\") [(0, 0), (1, 1), (2, 2), (3, 3), (4, 4), (5, 5)] >>> partition_labels(\\"a\\") [(0, 0)] >>> partition_labels(\\"aaaaa\\") [(0, 4)] >>> partition_labels(\\"eccbbbbdec\\") [(0, 9)]","solution":"def partition_labels(s): Return the starting and ending indices of the smallest number of non-overlapping substrings such that each letter appears in at most one substring. if not s: return [] last_occurrence = {char: idx for idx, char in enumerate(s)} partitions = [] start, end = 0, 0 for idx, char in enumerate(s): end = max(end, last_occurrence[char]) if idx == end: partitions.append((start, end)) start = idx + 1 return partitions"},{"question":"def max_consecutive_buildings(heights: list[int]) -> int: Returns the maximum number of consecutive buildings the ball can travel when dropped from any building. :param heights: List[int], the heights of buildings in a row. :return: int, the maximum number of consecutive buildings the ball can travel. >>> max_consecutive_buildings([5]) 1 >>> max_consecutive_buildings([1, 2, 3, 4, 5]) 1 >>> max_consecutive_buildings([5, 4, 3, 2, 1]) 5 >>> max_consecutive_buildings([3, 3, 3, 3]) 4 >>> max_consecutive_buildings([5, 1, 2, 3, 4]) 2 >>> max_consecutive_buildings([1, 3, 2, 4, 2]) 2 >>> max_consecutive_buildings([10, 5, 5, 2, 3, 3]) 4 >>> max_consecutive_buildings([9, 6, 6, 3, 4, 1, 1, 1, 5, 6]) 4","solution":"def max_consecutive_buildings(heights): Returns the maximum number of consecutive buildings the ball can travel when dropped from any building. :param heights: List[int], the heights of buildings in a row. :return: int, the maximum number of consecutive buildings the ball can travel. max_count = 0 for i in range(len(heights)): current_count = 1 for j in range(i + 1, len(heights)): if heights[j] <= heights[j - 1]: current_count += 1 else: break max_count = max(max_count, current_count) return max_count"},{"question":"def restore_string(s: str, indices: List[int]) -> str: Restores the original string from the scrambled string \`s\` using the given \`indices\`. Args: s (str): The scrambled string. indices (List[int]): The list of indices to unshuffle the string. Returns: str: The restored unshuffled string. >>> restore_string(\\"abc\\", [0, 1, 2]) 'abc' >>> restore_string(\\"abc\\", [2, 1, 0]) 'cba'","solution":"def restore_string(s, indices): Restores the original string from the scrambled string \`s\` using the given \`indices\`. result = [''] * len(s) for i, idx in enumerate(indices): result[idx] = s[i] return ''.join(result)"},{"question":"def shortest_palindrome(s: str) -> str: Given a string s, converts it to a palindrome by adding the fewest number of characters in front of it. Returns the resulting palindrome. >>> shortest_palindrome(\\"\\") == \\"\\" >>> shortest_palindrome(\\"a\\") == \\"a\\" >>> shortest_palindrome(\\"racecar\\") == \\"racecar\\" >>> shortest_palindrome(\\"aacecaaa\\") == \\"aaacecaaa\\" >>> shortest_palindrome(\\"abcd\\") == \\"dcbabcd\\" >>> shortest_palindrome(\\"aaba\\") == \\"abaaba\\" >>> shortest_palindrome(\\"abb\\") == \\"bbabb\\"","solution":"def shortest_palindrome(s): Given a string s, converts it to a palindrome by adding the fewest number of characters in front of it. Returns the resulting palindrome. if s == \\"\\": return \\"\\" # Getting the suffix that is not part of the palindrome for i in range(len(s), -1, -1): if s[:i] == s[:i][::-1]: break # The characters to be added to the front to_add = s[i:][::-1] # Combining to form the palindrome return to_add + s"},{"question":"def longest_session_duration(logs: List[str]) -> int: Returns the duration of the longest session for any user. Parameters: logs (list of str): List of log strings in the format \\"user_id timestamp action\\". Returns: int: Duration of the longest session. If no valid sessions are found, return 0. >>> longest_session_duration([\\"user1 1 login\\", \\"user1 5 logout\\"]) == 4 >>> longest_session_duration([ \\"user1 1 login\\", \\"user1 5 logout\\", \\"user1 10 login\\", \\"user1 15 logout\\", \\"user2 3 login\\", \\"user2 9 logout\\" ]) == 6 >>> longest_session_duration([ \\"user1 1 login\\", \\"user1 5 logout\\", \\"user1 10 login\\", \\"user2 3 login\\" ]) == 4 >>> longest_session_duration([ \\"user1 1 login\\", \\"user1 5 logout\\", \\"user2 2 login\\", \\"user2 8 logout\\", \\"user3 3 login\\", \\"user3 6 logout\\" ]) == 6 >>> longest_session_duration([]) == 0 >>> longest_session_duration([ \\"user1 1 login\\", \\"user2 2 login\\" ]) == 0","solution":"def longest_session_duration(logs): Returns the duration of the longest session for any user. Parameters: logs (list of str): List of log strings in the format \\"user_id timestamp action\\". Returns: int: Duration of the longest session. If no valid sessions are found, return 0. sessions = {} max_duration = 0 for log in logs: user_id, timestamp, action = log.split() timestamp = int(timestamp) if user_id not in sessions: sessions[user_id] = {'login': None, 'logout': None} if action == 'login': sessions[user_id]['login'] = timestamp elif action == 'logout': if sessions[user_id]['login'] is not None: session_duration = timestamp - sessions[user_id]['login'] max_duration = max(max_duration, session_duration) sessions[user_id] = {'login': None, 'logout': None} # reset for future sessions return max_duration"}]`),S={name:"App",components:{PoemCard:j},data(){return{searchQuery:"",visibleCount:4,poemsData:F,isLoading:!1}},computed:{filteredPoems(){const s=this.searchQuery.trim().toLowerCase();return s?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(s)||e.solution&&e.solution.toLowerCase().includes(s)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(s=>setTimeout(s,1e3)),this.visibleCount+=4,this.isLoading=!1}}},A={class:"search-container"},z={class:"card-container"},I={key:0,class:"empty-state"},C=["disabled"],D={key:0},P={key:1};function B(s,e,l,h,i,a){const c=g("PoemCard");return r(),n("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"ð¤prompts chatð§ ")])],-1)),t("div",A,[e[3]||(e[3]=t("span",{class:"search-icon"},"ð",-1)),p(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>i.searchQuery=o),placeholder:"Search..."},null,512),[[b,i.searchQuery]]),i.searchQuery?(r(),n("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>i.searchQuery="")}," â ")):u("",!0)]),t("div",z,[(r(!0),n(x,null,w(a.displayedPoems,(o,f)=>(r(),y(c,{key:f,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(r(),n("div",I,' No results found for "'+d(i.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(r(),n("button",{key:0,class:"load-more-button",disabled:i.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[i.isLoading?(r(),n("span",P,"Loading...")):(r(),n("span",D,"See more"))],8,C)):u("",!0)])}const E=_(S,[["render",B],["__scopeId","data-v-be102155"]]),O=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"guide/8.md","filePath":"guide/8.md"}'),M={name:"guide/8.md"},W=Object.assign(M,{setup(s){return(e,l)=>(r(),n("div",null,[v(E)]))}});export{O as __pageData,W as default};
