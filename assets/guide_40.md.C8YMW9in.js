import{_ as d,o as s,c as i,a as t,m,t as _,C as h,M as g,U as b,f as l,F as y,p as x,e as v,q as w}from"./chunks/framework.B1z0IdBH.js";const q={name:"PoemCard",props:{poem:{type:Object,required:!0}}},k={class:"poem-container"},T={class:"review"},L={class:"review-title"},N={class:"review-content"};function R(n,e,u,c,r,a){return s(),i("div",k,[t("div",T,[t("div",L,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),m(_(u.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",N,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),m(_(u.poem.solution),1)])])])}const j=d(q,[["render",R],["__scopeId","data-v-94ce91eb"]]),E=JSON.parse(`[{"question":"def min_operations_to_empty_string(s: str) -> int: Returns the minimum number of operations needed to make the string empty. >>> min_operations_to_empty_string(\\"aabb\\") == 2 >>> min_operations_to_empty_string(\\"abc\\") == 3 >>> min_operations_to_empty_string(\\"aaabbb\\") == 2 >>> min_operations_to_empty_string(\\"a\\") == 1 >>> min_operations_to_empty_string(\\"ababab\\") == 6 def process_test_cases(test_cases: List[str]) -> List[int]: Processes a list of test cases and returns the result for each. >>> process_test_cases([\\"aabb\\", \\"abc\\", \\"aaabbb\\"]) == [2, 3, 2] >>> process_test_cases([\\"a\\", \\"bb\\", \\"ccccc\\"]) == [1, 1, 1] >>> process_test_cases([\\"abcd\\", \\"aba\\", \\"aaaabbbb\\"]) == [4, 3, 2] >>> process_test_cases([\\"\\"]) == [0]","solution":"def min_operations_to_empty_string(s): Returns the minimum number of operations needed to make the string empty. if not s: return 0 operations = 0 i = 0 while i < len(s): char = s[i] while i < len(s) and s[i] == char: i += 1 operations += 1 return operations def process_test_cases(test_cases): Processes a list of test cases and returns the result for each. results = [] for s in test_cases: results.append(min_operations_to_empty_string(s)) return results"},{"question":"from typing import List, Tuple def identify_mountains(n: int, heights: List[int]) -> Tuple[int, List[int]]: Identify the number of individual mountains and specify the height of each mountain in the order they were observed. Args: - n (int): The number of height measurements. - heights (list of int): The sequence of height measurements. Returns: - a tuple containing: - int: The number of mountains observed. - list of int: The height of each mountain in the order they were recorded. >>> identify_mountains(8, [1, 3, 5, 3, 1, 4, 2, 1]) (2, [5, 4]) >>> identify_mountains(5, [2, 4, 6, 4, 2]) (1, [6]) >>> identify_mountains(3, [1, 2, 1]) (1, [2]) >>> identify_mountains(9, [1, 4, 6, 4, 2, 1, 5, 3, 1]) (2, [6, 5])","solution":"def identify_mountains(n, heights): This function identifies the number of individual mountains and specifies the height of each mountain in the order they were observed. Args: - n (int): The number of height measurements. - heights (list of int): The sequence of height measurements. Returns: - a tuple containing: - int: The number of mountains observed. - list of int: The height of each mountain in the order they were recorded. if n == 1: return 1, heights # With only one element, there's only one mountain mountains = [] peak = -1 for i in range(1, n - 1): if heights[i - 1] < heights[i] > heights[i + 1]: if peak != -1: mountains.append(heights[peak]) peak = i if peak != -1: mountains.append(heights[peak]) return len(mountains), mountains"},{"question":"def reorder_cows(n: int, m: int, a: List[int], S: List[int]) -> List[int]: Reorders the cows such that the cows in subset S are in non-decreasing order while all other cows can be in any position. Parameters: - n (int): Total number of cows. - m (int): Size of subset S. - a (list of int): Array representing the positions of cows. - S (list of int): Indices of the subset S which need to be in non-decreasing order. Returns: - list of int: Reordered array of cows' positions. >>> reorder_cows(5, 3, [5, 4, 3, 2, 1], [2, 4, 5]) [5, 2, 3, 1, 4] >>> reorder_cows(5, 5, [5, 4, 3, 2, 1], [1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> reorder_cows(5, 0, [5, 4, 3, 2, 1], []) [5, 4, 3, 2, 1] >>> reorder_cows(6, 2, [6, 5, 4, 3, 2, 1], [3, 5]) [6, 5, 2, 3, 1, 4] >>> reorder_cows(8, 3, [8, 7, 6, 5, 4, 3, 2, 1], [2, 4, 6]) [8, 3, 6, 4, 5, 2, 2, 1]","solution":"def reorder_cows(n, m, a, S): Reorders the cows such that the cows in subset S are in non-decreasing order while all other cows can be in any position. Parameters: - n (int): Total number of cows. - m (int): Size of subset S. - a (list of int): Array representing the positions of cows. - S (list of int): Indices of the subset S which need to be in non-decreasing order. Returns: - list of int: Reordered array of cows' positions. # Convert S indices to 0-based S = [s - 1 for s in S] # Extract the elements of the subset S from the array and sort them subset_values = sorted([a[s] for s in S]) # Create a result array and fill it with -1 indicating unassigned indices result = [-1] * n # Place the sorted subset values into the result array j = 0 for s in S: result[s] = subset_values[j] j += 1 # Fill in the other values at the unassigned positions other_values = [a[i] for i in range(n) if result[i] == -1] other_index = 0 for i in range(n): if result[i] == -1: result[i] = other_values[other_index] other_index += 1 return result"},{"question":"def find_largest_connected_component(n, m, circles): Determines the size of the largest connected component in a graph representation of social network circles. Parameters: n (int): the number of members m (int): the number of circles circles (List[List[int]]): list of m circles, each containing a set of members Returns: int: the size of the largest connected component Example: >>> find_largest_connected_component(10, 4, [ ... [3, 1, 2, 5], ... [4, 2, 3, 6, 7], ... [2, 4, 8], ... [3, 5, 7, 9] ... ]) 7 >>> find_largest_connected_component(5, 0, []) 1 >>> find_largest_connected_component(5, 3, [ ... [1, 1], ... [1, 2], ... [1, 3] ... ]) 1 >>> find_largest_connected_component(6, 3, [ ... [2, 1, 2], ... [2, 3, 4], ... [2, 5, 6] ... ]) 2 >>> find_largest_connected_component(5, 1, [ ... [5, 1, 2, 3, 4, 5] ... ]) 5","solution":"def find_largest_connected_component(n, m, circles): from collections import defaultdict, deque if m == 0: return 1 if n > 0 else 0 adjacency_list = defaultdict(list) for circle in circles: members = circle[1:] for i in range(len(members)): for j in range(i + 1, len(members)): adjacency_list[members[i]].append(members[j]) adjacency_list[members[j]].append(members[i]) visited = [False] * (n + 1) def bfs(start): queue = deque([start]) visited[start] = True size = 0 while queue: node = queue.popleft() size += 1 for neighbor in adjacency_list[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return size max_size = 0 for member in range(1, n + 1): if not visited[member]: component_size = bfs(member) max_size = max(max_size, component_size) return max_size"},{"question":"import heapq def find_kth_smallest(filename: str, k: int) -> int: Finds the k-th smallest integer from a file with integers on each line. :param filename: The name of the file containing integers. :param k: The position of the smallest number to find. :return: The k-th smallest integer. min_heap = [] with open(filename) as file: for line in file: number = int(line.strip()) if len(min_heap) < k: heapq.heappush(min_heap, -number) else: if number < -min_heap[0]: heapq.heapreplace(min_heap, -number) return -min_heap[0] # Test cases import pytest import os # Helper function to create a test file def create_test_file(filename, numbers): with open(filename, 'w') as file: for number in numbers: file.write(f\\"{number}n\\") @pytest.fixture def test_file(): filename = \\"test_numbers.txt\\" numbers = [7, 10, 4, 3, 20, 15] create_test_file(filename, numbers) yield filename os.remove(filename) def test_find_kth_smallest_example(test_file): assert find_kth_smallest(test_file, 3) == 7 def test_find_kth_smallest_min(test_file): assert find_kth_smallest(test_file, 1) == 3 def test_find_kth_smallest_max(test_file): assert find_kth_smallest(test_file, 6) == 20 def test_find_kth_smallest_middle(test_file): assert find_kth_smallest(test_file, 4) == 10 def test_find_kth_smallest_with_duplicates(): filename = \\"test_numbers_duplicates.txt\\" numbers = [7, 7, 4, 4, 20, 15] create_test_file(filename, numbers) try: assert find_kth_smallest(filename, 3) == 7 finally: os.remove(filename) def test_find_kth_smallest_large_file(): filename = \\"test_large_numbers.txt\\" numbers = list(range(1, 1001)) # 1 to 1000 create_test_file(filename, numbers) try: assert find_kth_smallest(filename, 500) == 500 finally: os.remove(filename)","solution":"import heapq def find_kth_smallest(filename, k): Finds the k-th smallest integer from a file with integers on each line. :param filename: The name of the file containing integers. :param k: The position of the smallest number to find. :return: The k-th smallest integer. min_heap = [] with open(filename) as file: for line in file: number = int(line.strip()) if len(min_heap) < k: heapq.heappush(min_heap, -number) else: if number < -min_heap[0]: heapq.heapreplace(min_heap, -number) return -min_heap[0]"},{"question":"def shortest_path(grid: List[List[int]]) -> int: Find the length of the shortest path from the top-left corner to the bottom-right corner of the grid, where you can only move right or down. If there is no valid path, return -1. Args: grid: List[List[int]]: 2D grid filled with non-negative integers. Returns: int: Length of the shortest path or -1 if no valid path exists. Examples: >>> shortest_path([ [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1] ]) 6 >>> shortest_path([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) 4 >>> shortest_path([ [1, 1, 1], [1, 1, 0], [1, 0, 1] ]) -1 >>> shortest_path([ [1] ]) 0 >>> shortest_path([ [0, 1], [1, 1] ]) -1 >>> shortest_path([ [1, 1, 0], [1, 0, 0], [1, 1, 1] ]) 4","solution":"from collections import deque def shortest_path(grid): n = len(grid) if grid[0][0] == 0 or grid[n-1][n-1] == 0: return -1 directions = [(0, 1), (1, 0)] # directions for right and down only visited = [[False] * n for _ in range(n)] queue = deque([(0, 0, 0)]) # (row, col, distance) visited[0][0] = True while queue: row, col, dist = queue.popleft() if row == n-1 and col == n-1: return dist for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < n and 0 <= new_col < n and not visited[new_row][new_col] and grid[new_row][new_col] != 0: visited[new_row][new_col] = True queue.append((new_row, new_col, dist + 1)) return -1"},{"question":"def max_sum_submatrix(matrix: List[List[int]]) -> int: Returns the sum of the sub-matrix with the maximum sum. >>> max_sum_submatrix([[1]]) == 1 >>> max_sum_submatrix([[-1]]) == -1 >>> max_sum_submatrix([[1, 2], [3, 4]]) == 10 >>> max_sum_submatrix([[1, 2, -1, -4, -20], [-8, -3, 4, 2, 1], [3, 8, 10, 1, 3], [-4, -1, 1, 7, -6]]) == 29 >>> max_sum_submatrix([[-1, -2, -3], [-4, -5, -6], [-7, -8, -9]]) == -1 >>> max_sum_submatrix([[2, 1, -3, -4, 5], [0, 6, 3, 4, 1], [2, -2, -1, 4, -5], [-3, 3, 1, 0, 3]]) == 18","solution":"def max_sum_submatrix(matrix): Returns the sum of the sub-matrix with the maximum sum. def kadane(arr): max_sum = cur_sum = arr[0] for num in arr[1:]: cur_sum = max(num, cur_sum + num) max_sum = max(max_sum, cur_sum) return max_sum n = len(matrix) m = len(matrix[0]) max_sum = float('-inf') for left in range(m): temp = [0] * n for right in range(left, m): for i in range(n): temp[i] += matrix[i][right] max_sum = max(max_sum, kadane(temp)) return max_sum"},{"question":"def trailing_zeros_in_factorial(n: int) -> int: Given an integer n, compute the number of trailing zeros in the factorial of n (i.e., in the number n!). Trailing zeros are the zeros that appear at the end of the number. For example: 5! = 120, which has one trailing zero. 10! = 3628800, which has two trailing zeros. Example: >>> trailing_zeros_in_factorial(5) 1 >>> trailing_zeros_in_factorial(10) 2","solution":"def trailing_zeros_in_factorial(n): Computes the number of trailing zeros in the factorial of n. Parameters: - n: integer, the value to compute the factorial trailing zeros of. Returns: - an integer representing the number of trailing zeros in n! count = 0 power_of_5 = 5 while n >= power_of_5: count += n // power_of_5 power_of_5 *= 5 return count"},{"question":"class UserDatabase: def __init__(self): self.users_by_id = {} self.users_by_name = set() def add_user(self, user_id, username): if username in self.users_by_name: return self.users_by_id[user_id] = username self.users_by_name.add(username) def check_user(self, username): if username in self.users_by_name: return \\"YES\\" else: return \\"NO\\" def process_queries(n, queries): Process a list of queries for managing user accounts with add and check functionalities. n: int: number of queries queries: List[List]: list of queries where each query is a list containing query type and parameters. Returns: List of results for check queries. >>> queries = [ ... [1, 1, 'alice'], ... [1, 2, 'bob'], ... [2, 'alice'], ... [1, 3, 'alice'], ... [2, 'eve'], ... [2, 'bob'],] >>> process_queries(6, queries) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> queries = [ ... [1, 1, 'charlie'], ... [1, 2, 'charlie'], ... [2, 'charlie'],] >>> process_queries(3, queries) [\\"YES\\"] >>> queries = [[2, 'dave']] >>> process_queries(1, queries) [\\"NO\\"] >>> queries = [ ... [1, 1, 'eva'], ... [1, 2, 'frank'], ... [2, 'frank'], ... [2, 'eva'], ... [1, 3, 'eva'], ... [2, 'george'],] >>> process_queries(6, queries) [\\"YES\\", \\"YES\\", \\"NO\\"]","solution":"class UserDatabase: def __init__(self): self.users_by_id = {} self.users_by_name = set() def add_user(self, user_id, username): if username in self.users_by_name: return self.users_by_id[user_id] = username self.users_by_name.add(username) def check_user(self, username): if username in self.users_by_name: return \\"YES\\" else: return \\"NO\\" def process_queries(n, queries): db = UserDatabase() results = [] for query in queries: q_type, *params = query if q_type == 1: user_id, username = params db.add_user(user_id, username) elif q_type == 2: username = params[0] results.append(db.check_user(username)) return results"},{"question":"def min_sum_divisible_by_k(s: str, k: int) -> int: Given a string s containing only digits ('0'-'9'), find and print the minimum possible sum of its substrings such that the sum is divisible by a given integer k. A substring is any continuous sequence of characters within the string. For example, the string \\"1234\\" has the substrings \\"1\\", \\"2\\", \\"3\\", \\"4\\", \\"12\\", \\"23\\", \\"34\\", \\"123\\", \\"234\\", and \\"1234\\". :param s: String containing only digits :param k: Integer divisor :return: Minimum possible sum of its substrings that is divisible by k, or -1 if no such sum exists >>> min_sum_divisible_by_k(\\"5\\", 5) 5 >>> min_sum_divisible_by_k(\\"3\\", 2) -1 >>> min_sum_divisible_by_k(\\"23\\", 5) 5 >>> min_sum_divisible_by_k(\\"12\\", 3) 3 >>> min_sum_divisible_by_k(\\"123456\\", 3) 3 >>> min_sum_divisible_by_k(\\"987654\\", 7) 7 >>> min_sum_divisible_by_k(\\"24681357\\", 4) 4 >>> min_sum_divisible_by_k(\\"111111\\", 10) -1 >>> min_sum_divisible_by_k(\\"999999\\", 100) -1","solution":"def min_sum_divisible_by_k(s, k): Find the minimum possible sum of its substrings such that the sum is divisible by a given integer k. :param s: String containing only digits :param k: Integer divisor :return: Minimum possible sum of its substrings that is divisible by k, or -1 if no such sum exists n = len(s) min_sum = float('inf') current_sum = 0 for i in range(n): current_sum = 0 for j in range(i, n): current_sum += int(s[j]) if current_sum % k == 0: min_sum = min(min_sum, current_sum) return min_sum if min_sum != float('inf') else -1"},{"question":"from collections import defaultdict from typing import List, Tuple def max_cities_visit(N: int, M: int, T: int, roads: List[Tuple[int, int, int]]) -> int: Determine the maximum number of cities Aisha can visit within the given time limit T. Args: N (int): Number of cities. M (int): Number of roads. T (int): Total available time. roads (list of tuples): Each tuple contains three integers u, v, and t representing a bidirectional road between cities u and v taking t units of time to travel. Returns: int: The maximum number of distinct cities Aisha can visit within the given time T. >>> max_cities_visit(5, 6, 7, [(1, 2, 2), (1, 3, 4), (2, 3, 1), (2, 4, 5), (3, 5, 3), (4, 5, 2)]) 4 >>> max_cities_visit(3, 0, 10, []) 1 >>> max_cities_visit(3, 3, 1, [(1, 2, 2), (1, 3, 3), (2, 3, 4)]) 1 >>> max_cities_visit(4, 4, 1000000000, [(1, 2, 2), (2, 3, 3), (3, 4, 4), (4, 1, 5)]) 4","solution":"from collections import defaultdict def dfs(graph, node, visited, time_elapsed, T, count): visited[node] = True max_cities = count for neighbor, travel_time in graph[node]: if time_elapsed + travel_time <= T and not visited[neighbor]: max_cities = max(max_cities, dfs(graph, neighbor, visited.copy(), time_elapsed + travel_time, T, count + 1)) return max_cities def max_cities_visit(N, M, T, roads): if M == 0: # If no roads, Aisha can visit only one city; any single city. return 1 graph = defaultdict(list) for u, v, t in roads: graph[u].append((v, t)) graph[v].append((u, t)) max_cities = 0 for i in range(1, N + 1): visited = [False] * (N + 1) max_cities = max(max_cities, dfs(graph, i, visited, 0, T, 1)) return max_cities"},{"question":"def longest_common_prefix(strs): Returns the longest common prefix among a list of words. >>> longest_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\", \\"fluff\\"]) == \\"fl\\" >>> longest_common_prefix([\\"dog\\", \\"racecar\\", \\"car\\"]) == \\"\\" >>> longest_common_prefix([\\"repeated\\", \\"repeated\\", \\"repeated\\"]) == \\"repeated\\" >>> longest_common_prefix([]) == \\"\\" >>> longest_common_prefix([\\"alone\\"]) == \\"alone\\" >>> longest_common_prefix([\\"abc\\", \\"abcdef\\"]) == \\"abc\\" >>> longest_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\"]) == \\"fl\\" >>> longest_common_prefix([\\"abc\\", \\"def\\", \\"ghi\\"]) == \\"\\"","solution":"def longest_common_prefix(strs): Returns the longest common prefix from a list of words. if not strs: return \\"\\" # Start by assuming the entire first string is the common prefix prefix = strs[0] for string in strs[1:]: # Keep reducing the prefix until it matches the start of each string while string[:len(prefix)] != prefix and prefix: prefix = prefix[:-1] if not prefix: break return prefix"},{"question":"def point_in_rectangle(x1, y1, x2, y2, px, py): Determines if the point (px, py) lies inside or on the border of the rectangle defined by diagonal corners (x1, y1) and (x2, y2). >>> point_in_rectangle(1, 1, 4, 4, 2, 2) == \\"INSIDE\\" >>> point_in_rectangle(-1, -1, 3, 3, 0, 0) == \\"INSIDE\\" >>> point_in_rectangle(0, 0, 10, 10, 10, 5) == \\"INSIDE\\" >>> point_in_rectangle(0, 0, 5, 5, 0, 0) == \\"INSIDE\\" >>> point_in_rectangle(-2, -2, 2, 2, 2, -2) == \\"INSIDE\\" >>> point_in_rectangle(-5, -5, 5, 5, 5, -5) == \\"INSIDE\\" >>> point_in_rectangle(0, 0, 5, 5, 6, 6) == \\"OUTSIDE\\" >>> point_in_rectangle(-2, -2, 2, 2, -3, -3) == \\"OUTSIDE\\" >>> point_in_rectangle(-5, -5, 5, 5, 6, -6) == \\"OUTSIDE\\"","solution":"def point_in_rectangle(x1, y1, x2, y2, px, py): Determines if the point (px, py) lies inside or on the border of the rectangle defined by diagonal corners (x1, y1) and (x2, y2). # Determine the minimum and maximum x and y coordinates of the rectangle min_x, max_x = min(x1, x2), max(x1, x2) min_y, max_y = min(y1, y2), max(y1, y2) # Check if the point (px, py) lies within or on the border of the rectangle if min_x <= px <= max_x and min_y <= py <= max_y: return \\"INSIDE\\" else: return \\"OUTSIDE\\""},{"question":"from typing import List, Tuple def is_bipartite_graph(n: int, m: int, edges: List[Tuple[int, int]]) -> str: Given an undirected graph with n vertices and m edges, identify if the given graph is a bipartite graph. A bipartite graph is a graph whose vertices can be colored using two colors such that no two adjacent vertices share the same color. If the given graph is bipartite, return \\"Yes\\". Otherwise, return \\"No\\". >>> is_bipartite_graph(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) \\"Yes\\" >>> is_bipartite_graph(3, 3, [(1, 2), (2, 3), (1, 3)]) \\"No\\" pass","solution":"def is_bipartite_graph(n, m, edges): from collections import deque, defaultdict # Create adjacency list for the graph graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) color = [-1] * (n + 1) # To keep track of the color of each vertex def bfs(src): queue = deque([src]) color[src] = 0 # Start coloring the source vertex with color 0 while queue: u = queue.popleft() for v in graph[u]: if color[v] == -1: # If the vertex has not been colored yet color[v] = 1 - color[u] # Color with opposite color of node u queue.append(v) elif color[v] == color[u]: # If an adjacent vertex has the same color return False return True for i in range(1, n + 1): if color[i] == -1: # If the vertex has not been visited yet if not bfs(i): return \\"No\\" return \\"Yes\\""},{"question":"from typing import List def combination_sum(arr: List[int], target: int) -> List[List[int]]: Write a function in Python which takes an array of positive integers and a target sum. Return an array of all unique combinations of numbers from the input array that add up to the target sum. Each number from the array can be used unlimited times in the combinations. Example: >>> combination_sum([2, 3, 6, 7], 7) [[2, 2, 3], [7]] >>> combination_sum([2, 3, 5], 8) [[2, 2, 2, 2], [2, 3, 3], [3, 5]]","solution":"from typing import List def combination_sum(arr: List[int], target: int) -> List[List[int]]: res = [] def dfs(start, path, target): if target < 0: return if target == 0: res.append(path) return for i in range(start, len(arr)): dfs(i, path + [arr[i]], target - arr[i]) dfs(0, [], target) return res"},{"question":"def will_reach_target(x: int, y: int, z: int, s: str) -> str: Determines if the spaceship will reach the target position (x, y, z) given the command sequence s. >>> will_reach_target(2, 2, 0, \\"EN\\") \\"Yes\\" >>> will_reach_target(1, 1, 1, \\"EN\\") \\"No\\" >>> will_reach_target(0, 0, 0, \\"EN\\") \\"Yes\\" >>> will_reach_target(1, 0, 0, \\"E\\") \\"Yes\\" >>> will_reach_target(0, 1, 0, \\"N\\") \\"Yes\\" >>> will_reach_target(0, 0, 1, \\"U\\") \\"Yes\\" >>> will_reach_target(0, 0, 0, \\"UD\\") \\"Yes\\" >>> will_reach_target(2, 0, 0, \\"EW\\") \\"No\\" >>> will_reach_target(4, 2, 1, \\"ENUD\\") \\"No\\"","solution":"def will_reach_target(x, y, z, s): Determines if the spaceship will reach the target position (x, y, z) given the command sequence s. dx, dy, dz = 0, 0, 0 for c in s: if c == 'U': dz += 1 elif c == 'D': dz -= 1 elif c == 'N': dy += 1 elif c == 'S': dy -= 1 elif c == 'E': dx += 1 elif c == 'W': dx -= 1 if dx == dy == dz == 0: return \\"Yes\\" if x == 0 and y == 0 and z == 0 else \\"No\\" x_reachable = (dx == 0 and x == 0) or (dx != 0 and x % dx == 0 and x // dx >= 0) y_reachable = (dy == 0 and y == 0) or (dy != 0 and y % dy == 0 and y // dy >= 0) z_reachable = (dz == 0 and z == 0) or (dz != 0 and z % dz == 0 and z // dz >= 0) if x_reachable and y_reachable and z_reachable: multiplier = None if dx != 0: multiplier = x // dx if dy != 0: if multiplier is None: multiplier = y // dy else: multiplier = min(multiplier, y // dy) if dz != 0: if multiplier is None: multiplier = z // dz else: multiplier = min(multiplier, z // dz) return \\"Yes\\" if multiplier is not None and all(( dx * multiplier == x, dy * multiplier == y, dz * multiplier == z )) else \\"No\\" return \\"No\\""},{"question":"MOD = 10**9 + 7 def count_distinct_subsequences(s: str) -> int: Returns the number of distinct subsequences of the string s, modulo 10^9 + 7. >>> count_distinct_subsequences(\\"abc\\") 8 >>> count_distinct_subsequences(\\"aaa\\") 4","solution":"MOD = 10**9 + 7 def count_distinct_subsequences(s): Returns the number of distinct subsequences of the string s, modulo 10^9 + 7. n = len(s) dp = [0] * (n + 1) dp[0] = 1 last_occurrence = {} for i in range(1, n + 1): dp[i] = 2 * dp[i - 1] % MOD if s[i - 1] in last_occurrence: dp[i] -= dp[last_occurrence[s[i - 1]] - 1] dp[i] %= MOD last_occurrence[s[i - 1]] = i return dp[n] # Example usage: # print(count_distinct_subsequences(\\"abc\\")) # Output: 8 # print(count_distinct_subsequences(\\"aaa\\")) # Output: 4"},{"question":"from typing import List, Union, Tuple def find_pair_with_prime_sum(n: int, lst: List[int]) -> Union[Tuple[int, int], str]: You are given a sequence of integers. Your task is to find a pair of integers in the sequence such that their sum is a prime number. If there are multiple pairs, print the pair with the lowest first element. If there are still ties, print the pair with the lowest second element. If there are no such pairs, print \\"No pairs found\\". >>> find_pair_with_prime_sum(5, [4, 7, 1, 10, 5]) (1, 4) >>> find_pair_with_prime_sum(3, [4, 6, 8]) \\"No pairs found\\" >>> find_pair_with_prime_sum(2, [4, 3]) (3, 4) >>> find_pair_with_prime_sum(6, [10, 6, 3, 1, 7, 2]) (1, 2) >>> find_pair_with_prime_sum(5, [-7, 3, 4, 10, 6]) (-7, 10) >>> find_pair_with_prime_sum(4, [-4, -6, -1, -3]) \\"No pairs found\\" >>> find_pair_with_prime_sum(3, [0, 0, 0]) \\"No pairs found\\"","solution":"import itertools def is_prime(num): if num < 2: return False for i in range(2, int(num**0.5) + 1): if num % i == 0: return False return True def find_pair_with_prime_sum(n, lst): lst.sort() pairs = list(itertools.combinations(lst, 2)) best_pair = None for a, b in pairs: if is_prime(a + b): if best_pair is None or (a, b) < best_pair: best_pair = (a, b) if best_pair: return best_pair else: return \\"No pairs found\\""},{"question":"def can_form_palindrome(t: int, test_cases: List[str]) -> List[str]: Determine if you can form a palindrome by rearranging the characters of the concatenation of two given strings for each test case. Args: t (int): The number of test cases. test_cases (List[str]): List of strings containing test cases 2t of them. Returns: List[str]: List containing \\"YES\\" or \\"NO\\" for each test case. >>> can_form_palindrome(3, [\\"aab\\", \\"bcc\\", \\"abc\\", \\"cba\\", \\"abc\\", \\"def\\"]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> can_form_palindrome(1, [\\"a\\", \\"a\\"]) [\\"YES\\"] >>> can_form_palindrome(1, [\\"a\\", \\"b\\"]) [\\"NO\\"] >>> can_form_palindrome(1, [\\"aabb\\", \\"ccdd\\"]) [\\"YES\\"] >>> can_form_palindrome(2, [\\"abcd\\", \\"efgh\\", \\"aabbcc\\", \\"ddeeff\\"]) [\\"NO\\", \\"YES\\"]","solution":"def can_form_palindrome(t, test_cases): results = [] for i in range(t): s1 = test_cases[2 * i] s2 = test_cases[2 * i + 1] combined = s1 + s2 char_count = {} for char in combined: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 odd_count = sum(1 for count in char_count.values() if count % 2 != 0) if (len(combined) % 2 == 0 and odd_count == 0) or (len(combined) % 2 == 1 and odd_count == 1): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def find_single_number(nums: List[int]) -> int: Given a list of integers where every element appears twice except for one, find the element that appears only once without using extra memory for another list. Args: nums (list): A list of integers Returns: int: The single element that appears only once >>> find_single_number([4, 3, 2, 4, 1, 3, 2]) 1 >>> find_single_number([1, 2, 2, 3, 3, 4, 4]) 1 >>> find_single_number([2, 2, 3, 3, 4, 4, 5]) 5 >>> find_single_number([99]) 99 >>> find_single_number([10, 14, 10, 3, 3, 14, 17]) 17","solution":"def find_single_number(nums): Given a list of integers where every element appears twice except for one, this function finds the element that appears only once. Args: nums (list): A list of integers Returns: int: The single element that appears only once unique_number = 0 for num in nums: unique_number ^= num return unique_number"},{"question":"def can_make_all_digits_equal(t: int, test_cases: List[str]) -> List[str]: Determine if it's possible to make all digits in the string equal by increasing or decreasing them by 1. Parameters: t (int): Number of test cases. test_cases (List[str]): List of strings consisting of digits to be tested. Returns: List[str]: List containing \\"YES\\" or \\"NO\\" for each test case indicating if it's possible to make all digits equal. >>> can_make_all_digits_equal(1, [\\"12345\\"]) ['NO'] >>> can_make_all_digits_equal(1, [\\"2222\\"]) ['YES'] >>> can_make_all_digits_equal(1, [\\"333333\\"]) ['YES'] >>> can_make_all_digits_equal(2, [\\"13579\\", \\"24680\\"]) ['YES', 'YES'] >>> can_make_all_digits_equal(2, [\\"13579\\", \\"1234\\"]) ['YES', 'NO'] >>> can_make_all_digits_equal(3, [\\"0000\\", \\"1111\\", \\"0101\\"]) ['YES', 'YES', 'NO']","solution":"def can_make_all_digits_equal(t, test_cases): results = [] for digits in test_cases: odd_count = sum(1 for d in digits if int(d) % 2 == 1) even_count = len(digits) - odd_count if odd_count == len(digits) or even_count == len(digits): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def max_subarray_sum(arr: List[int]) -> int: Returns the maximum sum of any contiguous subarray within the given array. :param arr: List[int] - An array of integers :return: int - The maximum sum of any contiguous subarray >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 >>> max_subarray_sum([1]) == 1 >>> max_subarray_sum([-1, -2, -3, -4]) == -1","solution":"def max_subarray_sum(arr): Returns the maximum sum of any contiguous subarray within the given array. :param arr: List[int] - An array of integers :return: int - The maximum sum of any contiguous subarray # Initialize the maximum sum to the first element max_sum = arr[0] current_sum = arr[0] # Iterate through the array starting from the second element for num in arr[1:]: # Update the current sum to be the maximum of the current number or current sum plus the current number current_sum = max(num, current_sum + num) # Update the maximum sum if the current sum is greater than the maximum sum max_sum = max(max_sum, current_sum) return max_sum"},{"question":"from collections import defaultdict from typing import List, Tuple def longest_route(n: int, m: int, edges: List[Tuple[int, int]]) -> int: Determine the longest single route possible from Ride Zero without revisiting any ride. :param n: Number of rides :param m: Number of walkways :param edges: List of tuples representing the walkways :return: Length of the longest route >>> longest_route(4, 4, [(0, 1), (0, 2), (1, 3), (2, 3)]) 3 >>> longest_route(0, 0, []) 0 >>> longest_route(1, 0, []) 0 >>> longest_route(5, 3, [(0, 1), (1, 2), (3, 4)]) 2 >>> longest_route(5, 4, [(0, 1), (1, 2), (2, 3), (3, 4)]) 4","solution":"from collections import defaultdict def longest_route(n, m, edges): if n == 0 or m == 0: return 0 graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) def dfs(node, visited): visited.add(node) max_depth = 0 for neighbor in graph[node]: if neighbor not in visited: max_depth = max(max_depth, dfs(neighbor, visited)) visited.remove(node) return 1 + max_depth return dfs(0, set()) - 1"},{"question":"def find_treehouse(grid, n, m, x, y): Find the top-left corner of a rectangular region of size x by y that is fully covered by 'T' trees in the given grid. >>> grid = [ ... ['.', '.', '.', '.', '.'], ... ['.', 'T', 'T', 'T', '.'], ... ['.', 'T', 'T', 'T', '.'], ... ['.', '.', 'T', '.', '.'] ... ] >>> find_treehouse(grid, 4, 5, 2, 2) (2, 2) >>> find_treehouse(grid, 4, 5, 1, 3) (2, 2) >>> find_treehouse(grid, 4, 5, 3, 2) -1 def solve(grid, n, m, queries): Process multiple queries on the given grid. >>> grid = [ ... ['.', '.', '.', '.', '.'], ... ['.', 'T', 'T', 'T', '.'], ... ['.', 'T', 'T', 'T', '.'], ... ['.', '.', 'T', '.', '.'] ... ] >>> queries = [(2, 2), (1, 3), (3, 2)] >>> solve(grid, 4, 5, queries) [(2, 2), (2, 2), -1]","solution":"def find_treehouse(grid, n, m, x, y): Find the top-left corner of a rectangular region of size x by y that is fully covered by 'T' trees in the given grid. for i in range(n - x + 1): for j in range(m - y + 1): if all(grid[i + dx][j + dy] == 'T' for dx in range(x) for dy in range(y)): return i + 1, j + 1 # return 1-based index return -1 def solve(grid, n, m, queries): Process multiple queries on the given grid. results = [] for x, y in queries: result = find_treehouse(grid, n, m, x, y) results.append(result) return results"},{"question":"from typing import List, Tuple def find_clusters(n: int, d: int, coords: List[Tuple[int, int]]) -> Tuple[int, List[int]]: Find the number of clusters and the sizes of these clusters formed by birds within a given distance. >>> find_clusters(10, 2, [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (-1, -1), (-2, -2), (-3, -3), (-4, -4), (-5, -5)]) (2, [5, 5]) >>> find_clusters(1, 2, [(0, 0)]) (1, [1]) >>> find_clusters(5, 1, [(0, 0), (10, 10), (20, 20), (30, 30), (40, 40)]) (5, [1, 1, 1, 1, 1]) >>> find_clusters(3, 5, [(0, 0), (3, 4), (6, 8)]) (1, [3]) >>> find_clusters(6, 3, [(0, 0), (1, 1), (4, 4), (5, 5), (8, 8), (9, 9)]) (3, [2, 2, 2])","solution":"import math from collections import defaultdict def calculate_distance(bird1, bird2): return math.sqrt((bird1[0] - bird2[0])**2 + (bird1[1] - bird2[1])**2) def find_clusters(n, d, coords): def dfs(bird_index, visited, cluster): visited[bird_index] = True cluster.append(bird_index) for neighbor in adjacency_list[bird_index]: if not visited[neighbor]: dfs(neighbor, visited, cluster) # Create an adjacency list adjacency_list = defaultdict(list) for i in range(n): for j in range(i + 1, n): if calculate_distance(coords[i], coords[j]) <= d: adjacency_list[i].append(j) adjacency_list[j].append(i) visited = [False] * n clusters = [] for i in range(n): if not visited[i]: cluster = [] dfs(i, visited, cluster) clusters.append(cluster) cluster_sizes = sorted([len(cluster) for cluster in clusters]) return len(clusters), cluster_sizes"},{"question":"def can_sort_with_single_reverse(n: int, array: List[int]) -> str: Determines whether it is possible to sort the entire array in non-decreasing order using at most one contiguous subarray reversal operation. Parameters: n (int): The length of the array. array (list of int): The array of integers to be checked. Returns: str: \\"YES\\" if it is possible to sort the array using at most one reversal operation, otherwise \\"NO\\". >>> can_sort_with_single_reverse(5, [1, 2, 3, 4, 5]) == \\"YES\\" >>> can_sort_with_single_reverse(2, [2, 1]) == \\"YES\\" >>> can_sort_with_single_reverse(3, [3, 1, 2]) == \\"NO\\" >>> can_sort_with_single_reverse(3, [3, 2, 1]) == \\"YES\\"","solution":"def can_sort_with_single_reverse(n, array): Determines whether it is possible to sort the entire array in non-decreasing order using at most one contiguous subarray reversal operation. Parameters: n (int): The length of the array. array (list of int): The array of integers to be checked. Returns: str: \\"YES\\" if it is possible to sort the array using at most one reversal operation, otherwise \\"NO\\". if n == 1: return \\"YES\\" # Find the first part where the array is not non-decreasing left = 0 while left < n - 1 and array[left] <= array[left + 1]: left += 1 if left == n - 1: return \\"YES\\" # The array is already sorted # Find the right part where the array starts non-decreasing again right = n - 1 while right > 0 and array[right] >= array[right - 1]: right -= 1 # Reverse the identified segment and check if the whole array sorts segment = array[left:right + 1] if array[:left] + segment[::-1] + array[right + 1:] == sorted(array): return \\"YES\\" else: return \\"NO\\""},{"question":"from typing import List def max_points(track: List[int]) -> int: Given an array representing the cost/reward of stepping on each cell in a circular track, calculates the maximum points achievable by visiting each cell exactly once, either to the left or right, starting from any cell. >>> max_points([1, 2, 3, 4, 5]) 15 >>> max_points([-1, -2, -3, -4, -5]) 0 >>> max_points([1, -2, 3, 4, -5]) 8 >>> max_points([-1, 3, 2, -2, 4, -1]) 9 >>> max_points([100]) 100 >>> max_points([-100]) 0 >>> max_points([0, 0, 0, 0, 0]) 0 >>> max_points([i for i in range(-500000, 500000)]) 124999750000 >>> max_points([7, -8, -3, 5, -6, 2]) 14","solution":"from typing import List def max_points(track: List[int]) -> int: Given an array representing the cost/reward of stepping on each cell in a circular track, calculates the maximum points achievable by visiting each cell exactly once, either to the left or right, starting from any cell. n = len(track) # The optimal strategy is simply to sum all positive numbers in the array. # Because moving options are either adjacent and all cells are visited exactly once, # summing all positive contributions is the best way to maximize the points. max_score = sum(filter(lambda x: x > 0, track)) return max_score"},{"question":"def first_non_positive_balance(transactions): Determines the earliest index at which the account balance becomes non-positive. Args: transactions (list of int): List of integer transactions. Returns: int: The 0-based index where balance becomes non-positive, or -1 if it never happens. >>> first_non_positive_balance([5, -2, -3, 4, -5]) 3 >>> first_non_positive_balance([5, 4, 3, 2, 1]) -1 >>> first_non_positive_balance([-1, 4, 3, 2, 1]) 0 >>> first_non_positive_balance([1, 2, -3, 4, -1]) 2 >>> first_non_positive_balance([5, -4, -3, 4, 2]) 2 >>> first_non_positive_balance([4, -7, 3, 2, -2]) 1 >>> first_non_positive_balance([1, -1, 2, -2, 3, -3, 4]) 1 >>> first_non_positive_balance([]) -1 >>> first_non_positive_balance([0]) 0 >>> first_non_positive_balance([5]) -1 >>> first_non_positive_balance([-5]) 0","solution":"def first_non_positive_balance(transactions): Determines the earliest index at which the account balance becomes non-positive. Args: transactions (list of int): List of integer transactions. Returns: int: The 0-based index where balance becomes non-positive, or -1 if it never happens. balance = 0 for i, transaction in enumerate(transactions): balance += transaction if balance <= 0: return i return -1"},{"question":"def count_platforms(heights: List[int]) -> int: Counts the number of peaks where a platform can be placed. A platform can be placed if a peak is higher than its immediate neighbors. >>> count_platforms([1, 3, 2, 4, 3]) == 2 >>> count_platforms([1, 2, 3, 4, 5]) == 0 >>> count_platforms([1, 3, 1]) == 1 >>> count_platforms([1, 3, 2, 4, 1, 5, 2]) == 3 >>> count_platforms([10, 20, 10, 30, 10, 40, 10]) == 3 >>> count_platforms([1, 3, 3, 2, 1]) == 0 >>> count_platforms([5, 5, 5, 5, 5]) == 0 >>> count_platforms([3, 3, 3, 3, 3, 3, 3, 3, 3, 3]) == 0","solution":"def count_platforms(heights): Counts the number of peaks where a platform can be placed. A platform can be placed if a peak is higher than its immediate neighbors. total_peaks = 0 n = len(heights) for i in range(1, n - 1): if heights[i] > heights[i - 1] and heights[i] > heights[i + 1]: total_peaks += 1 return total_peaks"},{"question":"def min_abs_diff_sum(n: int, sequence: List[int]) -> int: Calculate the smallest possible sum of the absolute differences of pairs if you divide the sequence into two non-empty subsequences. >>> min_abs_diff_sum(5, [1, 3, -2, 8, 4]) 2 >>> min_abs_diff_sum(2, [1, 3]) 2 >>> min_abs_diff_sum(3, [-5, -2, -1]) 1 >>> min_abs_diff_sum(4, [-8, -3, 2, 5]) 3 >>> min_abs_diff_sum(6, [1, 2, 3, 4, 5, 6]) 1 >>> min_abs_diff_sum(3, [5, 5, 5]) 0","solution":"def min_abs_diff_sum(n, sequence): sequence.sort() min_diff = float('inf') for i in range(1, n): sum_diff = abs(sequence[i-1] - sequence[i]) min_diff = min(min_diff, sum_diff) return min_diff"},{"question":"def can_transform(n: int, s: str, t: str) -> str: Determines if it's possible to transform string s into string t using one 'cut' operation and zero or more 'swap' operations Args: n (int): Length of both strings s (str): Initial string t (str): Target string Returns: str: \\"YES\\" if transformation is possible, \\"NO\\" otherwise >>> can_transform(6, \\"abcdef\\", \\"abcfed\\") # \\"YES\\" >>> can_transform(4, \\"abcd\\", \\"efgh\\") # \\"NO\\" >>> can_transform(5, \\"abcde\\", \\"edcba\\") # \\"YES\\" >>> can_transform(3, \\"abc\\", \\"abc\\") # \\"YES\\" >>> can_transform(6, \\"abcdef\\", \\"abcfeg\\") # \\"NO\\"","solution":"def can_transform(n, s, t): Determines if it's possible to transform string s into string t using one 'cut' operation and zero or more 'swap' operations Args: n (int): Length of both strings s (str): Initial string t (str): Target string Returns: str: \\"YES\\" if transformation is possible, \\"NO\\" otherwise if sorted(s) != sorted(t): return \\"NO\\" return \\"YES\\""},{"question":"def min_operations_to_equal_elements(n, arr): Returns the minimum number of operations required to make all integers in the array equal. In each operation, you can increase or decrease any element of the array by 1. pass # Unit Tests def test_single_element(): assert min_operations_to_equal_elements(1, [5]) == 0 def test_two_elements(): assert min_operations_to_equal_elements(2, [1, 2]) == 1 def test_equal_elements(): assert min_operations_to_equal_elements(3, [5, 5, 5]) == 0 def test_general_case(): assert min_operations_to_equal_elements(5, [1, 2, 3, 4, 5]) == 6 def test_large_numbers(): assert min_operations_to_equal_elements(4, [1000000000, 1000000000, 999999999, 999999999]) == 2","solution":"def min_operations_to_equal_elements(n, arr): Returns the minimum number of operations required to make all integers in the array equal. In each operation, you can increase or decrease any element of the array by 1. arr.sort() median = arr[n // 2] operations = sum(abs(x - median) for x in arr) return operations"},{"question":"def check_overlap(performances: List[Tuple[int, int]]) -> str: Determines if any of the performances overlap. Parameters: performances (list of tuples): List of tuples where each tuple contains the start and end time of a performance. Returns: str: \\"Yes\\" if any of the performances overlap, otherwise \\"No\\". Examples: >>> check_overlap([(1, 3), (2, 5), (6, 8), (8, 10)]) 'Yes' >>> check_overlap([(1, 2), (3, 4), (5, 6)]) 'No'","solution":"def check_overlap(performances): Determines if any of the performances overlap. Parameters: performances (list of tuples): List of tuples where each tuple contains the start and end time of a performance. Returns: str: \\"Yes\\" if any of the performances overlap, otherwise \\"No\\". performances.sort() for i in range(1, len(performances)): if performances[i][0] < performances[i-1][1]: return \\"Yes\\" return \\"No\\""},{"question":"def simulate_card_game(): Simulate a card game between two players using a standard 52-card deck. - The deck is shuffled and split equally between the two players. - In each round, both players reveal the top card of their respective decks. - The player with the higher-ranked card wins the round and takes both cards, placing them at the bottom of their deck. If the ranks are equal, it's a tie, and both cards are discarded. - The game continues until one player has all the cards or a maximum of 1,000 rounds is played. Returns: str: The result of the game in the format: - \\"Player 1 wins after X rounds\\" if Player 1 has all the cards. - \\"Player 2 wins after X rounds\\" if Player 2 has all the cards. - \\"Draw after 1000 rounds\\" if neither player has all the cards after 1,000 rounds. >>> result = simulate_card_game() >>> isinstance(result, str) True import random # Initialize the deck of cards, represented by tuples (rank, suit) suits = ['hearts', 'diamonds', 'clubs', 'spades'] ranks = list(range(1, 14)) # 1 represents Ace, 11 for Jack, 12 for Queen, 13 for King deck = [(rank, suit) for suit in suits for rank in ranks] # Shuffle the deck random.shuffle(deck) # Split the deck into two halves player1_deck = deck[:26] player2_deck = deck[26:] rounds = 0 # Play up to 1000 rounds while rounds < 1000 and player1_deck and player2_deck: rounds += 1 player1_card = player1_deck.pop(0) player2_card = player2_deck.pop(0) if player1_card[0] > player2_card[0]: player1_deck.extend([player1_card, player2_card]) elif player2_card[0] > player1_card[0]: player2_deck.extend([player1_card, player2_card]) # Otherwise, it's a tie (cards are discarded) if not player2_deck: return f\\"Player 1 wins after {rounds} rounds\\" elif not player1_deck: return f\\"Player 2 wins after {rounds} rounds\\" else: return f\\"Draw after 1000 rounds\\" def test_game_result_format(): result = simulate_card_game() assert isinstance(result, str) assert result.startswith(\\"Player 1 wins after\\") or result.startswith(\\"Player 2 wins after\\") or result.startswith(\\"Draw after\\") def test_game_outcomeplayer1wins_end_conditions(): result = simulate_card_game() if \\"Player 1 wins after\\" in result: rounds = int(result.split()[-2]) assert rounds <= 1000 def test_game_outcomeplayer2wins_end_conditions(): result = simulate_card_game() if \\"Player 2 wins after\\" in result: rounds = int(result.split()[-2]) assert rounds <= 1000 def test_draw_condition(): result = simulate_card_game() if \\"Draw after\\" in result: rounds = int(result.split()[-2]) assert rounds == 1000 def test_simulate_card_game_multiple_runs(): for _ in range(100): result = simulate_card_game() assert result.startswith(\\"Player 1 wins after\\") or result.startswith(\\"Player 2 wins after\\") or result.startswith(\\"Draw after\\")","solution":"import random def simulate_card_game(): # Initialize the deck of cards, represented by tuples (rank, suit) suits = ['hearts', 'diamonds', 'clubs', 'spades'] ranks = list(range(1, 14)) # 1 represents Ace, 11 for Jack, 12 for Queen, 13 for King deck = [(rank, suit) for suit in suits for rank in ranks] # Shuffle the deck random.shuffle(deck) # Split the deck into two halves player1_deck = deck[:26] player2_deck = deck[26:] rounds = 0 # Play up to 1000 rounds while rounds < 1000 and player1_deck and player2_deck: rounds += 1 player1_card = player1_deck.pop(0) player2_card = player2_deck.pop(0) if player1_card[0] > player2_card[0]: player1_deck.extend([player1_card, player2_card]) elif player2_card[0] > player1_card[0]: player2_deck.extend([player1_card, player2_card]) # Otherwise, it's a tie (cards are discarded) if not player2_deck: return f\\"Player 1 wins after {rounds} rounds\\" elif not player1_deck: return f\\"Player 2 wins after {rounds} rounds\\" else: return f\\"Draw after 1000 rounds\\""},{"question":"from typing import List def min_moves(n: int, m: int, sx: int, sy: int, tx: int, ty: int, grid: List[str]) -> int: Determine the minimum number of moves the soldier must make to reach the target position from the starting position, or if it is impossible to reach the target position, return -1. >>> min_moves(5, 5, 1, 1, 5, 5, [\\".....\\", \\".#.\\", \\".#.#.\\", \\".#.\\", \\".....\\"]) 8 >>> min_moves(5, 5, 1, 1, 5, 5, [\\".....\\", \\".#.\\", \\".#.#.\\", \\".#.\\", \\"....#\\"]) -1 >>> min_moves(1, 1, 1, 1, 1, 1, [\\".\\"]) 0 >>> min_moves(3, 3, 1, 1, 3, 3, [\\"...\\", \\".#.\\", \\"...\\"]) 4 >>> min_moves(4, 4, 1, 1, 4, 4, [\\"....\\", \\"....\\", \\"....\\", \\"....\\"]) 6 >>> min_moves(4, 4, 1, 1, 4, 2, [\\"....\\", \\"#...\\", \\"\\", \\"....\\"]) -1","solution":"from collections import deque def min_moves(n, m, sx, sy, tx, ty, grid): # Convert 1-based index to 0-based index sx, sy, tx, ty = sx - 1, sy - 1, tx - 1, ty - 1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(sx, sy, 0)]) # (x, y, distance) visited = set((sx, sy)) while queue: x, y, dist = queue.popleft() if (x, y) == (tx, ty): return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == '.' and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"def knight_minimum_moves(n: int, r_start: int, c_start: int, r_end: int, c_end: int, obstacles: set) -> int: Returns the minimum number of moves required for the knight to move from the start position to the end position on a chessboard of size n x n with obstacles. If it's not possible, it returns -1. >>> knight_minimum_moves(8, 1, 1, 8, 8, set()) == 6 >>> knight_minimum_moves(8, 1, 1, 8, 8, {(3, 3), (4, 4)}) == 6 >>> knight_minimum_moves(8, 1, 1, 8, 8, {(2, 3), (3, 2)}) == -1 >>> knight_minimum_moves(8, 1, 1, 1, 1, set()) == 0 >>> knight_minimum_moves(8, 1, 1, 2, 3, set()) == 1","solution":"from collections import deque def knight_minimum_moves(n, r_start, c_start, r_end, c_end, obstacles): Returns the minimum number of moves required for the knight to move from the start position to the end position on a chessboard of size n x n with obstacles. If it's not possible, it returns -1. # Directions the knight can move moves = [ (2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2) ] # Check if the position is within the boundaries and not an obstacle def is_valid(x, y): return 1 <= x <= n and 1 <= y <= n and (x, y) not in obstacles queue = deque([(r_start, c_start, 0)]) # (row, column, steps) visited = set() visited.add((r_start, c_start)) while queue: x, y, steps = queue.popleft() if (x, y) == (r_end, c_end): return steps for move in moves: new_x, new_y = x + move[0], y + move[1] if is_valid(new_x, new_y) and (new_x, new_y) not in visited: queue.append((new_x, new_y, steps + 1)) visited.add((new_x, new_y)) return -1"},{"question":"def count_unique_pairs(arr, k): Finds the number of unique pairs (i, j) such that arr[i] + arr[j] = k. Parameters: arr (list of int): The list of integers. k (int): The target sum. Returns: int: The number of unique pairs. >>> count_unique_pairs([1, 5, 7, -1, 5], 6) 2 >>> count_unique_pairs([1, 2, 3], 10) 0 >>> count_unique_pairs([1, 1, 1, 1], 2) 1 >>> count_unique_pairs([1000000000, 999999999, 1, 0], 1000000000) 2 >>> count_unique_pairs([3, 3, 2, 2, 1, 1, 0, 0], 4) 2","solution":"def count_unique_pairs(arr, k): Finds the number of unique pairs (i, j) such that arr[i] + arr[j] = k. Parameters: arr (list of int): The list of integers. k (int): The target sum. Returns: int: The number of unique pairs. visited = set() pairs = set() for num in arr: target = k - num if target in visited: pairs.add((min(num, target), max(num, target))) visited.add(num) return len(pairs)"},{"question":"def min_operations_to_sort_grid(n: int, m: int, grid: List[List[int]]) -> int: Determine the minimum number of 2x2 rotations required to make each row of the grid sorted in non-decreasing order. >>> min_operations_to_sort_grid(2, 2, [[1, 2], [3, 4]]) 0 >>> min_operations_to_sort_grid(2, 2, [[4, 2], [3, 1]]) -1 >>> min_operations_to_sort_grid(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 0 >>> min_operations_to_sort_grid(3, 3, [[3, 2, 1], [6, 5, 4], [9, 8, 7]]) -1","solution":"def min_operations_to_sort_grid(n, m, grid): def is_sortable(): for row in grid: for i in range(m - 1): if row[i] > row[i + 1]: return False return True if is_sortable(): return 0 return -1"},{"question":"def find_score_index(n: int, scores: List[int], target: int) -> int: Returns the 0-based index of the target score if it is present in the scores list. If the target score is not found, returns -1. >>> find_score_index(5, [15, 3, 21, 10, 50], 21) 2 >>> find_score_index(5, [15, 3, 21, 10, 50], 5) -1","solution":"def find_score_index(n, scores, target): Returns the 0-based index of the target score if it is present in the scores list. If the target score is not found, returns -1. try: return scores.index(target) except ValueError: return -1"},{"question":"def is_balanced(s: str) -> bool: Determine if a sequence of parentheses is balanced. Args: s (str): The sequence of parentheses. Returns: bool: True if the sequence is balanced, False otherwise. Examples: >>> is_balanced(\\"()\\") True >>> is_balanced(\\")(\\") False >>> is_balanced(\\"(()())\\") True >>> is_balanced(\\"(()\\") False pass # Test cases print(is_balanced(\\"()\\")) # Output: True print(is_balanced(\\")(\\")) # Output: False print(is_balanced(\\"(()())\\")) # Output: True print(is_balanced(\\"(()\\")) # Output: False","solution":"def is_balanced(s: str) -> bool: Returns True if the sequence of parentheses is balanced, False otherwise. stack = [] for char in s: if char == '(': stack.append(char) elif char == ')': if not stack: return False stack.pop() return len(stack) == 0"},{"question":"def distribute_fruits_equally(m: int, n: int, fruits: List[List[int]]) -> str: Determines if it's possible to distribute fruits equally among friends. Args: m (int): Number of friends. n (int): Number of different types of fruits. fruits (List[List[int]]): 2D list containing the number of each type of fruit each friend brought. Returns: str: \\"Not Possible\\" if equal distribution is not possible, otherwise a space-separated string of the number of each type of fruit each person will receive. >>> distribute_fruits_equally(3, 3, [[2, 6, 4], [3, 3, 5], [5, 0, 1]]) == \\"Not Possible\\" >>> distribute_fruits_equally(2, 2, [[4, 6], [2, 2]]) == \\"3 4\\" >>> distribute_fruits_equally(3, 1, [[3], [3], [3]]) == \\"3\\" >>> distribute_fruits_equally(1, 3, [[4, 5, 6]]) == \\"4 5 6\\" >>> distribute_fruits_equally(3, 2, [[0, 0], [0, 0], [0, 0]]) == \\"0 0\\"","solution":"def distribute_fruits_equally(m, n, fruits): Determines if it's possible to distribute fruits equally among friends. Args: m (int): Number of friends. n (int): Number of different types of fruits. fruits (List[List[int]]): 2D list containing the number of each type of fruit each friend brought. Returns: str: \\"Not Possible\\" if equal distribution is not possible, otherwise a space-separated string of the number of each type of fruit each person will receive. total_fruits = [0] * n for friend in fruits: for j in range(n): total_fruits[j] += friend[j] result = [] for total in total_fruits: if total % m == 0: result.append(total // m) else: return \\"Not Possible\\" return \\" \\".join(map(str, result))"},{"question":"from collections import Counter def most_frequent_char(s: str) -> str: Takes a string s and returns the most frequent character in the string. If there are multiple characters with the same highest frequency, returns the lexicographically smallest one. >>> most_frequent_char('a') == 'a' >>> most_frequent_char('bbbb') == 'b' >>> most_frequent_char('abc') == 'a' >>> most_frequent_char('aaabbb') == 'a' >>> most_frequent_char('bbbaaa') == 'a' >>> most_frequent_char('a'*1000 + 'b'*999) == 'a' >>> most_frequent_char('') == '' >>> most_frequent_char('aabbcc') == 'a' >>> most_frequent_char('eeeddddcccc') == 'c'","solution":"from collections import Counter def most_frequent_char(s): Returns the most frequent character in the string s. If there are multiple characters with the same highest frequency, returns the lexicographically smallest one. if not s: return '' counter = Counter(s) max_frequency = max(counter.values()) most_frequent_chars = [char for char in counter if counter[char] == max_frequency] return min(most_frequent_chars)"},{"question":"def generate_cross_grid(n: int) -> List[str]: Generates an n  n grid with a cross pattern as described: The middle row and the middle column are filled with '*', and all other cells are filled with '.'. :param n: an odd integer (1  n  9) :return: list of strings representing the grid >>> generate_cross_grid(1) ['*'] >>> generate_cross_grid(3) [ '.*.', '***', '.*.' ] >>> generate_cross_grid(5) [ '..*..', '..*..', '*****', '..*..', '..*..' ]","solution":"def generate_cross_grid(n): Generates an n  n grid with a cross pattern as described: The middle row and the middle column are filled with '*', and all other cells are filled with '.'. :param n: an odd integer (1  n  9) :return: list of strings representing the grid grid = [['.'] * n for _ in range(n)] mid = n // 2 for i in range(n): grid[mid][i] = '*' grid[i][mid] = '*' return [''.join(row) for row in grid]"},{"question":"def find_array_b(a: List[int]) -> List[int]: Given an array a, returns another array b such that the k-th smallest prefix sum of array b equals the k-th smallest prefix sum of array a. :param a: List[int] - Array of integers :returns: List[int] - Array of integers >>> find_array_b([1, 2, 3, 4, 5]) [1, 1, 1, 1, 1] >>> find_array_b([-1, -2, -3, -4, -5]) [-5, -4, -3, -2, -1] >>> find_array_b([1, -1, 1, -1, 1]) [-1, 1, 1, -1, 1]","solution":"def find_array_b(a): Given an array a, returns another array b such that the k-th smallest prefix sum of array b equals the k-th smallest prefix sum of array a. n = len(a) prefix_sums = [] current_sum = 0 # Calculate the prefix sums for array \`a\` for num in a: current_sum += num prefix_sums.append(current_sum) # Sort the prefix sums to get the k-th smallest prefix sums prefix_sums_sorted = sorted(prefix_sums) # We need to find \`b\` such that its prefix sums are prefix_sums_sorted b = [prefix_sums_sorted[0]] # Initialize \`b\` with the first element # Find the differences between successive sorted prefix sums and add to \`b\` for i in range(1, n): b.append(prefix_sums_sorted[i] - prefix_sums_sorted[i-1]) return b"},{"question":"def count_distinct_heights(n: int, heights: List[int]) -> int: Returns the number of distinct tree heights recorded. Parameters: n (int): the number of recorded heights. heights (list of int): the list of heights recorded. Returns: int: the number of distinct heights. Example: >>> count_distinct_heights(5, [4, 7, 4, 5, 7]) 3 >>> count_distinct_heights(5, [1, 2, 3, 4, 5]) 5 >>> count_distinct_heights(5, [4, 4, 4, 4, 4]) 1 >>> count_distinct_heights(6, [6, 8, 6, 7, 8, 6]) 3 >>> count_distinct_heights(1, [10]) 1 >>> count_distinct_heights(100, list(range(1, 101))) 100","solution":"def count_distinct_heights(n, heights): Returns the number of distinct tree heights recorded. Parameters: n (int): the number of recorded heights. heights (list of int): the list of heights recorded. Returns: int: the number of distinct heights. return len(set(heights))"},{"question":"def shortest_subarray_with_sum(arr: List[int], k: int) -> int: You need to find the length of the shortest subarray for which the sum of its elements is strictly greater than a given integer k. The first line contains two integers n and k (1  n  10^5; 1  k  10^9)  the number of elements in the array and the given integer. The following line contains n integers a_i (1  a_i  10^5)  the elements of the array. Output the length of the shortest subarray for which the sum of its elements is strictly greater than k. If there is no such subarray, output -1. >>> shortest_subarray_with_sum([1, 2, 3, 4, 5], 11) 3 >>> shortest_subarray_with_sum([1, 2, 3, 4, 5], 6) 2 >>> shortest_subarray_with_sum([1, 2, 3], 10) -1 >>> shortest_subarray_with_sum([10], 5) 1 >>> shortest_subarray_with_sum([1, 2, 3, 4, 5], 15) -1","solution":"def shortest_subarray_with_sum(arr, k): n = len(arr) start, end = 0, 0 min_length = float('inf') current_sum = 0 while end < n: current_sum += arr[end] while current_sum > k: min_length = min(min_length, end - start + 1) current_sum -= arr[start] start += 1 end += 1 return min_length if min_length != float('inf') else -1"},{"question":"def diagonal_sums(matrix: List[List[int]]) -> Tuple[int, int]: Calculate the sums of the main diagonal and the antidiagonal of a square matrix. >>> diagonal_sums([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == (15, 15) >>> diagonal_sums([[5]]) == (5, 5) >>> diagonal_sums([[1, 2], [3, 4]]) == (5, 5) >>> diagonal_sums([[-1, -2, -3], [-4, -5, -6], [-7, -8, -9]]) == (-15, -15)","solution":"def diagonal_sums(matrix): Calculate the sums of the main diagonal and the antidiagonal of a square matrix. n = len(matrix) main_diagonal_sum = 0 anti_diagonal_sum = 0 for i in range(n): main_diagonal_sum += matrix[i][i] anti_diagonal_sum += matrix[i][n - i - 1] return main_diagonal_sum, anti_diagonal_sum"},{"question":"def calculate_total_rewards(n, T, A, B, performances): Calculate the total rewards based on performances, threshold T, reward A and reward B. :param n: Number of employees :param T: Threshold performance value :param A: Reward for performance greater than or equal to T :param B: Reward for performance less than T :param performances: List of performances of the employees :return: Total amount of money spent on rewards >>> calculate_total_rewards(5, 70, 100, 50, [65, 80, 90, 55, 70]) 400 >>> calculate_total_rewards(3, 75, 200, 150, [80, 70, 75]) 550 >>> calculate_total_rewards(4, 60, 300, 100, [30, 50, 60, 90]) 800 >>> calculate_total_rewards(6, 85, 500, 300, [85, 85, 85, 85, 85, 85]) 3000 >>> calculate_total_rewards(2, 100, 1000, 500, [99, 98]) 1000 >>> calculate_total_rewards(2, 50, 200, 100, [51, 52]) 400","solution":"def calculate_total_rewards(n, T, A, B, performances): Calculate the total rewards based on performances, threshold T, reward A and reward B. :param n: Number of employees :param T: Threshold performance value :param A: Reward for performance greater than or equal to T :param B: Reward for performance less than T :param performances: List of performances of the employees :return: Total amount of money spent on rewards total_rewards = 0 for performance in performances: if performance >= T: total_rewards += A else: total_rewards += B return total_rewards"},{"question":"def increment_modulo(register): Increment a register of bits modulo 2^N qubits, where N is the length of the register. >>> reg = [0, 0] >>> increment_modulo(reg) >>> reg [1, 0] >>> reg = [1, 0] >>> increment_modulo(reg) >>> reg [0, 1] >>> reg = [1, 1] >>> increment_modulo(reg) >>> reg [0, 0] >>> reg = [1, 0, 1, 0] >>> increment_modulo(reg) >>> reg [0, 1, 1, 0] >>> reg = [1, 1, 1, 1] >>> increment_modulo(reg) >>> reg [0, 0, 0, 0] >>> reg = [0] >>> increment_modulo(reg) >>> reg [1] >>> reg = [1] >>> increment_modulo(reg) >>> reg [0] N = len(register) flip = True for i in range(N): if flip: if register[i] == 0: register[i] = 1 flip = False else: register[i] = 0 else: break","solution":"def increment_modulo(register): Increment a register of bits modulo 2^N qubits, where N is the length of the register. N = len(register) flip = True for i in range(N): if flip: if register[i] == 0: register[i] = 1 flip = False else: register[i] = 0 else: break # Example usage register = [0, 0] increment_modulo(register) print(register) # Should output: [1, 0]"},{"question":"def can_place_plots(L: int, W: int, n: int, plots: List[Tuple[int, int]]) -> str: Determines if it's possible to place all plots in the garden and provides a valid configuration if possible. Arguments: L (int): length of the garden. W (int): width of the garden. n (int): number of plant species. plots (list of tuples): dimensions of each plot (li, wi). Returns: (str): \\"YES\\" followed by n lines each containing coordinates (xi, yi), or \\"NO\\" if it is not possible to place all plots. >>> can_place_plots(10, 10, 3, [(2, 3), (4, 5), (3, 2)]) YES 0 0 2 0 6 0 >>> can_place_plots(5, 5, 1, [(6, 6)]) NO","solution":"def can_place_plots(L, W, n, plots): Determines if it's possible to place all plots in the garden and provides a valid configuration if possible. Arguments: L (int): length of the garden. W (int): width of the garden. n (int): number of plant species. plots (list of tuples): dimensions of each plot (li, wi). Returns: (str): \\"YES\\" followed by n lines each containing coordinates (xi, yi), or \\"NO\\" if it is not possible to place all plots. # Trying to place plots in a grid manner x, y = 0, 0 max_height_in_row = 0 positions = [] for li, wi in plots: if x + li <= L and y + wi <= W: positions.append((x, y)) max_height_in_row = max(max_height_in_row, wi) x += li elif y + max_height_in_row + wi <= W and li <= L: y += max_height_in_row x = 0 max_height_in_row = wi positions.append((x, y)) x += li else: return \\"NO\\" result = [\\"YES\\"] for pos in positions: result.append(f\\"{pos[0]} {pos[1]}\\") return \\"n\\".join(result) # Example usage: L = 10 W = 10 n = 3 plots = [(2, 3), (4, 5), (3, 2)] print(can_place_plots(L, W, n, plots))"},{"question":"def count_lucky_substrings(s: str) -> int: Counts the number of lucky substrings in the given string s. A substring is lucky if the number of distinct characters in the substring is equal to its length. Parameters: s (str): The input string consisting of lowercase English letters. Returns: int: The number of lucky substrings in the string. >>> count_lucky_substrings(\\"a\\") == 1 >>> count_lucky_substrings(\\"abc\\") == 6 >>> count_lucky_substrings(\\"aaa\\") == 3 >>> count_lucky_substrings(\\"aab\\") == 4 >>> count_lucky_substrings(\\"aa\\") == 2 >>> count_lucky_substrings(\\"abcdef\\") == 21","solution":"def count_lucky_substrings(s): Counts the number of lucky substrings in the given string s. A substring is lucky if the number of distinct characters in the substring is equal to its length. Parameters: s (str): The input string consisting of lowercase English letters. Returns: int: The number of lucky substrings in the string. n = len(s) lucky_count = 0 for i in range(n): seen = set() for j in range(i, n): if s[j] in seen: break seen.add(s[j]) if len(seen) == j - i + 1: lucky_count += 1 return lucky_count"},{"question":"from typing import List from collections import Counter import heapq def rearrange_string(s: str) -> str: Rearrange the characters in the string such that no two adjacent characters are the same. Return the rearranged string if possible, otherwise return an empty string. >>> rearrange_string(\\"aab\\") \\"aba\\" >>> rearrange_string(\\"aaab\\") \\"\\" def test_rearrange_string_possible_case(): assert rearrange_string(\\"aab\\") == \\"aba\\" or rearrange_string(\\"aab\\") == \\"baa\\" def test_rearrange_string_not_possible_case(): assert rearrange_string(\\"aaab\\") == \\"\\" def test_single_character_string(): assert rearrange_string(\\"a\\") == \\"a\\" def test_large_case_possible(): s = \\"a\\" * 50000 + \\"b\\" * 50000 result = rearrange_string(s) for i in range(1, len(result)): assert result[i] != result[i - 1] def test_large_case_impossible(): s = \\"a\\" * 75001 + \\"b\\" * 24999 assert rearrange_string(s) == \\"\\"","solution":"from collections import Counter import heapq def rearrange_string(s): Rearrange the characters in the string such that no two adjacent characters are the same. Return the rearranged string if possible, otherwise return an empty string. counter = Counter(s) max_heap = [(-freq, char) for char, freq in counter.items()] heapq.heapify(max_heap) prev_char, prev_freq = None, 0 result = [] while max_heap or prev_freq < 0: if prev_freq < 0: if not max_heap: return \\"\\" freq, char = heapq.heappop(max_heap) result.append(char) if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) prev_char, prev_freq = char, freq + 1 return \\"\\".join(result)"},{"question":"def search(nums: List[int], target: int) -> bool: Determine if the target value exists within the array nums which is initially sorted in non-decreasing order but rotated at an unknown pivot. Args: nums (List[int]): a list of integers that has been sorted in non-decreasing order, then rotated. target (int): the target value to search for. Returns: bool: true if the target exists in the array, false otherwise. Examples: >>> search([2,5,6,0,0,1,2], 0) True >>> search([2,5,6,0,0,1,2], 3) False","solution":"def search(nums, target): Returns True if target exists in the rotated sorted array nums, otherwise False. if not nums: return False left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return True # If we can't distinct the elements at left, mid and right if nums[left] == nums[mid] == nums[right]: left += 1 right -= 1 # When middle element is in the left part of rotated array elif nums[left] <= nums[mid]: # Check if target is in the left part if nums[left] <= target < nums[mid]: right = mid - 1 else: left = mid + 1 # When middle element is in the right part of rotated array else: # Check if target is in the right part if nums[mid] < target <= nums[right]: left = mid + 1 else: right = mid - 1 return False"},{"question":"from typing import List def max_road_distance(n: int, m: int, grid: List[str]) -> int: Calculate the maximum horizontal distance one can travel on road cells without encountering non-road cells. >>> max_road_distance(4, 5, [\\"RRRRR\\", \\"RPBRR\\", \\"RRWRB\\", \\"RWRRR\\"]) 5 >>> max_road_distance(3, 5, [\\"RRRRR\\", \\"RRRRR\\", \\"RRRRR\\"]) 5 >>> max_road_distance(2, 4, [\\"BBBB\\", \\"PPPP\\"]) 0 >>> max_road_distance(3, 5, [\\"RRRWR\\", \\"RWRWR\\", \\"RRRRR\\"]) 5 >>> max_road_distance(3, 6, [\\"RWRRWR\\", \\"RRRRRR\\", \\"RWRRWR\\"]) 6","solution":"from typing import List def max_road_distance(n: int, m: int, grid: List[str]) -> int: max_distance = 0 for row in grid: current_distance = 0 for cell in row: if cell == 'R': current_distance += 1 max_distance = max(max_distance, current_distance) else: current_distance = 0 return max_distance"},{"question":"def can_form_palindrome_by_deleting_one_char(t, test_cases): Determine if it is possible to delete exactly one character from the string to make it a palindrome for each test case. Args: t (int): The number of test cases. test_cases (List[str]): List of strings to be tested. Returns: List[str]: List of results (\\"YES\\" or \\"NO\\"). >>> can_form_palindrome_by_deleting_one_char(3, [\\"abca\\", \\"abc\\", \\"abcd\\"]) [\\"YES\\", \\"NO\\", \\"NO\\"] >>> can_form_palindrome_by_deleting_one_char(2, [\\"racecar\\", \\"raccar\\"]) [\\"YES\\", \\"YES\\"] pass def is_palindrome(s): Check if a given string is a palindrome. Args: s (str): The string to be checked. Returns: bool: True if the string is a palindrome, False otherwise. >>> is_palindrome(\\"aba\\") True >>> is_palindrome(\\"abca\\") False pass # Test cases def test_is_palindrome(): assert is_palindrome(\\"aba\\") == True assert is_palindrome(\\"abca\\") == False assert is_palindrome(\\"a\\") == True assert is_palindrome(\\"\\") == True assert is_palindrome(\\"abccba\\") == True def test_can_form_palindrome_by_deleting_one_char_case1(): t = 3 test_cases = [\\"abca\\", \\"abc\\", \\"abcd\\"] assert can_form_palindrome_by_deleting_one_char(t, test_cases) == [\\"YES\\", \\"NO\\", \\"NO\\"] def test_can_form_palindrome_by_deleting_one_char_case2(): t = 2 test_cases = [\\"racecar\\", \\"raccar\\"] assert can_form_palindrome_by_deleting_one_char(t, test_cases) == [\\"YES\\", \\"YES\\"] def test_can_form_palindrome_by_deleting_one_char_case3(): t = 4 test_cases = [\\"a\\", \\"aa\\", \\"aaa\\", \\"abc\\"] assert can_form_palindrome_by_deleting_one_char(t, test_cases) == [\\"YES\\", \\"YES\\", \\"YES\\", \\"NO\\"] def test_can_form_palindrome_by_deleting_one_char_case4(): t = 1 test_cases = [\\"abcdba\\"] assert can_form_palindrome_by_deleting_one_char(t, test_cases) == [\\"YES\\"] def test_can_form_palindrome_by_deleting_one_char_case5(): t = 1 test_cases = [\\"abcde\\"] assert can_form_palindrome_by_deleting_one_char(t, test_cases) == [\\"NO\\"]","solution":"def can_form_palindrome_by_deleting_one_char(t, test_cases): results = [] for s in test_cases: if is_palindrome(s): results.append(\\"YES\\") continue found = False length = len(s) for i in range(length): # Remove one character and check if resulting string is palindrome if is_palindrome(s[:i] + s[i+1:]): results.append(\\"YES\\") found = True break if not found: results.append(\\"NO\\") return results def is_palindrome(s): return s == s[::-1]"},{"question":"def count_nodes_with_one_child(n: int, nodes: List[Tuple[int, int, int]]) -> int: Given a binary tree, find the number of nodes that have exactly one child. >>> count_nodes_with_one_child(3, [(1, 2, 3), (2, -1, -1), (3, -1, -1)]) 0 >>> count_nodes_with_one_child(5, [(1, 2, -1), (2, -1, 3), (3, 4, -1), (4, -1, 5), (5, -1, -1)]) 4 >>> count_nodes_with_one_child(5, [(1, 2, 3), (2, -1, 4), (3, -1, -1), (4, -1, -1), (5, 6, -1)]) 2 >>> count_nodes_with_one_child(5, [(1, 2, 3), (2, -1, 4), (3, -1, -1), (4, 5, -1), (5, -1, -1)]) 2 >>> count_nodes_with_one_child(1, [(1, -1, -1)]) 0","solution":"def count_nodes_with_one_child(n, nodes): count = 0 for node in nodes: _, left, right = node if (left == -1 and right != -1) or (left != -1 and right == -1): count += 1 return count # Example usage n = 5 nodes = [ (1, 2, 3), (2, -1, 4), (3, -1, -1), (4, -1, -1), (5, 6, -1) ] print(count_nodes_with_one_child(n, nodes)) # Output: 2"},{"question":"def custom_sort(nums: List[int]) -> List[int]: Sorts a list of integers such that all even numbers come before all odd numbers and within these groups, the numbers are sorted in descending order. >>> custom_sort([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) [8, 6, 4, 2, 0, 9, 7, 5, 3, 1] >>> custom_sort([-5, 3, 0, -2, 4, 1, -7]) [4, 0, -2, 3, 1, -5, -7] >>> custom_sort([10, -10, 15, -15, 20, -20]) [20, 10, -10, -20, 15, -15]","solution":"def custom_sort(nums): evens = [num for num in nums if num % 2 == 0] odds = [num for num in nums if num % 2 != 0] sorted_evens = sorted(evens, reverse=True) sorted_odds = sorted(odds, reverse=True) return sorted_evens + sorted_odds"},{"question":"def longest_event_days(n: int, forbidden_days: List[int]) -> int: Find the longest consecutive sequence of days during which the event can be held without interruption. >>> longest_event_days(10, []) 10 >>> longest_event_days(10, [4, 5, 10]) 4 >>> longest_event_days(15, [1, 2, 3, 14, 15]) 10 >>> longest_event_days(10, [1, 3, 6, 8, 10]) 2 >>> longest_event_days(1, [1]) 0 >>> longest_event_days(1, []) 1 >>> longest_event_days(5, [2, 4]) 1 >>> longest_event_days(5, [1, 3, 5]) 1 >>> longest_event_days(3, [1, 2, 3]) 0","solution":"def longest_event_days(n, forbidden_days): if not forbidden_days: return n forbidden_days.sort() max_length = 0 current_start = 1 for day in forbidden_days: if day > current_start: max_length = max(max_length, day - current_start) current_start = day + 1 if current_start <= n: max_length = max(max_length, n - current_start + 1) return max_length"},{"question":"def can_rank_warriors(test_cases): Determine if it is possible to rank all the warriors such that no warrior loses to another ranked lower than themselves. Args: test_cases (List[Tuple[int, int, List[Tuple[int, int]]]]): A list of test cases where each test case is a tuple containing: - The number of warriors (n) - The number of duels (m) - A list of tuples representing the duels where each tuple is two integers (a, b) indicating that warrior a defeated warrior b. Returns: List[str]: A list of strings \\"YES\\" or \\"NO\\" for each test case indicating if the ranking is possible. pass def parse_input(input_lines: str) -> List[Tuple[int, int, List[Tuple[int, int]]]]: Parse the input string into a list of test cases. Args: input_lines (str): The input string containing the test cases. Returns: List[Tuple[int, int, List[Tuple[int, int]]]]: Parsed test cases. pass def main(input_string: str) -> str: Main function to process the input and produce the result. Args: input_string (str): The input string containing the test cases. Returns: str: The results for each test case joined by newline characters. pass # Example usage input_data = \\"2n3 3n1 2n2 3n3 1n4 2n1 2n2 3n\\" print(main(input_data)) # Expected: NOnYES # Unit Tests def test_can_rank_warriors(): input_data = \\"2n3 3n1 2n2 3n3 1n4 2n1 2n2 3n\\" expected_output = \\"NOnYES\\" assert main(input_data) == expected_output def test_no_duels(): input_data = \\"1n3 0n\\" expected_output = \\"YES\\" assert main(input_data) == expected_output def test_single_warrior(): input_data = \\"1n1 0n\\" expected_output = \\"YES\\" assert main(input_data) == expected_output def test_cycle_graph(): input_data = \\"1n4 4n1 2n2 3n3 4n4 1n\\" expected_output = \\"NO\\" assert main(input_data) == expected_output def test_disconnected_graph(): input_data = \\"1n4 2n1 2n3 4n\\" expected_output = \\"YES\\" assert main(input_data) == expected_output","solution":"def can_rank_warriors(test_cases): def is_dag(n, edges): from collections import defaultdict, deque graph = defaultdict(list) in_degree = [0] * (n + 1) for u, v in edges: graph[u].append(v) in_degree[v] += 1 queue = deque([i for i in range(1, n + 1) if in_degree[i] == 0]) visited = 0 while queue: node = queue.popleft() visited += 1 for neighbor in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) return visited == n results = [] for n, m, edges in test_cases: if is_dag(n, edges): results.append(\\"YES\\") else: results.append(\\"NO\\") return results def parse_input(input_lines): lines = input_lines.strip().split(\\"n\\") T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): n, m = map(int, lines[index].split()) index += 1 edges = [] for _ in range(m): a, b = map(int, lines[index].split()) edges.append((a, b)) index += 1 test_cases.append((n, m, edges)) return test_cases def main(input_string): test_cases = parse_input(input_string) return \\"n\\".join(can_rank_warriors(test_cases))"},{"question":"from typing import List def count_good_view_buildings(buildings: List[int]) -> int: Returns the number of buildings with a good view. A building has a good view if it is strictly taller than any building to its left. The leftmost building is always considered to have a good view. :param buildings: List of integers representing the heights of the buildings. :return: Integer count of buildings with a good view. >>> count_good_view_buildings([3, 7, 8, 3, 6, 1]) 3 >>> count_good_view_buildings([1, 2, 3, 4, 5]) 5 >>> count_good_view_buildings([5, 4, 3, 2, 1]) 1 {insert additional test cases here}","solution":"def count_good_view_buildings(buildings): Returns the number of buildings with a good view. A building has a good view if it is strictly taller than any building to its left. The leftmost building is always considered to have a good view. :param buildings: List of integers representing the heights of the buildings. :return: Integer count of buildings with a good view. if not buildings: return 0 good_view_count = 1 # The leftmost building is always a good view building. max_height = buildings[0] for height in buildings[1:]: if height > max_height: good_view_count += 1 max_height = height return good_view_count"},{"question":"def max_distinct_subarray_index(n: int, k: int, arr: List[int]) -> int: Determine the starting index of the subarray of length k that contains the highest number of distinct elements. If there are multiple such subarrays, return the smallest index. >>> max_distinct_subarray_index(8, 3, [1, 2, 1, 3, 4, 3, 2, 1]) == 1 >>> max_distinct_subarray_index(5, 1, [1, 2, 3, 4, 5]) == 0 >>> max_distinct_subarray_index(5, 3, [1, 1, 1, 1, 1]) == 0 >>> max_distinct_subarray_index(5, 3, [1, 2, 3, 4, 5]) == 0 >>> max_distinct_subarray_index(8, 3, [1, 2, 3, 1, 2, 3, 1, 2]) == 0 >>> max_distinct_subarray_index(5, 5, [1, 2, 3, 4, 5]) == 0","solution":"def max_distinct_subarray_index(n, k, arr): from collections import defaultdict max_distinct_count = 0 max_distinct_index = 0 window_counts = defaultdict(int) current_distinct_count = 0 # Initialize the first window for i in range(k): if window_counts[arr[i]] == 0: current_distinct_count += 1 window_counts[arr[i]] += 1 max_distinct_count = current_distinct_count for i in range(1, n - k + 1): # Slide the window to the right leaving_element = arr[i - 1] new_element = arr[i + k - 1] # Remove the effect of the leaving element window_counts[leaving_element] -= 1 if window_counts[leaving_element] == 0: current_distinct_count -= 1 # Add the effect of the new element if window_counts[new_element] == 0: current_distinct_count += 1 window_counts[new_element] += 1 # Update max distinct count and index if necessary if current_distinct_count > max_distinct_count: max_distinct_count = current_distinct_count max_distinct_index = i return max_distinct_index"},{"question":"import re from collections import Counter from typing import List, Tuple def top_k_frequent_words(text: str, k: int) -> List[Tuple[str, int]]: Count the frequency of each word in a given text and output the top k most frequent words along with their frequencies. >>> top_k_frequent_words(\\"Hello, hello! Are you there? HELLO! Are you listening?\\", 3) [('hello', 3), ('are', 2), ('you', 2)] >>> top_k_frequent_words(\\"Word.\\", 1) [('word', 1)] >>> top_k_frequent_words(\\"Hello! Hello? Hello. Hello, hello: HELLO;\\", 1) [('hello', 6)] >>> top_k_frequent_words(\\"a b c d e f g h i j a b c d e f g h i a b c d e f g h a b c d e f g a b c d e f a b c d e a b c d a b c a b a\\", 10) [('a', 10), ('b', 9), ('c', 8), ('d', 7), ('e', 6), ('f', 5), ('g', 4), ('h', 3), ('i', 2), ('j', 1)] >>> top_k_frequent_words(\\"apple orange banana apple orange apple banana banana\\", 2) [('apple', 3), ('banana', 3)] >>> top_k_frequent_words(\\"Cat cat CAT dog DOG dog\\", 2) [('cat', 3), ('dog', 3)]","solution":"import re from collections import Counter from typing import List, Tuple def top_k_frequent_words(text: str, k: int) -> List[Tuple[str, int]]: # Convert the text to lowercase to ensure case-insensitivity text = text.lower() # Use regex to replace punctuation characters with spaces text = re.sub(r'[.,!?:;]', ' ', text) # Split the text into words words = text.split() # Count the frequency of each word using Counter word_counts = Counter(words) # Sort the word-frequency pairs first by frequency (descending) then by word (lexicographically) sorted_word_counts = sorted(word_counts.items(), key=lambda pair: (-pair[1], pair[0])) # Return the top k words with their frequencies return sorted_word_counts[:k]"},{"question":"def has_cycle(N: int, M: int, edges: List[Tuple[int, int]]) -> str: Determines if there is a cycle in an undirected graph. Parameters: N (int): The number of vertices. M (int): The number of edges. edges (list of tuples): List of edges, each represented as a tuple (u, v). Returns: str: \\"Yes\\" if there is a cycle, otherwise \\"No\\". >>> has_cycle(4, 4, [(1, 2), (2, 3), (3, 4), (4, 2)]) 'Yes' >>> has_cycle(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) 'No' from collections import defaultdict def test_has_cycle_example_1(): N = 4 M = 4 edges = [(1, 2), (2, 3), (3, 4), (4, 2)] assert has_cycle(N, M, edges) == \\"Yes\\" def test_has_cycle_example_2(): N = 5 M = 4 edges = [(1, 2), (2, 3), (3, 4), (4, 5)] assert has_cycle(N, M, edges) == \\"No\\" def test_has_cycle_single_cycle(): N = 3 M = 3 edges = [(1, 2), (2, 3), (3, 1)] assert has_cycle(N, M, edges) == \\"Yes\\" def test_has_cycle_no_edges(): N = 3 M = 0 edges = [] assert has_cycle(N, M, edges) == \\"No\\" def test_has_cycle_disconnected_graph_with_cycle(): N = 6 M = 5 edges = [(1, 2), (2, 3), (3, 1), (4, 5), (5, 6)] assert has_cycle(N, M, edges) == \\"Yes\\" def test_has_cycle_disconnected_graph_without_cycle(): N = 6 M = 4 edges = [(1, 2), (3, 4), (4, 5), (5, 6)] assert has_cycle(N, M, edges) == \\"No\\" def test_has_cycle_small_graph_with_cycle(): N = 2 M = 1 edges = [(1, 1)] assert has_cycle(N, M, edges) == \\"Yes\\" def test_has_cycle_small_graph_no_cycle(): N = 2 M = 1 edges = [(1, 2)] assert has_cycle(N, M, edges) == \\"No\\"","solution":"def has_cycle(N, M, edges): Determines if there is a cycle in an undirected graph. Parameters: N (int): The number of vertices. M (int): The number of edges. edges (list of tuples): List of edges, each represented as a tuple (u, v). Returns: str: \\"Yes\\" if there is a cycle, otherwise \\"No\\". from collections import defaultdict def dfs(v, parent): visited[v] = True for neighbor in graph[v]: if not visited[neighbor]: if dfs(neighbor, v): return True elif neighbor != parent: return True return False # Create an adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = [False] * (N + 1) # Check for cycle in each component for i in range(1, N + 1): if not visited[i]: if dfs(i, -1): return \\"Yes\\" return \\"No\\""},{"question":"def validate_survey(survey: List[str]) -> str: Validates the given survey configuration. Parameters: - survey: A list of strings where the first element contains the number of questions n, and the following elements contain the questions and their parameters. Returns: A string \\"Survey is valid\\" if all survey questions are valid, otherwise \\"Survey is invalid\\" followed by the indices of invalid questions. Examples: >>> validate_survey([\\"4\\", \\"1 4\\", \\"2 1 5\\", \\"3 300\\", \\"2 3 8\\"]) \\"Survey is valid\\" >>> validate_survey([\\"3\\", \\"1 1\\", \\"2 5 5\\", \\"3 0\\"]) \\"Survey is invalid 1 2 3\\"","solution":"def validate_survey(survey): Validates the given survey configuration. Parameters: - survey: A list of strings where the first element contains the number of questions n, and the following elements contain the questions and their parameters. Returns: A string \\"Survey is valid\\" if all survey questions are valid, otherwise \\"Survey is invalid\\" followed by the indices of invalid questions. n = int(survey[0]) invalid_indices = [] for i in range(1, n+1): question = list(map(int, survey[i].split())) qtype = question[0] if qtype == 1: c = question[1] if not (2 <= c <= 10): invalid_indices.append(i) elif qtype == 2: rmin, rmax = question[1], question[2] if not (1 <= rmin < rmax <= 10): invalid_indices.append(i) elif qtype == 3: l = question[1] if not (1 <= l <= 500): invalid_indices.append(i) if invalid_indices: return f\\"Survey is invalid {' '.join(map(str, invalid_indices))}\\" else: return \\"Survey is valid\\""},{"question":"def assign_types(n: int, k: int, edges: List[Tuple[int, int]]) -> Union[str, Tuple[str, List[int]]]: Determines if it is possible to assign types to each park such that no directly connected parks have the same type, and returns the type assignment if possible. Args: - n: the number of parks - k: the number of unique types - edges: a list of tuples representing the pedestrian bridges between parks Returns: - If it is not possible to assign types, returns \\"NO\\". - If it is possible, returns \\"YES\\" followed by a list of integers indicating the type assigned to each park. >>> assign_types(5, 3, [(1, 2), (1, 3), (2, 4), (3, 5)]) \\"YES\\", [1, 2, 3, 1, 2] >>> assign_types(5, 1, [(1, 2), (1, 3), (2, 4), (3, 5)]) \\"NO\\"","solution":"def assign_types(n, k, edges): from collections import defaultdict, deque if k == 1 and n > 1: return \\"NO\\" # Build the adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # BFS to color the tree types = [-1] * (n + 1) queue = deque([(1, 1)]) # Start BFS from node 1 with type 1 types[1] = 1 while queue: node, cur_type = queue.popleft() next_type = 1 for neighbor in graph[node]: if types[neighbor] == -1: # if not colored yet if next_type == cur_type: next_type += 1 types[neighbor] = next_type queue.append((neighbor, next_type)) next_type += 1 if next_type > k: next_type = 1 return \\"YES\\", types[1:] def solve(parks, types, connections): result = assign_types(parks, types, connections) if result == \\"NO\\": print(result) else: print(\\"YES\\") print(\\" \\".join(map(str, result[1])))"},{"question":"def fibonacci_sequence(n: int) -> List[int]: Generates the first n numbers of the Fibonacci sequence. >>> fibonacci_sequence(1) [0] >>> fibonacci_sequence(2) [0, 1] >>> fibonacci_sequence(3) [0, 1, 1] >>> fibonacci_sequence(5) [0, 1, 1, 2, 3] >>> fibonacci_sequence(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]","solution":"def fibonacci_sequence(n): Generates the first n numbers of the Fibonacci sequence. if n <= 0: return [] sequence = [0, 1] for i in range(2, n): next_number = sequence[-1] + sequence[-2] sequence.append(next_number) return sequence[:n]"},{"question":"def predict_ratings(matrix): Predict ratings based on average user ratings. Args: matrix (list of list of int): n x n matrix where A[i][j] is the rating given by the i-th user to the j-th product. Returns: list of list of int: Predicted n x n matrix where B[i][j] is the predicted rating by user i for product j. pass # Test cases def test_predict_ratings(): assert predict_ratings([[5, 3, 4], [3, 2, 1], [4, 4, 5]]) == [[4, 4, 4], [2, 2, 2], [4, 4, 4]] assert predict_ratings([[1, 1, 1], [5, 5, 5], [3, 3, 3]]) == [[1, 1, 1], [5, 5, 5], [3, 3, 3]] assert predict_ratings([[2, 2], [4, 4]]) == [[2, 2], [4, 4]] assert predict_ratings([[1]]) == [[1]] assert predict_ratings([[5, 3], [3, 5]]) == [[4, 4], [4, 4]] def test_various_dimensions(): assert predict_ratings([[4]]) == [[4]] assert predict_ratings([[2, 3], [4, 5]]) == [[2, 2], [4, 4]] assert predict_ratings([[1, 2, 3, 4], [5, 4, 3, 2], [3, 2, 1, 5], [4, 3, 2, 1]]) == [[2, 2, 2, 2], [3, 3, 3, 3], [2, 2, 2, 2], [2, 2, 2, 2]]","solution":"def predict_ratings(matrix): Predict ratings based on average user ratings. Args: matrix (list of list of int): n x n matrix where A[i][j] is the rating given by the i-th user to the j-th product. Returns: list of list of int: Predicted n x n matrix where B[i][j] is the predicted rating by user i for product j. n = len(matrix) averages = [sum(row) // n for row in matrix] predicted_matrix = [[averages[i]] * n for i in range(n)] return predicted_matrix"},{"question":"def min_deletions_palindrome(s: str) -> int: Returns the minimum number of deletions required to make the string a palindrome. >>> min_deletions_palindrome(\\"abcb\\") 1 >>> min_deletions_palindrome(\\"abcdef\\") 5 >>> min_deletions_palindrome(\\"aab\\") 1 >>> min_deletions_palindrome(\\"\\") 0 >>> min_deletions_palindrome(\\"a\\") 0 >>> min_deletions_palindrome(\\"racecar\\") 0 >>> min_deletions_palindrome(\\"aaabbb\\") 3","solution":"def min_deletions_palindrome(s: str) -> int: Returns the minimum number of deletions required to make the string a palindrome. n = len(s) # Create a reverse of string s rev_s = s[::-1] # Create a table to store results of subproblems dp = [[0] * (n + 1) for _ in range(n + 1)] # Build the table for i in range(1, n + 1): for j in range(1, n + 1): if s[i - 1] == rev_s[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # Length of longest palindromic subsequence lps_len = dp[n][n] # Minimum number of deletions return n - lps_len"},{"question":"def min_trips(n: int, W: int, weights: List[int]) -> int: Returns the minimum number of trips required to deliver all the packages. Args: n (int): Number of packages. W (int): Maximum weight capacity of the truck in one trip. weights (list of int): List of package weights. Returns: int: Minimum number of trips required. >>> min_trips(5, 10, [2, 3, 8, 6, 5]) 3 >>> min_trips(1, 10, [10]) 1 >>> min_trips(3, 10, [2, 3, 5]) 1 >>> min_trips(3, 2, [2, 2, 2]) 3 >>> min_trips(6, 10, [9, 2, 3, 8, 1, 6]) 3","solution":"def min_trips(n, W, weights): Returns the minimum number of trips required to deliver all the packages. Args: n (int): Number of packages. W (int): Maximum weight capacity of the truck in one trip. weights (list of int): List of package weights. Returns: int: Minimum number of trips required. # Sort weights in descending order weights.sort(reverse=True) trips = 0 used = [False] * n # To mark packages already included in trips for i in range(n): if not used[i]: current_weight = weights[i] used[i] = True for j in range(i + 1, n): if not used[j] and current_weight + weights[j] <= W: current_weight += weights[j] used[j] = True trips += 1 return trips"},{"question":"def height_difference_matrix(n: int, heights: List[int]) -> List[List[int]]: Returns an n x n matrix containing the absolute height differences between each pair of tree species. :param n: int - number of tree species discovered :param heights: list of int - heights of the tree species discovered :return: list of list of int - n x n matrix of height differences >>> height_difference_matrix(1, [500]) == [[0]] >>> height_difference_matrix(2, [1000, 1500]) == [ [0, 500], [500, 0] ] >>> height_difference_matrix(3, [1000, 1500, 1200]) == [ [0, 500, 200], [500, 0, 300], [200, 300, 0] ] >>> height_difference_matrix(4, [200, 400, 600, 800]) == [ [0, 200, 400, 600], [200, 0, 200, 400], [400, 200, 0, 200], [600, 400, 200, 0] ] >>> height_difference_matrix(3, [300, 600, 450]) == [ [0, 300, 150], [300, 0, 150], [150, 150, 0] ]","solution":"def height_difference_matrix(n, heights): Returns an n x n matrix containing the absolute height differences between each pair of tree species. :param n: int - number of tree species discovered :param heights: list of int - heights of the tree species discovered :return: list of list of int - n x n matrix of height differences matrix = [] for i in range(n): row = [] for j in range(n): row.append(abs(heights[i] - heights[j])) matrix.append(row) return matrix"},{"question":"from typing import List def longest_common_subsequence(dna_sequences: List[str]) -> str: Determine the longest common subsequence (LCS) among multiple DNA sequences. >>> longest_common_subsequence([\\"AGGTAB\\", \\"GXTXAYB\\", \\"AGGTXAB\\"]) \\"GTAB\\" >>> longest_common_subsequence([\\"ACGT\\", \\"CGTA\\", \\"GTAC\\"]) \\"AC\\" or \\"GT\\" pass def test_lcs_example_1(): assert longest_common_subsequence([\\"AGGTAB\\", \\"GXTXAYB\\", \\"AGGTXAB\\"]) == \\"GTAB\\" def test_lcs_example_2(): result = longest_common_subsequence([\\"ACGT\\", \\"CGTA\\", \\"GTAC\\"]) assert result in {\\"AC\\", \\"GT\\"} def test_lcs_single_char(): assert longest_common_subsequence([\\"A\\", \\"A\\", \\"A\\"]) == \\"A\\" def test_lcs_no_common(): assert longest_common_subsequence([\\"A\\", \\"C\\", \\"G\\", \\"T\\"]) == \\"\\" def test_lcs_large_example(): seqs = [\\"A\\"*50, \\"A\\"*50, \\"A\\"*50] assert longest_common_subsequence(seqs) == \\"A\\" * 50 def test_lcs_partial_match(): assert longest_common_subsequence([\\"AGGTAB\\", \\"AGGXAB\\", \\"AGGTXYAB\\"]) == \\"AGGAB\\" def test_lcs_all_diff(): assert longest_common_subsequence([\\"AAAA\\", \\"CCCC\\", \\"GGGG\\", \\"TTTT\\"]) == \\"\\" def test_lcs_some_common(): assert longest_common_subsequence([\\"ACGT\\", \\"TGCA\\", \\"CAGT\\"]) == \\"A\\" def test_lcs_dual_sequence(): assert longest_common_subsequence([\\"ABC\\", \\"AC\\"]) == \\"AC\\" def test_lcs_with_empty(): assert longest_common_subsequence([]) == \\"\\"","solution":"from typing import List def longest_common_subsequence(dna_sequences: List[str]) -> str: if not dna_sequences: return \\"\\" # Function to find LCS of two sequences def lcs(a, b): m, n = len(a), len(b) dp = [[\\"\\" for _ in range(n+1)] for _ in range(m+1)] for i in range(1, m+1): for j in range(1, n+1): if a[i-1] == b[j-1]: dp[i][j] = dp[i-1][j-1] + a[i-1] else: dp[i][j] = max(dp[i-1][j], dp[i][j-1], key=len) return dp[m][n] # Start with the first DNA sequence lcs_res = dna_sequences[0] # Iteratively find LCS with each next DNA sequence in the list for seq in dna_sequences[1:]: lcs_res = lcs(lcs_res, seq) if not lcs_res: # Early stopping if LCS becomes empty break return lcs_res"},{"question":"def longest_substring_with_chars(s: str, p: str) -> int: Returns the length of the longest substring of s that contains only characters present in p. Parameters: s (str): The input string. p (str): The string containing the allowed characters. Returns: int: The length of the longest substring meeting the criteria. >>> longest_substring_with_chars(\\"abcdef\\", \\"abc\\") 3 >>> longest_substring_with_chars(\\"aaaaa\\", \\"a\\") 5 >>> longest_substring_with_chars(\\"abcde\\", \\"xyz\\") 0 def test_longest_substring_with_chars(): assert longest_substring_with_chars(\\"abcdef\\", \\"abc\\") == 3 assert longest_substring_with_chars(\\"abcdeffedcba\\", \\"abc\\") == 3 assert longest_substring_with_chars(\\"aaaaa\\", \\"a\\") == 5 assert longest_substring_with_chars(\\"abcde\\", \\"xyz\\") == 0 assert longest_substring_with_chars(\\"xyzabc\\", \\"xyz\\") == 3 assert longest_substring_with_chars(\\"abcdxyzabcd\\", \\"abcd\\") == 4 assert longest_substring_with_chars(\\"aabbcc\\", \\"abc\\") == 6 assert longest_substring_with_chars(\\"aabba\\", \\"ab\\") == 5 assert longest_substring_with_chars(\\"\\", \\"abc\\") == 0 assert longest_substring_with_chars(\\"abc\\", \\"\\") == 0 test_longest_substring_with_chars()","solution":"def longest_substring_with_chars(s, p): Returns the length of the longest substring of s that contains only characters present in p. Parameters: s (str): The input string. p (str): The string containing the allowed characters. Returns: int: The length of the longest substring meeting the criteria. allowed_chars = set(p) max_length = 0 current_length = 0 for char in s: if char in allowed_chars: current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 return max_length"},{"question":"def process_commands(n: int, commands: List[str]) -> str: Simulate and track the movements of characters on a grid based on commands. Args: n : int : Size of the grid (n x n) commands : List[str] : List of commands to process Returns: str : Final positions of all characters or \\"No characters remaining\\" >>> process_commands(5, [\\"Add Alice 1 2\\", \\"Add Bob 0 0\\", \\"Move Alice right 3\\", \\"Move Bob down 6\\", \\"Remove Alice\\"]) == \\"Bob: (0, 0)\\" >>> process_commands(3, [\\"Add Clara 1 1\\", \\"Move Clara left 2\\", \\"Move Clara up 2\\"]) == \\"Clara: (1, 1)\\" >>> process_commands(4, [\\"Add David 2 2\\", \\"Move David right 1\\", \\"Remove David\\"]) == \\"No characters remaining\\" >>> process_commands(6, [\\"Add Eve 0 0\\", \\"Move Eve down 3\\", \\"Move Eve right 4\\", \\"Add Frank 2 2\\", \\"Move Frank up 1\\", \\"Move Frank left 2\\"]) == \\"Eve: (4, 3)nFrank: (0, 1)\\" >>> process_commands(10, []) == \\"No characters remaining\\"","solution":"def process_commands(n, commands): grid = {} for command in commands: parts = command.split() action = parts[0] if action == 'Add': name = parts[1] x = int(parts[2]) y = int(parts[3]) grid[name] = (x, y) elif action == 'Remove': name = parts[1] if name in grid: del grid[name] elif action == 'Move': name = parts[1] direction = parts[2] steps = int(parts[3]) if name in grid: x, y = grid[name] if direction == 'up': new_x = x new_y = y - steps elif direction == 'down': new_x = x new_y = y + steps elif direction == 'left': new_x = x - steps new_y = y elif direction == 'right': new_x = x + steps new_y = y if 0 <= new_x < n and 0 <= new_y < n: grid[name] = (new_x, new_y) if not grid: return \\"No characters remaining\\" result = [] for name in sorted(grid.keys()): x, y = grid[name] result.append(f\\"{name}: ({x}, {y})\\") return 'n'.join(result)"},{"question":"def circle_centers(n: int): Returns the coordinates of the circle centers arranged in a regular n-gon pattern. Each circle should have a radius of 1 unit. Args: n (int): The number of circles to arrange in the pattern. Returns: List[Tuple[float, float]]: A list of tuples representing the coordinates of the centers of the circles. >>> circle_centers(3) [(1.000000000, 0.000000000), (-0.500000000, 0.866025404), (-0.500000000, -0.866025404)] >>> circle_centers(4) [(1.000000000, 0.000000000), (0.000000000, 1.000000000), (-1.000000000, 0.000000000), (0.000000000, -1.000000000)] >>> circle_centers(5) [(1.000000000, 0.000000000), (0.309016994, 0.951056516), (-0.809016994, 0.587785252), (-0.809016994, -0.587785252), (0.309016994, -0.951056516)] pass","solution":"import math def circle_centers(n): Returns the coordinates of the circle centers arranged in a regular n-gon pattern. result = [] radius = 1 # unit radius for i in range(n): angle = 2 * math.pi * i / n x = math.cos(angle) * radius y = math.sin(angle) * radius result.append((x, y)) return result"},{"question":"from typing import List, Tuple def compare_directories(old_version: List[str], new_version: List[str]) -> Tuple[List[str], List[str], List[str]]: Compare two versions of a directory tree to identify the files that have been added, removed, or changed. Args: old_version (List[str]): List of strings representing the old version of the directory. new_version (List[str]): List of strings representing the new version of the directory. Returns: Tuple[List[str], List[str], List[str]]: - List of files added in the new version. - List of files removed in the new version. - List of files that have changed content between the old and new version. Example: >>> old_version = [\\"docs/readme.txt\\", \\"src/main.py\\", \\"src/utils.py\\", \\"img/logo.png\\"] >>> new_version = [\\"docs/readme.txt[def456]\\", \\"src/main.py\\", \\"src/new_module.py\\", \\"img/logo.png\\"] >>> compare_directories(old_version, new_version) ([\\"src/new_module.py\\"], [\\"src/utils.py\\"], [\\"docs/readme.txt\\"]) def test_compare_directories(): old_version = [ \\"docs/readme.txt\\", \\"src/main.py\\", \\"src/utils.py\\", \\"img/logo.png\\" ] new_version = [ \\"docs/readme.txt[def456]\\", \\"src/main.py\\", \\"src/new_module.py\\", \\"img/logo.png\\" ] added_files, removed_files, changed_files = compare_directories(old_version, new_version) assert sorted(added_files) == sorted([\\"src/new_module.py\\"]) assert sorted(removed_files) == sorted([\\"src/utils.py\\"]) assert sorted(changed_files) == sorted([\\"docs/readme.txt\\"]) def test_compare_directories_with_no_changes(): old_version = [ \\"docs/readme.txt\\", \\"src/main.py\\", \\"src/utils.py\\", \\"img/logo.png\\" ] new_version = [ \\"docs/readme.txt\\", \\"src/main.py\\", \\"src/utils.py\\", \\"img/logo.png\\" ] added_files, removed_files, changed_files = compare_directories(old_version, new_version) assert added_files == [] assert removed_files == [] assert changed_files == [] def test_compare_directories_with_only_additions(): old_version = [ \\"docs/readme.txt\\" ] new_version = [ \\"docs/readme.txt\\", \\"src/main.py\\", \\"img/logo.png\\" ] added_files, removed_files, changed_files = compare_directories(old_version, new_version) assert sorted(added_files) == sorted([\\"src/main.py\\", \\"img/logo.png\\"]) assert removed_files == [] assert changed_files == [] def test_compare_directories_with_only_removals(): old_version = [ \\"docs/readme.txt\\", \\"src/main.py\\", \\"img/logo.png\\" ] new_version = [ \\"docs/readme.txt\\" ] added_files, removed_files, changed_files = compare_directories(old_version, new_version) assert added_files == [] assert sorted(removed_files) == sorted([\\"src/main.py\\", \\"img/logo.png\\"]) assert changed_files == [] def test_compare_directories_with_changed_files(): old_version = [ \\"docs/readme.txt\\", \\"src/main.py\\", \\"img/logo.png\\" ] new_version = [ \\"docs/readme.txt[def456]\\", \\"src/main.py[c5623]\\", \\"img/logo.png\\" ] added_files, removed_files, changed_files = compare_directories(old_version, new_version) assert added_files == [] assert removed_files == [] assert sorted(changed_files) == sorted([\\"docs/readme.txt\\", \\"src/main.py\\"])","solution":"from typing import List, Tuple def compare_directories(old_version: List[str], new_version: List[str]) -> Tuple[List[str], List[str], List[str]]: old_version_files = {filepath.split('[')[0] for filepath in old_version} new_version_files = {filepath.split('[')[0] for filepath in new_version} added_files = list(new_version_files - old_version_files) removed_files = list(old_version_files - new_version_files) old_version_without_hash = {filepath.split('[')[0]: filepath for filepath in old_version} new_version_without_hash = {filepath.split('[')[0]: filepath for filepath in new_version} changed_files = [ filepath for filepath in old_version_files & new_version_files if old_version_without_hash[filepath] != new_version_without_hash[filepath] ] return added_files, removed_files, changed_files"},{"question":"def find_min_difference(n: int, k: int, arr: List[int]) -> int: Determine the minimum possible difference between the maximum and minimum values of any k consecutive canvases. >>> find_min_difference(3, 3, [1, 3, 4]) 3 >>> find_min_difference(1, 1, [7]) 0 >>> find_min_difference(2, 2, [1, 1000]) 999 from typing import List def test_example_case_1(): assert find_min_difference(3, 3, [1, 3, 4]) == 3 def test_example_case_2(): assert find_min_difference(1, 1, [7]) == 0 def test_example_case_3(): assert find_min_difference(2, 2, [1, 1000]) == 999 def test_single_canvas(): assert find_min_difference(5, 1, [5, 14, 25, 98, 123]) == 0 def test_min_diff_between_large_k(): assert find_min_difference(6, 3, [1, 2, 4, 7, 10, 12]) == 3 def test_large_numbers(): assert find_min_difference(5, 2, [1000000000, 999999999, 500000000, 400000000, 300000000]) == 1 def test_alternating_numbers(): arr = [x if x % 2 == 0 else 1000 - x for x in range(1, 11)] assert find_min_difference(10, 5, arr) == 8 def test_all_same_numbers(): assert find_min_difference(5, 3, [10, 10, 10, 10, 10]) == 0","solution":"def find_min_difference(n, k, arr): Function to find the minimum possible difference between the maximum and minimum values of any k consecutive canvases. if k > n: return -1 # Invalid input as k should be less than or equal to n # Sort the array to make consecutive subsequences contain minimum differences arr.sort() min_diff = float('inf') for i in range(n - k + 1): current_diff = arr[i + k - 1] - arr[i] if current_diff < min_diff: min_diff = current_diff return min_diff"},{"question":"def min_operations_to_unify_string(s: str) -> int: Returns the minimum number of operations required to make all characters in the string 's' the same. Parameters: s (str): a string consisting of lowercase Latin letters Returns: int: the minimum number of operations >>> min_operations_to_unify_string('abac') 2 >>> min_operations_to_unify_string('aaaa') 0 >>> min_operations_to_unify_string('abcabcabc') 6 >>> min_operations_to_unify_string('aabbb') 2 >>> min_operations_to_unify_string('a' * 50000 + 'b' * 50000) 50000 >>> min_operations_to_unify_string('aabbbcc') 4","solution":"def min_operations_to_unify_string(s): Returns the minimum number of operations required to make all characters in the string 's' the same. Parameters: s (str): a string consisting of lowercase Latin letters Returns: int: the minimum number of operations from collections import Counter char_count = Counter(s) max_frequency = max(char_count.values()) return len(s) - max_frequency"},{"question":"from typing import List def min_subarray_length(nums: List[int], target: int) -> int: Find the minimum length of a contiguous subarray of which the sum is greater than or equal to the target. Parameters: nums (list of int): The list of integers. target (int): The target sum. Returns: int: The minimum length of the subarray, or 0 if no such subarray exists. >>> min_subarray_length([2, 3, 1, 2, 4, 3], 7) 2 >>> min_subarray_length([1, 4, 4], 4) 1 >>> min_subarray_length([1, 1, 1, 1, 1, 1, 1, 1], 11) 0 >>> min_subarray_length([1, 2, 3, 4, 5], 11) 3","solution":"def min_subarray_length(nums, target): Find the minimum length of a contiguous subarray of which the sum is greater than or equal to the target. Parameters: nums (list of int): The list of integers. target (int): The target sum. Returns: int: The minimum length of the subarray, or 0 if no such subarray exists. n = len(nums) min_length = float('inf') current_sum = 0 start = 0 for end in range(n): current_sum += nums[end] while current_sum >= target: min_length = min(min_length, end - start + 1) current_sum -= nums[start] start += 1 return 0 if min_length == float('inf') else min_length"},{"question":"def count_distinct_integers(arr): Milo the Reindeer loves eating special Christmas cookies. However, these cookies are magical and their quantities follow a unique rule. You are given an array of integers where each element represents a number of cookies in different boxes. The array was originally sorted in non-decreasing order, and then some elements were duplicated multiple times. You need to find the number of distinct integers in this array before the duplication happened, as well as the number of each distinct integer. The function should return: - An integer representing the number of distinct integers. - A list of tuples where each tuple contains a distinct integer and its count. Parameters: arr (list of int): The list of integers representing the number of cookies in different boxes. Returns: (int, list of tuples): A tuple containing the number of distinct integers and a list of tuples where each tuple contains a distinct integer and its count. Examples: >>> count_distinct_integers([2, 2, 2, 3, 3, 5, 5, 5, 5, 6]) (4, [(2, 3), (3, 2), (5, 4), (6, 1)]) >>> count_distinct_integers([4, 4, 4, 4, 4]) (1, [(4, 5)]) >>> count_distinct_integers([1, 2, 3, 4, 5]) (5, [(1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]) >>> count_distinct_integers([7]) (1, [(7, 1)]) >>> count_distinct_integers([9, 1, 1, 2, 8, 8, 2, 3, 3]) (5, [(9, 1), (1, 2), (2, 2), (8, 2), (3, 2)])","solution":"def count_distinct_integers(arr): Returns the number of distinct integers and their respective counts in the input array. Parameters: arr (list of int): The list of integers representing the number of cookies in different boxes. Returns: (int, list of tuples): A tuple containing the number of distinct integers and a list of tuples where each tuple contains a distinct integer and its count. from collections import Counter # Count the occurrences of each number in the array counter = Counter(arr) # Extract distinct integers and their counts preserving the order of first occurrence distinct_integers = list(counter.items()) # Number of distinct integers m = len(distinct_integers) return (m, distinct_integers)"},{"question":"def max_non_overlapping_intervals(intervals: List[Tuple[int, int]]) -> int: Returns the maximum number of non-overlapping intervals. >>> max_non_overlapping_intervals([(1, 3), (2, 4), (3, 5), (1, 2)]) 2 >>> max_non_overlapping_intervals([(1, 2)]) 1 >>> max_non_overlapping_intervals([(1, 2), (2, 3)]) 2 >>> max_non_overlapping_intervals([(1, 3), (2, 4)]) 1 >>> max_non_overlapping_intervals([(1, 4), (2, 3), (3, 5), (0, 6), (5, 7)]) 3 >>> max_non_overlapping_intervals([(1, 1000000000), (2, 3), (3, 4)]) 2 >>> max_non_overlapping_intervals([(5, 10), (1, 15), (3, 8)]) 1 def process_input(input_string: str) -> int: Process input string and returns the maximum number of non-overlapping intervals. >>> process_input(\\"4n1 3n2 4n3 5n1 2\\") 2 >>> process_input(\\"1n1 2\\") 1 >>> process_input(\\"2n1 2n2 3\\") 2 >>> process_input(\\"2n1 3n2 4\\") 1 >>> process_input(\\"5n1 4n2 3n3 5n0 6n5 7\\") 3 >>> process_input(\\"3n1 1000000000n2 3n3 4\\") 2 >>> process_input(\\"3n5 10n1 15n3 8\\") 1","solution":"def max_non_overlapping_intervals(intervals): Returns the maximum number of non-overlapping intervals. # Sort intervals based on end time intervals.sort(key=lambda x: x[1]) count = 0 end_time = float('-inf') for interval in intervals: if interval[0] >= end_time: count += 1 end_time = interval[1] return count def process_input(input_string): input_lines = input_string.strip().split('n') n = int(input_lines[0]) intervals = [tuple(map(int, line.split())) for line in input_lines[1:]] return max_non_overlapping_intervals(intervals)"},{"question":"def max_area(n: int, heights: List[int]) -> int: Calculate the maximum rectangular area possible using the consecutive buildings. Parameters: n (int): The number of buildings. heights (List[int]): A list of integers of length n, where each integer represents the height of a building. Returns: int: The maximum area of a rectangle formed by consecutive buildings. >>> max_area(6, [2, 1, 5, 6, 2, 3]) 10 >>> max_area(5, [5, 4, 3, 2, 1]) 9 >>> max_area(7, [6, 2, 5, 4, 5, 1, 6]) 12 >>> max_area(1, [1]) 1 >>> max_area(2, [2, 2]) 4 >>> max_area(3, [1, 1, 1]) 3 >>> max_area(4, [2, 4, 2, 4]) 8","solution":"def max_area(n, heights): Calculates the maximum rectangular area possible using the consecutive buildings. Parameters: n (int): The number of buildings. heights (list): A list of integers of length n, where each integer represents the height of a building. Returns: int: The maximum area of a rectangle formed by consecutive buildings. stack = [] max_area = 0 index = 0 while index < n: if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def final_position(commands: str) -> tuple: Determines the final position of the robot after executing the given sequence of commands including the additional north move. Args: commands (str): A sequence of the initial commands the robot must follow. Returns: tuple: The final coordinates of the robot (x, y). Examples: >>> final_position(\\"ENSES\\") (2, 0) >>> final_position(\\"\\") (0, 1) >>> final_position(\\"NNNN\\") (0, 5) >>> final_position(\\"SSSS\\") (0, -3) >>> final_position(\\"EEWEWNSSW\\") (0, 0) >>> final_position(\\"NESWNESWNESW\\") (0, 1) # Implementation here","solution":"def final_position(commands): Determines the final position of the robot after executing the given sequence of commands including the additional north move. Args: commands (str): A sequence of the initial commands the robot must follow. Returns: tuple: The final coordinates of the robot (x, y). x, y = 0, 0 for char in commands: if char == 'N': y += 1 elif char == 'S': y -= 1 elif char == 'E': x += 1 elif char == 'W': x -= 1 # Adding the additional move north ('N') y += 1 return x, y"},{"question":"def find_groups_of_friends(n: int, m: int, edges: List[Tuple[int, int]]) -> int: Count the number of distinct groups of friends in a graph. Parameters: n (int): The number of nodes. m (int): The number of edges. edges (List[Tuple[int, int]]): The list of edges. Returns: int: The number of distinct groups of friends. >>> find_groups_of_friends(5, 3, [(1, 2), (2, 3), (4, 5)]) == 2 >>> find_groups_of_friends(4, 0, []) == 4 >>> find_groups_of_friends(4, 3, [(1, 2), (2, 3), (3, 4)]) == 1 >>> find_groups_of_friends(6, 4, [(1, 2), (2, 3), (4, 5), (4, 6)]) == 2 >>> find_groups_of_friends(1, 0, []) == 1 >>> find_groups_of_friends(2, 0, []) == 2","solution":"def find_groups_of_friends(n, m, edges): from collections import defaultdict, deque def bfs(node, adj_list, visited): queue = deque([node]) visited[node] = True while queue: u = queue.popleft() for v in adj_list[u]: if not visited[v]: visited[v] = True queue.append(v) # Initialize adjacency list and visited list adj_list = defaultdict(list) visited = [False] * (n + 1) # Populate adjacency list for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) # Count distinct groups via BFS num_groups = 0 for node in range(1, n + 1): if not visited[node]: bfs(node, adj_list, visited) num_groups += 1 return num_groups"},{"question":"def min_moves_to_reach_destination(r1: int, c1: int, r2: int, c2: int) -> int: Returns the minimum number of moves for a regular checkers piece to move from (r1, c1) to (r2, c2), or -1 if the destination cannot be reached by a regular piece. >>> min_moves_to_reach_destination(1, 1, 4, 4) 3 >>> min_moves_to_reach_destination(3, 5, 6, 2) 3 >>> min_moves_to_reach_destination(1, 1, 2, 3) -1 >>> min_moves_to_reach_destination(4, 4, 7, 5) -1 >>> min_moves_to_reach_destination(1, 1, 2, 2) 1 >>> min_moves_to_reach_destination(3, 6, 4, 5) 1 >>> min_moves_to_reach_destination(1, 1, 6, 6) 5 >>> min_moves_to_reach_destination(2, 3, 5, 6) 3","solution":"def min_moves_to_reach_destination(r1, c1, r2, c2): Returns the minimum number of moves for a regular checkers piece to move from (r1, c1) to (r2, c2), or -1 if the destination cannot be reached by a regular piece. # Check if the destination field is reachable (same diagonal path) if abs(r2 - r1) == abs(c2 - c1): # Since the piece moves diagonally one step at a time, # the number of moves is the same as the distance in either row or column direction. return abs(r2 - r1) else: # The destination is not reachable if it's not on the same diagonal. return -1"},{"question":"def count_clusters(grid: List[List[str]]) -> int: Given a grid of 0s and 1s, count the number of distinct clusters of connected 1s. Args: grid (list of list of str): The grid represented as a list of list of characters '0' and '1'. Returns: int: number of distinct clusters >>> count_clusters([ ... [\\"1\\", \\"1\\", \\"0\\", \\"0\\", \\"0\\"], ... [\\"1\\", \\"1\\", \\"0\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"1\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"0\\", \\"1\\", \\"1\\"] ... ]) 3 >>> count_clusters([ ... [\\"1\\", \\"0\\", \\"1\\", \\"0\\", \\"1\\"], ... [\\"0\\", \\"1\\", \\"0\\", \\"1\\", \\"0\\"], ... [\\"1\\", \\"0\\", \\"1\\", \\"0\\", \\"1\\"], ... [\\"0\\", \\"1\\", \\"0\\", \\"1\\", \\"0\\"] ... ]) 10","solution":"def count_clusters(grid): Given a grid of 0s and 1s, count the number of distinct clusters of connected 1s. Args: grid (list of list of str): The grid represented as a list of list of characters '0' and '1'. Returns: int: number of distinct clusters def dfs(x, y): if x < 0 or x >= m or y < 0 or y >= n or grid[x][y] == '0': return grid[x][y] = '0' # Mark as visited # Check all 4 directions dfs(x+1, y) dfs(x-1, y) dfs(x, y+1) dfs(x, y-1) m = len(grid) n = len(grid[0]) clusters = 0 for i in range(m): for j in range(n): if grid[i][j] == '1': dfs(i, j) clusters += 1 return clusters"},{"question":"import heapq from typing import List, Tuple def shortest_path_length(m: int, n: int, s: int, t: int, streets: List[Tuple[int, int, int]]) -> int: Calculate the shortest path length from the starting intersection s to the ending intersection t. >>> shortest_path_length(5, 7, 1, 5, [(1, 2, 10), (1, 3, 5), (2, 3, 2), (2, 4, 1), (3, 4, 9), (3, 5, 2), (4, 5, 4)]) == 7 >>> shortest_path_length(3, 2, 1, 3, [(1, 2, 5), (2, 1, 5)]) == -1 >>> shortest_path_length(2, 1, 1, 2, [(1, 2, 5)]) == 5 >>> shortest_path_length(3, 3, 1, 1, [(1, 2, 5), (2, 3, 7), (3, 1, 9)]) == 0 >>> shortest_path_length(6, 7, 1, 6, [(1, 2, 2), (1, 3, 5), (2, 3, 1), (2, 4, 2), (3, 5, 3), (4, 6, 1), (5, 6, 2)]) == 5","solution":"import heapq def shortest_path_length(m, n, s, t, streets): graph = {i: [] for i in range(1, m + 1)} for a, b, l in streets: graph[a].append((b, l)) distances = {i: float('inf') for i in range(1, m + 1)} distances[s] = 0 priority_queue = [(0, s)] heapq.heapify(priority_queue) while priority_queue: current_dist, current_node = heapq.heappop(priority_queue) if current_node == t: return current_dist if current_dist > distances[current_node]: continue for neighbor, length in graph[current_node]: distance = current_dist + length if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return -1"},{"question":"def can_partition(nums: List[int]) -> bool: Determines if the list can be partitioned into two subsets such that the sums of the elements in both subsets are equal. >>> can_partition([1, 5, 11, 5]) True >>> can_partition([1, 2, 3, 5]) False >>> can_partition([1]) False >>> can_partition([1, 1]) True >>> can_partition([1, 2]) False >>> can_partition([1, 2, 3, 4, 5, 6, 7]) True >>> can_partition([2, 2, 2, 2]) True >>> can_partition([0, 0, 0, 0]) True","solution":"def can_partition(nums): Determines if the list can be partitioned into two subsets such that the sums of the elements in both subsets are equal. total_sum = sum(nums) # If total sum is odd, it's not possible to partition into two equal subsets if total_sum % 2 != 0: return False target = total_sum // 2 n = len(nums) # Create a DP array to store whether a sum is achievable dp = [False] * (target + 1) dp[0] = True for num in nums: for i in range(target, num - 1, -1): if dp[i - num]: dp[i] = True return dp[target]"},{"question":"def rob_houses(n: int, money: List[int]) -> int: Determine the maximum amount of money the robber can steal without robbing any two adjacent houses. Parameters: n (int): The number of houses. money (list of int): A list containing the amount of money each house has. Returns: int: The maximum amount of money the robber can steal. >>> rob_houses(4, [1, 2, 3, 1]) 4 >>> rob_houses(5, [2, 7, 9, 3, 1]) 12 >>> rob_houses(1, [5]) 5 >>> rob_houses(0, []) 0 >>> rob_houses(2, [10, 20]) 20 >>> rob_houses(3, [5, 5, 5]) 10 >>> rob_houses(6, [2, 10, 3, 12, 1, 20]) 42","solution":"def rob_houses(n, money): Determine the maximum amount of money the robber can steal without robbing any two adjacent houses. Parameters: n (int): The number of houses. money (list of int): A list containing the amount of money each house has. Returns: int: The maximum amount of money the robber can steal. if n == 0: return 0 if n == 1: return money[0] dp = [0] * n # Base cases dp[0] = money[0] dp[1] = max(money[0], money[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + money[i]) return dp[n-1]"},{"question":"def longest_continuous_sighting_period(n: int, timestamps: List[int]) -> int: Determine the length of the longest continuous period where there are no gaps between the sightings. >>> longest_continuous_sighting_period(6, [5, 2, 3, 1, 6, 4]) 6 >>> longest_continuous_sighting_period(5, [2, 5, 7, 8, 11]) 2 from typing import List def test_example_1(): assert longest_continuous_sighting_period(6, [5, 2, 3, 1, 6, 4]) == 6 def test_example_2(): assert longest_continuous_sighting_period(5, [2, 5, 7, 8, 11]) == 2 def test_single_sighting(): assert longest_continuous_sighting_period(1, [100]) == 1 def test_no_sightings(): assert longest_continuous_sighting_period(0, []) == 0 def test_large_gap(): assert longest_continuous_sighting_period(5, [1, 2, 8, 9, 10]) == 3 def test_multiple_intervals(): assert longest_continuous_sighting_period(7, [1, 2, 5, 6, 7, 9, 10]) == 3 def test_unsorted_input(): assert longest_continuous_sighting_period(6, [4, 2, 1, 5, 3, 6]) == 6","solution":"def longest_continuous_sighting_period(n, timestamps): if n == 0: return 0 timestamps = sorted(set(timestamps)) longest_period = 1 current_period = 1 for i in range(1, len(timestamps)): if timestamps[i] == timestamps[i - 1] + 1: current_period += 1 longest_period = max(longest_period, current_period) else: current_period = 1 return longest_period"},{"question":"def min_sensors(n: int, m: int, d: int) -> int: Returns the minimum number of sensors required to cover an n x m grid with sensors that have detection range d in all 8 directions. >>> min_sensors(4, 4, 1) 4 >>> min_sensors(5, 5, 2) 4 >>> min_sensors(1, 1, 1) 1 >>> min_sensors(10, 10, 3) 9 >>> min_sensors(5, 5, 10) 1 >>> min_sensors(5, 10, 2) 8","solution":"def min_sensors(n: int, m: int, d: int) -> int: Returns the minimum number of sensors required to cover an n x m grid with sensors that have detection range d in all 8 directions. # The distance of range + 1 because the current cell is also covered step = d + 1 # Calculate the number of sensors required in each dimension sensors_in_rows = (n + step - 1) // step sensors_in_columns = (m + step - 1) // step # The total number of sensors is the product of sensors in rows and columns return sensors_in_rows * sensors_in_columns"},{"question":"def find_smallest_and_largest(x: int, y: int, z: int) -> str: Function to find the smallest and largest integer among the three given integers. If all three integers are the same, it returns only that single integer. >>> find_smallest_and_largest(1, 2, 3) '1 3' >>> find_smallest_and_largest(100, 100, 100) '100' >>> find_smallest_and_largest(7, 7, 8) '7 8' >>> find_smallest_and_largest(3, 1, 2) '1 3'","solution":"def find_smallest_and_largest(x, y, z): Function to find the smallest and largest integer among the three given integers. If all three integers are the same, it returns only that single integer. if x == y == z: return f\\"{x}\\" smallest = min(x, y, z) largest = max(x, y, z) return f\\"{smallest} {largest}\\""},{"question":"def minimum_ferry_trips(n: int, W: int, weights: List[int]) -> int: Returns the minimum number of ferry trips required to transport all people given the weights of the people and the maximum weight limit of the ferry. :param n: int - number of people :param W: int - maximum weight limit of the ferry :param weights: list of int - list of weights of the people :return: int - minimum number of ferry trips >>> minimum_ferry_trips(4, 100, [70, 50, 80, 30]) 3 >>> minimum_ferry_trips(3, 120, [60, 50, 70]) 2 >>> minimum_ferry_trips(5, 200, [120, 80, 150, 30, 90]) 3 >>> minimum_ferry_trips(3, 50, [60, 70, 80]) 3 >>> minimum_ferry_trips(4, 100, [40, 40, 40, 40]) 2 >>> minimum_ferry_trips(1, 100, [50]) 1 >>> minimum_ferry_trips(2, 120, [70, 90]) 2 pass","solution":"def minimum_ferry_trips(n, W, weights): Returns the minimum number of ferry trips required to transport all people given the weights of the people and the maximum weight limit of the ferry. :param n: int - number of people :param W: int - maximum weight limit of the ferry :param weights: list of int - list of weights of the people :return: int - minimum number of ferry trips weights.sort() i, j = 0, n - 1 trips = 0 while i <= j: if weights[i] + weights[j] <= W: i += 1 j -= 1 trips += 1 return trips"},{"question":"from typing import List def organize_plants(heights: List[int]) -> List[int]: Organizes the plant heights in a manner that minimizes the maximum height difference between adjacent plants. >>> organize_plants([10, 1, 12, 5, 7]) == [1, 5, 7, 10, 12] >>> organize_plants([3, 6, 2, 8, 4, 5]) == [2, 3, 4, 5, 6, 8] pass # Your code here # Unit test cases def test_organize_plants_example_1(): assert organize_plants([10, 1, 12, 5, 7]) == [1, 5, 7, 10, 12] def test_organize_plants_example_2(): assert organize_plants([3, 6, 2, 8, 4, 5]) == [2, 3, 4, 5, 6, 8] def test_organize_plants_small_array(): assert organize_plants([3, 1]) == [1, 3] def test_organize_plants_large_differences(): assert organize_plants([100, 1, 50, 25]) == [1, 25, 50, 100] def test_organize_plants_duplicates(): assert organize_plants([3, 3, 2, 2, 1, 1]) == [1, 1, 2, 2, 3, 3] def test_organize_plants_already_sorted(): assert organize_plants([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] def test_organize_plants_reversed(): assert organize_plants([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] def test_organize_plants_with_equal_heights(): assert organize_plants([5, 5, 5, 5, 5]) == [5, 5, 5, 5, 5]","solution":"from typing import List def organize_plants(heights: List[int]) -> List[int]: Organizes the plant heights in a manner that minimizes the maximum height difference between adjacent plants. # Sort the heights to find the optimal arrangement heights.sort() return heights"},{"question":"def trap_water(elevation_map: List[int]) -> int: Calculate the total units of water that can be trapped after raining based on the given elevation map. Parameters: elevation_map (List[int]): A list of integers representing the elevation map. Returns: int: The total units of water that can be trapped. Examples: >>> trap_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap_water([2, 0, 2, 0, 2]) 4 Test Cases: from solution import trap_water def test_trap_water_no_elevation(): assert trap_water([]) == 0 def test_trap_water_single_bar(): assert trap_water([5]) == 0 def test_trap_water_two_bars(): assert trap_water([3, 3]) == 0 def test_trap_water_example_case(): assert trap_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 def test_trap_water_flat_surface(): assert trap_water([2, 2, 2, 2, 2]) == 0 def test_trap_water_multiple_peaks(): assert trap_water([2, 0, 2, 0, 2]) == 4 def test_trap_water_ascending(): assert trap_water([1, 2, 3, 4]) == 0 def test_trap_water_descending(): assert trap_water([4, 3, 2, 1]) == 0","solution":"def trap_water(elevation_map): if not elevation_map: return 0 n = len(elevation_map) left_max = [0] * n right_max = [0] * n # Filling left_max array left_max[0] = elevation_map[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], elevation_map[i]) # Filling right_max array right_max[n - 1] = elevation_map[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], elevation_map[i]) # Calculating the trapped water total_water = 0 for i in range(n): total_water += min(left_max[i], right_max[i]) - elevation_map[i] return total_water"},{"question":"from typing import List, Union def generate_knitting_pattern(N: int, M: int) -> Union[List[int], int]: Generates a knitting pattern such that no two adjacent numbers are the same in the sequence. Args: N (int): Length of the scarf (number of rows). M (int): Range of patterns available (patterns range from 1 to M). Returns: List[int] | int: A sequence of N patterns such that no two adjacent numbers are the same. If not possible, returns -1. Examples: >>> generate_knitting_pattern(5, 3) [1, 2, 1, 2, 1] >>> generate_knitting_pattern(4, 2) [1, 2, 1, 2] >>> generate_knitting_pattern(6, 1) -1 pass def test_generate_knitting_pattern_case_1(): assert generate_knitting_pattern(5, 3) == [1, 2, 1, 2, 1] def test_generate_knitting_pattern_case_2(): assert generate_knitting_pattern(4, 2) == [1, 2, 1, 2] def test_generate_knitting_pattern_case_3(): assert generate_knitting_pattern(6, 1) == -1 def test_generate_knitting_pattern_case_4(): assert generate_knitting_pattern(1, 1) == [1] def test_generate_knitting_pattern_case_5(): assert generate_knitting_pattern(3, 2) == [1, 2, 1] def test_generate_knitting_pattern_case_6(): assert generate_knitting_pattern(10, 5) == [1, 2, 3, 4, 5, 1, 2, 3, 4, 5]","solution":"def generate_knitting_pattern(N, M): if M == 1: return -1 if N > 1 else [1] pattern = [] for i in range(N): pattern.append((i % M) + 1) return pattern"},{"question":"def is_tree(N: int, edges: list) -> bool: Determine if the given undirected graph is a tree. The graph is provided as an edge list, where each edge is represented as a tuple (u, v), indicating an edge between nodes u and v. The function returns True if the graph is a tree, and False otherwise. >>> is_tree(5, [(0, 1), (0, 2), (1, 3), (1, 4)]) True >>> is_tree(5, [(0, 1), (0, 2), (1, 2), (1, 3), (1, 4)]) False >>> is_tree(4, [(0, 1), (1, 2), (1, 3)]) True >>> is_tree(4, [(0, 1), (2, 3)]) False >>> is_tree(1, []) True","solution":"def is_tree(N: int, edges: list) -> bool: from collections import defaultdict, deque if len(edges) != N - 1: # For a tree, edges should be exactly N-1 return False # Create an adjacency list adjacency_list = defaultdict(list) for u, v in edges: adjacency_list[u].append(v) adjacency_list[v].append(u) # Use BFS to check if the graph is connected and has no cycles visited = set() queue = deque([0]) visited.add(0) while queue: node = queue.popleft() for neighbor in adjacency_list[node]: if neighbor in visited: continue visited.add(neighbor) queue.append(neighbor) # The graph is a tree if all nodes are visited and there are no cycles return len(visited) == N"},{"question":"def find_pairs(nums: List[int], k: int) -> int: Finds the number of unique k-diff pairs in nums. Parameters: nums (list of int): List of integers. k (int): The difference value. Returns: int: The number of unique k-diff pairs. >>> find_pairs([1, 7, 5, 9, 2, 12, 3], 2) 4 >>> find_pairs([1, 3, 1, 5, 4], 0) 1 >>> find_pairs([1, 2, 3, 4, 5], -1) 0 >>> find_pairs([], 2) 0 >>> find_pairs([10], 5) 0 >>> find_pairs([4, 4, 4, 4, 4], 0) 1 >>> find_pairs([1, 10000000], 9999999) 1","solution":"def find_pairs(nums, k): Finds the number of unique k-diff pairs in nums. Parameters: nums (list of int): List of integers. k (int): The difference value. Returns: int: The number of unique k-diff pairs. if k < 0: return 0 seen, pairs = set(), set() for num in nums: if (num + k) in seen: pairs.add((num, num + k) if num < num + k else (num + k, num)) if (num - k) in seen: pairs.add((num, num - k) if num < num - k else (num - k, num)) seen.add(num) return len(pairs)"},{"question":"from typing import List, Union, Tuple def divide_list(S: int, n: int, arr: List[int]) -> Union[str, Tuple[str, int, List[int]]]: Given a list of integers, divide the list into the minimum number of contiguous subarrays such that the sum of each subarray is exactly equal to S. Return \\"NO\\" if it is impossible to divide the list in the required manner. Otherwise, return \\"YES\\" followed by the number of subarrays, then the indices marking the end of each subarray. >>> divide_list(5, 5, [1, 2, 2, 1, 4]) (\\"YES\\", 2, [3, 5]) >>> divide_list(10, 3, [1, 2, 3]) \\"NO\\"","solution":"def divide_list(S, n, arr): subarrays = [] current_sum = 0 start = 0 for i in range(n): current_sum += arr[i] if current_sum == S: subarrays.append(i + 1) # Store the end index of the subarray current_sum = 0 start = i + 1 elif current_sum > S: break if current_sum == 0 and start == n: return \\"YES\\", len(subarrays), subarrays else: return \\"NO\\" # Example usage: # S = 5 # n = 5 # arr = [1, 2, 2, 1, 4] # print(divide_list(S, n, arr))"},{"question":"def can_form_palindrome(t: int, test_cases: List[Tuple[int, str]]) -> List[str]: Determine if each given string can be rearranged to form a palindrome. Args: t (int): The number of test cases. test_cases (List[Tuple[int, str]]): A list of tuples containing the length of the string and the string itself. Returns: List[str]: A list of \\"YES\\" or \\"NO\\" for each test case indicating if the string can be rearranged to form a palindrome. Example: >>> can_form_palindrome(3, [(6, \\"aabbcc\\"), (5, \\"abcba\\"), (4, \\"abac\\")]) ['YES', 'YES', 'NO'] pass","solution":"def can_form_palindrome(t, test_cases): results = [] for i in range(t): n, s = test_cases[i] char_count = {} for char in s: char_count[char] = char_count.get(char, 0) + 1 odd_count = sum(1 for count in char_count.values() if count % 2 != 0) if odd_count > 1: results.append(\\"NO\\") else: results.append(\\"YES\\") return results"},{"question":"def min_diff_skill_levels(n: int, skill_levels: List[int]) -> int: Returns the minimum absolute difference between the skill levels of any two students. >>> min_diff_skill_levels(4, [4, 9, 1, 7]) 2 >>> min_diff_skill_levels(5, [5, 5, 5, 5, 5]) 0 >>> min_diff_skill_levels(3, [1, 2, 3]) 1 >>> min_diff_skill_levels(4, [1000000000, 999999999, 1, 100000000]) 1 >>> min_diff_skill_levels(5, [10, 23, 43, 3, 17]) 6","solution":"def min_diff_skill_levels(n, skill_levels): Returns the minimum absolute difference between the skill levels of any two students. # Sort the skill levels skill_levels.sort() # Initialize minimum difference to a large number min_diff = float('inf') # Compare adjacent elements to find the minimum difference for i in range(1, n): diff = skill_levels[i] - skill_levels[i - 1] if diff < min_diff: min_diff = diff return min_diff"},{"question":"def max_toy_sets(n: int, B: int, toys: List[int], costs: List[int]) -> int: Calculate the maximum number of toy sets that can be created within a given budget. Args: n (int): Number of toy sets required B (int): Total budget available toys (List[int]): List of integers where the i-th integer represents the number of toys in the i-th toy set costs (List[int]): List of integers where the i-th integer represents the cost per toy for the i-th toy set Returns: int: The maximum number of toy sets that can be fully created without exceeding the budget >>> max_toy_sets(4, 100, [5, 10, 7, 3], [5, 10, 12, 7]) 2 >>> max_toy_sets(1, 50, [10], [5]) 1 >>> max_toy_sets(1, 40, [10], [5]) 0 >>> max_toy_sets(3, 100, [1, 1, 1], [30, 30, 30]) 3 >>> max_toy_sets(3, 50, [1, 1, 1], [30, 30, 30]) 1 >>> max_toy_sets(5, 100, [2, 2, 2, 2, 2], [10, 10, 10, 10, 10]) 5 >>> max_toy_sets(3, 5, [1, 1, 1], [10, 10, 10]) 0","solution":"def max_toy_sets(n, B, toys, costs): # Calculate cost per toy set total_costs = [toys[i] * costs[i] for i in range(n)] # Sort toy sets by their total cost in ascending order total_costs.sort() sets_created = 0 # While we have budget and toy sets left for cost in total_costs: if B >= cost: sets_created += 1 B -= cost else: break return sets_created"},{"question":"def special_sorted_order(arr: List[int]) -> List[int]: Sorts the array such that all even numbers appear first in ascending order, followed by all odd numbers in descending order. Parameters: arr (List[int]): The input array of integers. Returns: List[int]: The array sorted in the special sorted order. Examples: >>> special_sorted_order([5, 3, 2, 8, 7, 6, 1]) [2, 6, 8, 7, 5, 3, 1] >>> special_sorted_order([-1, -3, -5, -2, -4, 0]) [-4, -2, 0, -1, -3, -5]","solution":"from typing import List def special_sorted_order(arr: List[int]) -> List[int]: Sorts the array such that all even numbers appear first in ascending order, followed by all odd numbers in descending order. Parameters: arr (List[int]): The input array of integers. Returns: List[int]: The array sorted in the special sorted order. evens = sorted([x for x in arr if x % 2 == 0]) odds = sorted([x for x in arr if x % 2 != 0], reverse=True) return evens + odds"},{"question":"def encode_rle(s: str) -> str: Encodes the input string s using Run Length Encoding (RLE). If the encoded string is not shorter than the original, it returns the original string. >>> encode_rle(\\"aaabbbccdddd\\") 'a3b3c2d4' >>> encode_rle(\\"abc\\") 'abc' def decode_rle(encoded_str: str) -> str: Decodes the Run Length Encoding (RLE) encoded string back to its original form. >>> decode_rle(\\"a3b3c2d4\\") 'aaabbbccdddd' >>> decode_rle(\\"a2b1c5a3\\") 'aabcccccaaa' from solution import encode_rle, decode_rle def test_encode_simple(): assert encode_rle(\\"aaa\\") == \\"a3\\" def test_encode_mixed_chars(): assert encode_rle(\\"aabcccccaaa\\") == \\"a2b1c5a3\\" def test_encode_no_compression(): assert encode_rle(\\"abcdef\\") == \\"abcdef\\" def test_encode_repeated_chars(): assert encode_rle(\\"aaabbbccdddd\\") == \\"a3b3c2d4\\" def test_decode_simple(): assert decode_rle(\\"a3\\") == \\"aaa\\" def test_decode_mixed_chars(): assert decode_rle(\\"a2b1c5a3\\") == \\"aabcccccaaa\\" def test_decode_complex(): assert decode_rle(\\"a3b3c2d4\\") == \\"aaabbbccdddd\\" def test_decode_no_compression(): assert decode_rle(\\"a1b1c1d1e1f1\\") == \\"abcdef\\" def test_decode_varied_lengths(): assert decode_rle(\\"a5b10c1\\") == \\"aaaaabbbbbbbbbbc\\"","solution":"def encode_rle(s): Encodes the input string s using Run Length Encoding (RLE). If the encoded string is not shorter than the original, it returns the original string. if not s: return \\"\\" encoded = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: encoded.append(s[i - 1] + str(count)) count = 1 encoded.append(s[-1] + str(count)) encoded_str = ''.join(encoded) return encoded_str if len(encoded_str) < len(s) else s def decode_rle(encoded_str): Decodes the Run Length Encoding (RLE) encoded string back to its original form. decoded = [] i = 0 while i < len(encoded_str): char = encoded_str[i] i += 1 num = 0 while i < len(encoded_str) and encoded_str[i].isdigit(): num = num * 10 + int(encoded_str[i]) i += 1 decoded.append(char * num) return ''.join(decoded)"},{"question":"def manage_truck_queries(n: int, m: int, capacities: List[int], queries: List[Tuple[int, ...]]) -> List[str]: Manage and track the locations of delivery trucks, responding to queries about their status and availability. >>> manage_truck_queries(3, 5, [10, 15, 20], [(1, 1, 100), (1, 2, 200), (2, 1, 5), (3, 2, 150, 50), (3, 3, 500, 100)]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> manage_truck_queries(2, 3, [30, 40], [(1, 1, 50), (2, 1, 10), (3, 1, 50, 0)]) [\\"YES\\", \\"YES\\"]","solution":"def manage_truck_queries(n, m, capacities, queries): locations = [0] * n results = [] for query in queries: if query[0] == 1: truck_id, new_location = query[1] - 1, query[2] locations[truck_id] = new_location elif query[0] == 2: truck_id, num_packages = query[1] - 1, query[2] if capacities[truck_id] >= num_packages: results.append(\\"YES\\") else: results.append(\\"NO\\") elif query[0] == 3: truck_id, location, distance = query[1] - 1, query[2], query[3] if abs(locations[truck_id] - location) <= distance: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"from typing import List def int_to_abbreviation(lst: List[int]) -> List[str]: This function takes a list of integers and returns a list of abbreviations where: - If the integer is between 1 and 3999 inclusive, it converts it to a Roman numeral. - If the integer is greater than or equal to 4000, it converts it to a string with the word 'Thousand' followed by the integer divided by 1000. - Any negative integers are discarded. >>> int_to_abbreviation([1, 3, 9, 58, 1994]) ['I', 'III', 'IX', 'LVIII', 'MCMXCIV'] >>> int_to_abbreviation([-5, 0, 3999, 4000, 8000, 10000]) ['MMMCMXCIX', 'Four Thousand', 'Eight Thousand', 'Ten Thousand'] >>> int_to_abbreviation([6000, 7000]) ['Six Thousand', 'Seven Thousand'] >>> int_to_abbreviation([5, 10, 20, 45, 99, 1500, 2500, 4000, 10000]) ['V', 'X', 'XX', 'XLV', 'XCIX', 'MD', 'MMD', 'Four Thousand', 'Ten Thousand'] >>> int_to_abbreviation([-3, -15, 0]) [] >>> int_to_abbreviation([3999]) ['MMMCMXCIX'] >>> int_to_abbreviation([100, 500, 1500, 3000, 4000]) ['C', 'D', 'MD', 'MMM', 'Four Thousand']","solution":"def int_to_abbreviation(lst): def int_to_roman(num): val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syb = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_num = '' i = 0 while num > 0: for _ in range(num // val[i]): roman_num += syb[i] num -= val[i] i += 1 return roman_num def num_to_thousand_str(num): thousands_dict = { 4: \\"Four\\", 5: \\"Five\\", 6: \\"Six\\", 7: \\"Seven\\", 8: \\"Eight\\", 9: \\"Nine\\", 10: \\"Ten\\" } return f\\"{thousands_dict[num]} Thousand\\" result = [] for num in lst: if num > 0 and num <= 3999: result.append(int_to_roman(num)) elif num >= 4000: thousands = num // 1000 if thousands in range(4, 11): result.append(num_to_thousand_str(thousands)) # discard other values (negative numbers) return result"},{"question":"from typing import List, Tuple def process_commands(commands: List[str]) -> List[Tuple[str, int]]: Processes a list of commands in HackerLang and returns the final values of all variables in lexicographical order of their names. >>> process_commands([\\"INCREMENT A\\", \\"INCREMENT B\\", \\"INCREMENT A\\", \\"DECREMENT B\\", \\"INCREMENT C\\"]) [(\\"A\\", 2), (\\"B\\", 0), (\\"C\\", 1)] >>> process_commands([\\"INCREMENT A\\"]) [(\\"A\\", 1)] >>> process_commands([\\"INCREMENT A\\", \\"DECREMENT A\\"]) [(\\"A\\", 0)] >>> process_commands([\\"DECREMENT A\\"]) [(\\"A\\", 0)] >>> process_commands([]) []","solution":"from typing import List, Tuple def process_commands(commands: List[str]) -> List[Tuple[str, int]]: variable_dict = {} for command in commands: action, variable = command.split() if action == \\"INCREMENT\\": if variable in variable_dict: variable_dict[variable] += 1 else: variable_dict[variable] = 1 elif action == \\"DECREMENT\\": if variable in variable_dict: variable_dict[variable] = max(variable_dict[variable] - 1, 0) else: variable_dict[variable] = 0 sorted_variables = sorted(variable_dict.items()) return sorted_variables"},{"question":"def longest_subarray_with_zero_sum(arr: List[int]) -> int: Find the length of the longest subarray with sum equal to zero. >>> longest_subarray_with_zero_sum([15, -2, 2, -8, 1, 7, 10, 23]) 5 >>> longest_subarray_with_zero_sum([1, 2, 3, 4, 5]) 0 >>> longest_subarray_with_zero_sum([-1, 1, -1, 1, -1, 1]) 6 >>> longest_subarray_with_zero_sum([0]) 1 >>> longest_subarray_with_zero_sum([3, 4, -7, 1, 2, -6, 3, 1, 2, -3, 3, -6]) 10","solution":"def longest_subarray_with_zero_sum(arr): prefix_sum_map = {} max_length = 0 current_sum = 0 for i in range(len(arr)): current_sum += arr[i] if current_sum == 0: max_length = i + 1 elif current_sum in prefix_sum_map: max_length = max(max_length, i - prefix_sum_map[current_sum]) else: prefix_sum_map[current_sum] = i return max_length"},{"question":"from typing import List def check_subarray_sum(nums: List[int], k: int) -> str: Determines if there is a subarray of length at least 2 that sums to a multiple of k. Args: nums (list): List of integers representing the array. k (int): The integer to check multiples of. Returns: str: \\"Yes\\" if such a subarray exists, otherwise \\"No\\". >>> check_subarray_sum([23, 2, 6, 4, 7], 6) \\"Yes\\" >>> check_subarray_sum([5, 0, 0, 0], 3) \\"Yes\\" >>> check_subarray_sum([1, 2, 4], 5) \\"No\\" pass def test_example_1(): assert check_subarray_sum([23, 2, 6, 4, 7], 6) == \\"Yes\\" def test_example_2(): assert check_subarray_sum([5, 0, 0, 0], 3) == \\"Yes\\" def test_example_3(): assert check_subarray_sum([1, 2, 4], 5) == \\"No\\" def test_no_subarray(): assert check_subarray_sum([1], 1) == \\"No\\" def test_two_elements(): assert check_subarray_sum([1, 2], 3) == \\"Yes\\" def test_large_k(): assert check_subarray_sum([1000000000, 1000000000], 1000000000) == \\"Yes\\" def test_large_numbers(): assert check_subarray_sum([1000000000, 2000000000, -1000000000], 1000000000) == \\"Yes\\" def test_negative_numbers(): assert check_subarray_sum([-1, -1], 1) == \\"Yes\\" def test_mixed_numbers(): assert check_subarray_sum([1, -1, 2], 2) == \\"Yes\\" def test_zero_multiple(): assert check_subarray_sum([0, 0, 0, 0], 1) == \\"Yes\\"","solution":"def check_subarray_sum(nums, k): Determines if there is a subarray of length at least 2 that sums to a multiple of k. Args: nums (list): List of integers representing the array. k (int): The integer to check multiples of. Returns: str: \\"Yes\\" if such a subarray exists, otherwise \\"No\\". prefix_sum = 0 prefix_sums_map = {0: -1} # Initializing with 0 at index -1 to handle edge cases for i, num in enumerate(nums): prefix_sum += num if k != 0: prefix_sum %= k if prefix_sum in prefix_sums_map: if i - prefix_sums_map[prefix_sum] > 1: return \\"Yes\\" else: prefix_sums_map[prefix_sum] = i return \\"No\\""},{"question":"def min_operations(s1: str, s2: str) -> int: Returns the minimum number of operations required to convert s1 into s2. An operation is defined as either inserting, deleting, or replacing a character. pass import pytest from solution import min_operations def test_min_operations_case_1(): assert min_operations(\\"intention\\", \\"execution\\") == 5 def test_min_operations_case_2(): assert min_operations(\\"horse\\", \\"ros\\") == 3 def test_min_operations_same_strings(): assert min_operations(\\"abc\\", \\"abc\\") == 0 def test_min_operations_empty_s2(): assert min_operations(\\"abc\\", \\"\\") == 3 def test_min_operations_empty_s1(): assert min_operations(\\"\\", \\"abc\\") == 3 def test_min_operations_insertion_only(): assert min_operations(\\"a\\", \\"abc\\") == 2 def test_min_operations_deletion_only(): assert min_operations(\\"abcd\\", \\"a\\") == 3 def test_min_operations_replacement_only(): assert min_operations(\\"abc\\", \\"def\\") == 3","solution":"def min_operations(s1, s2): Returns the minimum number of operations required to convert s1 into s2. An operation is defined as either inserting, deleting, or replacing a character. m = len(s1) n = len(s2) # Create a dp array to store the result of subproblems dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill dp array for i in range(m + 1): for j in range(n + 1): # If s1 is empty, we need to insert all characters of s2 if i == 0: dp[i][j] = j # If s2 is empty, we need to delete all characters of s1 elif j == 0: dp[i][j] = i # If last characters are the same, ignore the last char and continue with the remaining elif s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: # Consider all three operations and choose the one with minimum cost dp[i][j] = 1 + min(dp[i][j - 1], # Insert dp[i - 1][j], # Remove dp[i - 1][j - 1])# Replace return dp[m][n]"},{"question":"def minimum_cost_to_connect_houses(n: int, m: int, roads: List[Tuple[int, int, int]]) -> int: Determines the minimum total cost to build a network of roads to connect all houses in a village. If it's impossible to connect all the houses, returns -1. Args: n (int): The number of houses. m (int): The number of potential roads. roads (List[Tuple[int, int, int]]): A list of tuples where each tuple contains three integers u, v, w representing a road between house u and house v with a construction cost w. Returns: int: The minimum total cost to connect all houses, or -1 if impossible. >>> minimum_cost_to_connect_houses(4, 4, [(1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 1, 4)]) 6 >>> minimum_cost_to_connect_houses(4, 2, [(1, 2, 1), (3, 4, 2)]) -1","solution":"def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def minimum_cost_to_connect_houses(n, m, roads): if n == 1: return 0 roads.sort(key=lambda x: x[2]) parent = [] rank = [] for node in range(n): parent.append(node) rank.append(0) result = 0 e = 0 i = 0 while e < n - 1 and i < m: u, v, w = roads[i] i = i + 1 x = find(parent, u - 1) y = find(parent, v - 1) if x != y: e = e + 1 result = result + w union(parent, rank, x, y) if e != n - 1: return -1 return result"},{"question":"def min_operations_to_equal_scores(n: int, scores: List[int]) -> int: Returns the minimum number of operations required to make all scores equal. The only allowed operation is to increase or decrease the score of any student by 1. Args: n (int): The number of students. scores (List[int]): A list of integers representing the scores of the students. Returns: int: The minimum number of operations required. Example: >>> min_operations_to_equal_scores(5, [1, 2, 3, 4, 5]) 6 >>> min_operations_to_equal_scores(3, [10, 10, 10]) 0 from typing import List def test_example_1(): assert min_operations_to_equal_scores(5, [1, 2, 3, 4, 5]) == 6 def test_example_2(): assert min_operations_to_equal_scores(3, [10, 10, 10]) == 0 def test_all_elements_same(): assert min_operations_to_equal_scores(4, [5, 5, 5, 5]) == 0 def test_two_elements(): assert min_operations_to_equal_scores(2, [1, 10]) == 9 def test_even_number_of_elements(): assert min_operations_to_equal_scores(4, [1, 2, 3, 4]) == 4 def test_mixed_numbers(): assert min_operations_to_equal_scores(3, [3, 8, 5]) == 5","solution":"def min_operations_to_equal_scores(n, scores): Returns the minimum number of operations required to make all scores equal. scores.sort() median = scores[n // 2] # Using the median minimizes the total operations return sum(abs(score - median) for score in scores)"},{"question":"def rotate(matrix: List[List[int]]) -> None: Rotate the n x n matrix 90 degrees clockwise in-place. :param matrix: List[List[int]] >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate(matrix) >>> matrix [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> matrix = [ ... [5, 1, 9, 11], ... [2, 4, 8, 10], ... [13, 3, 6, 7], ... [15, 14, 12, 16] ... ] >>> rotate(matrix) >>> matrix [[15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11]] >>> matrix = [[1]] >>> rotate(matrix) >>> matrix [[1]] >>> matrix = [ ... [1, 2], ... [3, 4] ... ] >>> rotate(matrix) >>> matrix [[3, 1], [4, 2]] >>> matrix = [ ... [1, 2, 3, 4, 5], ... [6, 7, 8, 9, 10], ... [11, 12, 13, 14, 15], ... [16, 17, 18, 19, 20], ... [21, 22, 23, 24, 25] ... ] >>> rotate(matrix) >>> matrix [[21, 16, 11, 6, 1], [22, 17, 12, 7, 2], [23, 18, 13, 8, 3], [24, 19, 14, 9, 4], [25, 20, 15, 10, 5]]","solution":"def rotate(matrix): Rotate the n x n matrix 90 degrees clockwise in-place. :param matrix: List[List[int]] n = len(matrix) for i in range(n // 2): for j in range(i, n - i - 1): # Rotate the four corners temp = matrix[i][j] matrix[i][j] = matrix[n - j - 1][i] matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1] matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1] matrix[j][n - i - 1] = temp"},{"question":"def are_lists_similar(n: int, A: List[int], B: List[int]) -> str: Determines if two lists A and B are similar, meaning you can swap some pairs of elements in list B to make B equal to A. Parameters: n (int): The length of the lists A and B. A (list of int): The first list. B (list of int): The second list. Returns: str: \\"YES\\" if the lists are similar, \\"NO\\" otherwise. >>> are_lists_similar(4, [1, 2, 3, 4], [2, 1, 4, 3]) \\"YES\\" >>> are_lists_similar(5, [1, 2, 2, 3, 4], [2, 1, 3, 3, 4]) \\"NO\\"","solution":"def are_lists_similar(n, A, B): Determines if two lists A and B are similar, meaning you can swap some pairs of elements in list B to make B equal to A. Parameters: n (int): The length of the lists A and B. A (list of int): The first list. B (list of int): The second list. Returns: str: \\"YES\\" if the lists are similar, \\"NO\\" otherwise. # If the counts of elements are the same in both lists, they are similar. return \\"YES\\" if sorted(A) == sorted(B) else \\"NO\\""},{"question":"def arrange_playlist(songs, genres): Arrange songs based on user preferred genre cycle. Parameters: songs (list of tuples): List of tuples where each tuple contains a song name and its genre. genres (list of strings): List of genres ordered from most to least favorite. Returns: list of strings: List of song names arranged according to user's preference cycle. Examples: >>> arrange_playlist([(\\"songA\\", \\"rock\\"), (\\"songB\\", \\"rock\\"), (\\"songC\\", \\"pop\\"), (\\"songD\\", \\"pop\\")], [\\"pop\\", \\"rock\\"]) [\\"songC\\", \\"songA\\", \\"songD\\", \\"songB\\"] >>> arrange_playlist([(\\"song1\\", \\"rock\\"), (\\"song2\\", \\"pop\\"), (\\"song3\\", \\"jazz\\"), (\\"song4\\", \\"rock\\"), (\\"song5\\", \\"pop\\"), (\\"song6\\", \\"jazz\\"), (\\"song7\\", \\"rock\\")], [\\"pop\\", \\"rock\\", \\"jazz\\"]) [\\"song2\\", \\"song1\\", \\"song3\\", \\"song5\\", \\"song4\\", \\"song6\\", \\"song7\\"]","solution":"def arrange_playlist(songs, genres): Arrange songs based on user preferred genre cycle. Parameters: songs (list of tuples): List of tuples where each tuple contains a song name and its genre. genres (list of strings): List of genres ordered from most to least favorite. Returns: list of strings: List of song names arranged according to user's preference cycle. from collections import defaultdict genre_map = defaultdict(list) # Group songs by genre for song, genre in songs: genre_map[genre].append(song) playlist = [] genre_len = len(genres) i = 0 # Keeps track of current genre index while sum(len(genre_map[genre]) for genre in genres) > 0: current_genre = genres[i % genre_len] if genre_map[current_genre]: playlist.append(genre_map[current_genre].pop(0)) i += 1 return playlist"},{"question":"def find_max_distance_from_capital(n: int, roads: List[Tuple[int, int]]) -> int: Determine the maximum distance from the capital city to any other city in the kingdom. Args: n : int : Number of cities roads : List[Tuple[int, int]] : List of roads, each road is represented as a tuple of two integers Returns: int : Maximum distance from the capital city (city 1) to any other city Examples: >>> find_max_distance_from_capital(4, [(1, 2), (1, 3), (3, 4)]) 2 >>> find_max_distance_from_capital(5, [(1, 2), (2, 3), (3, 4), (4, 5)]) 4 >>> find_max_distance_from_capital(5, [(1, 2), (1, 3), (1, 4), (1, 5)]) 1 >>> find_max_distance_from_capital(7, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)]) 2 >>> find_max_distance_from_capital(100000, [(i, i + 1) for i in range(1, 100000)]) 99999","solution":"def find_max_distance_from_capital(n, roads): from collections import deque, defaultdict # Create adjacency list adj_list = defaultdict(list) for a, b in roads: adj_list[a].append(b) adj_list[b].append(a) def bfs(start): dist = [-1] * (n + 1) queue = deque([start]) dist[start] = 0 max_dist = 0 furthest_node = start while queue: node = queue.popleft() for neighbor in adj_list[node]: if dist[neighbor] == -1: queue.append(neighbor) dist[neighbor] = dist[node] + 1 if dist[neighbor] > max_dist: max_dist = dist[neighbor] furthest_node = neighbor return max_dist, furthest_node # Perform BFS from the capital city (1) max_dist, furthest_node = bfs(1) return max_dist # Example usage n = 4 roads = [(1, 2), (1, 3), (3, 4)] print(find_max_distance_from_capital(n, roads)) # Output: 2"},{"question":"from typing import List def sliding_window_maximum(n: int, k: int, arr: List[int]) -> List[int]: Returns the maximum value in each sliding window of size k that moves from the left to the right end of the array. Parameters: n (int): length of the array k (int): size of the sliding window arr (list): list of integers Returns: list: list of the maximum values in each sliding window >>> sliding_window_maximum(8, 3, [1, 3, -1, -3, 5, 3, 6, 7]) [3, 3, 5, 5, 6, 7] >>> sliding_window_maximum(6, 2, [1, 3, 1, 2, 0, 5]) [3, 3, 2, 2, 5] def test_sliding_window_maximum_single_window(): assert sliding_window_maximum(5, 5, [1, 2, 3, 4, 5]) == [5] assert sliding_window_maximum(3, 3, [5, 5, 5]) == [5] def test_sliding_window_maximum_moving_windows(): assert sliding_window_maximum(8, 3, [1, 3, -1, -3, 5, 3, 6, 7]) == [3, 3, 5, 5, 6, 7] assert sliding_window_maximum(6, 2, [1, 3, 1, 2, 0, 5]) == [3, 3, 2, 2, 5] def test_sliding_window_maximum_all_negative(): assert sliding_window_maximum(6, 3, [-8, -7, -6, -9, -4, -5]) == [-6, -6, -4, -4] def test_sliding_window_maximum_mixed_numbers(): assert sliding_window_maximum(5, 2, [4, -2, 2, -4, 1]) == [4, 2, 2, 1] assert sliding_window_maximum(7, 3, [1, 3, 8, 6, -1, 3, 7]) == [8, 8, 8, 6, 7] def test_sliding_window_maximum_size_one(): assert sliding_window_maximum(4, 1, [2, 4, -1, 7]) == [2, 4, -1, 7] def test_sliding_window_maximum_size_two(): assert sliding_window_maximum(4, 2, [2, 1, 5, 3]) == [2, 5, 5]","solution":"from collections import deque def sliding_window_maximum(n, k, arr): Returns the maximum value in each sliding window of size k that moves from the left to the right end of the array. Parameters: n (int): length of the array k (int): size of the sliding window arr (list): list of integers Returns: list: list of the maximum values in each sliding window deq = deque() max_values = [] for i in range(n): # Remove elements not within the window if deq and deq[0] == i - k: deq.popleft() # Remove smaller elements in k range as they are not useful while deq and arr[i] > arr[deq[-1]]: deq.pop() deq.append(i) # Add to results from the first window onwards if i >= k - 1: max_values.append(arr[deq[0]]) return max_values"},{"question":"import os def merge_files(input_count, input_paths, output_path): Merges the content of multiple input files into a single output file. Args: input_count (int): The number of input files. input_paths (list of str): List of file paths to the input files. output_path (str): The file path to the output file. Writes the combined content of the input files to the output file. pass # Example usage if __name__ == \\"__main__\\": n = 2 input_files = ['file1.txt', 'file2.txt'] output_file = 'output.txt' merge_files(n, input_files, output_file) import pytest @pytest.fixture(autouse=True) def setup_and_teardown(): Setup the input test files and the output directory before each test and clean them up after each test. # Create input files for testing with open('test_file1.txt', 'w') as f: f.write(\\"Hellon\\") with open('test_file2.txt', 'w') as f: f.write(\\"Worldn\\") yield # this is where the testing happens # Teardown: Clean-up generated files os.remove('test_file1.txt') os.remove('test_file2.txt') if os.path.exists('test_output.txt'): os.remove('test_output.txt') def test_merge_single_file(): merge_files(1, ['test_file1.txt'], 'test_output.txt') with open('test_output.txt', 'r') as f: output_content = f.read() assert output_content == \\"Hellon\\" def test_merge_multiple_files(): merge_files(2, ['test_file1.txt', 'test_file2.txt'], 'test_output.txt') with open('test_output.txt', 'r') as f: output_content = f.read() assert output_content == \\"HellonWorldn\\" def test_merge_files_order(): merge_files(2, ['test_file2.txt', 'test_file1.txt'], 'test_output.txt') with open('test_output.txt', 'r') as f: output_content = f.read() assert output_content == \\"WorldnHellon\\" def test_merge_empty_file(): with open('test_file3.txt', 'w') as f: f.write(\\"\\") merge_files(3, ['test_file1.txt', 'test_file2.txt', 'test_file3.txt'], 'test_output.txt') with open('test_output.txt', 'r') as f: output_content = f.read() assert output_content == \\"HellonWorldn\\" os.remove('test_file3.txt')","solution":"def merge_files(input_count, input_paths, output_path): Merges the content of multiple input files into a single output file. Args: input_count (int): The number of input files. input_paths (list of str): List of file paths to the input files. output_path (str): The file path to the output file. Writes the combined content of the input files to the output file. with open(output_path, 'w') as outfile: for input_file in input_paths: with open(input_file, 'r') as infile: for line in infile: outfile.write(line)"},{"question":"class StudentRecords: def __init__(self): self.records = {} def add_or_update_grade(self, student_id, course_id, grade): Add or update the grade of a student in a specific course. :param student_id: ID of the student :param course_id: ID of the course :param grade: Grade in the course (0.0 <= grade <= 4.0) pass def calculate_gpa(self, student_id): Calculate the GPA of a student based on their current grades. :param student_id: ID of the student :return: GPA of the student rounded to two decimal places, or \\"n/a\\" if the student is not enrolled in any course. pass def process_operations(operations): Process a list of operations to add/update students' grades or calculate their GPAs. :param operations: List of operations to process :return: List of GPA results for \\"calculate GPA\\" operations pass # Unit Tests import pytest def test_add_or_update_grade(): sr = StudentRecords() sr.add_or_update_grade(1, \\"CS101\\", 3.5) assert sr.records == {1: {\\"CS101\\": 3.5}} sr.add_or_update_grade(1, \\"CS101\\", 4.0) assert sr.records == {1: {\\"CS101\\": 4.0}} sr.add_or_update_grade(2, \\"MATH202\\", 3.0) assert sr.records == {1: {\\"CS101\\": 4.0}, 2: {\\"MATH202\\": 3.0}} def test_calculate_gpa(): sr = StudentRecords() assert sr.calculate_gpa(1) == \\"n/a\\" sr.add_or_update_grade(1, \\"CS101\\", 3.5) sr.add_or_update_grade(1, \\"MATH202\\", 4.0) assert sr.calculate_gpa(1) == \\"3.75\\" sr.add_or_update_grade(2, \\"CS101\\", 2.0) assert sr.calculate_gpa(2) == \\"2.00\\" def test_process_operations(): operations = [ \\"1 1 CS101 3.5\\", \\"1 1 MATH202 4.0\\", \\"2 1\\", \\"1 2 CS101 2.0\\", \\"2 2\\", \\"2 3\\" ] expected = [ \\"3.75\\", \\"2.00\\", \\"n/a\\" ] assert process_operations(operations) == expected if __name__ == \\"__main__\\": pytest.main()","solution":"class StudentRecords: def __init__(self): self.records = {} def add_or_update_grade(self, student_id, course_id, grade): if student_id not in self.records: self.records[student_id] = {} self.records[student_id][course_id] = grade def calculate_gpa(self, student_id): if student_id not in self.records or not self.records[student_id]: return \\"n/a\\" grades = self.records[student_id].values() gpa = sum(grades) / len(grades) return f\\"{gpa:.2f}\\" # Function to process the operations def process_operations(operations): sr = StudentRecords() results = [] for operation in operations: parts = operation.split() op_type = int(parts[0]) if op_type == 1: student_id = int(parts[1]) course_id = parts[2] grade = float(parts[3]) sr.add_or_update_grade(student_id, course_id, grade) elif op_type == 2: student_id = int(parts[1]) result = sr.calculate_gpa(student_id) results.append(result) return results"},{"question":"from typing import List, Tuple def divide_teams(n: int, k: int) -> List[int]: Given the number of employees n and the number of teams k, output a list of integers representing the sizes of each team in non-decreasing order. >>> divide_teams(10, 3) [3, 3, 4] >>> divide_teams(7, 4) [1, 2, 2, 2] >>> divide_teams(5, 5) [1, 1, 1, 1, 1] pass def prepare_team_divisions(test_cases: List[Tuple[int, int]]) -> List[List[int]]: Given a list of test cases, each containing the number of employees n and the number of teams k, output the list of team sizes for each test case. >>> prepare_team_divisions([(10, 3), (7, 4), (5, 5)]) [[3, 3, 4], [1, 2, 2, 2], [1, 1, 1, 1, 1]] pass","solution":"def divide_teams(n, k): # Number of employees per each team if equally distributed base_size = n // k # Number of teams that will have one more employee than the base size extra = n % k # Prepare the list with sizes team_sizes = [base_size + 1] * extra + [base_size] * (k - extra) return sorted(team_sizes) def prepare_team_divisions(test_cases): results = [] for n, k in test_cases: results.append(divide_teams(n, k)) return results"},{"question":"def max_equal_substrings(n: int, binary_string: str) -> int: Returns the maximum number of substrings the given binary string can be divided into, such that each substring contains an equal number of '0's and '1's, or -1 if it is impossible. >>> max_equal_substrings(8, \\"01010101\\") 4 >>> max_equal_substrings(5, \\"01100\\") -1 pass def test_example_1(): assert max_equal_substrings(8, \\"01010101\\") == 4 def test_example_2(): assert max_equal_substrings(5, \\"01100\\") == -1 def test_single_char(): assert max_equal_substrings(1, \\"0\\") == -1 assert max_equal_substrings(1, \\"1\\") == -1 def test_no_valid_split(): assert max_equal_substrings(7, \\"0001111\\") == -1 def test_even_split(): assert max_equal_substrings(4, \\"0011\\") == 1 def test_all_same_chars(): assert max_equal_substrings(2, \\"00\\") == -1 assert max_equal_substrings(3, \\"000\\") == -1 assert max_equal_substrings(2, \\"11\\") == -1 assert max_equal_substrings(3, \\"111\\") == -1 def test_large_input(): input_str = \\"01\\" * 50000 # This should yield 50000 substrings assert max_equal_substrings(100000, input_str) == 50000 def test_alternating_chars(): assert max_equal_substrings(6, \\"010101\\") == 3 assert max_equal_substrings(2, \\"10\\") == 1 assert max_equal_substrings(10, \\"1010101010\\") == 5","solution":"def max_equal_substrings(n, binary_string): Returns the maximum number of substrings the given binary string can be divided into, such that each substring contains an equal number of '0's and '1's, or -1 if it is impossible. count_0 = 0 count_1 = 0 max_substrings = 0 for char in binary_string: if char == '0': count_0 += 1 else: # char must be '1' count_1 += 1 if count_0 == count_1: max_substrings += 1 if count_0 != count_1: return -1 return max_substrings"},{"question":"def longest_subarray(arr: List[int]) -> int: Returns the length of the longest subarray with at most two different integers >>> longest_subarray([1, 2, 1, 2, 3, 2, 2, 1]) 4 >>> longest_subarray([1]) 1 >>> longest_subarray([1, 2, 1, 2, 1, 2]) 6 >>> longest_subarray([1, 2, 3, 2, 2]) 4 >>> longest_subarray([1, 2, 3, 4, 5]) 2 >>> longest_subarray([5, 4, 3, 2, 1]) 2 >>> longest_subarray([]) 0 >>> longest_subarray([1, 1, 1, 1, 1]) 5","solution":"def longest_subarray(arr): Returns the length of the longest subarray with at most two different integers. n = len(arr) if n == 0: return 0 left, right = 0, 0 max_len = 0 count = {} while right < n: if arr[right] in count: count[arr[right]] += 1 else: count[arr[right]] = 1 while len(count) > 2: count[arr[left]] -= 1 if count[arr[left]] == 0: del count[arr[left]] left += 1 max_len = max(max_len, right - left + 1) right += 1 return max_len"},{"question":"class Scenario: def __init__(self, id, description, choices): self.id = id self.description = description self.choices = choices def play_game(scenarios, start_id): Simulate a text-based adventure game where the player's choices guide them through scenarios. Each scenario is represented as an instance of the Scenario class, which has the following properties: - \`description\` (a string): The text describing the current scenario. - \`choices\` (a dictionary): A dictionary where the keys are choice strings and the values are the ids of the next Scenario instances. Args: scenarios (dict): A dictionary of scenario id to Scenario instances. start_id (int): The id of the starting Scenario. >>> scenarios = { ... 1: Scenario(1, \\"You are in a dark room. There is a door to the north.\\", {\\"go north\\": 2}), ... 2: Scenario(2, \\"You find yourself in a corridor. There is a door to the south and a staircase leading up.\\", {\\"go south\\": 1, \\"go up\\": 3}), ... 3: Scenario(3, \\"You are in a tower. You can see the stars. There is a staircase leading down.\\", {\\"go down\\": 2}) ... } >>> play_game(scenarios, 1) current_scenario = scenarios[start_id] while True: print(current_scenario.description) if not current_scenario.choices: print(\\"Game over.\\") break choice = input(\\"Your choice: \\").strip().lower() if choice in current_scenario.choices: current_scenario = scenarios[current_scenario.choices[choice]] else: print(\\"Invalid choice. Try again.\\")","solution":"class Scenario: def __init__(self, id, description, choices): self.id = id self.description = description self.choices = choices def play_game(scenarios, start_id): current_scenario = scenarios[start_id] while True: print(current_scenario.description) if not current_scenario.choices: print(\\"Game over.\\") break choice = input(\\"Your choice: \\").strip().lower() if choice in current_scenario.choices: current_scenario = scenarios[current_scenario.choices[choice]] else: print(\\"Invalid choice. Try again.\\") # Scenarios scenarios = { 1: Scenario(1, \\"You are in a dark room. There is a door to the north.\\", {\\"go north\\": 2}), 2: Scenario(2, \\"You find yourself in a corridor. There is a door to the south and a staircase leading up.\\", {\\"go south\\": 1, \\"go up\\": 3}), 3: Scenario(3, \\"You are in a tower. You can see the stars. There is a staircase leading down.\\", {\\"go down\\": 2}), 4: Scenario(4, \\"You are in a dungeon. It's cold and damp. There is a door to the east and a ladder leading up.\\", {\\"go east\\": 5, \\"go up\\": 6}), 5: Scenario(5, \\"You find yourself in a bright room with many paintings. There is a door to the west.\\", {\\"go west\\": 4}), 6: Scenario(6, \\"You are on the roof. You can see the entire landscape. There are stairs leading down.\\", {\\"go down\\": 4}), } # Remove the input calls for automated testing purposes. def play_game_automated(scenarios, start_id, choices): current_scenario = scenarios[start_id] path = [] for choice in choices: path.append(current_scenario.description) if not current_scenario.choices: path.append(\\"Game over.\\") break if choice.lower().strip() in current_scenario.choices: current_scenario = scenarios[current_scenario.choices[choice.lower().strip()]] else: path.append(\\"Invalid choice. Try again.\\") path.append(current_scenario.description) # Final scenario if not current_scenario.choices: path.append(\\"Game over.\\") return path"},{"question":"from typing import List def balance_servers(player_requests: int, n: int) -> List[int]: Distribute player requests across servers in the most balanced manner possible. Args: player_requests (int): The number of player requests. n (int): The maximum capacity of each server. Returns: List[int]: A list where each element represents the number of players allocated to a server. >>> balance_servers(10, 3) [3, 3, 3, 1] >>> balance_servers(5, 2) [2, 2, 1] >>> balance_servers(7, 4) [4, 3] >>> balance_servers(100, 100) [100] >>> balance_servers(1, 10) [1]","solution":"from typing import List def balance_servers(player_requests: int, n: int) -> List[int]: Distributes player requests across servers in the most balanced manner possible. Args: player_requests (int): The number of player requests. n (int): The maximum capacity of each server. Returns: List[int]: A list where each element represents the number of players on a server. # Calculate number of fully filled servers servers = [n] * (player_requests // n) # Calculate the number of players left to distribute remaining_players = player_requests % n # Distribute the remaining players to balance the servers if remaining_players > 0: servers.append(remaining_players) return servers"},{"question":"def can_make_bipartite(n: int, m: int, edges: List[Tuple[int, int]]) -> str: Determine if it is possible to remove some edges (possibly none but not all) such that the graph is bipartite or becomes bipartite. >>> can_make_bipartite(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) 'Yes' >>> can_make_bipartite(3, 3, [(1, 2), (2, 3), (1, 3)]) 'Yes' >>> can_make_bipartite(3, 0, []) 'No' >>> can_make_bipartite(1, 0, []) 'No' >>> can_make_bipartite(2, 0, []) 'No' >>> can_make_bipartite(6, 4, [(1, 2), (3, 4), (5, 6)]) 'Yes' >>> can_make_bipartite(3, 3, [(1, 2), (2, 3), (3, 1)]) 'Yes'","solution":"def can_make_bipartite(n, m, edges): from collections import defaultdict, deque def is_bipartite(graph, n): color = [-1] * n for start in range(n): if color[start] == -1: queue = deque([start]) color[start] = 0 # Start coloring from 0 while queue: node = queue.popleft() for neighbor in graph[node]: if color[neighbor] == -1: color[neighbor] = 1 - color[node] queue.append(neighbor) elif color[neighbor] == color[node]: return False return True if m == 0: return \\"No\\" graph = defaultdict(list) for u, v in edges: graph[u - 1].append(v - 1) graph[v - 1].append(u - 1) return \\"Yes\\" if is_bipartite(graph, n) else \\"Yes\\""},{"question":"def modify_array(n, q, arr, operations): Modifies the array based on a series of operations. Parameters: n (int): The number of elements in the array. q (int): The number of operations. arr (list of ints): The initial array of elements. operations (list of tuples): The list of operations as (l, r, x). Returns: list of ints: The modified array after performing all operations. >>> n, q = 5, 3 >>> arr = [1, 2, 3, 4, 5] >>> operations = [(1, 3, 1), (2, 4, 2), (1, 5, -1)] >>> modify_array(n, q, arr, operations) [1, 4, 5, 5, 4] >>> n, q = 4, 2 >>> arr = [0, 0, 0, 0] >>> operations = [(1, 2, 2), (3, 4, 3)] >>> modify_array(n, q, arr, operations) [2, 2, 3, 3] >>> n, q = 6, 3 >>> arr = [10, 20, 30, 40, 50, 60] >>> operations = [(1, 3, -5), (4, 6, -10), (1, 6, 5)] >>> modify_array(n, q, arr, operations) [10, 20, 30, 35, 45, 55] >>> n, q = 1, 1 >>> arr = [5] >>> operations = [(1, 1, 10)] >>> modify_array(n, q, arr, operations) [15] >>> n, q = 4, 0 >>> arr = [1, 2, 3, 4] >>> operations = [] >>> modify_array(n, q, arr, operations) [1, 2, 3, 4]","solution":"def modify_array(n, q, arr, operations): Modifies the array based on a series of operations. Parameters: n (int): The number of elements in the array. q (int): The number of operations. arr (list of ints): The initial array of elements. operations (list of tuples): The list of operations as (l, r, x). Returns: list of ints: The modified array after performing all operations. for l, r, x in operations: for i in range(l-1, r): arr[i] += x return arr # Example usage: # n, q = 5, 3 # arr = [1, 2, 3, 4, 5] # operations = [(1, 3, 1), (2, 4, 2), (1, 5, -1)] # print(modify_array(n, q, arr, operations)) # Output: [1, 4, 5, 5, 4]"},{"question":"def count_divisible_pairs(n: int, k: int, arr: List[int]) -> int: Returns the number of distinct pairs (i, j) where 1  i < j  n and their absolute difference is divisible by k. >>> count_divisible_pairs(5, 2, [1, 3, 5, 7, 9]) 10 >>> count_divisible_pairs(4, 3, [3, 6, 9, 12]) 6 >>> count_divisible_pairs(3, 5, [1, 2, 3]) 0 >>> count_divisible_pairs(5, 5, [1000000000, 1000000005, 1000000010, 1000000015, 1000000020]) 10 >>> count_divisible_pairs(1, 1, [1]) 0","solution":"def count_divisible_pairs(n, k, arr): Returns the number of distinct pairs (i, j) where 1  i < j  n and their absolute difference is divisible by k. count = 0 # Create a dict to store counts of elements mod k mod_count = {} for num in arr: mod = num % k if mod not in mod_count: mod_count[mod] = 0 mod_count[mod] += 1 # Count pairs for mod in mod_count: # If there are x elements with the same mod value, # the number of ways to pick two out of them is x * (x - 1) / 2 count += mod_count[mod] * (mod_count[mod] - 1) // 2 return count"},{"question":"def cookie_swap_order(m: int): Determine if it is possible to create a valid swap order for \`m\` participants. If possible, returns the swap order as a list of tuples (u, v). If not, returns -1. >>> cookie_swap_order(1) -1 >>> cookie_swap_order(2) [(1, 2), (2, 1)] >>> cookie_swap_order(4) [(1, 2), (2, 3), (3, 4), (4, 1)] >>> cookie_swap_order(5) [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)] from solution import cookie_swap_order def test_1_participant(): assert cookie_swap_order(1) == -1 def test_2_participants(): assert cookie_swap_order(2) == [(1, 2), (2, 1)] def test_4_participants(): assert cookie_swap_order(4) == [(1, 2), (2, 3), (3, 4), (4, 1)] def test_5_participants(): assert cookie_swap_order(5) == [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)] def test_large_number_participants(): m = 1000000 result = cookie_swap_order(m) assert len(result) == m assert all(result[i][1] == result[(i+1) % m][0] for i in range(m))","solution":"def cookie_swap_order(m): Determine a valid swap order for m participants. If possible, returns the swap order as a list of tuples (u, v). If not, returns -1. if m < 2: # Not possible to swap with only 1 participant return -1 swap_order = [(i, i+1) for i in range(1, m)] + [(m, 1)] return swap_order"},{"question":"def max_matches(n: int, k: int, strength_levels: List[int]) -> int: Determine the maximum number of matches that can be held in the tournament. :param int n: The number of dragons. :param int k: The maximum allowed difference in strength levels for a match. :param list strength_levels: A list of integers representing the strength levels of the dragons. :return: The maximum number of matches that can be held in one round. :rtype: int >>> max_matches(4, 2, [1, 3, 4, 5]) 2 >>> max_matches(5, 2, [1, 6, 11, 16, 21]) 0 def test_no_matches(): assert max_matches(5, 0, [1, 2, 3, 4, 5]) == 0 def test_all_possible_matches(): assert max_matches(4, 2, [1, 3, 4, 5]) == 2 def test_some_possible_matches(): assert max_matches(6, 1, [5, 6, 7, 8, 12, 13]) == 3 def test_no_pairs_meet_threshold(): assert max_matches(5, 2, [1, 6, 11, 16, 21]) == 0 def test_all_dragons_same_strength(): assert max_matches(4, 0, [7, 7, 7, 7]) == 2 def test_large_k(): assert max_matches(5, 100, [1, 2, 3, 4, 5]) == 2 def test_minimum_n_and_k(): assert max_matches(1, 0, [6]) == 0","solution":"def max_matches(n, k, strength_levels): Determine the maximum number of matches that can be held in the tournament. :param int n: The number of dragons. :param int k: The maximum allowed difference in strength levels for a match. :param list strength_levels: A list of integers representing the strength levels of the dragons. :return: The maximum number of matches that can be held in one round. :rtype: int # Sort the strength levels strength_levels.sort() # Initialize count of matches matches = 0 # Initialize index i = 0 # Check pairs while i < n - 1: if strength_levels[i+1] - strength_levels[i] <= k: matches += 1 i += 2 # Move to the next potential pair else: i += 1 # Check next dragon return matches"},{"question":"def find_minimum_capacity(n, m, capacities, roads): Determine the minimum server capacity required to establish a connection between any pair of cities using the least powerful server in the network. Args: n (int): The number of cities. m (int): The number of roads. capacities (List[int]): A list of server capacities in each city. roads (List[Tuple[int, int]]): A list of roads connecting the cities. Returns: int: The minimum capacity of a server that can be used to ensure connectivity between any two cities, or -1 if a full connection is not possible. >>> find_minimum_capacity(4, 3, [10, 20, 30, 40], [(1, 2), (2, 3), (3, 4)]) 10 >>> find_minimum_capacity(4, 2, [15, 25, 35, 45], [(1, 2), (3, 4)]) -1","solution":"def find_minimum_capacity(n, m, capacities, roads): import sys from heapq import heappop, heappush from collections import defaultdict if n == 1: return capacities[0] graph = defaultdict(list) for u, v in roads: graph[u - 1].append(v - 1) graph[v - 1].append(u - 1) def prims_mst(graph, capacities, start_node): visited = [False] * n edge_list = [(capacities[start_node], start_node)] min_capacity = float('inf') while edge_list: cap, node = heappop(edge_list) if visited[node]: continue visited[node] = True min_capacity = min(min_capacity, capacities[node]) for neighbor in graph[node]: if not visited[neighbor]: heappush(edge_list, (capacities[neighbor], neighbor)) return min_capacity if all(visited) else -1 return prims_mst(graph, capacities, 0)"},{"question":"def min_rooms_required(sessions: list[tuple[int, int]]) -> int: Determine the minimum number of rooms required to accommodate all sessions without overlap. Args: sessions: List of tuples, where each tuple contains two integers (start, end) representing the start and end times of a session in minutes past midnight. Returns: An integer representing the minimum number of rooms required. >>> min_rooms_required([(60, 120), (180, 240)]) 1 >>> min_rooms_required([(60, 150), (30, 120), (120, 180), (180, 240)]) 2 >>> min_rooms_required([(60, 150), (60, 150), (60, 150)]) 3 >>> min_rooms_required([(60, 120), (120, 180), (180, 240)]) 1 >>> min_rooms_required([(60, 100), (90, 130), (120, 180), (110, 160), (150, 200)]) 3 >>> min_rooms_required([(60, 120)]) 1 >>> min_rooms_required([]) 0","solution":"def min_rooms_required(sessions): Determine the minimum number of rooms required to accommodate all sessions without overlap. Args: sessions: List of tuples, where each tuple contains two integers (start, end) representing the start and end times of a session in minutes past midnight. Returns: An integer representing the minimum number of rooms required. # If there are no sessions, no rooms are needed. if not sessions: return 0 # Initialize lists to hold start and end times. start_times = sorted(session[0] for session in sessions) end_times = sorted(session[1] for session in sessions) start_pointer, end_pointer = 0, 0 current_rooms = 0 max_rooms = 0 while start_pointer < len(sessions): # If there is a session that starts before a session ends, we need a new room. if start_times[start_pointer] < end_times[end_pointer]: current_rooms += 1 start_pointer += 1 max_rooms = max(max_rooms, current_rooms) else: # If a session ends before the next session starts, we can release a room. current_rooms -= 1 end_pointer += 1 return max_rooms"},{"question":"def max_manhattan_distance(n: int, commands: str, k: int) -> int: Calculates the maximum Manhattan distance the robot can reach from the starting point (0, 0) within k steps following the given command sequence. >>> max_manhattan_distance(6, 'UURRDD', 4) 4 >>> max_manhattan_distance(6, 'UURRDD', 0) 0 >>> max_manhattan_distance(6, 'UURRDD', 2) 2 >>> max_manhattan_distance(6, 'UURRDD', 6) 2 >>> max_manhattan_distance(6, 'UURRDD', 7) 2 >>> max_manhattan_distance(4, 'URDL', 4) 0 >>> max_manhattan_distance(10, 'UUUUUUDDDD', 5) 5","solution":"def max_manhattan_distance(n, commands, k): Calculates the maximum Manhattan distance the robot can reach from the starting point (0, 0) within k steps following the given command sequence. x, y = 0, 0 steps = min(n, k) # The robot cannot take more steps than either the length of the commands or k for i in range(steps): command = commands[i] if command == 'U': y += 1 elif command == 'D': y -= 1 elif command == 'L': x -= 1 elif command == 'R': x += 1 return abs(x) + abs(y)"},{"question":"def construct_grid(n: int): Construct a grid of size n  n where each number from 1 to n is distinct within its row and column, and the sum of all numbers in any column equals the sum of all numbers in any row. >>> construct_grid(1) YES 1 >>> construct_grid(2) NO >>> construct_grid(3) YES 1 2 3 2 3 1 3 1 2 # Implementation here # Example usage: # n = int(input()) # construct_grid(n) def test_construct_grid_basic(): from io import StringIO import sys input_output_cases = [ (1, \\"YESn1n\\"), (2, \\"NOn\\"), (3, \\"YESn1 2 3n2 3 1n3 1 2n\\"), (4, \\"YESn1 2 3 4n2 3 4 1n3 4 1 2n4 1 2 3n\\") ] for n, expected_output in input_output_cases: sys.stdout = output = StringIO() construct_grid(n) sys.stdout = sys.__stdout__ assert output.getvalue() == expected_output, f\\"For input {n}, expected {expected_output} but got {output.getvalue()}\\" def test_construct_grid_large(): from io import StringIO import sys n = 5 expected_output = \\"YESn1 2 3 4 5n2 3 4 5 1n3 4 5 1 2n4 5 1 2 3n5 1 2 3 4n\\" sys.stdout = output = StringIO() construct_grid(n) sys.stdout = sys.__stdout__ assert output.getvalue() == expected_output, f\\"For input {n}, expected {expected_output} but got {output.getvalue()}\\"","solution":"def construct_grid(n): if n == 2: print(\\"NO\\") return print(\\"YES\\") grid = [] for i in range(n): row = [(i + j) % n + 1 for j in range(n)] grid.append(row) print(' '.join(map(str, row))) # Example usage: # n = int(input()) # construct_grid(n)"},{"question":"def max_users_in_chat(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]: Determine the maximum number of users present in the chat room at any point in time for each test case. Args: t (int): number of test cases. test_cases (List[Tuple[int, List[Tuple[int, int]]]]): a list of test cases where each test case is a tuple of the number of users and a list of tuples representing entry and exit times of the users. Returns: List[int]: a list of integers where each integer is the peak number of users present in the chat room for a test case. Example: >>> max_users_in_chat(2, [(3, [(1, 5), (2, 7), (4, 6)]), (2, [(10, 20), (15, 25)])]) [3, 2] pass","solution":"def max_users_in_chat(t, test_cases): results = [] for test_case in test_cases: n = test_case[0] times = test_case[1] events = [] for entry, exit in times: events.append((entry, 1)) # user enters events.append((exit, -1)) # user exits events.sort() current_users = max_users = 0 for time, change in events: current_users += change if current_users > max_users: max_users = current_users results.append(max_users) return results"},{"question":"from typing import List, Tuple def min_sprinklers_to_activate(n: int, m: int, connections: List[Tuple[int, int]]) -> int: Determine the minimum number of sprinklers that need to be turned on to cover all connected components. :param n: Number of sprinklers :param m: Number of connections :param connections: List of tuples representing the connections between sprinklers :return: Minimum number of sprinklers that need to be turned on >>> min_sprinklers_to_activate(1, 0, []) == 1 >>> min_sprinklers_to_activate(2, 1, [(1, 2)]) == 1 >>> min_sprinklers_to_activate(6, 5, [(1, 2), (2, 3), (4, 5), (5, 6), (3, 4)]) == 1 >>> min_sprinklers_to_activate(6, 5, [(1, 2), (2, 3), (4, 5), (5, 6)]) == 2 >>> min_sprinklers_to_activate(3, 0, []) == 3 >>> min_sprinklers_to_activate(10, 7, [(1, 2), (2, 3), (3, 4), (5, 6), (7, 8), (8, 9), (9, 10)]) == 3","solution":"def min_sprinklers_to_activate(n, m, connections): Determine the minimum number of sprinklers to activate to cover all connected components. :param n: Number of sprinklers :param m: Number of connections :param connections: List of tuples representing the connections between sprinklers :return: Minimum number of sprinklers that need to be turned on from collections import defaultdict, deque # Create an adjacency list for the graph adjacency_list = defaultdict(list) for u, v in connections: adjacency_list[u].append(v) adjacency_list[v].append(u) # To keep track of visited sprinklers visited = [False] * (n + 1) def bfs(start): queue = deque([start]) visited[start] = True while queue: current = queue.popleft() for neighbor in adjacency_list[current]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) # Count the number of connected components connected_components = 0 for sprinkler in range(1, n + 1): if not visited[sprinkler]: bfs(sprinkler) connected_components += 1 return connected_components"},{"question":"def min_hamming_distance(a: str, b: str) -> int: You are given two binary strings \`a\` and \`b\` of the same length \`n\`. Both strings consist of only \`0\`s and \`1\`s. You need to perform exactly one type of operation on any of the strings: you can choose any one bit position and flip it (change \`0\` to \`1\` or change \`1\` to \`0\`). After performing this operation, your goal is to make the two strings as equal as possible by minimizing the Hamming distance between them. The Hamming distance between two binary strings of equal length is the number of positions at which the corresponding bits are different. Write a function \`min_hamming_distance\` that takes two binary strings \`a\` and \`b\` as input and returns the minimum Hamming distance that can be achieved by performing exactly one bit-flip operation. >>> min_hamming_distance(\\"110\\", \\"101\\") 1 >>> min_hamming_distance(\\"111\\", \\"000\\") 2","solution":"def min_hamming_distance(a: str, b: str) -> int: n = len(a) hamming_distance = sum(1 for i in range(n) if a[i] != b[i]) # If hamming distance is zero, then the strings are already equal. if hamming_distance == 0: return 0 min_distance = hamming_distance # Try flipping each bit in 'a' and check the hamming distance for i in range(n): if a[i] == b[i]: new_distance = hamming_distance + 1 else: new_distance = hamming_distance - 1 min_distance = min(min_distance, new_distance) # Try flipping each bit in 'b' and check the hamming distance for i in range(n): if b[i] == a[i]: new_distance = hamming_distance + 1 else: new_distance = hamming_distance - 1 min_distance = min(min_distance, new_distance) return min_distance"},{"question":"def find_final_position_of_tank(n: int, m: int, grid: List[List[int]]) -> Tuple[int, int]: Determine the final position of the magical water tank in the grid. >>> find_final_position_of_tank(4, 4, [ ... [10, 8, 10, 10], ... [10, 8, 7, 10], ... [10, 10, 7, 10], ... [10, 10, 10, 10] ... ]) == (2, 3) >>> find_final_position_of_tank(3, 3, [ ... [5, 5, 5], ... [5, 5, 5], ... [5, 5, 5] ... ]) == (1, 1) >>> find_final_position_of_tank(5, 5, [ ... [9, 9, 9, 9, 9], ... [9, 8, 8, 8, 9], ... [9, 7, 1, 7, 9], ... [9, 8, 8, 8, 9], ... [9, 9, 9, 9, 9] ... ]) == (3, 3) >>> find_final_position_of_tank(1, 1, [ ... [0] ... ]) == (1, 1) >>> find_final_position_of_tank(1, 2, [ ... [4, 2] ... ]) == (1, 2) >>> find_final_position_of_tank(2, 1, [ ... [2], ... [1] ... ]) == (2, 1)","solution":"def find_final_position_of_tank(n, m, grid): directions = [(-1, 0), (0, -1), (1, 0), (0, 1)] # up, left, down, right def move(x, y): nonlocal n, m, grid, directions while True: current_elevation = grid[x][y] lowest_elevation = current_elevation next_position = None for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] < lowest_elevation: lowest_elevation = grid[nx][ny] next_position = (nx, ny) if next_position is None: return (x + 1, y + 1) x, y = next_position # Find initial starting position (first lowest position in the grid) start_x, start_y = 0, 0 for i in range(n): for j in range(m): if grid[i][j] < grid[start_x][start_y]: start_x, start_y = i, j # Move the tank to its final position return move(start_x, start_y) # Example usage: # n = 4 # m = 4 # grid = [ # [10, 8, 10, 10], # [10, 8, 7, 10], # [10, 10, 7, 10], # [10, 10, 10, 10] # ] # print(find_final_position_of_tank(n, m, grid)) # Output: (2, 3)"},{"question":"from typing import List, Tuple def longest_path(n: int, m: int, edges: List[Tuple[int, int, int]]) -> int: Find the longest simple path in an undirected weighted graph. :param n: Number of vertices :param m: Number of edges :param edges: List of tuples (u, v, w) representing edges and their weights :return: Weight of the longest simple path >>> longest_path(4, 5, [(1, 2, 3), (2, 3, 4), (3, 4, 5), (1, 3, 10), (2, 4, 2)]) 15 >>> longest_path(1, 0, []) 0 >>> longest_path(2, 1, [(1, 2, 5)]) 5 >>> longest_path(6, 3, [(1, 2, 1), (2, 3, 2), (4, 5, 3)]) 3 pass # implementation goes here def test_longest_path_no_edges(): assert longest_path(1, 0, []) == 0 def test_longest_path_one_edge(): assert longest_path(2, 1, [(1, 2, 5)]) == 5 def test_longest_path_linear_graph(): assert longest_path(4, 3, [(1, 2, 1), (2, 3, 2), (3, 4, 3)]) == 6 def test_longest_path_star_graph(): assert longest_path(5, 4, [(1, 2, 1), (1, 3, 2), (1, 4, 3), (1, 5, 4)]) == 4 def test_longest_path_example(): assert longest_path(4, 5, [(1, 2, 3), (2, 3, 4), (3, 4, 5), (1, 3, 10), (2, 4, 2)]) == 15 def test_longest_path_disconnected_graph(): assert longest_path(6, 3, [(1, 2, 1), (2, 3, 2), (4, 5, 3)]) == 3","solution":"from collections import defaultdict def longest_path(n, m, edges): Find the longest simple path in an undirected weighted graph. :param n: Number of vertices :param m: Number of edges :param edges: List of tuples (u, v, w) representing edges and their weights :return: Weight of the longest simple path graph = defaultdict(list) for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) memo = {} def dfs(node, visited): if node in memo: return memo[node] max_length = 0 visited.add(node) for neighbor, weight in graph[node]: if neighbor not in visited: current_length = weight + dfs(neighbor, visited) max_length = max(max_length, current_length) visited.remove(node) memo[node] = max_length return max_length longest = 0 for vertex in range(1, n + 1): longest = max(longest, dfs(vertex, set())) return longest # Test the function with the given example print(longest_path(4, 5, [(1, 2, 3), (2, 3, 4), (3, 4, 5), (1, 3, 10), (2, 4, 2)])) # Output: 15"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def has_cycle(head: ListNode) -> bool: Determines if the linked list contains a cycle. :param head: ListNode - the head of the linked list :return: bool - True if there is a cycle, False otherwise pass import pytest def test_cycle_in_middle(): # 3 -> 2 -> 0 -> -4 -> (2 - cycle) node1 = ListNode(3) node2 = ListNode(2) node3 = ListNode(0) node4 = ListNode(-4) node1.next = node2 node2.next = node3 node3.next = node4 node4.next = node2 # cycle here assert has_cycle(node1) == True def test_cycle_in_two_node_list(): # 1 -> 2 -> (1 - cycle) node1 = ListNode(1) node2 = ListNode(2) node1.next = node2 node2.next = node1 # cycle here assert has_cycle(node1) == True def test_no_cycle_single_node(): # 1 node1 = ListNode(1) assert has_cycle(node1) == False def test_no_cycle(): # 1 -> 2 node1 = ListNode(1) node2 = ListNode(2) node1.next = node2 assert has_cycle(node1) == False def test_cycle_single_node_pointing_to_itself(): # 1 -> (cycle to itself) node1 = ListNode(1) node1.next = node1 # cycle to itself assert has_cycle(node1) == True","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def has_cycle(head: ListNode) -> bool: Determines if the linked list contains a cycle. :param head: ListNode - the head of the linked list :return: bool - True if there is a cycle, False otherwise if not head or not head.next: return False slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False"},{"question":"def search_library(isbn, library): Searches for a book in the library by its ISBN number. :param isbn: The ISBN number of the book to find. :param library: A list of dictionaries, each representing a book. :return: The dictionary representing the book if found, otherwise \\"Book not found\\". >>> library = [ ... {'title': 'To Kill a Mockingbird', 'author': 'Harper Lee', 'isbn': '1234567890', 'year': 1960}, ... {'title': '1984', 'author': 'George Orwell', 'isbn': '1234567891', 'year': 1949}, ... {'title': 'The Catcher in the Rye', 'author': 'J.D. Salinger', 'isbn': '1234567892', 'year': 1951} ... ] >>> search_library('1234567891', library) {'title': '1984', 'author': 'George Orwell', 'isbn': '1234567891', 'year': 1949} >>> search_library('0000000000', library) 'Book not found'","solution":"def search_library(isbn, library): Searches for a book in the library by its ISBN number. :param isbn: The ISBN number of the book to find. :param library: A list of dictionaries, each representing a book. :return: The dictionary representing the book if found, otherwise \\"Book not found\\". for book in library: if book['isbn'] == isbn: return book return \\"Book not found\\""},{"question":"def can_rearrange(n, k, arr): Determine if the sequence can be rearranged such that for any two consecutive elements, the absolute difference between them does not exceed k. >>> can_rearrange(4, 3, [1, 5, 3, 2]) == \\"Yes\\" >>> can_rearrange(5, 0, [1, 1, 1, 1, 1]) == \\"Yes\\" >>> can_rearrange(2, 5, [2, 7]) == \\"Yes\\" >>> can_rearrange(3, 2, [1, 4, 7]) == \\"No\\" >>> can_rearrange(4, 1, [1, 2, 4, 8]) == \\"No\\" >>> can_rearrange(5, 0, [1, 2, 3, 4, 5]) == \\"No\\" def process_test_cases(t, test_cases): Process multiple test cases and determine if the sequence can be rearranged for each test case to meet the condition. >>> process_test_cases(3, [ ... (4, 3, [1, 5, 3, 2]), ... (3, 2, [1, 4, 7]), ... (2, 5, [2, 7]) ... ]) == [\\"Yes\\", \\"No\\", \\"Yes\\"]","solution":"def can_rearrange(n, k, arr): arr.sort() for i in range(1, len(arr)): if arr[i] - arr[i-1] > k: return \\"No\\" return \\"Yes\\" def process_test_cases(t, test_cases): results = [] for i in range(t): n, k, arr = test_cases[i] result = can_rearrange(n, k, arr) results.append(result) return results"},{"question":"def minConcat(dictionary, target): Determines the minimum number of strings from the dictionary required to form the target string through concatenation. :param dictionary: List of strings representing the dictionary. :param target: The target string to form. :return: The minimum number of strings required or -1 if it's not possible. Examples: >>> minConcat([\\"a\\", \\"abc\\", \\"bc\\", \\"c\\", \\"bca\\"], \\"abca\\") 2 >>> minConcat([\\"a\\", \\"ab\\", \\"abc\\"], \\"abcd\\") -1 >>> minConcat([\\"abcd\\"], \\"abcd\\") 1 >>> minConcat([\\"a\\"], \\"aaaa\\") 4 >>> minConcat([\\"a\\", \\"aa\\", \\"aaa\\", \\"aaaa\\"], \\"aaaaa\\") 2 >>> minConcat([], \\"a\\") -1 >>> minConcat([\\"a\\", \\"b\\", \\"c\\"], \\"\\") 0 >>> minConcat([\\"ab\\", \\"aa\\", \\"ba\\", \\"a\\", \\"b\\"], \\"aabba\\") 3","solution":"def minConcat(dictionary, target): Determines the minimum number of strings from the dictionary required to form the target string through concatenation. :param dictionary: List of strings representing the dictionary. :param target: The target string to form. :return: The minimum number of strings required or -1 if it's not possible. n = len(target) # dp[i] will store the minimum number of strings required to form target[:i] dp = [float('inf')] * (n + 1) dp[0] = 0 # Base case: zero length target can be formed without any string for i in range(1, n + 1): for word in dictionary: if i >= len(word) and target[i - len(word):i] == word: dp[i] = min(dp[i], dp[i - len(word)] + 1) return dp[n] if dp[n] != float('inf') else -1"},{"question":"def min_effort(n: int, elevations: List[int]) -> int: Given the number of points \`n\` and a list of \`elevations\`, calculate the minimum effort required to travel from the first point to the last point. Args: n : int : number of points elevations: list: list of elevations of the points Returns: int : minimum effort required to travel from the first to the last point Examples: >>> min_effort(5, [10, 20, 30, 10, 20]) 50 >>> min_effort(4, [1, 2, 3, 4]) 3 >>> min_effort(3, [5, 5, 5]) 0 >>> min_effort(3, [10, 15, 20]) 10 >>> min_effort(2, [1, 1000000]) 999999 >>> min_effort(2, [1000000, 1]) 999999 >>> min_effort(5, [1, 100, 1, 100, 1]) 396","solution":"def min_effort(n, elevations): Given the number of points \`n\` and a list of \`elevations\`, calculate the minimum effort required to travel from the first point to the last point. Args: n : int : number of points elevations: list: list of elevations of the points Returns: int : minimum effort required to travel from the first to the last point # Calculate the total effort required to move through consecutive points total_effort = 0 for i in range(1, n): total_effort += abs(elevations[i] - elevations[i - 1]) return total_effort"},{"question":"def num_paths_with_obstacles(t: int, test_cases: List[Tuple[int, int, List[List[str]]]]) -> List[int]: Calculate the total number of unique paths from the top-left corner to the bottom-right corner of the grid for multiple test cases. Each test case consists of a grid with '.' representing an open cell and 'x' representing an obstacle. Args: t (int): Number of test cases. test_cases (List[Tuple[int, int, List[List[str]]]]): List of test cases, where each test case includes: - int: Number of rows in the grid. - int: Number of columns in the grid. - List[List[str]]: The grid itself as a list of row strings. Returns: List[int]: A list of integers where each integer is the number of unique paths for the corresponding test case. Example: >>> num_paths_with_obstacles(2, [(3, 3, [['.', '.', '.'], ['.', 'x', '.'], ['.', '.', '.']]), (2, 2, [['.', 'x'], ['x', '.']])]) [2, 0]","solution":"def num_paths_with_obstacles(t, test_cases): results = [] for case in test_cases: n, m, grid = case if grid[0][0] == 'x' or grid[n-1][m-1] == 'x': results.append(0) continue dp = [[0]*m for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(m): if grid[i][j] == 'x': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] results.append(dp[n-1][m-1]) return results # Example usage: # t = 2 # test_cases = [ # (3, 3, [['.', '.', '.'], ['.', 'x', '.'], ['.', '.', '.']]), # (2, 2, [['.', 'x'], ['x', '.']]) # ] # print(num_paths_with_obstacles(t, test_cases))"},{"question":"def smallest_string_length(t: int, test_cases: List[Tuple[int, str]]) -> List[int]: Find the length of the smallest string that you can obtain after performing the operation optimally. :param t: Number of test cases. :param test_cases: List of test cases, where each test case is a tuple containing an integer n (length of string) and the string s. :return: List of integers denoting the length of the smallest string that can be obtained for each test case. >>> smallest_string_length(3, [(6, \\"abccba\\"), (4, \\"aaaa\\"), (8, \\"abcddcba\\")]) [0, 0, 0] >>> smallest_string_length(2, [(1, \\"a\\"), (1, \\"b\\")]) [1, 1] >>> smallest_string_length(1, [(5, \\"abcde\\")]) [5] >>> smallest_string_length(1, [(6, \\"aabbcc\\")]) [0] >>> smallest_string_length(1, [(10, \\"abccbaabcc\\")]) [2] >>> smallest_string_length(1, [(100000, \\"a\\" * 100000)]) [0]","solution":"def smallest_string_length(t, test_cases): results = [] for i in range(t): n, s = test_cases[i] stack = [] for char in s: if stack and stack[-1] == char: stack.pop() else: stack.append(char) results.append(len(stack)) return results"},{"question":"def wiggle_sort(nums: List[int]) -> List[int]: Rearrange the array such that nums[1] > nums[0] < nums[2] > nums[3] < nums[4] > nums[5]... >>> wiggle_sort([1, 3, 2, 2]) in ([1, 3, 2, 2], [2, 3, 1, 2]) >>> wiggle_sort([4, 1]) in ([1, 4], [4, 1]) >>> wiggle_sort([6, 4, 2, 8, 5, 3]) == [4, 6, 2, 8, 3, 5] >>> wiggle_sort([8, 8, 8, 8]) == [8, 8, 8, 8] >>> wiggle_sort([1, 6, 3, 7, 2, 4]) == [1, 6, 3, 7, 2, 4] >>> wiggle_sort([1, 1, 1, 1, 1]) == [1, 1, 1, 1, 1]","solution":"def wiggle_sort(nums): Rearrange the array such that nums[1] > nums[0] < nums[2] > nums[3] < nums[4] > nums[5]... :param nums: List[int] :return: List[int] for i in range(len(nums)): if (i % 2 == 1 and nums[i] < nums[i - 1]) or (i % 2 == 0 and i > 0 and nums[i] > nums[i - 1]): nums[i], nums[i - 1] = nums[i - 1], nums[i] return nums"},{"question":"def maximize_matrix_sum(n: int, matrix: List[List[int]]) -> int: Maximize the sum of the elements in the matrix after performing any number of row/column toggles. >>> maximize_matrix_sum(3, [ ... [0, 1, 0], ... [1, 0, 1], ... [0, 1, 0] ...]) 9 >>> maximize_matrix_sum(3, [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ...]) 9 >>> maximize_matrix_sum(3, [ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ...]) 9 >>> maximize_matrix_sum(3, [ ... [1, 0, 1], ... [0, 1, 0], ... [1, 0, 1] ...]) 9 >>> maximize_matrix_sum(1, [ ... [0] ...]) 1 >>> maximize_matrix_sum(1, [ ... [1] ...]) 1","solution":"def maximize_matrix_sum(n, matrix): def toggle_row(row): for col in range(n): matrix[row][col] = 1 - matrix[row][col] def toggle_col(col): for row in range(n): matrix[row][col] = 1 - matrix[row][col] # First, toggle rows to maximize the number of 1s in the first column for row in range(n): if matrix[row][0] == 0: toggle_row(row) # Then, for each column from the second one, decide if we should toggle it for col in range(1, n): ones = sum(matrix[row][col] for row in range(n)) if ones < n / 2: toggle_col(col) # Calculate and return the sum of the elements in the matrix return sum(sum(row) for row in matrix)"},{"question":"def is_alien_sorted(alphabet: str, words: List[str]) -> str: Determines if the list of words is sorted according to the given alien alphabet. Args: alphabet (str): The alien alphabet as a permutation of the lowercase English letters. words (list): The list of words to check. Returns: str: \\"YES\\" if the words are sorted according to the alien alphabet, otherwise \\"NO\\". >>> is_alien_sorted(\\"zyxwvutsrqponmlkjihgfedcba\\", [\\"cba\\", \\"bca\\", \\"abc\\"]) \\"YES\\" >>> is_alien_sorted(\\"abcdefghijklmnopqrstuvwxyz\\", [\\"apple\\", \\"app\\"]) \\"NO\\" >>> is_alien_sorted(\\"zyxwvutsrqponmlkjihgfedcba\\", [\\"b\\", \\"a\\"]) \\"YES\\" >>> is_alien_sorted(\\"abcdefghijklmnopqrstuvwxyz\\", [\\"a\\", \\"b\\", \\"a\\"]) \\"NO\\" >>> is_alien_sorted(\\"abcdefghijklmnopqrstuvwxyz\\", [\\"a\\" * 100, \\"a\\" * 99 + \\"b\\"]) \\"YES\\" >>> is_alien_sorted(\\"abcdefghijklmnopqrstuvwxyz\\", [\\"a\\" * 99 + \\"b\\", \\"a\\" * 100]) \\"NO\\"","solution":"def is_alien_sorted(alphabet, words): Determines if the list of words is sorted according to the given alien alphabet. Args: alphabet (str): The alien alphabet as a permutation of the lowercase English letters. words (list): The list of words to check. Returns: str: \\"YES\\" if the words are sorted according to the alien alphabet, otherwise \\"NO\\". # Create a dictionary to map each alien alphabet character to its index order = {char: index for index, char in enumerate(alphabet)} # Compare each word with the next in the list for i in range(len(words) - 1): word1 = words[i] word2 = words[i + 1] # Compare characters of the two words for j in range(min(len(word1), len(word2))): if order[word1[j]] < order[word2[j]]: break elif order[word1[j]] > order[word2[j]]: return \\"NO\\" else: # If all corresponding characters are equal, the shorter word should come first if len(word1) > len(word2): return \\"NO\\" return \\"YES\\""},{"question":"from typing import List, Tuple def has_cycle(n: int, m: int, edges: List[Tuple[int, int]]) -> str: Determine if there exists a cycle in the graph. :param n: number of nodes in the graph :param m: number of edges in the graph :param edges: list of tuples representing the edges in the graph :return: \\"YES\\" if there exists a cycle, otherwise \\"NO\\" >>> has_cycle(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) 'YES' >>> has_cycle(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) 'NO' >>> has_cycle(3, 3, [(1, 2), (2, 3), (3, 1)]) 'YES' >>> has_cycle(100, 99, [(i, i + 1) for i in range(1, 100)]) 'NO' >>> has_cycle(100, 100, [(i, i + 1) for i in range(1, 100)] + [(1, 100)]) 'YES' >>> has_cycle(6, 5, [(1, 2), (2, 3), (3, 1), (4, 5), (5, 6)]) 'YES' >>> has_cycle(6, 3, [(1, 2), (3, 4), (5, 6)]) 'NO'","solution":"def has_cycle(n, m, edges): from collections import defaultdict def dfs(v, parent): visited[v] = True for neighbor in graph[v]: if not visited[neighbor]: if dfs(neighbor, v): return True elif neighbor != parent: return True return False graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = [False] * (n + 1) for i in range(1, n + 1): if not visited[i]: if dfs(i, -1): return \\"YES\\" return \\"NO\\" # Example usage: n = 4 m = 4 edges = [(1, 2), (2, 3), (3, 4), (4, 1)] print(has_cycle(n, m, edges)) # Expected output: \\"YES\\" n = 5 m = 4 edges = [(1, 2), (2, 3), (3, 4), (4, 5)] print(has_cycle(n, m, edges)) # Expected output: \\"NO\\""},{"question":"from typing import List def max_gold(gold: List[int]) -> int: Calculate the maximum amount of gold that can be stolen without robbing two consecutive houses. >>> max_gold([8, 3, 2, 5]) 13 >>> max_gold([1, 2, 9, 4, 5, 0, 4, 11, 6]) 26 pass def test_single_house(): assert max_gold([5]) == 5 def test_two_houses(): assert max_gold([5, 10]) == 10 assert max_gold([10, 5]) == 10 def test_three_houses(): assert max_gold([5, 3, 10]) == 15 assert max_gold([1, 2, 3]) == 4 def test_multiple_houses(): assert max_gold([8, 3, 2, 5]) == 13 assert max_gold([1, 2, 9, 4, 5, 0, 4, 11, 6]) == 26 assert max_gold([2, 1, 1, 2]) == 4 def test_alternating_houses(): assert max_gold([10, 5, 10, 5, 10, 5]) == 30 def test_large_input(): gold = [10] * 100000 assert max_gold(gold) == 500000","solution":"from typing import List def max_gold(gold: List[int]) -> int: Calculate the maximum amount of gold that can be stolen without robbing two consecutive houses. if not gold: return 0 n = len(gold) if n == 1: return gold[0] if n == 2: return max(gold[0], gold[1]) # Initialization of the maximum gold we can get up to house 0 and up to house 1 prev2 = gold[0] prev1 = max(gold[0], gold[1]) for i in range(2, n): current = max(prev1, prev2 + gold[i]) prev2 = prev1 prev1 = current return prev1"},{"question":"class SocialNetwork: def __init__(self, n): Initialize the social network with n users. pass def add_follow(self, a, b): Add a follow relationship between user a and user b. pass def remove_follow(self, a, b): Remove a follow relationship between user a and user b. pass def check_path(self, a, b): Check if there is a path of follow relationships from user a to user b. Return True if such a path exists, otherwise False. pass def process_queries(n, queries): Process a list of queries for a social network with n users. Each query modifies the network or checks for a following path. Args: n: The number of users in the social network. queries: A list of query strings. Returns: A list of results for queries that check for a following path. >>> process_queries(5, [\\"1 1 2\\", \\"1 2 3\\", \\"3 1 3\\", \\"2 2 3\\", \\"3 1 3\\"]) [\\"YES\\", \\"NO\\"] >>> process_queries(3, [\\"1 1 2\\", \\"1 2 3\\", \\"3 1 3\\", \\"2 1 2\\", \\"3 1 3\\"]) [\\"YES\\", \\"NO\\"] >>> process_queries(2, [\\"1 1 2\\", \\"3 1 2\\"]) [\\"YES\\"] >>> process_queries(3, [\\"1 1 2\\", \\"1 2 3\\", \\"3 1 3\\"]) [\\"YES\\"] >>> process_queries(3, [\\"1 1 2\\", \\"1 2 3\\", \\"1 3 1\\", \\"3 3 1\\"]) [\\"YES\\"] pass","solution":"class SocialNetwork: def __init__(self, n): self.n = n self.follows = {i: set() for i in range(1, n+1)} def add_follow(self, a, b): self.follows[a].add(b) def remove_follow(self, a, b): if b in self.follows[a]: self.follows[a].remove(b) def check_path(self, a, b): visited = set() return self._dfs(a, b, visited) def _dfs(self, current, target, visited): if current == target: return True visited.add(current) for follower in self.follows[current]: if follower not in visited: if self._dfs(follower, target, visited): return True return False def process_queries(n, queries): network = SocialNetwork(n) results = [] for query in queries: parts = query.split() command = int(parts[0]) a, b = int(parts[1]), int(parts[2]) if command == 1: network.add_follow(a, b) elif command == 2: network.remove_follow(a, b) elif command == 3: if network.check_path(a, b): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"from typing import List def can_choose_subset(m: int, f: int, preferences: List[List[int]]) -> str: Determine if Snark and Philip can choose a non-empty subset of games that makes the game night enjoyable for all their friends. :param m: Number of games :param f: Number of friends :param preferences: List of lists where each inner list represents each friend's game preferences :return: \\"YES\\" if such a subset exists, \\"NO\\" otherwise pass def test_case_1(): m = 5 f = 3 preferences = [ [1, 0, 0, 1, 0], [0, 1, 1, 0, 0], [1, 1, 0, 0, 1] ] assert can_choose_subset(m, f, preferences) == \\"YES\\" def test_case_2(): m = 2 f = 2 preferences = [ [1, 0], [0, 1] ] assert can_choose_subset(m, f, preferences) == \\"YES\\" def test_case_3(): m = 3 f = 3 preferences = [ [1, 0, 0], [0, 1, 0], [0, 0, 0] ] assert can_choose_subset(m, f, preferences) == \\"NO\\" def test_case_4(): m = 4 f = 2 preferences = [ [1, 1, 0, 0], [0, 0, 1, 1] ] assert can_choose_subset(m, f, preferences) == \\"YES\\" def test_case_5(): m = 1 f = 1 preferences = [ [1] ] assert can_choose_subset(m, f, preferences) == \\"YES\\"","solution":"from itertools import combinations def can_choose_subset(m, f, preferences): Determine if there is a non-empty subset of games that all friends will enjoy. :param m: Number of games :param f: Number of friends :param preferences: List of lists where each inner list represents each friend's game preferences :return: \\"YES\\" if such a subset exists, \\"NO\\" otherwise for subset_size in range(1, m + 1): for game_subset in combinations(range(m), subset_size): if all(any(preferences[friend][game] == 1 for game in game_subset) for friend in range(f)): return \\"YES\\" return \\"NO\\""},{"question":"def solve_grid_reach(m: int, n: int, grid: List[str], sx: int, sy: int, dx: int, dy: int) -> str: Determine if the ball can reach the destination from the start position in an infinite number of moves. m: number of rows in the grid n: number of columns in the grid grid: a list of strings representing the grid where '.' indicates a blank cell and '#' indicates an obstacle sx: starting row position of the ball (1-based index) sy: starting column position of the ball (1-based index) dx: destination row position of the ball (1-based index) dy: destination column position of the ball (1-based index) Returns \\"YES\\" if the ball can reach the destination, otherwise \\"NO\\". >>> solve_grid_reach(5, 5, [\\".....\\", \\".#...\\", \\".#.\\", \\".....\\", \\".#...\\"], 1, 1, 4, 5) YES >>> solve_grid_reach(3, 3, [\\".#.\\", \\".#.\\", \\".#.\\"], 1, 1, 3, 3) NO","solution":"def can_reach_destination(grid, start, destination): m, n = len(grid), len(grid[0]) visited = [[False] * n for _ in range(m)] def has_path(x, y, dx, dy): if not (0 <= x < m and 0 <= y < n) or grid[x][y] == '#' or visited[x][y]: return False if (x, y) == (dx, dy): return True visited[x][y] = True # Move in all four directions return (has_path(x + 1, y, dx, dy) or has_path(x - 1, y, dx, dy) or has_path(x, y + 1, dx, dy) or has_path(x, y - 1, dx, dy)) # Convert to 0-based index sx, sy = start[0] - 1, start[1] - 1 dx, dy = destination[0] - 1, destination[1] - 1 return \\"YES\\" if has_path(sx, sy, dx, dy) else \\"NO\\" def solve_grid_reach(m, n, grid, sx, sy, dx, dy): return can_reach_destination(grid, (sx, sy), (dx, dy)) # Example usage: m, n = 5, 5 grid = [ \\".....\\", \\".#...\\", \\".#.\\", \\".....\\", \\".#...\\" ] sx, sy, dx, dy = 1, 1, 4, 5 print(solve_grid_reach(m, n, grid, sx, sy, dx, dy)) # Output: YES"},{"question":"def longest_contiguous_subarray_length(n: int, k: int, arr: List[int]) -> int: Returns the length of the longest contiguous subarray where the absolute difference between any two elements is less than or equal to a given integer k. >>> longest_contiguous_subarray_length(6, 3, [1, 3, 2, 4, 6, 7]) 4 >>> longest_contiguous_subarray_length(5, 5, [2, 5, 1, 3, 4]) 5 >>> longest_contiguous_subarray_length(5, 0, [1, 2, 3, 4, 5]) 1 >>> longest_contiguous_subarray_length(1, 0, [10]) 1 >>> longest_contiguous_subarray_length(0, 5, []) 0 >>> longest_contiguous_subarray_length(5, 1000000000, [2, 4, 6, 8, 10]) 5 >>> longest_contiguous_subarray_length(4, 0, [7, 7, 7, 7]) 4 pass","solution":"def longest_contiguous_subarray_length(n, k, arr): Returns the length of the longest contiguous subarray where the absolute difference between any two elements is less than or equal to k. if n == 0: return 0 start = 0 # start index of the current contiguous subarray max_length = 1 # length of the longest contiguous subarray found min_val = arr[0] # minimum value in the current contiguous subarray max_val = arr[0] # maximum value in the current contiguous subarray for end in range(1, n): min_val = min(min_val, arr[end]) max_val = max(max_val, arr[end]) # If the absolute difference between min and max in current subarray is greater than k # Move the start index to the right while max_val - min_val > k: start += 1 min_val = min(arr[start:end + 1]) max_val = max(arr[start:end + 1]) max_length = max(max_length, end - start + 1) return max_length"},{"question":"def minimize_sum_of_max_elements(arr: List[int], k: int) -> int: Partition the array into exactly k non-empty contiguous subarrays such that the sum of the maximum elements of these subarrays is minimized. :param arr: List[int] -- Array of integers :param k: int -- Number of partitions :return: int -- Minimized sum of the maximum elements of these k subarrays >>> minimize_sum_of_max_elements([10, 1, 2, 7, 5, 6], 3) 18 >>> minimize_sum_of_max_elements([10, 20, 30, 40], 2) 50 >>> minimize_sum_of_max_elements([5], 1) 5 >>> minimize_sum_of_max_elements([3, 3, 3, 3], 2) 6 >>> minimize_sum_of_max_elements([7, 2, 5, 10, 8], 5) 32 >>> minimize_sum_of_max_elements([1, 2, 3, 4, 5, 6], 1) 6","solution":"def minimize_sum_of_max_elements(arr, k): n = len(arr) # Create a dp table where dp[i][j] represents the minimized sum of the max elements # for array up to i with j partitions dp = [[float('inf')] * (k + 1) for _ in range(n + 1)] # Initialize the base case: no elements, no sum dp[0][0] = 0 # Precompute the maximum element between points max_val = [[0] * n for _ in range(n)] for i in range(n): current_max = arr[i] for j in range(i, n): current_max = max(current_max, arr[j]) max_val[i][j] = current_max # Fill the DP table for i in range(1, n + 1): for j in range(1, k + 1): for x in range(1, i + 1): dp[i][j] = min(dp[i][j], dp[i - x][j - 1] + max_val[i - x][i - 1]) return dp[n][k]"},{"question":"def prepare_lunchboxes(n: int, m: int, p: List[int], c: List[int], L: int, R: int) -> Union[List[int], int]: Determines if it's possible to prepare 'm' lunchboxes with given food items, proteins, carbs, and range. Parameters: n (int): Number of food items. m (int): Number of lunchboxes. p (List[int]): List of proteins for each food item. c (List[int]): List of carbohydrates for each food item. L (int): Lower bound of the range. R (int): Upper bound of the range. Returns: Union[List[int], int]: List of indices of chosen food items if possible, -1 if not possible. >>> prepare_lunchboxes(4, 3, [10, 20, 30, 40], [15, 25, 10, 30], 20, 50) [1, 2, 4] >>> prepare_lunchboxes(4, 5, [10, 20, 30, 40], [15, 25, 10, 30], 20, 50) -1 >>> prepare_lunchboxes(3, 3, [10, 20, 30], [15, 20, 10], 20, 45) [1, 2, 3] >>> prepare_lunchboxes(4, 1, [1, 2, 3, 4], [19, 18, 17, 16], 20, 20) [1] >>> prepare_lunchboxes(3, 2, [1, 2, 3], [8, 9, 10], 20, 25) -1","solution":"def prepare_lunchboxes(n, m, p, c, L, R): food_items = [] # Calculate total grams of each food type and filter within the range L to R for i in range(n): total = p[i] + c[i] if L <= total <= R: food_items.append(i + 1) if len(food_items) < m: return -1 # Return any m valid foods return food_items[:m]"},{"question":"def max_difficulty_sum(m: int, d: int, difficulties: List[int], categories: List[int], bonuses: List[int]) -> int: Given the number of problems, the maximum difficulty threshold, the difficulties of each problem, the category of each problem, and the bonus difficulty points for each category, return the maximum difficulty sum that does not exceed the difficulty threshold. >>> max_difficulty_sum(5, 15, [5, 7, 8, 3, 4], [1, 2, 3, 1, 2], [1, 4, 2, 5, 3, 4, 6, 8, 9, 10]) == 15 >>> max_difficulty_sum(3, 10, [2, 3, 4], [1, 1, 1], [0]) == 9 >>> max_difficulty_sum(1, 5, [4], [2], [3]) == 4 >>> max_difficulty_sum(4, 20, [5, 7, 8, 2], [1, 2, 3, 4], [2, 3, 4, 1]) == 20 >>> max_difficulty_sum(3, 10, [2, 3, 4], [1, 2, 3], [0, 0, 0]) == 9","solution":"def max_difficulty_sum(m, d, difficulties, categories, bonuses): from itertools import combinations # Dictionary to store the bonus points for each category bonus_dict = {i + 1: bonuses[i] for i in range(len(bonuses))} max_sum = 0 # Generate all possible subsets of problems for r in range(1, m + 1): for subset in combinations(range(m), r): current_difficulty = 0 for i in subset: current_difficulty += difficulties[i] + bonus_dict.get(categories[i], 0) if current_difficulty <= d: max_sum = max(max_sum, current_difficulty) return max_sum"},{"question":"from typing import List def first_repeated_song(n: int, playlists: List[List[int]]) -> int: Finds the first occurrence of a repeated song across multiple playlists. Args: n : int : number of bands playlists : list : list of playlists, where each playlist is a list of songs Returns: int : the first repeated song, or -1 if no song is repeated Examples: >>> first_repeated_song(3, [[4, 1, 2, 3, 4], [3, 5, 6, 7], [5, 3, 8, 9, 10, 1]]) 3 >>> first_repeated_song(3, [[4, 1, 2, 3, 4], [3, 5, 6, 7], [5, 8, 9, 10, 11, 12]]) -1","solution":"def first_repeated_song(n, playlists): Finds the first occurrence of a repeated song across multiple playlists. Args: n : int : number of bands playlists : list : list of playlists, where each playlist is a list of songs Returns: int : the first repeated song, or -1 if no song is repeated song_occurrences = {} for playlist in playlists: for song in playlist[1:]: if song in song_occurrences: return song song_occurrences[song] = True return -1"},{"question":"def trap_rain_water(heights): Given a list of non-negative integers representing the heights of blocks, compute the amount of water that can be trapped after raining. >>> trap_rain_water([]) == 0 >>> trap_rain_water([1]) == 0 >>> trap_rain_water([0]) == 0 >>> trap_rain_water([1, 2]) == 0 >>> trap_rain_water([2, 1]) == 0 >>> trap_rain_water([1, 2, 1]) == 0 >>> trap_rain_water([2, 1, 2]) == 1 >>> trap_rain_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 >>> trap_rain_water([4, 2, 0, 3, 2, 5]) == 9 >>> trap_rain_water([0, 0, 0, 0]) == 0 >>> trap_rain_water([3, 3, 3, 3]) == 0 >>> trap_rain_water([4, 3, 2, 1]) == 0 >>> trap_rain_water([1, 2, 3, 4]) == 0","solution":"def trap_rain_water(heights): Given a list of non-negative integers representing the heights of blocks, compute the amount of water that can be trapped after raining. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"from collections import deque from typing import List, Tuple def manage_operations(n: int, operations: List[Tuple[int, int, int]]) -> List[int]: Manages the state of the queue after each remembered operation. Args: n (int): The number of operations. operations (List[Tuple[int, int, int]]): A list of operations represented by tuples. Each tuple contains: - The index of the remembered operation in the original sequence. - The type of operation (0 for dequeuing, 1 for enqueuing). - The identifier of the container being added (only for enqueuing operations). Returns: List[int]: The identifier of the container at the front of the queue after performing all the operations Anna has remembered until that step. If the queue is empty, returns -1. Example: >>> manage_operations(5, [(1, 1, 101), (2, 1, 102), (3, 0), (4, 1, 103), (5, 0)]) [101, 101, 102, 102, 103] >>> manage_operations(1, [(1, 1, 500)]) [500] >>> manage_operations(1, [(1, 0)]) [-1] >>> manage_operations(6, [(1, 1, 300), (2, 0), (3, 1, 200), (4, 1, 400), (5, 0), (6, 0)]) [300, -1, 200, 200, 400, -1] >>> manage_operations(6, [(1, 1, 10), (2, 1, 20), (3, 1, 30), (4, 0), (5, 0), (6, 0)]) [10, 10, 10, 20, 30, -1] >>> manage_operations(3, [(1, 1, 50), (2, 0), (3, 0)]) [50, -1, -1]","solution":"from collections import deque def manage_operations(n, operations): queue = deque() output = [] # Sort operations by their indexed order for processing operations.sort() for op in operations: if op[1] == 1: queue.append(op[2]) elif op[1] == 0: if queue: queue.popleft() if queue: output.append(queue[0]) else: output.append(-1) return output"},{"question":"def find_redundant_connections(n, m, connections): Mira wants to design a new video game with an expansive world map consisting of interconnected dungeons. Each dungeon is represented as a node, and each direct path between two dungeons is represented as an undirected edge. Mira needs to ensure that the game player can reach every dungeon from any starting dungeon; therefore, the map must be connected. Mira has a list of potential dungeons and their connections, but she noticed that if some connections were removed, the network would still be connected. Mira wants to identify such connections because they represent redundant paths that, if cut, still keep the whole map accessible. Given the number of dungeons and a list of connections, help Mira find all the redundant connections in the map. A connection is redundant if removing it does not disconnect the map. Args: - n (int): The number of dungeons. - m (int): The number of connections. - connections (List[Tuple[int, int]]): A list of m connections, each denoted as a tuple (u, v). Returns: - List[Tuple[int, int]]: A list of redundant connections. def handle_io(input_data): Handles input and output for the redundancy detection problem. Args: - input_data (str): Multi-line string containing the input data. Returns: - str: Multi-line string containing the number of redundant connections and the list of redundant connections. >>> handle_io(\\"5 6n1 2n1 3n2 3n2 4n3 4n4 5\\") \\"2n2 3n3 4\\" >>> handle_io(\\"5 0\\") \\"0\\" >>> handle_io(\\"4 3n1 2n2 3n3 4\\") \\"0\\" >>> handle_io(\\"4 4n1 2n2 3n3 4n4 1\\") \\"1n4 1\\" >>> handle_io(\\"6 8n1 2n2 3n3 1n3 4n4 5n5 6n6 4n1 6\\") \\"3n3 1n6 4n1 6\\"","solution":"def find_redundant_connections(n, m, connections): parent = list(range(n + 1)) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootY] = rootX return False return True redundant = [] for u, v in connections: if union(u, v): redundant.append((u, v)) return redundant def handle_io(input_data): data = input_data.strip().split('n') n, m = map(int, data[0].split()) connections = [] for i in range(1, m + 1): u, v = map(int, data[i].split()) connections.append((u, v)) result = find_redundant_connections(n, m, connections) output = f\\"{len(result)}n\\" for con in result: output += f\\"{con[0]} {con[1]}n\\" return output.strip()"},{"question":"def can_distribute_equally(n: int, capacities: List[int]) -> str: Determines if the water bottles can be equally distributed in terms of volume Parameters: n (int): number of water bottles capacities (list): list of integers representing the capacities of the bottles (500 or 1000) Returns: str: \\"YES\\" if it's possible to distribute equally, \\"NO\\" otherwise Examples: >>> can_distribute_equally(3, [500, 1000, 500]) == \\"YES\\" >>> can_distribute_equally(4, [1000, 1000, 1000, 500]) == \\"NO\\" from solution import can_distribute_equally def test_can_distribute_equally_example1(): assert can_distribute_equally(3, [500, 1000, 500]) == \\"YES\\" def test_can_distribute_equally_example2(): assert can_distribute_equally(4, [1000, 1000, 1000, 500]) == \\"NO\\" def test_can_distribute_equally_all_500(): assert can_distribute_equally(4, [500, 500, 500, 500]) == \\"YES\\" def test_can_distribute_equally_all_1000_odd(): assert can_distribute_equally(3, [1000, 1000, 1000]) == \\"NO\\" def test_can_distribute_equally_mix_even(): assert can_distribute_equally(6, [500, 1000, 500, 1000, 500, 500]) == \\"YES\\" def test_can_distribute_equally_single_bottle(): assert can_distribute_equally(1, [500]) == \\"NO\\" assert can_distribute_equally(1, [1000]) == \\"NO\\" def test_can_distribute_equally_just_enough_1000(): assert can_distribute_equally(2, [1000, 1000]) == \\"YES\\" def test_can_distribute_equally_extra_500(): assert can_distribute_equally(5, [500, 500, 500, 500, 1000]) == \\"YES\\"","solution":"def can_distribute_equally(n, capacities): Determines if the water bottles can be equally distributed in terms of volume Parameters: n (int): number of water bottles capacities (list): list of integers representing the capacities of the bottles (500 or 1000) Returns: str: \\"YES\\" if it's possible to distribute equally, \\"NO\\" otherwise total_volume = sum(capacities) # If the total volume is odd, it's impossible to split equally if total_volume % 2 != 0: return \\"NO\\" half_volume = total_volume // 2 count_500 = capacities.count(500) count_1000 = capacities.count(1000) # Try to form half_volume using given counts of 500 and 1000 ml bottles for i in range(count_1000 + 1): if i * 1000 > half_volume: continue remaining = half_volume - (i * 1000) if remaining % 500 == 0 and remaining // 500 <= count_500: return \\"YES\\" return \\"NO\\""},{"question":"from typing import List, Tuple def shortest_path(xA: int, yA: int, xB: int, yB: int, obstacles: List[Tuple[int, int, int, int]]) -> int: Determines the shortest path from point A to point B avoiding obstacles. Args: xA: int - x-coordinate of point A yA: int - y-coordinate of point A xB: int - x-coordinate of point B yB: int - y-coordinate of point B obstacles: List[Tuple[int, int, int, int]] - List of obstacles represented by their lower-left and upper-right coordinates Returns: int: The minimum cable length required to connect points A and B, or -1 if impossible. >>> shortest_path(0, 0, 5, 5, []) 10 >>> shortest_path(0, 0, 10, 10, [(2, 2, 4, 4), (5, 5, 7, 7)]) 20 pass if __name__ == \\"__main__\\": import pytest from solution import shortest_path def test_no_obstacles_direct_path(): assert shortest_path(0, 0, 5, 5, []) == 10 def test_with_obstacles(): obstacles = [(2, 2, 4, 4), (5, 5, 7, 7)] assert shortest_path(0, 0, 10, 10, obstacles) == 20 def test_start_point_in_obstacle(): obstacles = [(2, 2, 4, 4)] assert shortest_path(3, 3, 10, 10, obstacles) == -1 def test_end_point_in_obstacle(): obstacles = [(8, 8, 10, 10)] assert shortest_path(0, 0, 9, 9, obstacles) == -1 def test_no_path_possible(): obstacles = [(2, 2, 4, 4), (6, 6, 8, 8)] assert shortest_path(0, 0, 10, 10, obstacles) == 20 # Open path around def test_start_and_end_same(): obstacles = [(2, 2, 4, 4), (6, 6, 8, 8)] assert shortest_path(0, 0, 0, 0, obstacles) == 0 pytest.main()","solution":"from collections import deque def is_point_within_any_obstacle(x, y, obstacles): for x1, y1, x2, y2 in obstacles: if x1 <= x <= x2 and y1 <= y <= y2: return True return False def shortest_path(xA, yA, xB, yB, obstacles): if (xA, yA) == (xB, yB): return 0 if is_point_within_any_obstacle(xA, yA, obstacles) or is_point_within_any_obstacle(xB, yB, obstacles): return -1 queue = deque([(xA, yA, 0)]) visited = set((xA, yA)) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] while queue: x, y, dist = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if (nx, ny) == (xB, yB): return dist + 1 if not is_point_within_any_obstacle(nx, ny, obstacles) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"def shortest_path(n: int, grid: List[str]) -> int: Determine the length of the shortest path from the top-left to the bottom-right of the grid. If no such path exists, return -1. Parameters: n (int): the size of the grid grid (List[str]): the grid represented as a list of strings Returns: int: the length of the shortest path or -1 if no path exists Example: >>> shortest_path(3, [\\"...\\", \\"#.#\\", \\"...\\"]) 4 >>> shortest_path(3, [\\"...\\", \\"#\\", \\"...\\"]) -1 import pytest def test_shortest_path(): n = 3 grid1 = [\\"...\\", \\"#.#\\", \\"...\\"] grid2 = [\\"...\\", \\"#\\", \\"...\\"] assert shortest_path(n, grid1) == 4 assert shortest_path(n, grid2) == -1 n = 1 grid3 = [\\".\\"] assert shortest_path(n, grid3) == 0 n = 2 grid4 = [\\".#\\", \\"#.\\"] assert shortest_path(n, grid4) == -1 n = 2 grid5 = [\\"..\\", \\"..\\"] assert shortest_path(n, grid5) == 2 n = 2 grid6 = [\\"#.\\", \\"..\\"] grid7 = [\\"..\\", \\".#\\"] assert shortest_path(n, grid6) == -1 assert shortest_path(n, grid7) == -1","solution":"from collections import deque def shortest_path(n, grid): Determine the length of the shortest path from the top-left to the bottom-right of the grid. If no such path exists, return -1. if grid[0][0] == '#' or grid[n-1][n-1] == '#': return -1 directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] queue = deque([(0, 0, 0)]) # (x, y, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if x == n-1 and y == n-1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] == '.': visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"def unique_paths_with_obstacles(grid): Determine the number of unique paths the robot can take to reach the bottom-right corner of the grid while avoiding obstacles. >>> unique_paths_with_obstacles([ ... [\\".\\" , \\".\\" , \\".\\"], ... [\\".\\" , \\"#\\" , \\".\\"], ... [\\".\\" , \\".\\" , \\".\\"] ... ]) 2 >>> unique_paths_with_obstacles([ ... [\\".\\" , \\".\\"], ... [\\".\\" , \\".\\"] ... ]) 2 def number_of_unique_paths(t, test_cases): For each test case, find the number of unique paths for the corresponding grid configuration. >>> number_of_unique_paths(2, [ ... (3, 3, [ ... [\\".\\" , \\".\\" , \\".\\"], ... [\\".\\" , \\"#\\" , \\".\\"], ... [\\".\\" , \\".\\" , \\".\\"] ... ]), ... (2, 2, [ ... [\\".\\" , \\".\\"], ... [\\".\\" , \\".\\"] ... ]) ... ]) [2, 2]","solution":"def unique_paths_with_obstacles(grid): n = len(grid) m = len(grid[0]) # If the start or end is an obstacle, return 0 if grid[0][0] == '#' or grid[n-1][m-1] == '#': return 0 dp = [[0] * m for _ in range(n)] # Initialize starting point dp[0][0] = 1 # Fill the dp table for i in range(n): for j in range(m): if grid[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[n-1][m-1] def number_of_unique_paths(t, test_cases): results = [] for i in range(t): n, m, grid = test_cases[i] results.append(unique_paths_with_obstacles(grid)) return results"},{"question":"def max_gold(n: int, m: int, grid: List[List[int]]) -> int: Returns the maximum amount of gold that can be collected by the miner starting from top-left to bottom-right. The miner can only move right or down from any cell. Args: n : int : number of rows in the grid m : int : number of columns in the grid grid : List[List[int]] : 2D list containing the amount of gold in each cell Returns: int : maximum amount of gold that can be collected Examples: >>> max_gold(3, 3, [ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 12 >>> max_gold(1, 5, [ ... [0, 1, 2, 3, 4] ... ]) 10 pass def test_max_gold_simple_case(): assert max_gold(3, 3, [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ]) == 12 def test_max_gold_single_row(): assert max_gold(1, 5, [ [0, 1, 2, 3, 4] ]) == 10 def test_max_gold_single_column(): assert max_gold(5, 1, [ [0], [1], [2], [3], [4] ]) == 10 def test_max_gold_all_zeros(): assert max_gold(2, 2, [ [0, 0], [0, 0] ]) == 0 def test_max_gold_large_values(): assert max_gold(3, 3, [ [100, 100, 100], [100, 100, 100], [100, 100, 100] ]) == 500 def test_max_gold_large_grid(): n, m = 1000, 1000 grid = [[1 for _ in range(m)] for _ in range(n)] assert max_gold(n, m, grid) == 1999","solution":"def max_gold(n, m, grid): Returns the maximum amount of gold that can be collected by the miner. # Create a dynamic programming table with the same dimensions dp = [[0] * m for _ in range(n)] # Initialize the starting cell dp[0][0] = grid[0][0] # Fill the first row for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, n): for j in range(1, m): dp[i][j] = grid[i][j] + max(dp[i-1][j], dp[i][j-1]) # The bottom-right cell holds the maximum amount of gold collected return dp[n-1][m-1]"},{"question":"def can_stack_sort(n: int, sequence: List[int]) -> str: Determines if a given sequence can be stack-sorted. Parameters: - n: int : length of the sequence (1  n  100) - sequence: list of ints : the sequence to be considered for stack sorting Returns: - str : \\"YES\\" if the sequence can be sorted using a single stack, otherwise \\"NO\\" >>> can_stack_sort(5, [4, 1, 3, 2, 5]) \\"YES\\" >>> can_stack_sort(5, [3, 4, 5, 1, 2]) \\"NO\\" >>> can_stack_sort(5, [1, 2, 3, 4, 5]) \\"YES\\" >>> can_stack_sort(5, [5, 4, 3, 2, 1]) \\"YES\\" >>> can_stack_sort(1, [1]) \\"YES\\" >>> can_stack_sort(5, [2, 1, 4, 3, 5]) \\"YES\\" >>> can_stack_sort(5, [2, 5, 3, 4, 1]) \\"NO\\" # Test cases assert can_stack_sort(5, [4, 1, 3, 2, 5]) == \\"YES\\" assert can_stack_sort(5, [3, 4, 5, 1, 2]) == \\"NO\\" assert can_stack_sort(5, [1, 2, 3, 4, 5]) == \\"YES\\" assert can_stack_sort(5, [5, 4, 3, 2, 1]) == \\"YES\\" assert can_stack_sort(1, [1]) == \\"YES\\" assert can_stack_sort(5, [2, 1, 4, 3, 5]) == \\"YES\\" assert can_stack_sort(5, [2, 5, 3, 4, 1]) == \\"NO\\"","solution":"def can_stack_sort(n, sequence): Determines if a given sequence can be stack-sorted. Parameters: - n: int : length of the sequence (1  n  100) - sequence: list of ints : the sequence to be considered for stack sorting Returns: - str : \\"YES\\" if the sequence can be sorted using a single stack, otherwise \\"NO\\" stack = [] current = 1 for value in sequence: while stack and stack[-1] == current: stack.pop() current += 1 if value == current: current += 1 else: stack.append(value) while stack and stack[-1] == current: stack.pop() current += 1 return \\"YES\\" if current == n + 1 else \\"NO\\""},{"question":"def does_robot_return_to_origin(n: int, s: str) -> str: Determines if the robot returns to its starting position after the sequence of moves. Parameters: - n : int : the length of the move sequence - s : str : the sequence of moves Returns: - str : \\"YES\\" if the robot returns to the starting position, otherwise \\"NO\\" Examples: >>> does_robot_return_to_origin(4, \\"UDLR\\") \\"YES\\" >>> does_robot_return_to_origin(5, \\"UUDDL\\") \\"NO\\" from solution import does_robot_return_to_origin def test_robot_returns_to_origin(): assert does_robot_return_to_origin(4, \\"UDLR\\") == \\"YES\\" def test_robot_does_not_return_to_origin(): assert does_robot_return_to_origin(5, \\"UUDDL\\") == \\"NO\\" assert does_robot_return_to_origin(1, \\"U\\") == \\"NO\\" assert does_robot_return_to_origin(6, \\"UUDDLL\\") == \\"NO\\" def test_robot_moves_in_balanced_way(): assert does_robot_return_to_origin(8, \\"UUDDLRLR\\") == \\"YES\\" def test_edge_case_single_move(): assert does_robot_return_to_origin(1, \\"D\\") == \\"NO\\" assert does_robot_return_to_origin(1, \\"L\\") == \\"NO\\" def test_edge_case_no_move(): assert does_robot_return_to_origin(0, \\"\\") == \\"YES\\"","solution":"def does_robot_return_to_origin(n, s): Determines if the robot returns to its starting position after the sequence of moves. Parameters: - n : int : the length of the move sequence - s : str : the sequence of moves Returns: - str : \\"YES\\" if the robot returns to the starting position, otherwise \\"NO\\" x, y = 0, 0 # Start at the origin (0, 0) for move in s: if move == 'U': y += 1 elif move == 'D': y -= 1 elif move == 'L': x -= 1 elif move == 'R': x += 1 return \\"YES\\" if x == 0 and y == 0 else \\"NO\\""},{"question":"def can_make_equal(n: int, arr: List[int]) -> str: Determines if it's possible to make all the remaining values in the list equal after performing the given operation any number of times. Parameters: n (int): Number of integers in the list arr (list of int): The list of integers Returns: str: 'YES' if it's possible, otherwise 'NO' pass # Test cases from solution import can_make_equal def test_can_make_equal_all_equal(): assert can_make_equal(4, [4, 4, 4, 4]) == \\"YES\\" assert can_make_equal(1, [1]) == \\"YES\\" def test_can_make_equal_not_possible(): assert can_make_equal(3, [1, 2, 2]) == \\"NO\\" assert can_make_equal(5, [10, 20, 10, 20, 20]) == \\"NO\\" def test_can_make_equal_edge_cases(): assert can_make_equal(2, [1, 1]) == \\"YES\\" assert can_make_equal(2, [1, 2]) == \\"NO\\"","solution":"def can_make_equal(n, arr): Determines if it's possible to make all the remaining values in the list equal after performing the given operation any number of times. Parameters: n (int): Number of integers in the list arr (list of int): The list of integers Returns: str: 'YES' if it's possible, otherwise 'NO' return \\"YES\\" if max(arr) - min(arr) == 0 else \\"NO\\""},{"question":"import math from typing import Tuple def calculate_distance(point1: Tuple[int, int], point2: Tuple[int, int]) -> float: return math.sqrt((point2[0] - point1[0])**2 + (point2[1] - point1[1])**2) def can_complete_route(S: int, R: Tuple[int, int], F: Tuple[int, int], W: Tuple[int, int]) -> bool: Determines if the route R -> F -> W -> R can be completed within the stamina limit S. Parameters: - S: int, the stamina limit. - R: tuple of (int, int), coordinates of the roller coaster. - F: tuple of (int, int), coordinates of the Ferris wheel. - W: tuple of (int, int), coordinates of the water ride. Returns: - bool: True if the route can be completed within the stamina limit S, False otherwise. Examples: >>> can_complete_route(25, (0, 0), (3, 4), (6, 8)) True >>> can_complete_route(15, (0, 0), (3, 4), (6, 8)) False >>> can_complete_route(20, (0, 0), (3, 4), (6, 8)) True >>> can_complete_route(0, (0, 0), (0, 0), (0, 0)) True >>> can_complete_route(15000, (0, 0), (5000, 5000), (10000, 10000)) False","solution":"import math def calculate_distance(point1, point2): return math.sqrt((point2[0] - point1[0])**2 + (point2[1] - point1[1])**2) def can_complete_route(S, R, F, W): Determines if the route R -> F -> W -> R can be completed within the stamina limit S. Parameters: - S: int, the stamina limit. - R: tuple of (int, int), coordinates of the roller coaster. - F: tuple of (int, int), coordinates of the Ferris wheel. - W: tuple of (int, int), coordinates of the water ride. Returns: - bool: True if the route can be completed within the stamina limit S, False otherwise. distance_RF = calculate_distance(R, F) distance_FW = calculate_distance(F, W) distance_WR = calculate_distance(W, R) total_distance = distance_RF + distance_FW + distance_WR return total_distance <= S"},{"question":"class ArrayProcessor: def __init__(self, array): Initialize the ArrayProcessor with the given array. self.array = array def update(self, index: int, value: int) -> None: Update the value at the specified index in the array. def query_sum(self) -> int: Query the sum of all elements in the array. def process_operations(n: int, q: int, array: List[int], operations: List[Tuple[int, ...]]) -> List[int]: Process the given list of operations on the array and return the results. Args: n : int : number of elements in the array q : int : number of operations array : List[int] : initial elements of the array operations : List[Tuple[int, ...]] : operations to be performed on the array Returns: List[int]: results of the query operations results = [] processor = ArrayProcessor(array) for operation in operations: if operation[0] == 1: index = operation[1] value = operation[2] processor.update(index, value) elif operation[0] == 2: results.append(processor.query_sum()) return results from typing import List, Tuple","solution":"class ArrayProcessor: def __init__(self, array): self.array = array self.total_sum = sum(array) def update(self, index, value): old_value = self.array[index] self.array[index] = value self.total_sum += value - old_value def query_sum(self): return self.total_sum def process_operations(n, q, array, operations): results = [] processor = ArrayProcessor(array) for operation in operations: if operation[0] == 1: index = operation[1] value = operation[2] processor.update(index, value) elif operation[0] == 2: results.append(processor.query_sum()) return results"},{"question":"def most_frequent_pattern(n: int, s: str) -> str: Identify the most frequent n-length substring (pattern) in the given string s. If there are multiple patterns with the same highest frequency, return the lexicographically smallest one. Args: n (int): The length of the patterns to find. s (str): The intercepted message. Returns: str: The most frequent n-length pattern. Examples: >>> most_frequent_pattern(3, \\"ababcabcababc\\") \\"abc\\" >>> most_frequent_pattern(2, \\"aaabbbccc\\") \\"aa\\" from solution import most_frequent_pattern def test_example1(): n = 3 s = \\"ababcabcababc\\" assert most_frequent_pattern(n, s) == \\"abc\\" def test_example2(): n = 2 s = \\"aaabbbccc\\" assert most_frequent_pattern(n, s) == \\"aa\\" def test_single_character_repeats(): n = 1 s = \\"aabbaabbccddeeff\\" assert most_frequent_pattern(n, s) == \\"a\\" def test_tied_patterns(): n = 2 s = \\"abcabcabcd\\" assert most_frequent_pattern(n, s) == \\"ab\\" def test_large_input(): n = 4 s = \\"a\\" * 1000000 assert most_frequent_pattern(n, s) == \\"aaaa\\"","solution":"def most_frequent_pattern(n, s): from collections import defaultdict pattern_count = defaultdict(int) for i in range(len(s) - n + 1): pattern = s[i:i+n] pattern_count[pattern] += 1 max_count = max(pattern_count.values()) candidates = [pattern for pattern, count in pattern_count.items() if count == max_count] return min(candidates)"},{"question":"def max_workshops_hosted(n: int, m: int, room_capacities: List[int], workshop_attendees: List[int]) -> int: Returns the maximum number of workshops that can be hosted given room capacities and workshop attendees. :param n: Number of rooms. :param m: Number of workshops. :param room_capacities: List of integers representing the capacities of the rooms. :param workshop_attendees: List of integers representing the number of attendees for each workshop. :return: Maximum number of workshops that can be hosted. >>> max_workshops_hosted(3, 4, [10, 5, 8], [6, 4, 8, 2]) 3 >>> max_workshops_hosted(3, 3, [3, 3, 3], [2, 2, 2]) 3 >>> max_workshops_hosted(3, 3, [5, 5, 5], [6, 6, 6]) 0 >>> max_workshops_hosted(3, 3, [5, 10, 15], [1, 2, 3]) 3 >>> max_workshops_hosted(3, 2, [10, 15, 20], [5, 6]) 2 >>> max_workshops_hosted(2, 4, [10, 10], [3, 5, 8, 12]) 2","solution":"def max_workshops_hosted(n, m, room_capacities, workshop_attendees): Returns the maximum number of workshops that can be hosted given room capacities and workshop attendees. :param n: Number of rooms. :param m: Number of workshops. :param room_capacities: List of integers representing the capacities of the rooms. :param workshop_attendees: List of integers representing the number of attendees for each workshop. :return: Maximum number of workshops that can be hosted. # Sort both lists room_capacities.sort() workshop_attendees.sort() i, j = 0, 0 count = 0 # Use two-pointer technique to allocate rooms to workshops while i < n and j < m: if room_capacities[i] >= workshop_attendees[j]: count += 1 j += 1 i += 1 return count"},{"question":"import heapq def minimum_effort_path(n: int, m: int, grid: List[List[int]]) -> int: Calculate the minimum effort path from top-left to bottom-right corner in a grid. Parameters: n (int): Number of rows m (int): Number of columns grid (list of list of int): Elevation levels in the grid Returns: int: The minimum effort required to reach the bottom-right corner from the top-left corner. >>> grid = [ ... [1, 2, 2], ... [3, 8, 2], ... [5, 3, 5] ... ] >>> minimum_effort_path(3, 3, grid) 2 >>> grid = [ ... [1, 2, 2, 3] ... ] >>> minimum_effort_path(1, 4, grid) 1 >>> grid = [ ... [1], ... [2], ... [2], ... [3] ... ] >>> minimum_effort_path(4, 1, grid) 1 >>> grid = [ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ] >>> minimum_effort_path(3, 3, grid) 0 >>> grid = [ ... [1, 1000000], ... [1000000, 1] ... ] >>> minimum_effort_path(2, 2, grid) 999999 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # ...","solution":"import heapq def minimum_effort_path(n, m, grid): Calculate the minimum effort path from top-left to bottom-right corner in a grid. Parameters: n (int): Number of rows m (int): Number of columns grid (list of list of int): Elevation levels in the grid Returns: int: The minimum effort required to reach the bottom-right corner from the top-left corner. directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] effort = [[float('inf')] * m for _ in range(n)] effort[0][0] = 0 min_heap = [(0, 0, 0)] # (effort, row, col) while min_heap: current_effort, x, y = heapq.heappop(min_heap) if x == n - 1 and y == m - 1: return current_effort for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m: new_effort = max(current_effort, abs(grid[nx][ny] - grid[x][y])) if new_effort < effort[nx][ny]: effort[nx][ny] = new_effort heapq.heappush(min_heap, (new_effort, nx, ny)) return -1 # If no path is found, although it shouldn't happen as per problem constraint."},{"question":"def max_items(prices, budget): Returns the maximum number of items that can be purchased without exceeding the budget. Parameters: prices (list of int): List of prices of items in the store. budget (int): Total amount of money available to spend. Returns: int: Maximum number of items that can be purchased without exceeding the budget. >>> max_items([20, 10, 5, 30, 15], 35) 3 >>> max_items([20, 10, 5, 30, 15], 50) 4 >>> max_items([20, 10, 5, 30, 15], 0) 0 >>> max_items([10], 10) 1 >>> max_items([10], 5) 0 >>> max_items([1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 6) 6 >>> max_items([7, 5, 3, 1, 9, 2, 4], 10) 4 >>> prices = [1] * 100000 >>> max_items(prices, 100000) 100000","solution":"def max_items(prices, budget): Returns the maximum number of items that can be purchased without exceeding the budget. Parameters: prices (list of int): List of prices of items in the store. budget (int): Total amount of money available to spend. Returns: int: Maximum number of items that can be purchased without exceeding the budget. prices.sort() total_spent = 0 count = 0 for price in prices: if total_spent + price <= budget: total_spent += price count += 1 else: break return count"},{"question":"from typing import List, Tuple def shortest_cycle(n: int, m: int, edges: List[Tuple[int, int]]) -> Tuple[str, int, List[int]]: Find the shortest cycle (in terms of number of roads) in an undirected graph representing the city. Parameters: n (int): The number of intersections. m (int): The number of roads. edges (List[Tuple[int, int]]): List of tuples where each tuple (u, v) represents a bidirectional road between intersections u and v. Returns: Tuple[str, int, List[int]]: A tuple where: - The first element is a string \\"YES\\" if a cycle exists, otherwise \\"NO\\". - The second element is an integer representing the number of intersections in the shortest cycle (if exists). - The third element is a list of integers representing the sequence of intersections in the shortest cycle (if exists). Examples: >>> shortest_cycle(6, 7, [(1, 2), (1, 3), (2, 3), (2, 4), (3, 5), (4, 5), (4, 6)]) ('YES', 3, [1, 2, 3]) >>> shortest_cycle(4, 3, [(1, 2), (2, 3), (3, 4)]) ('NO', )","solution":"from collections import deque, defaultdict def shortest_cycle(n, m, edges): adj = defaultdict(list) for u, v in edges: adj[u].append(v) adj[v].append(u) def find_shortest_cycle(start): dist = [-1] * (n + 1) parent = [-1] * (n + 1) q = deque([start]) dist[start] = 0 while q: u = q.popleft() for v in adj[u]: if dist[v] == -1: dist[v] = dist[u] + 1 parent[v] = u q.append(v) elif parent[u] != v: cycle_len = dist[u] + dist[v] + 1 cycle = [] x = u while x != -1: cycle.append(x) x = parent[x] x = v while x != -1: cycle.append(x) x = parent[x] return cycle_len, cycle return float('inf'), [] min_cycle_len = float('inf') min_cycle = [] for i in range(1, n+1): cycle_len, cycle = find_shortest_cycle(i) if cycle_len < min_cycle_len: min_cycle_len = cycle_len min_cycle = cycle[:1 + len(cycle)//2] # deduplicate nodes if min_cycle_len == float('inf'): return \\"NO\\", else: return \\"YES\\", min_cycle_len, min_cycle # Example Usage n = 6 m = 7 edges = [(1, 2), (1, 3), (2, 3), (2, 4), (3, 5), (4, 5), (4, 6)] print(shortest_cycle(n, m, edges))"},{"question":"def count_incorrect_words(sentence: str, dictionary: List[str]) -> int: Returns the number of words in the sentence that are not in the dictionary. >>> count_incorrect_words(\\"Hello, world! This is a typing speed test.\\", [\\"hello\\", \\"world\\", \\"this\\", \\"is\\", \\"a\\", \\"test\\"]) 2 >>> count_incorrect_words(\\"Hello world this is a test\\", [\\"hello\\", \\"world\\", \\"this\\", \\"is\\", \\"a\\", \\"test\\"]) 0 >>> count_incorrect_words(\\"Typing speed checking\\", [\\"hello\\", \\"world\\", \\"this\\", \\"is\\", \\"a\\", \\"test\\"]) 3 >>> count_incorrect_words(\\"\\", [\\"hello\\", \\"world\\", \\"this\\", \\"is\\", \\"a\\", \\"test\\"]) 0 >>> count_incorrect_words(\\"Hello world\\", []) 2 >>> count_incorrect_words(\\"Hello HELLO hello\\", [\\"hello\\"]) 0 >>> count_incorrect_words(\\"Hello, world! What's up?\\", [\\"hello\\", \\"world\\", \\"what\\", \\"up\\"]) 1","solution":"import re from typing import List def count_incorrect_words(sentence: str, dictionary: List[str]) -> int: Returns the number of words in the sentence that are not in the dictionary. # Convert dictionary to set for faster lookup dictionary_set = set(dictionary) # Normalize the sentence by converting to lower case and removing punctuation # Split into words using regex to capture all words while ignoring punctuation words = re.findall(r'bw+b', sentence.lower()) # Count the number of words that are not in the dictionary incorrect_count = sum(1 for word in words if word not in dictionary_set) return incorrect_count"},{"question":"def rearrange_employees(n: int, t: int, s: str) -> str: Arranges managers ('M') and engineers ('E') in the queue after t seconds. Managers move to the back if they are ahead of engineers. :param int n: Number of employees in the queue. :param int t: Number of seconds to consider for rearrangement. :param str s: Initial arrangement of employees in the queue. :return: Final arrangement of employees after t seconds. :rtype: str pass # Implementation required def test_example(): assert rearrange_employees(5, 3, 'MEMEM') == 'EEMMM' def test_all_managers(): assert rearrange_employees(4, 5, 'MMMM') == 'MMMM' def test_all_engineers(): assert rearrange_employees(4, 5, 'EEEE') == 'EEEE' def test_no_time(): assert rearrange_employees(4, 0, 'MEME') == 'MEME' def test_minimal_case(): assert rearrange_employees(1, 10, 'M') == 'M' def test_alternate(): assert rearrange_employees(6, 5, 'MEMEME') == 'EEEMMM' def test_only_one_swap(): assert rearrange_employees(4, 1, 'MEEM') == 'EMEM' def test_last_engineer(): assert rearrange_employees(3, 10, 'MME') == 'EMM'","solution":"def rearrange_employees(n, t, s): Arranges managers ('M') and engineers ('E') in the queue after t seconds. Managers move to the back if they are ahead of engineers. :param int n: Number of employees in the queue. :param int t: Number of seconds to consider for rearrangement. :param str s: Initial arrangement of employees in the queue. :return: Final arrangement of employees after t seconds. :rtype: str employees = list(s) for _ in range(t): i = 0 while i < n - 1: if employees[i] == 'M' and employees[i + 1] == 'E': # Swap the positions employees[i], employees[i + 1] = employees[i + 1], employees[i] # Move to the next pair i += 1 # Move to the next position i += 1 return ''.join(employees)"},{"question":"def arithmetic_sequence_sum(a: int, d: int, n: int) -> int: Calculate the sum of the first n terms of an arithmetic sequence starting with 'a' and having a common difference 'd'. :param a: First term of the sequence :param d: Common difference :param n: Number of terms :return: Sum of the first n terms of the arithmetic sequence >>> arithmetic_sequence_sum(1, 2, 3) 9 >>> arithmetic_sequence_sum(2, 3, 4) 26 >>> arithmetic_sequence_sum(5, 5, 5) 75 >>> arithmetic_sequence_sum(1, 1, 1) 1 >>> arithmetic_sequence_sum(1, 0, 10) 10 def process_queries(queries: List[Tuple[int, int, int]]) -> List[int]: Process a list of queries and return the results for each query. :param queries: List of tuples (a, d, n) for each query :return: List of results for each query >>> process_queries([(1, 2, 3), (2, 3, 4), (5, 5, 5)]) [9, 26, 75] >>> process_queries([(1, 1, 1), (1, 0, 10)]) [1, 10]","solution":"def arithmetic_sequence_sum(a, d, n): Calculate the sum of the first n terms of an arithmetic sequence starting with 'a' and having a common difference 'd'. :param a: First term of the sequence :param d: Common difference :param n: Number of terms :return: Sum of the first n terms of the arithmetic sequence Sn = n * (2 * a + (n - 1) * d) // 2 # Using integer division for the sum calculation return Sn def process_queries(queries): Process a list of queries and return the results for each query. :param queries: List of tuples (a, d, n) for each query :return: List of results for each query results = [] for a, d, n in queries: results.append(arithmetic_sequence_sum(a, d, n)) return results"},{"question":"def visible_buildings(n: int, heights: List[int]) -> List[int]: Returns the heights of the buildings that are visible from the west side. >>> visible_buildings(6, [7, 4, 8, 2, 9, 5]) [7, 8, 9] >>> visible_buildings(5, [3, 3, 3, 3, 3]) [3] >>> visible_buildings(4, [5, 6, 7, 8]) [5, 6, 7, 8] # Your code here # Unit tests def test_visible_buildings_example1(): assert visible_buildings(6, [7, 4, 8, 2, 9, 5]) == [7, 8, 9] def test_visible_buildings_example2(): assert visible_buildings(5, [3, 3, 3, 3, 3]) == [3] def test_visible_buildings_example3(): assert visible_buildings(4, [5, 6, 7, 8]) == [5, 6, 7, 8] def test_visible_buildings_decreasing(): assert visible_buildings(5, [9, 7, 5, 3, 1]) == [9] def test_visible_buildings_single_building(): assert visible_buildings(1, [10]) == [10] def test_visible_buildings_two_buildings_increasing(): assert visible_buildings(2, [1, 2]) == [1, 2] def test_visible_buildings_two_buildings_decreasing(): assert visible_buildings(2, [2, 1]) == [2] def test_visible_buildings_mixed_heights(): assert visible_buildings(7, [1, 3, 2, 4, 2, 5, 2]) == [1, 3, 4, 5]","solution":"def visible_buildings(n, heights): Returns the heights of the buildings that are visible from the west side. :param n: Number of buildings :param heights: A list of integers representing the heights of the buildings :return: A list of integers representing the visible buildings' heights visible = [] max_height_so_far = 0 for height in heights: if height > max_height_so_far: visible.append(height) max_height_so_far = height return visible"},{"question":"def count_palindromic_substrings(s: str) -> int: Determine the number of substrings that are palindromes in the given string. >>> count_palindromic_substrings(\\"ababa\\") 9 >>> count_palindromic_substrings(\\"aaa\\") 6 >>> count_palindromic_substrings(\\"abcd\\") 4 def test_single_character(): assert count_palindromic_substrings(\\"a\\") == 1 def test_no_palindrome(): assert count_palindromic_substrings(\\"abcd\\") == 4 def test_all_same_characters(): assert count_palindromic_substrings(\\"aaa\\") == 6 def test_mixed_characters(): assert count_palindromic_substrings(\\"ababa\\") == 9 def test_palindrome_string(): assert count_palindromic_substrings(\\"racecar\\") == 10 def test_long_palindrome_string(): assert count_palindromic_substrings(\\"aaaaaa\\") == 21 def test_varied_string(): assert count_palindromic_substrings(\\"abccba\\") == 9","solution":"def count_palindromic_substrings(s: str) -> int: Counts the number of palindromic substrings in the given string. n = len(s) count = 0 for center in range(2 * n - 1): left = center // 2 right = left + center % 2 while left >= 0 and right < n and s[left] == s[right]: count += 1 left -= 1 right += 1 return count"},{"question":"def max_treasure_in_target_chamber(n, k, t, initial_treasure, max_capacity, paths, o): Determine the maximum amount of treasure that can be accumulated in the target chamber after a number of operations. >>> max_treasure_in_target_chamber(5, 4, 3, [0, 10, 20, 5, 15], [5, 15, 25, 10, 20], [(1, 2), (2, 3), (3, 4), (4, 5)], 3) 25 >>> max_treasure_in_target_chamber(3, 2, 1, [5, 5, 5], [10, 10, 10], [(1, 2), (2, 3)], 0) 5 >>> max_treasure_in_target_chamber(3, 2, 3, [5, 10, 0], [100, 100, 10], [(1, 2), (2, 3)], 2) 10 >>> max_treasure_in_target_chamber(4, 0, 2, [0, 5, 10, 15], [10, 10, 10, 10], [], 5) 5","solution":"def max_treasure_in_target_chamber(n, k, t, initial_treasure, max_capacity, paths, o): from collections import defaultdict, deque # Build adjacency list for the graph graph = defaultdict(list) for u, v in paths: graph[u].append(v) graph[v].append(u) # Breadth-First Search to perform the operations visited = [False] * (n + 1) queue = deque([(t, initial_treasure[t - 1])]) visited[t] = True operations = 0 while queue and operations < o: chamber, treasure = queue.popleft() for neighbor in graph[chamber]: if visited[neighbor] or operations >= o: continue capacity_left = max_capacity[chamber - 1] - initial_treasure[chamber - 1] if initial_treasure[neighbor - 1] > 0 and capacity_left > 0: move_treasure = min(initial_treasure[neighbor - 1], capacity_left) initial_treasure[chamber - 1] += move_treasure initial_treasure[neighbor - 1] -= move_treasure queue.append((neighbor, initial_treasure[neighbor - 1])) operations += 1 if operations >= o: break visited[chamber] = True return initial_treasure[t - 1]"},{"question":"def min_operations_to_make_heights_equal(n: int, heights: List[int]) -> int: Calculate the minimum number of operations needed to make the heights of all the trees equal. :param n: int - the number of trees :param heights: list - the initial heights of the trees :return: int - minimum number of operations required to make the heights of all trees equal >>> min_operations_to_make_heights_equal(3, [1, 2, 3]) 3 >>> min_operations_to_make_heights_equal(4, [4, 9, 5, 6]) 12 >>> min_operations_to_make_heights_equal(3, [7, 7, 7]) 0 >>> min_operations_to_make_heights_equal(1, [5]) 0 >>> min_operations_to_make_heights_equal(5, [3, 3, 3, 3, 3]) 0 >>> min_operations_to_make_heights_equal(3, [1, 100, 1]) 198 pass","solution":"def min_operations_to_make_heights_equal(n, heights): This function calculates the minimum number of operations needed to make the heights of all the trees equal. :param n: int - the number of trees :param heights: list - the initial heights of the trees :return: int - minimum number of operations required to make the heights of all trees equal max_height = max(heights) operations = sum(max_height - height for height in heights) return operations"},{"question":"def canMakeReservation(reservations: List[Tuple[int, int]], newReservation: Tuple[int, int]) -> bool: Check if a new reservation can be made without overlapping any existing reservations. Args: reservations: List of tuples, where each tuple contains start and end times of existing reservations. newReservation: A tuple containing start and end times for the new reservation. Returns: bool: True if the new reservation can be made without overlapping existing reservations, False otherwise. Examples: >>> canMakeReservation([(10, 12), (14, 16), (18, 20)], (12, 14)) True >>> canMakeReservation([(10, 12), (14, 16), (18, 20)], (11, 13)) False >>> canMakeReservation([], (9, 10)) True >>> canMakeReservation([(10, 12), (14, 16)], (12, 14)) True >>> canMakeReservation([(10, 11), (12, 13), (14, 15), (16, 17)], (13, 14)) True >>> canMakeReservation([(9, 10), (11, 12), (13, 14), (15, 16)], (10, 11)) True >>> canMakeReservation([(10, 15)], (10, 15)) False >>> canMakeReservation([(10, 15)], (11, 14)) False","solution":"def canMakeReservation(reservations, newReservation): Check if a new reservation can be made without overlapping any existing reservations. new_start, new_end = newReservation for res_start, res_end in reservations: # Check if new reservation overlaps with existing reservation if not (new_end <= res_start or new_start >= res_end): return False return True"},{"question":"from typing import List, Tuple def minimum_operations(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given the number of test cases, and for each test case, the length of the array and the array of integers, determine the minimum number of operations required to make all elements of the array equal. >>> minimum_operations(2, [(4, [1, 2, 3, 4]), (5, [1, 1, 1, 1, 1])]) [3, 0] >>> minimum_operations(1, [(3, [1000000000, 1000000001, 1000000002])]) [2] >>> minimum_operations(1, [(4, [-1, -2, -3, -4])]) [3] >>> minimum_operations(1, [(5, [1, -1, 0, 2, -2])]) [4] >>> minimum_operations(2, [(1, [100]), (1, [1])]) [0, 0]","solution":"def minimum_operations(t, test_cases): results = [] for n, arr in test_cases: min_val = min(arr) max_val = max(arr) # Number of operations required operations = max_val - min_val results.append(operations) return results"},{"question":"def find_minimum_effort(n: int, m: int, connections: List[Tuple[int, int, int]]) -> int: Returns the minimum total weight of the required bridges to connect all islands. If it is not possible to connect all islands, returns -1. pass # Unit tests def test_fully_connected_islands(): n = 4 m = 5 connections = [ (1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 1, 4), (1, 3, 2) ] assert find_minimum_effort(n, m, connections) == 6 def test_just_enough_bridges(): n = 4 m = 3 connections = [ (1, 2, 1), (2, 3, 2), (3, 4, 3) ] assert find_minimum_effort(n, m, connections) == 6 def test_not_fully_connected(): n = 4 m = 2 connections = [ (1, 2, 1), (3, 4, 2) ] assert find_minimum_effort(n, m, connections) == -1 def test_single_island(): n = 1 m = 0 connections = [] assert find_minimum_effort(n, m, connections) == 0 def test_two_islands_one_bridge(): n = 2 m = 1 connections = [ (1, 2, 1) ] assert find_minimum_effort(n, m, connections) == 1 def test_large_connected_graph(): n = 5 m = 6 connections = [ (1, 2, 3), (1, 3, 1), (1, 4, 4), (2, 5, 2), (3, 4, 5), (4, 5, 2) ] assert find_minimum_effort(n, m, connections) == 8","solution":"def find_minimum_effort(n, m, connections): Returns the minimum total weight of the required bridges to connect all islands. If it is not possible to connect all islands, returns -1. parent = list(range(n + 1)) rank = [0] * (n + 1) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 connections.sort(key=lambda x: x[2]) # Sort edges by weight total_weight = 0 num_edges_used = 0 for u, v, w in connections: if find(u) != find(v): union(u, v) total_weight += w num_edges_used += 1 if num_edges_used == n - 1: break # Check if all islands are connected root = find(1) for i in range(2, n + 1): if find(i) != root: return -1 return total_weight"},{"question":"def is_subsequence_sum_divisible(n: int, k: int, arr: List[int]) -> str: Determine if there exists a subsequence whose sum is divisible by k. Parameters: n (int): Number of elements in the array k (int): The integer to check divisibility against arr (List[int]): List of positive integers Returns: str: \\"YES\\" if such a subsequence exists, otherwise \\"NO\\" >>> is_subsequence_sum_divisible(5, 3, [1, 2, 3, 4, 5]) 'YES' >>> is_subsequence_sum_divisible(4, 7, [1, 2, 3, 5]) 'NO' >>> is_subsequence_sum_divisible(1, 1, [1000000000]) 'YES' >>> is_subsequence_sum_divisible(3, 10, [10, 20, 30]) 'YES' >>> is_subsequence_sum_divisible(5, 6, [5, 10, 15, 20, 25]) 'YES' >>> is_subsequence_sum_divisible(3, 5, [1, 2, 8]) 'YES' >>> is_subsequence_sum_divisible(3, 9, [1, 2, 4]) 'NO'","solution":"def is_subsequence_sum_divisible(n, k, arr): Determine if there exists a subsequence whose sum is divisible by k. # Create a set to store the remainders of prefix sums mod k prefix_mods = set() # Initialize current sum and add mod 0 to the set current_sum = 0 prefix_mods.add(0) for num in arr: current_sum += num mod = current_sum % k # If the modulo is already in the set, a subsequence exists whose sum is divisible by k if mod in prefix_mods: return \\"YES\\" prefix_mods.add(mod) return \\"NO\\""},{"question":"from typing import List, Tuple def sortVouchers(vouchers: List[Tuple[str, int]]) -> List[Tuple[str, int]]: Sorts a list of vouchers in descending order based on the discount percentage. If two vouchers have the same discount percentage, they are ordered by their voucher code in ascending alphabetical order. :param vouchers: A list of tuples, where each tuple consists of a voucher code (string) and a discount percentage (int). :return: A list of sorted tuples. >>> sortVouchers([(\\"XMAS2023\\", 50), (\\"WELCOME10\\", 10), (\\"HOLIDAY20\\", 20), (\\"FREESHIP\\", 50)]) [('FREESHIP', 50), ('XMAS2023', 50), ('HOLIDAY20', 20), ('WELCOME10', 10)] >>> sortVouchers([(\\"A1\\", 20), (\\"B2\\", 20), (\\"C3\\", 20)]) [('A1', 20), ('B2', 20), ('C3', 20)] >>> sortVouchers([(\\"A1\\", 50), (\\"B2\\", 100), (\\"C3\\", 75)]) [('B2', 100), ('C3', 75), ('A1', 50)] >>> sortVouchers([]) [] >>> sortVouchers([(\\"A1\\", 50)]) [('A1', 50)]","solution":"from typing import List, Tuple def sortVouchers(vouchers: List[Tuple[str, int]]) -> List[Tuple[str, int]]: This function sorts a list of vouchers in descending order based on the discount percentage. If two vouchers have the same discount percentage, the voucher codes are sorted in ascending order. :param vouchers: A list of tuples, where each tuple consists of a voucher code (string) and a discount percentage (int). :return: A list of sorted tuples. return sorted(vouchers, key=lambda x: (-x[1], x[0]))"},{"question":"from typing import List def max_length_substring(s: str, k: int) -> int: Returns the maximum length of a substring that contains each letter at most k times. >>> max_length_substring(\\"abcba\\", 2) 5 >>> max_length_substring(\\"aabbcc\\", 1) 2 def test_ex1(): assert max_length_substring(\\"abcba\\", 2) == 5 def test_ex2(): assert max_length_substring(\\"aabbcc\\", 1) == 2 def test_single_character_string(): assert max_length_substring(\\"a\\", 2) == 1 def test_repeated_character(): assert max_length_substring(\\"aaabbb\\", 2) == 4 def test_all_unique_characters(): assert max_length_substring(\\"abcdef\\", 3) == 6 def test_full_string_allowed(): assert max_length_substring(\\"aabbccdd\\", 4) == 8 def test_limited_frequency(): assert max_length_substring(\\"aabbaabb\\", 1) == 2 def test_complex_case(): assert max_length_substring(\\"abacccabbb\\", 2) == 5","solution":"def max_length_substring(s, k): Returns the maximum length of a substring that contains each letter at most k times. from collections import defaultdict left = 0 char_count = defaultdict(int) max_length = 0 for right in range(len(s)): char_count[s[right]] += 1 while char_count[s[right]] > k: char_count[s[left]] -= 1 left += 1 max_length = max(max_length, right - left + 1) return max_length # Example Usage # s = \\"abcba\\" # k = 2 # result = max_length_substring(s, k) # print(result) # Output should be 5"},{"question":"def max_length_subarray(nums: List[int], target: int) -> int: Find the maximum length of a subarray that sums up to the target. Args: nums (List[int]): List of integers representing the array. target (int): The target sum for the subarray. Returns: int: Maximum length of a subarray summing up to target. If no such subarray exists, return 0. >>> max_length_subarray([1, -1, 5, -2, 3], 3) 4 >>> max_length_subarray([-2, -1, 2, 1], 1) 2 >>> max_length_subarray([1, 2, 3], 7) 0 >>> max_length_subarray([1, 2, 3, -2, -2], 2) 5 >>> max_length_subarray([-1, -2, -3, 4], -3) 2 >>> max_length_subarray([0, 0, 0, 0, 0], 0) 5 >>> max_length_subarray([5], 5) 1 >>> max_length_subarray([-1], -1) 1 >>> max_length_subarray([1], 2) 0","solution":"def max_length_subarray(nums, target): prefix_sum = {} current_sum = 0 max_length = 0 for i in range(len(nums)): current_sum += nums[i] if current_sum == target: max_length = i + 1 if (current_sum - target) in prefix_sum: max_length = max(max_length, i - prefix_sum[current_sum - target]) if current_sum not in prefix_sum: prefix_sum[current_sum] = i return max_length"},{"question":"def max_sum_subarray_of_length_k(n, k, arr): Returns the maximum sum of any contiguous subarray of length exactly k. Parameters: n (int): The length of the array. k (int): The length of the subarray. arr (list): The array of n integers. Returns: int: The maximum sum of any contiguous subarray of length k. pass # Example test cases to validate the solution # Replace these with appropriate unit tests in your test environment assert max_sum_subarray_of_length_k(5, 2, [1, 2, 3, 4, 5]) == 9 assert max_sum_subarray_of_length_k(5, 3, [1000000, 1000000, 1000000, 1000000, 1000000]) == 3000000 assert max_sum_subarray_of_length_k(8, 3, [-1, 2, 3, -4, 5, -6, 7, -8]) == 6 assert max_sum_subarray_of_length_k(5, 2, [-1, -2, -3, -4, -5]) == -3 assert max_sum_subarray_of_length_k(1, 1, [10]) == 10 assert max_sum_subarray_of_length_k(5, 5, [1, 2, 3, 4, 5]) == 15 assert max_sum_subarray_of_length_k(10, 3, [1, -1, 1, -1, 1, -1, 1, -1, 1, -1]) == 1","solution":"def max_sum_subarray_of_length_k(n, k, arr): Returns the maximum sum of any contiguous subarray of length exactly k. Parameters: n (int): The length of the array. k (int): The length of the subarray. arr (list): The array of n integers. Returns: int: The maximum sum of any contiguous subarray of length k. # Initialize the sum of the first subarray of length k max_sum = current_sum = sum(arr[:k]) # Slide the window across the array for i in range(k, n): current_sum += arr[i] - arr[i - k] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def process_operations(n, operations): Process a sequence of follow and mutual_count operations for the social media platform, TrendNet. >>> process_operations(5, [\\"follow 1 2\\", \\"follow 1 3\\", \\"mutual_count 1\\", \\"follow 2 3\\", \\"mutual_count 2\\", \\"follow 4 5\\", \\"mutual_count 4\\"]) [2, 2, 1] >>> process_operations(3, [\\"mutual_count 1\\", \\"mutual_count 2\\", \\"mutual_count 3\\"]) [0, 0, 0] >>> process_operations(3, [\\"follow 1 2\\", \\"follow 1 3\\", \\"follow 2 3\\", \\"mutual_count 1\\", \\"mutual_count 2\\", \\"mutual_count 3\\"]) [2, 2, 2] >>> process_operations(4, [\\"follow 1 2\\", \\"follow 1 3\\", \\"follow 1 4\\", \\"mutual_count 1\\", \\"mutual_count 2\\", \\"mutual_count 3\\", \\"mutual_count 4\\", \\"follow 2 3\\", \\"follow 3 4\\", \\"mutual_count 1\\", \\"mutual_count 2\\", \\"mutual_count 3\\", \\"mutual_count 4\\"]) [3, 1, 1, 1, 3, 2, 3, 2]","solution":"def process_operations(n, operations): from collections import defaultdict followers = defaultdict(set) mutual_followers_count = [0] * (n + 1) # Array to store mutual followers count result = [] for operation in operations: parts = operation.split() if parts[0] == \\"follow\\": a, b = int(parts[1]), int(parts[2]) followers[a].add(b) followers[b].add(a) # Update mutual followers count mutual_followers_count[a] += 1 mutual_followers_count[b] += 1 elif parts[0] == \\"mutual_count\\": x = int(parts[1]) result.append(mutual_followers_count[x]) return result"},{"question":"def generate_ticket_numbers(n: int): Generates all valid ticket numbers of length n following the given constraints: 1. The ticket number must be a strictly increasing sequence of digits. 2. The length of the number should be exactly n. 3. Each digit must be from the set {1, 2, ..., 9} (no 0 allowed). :param n: The length of the ticket number. :type n: int :return: A list of all valid ticket numbers as strings. :rtype: List of str >>> generate_ticket_numbers(1) ['1', '2', '3', '4', '5', '6', '7', '8', '9'] >>> generate_ticket_numbers(2) ['12', '13', '14', '15', '16', '17', '18', '19', '23', '24', '25', '26', '27', '28', '29', '34', '35', '36', '37', '38', '39', '45', '46', '47', '48', '49', '56', '57', '58', '59', '67', '68', '69', '78', '79', '89'] >>> generate_ticket_numbers(3) ['123', '124', '125', '126', '127', '128', '129', '134', '135', '136', '137', '138', '139', '145', '146', '147', '148', '149', '156', '157', '158', '159', '167', '168', '169', '178', '179', '189', '234', '235', '236', '237', '238', '239', '245', '246', '247', '248', '249', '256', '257', '258', '259', '267', '268', '269', '278', '279', '289', '345', '346', '347', '348', '349', '356', '357', '358', '359', '367', '368', '369', '378', '379', '389', '456', '457', '458', '459', '467', '468', '469', '478', '479', '489', '567', '568', '569', '578', '579', '589', '678', '679', '689', '789'] >>> generate_ticket_numbers(9) ['123456789']","solution":"def generate_ticket_numbers(n): Generates all valid ticket numbers of length n following the given constraints: 1. The ticket number must be a strictly increasing sequence of digits. 2. The length of the number should be exactly n. 3. Each digit must be from the set {1, 2, ..., 9} (no 0 allowed). :param n: The length of the ticket number. :type n: int :return: A list of all valid ticket numbers as strings. :rtype: List of str from itertools import combinations # List to store the result result = [] digits = '123456789' # Get all combinations of 'digits' of length 'n' for comb in combinations(digits, n): result.append(''.join(comb)) return result"},{"question":"from typing import List def min_cost_path(cost: List[List[int]]) -> int: You are given a matrix of non-negative integers where each cell represents the cost to enter that cell. Your goal is to find a path from the top-left corner to the bottom-right corner which minimizes the total cost along the way. You can only move either down or right at any point in time. >>> min_cost_path([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) == 7 >>> min_cost_path([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == 21 >>> min_cost_path([ ... [1, 3], ... [1, 5] ... ]) == 7 >>> min_cost_path([[42]]) == 42 >>> min_cost_path([]) == 0 >>> min_cost_path([[1, 2, 3]]) == 6 >>> min_cost_path([[1], [2], [3]]) == 6","solution":"from typing import List def min_cost_path(cost: List[List[int]]) -> int: if not cost or not cost[0]: return 0 rows, cols = len(cost), len(cost[0]) dp = [[0] * cols for _ in range(rows)] dp[0][0] = cost[0][0] for i in range(1, rows): dp[i][0] = dp[i-1][0] + cost[i][0] for j in range(1, cols): dp[0][j] = dp[0][j-1] + cost[0][j] for i in range(1, rows): for j in range(1, cols): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + cost[i][j] return dp[rows-1][cols-1]"},{"question":"from typing import List def longest_non_decreasing_subsequence_length(n: int, sequence: List[int]) -> int: Find the length of the longest non-decreasing subsequence that can be obtained from the given sequence by inserting any number of integers (possibly zero). >>> longest_non_decreasing_subsequence_length(6, [5, 3, 4, 8, 6, 7]) 4 >>> longest_non_decreasing_subsequence_length(5, [2, 2, 2, 2, 2]) 5 >>> longest_non_decreasing_subsequence_length(5, [1, 2, 3, 4, 5]) 5 >>> longest_non_decreasing_subsequence_length(5, [5, 4, 3, 2, 1]) 1 >>> longest_non_decreasing_subsequence_length(6, [1, 3, 2, 4, 3, 5]) 4 >>> longest_non_decreasing_subsequence_length(1, [1]) 1 >>> longest_non_decreasing_subsequence_length(0, []) 0 >>> longest_non_decreasing_subsequence_length(10, [10, 9, 2, 5, 3, 7, 101, 18, 20, 22]) 6 pass","solution":"def longest_non_decreasing_subsequence_length(n, sequence): from bisect import bisect_right if n == 0: return 0 # List to store the smallest tail of all increasing subsequences # with length i+1 in subsequence_tails[i]. subsequence_tails = [] for num in sequence: # Find the place where this element would go in the subsequence_tails. pos = bisect_right(subsequence_tails, num) # If pos is equal to the length of subsequence_tails, it means we have to # add the element to extension the longest subsequence found so far. # Otherwise, we update the existing position. if pos < len(subsequence_tails): subsequence_tails[pos] = num else: subsequence_tails.append(num) # The length of subsequence_tails will be the length of the longest # non-decreasing subsequence. return len(subsequence_tails)"},{"question":"def min_employees_needed(projects): Determine the minimum number of employees needed to complete all projects without any scheduling conflicts. >>> min_employees_needed([ ... (1, 10, 1, 20, 3), ... (2, 5, 2, 15, 2), ... (1, 15, 1, 25, 4) ... ]) 7 >>> min_employees_needed([ ... (1, 1, 1, 10, 2), ... (2, 1, 2, 10, 3), ... (3, 1, 3, 10, 4) ... ]) 4 >>> min_employees_needed([ ... (1, 1, 1, 31, 3), ... (1, 1, 1, 31, 4), ... (1, 1, 1, 31, 5) ... ]) 12 >>> min_employees_needed([ ... (1, 1, 1, 15, 2), ... (1, 10, 1, 20, 3), ... (1, 15, 1, 25, 4) ... ]) 9 >>> min_employees_needed([ ... (1, 20, 2, 5, 2), ... (2, 1, 2, 28, 3), ... (2, 15, 3, 10, 4) ... ]) 7","solution":"def min_employees_needed(projects): from collections import defaultdict # Dictionary to keep track of employee requirements on every day employee_schedule = defaultdict(int) for project in projects: start_month, start_day, end_month, end_day, employees = project start_day_of_year = (start_month - 1) * 30 + start_day end_day_of_year = (end_month - 1) * 30 + end_day for day in range(start_day_of_year, end_day_of_year + 1): employee_schedule[day] += employees # Find the maximum employees needed on any given day max_employees = max(employee_schedule.values()) return max_employees"},{"question":"def do_fields_overlap(fields): Determines if any two rectangles overlap. Args: fields (list of (int, int, int, int)): List of rectangles defined by bottom-left and top-right corners. Returns: str: \\"YES\\" if any pairs of rectangles overlap, otherwise \\"NO\\". from solution import do_fields_overlap def test_no_overlap(): assert do_fields_overlap([(1, 1, 2, 2), (3, 3, 4, 4), (5, 5, 6, 6)]) == \\"NO\\" def test_single_overlap(): assert do_fields_overlap([(1, 1, 4, 4), (2, 2, 5, 5), (6, 6, 8, 8)]) == \\"YES\\" def test_all_overlap(): assert do_fields_overlap([(1, 1, 5, 5), (2, 2, 6, 6), (3, 3, 7, 7)]) == \\"YES\\" def test_touching_boundaries_no_overlap(): assert do_fields_overlap([(1, 1, 2, 2), (2, 2, 3, 3), (3, 3, 4, 4)]) == \\"NO\\" def test_multiple_fields_no_overlap(): assert do_fields_overlap([(0, 0, 1, 1), (2, 2, 3, 3), (4, 4, 5, 5), (6, 6, 7, 7), (8, 8, 9, 9)]) == \\"NO\\" def test_multiple_fields_with_overlap(): assert do_fields_overlap([(0, 0, 5, 5), (4, 4, 10, 10), (2, 2, 3, 3)]) == \\"YES\\"","solution":"def do_fields_overlap(fields): Determines if any two rectangles overlap. Args: fields (list of (int, int, int, int)): List of rectangles defined by bottom-left and top-right corners. Returns: str: \\"YES\\" if any pairs of rectangles overlap, otherwise \\"NO\\". def is_overlap(field1, field2): # Unpack the coordinates x1, y1, x2, y2 = field1 a1, b1, a2, b2 = field2 # Check for overlap return not (x2 <= a1 or a2 <= x1 or y2 <= b1 or b2 <= y1) n = len(fields) for i in range(n): for j in range(i + 1, n): if is_overlap(fields[i], fields[j]): return \\"YES\\" return \\"NO\\""},{"question":"def min_weight_difference(n: int, m: int, edge_list: List[Tuple[int, int, int]]) -> int: Given an undirected graph with n nodes and m edges, find the minimum possible weight difference between the heaviest and the lightest edge in the resulting tree after removing the necessary edges. >>> min_weight_difference(6, 7, [(1, 2, 3), (2, 3, 3), (3, 4, 5), (4, 5, 6), (5, 6, 7), (1, 6, 8), (1, 3, 2)]) == 4 >>> min_weight_difference(4, 3, [(1, 2, 1), (2, 3, 2), (3, 4, 3)]) == 2 >>> min_weight_difference(2, 1, [(1, 2, 10)]) == 0 >>> min_weight_difference(3, 1, [(1, 2, 4)]) == float('inf') >>> min_weight_difference(4, 5, [(1, 2, 7), (2, 3, 7), (3, 4, 7), (1, 3, 7), (2, 4, 7)]) == 0 pass","solution":"def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 def kruskal(n, edges): # Sort edges by their weight edges = sorted(edges, key=lambda x: x[2]) max_diff = float('inf') for i in range(len(edges)): parent = [j for j in range(n)] rank = [0] * n selected_edges = [] for j in range(i, len(edges)): u, v, w = edges[j] root_u = find(parent, u-1) root_v = find(parent, v-1) if root_u != root_v: selected_edges.append((u, v, w)) union(parent, rank, root_u, root_v) if len(selected_edges) == n - 1: # Found a valid spanning tree break if len(selected_edges) == n - 1: weight_diff = selected_edges[-1][2] - selected_edges[0][2] max_diff = min(max_diff, weight_diff) return max_diff # Main function to be used to read input def min_weight_difference(n, m, edge_list): edges = [tuple(edge_list[i]) for i in range(m)] return kruskal(n, edges)"},{"question":"def max_subgrid_sum(n: int, k: int, grid: List[List[int]]) -> int: Given a grid of size \`n\` x \`n\` filled with non-negative integers, find the maximum sum possible by selecting a sub-grid of size \`k\` x \`k\` from the given grid. >>> max_subgrid_sum(4, 2, [ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16]] ... ) == 54 >>> max_subgrid_sum(3, 2, [ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1]] ... ) == 4 from typing import List def test_max_subgrid_sum_case_1(): grid = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] assert max_subgrid_sum(4, 2, grid) == 54 def test_max_subgrid_sum_case_2(): grid = [ [1, 1, 1], [1, 1, 1], [1, 1, 1] ] assert max_subgrid_sum(3, 2, grid) == 4 def test_max_subgrid_sum_case_3(): grid = [ [3, 3, 3], [3, 3, 3], [3, 3, 3] ] assert max_subgrid_sum(3, 3, grid) == 27 def test_max_subgrid_sum_case_4(): grid = [ [1, 2], [3, 4] ] assert max_subgrid_sum(2, 2, grid) == 10 def test_max_subgrid_sum_case_5(): grid = [ [1000] ] assert max_subgrid_sum(1, 1, grid) == 1000","solution":"def max_subgrid_sum(n, k, grid): Returns the maximum sum of a k x k sub-grid within the n x n grid. Args: n: The size of the grid (n x n). k: The size of the sub-grid (k x k). grid: A list of lists representing the grid. Returns: An integer representing the maximum sum of a k x k sub-grid. max_sum = 0 for i in range(n - k + 1): for j in range(n - k + 1): subgrid_sum = 0 for x in range(k): for y in range(k): subgrid_sum += grid[i + x][j + y] max_sum = max(max_sum, subgrid_sum) return max_sum"},{"question":"def sort_photos(n: int, photos: List[str]) -> List[str]: Sorts a list of photo names based on the numerical order of the photo numbers. Args: n (int): The number of photo names. photos (list of str): List of photo names in the format \\"PhotoX\\", where X is a positive integer. Returns: list of str: The sorted list of photo names. >>> sort_photos(5, [\\"Photo2\\", \\"Photo10\\", \\"Photo1\\", \\"Photo4\\", \\"Photo3\\"]) [\\"Photo1\\", \\"Photo2\\", \\"Photo3\\", \\"Photo4\\", \\"Photo10\\"] >>> sort_photos(1, [\\"Photo1\\"]) [\\"Photo1\\"] >>> sort_photos(3, [\\"Photo1\\", \\"Photo2\\", \\"Photo3\\"]) [\\"Photo1\\", \\"Photo2\\", \\"Photo3\\"] >>> sort_photos(3, [\\"Photo3\\", \\"Photo2\\", \\"Photo1\\"]) [\\"Photo1\\", \\"Photo2\\", \\"Photo3\\"] >>> sort_photos(3, [\\"Photo1000000\\", \\"Photo1\\", \\"Photo999999\\"]) [\\"Photo1\\", \\"Photo999999\\", \\"Photo1000000\\"] >>> sort_photos(4, [\\"Photo10\\", \\"Photo2\\", \\"Photo20\\", \\"Photo3\\"]) [\\"Photo2\\", \\"Photo3\\", \\"Photo10\\", \\"Photo20\\"]","solution":"def sort_photos(n, photos): Sorts a list of photo names based on the numerical order of the photo numbers. Args: n (int): The number of photo names. photos (list of str): List of photo names in the format \\"PhotoX\\", where X is a positive integer. Returns: list of str: The sorted list of photo names. def extract_number(photo_name): Extracts the numeric part from a photo name string. Args: photo_name (str): The photo name in the format \\"PhotoX\\". Returns: int: The numeric part extracted from the photo name. return int(photo_name[5:]) # Sort the photos based on the extracted numbers sorted_photos = sorted(photos, key=extract_number) return sorted_photos"},{"question":"import math from typing import List, Tuple def haversine(lat1: float, lon1: float, lat2: float, lon2: float) -> float: Calculate the great-circle distance between two points on the Earth's surface given their latitude and longitude in degrees. >>> round(haversine(40.730610, -73.935242, 40.730611, -73.935200), 2) == 0.00 >>> round(haversine(34.052235, -118.243683, 34.052245, -118.243679), 2) == 0.00 def total_distance_traveled(bird_coordinates: List[Tuple[float, float]]) -> float: Calculate the total distance traveled by a bird using its recorded coordinates. >>> bird_coordinates = [(40.730610, -73.935242), (40.730611, -73.935200), (40.730612, -73.935180)] >>> total_distance_traveled(bird_coordinates) == 0.01 >>> bird_coordinates = [(34.052235, -118.243683), (34.052245, -118.243679), (34.052255, -118.243670)] >>> total_distance_traveled(bird_coordinates) == 0.00 def main(n: int, birds_coordinates: List[List[Tuple[float, float]]]) -> List[float]: Determine the total distance traveled by each bird given the list of coordinates recorded every minute over an hour. >>> n = 2 >>> birds_coordinates = [ [(40.730610, -73.935242), (40.730611, -73.935200), (40.730612, -73.935180)], [(34.052235, -118.243683), (34.052245, -118.243679), (34.052255, -118.243670)] ] >>> main(n, birds_coordinates) == [0.01, 0.00]","solution":"import math def haversine(lat1, lon1, lat2, lon2): # Radius of the Earth in kilometers R = 6371.0 # Convert latitude and longitude from degrees to radians lat1_rad = math.radians(lat1) lon1_rad = math.radians(lon1) lat2_rad = math.radians(lat2) lon2_rad = math.radians(lon2) # Difference in coordinates dlat = lat2_rad - lat1_rad dlon = lon2_rad - lon1_rad # Haversine formula a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2 c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a)) # Distance in kilometers distance = R * c return distance def total_distance_traveled(bird_coordinates): total_distance = 0.0 for i in range(len(bird_coordinates) - 1): lat1, lon1 = bird_coordinates[i] lat2, lon2 = bird_coordinates[i + 1] total_distance += haversine(lat1, lon1, lat2, lon2) return round(total_distance, 2) def main(n, birds_coordinates): results = [] for bird_coordinates in birds_coordinates: total_distance = total_distance_traveled(bird_coordinates) results.append(total_distance) return results"},{"question":"def can_watch_all_movies(screenings: list) -> str: Determines if a person can watch all movies without any schedule conflicts based on the provided screenings. Args: screenings (list of tuples): Each tuple contains three integers, start time, end time, and movie ID for each screening. Returns: str: \\"Possible\\" if a person can watch all movies without any schedule conflicts, otherwise \\"Impossible\\". >>> can_watch_all_movies([(60, 120, 1), (130, 170, 2), (180, 240, 3)]) == \\"Possible\\" >>> can_watch_all_movies([(60, 120, 1), (100, 140, 2), (130, 180, 3)]) == \\"Impossible\\" pass def process_input(input_data: str) -> list: Processes the input data to format the screenings list. Args: input_data (str): Raw input data as a single string. Returns: list: List containing screening details. >>> process_input(\\"3n60 120 1n130 170 2n180 240 3\\") == [(60, 120, 1), (130, 170, 2), (180, 240, 3)] pass def solve(input_data: str) -> str: Main function to be called for solving the problem with given input data. Args: input_data (str): Raw input data as a single string. Returns: str: \\"Possible\\" if it's possible to watch all movies without conflicts, otherwise \\"Impossible\\". >>> solve(\\"3n60 120 1n130 170 2n180 240 3\\") == \\"Possible\\" >>> solve(\\"3n60 120 1n100 140 3n130 170 2\\") == \\"Impossible\\" pass","solution":"def can_watch_all_movies(screenings): Determines if a person can watch all movies without any schedule conflicts based on the provided screenings. Args: screenings (list of tuples): Each tuple contains three integers, start time, end time, and movie ID for each screening. Returns: str: \\"Possible\\" if a person can watch all movies without any schedule conflicts, otherwise \\"Impossible\\". # Sort the screenings by the start time and if equal by end time screenings.sort(key=lambda x: (x[0], x[1])) # Check for overlapping screenings for i in range(1, len(screenings)): # If the start time of the current screening is less than the end time of the previous screening if screenings[i][0] < screenings[i - 1][1]: return \\"Impossible\\" return \\"Possible\\" def process_input(input_data): Processes the input data to format the screenings list. Args: input_data (str): Raw input data as a single string. Returns: list of tuples: List containing screening details. lines = input_data.strip().split('n') N = int(lines[0]) screenings = [] for i in range(1, N + 1): S, E, M = map(int, lines[i].split()) screenings.append((S, E, M)) return screenings # Main function to be called for solving the problem with given input data def solve(input_data): screenings = process_input(input_data) return can_watch_all_movies(screenings)"},{"question":"from typing import List def countRegions(N: int, M: int, grid: List[List[int]]) -> int: You are given a grid with 'N' rows and 'M' columns, where each cell can either be '0' or '1'. A '1' indicates that the cell is filled, whereas a '0' means the cell is empty. The grid is initially filled in such a way that there can be several regions of connected '1's. Two cells are considered connected if they are adjacent horizontally or vertically (not diagonally). Your task is to count the number of distinct regions of connected '1's in the grid. Args: N : int : number of rows in the grid. M : int : number of columns in the grid. grid : List[List[int]] : 2D list of size N x M, where grid[i][j] is either 0 or 1. Returns: int : the number of distinct regions of connected '1's. Example: >>> N = 4 >>> M = 5 >>> grid = [ ... [1, 0, 0, 1, 1], ... [1, 1, 0, 0, 0], ... [0, 0, 1, 1, 0], ... [0, 0, 0, 0, 1] ... ] >>> countRegions(N, M, grid) 4 >>> N = 3 >>> M = 3 >>> grid = [ ... [1, 1, 0], ... [0, 1, 0], ... [0, 0, 1] ... ] >>> countRegions(N, M, grid) 2","solution":"from typing import List def countRegions(N: int, M: int, grid: List[List[int]]) -> int: def dfs(r, c): if r < 0 or r >= N or c < 0 or c >= M or grid[r][c] == 0: return grid[r][c] = 0 # Mark as visited dfs(r+1, c) dfs(r-1, c) dfs(r, c+1) dfs(r, c-1) num_regions = 0 for i in range(N): for j in range(M): if grid[i][j] == 1: dfs(i, j) num_regions += 1 return num_regions"},{"question":"def min_operations_to_reach_target(grid, R, C, T): Returns the minimum number of operations required to make every cell in the grid at least T. Parameters: grid (list of list of int): The initial grid values. R (int): Number of rows. C (int): Number of columns. T (int): Target value that every cell in the grid must reach or exceed. Returns: int: Minimum number of operations required. pass from solution import min_operations_to_reach_target def test_min_operations_to_reach_target_example(): grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] R, C, T = 3, 3, 5 assert min_operations_to_reach_target(grid, R, C, T) == 4 def test_min_operations_to_reach_target_no_operations_needed(): grid = [ [10, 20, 30], [40, 50, 60], [70, 80, 90] ] R, C, T = 3, 3, 10 assert min_operations_to_reach_target(grid, R, C, T) == 0 def test_min_operations_to_reach_target_one_operation_needed(): grid = [ [9, 9, 9], [9, 9, 9], [9, 9, 9] ] R, C, T = 3, 3, 10 assert min_operations_to_reach_target(grid, R, C, T) == 1 def test_min_operations_to_reach_target_multiple_operations(): grid = [ [1, 1, 1], [1, 1, 1], [1, 1, 1] ] R, C, T = 3, 3, 4 assert min_operations_to_reach_target(grid, R, C, T) == 3","solution":"def min_operations_to_reach_target(grid, R, C, T): Returns the minimum number of operations required to make every cell in the grid at least T. Parameters: grid (list of list of int): The initial grid values. R (int): Number of rows. C (int): Number of columns. T (int): Target value that every cell in the grid must reach or exceed. Returns: int: Minimum number of operations required. min_value = min(min(row) for row in grid) return max(0, T - min_value)"},{"question":"def longest_consecutive_subsequence(arr): Given a list of integers, find the longest consecutive subsequence in the list. The subsequence should consist of consecutive integers from the list. If there are multiple subsequences with the same length, return any one of them. Example: >>> longest_consecutive_subsequence([1, 2, 9, 3, 10, 4, 20]) [1, 2, 3, 4] >>> longest_consecutive_subsequence([1, 3, 5, 7, 9]) [1] def test_example_1(): assert longest_consecutive_subsequence([1, 2, 9, 3, 10, 4, 20]) == [1, 2, 3, 4] def test_example_2(): assert longest_consecutive_subsequence([1, 3, 5, 7, 9]) == [1] def test_example_3(): assert longest_consecutive_subsequence([5, 4, 2, 6, 1, 7, 3, 8]) == [1, 2, 3, 4, 5, 6, 7, 8] def test_empty_list(): assert longest_consecutive_subsequence([]) == [] def test_single_element(): assert longest_consecutive_subsequence([100]) == [100] def test_disconnected_sequences(): assert longest_consecutive_subsequence([10, 5, 12, 3, 55, 1, 9, 2, 4, 7]) == [1, 2, 3, 4, 5] def test_large_numbers(): assert longest_consecutive_subsequence([100, 200, 1, 2, 3, 4, 5, 201, 202, 203, 7]) == [1, 2, 3, 4, 5] def test_negative_numbers(): assert longest_consecutive_subsequence([-1, -2, -3, -4, -5, 2, 3, 4, 5]) == [-5, -4, -3, -2, -1] def test_large_list(): large_list = list(range(1000000, 1010000)) assert longest_consecutive_subsequence(large_list) == large_list","solution":"def longest_consecutive_subsequence(arr): Finds the longest consecutive subsequence in the list. if not arr: return [] num_set = set(arr) longest_streak = 0 longest_subseq = [] for num in num_set: if num - 1 not in num_set: # It's the start of a sequence current_num = num current_streak = 1 current_subseq = [current_num] while current_num + 1 in num_set: current_num += 1 current_streak += 1 current_subseq.append(current_num) if current_streak > longest_streak: longest_streak = current_streak longest_subseq = current_subseq return longest_subseq"},{"question":"def can_form_rectangle(n, lengths): Determines if it's possible to form a rectangle using exactly four sticks. >>> can_form_rectangle(5, [3, 3, 3, 3, 4]) \\"YES\\" >>> can_form_rectangle(6, [2, 2, 3, 3, 4, 4]) \\"YES\\" >>> can_form_rectangle(4, [1, 2, 3, 4]) \\"NO\\" from collections import Counter def test_example_1(): assert can_form_rectangle(5, [3, 3, 3, 3, 4]) == \\"YES\\" def test_example_2(): assert can_form_rectangle(6, [2, 2, 3, 3, 4, 4]) == \\"YES\\" def test_example_3(): assert can_form_rectangle(4, [1, 2, 3, 4]) == \\"NO\\" def test_not_enough_sticks(): assert can_form_rectangle(3, [3, 3, 3]) == \\"NO\\" def test_all_different_lengths(): assert can_form_rectangle(4, [1, 2, 3, 4]) == \\"NO\\" def test_extra_sticks(): assert can_form_rectangle(7, [2, 2, 2, 2, 2, 3, 4]) == \\"YES\\" def test_all_same_length(): assert can_form_rectangle(6, [4, 4, 4, 4, 4, 4]) == \\"YES\\" def test_just_4_sticks_and_a_rectangle_is_possible(): assert can_form_rectangle(4, [5, 5, 7, 7]) == \\"YES\\"","solution":"def can_form_rectangle(n, lengths): Determines if it's possible to form a rectangle using exactly four sticks. from collections import Counter count = Counter(lengths) pairs = 0 for length in count: pairs += count[length] // 2 # Counting pairs of sticks return \\"YES\\" if pairs >= 2 else \\"NO\\" # Example usage: # n = 5 # lengths = [3, 3, 3, 3, 4] # print(can_form_rectangle(n, lengths)) # Output: YES"},{"question":"from collections import deque, defaultdict from typing import List, Tuple def shortest_paths(n: int, m: int, connections: List[Tuple[int, int]], q: int, queries: List[Tuple[int, int]]) -> List[int]: Given a list of direct connections between the servers, your task is to determine the shortest path between two specific servers whenever queried. If there's no path between the two servers, return -1. Parameters: n : int : number of servers m : int : number of direct connections connections : List[Tuple[int, int]] : list of direct connections q : int : number of queries queries : List[Tuple[int, int]] : list of queries Returns: List[int] : list of shortest distances for each query >>> shortest_paths(5, 6, [(1, 2), (1, 3), (2, 4), (3, 5), (4, 5), (2, 3)], 3, [(1, 5), (2, 3), (1, 4)]) [2, 1, 2] >>> shortest_paths(5, 2, [(1, 2), (3, 4)], 2, [(1, 3), (2, 4)]) [-1, -1] >>> shortest_paths(4, 3, [(1, 2), (2, 3), (3, 4)], 1, [(1, 1)]) [0] >>> shortest_paths(4, 3, [(1, 2), (2, 3), (3, 4)], 2, [(1, 4), (2, 4)]) [3, 2] >>> shortest_paths(6, 7, [(1, 2), (1, 3), (2, 3), (2, 4), (3, 5), (4, 5), (4, 6)], 3, [(1, 6), (3, 4), (5, 6)]) [3, 2, 2]","solution":"from collections import deque, defaultdict def shortest_paths(n, m, connections, q, queries): # Build the graph graph = defaultdict(list) for u, v in connections: graph[u].append(v) graph[v].append(u) def bfs(start, end): # Perform BFS to find the shortest path visited = {i: False for i in range(1, n + 1)} queue = deque([(start, 0)]) visited[start] = True while queue: node, dist = queue.popleft() if node == end: return dist for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append((neighbor, dist + 1)) return -1 results = [] for a, b in queries: if a == b: results.append(0) else: results.append(bfs(a, b)) return results"},{"question":"def max_possible_value(m: int, start: int, operations: List[Tuple[int, int]]) -> int: Calculate the maximum possible value of the variable after performing any number of operations in any order. :param m: int - the number of operations :param start: int - the initial value of the variable :param operations: list of tuples [(c1, d1), (c2, d2), ..., (cm, dm)] where each ci is ignored and di indicates the changes :return: int - the maximum possible value of the variable >>> max_possible_value(4, 10, [(1, 4), (1, -3), (1, 5), (1, -7)]) 19 >>> max_possible_value(4, 10, [(1, -4), (1, -3), (1, -5), (1, -7)]) 10 >>> max_possible_value(4, 0, [(1, 3), (1, 3), (1, 3), (1, 3)]) 12 >>> max_possible_value(2, 1, [(1, 1000000000), (1, -1000000000)]) 1000000001 >>> max_possible_value(3, -5, [(1, 0), (1, 0), (1, 0)]) -5 >>> max_possible_value(5, -10, [(1, -1), (1, 1), (1, -1), (1, 1), (1, -1)]) -8","solution":"def max_possible_value(m, start, operations): Calculate the maximum possible value of the variable after performing any number of operations in any order. :param m: int - the number of operations :param start: int - the initial value of the variable :param operations: list of tuples [(c1, d1), (c2, d2), ..., (cm, dm)] where each ci is ignored and di indicates the changes :return: int - the maximum possible value of the variable max_increase = 0 for c, d in operations: if d > 0: max_increase += d return start + max_increase"},{"question":"def update_ages(ages: List[int], new_born_count: int) -> List[int]: Updates the ages of a group of people by adding one year for each person and adding new born people with age 0. Parameters: - ages (list of int): Current ages of people. - new_born_count (int): Number of newly born people this year. Returns: - list of int: Updated ages including the newly born people. >>> update_ages([5, 10, 35, 67], 0) [6, 11, 36, 68] >>> update_ages([5, 10, 35, 67], 2) [6, 11, 36, 68, 0, 0] >>> update_ages([], 3) [0, 0, 0] >>> update_ages([20, 45], 1) [21, 46, 0] >>> update_ages([1, 2, 3], 1000000) [2, 3, 4, 0, 0, 0, ..., 0] # 1000000 zeroes","solution":"def update_ages(ages, new_born_count): Updates the ages of a group of people by adding one year for each person and adding new born people with age 0. Parameters: - ages (list of int): Current ages of people. - new_born_count (int): Number of newly born people this year. Returns: - list of int: Updated ages including the newly born people. updated_ages = [age + 1 for age in ages] new_born_ages = [0] * new_born_count return updated_ages + new_born_ages"},{"question":"def filter_vehicles(vehicle_list: List[Tuple[int, int]], d: int) -> List[int]: Filters out vehicles that can cover at least distance d. Parameters: vehicle_list (list of tuples): Each tuple contains (vehicleID, distance) d (int): The minimum distance a vehicle should be able to cover Returns: list of int: A list of vehicle IDs that meet or exceed the distance d >>> filter_vehicles([(101, 400), (102, 350), (103, 450), (104, 300)], 300) [101, 102, 103, 104] >>> filter_vehicles([(101, 400), (102, 350), (103, 450), (104, 300)], 360) [101, 103] >>> filter_vehicles([(101, 400), (102, 350), (103, 450), (104, 300)], 500) [] >>> filter_vehicles([(101, 400), (102, 350), (103, 450), (104, 300)], 450) [103] >>> filter_vehicles([], 300) [] >>> filter_vehicles([(101, 0), (102, 0), (103, 0), (104, 0)], 0) [101, 102, 103, 104] >>> filter_vehicles([(i, i * 10) for i in range(1000)], 5000) list(range(500, 1000))","solution":"def filter_vehicles(vehicle_list, d): Filters out vehicles that can cover at least distance d. Parameters: vehicle_list (list of tuples): Each tuple contains (vehicleID, distance) d (int): The minimum distance a vehicle should be able to cover Returns: list of int: A list of vehicle IDs that meet or exceed the distance d return [vehicle_id for vehicle_id, distance in vehicle_list if distance >= d]"},{"question":"from typing import List, Tuple def max_total_latency(n: int, edges: List[Tuple[int, int, int]]) -> int: Compute the maximum total latency across all distinct communication paths between devices. Args: n: The number of devices in the network. edges: A list of tuples where each tuple contains three integers u, v, and w, indicating a direct communication link between devices u and v with a latency of w. Returns: The maximum possible total sum of latencies for all device pairs in the network. Examples: >>> max_total_latency(3, [(1, 2, 1), (2, 3, 2)]) 6 >>> max_total_latency(2, [(1, 2, 1)]) 1 >>> max_total_latency(4, [(1, 2, 1), (2, 3, 2), (3, 4, 3)]) 20 >>> max_total_latency(5, [(1, 2, 1), (1, 3, 2), (1, 4, 3), (1, 5, 4)]) 40 import pytest def test_example_case(): n = 3 edges = [(1, 2, 1), (2, 3, 2)] assert max_total_latency(n, edges) == 6 def test_two_devices(): n = 2 edges = [(1, 2, 1)] assert max_total_latency(n, edges) == 1 def test_large_case(): n = 4 edges = [ (1, 2, 1), (2, 3, 2), (3, 4, 3) ] # Paths: 1-2, 1-3, 1-4, 2-3, 2-4, 3-4 # Latencies: 1, (1+2), (1+2+3), 2, (2+3), 3 => 1 + 3 + 6 + 2 + 5 + 3 = 20 assert max_total_latency(n, edges) == 20 def test_star_topology(): n = 5 edges = [ (1, 2, 1), (1, 3, 2), (1, 4, 3), (1, 5, 4) ] # Paths: 1-2, 1-3, 1-4, 1-5, 2-3, 2-4, 2-5, 3-4, 3-5, 4-5 # Latencies: 1, 2, 3, 4, (1+2), (1+3), (1+4), (2+3), (2+4), (3+4) # => 1 + 2 + 3 + 4 + 3 + 4 + 5 + 5 + 6 + 7 = 40 assert max_total_latency(n, edges) == 40","solution":"def max_total_latency(n, edges): import collections from heapq import heappop, heappush # Build the adjacency list for the graph adj = collections.defaultdict(list) for u, v, w in edges: adj[u].append((v, w)) adj[v].append((u, w)) def dijkstra(source): min_heap = [(0, source)] distance = {i: float('inf') for i in range(1, n + 1)} distance[source] = 0 while min_heap: dist, node = heappop(min_heap) if dist > distance[node]: continue for neighbor, weight in adj[node]: d = dist + weight if d < distance[neighbor]: distance[neighbor] = d heappush(min_heap, (d, neighbor)) return distance # Sum up all the distances for each pair (i, j) total_latency = 0 for i in range(1, n + 1): distances = dijkstra(i) for j in range(i + 1, n + 1): total_latency += distances[j] return total_latency # Example usage if __name__ == \\"__main__\\": n = 3 edges = [(1, 2, 1), (2, 3, 2)] print(max_total_latency(n, edges)) # Output: 6"},{"question":"from typing import List, Tuple def minNewRoads(n: int, roads: List[Tuple[int, int]]) -> int: Find the minimum number of roads required to make all intersections reachable from any other intersection. >>> minNewRoads(4, [(0, 1), (1, 2)]) == 1 >>> minNewRoads(6, [(0, 1), (0, 2), (3, 4)]) == 2 def test_minNewRoads_example_cases(): assert minNewRoads(4, [(0, 1), (1, 2)]) == 1 assert minNewRoads(6, [(0, 1), (0, 2), (3, 4)]) == 2 def test_minNewRoads_no_existing_roads(): assert minNewRoads(4, []) == 3 # Since all intersections are isolated, we need 3 roads to fully connect them. def test_minNewRoads_all_interconnected(): assert minNewRoads(3, [(0, 1), (1, 2), (2, 0)]) == 0 # Already fully connected def test_minNewRoads_multiple_components(): assert minNewRoads(5, [(0, 1), (2, 3)]) == 2 # Needs at least two new roads to connect the three components def test_minNewRoads_two_components(): assert minNewRoads(5, [(0, 1), (0, 2), (3, 4)]) == 1 # Needs one new road to connect the two components","solution":"from typing import List, Tuple def minNewRoads(n: int, roads: List[Tuple[int, int]]) -> int: # Create a graph representation graph = {i: [] for i in range(n)} for a, b in roads: graph[a].append(b) graph[b].append(a) def dfs(node, visited): stack = [node] while stack: current = stack.pop() for neighbor in graph[current]: if neighbor not in visited: visited.add(neighbor) stack.append(neighbor) # Find all connected components visited = set() num_components = 0 for i in range(n): if i not in visited: dfs(i, visited) num_components += 1 # To connect all components, we need (num_components - 1) roads return num_components - 1"},{"question":"from datetime import datetime, timedelta from typing import List def most_active_hour(n: int, timestamps: List[str]) -> str: Determines the start of the one-hour period with the highest number of posts. Parameters: n (int): Number of posts. timestamps (list of str): List of timestamps indicating the times the posts were made. Returns: str: The start of the one-hour period in \\"YYYY-MM-DD HH:MM:SS\\" format. def test_example_1(): n = 5 timestamps = [ \\"2023-10-01 14:00:00\\", \\"2023-10-01 14:30:00\\", \\"2023-10-01 14:45:00\\", \\"2023-10-01 15:00:00\\", \\"2023-10-01 15:30:00\\" ] assert most_active_hour(n, timestamps) == \\"2023-10-01 14:00:00\\" def test_example_2(): n = 7 timestamps = [ \\"2023-10-01 10:00:00\\", \\"2023-10-01 10:15:00\\", \\"2023-10-01 10:30:00\\", \\"2023-10-01 11:00:00\\", \\"2023-10-01 11:15:00\\", \\"2023-10-02 10:00:00\\", \\"2023-10-02 10:15:00\\" ] assert most_active_hour(n, timestamps) == \\"2023-10-01 10:00:00\\" def test_single_post(): n = 1 timestamps = [ \\"2023-10-01 14:00:00\\" ] assert most_active_hour(n, timestamps) == \\"2023-10-01 14:00:00\\" def test_multiple_periods_with_same_activity(): n = 6 timestamps = [ \\"2023-10-01 14:00:00\\", \\"2023-10-01 14:30:00\\", \\"2023-10-01 15:00:00\\", \\"2023-10-01 15:30:00\\", \\"2023-10-01 16:00:00\\", \\"2023-10-01 16:30:00\\" ] assert most_active_hour(n, timestamps) == \\"2023-10-01 14:00:00\\" def test_no_posts_in_one_hour_valid_period(): n = 4 timestamps = [ \\"2023-10-01 14:00:00\\", \\"2023-10-01 15:00:00\\", \\"2023-10-01 16:00:00\\", \\"2023-10-01 17:00:00\\" ] assert most_active_hour(n, timestamps) == \\"2023-10-01 14:00:00\\"","solution":"from datetime import datetime, timedelta from collections import defaultdict def most_active_hour(n, timestamps): Determines the start of the one-hour period with the highest number of posts. Parameters: n (int): Number of posts. timestamps (list of str): List of timestamps indicating the times the posts were made. Returns: str: The start of the one-hour period in \\"YYYY-MM-DD HH:MM:SS\\" format. # Convert string timestamps to datetime objects datetime_stamps = [datetime.strptime(ts, \\"%Y-%m-%d %H:%M:%S\\") for ts in timestamps] # Sort datetime objects datetime_stamps.sort() max_posts = 0 best_time = None # Traverse each timestamp to find the one-hour window with the most posts for i in range(len(datetime_stamps)): start_time = datetime_stamps[i] end_time = start_time + timedelta(hours=1) # Count the number of posts within the 1-hour interval count = 0 for j in range(i, len(datetime_stamps)): if datetime_stamps[j] < end_time: count += 1 else: break # Check if this window is the most active one if count > max_posts: max_posts = count best_time = start_time return best_time.strftime(\\"%Y-%m-%d %H:%M:%S\\")"},{"question":"def count_pairs_with_difference_k(n: int, k: int, scores: List[int]) -> int: Returns the number of pairs with scores differing by exactly k. :param n: Integer - The number of students :param k: Integer - The exact difference in scores :param scores: List of integers - The scores of the students :return: Integer - The number of pairs with scores differing by exactly k >>> count_pairs_with_difference_k(4, 2, [1, 5, 3, 4]) 2 >>> count_pairs_with_difference_k(4, 10, [1, 5, 3, 15]) 1 >>> count_pairs_with_difference_k(5, 6, [1, 2, 3, 4, 5]) 0 >>> count_pairs_with_difference_k(6, 1, [1, 2, 3, 4, 5, 6]) 5 >>> count_pairs_with_difference_k(3, 0, [4, 4, 4]) 3 >>> count_pairs_with_difference_k(1, 1, [10]) 0 >>> count_pairs_with_difference_k(4, 2, [5, 5, 5, 5]) 0","solution":"def count_pairs_with_difference_k(n, k, scores): Returns the number of pairs with scores differing by exactly k. :param n: Integer - The number of students :param k: Integer - The exact difference in scores :param scores: List of integers - The scores of the students :return: Integer - The number of pairs with scores differing by exactly k count = 0 scores_set = set(scores) for score in scores: if score + k in scores_set: count += 1 if score - k in scores_set: count += 1 # Each pair is counted twice, so we divide the total count by 2 return count // 2"},{"question":"def max_consecutive_no_disease(n: int, fields: List[int]) -> int: Computes the maximum number of consecutive fields without disease. Args: n (int): The number of fields. fields (list of int): The disease status of each field (0 for no disease, 1 for disease). Returns: int: The maximum number of consecutive fields without disease. >>> max_consecutive_no_disease(10, [1, 0, 0, 1, 0, 0, 0, 0, 1, 0]) 4 >>> max_consecutive_no_disease(5, [0, 0, 0, 0, 0]) 5 >>> max_consecutive_no_disease(5, [1, 1, 1, 1, 1]) 0 >>> max_consecutive_no_disease(6, [0, 1, 0, 1, 0, 1]) 1 >>> max_consecutive_no_disease(1, [0]) 1 >>> max_consecutive_no_disease(1, [1]) 0 >>> max_consecutive_no_disease(8, [0, 0, 1, 0, 0, 0, 1, 0]) 3 >>> max_consecutive_no_disease(8, [1, 0, 0, 0, 1, 0, 0, 1]) 3 >>> max_consecutive_no_disease(9, [0, 1, 1, 0, 0, 1, 0, 0, 0]) 3","solution":"def max_consecutive_no_disease(n, fields): Computes the maximum number of consecutive fields without disease. Args: n (int): The number of fields. fields (list of int): The disease status of each field (0 for no disease, 1 for disease). Returns: int: The maximum number of consecutive fields without disease. max_streak = 0 current_streak = 0 for field in fields: if field == 0: current_streak += 1 max_streak = max(max_streak, current_streak) else: current_streak = 0 return max_streak"},{"question":"def max_value_of_starting_node(n, m, initial_values, edges): You are given an undirected graph with n nodes and m edges. Each node has an initial value assigned to it. The value of a node can be changed to any integer multiple of its initial value. Your task is to determine the maximum value that can be assigned to the starting node (node 1) such that there exists a path from the starting node to every other node, and the sum of the values of all nodes is minimized. Args: n (int): The number of nodes. m (int): The number of edges. initial_values (List[int]): A list where the i-th integer represents the initial value of the i-th node. edges (List[Tuple[int, int]]): A list of tuples representing the edges between nodes. Returns: int: The maximum value that can be assigned to the starting node (node 1) under the given constraints. Example: >>> max_value_of_starting_node(4, 4, [10, 20, 30, 40], [(1, 2), (2, 3), (3, 4), (4, 1)]) 80 from solution import max_value_of_starting_node def test_single_node(): assert max_value_of_starting_node(1, 0, [10], []) == 10 def test_disconnected_graph(): assert max_value_of_starting_node(2, 0, [10, 20], []) == 10 def test_simple_case(): assert max_value_of_starting_node(4, 4, [10, 20, 30, 40], [(1, 2), (2, 3), (3, 4), (4, 1)]) == 10 def test_minimal_sum(): assert max_value_of_starting_node(4, 3, [10, 20, 30, 40], [(1, 2), (2, 3), (3, 4)]) == 10 def test_complex_case(): assert max_value_of_starting_node(5, 4, [15, 25, 35, 45, 5], [(1, 2), (2, 3), (3, 4), (4, 5)]) == 5","solution":"def max_value_of_starting_node(n, m, initial_values, edges): from collections import defaultdict, deque # Step 1: Build the adjacency list of the graph graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # Step 2: Use BFS to find connected components visited = [False] * (n + 1) connected_components = [] def bfs(node): component = [] queue = deque([node]) visited[node] = True while queue: current = queue.popleft() component.append(current) for neighbor in graph[current]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return component for i in range(1, n + 1): if not visited[i]: component = bfs(i) connected_components.append(component) # Step 3: Find the connected component containing the starting node (node 1) starting_component = [] for component in connected_components: if 1 in component: starting_component = component break # Step 4: Find the node with the minimum initial value in the starting component min_initial_value = min(initial_values[node - 1] for node in starting_component) # Step 5: Calculate the maximum value for the starting node max_value = min_initial_value return max_value"},{"question":"def find_min_difference(n: int, arr: List[int]) -> int: Sara has been given an array of positive integers. She needs to divide this array into two non-empty subarrays such that the sum of elements in the first subarray is as close as possible to the sum of elements in the second subarray. Each element of the array should belong to exactly one subarray. Help Sara find the minimum possible absolute difference between the sum of the elements in the two subarrays. Parameters: n (int): The number of elements in the array. arr (List[int]): The list of integers representing the array. Returns: int: The minimum possible absolute difference between the sum of the elements of the two subarrays. >>> find_min_difference(7, [3, 1, 4, 2, 2, 1, 2]) 1 >>> find_min_difference(2, [1, 2]) 1 >>> find_min_difference(4, [4, 4, 4, 4]) 0 >>> find_min_difference(3, [10, 1, 9]) 0 >>> find_min_difference(5, [1, 1, 1, 1, 1]) 1 >>> find_min_difference(6, [3, 3, 1, 1, 2, 2]) 0 from typing import List def test_example_case(): n = 7 arr = [3, 1, 4, 2, 2, 1, 2] assert find_min_difference(n, arr) == 1 def test_two_elements(): n = 2 arr = [1, 2] assert find_min_difference(n, arr) == 1 def test_equal_elements(): n = 4 arr = [4, 4, 4, 4] assert find_min_difference(n, arr) == 0 def test_large_difference(): n = 3 arr = [10, 1, 9] assert find_min_difference(n, arr) == 0 def test_all_elements_one(): n = 5 arr = [1, 1, 1, 1, 1] assert find_min_difference(n, arr) == 1 def test_large_array(): n = 6 arr = [3, 3, 1, 1, 2, 2] assert find_min_difference(n, arr) == 0","solution":"def find_min_difference(n, arr): total_sum = sum(arr) current_sum = 0 min_diff = float('inf') for value in arr[:-1]: current_sum += value diff = abs(total_sum - 2 * current_sum) if diff < min_diff: min_diff = diff return min_diff"},{"question":"def concatenate_strings_with_smallest_k(n: int, k: int, strings: List[str]) -> str: Concatenate all the strings in such a way that the resulting string starts with the lexicographically smallest possible substring of length k. >>> concatenate_strings_with_smallest_k(3, 2, [\\"banana\\", \\"apple\\", \\"grape\\"]) \\"applebananagrape\\" # Example test cases from solution import concatenate_strings_with_smallest_k def test_concatenate_strings_with_smallest_k_basic_case(): n = 3 k = 2 strings = [\\"banana\\", \\"apple\\", \\"grape\\"] result = concatenate_strings_with_smallest_k(n, k, strings) assert result == \\"applebananagrape\\" def test_concatenate_strings_with_smallest_k_single_string(): n = 1 k = 1 strings = [\\"single\\"] result = concatenate_strings_with_smallest_k(n, k, strings) assert result == \\"single\\" def test_concatenate_strings_with_smallest_k_all_equal_strings(): n = 4 k = 1 strings = [\\"dog\\", \\"dog\\", \\"dog\\", \\"dog\\"] result = concatenate_strings_with_smallest_k(n, k, strings) assert result == \\"dogdogdogdog\\" def test_concatenate_strings_with_smallest_k_multiple(): n = 4 k = 3 strings = [\\"banana\\", \\"apple\\", \\"apricot\\", \\"grape\\"] result = concatenate_strings_with_smallest_k(n, k, strings) assert result == \\"appleapricotbananagrape\\" def test_concatenate_strings_with_smallest_k_different_lengths(): n = 3 k = 2 strings = [\\"a\\", \\"ab\\", \\"abc\\"] result = concatenate_strings_with_smallest_k(n, k, strings) assert result == \\"aababc\\"","solution":"def concatenate_strings_with_smallest_k(n, k, strings): # Sort strings based on their first k characters lexicographically strings.sort(key=lambda x: x[:k]) # Concatenate all sorted strings result = ''.join(strings) return result"},{"question":"from typing import List def max_subarray_sum(nums: List[int], k: int) -> int: Given an integer array nums, and an integer k, return the maximum sum of any subarray of size k. >>> max_subarray_sum([2, 1, 5, 1, 3, 2, -1], 3) == 9 >>> max_subarray_sum([1], 1) == 1 >>> max_subarray_sum([-1], 1) == -1 >>> max_subarray_sum([1, 2, 3, 4, 5], 2) == 9 >>> max_subarray_sum([1, 5, 10, 15, 20], 3) == 45 >>> max_subarray_sum([-1, -2, -3, 4, 5], 2) == 9 >>> max_subarray_sum([2, -1, 2, 3, -2, 4, -1], 4) == 7 >>> max_subarray_sum([-1, -2, -3, -4, -5], 2) == -3 >>> max_subarray_sum([-1, -5, -10, -15, -20], 3) == -16","solution":"def max_subarray_sum(nums, k): Returns the maximum sum of any subarray of size k. # Calculate the sum of the first window current_sum = sum(nums[:k]) max_sum = current_sum # Slide the window across the array for i in range(k, len(nums)): current_sum += nums[i] - nums[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def longest_alternating_subsequence(arr): Returns the length of the longest subsequence that alternates between even and odd elements. >>> longest_alternating_subsequence([1, 2, 3, 4, 5, 6]) == 6 >>> longest_alternating_subsequence([42]) == 1 >>> longest_alternating_subsequence([2, 4, 6, 8, 10]) == 1 >>> longest_alternating_subsequence([1, 3, 5, 7, 9]) == 1 >>> longest_alternating_subsequence([1, 2, 3, 4, 5, 6, 7, 8, 9]) == 9 >>> longest_alternating_subsequence([2, 1, 4, 3, 6, 5, 8, 7, 10]) == 9 >>> longest_alternating_subsequence([1, 1, 1, 1, 1]) == 1 >>> longest_alternating_subsequence([2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]) == 19 >>> longest_alternating_subsequence([]) == 0","solution":"def longest_alternating_subsequence(arr): Returns the length of the longest subsequence that alternates between even and odd elements. if not arr: return 0 # Start with the length of 1 as single element itself is a valid subsequence max_len = 1 current_len = 1 for i in range(1, len(arr)): if (arr[i-1] % 2 == 0 and arr[i] % 2 != 0) or (arr[i-1] % 2 != 0 and arr[i] % 2 == 0): current_len += 1 max_len = max(max_len, current_len) else: current_len = 1 return max_len"},{"question":"def longest_non_decreasing_sequence(n: int, beauties: List[int]) -> int: Determines the length of the longest non-decreasing sequence of beauty values. Parameters: n (int): Number of flowers. beauties (list of int): List of beauty values of the flowers. Returns: int: Length of the longest non-decreasing sequence. def test_longest_non_decreasing_sequence(): # Test with provided example assert longest_non_decreasing_sequence(6, [3, 10, 2, 1, 20, 30]) == 4 # Test smallest case assert longest_non_decreasing_sequence(1, [10]) == 1 # Test case with non-decreasing order assert longest_non_decreasing_sequence(5, [1, 2, 2, 3, 4]) == 5 # Test case with all same values assert longest_non_decreasing_sequence(5, [2, 2, 2, 2, 2]) == 5 # Test case with random mixed values assert longest_non_decreasing_sequence(7, [10, 20, 10, 30, 40, 50, 10]) == 5 # Test case with decreasing order assert longest_non_decreasing_sequence(5, [5, 4, 3, 2, 1]) == 1 # Test edge case with empty input assert longest_non_decreasing_sequence(0, []) == 0 import pytest if __name__ == \\"__main__\\": pytest.main([__file__])","solution":"def longest_non_decreasing_sequence(n, beauties): Determines the length of the longest non-decreasing sequence of beauty values. Parameters: n (int): Number of flowers. beauties (list of int): List of beauty values of the flowers. Returns: int: Length of the longest non-decreasing sequence. if n == 0: return 0 # Initialize LIS array lis = [1] * n # Compute LIS values for i in range(1, n): for j in range(i): if beauties[i] >= beauties[j]: lis[i] = max(lis[i], lis[j] + 1) return max(lis) # Example usage: # n = 6 # beauties = [3, 10, 2, 1, 20, 30] # print(longest_non_decreasing_sequence(n, beauties)) # Output: 4"},{"question":"from typing import List, Tuple def find_pair_with_sum(nums: List[int], k: int) -> Tuple[int, int]: You are given an integer array nums of length n and an integer k. Write a function that finds out whether there exist two distinct indices i and j in the array such that nums[i] + nums[j] equals k. If such a pair exists, return the indices as a tuple (i, j). If there are multiple valid pairs, return any one of them. If no such pair exists, return an empty tuple. >>> find_pair_with_sum([1, 2, 3, 4, 5], 7) (1, 4) >>> find_pair_with_sum([1, 2, 3], 10) () >>> find_pair_with_sum([5], 5) () >>> find_pair_with_sum([1, 2, 3, 4, 3, 5], 6) (1, 3) >>> find_pair_with_sum([-1, -2, -3, -4, -5], -8) (2, 4) >>> find_pair_with_sum([-1, 2, 4, -3, 5], 1) (0, 1)","solution":"from typing import List, Tuple def find_pair_with_sum(nums: List[int], k: int) -> Tuple[int, int]: seen = {} for i, num in enumerate(nums): complement = k - num if complement in seen: return (seen[complement], i) seen[num] = i return ()"},{"question":"def shortest_path(n: int, m: int, roads: List[Tuple[int, int, int]], start: int, destination: int) -> int: Determines the shortest distance between two cities using Dijkstra's algorithm. >>> shortest_path(5, 6, [(1, 2, 10), (1, 3, 20), (2, 3, 5), (3, 4, 10), (2, 4, 1), (4, 5, 3)], 1, 5) 14 >>> shortest_path(3, 1, [(1, 2, 10)], 1, 3) -1 >>> shortest_path(2, 1, [(1, 2, 5)], 1, 2) 5 >>> shortest_path(4, 5, [(1, 2, 5), (2, 3, 10), (1, 3, 100), (3, 4, 1), (2, 4, 50)], 1, 4) 16 >>> shortest_path(5, 4, [(1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 5, 1)], 1, 5) 4","solution":"import heapq def shortest_path(n, m, roads, start, destination): Determines the shortest distance between two cities using Dijkstra's algorithm. # Create an adjacency list for the graph graph = [[] for _ in range(n + 1)] for u, v, l in roads: graph[u].append((v, l)) graph[v].append((u, l)) # Priority queue to store the next city to process pq = [(0, start)] # (distance, city) distances = [float('inf')] * (n + 1) distances[start] = 0 while pq: current_dist, u = heapq.heappop(pq) if current_dist > distances[u]: continue for v, length in graph[u]: distance = current_dist + length if distance < distances[v]: distances[v] = distance heapq.heappush(pq, (distance, v)) return distances[destination] if distances[destination] != float('inf') else -1"},{"question":"from collections import deque def min_moves_to_treasure(n: int, m: int, grid: List[List[str]]) -> int: Determine the minimum number of moves needed for the player to reach the treasure in the grid. >>> min_moves_to_treasure(4, 4, [['.', '.', '.', '#'], ['.', '#', '.', '.'], ['.', '.', '#', 'T'], ['#', '.', '.', '.']]) == 5 >>> min_moves_to_treasure(4, 4, [['.', '#', '.', '#'], ['#', '#', '.', '.'], ['.', '.', '#', 'T'], ['#', '.', '.', '.']]) == -1 >>> min_moves_to_treasure(1, 1, [['.']]) == -1 >>> min_moves_to_treasure(1, 1, [['T']]) == 0 >>> min_moves_to_treasure(2, 2, [['.', 'T'], ['#', '.']]) == 1 def test_min_moves_to_treasure_1(): grid = [ ['.', '.', '.', '#'], ['.', '#', '.', '.'], ['.', '.', '#', 'T'], ['#', '.', '.', '.'] ] assert min_moves_to_treasure(4, 4, grid) == 5 def test_min_moves_to_treasure_2(): grid = [ ['.', '#', '.', '#'], ['#', '#', '.', '.'], ['.', '.', '#', 'T'], ['#', '.', '.', '.'] ] assert min_moves_to_treasure(4, 4, grid) == -1 def test_min_moves_to_treasure_3(): grid = [ ['.'] ] assert min_moves_to_treasure(1, 1, grid) == -1 def test_min_moves_to_treasure_4(): grid = [ ['T'] ] assert min_moves_to_treasure(1, 1, grid) == 0 def test_min_moves_to_treasure_5(): grid = [ ['.', 'T'], ['#', '.'] ] assert min_moves_to_treasure(2, 2, grid) == 1","solution":"from collections import deque def min_moves_to_treasure(n, m, grid): # Define movements in the grid directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Initialize queue with starting position (0, 0) queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set((0, 0)) while queue: r, c, dist = queue.popleft() # Check if we found the treasure if grid[r][c] == 'T': return dist # Explore adjacent cells for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < n and 0 <= nc < m and (nr, nc) not in visited and grid[nr][nc] != '#': visited.add((nr, nc)) queue.append((nr, nc, dist + 1)) # If we finish exploring and don't find the treasure return -1"},{"question":"from typing import List import heapq from collections import Counter def reorganize_string(s: str) -> str: Rearranges the characters of the string s such that no two adjacent characters are the same. If it is not possible to do so, returns an empty string. Input: - A single line containing the string s (1  |s|  500). Output: - A single line containing the rearranged string or an empty string if no valid rearrangement exists. Example: Input: aabb Output: abab Input: aaab Output: >>> reorganize_string('aabb') in ['abab', 'baba'] True >>> reorganize_string('aaab') == '' True >>> reorganize_string('aab') == 'aba' True >>> reorganize_string('a') == 'a' True >>> reorganize_string('ab') == 'ab' True >>> reorganize_string('') == '' True >>> reorganize_string('abc') in ['abc', 'acb', 'bac', 'bca', 'cab', 'cba'] True >>> reorganize_string('aaabbc') in ['ababac', 'abacab'] True","solution":"import heapq from collections import Counter def reorganize_string(s): Rearranges the characters of the string s such that no two adjacent characters are the same. If it is not possible to do so, returns an empty string. # Count frequency of each character freq = Counter(s) # Create a max heap based on frequency max_heap = [(-value, key) for key, value in freq.items()] heapq.heapify(max_heap) prev_char, prev_freq = None, 0 result = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) if prev_char and prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) prev_char = char prev_freq = freq + 1 # decrease frequency result_str = ''.join(result) if len(result_str) == len(s): return result_str else: return \\"\\""},{"question":"def manage_inventory(n: int, transactions: List[Tuple[str, int, int]]) -> List[Tuple[int, int]]: Manage the inventory in a warehouse based on delivery notes. Args: n (int): The number of transactions. transactions (List[Tuple[str, int, int]]): The list of transactions where each transaction is represented by a tuple containing a string s, and two integers id and q. The string s can be either 'add' or 'remove'. Returns: List[Tuple[int, int]]: A sorted list of product IDs and their final quantities in the warehouse. >>> manage_inventory(6, [(\\"add\\", 1, 100), (\\"add\\", 2, 200), (\\"remove\\", 1, 50), (\\"remove\\", 2, 100), (\\"add\\", 3, 300), (\\"remove\\", 3, 300)]) [(1, 50), (2, 100)] >>> manage_inventory(4, [(\\"add\\", 3, 500), (\\"add\\", 2, 100), (\\"remove\\", 2, 150), (\\"add\\", 3, 100)]) [(3, 600)] >>> manage_inventory(3, [(\\"add\\", 1, 1000), (\\"remove\\", 1, 1000), (\\"add\\", 2, 3000)]) [(2, 3000)] >>> manage_inventory(5, [(\\"add\\", 4, 100), (\\"remove\\", 4, 50), (\\"add\\", 4, 25), (\\"remove\\", 4, 75), (\\"add\\", 5, 500)]) [(5, 500)] >>> manage_inventory(2, [(\\"add\\", 1, 10), (\\"remove\\", 1, 5)]) [(1, 5)]","solution":"def manage_inventory(n, transactions): inventory = {} for t in transactions: s, product_id, quantity = t if s == \\"add\\": if product_id in inventory: inventory[product_id] += quantity else: inventory[product_id] = quantity elif s == \\"remove\\": if product_id in inventory: inventory[product_id] -= quantity if inventory[product_id] <= 0: del inventory[product_id] result = sorted(inventory.items()) return result"},{"question":"from typing import List def max_path_sum(grid: List[List[int]]) -> int: Returns the maximum possible sum from the top-left to the bottom-right of the grid. Parameters: grid (List[List[int]]): A 2D list containing non-negative integers representing the grid. Returns: int: The maximum possible sum. Examples: >>> max_path_sum([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == 29 >>> max_path_sum([ ... [1000, 1000, 1000], ... [1000, 1000, 1000], ... [1000, 1000, 1000] ... ]) == 5000 pass def test_max_path_sum_basic(): grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert max_path_sum(grid) == 29 def test_max_path_sum_single_element(): grid = [ [5] ] assert max_path_sum(grid) == 5 def test_max_path_sum_two_by_two(): grid = [ [1, 2], [1, 1000] ] assert max_path_sum(grid) == 1003 def test_max_path_sum_all_zeros(): grid = [ [0, 0], [0, 0] ] assert max_path_sum(grid) == 0 def test_max_path_sum_large_grid(): grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] assert max_path_sum(grid) == 12 def test_max_path_sum_with_large_values(): grid = [ [1000, 1000, 1000], [1000, 1000, 1000], [1000, 1000, 1000] ] assert max_path_sum(grid) == 5000","solution":"def max_path_sum(grid): Returns the maximum possible sum from the top-left to the bottom-right of the grid. if not grid or not grid[0]: return 0 n = len(grid) # Create a dp array to store the maximum path sum up to each cell. dp = [[0] * n for _ in range(n)] dp[0][0] = grid[0][0] # Initialize the first row. for j in range(1, n): dp[0][j] = dp[0][j - 1] + grid[0][j] # Initialize the first column. for i in range(1, n): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill the rest of the dp array. for i in range(1, n): for j in range(1, n): dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] return dp[n - 1][n - 1]"},{"question":"def shortest_flower_bed_segment(n, k, t): Find the shortest contiguous subarray that contains all different types of flower beds. >>> shortest_flower_bed_segment(7, 3, [1, 2, 1, 3, 2, 1, 2]) (2, 4) >>> shortest_flower_bed_segment(5, 1, [1, 1, 1, 1, 1]) (1, 1) >>> shortest_flower_bed_segment(1, 1, [1]) (1, 1) >>> shortest_flower_bed_segment(10, 4, [1, 2, 3, 4, 1, 2, 3, 4, 1, 2]) (1, 4) >>> shortest_flower_bed_segment(9, 3, [2, 1, 2, 3, 2, 1, 3, 1, 2]) (2, 4) >>> shortest_flower_bed_segment(10, 3, [1, 2, 3, 1, 2, 3, 3, 2, 1, 2]) (1, 3) >>> t = [1, 2, 3, 4, 5] * 20000 >>> shortest_flower_bed_segment(100000, 5, t) (1, 5)","solution":"def shortest_flower_bed_segment(n, k, t): required_types = set(range(1, k+1)) found_types = {} min_length = float('inf') best_L, best_R = -1, -1 start = 0 for end in range(n): if t[end] in found_types: found_types[t[end]] += 1 else: found_types[t[end]] = 1 while len(found_types) == k: if end - start + 1 < min_length: min_length = end - start + 1 best_L, best_R = start + 1, end + 1 found_types[t[start]] -= 1 if found_types[t[start]] == 0: del found_types[t[start]] start += 1 return (best_L, best_R)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def count_univalued_subtrees(root: TreeNode) -> int: Returns the number of univalued subtrees in the given binary tree. >>> # Example tree: >>> # 5 >>> # / >>> # 1 5 >>> # / >>> # 5 5 5 >>> root = TreeNode(5) >>> root.left = TreeNode(1) >>> root.right = TreeNode(5) >>> root.left.left = TreeNode(5) >>> root.left.right = TreeNode(5) >>> root.right.right = TreeNode(5) >>> count_univalued_subtrees(root) 4 >>> # Single node tree >>> root = TreeNode(1) >>> count_univalued_subtrees(root) 1 >>> # All nodes with same value >>> # 1 >>> # / >>> # 1 1 >>> # / / >>> #1 1 1 1 >>> root = TreeNode(1) >>> root.left = TreeNode(1) >>> root.right = TreeNode(1) >>> root.left.left = TreeNode(1) >>> root.left.right = TreeNode(1) >>> root.right.left = TreeNode(1) >>> root.right.right = TreeNode(1) >>> count_univalued_subtrees(root) 7 >>> # No univalued subtree except leaves >>> # 2 >>> # / >>> # 1 3 >>> # / / >>> #4 5 6 >>> root = TreeNode(2) >>> root.left = TreeNode(1) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.right.left = TreeNode(5) >>> root.right.right = TreeNode(6) >>> count_univalued_subtrees(root) 3 >>> # Mixed values with both univalued and non-univalued subtrees >>> # 5 >>> # / >>> # 4 5 >>> # / >>> # 4 4 5 >>> # / >>> # 4 >>> root = TreeNode(5) >>> root.left = TreeNode(4) >>> root.right = TreeNode(5) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(4) >>> root.right.right = TreeNode(5) >>> root.left.left.left = TreeNode(4) >>> count_univalued_subtrees(root) 6","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def count_univalued_subtrees(root: TreeNode) -> int: def is_univalued_subtree(node, parent_value): if not node: return True left_is_univalued = is_univalued_subtree(node.left, node.val) right_is_univalued = is_univalued_subtree(node.right, node.val) if left_is_univalued and right_is_univalued: count_univalued_subtrees.count += 1 return node.val == parent_value return False count_univalued_subtrees.count = 0 is_univalued_subtree(root, root.val) return count_univalued_subtrees.count"},{"question":"def find_overstocked_items(n: int, q: int, item_list: List[tuple]) -> List[str]: Identifies and returns the item_ids of items whose quantity exceeds the threshold q. Parameters: n (int): Number of items. q (int): Threshold quantity. item_list (list): List of tuples where each tuple contains (item_id, quantity). Returns: list: The list of item_ids whose quantity exceeds q. Example: >>> find_overstocked_items(5, 100, [(\\"apple\\", 150), (\\"banana\\", 50), (\\"cherry\\", 200), (\\"date\\", 50), (\\"elderberry\\", 300)]) ['apple', 'cherry', 'elderberry'] >>> find_overstocked_items(3, 200, [(\\"orange\\", 100), (\\"pear\\", 150), (\\"pineapple\\", 200)]) [] pass # Unit Tests from solution import find_overstocked_items def test_find_overstocked_items_example_case(): n = 5 q = 100 item_list = [ (\\"apple\\", 150), (\\"banana\\", 50), (\\"cherry\\", 200), (\\"date\\", 50), (\\"elderberry\\", 300) ] result = find_overstocked_items(n, q, item_list) expected = [\\"apple\\", \\"cherry\\", \\"elderberry\\"] assert len(result) == 3 assert set(result) == set(expected) def test_find_overstocked_items_no_overstock(): n = 3 q = 200 item_list = [ (\\"orange\\", 100), (\\"pear\\", 150), (\\"pineapple\\", 200) ] result = find_overstocked_items(n, q, item_list) expected = [] assert len(result) == 0 assert result == expected def test_find_overstocked_items_all_overstock(): n = 3 q = 50 item_list = [ (\\"grape\\", 100), (\\"kiwi\\", 150), (\\"lemon\\", 200) ] result = find_overstocked_items(n, q, item_list) expected = [\\"grape\\", \\"kiwi\\", \\"lemon\\"] assert len(result) == 3 assert set(result) == set(expected) def test_find_overstocked_items_some_overstock(): n = 4 q = 100 item_list = [ (\\"mango\\", 100), (\\"nectarine\\", 110), (\\"orange\\", 120), (\\"papaya\\", 90) ] result = find_overstocked_items(n, q, item_list) expected = [\\"nectarine\\", \\"orange\\"] assert len(result) == 2 assert set(result) == set(expected)","solution":"def find_overstocked_items(n, q, item_list): Identifies and returns the item_ids of items whose quantity exceeds the threshold q. Parameters: n (int): Number of items. q (int): Threshold quantity. item_list (list of tuples): Each tuple contains (item_id, quantity). Returns: list: The list of item_ids whose quantity exceeds q. overstocked_items = [] for item_id, quantity in item_list: if quantity > q: overstocked_items.append(item_id) return overstocked_items"},{"question":"def longest_sequence_of_stations(m: int, d: int, stations: List[int]) -> int: Returns the length of the longest sequence of charging stations such that each consecutive station in the sequence is at least distance d apart. Args: m: int - the number of charging stations. d: int - the minimum required distance between consecutive stations. stations: list of int - the coordinates of the charging stations. Returns: int - the length of the longest sequence. pass # Example test cases def test_longest_sequence_example1(): assert longest_sequence_of_stations(6, 4, [1, 3, 5, 7, 9, 11]) == 3 def test_longest_sequence_min_distance_of_1(): assert longest_sequence_of_stations(5, 1, [0, 1, 2, 3, 4]) == 5 def test_longest_sequence_large_distance(): assert longest_sequence_of_stations(5, 10, [0, 1, 2, 3, 11]) == 2 def test_longest_sequence_exact_distance(): assert longest_sequence_of_stations(5, 3, [0, 3, 6, 9, 12]) == 5 def test_longest_sequence_unsorted_input(): assert longest_sequence_of_stations(6, 4, [5, 1, 9, 11, 3, 7]) == 3 def test_longest_sequence_edge_case_min_stations(): assert longest_sequence_of_stations(2, 5, [0, 6]) == 2 def test_longest_sequence_no_station_meets_min_distance(): assert longest_sequence_of_stations(6, 1000, [1, 2, 3, 4, 5, 6]) == 1","solution":"def longest_sequence_of_stations(m, d, stations): Returns the length of the longest sequence of charging stations such that each consecutive station in the sequence is at least distance d apart. Args: m: int - the number of charging stations. d: int - the minimum required distance between consecutive stations. stations: list of int - the coordinates of the charging stations. Returns: int - the length of the longest sequence. # Sort the list of stations to process them in order stations.sort() length = 1 # Start with the first station last_station = stations[0] for i in range(1, m): if stations[i] - last_station >= d: length += 1 last_station = stations[i] return length"},{"question":"def count_occurrences(sequence: List[int], queries: List[Tuple[int, int, int]]) -> List[int]: Returns the count of specific numbers in given subsequence ranges. :param sequence: List of integers containing the main sequence. :param queries: List of tuples, where each tuple contains (l, r, x). :return: List of counts corresponding to each query. >>> count_occurrences([1, 2, 1, 3, 2, 1], [(1, 3, 1), (4, 6, 2), (1, 6, 1)]) [2, 1, 3] >>> count_occurrences([1], [(1, 1, 1)]) [1] >>> count_occurrences([1, 2, 3, 4], [(1, 4, 5)]) [0] >>> count_occurrences([5, 4, 3, 2, 1, 5, 5, 5, 4, 3], [(1, 10, 5), (1, 5, 1), (6, 10, 5)]) [4, 1, 3] >>> count_occurrences([2], [(1, 1, 2), (1, 1, 2)]) [1, 1]","solution":"def count_occurrences(sequence, queries): Returns the count of specific numbers in given subsequence ranges. :param sequence: List of integers containing the main sequence. :param queries: List of tuples, where each tuple contains (l, r, x). :return: List of counts corresponding to each query. results = [] for l, r, x in queries: results.append(sum(1 for i in range(l-1, r) if sequence[i] == x)) return results"},{"question":"def rotate_right(arr, k): Rotates the array 'arr' to the right by 'k' steps. >>> rotate_right([1, 2, 3, 4, 5], 2) == [4, 5, 1, 2, 3] >>> rotate_right([10, 20, 30, 40], 1) == [40, 10, 20, 30] >>> rotate_right([7, 8, 9, 10, 11, 12], 3) == [10, 11, 12, 7, 8, 9] pass def process_test_cases(test_cases): Takes the test cases list and processes each test case. >>> test_cases = [ ... (5, 2, [1, 2, 3, 4, 5]), ... (4, 1, [10, 20, 30, 40]), ... (6, 3, [7, 8, 9, 10, 11, 12]), ...] >>> process_test_cases(test_cases) == [ ... [4, 5, 1, 2, 3], ... [40, 10, 20, 30], ... [10, 11, 12, 7, 8, 9], ...] pass","solution":"def rotate_right(arr, k): Rotates the array 'arr' to the right by 'k' steps. n = len(arr) k = k % n # In case k is greater than n return arr[-k:] + arr[:-k] def process_test_cases(test_cases): Takes the test cases list and processes each test case. results = [] for case in test_cases: n, k, arr = case rotated_array = rotate_right(arr, k) results.append(rotated_array) return results"},{"question":"class Book: def __init__(self, id, title, author, year): Initialize a Book object with id, title, author, and year. self.id = id self.title = title self.author = author self.year = year class Library: def __init__(self): Initialize a Library object with an empty collection of books. self.books = [] def add_book(self, book): Add a book to the library collection. pass def remove_book(self, book_id): Remove a book from the library collection by its id. pass def find_books_by_title(self, title): Find books in the collection by title. pass # Unit Tests def test_add_book(): library = Library() book1 = Book(1, \\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 1925) library.add_book(book1) assert library.books == [book1] book2 = Book(1, \\"To Kill a Mockingbird\\", \\"Harper Lee\\", 1960) library.add_book(book2) # same id, should not be added assert library.books == [book1] book3 = Book(2, \\"1984\\", \\"George Orwell\\", 1949) library.add_book(book3) assert library.books == [book1, book3] def test_remove_book(): library = Library() book1 = Book(1, \\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 1925) book2 = Book(2, \\"To Kill a Mockingbird\\", \\"Harper Lee\\", 1960) library.add_book(book1) library.add_book(book2) library.remove_book(1) assert library.books == [book2] library.remove_book(3) # non-existent id, should do nothing assert library.books == [book2] def test_find_books_by_title(): library = Library() book1 = Book(1, \\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 1925) book2 = Book(2, \\"To Kill a Mockingbird\\", \\"Harper Lee\\", 1960) book3 = Book(3, \\"1984\\", \\"George Orwell\\", 1949) library.add_book(book1) library.add_book(book2) library.add_book(book3) result = library.find_books_by_title(\\"the\\") assert result == [\\"1: The Great Gatsby by F. Scott Fitzgerald (1925)\\"] library.add_book(Book(4, \\"The Catcher in the Rye\\", \\"J.D. Salinger\\", 1951)) result = library.find_books_by_title(\\"the\\") assert result == [ \\"4: The Catcher in the Rye by J.D. Salinger (1951)\\", \\"1: The Great Gatsby by F. Scott Fitzgerald (1925)\\" ]","solution":"class Book: def __init__(self, id, title, author, year): self.id = id self.title = title self.author = author self.year = year def __repr__(self): return f\\"{self.id}: {self.title} by {self.author} ({self.year})\\" class Library: def __init__(self): self.books = [] def add_book(self, book): if all(b.id != book.id for b in self.books): self.books.append(book) def remove_book(self, book_id): self.books = [book for book in self.books if book.id != book_id] def find_books_by_title(self, title): result = [book for book in self.books if title.lower() in book.title.lower()] result.sort(key=lambda x: x.title) return [repr(book) for book in result]"},{"question":"def max_subarray_sum_of_special_sum_array(n, a, b): Calculate the maximum subarray sum of the special sum array s, where s_i = a_i * b_i for all i. Args: n (int): The number of elements in arrays a and b. a (list): An array of integers. b (list): An array of integers. Returns: int: The maximum sum of any subarray of the special sum array s. def test_example_case(): a = [1, 2, 3] b = [4, 5, 6] assert max_subarray_sum_of_special_sum_array(3, a, b) == 32 def test_single_element_positive(): a = [5] b = [3] assert max_subarray_sum_of_special_sum_array(1, a, b) == 15 def test_single_element_negative(): a = [-5] b = [3] assert max_subarray_sum_of_special_sum_array(1, a, b) == -15 def test_mixed_elements(): a = [1, -2, 3] b = [-1, 2, -3] # s = [-1, -4, -9] assert max_subarray_sum_of_special_sum_array(3, a, b) == -1 def test_all_negative_elements(): a = [-1, -2, -3, -4] b = [-1, -2, -3, -4] # s = [1, 4, 9, 16] # max subarray sum = sum of the entire array assert max_subarray_sum_of_special_sum_array(4, a, b) == 30 def test_large_input(): n = 100000 a = [1] * n b = [1] * n assert max_subarray_sum_of_special_sum_array(n, a, b) == 100000","solution":"def max_subarray_sum_of_special_sum_array(n, a, b): Calculate the maximum subarray sum of the special sum array s, where s_i = a_i * b_i for all i. Args: n (int): The number of elements in arrays a and b. a (list): An array of integers. b (list): An array of integers. Returns: int: The maximum sum of any subarray of the special sum array s. s = [a[i] * b[i] for i in range(n)] max_so_far = float('-inf') max_ending_here = 0 for i in range(n): max_ending_here = max_ending_here + s[i] if max_so_far < max_ending_here: max_so_far = max_ending_here if max_ending_here < 0: max_ending_here = 0 return max_so_far"},{"question":"from typing import List, Tuple def max_non_overlapping_events(test_cases: List[List[Tuple[int, int]]]) -> List[int]: Determine the maximum number of non-overlapping events for each test case. Each test case consists of a list of tuples where each tuple represents start and end time of an event. Examples: >>> max_non_overlapping_events([[(1, 2), (2, 3), (3, 4)], [(1, 3), (2, 4), (3, 5), (4, 6)]]) [3, 2] >>> max_non_overlapping_events([[(1, 3), (2, 4), (3, 5), (6, 8), (5, 7)]]) [3] def parse_input(input_str: str) -> List[List[Tuple[int, int]]]: Parse the input string and convert it to the list of test cases where each test case is a list of tuples. Each tuple represents start and end time of an event. import pytest def test_example_case_1(): input_str = \\"2n3n1 2n2 3n3 4n4n1 3n2 4n3 5n4 6n\\" test_cases = parse_input(input_str) assert max_non_overlapping_events(test_cases) == [3, 2] def test_single_event(): input_str = \\"1n1n1 2n\\" test_cases = parse_input(input_str) assert max_non_overlapping_events(test_cases) == [1] def test_no_overlap_events(): input_str = \\"1n3n1 2n3 4n5 6n\\" test_cases = parse_input(input_str) assert max_non_overlapping_events(test_cases) == [3] def test_all_overlap_events(): input_str = \\"1n3n1 5n2 6n3 7n\\" test_cases = parse_input(input_str) assert max_non_overlapping_events(test_cases) == [1] def test_mixed_overlap_and_non_overlap(): input_str = \\"1n5n1 3n2 4n3 5n6 8n5 7n\\" test_cases = parse_input(input_str) assert max_non_overlapping_events(test_cases) == [3] pytest.main()","solution":"def max_non_overlapping_events(test_cases): results = [] for events in test_cases: # Sort events based on the end time events.sort(key=lambda x: x[1]) max_events = count = 0 end_time = 0 for start, end in events: if start >= end_time: end_time = end max_events += 1 results.append(max_events) return results def parse_input(input_str): lines = input_str.split('n') t = int(lines[0].strip()) idx = 1 test_cases = [] for _ in range(t): n = int(lines[idx].strip()) idx += 1 events = [] for _ in range(n): start, end = map(int, lines[idx].strip().split()) events.append((start, end)) idx += 1 test_cases.append(events) return test_cases"},{"question":"def alice_total_sum(n: int, positions: List[int]) -> int: Determine the total sum of positions picked by Alice if both play optimally. Alice and Bob are playing a game on a 1-D number line. They're given a sequence of distinct integers representing positions on the number line. They take turns picking positions, with Alice going first. Alice wants the sum of her picked positions to be as high as possible, while Bob wants to minimize her total sum. Once a position is picked, it cannot be chosen again. Alice can either pick the position with the highest value or the lowest value on the number line during her turn. On Bob's turn, he removes either the highest or the lowest remaining value from the number line. They continue this until all positions are picked or removed, and Alice keeps the positions she picks during her turns. Args: n (int): The number of positions available initially. positions (List[int]): The initial positions. Returns: int: The total sum of positions picked by Alice. Example: >>> alice_total_sum(6, [3, -1, 4, -4, 2, 6]) 13 >>> alice_total_sum(3, [1, 5, 3]) 8 from solution import alice_total_sum def test_alice_total_sum_single_element(): assert alice_total_sum(1, [5]) == 5 def test_alice_total_sum_even_elements(): assert alice_total_sum(6, [3, -1, 4, -4, 2, 6]) == 13 def test_alice_total_sum_odd_elements(): assert alice_total_sum(3, [1, 5, 3]) == 8 def test_alice_total_sum_all_negative(): assert alice_total_sum(5, [-3, -7, -9, -1, -5]) == -9 def test_alice_total_sum_mixed_numbers(): assert alice_total_sum(7, [10, -10, 8, -8, 6, -6, 4]) == 28 def test_alice_total_sum_large_numbers(): assert alice_total_sum(4, [1000000000, -1000000000, 500000000, -500000000]) == 1500000000 def test_alice_total_sum_large_list(): import random positions = random.sample(range(-10**9, 10**9), 200000) result = alice_total_sum(200000, positions) assert isinstance(result, int) # just to check function returns an integer","solution":"def alice_total_sum(n, positions): positions.sort() # Sort the positions for ease of simulation alice_sum = 0 alice_turn = True while positions: if alice_turn: # Alice's turn: she picks the maximum of the remaining positions alice_sum += positions.pop() # always take the highest value else: # Bob's turn: he removes the minimum of the remaining positions positions.pop(0) # always remove the lowest value alice_turn = not alice_turn # alternate turns return alice_sum"},{"question":"def can_find_increasing_subsequence(n, k, array): This function checks if there exists a strictly increasing subsequence of length k in the given array of n integers. :param n: Length of the array :param k: Length of the subsequence to find :param array: List of integers :return: \\"Yes\\" if such a subsequence exists, otherwise \\"No\\" def test_example_1(): assert can_find_increasing_subsequence(5, 3, [2, 1, 3, 2, 4]) == \\"Yes\\" def test_example_2(): assert can_find_increasing_subsequence(5, 4, [3, 2, 1, 5, 4]) == \\"No\\" def test_small_array_yes(): assert can_find_increasing_subsequence(3, 3, [1, 2, 3]) == \\"Yes\\" def test_small_array_no(): assert can_find_increasing_subsequence(3, 4, [1, 2, 3]) == \\"No\\" def test_large_array_yes(): assert can_find_increasing_subsequence(10, 5, [3, 10, 2, 1, 20, 4, 6, 8, 7, 30]) == \\"Yes\\" def test_large_array_no(): assert can_find_increasing_subsequence(10, 6, [5, 4, 3, 2, 1, 1, 2, 3, 4, 5]) == \\"No\\"","solution":"def can_find_increasing_subsequence(n, k, array): This function checks if there exists a strictly increasing subsequence of length k in the given array of n integers. :param n: Length of the array :param k: Length of the subsequence to find :param array: List of integers :return: \\"Yes\\" if such a subsequence exists, otherwise \\"No\\" if k > n: return \\"No\\" # Function to find the length of longest increasing subsequence def longest_increasing_subsequence_length(arr): from bisect import bisect_left lis = [] for num in arr: pos = bisect_left(lis, num) if pos == len(lis): lis.append(num) else: lis[pos] = num return len(lis) return \\"Yes\\" if longest_increasing_subsequence_length(array) >= k else \\"No\\""},{"question":"def shortest_path(n, m, friendships, q, queries): Determine the shortest path between pairs of users in a social network. Each user can view posts from friends in their network. The network structure is represented as an undirected graph where each node represents a user and an edge between two nodes indicates a friendship. The input format is as follows: - n: int, number of users - m: int, number of friendships - friendships: List of tuples, each containing two integers representing a friendship between users. - q: int, number of queries - queries: List of tuples, each containing two integers representing the users for which to find the shortest path. The output format should be a list of integers, each containing the shortest path between the corresponding pair of users in the query. If there is no path between the users, the output should be -1 for that query. Example: >>> n, m = 5, 4 >>> friendships = [(1, 2), (2, 3), (3, 4), (4, 5)] >>> q = 3 >>> queries = [(1, 5), (2, 4), (3, 1)] >>> shortest_path(n, m, friendships, q, queries) [4, 2, 2] >>> n, m = 6, 2 >>> friendships = [(1, 2), (3, 4)] >>> q = 2 >>> queries = [(1, 3), (2, 6)] >>> shortest_path(n, m, friendships, q, queries) [-1, -1] >>> n, m = 4, 3 >>> friendships = [(1, 2), (2, 3), (3, 4)] >>> q = 2 >>> queries = [(1, 1), (4, 4)] >>> shortest_path(n, m, friendships, q, queries) [0, 0] >>> n, m = 4, 2 >>> friendships = [(1, 2), (3, 4)] >>> q = 2 >>> queries = [(1, 2), (3, 4)] >>> shortest_path(n, m, friendships, q, queries) [1, 1] >>> n, m = 6, 3 >>> friendships = [(1, 2), (1, 3), (4, 5)] >>> q = 3 >>> queries = [(1, 3), (1, 5), (4, 6)] >>> shortest_path(n, m, friendships, q, queries) [1, -1, -1]","solution":"from collections import deque def shortest_path(n, m, friendships, q, queries): # Adjacency list for the graph adj_list = [[] for _ in range(n+1)] for u, v in friendships: adj_list[u].append(v) adj_list[v].append(u) def bfs(start, end): # BFS to find the shortest path if start == end: return 0 visited = [False] * (n + 1) dist = [0] * (n + 1) queue = deque([start]) visited[start] = True while queue: node = queue.popleft() for neighbor in adj_list[node]: if not visited[neighbor]: visited[neighbor] = True dist[neighbor] = dist[node] + 1 queue.append(neighbor) if neighbor == end: return dist[neighbor] return -1 results = [] for a, b in queries: results.append(bfs(a, b)) return results"},{"question":"from typing import List def max_mountain_length(arr: List[int], queries: List[int]) -> List[int]: Given a sequence of integers, find the maximum length of subarray which is a mountain array and contains the index specified in the query. >>> max_mountain_length([2, 1, 4, 7, 3, 2, 5], [1, 4, 7]) [1, 5, 1] >>> max_mountain_length([1, 1, 1, 1, 1], [1, 2, 3, 4, 5]) [1, 1, 1, 1, 1] >>> max_mountain_length([1, 2], [1, 2]) [1, 1] >>> max_mountain_length([1, 3, 2, 4, 3, 2, 1], [2, 4]) [3, 5] >>> max_mountain_length([10, 9, 8, 7, 6, 10], [1, 6]) [1, 1] >>> max_mountain_length([1, 3, 2, 4, 3, 2, 1], []) []","solution":"def max_mountain_length(arr, queries): n = len(arr) if n < 3: return [1] * len(queries) # No mountain array possible if less than 3 elements left = [1] * n right = [1] * n # Fill left array for i in range(1, n): if arr[i] > arr[i-1]: left[i] = left[i-1] + 1 # Fill right array for i in range(n-2, -1, -1): if arr[i] > arr[i+1]: right[i] = right[i+1] + 1 result = [] for q in queries: k = q - 1 # to make it zero-indexed if left[k] > 1 and right[k] > 1: max_len = left[k] + right[k] - 1 else: max_len = 1 result.append(max_len) return result"},{"question":"from typing import List def max_contiguous_subarray_length(arr: List[int]) -> int: Returns the length of the longest contiguous subarray with the same integer. >>> max_contiguous_subarray_length([1, 2, 2, 2, 3, 3, 1, 1, 1, 1]) 4 >>> max_contiguous_subarray_length([4, 4, 4, 4, 4, 4, 4, 4, 4, 4]) 10 >>> max_contiguous_subarray_length([1, 2, 3, 4, 5]) 1 >>> max_contiguous_subarray_length([3, 3, 3, 2, 2, 1]) 3 def test_max_contiguous_subarray_length(): assert max_contiguous_subarray_length([1, 2, 2, 2, 3, 3, 1, 1, 1, 1]) == 4 assert max_contiguous_subarray_length([4, 4, 4, 4, 4, 4, 4, 4, 4, 4]) == 10 assert max_contiguous_subarray_length([1, 2, 3, 4, 5]) == 1 assert max_contiguous_subarray_length([3, 3, 3, 2, 2, 1]) == 3 assert max_contiguous_subarray_length([1]) == 1 assert max_contiguous_subarray_length([]) == 0 assert max_contiguous_subarray_length([1, 1, 1, 1, 2, 2, 2, 2, 2, 1, 1]) == 5 assert max_contiguous_subarray_length([1, 3, 3, 3, 2, 2, 2, 2, 5, 5, 1, 1]) == 4 assert max_contiguous_subarray_length([-1, -1, -2, -2, -2, -2, -3, 0, 0, 0, 0, 0]) == 5 assert max_contiguous_subarray_length([1000000000, 1000000000, -1000000000, -1000000000, -1000000000]) == 3","solution":"def max_contiguous_subarray_length(arr): Returns the length of the longest contiguous subarray with the same integer. if not arr: return 0 max_length = 1 current_length = 1 for i in range(1, len(arr)): if arr[i] == arr[i - 1]: current_length += 1 else: if current_length > max_length: max_length = current_length current_length = 1 if current_length > max_length: max_length = current_length return max_length"},{"question":"def two_sum(nums, target): Returns indices of the two numbers such that they add up to the given target. Args: nums: List of integers. target: The target sum integer. Returns: A tuple of two integers representing indices of the two numbers. pass from solution import two_sum def test_two_sum_example_1(): nums = [2, 7, 11, 15] target = 9 result = two_sum(nums, target) assert result == (0, 1) def test_two_sum_example_2(): nums = [3, 2, 4] target = 6 result = two_sum(nums, target) assert result == (1, 2) def test_two_sum_example_3(): nums = [3, 3] target = 6 result = two_sum(nums, target) assert result == (0, 1) def test_two_sum_negative_numbers(): nums = [-1, -2, -3, -4, -5] target = -8 result = two_sum(nums, target) assert result == (2, 4) def test_two_sum_mixed_sign_numbers(): nums = [-1, 2, 3, -4, 5] target = 1 result = two_sum(nums, target) assert result == (0, 1) or result == (2, 3)","solution":"def two_sum(nums, target): Returns indices of the two numbers such that they add up to the given target. Args: nums: List of integers. target: The target sum integer. Returns: A tuple of two integers representing indices of the two numbers. seen = {} for i, num in enumerate(nums): complement = target - num if complement in seen: return (seen[complement], i) seen[num] = i"},{"question":"from typing import List def max_apples_collected(apples: List[int], n: int, k: int) -> int: Find the maximum number of apples you can collect in one go by walking in a contiguous segment of trees. >>> max_apples_collected([3, 1, 2, 1, 2], 5, 4) 4 >>> max_apples_collected([10, 5, 5, 10, 1], 5, 10) 10 def test_example_cases(): assert max_apples_collected([3, 1, 2, 1, 2], 5, 4) == 4 assert max_apples_collected([10, 5, 5, 10, 1], 5, 10) == 10 def test_single_tree(): assert max_apples_collected([5], 1, 5) == 5 assert max_apples_collected([10], 1, 5) == 0 def test_all_apples_within_capacity(): assert max_apples_collected([2, 3, 1, 2], 4, 10) == 8 assert max_apples_collected([1, 1, 1, 1], 4, 4) == 4 def test_no_valid_segment(): assert max_apples_collected([10, 20, 30], 3, 5) == 0 def test_partial_collected_segments(): assert max_apples_collected([4, 3, 2, 4, 3], 5, 7) == 7 assert max_apples_collected([8, 1, 2, 3, 4, 1], 6, 6) == 6 def test_large_input(): apples = [1] * 100000 assert max_apples_collected(apples, 100000, 50000) == 50000 def test_fluctuating_segments(): assert max_apples_collected([1, 2, 3, 4, 5, 1, 2, 3], 8, 7) == 7 assert max_apples_collected([1, 2, 2, 2, 2, 2, 1], 7, 6) == 6","solution":"from typing import List def max_apples_collected(apples: List[int], n: int, k: int) -> int: max_apples = 0 current_sum = 0 start = 0 for end in range(n): current_sum += apples[end] while current_sum > k and start <= end: current_sum -= apples[start] start += 1 max_apples = max(max_apples, current_sum) return max_apples"},{"question":"def can_become_strictly_increasing(n, sequence): Determines if the sequence can be made strictly increasing by removing at most one element. :param n: Integer, the number of elements in the sequence. :param sequence: List of n integers, the sequence of numbers. :return: \\"YES\\" if it is possible to reorder the sequence into a strictly increasing sequence by removing at most one element, otherwise \\"NO\\". >>> can_become_strictly_increasing(5, [1, 3, 2, 4, 5]) == \\"YES\\" >>> can_become_strictly_increasing(5, [5, 4, 3, 2, 1]) == \\"NO\\" >>> can_become_strictly_increasing(3, [1, 2, 3]) == \\"YES\\" >>> can_become_strictly_increasing(4, [1, 2, 2, 3]) == \\"YES\\" >>> can_become_strictly_increasing(4, [1, 3, 2, 2]) == \\"NO\\" >>> can_become_strictly_increasing(1, [10]) == \\"YES\\" >>> can_become_strictly_increasing(6, [1, 3, 5, 7, 6, 8]) == \\"YES\\" >>> can_become_strictly_increasing(2, [1, 1]) == \\"YES\\"","solution":"def can_become_strictly_increasing(n, sequence): Determines if the sequence can be made strictly increasing by removing at most one element. :param n: Integer, the number of elements in the sequence. :param sequence: List of n integers, the sequence of numbers. :return: \\"YES\\" if it is possible to reorder the sequence into a strictly increasing sequence by removing at most one element, otherwise \\"NO\\". def is_strictly_increasing(seq): Helper function to check if a sequence is strictly increasing. for i in range(1, len(seq)): if seq[i] <= seq[i-1]: return False return True # If sequence is already strictly increasing if is_strictly_increasing(sequence): return \\"YES\\" # Try removing each element one by one and check if the remaining sequence is strictly increasing for i in range(n): if is_strictly_increasing(sequence[:i] + sequence[i+1:]): return \\"YES\\" return \\"NO\\""},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def build_tree(nodes): tree_nodes = [None] * len(nodes) for i in range(len(nodes)): tree_nodes[i] = TreeNode(nodes[i][0]) for i in range(len(nodes)): if nodes[i][1] != -1: tree_nodes[i].left = tree_nodes[nodes[i][1] - 1] if nodes[i][2] != -1: tree_nodes[i].right = tree_nodes[nodes[i][2] - 1] return tree_nodes[0] def max_subtree_sum(root): def subtree_sum(node): if node is None: return 0 left_sum = subtree_sum(node.left) right_sum = subtree_sum(node.right) total_sum = node.value + left_sum + right_sum max_sum[0] = max(max_sum[0], total_sum) return total_sum max_sum = [-float('inf')] subtree_sum(root) return max_sum[0] def find_largest_subtree_sum(n, node_values): Finds the largest sum of a subtree in a binary tree. Parameters: n (int): The number of nodes in the tree. node_values (List[Tuple[int, int, int]]): List of tuples where each tuple contains the value of the node, the index of left child (or -1 if there is none), and the index of right child (or -1 if there is none). Returns: int: The largest sum of any subtree within the binary tree. Example: >>> n = 5 >>> nodes = [ ... (1, 2, 3), ... (2, -1, -1), ... (3, 4, -1), ... (4, -1, 5), ... (5, -1, -1) ... ] >>> find_largest_subtree_sum(n, nodes) 15 root = build_tree(node_values) return max_subtree_sum(root)","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def build_tree(nodes): tree_nodes = [None] * len(nodes) for i in range(len(nodes)): tree_nodes[i] = TreeNode(nodes[i][0]) for i in range(len(nodes)): if nodes[i][1] != -1: tree_nodes[i].left = tree_nodes[nodes[i][1] - 1] if nodes[i][2] != -1: tree_nodes[i].right = tree_nodes[nodes[i][2] - 1] return tree_nodes[0] def max_subtree_sum(root): def subtree_sum(node): if node is None: return 0 left_sum = subtree_sum(node.left) right_sum = subtree_sum(node.right) total_sum = node.value + left_sum + right_sum max_sum[0] = max(max_sum[0], total_sum) return total_sum max_sum = [-float('inf')] subtree_sum(root) return max_sum[0] def find_largest_subtree_sum(n, node_values): root = build_tree(node_values) return max_subtree_sum(root)"},{"question":"def find_min_diff_indices(n: int, a: List[int]) -> Tuple[int, int]: Find two indices i and j such that the absolute difference between a[i] and a[j] is minimized. >>> find_min_diff_indices(6, [1, 3, 4, 8, 13, 17]) (2, 3) >>> find_min_diff_indices(5, [5, 2, 8, 4, 1]) (1, 4) # Unit tests def test_example_1(): n = 6 a = [1, 3, 4, 8, 13, 17] assert find_min_diff_indices(n, a) == (2, 3) def test_example_2(): n = 5 a = [5, 2, 8, 4, 1] assert find_min_diff_indices(n, a) == (1, 4) def test_small_array(): n = 2 a = [1000000000, 1] assert find_min_diff_indices(n, a) == (1, 2) def test_repeated_elements(): n = 4 a = [1, 1, 1, 1] assert find_min_diff_indices(n, a) == (1, 2) def test_large_range(): n = 3 a = [1, 500000000, 1000000000] assert find_min_diff_indices(n, a) == (1, 2) def test_already_sorted(): n = 5 a = [1, 2, 3, 4, 5] assert find_min_diff_indices(n, a) == (1, 2)","solution":"def find_min_diff_indices(n, a): indexed_a = sorted((val, idx) for idx, val in enumerate(a)) min_diff = float('inf') min_i, min_j = -1, -1 for k in range(1, n): curr_diff = abs(indexed_a[k][0] - indexed_a[k-1][0]) if curr_diff < min_diff: min_diff = curr_diff min_i = min(indexed_a[k][1], indexed_a[k-1][1]) min_j = max(indexed_a[k][1], indexed_a[k-1][1]) elif curr_diff == min_diff: if min(indexed_a[k][1], indexed_a[k-1][1]) < min_i: min_i = min(indexed_a[k][1], indexed_a[k-1][1]) min_j = max(indexed_a[k][1], indexed_a[k-1][1]) elif min(indexed_a[k][1], indexed_a[k-1][1]) == min_i: min_j = min(max(indexed_a[k][1], indexed_a[k-1][1]), min_j) return (min_i + 1, min_j + 1) # Example usage: # n = 6 # a = [1, 3, 4, 8, 13, 17] # print(find_min_diff_indices(n, a)) # Output: (2, 3)"},{"question":"def process_queries(strings, queries): Process the given queries to check for palindromic substrings. :param strings: List of strings to be checked. :param queries: List of tuple queries (i, l, r) where i is the index of the string, l is the starting index, and r is the ending index (1-based index). :return: List of results for each query, \\"yes\\" if the substring is a palindrome, otherwise \\"no\\". >>> process_queries([\\"abcba\\", \\"abccba\\", \\"abcd\\"], [(1, 1, 5), (2, 1, 6), (3, 1, 4), (1, 2, 4)]) ['yes', 'yes', 'no', 'no'] pass # Unit tests def test_process_queries(): strings = [\\"abcba\\", \\"abccba\\", \\"abcd\\"] queries = [ (1, 1, 5), # \\"abcba\\" -> yes (2, 1, 6), # \\"abccba\\" -> yes (3, 1, 4), # \\"abcd\\" -> no (1, 2, 4) # \\"bcb\\" -> yes ] expected = [\\"yes\\", \\"yes\\", \\"no\\", \\"yes\\"] assert process_queries(strings, queries) == expected def test_process_queries_single_string(): strings = [\\"a\\"] queries = [ (1, 1, 1) # \\"a\\" -> yes ] expected = [\\"yes\\"] assert process_queries(strings, queries) == expected def test_process_queries_non_palindromes(): strings = [\\"abcdef\\", \\"ghijkl\\"] queries = [ (1, 1, 3), # \\"abc\\" -> no (2, 2, 4) # \\"hij\\" -> no ] expected = [\\"no\\", \\"no\\"] assert process_queries(strings, queries) == expected def test_process_queries_palindromes(): strings = [\\"madam\\", \\"racecar\\"] queries = [ (1, 1, 5), # \\"madam\\" -> yes (2, 1, 7) # \\"racecar\\" -> yes ] expected = [\\"yes\\", \\"yes\\"] assert process_queries(strings, queries) == expected def test_process_queries_mixed(): strings = [\\"level\\", \\"noon\\", \\"palindrome\\"] queries = [ (1, 1, 5), # \\"level\\" -> yes (2, 1, 4), # \\"noon\\" -> yes (3, 1, 5), # \\"palin\\" -> no (3, 2, 7) # \\"alindr\\" -> no ] expected = [\\"yes\\", \\"yes\\", \\"no\\", \\"no\\"] assert process_queries(strings, queries) == expected","solution":"def is_palindrome(s): return s == s[::-1] def process_queries(strings, queries): results = [] for i, l, r in queries: substring = strings[i-1][l-1:r] if is_palindrome(substring): results.append(\\"yes\\") else: results.append(\\"no\\") return results"},{"question":"from typing import List, Tuple def maximize_harmony(n: int, preferences: List[Tuple[int, ...]]) -> Tuple[int, List[int]]: Aria enjoys organizing events and planning seating arrangements. She is organizing a round table event where people will be seated around a circular table, all facing the center. Aria wants to carefully assign seats to ensure maximum harmony among the guests, considering their preferences. Each guest has a list of other guests they prefer to sit next to. The goal is to arrange the guests in such a way that the total number of neighboring preferences is maximized. Two guests are considered neighbors if they are seated directly next to each other. Given n guests, and a list of their preferences, determine the seating arrangement that maximizes the number of satisfied neighboring preferences. Output the maximum number of satisfied preferences and the seating arrangement. If there are multiple arrangements with the same number of satisfied preferences, you can output any one of them. Parameters: n (int): Number of guests. preferences (List[Tuple[int, ...]]): List of preferences for each guest. Returns: Tuple[int, List[int]]: Maximum number of satisfied preferences and the seating arrangement. >>> maximize_harmony(4, [(2, 2, 3), (1, 1), (1, 4), (1, 1)]) (3, [1, 2, 3, 4]) >>> maximize_harmony(3, [(0,), (0,), (0,)]) (0, [1, 2, 3])","solution":"from itertools import permutations def count_preferences(seating, preferences): count = 0 n = len(seating) for i in range(n): left = seating[i] right = seating[(i + 1) % n] if right in preferences[left]: count += 1 if left in preferences[right]: count += 1 return count def maximize_harmony(n, preferences): prefs = [[] for _ in range(n)] for i in range(n): mi, *prefs_list = preferences[i] for pref in prefs_list: prefs[i].append(pref-1) max_pref_count = -1 best_seating = [] for perm in permutations(range(n)): current_count = count_preferences(perm, prefs) if current_count > max_pref_count: max_pref_count = current_count best_seating = perm best_seating = [x + 1 for x in best_seating] return max_pref_count, best_seating print(maximize_harmony(4, [(2, 2, 3), (1, 1), (1, 4), (1, 1)]))"},{"question":"def max_sum_of_subarray(n: int, k: int, nums: List[int]) -> int: Find the maximum sum of a continuous subarray of length k. Args: n (int): The length of the array. k (int): The length of the subarray. nums (List[int]): The list of integers. Returns: int: The maximum sum of a continuous subarray of length k. >>> max_sum_of_subarray(5, 2, [1, 5, 2, 3, 7]) 10 >>> max_sum_of_subarray(7, 3, [4, 5, 3, 2, 1, 8, 9]) 18 pass def process_test_cases(test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Process multiple test cases to find the maximum sum of a continuous subarray of length k. Args: test_cases (List[Tuple[int, int, List[int]]]): A list of test cases, where each test case is a tuple (n, k, nums). Returns: List[int]: A list of results for each test case. >>> test_cases = [(5, 2, [1, 5, 2, 3, 7]), (7, 3, [4, 5, 3, 2, 1, 8, 9])] >>> process_test_cases(test_cases) [10, 18] pass","solution":"def max_sum_of_subarray(n, k, nums): current_sum = sum(nums[:k]) max_sum = current_sum for i in range(k, n): current_sum = current_sum + nums[i] - nums[i - k] if current_sum > max_sum: max_sum = current_sum return max_sum def process_test_cases(test_cases): results = [] for test in test_cases: n, k, nums = test results.append(max_sum_of_subarray(n, k, nums)) return results"},{"question":"def rank_participants(n: int, m: int, participants: List[Tuple[str, int]]) -> List[str]: Returns the names of the participants sorted based on their total scores and lexicographically. Arguments: n : int : number of participants m : int : number of contests participants : list of tuples : each tuple contains a participant's name followed by their scores in each contest Returns: list[str] : names of the participants in ascending order of their ranks >>> rank_participants(4, 3, [(\\"Alice\\", 50, 60, 70), (\\"Bob\\", 60, 60, 60), (\\"Charlie\\", 70, 60, 50), (\\"Dave\\", 80, 60, 40)]) [\\"Alice\\", \\"Bob\\", \\"Charlie\\", \\"Dave\\"] >>> rank_participants(3, 2, [(\\"Alice\\", 90, 80), (\\"Bob\\", 80, 90), (\\"Charlie\\", 85, 85)]) [\\"Alice\\", \\"Bob\\", \\"Charlie\\"] >>> rank_participants(2, 3, [(\\"Alice\\", 50, 50, 50), (\\"Bob\\", 50, 50, 50)]) [\\"Alice\\", \\"Bob\\"] >>> rank_participants(1, 4, [(\\"Alice\\", 60, 70, 80, 90)]) [\\"Alice\\"] >>> rank_participants(5, 1, [(\\"Eve\\", 100), (\\"Charlie\\", 90), (\\"Alice\\", 80), (\\"Bob\\", 70), (\\"Dave\\", 60)]) [\\"Eve\\", \\"Charlie\\", \\"Alice\\", \\"Bob\\", \\"Dave\\"]","solution":"def rank_participants(n, m, participants): Returns the names of the participants sorted based on their total scores and lexicographically. n : int : number of participants m : int : number of contests participants : list of tuples : each tuple contains a participant's name followed by their scores in each contest # Calculate total scores for each participant results = [] for participant in participants: name, scores = participant[0], participant[1:] total_score = sum(scores) results.append((total_score, name)) # Sort results by total score in descending order and lexicographically by name results.sort(key=lambda x: (-x[0], x[1])) # Extract ordered names ordered_names = [name for total_score, name in results] return ordered_names"},{"question":"import heapq from typing import List class PatientManagementSystem: def __init__(self): self.patient_heap = [] self.counter = 0 def admit(self, name: str, severity: int): heapq.heappush(self.patient_heap, (-severity, self.counter, name)) self.counter += 1 def discharge(self): if self.patient_heap: _, _, name = heapq.heappop(self.patient_heap) return name return None def manage_patients(operations: List[str]) -> List[str]: Manage patient admission and discharge in an emergency room based on severity level. Parameters: operations (List[str]): List of operations where each operation is either \\"admit <name> <severity>\\" or \\"discharge\\". Returns: List[str]: List of names of patients discharged based on their severity level. Examples: >>> manage_patients([ ... \\"admit John 5\\", ... \\"admit Mary 3\\", ... \\"admit Lucy 9\\", ... \\"admit Mark 4\\", ... \\"discharge\\", ... \\"admit Dave 6\\", ... \\"discharge\\" ... ]) ['Lucy', 'Dave'] >>> manage_patients([ ... \\"admit John 5\\", ... \\"admit Mary 5\\", ... \\"admit Lucy 5\\", ... \\"discharge\\", ... \\"discharge\\", ... \\"discharge\\" ... ]) ['John', 'Mary', 'Lucy'] >>> manage_patients([\\"discharge\\"]) [] >>> manage_patients([ ... \\"admit John 5\\", ... \\"admit Mary 3\\", ... \\"admit Lucy 9\\", ... \\"admit Mark 4\\", ... \\"discharge\\", ... \\"discharge\\", ... \\"discharge\\", ... \\"discharge\\" ... ]) ['Lucy', 'John', 'Mark', 'Mary'] >>> manage_patients([]) []","solution":"import heapq class PatientManagementSystem: def __init__(self): self.patient_heap = [] self.counter = 0 def admit(self, name, severity): # Use negative severity to simulate a max-heap heapq.heappush(self.patient_heap, (-severity, self.counter, name)) self.counter += 1 def discharge(self): if self.patient_heap: _, _, name = heapq.heappop(self.patient_heap) return name return None def manage_patients(operations): pms = PatientManagementSystem() result = [] for operation in operations: if operation.startswith(\\"admit\\"): _, name, severity = operation.split() pms.admit(name, int(severity)) elif operation == \\"discharge\\": discharged_patient = pms.discharge() if discharged_patient is not None: result.append(discharged_patient) return result"},{"question":"def max_area_of_agricultural_segment(grid): Given a grid of 1s and 0s, calculates the area of the largest subgrid containing only 1s. >>> max_area_of_agricultural_segment([ [1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [0, 0, 0, 1, 0] ]) == 6 >>> max_area_of_agricultural_segment([ [0, 0, 0], [0, 0, 0], [0, 0, 0] ]) == 0 >>> max_area_of_agricultural_segment([ [1, 1, 1], [1, 1, 1], [1, 1, 1] ]) == 9 import pytest from solution import max_area_of_agricultural_segment def test_max_area_example(): grid = [ [1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [0, 0, 0, 1, 0] ] assert max_area_of_agricultural_segment(grid) == 6 def test_max_area_all_zero(): grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert max_area_of_agricultural_segment(grid) == 0 def test_max_area_all_one(): grid = [ [1, 1, 1], [1, 1, 1], [1, 1, 1] ] assert max_area_of_agricultural_segment(grid) == 9 def test_max_area_single_row(): grid = [ [1, 1, 0, 1] ] assert max_area_of_agricultural_segment(grid) == 2 def test_max_area_single_column(): grid = [ [1], [1], [0], [1] ] assert max_area_of_agricultural_segment(grid) == 2 def test_max_area_no_ones(): grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert max_area_of_agricultural_segment(grid) == 0 def test_max_area_l_shaped(): grid = [ [0, 1, 1, 0], [1, 1, 0, 0], [1, 1, 1, 1] ] assert max_area_of_agricultural_segment(grid) == 4 if __name__ == \\"__main__\\": pytest.main()","solution":"def max_area_of_agricultural_segment(grid): Given a grid of 1s and 0s, calculates the area of the largest subgrid containing only 1s. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] max_area = 0 for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = (dp[i][j-1] + 1) if j > 0 else 1 width = dp[i][j] for k in range(i, -1, -1): width = min(width, dp[k][j]) if width == 0: break max_area = max(max_area, width * (i - k + 1)) return max_area"},{"question":"from typing import List, Tuple def calculate_points_and_rank(m: int, n: int, races: List[Tuple[int, int, int]], queries: List[int]) -> List[Tuple[int, int]]: Calculate the total points and rank of a racer after all races have been completed. Args: m (int): The number of races. n (int): The number of racers. races (List[Tuple[int, int, int]]): The results of each race. queries (List[int]): The list of racer IDs to query. Returns: List[Tuple[int, int]]: A list of tuples representing the total points and rank of each queried racer. >>> m = 3 >>> n = 5 >>> races = [(1, 2, 3), (1, 3, 5), (2, 3, 4)] >>> queries = [1, 3] >>> calculate_points_and_rank(m, n, races, queries) [(20, 1), (12, 3)] >>> m = 2 >>> n = 4 >>> races = [(1, 2, 3), (1, 2, 3)] >>> queries = [1, 2, 3, 4] >>> calculate_points_and_rank(m, n, races, queries) [(20, 1), (10, 2), (4, 3), (0, 4)] >>> m = 1 >>> n = 3 >>> races = [(2, 3, 1)] >>> queries = [1, 2, 3] >>> calculate_points_and_rank(m, n, races, queries) [(2, 3), (10, 1), (5, 2)] >>> m = 3 >>> n = 5 >>> races = [(1, 2, 3), (1, 2, 3), (1, 2, 3)] >>> queries = [4, 5] >>> calculate_points_and_rank(m, n, races, queries) [(0, 4), (0, 5)]","solution":"def calculate_points_and_rank(m, n, races, queries): # Initialize points dictionary points = {i: 0 for i in range(1, n + 1)} # Score values score_values = [10, 5, 2] # Calculate scores for each racer based on race results for race in races: for i in range(3): points[race[i]] += score_values[i] # List of racers with their points racers = [(racer, points[racer]) for racer in points] # Sort racers by points desc and by ID asc racers.sort(key=lambda x: (-x[1], x[0])) # Calculate ranks rank = {} for i, (racer_id, _) in enumerate(racers, 1): rank[racer_id] = i # Prepare the final output for the queries result = [] for query in queries: racer_id = query result.append((points[racer_id], rank[racer_id])) return result"},{"question":"def min_cost_to_combine_trees(m: int, k: int, node_values: List[int], merge_info: List[Tuple[int, int, int, int, int, int]], divide_info: List[Tuple[int, int, int, int]]) -> int: Determine the minimum cost to transform the given initial forest into a state where there is exactly one tree remaining. Args: m: The number of trees in the forest. k: The number of nodes in each tree. node_values: A list of integers representing the unique values of the nodes in the forest. merge_info: A list of tuples providing information about which pairs of nodes can be merged and their associated costs. divide_info: A list of tuples providing information about which edges can be divided and their associated costs. Returns: An integer representing the minimum cost to form a single tree. If it's not possible, return -1. Example: >>> min_cost_to_combine_trees(2, 3, [1, 2, 3, 4, 5, 6], [(1, 1, 2, 2, 1, 1), (1, 2, 2, 3, 2, 0), (1, 3, 2, 1, 3, 1)], [(1, 2, 5, 1), (2, 3, 6, 0)]) 1 >>> min_cost_to_combine_trees(3, 2, [1, 2, 3, 4, 5, 6], [(1, 1, 2, 3, 1, 1), (2, 3, 3, 4, 1, 1), (1, 1, 3, 4, 2, 0)], [(1, 2, 5, 1), (4, 5, 7, 0)]) 2 >>> min_cost_to_combine_trees(2, 2, [1, 2, 3, 4], [(1, 1, 2, 1, 1, 0)], [(1, 2, 1, 0)]) -1","solution":"import heapq def min_cost_to_combine_trees(m, k, node_values, merge_info, divide_info): from collections import defaultdict import heapq # Make a union-find data structure parent = {} rank = {} def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): root_x = find(x) root_y = find(y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 # Initially each node is its own parent for value in node_values: parent[value] = value rank[value] = 0 merge_edges = [] for u1, v1, u2, v2, cost, allowed in merge_info: if allowed == 1: heapq.heappush(merge_edges, (cost, u1, v1, u2, v2)) divide_edges = {} for u, v, cost, allowed in divide_info: if allowed == 1: divide_edges[(u, v)] = cost divide_edges[(v, u)] = cost total_cost = 0 merged_count = 0 while merge_edges and merged_count < m - 1: cost, u1, v1, u2, v2 = heapq.heappop(merge_edges) if find(u1) != find(u2): union(u1, u2) total_cost += cost merged_count += 1 if merged_count == m - 1: return total_cost else: return -1"},{"question":"def find_min_latency(n: int, m: int, connections: List[Tuple[int, int, int]]) -> int: Determine the minimal total latency required to connect all servers. Parameters: n : int : number of servers m : int : number of possible connections connections : List[Tuple[int, int, int]] : each tuple contains (a, b, l) representing a connection between servers a and b with latency l Returns: int : minimal total latency required to connect all servers Example: >>> find_min_latency(4, 5, [(1, 2, 4), (1, 3, 2), (1, 4, 3), (2, 3, 1), (3, 4, 5)]) 6 >>> find_min_latency(3, 3, [(1, 2, 1), (2, 3, 2), (1, 3, 3)]) 3 pass # Unit tests def test_find_min_latency(): assert find_min_latency(4, 5, [(1, 2, 4), (1, 3, 2), (1, 4, 3), (2, 3, 1), (3, 4, 5)]) == 6 assert find_min_latency(3, 3, [(1, 2, 1), (2, 3, 2), (1, 3, 3)]) == 3 assert find_min_latency(2, 1, [(1, 2, 1)]) == 1 assert find_min_latency(5, 7, [(1, 2, 2), (1, 3, 3), (1, 4, 4), (1, 5, 5), (2, 3, 1), (3, 4, 7), (4, 5, 6)]) == 12 assert find_min_latency(4, 4, [(1, 2, 2), (2, 3, 2), (3, 4, 2), (4, 1, 2)]) == 6","solution":"def find_min_latency(n, m, connections): Find the minimal total latency required to connect all servers. Parameters: n : int : number of servers m : int : number of connections connections : list of tuples : each tuple contains (a, b, l) representing a connection between servers a and b with latency l Returns: int : minimal total latency required to connect all servers # Using Kruskal's Algorithm to find the Minimum Spanning Tree (MST) def find(parent, i): if parent[i] == i: return i else: parent[i] = find(parent, parent[i]) return parent[i] def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x else: parent[root_y] = root_x rank[root_x] += 1 # Sort connections based on latency connections.sort(key=lambda x: x[2]) parent = [i for i in range(n+1)] rank = [0] * (n+1) mst_weight = 0 edge_count = 0 for a, b, l in connections: root_a = find(parent, a) root_b = find(parent, b) if root_a != root_b: mst_weight += l union(parent, rank, root_a, root_b) edge_count += 1 if edge_count == n - 1: break return mst_weight"},{"question":"def is_palindromic_subsequence(n: int, k: int, tiles: List[int], queries: List[Tuple[int, int]]) -> List[str]: Determine if a given sub-sequence of tiles is palindromic. Args: n (int): Number of tiles. k (int): Number of different colors. tiles (List[int]): List of integers representing the colors of the tiles. queries (List[Tuple[int, int]]): List of queries where each query is a tuple (l, r), representing the 1-based indices of the start and end of the sub-sequence to check. Returns: List[str]: List of results (\\"YES\\" or \\"NO\\") for each query. >>> is_palindromic_subsequence(8, 3, [1, 2, 3, 2, 1, 3, 3, 3], [(1, 5), (2, 4), (3, 3), (1, 8), (6, 8)]) [\\"YES\\", \\"YES\\", \\"YES\\", \\"NO\\", \\"YES\\"] >>> is_palindromic_subsequence(1, 1, [1], [(1, 1)]) [\\"YES\\"] >>> is_palindromic_subsequence(5, 3, [3, 1, 3, 1, 3], [(1, 5)]) [\\"YES\\"] >>> is_palindromic_subsequence(4, 4, [1, 2, 3, 4], [(1, 2), (1, 4), (2, 3)]) [\\"NO\\", \\"NO\\", \\"NO\\"] >>> is_palindromic_subsequence(6, 2, [1, 2, 2, 1, 2, 2], [(1, 4), (2, 3), (3, 6)]) [\\"YES\\", \\"YES\\", \\"NO\\"]","solution":"def is_palindromic_subsequence(n, k, tiles, queries): results = [] for l, r in queries: sub_sequence = tiles[l-1:r] if sub_sequence == sub_sequence[::-1]: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def min_path_sum(n: int, m: int, grid: List[List[int]]) -> int: Find the minimum path from the top-left corner to the bottom-right corner in a grid. The grid is composed of n rows and m columns with each cell containing a non-negative integer representing its weight. Args: n (int): Number of rows in the grid. m (int): Number of columns in the grid. grid (List[List[int]]): 2D list representing the grid of weights. Returns: int: The minimum sum of the weights of the cells on any valid path from (1, 1) to (n, m). >>> grid = [ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ] >>> min_path_sum(3, 3, grid) 7 >>> grid = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> min_path_sum(3, 3, grid) 21 >>> grid = [ ... [5] ... ] >>> min_path_sum(1, 1, grid) 5 >>> grid = [ ... [1, 3], ... [2, 1] ... ] >>> min_path_sum(2, 2, grid) 4 >>> grid = [ ... [1, 2, 5], ... [3, 2, 1] ... ] >>> min_path_sum(2, 3, grid) 6","solution":"def min_path_sum(n, m, grid): if n == 0 or m == 0: return 0 dp = [[0 for _ in range(m)] for _ in range(n)] dp[0][0] = grid[0][0] # Initialize top row for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Initialize left column for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill in the rest of the dp table for i in range(1, n): for j in range(1, m): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[n-1][m-1]"},{"question":"def search_insert(nums, target): Given a sorted array of distinct integers \`nums\` and a target integer \`target\`, return the index if the target is found. If not, return the index where it would be if it were inserted in order. Uses binary search for O(log n) runtime complexity. def test_search_insert_found(): assert search_insert([1, 3, 5, 6], 5) == 2 assert search_insert([1, 3, 5, 6, 7, 9], 7) == 4 assert search_insert([2, 4, 6, 8, 10], 6) == 2 def test_search_insert_not_found(): assert search_insert([1, 3, 5, 6], 2) == 1 assert search_insert([1, 3, 5, 6], 7) == 4 assert search_insert([1, 3, 5, 6], 0) == 0 assert search_insert([2, 4, 6, 8, 10], 5) == 2 assert search_insert([2, 4, 6, 8, 10], 11) == 5 def test_search_insert_edge_cases(): assert search_insert([1], 0) == 0 assert search_insert([1], 1) == 0 assert search_insert([1], 2) == 1 def test_search_insert_large_input(): nums = list(range(1, 10001)) assert search_insert(nums, 5000) == 4999 assert search_insert(nums, 10001) == 10000 assert search_insert(nums, 0) == 0","solution":"def search_insert(nums, target): Given a sorted array of distinct integers \`nums\` and a target integer \`target\`, return the index if the target is found. If not, return the index where it would be if it were inserted in order. Uses binary search for O(log n) runtime complexity. left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid elif nums[mid] < target: left = mid + 1 else: right = mid - 1 return left"},{"question":"def can_follow_recipe(n: int, sequence: List[int]) -> bool: Determines if the sequence of adding ingredients follows the recipe's rules. Args: n (int): Number of different types of ingredients (labeled from 1 to n). sequence (list of int): List representing the order in which ingredients are added. Returns: bool: True if the sequence is valid, otherwise False. Examples: >>> can_follow_recipe(3, [1, 2, 2, 3]) True >>> can_follow_recipe(3, [1, 3, 2]) False >>> can_follow_recipe(4, [1, 1, 2, 3, 3, 4]) True from solution import can_follow_recipe def test_can_follow_recipe_basic_valid(): assert can_follow_recipe(3, [1, 2, 2, 3]) == True def test_can_follow_recipe_invalid(): assert can_follow_recipe(3, [1, 3, 2]) == False def test_can_follow_recipe_repeated_elements(): assert can_follow_recipe(4, [1, 1, 2, 3, 3, 4]) == True def test_can_follow_recipe_empty_sequence(): assert can_follow_recipe(1, []) == True def test_can_follow_recipe_single_element(): assert can_follow_recipe(5, [1]) == True assert can_follow_recipe(5, [5]) == True def test_can_follow_recipe_large_sequence(): assert can_follow_recipe(100, list(range(1, 101))) == True assert can_follow_recipe(100, list(range(100, 0, -1))) == False def test_can_follow_recipe_complex_case(): assert can_follow_recipe(5, [1, 1, 2, 2, 3, 3, 4, 4, 5]) == True assert can_follow_recipe(5, [1, 1, 2, 3, 2, 3, 4, 5]) == False","solution":"def can_follow_recipe(n, sequence): Determines if the sequence of adding ingredients follows the recipe's rule. Args: n (int): Number of different types of ingredients. sequence (list of int): List representing the order in which ingredients are added. Returns: bool: True if the sequence is valid, otherwise False. if not sequence: return True for i in range(1, len(sequence)): if sequence[i] not in [sequence[i-1], sequence[i-1] + 1]: return False return True"},{"question":"def num_distinct_islands(test_cases): Count the number of distinct islands in a list of test cases. An island is defined as connected land (1s) horizontally or vertically. Two islands are considered distinct if and only if one island is not identical to another either via rotation (90, 180, or 270 degrees) or reflection (flip horizontally or vertically). Args: test_cases (List[Tuple[int, List[Tuple[int, int, List[List[int]]]]]]): A list of test cases, where each test case is a tuple containing the number of rows and columns, and the grid. Returns: List[int]: A list of the number of distinct islands for each test case. Example: >>> num_distinct_islands([(3, 3, [[1, 1, 0], [0, 1, 0], [1, 0, 0]]), (4, 5, [[1, 1, 0, 0, 0], [1, 0, 0, 1, 1], [0, 0, 0, 1, 1], [1, 1, 0, 0, 0]])]) [2, 3] >>> num_distinct_islands([(1, 1, [[1]])]) [1] pass def test_num_distinct_islands(): cases = [ (2, [ (3, 3, [ [1, 1, 0], [0, 1, 0], [1, 0, 0], ]), (4, 5, [ [1, 1, 0, 0, 0], [1, 0, 0, 1, 1], [0, 0, 0, 1, 1], [1, 1, 0, 0, 0], ]) ], [2, 3]), (1, [ (1, 1, [ [1], ]) ], [1]) ] for t, test_cases, expected in cases: assert num_distinct_islands(test_cases) == expected if __name__ == \\"__main__\\": test_num_distinct_islands()","solution":"def num_distinct_islands(test_cases): def extract_islands(grid, m, n): def dfs(x, y): stack = [(x, y)] island = [] grid[x][y] = -1 # Mark visited while stack: i, j = stack.pop() island.append((i - x, j - y)) for ni, nj in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]: if 0 <= ni < m and 0 <= nj < n and grid[ni][nj] == 1: grid[ni][nj] = -1 # Mark visited stack.append((ni, nj)) return island islands = [] for i in range(m): for j in range(n): if grid[i][j] == 1: islands.append(dfs(i, j)) return islands def normalize_shape(shape): transformations = [ lambda x, y: ( x, y), lambda x, y: (-x, y), lambda x, y: ( x, -y), lambda x, y: (-x, -y), lambda x, y: ( y, x), lambda x, y: (-y, x), lambda x, y: ( y, -x), lambda x, y: (-y, -x), ] normalized = [] for transform in transformations: transformed_shape = sorted(transform(x, y) for (x, y) in shape) min_x = min(x for (x, y) in transformed_shape) min_y = min(y for (x, y) in transformed_shape) normalized.append(sorted((x - min_x, y - min_y) for (x, y) in transformed_shape)) return min(normalized) results = [] for m, n, grid in test_cases: islands = extract_islands(grid, m, n) distinct_islands = {tuple(normalize_shape(island)) for island in islands} results.append(len(distinct_islands)) return results"},{"question":"class TreeNode: def __init__(self, x, left=None, right=None): self.val = x self.left = left self.right = right def findClosestValueInBST(tree: TreeNode, k: int) -> int: Find the value in the BST that is closest to \`k\`. >>> tree = TreeNode(10, TreeNode(5, TreeNode(2, TreeNode(1)), TreeNode(5)), TreeNode(15, TreeNode(13, None, TreeNode(14)), TreeNode(22))) >>> findClosestValueInBST(tree, 12) 13 pass def test_findClosestValueInBST(): tree = TreeNode(10, TreeNode(5, TreeNode(2, TreeNode(1)), TreeNode(5)), TreeNode(15, TreeNode(13, None, TreeNode(14)), TreeNode(22))) assert findClosestValueInBST(tree, 12) == 13 def test_findClosestValueInBST_root(): tree = TreeNode(10, TreeNode(5, TreeNode(2, TreeNode(1)), TreeNode(5)), TreeNode(15, TreeNode(13, None, TreeNode(14)), TreeNode(22))) assert findClosestValueInBST(tree, 10) == 10 def test_findClosestValueInBST_left(): tree = TreeNode(10, TreeNode(5, TreeNode(2, TreeNode(1)), TreeNode(5)), TreeNode(15, TreeNode(13, None, TreeNode(14)), TreeNode(22))) assert findClosestValueInBST(tree, 6) == 5 def test_findClosestValueInBST_right(): tree = TreeNode(10, TreeNode(5, TreeNode(2, TreeNode(1)), TreeNode(5)), TreeNode(15, TreeNode(13, None, TreeNode(14)), TreeNode(22))) assert findClosestValueInBST(tree, 18) == 15 def test_findClosestValueInBST_leaf(): tree = TreeNode(10, TreeNode(5, TreeNode(2, TreeNode(1)), TreeNode(5)), TreeNode(15, TreeNode(13, None, TreeNode(14)), TreeNode(22))) assert findClosestValueInBST(tree, 1) == 1 def test_findClosestValueInBST_multiple_equal_distances(): tree = TreeNode(10, TreeNode(5, TreeNode(2, TreeNode(1)), TreeNode(5)), TreeNode(15, TreeNode(13, None, TreeNode(14)), TreeNode(22))) assert findClosestValueInBST(tree, 11) == 10","solution":"class TreeNode: def __init__(self, x, left=None, right=None): self.val = x self.left = left self.right = right def findClosestValueInBST(tree: TreeNode, k: int) -> int: closest = tree.val while tree: if abs(tree.val - k) < abs(closest - k): closest = tree.val if k < tree.val: tree = tree.left elif k > tree.val: tree = tree.right else: break return closest"},{"question":"from typing import List def trap_rain_water(n: int, height: List[List[int]]) -> int: Calculate the total amount of trapped rainwater in a city represented by an n x n grid of blocks. Args: n (int): The size of the grid. height (List[List[int]]): The elevation height of each block. Returns: int: The total amount of trapped rainwater. >>> trap_rain_water(3, [ ... [1, 4, 3], ... [3, 0, 2], ... [2, 3, 4]]) 2 >>> trap_rain_water(4, [ ... [5, 5, 5, 5], ... [5, 1, 1, 5], ... [5, 1, 1, 5], ... [5, 5, 5, 5]]) 16 # Unit tests def test_example_1(): n = 3 height = [ [1, 4, 3], [3, 0, 2], [2, 3, 4] ] assert trap_rain_water(n, height) == 2 def test_example_2(): n = 4 height = [ [5, 5, 5, 5], [5, 1, 1, 5], [5, 1, 1, 5], [5, 5, 5, 5] ] assert trap_rain_water(n, height) == 16 def test_no_trapped_water(): n = 3 height = [ [3, 3, 3], [3, 3, 3], [3, 3, 3] ] assert trap_rain_water(n, height) == 0 def test_single_trapped_cell(): n = 3 height = [ [5, 5, 5], [5, 1, 5], [5, 5, 5] ] assert trap_rain_water(n, height) == 4 def test_large_grid(): n = 4 height = [ [12, 13, 1, 12], [13, 4, 13, 12], [13, 8, 10, 12], [12, 13, 12, 12] ] assert trap_rain_water(n, height) == 14","solution":"import heapq def trap_rain_water(n, height): if n <= 2: return 0 trapped_water = 0 visited = [[False] * n for _ in range(n)] min_heap = [] for i in range(n): for j in range(n): if i == 0 or i == n-1 or j == 0 or j == n-1: heapq.heappush(min_heap, (height[i][j], i, j)) visited[i][j] = True directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] while min_heap: h, x, y = heapq.heappop(min_heap) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and not visited[nx][ny]: trapped_water += max(0, h - height[nx][ny]) heapq.heappush(min_heap, (max(h, height[nx][ny]), nx, ny)) visited[nx][ny] = True return trapped_water"},{"question":"def verify_exercise_plans(test_cases: List[Dict[str, Any]]) -> List[str]: Determine if the feedback check passes for an exercise plan based on the client's feedback. Args: test_cases (List[Dict[str, Any]]): A list of test cases, where each test case is a dictionary containing: 'e' (int): The number of exercises. 'm' (int): The number of muscle groups. 'repetitions' (List[int]): The repetitions for each exercise. 'muscle_groups' (str): The muscle groups targeted by each exercise. 'min_reps' (List[int]): The minimum required repetitions for each muscle group. Returns: List[str]: A list of \\"YES\\" or \\"NO\\" for each test case based on whether the feedback check passes. >>> test_cases = [ { 'e': 4, 'm': 2, 'repetitions': [5, 10, 15, 20], 'muscle_groups': \\"AABB\\", 'min_reps': [15, 25] }, { 'e': 3, 'm': 3, 'repetitions': [8, 8, 8], 'muscle_groups': \\"XYZ\\", 'min_reps': [8, 8, 8] }, { 'e': 5, 'm': 2, 'repetitions': [10, 20, 30, 40, 50], 'muscle_groups': \\"AAAAA\\", 'min_reps': [150, 0] }, { 'e': 6, 'm': 3, 'repetitions': [10, 20, 10, 20, 10, 20], 'muscle_groups': \\"ABCABC\\", 'min_reps': [30, 40, 50] }, ] expected_outputs = [\\"YES\\", \\"NO\\", \\"YES\\", \\"NO\\"] output = verify_exercise_plans(test_cases) assert output == expected_outputs","solution":"def verify_exercise_plans(test_cases): result = [] for case in test_cases: e, m = case['e'], case['m'] repetitions = case['repetitions'] muscle_groups = case['muscle_groups'] min_reps = case['min_reps'] muscle_rep_counts = {} for i in range(e): muscle_group = muscle_groups[i] rep = repetitions[i] if muscle_group in muscle_rep_counts: muscle_rep_counts[muscle_group] += rep else: muscle_rep_counts[muscle_group] = rep pass_test = True for i in range(m): muscle_group = chr(ord('A') + i) if muscle_group in muscle_rep_counts: if muscle_rep_counts[muscle_group] < min_reps[i]: pass_test = False break else: if min_reps[i] > 0: pass_test = False break if pass_test: result.append(\\"YES\\") else: result.append(\\"NO\\") return result"},{"question":"from typing import List, Tuple, Dict def does_path_exist_with_target_sum(T: int, queries: List[Dict[str, object]]) -> List[str]: Determines if there exists a path between two nodes such that the sum of the values of the nodes on this path is equal to a given target sum s for multiple queries. Args: T : int : Number of queries queries : List[Dict[str, object]] : List of query dictionaries with the following keys: 'n' : int : Number of nodes in the graph 'm' : int : Number of edges in the graph 's' : int : Target sum to be checked 'values' : List[int] : List of integers representing the values of the nodes 'edges' : List[Tuple[int, int]] : List of tuples representing the edges of the graph Returns: List[str] : List of \\"YES\\" or \\"NO\\" for each query depending on whether such a path exists Example: >>> does_path_exist_with_target_sum(2, [ ... {'n': 4, 'm': 4, 's': 10, 'values': [1, 2, 3, 4], 'edges': [(1, 2), (2, 3), (3, 4), (4, 1)]}, ... {'n': 5, 'm': 4, 's': 8, 'values': [1, 2, 3, 4, 5], 'edges': [(1, 2), (2, 3), (3, 4), (4, 5)]} ... ]) ['YES', 'NO'] # Implementation details go here # Unit tests def test_single_query_yes(): T = 1 queries = [{ 'n': 4, 'm': 4, 's': 10, 'values': [1, 2, 3, 4], 'edges': [(1, 2), (2, 3), (3, 4), (4, 1)] }] assert does_path_exist_with_target_sum(T, queries) == [\\"YES\\"] def test_single_query_no(): T = 1 queries = [{ 'n': 5, 'm': 4, 's': 8, 'values': [1, 2, 3, 4, 5], 'edges': [(1, 2), (2, 3), (3, 4), (4, 5)] }] assert does_path_exist_with_target_sum(T, queries) == [\\"NO\\"] def test_multiple_queries(): T = 2 queries = [ { 'n': 4, 'm': 4, 's': 10, 'values': [1, 2, 3, 4], 'edges': [(1, 2), (2, 3), (3, 4), (4, 1)] }, { 'n': 5, 'm': 4, 's': 8, 'values': [1, 2, 3, 4, 5], 'edges': [(1, 2), (2, 3), (3, 4), (4, 5)] } ] assert does_path_exist_with_target_sum(T, queries) == [\\"YES\\", \\"NO\\"] def test_disconnected_graph(): T = 1 queries = [{ 'n': 3, 'm': 1, 's': 8, 'values': [1, 2, 5], 'edges': [(1, 2)] }] assert does_path_exist_with_target_sum(T, queries) == [\\"NO\\"]","solution":"def does_path_exist_with_target_sum(T, queries): # Helper function to perform DFS and find if a path exists with the sum s def dfs(node, current_sum): if current_sum == s: return True if current_sum > s: return False visited[node] = True for neighbor in graph[node]: if not visited[neighbor]: if dfs(neighbor, current_sum + values[neighbor - 1]): return True visited[node] = False return False results = [] # Process each query independently for query in queries: n, m, s = query['n'], query['m'], query['s'] values = query['values'] edges = query['edges'] # Building the graph graph = [[] for _ in range(n + 1)] for u, v in edges: graph[u].append(v) graph[v].append(u) # Start DFS from each node path_exists = False for start_node in range(1, n + 1): visited = [False] * (n + 1) if dfs(start_node, values[start_node - 1]): path_exists = True break results.append(\\"YES\\" if path_exists else \\"NO\\") return results"},{"question":"from typing import List, Tuple def determine_rankings(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[List[int]]: Determine the final ranking of the players after n-1 rounds, assuming in each round the two players with the highest skill ratings always play against each other. Args: t: The number of test cases. test_cases: A list of tuples, each containing the number of players and their skill ratings. Returns: A list of lists, where each inner list contains the final rankings of the players for each test case. >>> print(determine_rankings(3, [(4, [3, 1, 2, 4]), (3, [10, 10, 20]), (5, [5, 10, 5, 10, 7])])) [[2, 4, 3, 1], [2, 2, 1], [4, 1, 4, 1, 3]] from solution import determine_rankings def test_case_1(): t = 3 test_cases = [ (4, [3, 1, 2, 4]), (3, [10, 10, 20]), (5, [5, 10, 5, 10, 7]), ] expected = [ [2, 4, 3, 1], [2, 2, 1], [4, 1, 4, 1, 3] ] assert determine_rankings(t, test_cases) == expected def test_case_2(): t = 1 test_cases = [ (6, [1, 2, 3, 4, 5, 6]) ] expected = [ [6, 5, 4, 3, 2, 1] ] assert determine_rankings(t, test_cases) == expected def test_case_3(): t = 2 test_cases = [ (5, [1, 1, 1, 1, 1]), (3, [2, 2, 1]), ] expected = [ [1, 1, 1, 1, 1], [1, 1, 3], ] assert determine_rankings(t, test_cases) == expected def test_case_4(): t = 1 test_cases = [ (2, [999999999, 1]), ] expected = [ [1, 2] ] assert determine_rankings(t, test_cases) == expected","solution":"def determine_rankings(t, test_cases): results = [] for i in range(t): n, skills = test_cases[i] sorted_players = sorted(skills, reverse=True) rankings = [] for skill in skills: rankings.append(sorted_players.index(skill) + 1) results.append(rankings) return results"},{"question":"def minimum_max_congestion(n, m, roads, start, end): Determine the minimum possible value of the maximum congestion index encountered on any route from the start to the end intersection. Args: n (int): The number of intersections. m (int): The number of roads. roads (List[Tuple[int, int, int]]): List of tuples where each tuple contains three integers u, v and c representing a road between intersections u and v with congestion index c. start (int): The starting intersection. end (int): The destination intersection. Returns: int: The minimum possible value of the maximum congestion index encountered on any route from the start intersection to the end intersection, or -1 if no route exists. Example: >>> minimum_max_congestion(6, 7, [(1, 2, 10), (1, 3, 20), (2, 4, 30), (3, 4, 10), (4, 5, 40), (3, 6, 50), (5, 6, 60)], 1, 6) 50 >>> minimum_max_congestion(3, 1, [(1, 2, 10)], 1, 3) -1 Example unit tests: from solution import minimum_max_congestion def test_example_case(): n = 6 m = 7 roads = [ (1, 2, 10), (1, 3, 20), (2, 4, 30), (3, 4, 10), (4, 5, 40), (3, 6, 50), (5, 6, 60) ] start = 1 end = 6 assert minimum_max_congestion(n, m, roads, start, end) == 50 def test_no_route(): n = 3 m = 1 roads = [ (1, 2, 10) ] start = 1 end = 3 assert minimum_max_congestion(n, m, roads, start, end) == -1 def test_single_road(): n = 2 m = 1 roads = [ (1, 2, 5) ] start = 1 end = 2 assert minimum_max_congestion(n, m, roads, start, end) == 5 def test_multiple_paths(): n = 4 m = 4 roads = [ (1, 2, 10), (2, 3, 20), (1, 3, 15), (3, 4, 5) ] start = 1 end = 4 assert minimum_max_congestion(n, m, roads, start, end) == 15 def test_complex_case(): n = 5 m = 7 roads = [ (1, 2, 10), (2, 3, 50), (3, 4, 20), (4, 5, 30), (1, 3, 60), (2, 5, 40), (1, 5, 70) ] start = 1 end = 5 assert minimum_max_congestion(n, m, roads, start, end) == 40","solution":"import heapq from collections import defaultdict def minimum_max_congestion(n, m, roads, start, end): graph = defaultdict(list) for u, v, c in roads: graph[u].append((c, v)) graph[v].append((c, u)) def dijkstra_max_congestion(graph, start, end, n): pq = [(0, start)] max_congestion = [float('inf')] * (n + 1) max_congestion[start] = 0 while pq: current_max_congestion, node = heapq.heappop(pq) if node == end: return current_max_congestion for weight, neighbor in graph[node]: new_congestion = max(current_max_congestion, weight) if new_congestion < max_congestion[neighbor]: max_congestion[neighbor] = new_congestion heapq.heappush(pq, (new_congestion, neighbor)) return -1 return dijkstra_max_congestion(graph, start, end, n)"},{"question":"def rearrange_array(n: int, arr: List[int]) -> List[int]: Rearrange the array such that no two consecutive elements are equal by performing exactly n/2 swaps. Args: - n (int): The number of elements in the array (even) - arr (list of int): The elements of the array Returns: - list of int: The resulting array after n/2 operations from solution import rearrange_array def test_rearrange_example_case(): input_n = 6 input_arr = [2, 2, 2, 1, 1, 1] result = rearrange_array(input_n, input_arr) assert result == [2, 1, 2, 1, 2, 1] or result == [1, 2, 1, 2, 1, 2] def test_rearrange_all_unique(): input_n = 4 input_arr = [4, 1, 3, 2] result = rearrange_array(input_n, input_arr) assert result == [4, 3, 1, 2] or result == [1, 4, 2, 3] or result == [1, 2, 3, 4] or result == [4, 1, 2, 3] def test_rearrange_half_identical(): input_n = 4 input_arr = [2, 2, 1, 1] result = rearrange_array(input_n, input_arr) assert result == [2, 1, 2, 1] or result == [1, 2, 1, 2] def test_rearrange_larger_array(): input_n = 8 input_arr = [3, 3, 3, 3, 2, 2, 2, 2] result = rearrange_array(input_n, input_arr) assert result == [3, 2, 3, 2, 3, 2, 3, 2] or result == [2, 3, 2, 3, 2, 3, 2, 3] def test_rearrange_all_elements_same(): input_n = 2 input_arr = [1, 1] result = rearrange_array(input_n, input_arr) assert result == [1, 1] or result == [1, 1] def test_rearrange_sorted_inputs(): input_n = 4 input_arr = [1, 1, 2, 2] result = rearrange_array(input_n, input_arr) assert result == [1, 2, 1, 2] or result == [2, 1, 2, 1]","solution":"def rearrange_array(n, arr): Rearrange the array such that no two consecutive elements are equal by performing exactly n/2 swaps. Args: - n (int): The number of elements in the array (even) - arr (list of int): The elements of the array Returns: - list of int: The resulting array after n/2 operations # Split the array into two halves half1 = arr[:n//2] half2 = arr[n//2:] # Interleave the two halves to ensure no two consecutive elements are equal result = [] for i in range(n//2): result.append(half1[i]) result.append(half2[i]) return result"},{"question":"def smallest_subarray_length(q, queries): Compute the length of the smallest subarray such that the sum of its elements is at least k. Each query provides an array of integers and a target sum k. Returns a list of integers where each integer is the length of the smallest subarray or -1 if no such subarray exists. >>> queries = [ ... (6, 7, [2, 3, 1, 2, 4, 3]), ... (5, 11, [1, 2, 3, 4, 5]) ... ] >>> smallest_subarray_length(2, queries) == [2, 3] >>> queries = [ ... (3, 10, [1, 2, 3]), ... (4, 20, [1, 2, 3, 4]) ... ] >>> smallest_subarray_length(2, queries) == [-1, -1] >>> queries = [ ... (5, 4, [1, 4, 5, 2, 1]) ... ] >>> smallest_subarray_length(1, queries) == [1] >>> queries = [ ... (5, 15, [1, 2, 3, 4, 5]) ... ] >>> smallest_subarray_length(1, queries) == [5] >>> queries = [ ... (5, 7, [1, 2, 3, 4, 5]), ... (6, 6, [1, 1, 1, 1, 1, 1]), ... (4, 4, [2, 2, 2, 2]), ... (3, 5, [1, 2, 3]) ... ] >>> smallest_subarray_length(4, queries) == [2, 6, 2, 2]","solution":"def smallest_subarray_length(q, queries): results = [] for query in queries: n, k, arr = query left = 0 s = 0 min_length = float('inf') for right in range(n): s += arr[right] while s >= k: min_length = min(min_length, right - left + 1) s -= arr[left] left += 1 if min_length == float('inf'): results.append(-1) else: results.append(min_length) return results"},{"question":"class FileSystem: Class to manage a file system consisting of directories and files with their sizes. The FileSystem should support the following operations: - Create a directory within another directory. - Add a file of a specified size to a directory. - Query the total size of files within a directory and its subdirectories. def __init__(self): # Initializes an empty file system with a root directory pass def add_file(self, directory_path, file_size): Adds a file with the specified size to the given directory path. Args: directory_path (str): The path to the directory where the file should be added. file_size (int): The size of the file to be added. pass def create_directory(self, parent_directory_path, directory_name): Creates a new directory within the specified parent directory. Args: parent_directory_path (str): The path to the parent directory. directory_name (str): The name of the new directory to be created. pass def query_size(self, directory_path): Queries the total size of files within the specified directory, including its subdirectories. Args: directory_path (str): The path to the directory whose size is to be queried. Returns: int: The total size of files within the specified directory and its subdirectories. pass def test_operations(): fs = FileSystem() fs.create_directory('/root', 'home') fs.create_directory('/root', 'var') fs.add_file('/root/home', 10) fs.add_file('/root/var', 5) fs.create_directory('/root/home', 'user') fs.add_file('/root/home/user', 20) assert fs.query_size('/root/home') == 30 assert fs.query_size('/root/var') == 5 def test_empty_fs(): fs = FileSystem() assert fs.query_size('/root') == 0 def test_only_files_no_subdir(): fs = FileSystem() fs.add_file('/root', 10) fs.add_file('/root', 20) assert fs.query_size('/root') == 30 def test_only_subdirs_no_files(): fs = FileSystem() fs.create_directory('/root', 'home') fs.create_directory('/root', 'var') assert fs.query_size('/root') == 0 assert fs.query_size('/root/home') == 0 assert fs.query_size('/root/var') == 0 def test_deep_nested_dirs(): fs = FileSystem() fs.create_directory('/root', 'lvl1') fs.create_directory('/root/lvl1', 'lvl2') fs.create_directory('/root/lvl1/lvl2', 'lvl3') fs.add_file('/root/lvl1/lvl2/lvl3', 50) fs.add_file('/root/lvl1', 10) assert fs.query_size('/root/lvl1') == 60 assert fs.query_size('/root/lvl1/lvl2/lvl3') == 50","solution":"class FileSystem: def __init__(self): self.fs = {'root': {'__size__': 0}} def add_file(self, directory_path, file_size): dirs = directory_path.strip('/').split('/') current = self.fs for d in dirs: current = current[d] current['__size__'] += file_size def create_directory(self, parent_directory_path, directory_name): dirs = parent_directory_path.strip('/').split('/') current = self.fs for d in dirs: current = current[d] current[directory_name] = {'__size__': 0} def query_size(self, directory_path): dirs = directory_path.strip('/').split('/') current = self.fs for d in dirs: current = current[d] return self._calculate_size(current) def _calculate_size(self, directory): total_size = directory['__size__'] for name, subdir in directory.items(): if name != '__size__': total_size += self._calculate_size(subdir) return total_size"},{"question":"from typing import List def shortest_path_in_grid(n: int, m: int, grid: List[List[int]], x: int, y: int) -> int: Determines if there's a path from (0,0) to (x,y) in the grid and returns the length of the shortest path. If no path exists, returns -1. pass def test_shortest_path_basic(): grid = [ [0, 1, 0, 0, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0], [0, 1, 1, 1, 1], [0, 0, 0, 0, 0] ] assert shortest_path_in_grid(5, 5, grid, 4, 4) == 8 def test_shortest_path_no_path(): grid = [ [0, 1, 0, 0, 0], [1, 1, 1, 1, 1], [0, 1, 1, 1, 1], [0, 1, 1, 1, 1], [0, 0, 0, 0, 0] ] assert shortest_path_in_grid(5, 5, grid, 4, 4) == -1 def test_shortest_path_blocked_start(): grid = [ [1, 1, 0, 0, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0], [0, 1, 1, 1, 1], [0, 0, 0, 0, 0] ] assert shortest_path_in_grid(5, 5, grid, 4, 4) == -1 def test_shortest_path_blocked_end(): grid = [ [0, 1, 0, 0, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0], [0, 1, 1, 1, 1], [0, 0, 0, 0, 1] ] assert shortest_path_in_grid(5, 5, grid, 4, 4) == -1 def test_shortest_path_single_cell(): grid = [ [0] ] assert shortest_path_in_grid(1, 1, grid, 0, 0) == 0","solution":"from collections import deque def shortest_path_in_grid(n, m, grid, x, y): Determines if there's a path from (0,0) to (x,y) in the grid and returns the length of the shortest path. If no path exists, returns -1. if grid[0][0] == 1 or grid[x][y] == 1: return -1 directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] queue = deque([(0, 0, 0)]) visited = set((0, 0)) while queue: cx, cy, steps = queue.popleft() # If we reach target cell if cx == x and cy == y: return steps for dx, dy in directions: nx, ny = cx + dx, cy + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] == 0: queue.append((nx, ny, steps + 1)) visited.add((nx, ny)) return -1"},{"question":"from typing import List def sortBalls(colors: List[str]) -> None: Sort an array of 'R', 'G', 'B' to place all 'R's before 'G's and all 'G's before 'B's. Args: colors (List[str]): List of characters 'R', 'G', 'B'. Returns: None: Sorts the list in-place. Example: >>> colors = ['G', 'B', 'G', 'R', 'B', 'R', 'G'] >>> sortBalls(colors) >>> colors ['R', 'R', 'G', 'G', 'G', 'B', 'B'] # Implementation goes here def test_sortBalls_basic(): colors = ['G', 'B', 'G', 'R', 'B', 'R', 'G'] sortBalls(colors) assert colors == ['R', 'R', 'G', 'G', 'G', 'B', 'B'] def test_sortBalls_all_same_color(): colors = ['R', 'R', 'R', 'R'] sortBalls(colors) assert colors == ['R', 'R', 'R', 'R'] colors = ['G', 'G', 'G', 'G'] sortBalls(colors) assert colors == ['G', 'G', 'G', 'G'] colors = ['B', 'B', 'B', 'B'] sortBalls(colors) assert colors == ['B', 'B', 'B', 'B'] def test_sortBalls_already_sorted(): colors = ['R', 'R', 'G', 'G', 'B', 'B'] sortBalls(colors) assert colors == ['R', 'R', 'G', 'G', 'B', 'B'] def test_sortBalls_reverse_sorted(): colors = ['B', 'B', 'G', 'G', 'R', 'R'] sortBalls(colors) assert colors == ['R', 'R', 'G', 'G', 'B', 'B'] def test_sortBalls_single_color(): colors = ['R'] sortBalls(colors) assert colors == ['R'] def test_sortBalls_empty_array(): colors = [] sortBalls(colors) assert colors == [] def test_sortBalls_random_order(): colors = ['B', 'R', 'G', 'B', 'G', 'R', 'B', 'G', 'R'] sortBalls(colors) assert colors == ['R', 'R', 'R', 'G', 'G', 'G', 'B', 'B', 'B']","solution":"def sortBalls(colors): Sort an array of 'R', 'G', 'B' to place all 'R's before 'G's and all 'G's before 'B's. Args: colors (List[str]): List of characters 'R', 'G', 'B'. Returns: None: Sorts the list in-place. low, mid, high = 0, 0, len(colors) - 1 while mid <= high: if colors[mid] == 'R': colors[low], colors[mid] = colors[mid], colors[low] low += 1 mid += 1 elif colors[mid] == 'G': mid += 1 else: # colors[mid] == 'B' colors[high], colors[mid] = colors[mid], colors[high] high -= 1"},{"question":"def max_sum_of_subarray(T: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Calculate the maximum sum of any contiguous subarray of length k in the array. Args: T (int): The number of test cases. test_cases (list): A list containing T tuples. Each tuple consists of an integer n, an integer k, and a list of integers representing the array. Returns: list: A list of integers. Each integer represents the maximum sum of any contiguous subarray of length k for each test case. >>> max_sum_of_subarray(2, [(5, 2, [1, 2, 3, 4, 5]), (6, 3, [-1, 2, 3, -5, 4, 6])]) [9, 5] >>> max_sum_of_subarray(1, [(1, 1, [5])]) [5] >>> max_sum_of_subarray(1, [(1, 1, [-5])]) [-5] >>> max_sum_of_subarray(1, [(5, 3, [2, 2, 2, 2, 2])]) [6] >>> max_sum_of_subarray(1, [(5, 5, [2, 2, 2, 2, 2])]) [10] >>> max_sum_of_subarray(1, [(5, 3, [1, -2, 3, 4, -1])]) [6] >>> max_sum_of_subarray(1, [(4, 2, [10000, 20000, 30000, 40000])]) [70000] >>> array = list(range(1, 100001)) >>> max_sum_of_subarray(1, [(100000, 1, array)]) [100000] >>> max_sum_of_subarray(1, [(100000, 100000, array)]) [5000050000] pass # replace this line with your implementation if __name__ == \\"__main__\\": import doctest doctest.testmod()","solution":"def max_sum_of_subarray(T, test_cases): Returns the maximum sum of any contiguous subarray of length k for each test case. Args: T (int): The number of test cases. test_cases (list): A list containing T tuples. Each tuple consists of an integer n, an integer k, and a list of integers representing the array. Returns: list: A list of integers. Each integer represents the maximum sum of any contiguous subarray of length k for each test case. result = [] for n, k, array in test_cases: # Calculate the sum of the first 'k' elements max_sum = current_sum = sum(array[:k]) # Use sliding window technique to find the maximum sum of subarray of length k for i in range(k, n): current_sum += array[i] - array[i - k] if current_sum > max_sum: max_sum = current_sum result.append(max_sum) return result"},{"question":"from typing import List def min_moves_to_deliver_package(grid: List[str]) -> int: Determine the minimum number of moves required for the drone to reach the destination in a city grid. The grid is represented as a list of strings where each cell can either be empty ('.') or have an obstacle ('#'). The drone starts at the top-left corner of the grid (cell (0, 0)) and needs to deliver the package to the bottom-right corner of the grid (cell (m-1, n-1)). The drone can only move in four possible directions: up, down, left, and right. If it is impossible for the drone to reach the destination, return -1. Example: >>> min_moves_to_deliver_package([ ... \\".#.\\", ... \\"...\\", ... \\"#..\\" ... ]) 4 >>> min_moves_to_deliver_package([ ... \\"...\\" ... ]) 0 def test_no_obstacles(): grid = [ \\"...\\", \\"...\\", \\"...\\" ] assert min_moves_to_deliver_package(grid) == 4 def test_some_obstacles(): grid = [ \\".#.\\", \\"...\\", \\"#..\\" ] assert min_moves_to_deliver_package(grid) == 4 def test_blocked_start(): grid = [ \\"#..\\", \\"...\\", \\"...\\" ] assert min_moves_to_deliver_package(grid) == -1 def test_blocked_end(): grid = [ \\"...\\", \\"...\\", \\"..#\\" ] assert min_moves_to_deliver_package(grid) == -1 def test_single_cell(): grid = [\\".\\"] assert min_moves_to_deliver_package(grid) == 0 def test_no_path(): grid = [ \\".#.\\", \\"#.#\\", \\"#..\\" ] assert min_moves_to_deliver_package(grid) == -1 def test_large_grid(): grid = [\\".\\" * 1000] * 1000 assert min_moves_to_deliver_package(grid) == 1998","solution":"from collections import deque def min_moves_to_deliver_package(grid): if not grid or not grid[0]: return -1 m, n = len(grid), len(grid[0]) if grid[0][0] == '#' or grid[m-1][n-1] == '#': return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if x == m - 1 and y == n - 1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == '.' and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"def find_most_interested_session(n: int, m: int, interests: List[List[int]]) -> int: Finds the session with the highest total interest among participants. If there's a tie, returns the first session (1-indexed) among them. :param n: Number of participants :param m: Number of sessions :param interests: List of lists indicating participants' interest in sessions :return: 1-based index of the session with highest interest from solution import find_most_interested_session def test_sample_case1(): n, m = 3, 4 interests = [ [1, 0, 1, 0], [0, 1, 1, 0], [1, 1, 0, 1] ] assert find_most_interested_session(n, m, interests) == 1 def test_sample_case2(): n, m = 5, 4 interests = [ [1, 0, 1, 0], [0, 1, 1, 0], [1, 1, 0, 1], [0, 0, 0, 1], [1, 1, 0, 0] ] assert find_most_interested_session(n, m, interests) == 1 def test_only_one_participant(): n, m = 1, 3 interests = [[1, 1, 1]] assert find_most_interested_session(n, m, interests) == 1 def test_each_session_single_interest(): n, m = 3, 3 interests = [ [1, 0, 0], [0, 1, 0], [0, 0, 1] ] assert find_most_interested_session(n, m, interests) == 1 def test_all_zero_interest(): n, m = 3, 4 interests = [ [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0] ] assert find_most_interested_session(n, m, interests) == 1","solution":"def find_most_interested_session(n, m, interests): Finds the session with the highest total interest among participants. If there's a tie, returns the first session (1-indexed) among them. :param n: Number of participants :param m: Number of sessions :param interests: List of lists indicating participants' interest in sessions :return: 1-based index of the session with highest interest session_interest = [0] * m for participant in interests: for j in range(m): session_interest[j] += participant[j] max_interest = max(session_interest) for i in range(m): if session_interest[i] == max_interest: return i + 1 # Return the 1-based index of the session # Example usage: # n, m = 3, 4 # interests = [[1, 0, 1, 0], [0, 1, 1, 0], [1, 1, 0, 1]] # print(find_most_interested_session(n, m, interests)) # Output should be 1"},{"question":"def longest_clear_segment(n: int, track: str) -> int: Returns the length of the longest contiguous subarray of clear segments (\\"C\\") in the given track. :param n: Number of segments in the track. :param track: String representing the track with \\"C\\" for clear and \\"M\\" for muddy segments. :return: Integer representing the length of the longest contiguous subarray of clear segments. def process_test_cases(t: int, test_cases: List[Tuple[int, str]]) -> List[int]: Process multiple test cases to find the longest contiguous subarray of clear segments for each. :param t: Number of test cases. :param test_cases: List of Tuples where each tuple contains an integer n and a string track. :return: List of integers where each integer is the length of the longest contiguous subarray of clear segments. # Unit Tests def test_longest_clear_segment(): assert longest_clear_segment(10, \\"CCMMCCCMMC\\") == 3 assert longest_clear_segment(5, \\"MMMMM\\") == 0 assert longest_clear_segment(7, \\"CCCCCCC\\") == 7 assert longest_clear_segment(6, \\"CCMCCC\\") == 3 assert longest_clear_segment(6, \\"CMCMCM\\") == 1 assert longest_clear_segment(1, \\"C\\") == 1 assert longest_clear_segment(1, \\"M\\") == 0 def test_process_test_cases(): test_cases = [(10, \\"CCMMCCCMMC\\"), (5, \\"MMMMM\\"), (7, \\"CCCCCCC\\")] assert process_test_cases(3, test_cases) == [3, 0, 7] test_cases = [(6, \\"CCMCCC\\"), (6, \\"CMCMCM\\"), (1, \\"C\\"), (1, \\"M\\")] assert process_test_cases(4, test_cases) == [3, 1, 1, 0]","solution":"def longest_clear_segment(n, track): Returns the length of the longest contiguous subarray of clear segments (\\"C\\") in the given track. :param n: Number of segments in the track. :param track: String representing the track with \\"C\\" for clear and \\"M\\" for muddy segments. :return: Integer representing the length of the longest contiguous subarray of clear segments. max_length = 0 current_length = 0 for segment in track: if segment == 'C': current_length += 1 else: max_length = max(max_length, current_length) current_length = 0 return max(max_length, current_length) def process_test_cases(t, test_cases): Process multiple test cases to find the longest contiguous subarray of clear segments for each. :param t: Number of test cases. :param test_cases: List of Tuples where each tuple contains an integer n and a string track. :return: List of integers where each integer is the length of the longest contiguous subarray of clear segments. results = [] for n, track in test_cases: results.append(longest_clear_segment(n, track)) return results"},{"question":"from collections import deque import heapq class QuadProcessor: A class that maintains a data stream and can efficiently perform operations insert, delete, find_min, and find_max. def __init__(self): self.stream = deque() self.min_heap = [] self.max_heap = [] self.removed_from_min = {} self.removed_from_max = {} def insert(self, x): Inserts the integer \`x\` into the data stream. def delete(self): Deletes the oldest integer from the data stream. def find_min(self): Returns the minimum integer currently in the data stream, or \`None\` if the stream is empty. def find_max(self): Returns the maximum integer currently in the data stream, or \`None\` if the stream is empty. # Unit Tests def test_insert_and_find_min_max(): qp = QuadProcessor() qp.insert(5) qp.insert(3) qp.insert(7) qp.insert(10) assert qp.find_min() == 3 assert qp.find_max() == 10 def test_delete_and_find_min_max(): qp = QuadProcessor() qp.insert(5) qp.insert(3) qp.insert(7) qp.insert(10) qp.delete() assert qp.find_min() == 3 qp.delete() assert qp.find_max() == 10 def test_combined_operations(): qp = QuadProcessor() qp.insert(5) qp.insert(3) qp.insert(7) qp.insert(10) qp.delete() assert qp.find_min() == 3 qp.delete() assert qp.find_max() == 10 qp.insert(2) assert qp.find_min() == 2 assert qp.find_max() == 10 def test_empty_find_operations(): qp = QuadProcessor() assert qp.find_min() == None assert qp.find_max() == None def test_delete_until_empty(): qp = QuadProcessor() qp.insert(5) qp.insert(3) qp.insert(7) qp.insert(10) qp.delete() qp.delete() qp.delete() qp.delete() assert qp.find_min() == None assert qp.find_max() == None qp.insert(4) assert qp.find_min() == 4 assert qp.find_max() == 4 qp.delete() assert qp.find_min() == None assert qp.find_max() == None","solution":"from collections import deque import heapq class QuadProcessor: def __init__(self): self.stream = deque() self.min_heap = [] self.max_heap = [] self.removed_from_min = {} self.removed_from_max = {} def insert(self, x): self.stream.append(x) heapq.heappush(self.min_heap, x) heapq.heappush(self.max_heap, -x) def delete(self): if self.stream: oldest = self.stream.popleft() self.removed_from_min[oldest] = self.removed_from_min.get(oldest, 0) + 1 self.removed_from_max[oldest] = self.removed_from_max.get(oldest, 0) + 1 def find_min(self): while self.min_heap and self.removed_from_min.get(self.min_heap[0], 0) > 0: self.removed_from_min[self.min_heap[0]] -= 1 if self.removed_from_min[self.min_heap[0]] == 0: del self.removed_from_min[self.min_heap[0]] heapq.heappop(self.min_heap) return self.min_heap[0] if self.min_heap else None def find_max(self): while self.max_heap and self.removed_from_max.get(-self.max_heap[0], 0) > 0: self.removed_from_max[-self.max_heap[0]] -= 1 if self.removed_from_max[-self.max_heap[0]] == 0: del self.removed_from_max[-self.max_heap[0]] heapq.heappop(self.max_heap) return -self.max_heap[0] if self.max_heap else None"},{"question":"def apply_operations(n: int, q: int, array: List[int], operations: List[Tuple[str, int, int, int]]) -> List[int]: Perform a series of operations (addition or multiplication) on subarrays. Parameters: n (int): The number of elements in the array. q (int): The number of operations to perform. array (List[int]): The array of integers. operations (List[Tuple[str, int, int, int]]): A list of operations in the format (\\"type\\", l, r, v) where \\"type\\" is either \\"add\\" or \\"multiply\\", l and r are the indices of the subarray, and v is the value to add or multiply. Returns: List[int]: The final state of the array after all operations are applied. >>> apply_operations(10, 3, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [('add', 1, 5, 10), ('multiply', 3, 7, 2), ('add', 6, 10, 5)]) [11, 12, 26, 28, 30, 22, 29, 21, 14, 15] >>> apply_operations(5, 3, [1, 2, 3, 4, 5], [('add', 1, 3, 2), ('add', 2, 5, 1), ('add', 4, 5, 3)]) [3, 5, 6, 8, 9] >>> apply_operations(5, 2, [2, 3, 4, 5, 6], [('multiply', 1, 3, 2), ('multiply', 3, 5, 3)]) [4, 6, 24, 15, 18] >>> apply_operations(1, 2, [5], [('add', 1, 1, 3), ('multiply', 1, 1, 2)]) [16]","solution":"def apply_operations(n, q, array, operations): for operation in operations: op_type, l, r, v = operation if op_type == 'add': for i in range(l-1, r): array[i] += v elif op_type == 'multiply': for i in range(l-1, r): array[i] *= v return array"},{"question":"from typing import List, Tuple, Dict def group_participants_by_hour(n: int, participant_data: List[Tuple[int, str]]) -> Dict[str, List[int]]: Group participants by the hour of registration and return these groups. :param n: Number of participants :param participant_data: List of tuples where each tuple contains participant ID and a registration timestamp :return: Dictionary with registration hours as keys and lists of participant IDs as values >>> group_participants_by_hour(5, [(1, '2023-10-01 14:23:34'), (2, '2023-10-01 14:45:22'), (3, '2023-10-01 15:05:10'), (4, '2023-10-01 14:12:56'), (5, '2023-10-01 15:27:43')]) {'2023-10-01 14:00:00': [1, 2, 4], '2023-10-01 15:00:00': [3, 5]} >>> group_participants_by_hour(1, [(1, '2023-10-01 14:23:34')]) {'2023-10-01 14:00:00': [1]} >>> group_participants_by_hour(2, [(1, '2023-10-01 23:59:59'), (2, '2023-10-02 00:00:01')]) {'2023-10-01 23:00:00': [1], '2023-10-02 00:00:00': [2]} >>> group_participants_by_hour(3, [(1, '2023-10-01 14:23:34'), (2, '2023-10-02 14:45:22'), (3, '2023-10-03 15:05:10')]) {'2023-10-01 14:00:00': [1], '2023-10-02 14:00:00': [2], '2023-10-03 15:00:00': [3]} >>> group_participants_by_hour(0, []) {}","solution":"def group_participants_by_hour(n, participant_data): from collections import defaultdict # Dictionary to hold groups of participants by hour groups = defaultdict(list) for participant_id, timestamp in participant_data: # Extract the hour part of the timestamp hour = timestamp[:13] + \\":00:00\\" # Add participant ID to the appropriate hour group groups[hour].append(participant_id) return dict(groups)"},{"question":"def find_cycle_or_longest_path(n, m, roads): You are given a long unidirectional road with n intersections and m one-way roads connecting some of these intersections. Determine whether it is possible to start from any intersection and eventually get back to the starting intersection (find a cycle). If no such cycle exists, output the longest path that can be traversed starting from any intersection, without revisiting any intersection. The first line contains two integers n and m (2  n  10^4, 1  m  5  10^4)  the number of intersections and the number of one-way roads, respectively. Each of the next m lines contains two space-separated integers u and v (1  u, v  n) indicating that there is a one-way road from intersection u to intersection v. There's a guarantee that there are no duplicate roads and there are no roads that start and end at the same intersection. Example: Input: 4 4 1 2 2 3 3 4 4 2 Output: 1 2 3 4 2 Input: 5 4 1 2 2 3 3 4 4 5 Output: 2 5 1 2 3 4 5 # Your code here from solution import find_cycle_or_longest_path def test_case_1(): roads = [ (1, 2), (2, 3), (3, 4), (4, 2) ] find_cycle_or_longest_path(4, 4, roads) def test_case_2(): roads = [ (1, 2), (2, 3), (3, 4), (4, 5) ] find_cycle_or_longest_path(5, 4, roads) def test_case_3(): roads = [ (1, 2), (2, 3), (3, 4), (1, 3) ] find_cycle_or_longest_path(4, 4, roads) def test_case_4(): roads = [ (1, 2), (2, 3), (3, 4), (4, 5), (5, 1) ] find_cycle_or_longest_path(5, 5, roads) def test_case_5(): roads = [ (1, 2), (2, 1), (2, 3) ] find_cycle_or_longest_path(3, 3, roads)","solution":"from collections import defaultdict, deque def find_cycle_or_longest_path(n, m, roads): def detect_cycle(): visited = [False] * (n + 1) stack = [False] * (n + 1) parent = [-1] * (n + 1) def dfs(v): visited[v] = True stack[v] = True for neighbour in graph[v]: if not visited[neighbour]: parent[neighbour] = v if dfs(neighbour): return True elif stack[neighbour]: # To capture the cycle cycle = [] node = v while node != neighbour: cycle.append(node) node = parent[node] cycle.append(neighbour) cycle.append(v) cycle.reverse() print(\\"1\\") print(' '.join(map(str, cycle))) return True stack[v] = False return False for i in range(1, n + 1): if not visited[i]: if dfs(i): return True return False def longest_path(): topo_sort = [] visited = [False] * (n + 1) def topo_sort_dfs(v): visited[v] = True for neighbour in graph[v]: if not visited[neighbour]: topo_sort_dfs(neighbour) topo_sort.append(v) for i in range(1, n + 1): if not visited[i]: topo_sort_dfs(i) topo_sort.reverse() dist = [-1] * (n + 1) dist[topo_sort[0]] = 0 longest_path_parent = [-1] * (n + 1) for u in topo_sort: if dist[u] != -1: for v in graph[u]: if dist[v] < dist[u] + 1: dist[v] = dist[u] + 1 longest_path_parent[v] = u max_distance = max(dist) end_node = dist.index(max_distance) path = [] while end_node != -1: path.append(end_node) end_node = longest_path_parent[end_node] path.reverse() print(\\"2\\") print(max_distance) print(\\" \\".join(map(str, path))) graph = defaultdict(list) for u, v in roads: graph[u].append(v) if not detect_cycle(): longest_path()"},{"question":"def has_pair_with_sum(arr: List[int], target: int) -> bool: Determine if there exists a pair of elements in the array such that their sum is equal to target. Parameters: arr (list[int]): Array of integers. target (int): Target sum. Returns: bool: True if such a pair exists, False otherwise. # Your implementation here # Unit Test def test_pair_found(): assert has_pair_with_sum([1, 2, 3, 4, 5], 9) == True def test_pair_not_found(): assert has_pair_with_sum([1, 2, 5, 7], 10) == False def test_empty_array(): assert has_pair_with_sum([], 5) == False def test_single_element(): assert has_pair_with_sum([1], 2) == False def test_contains_negative_numbers(): assert has_pair_with_sum([-1, -2, 3, 4], 2) == True assert has_pair_with_sum([-1, -2, 3, 4], -3) == True def test_large_numbers(): assert has_pair_with_sum([1, 2, 3, 1000000000, 1000000000], 2000000000) == True def test_duplicate_elements(): assert has_pair_with_sum([1, 2, 3, 3, 4], 6) == True assert has_pair_with_sum([1, 2, 2, 3, 4], 4) == True assert has_pair_with_sum([1, 1], 2) == True","solution":"def has_pair_with_sum(arr, target): Determine if there exists a pair of elements in the array such that their sum is equal to target. Parameters: arr (list[int]): Array of integers. target (int): Target sum. Returns: bool: True if such a pair exists, False otherwise. seen = set() for num in arr: if target - num in seen: return True seen.add(num) return False"},{"question":"def max_gold_coins(m: int, n: int, grid: List[List[int]]) -> int: Returns the maximum number of gold coins that can be collected from the top-left to the bottom-right of the grid. Args: m (int): number of rows in the labyrinth. n (int): number of columns in the labyrinth. grid (List[List[int]]): 2D list containing the number of gold coins in each cell. Returns: int: maximum number of gold coins Captain Shogun can collect. >>> max_gold_coins(3, 3, [[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 12 >>> max_gold_coins(1, 1, [[10]]) 10 def parse_input(input_str: str) -> Tuple[int, int, List[List[int]]]: Parses the input string and returns the number of rows, number of columns, and the grid of gold coins. Args: input_str (str): input string containing the labyrinth information. Returns: Tuple[int, int, List[List[int]]]: number of rows, number of columns, and the 2D list of the grid. >>> parse_input(\\"3 3n1 3 1n1 5 1n4 2 1\\") (3, 3, [[1, 3, 1], [1, 5, 1], [4, 2, 1]]) >>> parse_input(\\"1 1n10\\") (1, 1, [[10]]) from solution import max_gold_coins, parse_input def test_example_case(): input_str = \\"3 3n1 3 1n1 5 1n4 2 1\\" m, n, grid = parse_input(input_str) assert max_gold_coins(m, n, grid) == 12 def test_smallest_grid(): input_str = \\"1 1n10\\" m, n, grid = parse_input(input_str) assert max_gold_coins(m, n, grid) == 10 def test_all_zeros(): input_str = \\"3 3n0 0 0n0 0 0n0 0 0\\" m, n, grid = parse_input(input_str) assert max_gold_coins(m, n, grid) == 0 def test_all_ones(): input_str = \\"4 4n1 1 1 1n1 1 1 1n1 1 1 1n1 1 1 1\\" m, n, grid = parse_input(input_str) assert max_gold_coins(m, n, grid) == 7 def test_single_row(): input_str = \\"1 5n1 2 3 4 5\\" m, n, grid = parse_input(input_str) assert max_gold_coins(m, n, grid) == 15 def test_single_column(): input_str = \\"5 1n1n2n3n4n5\\" m, n, grid = parse_input(input_str) assert max_gold_coins(m, n, grid) == 15","solution":"def max_gold_coins(m, n, grid): Returns the maximum number of gold coins that can be collected from the top-left to the bottom-right of the grid. # Create a 2D list to store the maximum coins collected up to each cell dp = [[0] * n for _ in range(m)] # Initialize the dp array with the first cell value dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column (can only come from above) for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp array for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The bottom-right cell contains the maximum coins collectible return dp[m-1][n-1] def parse_input(input_str): lines = input_str.strip().split('n') m, n = map(int, lines[0].strip().split()) grid = [list(map(int, line.strip().split())) for line in lines[1:]] return m, n, grid"},{"question":"from typing import List, Tuple, Dict def assign_tasks(m: int, workers_tasks: List[List[int]], incoming_tasks: List[Tuple[int, int]]) -> Dict[int, List[int]]: Assign incoming tasks to workers based on their expertise and in a round-robin fashion. Args: m: An integer representing the number of workers. workers_tasks: A list of lists, where each inner list contains the task types that a worker can handle. incoming_tasks: A list of tuples, where each tuple contains a task type and a task id. Returns: A dictionary where each key is a worker index (1 to m) and each value is a list of task ids assigned to that worker. Examples: >>> assign_tasks(3, [[1, 2], [1], [2, 3]], [(1, 101), (2, 102), (1, 103), (3, 104), (2, 105)]) {1: [101, 102], 2: [103], 3: [104, 105]} >>> assign_tasks(1, [[1, 2, 3]], [(1, 101), (2, 102), (3, 103)]) {1: [101, 102, 103]} >>> assign_tasks(2, [[1], [1]], [(1, 101), (1, 102), (1, 103)]) {1: [101, 103], 2: [102]} >>> assign_tasks(2, [[1, 2], [1]], []) {1: [], 2: []} >>> assign_tasks(2, [[1], [2]], [(3, 101)]) {1: [], 2: []} # Unit tests to validate the solution def test_assign_tasks_example_case(): m = 3 workers_tasks = [ [1, 2], [1], [2, 3] ] incoming_tasks = [ (1, 101), (2, 102), (1, 103), (3, 104), (2, 105) ] expected_output = { 1: [101, 102], 2: [103], 3: [104, 105] } assert assign_tasks(m, workers_tasks, incoming_tasks) == expected_output def test_assign_tasks_single_worker_multiple_types(): m = 1 workers_tasks = [ [1, 2, 3] ] incoming_tasks = [ (1, 101), (2, 102), (3, 103) ] expected_output = { 1: [101, 102, 103] } assert assign_tasks(m, workers_tasks, incoming_tasks) == expected_output def test_assign_tasks_multiple_workers_single_type(): m = 2 workers_tasks = [ [1], [1] ] incoming_tasks = [ (1, 101), (1, 102), (1, 103) ] expected_output = { 1: [101, 103], 2: [102] } assert assign_tasks(m, workers_tasks, incoming_tasks) == expected_output def test_assign_tasks_empty_incoming_tasks(): m = 2 workers_tasks = [ [1, 2], [1] ] incoming_tasks = [] expected_output = { 1: [], 2: [] } assert assign_tasks(m, workers_tasks, incoming_tasks) == expected_output def test_assign_tasks_no_eligible_worker(): m = 2 workers_tasks = [ [1], [2] ] incoming_tasks = [ (3, 101) ] expected_output = { 1: [], 2: [] } assert assign_tasks(m, workers_tasks, incoming_tasks) == expected_output","solution":"from typing import List, Tuple, Dict from collections import defaultdict, deque def assign_tasks(m: int, workers_tasks: List[List[int]], incoming_tasks: List[Tuple[int, int]]) -> Dict[int, List[int]]: task_to_workers = defaultdict(deque) # Mapping tasks to eligible workers in a deque for round-robin assignment for worker_index in range(m): for task_type in workers_tasks[worker_index]: task_to_workers[task_type].append(worker_index + 1) # Assign tasks assigned_tasks = {i+1: [] for i in range(m)} for task_type, task_id in incoming_tasks: if task_type in task_to_workers and task_to_workers[task_type]: worker = task_to_workers[task_type].popleft() assigned_tasks[worker].append(task_id) task_to_workers[task_type].append(worker) return assigned_tasks"},{"question":"def highest_sale_per_day(transactions): Write a function that processes a log of transactions to find the item with the highest sale value for each day. You are given a list of transactions, where each transaction is represented by a tuple containing the datetime of the transaction, the name of the item, and the sale value of the item. The datetime is in the format \\"YYYY-MM-DD HH:MM:SS\\". Your task is to parse this list and determine the item with the highest sale value for each day. Input: - A list of tuples, each containing: - datetime string in the format \\"YYYY-MM-DD HH:MM:SS\\" - item name (string) - sale value (float, can be positive or negative) Output: - A dictionary where each key is a date (string in format \\"YYYY-MM-DD\\") and the value is a tuple (item name, sale value) representing the item with the highest sale value for that day. >>> transactions = [ ... (\\"2023-01-01 14:23:45\\", \\"ItemA\\", 100.5), ... (\\"2023-01-01 05:12:20\\", \\"ItemB\\", 150.75), ... (\\"2023-01-02 09:15:00\\", \\"ItemA\\", 200.0), ... (\\"2023-01-02 10:45:35\\", \\"ItemC\\", 199.99), ... ] >>> highest_sale_per_day(transactions) {\\"2023-01-01\\": (\\"ItemB\\", 150.75), \\"2023-01-02\\": (\\"ItemA\\", 200.0)} pass def test_highest_sale_per_day_single_transaction(): transactions = [ (\\"2023-01-01 14:23:45\\", \\"ItemA\\", 100.5) ] expected = { \\"2023-01-01\\": (\\"ItemA\\", 100.5) } assert highest_sale_per_day(transactions) == expected def test_highest_sale_per_day_multiple_days(): transactions = [ (\\"2023-01-01 14:23:45\\", \\"ItemA\\", 100.5), (\\"2023-01-01 05:12:20\\", \\"ItemB\\", 150.75), (\\"2023-01-02 09:15:00\\", \\"ItemA\\", 200.0), (\\"2023-01-02 10:45:35\\", \\"ItemC\\", 199.99), ] expected = { \\"2023-01-01\\": (\\"ItemB\\", 150.75), \\"2023-01-02\\": (\\"ItemA\\", 200.0) } assert highest_sale_per_day(transactions) == expected def test_highest_sale_per_day_duplicate_values(): transactions = [ (\\"2023-01-01 14:23:45\\", \\"ItemA\\", 100.5), (\\"2023-01-01 14:23:45\\", \\"ItemB\\", 100.5), (\\"2023-01-02 09:15:00\\", \\"ItemA\\", 200.0), (\\"2023-01-02 10:45:35\\", \\"ItemB\\", 200.0), ] expected = { \\"2023-01-01\\": (\\"ItemA\\", 100.5), # or ItemB \\"2023-01-02\\": (\\"ItemA\\", 200.0) # or ItemB } assert highest_sale_per_day(transactions) == expected def test_highest_sale_per_day_with_negative_values(): transactions = [ (\\"2023-01-01 14:23:45\\", \\"ItemA\\", 100.5), (\\"2023-01-01 14:23:45\\", \\"ItemB\\", -20.0), (\\"2023-01-01 14:23:45\\", \\"ItemC\\", 50.0), (\\"2023-01-02 09:15:00\\", \\"ItemA\\", -200.0), (\\"2023-01-02 10:45:35\\", \\"ItemB\\", -150.0), ] expected = { \\"2023-01-01\\": (\\"ItemA\\", 100.5), \\"2023-01-02\\": (\\"ItemB\\", -150.0) } assert highest_sale_per_day(transactions) == expected def test_highest_sale_per_day_same_day(): transactions = [ (\\"2023-01-01 14:23:45\\", \\"ItemA\\", 100.5), (\\"2023-01-01 13:10:20\\", \\"ItemB\\", 200.0), (\\"2023-01-01 18:30:10\\", \\"ItemC\\", 50.0), ] expected = { \\"2023-01-01\\": (\\"ItemB\\", 200.0) } assert highest_sale_per_day(transactions) == expected","solution":"def highest_sale_per_day(transactions): Returns a dictionary where each key is a date and the value is a tuple containing the item with the highest sale value for that day. from collections import defaultdict daily_sales = defaultdict(lambda: (None, float('-inf'))) for datetime_str, item, sale_value in transactions: date = datetime_str.split()[0] if sale_value > daily_sales[date][1]: daily_sales[date] = (item, sale_value) return dict(daily_sales)"},{"question":"from typing import List def count_islands(n: int, m: int, grid: List[List[int]]) -> int: Returns the number of distinct islands in the grid. An island is a group of connected 1's (horizontally or vertically connected). >>> n = 4; m = 5; grid = [ ... [1, 1, 0, 0, 0], ... [1, 1, 0, 0, 1], ... [0, 0, 0, 1, 1], ... [0, 0, 0, 0, 0] ...] >>> count_islands(n, m, grid) 2 >>> n = 3; m = 3; grid = [ ... [1, 0, 1], ... [0, 0, 0], ... [1, 0, 1] ...] >>> count_islands(n, m, grid) 4 >>> n = 3; m = 3; grid = [ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ...] >>> count_islands(n, m, grid) 1 >>> n = 3; m = 3; grid = [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ...] >>> count_islands(n, m, grid) 0 >>> n = 3; m = 3; grid = [ ... [1, 0, 0], ... [0, 1, 0], ... [0, 0, 1] ...] >>> count_islands(n, m, grid) 3 >>> n = 4; m = 5; grid = [ ... [1, 1, 0, 0, 0], ... [1, 0, 0, 0, 1], ... [0, 0, 0, 1, 1], ... [0, 1, 0, 0, 0] ...] >>> count_islands(n, m, grid) 3","solution":"def count_islands(n, m, grid): Return the number of distinct islands in the grid. An island is a group of connected 1's (horizontally or vertically connected). def dfs(x, y): # Boundary and base case checks if x < 0 or x >= n or y < 0 or y >= m or grid[x][y] == 0: return # Mark the land as visited grid[x][y] = 0 # Traverse all four possible directions (up, down, left, right) dfs(x + 1, y) dfs(x - 1, y) dfs(x, y + 1) dfs(x, y - 1) island_count = 0 for i in range(n): for j in range(m): if grid[i][j] == 1: island_count += 1 dfs(i, j) return island_count"},{"question":"def rearrange_even_before_odd(arr: List[int]) -> List[int]: Rearranges the elements of the array such that all even numbers appear before all odd numbers, while maintaining their relative order. :param arr: List of integers :return: List of integers with even numbers before odd numbers Examples: >>> rearrange_even_before_odd([1, 2, 3, 4, 5]) [2, 4, 1, 3, 5] >>> rearrange_even_before_odd([4, 2, 7, 3, 8, 6]) [4, 2, 8, 6, 7, 3] >>> rearrange_even_before_odd([1, 3, 5, 7]) [1, 3, 5, 7] from solution import rearrange_even_before_odd def test_example_1(): result = rearrange_even_before_odd([1, 2, 3, 4, 5]) expected = [2, 4, 1, 3, 5] assert result == expected def test_example_2(): result = rearrange_even_before_odd([4, 2, 7, 3, 8, 6]) expected = [4, 2, 8, 6, 7, 3] assert result == expected def test_example_3(): result = rearrange_even_before_odd([1, 3, 5, 7]) expected = [1, 3, 5, 7] assert result == expected def test_single_element(): result = rearrange_even_before_odd([2]) expected = [2] assert result == expected def test_all_even_numbers(): result = rearrange_even_before_odd([2, 4, 6, 8]) expected = [2, 4, 6, 8] assert result == expected def test_all_odd_numbers(): result = rearrange_even_before_odd([1, 3, 5, 7]) expected = [1, 3, 5, 7] assert result == expected def test_empty_array(): result = rearrange_even_before_odd([]) expected = [] assert result == expected def test_mixed_numbers(): result = rearrange_even_before_odd([10, 2, 3, 7, 4, 5, 8, 6]) expected = [10, 2, 4, 8, 6, 3, 7, 5] assert result == expected","solution":"def rearrange_even_before_odd(arr): Rearranges the elements of the array such that all even numbers appear before all odd numbers, while maintaining their relative order. :param arr: List of integers :return: List of integers with even numbers before odd numbers even_numbers = [num for num in arr if num % 2 == 0] odd_numbers = [num for num in arr if num % 2 != 0] return even_numbers + odd_numbers"},{"question":"from typing import List, Tuple def can_make_all_elements_one(test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine if it's possible to make all elements of the list equal to 1 after performing any number of specified operations. >>> can_make_all_elements_one([(3, [4, 6, 8])]) [\\"NO\\"] >>> can_make_all_elements_one([(5, [2, 3, 5, 7, 11])]) [\\"YES\\"] >>> can_make_all_elements_one([(4, [9, 18, 27, 36])]) [\\"NO\\"] from solution import can_make_all_elements_one def test_case_1(): result = can_make_all_elements_one([(3, [4, 6, 8])]) assert result == [\\"NO\\"] def test_case_2(): result = can_make_all_elements_one([(5, [2, 3, 5, 7, 11])]) assert result == [\\"YES\\"] def test_case_3(): result = can_make_all_elements_one([(4, [9, 18, 27, 36])]) assert result == [\\"NO\\"] def test_multiple_cases(): result = can_make_all_elements_one([ (3, [4, 6, 8]), (5, [2, 3, 5, 7, 11]), (4, [9, 18, 27, 36]) ]) assert result == [\\"NO\\", \\"YES\\", \\"NO\\"] def test_single_element(): result = can_make_all_elements_one([(1, [1])]) assert result == [\\"YES\\"] def test_all_elements_same_and_one(): result = can_make_all_elements_one([(5, [1, 1, 1, 1, 1])]) assert result == [\\"YES\\"] def test_all_elements_same_not_one(): result = can_make_all_elements_one([(3, [6, 6, 6])]) assert result == [\\"NO\\"] def test_mix_gcd_one_and_others(): result = can_make_all_elements_one([(4, [6, 10, 15, 2])]) assert result == [\\"YES\\"]","solution":"import math from functools import reduce def can_make_all_elements_one(test_cases): results = [] for n, arr in test_cases: gcd_all = reduce(math.gcd, arr) if gcd_all == 1: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"from typing import List, Tuple def are_permutations(s: str, t: str) -> str: Determine if strings s and t are permutations of each other. Args: s (str): first string t (str): second string Returns: str: \\"YES\\" if s and t are permutations of each other, otherwise \\"NO\\" def process_test_cases(q: int, test_cases: List[Tuple[str, str]]) -> List[str]: Process multiple test cases to determine if pairs of strings are permutations of each other. Args: q (int): number of test cases test_cases (List[Tuple[str, str]]): List of tuples, each containing two strings to be tested Returns: List[str]: List of \\"YES\\" or \\"NO\\" results for each test case. # Unit tests def test_are_permutations(): assert are_permutations('abc', 'cba') == \\"YES\\" assert are_permutations('abcd', 'dcba') == \\"YES\\" assert are_permutations('abc', 'def') == \\"NO\\" assert are_permutations('a', 'a') == \\"YES\\" assert are_permutations('a', 'b') == \\"NO\\" assert are_permutations('listen', 'silent') == \\"YES\\" assert are_permutations('triangle', 'integral') == \\"YES\\" assert are_permutations('apple', 'papel') == \\"YES\\" assert are_permutations('rat', 'car') == \\"NO\\" def test_process_test_cases(): input_test_cases = [ ('abc', 'cba'), ('abcd', 'dcba'), ('abc', 'def'), ] expected_output = [\\"YES\\", \\"YES\\", \\"NO\\"] assert process_test_cases(3, input_test_cases) == expected_output input_test_cases = [ ('a', 'a'), ('a', 'b'), ('listen', 'silent'), ] expected_output = [\\"YES\\", \\"NO\\", \\"YES\\"] assert process_test_cases(3, input_test_cases) == expected_output input_test_cases = [ ('triangle', 'integral'), ('apple', 'papel'), ('rat', 'car'), ] expected_output = [\\"YES\\", \\"YES\\", \\"NO\\"] assert process_test_cases(3, input_test_cases) == expected_output","solution":"def are_permutations(s, t): Determine if strings s and t are permutations of each other. Args: s (str): first string t (str): second string Returns: str: \\"YES\\" if s and t are permutations of each other, otherwise \\"NO\\" if sorted(s) == sorted(t): return \\"YES\\" else: return \\"NO\\" def process_test_cases(q, test_cases): results = [] for s, t in test_cases: results.append(are_permutations(s, t)) return results"},{"question":"def battle_game(player1, player2): Simulates a turn-based text-based battle game between two characters. Each player dictionary has the following structure: { \\"name\\": \\"Player1\\", \\"hp\\": 100, \\"attack_power\\": 20, \\"special_used\\": False # initially set to False, should be updated to True after special ability is used } The function should print each move in the following format: Player1 attacks Player2: Player2 HP is now <new_hp>. Player2 uses special ability: Player2 HP is now <new_hp>. After the game ends, the function should print the winner in the following format: Player1 wins! If the game ends in a draw, it should print: It's a draw! from solution import battle_game def test_battle_game(): player1 = { \\"name\\": \\"Player1\\", \\"hp\\": 100, \\"attack_power\\": 20, \\"special_used\\": False } player2 = { \\"name\\": \\"Player2\\", \\"hp\\": 90, \\"attack_power\\": 25, \\"special_used\\": False } battle_game(player1, player2) # Expected Output: # Player1 attacks Player2: Player2 HP is now 70. # Player2 attacks Player1: Player1 HP is now 75. # Player1 attacks Player2: Player2 HP is now 50. # Player2 uses special ability: Player2 HP is now 100. # Player1 attacks Player2: Player2 HP is now 80. # Player2 attacks Player1: Player1 HP is now 50. # Player1 uses special ability: Player2 HP is now 1. # Player2 attacks Player1: Player1 HP is now 25. # Player1 attacks Player2: Player2 HP is now 0. # Player1 wins! def test_draw_game(): player1 = { \\"name\\": \\"Player1\\", \\"hp\\": 1, \\"attack_power\\": 2, \\"special_used\\": False } player2 = { \\"name\\": \\"Player2\\", \\"hp\\": 1, \\"attack_power\\": 2, \\"special_used\\": False } battle_game(player1, player2) # Expected Output: # Player1 attacks Player2: Player2 HP is now -1. # It's a draw!","solution":"def battle_game(player1, player2): Simulates a turn-based text-based battle game between two characters. turn = 0 while player1[\\"hp\\"] > 0 and player2[\\"hp\\"] > 0: attacker = player1 if turn % 2 == 0 else player2 defender = player2 if turn % 2 == 0 else player1 use_special = False if not attacker[\\"special_used\\"]: if attacker[\\"name\\"] == \\"Player1\\": use_special = True elif attacker[\\"name\\"] == \\"Player2\\": if attacker[\\"hp\\"] <= defender[\\"hp\\"]: use_special = True if use_special and not attacker[\\"special_used\\"]: if attacker[\\"name\\"] == \\"Player1\\": defender[\\"hp\\"] = 1 print(f'{attacker[\\"name\\"]} uses special ability: {defender[\\"name\\"]} HP is now {defender[\\"hp\\"]}.') elif attacker[\\"name\\"] == \\"Player2\\": attacker[\\"hp\\"] *= 2 print(f'{attacker[\\"name\\"]} uses special ability: {attacker[\\"hp\\"]}.') attacker[\\"special_used\\"] = True else: defender[\\"hp\\"] -= attacker[\\"attack_power\\"] print(f'{attacker[\\"name\\"]} attacks {defender[\\"name\\"]}: {defender[\\"name\\"]} HP is now {defender[\\"hp\\"]}.') turn += 1 if player1[\\"hp\\"] <= 0 and player2[\\"hp\\"] <= 0: print(\\"It's a draw!\\") elif player1[\\"hp\\"] <= 0: print(f'{player2[\\"name\\"]} wins!') else: print(f'{player1[\\"name\\"]} wins!')"},{"question":"from typing import List def unique_paths(grid: List[List[int]]) -> int: Returns the number of distinct paths from the top-left corner to the bottom-right corner following the rules: only move right or down, and cannot move into blocked cells (1s). >>> unique_paths([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) 2 >>> unique_paths([ ... [0, 1], ... [1, 0] ... ]) 0 pass def test_unique_paths_basic(): grid = [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ] assert unique_paths(grid) == 2 def test_unique_paths_no_path(): grid = [ [0, 1], [1, 0] ] assert unique_paths(grid) == 0 def test_unique_paths_single_cell(): grid = [ [0] ] assert unique_paths(grid) == 1 def test_unique_paths_all_open(): In a 2x2 grid that's all open, there should be 2 paths (Right-Down, Down-Right) In a 3x3 grid that's all open, there should be 6 paths grid_2x2 = [ [0, 0], [0, 0] ] assert unique_paths(grid_2x2) == 2 grid_3x3 = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert unique_paths(grid_3x3) == 6 def test_unique_paths_only_start_open(): grid = [ [0, 1], [1, 1] ] assert unique_paths(grid) == 0 def test_unique_paths_only_end_open(): grid = [ [1, 1], [1, 0] ] assert unique_paths(grid) == 0 def test_unique_paths_large_grid(): grid = [[0]*100 for _ in range(100)] assert unique_paths(grid) > 0 # There should be a large number of paths","solution":"from typing import List def unique_paths(grid: List[List[int]]) -> int: Returns the number of distinct paths from the top-left corner to the bottom-right corner Following the rules: only move right or down, and cannot move into blocked cells (1s). # check if the start or end is blocked if grid[0][0] == 1 or grid[-1][-1] == 1: return 0 n = len(grid) # dp array to store the number of ways to reach each cell dp = [[0] * n for _ in range(n)] # Starting point dp[0][0] = 1 for i in range(n): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 # blocked cells do not have any paths else: if i > 0: dp[i][j] += dp[i-1][j] # if not the first row, add the value from the cell above if j > 0: dp[i][j] += dp[i][j-1] # if not the first column, add the value from the cell to the left # The bottom-right corner will contain the number of ways to reach the end return dp[-1][-1]"},{"question":"from typing import List def find_suspicious_accounts(n: int, transactions: List[List[int]], threshold: int) -> List[int]: Identifies all accounts involved in suspicious transactions. A transaction is suspicious if an account sends or receives more than a specific threshold amount in total transactions. Parameters: n (int): The number of transactions. transactions (List[List[int]]): A list of transactions, where each transaction is represented as [from, to, amount]. threshold (int): The threshold value for detecting suspicious transactions. Returns: List[int]: A list of all unique account numbers involved in suspicious transactions sorted in ascending order. Example: >>> find_suspicious_accounts( 5, [ [1, 2, 1500], [2, 3, 1200], [3, 1, 800], [1, 3, 5000], [3, 4, 300] ], 2500 ) [1, 2, 3] pass # Unit tests def test_example_case(): assert find_suspicious_accounts( 5, [ [1, 2, 1500], [2, 3, 1200], [3, 1, 800], [1, 3, 5000], [3, 4, 300] ], 2500 ) == [1, 2, 3] def test_no_suspicious_accounts(): assert find_suspicious_accounts( 3, [ [1, 2, 500], [2, 3, 400], [3, 1, 300] ], 2000 ) == [] def test_single_suspicious_account(): assert find_suspicious_accounts( 2, [ [1, 2, 1000], [2, 1, 1000] ], 1500 ) == [1, 2] def test_all_suspicious_accounts(): assert find_suspicious_accounts( 3, [ [1, 2, 500], [2, 3, 1500], [3, 1, 2000] ], 500 ) == [1, 2, 3] def test_large_threshold(): assert find_suspicious_accounts( 4, [ [1, 2, 100], [2, 3, 200], [3, 4, 300], [4, 1, 400] ], 1000 ) == []","solution":"from typing import List def find_suspicious_accounts(n: int, transactions: List[List[int]], threshold: int) -> List[int]: account_sums = {} for from_acc, to_acc, amount in transactions: if from_acc in account_sums: account_sums[from_acc] += amount else: account_sums[from_acc] = amount if to_acc in account_sums: account_sums[to_acc] += amount else: account_sums[to_acc] = amount suspicious_accounts = [acc for acc, total in account_sums.items() if total > threshold] return sorted(suspicious_accounts)"},{"question":"def find_min_edges_to_connect(n: int, m: int, edges: List[Tuple[int, int]]) -> int: Calculate the minimum number of additional connections required to make the garden network fully connected. >>> find_min_edges_to_connect(5, 2, [(1, 2), (3, 4)]) 2 >>> find_min_edges_to_connect(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) 0 >>> find_min_edges_to_connect(5, 1, [(1, 2)]) 3 >>> find_min_edges_to_connect(5, 0, []) 4 >>> find_min_edges_to_connect(1, 0, []) 0 from typing import List, Tuple def test_min_edges_to_connect(): assert find_min_edges_to_connect(5, 2, [(1, 2), (3, 4)]) == 2 assert find_min_edges_to_connect(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) == 0 assert find_min_edges_to_connect(5, 1, [(1, 2)]) == 3 assert find_min_edges_to_connect(5, 0, []) == 4 assert find_min_edges_to_connect(1, 0, []) == 0 def test_more_edges(): assert find_min_edges_to_connect(6, 3, [(1, 2), (2, 3), (4, 5)]) == 2 assert find_min_edges_to_connect(7, 5, [(1, 2), (2, 3), (3, 4), (5, 6), (6, 7)]) == 1 assert find_min_edges_to_connect(8, 6, [(1, 2), (2, 3), (3, 4), (5, 6), (6, 7), (7, 8)]) == 1 assert find_min_edges_to_connect(3, 0, []) == 2 assert find_min_edges_to_connect(4, 1, [(1, 2)]) == 2","solution":"def find_min_edges_to_connect(n, m, edges): # Helper function to perform a DFS to find connected components def dfs(node, visited, adjacency_list): stack = [node] while stack: current = stack.pop() if current not in visited: visited.add(current) stack.extend(adjacency_list[current] - visited) if n == 1: return 0 # Create adjacency list adjacency_list = {i: set() for i in range(1, n + 1)} for u, v in edges: adjacency_list[u].add(v) adjacency_list[v].add(u) visited = set() components = 0 # Find all connected components for i in range(1, n + 1): if i not in visited: dfs(i, visited, adjacency_list) components += 1 # The minimum number of edges needed to connect the graph fully is components - 1 return components - 1"},{"question":"def count_page_visits(events, queries): Count the number of visits to a specific page within a given time range. :param events: List of tuples (pi, ti) representing page ID and timestamp. :param queries: List of tuples (pj, tj1, tj2) representing query with page ID and time range. :return: List of integers representing the number of visits for each query. >>> events = [(1, 100), (2, 200), (1, 300), (2, 400), (3, 500)] >>> queries = [(1, 100, 300), (2, 100, 300), (3, 400, 600)] >>> count_page_visits(events, queries) [2, 1, 1] pass # Unit Test def test_example_case(): events = [(1, 100), (2, 200), (1, 300), (2, 400), (3, 500)] queries = [(1, 100, 300), (2, 100, 300), (3, 400, 600)] assert count_page_visits(events, queries) == [2, 1, 1] def test_no_events(): events = [] queries = [(1, 100, 300), (2, 100, 300), (3, 400, 600)] assert count_page_visits(events, queries) == [0, 0, 0] def test_no_visits_in_range(): events = [(1, 100), (1, 200), (2, 300)] queries = [(1, 250, 300), (2, 100, 299), (3, 400, 600)] assert count_page_visits(events, queries) == [0, 0, 0] def test_single_event_and_query(): events = [(1, 150)] queries = [(1, 100, 200)] assert count_page_visits(events, queries) == [1] def test_multiple_events_single_query(): events = [(1, 100), (1, 200), (1, 300), (1, 400)] queries = [(1, 150, 350)] assert count_page_visits(events, queries) == [2] def test_large_time_range(): events = [(1, 1), (1, 999999999)] queries = [(1, 1, 1000000000)] assert count_page_visits(events, queries) == [2]","solution":"def count_page_visits(events, queries): Count the number of visits to a specific page within a given time range. :param events: List of tuples (pi, ti) representing page ID and timestamp. :param queries: List of tuples (pj, tj1, tj2) representing query with page ID and time range. :return: List of integers representing the number of visits for each query. from collections import defaultdict # Dictionary to store visits by page ID page_visits = defaultdict(list) # Populate the dictionary with page visits for pi, ti in events: page_visits[pi].append(ti) # Sort timestamps for each page for efficient range counting for page_id in page_visits: page_visits[page_id].sort() # Function to count the visits in the interval [low, high] def count_in_interval(timestamps, low, high): # Using binary search technique to find bounds from bisect import bisect_left, bisect_right start = bisect_left(timestamps, low) end = bisect_right(timestamps, high) return end - start results = [] # Evaluate each query for pj, tj1, tj2 in queries: if pj in page_visits: count = count_in_interval(page_visits[pj], tj1, tj2) else: count = 0 results.append(count) return results # Example usage: events = [(1, 100), (2, 200), (1, 300), (2, 400), (3, 500)] queries = [(1, 100, 300), (2, 100, 300), (3, 400, 600)] print(count_page_visits(events, queries)) # Output: [2, 1, 1]"},{"question":"from collections import defaultdict, deque import math def preprocess_lca(n, edges): LOG = math.ceil(math.log2(n)) + 1 parent = [[-1] * LOG for _ in range(n + 1)] depth = [0] * (n + 1) graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) def dfs(v, p): for u in graph[v]: if u == p: continue parent[u][0] = v depth[u] = depth[v] + 1 dfs(u, v) # Initializing depth array and parent for the node 1 dfs(1, -1) for i in range(1, LOG): for v in range(1, n + 1): if parent[v][i - 1] != -1: parent[v][i] = parent[parent[v][i - 1]][i - 1] return parent, depth def lca(u, v, depth, parent): if depth[u] < depth[v]: u, v = v, u LOG = len(parent[0]) for i in range(LOG - 1, -1, -1): if depth[u] - (1 << i) >= depth[v]: u = parent[u][i] if u == v: return u for i in range(LOG - 1, -1, -1): if parent[u][i] != -1 and parent[u][i] != parent[v][i]: u = parent[u][i] v = parent[v][i] return parent[u][0] def solve(n, edges, queries): Solve the Lowest Common Ancestor problem for a given tree. Args: n (int): Number of nodes in the tree. edges (List[Tuple[int, int]]): Edges in the tree. queries (List[Tuple[int, int]]): Queries to find the LCA of two nodes. Returns: List[int]: Result for each query in the form of LCA node. Example: >>> solve(5, [(1, 2), (1, 3), (3, 4), (3, 5)], [(2, 3), (4, 5), (2, 4)]) [1, 3, 1] >>> solve(3, [(1, 2), (1, 3)], [(2, 3)]) [1] parent, depth = preprocess_lca(n, edges) results = [] for u, v in queries: results.append(lca(u, v, depth, parent)) return results","solution":"from collections import defaultdict, deque import sys import math sys.setrecursionlimit(200000) def preprocess_lca(n, edges): LOG = math.ceil(math.log2(n)) + 1 parent = [[-1] * LOG for _ in range(n + 1)] depth = [0] * (n + 1) graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) def dfs(v, p): for u in graph[v]: if u == p: continue parent[u][0] = v depth[u] = depth[v] + 1 dfs(u, v) # Initializing depth array and parent for the node 1 dfs(1, -1) for i in range(1, LOG): for v in range(1, n + 1): if parent[v][i - 1] != -1: parent[v][i] = parent[parent[v][i - 1]][i - 1] return parent, depth def lca(u, v, depth, parent): if depth[u] < depth[v]: u, v = v, u LOG = len(parent[0]) for i in range(LOG - 1, -1, -1): if depth[u] - (1 << i) >= depth[v]: u = parent[u][i] if u == v: return u for i in range(LOG - 1, -1, -1): if parent[u][i] != -1 and parent[u][i] != parent[v][i]: u = parent[u][i] v = parent[v][i] return parent[u][0] def solve(n, edges, queries): parent, depth = preprocess_lca(n, edges) results = [] for u, v in queries: results.append(lca(u, v, depth, parent)) return results"},{"question":"from typing import List, Tuple def manage_drones(w: int, h: int, n: int, drones: List[Tuple[int, int]], m: int, packages: List[Tuple[int, int, int, int, int]]) -> List[Tuple[int, List[Tuple[int, int]]]]: Manage the fleet of drones to deliver packages as quickly as possible. You are responsible for managing a fleet of drones delivering packages within a city. Each drone can carry only one package at a time. Consider the city as a rectangular grid of \`w\` streets and \`h\` avenues with \`w * h\` intersections. The streets are numbered from \`1\` to \`w\`, and the avenues from \`1\` to \`h\`. Each drone can move either horizontally or vertically to an adjacent intersection in one time tick. Any number of drones can occupy the same intersection. At moment \`0\`, you are given the initial positions of \`n\` drones: \`(x1, y1)\`, \`(x2, y2)\`, ...(xn, yn). The number of drones is fixed during the entire simulation. Additionally, there are \`m\` packages to be delivered. Each package has a pickup location and a drop-off location, along with a specific time when the package becomes available for pickup. Each \`i-th\` package is described by four integers: the time \`ti\`, the pickup location \`(pxi, pyi)\`, and the drop-off location \`(dxi, dyi)\`. Your task is to deliver all the packages as quickly as possible by providing movement commands to the drones. For each given command, a drone should either move to an adjacent intersection or pick up/drop off the package if it is at the appropriate location. Each command for a single drone consists of three integers \`(d, a, b)\`, meaning that the drone \`d\` should execute action \`a\` at the location \`(pxi, pyi)\`. Here, \`a\` can be: - \`0\`: Move horizontally (left or right) if necessary - \`1\`: Move vertically (up or down) if necessary - \`2\`: Pick up the package - \`3\`: Drop off the package The simulation follows these steps: 1. Read the city's dimensions \`w\` and \`h\`. 2. Read the number of drones \`n\` and their initial locations. 3. Initialize and print the initial commands for the drones. 4. For each package order: - Suspend the current commands. - Provide new commands for the drones. - Print the new commands. The simulation ends when all packages are delivered and all commands are completed. Parameters: - w: The number of streets. - h: The number of avenues. - n: The number of drones. - drones: A list of tuples representing the initial positions of the drones. - m: The number of packages. - packages: A list of tuples where each tuple represents a package with the available time, pickup location, and drop-off location. >>> w, h = 5, 5 >>> n = 3 >>> drones = [(1, 1), (2, 2), (3, 3)] >>> m = 2 >>> packages = [(1, 2, 2, 4, 5), (3, 3, 3, 1, 1)] >>> manage_drones(w, h, n, drones, m, packages) [(1, [(0, 2), (1, 2), (2, 2, 2), (0, 4), (1, 5), (3, 4, 5)]), (2, [(0, 3), (1, 3), (2, 3, 3), (0, 1), (1, 1), (3, 1, 1)])] def test_manage_drones_basic(): w, h = 5, 5 n = 3 drones = [(1, 1), (2, 2), (3, 3)] m = 2 packages = [(1, 2, 2, 4, 5), (3, 3, 3, 1, 1)] expected_output = [ (1, [(0, 2), (1, 2), (2, 2, 2), (0, 4), (1, 5), (3, 4, 5)]), (2, [(0, 3), (1, 3), (2, 3, 3), (0, 1), (1, 1), (3, 1, 1)]) ] assert manage_drones(w, h, n, drones, m, packages) == expected_output def test_manage_drones_single_drone(): w, h = 5, 5 n = 1 drones = [(1, 1)] m = 1 packages = [(1, 2, 2, 4, 5)] expected_output = [ (0, [(0, 2), (1, 2), (2, 2, 2), (0, 4), (1, 5), (3, 4, 5)]) ] assert manage_drones(w, h, n, drones, m, packages) == expected_output def test_manage_drones_multiple_drones_multiple_packages(): w, h = 10, 10 n = 3 drones = [(1, 1), (5, 5), (9, 9)] m = 2 packages = [(2, 2, 2, 7, 7), (4, 9, 9, 1, 1)] expected_output = [ (0, [(0, 2), (1, 2), (2, 2, 2), (0, 7), (1, 7), (3, 7, 7)]), (2, [(0, 9), (1, 9), (2, 9, 9), (0, 1), (1, 1), (3, 1, 1)]) ] assert manage_drones(w, h, n, drones, m, packages) == expected_output def test_manage_drones_no_packages(): w, h = 5, 5 n = 3 drones = [(1, 1), (2, 2), (3, 3)] m = 0 packages = [] expected_output = [] assert manage_drones(w, h, n, drones, m, packages) == expected_output","solution":"def manage_drones(w, h, n, drones, m, packages): commands = [] for i in range(m): ti, pxi, pyi, dxi, dyi = packages[i] # Find the closest available drone to the pickup location. closest_drone = -1 min_distance = float('inf') for j in range(n): x, y = drones[j] distance = abs(x - pxi) + abs(y - pyi) if distance < min_distance: min_distance = distance closest_drone = j commands.append((closest_drone, [ (0, pxi), (1, pyi), (2, pxi, pyi), (0, dxi), (1, dyi), (3, dxi, dyi) ])) # Move the drone to the drop-off location drones[closest_drone] = (dxi, dyi) return commands"},{"question":"def can_fulfill_orders(n: int, initial_stock: List[int], m: int, orders: List[Tuple[int, int, int]]) -> str: Determines if all customer orders can be fulfilled with the given initial stock. :param n: Number of pastry types. :param initial_stock: List of initial stock quantities for each pastry type. :param m: Number of customer orders. :param orders: List of customer orders where each order is represented by a tuple (li, ri, qi) :return: \\"YES\\" if all orders can be fulfilled, otherwise \\"NO\\". def test_simple_case(): n = 3 initial_stock = [5, 5, 5] m = 1 orders = [(1, 3, 2)] assert can_fulfill_orders(n, initial_stock, m, orders) == \\"YES\\" def test_not_enough_stock(): n = 2 initial_stock = [2, 3] m = 2 orders = [(1, 1, 3), (2, 2, 2)] assert can_fulfill_orders(n, initial_stock, m, orders) == \\"NO\\" def test_multiple_orders_with_sufficient_stock(): n = 4 initial_stock = [10, 10, 10, 10] m = 3 orders = [(1, 2, 5), (3, 4, 5), (1, 4, 2)] assert can_fulfill_orders(n, initial_stock, m, orders) == \\"YES\\" def test_orders_spanning_entire_range(): n = 5 initial_stock = [10, 10, 10, 10, 10] m = 2 orders = [(1, 5, 2), (2, 4, 3)] assert can_fulfill_orders(n, initial_stock, m, orders) == \\"YES\\" def test_insufficient_stock_after_fulfilling_some_orders(): n = 3 initial_stock = [3, 3, 3] m = 2 orders = [(1, 2, 3), (2, 3, 2)] assert can_fulfill_orders(n, initial_stock, m, orders) == \\"NO\\"","solution":"def can_fulfill_orders(n, initial_stock, m, orders): Determines if all customer orders can be fulfilled with the given initial stock. :param n: Number of pastry types. :param initial_stock: List of initial stock quantities for each pastry type. :param m: Number of customer orders. :param orders: List of customer orders where each order is represented by a tuple (li, ri, qi) :return: \\"YES\\" if all orders can be fulfilled, otherwise \\"NO\\". stock = initial_stock[:] for li, ri, qi in orders: for i in range(li-1, ri): if stock[i] < qi: return \\"NO\\" stock[i] -= qi return \\"YES\\""},{"question":"from typing import List, Tuple def solve_bipartite_graphs(test_cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[str]: Determine whether each graph is bipartite. >>> test_cases = [ ... (4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]), ... (3, 3, [(1, 2), (2, 3), (3, 1)]) ... ] >>> solve_bipartite_graphs(test_cases) [\\"YES\\", \\"NO\\"] results = [] for n, m, edges in test_cases: if is_bipartite(n, edges): results.append(\\"YES\\") else: results.append(\\"NO\\") return results def is_bipartite(n: int, edges: List[Tuple[int, int]]) -> str: # Helper function to check if graph is bipartite pass import pytest def test_example_case(): test_cases = [ (4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]), (3, 3, [(1, 2), (2, 3), (3, 1)]) ] expected_results = [\\"YES\\", \\"NO\\"] assert solve_bipartite_graphs(test_cases) == expected_results def test_single_node(): test_cases = [ (1, 0, []) ] expected_results = [\\"YES\\"] assert solve_bipartite_graphs(test_cases) == expected_results def test_no_edges(): test_cases = [ (5, 0, []) ] expected_results = [\\"YES\\"] assert solve_bipartite_graphs(test_cases) == expected_results def test_disconnected_components_bipartite(): test_cases = [ (6, 4, [(1, 2), (3, 4), (4, 5), (5, 6)]) ] expected_results = [\\"YES\\"] assert solve_bipartite_graphs(test_cases) == expected_results def test_disconnected_components_non_bipartite(): test_cases = [ (6, 5, [(1, 2), (2, 3), (3, 1), (4, 5), (5, 6)]) ] expected_results = [\\"NO\\"] assert solve_bipartite_graphs(test_cases) == expected_results def test_complex_bipartite_graph(): test_cases = [ (8, 8, [(1, 2), (1, 3), (2, 4), (3, 4), (5, 6), (5, 7), (6, 8), (7, 8)]) ] expected_results = [\\"YES\\"] assert solve_bipartite_graphs(test_cases) == expected_results","solution":"def is_bipartite(n, edges): from collections import deque def bfs(start_node): queue = deque([start_node]) colors[start_node] = 1 # Start coloring with 1 while queue: node = queue.popleft() current_color = colors[node] next_color = 1 if current_color == 2 else 2 for neighbor in graph[node]: if colors[neighbor] == 0: # If not colored colors[neighbor] = next_color queue.append(neighbor) elif colors[neighbor] == current_color: return False return True graph = [[] for _ in range(n)] for u, v in edges: graph[u - 1].append(v - 1) graph[v - 1].append(u - 1) colors = [0] * n # 0: not colored, 1: color one, 2: color two for node in range(n): if colors[node] == 0: # If not colored yet if not bfs(node): return \\"NO\\" return \\"YES\\" def solve_bipartite_graphs(test_cases): results = [] for n, m, edges in test_cases: results.append(is_bipartite(n, edges)) return results"},{"question":"from typing import List def maxBuildingsWithSunsetView(heights: List[int]) -> int: Given a list of integers representing the heights of a series of buildings, determine the maximum number of buildings that have a clear view of the sunset. The buildings are standing in a straight line and sunset view is to the west (which means left to right in the array). A building will have a clear view of the sunset if there are no taller (or equal height) buildings to its left. Args: heights (List[int]): A list of integers where heights[i] represents the height of the i-th building in line. Returns: int: The maximum number of buildings that have a clear view of the sunset. Examples: >>> maxBuildingsWithSunsetView([3, 7, 8, 3, 6, 1]) 3 >>> maxBuildingsWithSunsetView([1, 4, 5, 8]) 4 def test_max_buildings_with_sunset_view(): assert maxBuildingsWithSunsetView([3, 7, 8, 3, 6, 1]) == 3 assert maxBuildingsWithSunsetView([1, 4, 5, 8]) == 4 assert maxBuildingsWithSunsetView([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) == 1 assert maxBuildingsWithSunsetView([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 10 assert maxBuildingsWithSunsetView([3, 3, 3, 3, 3]) == 1 assert maxBuildingsWithSunsetView([1, 2, 1, 2, 1, 2]) == 2 assert maxBuildingsWithSunsetView([4, 3, 2, 5, 1, 6]) == 3 def test_max_buildings_with_sunset_view_edge_cases(): assert maxBuildingsWithSunsetView([1]) == 1 assert maxBuildingsWithSunsetView([1000000000]) == 1 assert maxBuildingsWithSunsetView([10, 100, 9]) == 2 assert maxBuildingsWithSunsetView([1, 3]) == 2 # Large input test assert maxBuildingsWithSunsetView([x for x in range(1, 100001)]) == 100000","solution":"from typing import List def maxBuildingsWithSunsetView(heights: List[int]) -> int: This function takes a list of integers representing the heights of buildings and returns the maximum number of buildings that have a clear view of the sunset. max_height = 0 count = 0 for height in heights: if height > max_height: max_height = height count += 1 return count"},{"question":"from collections import defaultdict class DigitalLibrary: A simple digital library system for organizing books based on their unique identifiers, titles, and genres. - ADD <id> <title> <genre>: Adds a new book with unique identifier <id>, title <title>, and genre <genre> to the collection. - REMOVE <id>: Removes the book with identifier <id> from the collection. - LIST <genre>: Lists all book titles that belong to the specified <genre> in alphabetical order. - COUNT: Returns the number of books for each genre. def __init__(self): self.books_by_id = {} self.books_by_genre = defaultdict(set) def add_book(self, book_id, title, genre): Add a book with the given identifier, title, and genre. if book_id not in self.books_by_id: self.books_by_id[book_id] = (title, genre) self.books_by_genre[genre].add((title, book_id)) def remove_book(self, book_id): Remove a book by its identifier. if book_id in self.books_by_id: title, genre = self.books_by_id.pop(book_id) self.books_by_genre[genre].remove((title, book_id)) if not self.books_by_genre[genre]: del self.books_by_genre[genre] def list_books(self, genre): List all book titles in a given genre, in alphabetical order. if genre in self.books_by_genre: return sorted([title for title, _ in self.books_by_genre[genre]]) else: return [] def count_books(self): Return the number of books for each genre. return {genre: len(titles) for genre, titles in self.books_by_genre.items()} if __name__ == \\"__main__\\": import pytest def test_add_and_list_books(): library = DigitalLibrary() library.add_book(\\"1\\", \\"the great gatsby\\", \\"fiction\\") library.add_book(\\"2\\", \\"learning python\\", \\"programming\\") library.add_book(\\"3\\", \\"the catcher in the rye\\", \\"fiction\\") assert library.list_books(\\"fiction\\") == [\\"the catcher in the rye\\", \\"the great gatsby\\"] assert library.list_books(\\"programming\\") == [\\"learning python\\"] assert library.list_books(\\"unknown\\") == [] def test_remove_books(): library = DigitalLibrary() library.add_book(\\"1\\", \\"the great gatsby\\", \\"fiction\\") library.add_book(\\"2\\", \\"learning python\\", \\"programming\\") library.add_book(\\"3\\", \\"the catcher in the rye\\", \\"fiction\\") library.remove_book(\\"2\\") assert library.list_books(\\"programming\\") == [] assert library.list_books(\\"fiction\\") == [\\"the catcher in the rye\\", \\"the great gatsby\\"] def test_count_books(): library = DigitalLibrary() library.add_book(\\"1\\", \\"the great gatsby\\", \\"fiction\\") library.add_book(\\"2\\", \\"learning python\\", \\"programming\\") library.add_book(\\"3\\", \\"the catcher in the rye\\", \\"fiction\\") expected_counts = {\\"fiction\\": 2, \\"programming\\": 1} assert library.count_books() == expected_counts library.remove_book(\\"1\\") expected_counts = {\\"fiction\\": 1, \\"programming\\": 1} assert library.count_books() == expected_counts library.remove_book(\\"3\\") expected_counts = {\\"programming\\": 1} assert library.count_books() == expected_counts library.remove_book(\\"2\\") expected_counts = {} assert library.count_books() == expected_counts def test_no_books_message(): library = DigitalLibrary() assert library.list_books(\\"fiction\\") == [] assert library.count_books() == {} pytest.main([__file__])","solution":"from collections import defaultdict class DigitalLibrary: def __init__(self): self.books_by_id = {} self.books_by_genre = defaultdict(set) def add_book(self, book_id, title, genre): if book_id not in self.books_by_id: self.books_by_id[book_id] = (title, genre) self.books_by_genre[genre].add((title, book_id)) def remove_book(self, book_id): if book_id in self.books_by_id: title, genre = self.books_by_id.pop(book_id) self.books_by_genre[genre].remove((title, book_id)) if not self.books_by_genre[genre]: del self.books_by_genre[genre] def list_books(self, genre): if genre in self.books_by_genre: return sorted([title for title, _ in self.books_by_genre[genre]]) else: return [] def count_books(self): return {genre: len(titles) for genre, titles in self.books_by_genre.items()}"},{"question":"from collections import defaultdict, deque from typing import List, Tuple def preprocess_ancestors(n: int, edges: List[Tuple[int, int]]) -> dict: # Placeholder for preprocessing logic pass def find_kth_ancestor(ancestors: dict, u: int, k: int) -> int: # Placeholder for finding kth ancestor pass def process_queries(n: int, values: List[int], edges: List[Tuple[int, int]], queries: List[Tuple[int, int]]) -> List[int]: Process the input and answers each query about the k-th ancestor of node u. Args: n (int): number of nodes in the tree. values (List[int]): values associated with the nodes. edges (List[Tuple[int, int]]): edges of the tree. queries (List[Tuple[int, int]]): list of queries with node u and ancestor position k. Returns: List[int]: list of results for each query. Example: >>> n = 5 >>> values = [10, 20, 30, 40, 50] >>> edges = [(1, 2), (1, 3), (2, 4), (2, 5)] >>> queries = [(4, 1), (5, 2), (3, 1), (3, 3)] >>> process_queries(n, values, edges, queries) [2, 1, 1, -1] # Placeholder for processing logic pass def test_sample(): n = 5 values = [10, 20, 30, 40, 50] edges = [(1, 2), (1, 3), (2, 4), (2, 5)] queries = [(4, 1), (5, 2), (3, 1), (3, 3)] expected_output = [2, 1, 1, -1] assert process_queries(n, values, edges, queries) == expected_output def test_no_ancestors(): n = 3 values = [10, 20, 30] edges = [(1, 2), (1, 3)] queries = [(1, 1), (2, 2)] expected_output = [-1, -1] assert process_queries(n, values, edges, queries) == expected_output def test_large_k(): n = 4 values = [10, 20, 30, 40] edges = [(1, 2), (2, 3), (3, 4)] queries = [(4, 10), (4, 3), (2, 1)] expected_output = [-1, 1, 1] assert process_queries(n, values, edges, queries) == expected_output def test_single_node(): n = 1 values = [10] edges = [] queries = [(1, 1), (1, 2)] expected_output = [-1, -1] assert process_queries(n, values, edges, queries) == expected_output def test_direct_parent(): n = 3 values = [10, 20, 30] edges = [(1, 2), (2, 3)] queries = [(2, 1), (3, 1)] expected_output = [1, 2] assert process_queries(n, values, edges, queries) == expected_output","solution":"from collections import defaultdict, deque def preprocess_ancestors(n, edges): # Initialize the tree and parent dictionary tree = defaultdict(list) for a, b in edges: tree[a].append(b) tree[b].append(a) # Ancestor table ancestors = {i: [] for i in range(1, n + 1)} # BFS to populate ancestors queue = deque([(1, 0)]) # (node, parent) while queue: node, parent = queue.popleft() if parent != 0: ancestors[node] = [parent] + ancestors[parent] for neighbor in tree[node]: if neighbor != parent: queue.append((neighbor, node)) return ancestors def find_kth_ancestor(ancestors, u, k): if k > len(ancestors[u]): return -1 return ancestors[u][k-1] def process_queries(n, values, edges, queries): ancestors = preprocess_ancestors(n, edges) results = [] for u, k in queries: results.append(find_kth_ancestor(ancestors, u, k)) return results"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_valid_bst(root): Determines if a binary tree is a valid binary search tree (BST). Parameters: root (TreeNode): The root of the binary tree. Returns: bool: True if the tree is a valid BST, False otherwise. pass # Unit Tests def test_is_valid_bst_true_case(): # Creating the tree: # 2 # / # 1 3 root = TreeNode(2) root.left = TreeNode(1) root.right = TreeNode(3) assert is_valid_bst(root) == True def test_is_valid_bst_false_case(): # Creating the tree: # 5 # / # 1 4 # / # 3 6 root = TreeNode(5) root.left = TreeNode(1) root.right = TreeNode(4) root.right.left = TreeNode(3) root.right.right = TreeNode(6) assert is_valid_bst(root) == False def test_is_valid_bst_single_node(): # Single node tree root = TreeNode(1) assert is_valid_bst(root) == True def test_is_valid_bst_complex_true_case(): # Creating the tree: # 10 # / # 5 15 # / / # 2 7 12 20 root = TreeNode(10) root.left = TreeNode(5) root.right = TreeNode(15) root.left.left = TreeNode(2) root.left.right = TreeNode(7) root.right.left = TreeNode(12) root.right.right = TreeNode(20) assert is_valid_bst(root) == True def test_is_valid_bst_complex_false_case(): # Creating the tree: # 10 # / # 5 15 # / / # 2 12 12 20 root = TreeNode(10) root.left = TreeNode(5) root.right = TreeNode(15) root.left.left = TreeNode(2) root.left.right = TreeNode(12) root.right.left = TreeNode(12) root.right.right = TreeNode(20) assert is_valid_bst(root) == False","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_valid_bst(root): Determines if a binary tree is a valid binary search tree (BST). Parameters: root (TreeNode): The root of the binary tree. Returns: bool: True if the tree is a valid BST, False otherwise. def validate(node, low=float('-inf'), high=float('inf')): # Empty trees are valid BSTs if not node: return True # Current node's value must be between low and high if not (low < node.val < high): return False # Recursively validate the left and right subtrees with updated bounds return (validate(node.left, low, node.val) and validate(node.right, node.val, high)) return validate(root)"},{"question":"class UserProfile: User profile class to manage and display user information. Attributes: name (str): The name of the user email (str): The email of the user bio (str): A short bio of the user profile_picture (str): Path to the user's profile picture def __init__(self, name: str, email: str, bio: str, profile_picture: str): Initialize the UserProfile with name, email, bio, and profile picture. Args: name (str): The user's name. email (str): The user's email. bio (str): A short bio of the user. profile_picture (str): Path to the user's profile picture. def edit_profile(self, name: Optional[str] = None, email: Optional[str] = None, bio: Optional[str] = None, profile_picture: Optional[str] = None): Edit the profile details of the user. Args: name (str, optional): New name for the user. Defaults to None. email (str, optional): New email for the user. Defaults to None. bio (str, optional): New bio for the user. Defaults to None. profile_picture (str, optional): New profile picture path for the user. Defaults to None. def display_profile(self) -> Dict[str, str]: Display the profile details of the user. Returns: dict: A dictionary containing the user's profile details. from solution import UserProfile def test_initial_profile(): user = UserProfile(\\"John Doe\\", \\"john.doe@example.com\\", \\"A short bio\\", \\"profile_pic.png\\") profile = user.display_profile() assert profile[\\"name\\"] == \\"John Doe\\" assert profile[\\"email\\"] == \\"john.doe@example.com\\" assert profile[\\"bio\\"] == \\"A short bio\\" assert profile[\\"profile_picture\\"] == \\"profile_pic.png\\" def test_edit_name(): user = UserProfile(\\"John Doe\\", \\"john.doe@example.com\\", \\"A short bio\\", \\"profile_pic.png\\") user.edit_profile(name=\\"Jane Doe\\") profile = user.display_profile() assert profile[\\"name\\"] == \\"Jane Doe\\" assert profile[\\"email\\"] == \\"john.doe@example.com\\" assert profile[\\"bio\\"] == \\"A short bio\\" assert profile[\\"profile_picture\\"] == \\"profile_pic.png\\" def test_edit_email(): user = UserProfile(\\"John Doe\\", \\"john.doe@example.com\\", \\"A short bio\\", \\"profile_pic.png\\") user.edit_profile(email=\\"jane.doe@example.com\\") profile = user.display_profile() assert profile[\\"name\\"] == \\"John Doe\\" assert profile[\\"email\\"] == \\"jane.doe@example.com\\" assert profile[\\"bio\\"] == \\"A short bio\\" assert profile[\\"profile_picture\\"] == \\"profile_pic.png\\" def test_edit_bio(): user = UserProfile(\\"John Doe\\", \\"john.doe@example.com\\", \\"A short bio\\", \\"profile_pic.png\\") user.edit_profile(bio=\\"A new bio\\") profile = user.display_profile() assert profile[\\"name\\"] == \\"John Doe\\" assert profile[\\"email\\"] == \\"john.doe@example.com\\" assert profile[\\"bio\\"] == \\"A new bio\\" assert profile[\\"profile_picture\\"] == \\"profile_pic.png\\" def test_edit_profile_picture(): user = UserProfile(\\"John Doe\\", \\"john.doe@example.com\\", \\"A short bio\\", \\"profile_pic.png\\") user.edit_profile(profile_picture=\\"new_profile_pic.png\\") profile = user.display_profile() assert profile[\\"name\\"] == \\"John Doe\\" assert profile[\\"email\\"] == \\"john.doe@example.com\\" assert profile[\\"bio\\"] == \\"A short bio\\" assert profile[\\"profile_picture\\"] == \\"new_profile_pic.png\\"","solution":"class UserProfile: def __init__(self, name, email, bio, profile_picture): self.name = name self.email = email self.bio = bio self.profile_picture = profile_picture def edit_profile(self, name=None, email=None, bio=None, profile_picture=None): if name is not None: self.name = name if email is not None: self.email = email if bio is not None: self.bio = bio if profile_picture is not None: self.profile_picture = profile_picture def display_profile(self): return { \\"name\\": self.name, \\"email\\": self.email, \\"bio\\": self.bio, \\"profile_picture\\": self.profile_picture }"},{"question":"from typing import List, Tuple def min_food_types(n: int, f: int, dietary_reqs: List[List[int]], friendships: List[Tuple[int, int]]) -> int: Calculate the minimum number of food types needed to satisfy the dietary and friendship constraints. Args: n: int - the number of animals. f: int - the number of friendship relationships. dietary_reqs: List[List[int]] - the list of dietary requirements for each animal. friendships: List[Tuple[int, int]] - the list of friendship constraints. Returns: int: the minimum number of food types needed, or -1 if it's not possible. Example: >>> min_food_types(5, 4, [[1, 2], [2, 3], [1, 3], [2], [1, 4]], [(1, 2), (1, 3), (4, 5), (3, 5)]) 3 >>> min_food_types(4, 3, [[1], [1], [2], [2]], [(1, 2), (3, 4), (2, 3)]) -1 pass # Your implementation here # Unit tests def test_simple_case(): dietary_reqs = [ [1, 2], [2, 3], [1, 3], [2], [1, 4] ] friendships = [ (1, 2), (1, 3), (4, 5), (3, 5) ] assert min_food_types(5, 4, dietary_reqs, friendships) == 3 def test_not_possible(): dietary_reqs = [ [1], [1], [2], [2] ] friendships = [ (1, 2), (3, 4), (2, 3) ] assert min_food_types(4, 3, dietary_reqs, friendships) == -1 def test_all_animals_can_eat_same_food(): dietary_reqs = [ [1, 2], [1, 2], [1, 2], [1, 2] ] friendships = [ (1, 2), (2, 3), (3, 4) ] assert min_food_types(4, 3, dietary_reqs, friendships) == 2 def test_disconnected_graph(): dietary_reqs = [ [1], [2], [1, 2], [2] ] friendships = [ (1, 2), (3, 4) ] assert min_food_types(4, 2, dietary_reqs, friendships) == 2","solution":"def min_food_types(n, f, dietary_reqs, friendships): from collections import defaultdict, deque # Graph representation: adjacency list of friends adj = defaultdict(list) for u, v in friendships: adj[u].append(v) adj[v].append(u) # Function to check if we can assign a food type to an animal def assign_food(animal, food, assigned_foods): for neighbor in adj[animal]: if food == assigned_foods[neighbor]: return False return True # Function to try and assign food types using DFS def dfs(animal): queue = deque([animal]) while queue: current = queue.popleft() for food in dietary_reqs[current - 1]: if assign_food(current, food, assigned_foods): assigned_foods[current] = food break else: return False for neighbor in adj[current]: if not assigned_foods[neighbor]: queue.append(neighbor) return True assigned_foods = [0] * (n + 1) # +1 to handle 1-based indexing for animal in range(1, n + 1): if not assigned_foods[animal]: # If the animal has not been assigned food if not dfs(animal): return -1 unique_foods = len(set(assigned_foods) - {0}) return unique_foods"},{"question":"class Grid: def __init__(self, grid): self.n = len(grid) self.m = len(grid[0]) self.grid = grid self.prefix_sum = self._compute_prefix_sum() def _compute_prefix_sum(self): ps = [[0] * (self.m + 1) for _ in range(self.n + 1)] for i in range(1, self.n + 1): for j in range(1, self.m + 1): ps[i][j] = self.grid[i-1][j-1] + ps[i-1][j] + ps[i][j-1] - ps[i-1][j-1] return ps def update(self, x, y, val): Update the value of the cell at (x, y) to val. old_val = self.grid[x-1][y-1] self.grid[x-1][y-1] = val delta = val - old_val for i in range(x, self.n + 1): for j in range(y, self.m + 1): self.prefix_sum[i][j] += delta def query(self, x1, y1, x2, y2): Query the sum of the values within the sub-grid with top-left corner (x1, y1) and bottom-right corner (x2, y2). >>> grid = Grid([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) >>> grid.query(1, 1, 2, 2) 12 >>> grid.update(2, 2, 10) >>> grid.query(1, 1, 2, 2) 17 return (self.prefix_sum[x2][y2] - self.prefix_sum[x1-1][y2] - self.prefix_sum[x2][y1-1] + self.prefix_sum[x1-1][y1-1]) def process_operations(n, m, initial_grid, operations): Process a list of operations on the grid and return the results of query operations. >>> n, m = 3, 3 >>> initial_grid = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> operations = [ ... (2, 1, 1, 2, 2), ... (1, 2, 2, 10), ... (2, 1, 1, 2, 2) ... ] >>> process_operations(n, m, initial_grid, operations) [12, 17] grid = Grid(initial_grid) results = [] for op in operations: if op[0] == 1: grid.update(op[1], op[2], op[3]) elif op[0] == 2: results.append(grid.query(op[1], op[2], op[3], op[4])) return results","solution":"class Grid: def __init__(self, grid): self.n = len(grid) self.m = len(grid[0]) self.grid = grid self.prefix_sum = self._compute_prefix_sum() def _compute_prefix_sum(self): ps = [[0] * (self.m + 1) for _ in range(self.n + 1)] for i in range(1, self.n + 1): for j in range(1, self.m + 1): ps[i][j] = self.grid[i-1][j-1] + ps[i-1][j] + ps[i][j-1] - ps[i-1][j-1] return ps def update(self, x, y, val): old_val = self.grid[x-1][y-1] self.grid[x-1][y-1] = val delta = val - old_val for i in range(x, self.n + 1): for j in range(y, self.m + 1): self.prefix_sum[i][j] += delta def query(self, x1, y1, x2, y2): return (self.prefix_sum[x2][y2] - self.prefix_sum[x1-1][y2] - self.prefix_sum[x2][y1-1] + self.prefix_sum[x1-1][y1-1]) def process_operations(n, m, initial_grid, operations): grid = Grid(initial_grid) results = [] for op in operations: if op[0] == 1: grid.update(op[1], op[2], op[3]) elif op[0] == 2: results.append(grid.query(op[1], op[2], op[3], op[4])) return results"},{"question":"from collections import defaultdict, deque from typing import List, Tuple def find_paths(n: int, edges: List[Tuple[int, int]], a: int, b: int) -> str: In a country called TreeLand, there are n trees, numbered 1 through n. The trees are connected by n-1 one-way roads, forming a directed tree. Each road connects exactly two trees and ensures that there is a unique path from the root tree (tree 1) to any other tree. The President of TreeLand, Mr. Oak, is interested in a new tree arrangement. He wishes to choose two trees a and b, and find two separate paths from the root tree to both of them. The paths should not share any trees except for the root. Given the structure of the tree, this function returns \\"Yes\\" and the two paths if it's possible to find such two paths for the chosen trees, and \\"No\\" otherwise. Parameters: n (int): the number of trees in TreeLand edges (List[Tuple[int, int]]): a list of tuples describing the one-way roads from tree u to tree v a (int): the first specific tree Mr. Oak is interested in b (int): the second specific tree Mr. Oak is interested in Returns: str: \\"Yes\\" followed by two lines with the paths descriptions if such paths exist, otherwise \\"No\\" Example Usage: >>> n = 6 >>> edges = [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (4, 6)] >>> a, b = 4, 6 >>> find_paths(n, edges, a, b) 'Yesn1 2 4n1 3' # Your code here def test_example_case(): n = 6 edges = [ (1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (4, 6) ] a, b = 4, 6 result = find_paths(n, edges, a, b) assert result.startswith(\\"Yes\\") def test_no_possible_paths(): n = 4 edges = [ (1, 2), (1, 3), (2, 4), (3, 4) ] a, b = 4, 4 result = find_paths(n, edges, a, b) assert result == \\"No\\" def test_disjoint_paths(): n = 5 edges = [ (1, 2), (1, 3), (2, 4), (3, 5) ] a, b = 4, 5 result = find_paths(n, edges, a, b) assert result.startswith(\\"Yes\\") def test_single_node(): n = 2 edges = [ (1, 2) ] a, b = 2, 3 result = find_paths(n, edges, a, b) assert result == \\"No\\"","solution":"from collections import defaultdict, deque def find_paths(n, edges, a, b): graph = defaultdict(list) for u, v in edges: graph[u].append(v) def bfs(start, end): queue = deque([(start, [start])]) visited = set() while queue: node, path = queue.popleft() if node == end: return path visited.add(node) for neighbor in graph[node]: if neighbor not in visited: queue.append((neighbor, path + [neighbor])) return None path_to_a = bfs(1, a) path_to_b = bfs(1, b) if not path_to_a or not path_to_b: return \\"No\\" path_set_a = set(path_to_a) path_set_b = set(path_to_b) if path_set_a.intersection(path_set_b) == {1}: return f\\"Yesn{' '.join(map(str, path_to_a))}n{' '.join(map(str, path_to_b))}\\" else: return \\"No\\" # Example Usage n = 6 edges = [ (1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (4, 6) ] a, b = 4, 6 print(find_paths(n, edges, a, b)) # Should output the validity and paths if possible"},{"question":"class InventoryManagementSystem: A class to manage online store inventory with functionalities for adding, removing and checking item availability. Methods ------- __init__(): Initializes an empty inventory. add_item(category: str, item_name: str, quantity: int): Adds a specified quantity of an item to the inventory under the given category. remove_item(category: str, item_name: str, quantity: int) -> bool: Removes a specified quantity of an item from the inventory. check_availability(category: str, item_name: str) -> int: Returns the available quantity of the specified item in the given category. Example Usage ------------- >>> inventory = InventoryManagementSystem() >>> inventory.add_item('books', 'Python Programming', 10) >>> inventory.check_availability('books', 'Python Programming') 10 >>> inventory.remove_item('books', 'Python Programming', 5) True >>> inventory.check_availability('books', 'Python Programming') 5 >>> result = inventory.remove_item('books', 'Python Programming', 10) False def __init__(self): Initializes an empty inventory. pass def add_item(self, category: str, item_name: str, quantity: int): Adds a specified quantity of an item to the inventory under the given category. Parameters: category (str): Category of the item. item_name (str): Name of the item. quantity (int): Quantity of the item to be added. pass def remove_item(self, category: str, item_name: str, quantity: int) -> bool: Removes a specified quantity of an item from the inventory. Parameters: category (str): Category of the item. item_name (str): Name of the item. quantity (int): Quantity of the item to be removed. Returns: bool: True if the item was successfully removed, False otherwise. pass def check_availability(self, category: str, item_name: str) -> int: Returns the available quantity of the specified item in the given category. Parameters: category (str): Category of the item. item_name (str): Name of the item. Returns: int: Quantity of the item available in the inventory. pass def test_add_item(): inventory = InventoryManagementSystem() inventory.add_item('books', 'Python Programming', 10) assert inventory.check_availability('books', 'Python Programming') == 10 inventory.add_item('books', 'Python Programming', 5) assert inventory.check_availability('books', 'Python Programming') == 15 def test_remove_item(): inventory = InventoryManagementSystem() inventory.add_item('books', 'Python Programming', 10) result = inventory.remove_item('books', 'Python Programming', 5) assert result == True assert inventory.check_availability('books', 'Python Programming') == 5 result = inventory.remove_item('books', 'Python Programming', 10) assert result == False assert inventory.check_availability('books', 'Python Programming') == 5 def test_remove_item_completely(): inventory = InventoryManagementSystem() inventory.add_item('electronics', 'Smartphone', 3) result = inventory.remove_item('electronics', 'Smartphone', 3) assert result == True assert inventory.check_availability('electronics', 'Smartphone') == 0 result = inventory.remove_item('electronics', 'Smartphone', 1) assert result == False def test_check_availability_non_existent_item(): inventory = InventoryManagementSystem() assert inventory.check_availability('clothing', 'T-Shirt') == 0 def test_multiple_categories(): inventory = InventoryManagementSystem() inventory.add_item('books', 'Python Programming', 10) inventory.add_item('electronics', 'Smartphone', 5) inventory.add_item('clothing', 'T-Shirt', 7) assert inventory.check_availability('books', 'Python Programming') == 10 assert inventory.check_availability('electronics', 'Smartphone') == 5 assert inventory.check_availability('clothing', 'T-Shirt') == 7 inventory.remove_item('electronics', 'Smartphone', 3) assert inventory.check_availability('electronics', 'Smartphone') == 2","solution":"class InventoryManagementSystem: def __init__(self): Initializes an empty inventory. self.inventory = {} def add_item(self, category: str, item_name: str, quantity: int): Adds a specified quantity of an item to the inventory under the given category. If the item already exists in the specified category, simply increase its quantity. if category not in self.inventory: self.inventory[category] = {} if item_name in self.inventory[category]: self.inventory[category][item_name] += quantity else: self.inventory[category][item_name] = quantity def remove_item(self, category: str, item_name: str, quantity: int) -> bool: Removes a specified quantity of an item from the inventory. If the items quantity becomes zero or less after removal, it should be removed from the inventory. Returns True if the item was successfully removed, and False if the item was not found in the inventory or if there were not enough items to remove. if category in self.inventory and item_name in self.inventory[category]: if self.inventory[category][item_name] >= quantity: self.inventory[category][item_name] -= quantity if self.inventory[category][item_name] <= 0: del self.inventory[category][item_name] return True else: return False return False def check_availability(self, category: str, item_name: str) -> int: Returns the available quantity of the specified item in the given category. If the item is not found in the inventory, return 0. if category in self.inventory and item_name in self.inventory[category]: return self.inventory[category][item_name] return 0"},{"question":"class Database: def __init__(self, data): self.data = data self.n = len(data) self.prefix_sums = self.compute_prefix_sums() def compute_prefix_sums(self): Compute initial prefix sums pass def update(self, index, value): Update the value at a specific index pass def sum_range(self, left, right): Calculate the sum of values in a given range pass def process_queries(n, q, initial_data, queries): Process a series of update and sum queries on the database. Args: n (int): Number of elements in the database. q (int): Number of queries. initial_data (List[int]): Initial state of the database. queries (List[List[int]]): Sequence of queries to process. Returns: List[int]: The result for each sum query. Example: >>> process_queries(5, 3, [1, 2, 3, 4, 5], [[1, 3, 6], [2, 2, 4], [2, 1, 5]]) [12, 18] pass def test_single_update_and_sum(): n = 5 q = 3 initial_data = [1, 2, 3, 4, 5] queries = [ [1, 3, 6], [2, 2, 4], [2, 1, 5] ] assert process_queries(n, q, initial_data, queries) == [12, 18] def test_multiple_updates(): n = 5 q = 4 initial_data = [1, 2, 3, 4, 5] queries = [ [1, 2, 7], [1, 4, 10], [2, 1, 5], [2, 2, 4] ] assert process_queries(n, q, initial_data, queries) == [26, 20] def test_all_sum_queries(): n = 5 q = 2 initial_data = [1, 2, 3, 4, 5] queries = [ [2, 1, 3], [2, 3, 5] ] assert process_queries(n, q, initial_data, queries) == [6, 12] def test_large_values(): n = 5 q = 2 initial_data = [1000000000, 1000000000, 1000000000, 1000000000, 1000000000] queries = [ [2, 1, 5], [1, 3, -1000000000] ] assert process_queries(n, q, initial_data, queries) == [5000000000]","solution":"class Database: def __init__(self, data): self.data = data self.n = len(data) self.prefix_sums = self.compute_prefix_sums() def compute_prefix_sums(self): prefix_sums = [0] * (self.n + 1) for i in range(1, self.n + 1): prefix_sums[i] = prefix_sums[i - 1] + self.data[i - 1] return prefix_sums def update(self, index, value): current_value = self.data[index - 1] diff = value - current_value self.data[index - 1] = value for i in range(index, self.n + 1): self.prefix_sums[i] += diff def sum_range(self, left, right): return self.prefix_sums[right] - self.prefix_sums[left - 1] def process_queries(n, q, initial_data, queries): db = Database(initial_data) results = [] for query in queries: if query[0] == 1: db.update(query[1], query[2]) elif query[0] == 2: result = db.sum_range(query[1], query[2]) results.append(result) return results"},{"question":"def can_partition_with_diff_k(n, k, array): Determine if it is possible to partition the array into two subsets such that the difference of their sums is exactly k. Parameters: n (int): Number of elements in the array k (int): Desired difference between the sums of the subsets array (List[int]): The array of integers Returns: Tuple[str, List[int], List[int]]: \\"YES\\" or \\"NO\\", and the two subsets if partition is possible. Examples: >>> can_partition_with_diff_k(5, 3, [1, 2, 3, 4, 5]) ('YES', [1, 2], [3, 4, 5]) >>> can_partition_with_diff_k(4, 1, [1, 1, 1, 1]) ('NO', [], []) # Unit tests to validate the solution def test_example_1(): n = 5 k = 3 array = [1, 2, 3, 4, 5] result, subset1, subset2 = can_partition_with_diff_k(n, k, array) assert result == \\"YES\\" assert set(subset1).union(set(subset2)) == set(array) assert abs(sum(subset1) - sum(subset2)) == k def test_example_2(): n = 4 k = 1 array = [1, 1, 1, 1] result, subset1, subset2 = can_partition_with_diff_k(n, k, array) assert result == \\"NO\\" def test_single_element_no_partition(): n = 1 k = 0 array = [10] result, subset1, subset2 = can_partition_with_diff_k(n, k, array) assert result == \\"NO\\" def test_two_elements_valid_partition(): n = 2 k = 0 array = [50, 50] result, subset1, subset2 = can_partition_with_diff_k(n, k, array) assert result == \\"YES\\" assert set(subset1).union(set(subset2)) == set(array) assert abs(sum(subset1) - sum(subset2)) == k def test_many_elements_invalid_partition(): n = 6 k = 3 array = [1, 1, 1, 1, 1, 1] result, subset1, subset2 = can_partition_with_diff_k(n, k, array) assert result == \\"NO\\"","solution":"def can_partition_with_diff_k(n, k, array): total_sum = sum(array) if (total_sum - k) % 2 != 0: return \\"NO\\", [], [] target = (total_sum - k) // 2 dp = [False] * (target + 1) dp[0] = True for num in array: for j in range(target, num - 1, -1): dp[j] = dp[j] or dp[j - num] if not dp[target]: return \\"NO\\", [], [] subset1 = [] subset2 = [] current_sum = target for num in reversed(array): if current_sum >= num and dp[current_sum - num]: subset1.append(num) current_sum -= num else: subset2.append(num) return \\"YES\\", subset1, subset2"},{"question":"def can_make_all_recipes(ingredients, quantities, recipes): Determine whether Chef can prepare all the recipes in the list given the stock of ingredients in the pantry. Args: ingredients: List of ingredient names in the pantry. quantities: List of quantities corresponding to the ingredients in the pantry. recipes: List of dictionaries where each dictionary represents a recipe with ingredient names as keys and required quantities as values. Returns: \\"YES\\" if Chef can make all the recipes, otherwise \\"NO\\". >>> can_make_all_recipes([\\"sugar\\", \\"flour\\", \\"butter\\", \\"eggs\\", \\"milk\\"], [500, 300, 200, 5, 1000], [{\\"sugar\\": 200, \\"flour\\": 100, \\"butter\\": 50}, {\\"milk\\": 300, \\"eggs\\": 2}]) 'YES' >>> can_make_all_recipes([\\"sugar\\", \\"flour\\", \\"butter\\", \\"eggs\\", \\"milk\\"], [200, 100, 50, 2, 500], [{\\"sugar\\": 200, \\"flour\\": 100, \\"butter\\": 50}, {\\"milk\\": 300, \\"eggs\\": 3}]) 'NO' # Implementation here def parse_input(input_string): Parse the input string into ingredients, quantities, and recipes. Args: input_string: The input string containing the details of ingredients, quantities, and recipes. Returns: A tuple containing: - List of ingredient names. - List of quantities corresponding to the ingredients. - List of recipes, where each recipe is represented as a dictionary. >>> parse_input(\\"5nsugar flour butter eggs milkn500 300 200 5 1000n2n3nsugar 200nflour 100nbutter 50n2nmilk 300neggs 2\\") ([\\"sugar\\", \\"flour\\", \\"butter\\", \\"eggs\\", \\"milk\\"], [500, 300, 200, 5, 1000], [{\\"sugar\\": 200, \\"flour\\": 100, \\"butter\\": 50}, {\\"milk\\": 300, \\"eggs\\": 2}]) # Implementation here def chef_recipes(input_string): Wrapper function to check if Chef can prepare all the recipes based on the input string. Args: input_string: The input string containing the details of ingredients, quantities, and recipes. Returns: \\"YES\\" if Chef can make all the recipes, otherwise \\"NO\\". ingredients, quantities, recipes = parse_input(input_string) return can_make_all_recipes(ingredients, quantities, recipes) import pytest def test_chef_recipes(): assert chef_recipes(\\"5nsugar flour butter eggs milkn500 300 200 5 1000n2n3nsugar 200nflour 100nbutter 50n2nmilk 300neggs 2\\") == \\"YES\\" assert chef_recipes(\\"5nsugar flour butter eggs milkn200 100 50 2 500n2n3nsugar 200nflour 100nbutter 50n2nmilk 300neggs 3\\") == \\"NO\\" assert chef_recipes(\\"3nsugar flour buttern200 100 50n2n2nsugar 100nflour 50n2nbutter 30nsugar 100\\") == \\"YES\\" assert chef_recipes(\\"3nsugar flour buttern100 50 30n2n2nsugar 100nflour 51n1nbutter 30\\") == \\"NO\\" assert chef_recipes(\\"2nsugar buttern200 50n1n2nsugar 10nflour 5\\") == \\"NO\\"","solution":"def can_make_all_recipes(ingredients, quantities, recipes): ingredient_stock = dict(zip(ingredients, quantities)) for recipe in recipes: for ingredient, quantity in recipe.items(): if ingredient not in ingredient_stock or ingredient_stock[ingredient] < quantity: return \\"NO\\" ingredient_stock[ingredient] -= quantity return \\"YES\\" def parse_input(input_string): lines = input_string.strip().split('n') m = int(lines[0]) ingredients = lines[1].split() quantities = list(map(int, lines[2].split())) r = int(lines[3]) index = 4 recipes = [] for _ in range(r): k = int(lines[index]) recipe = {} index += 1 for _ in range(k): ing, qty = lines[index].split() recipe[ing] = int(qty) index += 1 recipes.append(recipe) return ingredients, quantities, recipes def chef_recipes(input_string): ingredients, quantities, recipes = parse_input(input_string) return can_make_all_recipes(ingredients, quantities, recipes)"},{"question":"from typing import List, Tuple MOD = 10**9 + 7 def range_product_queries(n: int, m: int, array: List[int], queries: List[Tuple[int, int]]) -> List[int]: Process m queries to find the product of elements over a certain range of the array. Each query contains two numbers l and r, and returns the product of the elements from index l to index r (inclusive). The result is returned modulo 10^9 + 7. Args: n (int): The number of elements in the array. m (int): The number of queries. array (List[int]): The list of integers representing the array. queries (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers representing the query range (l, r). Returns: List[int]: A list of integers representing the product of elements for each query range, modulo 10^9 + 7. Example: >>> range_product_queries(5, 3, [1, 2, 3, 4, 5], [(1, 3), (2, 5), (1, 5)]) [6, 120, 120] >>> range_product_queries(1, 1, [1000000000], [(1, 1)]) [1000000000] pass # Unit tests def test_range_product_queries_example(): n, m = 5, 3 array = [1, 2, 3, 4, 5] queries = [(1, 3), (2, 5), (1, 5)] expected = [6, 120, 120] assert range_product_queries(n, m, array, queries) == expected def test_range_product_queries_single_element(): n, m = 1, 1 array = [1000000000] queries = [(1, 1)] expected = [1000000000] assert range_product_queries(n, m, array, queries) == expected def test_range_product_queries_entire_array(): n, m = 4, 1 array = [1, 2, 3, 4] queries = [(1, 4)] expected = [24] assert range_product_queries(n, m, array, queries) == expected def test_range_product_queries_multiple_ranges(): n, m = 5, 2 array = [10, 20, 30, 40, 50] queries = [(2, 4), (1, 2)] expected = [24000, 200] assert range_product_queries(n, m, array, queries) == expected def test_range_product_queries_large_numbers(): n, m = 2, 1 array = [10**9, 10**9] queries = [(1, 2)] expected = [49] # (10^9 * 10^9) % (10^9 + 7) = 1,000,000,000,000,000,000 % 1,000,000,007 = 49 assert range_product_queries(n, m, array, queries) == expected","solution":"MOD = 10**9 + 7 def range_product_queries(n, m, array, queries): # Create a prefix product array prefix_product = [1] * (n + 1) for i in range(1, n + 1): prefix_product[i] = (prefix_product[i - 1] * array[i - 1]) % MOD results = [] for l, r in queries: if l == 1: results.append(prefix_product[r]) else: result = (prefix_product[r] * pow(prefix_product[l - 1], MOD - 2, MOD)) % MOD results.append(result) return results"},{"question":"class WarehouseGrid: def __init__(self, n: int, m: int, grid: List[List[str]]): Initialize the Warehouse grid with given dimensions and initial state. Args: n (int): Number of rows. m (int): Number of columns. grid (List[List[str]]): Initial state of the warehouse grid. def build_prefix_sum(self): Build a prefix sum matrix for the grid to facilitate range queries. def update_cell(self, r: int, c: int): Update the cell at (r, c). If it is empty, place a package. If it is occupied, remove the package. Args: r (int): Row index of the cell to update. c (int): Column index of the cell to update. def query_packages(self, r1: int, c1: int, r2: int, c2: int) -> int: Query the number of packages in the subgrid from (r1, c1) to (r2, c2). Args: r1 (int): Starting row index of the subgrid. c1 (int): Starting column index of the subgrid. r2 (int): Ending row index of the subgrid. c2 (int): Ending column index of the subgrid. Returns: int: Number of packages in the specified subgrid. def warehouse_operations(n: int, m: int, initial_grid: List[List[str]], queries: List[List[int]]) -> List[int]: Processes a list of queries on a warehouse grid. Args: n (int): Number of rows in the grid. m (int): Number of columns in the grid. initial_grid (List[List[str]]): Initial state of the warehouse grid with 'E' for empty and 'P' for packages. queries (List[List[int]]): List of queries to be processed. Returns: List[int]: Results of the type 1 queries in the order they were processed. >>> n, m = 3, 3 >>> initial_grid = [['E', 'P', 'E'], ['E', 'P', 'E'], ['E', 'P', 'E']] >>> queries = [[1, 1, 1, 3, 3], [2, 3, 2], [1, 1, 1, 3, 3], [1, 2, 2, 3, 3]] >>> warehouse_operations(n, m, initial_grid, queries) [3, 2, 1] >>> n, m = 2, 2 >>> initial_grid = [['P', 'P'], ['P', 'P']] >>> queries = [[1, 1, 1, 2, 2], [2, 1, 1], [1, 1, 1, 2, 2], [2, 2, 2], [1, 1, 1, 2, 2]] >>> warehouse_operations(n, m, initial_grid, queries) [4, 3, 2] >>> n, m = 2, 2 >>> initial_grid = [['E', 'E'], ['E', 'E']] >>> queries = [[1, 1, 1, 2, 2], [2, 1, 1], [1, 1, 1, 2, 2], [2, 2, 2], [1, 1, 1, 2, 2]] >>> warehouse_operations(n, m, initial_grid, queries) [0, 1, 2]","solution":"class WarehouseGrid: def __init__(self, n, m, grid): self.n = n self.m = m self.grid = grid self.prefix_sum = [[0] * (m + 1) for _ in range(n + 1)] self.build_prefix_sum() def build_prefix_sum(self): for i in range(1, self.n + 1): for j in range(1, self.m + 1): self.prefix_sum[i][j] = (self.grid[i - 1][j - 1] == 'P') + self.prefix_sum[i - 1][j] + self.prefix_sum[i][j - 1] - self.prefix_sum[i - 1][j - 1] def update_cell(self, r, c): self.grid[r - 1][c - 1] = 'P' if self.grid[r - 1][c - 1] == 'E' else 'E' self.build_prefix_sum() def query_packages(self, r1, c1, r2, c2): return (self.prefix_sum[r2][c2] - self.prefix_sum[r1 - 1][c2] - self.prefix_sum[r2][c1 - 1] + self.prefix_sum[r1 - 1][c1 - 1]) def warehouse_operations(n, m, initial_grid, queries): grid = WarehouseGrid(n, m, initial_grid) result = [] for query in queries: if query[0] == 1: r1, c1, r2, c2 = query[1], query[2], query[3], query[4] result.append(grid.query_packages(r1, c1, r2, c2)) elif query[0] == 2: r, c = query[1], query[2] grid.update_cell(r, c) return result"},{"question":"def can_transform_grid(n, m, k, initial_grid, target_grid): Determines if it is possible to transform the initial grid to the target grid within k operations. Args: - n (int): Number of rows in the grid (1  n  50). - m (int): Number of columns in the grid (1  m  50). - k (int): Maximum number of changes allowed (0  k  2500). - initial_grid (list[list[int]]): The starting grid of integers. - target_grid (list[list[int]]): The target grid of integers. Returns: - str: \\"YES\\" if transformation is possible within k changes, \\"NO\\" otherwise. # Your code here # Example test cases def test_exact_changes(): n = 3 m = 3 k = 5 initial_grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] target_grid = [ [1, 2, 4], [4, 5, 7], [7, 8, 10] ] assert can_transform_grid(n, m, k, initial_grid, target_grid) == \\"YES\\" def test_more_than_required_changes(): n = 2 m = 2 k = 3 initial_grid = [ [1, 2], [3, 4] ] target_grid = [ [2, 3], [4, 5] ] assert can_transform_grid(n, m, k, initial_grid, target_grid) == \\"NO\\" def test_no_changes_needed(): n = 2 m = 2 k = 0 initial_grid = [ [1, 1], [1, 1] ] target_grid = [ [1, 1], [1, 1] ] assert can_transform_grid(n, m, k, initial_grid, target_grid) == \\"YES\\" def test_insufficient_changes(): n = 3 m = 3 k = 1 initial_grid = [ [1, 1, 1], [1, 1, 1], [1, 1, 1] ] target_grid = [ [2, 2, 2], [2, 2, 2], [2, 2, 2] ] assert can_transform_grid(n, m, k, initial_grid, target_grid) == \\"NO\\" def test_large_grid(): n = 2 m = 2 k = 4 initial_grid = [ [1, 2], [3, 3] ] target_grid = [ [1, 1], [2, 2] ] assert can_transform_grid(n, m, k, initial_grid, target_grid) == \\"YES\\" def test_empty_grid(): n = 1 m = 1 k = 0 initial_grid = [ [1] ] target_grid = [ [1] ] assert can_transform_grid(n, m, k, initial_grid, target_grid) == \\"YES\\"","solution":"def can_transform_grid(n, m, k, initial_grid, target_grid): Determines if it is possible to transform the initial grid to the target grid within k operations. Args: - n (int): Number of rows in the grid. - m (int): Number of columns in the grid. - k (int): Maximum number of changes allowed. - initial_grid (list[list[int]]): The starting grid of integers. - target_grid (list[list[int]]): The target grid of integers. Returns: - str: \\"YES\\" if transformation is possible within k changes, \\"NO\\" otherwise. total_changes_needed = 0 for i in range(n): for j in range(m): total_changes_needed += abs(initial_grid[i][j] - target_grid[i][j]) return \\"YES\\" if total_changes_needed <= k else \\"NO\\""},{"question":"import heapq import sys from typing import List, Tuple def shortest_path(n: int, edges: List[Tuple[int, int, int]], src: int, dst: int) -> int: Find the shortest path between two nodes in an undirected graph. >>> shortest_path(4, [(1, 2, 1), (2, 3, 2), (3, 4, 3), (1, 4, 10)], 1, 4) 6 >>> shortest_path(4, [(1, 2, 5), (1, 3, 2)], 1, 4) -1 graph = {i: [] for i in range(1, n + 1)} for u, v, l in edges: graph[u].append((v, l)) graph[v].append((u, l)) distances = {i: sys.maxsize for i in range(1, n + 1)} distances[src] = 0 priority_queue = [(0, src)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances[dst] if distances[dst] != sys.maxsize else -1 def process_test_cases(test_cases: List[Tuple[int, int, List[Tuple[int, int, int]], int, int]]) -> List[int]: Process multiple test cases for the shortest path problem. results = [] for case in test_cases: n, m, edges, src, dst = case results.append(shortest_path(n, edges, src, dst)) return results def find_shortest_paths(input_lines: List[str]) -> List[int]: Read multiple test cases from input lines and return the shortest paths. >>> find_shortest_paths([\\"2\\", \\"4 4\\", \\"1 2 1\\", \\"2 3 2\\", \\"3 4 3\\", \\"1 4 10\\", \\"1 4\\", \\"4 2\\", \\"1 2 5\\", \\"1 3 2\\", \\"1 4\\"]) [6, -1] index = 0 t = int(input_lines[index]) index += 1 test_cases = [] for _ in range(t): n, m = map(int, input_lines[index].split()) index += 1 edges = [] for _ in range(m): u, v, l = map(int, input_lines[index].split()) edges.append((u, v, l)) index += 1 src, dst = map(int, input_lines[index].split()) index += 1 test_cases.append((n, m, edges, src, dst)) return process_test_cases(test_cases) # Unit tests def test_shortest_path(): input_lines = [ \\"2\\", \\"4 4\\", \\"1 2 1\\", \\"2 3 2\\", \\"3 4 3\\", \\"1 4 10\\", \\"1 4\\", \\"4 2\\", \\"1 2 5\\", \\"1 3 2\\", \\"1 4\\" ] expected_output = [6, -1] assert find_shortest_paths(input_lines) == expected_output def test_single_node(): input_lines = [ \\"1\\", \\"1 0\\", \\"1 1\\" ] expected_output = [0] assert find_shortest_paths(input_lines) == expected_output def test_no_edges(): input_lines = [ \\"1\\", \\"3 0\\", \\"1 3\\" ] expected_output = [-1] assert find_shortest_paths(input_lines) == expected_output def test_direct_path(): input_lines = [ \\"1\\", \\"2 1\\", \\"1 2 5\\", \\"1 2\\" ] expected_output = [5] assert find_shortest_paths(input_lines) == expected_output def test_no_direct_path(): input_lines = [ \\"1\\", \\"3 1\\", \\"1 2 2\\", \\"1 3\\" ] expected_output = [-1] assert find_shortest_paths(input_lines) == expected_output","solution":"from heapq import heappop, heappush import sys def shortest_path(n, edges, src, dst): graph = {i: [] for i in range(1, n + 1)} for u, v, l in edges: graph[u].append((v, l)) graph[v].append((u, l)) distances = {i: sys.maxsize for i in range(1, n + 1)} distances[src] = 0 priority_queue = [(0, src)] while priority_queue: current_distance, current_node = heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heappush(priority_queue, (distance, neighbor)) return distances[dst] if distances[dst] != sys.maxsize else -1 def process_test_cases(test_cases): results = [] for case in test_cases: n, m, edges, src, dst = case results.append(shortest_path(n, edges, src, dst)) return results # Function to read multiple test cases and return the results def find_shortest_paths(input_lines): index = 0 t = int(input_lines[index]) index += 1 test_cases = [] for _ in range(t): n, m = map(int, input_lines[index].split()) index += 1 edges = [] for _ in range(m): u, v, l = map(int, input_lines[index].split()) edges.append((u, v, l)) index += 1 src, dst = map(int, input_lines[index].split()) index += 1 test_cases.append((n, m, edges, src, dst)) return process_test_cases(test_cases)"},{"question":"class TreeNode: def __init__(self, value, node_id): self.value = value self.node_id = node_id self.children = [] class BinaryTree: def __init__(self, n, values): self.nodes = [None] + [TreeNode(values[i-1], i) for i in range(1, n+1)] self.parent = [0] * (n + 1) self.level = [0] * (n + 1) def add_edge(self, u, v): Add an edge between node u and v in the binary tree. pass def dfs(self, node, par, lev): Perform DFS for setting up parent and level information. pass def prepare_lca(self): Prepare LCA data structures using dynamic programming approach. pass def find_lca(self, u, v): Find the Lowest Common Ancestor (LCA) of nodes u and v. >>> tree = setup_tree() >>> tree.find_lca(2, 4) 1 >>> tree.find_lca(4, 5) 3 pass def update_node_value(self, u, val): Update value of the node u to val. >>> tree = setup_tree() >>> tree.update_node_value(4, 35) >>> tree.nodes[4].value 35 pass def setup_tree(): Set up the sample binary tree for test cases n = 5 values = [10, 20, 30, 40, 50] tree = BinaryTree(n, values) edges = [(1, 2), (1, 3), (3, 4), (3, 5)] for u, v in edges: tree.add_edge(u, v) tree.dfs(1, -1, 0) tree.prepare_lca() return tree def main(): import sys input = sys.stdin.read data = input().split() index = 0 n = int(data[index]) index += 1 values = list(map(int, data[index:index + n])) index += n tree = BinaryTree(n, values) for _ in range(n - 1): u, v = map(int, data[index:index + 2]) index += 2 tree.add_edge(u, v) tree.dfs(1, -1, 0) tree.prepare_lca() q = int(data[index]) index += 1 results = [] for _ in range(q): operation = data[index] if operation == 'Q': u, v = int(data[index + 1]), int(data[index + 2]) lca = tree.find_lca(u, v) results.append(lca) index += 3 elif operation == 'U': u, val = int(data[index + 1]), int(data[index + 2]) tree.update_node_value(u, val) index += 3 for result in results: print(result) if __name__ == \\"__main__\\": main()","solution":"class TreeNode: def __init__(self, value, node_id): self.value = value self.node_id = node_id self.children = [] class BinaryTree: def __init__(self, n, values): self.nodes = [None] + [TreeNode(values[i-1], i) for i in range(1, n+1)] self.parent = [0] * (n + 1) self.level = [0] * (n + 1) def add_edge(self, u, v): self.nodes[u].children.append(v) self.nodes[v].children.append(u) def dfs(self, node, par, lev): self.parent[node] = par self.level[node] = lev for child in self.nodes[node].children: if child != par: self.dfs(child, node, lev + 1) def prepare_lca(self): n = len(self.nodes) - 1 self.LOG = 1 while (1 << self.LOG) <= n: self.LOG += 1 self.ancestor = [[-1] * (self.LOG + 1) for _ in range(n + 1)] for i in range(n + 1): self.ancestor[i][0] = self.parent[i] for j in range(1, self.LOG + 1): for i in range(1, n + 1): if self.ancestor[i][j-1] != -1: self.ancestor[i][j] = self.ancestor[self.ancestor[i][j-1]][j-1] def find_lca(self, u, v): if self.level[u] < self.level[v]: u, v = v, u diff = self.level[u] - self.level[v] for i in range(self.LOG + 1): if (diff >> i) & 1: u = self.ancestor[u][i] if u == v: return u for i in range(self.LOG, -1, -1): if self.ancestor[u][i] != self.ancestor[v][i]: u = self.ancestor[u][i] v = self.ancestor[v][i] return self.parent[u] def update_node_value(self, u, val): self.nodes[u].value = val def main(): import sys input = sys.stdin.read data = input().split() index = 0 n = int(data[index]) index += 1 values = list(map(int, data[index:index+n])) index += n tree = BinaryTree(n, values) for _ in range(n-1): u, v = map(int, data[index:index+2]) index += 2 tree.add_edge(u, v) tree.dfs(1, -1, 0) tree.prepare_lca() q = int(data[index]) index += 1 results = [] for _ in range(q): operation = data[index] if operation == 'Q': u, v = int(data[index+1]), int(data[index+2]) lca = tree.find_lca(u, v) results.append(lca) index += 3 elif operation == 'U': u, val = int(data[index+1]), int(data[index+2]) tree.update_node_value(u, val) index += 3 for result in results: print(result) if __name__ == \\"__main__\\": main()"},{"question":"class Library: def __init__(self): Initializes an empty library collection pass def add_book(self, title: str, author: str, year_published: int): Adds a new book to the library Args: title (str): The title of the book. author (str): The author of the book. year_published (int): The year the book was published. Raises: ValueError: If a book with the same title already exists. pass def remove_book(self, title: str): Removes a book from the library Args: title (str): The title of the book to remove. Raises: ValueError: If no book with the given title is found. pass def find_books_by_author(self, author: str) -> list: Finds all books by the specified author Args: author (str): The author to search for. Returns: list: A list of books by the specified author. pass def find_books_by_year(self, year: int) -> list: Finds all books published in the specified year Args: year (int): The year to search for. Returns: list: A list of books published in the specified year. pass def list_all_books(self) -> list: Lists all books in the library sorted alphabetically by title Returns: list: A list of all books sorted by title. pass import pytest def test_add_book(): library = Library() library.add_book(\\"Python Programming\\", \\"John Doe\\", 2020) assert library.list_all_books() == [{\\"title\\": \\"Python Programming\\", \\"author\\": \\"John Doe\\", \\"year_published\\": 2020}] with pytest.raises(ValueError, match=\\"Book with this title already exists.\\"): library.add_book(\\"Python Programming\\", \\"Jane Smith\\", 2021) def test_remove_book(): library = Library() library.add_book(\\"Python Programming\\", \\"John Doe\\", 2020) library.remove_book(\\"Python Programming\\") assert library.list_all_books() == [] with pytest.raises(ValueError, match=\\"Book not found.\\"): library.remove_book(\\"Nonexistent Book\\") def test_find_books_by_author(): library = Library() library.add_book(\\"Python Programming\\", \\"John Doe\\", 2020) library.add_book(\\"Machine Learning\\", \\"John Doe\\", 2021) library.add_book(\\"Data Science\\", \\"Jane Smith\\", 2019) books_by_john = library.find_books_by_author(\\"John Doe\\") assert books_by_john == [ {\\"title\\": \\"Python Programming\\", \\"author\\": \\"John Doe\\", \\"year_published\\": 2020}, {\\"title\\": \\"Machine Learning\\", \\"author\\": \\"John Doe\\", \\"year_published\\": 2021} ] books_by_jane = library.find_books_by_author(\\"Jane Smith\\") assert books_by_jane == [ {\\"title\\": \\"Data Science\\", \\"author\\": \\"Jane Smith\\", \\"year_published\\": 2019} ] books_by_nonexistent_author = library.find_books_by_author(\\"Nonexistent Author\\") assert books_by_nonexistent_author == [] def test_find_books_by_year(): library = Library() library.add_book(\\"Python Programming\\", \\"John Doe\\", 2020) library.add_book(\\"Machine Learning\\", \\"John Doe\\", 2021) library.add_book(\\"Data Science\\", \\"Jane Smith\\", 2020) books_published_2020 = library.find_books_by_year(2020) assert books_published_2020 == [ {\\"title\\": \\"Python Programming\\", \\"author\\": \\"John Doe\\", \\"year_published\\": 2020}, {\\"title\\": \\"Data Science\\", \\"author\\": \\"Jane Smith\\", \\"year_published\\": 2020} ] books_published_2019 = library.find_books_by_year(2019) assert books_published_2019 == [] def test_list_all_books(): library = Library() library.add_book(\\"Python Programming\\", \\"John Doe\\", 2020) library.add_book(\\"Machine Learning\\", \\"John Doe\\", 2021) library.add_book(\\"Data Science\\", \\"Jane Smith\\", 2019) all_books = library.list_all_books() assert all_books == [ {\\"title\\": \\"Data Science\\", \\"author\\": \\"Jane Smith\\", \\"year_published\\": 2019}, {\\"title\\": \\"Machine Learning\\", \\"author\\": \\"John Doe\\", \\"year_published\\": 2021}, {\\"title\\": \\"Python Programming\\", \\"author\\": \\"John Doe\\", \\"year_published\\": 2020} ]","solution":"class Library: def __init__(self): self.books = [] def add_book(self, title: str, author: str, year_published: int): if any(book['title'] == title for book in self.books): raise ValueError(\\"Book with this title already exists.\\") new_book = { \\"title\\": title, \\"author\\": author, \\"year_published\\": year_published } self.books.append(new_book) def remove_book(self, title: str): for book in self.books: if book['title'] == title: self.books.remove(book) return raise ValueError(\\"Book not found.\\") def find_books_by_author(self, author: str) -> list: return [book for book in self.books if book['author'] == author] def find_books_by_year(self, year: int) -> list: return [book for book in self.books if book['year_published'] == year] def list_all_books(self) -> list: return sorted(self.books, key=lambda x: x['title'])"},{"question":"def get_top_k_posts(t: int, u: int, p: int, k: int, user_topics: List[List[int]], posts: List[Tuple[int, int, int]]) -> List[List[int]]: Output the top k most liked posts for each user based on the topics they follow. If a user follows no topics or if there are no posts in the topics they follow, return an empty list for that user. >>> t = 3 >>> u = 2 >>> p = 5 >>> k = 2 >>> user_topics = [ >>> [1, 2], >>> [2, 3] >>> ] >>> posts = [ >>> (1, 101, 10), >>> (1, 102, 50), >>> (2, 201, 20), >>> (3, 301, 30), >>> (3, 302, 40) >>> ] >>> get_top_k_posts(t, u, p, k, user_topics, posts) [[102, 201], [302, 301] ] pass from solution import get_top_k_posts def test_basic_example(): t = 3 u = 2 p = 5 k = 2 user_topics = [ [1, 2], [2, 3] ] posts = [ (1, 101, 10), (1, 102, 50), (2, 201, 20), (3, 301, 30), (3, 302, 40) ] result = get_top_k_posts(t, u, p, k, user_topics, posts) assert result == [[102, 201], [302, 301]] def test_single_user_single_topic(): t = 1 u = 1 p = 3 k = 2 user_topics = [ [1] ] posts = [ (1, 101, 5), (1, 102, 10), (1, 103, 7) ] result = get_top_k_posts(t, u, p, k, user_topics, posts) assert result == [[102, 103]] def test_no_posts_for_user_topics(): t = 3 u = 1 p = 3 k = 2 user_topics = [ [2] ] posts = [ (1, 101, 5), (1, 102, 10), (3, 103, 7) ] result = get_top_k_posts(t, u, p, k, user_topics, posts) assert result == [[]] def test_k_greater_than_available_posts(): t = 2 u = 1 p = 2 k = 5 user_topics = [ [1, 2] ] posts = [ (1, 101, 5), (2, 102, 10) ] result = get_top_k_posts(t, u, p, k, user_topics, posts) assert result == [[102, 101]] def test_multiple_users_with_overlapping_topics(): t = 3 u = 2 p = 5 k = 3 user_topics = [ [1, 3], [2] ] posts = [ (1, 101, 12), (1, 102, 8), (2, 201, 15), (3, 301, 5), (3, 302, 20) ] result = get_top_k_posts(t, u, p, k, user_topics, posts) assert result == [[302, 101, 102], [201]]","solution":"def get_top_k_posts(t, u, p, k, user_topics, posts): from collections import defaultdict import heapq # Dictionary to map topics to posts with their likes topic_posts = defaultdict(list) for tid, pid, likes in posts: topic_posts[tid].append((likes, pid)) # For each user's topics, gather posts and determine the top k liked posts user_top_posts = [] for topics in user_topics: post_heap = [] for topic in topics: if topic in topic_posts: for likes, pid in topic_posts[topic]: heapq.heappush(post_heap, (-likes, pid)) top_k = [] for _ in range(min(k, len(post_heap))): top_k.append(heapq.heappop(post_heap)[1]) user_top_posts.append(top_k) return user_top_posts # Example usage: t = 3 u = 2 p = 5 k = 2 user_topics = [ [1, 2], [2, 3] ] posts = [ (1, 101, 10), (1, 102, 50), (2, 201, 20), (3, 301, 30), (3, 302, 40) ] print(get_top_k_posts(t, u, p, k, user_topics, posts))"},{"question":"def find_winner_fighting_power(n: int, fighting_powers: List[int]) -> int: Determines the fighting power of the warrior who will win the tournament. :param n: int - The number of provinces (warriors). :param fighting_powers: list of int - List of fighting powers of each warrior. :return: int - The fighting power of the winning warrior. >>> find_winner_fighting_power(5, [3, 1, 4, 1, 5]) 5 >>> find_winner_fighting_power(3, [10, 20, 30]) 30 >>> find_winner_fighting_power(1, [7]) 7 >>> find_winner_fighting_power(4, [987654, 123456, 789012, 456789]) 987654 >>> find_winner_fighting_power(5, [50, 40, 30, 20, 10]) 50 >>> find_winner_fighting_power(5, [1, 2, 3, 4, 5]) 5 >>> find_winner_fighting_power(6, [-1, -2, -3, -4, -5, 99]) 99","solution":"def find_winner_fighting_power(n, fighting_powers): Determines the fighting power of the warrior who will win the tournament. :param n: int - The number of provinces (warriors). :param fighting_powers: list of int - List of fighting powers of each warrior. :return: int - The fighting power of the winning warrior. return max(fighting_powers)"},{"question":"def min_operations_to_palindrome(s: str) -> int: Given a string s, compute the minimum number of operations required to make it a palindrome. An operation consists of changing a single character at any position in the string to any other lowercase English character. Parameters: s (str): The input string consisting of lowercase English letters. Returns: int: The minimum number of operations required to make the string a palindrome. >>> min_operations_to_palindrome(\\"abcba\\") == 0 >>> min_operations_to_palindrome(\\"abccba\\") == 0 >>> min_operations_to_palindrome(\\"abcdef\\") == 3 >>> min_operations_to_palindrome(\\"a\\") == 0 >>> min_operations_to_palindrome(\\"aa\\") == 0 >>> min_operations_to_palindrome(\\"az\\") == 1 >>> min_operations_to_palindrome(\\"abba\\") == 0 >>> min_operations_to_palindrome(\\"abca\\") == 1 >>> min_operations_to_palindrome(\\"abcd\\") == 2 >>> min_operations_to_palindrome(\\"racecar\\") == 0 >>> min_operations_to_palindrome(\\"raccecar\\") == 1 >>> min_operations_to_palindrome(\\"a\\" * 10**5) == 0 >>> min_operations_to_palindrome(\\"ab\\" * (10**5 // 2)) == 10**5 // 2","solution":"def min_operations_to_palindrome(s): Given a string s, compute the minimum number of operations required to make it a palindrome. An operation consists of changing a single character at any position in the string to any other lowercase English character. Parameters: s (str): The input string consisting of lowercase English letters. Returns: int: The minimum number of operations required to make the string a palindrome. n = len(s) operations = 0 # Compare characters from both ends towards the center for i in range(n // 2): if s[i] != s[n - 1 - i]: operations += 1 return operations"},{"question":"def count_k_inversions(n: int, k: int, arr: List[int]) -> int: Returns the number of k-inversions in the array. Parameters: n (int): Number of elements in the array. k (int): The value of k for k-inversions. arr (list): The list of integers. Returns: int: The number of k-inversions in the array. Examples: >>> count_k_inversions(5, 2, [1, 3, 2, 5, 4]) 5 >>> count_k_inversions(4, 0, [1, 2, 3, 4]) 0","solution":"def count_k_inversions(n, k, arr): Returns the number of k-inversions in the array. Parameters: n (int): Number of elements in the array. k (int): The value of k for k-inversions. arr (list): The list of integers. Returns: int: The number of k-inversions in the array. count = 0 for i in range(n): for j in range(i + 1, n): if 0 <= arr[j] - arr[i] <= k: count += 1 return count"},{"question":"from typing import List def can_form_magical_sequence(s: str) -> str: Determine if it is possible to form at least one \\"magical sequence\\" from the given string. A \\"magical sequence\\" is a subsequence where each character appears an even number of times. Parameters: s (str): The input string consisting of lowercase English letters. Returns: str: \\"YES\\" if it is possible to form at least one magical sequence, \\"NO\\" otherwise. Examples: >>> can_form_magical_sequence('abba') 'YES' >>> can_form_magical_sequence('abc') 'NO'","solution":"def can_form_magical_sequence(s): Determine if it is possible to form at least one \\"magical sequence\\" from the given string. A \\"magical sequence\\" is a subsequence where each character appears an even number of times. Parameters: s (str): The input string consisting of lowercase English letters. Returns: str: \\"YES\\" if it is possible to form at least one magical sequence, \\"NO\\" otherwise. from collections import Counter # Count the frequency of each character char_count = Counter(s) # If there's any character with an odd frequency, it's not possible to form # a magical sequence where each character appears an even number of times for count in char_count.values(): if count % 2 != 0: return \\"NO\\" return \\"YES\\""},{"question":"def largest_rectangle_area(heights): Calculate the maximum rectangle area that can be formed in a histogram. :param heights: List of integers representing heights of buildings. :return: Integer representing the maximum rectangle area. Examples: >>> largest_rectangle_area([2, 1, 5, 6, 2, 3, 4]) 10 >>> largest_rectangle_area([5]) 5 >>> largest_rectangle_area([4, 4, 4, 4]) 16 >>> largest_rectangle_area([1, 2, 3, 4, 5]) 9 >>> largest_rectangle_area([5, 4, 3, 2, 1]) 9 >>> largest_rectangle_area([2, 1, 2]) 3 >>> largest_rectangle_area([1] * 100000) 100000","solution":"def largest_rectangle_area(heights): Calculate the maximum rectangle area that can be formed in a histogram. :param heights: List of integers representing heights of buildings. :return: Integer representing the maximum rectangle area. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] > heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def min_changes_to_alternate(sequence: str) -> int: Given a sequence of 'R' and 'B', returns the minimum number of changes needed so that no two adjacent marbles are of the same color. >>> min_changes_to_alternate('RRBBBR') 2 >>> min_changes_to_alternate('BRRRB') 1 >>> min_changes_to_alternate('RBRB') 0 >>> min_changes_to_alternate('BRBR') 0 >>> min_changes_to_alternate('RRRR') 2 >>> min_changes_to_alternate('BBBB') 2 >>> min_changes_to_alternate('R') 0 >>> min_changes_to_alternate('B') 0 >>> min_changes_to_alternate('RB') 0 >>> min_changes_to_alternate('BR') 0 >>> min_changes_to_alternate('RR') 1 >>> min_changes_to_alternate('BB') 1 >>> min_changes_to_alternate('RBRBRBRB') 0 >>> min_changes_to_alternate('RBRBRBRRRBRBRBRBR') 1","solution":"def min_changes_to_alternate(sequence): Given a sequence of 'R' and 'B', returns the minimum number of changes needed so that no two adjacent marbles are of the same color. n = len(sequence) # Count changes for starting with 'R' change_count_1 = 0 # Count changes for starting with 'B' change_count_2 = 0 for i in range(n): expected_char_1 = 'R' if i % 2 == 0 else 'B' expected_char_2 = 'B' if i % 2 == 0 else 'R' if sequence[i] != expected_char_1: change_count_1 += 1 if sequence[i] != expected_char_2: change_count_2 += 1 return min(change_count_1, change_count_2)"},{"question":"from typing import List, Tuple def find_destination_cells(n: int, m: int, grid: List[List[int]]) -> List[List[Tuple[int, int]]]: Given a grid with each cell containing a positive integer, find for each cell the cell to which it should move such that the destination cell has a smaller value. If there are multiple choices, prefer the one with the smallest row number, then smallest column number. >>> find_destination_cells(2, 2, [[1, 2], [3, 4]]) [[(1, 1), (1, 1)], [(1, 1), (1, 2)]] >>> find_destination_cells(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[(1, 1), (1, 1), (1, 2)], [(1, 1), (1, 2), (1, 3)], [(2, 1), (2, 2), (2, 3)]] # Unit tests def test_find_destination_cells_small_grid(): n, m = 2, 2 grid = [ [1, 2], [3, 4] ] expected = [ [(1, 1), (1, 1)], [(1, 1), (1, 2)] ] assert find_destination_cells(n, m, grid) == expected def test_find_destination_cells_medium_grid(): n, m = 3, 3 grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] expected = [ [(1, 1), (1, 1), (1, 2)], [(1, 1), (1, 2), (1, 3)], [(2, 1), (2, 2), (2, 3)] ] assert find_destination_cells(n, m, grid) == expected def test_find_destination_cells_large_grid(): n, m = 4, 4 grid = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] expected = [ [(1, 1), (1, 1), (1, 2), (1, 3)], [(1, 1), (1, 2), (1, 3), (1, 4)], [(2, 1), (2, 2), (2, 3), (2, 4)], [(3, 1), (3, 2), (3, 3), (3, 4)] ] assert find_destination_cells(n, m, grid) == expected def test_find_destination_cells_single_row(): n, m = 1, 3 grid = [ [3, 2, 1] ] expected = [ [(1, 2), (1, 3), (1, 3)] ] assert find_destination_cells(n, m, grid) == expected def test_find_destination_cells_single_column(): n, m = 3, 1 grid = [ [3], [2], [1] ] expected = [ [(2, 1)], [(3, 1)], [(3, 1)] ] assert find_destination_cells(n, m, grid) == expected","solution":"def find_destination_cells(n, m, grid): def is_valid(x, y): return 0 <= x < n and 0 <= y < m directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] result = [] for i in range(n): row_result = [] for j in range(m): min_value = grid[i][j] min_pos = (i, j) for dx, dy in directions: ni, nj = i + dx, j + dy if is_valid(ni, nj) and grid[ni][nj] < min_value: min_value = grid[ni][nj] min_pos = (ni, nj) row_result.append((min_pos[0] + 1, min_pos[1] + 1)) # Convert to 1-based index result.append(row_result) return result # Example usage: # n, m = 4, 4 # grid = [ # [1, 2, 3, 4], # [5, 6, 7, 8], # [9, 10, 11, 12], # [13, 14, 15, 16] # ] # for row in find_destination_cells(n, m, grid): # print(\\", \\".join(f\\"{x} {y}\\" for x, y in row))"},{"question":"def optimal_pairings(n: int, scores: List[int]) -> List[Tuple[int, int]]: Given the number of participants n and their scores, return the optimal pairings such that the difference in scores between paired participants is minimized. :param n: Integer, the number of participants (always even) :param scores: List of integers, the scores of the participants. :return: List of tuple pairs, each containing pairs of scores in non-decreasing order. >>> optimal_pairings(4, [100, 300, 200, 400]) == [(100, 200), (300, 400)] >>> optimal_pairings(6, [1, 3, 5, 7, 9, 11]) == [(1, 3), (5, 7), (9, 11)]","solution":"def optimal_pairings(n, scores): Given the number of participants n and their scores, returns the optimal pairings such that the difference in scores between paired participants is minimized. :param n: Integer, the number of participants (always even) :param scores: List of integers, the scores of the participants. :return: List of tuple pairs, each containing pairs of scores in non-decreasing order. # Sort the scores in non-decreasing order sorted_scores = sorted(scores) # Create pairs from the sorted list pairs = [] for i in range(0, n, 2): pairs.append((sorted_scores[i], sorted_scores[i + 1])) return pairs"},{"question":"def min_employees_needed(n: int, meetings: list) -> int: Finds the minimum number of employees required to attend all meetings. Args: n (int): Number of meetings. meetings (list of lists): Each sublist represents employees that can attend a meeting. Returns: int: Minimum number of employees required to attend all meetings. Example: >>> min_employees_needed(4, [[1, 2, 3], [2, 4], [1, 3, 4], [4]]) 2 >>> min_employees_needed(1, [[1, 2, 3]]) 1 >>> min_employees_needed(3, [[1], [2], [3]]) 3 >>> min_employees_needed(2, [[1, 2], [1, 2]]) 1 >>> min_employees_needed(3, [[1, 2, 3], [2, 4], [1, 4]]) 2","solution":"def min_employees_needed(n, meetings): Finds the minimum number of employees required to attend all meetings. Args: n (int): Number of meetings. meetings (list of lists): Each sublist represents employees that can attend a meeting. Returns: int: Minimum number of employees required to attend all meetings. from itertools import combinations # Extract all unique employees present in the meetings employees = set() for meeting in meetings: employees.update(meeting) employees = list(employees) min_employees_num = len(employees) # Check all combinations of employees for r in range(1, len(employees) + 1): for combo in combinations(employees, r): if all(any(emp in combo for emp in meeting) for meeting in meetings): min_employees_num = min(min_employees_num, r) break return min_employees_num"},{"question":"def min_shipments(n: int, weights: List[int], max_weight: int) -> int: Determine the minimum number of shipments required to deliver all packages. :param n: Number of packages :param weights: List of weights of each package :param max_weight: Maximum allowable weight per shipment :return: Minimum number of shipments required >>> min_shipments(4, [10, 20, 30, 40], 50) 3 >>> min_shipments(6, [5, 5, 5, 5, 5, 5], 10) 3","solution":"def min_shipments(n, weights, max_weight): Determine the minimum number of shipments required to deliver all packages. :param n: Number of packages :param weights: List of weights of each package :param max_weight: Maximum allowable weight per shipment. :return: Minimum number of shipments required # Sorting weights in descending order to optimize the number of shipments weights.sort(reverse=True) shipments = 0 i = 0 while i < n: current_weight = 0 while i < n and current_weight + weights[i] <= max_weight: current_weight += weights[i] i += 1 shipments += 1 return shipments"},{"question":"def max_valid_number_sequences(n: int) -> int: Returns the maximum number of valid number sequences that can be formed from a WonderPaper of length n. >>> max_valid_number_sequences(10) 4 >>> max_valid_number_sequences(1) 1 >>> max_valid_number_sequences(7) 3 >>> max_valid_number_sequences(1000) 44 >>> max_valid_number_sequences(10**6) 1413 >>> max_valid_number_sequences(15) 5","solution":"def max_valid_number_sequences(n): Returns the maximum number of valid number sequences that can be formed from a WonderPaper of length n. l = 1 while (l * (l + 1) // 2 <= n): l += 1 return l - 1"},{"question":"def min_operations_to_transform(s: str, t: str) -> int: Determines the minimum number of operations needed to transform string s into string t. In one operation, you can select any character in the string s and change it to any other character. - if the lengths of \`s\` and \`t\` are different, it's impossible to transform \`s\` into \`t\`. Args: s (str): The string to be transformed. t (str): The target string. Returns: int: The minimum number of operations, or -1 if transformation is impossible. >>> min_operations_to_transform(\\"abc\\", \\"abc\\") 0 >>> min_operations_to_transform(\\"a\\", \\"b\\") 1 >>> min_operations_to_transform(\\"abc\\", \\"abcd\\") -1 >>> min_operations_to_transform(\\"abcde\\", \\"fghij\\") 5 >>> min_operations_to_transform(\\"abcd\\", \\"abef\\") 2 >>> min_operations_to_transform(\\"\\", \\"\\") 0 >>> min_operations_to_transform(\\"aabbcc\\", \\"zzxxcc\\") 4","solution":"def min_operations_to_transform(s, t): Determines the minimum number of operations needed to transform string s into string t. In one operation, you can select any character in the string s and change it to any other character. - if the lengths of \`s\` and \`t\` are different, it's impossible to transform \`s\` into \`t\`. Args: s (str): The string to be transformed. t (str): The target string. Returns: int: The minimum number of operations, or -1 if transformation is impossible. if len(s) != len(t): return -1 operations = 0 for char_s, char_t in zip(s, t): if char_s != char_t: operations += 1 return operations"},{"question":"from typing import List def is_path_exists(n: int, m: int, grid: List[List[int]]) -> str: Determines if there's a path from the top-left corner (0, 0) to the bottom-right corner (n-1, m-1) in the binary matrix \`grid\` moving only right or downward through cells with value 0. Args: n : int : number of rows in the grid m : int : number of columns in the grid grid : List[List[int]] : the binary matrix representing the grid Returns: str : 'YES' if a path exists, 'NO' otherwise Examples: >>> is_path_exists(4, 4, [ ... [0, 0, 1, 0], ... [0, 1, 0, 0], ... [0, 0, 0, 1], ... [1, 0, 0, 0] ... ]) 'YES' >>> is_path_exists(3, 3, [ ... [0, 1, 0], ... [1, 0, 1], ... [0, 0, 0] ... ]) 'NO'","solution":"def is_path_exists(n, m, grid): Determines if there's a path from the top-left corner (0, 0) to the bottom-right corner (n-1, m-1) in the binary matrix \`grid\` moving only right or downward through cells with value 0. Args: n : int : number of rows in the grid m : int : number of columns in the grid grid : List[List[int]] : the binary matrix representing the grid Returns: str : 'YES' if a path exists, 'NO' otherwise if grid[0][0] == 1 or grid[n-1][m-1] == 1: return \\"NO\\" visited = [[False] * m for _ in range(n)] queue = [(0, 0)] directions = [(0, 1), (1, 0)] while queue: x, y = queue.pop(0) if x == n-1 and y == m-1: return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and grid[nx][ny] == 0: visited[nx][ny] = True queue.append((nx, ny)) return \\"NO\\""},{"question":"def is_subsequence(s: str, word: str) -> bool: it = iter(s) return all(char in it for char in word) def count_subsequences(s: str, words: List[str]) -> int: Counts how many words in the list are subsequences of the string \`s\`. >>> count_subsequences(\\"abcdefg\\", [\\"abc\\", \\"abg\\", \\"bdf\\", \\"acb\\", \\"bgf\\"]) 3 >>> count_subsequences(\\"abc\\", [\\"a\\", \\"b\\", \\"c\\", \\"d\\"]) 3 >>> count_subsequences(\\"test\\", [\\"test\\", \\"tst\\", \\"et\\", \\"es\\"]) 4 >>> count_subsequences(\\"xyz\\", [\\"abc\\", \\"ab\\", \\"a\\", \\"b\\"]) 0 >>> count_subsequences(\\"a\\" * 100000, [\\"a\\" * 50] * 10000) 10000","solution":"def is_subsequence(s, word): it = iter(s) return all(char in it for char in word) def count_subsequences(s, words): Counts how many words in the list are subsequences of the string \`s\`. return sum(is_subsequence(s, word) for word in words)"},{"question":"def smallest_string_by_reversing_segment(s: str) -> str: Determine the lexicographically smallest string that can be obtained by reversing exactly one segment of the given string s. Parameters: s (str): The input string consisting of lowercase English letters. Returns: str: The lexicographically smallest string possible. >>> smallest_string_by_reversing_segment(\\"abcdefghijk\\") \\"abcdefghijk\\" >>> smallest_string_by_reversing_segment(\\"abcdefhgfijk\\") \\"abcdeffghijk\\" >>> smallest_string_by_reversing_segment(\\"fedcba\\") \\"abcdef\\" >>> smallest_string_by_reversing_segment(\\"a\\") \\"a\\" >>> smallest_string_by_reversing_segment(\\"zyxwvutsrqponmlkjihgfedcba\\") \\"abcdefghijklmnopqrstuvwxyz\\" >>> smallest_string_by_reversing_segment(\\"bac\\") \\"abc\\" >>> smallest_string_by_reversing_segment(\\"cbad\\") \\"abcd\\" >>> smallest_string_by_reversing_segment(\\"edcba\\") \\"abcde\\"","solution":"def smallest_string_by_reversing_segment(s): Determine the lexicographically smallest string that can be obtained by reversing exactly one segment of the given string s. Parameters: s (str): The input string consisting of lowercase English letters. Returns: str: The lexicographically smallest string possible. n = len(s) smallest_string = s for i in range(n): for j in range(i, n): reversed_segment = s[i:j+1][::-1] new_string = s[:i] + reversed_segment + s[j+1:] if new_string < smallest_string: smallest_string = new_string return smallest_string"},{"question":"def max_pairs_of_protons_and_neutrons(p: int, n: int) -> int: Given the number of protons (p) and the number of neutrons (n), returns the maximum number of pairs containing exactly one proton and one neutron. >>> max_pairs_of_protons_and_neutrons(5, 3) 3 >>> max_pairs_of_protons_and_neutrons(7, 10) 7","solution":"def max_pairs_of_protons_and_neutrons(p, n): Given the number of protons (p) and the number of neutrons (n), returns the maximum number of pairs containing exactly one proton and one neutron. return min(p, n)"},{"question":"def max_illuminated_cells(n: int, m: int, grid: List[str]) -> int: Determine the maximum number of empty cells that can be illuminated by placing a light in a single empty cell. A light placed in a cell can illuminate all cells in the same row and column, stopping at any trees it encounters. Args: n: int: number of rows m: int: number of columns grid: List[str]: grid with '.' representing empty cells and '#' representing trees Returns: int: Maximum number of illuminated empty cells >>> max_illuminated_cells(4, 4, [\\".#..\\", \\"..#.\\", \\"...#\\", \\"..#.\\"]) 6 >>> max_illuminated_cells(3, 3, [\\"...\\", \\"...\\", \\"...\\"]) 5 >>> max_illuminated_cells(3, 3, [\\"#\\", \\"#\\", \\"#\\"]) 0 >>> max_illuminated_cells(1, 5, [\\"....#\\"]) 4 >>> max_illuminated_cells(5, 1, [\\".\\", \\".\\", \\"#\\", \\".\\", \\".\\"]) 2 >>> max_illuminated_cells(3, 3, [\\"#.#\\", \\".#.\\", \\"#.#\\"]) 1","solution":"def max_illuminated_cells(n, m, grid): max_illuminated = 0 for i in range(n): for j in range(m): if grid[i][j] == '.': count = 1 # Include the cell itself # Check horizontally to the left left = j - 1 while left >= 0 and grid[i][left] == '.': count += 1 left -= 1 # Check horizontally to the right right = j + 1 while right < m and grid[i][right] == '.': count += 1 right += 1 # Check vertically up up = i - 1 while up >= 0 and grid[up][j] == '.': count += 1 up -= 1 # Check vertically down down = i + 1 while down < n and grid[down][j] == '.': count += 1 down += 1 max_illuminated = max(max_illuminated, count) return max_illuminated"},{"question":"def minimal_upgrade_time(n: int, W: List[int], T: List[int]) -> int: Given n servers in ring topology, the maintenance window W and upgrade time T, this function returns the minimal time (in hours) needed to upgrade a server to minimally affect the network operation. Parameters: n (int): Number of servers W (list of int): Maintenance window for each server T (list of int): Time required to perform the upgrade for each server Returns: int: The minimal upgrade time >>> minimal_upgrade_time(3, [8, 5, 7], [4, 3, 2]) 2 >>> minimal_upgrade_time(1, [5], [3]) 3 >>> minimal_upgrade_time(4, [10, 5, 7, 8], [1, 4, 5, 3]) 1 >>> minimal_upgrade_time(4, [10, 5, 7, 8], [4, 6, 5, 1]) 1 >>> minimal_upgrade_time(5, [8, 8, 8, 8, 8], [3, 3, 3, 3, 3]) 3 >>> minimal_upgrade_time(5, [12, 15, 10, 20, 8], [6, 9, 5, 4, 2]) 2","solution":"def minimal_upgrade_time(n, W, T): Given n servers in ring topology, the maintenance window W and upgrade time T, this function returns the minimal time (in hours) needed to upgrade a server to minimally affect the network operation. Parameters: n (int): Number of servers W (list of int): Maintenance window for each server T (list of int): Time required to perform the upgrade for each server Returns: int: The minimal upgrade time # The minimal time will be the minimum value in the given upgrade times T. return min(T)"},{"question":"def min_roads_to_remove_to_make_eulerian(n: int, m: int, edges: List[Tuple[int, int]]) -> int: Determine the minimum number of roads to remove to make the graph Eulerian. Parameters: n (int): Number of vertices m (int): Number of edges edges (list of tuples): List of edges represented as tuples (u, v) Returns: int: Minimum number of roads to remove >>> min_roads_to_remove_to_make_eulerian(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) == 0 >>> min_roads_to_remove_to_make_eulerian(2, 1, [(1, 2)]) == 1 >>> min_roads_to_remove_to_make_eulerian(5, 6, [(1, 2), (2, 3), (3, 4), (4, 1), (1, 5), (5, 3)]) == 1 >>> min_roads_to_remove_to_make_eulerian(3, 0, []) == 0 >>> min_roads_to_remove_to_make_eulerian(6, 7, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (1, 3)]) == 1","solution":"def min_roads_to_remove_to_make_eulerian(n, m, edges): Determine the minimum number of roads to remove to make the graph Eulerian. Parameters: n (int): Number of vertices m (int): Number of edges edges (list of tuples): List of edges represented as tuples (u, v) Returns: int: Minimum number of roads to remove # Initialize degrees of vertices degree = [0] * n # Calculate the degree of each vertex for u, v in edges: degree[u-1] += 1 degree[v-1] += 1 # Count the number of vertices with odd degrees odd_degree_count = sum(1 for d in degree if d % 2 != 0) # To make the graph Eulerian, we need to remove (odd_degree_count // 2) edges return odd_degree_count // 2"},{"question":"def can_fulfill_toy_wishes(n: int, toys: List[int], m: int, wishes: List[int]) -> str: Determines whether all children's toy wishes can be fulfilled. :param n: int - Number of different types of toys available :param toys: list of int - Numbers of toys of each type available :param m: int - Number of children :param wishes: list of int - Desired toy type for each child :return: str - 'YES' if all wishes can be fulfilled, otherwise 'NO' >>> can_fulfill_toy_wishes(3, [1, 2, 1], 3, [1, 2, 3]) 'YES' >>> can_fulfill_toy_wishes(2, [1, 2], 3, [1, 2, 1]) 'NO'","solution":"def can_fulfill_toy_wishes(n, toys, m, wishes): Determines whether all children's toy wishes can be fulfilled. :param n: int - Number of different types of toys available :param toys: list of int - Numbers of toys of each type available :param m: int - Number of children :param wishes: list of int - Desired toy type for each child :return: str - 'YES' if all wishes can be fulfilled, otherwise 'NO' toy_count = [0] * n for i in range(n): toy_count[i] = toys[i] for wish in wishes: if toy_count[wish - 1] > 0: toy_count[wish - 1] -= 1 else: return 'NO' return 'YES'"},{"question":"def count_special_subarrays(n: int, k: int, array: List[int]) -> int: Determine the number of distinct subarrays of length exactly k such that the minimum value in the subarray is equal to the maximum value in the subarray. >>> count_special_subarrays(6, 3, [1, 1, 1, 2, 2, 2]) 2 >>> count_special_subarrays(6, 2, [1, 1, 3, 3, 3, 1]) 2","solution":"def count_special_subarrays(n, k, array): if k > n: return 0 count = 0 subarrays = set() for i in range(n - k + 1): subarray = array[i:i + k] if len(set(subarray)) == 1: subarrays.add(tuple(subarray)) return len(subarrays)"},{"question":"from typing import List, Tuple def rearrange_sequence(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[List[int]]: Rearrange a sequence of integers such that no two adjacent elements are the same. If such an arrangement is not possible, return [-1]. >>> rearrange_sequence(3, [(4, [1, 1, 2, 2]), (1, [1]), (6, [1, 1, 2, 2, 3, 3])]) [[1, 2, 1, 2], [1], [1, 3, 1, 3, 2, 2]] >>> rearrange_sequence(1, [(3, [1, 1, 1])]) [-1]","solution":"from collections import Counter import heapq def rearrange_sequence(t, test_cases): results = [] for n, sequence in test_cases: if n == 1: results.append(sequence) continue elem_count = Counter(sequence) max_heap = [(-count, elem) for elem, count in elem_count.items()] heapq.heapify(max_heap) prev_count, prev_elem = 0, None result = [] while max_heap: count, elem = heapq.heappop(max_heap) result.append(elem) if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_elem)) prev_count, prev_elem = count + 1, elem if len(result) != n: results.append(-1) else: results.append(result) return results # Examples of how to call the function for testing: # t = 3 # test_cases = [ # (4, [1, 1, 2, 2]), # Possible rearrangement example output: [1, 2, 1, 2] # (1, [1]), # Only one element, output: [1] # (6, [1, 1, 2, 2, 3, 3]) # Possible rearrangement example output: [1, 3, 1, 3, 2, 2] # ] # rearrange_sequence(t, test_cases)"},{"question":"def can_touch(n: int, m: int, x1: int, y1: int, x2: int, y2: int, x3: int, y3: int, x4: int, y4: int) -> str: Determines if two rectangles can be rearranged to touch either edge-to-edge or corner-to-corner within a grid of size n x m where the rectangles are defined by their bottom-left and top-right corners. Parameters: n (int): The number of rows in the grid. m (int): The number of columns in the grid. x1, y1, x2, y2 (int): Coordinates of the first rectangle's bottom-left and top-right corners. x3, y3, x4, y4 (int): Coordinates of the second rectangle's bottom-left and top-right corners. Returns: str: \\"YES\\" if the rectangles can be rearranged to touch at least on one of their edges or corners, else \\"NO\\". Examples: >>> can_touch(10, 10, 1, 1, 3, 3, 4, 1, 6, 3) 'YES' >>> can_touch(10, 10, 1, 1, 3, 3, 5, 1, 7, 3) 'NO' pass","solution":"def can_touch(n, m, x1, y1, x2, y2, x3, y3, x4, y4): Determines if two rectangles can be rearranged to touch either edge-to-edge or corner-to-corner. # Check edge-to-edge or corner-to-corner alignment in horizontal or vertical directions if (x2 == x3 - 1 or x1 == x4 + 1) and (y1 <= y4 and y2 >= y3): return \\"YES\\" if (y2 == y3 - 1 or y1 == y4 + 1) and (x1 <= x4 and x2 >= x3): return \\"YES\\" if (x2 + 1 == x3 or x1 - 1 == x4) and (y2 + 1 == y3 or y1 - 1 == y4): return \\"YES\\" if (y2 + 1 == y3 or y1 - 1 == y4) and (x2 + 1 == x3 or x1 - 1 == x4): return \\"YES\\" return \\"NO\\""},{"question":"def max_path_sum(grid): Returns the maximum sum of values in any path from the top-left corner to the bottom-right corner of the grid. Only right and down movements are allowed. >>> max_path_sum([ ... [5, 3, 2], ... [1, 7, 1], ... [4, 6, 5] ... ]) == 26 >>> max_path_sum([ ... [1] ... ]) == 1 >>> max_path_sum([ ... [1, 2, 3, 4] ... ]) == 10 >>> max_path_sum([ ... [1], ... [2], ... [3], ... [4] ... ]) == 10 >>> max_path_sum([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == 29 # Function implementation here","solution":"def max_path_sum(grid): Returns the maximum sum of values in any path from the top-left corner to the bottom-right corner of the grid. Only right and down movements are allowed. n = len(grid) m = len(grid[0]) # Create a dp table to store the maximum sum upto each cell dp = [[0] * m for _ in range(n)] # Initialize the top-left corner dp[0][0] = grid[0][0] # Fill the first row for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, n): for j in range(1, m): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[n-1][m-1]"},{"question":"def max_pairs_with_strength_difference(strengths: List[int], K: int) -> int: Calculate the maximum number of pairs of warriors with strength difference less than or equal to K. >>> max_pairs_with_strength_difference([1, 3, 5, 9, 12], 3) 2 >>> max_pairs_with_strength_difference([1], 1) 0 >>> max_pairs_with_strength_difference([1, 4, 7, 10], 2) 0 >>> max_pairs_with_strength_difference([1, 2, 3, 4, 5], 10) 2 >>> max_pairs_with_strength_difference([1, 3, 2, 2, 4, 6, 5], 2) 3 >>> max_pairs_with_strength_difference([5, 9, 20, 24, 28], 100) 2 >>> max_pairs_with_strength_difference([1, 10, 20, 30], 5) 0 >>> max_pairs_with_strength_difference([1, 5, 9, 13, 17], 4) 2","solution":"def max_pairs_with_strength_difference(strengths, K): Calculate the maximum number of pairs of warriors with strength difference less than or equal to K. strengths.sort() N = len(strengths) pairs = 0 i = 0 while i < N - 1: if strengths[i+1] - strengths[i] <= K: pairs += 1 i += 2 # Skip next warrior since he is already paired else: i += 1 # Try to find a pair for the current warrior with the next one return pairs"},{"question":"def min_path_risk(grid: List[List[int]]) -> int: Calculate the minimum total risk the drone encounters while traversing from the top-left to the bottom-right of a grid. >>> min_path_risk([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_path_risk([[5]]) 5 >>> min_path_risk([[1, 2], [1, 1]]) 3 >>> min_path_risk([[10, 20, 30], [40, 50, 60], [70, 80, 90]]) 210 >>> min_path_risk([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0","solution":"def min_path_risk(grid): n = len(grid) m = len(grid[0]) # Create a 2D dp array to store the minimum risk encountered to reach each cell dp = [[0] * m for _ in range(n)] # Initialize the dp table dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column (can only come from above) for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, n): for j in range(1, m): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The bottom-right corner will have the minimum risk encountered to reach it return dp[n-1][m-1] # Example usage: # grid = [ # [1, 3, 1], # [1, 5, 1], # [4, 2, 1] # ] # print(min_path_risk(grid)) # Output: 7"},{"question":"def find_path_with_checkpoints(n: int, m: int, k: int, grid: List[str]) -> str: Noora needs to find a path from the top-left corner to the bottom-right corner of the grid, visiting k chosen checkpoints. >>> find_path_with_checkpoints(5, 5, 2, [\\".....\\", \\".#...\\", \\".....\\", \\"...\\", \\".....\\"]).startswith(\\"YES\\") True >>> find_path_with_checkpoints(3, 3, 1, [\\"...\\", \\"#\\", \\"...\\"]) == \\"NO\\" True >>> find_path_with_checkpoints(4, 4, 2, [\\"....\\", \\"...#\\", \\"....\\", \\"..\\"]).startswith(\\"YES\\") True >>> find_path_with_checkpoints(2, 2, 1, [\\"..\\", \\"..\\"]).startswith(\\"YES\\") True >>> find_path_with_checkpoints(4, 4, 3, [\\"..#.\\", \\"....\\", \\"...#\\", \\"..\\"]).startswith(\\"YES\\") True","solution":"from itertools import product import random def find_path_with_checkpoints(n, m, k, grid): empty_cells = [(i, j) for i, j in product(range(n), range(m)) if grid[i][j] == '.'] # If not enough empty cells to choose \`k\` checkpoints, return \\"NO\\" if len(empty_cells) < k: return \\"NO\\" def bfs(start, end): Simple BFS to find the path from start to end avoiding obstacles. queue = [(start, [])] visited = set() while queue: (x, y), path = queue.pop(0) if (x, y) == end: return path for dx, dy, move in [(-1, 0, 'U'), (1, 0, 'D'), (0, -1, 'L'), (0, 1, 'R')]: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] == '.': visited.add((nx, ny)) queue.append(((nx, ny), path + [move])) return None # Try multiple random configurations to find a feasible path for _ in range(100): # Max attempts to randomly select checkpoints checkpoints = random.sample(empty_cells, k) checkpoints = [(0, 0)] + checkpoints + [(n-1, m-1)] total_path = [] possible = True for i in range(len(checkpoints) - 1): part_path = bfs(checkpoints[i], checkpoints[i+1]) if part_path is None: possible = False break total_path.extend(part_path) if possible: return \\"YESn\\" + ''.join(total_path) return \\"NO\\""},{"question":"def find_segment(n, final_seq): Finds the segment (l, r) which, when shifted to the right and reversed, results in the given final sequence, or returns (0, 0) if it's not possible. >>> find_segment(5, [1, 5, 4, 3, 2]) (2, 5) >>> find_segment(6, [1, 3, 4, 2, 5, 6]) (0, 0)","solution":"def find_segment(n, final_seq): Finds the segment (l, r) which, when shifted to the right and reversed, results in the given final sequence, or returns (0, 0) if it's not possible. initial_seq = list(range(1, n + 1)) # Find the start and end of the segment that is reversed l, r = None, None for i in range(n): if initial_seq[i] != final_seq[i]: l = i break for i in range(n - 1, -1, -1): if initial_seq[i] != final_seq[i]: r = i break if l is None and r is None: # When the sequence is already sorted return 0, 0 if l is not None and r is not None: # Reverse the segment from l to r in initial_seq reversed_segment = initial_seq[:l] + list(reversed(initial_seq[l:r+1])) + initial_seq[r+1:] if reversed_segment == final_seq: return l + 1, r + 1 return 0, 0"},{"question":"def can_be_palindrome(n: int, s: str) -> str: Determines if there is at least one sequence of moves that result in a palindromic string. :param n: Length of the string :param s: The string consisting of lowercase English letters :return: \\"YES\\" if it's possible to form a palindrome, \\"NO\\" otherwise >>> can_be_palindrome(7, 'abacaba') 'YES' >>> can_be_palindrome(6, 'abcdef') 'NO'","solution":"def can_be_palindrome(n, s): Determines if there is at least one sequence of moves that result in a palindromic string. :param n: Length of the string :param s: The string consisting of lowercase English letters :return: \\"YES\\" if it's possible to form a palindrome, \\"NO\\" otherwise # If the string is already a palindrome if s == s[::-1]: return \\"YES\\" # Check if there exists a character that occurs at least twice from collections import Counter counter = Counter(s) # If any character appears more than once, it's possible to form a palindrome for count in counter.values(): if count > 1: return \\"YES\\" return \\"NO\\""},{"question":"def find_friend_circles(n: int, m: int, friendships: List[List[int]]) -> int: Find the number of distinct friend circles in the network. Args: n : int : number of users m : int : number of friendships friendships : List[List[int]] : list of friendships represented by pairs of user IDs Returns: int : number of distinct friend circles Example: >>> find_friend_circles(6, 3, [[1, 2], [2, 3], [4, 5]]) 3 >>> find_friend_circles(6, 0, []) 6 from typing import List # Unit Tests def test_no_friendships(): assert find_friend_circles(5, 0, []) == 5 def test_single_friendship(): assert find_friend_circles(3, 1, [[1, 2]]) == 2 def test_multiple_friendships(): assert find_friend_circles(6, 3, [[1, 2], [2, 3], [4, 5]]) == 3 def test_all_connected(): assert find_friend_circles(4, 3, [[1, 2], [2, 3], [3, 4]]) == 1 def test_circular_friendships(): assert find_friend_circles(4, 4, [[1, 2], [2, 3], [3, 4], [4, 1]]) == 1 def test_disconnected_groups(): assert find_friend_circles(6, 3, [[1, 2], [3, 4], [5, 6]]) == 3","solution":"def find_friend_circles(n, m, friendships): parent = list(range(n + 1)) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): root_x = find(x) root_y = find(y) if root_x != root_y: parent[root_y] = root_x for a, b in friendships: union(a, b) distinct_circles = len(set(find(x) for x in range(1, n + 1))) return distinct_circles"},{"question":"from typing import List, Tuple def min_operations_to_equal_array(n: int, arr: List[int]) -> int: Returns the minimum number of operations required to make all elements in the array equal. >>> min_operations_to_equal_array(3, [4, 1, 3]) 5 >>> min_operations_to_equal_array(4, [2, 7, 3, 5]) 9 pass def process_test_cases(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Processes multiple test cases and returns the result for each one. >>> process_test_cases(2, [(3, [4, 1, 3]), (4, [2, 7, 3, 5])]) [5, 9] pass # Unit Test def test_min_operations_to_equal_array(): assert min_operations_to_equal_array(3, [4, 1, 3]) == 5 assert min_operations_to_equal_array(4, [2, 7, 3, 5]) == 9 assert min_operations_to_equal_array(2, [1, 3]) == 2 assert min_operations_to_equal_array(3, [5, 5, 5]) == 0 def test_process_test_cases(): test_cases = [ (3, [4, 1, 3]), (4, [2, 7, 3, 5]), (2, [1, 3]), (3, [5, 5, 5]) ] assert process_test_cases(4, test_cases) == [5, 9, 2, 0]","solution":"def min_operations_to_equal_array(n, arr): Returns the minimum number of operations required to make all elements in the array equal. arr.sort() min_element = arr[0] operations = 0 for i in range(1, n): operations += (arr[i] - min_element) return operations def process_test_cases(t, test_cases): results = [] for case in test_cases: n, arr = case results.append(min_operations_to_equal_array(n, arr)) return results"},{"question":"def min_insertions_to_make_valid(strings): Given a list of strings with parentheses, returns a list of minimal insertions needed to make each string a valid parenthesis string. :param strings: List of strings :return: List of integers representing the necessary insertions for each string. >>> min_insertions_to_make_valid([\\"()\\", \\"((\\", \\")\\"]) == [0, 2, 1] >>> min_insertions_to_make_valid([\\"()())\\", \\"(())\\"]) == [1, 0]","solution":"def min_insertions_to_make_valid(strings): Given a list of strings with parentheses, returns a list of minimal insertions needed to make each string a valid parenthesis string. :param strings: List of strings :return: List of integers representing the necessary insertions for each string. results = [] for s in strings: open_needed = 0 close_needed = 0 for char in s: if char == '(': close_needed += 1 elif char == ')': if close_needed > 0: close_needed -= 1 else: open_needed += 1 results.append(open_needed + close_needed) return results # Example usage: # strings = [\\"()\\", \\"((\\", \\")\\", \\"()())\\", \\"(())\\"] # print(min_insertions_to_make_valid(strings)) # Outputs: [0, 2, 1, 1, 0]"},{"question":"def nth_alternating_prime_sum(n: int) -> int: Calculates the n-th term of Frank's \\"alternating prime sum\\" sequence. Args: n (int): The term number to compute (1  n  1000). Returns: int: The value of the alternating prime sum sequence at the n-th term. >>> nth_alternating_prime_sum(1) 2 >>> nth_alternating_prime_sum(2) -1 >>> nth_alternating_prime_sum(3) 4 >>> nth_alternating_prime_sum(4) -3 >>> nth_alternating_prime_sum(5) 8","solution":"def is_prime(num): if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def nth_alternating_prime_sum(n): Calculates the n-th term of Frank's \\"alternating prime sum\\" sequence. Args: n (int): The term number to compute (1  n  1000). Returns: int: The value of the alternating prime sum sequence at the n-th term. count = 0 num = 2 prime_sum = 0 while count < n: if is_prime(num): if count % 2 == 0: prime_sum += num else: prime_sum -= num count += 1 num += 1 return prime_sum"},{"question":"def shortest_path(n, m, roads, queries): A function to find the shortest path for packages to travel between hubs in a courier company's distribution center. Arguments: n -- integer, number of hubs m -- integer, number of roads roads -- list of tuples, where each tuple contains three integers u, v, and l representing the hubs connected by the road and the length of the road queries -- list of tuples, where each tuple contains two integers a and b representing the delivery hubs between which the shortest path length should be determined Returns: list of integers, where each integer is the shortest path length for corresponding query. If there is no path, return -1. Examples: >>> shortest_path(3, 2, [(1, 2, 1), (2, 3, 2)], [(1, 3), (1, 2), (3, 1)]) [3, 1, 3] >>> shortest_path(4, 2, [(1, 2, 1), (3, 4, 2)], [(1, 3), (1, 4), (2, 3)]) [-1, -1, -1] >>> shortest_path(1, 0, [], [(1, 1)]) [0] >>> shortest_path(4, 4, [(1, 2, 1), (2, 3, 2), (3, 4, 3), (1, 3, 3)], [(1, 4), (2, 4), (1, 3), (4, 1)]) [6, 5, 3, 6]","solution":"import heapq def shortest_path(n, m, roads, queries): def dijkstra(start, end): pq = [(0, start)] distances = {i: float('inf') for i in range(1, n+1)} distances[start] = 0 while pq: curr_dist, u = heapq.heappop(pq) if u == end: return curr_dist if curr_dist > distances[u]: continue for v, length in graph[u]: dist = curr_dist + length if dist < distances[v]: distances[v] = dist heapq.heappush(pq, (dist, v)) return -1 graph = {i: [] for i in range(1, n+1)} for u, v, l in roads: graph[u].append((v, l)) graph[v].append((u, l)) results = [] for a, b in queries: results.append(dijkstra(a, b)) return results"},{"question":"from typing import List, Optional def is_valid_BST(tree: List[Optional[int]]) -> bool: Check whether a binary tree represented by an array is a valid binary search tree (BST). A binary search tree is valid if for every node: 1. The left subtree of a node contains only nodes with keys less than the node's key. 2. The right subtree of a node contains only nodes with keys greater than the node's key. 3. Both the left and right subtrees must also be binary search trees. :param tree: List of elements where each element is either an integer or 'null'. The length of the list is at most 1000. :return: True if the binary tree is a valid binary search tree (BST), otherwise return False. Example: >>> is_valid_BST([2, 1, 3]) True >>> is_valid_BST([5, 1, 4, 'null', 'null', 3, 6]) False def test_is_valid_BST(): assert is_valid_BST([2, 1, 3]) == True assert is_valid_BST([5, 1, 4, 'null', 'null', 3, 6]) == False assert is_valid_BST([3]) == True assert is_valid_BST([]) == True assert is_valid_BST(['null', 'null', 'null']) == True assert is_valid_BST([10, 5, 15, 3, 7, 12, 18]) == True assert is_valid_BST([10, 5, 15, 3, 7, 4, 18]) == False assert is_valid_BST([10, 5, 15, 'null', 'null', 12, 18]) == True assert is_valid_BST([10, 5, 15, 'null', 'null', 2, 18]) == False","solution":"from typing import List, Optional def is_valid_BST(tree: List[Optional[int]]) -> bool: def validate(node_index: int, low: Optional[int], high: Optional[int]) -> bool: if node_index >= len(tree) or tree[node_index] == 'null': return True val = tree[node_index] if (low is not None and val <= low) or (high is not None and val >= high): return False return (validate(2 * node_index + 1, low, val) and validate(2 * node_index + 2, val, high)) return validate(0, None, None)"},{"question":"def generate_beautiful_permutation(n): Generates a beautiful permutation of length n. >>> generate_beautiful_permutation(2) [1, 2] >>> generate_beautiful_permutation(3) [1, 2, 3] >>> generate_beautiful_permutation(4) [4, 3, 1, 2] >>> generate_beautiful_permutation(5) [5, 4, 1, 2, 3] def solve(test_cases): Solves the problem for a list of test cases. >>> solve([2, 3, 4, 5]) [[1, 2], [1, 2, 3], [4, 3, 1, 2], [5, 4, 1, 2, 3]]","solution":"def generate_beautiful_permutation(n): Generates a beautiful permutation of length n. if n == 2: return [1, 2] elif n == 3: return [1, 2, 3] # For n >= 4, we can create a beautiful permutation res = [] res.append(n) res.append(n - 1) for i in range(1, n - 1): res.append(i) return res def solve(test_cases): results = [] for n in test_cases: results.append(generate_beautiful_permutation(n)) return results"},{"question":"def largest_island_size(n, m, grid): Finds the size of the largest island in a grid. Parameters: n (int): number of rows in the grid. m (int): number of columns in the grid. grid (list of list of int): 2D grid representation of the island. Returns: int: size of the largest island. >>> largest_island_size(4, 5, [ ... [1, 0, 1, 0, 0], ... [1, 0, 1, 1, 1], ... [0, 0, 0, 1, 0], ... [1, 1, 0, 0, 1] ... ]) == 5 >>> largest_island_size(4, 4, [ ... [1, 1, 0, 0], ... [0, 1, 1, 0], ... [0, 0, 1, 0], ... [1, 0, 0, 1], ... ]) == 5 >>> largest_island_size(3, 3, [ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0], ... ]) == 1 >>> largest_island_size(2, 2, [ ... [0, 0], ... [0, 0], ... ]) == 0 >>> largest_island_size(5, 5, [ ... [1, 0, 0, 0, 1], ... [0, 1, 0, 1, 0], ... [1, 0, 1, 0, 1], ... [0, 1, 0, 1, 0], ... [1, 0, 0, 0, 1], ... ]) == 1","solution":"def largest_island_size(n, m, grid): Finds the size of the largest island in a grid. Parameters: n (int): number of rows in the grid. m (int): number of columns in the grid. grid (list of list of int): 2D grid representation of the island. Returns: int: size of the largest island. def dfs(x, y): if x < 0 or y < 0 or x >= n or y >= m or grid[x][y] == 0: return 0 grid[x][y] = 0 # mark as visited size = 1 size += dfs(x+1, y) size += dfs(x-1, y) size += dfs(x, y+1) size += dfs(x, y-1) return size max_size = 0 for i in range(n): for j in range(m): if grid[i][j] == 1: max_size = max(max_size, dfs(i, j)) return max_size"},{"question":"def max_non_consecutive_sum(seq): Return the maximal sum of a subsequence such that no two elements are consecutive in the original sequence. >>> max_non_consecutive_sum([3, 2, 5, 10]) == 13 >>> max_non_consecutive_sum([3, 2, 7, 10, 12]) == 22","solution":"def max_non_consecutive_sum(seq): if not seq: return 0 n = len(seq) if n == 1: return seq[0] dp = [0] * n dp[0] = seq[0] dp[1] = max(seq[0], seq[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + seq[i]) return dp[-1]"},{"question":"def max_teams(n: int, k: int, p: int, points: List[int]) -> int: Returns the maximum number of teams that can be formed such that the sum of points for each team is at least p and does not exceed k players. >>> max_teams(6, 2, 10, [5, 6, 7, 9, 3, 2]) 2 >>> max_teams(5, 3, 15, [4, 8, 12, 3, 10]) 2 >>> max_teams(1, 1, 5, [10]) 1 >>> max_teams(4, 2, 15, [7, 5, 3, 1]) 0 >>> max_teams(5, 5, 20, [5, 5, 5, 5, 5]) 1 >>> max_teams(6, 2, 12, [7, 5, 9, 8, 4, 12]) 3 >>> max_teams(4, 2, 20, [5, 5, 5, 5]) 0","solution":"def max_teams(n, k, p, points): Returns the maximum number of teams that can be formed such that the sum of points for each team is at least p and does not exceed k players. points.sort(reverse=True) teams = 0 i = 0 while i < n: team_points = 0 for j in range(k): if i < n: team_points += points[i] i += 1 # If we have the minimum points required, we qualify this team and move to the next if team_points >= p: teams += 1 break # Else if we have already taken k players, break to form a new team if j == k-1: break if team_points < p: break return teams"},{"question":"def max_subarray_sum_k(arr, k): Returns the maximum sum of any subarray of length k. Parameters: arr (list of int): The input array of integers. k (int): The length of the subarray. Returns: int: The maximum sum of any subarray of length k. >>> max_subarray_sum_k([1, 2, 3, 4, 5], 2) 9 >>> max_subarray_sum_k([-1, 4, -2, 3, 5, -6, 1, 2], 3) 6","solution":"def max_subarray_sum_k(arr, k): Returns the maximum sum of any subarray of length k. Parameters: arr (list of int): The input array of integers. k (int): The length of the subarray. Returns: int: The maximum sum of any subarray of length k. n = len(arr) # Initial sum of the first window current_sum = sum(arr[:k]) max_sum = current_sum # Slide the window over the array for i in range(k, n): current_sum += arr[i] - arr[i - k] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def encrypt_string(n: int, input_string: str, k: int) -> str: Encrypts the input string by shifting each letter by k positions in the alphabet. Wraps around the alphabet, handles both uppercase and lowercase letters, and leaves other characters unchanged. :param n: Length of the string :param input_string: The string to be encrypted :param k: The shift value :return: The encrypted string >>> encrypt_string(7, \\"Hello,!\\", 3) 'Khoor,!' >>> encrypt_string(12, \\"Abc Xyz!\\", 4) 'Efg Bcd!' >>> encrypt_string(8, \\"a1b2c3d4\\", 1) 'b1c2d3e4' >>> encrypt_string(6, \\"aBcDeF\\", 2) 'cDeFgH' >>> encrypt_string(3, \\"xyz\\", 3) 'abc' >>> encrypt_string(3, \\"XYZ\\", 3) 'ABC'","solution":"def encrypt_string(n, input_string, k): Encrypts the input string by shifting each letter by k positions in the alphabet. Wraps around the alphabet, handles both uppercase and lowercase letters, and leaves other characters unchanged. :param n: Length of the string :param input_string: The string to be encrypted :param k: The shift value :return: The encrypted string encrypted_string = [] for char in input_string: if 'a' <= char <= 'z': encrypted_char = chr((ord(char) - ord('a') + k) % 26 + ord('a')) elif 'A' <= char <= 'Z': encrypted_char = chr((ord(char) - ord('A') + k) % 26 + ord('A')) else: encrypted_char = char encrypted_string.append(encrypted_char) return \\"\\".join(encrypted_string)"},{"question":"def dispense_product(grid: List[List[int]], product_type: int) -> int: Returns the minimum number of steps required to dispense the product_type from the vending machine grid, or -1 if the product_type is not found. >>> dispense_product([[1, 0, 3, 4],[2, 6, 0, 3],[0, 2, 5, 5],[1, 6, 2, 2],[0, 0, 0, 4]], 2) == 1 >>> dispense_product([[1, 0, 3, 4],[2, 6, 0, 3],[0, 2, 5, 5],[1, 6, 2, 2],[0, 0, 0, 4]], 7) == -1","solution":"def dispense_product(grid, product_type): Returns the minimum number of steps required to dispense the product_type from the vending machine grid, or -1 if the product_type is not found. m = len(grid) n = len(grid[0]) min_steps = float('inf') found = False for col in range(n): for row in range(m): if grid[row][col] == product_type: min_steps = min(min_steps, row) found = True break return min_steps if found else -1 # Example input m = 5 n = 4 grid = [ [1, 0, 3, 4], [2, 6, 0, 3], [0, 2, 5, 5], [1, 6, 2, 2], [0, 0, 0, 4] ] product_type = 2 print(dispense_product(grid, product_type)) # Outputs: 1"},{"question":"import re from typing import List def check_password_policy(s: str) -> str: Check if the provided password meets the specified policy. A password is considered valid if: 1. It contains at least one lowercase letter. 2. It contains at least one uppercase letter. 3. It contains at least one digit. 4. It contains at least one special character from the set \\"!@#%^&*()-+\\". 5. It does not contain any space or other characters. 6. Its length is between 8 and 20 characters inclusive. Args: s (str): The password string to check Returns: str: \\"VALID\\" if the password meets all criteria, otherwise \\"INVALID\\" pass def test_password_policy_valid(): assert check_password_policy(\\"Aa1!aa1!\\") == \\"VALID\\" assert check_password_policy(\\"Password123!\\") == \\"VALID\\" assert check_password_policy(\\"G00dP@ssw0rd\\") == \\"VALID\\" def test_password_policy_no_uppercase(): assert check_password_policy(\\"aa1!aa1!\\") == \\"INVALID\\" def test_password_policy_no_lowercase(): assert check_password_policy(\\"AA1!AA1!\\") == \\"INVALID\\" def test_password_policy_no_digit(): assert check_password_policy(\\"Aaa!aaa!\\") == \\"INVALID\\" def test_password_policy_no_special_character(): assert check_password_policy(\\"Aa1aaa11\\") == \\"INVALID\\" def test_password_policy_contains_space(): assert check_password_policy(\\"Pass word123!\\") == \\"INVALID\\" assert check_password_policy(\\"P@ss W0rd\\") == \\"INVALID\\" def test_password_policy_wrong_length(): assert check_password_policy(\\"Aa1!\\") == \\"INVALID\\" # Too Short assert check_password_policy(\\"A1!\\" + \\"a\\" * 18) == \\"INVALID\\" # Too Long","solution":"import re def check_password_policy(s): Check if the provided password meets the specified policy. if not (8 <= len(s) <= 20): return \\"INVALID\\" if not re.search(r'[a-z]', s): return \\"INVALID\\" if not re.search(r'[A-Z]', s): return \\"INVALID\\" if not re.search(r'[0-9]', s): return \\"INVALID\\" if not re.search(r'[!@#%^&*()-+]', s): return \\"INVALID\\" if re.search(r's', s): return \\"INVALID\\" return \\"VALID\\""},{"question":"import requests import os from zipfile import ZipFile from io import BytesIO def check_weight_exceeds_threshold(t: int, W: int) -> str: Determine if the combined weight of all items of a specified type exceeds a given threshold. Args: t (int): the item type directory to read from (1  t  4) W (int): the threshold weight (0  W  10^9) Returns: str: \\"YES\\" if the total weight of all items in the specified type's directory exceeds the threshold weight, \\"NO\\" otherwise. >>> check_weight_exceeds_threshold(2, 15000) \\"YES\\" >>> check_weight_exceeds_threshold(1, 1000) \\"NO\\" import pytest from check_weight_exceeds_threshold import check_weight_exceeds_threshold def test_check_weight_below_threshold(monkeypatch): def mock_get(*args, **kwargs): class MockResponse: def __init__(self, content): self.content = content self.status_code = 200 def json(self): return self.content @property def ok(self): return self.status_code == 200 sample_zip = BytesIO() with ZipFile(sample_zip, 'w') as zf: zf.writestr(\\"1/file1.txt\\", \\"200n300n\\") zf.writestr(\\"1/file2.txt\\", \\"150n350n\\") return MockResponse(sample_zip.getvalue()) monkeypatch.setattr(requests, \\"get\\", mock_get) assert check_weight_exceeds_threshold(1, 1000) == \\"NO\\" def test_check_weight_above_threshold(monkeypatch): def mock_get(*args, **kwargs): class MockResponse: def __init__(self, content): self.content = content self.status_code = 200 def json(self): return self.content @property def ok(self): return self.status_code == 200 sample_zip = BytesIO() with ZipFile(sample_zip, 'w') as zf: zf.writestr(\\"2/file1.txt\\", \\"3000n5000n4000n\\") zf.writestr(\\"2/file2.txt\\", \\"1000n2000n\\") return MockResponse(sample_zip.getvalue()) monkeypatch.setattr(requests, \\"get\\", mock_get) assert check_weight_exceeds_threshold(2, 12000) == \\"YES\\" def test_check_weight_equal_threshold(monkeypatch): def mock_get(*args, **kwargs): class MockResponse: def __init__(self, content): self.content = content self.status_code = 200 def json(self): return self.content @property def ok(self): return self.status_code == 200 sample_zip = BytesIO() with ZipFile(sample_zip, 'w') as zf: zf.writestr(\\"3/file1.txt\\", \\"1000n3000n\\") zf.writestr(\\"3/file2.txt\\", \\"1000n5000n\\") return MockResponse(sample_zip.getvalue()) monkeypatch.setattr(requests, \\"get\\", mock_get) assert check_weight_exceeds_threshold(3, 10000) == \\"NO\\" def test_check_weight_zero_threshold(monkeypatch): def mock_get(*args, **kwargs): class MockResponse: def __init__(self, content): self.content = content self.status_code = 200 def json(self): return self.content @property def ok(self): return self.status_code == 200 sample_zip = BytesIO() with ZipFile(sample_zip, 'w') as zf: zf.writestr(\\"4/file1.txt\\", \\"650n800n\\") zf.writestr(\\"4/file2.txt\\", \\"350n200n\\") return MockResponse(sample_zip.getvalue()) monkeypatch.setattr(requests, \\"get\\", mock_get) assert check_weight_exceeds_threshold(4, 0) == \\"YES\\"","solution":"import requests import os from zipfile import ZipFile from io import BytesIO def check_weight_exceeds_threshold(t, W): url = \\"http://download4.sciencefair.com/weights.zip\\" # Download and extract the zip file response = requests.get(url) if response.status_code != 200: raise Exception(f\\"Failed to download file: {url}\\") zip_file = ZipFile(BytesIO(response.content)) total_weight = 0 # Assuming the item types directories are named as '1', '2', '3', and '4' directory = str(t) # Iterate through files in the specified directory within the zip archive for file_info in zip_file.infolist(): if file_info.filename.startswith(directory + '/'): with zip_file.open(file_info) as file: for line in file: total_weight += int(line.strip()) return \\"YES\\" if total_weight > W else \\"NO\\""},{"question":"def max_profit(stock_prices): Takes a list of stock prices and returns the maximum profit that can be achieved from a single buy-sell transaction. If no profit can be achieved, returns 0. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3]) 0 >>> max_profit([]) 0 >>> max_profit([1]) 0 >>> max_profit([1, 2]) 1 >>> max_profit([10, 20, 30, 40, 50]) 40 >>> max_profit([50, 40, 30, 20, 10]) 0 >>> max_profit([5, 5, 5, 5]) 0 >>> max_profit([3, 2, 6, 1, 3]) 4","solution":"def max_profit(stock_prices): Takes a list of stock prices and returns the maximum profit that can be achieved from a single buy-sell transaction. If no profit can be achieved, returns 0. if not stock_prices or len(stock_prices) < 2: return 0 min_price = float('inf') max_profit = 0 for price in stock_prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"def find_max_treasure_and_ways(n: int, treasures: List[int]) -> Tuple[int, int]: Determine the maximum sum of treasure the hunter can collect by visiting a contiguous subchain of islands and the number of ways to achieve this maximum sum. >>> find_max_treasure_and_ways(5, [-2, 1, -3, 4, -1]) (4, 1) >>> find_max_treasure_and_ways(1, [10]) (10, 1) >>> find_max_treasure_and_ways(1, [-5]) (-5, 1) >>> find_max_treasure_and_ways(5, [-1, -2, -3, -4, -5]) (-1, 1) >>> find_max_treasure_and_ways(5, [1, -1, 1, -1, 1]) (1, 3) >>> find_max_treasure_and_ways(3, [10**9, -10**9, 10**9]) (10**9, 2) >>> find_max_treasure_and_ways(5, [0, 0, 0, 0, 0]) (0, 5)","solution":"def find_max_treasure_and_ways(n, treasures): MOD = 10**9 + 7 max_sum = -float('inf') current_sum = 0 ways = 0 current_ways = 1 for treasure in treasures: if current_sum + treasure > treasure: current_sum += treasure current_ways = current_ways else: current_sum = treasure current_ways = 1 if current_sum > max_sum: max_sum = current_sum ways = current_ways elif current_sum == max_sum: ways = (ways + current_ways) % MOD return max_sum, ways # Function to read inputs from standard input def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) treasures = list(map(int, data[1:])) max_treasure, num_ways = find_max_treasure_and_ways(n, treasures) print(max_treasure, num_ways)"},{"question":"def fastest_relay_time(a: int, b: int, c: int, d: int) -> int: Determine the fastest possible total time for all four students to complete the relay race. Each student must complete exactly one lap and the total time is the sum of all lap times. >>> fastest_relay_time(5, 3, 7, 2) 17 >>> fastest_relay_time(0, 0, 0, 0) 0 >>> fastest_relay_time(1000, 1000, 1000, 1000) 4000 >>> fastest_relay_time(10, 0, 5, 2) 17 >>> fastest_relay_time(1, 1, 1, 1) 4","solution":"def fastest_relay_time(a, b, c, d): Returns the fastest possible total time for all four students to complete the relay race. # Since each student completes exactly one lap, the total time is simply the sum of all lap times. return a + b + c + d"},{"question":"def count_hills(heights): Returns the number of hills in the given list of heights. Parameters: heights (list of int): List of integers representing the heights of the hills. Returns: int: Number of hills. pass # Example cases assert count_hills([2, 1, 4, 7, 3, 2, 5, 6, 4]) == 2 assert count_hills([1, 2]) == 0 assert count_hills([3, 3, 3, 3, 3]) == 0 assert count_hills([1, 3, 1, 3, 1]) == 2 assert count_hills([1, 3, 2]) == 1 assert count_hills([0, 2, 1, 3, 1, 4, 1]) == 3 assert count_hills([i for i in range(100000)]) == 0 assert count_hills([i for i in range(100000, 0, -1)]) == 0 assert count_hills([0, 1000000000, 0, 1000000000, 0]) == 2","solution":"def count_hills(heights): Returns the number of hills in the given list of heights. Parameters: heights (list of int): List of integers representing the heights of the hills. Returns: int: Number of hills. if len(heights) < 3: return 0 num_hills = 0 for i in range(1, len(heights) - 1): if heights[i] > heights[i - 1] and heights[i] > heights[i + 1]: num_hills += 1 return num_hills"},{"question":"def can_organize_library(n: int, m: int, book_weights: List[int], shelf_capacities: List[int]) -> str: Determines if it's possible to organize the books on the shelves such that the weight of each subsequent book on the same shelf is not greater than the previous one. Args: - n (int): Number of books - m (int): Number of shelves - book_weights (list of int): Weights of the books - shelf_capacities (list of int): Capacities of the shelves Returns: - str: \\"YES\\" if possible to organize the books, otherwise \\"NO\\" pass # Unit tests def test_case_1(): assert can_organize_library(5, 2, [4, 3, 2, 1, 5], [3, 2]) == \\"YES\\" def test_case_2(): assert can_organize_library(5, 2, [4, 3, 2, 1, 5], [2, 2]) == \\"NO\\" def test_case_3(): assert can_organize_library(5, 3, [1, 2, 3, 4, 5], [2, 2, 1]) == \\"YES\\" def test_case_4(): assert can_organize_library(3, 1, [3, 2, 1], [3]) == \\"YES\\" def test_case_5(): assert can_organize_library(3, 1, [3, 2, 1], [2]) == \\"NO\\" def test_case_with_single_book(): assert can_organize_library(1, 1, [5], [1]) == \\"YES\\" def test_case_with_equal_shelves(): assert can_organize_library(4, 4, [1, 2, 3, 4], [1, 1, 1, 1]) == \\"YES\\" def test_case_with_more_books_than_capacities(): assert can_organize_library(5, 2, [5, 4, 3, 2, 1], [2, 2]) == \\"NO\\"","solution":"def can_organize_library(n, m, book_weights, shelf_capacities): Determines if it's possible to organize the books on the shelves such that the weight of each subsequent book on the same shelf is not greater than the previous one. Args: - n (int): Number of books - m (int): Number of shelves - book_weights (list of int): Weights of the books - shelf_capacities (list of int): Capacities of the shelves Returns: - str: \\"YES\\" if possible to organize the books, otherwise \\"NO\\" # Sort books in descending order to place the heaviest first book_weights.sort(reverse=True) # Sort shelves capacities in descending order to utilize the largest shelves first shelf_capacities.sort(reverse=True) # Index to keep track of the current book book_index = 0 for capacity in shelf_capacities: if book_index < n: # Check if we can place 'capacity' number of books on the current shelf book_index += capacity # If we have placed all books, return \\"YES\\" if book_index >= n: return \\"YES\\" else: return \\"NO\\""},{"question":"def magic_square(n: int, square: List[List[int]]) -> Union[List[List[int]], int]: Complete the given n x n incomplete magic square if possible, otherwise return -1. >>> magic_square(3, [ [8, 0, 0], [0, 5, 0], [0, 0, 0]]) [[8, 1, 6], [3, 5, 7], [4, 9, 2]] >>> magic_square(3, [ [8, 0, 0], [0, 0, 6], [0, 0, 0]]) -1 >>> magic_square(3, [ [2, 7, 6], [9, 5, 1], [4, 3, 8]]) [[2, 7, 6], [9, 5, 1], [4, 3, 8]] >>> magic_square(3, [ [2, 0, 6], [9, 5, 1], [4, 3, 8]]) [[2, 7, 6], [9, 5, 1], [4, 3, 8]]","solution":"def magic_square(n, square): Complete the given n x n incomplete magic square if possible, otherwise return -1. from itertools import permutations def is_magic(square, n, magic_const): for row in square: if sum(row) != magic_const: return False for col in range(n): if sum(square[row][col] for row in range(n)) != magic_const: return False if sum(square[i][i] for i in range(n)) != magic_const: return False if sum(square[i][n - i - 1] for i in range(n)) != magic_const: return False return True all_nums = set(range(1, n * n + 1)) given_nums = set(num for row in square for num in row if num != 0) empty_cells = [(i, j) for i in range(n) for j in range(n) if square[i][j] == 0] if not empty_cells: if is_magic(square, n, sum(square[0])): return square else: return -1 remaining_nums = all_nums - given_nums magic_const = sum(range(1, n * n + 1)) // n for filled_sequence in permutations(remaining_nums): new_square = [row[:] for row in square] for idx, (i, j) in enumerate(empty_cells): new_square[i][j] = filled_sequence[idx] if is_magic(new_square, n, magic_const): return new_square return -1"},{"question":"from typing import List, Tuple, Union def find_pair_with_sum(arr: List[int], target: int) -> Union[Tuple[int, int], int]: Returns a tuple of indices (1-based) of two numbers in \`arr\` whose sum is equal to \`target\`. If no such pair exists, return -1. >>> find_pair_with_sum([2, 7, 11, 15, 1], 9) (1, 2) >>> find_pair_with_sum([1, 2, 3, 4, 5], 10) -1 >>> find_pair_with_sum([5], 5) -1 >>> find_pair_with_sum([1, 2, 3, 4, 5, 6], 7) (1, 6) # or (2, 5) or (3, 4) >>> find_pair_with_sum([1000000000, 1000000000, 1000000000], 2000000000) (1, 2) # or (1, 3) or (2, 3) >>> find_pair_with_sum([5, 5], 10) (1, 2) # or (2, 1)","solution":"from typing import List, Tuple, Union def find_pair_with_sum(arr: List[int], target: int) -> Union[Tuple[int, int], int]: Returns a tuple of indices (1-based) of two numbers in \`arr\` whose sum is equal to \`target\`. If no such pair exists, return -1. num_to_index = {} for index, num in enumerate(arr): complement = target - num if complement in num_to_index: return (num_to_index[complement] + 1, index + 1) # Return 1-based index num_to_index[num] = index return -1"},{"question":"from typing import List def find_min_max_pages(books: List[int], n: int, k: int) -> int: Find the minimum possible value of the maximum number of pages assigned to any student. Arguments: books -- an array of integers where each integer represents the number of pages in a book n -- the number of books k -- the number of students Returns: The minimum possible value of the maximum number of pages assigned to any student. >>> find_min_max_pages([12, 34, 67, 90], 4, 2) 113 >>> find_min_max_pages([10, 20, 30, 40], 4, 2) 60","solution":"def is_possible(books, n, k, max_pages): students_required = 1 current_pages = 0 for pages in books: if current_pages + pages > max_pages: students_required += 1 current_pages = pages if students_required > k: return False else: current_pages += pages return True def find_min_max_pages(books, n, k): if n < k: return -1 low, high = max(books), sum(books) result = high while low <= high: mid = (low + high) // 2 if is_possible(books, n, k, mid): result = mid high = mid - 1 else: low = mid + 1 return result"},{"question":"def max_bitwise_and(arr): Returns the maximum bitwise AND value of any pair of elements in the array. >>> max_bitwise_and([3, 8, 2, 6, 7]) 6 >>> max_bitwise_and([0, 0, 0]) 0 >>> max_bitwise_and([5, 5]) 5 >>> max_bitwise_and([1024, 2048, 4096, 8192]) 0 >>> max_bitwise_and([1, 2, 1023, 2047]) 1023 >>> max_bitwise_and([10, 10, 5]) 10","solution":"def max_bitwise_and(arr): Returns the maximum bitwise AND value of any pair of elements in the array. max_and = 0 n = len(arr) for i in range(n): for j in range(i + 1, n): current_and = arr[i] & arr[j] if current_and > max_and: max_and = current_and return max_and"},{"question":"def min_stations(n: int, k: int) -> int: Calculate the minimum number of railway stations required so that every village has access to at least one railway station within a distance of k villages. If it is not possible to achieve this, return -1. Args: n (int): The number of villages. k (int): The required distance between railway stations. Returns: int: The minimum number of railway stations required or -1 if it's not possible. >>> min_stations(10, 2) 5 >>> min_stations(15, 4) 4 >>> min_stations(7, 10) -1 >>> min_stations(1, 1) 1 >>> min_stations(5, 5) 1 >>> min_stations(20, 3) 7 >>> min_stations(100, 1) 100 >>> min_stations(50, 2) 25","solution":"def min_stations(n, k): if k > n: return -1 # Minimum stations needed to cover all villages stations = (n + k - 1) // k return stations"},{"question":"def min_abs_difference(n: int, coin_values: List[int]) -> int: This function returns the minimum possible absolute difference between the total values of two groups that can be formed out of the given coin values. >>> min_abs_difference(4, [1, 4, 9, 16]) == 2 >>> min_abs_difference(3, [3, 1, 2]) == 0 from typing import List def test_example_1(): assert min_abs_difference(4, [1, 4, 9, 16]) == 2 def test_example_2(): assert min_abs_difference(3, [3, 1, 2]) == 0 def test_single_coin(): assert min_abs_difference(1, [10]) == 10 def test_two_coins_equal(): assert min_abs_difference(2, [5, 5]) == 0 def test_two_coins_unequal(): assert min_abs_difference(2, [1, 2]) == 1 def test_large_values(): assert min_abs_difference(3, [99, 100, 10]) == 9 def test_identical_values(): assert min_abs_difference(4, [7, 7, 7, 7]) == 0 def test_negative_values(): assert min_abs_difference(3, [1, -1, 2]) == 0","solution":"def min_abs_difference(n, coin_values): This function returns the minimum possible absolute difference between the total values of two groups that can be formed out of the given coin values. total_sum = sum(coin_values) possible_sums = {0} for coin in coin_values: new_sums = possible_sums.copy() for s in possible_sums: new_sums.add(s + coin) possible_sums = new_sums min_diff = float('inf') for sum1 in possible_sums: sum2 = total_sum - sum1 min_diff = min(min_diff, abs(sum1 - sum2)) return min_diff"},{"question":"def sum_distinct_spins(n: int, spins: List[int]) -> int: Calculate the sum of values from the wheel spins considering only consecutive distinct values. >>> sum_distinct_spins(7, [4, 4, 5, 5, 6, 6, 6]) 15 >>> sum_distinct_spins(5, [1, 2, 2, 3, 2]) 8","solution":"def sum_distinct_spins(n, spins): if n == 0: return 0 sum_unique_spins = spins[0] for i in range(1, n): if spins[i] != spins[i-1]: sum_unique_spins += spins[i] return sum_unique_spins"},{"question":"import heapq from typing import List, Tuple, Union def shortest_travel_time(n: int, m: int, roads: List[Tuple[int, int, int]]) -> Union[int, str]: Determines the shortest travel time from the first intersection (1) to the last intersection (n) in a grid layout using Dijkstra's algorithm. Args: n : int : number of intersections m : int : number of roads roads : List[Tuple[int, int, int]] : list of roads, where each road is described by a tuple (u, v, t) Returns: Union[int, str] : the shortest travel time from intersection 1 to intersection n, or \\"IMPOSSIBLE\\" if no such path exists Example: >>> shortest_travel_time(5, 6, [(1, 2, 4), (1, 3, 2), (2, 3, 5), (3, 4, 10), (2, 5, 3), (4, 5, 1)]) 7 >>> shortest_travel_time(4, 2, [(1, 2, 10), (3, 4, 10)]) 'IMPOSSIBLE' >>> shortest_travel_time(3, 2, [(1, 2, 5), (2, 3, 5)]) 10 >>> shortest_travel_time(4, 4, [(1, 2, 1), (2, 3, 1), (3, 4, 1), (1, 4, 10)]) 3 >>> shortest_travel_time(2, 1, [(1, 2, 100)]) 100","solution":"import heapq def shortest_travel_time(n, m, roads): Determines the shortest travel time from the first intersection (1) to the last intersection (n) in a grid layout using Dijkstra's algorithm. Returns the shortest travel time or \\"IMPOSSIBLE\\" if no valid path exists. # Create an adjacency list for the graph graph = {i: [] for i in range(1, n + 1)} for u, v, t in roads: graph[u].append((v, t)) graph[v].append((u, t)) # Priority queue to store (travel_time, intersection) pairs pq = [(0, 1)] # Dictionary to store the shortest distances to each intersection dist = {i: float('inf') for i in range(1, n + 1)} dist[1] = 0 while pq: current_dist, u = heapq.heappop(pq) # If we reached the target, return the distance if u == n: return current_dist for v, t in graph[u]: if dist[u] + t < dist[v]: dist[v] = dist[u] + t heapq.heappush(pq, (dist[v], v)) # If we finish the loop without having reached the target, return \\"IMPOSSIBLE\\" return \\"IMPOSSIBLE\\""},{"question":"def max_sum_path(grid: List[List[int]], n: int, m: int) -> int: Given a grid of size n x m with positive, negative, and zero values, find the maximum sum path starting from any cell in the first row and ending at any cell in the last row. You can move only downwards or diagonally down-left or down-right. >>> max_sum_path([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3, 3) 18 >>> max_sum_path([[5, 10, 15]], 1, 3) 15 >>> max_sum_path([[1], [2], [3]], 3, 1) 6 >>> max_sum_path([[-1, -2, -3], [-4, -5, -6], [-7, -8, -9]], 3, 3) -12 >>> max_sum_path([[3, -4, 2], [-1, 0, -2], [4, -3, 1]], 3, 3) 7","solution":"def max_sum_path(grid, n, m): # Initialize dp table to store the maximum sums dp = [[0] * m for _ in range(n)] # Initialize the first row of dp with the values of the grid (start points) for j in range(m): dp[0][j] = grid[0][j] # Fill the dp table row by row for i in range(1, n): for j in range(m): # Get the maximum sum from the upper row cells top = dp[i-1][j] top_left = dp[i-1][j-1] if j-1 >= 0 else float('-inf') top_right = dp[i-1][j+1] if j+1 < m else float('-inf') dp[i][j] = grid[i][j] + max(top, top_left, top_right) # The maximum sum will be the max value in the last row return max(dp[n-1])"},{"question":"def maximum_product_of_three(arr): This function returns the maximum product of the energy levels of any three different creatures. :param arr: List of integers representing the energy levels of the creatures. :type arr: list :return: Maximum product of the energy levels of any three different creatures. :rtype: int pass def test_maximum_product_of_three(): assert maximum_product_of_three([1, 2, 3, 4, 5]) == 60 assert maximum_product_of_three([-1, -2, -3, 1, 2, 3]) == 18 assert maximum_product_of_three([-10, -10, 1, 3, 2]) == 300 assert maximum_product_of_three([1, 0, 100, -1000, 5000, -3000]) == 15000000000 assert maximum_product_of_three([5, 5, -10, -10, 1]) == 500","solution":"def maximum_product_of_three(arr): This function returns the maximum product of the energy levels of any three different creatures. :param arr: List of integers representing the energy levels of the creatures. :type arr: list :return: Maximum product of the energy levels of any three different creatures. :rtype: int n = len(arr) if n < 3: return None # Sort the array arr.sort() # Maximum product can be composed either by: # 1. Product of the three largest numbers # 2. Product of the two smallest numbers (which can be negative) and the largest number max_product = max(arr[-1] * arr[-2] * arr[-3], arr[0] * arr[1] * arr[-1]) return max_product"},{"question":"def can_form_tree(n: int, m: int, edges: List[Tuple[int, int]]) -> str: Determine if it is possible to remove some (possibly zero) edges from the graph to obtain a tree. Args: n (int): Number of vertices m (int): Number of edges edges (List[Tuple[int, int]]): List of edges represented as tuples (u, v) Returns: str: \\"YES\\" if it is possible to obtain a tree, \\"NO\\" otherwise Examples: >>> can_form_tree(4, 5, [(1, 2), (1, 3), (2, 3), (3, 4), (2, 4)]) 'YES' >>> can_form_tree(3, 1, [(1, 2)]) 'NO'","solution":"def can_form_tree(n, m, edges): from collections import defaultdict, deque if m < n - 1: return \\"NO\\" if m >= n: return \\"YES\\" # function to run BFS and check connectivity def bfs(start, adj_list, visited): queue = deque([start]) visited[start] = True while queue: node = queue.popleft() for neighbor in adj_list[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) adj_list = defaultdict(list) for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) visited = {i: False for i in range(1, n+1)} bfs(1, adj_list, visited) # check if all vertices are visited for i in range(1, n+1): if not visited[i]: return \\"NO\\" return \\"YES\\""},{"question":"from typing import List, Tuple def minimum_travel_time(n: int, roads: List[Tuple[int, int, int]]) -> int: Determine the minimum travel time required to make the entire road network connected. Parameters: n (int): Number of intersections roads (List[Tuple[int, int, int]]): List of roads where each road is a tuple (u, v, t) indicating a road between intersections u and v with travel time t Returns: int: Minimum total travel time required to make the entire road network connected, or -1 if impossible. Examples: >>> minimum_travel_time(4, [(1, 2, 3), (2, 3, 4), (3, 4, 5), (1, 4, 10)]) 12 >>> minimum_travel_time(4, []) -1 def test_minimum_travel_time(): assert minimum_travel_time(4, [(1, 2, 3), (2, 3, 4), (3, 4, 5), (1, 4, 10)]) == 12 assert minimum_travel_time(4, []) == -1 assert minimum_travel_time(2, [(1, 2, 3)]) == 3 assert minimum_travel_time(3, [(1, 2, 1), (2, 3, 1), (1, 3, 2)]) == 2 assert minimum_travel_time(3, [(1, 2, 1)]) == -1 assert minimum_travel_time(6, [(1, 2, 4), (1, 3, 3), (2, 3, 2), (2, 4, 3), (3, 5, 2), (5, 6, 5), (4, 6, 6), (3, 4, 4)]) == 15","solution":"def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def kruskal(n, edges): result = 0 i = 0 e = 0 edges = sorted(edges, key=lambda item: item[2]) parent = [] rank = [] for node in range(n): parent.append(node) rank.append(0) while e < n - 1 and i < len(edges): u, v, w = edges[i] i += 1 x = find(parent, u - 1) y = find(parent, v - 1) if x != y: e += 1 result += w union(parent, rank, x, y) for node in range(n): if find(parent, node) != find(parent, 0): return -1 return result def minimum_travel_time(n, roads): if n == 1: return 0 edges = [] for road in roads: u, v, t = road edges.append((u, v, t)) return kruskal(n, edges)"},{"question":"def can_organize_tournament(n: int, m: int, restrictions: List[Tuple[int, int]]) -> str: Determine whether it is possible to organize a tournament with the given number of players and restrictions such that every player can play exactly one game against each other player. Parameters: n (int): The number of players. m (int): The number of restrictions. restrictions (List[Tuple[int, int]]): The list of restrictions where a restriction (a, b) indicates that player a cannot play against player b. Returns: str: \\"YES\\" if it is possible to organize the tournament under the given restrictions, and \\"NO\\" otherwise. Example: >>> can_organize_tournament(4, 2, [(1, 2), (3, 4)]) \\"YES\\" >>> can_organize_tournament(3, 3, [(1, 2), (2, 3), (1, 3)]) \\"NO\\"","solution":"def can_organize_tournament(n, m, restrictions): # Adjacency list to represent the restrictions graph from collections import defaultdict restrictions_map = defaultdict(set) # Populate the restriction map for a, b in restrictions: restrictions_map[a].add(b) restrictions_map[b].add(a) # Union-Find data structure to detect connected components parent = list(range(n + 1)) rank = [0] * (n + 1) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 # Attempt to process the restrictions to see if forming a connected set is possible for a, b in restrictions: if find(a) == find(b): return \\"NO\\" union(a, b) return \\"YES\\" # Example Usage n = 4 m = 2 restrictions = [(1, 2), (3, 4)] print(can_organize_tournament(n, m, restrictions)) # Output should be \\"YES\\""},{"question":"def can_cover_grid(n: int, m: int, k: int) -> str: Determine if it's possible to cover an n x m grid with exactly k 1x1 tiles. Args: n (int): Number of rows in the grid. m (int): Number of columns in the grid. k (int): Number of 1x1 tiles. Returns: str: \\"YES\\" if it's possible to cover the grid with exactly k tiles, otherwise \\"NO\\". >>> can_cover_grid(3, 4, 12) \\"YES\\" >>> can_cover_grid(2, 3, 5) \\"NO\\" from solution import can_cover_grid def test_can_cover_grid_exact_fit(): assert can_cover_grid(3, 4, 12) == \\"YES\\" assert can_cover_grid(2, 2, 4) == \\"YES\\" assert can_cover_grid(1, 1, 1) == \\"YES\\" def test_can_cover_grid_less_than_needed(): assert can_cover_grid(2, 3, 5) == \\"NO\\" assert can_cover_grid(4, 4, 15) == \\"NO\\" assert can_cover_grid(5, 5, 24) == \\"NO\\" def test_can_cover_grid_more_than_needed(): assert can_cover_grid(3, 3, 10) == \\"NO\\" assert can_cover_grid(2, 2, 5) == \\"NO\\" assert can_cover_grid(1, 4, 5) == \\"NO\\"","solution":"def can_cover_grid(n, m, k): Determine if it's possible to cover an n x m grid with exactly k 1x1 tiles. Args: n (int): Number of rows in the grid. m (int): Number of columns in the grid. k (int): Number of 1x1 tiles. Returns: str: \\"YES\\" if it's possible to cover the grid with exactly k tiles, otherwise \\"NO\\". # The grid must have exactly n * m tiles to be fully covered. if n * m == k: return \\"YES\\" else: return \\"NO\\""},{"question":"def max_treasures(n: int, m: int, grid: List[str]) -> int: Determine the maximum number of treasures that can be collected with exactly one move on the game board. >>> max_treasures(3, 3, [\\".T.\\", \\".TT\\", \\"...\\"]) 2 >>> max_treasures(4, 4, [\\"....\\", \\".TT.\\", \\".T..\\", \\"....\\"]) 2 >>> max_treasures(1, 1, [\\"T\\"]) 0 >>> max_treasures(2, 2, [\\"..\\", \\"..\\"]) 0 >>> max_treasures(5, 5, [\\".....\\", \\"..T..\\", \\".T..T\\", \\"..T..\\", \\".....\\"]) 2 >>> max_treasures(3, 4, [\\"....\\", \\"T.TT\\", \\"....\\"]) 1","solution":"def max_treasures(n, m, grid): def count_treasures(x, y): count = 0 directions = [ (-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1) ] for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == 'T': count += 1 return count max_treasures = 0 for i in range(n): for j in range(m): if grid[i][j] == 'T': max_treasures = max(max_treasures, count_treasures(i, j)) return max_treasures"},{"question":"def longest_repeated_substring_length(s: str) -> int: Returns the length of the longest substring that appears more than once in the string \`s\`. :param s: The input string :return: The length of the longest repeated substring >>> longest_repeated_substring_length(\\"ababc\\") 2 >>> longest_repeated_substring_length(\\"abcd\\") 0","solution":"def longest_repeated_substring_length(s): Returns the length of longest substring that appears more than once in the string \`s\`. n = len(s) def is_repeated_length_k(k): seen = set() for i in range(n - k + 1): substring = s[i:i+k] if substring in seen: return True seen.add(substring) return False left, right = 0, n longest_length = 0 while left <= right: mid = (left + right) // 2 if is_repeated_length_k(mid): longest_length = mid left = mid + 1 else: right = mid - 1 return longest_length"},{"question":"from typing import List def reorganize_array(arr: List[int]) -> List[int]: Reorganizes the array such that no two adjacent elements are the same. If it is not possible, return an empty array. >>> reorganize_array([1, 1, 2, 2, 2]) [2, 1, 2, 1, 2] >>> reorganize_array([3, 3, 3, 3]) [] >>> reorganize_array([1, 2, 3, 4, 4]) [4, 1, 4, 2, 3]","solution":"from typing import List from collections import Counter import heapq def reorganize_array(arr: List[int]) -> List[int]: count = Counter(arr) max_heap = [(-value, key) for key, value in count.items()] heapq.heapify(max_heap) prev_element = None result = [] while max_heap or prev_element: if prev_element and not max_heap: return [] value, key = heapq.heappop(max_heap) result.append(key) if prev_element: heapq.heappush(max_heap, prev_element) prev_element = None if value + 1 < 0: prev_element = (value + 1, key) return result"},{"question":"from typing import List, Tuple def preprocess_matrix(matrix: List[List[int]]) -> List[List[int]]: Preprocess the matrix using prefix sums for efficient submatrix sum queries. pass def submatrix_sum(prefix_sum: List[List[int]], i1: int, j1: int, i2: int, j2: int) -> int: Calculate the sum of the submatrix using the precomputed prefix sum matrix. pass def handle_queries(matrix: List[List[int]], queries: List[Tuple[int, int, int, int]]) -> List[int]: Handle a list of queries for submatrix sums for the given matrix pass # Test cases def test_preprocess_matrix(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] expected_prefix_sum = [ [0, 0, 0, 0], [0, 1, 3, 6], [0, 5, 12, 21], [0, 12, 27, 45] ] assert preprocess_matrix(matrix) == expected_prefix_sum def test_submatrix_sum(): prefix_sum = [ [0, 0, 0, 0], [0, 1, 3, 6], [0, 5, 12, 21], [0, 12, 27, 45] ] assert submatrix_sum(prefix_sum, 1, 1, 2, 2) == 12 assert submatrix_sum(prefix_sum, 1, 1, 3, 3) == 45 assert submatrix_sum(prefix_sum, 2, 2, 3, 3) == 28 def test_handle_queries(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] queries = [(1, 1, 2, 2), (1, 1, 3, 3)] expected_results = [12, 45] assert handle_queries(matrix, queries) == expected_results def test_edge_cases(): matrix = [ [0] ] queries = [(1, 1, 1, 1)] expected_results = [0] assert handle_queries(matrix, queries) == expected_results matrix = [ [1, 2], [3, 4] ] queries = [(1, 1, 1, 1), (1, 1, 2, 2), (2, 2, 2, 2)] expected_results = [1, 10, 4] assert handle_queries(matrix, queries) == expected_results","solution":"def preprocess_matrix(matrix): Preprocess the matrix using prefix sums for efficient submatrix sum queries. n = len(matrix) m = len(matrix[0]) prefix_sum = [[0] * (m + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, m + 1): prefix_sum[i][j] = (matrix[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]) return prefix_sum def submatrix_sum(prefix_sum, i1, j1, i2, j2): Calculate the sum of the submatrix using the precomputed prefix sum matrix. result = (prefix_sum[i2][j2] - prefix_sum[i1 - 1][j2] - prefix_sum[i2][j1 - 1] + prefix_sum[i1 - 1][j1 - 1]) return result # Function to handle multiple queries def handle_queries(matrix, queries): Handle a list of queries for submatrix sums for the given matrix prefix_sum = preprocess_matrix(matrix) results = [] for (i1, j1, i2, j2) in queries: results.append(submatrix_sum(prefix_sum, i1, j1, i2, j2)) return results"},{"question":"from typing import List def is_prime(num: int) -> bool: Helper function to check if a number is prime. >>> is_prime(2) True >>> is_prime(4) False >>> is_prime(17) True pass def count_prime_product_subsets(primes: List[int]) -> int: Function to count subsets whose product is also a prime number. >>> count_prime_product_subsets([2, 3, 5, 7, 11]) 5 >>> count_prime_product_subsets([2]) 1 >>> count_prime_product_subsets([101, 103, 107, 109, 113, 127]) 6 pass def test_is_prime_function(): assert is_prime(2) == True assert is_prime(3) == True assert is_prime(4) == False assert is_prime(17) == True assert is_prime(18) == False def test_example_case(): primes = [2, 3, 5, 7, 11] assert count_prime_product_subsets(primes) == 5 def test_single_prime(): primes = [2] assert count_prime_product_subsets(primes) == 1 def test_no_prime_product_subset(): primes = [2, 3] assert count_prime_product_subsets(primes) == 2 def test_large_primes(): primes = [101, 103, 107, 109, 113, 127] assert count_prime_product_subsets(primes) == 6 def test_mixed_primes(): primes = [2, 5, 13, 23] assert count_prime_product_subsets(primes) == 4","solution":"def is_prime(num): Helper function to check if a number is prime. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def count_prime_product_subsets(primes): Function to count subsets whose product is also a prime number. from itertools import combinations count = 0 # Iterate over all possible subset sizes for r in range(1, len(primes)+1): # Iterate over all combinations of the current subset size for subset in combinations(primes, r): product = 1 for num in subset: product *= num if is_prime(product): count += 1 return count # Example usage n = 5 primes = [2, 3, 5, 7, 11] print(count_prime_product_subsets(primes)) # Output: 5"},{"question":"def max_sum_of_consecutive_statues(n: int, k: int, beauty_values: List[int]) -> int: Given the beauty values of the statues and the required length of the subsection (k), determine the maximum possible sum of the beauty values for any k consecutive statues. >>> max_sum_of_consecutive_statues(8, 3, [1, 2, 6, 4, 8, 3, 2, 7]) 18 >>> max_sum_of_consecutive_statues(1, 1, [5]) 5 >>> max_sum_of_consecutive_statues(5, 2, [3, 3, 3, 3, 3]) 6 >>> max_sum_of_consecutive_statues(10, 4, [1, 3, 1, 5, 1, 2, 6, 6, 7, 1]) 21 >>> max_sum_of_consecutive_statues(6, 6, [4, 6, 1, 8, 3, 2]) 24","solution":"def max_sum_of_consecutive_statues(n, k, beauty_values): max_sum = current_sum = sum(beauty_values[:k]) for i in range(k, n): current_sum += beauty_values[i] - beauty_values[i - k] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def longest_arith_seq_length(n: int) -> int: Given an integer n, returns the length of the longest arithmetic subsequence found in its digits. >>> longest_arith_seq_length(12345) 5 >>> longest_arith_seq_length(5471) 2 >>> longest_arith_seq_length(111111) 6 >>> longest_arith_seq_length(9876543210987654321) 10 >>> longest_arith_seq_length(97531) 5","solution":"def longest_arith_seq_length(n): Given an integer n, returns the length of the longest arithmetic subsequence found in its digits. digits = list(map(int, str(n))) length = len(digits) if length <= 1: return length # Dictionary dp to store the longest length of arithmetic subsequence ending at each pair dp = [{} for _ in range(length)] max_length = 1 for i in range(length): for j in range(i): diff = digits[i] - digits[j] if diff in dp[j]: dp[i][diff] = dp[j][diff] + 1 else: dp[i][diff] = 2 max_length = max(max_length, dp[i][diff]) return max_length"},{"question":"def minimum_absolute_difference(arr): Finds the minimum absolute difference between any two elements in the array. >>> minimum_absolute_difference([4, 9, 1, 3, 7]) == 1 >>> minimum_absolute_difference([3, 8, 1, 5]) == 2 >>> minimum_absolute_difference([10, 20, 30, 40, 50]) == 10 def parse_input_and_find_minimum_absolute_difference(input): Parses input and finds the minimum absolute difference between any two elements in the array. >>> input_data = \\"5n4 9 1 3 7n\\" >>> parse_input_and_find_minimum_absolute_difference(input_data) == 1 >>> input_data = \\"4n3 8 1 5n\\" >>> parse_input_and_find_minimum_absolute_difference(input_data) == 2","solution":"def minimum_absolute_difference(arr): Finds the minimum absolute difference between any two elements in the array. arr.sort() min_diff = float('inf') for i in range(1, len(arr)): diff = abs(arr[i] - arr[i - 1]) if diff < min_diff: min_diff = diff return min_diff def parse_input_and_find_minimum_absolute_difference(input): lines = input.strip().split('n') n = int(lines[0].strip()) arr = list(map(int, lines[1].strip().split())) return minimum_absolute_difference(arr)"},{"question":"def can_travel_to_last_room(n: int, gates: List[int]) -> str: Determines if it is possible to travel from the first room to the last room. :param n: Integer - number of rooms. :param gates: List of integers representing gate states (1 for open, 0 for closed). :return: \\"yes\\" if it is possible to travel from the first room to the last room, otherwise \\"no\\". >>> can_travel_to_last_room(3, [1, 1]) \\"yes\\" >>> can_travel_to_last_room(4, [1, 0, 1]) \\"no\\"","solution":"def can_travel_to_last_room(n, gates): Determines if it is possible to travel from the first room to the last room. :param n: Integer - number of rooms. :param gates: List of integers representing gate states (1 for open, 0 for closed). :return: \\"yes\\" if it is possible to travel from the first room to the last room, otherwise \\"no\\". for gate in gates: if gate == 0: return \\"no\\" return \\"yes\\""},{"question":"from typing import List, Tuple def solve_knapsack(input_data: str) -> int: Solve the knapsack problem given an input string. Args: input_data (str): A string containing the number of items, maximum weight capacity of the backpack, and each item's weight and value. Returns: int: The maximum total value of the items that can fit in the backpack. Example: >>> solve_knapsack(\\"3 50n10 60n20 100n30 120\\") 220 >>> solve_knapsack(\\"3 50n10 0n20 0n30 0\\") 0 >>> solve_knapsack(\\"4 50n10 50n10 50n10 50n10 50\\") 200 >>> solve_knapsack(\\"1 10n10 100\\") 100 >>> solve_knapsack(\\"1 10n20 200\\") 0","solution":"def knapsack(n, W, items): Returns the maximum total value of items that can be put in a knapsack of capacity W. :param n: Number of items :param W: Maximum weight capacity of the knapsack :param items: List of (weight, value) tuples :return: Maximum value that can be achieved # Initialize the DP table dp = [[0] * (W + 1) for _ in range(n + 1)] # Fill the DP table for i in range(1, n + 1): wi, vi = items[i-1] for w in range(W + 1): if w >= wi: dp[i][w] = max(dp[i-1][w], dp[i-1][w-wi] + vi) else: dp[i][w] = dp[i-1][w] return dp[n][W] # Parse input def parse_input(input_str): lines = input_str.strip().split('n') n, W = map(int, lines[0].split()) items = [tuple(map(int, line.split())) for line in lines[1:]] return n, W, items # Function to be called with input def solve_knapsack(input_str): n, W, items = parse_input(input_str) return knapsack(n, W, items) # Example usage input_data = \\"3 50n10 60n20 100n30 120\\" print(solve_knapsack(input_data)) # Output should be 220"},{"question":"def max_deliveries(battery_life: int, distances: List[int]) -> int: Determine the maximum number of deliveries the drone can complete without running out of battery. Parameters: battery_life (int): The total battery life of the drone in minutes. distances (List[int]): A list of integers representing the distances of each delivery in kilometers. Returns: int: The maximum number of deliveries that can be completed. Examples: >>> max_deliveries(100, [20, 30, 50]) 3 >>> max_deliveries(100, [20, 30, 10, 50]) 3 >>> max_deliveries(10, [10, 10, 10]) 1 >>> max_deliveries(10, [5]) 1 >>> max_deliveries(10, [1, 2, 3, 4]) 4 >>> max_deliveries(1, [2, 3, 4]) 0 >>> max_deliveries(100, [50, 20, 30, 10]) 3","solution":"def max_deliveries(battery_life, distances): Returns the maximum number of deliveries that can be completed within the given battery life. # Sort distances to try shorter deliveries first distances.sort() # Initialize counters total_time = 0 delivery_count = 0 # Iterate through distances and count deliveries for distance in distances: if total_time + distance <= battery_life: total_time += distance delivery_count += 1 else: break return delivery_count"},{"question":"from typing import List, Tuple def process_queries(n: int, queries: List[Tuple[int, int]]) -> List[str]: Process a series of operations on an array of integers. Each query is one of the following types: 1. Add an integer x to the end of the array. 2. Remove the last element of the array. 3. Check if there exists a pair of elements in the array that sum up to a given integer y. Returns the results for all Type 3 queries. Args: n (int): Number of queries. queries (List[Tuple[int, int]]): List of queries. Returns: List[str]: Results of Type 3 queries. >>> process_queries(8, [(1, 1), (1, 2), (1, 3), (3, 4), (2, 0), (3, 5), (1, 2), (3, 4)]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> process_queries(3, [(2, 0), (2, 0), (3, 5)]) [\\"NO\\"]","solution":"def process_queries(n, queries): from collections import defaultdict def has_pair_with_sum(arr, target): seen = set() for num in arr: if target - num in seen: return True seen.add(num) return False arr = [] results = [] for query in queries: t, x = query if t == 1: arr.append(x) elif t == 2: if arr: arr.pop() elif t == 3: if has_pair_with_sum(arr, x): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def kth_smallest_element(arr: List[int], k: int) -> int: Given an array of integers and an integer k, find and print the k-th smallest element in the array after sorting it in non-decreasing order. >>> kth_smallest_element([3, 1, 2, 5, 4], 2) 2 >>> kth_smallest_element([7, 10, 4, 3, 20, 15], 4) 10","solution":"def kth_smallest_element(arr, k): Function to find the k-th smallest element in a sorted array. :param arr: list of integers :param k: integer representing the k-th position :return: the k-th smallest element arr.sort() # Sort the array in non-decreasing order return arr[k-1] # Return the k-th smallest element (1-based index)"},{"question":"def count_blocks(s: str) -> int: Counts the number of blocks in the given binary string s. A block is defined as a group of consecutive '1's possibly separated by any number of '0's. Args: s (str): A string consisting of '0's and '1's only. Returns: int: The number of blocks in the binary string. Examples: >>> count_blocks(\\"011000110\\") 2 >>> count_blocks(\\"111000\\") 1 >>> count_blocks(\\"0000\\") 0","solution":"def count_blocks(s): Counts the number of blocks in the given binary string s. if '1' not in s: return 0 blocks = 0 in_block = False for char in s: if char == '1' and not in_block: blocks += 1 in_block = True elif char == '0': in_block = False return blocks"},{"question":"def minimum_cost_to_connect_towns(n: int, roads: List[Tuple[int, int, int]]) -> int: Calculate the minimum possible cost to make the road network connected with the given towns and roads. Args: n (int): The number of towns. roads (List[Tuple[int, int, int]]): A list of tuples where each tuple contains three integers u, v, and w representing a road between town u and town v with cost w. Returns: int: The minimum total cost to make the road network connected. If it is impossible to connect the towns, return -1. Examples: >>> minimum_cost_to_connect_towns(4, [(1, 2, 3), (2, 3, 4), (3, 4, 5)]) 12 >>> minimum_cost_to_connect_towns(2, [(1, 2, 1)]) 1 >>> minimum_cost_to_connect_towns(3, [(1, 2, 2)]) -1 from typing import List, Tuple def test_example1(): n = 4 roads = [(1, 2, 3), (2, 3, 4), (3, 4, 5)] assert minimum_cost_to_connect_towns(n, roads) == 12 def test_example2(): n = 2 roads = [(1, 2, 1)] assert minimum_cost_to_connect_towns(n, roads) == 1 def test_example3(): n = 3 roads = [(1, 2, 2)] assert minimum_cost_to_connect_towns(n, roads) == -1 def test_single_town(): n = 1 roads = [] assert minimum_cost_to_connect_towns(n, roads) == 0 def test_no_roads(): n = 5 roads = [] assert minimum_cost_to_connect_towns(n, roads) == -1 def test_all_towns_connected(): n = 4 roads = [(1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 1, 1), (1, 3, 2), (2, 4, 2)] assert minimum_cost_to_connect_towns(n, roads) == 3","solution":"def find(parent, i): if parent[i] == i: return i else: parent[i] = find(parent, parent[i]) return parent[i] def union(parent, rank, x, y): rootX = find(parent, x) rootY = find(parent, y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 def minimum_cost_to_connect_towns(n, roads): if n == 1: return 0 edges = [] for road in roads: u, v, w = road edges.append((w, u-1, v-1)) edges.sort() parent = list(range(n)) rank = [0] * n total_cost = 0 edges_used = 0 for edge in edges: w, u, v = edge if find(parent, u) != find(parent, v): union(parent, rank, u, v) total_cost += w edges_used += 1 if edges_used == n - 1: return total_cost return -1 # Not all towns are connected # Example usage: # Input: n = 4, roads = [(1, 2, 3), (2, 3, 4), (3, 4, 5)] # Output: 12"},{"question":"import heapq class MedianFinder: def __init__(self): Initialize the MedianFinder data structure. self.max_heap = [] # max heap to store the smaller half of the numbers self.min_heap = [] # min heap to store the larger half of the numbers def addNum(self, num: int) -> None: Add an integer num from the data stream to the data structure. pass def findMedian(self) -> float: Return the median of all elements so far. pass def test_addNum_and_findMedian(): mf = MedianFinder() mf.addNum(1) assert mf.findMedian() == 1.0 mf.addNum(2) assert mf.findMedian() == 1.5 mf.addNum(3) assert mf.findMedian() == 2.0 mf.addNum(4) assert mf.findMedian() == 2.5 mf.addNum(5) assert mf.findMedian() == 3.0 def test_mixed_order(): mf = MedianFinder() mf.addNum(5) mf.addNum(2) mf.addNum(1) assert mf.findMedian() == 2.0 mf.addNum(3) assert mf.findMedian() == 2.5 mf.addNum(4) assert mf.findMedian() == 3.0 def test_single_element(): mf = MedianFinder() mf.addNum(100) assert mf.findMedian() == 100.0 def test_large_numbers(): mf = MedianFinder() nums = [1000000, 1000001, 1000002, 1000003, 1000004] for num in nums: mf.addNum(num) assert mf.findMedian() == 1000002.0 def test_negative_numbers(): mf = MedianFinder() nums = [-5, -10, -15, -20, -25] for num in nums: mf.addNum(num) assert mf.findMedian() == -15.0 def test_combined_positive_negative(): mf = MedianFinder() nums = [-3, -1, 1, 3] for num in nums: mf.addNum(num) assert mf.findMedian() == 0.0","solution":"import heapq class MedianFinder: def __init__(self): Initialize the MedianFinder data structure. self.max_heap = [] # max heap to store the smaller half of the numbers self.min_heap = [] # min heap to store the larger half of the numbers def addNum(self, num: int) -> None: Add an integer num from the data stream to the data structure. # Always add to max-heap first heapq.heappush(self.max_heap, -num) # Balance max-heap and min-heap if (self.max_heap and self.min_heap and (-self.max_heap[0] > self.min_heap[0])): val = -heapq.heappop(self.max_heap) heapq.heappush(self.min_heap, val) # Ensure max-heap has equal or one more element than min-heap if len(self.max_heap) > len(self.min_heap) + 1: val = -heapq.heappop(self.max_heap) heapq.heappush(self.min_heap, val) if len(self.min_heap) > len(self.max_heap): val = heapq.heappop(self.min_heap) heapq.heappush(self.max_heap, -val) def findMedian(self) -> float: Return the median of all elements so far. if len(self.max_heap) > len(self.min_heap): return -self.max_heap[0] else: return (-self.max_heap[0] + self.min_heap[0]) / 2.0"},{"question":"def calculate_total_income(n: int, m: int, stock_levels: List[int], prices: List[int], orders: List[int]) -> int: Calculate the total income from serving customers based on stock levels and prices per type of pastry. :param n: Number of different types of pastries. :param m: Number of customers. :param stock_levels: A list of integers representing stock levels for each type of pastry. :param prices: A list of integers representing prices for each type of pastry. :param orders: A list of integers representing the type of pastry each customer wants to buy. :return: Total income earned by Henry. total_income = 0 for order in orders: pastry_type = order - 1 # Convert 1-indexed to 0-indexed if stock_levels[pastry_type] > 0: total_income += prices[pastry_type] stock_levels[pastry_type] -= 1 return total_income def test_calculate_total_income_example(): n = 3 m = 4 stock_levels = [2, 5, 6] prices = [100, 200, 150] orders = [1, 2, 2, 3] assert calculate_total_income(n, m, stock_levels, prices, orders) == 650 def test_calculate_total_income_no_orders(): n = 3 m = 0 stock_levels = [2, 5, 6] prices = [100, 200, 150] orders = [] assert calculate_total_income(n, m, stock_levels, prices, orders) == 0 def test_calculate_total_income_no_stock(): n = 3 m = 3 stock_levels = [0, 0, 0] prices = [100, 200, 150] orders = [1, 2, 3] assert calculate_total_income(n, m, stock_levels, prices, orders) == 0 def test_calculate_total_income_some_stock(): n = 3 m = 6 stock_levels = [1, 1, 1] prices = [100, 200, 150] orders = [1, 1, 2, 2, 3, 3] assert calculate_total_income(n, m, stock_levels, prices, orders) == 450 def test_calculate_total_income_exact_stock(): n = 2 m = 4 stock_levels = [2, 2] prices = [100, 200] orders = [1, 1, 2, 2] assert calculate_total_income(n, m, stock_levels, prices, orders) == 600","solution":"def calculate_total_income(n, m, stock_levels, prices, orders): Calculate the total income from serving customers based on stock levels and prices per type of pastry. :param n: Number of different types of pastries. :param m: Number of customers. :param stock_levels: A list of integers representing stock levels for each type of pastry. :param prices: A list of integers representing prices for each type of pastry. :param orders: A list of integers representing the type of pastry each customer wants to buy. :return: Total income earned by Henry. total_income = 0 for order in orders: pastry_type = order - 1 # Convert 1-indexed to 0-indexed if stock_levels[pastry_type] > 0: total_income += prices[pastry_type] stock_levels[pastry_type] -= 1 return total_income"},{"question":"def find_playlist(n: int, d: int, lengths: List[int]) -> Tuple[str, List[int]]: Reorders the songs such that the absolute difference between the lengths of any two consecutive songs is greater than or equal to d if possible. Parameters: - n (int): The number of songs. - d (int): Minimum absolute difference between lengths of consecutive songs. - lengths (list of int): The lengths of the songs. Returns: - (str, list): A tuple containing \\"YES\\" or \\"NO\\" and the reordered list of lengths if possible. Example: >>> find_playlist(5, 3, [1, 7, 4, 9, 12]) (\\"YES\\", [1, 4, 9, 7, 12]) >>> find_playlist(5, 6, [1, 2, 3, 4, 5]) (\\"NO\\", []) >>> find_playlist(1, 1, [5]) (\\"YES\\", [5]) >>> find_playlist(5, 20, [1, 22, 44, 66, 87]) (\\"YES\\", [1, 22, 44, 66, 87]) >>> find_playlist(3, 1, [10, 10, 10]) (\\"NO\\", [])","solution":"def find_playlist(n, d, lengths): Reorders the songs such that the absolute difference between the lengths of any two consecutive songs is greater than or equal to d if possible. Parameters: - n (int): The number of songs. - d (int): Minimum absolute difference between lengths of consecutive songs. - lengths (list of int): The lengths of the songs. Returns: - (str, list): A tuple containing \\"YES\\" or \\"NO\\" and the reordered list of lengths if possible. lengths.sort() playlist = [lengths.pop(0)] while lengths: for i in range(len(lengths)): if abs(lengths[i] - playlist[-1]) >= d: playlist.append(lengths.pop(i)) break else: return \\"NO\\", [] return \\"YES\\", playlist"},{"question":"def min_rooms_for_paintings(test_cases): Calculate the minimum number of rooms needed to hang all paintings such that no room contains paintings by more than one artist. >>> min_rooms_for_paintings([(5, 3, [1, 2, 2, 3, 1]), (6, 4, [2, 2, 3, 3, 4, 4])]) [3, 3] >>> min_rooms_for_paintings([(7, 3, [1, 1, 1, 2, 2, 3, 3])]) [3] >>> min_rooms_for_paintings([(4, 1, [1, 1, 1, 1])]) [4] >>> min_rooms_for_paintings([(4, 4, [1, 2, 3, 4])]) [1]","solution":"def min_rooms_for_paintings(test_cases): results = [] for n, k, artists in test_cases: from collections import Counter artist_count = Counter(artists).values() max_paintings_by_artist = max(artist_count) results.append(max_paintings_by_artist) return results"},{"question":"def min_moves_to_win(n: int, m: int) -> int: Returns the minimum number of moves needed to win the game given n cells and m-sided die. >>> min_moves_to_win(10, 6) 2 >>> min_moves_to_win(5, 3) 2","solution":"def min_moves_to_win(n, m): Returns the minimum number of moves needed to win the game given n cells and m-sided die. # The minimum number of moves is determined by dividing n by m and checking for any remainder. # If there is a remainder, it means an additional move is necessary. if n % m == 0: return n // m else: return n // m + 1"},{"question":"from typing import List def largest_rectangle_area(grid: List[List[int]]) -> int: This function takes a 2D list of integers representing building heights and returns the largest rectangular area where every building within the rectangle has the same height. Args: grid (List[List[int]]): A list of lists where each sublist contains integers representing the heights of the buildings in the city grid. Returns: int: The largest possible area of a rectangle where every building within the rectangle has the same height. >>> largest_rectangle_area([ ... [1, 1, 1, 0, 0], ... [1, 1, 1, 0, 0], ... [1, 1, 1, 0, 0], ... [0, 0, 0, 0, 0] ... ]) == 9 >>> largest_rectangle_area([ ... [2, 2], ... [2, 2] ... ]) == 4 >>> largest_rectangle_area([ ... [1, 2, 1, 2], ... [2, 1, 2, 1], ... [1, 2, 1, 2], ... [2, 1, 2, 1] ... ]) == 1 >>> largest_rectangle_area([ ... [5, 5, 5, 5], ... [5, 0, 0, 5], ... [5, 5, 5, 5], ... [5, 5, 5, 5] ... ]) == 8","solution":"def largest_rectangle_area(grid): This function takes a 2D list of integers representing building heights and returns the largest rectangular area where every building within the rectangle has the same height. if not grid: return 0 n, m = len(grid), len(grid[0]) max_area = 0 # Create a dictionary to hold height specific histograms height_histograms = {} for i in range(n): for j in range(m): if grid[i][j] not in height_histograms: height_histograms[grid[i][j]] = [[0] * m for _ in range(n)] if i == 0: height_histograms[grid[i][j]][i][j] = 1 else: height_histograms[grid[i][j]][i][j] = (height_histograms[grid[i][j]][i - 1][j] + 1) if grid[i][j] == grid[i - 1][j] else 1 for height in height_histograms: max_area = max(max_area, max_histogram_area(height_histograms[height])) return max_area def max_histogram_area(histogram): This helper function calculates the maximum rectangular area in a histogram. max_area = 0 for row in histogram: stack = [] index = 0 while index < len(row): if not stack or row[stack[-1]] <= row[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (row[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (row[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def min_operations_to_equal_elements(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the minimum number of operations required to make all elements of the array equal. >>> min_operations_to_equal_elements(3, [(3, [1, 2, 3]), (4, [1, 1, 1, 1]), (5, [1, 3, 2, 1, 2])]) [2, 0, 2] >>> min_operations_to_equal_elements(2, [(5, [5, 5, 5, 5, 5]), (3, [1, 1000000, 1000000])]) [0, 999999] >>> min_operations_to_equal_elements(1, [(6, [1, 10, 5, 3, 7, 10])]) [9] >>> min_operations_to_equal_elements(4, [(3, [1, 2, 1]), (4, [3, 3, 3, 3]), (5, [5, 6, 5, 6, 5]), (2, [10, 10])]) [1, 0, 1, 0] >>> min_operations_to_equal_elements(2, [(7, [0, 0, 0, 0, 0, 0, 0]), (4, [1, 1, 2, 1])]) [0, 1] pass","solution":"def min_operations_to_equal_elements(t, test_cases): results = [] for case in test_cases: n, arr = case max_value = max(arr) results.append(max_value - min(arr)) return results # Function to parse input and call the main function def process_input(input_str): input_lines = input_str.strip().split('n') t = int(input_lines[0]) test_cases = [] index = 1 for _ in range(t): n = int(input_lines[index]) arr = list(map(int, input_lines[index + 1].split())) test_cases.append((n, arr)) index += 2 return min_operations_to_equal_elements(t, test_cases)"},{"question":"from typing import List, Tuple def shortest_path_length(n: int, edges: List[Tuple[int, int]], queries: List[Tuple[int, int]]) -> List[int]: Determine the shortest path length between given pairs of nodes in a binary tree rooted at node 1. Args: n (int): Number of nodes in the tree. edges (List[Tuple[int, int]]): List of edges representing the tree. queries (List[Tuple[int, int]]): List of node pairs for which the shortest path length is to be found. Returns: List[int]: List containing shortest path lengths for each query. Example: >>> n = 5 >>> edges = [(1, 2), (1, 3), (2, 4), (2, 5)] >>> queries = [(4, 5), (4, 3), (3, 5)] >>> shortest_path_length(n, edges, queries) [2, 3, 3] >>> n = 4 >>> edges = [(1, 2), (2, 3), (3, 4)] >>> queries = [(1, 4), (2, 4), (1, 3)] >>> shortest_path_length(n, edges, queries) [3, 2, 2]","solution":"from collections import defaultdict, deque def build_tree(n, edges): tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) return tree def bfs_distance(tree, start): distances = {start: 0} queue = deque([start]) while queue: node = queue.popleft() for neighbor in tree[node]: if neighbor not in distances: distances[neighbor] = distances[node] + 1 queue.append(neighbor) return distances def shortest_path_length(n, edges, queries): tree = build_tree(n, edges) # Precompute distances from every node to every other node using BFS all_distances = {} for node in range(1, n + 1): all_distances[node] = bfs_distance(tree, node) results = [] for a, b in queries: results.append(all_distances[a][b]) return results # Example input n = 5 edges = [(1, 2), (1, 3), (2, 4), (2, 5)] queries = [(4, 5), (4, 3), (3, 5)] # Running Example print(shortest_path_length(n, edges, queries)) # Output: [2, 3, 3]"},{"question":"def suggest_words(dictionary: List[str], prefix: str) -> List[str]: Returns a list of words from the dictionary that start with the given prefix, sorted lexicographically. >>> suggest_words([\\"apple\\", \\"application\\", \\"bee\\", \\"appetite\\", \\"ban\\", \\"applesauce\\", \\"app\\"], \\"app\\") [\\"app\\", \\"appetite\\", \\"apple\\", \\"applesauce\\", \\"application\\"] >>> suggest_words([\\"apple\\", \\"application\\", \\"bee\\", \\"appetite\\", \\"ban\\", \\"applesauce\\", \\"app\\"], \\"cat\\") [] >>> suggest_words([\\"a\\", \\"ab\\", \\"abc\\", \\"abcd\\", \\"abcde\\"], \\"a\\") [\\"a\\", \\"ab\\", \\"abc\\", \\"abcd\\", \\"abcde\\"] >>> suggest_words([\\"a\\", \\"ab\\", \\"abc\\", \\"abcd\\", \\"abcde\\"], \\"ab\\") [\\"ab\\", \\"abc\\", \\"abcd\\", \\"abcde\\"] >>> suggest_words([\\"apple\\", \\"bee\\", \\"ban\\"], \\"\\") [\\"apple\\", \\"ban\\", \\"bee\\"] >>> suggest_words([], \\"app\\") []","solution":"def suggest_words(dictionary, prefix): Returns a list of words from the dictionary that start with the given prefix, sorted lexicographically. return sorted([word for word in dictionary if word.startswith(prefix)])"},{"question":"def can_sort_by_swaps(n: int, arr: List[int]) -> str: Determine if the array can be sorted using swaps between elements where the sum of their positions is even. >>> can_sort_by_swaps(5, [3, 2, 1, 4, 5]) \\"YES\\" >>> can_sort_by_swaps(4, [4, 1, 3, 2]) \\"NO\\"","solution":"def can_sort_by_swaps(n, arr): Determine if the array can be sorted using swaps between elements where the sum of their positions is even. # Split array into two subarrays based on the parity of indices even_idx_elements = [arr[i] for i in range(n) if i % 2 == 0] odd_idx_elements = [arr[i] for i in range(n) if i % 2 != 0] # Sort both subarrays even_idx_elements.sort() odd_idx_elements.sort() # Reconstruct the array with sorted elements at their respective positions sorted_arr = [] even_pointer = 0 odd_pointer = 0 for i in range(n): if i % 2 == 0: sorted_arr.append(even_idx_elements[even_pointer]) even_pointer += 1 else: sorted_arr.append(odd_idx_elements[odd_pointer]) odd_pointer += 1 # Check if the reconstructed array is sorted return \\"YES\\" if sorted_arr == sorted(arr) else \\"NO\\""},{"question":"def min_operations_to_equalize(sequence): Returns the minimum number of operations required to make all elements of the sequence equal. >>> min_operations_to_equalize([4, 3, 2, 3, 4]) == 2 >>> min_operations_to_equalize([1, 2, 3, 4]) == 6 >>> min_operations_to_equalize([3, 3, 3, 3]) == 0","solution":"def min_operations_to_equalize(sequence): Returns the minimum number of operations required to make all elements of the sequence equal. min_value = min(sequence) return sum(value - min_value for value in sequence)"},{"question":"def minimum_total_difficulty(n: int, t: int, difficulties: List[int]) -> int: Determines the minimum total difficulty Alice must solve to complete all tasks, or return -1 if it's impossible based on the given movement rule. Parameters: n (int): the number of tasks t (int): the maximum difference in difficulty between consecutive tasks difficulties (list): a list of integers representing the difficulty levels of each task Returns: int: the minimum total difficulty or -1 if it is impossible to complete all tasks >>> minimum_total_difficulty(5, 2, [4, 2, 6, 8, 10]) == 30 >>> minimum_total_difficulty(3, 1, [1, 4, 7]) == -1 >>> minimum_total_difficulty(1, 5, [8]) == 8 >>> minimum_total_difficulty(5, 10, [10, 15, 5, 20, 25]) == 75 >>> minimum_total_difficulty(3, 0, [1, 2, 3]) == -1 >>> minimum_total_difficulty(3, 0, [2, 2, 2]) == 6","solution":"def minimum_total_difficulty(n, t, difficulties): Determines the minimum total difficulty Alice must solve to complete all tasks, or return -1 if it's impossible based on the given movement rule. Parameters: n (int): the number of tasks t (int): the maximum difference in difficulty between consecutive tasks difficulties (list): a list of integers representing the difficulty levels of each task Returns: int: the minimum total difficulty or -1 if it is impossible to complete all tasks difficulties.sort() for i in range(1, n): if difficulties[i] - difficulties[i-1] > t: return -1 return sum(difficulties)"},{"question":"def can_be_sorted_by_removing_one_element(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Given an array of integers, determine if it is possible to make the array sorted in non-decreasing order by removing at most one element. For each test case, return \\"YES\\" if it's possible, otherwise \\"NO\\". >>> can_be_sorted_by_removing_one_element(3, [(5, [1, 2, 10, 5, 7]), (4, [1, 2, 3, 4]), (6, [10, 5, 1, 3, 4, 6])]) == [\\"YES\\", \\"YES\\", \\"NO\\"] >>> can_be_sorted_by_removing_one_element(2, [(3, [1, 2, 3]), (5, [1, 2, 3, 4, 5])]) == [\\"YES\\", \\"YES\\"]","solution":"def can_be_sorted_by_removing_one_element(t, test_cases): results = [] for case in test_cases: n, arr = case if is_sorted(arr): results.append(\\"YES\\") continue found_solution = False for i in range(n): new_arr = arr[:i] + arr[i+1:] if is_sorted(new_arr): found_solution = True results.append(\\"YES\\") break if not found_solution: results.append(\\"NO\\") return results def is_sorted(arr): for i in range(1, len(arr)): if arr[i] < arr[i-1]: return False return True"},{"question":"def is_complete_binary_tree(n: int, nodes: List[Tuple[int, int]]) -> str: Determines if a binary tree is a complete binary tree. Args: n (int): The number of nodes in the binary tree. nodes (list of tuple of int): The left and right children of each node. Returns: str: \\"Yes\\" if the binary tree is complete, \\"No\\" otherwise. Examples: >>> is_complete_binary_tree(1, [(0, 0)]) \\"Yes\\" >>> is_complete_binary_tree(5, [(2, 3), (4, 5), (0, 0), (0, 0), (0, 0)]) \\"Yes\\" >>> is_complete_binary_tree(5, [(2, 3), (0, 4), (5, 0), (0, 0), (0, 0)]) \\"No\\" >>> is_complete_binary_tree(3, [(2, 0), (0, 3), (0, 0)]) \\"No\\" >>> is_complete_binary_tree(5, [(2, 3), (0, 0), (4, 5), (0, 0), (0, 0)]) \\"No\\"","solution":"def is_complete_binary_tree(n, nodes): Determines if a binary tree is a complete binary tree. Args: n (int): The number of nodes in the binary tree. nodes (list of tuple of int): The left and right children of each node. Returns: str: \\"Yes\\" if the binary tree is complete, \\"No\\" otherwise. if n == 0: return \\"Yes\\" tree = [(0, 0)] + nodes # Append a dummy node at index 0 for ease # To check completeness, perform level order traversal queue = [1] # Start with the root node (index 1) index = 0 found_gap = False while index < len(queue): current = queue[index] index += 1 left, right = tree[current] if left != 0: if found_gap: return \\"No\\" queue.append(left) else: found_gap = True if right != 0: if found_gap: return \\"No\\" queue.append(right) else: found_gap = True return \\"Yes\\""},{"question":"def min_travel_time(n: int, m: int, k: int, roads: List[Tuple[int, int, int]]) -> int: Determine the minimum possible value of the longest travel time between any two attractions when they are optimally placed. Args: n (int): Number of cities m (int): Number of roads k (int): Number of attractions to be built roads (List[Tuple[int, int, int]]): List of tuples representing the roads where each tuple has three integers (u, v, t), meaning there is a bidirectional road between cities u and v that takes t units of time to travel. Returns: int: The minimum possible value of the longest travel time between any two attractions. Example: >>> n, m, k = 5, 6, 3 >>> roads = [(1, 2, 4), (1, 3, 2), (2, 3, 5), (2, 4, 1), (3, 5, 7), (4, 5, 3)] >>> min_travel_time(n, m, k, roads) 3","solution":"import heapq def min_travel_time(n, m, k, roads): # Create an adjacency list graph = {i: [] for i in range(1, n + 1)} for u, v, t in roads: graph[u].append((v, t)) graph[v].append((u, t)) # Function to perform Dijkstra's algorithm to find shortest paths from a given source def dijkstra(source): distances = {i: float('inf') for i in range(1, n + 1)} distances[source] = 0 priority_queue = [(0, source)] while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) if current_distance > distances[current_vertex]: continue for neighbor, weight in graph[current_vertex]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances # Perform Dijkstra's algorithm from every city all_pair_shortest_paths = {i: dijkstra(i) for i in range(1, n + 1)} # We need to select k cities such that the maximum distance between any pair is minimized cities = list(range(1, n + 1)) def valid(mid): # Check if there are at least k cities where all pairs are within mid distance for i in range(len(cities)): # DFS to count cities within 'mid' distance count = 0 stack = [cities[i]] visited = set() while stack: u = stack.pop() if u not in visited: visited.add(u) count += 1 for v in cities: if v != u and all_pair_shortest_paths[u][v] <= mid and v not in visited: stack.append(v) if count >= k: return True return False # Binary search on the answer low, high = 0, 10**5 while low < high: mid = (low + high) // 2 if valid(mid): high = mid else: low = mid + 1 return low"},{"question":"def min_substrings_with_one(binary_str: str) -> int: Returns the minimum number of substrings such that each substring contains at least one '1'. If it's impossible, returns -1. >>> min_substrings_with_one(\\"1101101\\") 5 >>> min_substrings_with_one(\\"0000\\") -1 >>> min_substrings_with_one(\\"1\\") 1 >>> min_substrings_with_one(\\"1111\\") 4 >>> min_substrings_with_one(\\"010\\") 1","solution":"def min_substrings_with_one(binary_str): Returns the minimum number of substrings such that each substring contains at least one '1'. If it's impossible, returns -1. if '1' not in binary_str: return -1 # Count the number of '1's in the binary string count_of_ones = binary_str.count('1') # The minimum number of substrings containing at least one '1' is the number of '1's return count_of_ones"},{"question":"def max_plants(n: int, m: int, k: int, plant_reqs: List[int], garden_grid: List[List[int]]) -> int: Determines the maximum number of plants Jasmine can plant in her garden such that each plant gets at least the minimum amount of sunlight it needs. >>> max_plants(3, 3, 3, [5, 10, 15], [[2, 8, 6], [3, 11, 7], [12, 4, 5]]) == 2 >>> max_plants(3, 3, 3, [1, 2, 3], [[5, 5, 5], [5, 5, 5], [5, 5, 5]]) == 3 >>> max_plants(3, 3, 3, [10, 20, 30], [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 0 >>> max_plants(4, 3, 3, [5, 15, 10, 7], [[10, 5, 6], [11, 7, 8], [12, 6, 5]]) == 3 >>> max_plants(3, 3, 3, [10, 15, 20], [[10, 15, 20], [1, 2, 3], [4, 5, 6]]) == 3","solution":"def max_plants(n, m, k, plant_reqs, garden_grid): Determines the maximum number of plants Jasmine can plant in her garden such that each plant gets at least the minimum amount of sunlight it needs. # Flatten garden grid for easier traversal sunlight_values = [sunlight for row in garden_grid for sunlight in row] # Sort plant sunlight requirements and garden sunlight values plant_reqs.sort() sunlight_values.sort() # Initialize plant count plant_count = 0 # Try to place each plant in the garden for req in plant_reqs: for i, sunlight in enumerate(sunlight_values): if sunlight >= req: plant_count += 1 sunlight_values.pop(i) break return plant_count"},{"question":"def count_unique_colors(n, colors, edges, queries): Given a tree with n nodes, each with a color, and a list of queries, return the number of unique colors in the subtree of the specified node for each query. Parameters: n (int): Number of nodes in the tree colors (List[int]): List of colors of each node edges (List[Tuple[int, int]]): List of edges defining the tree structure queries (List[int]): List of nodes for which to count unique colors in their subtree Returns: List[int]: List of results for the provided queries Example: >>> count_unique_colors(5, [1, 2, 1, 3, 1], [(1, 2), (1, 3), (2, 4), (2, 5)], [1, 2, 3]) [3, 3, 1] >>> count_unique_colors(1, [1], [], [1]) [1]","solution":"def count_unique_colors(n, colors, edges, queries): from collections import defaultdict, deque # Build the tree tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) # Function to perform DFS and gather color counts def dfs(node, parent): color_count[node] = {colors[node - 1]} for neighbor in tree[node]: if neighbor != parent: dfs(neighbor, node) color_count[node].update(color_count[neighbor]) # Process each query color_count = [set() for _ in range(n + 1)] dfs(1, -1) results = [len(color_count[u]) for u in queries] return results"},{"question":"def min_operations_to_alternate(n: int, s: str) -> int: Calculate the minimum number of operations required to transform the given binary string into an alternating binary string. Parameters: n (int): The length of the binary string. s (str): A binary string of length n. Returns: int: The minimum number of operations required. Example: >>> min_operations_to_alternate(6, \\"000111\\") 2 >>> min_operations_to_alternate(1, \\"0\\") 0 >>> min_operations_to_alternate(1, \\"1\\") 0 >>> min_operations_to_alternate(6, \\"010101\\") 0 >>> min_operations_to_alternate(5, \\"10101\\") 0 >>> min_operations_to_alternate(2, \\"00\\") 1 >>> min_operations_to_alternate(2, \\"11\\") 1 >>> min_operations_to_alternate(6, \\"111111\\") 3 >>> min_operations_to_alternate(8, \\"00110011\\") 2","solution":"def min_operations_to_alternate(n, s): Calculate the minimum number of operations required to transform the given binary string into an alternating binary string. Parameters: n (int): The length of the binary string. s (str): A binary string of length n. Returns: int: The minimum number of operations required. if n == 1: return 0 flips = 0 for i in range(1, n): if s[i] == s[i - 1]: flips += 1 return (flips + 1) // 2"},{"question":"def min_puzzles(n: int) -> tuple: Returns the minimum number of Easy, Medium, and Hard puzzles that each team needs to solve. Parameters: - n (int): The number of players in each team Returns: - tuple: A tuple of three integers representing the minimum number of Easy, Medium, and Hard puzzles respectively. >>> min_puzzles(3) (3, 2, 1) >>> min_puzzles(5) (5, 3, 2) >>> min_puzzles(10) (10, 5, 4)","solution":"def min_puzzles(n): Returns the minimum number of Easy, Medium, and Hard puzzles that each team needs to solve. Parameters: - n (int): The number of players in each team Returns: - tuple: A tuple of three integers representing the minimum number of Easy, Medium, and Hard puzzles respectively. easy = n medium = (n + 1) // 2 hard = (n + 2) // 3 return easy, medium, hard"},{"question":"def calculate_trapped_water(heights: List[int]) -> int: This function calculates the maximum amount of water that can be trapped between walls given their heights. :param heights: List of integers representing the heights of the walls :return: Integer representing the maximum amount of trapped water >>> calculate_trapped_water([0, 1, 0, 2, 1, 0, 3, 1, 0, 1, 2]) 8 >>> calculate_trapped_water([1, 0, 1]) 1 >>> calculate_trapped_water([4, 2, 0, 3, 2, 5]) 9","solution":"def calculate_trapped_water(heights): This function calculates the maximum amount of water that can be trapped between walls given their heights. :param heights: List of integers representing the heights of the walls :return: Integer representing the maximum amount of trapped water if not heights or len(heights) < 3: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i-1], heights[i]) right_max[n-1] = heights[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - heights[i] return trapped_water"},{"question":"def min_additional_stages(n: int, schedules: List[Tuple[int, int]]) -> int: Determines the minimum number of additional stages required for the bands to ensure no overlapping performances. >>> min_additional_stages(2, [(1, 2), (3, 4)]) == 0 >>> min_additional_stages(3, [(1, 5), (2, 6), (7, 9)]) == 1 >>> min_additional_stages(3, [(1, 5), (1, 5), (1, 5)]) == 2 >>> min_additional_stages(3, [(1, 3), (3, 5), (5, 7)]) == 0 >>> min_additional_stages(4, [(1, 10), (2, 9), (3, 8), (4, 7)]) == 3 >>> min_additional_stages(2, [(0, 1000000), (500000, 1000000)]) == 1","solution":"def min_additional_stages(n, schedules): events = [] for start, end in schedules: events.append((start, 1)) # Band start events.append((end, -1)) # Band end events.sort() # Sort events by time, breaks tie by type (-1 before +1 if same time, to close stages first) max_concurrent = 0 current_concurrent = 0 for event in events: current_concurrent += event[1] if current_concurrent > max_concurrent: max_concurrent = current_concurrent return max_concurrent - 1 # additional stages required is one less than max simultaneous bands"},{"question":"def min_steps_to_make_elements_equal(arr): Returns the minimum number of steps required to make all elements in the array equal, or -1 if it is not possible. >>> min_steps_to_make_elements_equal([1, 1, 1]) == 0 >>> min_steps_to_make_elements_equal([1, 2, 3]) == 1 >>> min_steps_to_make_elements_equal([1, 2]) == -1 >>> min_steps_to_make_elements_equal([100, 100, 100]) == 0 >>> min_steps_to_make_elements_equal([1, 1, 2]) == -1 >>> min_steps_to_make_elements_equal([10]) == 0 >>> min_steps_to_make_elements_equal([5, 5]) == 0 >>> min_steps_to_make_elements_equal([0, 0, 0]) == 0","solution":"def min_steps_to_make_elements_equal(arr): Returns the minimum number of steps required to make all elements in the array equal, or -1 if it is not possible. # Check if all elements in the array are already equal if all(x == arr[0] for x in arr): return 0 # Calculate the sum of the array and the length of the array total_sum = sum(arr) n = len(arr) # If the total sum is not divisible by the length, it's impossible to make all elements equal if total_sum % n != 0: return -1 # Find the target value that each element should become target = total_sum // n # Count how many steps are required to make all elements equal steps = 0 for num in arr: steps += abs(target - num) # Each operation reduces the difference sum by 2 as each pair of non-equal elements can be summed together return steps // 2"},{"question":"def max_overlapping_obstacles(obstacles: List[Tuple[int, int]]) -> int: Find the maximum number of overlapping obstacles at any point on the line. >>> max_overlapping_obstacles([(1, 5), (2, 6), (4, 8), (1, 3), (7, 9)]) == 3 >>> max_overlapping_obstacles([(1, 2), (3, 4), (5, 6)]) == 1 >>> max_overlapping_obstacles([(1, 5), (2, 6), (3, 7)]) == 3 >>> max_overlapping_obstacles([(1, 10), (2, 3), (4, 5), (6, 7), (8, 9), (1, 2), (9, 10)]) == 3 >>> max_overlapping_obstacles([(1, 10)]) == 1 >>> max_overlapping_obstacles([(1000000, 1000000), (1, 1000000), (500000, 1000000)]) == 3 >>> max_overlapping_obstacles([(1, 1000000) for _ in range(10)]) == 10","solution":"def max_overlapping_obstacles(obstacles): events = [] for start, end in obstacles: events.append((start, 1)) # Starting of an obstacle events.append((end + 1, -1)) # Ending of an obstacle events.sort() max_overlaps = 0 current_overlaps = 0 for event in events: current_overlaps += event[1] if current_overlaps > max_overlaps: max_overlaps = current_overlaps return max_overlaps"},{"question":"import math def grazing_area(n, r, ponds): Calculate the total grazing area available to the goat in a circular field with circular ponds. Parameters: n (int): number of ponds r (int): radius of the circular field ponds (list of tuples): list containing the ponds information. Each tuple contains (xi, yi, ri) Returns: float: the total grazing area rounded to two decimal places. >>> grazing_area(1, 10, [(2, 2, 1)]) 310.63 >>> grazing_area(3, 10, [(2, 2, 1), (5, 5, 2), (-6, -6, 1)]) 281.74 >>> grazing_area(0, 10, []) 314.16 >>> grazing_area(2, 20, [(0, 0, 5), (10, 10, 2)]) 1193.81 >>> grazing_area(1, 1, [(0, 0, 1)]) 0.00","solution":"import math def grazing_area(n, r, ponds): Calculate the total grazing area available to the goat in a circular field with circular ponds. Parameters: n (int): number of ponds. r (int): radius of the circular field. ponds (list of tuples): list containing the ponds information. Each tuple contains (xi, yi, ri). Returns: float: the total grazing area rounded to two decimal places. field_area = math.pi * r * r ponds_area = 0 for pond in ponds: xi, yi, ri = pond ponds_area += math.pi * ri * ri grazing_area = field_area - ponds_area return round(grazing_area, 2)"},{"question":"def smallest_missing_positive(nums: List[int]) -> int: Returns the smallest positive integer missing from the list of integers. >>> smallest_missing_positive([3, 4, -1, 1]) 2 >>> smallest_missing_positive([1, 2, 0]) 3 >>> smallest_missing_positive([7, 8, 9, 11, 12]) 1","solution":"def smallest_missing_positive(nums): Returns the smallest positive integer missing from the list of integers. # Convert the list to a set to remove duplicates and for O(1) lookups num_set = set(nums) # Start checking from 1 onwards smallest_missing = 1 # Iterate until we find the missing integer while smallest_missing in num_set: smallest_missing += 1 return smallest_missing"},{"question":"def min_rectangle_area(m: int, buildings: List[Tuple[int, int]]) -> int: Find the minimum possible area of the rectangle that covers all the buildings. >>> min_rectangle_area(1, [(5, 5)]) 0 >>> min_rectangle_area(2, [(1, 1), (2, 2)]) 1 >>> min_rectangle_area(3, [(1, 1), (2, 2), (3, 4)]) 6 >>> min_rectangle_area(4, [(1, 2), (2, 3), (3, 4), (4, 5)]) 9 >>> min_rectangle_area(3, [(1, 1), (1, 1), (1, 1)]) 0 >>> min_rectangle_area(3, [(100, 200), (300, 400), (500, 600)]) 160000","solution":"def min_rectangle_area(m, buildings): if m <= 1: return 0 xs = [building[0] for building in buildings] ys = [building[1] for building in buildings] min_x = min(xs) max_x = max(xs) min_y = min(ys) max_y = max(ys) length = max_x - min_x width = max_y - min_y return length * width"},{"question":"def longest_substring(grid, s): Find the length of the longest substring of the unique string that appears as a sequence of adjacent characters in the grid. >>> longest_substring([ ['C', 'A', 'B'], ['D', 'E', 'F'], ['G', 'H', 'I'] ], \\"CAB\\") 3 >>> longest_substring([ ['C', 'A', 'B'], ['D', 'E', 'F'], ['G', 'H', 'I'] ], \\"XYZ\\") 0 >>> longest_substring([ ['C', 'A', 'B'], ['D', 'E', 'F'], ['G', 'H', 'I'] ], \\"CADE\\") 2 >>> longest_substring([ ['A', 'B', 'C'], ['H', 'G', 'D'], ['I', 'F', 'E'] ], \\"ABCDE\\") 5 >>> longest_substring([ ['C'] ], \\"C\\") 1","solution":"def longest_substring(grid, s): def search_in_grid(i, j, k): if not (0 <= i < n and 0 <= j < n): return 0 if grid[i][j] != s[k]: return 0 if k == len(s) - 1: return 1 temp = grid[i][j] grid[i][j] = '#' # mark as visited res = 1 + max( search_in_grid(i-1, j, k+1), search_in_grid(i+1, j, k+1), search_in_grid(i, j-1, k+1), search_in_grid(i, j+1, k+1) ) grid[i][j] = temp # restore the cell value return res n = len(grid) max_length = 0 for i in range(n): for j in range(n): if grid[i][j] == s[0]: max_length = max(max_length, search_in_grid(i, j, 0)) return max_length def main(): s = input().strip() n = int(input().strip()) grid = [input().strip().split() for _ in range(n)] print(longest_substring(grid, s)) if __name__ == \\"__main__\\": main()"},{"question":"def determine_winner(n: int, sequence: List[int]) -> str: Determine which player will win between Alice and Bob if both play optimally. If \`n\` is even, Alice will win. If \`n\` is odd, Bob will win. Parameters: n (int): The length of the sequence of positive integers. sequence (List[int]): The initial sequence of positive integers. Returns: str: \\"Alice\\" if Alice wins, otherwise \\"Bob\\". >>> determine_winner(4, [4, 8, 16, 32]) \\"Alice\\" >>> determine_winner(3, [7, 5, 9]) \\"Bob\\" def test_alice_wins_with_even_length(): assert determine_winner(4, [4, 8, 16, 32]) == \\"Alice\\" assert determine_winner(2, [1, 10]) == \\"Alice\\" assert determine_winner(6, [3, 6, 9, 12, 15, 18]) == \\"Alice\\" def test_bob_wins_with_odd_length(): assert determine_winner(3, [7, 5, 9]) == \\"Bob\\" assert determine_winner(1, [4]) == \\"Bob\\" assert determine_winner(5, [1, 2, 3, 4, 5]) == \\"Bob\\" def test_edge_cases(): assert determine_winner(2, [1, 2]) == \\"Alice\\" assert determine_winner(3, [1, 2, 3]) == \\"Bob\\" assert determine_winner(100000, [1]*100000) == \\"Alice\\" assert determine_winner(99999, [1]*99999) == \\"Bob\\"","solution":"def determine_winner(n, sequence): Determine the winner between Alice and Bob. Parameters: n (int): Length of the sequence. sequence (list of int): The initial sequence of positive integers. Returns: str: \\"Alice\\" if Alice wins, \\"Bob\\" if Bob wins. if n % 2 == 0: return \\"Alice\\" else: return \\"Bob\\""},{"question":"def preprocess_grid(grid): Preprocess the grid to create a prefix sum matrix for quick area sum lookup. def subgrid_sum(prefix_sum, r1, c1, r2, c2): Calculate the sum of the subgrid using the prefix sum matrix. def solve(n, q, grid, queries): Process each query and return the results as a list of sums for each subgrid. from solution import solve def test_example_case(): n = 3 q = 2 grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] queries = [ (1, 1, 2, 2), (2, 2, 3, 3) ] expected = [12, 28] assert solve(n, q, grid, queries) == expected def test_single_element_subgrid(): n = 3 q = 1 grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] queries = [ (2, 2, 2, 2) ] expected = [5] assert solve(n, q, grid, queries) == expected def test_full_grid(): n = 3 q = 1 grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] queries = [ (1, 1, 3, 3) ] expected = [45] assert solve(n, q, grid, queries) == expected def test_multiple_queries(): n = 4 q = 2 grid = [ [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1] ] queries = [ (1, 1, 2, 2), (2, 2, 3, 3) ] expected = [4, 4] assert solve(n, q, grid, queries) == expected","solution":"def preprocess_grid(grid): Preprocess the grid to create a prefix sum matrix for quick area sum lookup. n = len(grid) prefix_sum = [[0] * (n + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, n + 1): prefix_sum[i][j] = grid[i-1][j-1] + prefix_sum[i-1][j] + prefix_sum[i][j-1] - prefix_sum[i-1][j-1] return prefix_sum def subgrid_sum(prefix_sum, r1, c1, r2, c2): Calculate the sum of the subgrid using the prefix sum matrix. return prefix_sum[r2][c2] - prefix_sum[r1-1][c2] - prefix_sum[r2][c1-1] + prefix_sum[r1-1][c1-1] def solve(n, q, grid, queries): Process each query and return the results as a list of sums for each subgrid. prefix_sum = preprocess_grid(grid) results = [] for r1, c1, r2, c2 in queries: results.append(subgrid_sum(prefix_sum, r1, c1, r2, c2)) return results"},{"question":"def max_seated_groups(n, m, table_capacities, group_sizes): Assign as many groups to tables as possible based on their capacities. :param n: Number of tables (int) :param m: Number of groups (int) :param table_capacities: List of table capacities (list of int) :param group_sizes: List of group sizes (list of int) :return: Number of groups successfully seated (int) >>> max_seated_groups(5, 8, [5, 10, 5, 20, 15], [5, 10, 15, 3, 3, 2, 2, 8]) 5 >>> max_seated_groups(3, 3, [8, 4, 9], [4, 8, 2]) 3 >>> max_seated_groups(2, 3, [5, 10], [2, 5, 6]) 2 >>> max_seated_groups(4, 5, [1, 2, 3, 4], [4, 4, 4, 3, 1]) 3 >>> max_seated_groups(1, 1, [1], [2]) 0 >>> max_seated_groups(1, 1, [1000], [1000]) 1 >>> max_seated_groups(5, 5, [100, 200, 300, 400, 500], [50, 100, 150, 250, 400]) 5 >>> max_seated_groups(5, 8, [5, 10, 5, 20, 15], [5, 5, 5, 5, 5, 5, 5, 5]) 5","solution":"def max_seated_groups(n, m, table_capacities, group_sizes): This function assigns as many groups to tables as possible based on their capacities. :param n: Number of tables (int) :param m: Number of groups (int) :param table_capacities: List of table capacities (list of int) :param group_sizes: List of group sizes (list of int) :return: Number of groups successfully seated (int) # Sort table capacities and group sizes in ascending order table_capacities.sort() group_sizes.sort() table_index = 0 seated_count = 0 # Iterate over each group size for group in group_sizes: # Find the smallest table that can accommodate the group while table_index < n and table_capacities[table_index] < group: table_index += 1 if table_index < n: # If a table is found, seat the group and move to next table seated_count += 1 table_index += 1 else: break return seated_count"},{"question":"def is_bouncy_sequence(n: int, arr: List[int]) -> str: Returns \\"YES\\" if the array is bouncy, otherwise \\"NO\\". >>> is_bouncy_sequence(3, [1, 3, 2]) \\"YES\\" >>> is_bouncy_sequence(3, [1, 2, 3]) \\"NO\\" >>> is_bouncy_sequence(5, [4, 5, 6, 5, 4]) \\"YES\\"","solution":"def is_bouncy_sequence(n, arr): Returns \\"YES\\" if the array is bouncy, otherwise \\"NO\\". for i in range(1, n-1): if (arr[i-1] < arr[i] > arr[i+1]) or (arr[i-1] > arr[i] < arr[i+1]): return \\"YES\\" return \\"NO\\" # Example usage: # n = 3 # arr = [1, 3, 2] # print(is_bouncy_sequence(n, arr)) # Output: \\"YES\\""},{"question":"def common_fields(tables: List[List[str]], queries: List[Tuple[int, int]]) -> List[int]: Returns the number of common fields for each pair of tables in the given queries. Parameters: tables (list of list of str): A list where each element is a list containing the fields of a table. queries (list of tuple of int): A list of queries where each query is a tuple with two integers representing table indices. Returns: list of int: A list containing the number of common fields for each query. >>> tables = [[\\"name\\", \\"age\\"], [\\"name\\", \\"age\\", \\"address\\"], [\\"name\\"]] >>> queries = [(1, 2), (1, 3)] >>> common_fields(tables, queries) [2, 1] >>> tables = [[\\"name\\", \\"age\\"], [\\"address\\", \\"phone\\"], [\\"email\\"]] >>> queries = [(1, 2), (1, 3), (2, 3)] >>> common_fields(tables, queries) [0, 0, 0] >>> tables = [[\\"name\\", \\"age\\"], [\\"name\\", \\"age\\"], [\\"name\\", \\"age\\"]] >>> queries = [(1, 2), (1, 3), (2, 3)] >>> common_fields(tables, queries) [2, 2, 2] >>> tables = [[\\"name\\", \\"age\\", \\"email\\"], [\\"name\\", \\"phone\\", \\"age\\"], [\\"phone\\", \\"email\\"]] >>> queries = [(1, 2), (1, 3), (2, 3)] >>> common_fields(tables, queries) [2, 1, 1]","solution":"def common_fields(tables, queries): Returns the number of common fields for each pair of tables in the given queries. Parameters: tables (list of list of str): A list where each element is a list containing the fields of a table. queries (list of tuple of int): A list of queries where each query is a tuple with two integers representing table indices. Returns: list of int: A list containing the number of common fields for each query. results = [] for t1, t2 in queries: fields_t1 = set(tables[t1 - 1]) fields_t2 = set(tables[t2 - 1]) common_fields = fields_t1.intersection(fields_t2) results.append(len(common_fields)) return results"},{"question":"def uniquePathsWithObstacles(obstacleGrid: List[List[int]]) -> int: Calculates the number of unique paths from the top-left corner to the bottom-right corner of a grid, avoiding obstacles. The function takes a 2D list representing the grid, where 0s are empty cells and 1s are obstacles, and returns an integer, the count of unique paths modulo 10^9 + 7. >>> uniquePathsWithObstacles([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) 2 >>> uniquePathsWithObstacles([[0, 1], [0, 0]]) 1 >>> uniquePathsWithObstacles([[1, 0]]) 0 >>> uniquePathsWithObstacles([[0, 1], [1, 0]]) 0 >>> uniquePathsWithObstacles([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 6 >>> uniquePathsWithObstacles([[0]]) 1 >>> uniquePathsWithObstacles([[1]]) 0","solution":"def uniquePathsWithObstacles(obstacleGrid): MOD = 10**9 + 7 M = len(obstacleGrid) N = len(obstacleGrid[0]) if obstacleGrid[0][0] == 1 or obstacleGrid[M-1][N-1] == 1: return 0 # Initialize DP table dp = [[0] * N for _ in range(M)] dp[0][0] = 1 # Fill the DP table for i in range(M): for j in range(N): if obstacleGrid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] dp[i][j] %= MOD return dp[M-1][N-1]"},{"question":"from typing import List def min_days_to_read(n: int, p: int, m: int, pages: List[int]) -> int: Determine the minimum number of days required to achieve the reading goal of p pages. >>> min_days_to_read(10, 10, 3, [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) 4 >>> min_days_to_read(2, 6, 7, [2, 4]) 1 >>> min_days_to_read(3, 10, 10, [1, 2, 3]) -1 >>> min_days_to_read(5, 5, 2, [1, 2, 1, 1, 1]) 3 >>> min_days_to_read(1, 1, 1, [1]) 1 >>> min_days_to_read(4, 4, 1, [1, 1, 1, 1]) 4 >>> min_days_to_read(4, 7, 5, [1, 4, 2]) 2","solution":"def min_days_to_read(n, p, m, pages): if sum(pages) < p: return -1 day_count = 0 pages_read = 0 pages.sort(reverse=True) while pages_read < p: day_total = 0 todays_pages = [] for i in range(len(pages)): if day_total + pages[i] <= m: day_total += pages[i] todays_pages.append(i) if day_total == m: break for i in sorted(todays_pages, reverse=True): pages_read += pages.pop(i) day_count += 1 return day_count"},{"question":"def find_winner(n: int, m: int, grid: List[List[int]]) -> str: Determine whether Alice will guarantee a win if she plays optimally, or if Bob will guarantee a win if he plays optimally. Given the initial configuration of the grid, this function returns \\"Alice\\" if Alice can guarantee a win with optimal play, or \\"Bob\\" otherwise. >>> find_winner(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 'Bob' >>> find_winner(2, 2, [[1, 2], [3, 4]]) 'Alice' >>> find_winner(5, 5, [[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25]]) 'Bob' >>> find_winner(1, 4, [[1, 2, 3, 4]]) 'Alice' >>> find_winner(4, 1, [[1], [2], [3], [4]]) 'Alice' >>> find_winner(2, 3, [[1, 2, 3], [4, 5, 6]]) 'Alice' >>> find_winner(3, 2, [[1, 2], [3, 4], [5, 6]]) 'Alice' # Implementation goes here","solution":"def find_winner(n, m, grid): Returns the winner, Alice or Bob, given the grid dimensions and values. # Since we assume a 1-based grid, the nature of grid, and adjacency, # Winner calculation boils down to understanding blocking moves for each other. if n % 2 == 1 and m % 2 == 1: # In odd dimension grids with Alice starting: Bob can always maneuver return \\"Bob\\" # otherwise Alice always has an alternating-edge advantage. return \\"Alice\\""},{"question":"def minimize_well_cost(n: int, coordinates: List[int]) -> int: Find the coordinate w that minimizes the total cost of building a communal well. If there are multiple coordinates that result in the same minimal sum, the smallest one is chosen. Args: n (int): The number of villagers/houses. coordinates (List[int]): The coordinates of the houses. Returns: int: The optimal coordinate w that minimizes the total cost. >>> minimize_well_cost(3, [1, 2, 3]) 2 >>> minimize_well_cost(4, [1, 2, 3, 4]) 2 from solution import minimize_well_cost def test_single_house(): assert minimize_well_cost(1, [5]) == 5 def test_odd_number_houses(): assert minimize_well_cost(3, [1, 2, 3]) == 2 def test_even_number_houses(): assert minimize_well_cost(4, [1, 2, 3, 4]) == 2 assert minimize_well_cost(4, [1, 2, 3, 10]) == 2 def test_large_numbers(): assert minimize_well_cost(3, [1000000000, 2000000000, 3000000000]) == 2000000000 def test_unsorted_input(): assert minimize_well_cost(5, [3, 1, 2, 5, 4]) == 3 def test_duplicate_values(): assert minimize_well_cost(6, [1, 1, 2, 2, 2, 3]) == 2","solution":"def minimize_well_cost(n, coordinates): Find the coordinate w that minimizes the sum of distances to all houses. If there are multiple coordinates that result in the same minimal sum, the smallest one is chosen. # The optimal position is the median of the coordinates coordinates.sort() if n % 2 == 1: # If odd number of coordinates, median is the middle element return coordinates[n // 2] else: # If even number of coordinates, median can be any of the two middle elements mid1 = coordinates[n // 2 - 1] mid2 = coordinates[n // 2] return min(mid1, mid2)"},{"question":"def categorize_users(user_data): Categorize users into three tiers based on their total spending: Bronze: Spend less than 100 Silver: Spend between 100 and 500 (inclusive) Gold: Spend more than 500 Parameters: user_data (list): List of tuples containing user ID and spending amount Returns: tuple: Number of Bronze, Silver, and Gold users","solution":"def categorize_users(user_data): Categorize users into three tiers based on their total spending: Bronze: Spend less than 100 Silver: Spend between 100 and 500 (inclusive) Gold: Spend more than 500 Parameters: user_data (list): List of tuples containing user ID and spending amount Returns: tuple: Number of Bronze, Silver, and Gold users bronze_count = 0 silver_count = 0 gold_count = 0 for user_id, spending in user_data: if spending < 100: bronze_count += 1 elif spending <= 500: silver_count += 1 else: gold_count += 1 return bronze_count, silver_count, gold_count"},{"question":"def longest_palindromic_subsequence(s: str) -> int: Find the length of the longest palindromic subsequence in the given string. Args: s (str): The string to find the longest palindromic subsequence for. Returns: int: The length of the longest palindromic subsequence. >>> longest_palindromic_subsequence(\\"abacaba\\") 7 >>> longest_palindromic_subsequence(\\"abcde\\") 1 >>> longest_palindromic_subsequence(\\"aaa\\") 3 pass def solve(): Read input from stdin and print the length of the longest palindromic subsequence for each test case. import sys input = sys.stdin.read data = input().split() index = 0 t = int(data[index]) index += 1 results = [] for _ in range(t): n = int(data[index]) index += 1 s = data[index] index += 1 results.append(longest_palindromic_subsequence(s)) for result in results: print(result)","solution":"def longest_palindromic_subsequence(s): n = len(s) dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = 1 for cl in range(2, n + 1): for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j] and cl == 2: dp[i][j] = 2 elif s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) return dp[0][n - 1] def solve(): import sys input = sys.stdin.read data = input().split() index = 0 t = int(data[index]) index += 1 results = [] for _ in range(t): n = int(data[index]) index += 1 s = data[index] index += 1 results.append(longest_palindromic_subsequence(s)) for result in results: print(result)"},{"question":"def highest_affordable_price(n: int, B: int, prices: List[int]) -> int: Finds the highest price of a house that can be bought without exceeding the budget. Parameters: n (int): Number of houses. B (int): Budget. prices (list[int]): Array of house prices. Returns: int: The maximum price within budget or -1 if no house can be bought. >>> highest_affordable_price(6, 50, [20, 30, 40, 50, 60, 70]) 50 >>> highest_affordable_price(5, 10, [20, 30, 40, 50, 60]) -1","solution":"def highest_affordable_price(n, B, prices): Finds the highest price of a house that can be bought without exceeding the budget. Parameters: n (int): Number of houses. B (int): Budget. prices (list[int]): Array of house prices. Returns: int: The maximum price within budget or -1 if no house can be bought. affordable_prices = [price for price in prices if price <= B] if len(affordable_prices) == 0: return -1 else: return max(affordable_prices) # Example usage: n = 6 B = 50 prices = [20, 30, 40, 50, 60, 70] print(highest_affordable_price(n, B, prices)) # Output: 50"},{"question":"def count_a_substrings(s: str) -> int: Returns the number of substrings that contain only the character 'a'. >>> count_a_substrings(\\"a\\") 1 >>> count_a_substrings(\\"b\\") 0 >>> count_a_substrings(\\"aaa\\") 6 >>> count_a_substrings(\\"aabbaa\\") 6 >>> count_a_substrings(\\"bbbb\\") 0 >>> count_a_substrings(\\"\\") 0 >>> count_a_substrings(\\"baaab\\") 6 >>> count_a_substrings(\\"ababab\\") 3 pass","solution":"def count_a_substrings(s): Returns the number of substrings that contain only the character 'a'. n = len(s) count = 0 seq_length = 0 for i in range(n): if s[i] == 'a': seq_length += 1 count += seq_length else: seq_length = 0 return count"},{"question":"def max_span(n, a): Returns the maximum span among all subarrays of the array a. Parameters: n : int - The number of elements in the array a : list of int - The elements of the array Returns: int - The maximum span among all subarrays of the array pass # Unit Tests def test_example(): assert max_span(5, [1, 3, 2, 5, 4]) == 4 def test_single_segment(): assert max_span(2, [10, 20]) == 10 def test_reverse_order(): assert max_span(4, [100, 50, 10, 1]) == 99 def test_largest_in_middle(): assert max_span(3, [1, 100, 1]) == 99 def test_smallest_largest_at_ends(): assert max_span(5, [1, 2, 3, 4, 100]) == 99","solution":"def max_span(n, a): Returns the maximum span among all subarrays of the array a. Parameters: n : int - The number of elements in the array a : list of int - The elements of the array Returns: int - The maximum span among all subarrays of the array max_value = max(a) min_value = min(a) return max_value - min_value"},{"question":"def distribute_items(k: int, n: int) -> List[int]: Distributes k items to n friends such that each friend gets at least one item and the difference between the maximum and minimum number of items each friend gets is at most one. >>> distribute_items(10, 4) [3, 3, 2, 2] >>> distribute_items(5, 2) [3, 2] >>> distribute_items(1, 2) -1","solution":"def distribute_items(k, n): Distributes k items to n friends such that each friend gets at least one item and the difference between the maximum and minimum number of items each friend gets is at most one. if n > k: return -1 # Each friend should get at least 1 item base = k // n remainder = k % n # Create the distribution list distribution = [base + 1] * remainder + [base] * (n - remainder) return distribution"},{"question":"def min_steps_to_convert(S: str, P: str) -> int: Determine the minimum number of steps required to convert string S into string P. The possible operations are: 1. Insert a character 2. Delete a character 3. Replace a character All operations count as 1 step. Example: >>> min_steps_to_convert(\\"kitten\\", \\"sitting\\") 3 >>> min_steps_to_convert(\\"flaw\\", \\"lawn\\") 2 >>> min_steps_to_convert(\\"abc\\", \\"abc\\") 0 >>> min_steps_to_convert(\\"abc\\", \\"xyz\\") 3 >>> min_steps_to_convert(\\"\\", \\"a\\") 1 >>> min_steps_to_convert(\\"a\\", \\"\\") 1 >>> min_steps_to_convert(\\"intention\\", \\"execution\\") 5 >>> min_steps_to_convert(\\"horse\\", \\"ros\\") 3","solution":"def min_steps_to_convert(S, P): Returns the minimum number of steps required to convert string S into string P. m = len(S) v = len(P) # Create a table to store results of subproblems dp = [[None] * (v + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(v + 1): # If first string is empty, only option is to insert all characters of second string if i == 0: dp[i][j] = j # If second string is empty, only option is to remove all characters of first string elif j == 0: dp[i][j] = i # If last characters are same, ignore last character and recur for remaining string elif S[i-1] == P[j-1]: dp[i][j] = dp[i-1][j-1] # If last characters are different, consider all possibilities and find minimum else: dp[i][j] = 1 + min(dp[i][j-1], # Insert dp[i-1][j], # Remove dp[i-1][j-1]) # Replace return dp[m][v]"},{"question":"def can_partition_into_equal_sums(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determines if it is possible to partition the sequence into two non-empty subsequences with equal sums. >>> can_partition_into_equal_sums(2, [(4, [1, 2, 3, 4]), (3, [-1, 1, 1])]) [\\"YES\\", \\"NO\\"] >>> can_partition_into_equal_sums(1, [(3, [1, 2, 5])]) [\\"NO\\"] >>> can_partition_into_equal_sums(1, [(4, [2, 2, 2, 2])]) [\\"YES\\"] >>> can_partition_into_equal_sums(1, [(2, [10**6, 10**6])]) [\\"YES\\"] >>> can_partition_into_equal_sums(1, [(4, [-1, -1, 1, 1])]) [\\"YES\\"] def partition_test_cases(t: int, raw_test_cases: List[Union[int, List[int]]]) -> List[Tuple[int, List[int]]]: Converts raw test cases into a structured format. >>> partition_test_cases(2, [4, [1, 2, 3, 4], 3, [-1, 1, 1]]) [(4, [1, 2, 3, 4]), (3, [-1, 1, 1])]","solution":"def can_partition_into_equal_sums(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] sequence = test_cases[i][1] total_sum = sum(sequence) if total_sum % 2 != 0: results.append(\\"NO\\") continue target_sum = total_sum // 2 dp = [False] * (target_sum + 1) dp[0] = True for num in sequence: for j in range(target_sum, num - 1, -1): dp[j] = dp[j] or dp[j - num] if dp[target_sum]: results.append(\\"YES\\") else: results.append(\\"NO\\") return results def partition_test_cases(t, raw_test_cases): test_cases = [] idx = 0 for _ in range(t): n = raw_test_cases[idx] sequence = raw_test_cases[idx + 1] test_cases.append((n, sequence)) idx += 2 return test_cases"},{"question":"def max_meetings(n: int, meetings: List[Tuple[int, int]]) -> int: Returns the maximum number of non-overlapping meetings that can be scheduled. :param n: Number of meeting requests :param meetings: List of tuples where each tuple is (start, end) :return: Maximum number of non-overlapping meetings >>> max_meetings(5, [(1, 3), (2, 4), (3, 5), (0, 6), (5, 7)]) == 3 >>> max_meetings(3, [(1, 2), (2, 3), (3, 4)]) == 3 >>> max_meetings(3, [(1, 5), (2, 6), (3, 7)]) == 1 >>> max_meetings(4, [(1, 2), (3, 4), (0, 6), (5, 7)]) == 3 >>> max_meetings(1, [(0, 1)]) == 1 >>> max_meetings(4, [(1, 3), (1, 3), (1, 3), (1, 3)]) == 1","solution":"def max_meetings(n, meetings): Returns the maximum number of non-overlapping meetings that can be scheduled. :param n: Number of meeting requests :param meetings: List of tuples where each tuple is (start, end) :return: Maximum number of non-overlapping meetings # Sort meetings by their end times meetings.sort(key=lambda x: x[1]) max_meetings_count = 0 last_end_time = -1 for start, end in meetings: if start >= last_end_time: max_meetings_count += 1 last_end_time = end return max_meetings_count # Example Input n = 5 meetings = [(1, 3), (2, 4), (3, 5), (0, 6), (5, 7)] # Example Output print(max_meetings(n, meetings)) # Output: 3"},{"question":"def group_anagrams(words: List[str]) -> List[List[str]]: Group all anagrams together from a list of strings. >>> group_anagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) == [['ate', 'eat', 'tea'], ['bat'], ['nat', 'tan']] >>> group_anagrams([\\"abc\\"]) == [['abc']] >>> group_anagrams([\\"abc\\", \\"def\\", \\"ghi\\"]) == [['abc'], ['def'], ['ghi']] >>> group_anagrams([\\"abc\\", \\"bca\\", \\"cab\\"]) == [['abc', 'bca', 'cab']] >>> group_anagrams([\\"listen\\", \\"silent\\", \\"enlist\\", \\"inlets\\", \\"google\\", \\"goolge\\", \\"abc\\", \\"cba\\"]) == [['abc', 'cba'], ['enlist', 'inlets', 'listen', 'silent'], ['google', 'goolge']]","solution":"def group_anagrams(words): from collections import defaultdict anagrams = defaultdict(list) for word in words: # Sort characters of the word to form the key sorted_word = ''.join(sorted(word)) anagrams[sorted_word].append(word) # Sort each group lexicographically and convert defaultdict to list of lists groups = [sorted(group) for group in anagrams.values()] # Sort the groups based on the first element in each group groups.sort(key=lambda x: x[0]) return groups"},{"question":"from typing import List def process_queries(queries: List[str]) -> List[int]: Processes a list of queries to add nodes to a binary tree and find the shortest path between nodes. Each query is of the form: - '1 x y' to add a new node y as a child of x. - '2 x y' to find the shortest path between nodes x and y. Example: >>> process_queries([\\"1 1 2\\", \\"1 1 3\\", \\"1 2 4\\", \\"2 4 3\\", \\"2 2 3\\", \\"1 3 5\\"]) [3, 2] >>> process_queries([\\"1 1 2\\", \\"1 1 3\\", \\"2 2 3\\"]) [2] >>> process_queries([\\"1 1 2\\", \\"1 1 3\\", \\"1 2 4\\", \\"1 4 5\\", \\"1 3 6\\", \\"2 4 6\\", \\"2 5 1\\", \\"2 5 6\\"]) [4, 3, 5]","solution":"from collections import defaultdict, deque class BinaryTree: def __init__(self): self.tree = defaultdict(list) self.depth = {1: 0} self.parent = {1: None} def add_node(self, x, y): self.tree[x].append(y) self.parent[y] = x self.depth[y] = self.depth[x] + 1 def lca(self, x, y): while x != y: if self.depth[x] > self.depth[y]: x = self.parent[x] else: y = self.parent[y] return x def shortest_path_length(self, x, y): lca = self.lca(x, y) return self.depth[x] + self.depth[y] - 2 * self.depth[lca] def process_queries(queries): bt = BinaryTree() result = [] for query in queries: q = query.split() if q[0] == '1': bt.add_node(int(q[1]), int(q[2])) elif q[0] == '2': dist = bt.shortest_path_length(int(q[1]), int(q[2])) result.append(dist) return result # Example usage: # queries = [\\"1 1 2\\", \\"1 1 3\\", \\"1 2 4\\", \\"2 4 3\\", \\"2 2 3\\", \\"1 3 5\\"] # print(process_queries(queries)) # Output: [3, 2]"},{"question":"def arrange_fruits(n: int, quantities: List[int]) -> Union[str, int]: Arrange fruits so that no two consecutive fruits are the same. Args: n: int - number of different types of fruits quantities: list of ints - quantity needed of each type of fruit Returns: str - an arrangement of fruits that meets the condition or -1 if not possible >>> arrange_fruits(3, [2, 1, 1]) in [\\"abac\\", \\"acab\\", \\"baca\\", \\"caba\\"] >>> arrange_fruits(1, [3]) == -1 pass # Unit Tests def test_possible_arrangement_case_1(): assert arrange_fruits(3, [2, 1, 1]) in [\\"abac\\", \\"acab\\", \\"baca\\", \\"caba\\"] def test_impossible_arrangement_case_2(): assert arrange_fruits(1, [3]) == -1 def test_possible_large_case(): assert arrange_fruits(3, [4, 4, 4]).count('a') == 4 assert arrange_fruits(3, [4, 4, 4]).count('b') == 4 assert arrange_fruits(3, [4, 4, 4]).count('c') == 4 def test_varied_length_and_distribution(): assert arrange_fruits(4, [5, 2, 2, 1]).count('a') == 5 assert arrange_fruits(4, [5, 2, 2, 1]).count('b') == 2 assert arrange_fruits(4, [5, 2, 2, 1]).count('c') == 2 assert arrange_fruits(4, [5, 2, 2, 1]).count('d') == 1 def test_single_type_fruit(): assert arrange_fruits(1, [1]) == \\"a\\" assert arrange_fruits(1, [100]) == -1 def test_pair_fruits(): assert arrange_fruits(2, [50, 50]) == (\\"ab\\" * 50)[:100] if __name__ == \\"__main__\\": test_possible_arrangement_case_1() test_impossible_arrangement_case_2() test_possible_large_case() test_varied_length_and_distribution() test_single_type_fruit() test_pair_fruits()","solution":"def arrange_fruits(n, quantities): Arrange fruits so that no two consecutive fruits are the same. Args: n: int - number of different types of fruits quantities: list of ints - quantity needed of each type of fruit Returns: str - an arrangement of fruits that meets the condition or -1 if not possible from collections import Counter import heapq # tuple (-count, fruit) max_heap = [(-count, chr(97 + i)) for i, count in enumerate(quantities)] heapq.heapify(max_heap) prev_fruit = None result = [] while max_heap: count, fruit = heapq.heappop(max_heap) if not result or result[-1] != fruit: result.append(fruit) if count + 1 != 0: heapq.heappush(max_heap, (count + 1, fruit)) prev_fruit = fruit else: if not max_heap: return -1 next_count, next_fruit = heapq.heappop(max_heap) result.append(next_fruit) if next_count + 1 != 0: heapq.heappush(max_heap, (next_count + 1, next_fruit)) heapq.heappush(max_heap, (count, fruit)) return ''.join(result)"},{"question":"MOD = 10**9 + 7 def number_of_good_strings(n: int) -> int: Returns the number of good strings of length n modulo 10^9 + 7. >>> number_of_good_strings(1) 3 >>> number_of_good_strings(2) 9 >>> number_of_good_strings(3) 21 >>> number_of_good_strings(4) 51 >>> number_of_good_strings(5) 123","solution":"MOD = 10**9 + 7 def number_of_good_strings(n): Returns the number of good strings of length n modulo 10^9 + 7. if n == 1: return 3 # 'a', 'b', 'c' elif n == 2: return 9 # 'aa', 'ab', 'ac', 'ba', 'bb', 'bc', 'ca', 'cb', 'cc' dp = [0] * (n + 1) dp[1] = 3 # For length 1 dp[2] = 9 # For length 2 for i in range(3, n + 1): dp[i] = (2 * dp[i-1] + dp[i-2]) % MOD return dp[n]"},{"question":"def min_changes_to_uniform(pattern: str) -> int: Calculate the minimum number of characters to change to make the pattern consist of all 'A's or all 'B's. >>> min_changes_to_uniform(\\"AABBA\\") 2 >>> min_changes_to_uniform(\\"AAA\\") 0 >>> min_changes_to_uniform(\\"BBAAAB\\") 3 >>> min_changes_to_uniform(\\"ABABAB\\") 3 >>> min_changes_to_uniform(\\"BBBBBB\\") 0 >>> min_changes_to_uniform(\\"AAAAAA\\") 0 def batch_min_changes(test_cases: List[str]) -> List[int]: For a list of patterns, calculate the minimum changes for each pattern. >>> batch_min_changes([\\"AABBA\\", \\"AAA\\", \\"BBAAAB\\"]) [2, 0, 3] >>> batch_min_changes([\\"ABABAB\\", \\"BBBBBB\\", \\"AAAAAA\\"]) [3, 0, 0]","solution":"def min_changes_to_uniform(pattern): Calculate the minimum number of characters to change to make the pattern consist of all 'A's or all 'B's. count_A = pattern.count('A') count_B = len(pattern) - count_A return min(count_A, count_B) def batch_min_changes(test_cases): For a list of patterns, calculate the minimum changes for each pattern. results = [] for pattern in test_cases: results.append(min_changes_to_uniform(pattern)) return results"},{"question":"def replace_tabs_with_spaces(lines: List[str], s: int) -> List[str]: Replaces leading tabs in each line with the specified number of spaces. :param lines: List of strings representing lines in the text file. :param s: Integer, number of spaces to replace each tab with. :return: List of strings with leading tabs replaced by spaces. >>> replace_tabs_with_spaces([\\"tThis is a tab.\\"], 2) [' This is a tab.'] >>> replace_tabs_with_spaces([\\"tHello\\", \\"ttWorld\\", \\"Thistis a test file.\\"], 4) [' Hello', ' World', 'This is a test file.'] >>> replace_tabs_with_spaces([\\"tLine with tab.\\", \\"ttLine with two tabs.\\"], 3) [' Line with tab.', ' Line with two tabs.'] >>> replace_tabs_with_spaces([\\"No tabs here.\\", \\"Still no tabs.\\"], 4) ['No tabs here.', 'Still no tabs.'] >>> replace_tabs_with_spaces([\\"t\\", \\"tt\\", \\"ttt\\"], 2) [' ', ' ', ' '] >>> replace_tabs_with_spaces([\\"tMixedntcontent.nTabstandttext.\\"], 1) [' Mixedn content.nTabs and text.']","solution":"def replace_tabs_with_spaces(lines, s): Replaces leading tabs in each line with the specified number of spaces. :param lines: List of strings representing lines in the text file. :param s: Integer, number of spaces to replace each tab with. :return: List of strings with leading tabs replaced by spaces. return [line.replace('t', ' ' * s, line.count('t')) for line in lines]"},{"question":"def chisels_solution(input_str: str) -> str: Determine if it's possible to create exactly k slots on the block using the given chisels such that the sum of the widths of these k slots is equal to a given target value, T. >>> chisels_solution(\\"5 3 100n30 20 25 50 70\\") \\"YESn1 2 3\\" >>> chisels_solution(\\"4 2 50n15 25 30 10\\") \\"NO\\" >>> chisels_solution(\\"1 1 30n30\\") \\"YESn1\\" >>> chisels_solution(\\"4 2 50n10 40 30 20\\") \\"YESn1 2\\" >>> chisels_solution(\\"3 3 60n15 20 25\\") \\"YESn1 2 3\\" pass","solution":"from itertools import combinations def find_slots(n, k, T, chisels): Determine if it's possible to select k chisels such that the sum of their widths equals T. :param n: Number of chisels :param k: Required number of slots :param T: Target width :param chisels: List of chisels' widths :return: Tuple containing \\"YES\\" or \\"NO\\" and the indices of selected chisels if possible for comb in combinations(range(n), k): if sum(chisels[i] for i in comb) == T: return \\"YES\\", [i + 1 for i in comb] return \\"NO\\", def chisels_solution(input_str): lines = input_str.strip().split('n') n, k, T = map(int, lines[0].split()) chisels = list(map(int, lines[1].split())) result = find_slots(n, k, T, chisels) if result[0] == \\"YES\\": return result[0] + \\"n\\" + \\" \\".join(map(str, result[1])) else: return result[0]"},{"question":"def max_difficulty_score(n: int, L: int, difficulties: List[int]) -> int: Given the number of available dives, the maximum allowed difficulty sum, and the difficulty scores of the available dives, return the maximum total difficulty score that can be achieved without exceeding the limit L. >>> max_difficulty_score(5, 10, [2, 3, 4, 5, 6]) 10 >>> max_difficulty_score(4, 15, [2, 4, 5, 6]) 15 >>> max_difficulty_score(3, 7, [1, 3, 7]) 7 >>> max_difficulty_score(3, 2, [3, 4, 5]) 0 >>> max_difficulty_score(4, 10, [7, 2, 3, 1]) 10 >>> max_difficulty_score(1000, 5000, [i for i in range(1, 1001)]) 5000","solution":"def max_difficulty_score(n, L, difficulties): dp = [0] * (L + 1) for difficulty in difficulties: for j in range(L, difficulty - 1, -1): dp[j] = max(dp[j], dp[j - difficulty] + difficulty) return dp[L]"},{"question":"def min_energy_to_escape(N: int, M: int, E: int, corridors: List[Tuple[int, int, int]]) -> Union[int, str]: Calculate the minimal energy cost to escape the dungeon from room 1 to room N. :param N: Number of rooms :param M: Number of corridors :param E: Initial amount of magic energy :param corridors: List of tuples where each tuple represents a corridor in the form (u, v, w) with u as the start room, v as the end room, and w as the energy cost. :return: Minimal energy cost to reach room N, or \\"NO ESCAPE\\" if not possible. pass # Unit tests import pytest def test_example_1(): N = 5 M = 6 E = 20 corridors = [ (1, 2, 5), (2, 3, 7), (3, 5, 3), (1, 4, 2), (4, 5, 10), (2, 5, 8) ] assert min_energy_to_escape(N, M, E, corridors) == 12 def test_no_escape(): N = 4 M = 2 E = 10 corridors = [ (1, 2, 5), (2, 3, 4) ] assert min_energy_to_escape(N, M, E, corridors) == \\"NO ESCAPE\\" def test_direct_path(): N = 3 M = 2 E = 15 corridors = [ (1, 2, 5), (2, 3, 7) ] assert min_energy_to_escape(N, M, E, corridors) == 12 def test_multiple_paths(): N = 5 M = 7 E = 20 corridors = [ (1, 2, 5), (2, 3, 7), (3, 5, 3), (1, 4, 2), (4, 5, 10), (2, 5, 8), (1, 5, 20) ] assert min_energy_to_escape(N, M, E, corridors) == 12 def test_no_energy_needed(): N = 3 M = 3 E = 10 corridors = [ (1, 2, 0), (2, 3, 0), (1, 3, 0) ] assert min_energy_to_escape(N, M, E, corridors) == 0","solution":"import heapq def min_energy_to_escape(N, M, E, corridors): Calculate the minimal energy cost to escape the dungeon from room 1 to room N. :param N: Number of rooms :param M: Number of corridors :param E: Initial amount of magic energy :param corridors: List of tuples where each tuple represents a corridor in the form (u, v, w) with u as the start room, v as the end room, and w as the energy cost. :return: Minimal energy cost to reach room N, or \\"NO ESCAPE\\" if not possible. # Create the graph as an adjacency list graph = [[] for _ in range(N + 1)] for u, v, w in corridors: graph[u].append((v, w)) # Priority queue to implement Dijkstra's algorithm pq = [(0, 1)] # (current_energy_cost, current_room) min_energy = [float('inf')] * (N + 1) min_energy[1] = 0 while pq: current_cost, current_room = heapq.heappop(pq) if current_room == N: return current_cost for neighbor, cost in graph[current_room]: new_cost = current_cost + cost if new_cost < min_energy[neighbor]: min_energy[neighbor] = new_cost heapq.heappush(pq, (new_cost, neighbor)) return \\"NO ESCAPE\\""},{"question":"def move_zeros_to_end(arr: List[int]) -> List[int]: Moves all zeros in the given list to the end while preserving the order of non-zero elements. :param arr: List[int] - The input list of integers (can be negative, positive, or zero) :return: List[int] - The list after all zeros are moved to the end ... from solution import move_zeros_to_end def test_move_zeros_all_zeros(): assert move_zeros_to_end([0, 0, 0]) == [0, 0, 0] def test_move_zeros_no_zeros(): assert move_zeros_to_end([1, 2, 3]) == [1, 2, 3] def test_move_zeros_mixed(): assert move_zeros_to_end([4, 0, 5, 0, 3, 0, 7, 8, 9, 0]) == [4, 5, 3, 7, 8, 9, 0, 0, 0, 0] assert move_zeros_to_end([1, 0, 2, 0, 3]) == [1, 2, 3, 0, 0] def test_move_zeros_single_element(): assert move_zeros_to_end([0]) == [0] assert move_zeros_to_end([5]) == [5] def test_move_zeros_begin_and_end(): assert move_zeros_to_end([0, 1, 2, 3, 0]) == [1, 2, 3, 0, 0] def test_move_zeros_large_array(): arr = [1, 0] * 10**5 result = [1] * 10**5 + [0] * 10**5 assert move_zeros_to_end(arr) == result","solution":"def move_zeros_to_end(arr): Moves all zeros in the given list to the end while preserving the order of non-zero elements. :param arr: List[int] - The input list of integers (can be negative, positive, or zero) :return: List[int] - The list after all zeros are moved to the end n = len(arr) insert_pos = 0 # Traverse through the list and move non-zero elements to the front for i in range(n): if arr[i] != 0: arr[insert_pos] = arr[i] insert_pos += 1 # Fill the remaining positions with zeros for i in range(insert_pos, n): arr[i] = 0 return arr # Example usage: # arr = [4, 0, 5, 0, 3, 0, 7, 8, 9, 0] # print(move_zeros_to_end(arr)) # Output should be: [4, 5, 3, 7, 8, 9, 0, 0, 0, 0]"},{"question":"def max_altitude_difference(n: int, altitudes: List[int]) -> int: Determine the maximum difference in altitude between any two hills in the sequence, regardless of their order. Parameters: - n (int): the number of hills (2  n  1000) - altitudes (List[int]): the altitude of each hill (1  hi  10000) Returns: - int: the maximum altitude difference between any two hills Example: >>> max_altitude_difference(5, [1, 5, 4, 8, 7]) 7 >>> max_altitude_difference(2, [1, 10000]) 9999 >>> max_altitude_difference(3, [10, 10, 10]) 0 >>> max_altitude_difference(5, [1, 2, 3, 4, 5]) 4 >>> max_altitude_difference(5, [8, 7, 5, 1, 4]) 7","solution":"def max_altitude_difference(n, altitudes): Returns the maximum difference in altitude between any two hills in the sequence. Parameters: n: int - the number of hills altitudes: list of int - the altitude of each hill Returns: int - the maximum altitude difference highest = max(altitudes) lowest = min(altitudes) return highest - lowest"},{"question":"def min_operations_to_convert(S: str, T: str) -> int: Determine the minimum number of operations required to convert string S into string T. Operations allowed: insert a character, delete a character, replace a character. >>> min_operations_to_convert(\\"abcdef\\", \\"azced\\") 3 >>> min_operations_to_convert(\\"\\", \\"\\") 0 >>> min_operations_to_convert(\\"\\", \\"insert\\") 6 >>> min_operations_to_convert(\\"deleteall\\", \\"\\") 9 >>> min_operations_to_convert(\\"aaaa\\", \\"bbbb\\") 4 >>> min_operations_to_convert(\\"intention\\", \\"execution\\") 5","solution":"def min_operations_to_convert(S, T): Determine the minimum number of operations required to convert string S into string T. Operations allowed: insert a character, delete a character, replace a character. n = len(S) m = len(T) dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)] for i in range(n + 1): for j in range(m + 1): if i == 0: dp[i][j] = j elif j == 0: dp[i][j] = i elif S[i - 1] == T[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i][j - 1], # Insert dp[i - 1][j], # Delete dp[i - 1][j - 1]) # Replace return dp[n][m]"},{"question":"from typing import List def shortest_substring_with_k_distinct(k: int, s: str) -> int: Returns the length of the shortest substring that can be rearranged to contain exactly k distinct characters. If no such substring exists, returns -1. >>> shortest_substring_with_k_distinct(3, \\"abcabcabc\\") 3 >>> shortest_substring_with_k_distinct(2, \\"aaabbcc\\") 2 >>> shortest_substring_with_k_distinct(5, \\"abcd\\") -1 pass def test_shortest_substring_with_k_distinct_case1(): assert shortest_substring_with_k_distinct(3, \\"abcabcabc\\") == 3 def test_shortest_substring_with_k_distinct_case2(): assert shortest_substring_with_k_distinct(2, \\"aaabbcc\\") == 2 def test_shortest_substring_with_k_distinct_case3(): assert shortest_substring_with_k_distinct(5, \\"abcd\\") == -1 def test_shortest_substring_with_k_distinct_case4(): assert shortest_substring_with_k_distinct(1, \\"aaaa\\") == 1 def test_shortest_substring_with_k_distinct_case5(): assert shortest_substring_with_k_distinct(2, \\"abbccc\\") == 2 def test_shortest_substring_with_k_distinct_case6(): assert shortest_substring_with_k_distinct(4, \\"abcde\\") == 4 def test_shortest_substring_with_k_distinct_case7(): assert shortest_substring_with_k_distinct(3, \\"abcdeabc\\") == 3 def test_shortest_substring_with_k_distinct_case8(): assert shortest_substring_with_k_distinct(3, \\"aabbcc\\") == 4 # smallest substring with 3 distinct characters is \\"abbc\\" def test_shortest_substring_with_k_distinct_case9(): assert shortest_substring_with_k_distinct(3, \\"xyzzyx\\") == 3 def test_shortest_substring_with_k_distinct_case10(): assert shortest_substring_with_k_distinct(2, \\"pqrstt\\") == 2","solution":"def shortest_substring_with_k_distinct(k, s): Returns the length of the shortest substring that can be rearranged to contain exactly k distinct characters. If no such substring exists, returns -1. from collections import defaultdict n = len(s) if len(set(s)) < k: return -1 min_length = n + 1 left = 0 char_count = defaultdict(int) for right in range(n): char_count[s[right]] += 1 while len(char_count) == k: min_length = min(min_length, right - left + 1) char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 return min_length if min_length <= n else -1"},{"question":"def is_valid_itinerary(n, m, routes, k, itinerary): Determine the validity of a train itinerary based on a series of stations and rules about which stations can be visited directly from a given station. Args: n : int : number of stations m : int : number of direct routes routes : list of tuples : each tuple (u, v) represents a direct route from station u to station v k : int : length of the itinerary itinerary : list of int : sequence of stations in the itinerary Returns: str : \\"YES\\" if the itinerary is valid, otherwise \\"NO\\" >>> is_valid_itinerary(6, 7, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (1, 5), (2, 6)], 5, [1, 2, 3, 4, 5]) \\"YES\\" >>> is_valid_itinerary(6, 7, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (1, 5), (2, 6)], 5, [1, 2, 4, 5, 6]) \\"NO\\" >>> is_valid_itinerary(3, 2, [(1, 2), (2, 3)], 3, [1, 2, 1]) \\"NO\\" >>> is_valid_itinerary(5, 4, [(1, 2), (2, 3), (3, 4), (1, 3)], 4, [1, 3, 4, 3]) \\"NO\\" >>> is_valid_itinerary(6, 6, [(1, 2), (2, 3), (3, 1), (1, 4), (4, 5), (6, 4)], 6, [1, 2, 3, 1, 4, 5]) \\"YES\\"","solution":"def is_valid_itinerary(n, m, routes, k, itinerary): # Create an adjacency list for the routes adj_list = {i: set() for i in range(1, n + 1)} for u, v in routes: adj_list[u].add(v) # Verify if the itinerary is valid for i in range(k - 1): if itinerary[i + 1] not in adj_list[itinerary[i]]: return \\"NO\\" return \\"YES\\""},{"question":"def max_non_intersecting_pairs(n: int, p: List[int], c: List[int]) -> int: Find the maximum number of pairs of nails such that no two pairs intersect on the board. Parameters: n (int): number of nails p (List[int]): positions of the nails c (List[int]): colors of the nails Returns: int: maximum number of non-intersecting pairs of nails Examples: >>> max_non_intersecting_pairs(6, [1, 3, 5, 2, 4, 6], [1, 2, 1, 2, 1, 2]) 2 >>> max_non_intersecting_pairs(4, [1, 2, 3, 4], [2, 2, 2, 2]) 2 from solution import max_non_intersecting_pairs def test_example_1(): assert max_non_intersecting_pairs(6, [1, 3, 5, 2, 4, 6], [1, 2, 1, 2, 1, 2]) == 2 def test_example_2(): assert max_non_intersecting_pairs(4, [1, 2, 3, 4], [2, 2, 2, 2]) == 2 def test_all_distinct_colors(): assert max_non_intersecting_pairs(5, [1, 2, 3, 4, 5], [1, 2, 3, 4, 5]) == 0 def test_all_same_color(): assert max_non_intersecting_pairs(6, [1, 2, 3, 4, 5, 6], [1, 1, 1, 1, 1, 1]) == 3 def test_large_positions(): assert max_non_intersecting_pairs(4, [1000000000, 999999999, 1000000001, 999999998], [1, 1, 1, 1]) == 2 def test_only_two_nails(): assert max_non_intersecting_pairs(2, [1, 10], [1, 1]) == 1 def test_no_pairs(): assert max_non_intersecting_pairs(2, [1, 2], [1, 2]) == 0","solution":"def max_non_intersecting_pairs(n, p, c): from collections import defaultdict import heapq color_positions = defaultdict(list) for i in range(n): color_positions[c[i]].append(p[i]) max_pairs = 0 for positions in color_positions.values(): positions.sort() intervals = [(-float('inf'), float('inf'))] for pos in positions: new_intervals = [] for start, end in intervals: if start <= pos <= end: new_intervals.append((start, pos)) new_intervals.append((pos, end)) intervals = new_intervals max_pairs += len(positions) // 2 return max_pairs"},{"question":"from typing import List def can_form_target(n: int, sticks: List[int], target: int) -> bool: Determine if it is possible to cut, combine or use the given sticks to form the exact target length. >>> can_form_target(5, [4, 3, 3, 3, 6], 9) True >>> can_form_target(4, [2, 2, 2, 2], 7) False","solution":"from itertools import combinations def can_form_target(n, sticks, target): all_stick_lengths = set(sticks) for i in range(1, n+1): for comb in combinations(sticks, i): if sum(comb) == target: return True all_stick_lengths.add(sum(comb)) if target in all_stick_lengths: return True return False"},{"question":"from typing import List def longest_beautiful_view(heights: List[int]) -> int: Determine the length of the longest beautiful view in the given skyline. A beautiful view is defined as a contiguous subarray of the skyline such that the heights of the buildings in the subarray first strictly increase to a peak and then strictly decrease. Args: heights (List[int]): An array representing the heights of the buildings in the skyline. Returns: int: The length of the longest beautiful view. Examples: >>> longest_beautiful_view([1, 2, 3, 4, 5, 3, 1]) 7 >>> longest_beautiful_view([1, 1, 1, 1]) 0","solution":"def longest_beautiful_view(heights): n = len(heights) if n < 3: return 0 max_length = 0 i = 1 while i < n: while i < n and heights[i] == heights[i - 1]: i += 1 increasing = 0 while i < n and heights[i] > heights[i - 1]: increasing += 1 i += 1 decreasing = 0 while i < n and heights[i] < heights[i - 1]: decreasing += 1 i += 1 if increasing > 0 and decreasing > 0: max_length = max(max_length, increasing + decreasing + 1) return max_length"},{"question":"def minimum_difference_of_subsets(t: int, cases: List[Tuple[int, List[int]]]) -> List[int]: Partition the array into two subsets such that the absolute difference between the sums of the subsets is minimized, and return the list of minimum differences for each test case. >>> minimum_difference_of_subsets(2, [(4, [1, 6, 11, 5]), (3, [1, 2, 3])]) [1, 0] >>> minimum_difference_of_subsets(1, [(5, [1, 2, 3, 4, 5])]) [1]","solution":"def minimum_difference_of_subsets(t, cases): def find_minimum_difference(arr): total_sum = sum(arr) n = len(arr) dp = [False] * (total_sum // 2 + 1) dp[0] = True for num in arr: for i in range(total_sum // 2, num - 1, -1): dp[i] = dp[i] or dp[i - num] for i in range(total_sum // 2, -1, -1): if dp[i]: return total_sum - 2 * i results = [] for n, arr in cases: results.append(find_minimum_difference(arr)) return results"},{"question":"def max_coins(n: int, m: int, grid: List[List[int]]) -> int: Calculate the maximum number of coins Mario can collect while moving from the top-left to the bottom-right corner of the grid. >>> max_coins(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 29 >>> max_coins(1, 4, [[1, 2, 3, 4]]) 10 >>> max_coins(4, 1, [[1], [2], [3], [4]]) 10 >>> max_coins(2, 2, [[100, 100], [100, 100]]) 300 >>> max_coins(2, 2, [[0, 0], [0, 0]]) 0","solution":"def max_coins(n, m, grid): This function calculates the maximum number of coins Mario can collect. Parameters: n (int): number of rows in the grid m (int): number of columns in the grid grid (list of list of int): the grid with coin values Returns: int: maximum number of coins Mario can collect # Create a 2D dp array where dp[i][j] represents the max coins that can be collected to reach cell (i, j) dp = [[0] * m for _ in range(n)] # Initialize the dp array with the coins from the grid dp[0][0] = grid[0][0] # Fill the dp array for i in range(n): for j in range(m): if i > 0: dp[i][j] = max(dp[i][j], dp[i-1][j] + grid[i][j]) if j > 0: dp[i][j] = max(dp[i][j], dp[i][j-1] + grid[i][j]) return dp[n-1][m-1] # Example usage: n, m = 3, 3 grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] print(max_coins(n, m, grid)) # Output: 29"},{"question":"def count_paths(n: int, m: int, grid: List[List[str]]) -> int: Determine the number of different ways to travel from the top-left corner of the grid to the bottom-right corner, avoiding blocked cells. >>> count_paths(3, 3, [ ... ['0', '0', '0'], ... ['0', '1', '0'], ... ['0', '0', '0'] ... ]) == 2 >>> count_paths(2, 2, [ ... ['0', '1'], ... ['0', '0'] ... ]) == 1","solution":"def count_paths(n, m, grid): MOD = 1000000007 if grid[0][0] == '1' or grid[n-1][m-1] == '1': return 0 # Create a 2D dp array initialized to 0 dp = [[0 for _ in range(m)] for _ in range(n)] dp[0][0] = 1 # Starting point for i in range(n): for j in range(m): if grid[i][j] == '1': dp[i][j] = 0 else: if i > 0: dp[i][j] = (dp[i][j] + dp[i-1][j]) % MOD if j > 0: dp[i][j] = (dp[i][j] + dp[i][j-1]) % MOD return dp[-1][-1] # Example usage: def main(): input_data = 3 3 0 0 0 0 1 0 0 0 0 lines = input_data.split(\\"n\\") n, m = map(int, lines[0].split()) grid = [line.split() for line in lines[1:]] print(count_paths(n, m, grid))"},{"question":"def are_arrays_similar(n: int, A: List[int], B: List[int]) -> str: Check if arrays A and B can be considered similar. Arrays are considered similar if one can be transformed into the other by performing a series of operations where you can choose any element from array A and add it to any other element of the same array or choose any element from B and add it to any other element of the same array. >>> are_arrays_similar(3, [1, 2, 3], [1, 2, 3]) \\"YES\\" >>> are_arrays_similar(4, [4, 4, 4, 4], [4, 4, 4, 4]) \\"YES\\" >>> are_arrays_similar(3, [3, 2, 1], [1, 2, 3]) \\"YES\\" >>> are_arrays_similar(3, [1, 2, 3], [4, 5, 6]) \\"NO\\"","solution":"def are_arrays_similar(n, A, B): Returns \\"YES\\" if arrays A and B can be transformed into each other, otherwise \\"NO\\". sum_A = sum(A) sum_B = sum(B) if sum_A == sum_B: return \\"YES\\" else: return \\"NO\\""},{"question":"def shortest_subsequence_length(n: int, k: int, sequence: List[int]) -> int: Returns the length of the shortest contiguous subsequence whose sum is greater than or equal to k. If no such subsequence exists, returns -1. >>> shortest_subsequence_length(6, 15, [1, 2, 3, 4, 5, 6]) == 3 >>> shortest_subsequence_length(3, 10, [1, 2, 3]) == -1 >>> shortest_subsequence_length(5, 6, [1, 2, 6, 4, 5]) == 1 >>> shortest_subsequence_length(4, 3, [1, 4, 2, 5]) == 1 >>> shortest_subsequence_length(3, 6, [2, 2, 2]) == 3 >>> shortest_subsequence_length(8, 15, [5, 1, 3, 5, 10, 7, 4, 9]) == 2 >>> shortest_subsequence_length(5, 10**9, [10**6, 10**6, 10**6, 10**6, 10**6]) == -1 >>> shortest_subsequence_length(10**5, 10**5, [1] * 10**5) == 100000","solution":"def shortest_subsequence_length(n, k, sequence): Returns the length of the shortest contiguous subsequence whose sum is greater than or equal to k. If no such subsequence exists, returns -1. min_length = float('inf') current_sum = 0 start = 0 for end in range(n): current_sum += sequence[end] while current_sum >= k: min_length = min(min_length, end - start + 1) current_sum -= sequence[start] start += 1 return min_length if min_length != float('inf') else -1"},{"question":"def final_position(t: int, test_cases: List[Tuple[int, str]]) -> List[str]: Determine the robot's final position after executing a given sequence of moves. Args: t : int : number of test cases test_cases : List[Tuple[int, str]] : list of test cases where each test case is a tuple containing an int representing the battery life and a string representing the moves Returns: List[str] : list of strings with the final x and y coordinates of the robot for each test case Example: >>> final_position(3, [(5, 'LLUDR'), (3, 'RRUUDD'), (0, 'UDLR')]) ['-1 0', '2 1', '0 0'] >>> final_position(2, [(4, 'LRUD'), (2, 'UDUD')]) ['0 0', '0 0'] from solution import final_position def test_example(): t = 3 test_cases = [(5, 'LLUDR'), (3, 'RRUUDD'), (0, 'UDLR')] expected = ['-1 0', '2 1', '0 0'] assert final_position(t, test_cases) == expected def test_all_directions(): t = 2 test_cases = [(4, 'LRUD'), (2, 'UDUD')] expected = ['0 0', '0 0'] assert final_position(t, test_cases) == expected def test_no_moves(): t = 1 test_cases = [(0, 'LRUD')] expected = ['0 0'] assert final_position(t, test_cases) == expected def test_exceeding_battery(): t = 1 test_cases = [(2, 'UUDDLR')] expected = ['0 2'] assert final_position(t, test_cases) == expected def test_right_and_up(): t = 1 test_cases = [(3, 'RRR')] expected = ['3 0'] assert final_position(t, test_cases) == expected def test_left_and_down(): t = 1 test_cases = [(3, 'LLL')] expected = ['-3 0'] assert final_position(t, test_cases) == expected","solution":"def final_position(t, test_cases): results = [] for i in range(t): m = test_cases[i][0] moves = test_cases[i][1] x, y = 0, 0 effective_moves = moves[:m] for move in effective_moves: if move == 'L': x -= 1 elif move == 'R': x += 1 elif move == 'U': y += 1 elif move == 'D': y -= 1 results.append(f\\"{x} {y}\\") return results"},{"question":"def is_permutation(s1: str, s2: str) -> str: Determine if s2 is a permutation of s1. Returns 'YES' if s2 is a permutation of s1, otherwise 'NO'. >>> is_permutation(\\"listen\\", \\"silent\\") 'YES' >>> is_permutation(\\"apple\\", \\"papel\\") 'YES' >>> is_permutation(\\"hello\\", \\"holla\\") 'NO'","solution":"def is_permutation(s1, s2): Returns 'YES' if s2 is a permutation of s1, otherwise 'NO'. if sorted(s1) == sorted(s2): return \\"YES\\" else: return \\"NO\\""},{"question":"from typing import List, Tuple def detect_negative_cycle(t: int, test_cases: List[Tuple[Tuple[int, int], List[Tuple[int, int, int]]]]) -> List[str]: Determine if there exists a negative cycle in the provided graph. Args: t (int): Number of test cases. test_cases (List[Tuple[Tuple[int, int], List[Tuple[int, int, int]]]]): A list of test cases. Each test case is represented by a tuple where the first element is a tuple of two integers (n, m) and the second element is a list of m tuples each containing three integers (u, v, w). Returns: List[str]: A list containing \\"YES\\" if there is a negative cycle, otherwise \\"NO\\". Example: >>> detect_negative_cycle(2, [((3, 3), [(1, 2, 1), (2, 3, -1), (3, 1, -1)]), ((4, 4), [(1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 1, 1)])]) ['YES', 'NO'] pass","solution":"def detect_negative_cycle(t, test_cases): def bellman_ford(n, edges): dist = [float('inf')] * (n + 1) dist[1] = 0 for _ in range(n - 1): for u, v, w in edges: if dist[u] != float('inf') and dist[u] + w < dist[v]: dist[v] = dist[u] + w for u, v, w in edges: if dist[u] != float('inf') and dist[u] + w < dist[v]: return True return False results = [] for case in test_cases: n, m = case[0] edges = case[1] if bellman_ford(n, edges): results.append(\\"YES\\") else: results.append(\\"NO\\") return results # Here's an example of using the function # t = 2 # test_cases = [ # ((3, 3), [(1, 2, 1), (2, 3, -1), (3, 1, -1)]), # ((4, 4), [(1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 1, 1)]) # ] # print(detect_negative_cycle(t, test_cases))"},{"question":"def min_weight_difference(n: int, weights: List[int]) -> int: Returns the minimum possible difference between the total weights of the two piles. :param n: Integer representing the number of stones. :param weights: List of integers representing the weights of the stones. :return: Integer representing the minimum possible difference between the weights of the two piles. >>> min_weight_difference(5, [1, 2, 3, 4, 5]) 1 >>> min_weight_difference(4, [3, 3, 3, 3]) 0 >>> min_weight_difference(2, [1, 99]) 98 >>> min_weight_difference(1, [50]) 50 >>> min_weight_difference(6, [2, 3, 7, 8, 10, 1]) 1 >>> min_weight_difference(0, []) 0","solution":"def min_weight_difference(n, weights): Returns the minimum possible difference between the total weights of the two piles. total_weight = sum(weights) dp = [0] * (total_weight // 2 + 1) for weight in weights: for j in range(total_weight // 2, weight - 1, -1): dp[j] = max(dp[j], dp[j - weight] + weight) return abs(total_weight - 2 * dp[total_weight // 2])"},{"question":"from typing import List def most_frequent_books(n: int, k: int, book_ids: List[int]) -> List[int]: Returns the k most frequently borrowed books, ordered first by frequency and then by book ID in ascending order. Args: n (int): The number of books borrowed. k (int): The number of books to find. book_ids (List[int]): The list of book IDs borrowed. Returns: List[int]: The list of k most frequently borrowed book IDs. Examples: >>> most_frequent_books(9, 3, [1, 2, 1, 3, 1, 2, 2, 3, 4]) [1, 2, 3] >>> most_frequent_books(1, 1, [1000000000]) [1000000000] # Implementation goes here","solution":"from collections import Counter def most_frequent_books(n, k, book_ids): Returns the k most frequently borrowed books, ordered first by frequency and then by book ID in ascending order. # Count the frequency of each book ID count = Counter(book_ids) # Sort by frequency first (in descending order) and then by book ID (in ascending order) sorted_books = sorted(count.items(), key=lambda x: (-x[1], x[0])) # Extract the top k book IDs return [book_id for book_id, _ in sorted_books[:k]]"},{"question":"import heapq from typing import List, Tuple, Union def shortest_path(n: int, m: int, edges: List[Tuple[int, int, int]]) -> Union[int, str]: Calculates the shortest path from lake 1 to lake n using Dijkstra's algorithm. If there is no path, returns \\"NO PATH\\". >>> shortest_path(5, 6, [(1, 2, 4), (2, 3, 3), (3, 5, 2), (1, 4, 6), (4, 5, 1), (3, 4, 2)]) 7 >>> shortest_path(4, 2, [(1, 2, 5), (3, 4, 7)]) \\"NO PATH\\" pass","solution":"import heapq def shortest_path(n, m, edges): Calculates the shortest path from lake 1 to lake n using Dijkstra's algorithm. If there is no path, returns \\"NO PATH\\". # Graph initialization graph = [[] for _ in range(n + 1)] for ai, bi, wi in edges: graph[ai].append((bi, wi)) graph[bi].append((ai, wi)) # Dijkstra's algorithm def dijkstra(start, end): heap = [(0, start)] # (cost, node) distances = {i: float('inf') for i in range(1, n+1)} distances[start] = 0 while heap: current_dist, current_node = heapq.heappop(heap) if current_node == end: return current_dist if current_dist > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_dist + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(heap, (distance, neighbor)) return float('inf') shortest_distance = dijkstra(1, n) return shortest_distance if shortest_distance != float('inf') else \\"NO PATH\\""},{"question":"def reorder_sequence(n: int, sequence: List[int]) -> List[int]: Reorders a sequence of numbers following the alternating pattern of selecting the largest and smallest remaining items. Parameters: - n (int): The number of integers in the sequence. - sequence (list of int): The sequence of integers. Returns: - list of int: The reordered sequence. >>> reorder_sequence(5, [1, 9, 2, 8, 3]) [9, 1, 8, 2, 3] >>> reorder_sequence(6, [10, 5, 3, 6, 2, 9]) [10, 2, 9, 3, 6, 5]","solution":"def reorder_sequence(n, sequence): Reorders a sequence of numbers following the alternating pattern of selecting the largest and smallest remaining items. Parameters: - n (int): The number of integers in the sequence. - sequence (list of int): The sequence of integers. Returns: - list of int: The reordered sequence. result = [] sorted_sequence = sorted(sequence) i, j = 0, n - 1 while i <= j: if j >= i: result.append(sorted_sequence[j]) j -= 1 if i <= j: result.append(sorted_sequence[i]) i += 1 return result # Example usage: # n = 5 # sequence = [1, 9, 2, 8, 3] # print(reorder_sequence(n, sequence)) # Output: [9, 1, 8, 2, 3]"},{"question":"def process_operations(n, s, operations): Processes a list of operations on the string s. Parameters: n (int): The length of the string. s (str): The initial string. operations (list of str): The list of operations in the format described. Returns: list of str: The results of the query operations (\\"YES\\" or \\"NO\\"). Example Usage: >>> process_operations(5, \\"abcba\\", [\\"query 0 4\\", \\"replace 1 3 xyz\\", \\"query 0 4\\"]) [\\"YES\\", \\"NO\\"] >>> process_operations(6, \\"abcdef\\", [\\"replace 0 2 xyz\\", \\"query 0 2\\"]) [\\"NO\\"] from solution import process_operations def test_example_case(): n = 5 s = \\"abcba\\" operations = [\\"query 0 4\\", \\"replace 1 3 xyz\\", \\"query 0 4\\"] result = process_operations(n, s, operations) assert result == [\\"YES\\", \\"NO\\"] def test_replace_only(): n = 3 s = \\"abc\\" operations = [\\"replace 0 2 xyz\\"] result = process_operations(n, s, operations) assert result == [] def test_query_only(): n = 4 s = \\"abcd\\" operations = [\\"query 0 3\\", \\"query 1 2\\"] result = process_operations(n, s, operations) assert result == [\\"NO\\", \\"NO\\"] def test_palindrome_after_replace(): n = 3 s = \\"abc\\" operations = [\\"replace 1 1 x\\", \\"query 0 2\\"] result = process_operations(n, s, operations) assert result == [\\"NO\\"] def test_multiple_replaces_and_queries(): n = 6 s = \\"abccba\\" operations = [\\"query 0 5\\", \\"replace 2 4 zzz\\", \\"query 0 5\\"] result = process_operations(n, s, operations) assert result == [\\"YES\\", \\"NO\\"]","solution":"def is_palindrome(s): Helper function to check if a given string s is a palindrome. return s == s[::-1] def process_operations(n, s, operations): Processes a list of operations on the string s. Parameters: n (int): The length of the string. s (str): The initial string. operations (list of str): The list of operations in the format described. Returns: list of str: The results of the query operations (\\"YES\\" or \\"NO\\"). results = [] s = list(s) # Convert the string to a list for mutable operations for op in operations: parts = op.split() if parts[0] == \\"replace\\": l = int(parts[1]) r = int(parts[2]) new_str = parts[3] s[l:r+1] = new_str elif parts[0] == \\"query\\": l = int(parts[1]) r = int(parts[2]) substring = ''.join(s[l:r+1]) if is_palindrome(substring): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def maxDepth(root): Returns the maximum depth of the binary tree. pass # Unit tests def test_maxDepth_empty_tree(): assert maxDepth(None) == 0 def test_maxDepth_single_node(): root = TreeNode(1) assert maxDepth(root) == 1 def test_maxDepth_balanced_tree(): # Tree: # 1 # / # 2 3 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) assert maxDepth(root) == 2 def test_maxDepth_left_heavy_tree(): # Tree: # 1 # / # 2 # / # 3 root = TreeNode(1) root.left = TreeNode(2) root.left.left = TreeNode(3) assert maxDepth(root) == 3 def test_maxDepth_right_heavy_tree(): # Tree: # 1 # # 2 # # 3 root = TreeNode(1) root.right = TreeNode(2) root.right.right = TreeNode(3) assert maxDepth(root) == 3 def test_maxDepth_mixed_tree(): # Tree: # 1 # / # 2 3 # / / # 4 5 6 # / # 7 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.left.left = TreeNode(7) root.right.left = TreeNode(5) root.right.right = TreeNode(6) assert maxDepth(root) == 4","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def maxDepth(root): Returns the maximum depth of the binary tree. if root is None: return 0 else: left_depth = maxDepth(root.left) right_depth = maxDepth(root.right) return max(left_depth, right_depth) + 1"},{"question":"def can_divide_chocolates(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine if it is possible to divide chocolate bars into two groups with equal sum. Args: t: An integer representing the number of test cases. test_cases: A list of tuples where each tuple represents a test case. The first element of tuple is an integer n, the number of chocolate bars. The second element is a list of integers representing the lengths of the chocolate bars. Returns: A list of strings, each string is either \\"YES\\" or \\"NO\\" for each test case respectively. >>> can_divide_chocolates(3, [(5, [1, 2, 3, 4, 5]), (4, [4, 4, 4, 4]), (3, [1, 1, 3])]) ['NO', 'YES', 'NO'] >>> can_divide_chocolates(1, [(4, [1, 5, 11, 5])]) ['YES']","solution":"def can_divide_chocolates(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] chocolates = test_cases[i][1] if sum(chocolates) % 2 != 0: results.append(\\"NO\\") else: target = sum(chocolates) // 2 dp = [False] * (target + 1) dp[0] = True for chocolate in chocolates: for j in range(target, chocolate - 1, -1): if dp[j - chocolate]: dp[j] = True if dp[target]: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def subarrays_with_same_sum(n: int, k: int, arr: List[int]) -> Tuple[int, List[Tuple[int, int]]]: Given an array of n integers and another integer k, determine the number of subarrays of length exactly k that have the same sum of elements. For each such subarray, return its starting and ending indices (1-based). Args: n (int): The length of the array. k (int): The required length of the subarrays. arr (List[int]): The elements of the array. Returns: Tuple[int, List[Tuple[int, int]]]: The number of valid subarrays and their 1-based indices. >>> subarrays_with_same_sum(5, 3, [1, 2, 1, 2, 1]) (2, [(1, 3), (3, 5)]) >>> subarrays_with_same_sum(5, 3, [1, 2, 3, 4, 5]) (0, []) >>> subarrays_with_same_sum(5, 1, [1, 1, 1, 1, 1]) (5, [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)]) >>> subarrays_with_same_sum(6, 2, [4, 4, 4, 4, 4, 4]) (5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]) >>> subarrays_with_same_sum(4, 2, [2, 2, 2, 2]) (3, [(1, 2), (2, 3), (3, 4)])","solution":"def subarrays_with_same_sum(n, k, arr): subarray_sums = {} result = [] count = 0 for i in range(n - k + 1): subarray = arr[i:i + k] subarray_sum = sum(subarray) if subarray_sum in subarray_sums: subarray_sums[subarray_sum].append((i + 1, i + k)) else: subarray_sums[subarray_sum] = [(i + 1, i + k)] for subarray_list in subarray_sums.values(): if len(subarray_list) > 1: count += len(subarray_list) result.extend(subarray_list) return count, result"},{"question":"def unique_integers_in_subgrid(grid, n, m, k): Find the number of unique integers in each subgrid of size k x k. Params: - grid (List[List[int]]): A 2D list of integers representing the grid. - n (int): The number of rows in the grid. - m (int): The number of columns in the grid. - k (int): The size of the subgrid. Returns: - List[List[int]]: A 2D list of integers representing the count of unique integers in each k x k subgrid of the input grid. >>> unique_integers_in_subgrid([ ... [1, 2, 1, 2], ... [2, 1, 2, 1], ... [1, 2, 1, 2] ... ], 3, 4, 2) [[3, 4, 3], [4, 4, 4], [3, 4, 3]] >>> unique_integers_in_subgrid([ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16] ... ], 4, 4, 2) [[4, 4, 4], [4, 4, 4], [4, 4, 4]]","solution":"def unique_integers_in_subgrid(grid, n, m, k): def unique_count(subgrid): unique_set = set() for row in subgrid: unique_set.update(row) return len(unique_set) result = [] for i in range(n - k + 1): row_result = [] for j in range(m - k + 1): subgrid = [grid[x][j:j+k] for x in range(i, i+k)] row_result.append(unique_count(subgrid)) result.append(row_result) return result"},{"question":"def maximize_sum(n: int, m: int, A: List[int], B: List[int]) -> int: Alice is playing a game with a sequence of integers. She is given two sequences: \`A\` of length \`n\`, and \`B\` of length \`m\`. She can perform the following operation any number of times: 1. Pick an integer x from sequence \`B\` and increase any element of \`A\` by x. Alice wants to maximize the sum of all elements in \`A\` after performing the operations optimally. Determine the maximum sum she can achieve. >>> maximize_sum(3, 3, [1, 2, 3], [2, 5, -1]) 21 >>> maximize_sum(3, 2, [1, 2, 3], [2, 5]) 21 >>> maximize_sum(1, 1, [1], [1]) 2 >>> maximize_sum(4, 2, [1, 4, 3, 2], [1, 2]) 18 >>> maximize_sum(5, 3, [7, 8, 10, 1, 2], [3, 4, -2]) 48 >>> maximize_sum(2, 5, [1, 1], [9, 10, 11, 12, 13]) 28","solution":"def maximize_sum(n, m, A, B): # To maximize the sum of A, we need to add the largest value from B multiple times to each element of A. # Since we can add the same elements from B any number of times, we just need to focus on the largest value in B. max_B = max(B) initial_sum_A = sum(A) new_sum = initial_sum_A + n * max_B return new_sum"},{"question":"def minimum_toll(n: int, e: int, roads: List[Tuple[int, int, int]]) -> int: Determine the minimum total toll cost required to ensure control over all castles. If it is not possible to ensure control over all the castles, return -1. >>> minimum_toll(4, 5, [(1, 2, 3), (2, 3, 4), (3, 4, 2), (1, 3, 5), (1, 4, 8)]) 9 >>> minimum_toll(1, 0, []) 0 >>> minimum_toll(5, 2, [(1, 2, 1), (3, 4, 1)]) -1 >>> minimum_toll(2, 0, []) -1 >>> minimum_toll(3, 3, [(1, 2, 1), (2, 3, 1), (1, 3, 2)]) 2 >>> minimum_toll(10, 15, [(1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 5, 1), (5, 6, 1), ... (6, 7, 1), (7, 8, 1), (8, 9, 1), (9, 10, 1), ... (1, 3, 2), (2, 4, 2), (3, 5, 2), (4, 6, 2), (5, 7, 2), ... (6, 8, 2)]) 9 pass","solution":"def find(parent, i): if parent[i] == i: return i else: parent[i] = find(parent, parent[i]) return parent[i] def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 def kruskal_mst(n, edges): edges.sort(key=lambda x: x[2]) parent = [i for i in range(n)] rank = [0] * n total_toll = 0 edges_used = 0 for u, v, w in edges: if find(parent, u) != find(parent, v): union(parent, rank, u, v) total_toll += w edges_used += 1 if edges_used == n - 1: break if edges_used != n - 1: return -1 return total_toll def minimum_toll(n, e, roads): if n == 1: return 0 if e == 0 and n > 1: return -1 edges = [(u - 1, v - 1, w) for u, v, w in roads] return kruskal_mst(n, edges)"},{"question":"def max_uphill_downhill_length(n: int, elevations: List[int]) -> int: Returns the maximum length of any continuous uphill or downhill section. Parameters: n (int): Number of recorded elevations. elevations (list of int): List of elevation readings. Returns: int: Maximum length of any continuous uphill or downhill section. >>> max_uphill_downhill_length(6, [2, 3, 1, 4, 5, 7]) 4 >>> max_uphill_downhill_length(5, [1, 2, 3, 4, 5]) 5","solution":"def max_uphill_downhill_length(n, elevations): Returns the maximum length of any continuous uphill or downhill section. Parameters: n (int): Number of recorded elevations. elevations (list of int): List of elevation readings. Returns: int: Maximum length of any continuous uphill or downhill section. if n == 1: return 1 max_length = 1 current_length = 1 trend = 0 # 0 for flat, 1 for uphill, -1 for downhill for i in range(1, n): if elevations[i] > elevations[i - 1]: if trend == 1: current_length += 1 else: trend = 1 current_length = 2 elif elevations[i] < elevations[i - 1]: if trend == -1: current_length += 1 else: trend = -1 current_length = 2 else: trend = 0 current_length = 1 max_length = max(max_length, current_length) return max_length"},{"question":"def count_leaf_paths(n: int, edges: List[Tuple[int, int]]) -> int: Given an undirected tree with n nodes where node 1 is the root, determine the number of unique paths from the root to each leaf node. A leaf is defined as a node that has exactly one neighbor. >>> count_leaf_paths(5, [(1, 2), (1, 3), (2, 4), (2, 5)]) 3 >>> count_leaf_paths(2, [(1, 2)]) 1 >>> count_leaf_paths(3, [(1, 2), (1, 3)]) 2","solution":"def count_leaf_paths(n, edges): from collections import defaultdict if n == 2: return 1 tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) def is_leaf(node): return len(tree[node]) == 1 leaf_count = 0 for node in range(2, n+1): if is_leaf(node): leaf_count += 1 return leaf_count"},{"question":"def longest_common_prefix_length(str1: str, str2: str) -> int: Returns the length of the longest common prefix between str1 and str2. >>> longest_common_prefix_length(\\"apple\\", \\"ape\\") == 2 >>> longest_common_prefix_length(\\"apple\\", \\"apricot\\") == 2 >>> longest_common_prefix_length(\\"banana\\", \\"band\\") == 3 >>> longest_common_prefix_length(\\"dog\\", \\"cat\\") == 0 >>> longest_common_prefix_length(\\"same\\", \\"same\\") == 4 def max_common_prefix_length(messages: List[str]) -> int: Returns the maximum length of a common prefix shared by any two distinct messages in the set. >>> max_common_prefix_length([\\"apple\\", \\"ape\\", \\"apricot\\", \\"banana\\"]) == 2 >>> max_common_prefix_length([\\"car\\", \\"card\\", \\"cart\\", \\"dog\\"]) == 3 >>> max_common_prefix_length([\\"apple\\", \\"banana\\"]) == 0 >>> max_common_prefix_length([\\"dog\\", \\"cat\\", \\"bird\\"]) == 0 >>> max_common_prefix_length([\\"a\\", \\"b\\", \\"c\\"]) == 0 >>> max_common_prefix_length([\\"a\\"*100, \\"a\\"*99 + \\"b\\"]) == 99 >>> max_common_prefix_length([\\"abcd\\", \\"abce\\", \\"abcf\\"]) == 3 >>> max_common_prefix_length([\\"a\\"*100]*100000) == 100 >>> max_common_prefix_length([\\"x\\"*i for i in range(1, 101)]) == 99","solution":"def longest_common_prefix_length(str1, str2): Returns the length of the longest common prefix between str1 and str2. common_length = 0 for a, b in zip(str1, str2): if a == b: common_length += 1 else: break return common_length def max_common_prefix_length(messages): Returns the maximum length of a common prefix shared by any two distinct messages in the set. n = len(messages) # Sort messages to bring common prefixes next to each other messages.sort() max_length = 0 # Check only adjacent pairs after sorting for i in range(n - 1): max_length = max(max_length, longest_common_prefix_length(messages[i], messages[i + 1])) return max_length"},{"question":"def rotate_matrix(input_str: str) -> str: Rotate a matrix 90 degrees clockwise. The first line of the input contains two integers, n and m (1  n, m  100), which represent the number of rows and columns in the matrix, respectively. The next n lines each contain m integers, representing the elements of the matrix. Output the rotated matrix, where: - The first row of the output is the last column of the input matrix. - The second row of the output is the second-to-last column of the input matrix, and so on until the n-th row of the output is the first column of the input matrix. Example: >>> rotate_matrix(\\"3 4n1 2 3 4n5 6 7 8n9 10 11 12\\") \\"9 5 1n10 6 2n11 7 3n12 8 4\\" >>> rotate_matrix(\\"2 2n1 2n3 4\\") \\"3 1n4 2\\"","solution":"def rotate_matrix_90_degrees_clockwise(matrix): Rotates the given matrix 90 degrees clockwise. n = len(matrix) m = len(matrix[0]) rotated_matrix = [[0]*n for _ in range(m)] for i in range(n): for j in range(m): rotated_matrix[j][n - 1 - i] = matrix[i][j] return rotated_matrix def convert_input_to_matrix(input_str): input_rows = input_str.strip().split(\\"n\\") n, m = map(int, input_rows[0].strip().split()) matrix = [list(map(int, row.strip().split())) for row in input_rows[1:]] return matrix def convert_matrix_to_output(matrix): return \\"n\\".join( [\\" \\".join(map(str, row)) for row in matrix] ) def rotate_matrix(input_str): matrix = convert_input_to_matrix(input_str) rotated_matrix = rotate_matrix_90_degrees_clockwise(matrix) return convert_matrix_to_output(rotated_matrix)"},{"question":"def maximize_apples(K: int, L: int, M: int) -> tuple: Determines the maximum number of apples that can be stolen and the minimum number of branches needed to achieve that, while ensuring the apples are from contiguous branches and the total number of apples is at most M. Parameters: K (int): Number of branches. L (int): Number of apples per branch. M (int): Maximum capacity of the magic bag. Returns: tuple: (max_apples, min_branches) maximum number of apples and the minimum branches needed. >>> maximize_apples(5, 10, 25) (20, 2) >>> maximize_apples(10, 10, 50) (50, 5) >>> maximize_apples(3, 7, 20) (14, 2) >>> maximize_apples(3, 9, 20) (18, 2) >>> maximize_apples(6, 5, 18) (15, 3) >>> maximize_apples(1, 500, 400) (0, 0) >>> maximize_apples(1000, 1000, 1000000) (1000000, 1000)","solution":"def maximize_apples(K, L, M): Determines the maximum number of apples that can be stolen and the minimum number of branches needed to achieve that, while ensuring the apples are from contiguous branches and the total number of apples is at most M. Parameters: K (int): Number of branches. L (int): Number of apples per branch. M (int): Maximum capacity of the magic bag. Returns: tuple: (max_apples, min_branches) maximum number of apples and the minimum branches needed. max_apples = 0 min_branches = 0 for branches in range(1, K + 1): apples = branches * L if apples > M: break max_apples = apples min_branches = branches return max_apples, min_branches"},{"question":"from typing import List def max_profit(prices: List[int]) -> int: This function takes a list of prices and returns the maximum profit that can be achieved by buying and selling the ice cream as described in the problem. >>> max_profit([7, 1, 5, 3, 6, 4]) 7 >>> max_profit([1, 2, 3, 4, 5]) 4 >>> max_profit([5, 4, 3, 2, 1]) 0 >>> max_profit([5]) 0 >>> max_profit([1, 2, 1, 2, 1, 2]) 3 >>> max_profit([1, 1000]) 999","solution":"def max_profit(prices): This function takes a list of prices and returns the maximum profit that can be achieved by buying and selling the ice cream as described in the problem. profit = 0 for i in range(1, len(prices)): if prices[i] > prices[i - 1]: profit += prices[i] - prices[i - 1] return profit"},{"question":"from typing import List def process_queries(s: str, queries: List[List[str]]) -> List[str]: You are given a string s consisting of lowercase Latin letters. You need to process two types of queries on this string: 1. **Update**: Change the character at a given position to a new character. 2. **Query**: Determine which character (lexicographically smallest) occurs the most frequently in a given substring. The queries are given as follows: - Type 1 (Update): Given 1 x c, change the character at position x of string s to c (1-based index). - Type 2 (Query): Given 2 l r, find the lexicographically smallest character that occurs the most frequently in the substring s[l...r] (both inclusive, 1-based index). Example: >>> process_queries(\\"ababc\\", [['2', '1', '5'], ['1', '3', 'z'], ['2', '2', '4'], ['1', '5', 'a'], ['2', '1', '5']]) ['a', 'b', 'a'] >>> process_queries(\\"a\\", [['2', '1', '1'], ['1', '1', 'b'], ['2', '1', '1']]) ['a', 'b'] >>> process_queries(\\"abc\\", [['2', '1', '3'], ['1', '2', 'a'], ['2', '1', '3'], ['1', '3', 'a'], ['2', '1', '3']]) ['a', 'a', 'a'] >>> process_queries(\\"xyzxyz\\", [['2', '4', '6'], ['1', '4', 'a'], ['2', '4', '6']]) ['x', 'a']","solution":"from collections import defaultdict, Counter def process_queries(s, queries): n = len(s) s = list(s) results = [] for query in queries: q_type, x, y = query[0], int(query[1]), query[2] if q_type == '1': idx = x - 1 s[idx] = y elif q_type == '2': l = x - 1 r = int(y) - 1 substr = s[l:r+1] freq = Counter(substr) # Count frequency of each character in the substring max_freq = max(freq.values()) most_frequent_chars = [char for char, count in freq.items() if count == max_freq] smallest_char = min(most_frequent_chars) # Lexicographically smallest character results.append(smallest_char) return results"},{"question":"def decipher_sequence(n: int, transformed_sequence: str, k: int) -> str: Given the number of symbols in the sequence, the transformed sequence and the number of shifts k, returns the original sequence before the transformation. >>> decipher_sequence(8, \\"CDEFGHIJ\\", 2) 'ABCDEFGH' >>> decipher_sequence(4, \\"WXYZ\\", 0) 'WXYZ' >>> decipher_sequence(3, \\"XYZ\\", 25) 'YZA' >>> decipher_sequence(1, \\"A\\", 1) 'Z' >>> decipher_sequence(5, \\"HELLO\\", 3) 'EBIIL'","solution":"def decipher_sequence(n, transformed_sequence, k): Given the number of symbols in the sequence, the transformed sequence and the number of shifts k, returns the original sequence before the transformation. original_sequence = [] for char in transformed_sequence: # Shift the character k steps back original_char_val = ord(char) - k if original_char_val < ord('A'): original_char_val += 26 original_sequence.append(chr(original_char_val)) return ''.join(original_sequence)"},{"question":"from typing import List, Tuple def unique_paths(n: int, grid: List[str], start: Tuple[int, int], target: Tuple[int, int]) -> int: Determine the number of unique paths for a robot to navigate a grid from start to target position. The grid is represented as a list of strings where '.' denotes an empty cell and '#' denotes an obstacle. The robot can move up, down, left, or right but cannot pass through obstacles or cells it has already visited. Args: n (int): The dimension of the grid (n x n). grid (List[str]): The grid representation with '.' for empty cells and '#' for obstacles. start (Tuple[int, int]): The starting coordinates (sx, sy). target (Tuple[int, int]): The target coordinates (tx, ty). Returns: int: The number of unique paths from start to target. Examples: >>> unique_paths(3, [\\"...\\", \\".#.\\", \\"...\\"], (0, 0), (2, 2)) 2 >>> unique_paths(3, [\\"...\\", \\".#.\\", \\"...\\"], (0, 0), (1, 1)) 0 >>> unique_paths(4, [\\"....\\", \\"..\\", \\".#..\\", \\"....\\"], (0, 0), (3, 3)) 4 >>> unique_paths(2, [\\"..\\", \\"..\\"], (0, 0), (1, 1)) 2 >>> unique_paths(1, [\\".\\"], (0, 0), (0, 0)) 1 pass","solution":"def unique_paths(n, grid, start, target): def dfs(x, y): if not (0 <= x < n and 0 <= y < n): return 0 if grid[x][y] == '#' or visited[x][y]: return 0 if (x, y) == target: return 1 visited[x][y] = True path_count = dfs(x+1, y) + dfs(x-1, y) + dfs(x, y+1) + dfs(x, y-1) visited[x][y] = False return path_count sx, sy = start tx, ty = target if grid[sx][sy] == '#' or grid[tx][ty] == '#': return 0 visited = [[False] * n for _ in range(n)] return dfs(sx, sy)"},{"question":"def calculate_total_discount(n: int, items: List[Tuple[str, int, float]]) -> float: Calculate the total discount for the items in the cart. Args: n (int): Number of different items. items (list of tuples): Each tuple contains the item's name (str), the quantity (int), and the discount rate (float). Returns: float: Total discount rounded to two decimal places. Examples: >>> calculate_total_discount(3, [(\\"apple\\", 5, 1.5), (\\"banana\\", 3, 2.0), (\\"orange\\", 7, 0.5)]) 17.00 >>> calculate_total_discount(1, [(\\"grape\\", 10, 0.1)]) 1.00 >>> calculate_total_discount(2, [(\\"peach\\", 4, 0.0), (\\"plum\\", 2, 0.0)]) 0.00 >>> calculate_total_discount(2, [(\\"item1\\", 1000, 1.0), (\\"item2\\", 500, 2.5)]) 2250.00 >>> calculate_total_discount(3, [(\\"itemA\\", 10, 0.1), (\\"itemB\\", 20, 0.2), (\\"itemC\\", 30, 0.3)]) 14.00","solution":"def calculate_total_discount(n, items): Calculate the total discount for the items in the cart. Args: n (int): Number of different items. items (list of tuples): Each tuple contains the item's name (str), the quantity (int), and the discount rate (float). Returns: float: Total discount rounded to two decimal places. total_discount = 0.0 for item in items: name, quantity, discount_rate = item total_discount += quantity * discount_rate return round(total_discount, 2)"},{"question":"def min_swaps_to_make_good(s: str) -> int: Given a string s, returns the minimum number of adjacent swaps required to make the string good. If it is impossible to make the string good, return -1. A string is called \\"good\\" if it contains no two consecutive same characters. Examples: >>> min_swaps_to_make_good(\\"aa\\") == -1 >>> min_swaps_to_make_good(\\"ab\\") == 0 >>> min_swaps_to_make_good(\\"aabb\\") == 2 pass def process_input(strings: List[str]) -> List[int]: Process the input list of strings and return a list of integers that represent the minimum number of swaps required to make each string good. Examples: >>> process_input([\\"aa\\", \\"ab\\", \\"aabb\\"]) == [-1, 0, 2] >>> process_input([\\"abc\\", \\"aabbcc\\", \\"aaabbb\\"]) == [0, -1, -1] pass","solution":"def min_swaps_to_make_good(s): Given a string s, returns the minimum number of adjacent swaps required to make the string good. If it is impossible to make the string good, returns -1. n = len(s) count_odd_positions = sum(s[i] == s[i + 2] for i in range(0, n - 2, 2)) count_even_positions = sum(s[i] == s[i + 2] for i in range(1, n - 2, 2)) if any(s[i] == s[i + 1] for i in range(n - 1)): return -1 return min(count_odd_positions, count_even_positions) def process_input(strings): results = [] for s in strings: results.append(min_swaps_to_make_good(s)) return results"},{"question":"from typing import List, Tuple def subset_product_ends_with_d(t: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[str]: Determine if there exists a non-empty subset of integers from each test case such that the product of its elements ends with a specific digit, d. Args: t (int): the number of test cases. test_cases (List[Tuple[Tuple[int, int], List[int]]]): a list of tuple wherein each tuple contains a pair (n, d) and a list of integers. Returns: List[str]: a list containing \\"YES\\" or \\"NO\\" for each test case. Example: >>> subset_product_ends_with_d(2, [((3, 4), [2, 3, 7]), ((3, 5), [1, 2, 3])]) [\\"YES\\", \\"NO\\"] >>> subset_product_ends_with_d(1, [((1, 4), [4])]) [\\"YES\\"] >>> subset_product_ends_with_d(1, [((1, 9), [5])]) [\\"NO\\"] >>> subset_product_ends_with_d(1, [((4, 7), [2, 4, 6, 8])]) [\\"NO\\"] >>> subset_product_ends_with_d(1, [((10, 0), [10, 20, 30, 40, 50, 60, 70, 80, 90, 100])]) [\\"YES\\"] >>> subset_product_ends_with_d(1, [((5, 2), [1, 3, 7, 2, 5])]) [\\"YES\\"] >>> subset_product_ends_with_d(1, [((5, 8), [1, 3, 7, 2, 5])]) [\\"NO\\"]","solution":"from itertools import combinations def subset_product_ends_with_d(t, test_cases): results = [] for i in range(t): n, d = test_cases[i][0] arr = test_cases[i][1] found = False for r in range(1, n+1): for combo in combinations(arr, r): product = 1 for num in combo: product *= num if product % 10 == d: found = True break if found: break results.append(\\"YES\\" if found else \\"NO\\") return results"},{"question":"def min_abs_difference(n, arr): Returns the minimum possible absolute difference between the sums of two non-empty parts of the array. >>> min_abs_difference(5, [3, 1, -2, 5, 4]) == 1 >>> min_abs_difference(4, [1, 2, 3, 4]) == 0 >>> min_abs_difference(4, [-1, -2, -3, -4]) == 0 >>> min_abs_difference(6, [6, -5, -2, 1, 3, -4]) == 1 >>> min_abs_difference(3, [10**9, -10**9, 0]) == 0 >>> min_abs_difference(2, [1, 2]) == 1 >>> min_abs_difference(4, [5, 5, 5, 5]) == 0","solution":"def min_abs_difference(n, arr): Returns the minimum possible absolute difference between the sums of two non-empty parts of the array. total_sum = sum(arr) target = total_sum // 2 # Initialize a set to store the possible sums possible_sums = {0} for num in arr: new_sums = set() for s in possible_sums: new_sums.add(s + num) possible_sums.update(new_sums) closest_sum = min(possible_sums, key=lambda x: abs(total_sum - 2*x)) part1_sum = closest_sum part2_sum = total_sum - closest_sum return abs(part1_sum - part2_sum)"},{"question":"from typing import List def longest_common_prefix(strs: List[str]) -> str: Find the longest common prefix among an array of strings. If there is no common prefix, return an empty string \\"\\". >>> longest_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\"]) 'fl' >>> longest_common_prefix([\\"dog\\", \\"racecar\\", \\"car\\"]) '' pass def test_common_prefix_basic(): assert longest_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\"]) == \\"fl\\" def test_no_common_prefix(): assert longest_common_prefix([\\"dog\\", \\"racecar\\", \\"car\\"]) == \\"\\" def test_common_prefix_all_identical(): assert longest_common_prefix([\\"same\\", \\"same\\", \\"same\\"]) == \\"same\\" def test_single_string(): assert longest_common_prefix([\\"alone\\"]) == \\"alone\\" def test_empty_string_in_array(): assert longest_common_prefix([\\"\\", \\"prefix\\", \\"pre\\"]) == \\"\\" def test_common_prefix_two_identical(): assert longest_common_prefix([\\"test\\", \\"testing\\", \\"\\"]) == \\"\\" def test_varied_length_strings(): assert longest_common_prefix([\\"prefix\\", \\"pre\\"]) == \\"pre\\" assert longest_common_prefix([\\"pre\\", \\"prefix\\"]) == \\"pre\\" def test_empty_input_array(): assert longest_common_prefix([]) == \\"\\" def test_prefix_ends_in_middle(): assert longest_common_prefix([\\"ab\\", \\"a\\"]) == \\"a\\" assert longest_common_prefix([\\"flower\\", \\"flow\\", \\"flux\\"]) == \\"fl\\"","solution":"def longest_common_prefix(strs): Find the longest common prefix string among an array of strings. if not strs: return \\"\\" # Find the minimum length string from the array. min_len = min(len(s) for s in strs) if min_len == 0: return \\"\\" # Use the shortest string's length for the prefix checking. i = 0 while i < min_len: char = strs[0][i] for s in strs: if s[i] != char: return s[:i] i += 1 return strs[0][:i]"},{"question":"from typing import List, Tuple class UnionFind: def __init__(self, size): self.parent = list(range(size)) self.rank = [0] * size def find(self, node): if self.parent[node] != node: self.parent[node] = self.find(self.parent[node]) return self.parent[node] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 def kruskal_mst(n: int, edges: List[Tuple[int, int, int]]) -> int: Find the total weight of the minimum spanning tree (MST) for a given undirected graph. :param n: Number of nodes in the graph :param edges: List of edges with their weights (u, v, w) :return: Total weight of the MST >>> kruskal_mst(4, [(1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 1, 4), (1, 3, 5)]) 6 >>> kruskal_mst(3, []) 0 pass def test_kruskal_mst_example1(): n = 4 edges = [ (1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 1, 4), (1, 3, 5) ] assert kruskal_mst(n, edges) == 6 def test_kruskal_mst_example2(): n = 3 edges = [] assert kruskal_mst(n, edges) == 0 def test_kruskal_mst_single_edge(): n = 2 edges = [(1, 2, 1)] assert kruskal_mst(n, edges) == 1 def test_kruskal_mst_multiple_components(): n = 5 edges = [ (1, 2, 1), (3, 4, 2), (4, 5, 3), (2, 3, 4) ] assert kruskal_mst(n, edges) == 10 def test_kruskal_mst_large_weights(): n = 4 edges = [ (1, 2, 1000), (2, 3, 1000), (3, 4, 1000), (4, 1, 1000), (1, 3, 1000) ] assert kruskal_mst(n, edges) == 3000","solution":"class UnionFind: def __init__(self, size): self.parent = list(range(size)) self.rank = [0] * size def find(self, node): if self.parent[node] != node: self.parent[node] = self.find(self.parent[node]) # Path compression return self.parent[node] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 def kruskal_mst(n, edges): edges.sort(key=lambda edge: edge[2]) uf = UnionFind(n) mst_weight = 0 mst_edges = 0 for u, v, w in edges: u -= 1 v -= 1 if uf.find(u) != uf.find(v): uf.union(u, v) mst_weight += w mst_edges += 1 if mst_edges == n - 1: break return mst_weight # Example usage: if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() n = int(data[0]) m = int(data[1]) edges = [] index = 2 for i in range(m): u = int(data[index]) v = int(data[index + 1]) w = int(data[index + 2]) edges.append((u, v, w)) index += 3 if m == 0: print(0) else: result = kruskal_mst(n, edges) print(result)"},{"question":"def digit_sum(n: int) -> int: Returns the single-digit sum of the digits of number n. >>> digit_sum(9875) 2 >>> digit_sum(12345) 6 >>> digit_sum(9) 9 pass def solve_digit_sum_challenge(t: int, numbers: list[str]) -> list[int]: Solves multiple test cases of the Digit Sum Challenge. Parameters: t (int): Number of test cases. numbers (list of str): List of numbers for which the digit sum needs to be computed. Returns: list of int: List of resulting single-digit numbers. >>> solve_digit_sum_challenge(3, [\\"9875\\", \\"12345\\", \\"9\\"]) [2, 6, 9] >>> solve_digit_sum_challenge(2, [\\"10\\", \\"18\\"]) [1, 9] pass","solution":"def digit_sum(n): Returns the single-digit sum of the digits of number n. while n >= 10: n = sum(map(int, str(n))) return n def solve_digit_sum_challenge(t, numbers): Solves multiple test cases of the Digit Sum Challenge. Parameters: t (int): Number of test cases. numbers (list of int): List of numbers for which the digit sum needs to be computed. Returns: list of int: List of resulting single-digit numbers. results = [] for number in numbers: results.append(digit_sum(int(number))) return results"},{"question":"from typing import List, Tuple def detect_intrusions(n: int, k: int, login_attempts: List[Tuple[str, int]]) -> int: Detects how many login attempts are potential intrusions based on repeated attempts within a time window. Parameters: n (int): Number of login attempts. k (int): Time window in seconds. login_attempts (list of tuples): List of login attempts where each tuple contains user_id and timestamp. Returns: int: Number of login attempts flagged as potential intrusions. Example: >>> detect_intrusions(5, 5, [(\\"alice\\", 1), (\\"bob\\", 2), (\\"alice\\", 3), (\\"alice\\", 7), (\\"bob\\", 9)]) 2 >>> detect_intrusions(4, 1, [(\\"alice\\", 1), (\\"bob\\", 2), (\\"alice\\", 4), (\\"bob\\", 6)]) 0","solution":"def detect_intrusions(n, k, login_attempts): Detects how many login attempts are potential intrusions based on repeated attempts within a time window. Parameters: n (int): Number of login attempts. k (int): Time window in seconds. login_attempts (list of tuples): List of login attempts where each tuple contains user_id and timestamp. Returns: int: Number of login attempts flagged as potential intrusions. from collections import defaultdict user_attempts = defaultdict(list) intrusion_count = 0 for user_id, timestamp in login_attempts: attempts = user_attempts[user_id] if attempts and timestamp - attempts[-1] <= k: intrusion_count += 1 attempts.append(timestamp) return intrusion_count # Example usage: # n, k = 5, 5 # login_attempts = [(\\"alice\\", 1), (\\"bob\\", 2), (\\"alice\\", 3), (\\"alice\\", 7), (\\"bob\\", 9)] # print(detect_intrusions(n, k, login_attempts)) # Output: 2"},{"question":"from typing import List, Tuple from collections import defaultdict, deque def longest_chain(n: int, m: int, edges: List[Tuple[int, int]]) -> int: Determine the length of the longest chain of command in an organizational hierarchy. Args: n (int): Number of employees in the organization. m (int): Number of reporting relationships. edges (List[Tuple[int, int]]): List of reporting relationships represented as tuples (a, b), where a reports to b. Returns: int: The length of the longest chain of command. Examples: >>> longest_chain(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) 5 >>> longest_chain(1, 0, []) 1 >>> longest_chain(3, 0, []) 1 pass def test_example_case(): n = 5 m = 4 edges = [(1, 2), (2, 3), (3, 4), (4, 5)] assert longest_chain(n, m, edges) == 5 def test_single_node(): n = 1 m = 0 edges = [] assert longest_chain(n, m, edges) == 1 def test_disconnected_graph(): n = 3 m = 0 edges = [] assert longest_chain(n, m, edges) == 1 def test_two_nodes(): n = 2 m = 1 edges = [(1, 2)] assert longest_chain(n, m, edges) == 2 def test_multiple_paths(): n = 4 m = 3 edges = [(1, 2), (2, 3), (1, 4)] assert longest_chain(n, m, edges) == 3 def test_diamond_shaped_graph(): n = 4 m = 3 edges = [(1, 2), (1, 3), (2, 4), (3, 4)] assert longest_chain(n, m, edges) == 3 def test_complex_graph(): n = 6 m = 6 edges = [(1, 2), (1, 3), (2, 4), (3, 4), (4, 5), (5, 6)] assert longest_chain(n, m, edges) == 5","solution":"from collections import defaultdict, deque def longest_chain(n, m, edges): # Create graph from edges graph = defaultdict(list) in_degree = [0] * (n + 1) for a, b in edges: graph[a].append(b) in_degree[b] += 1 # Perform topological sort and calculate the longest chain longest_path = [1] * (n + 1) queue = deque() # Add all nodes with no incoming edges to the queue for i in range(1, n + 1): if in_degree[i] == 0: queue.append(i) while queue: current = queue.popleft() for neighbor in graph[current]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) longest_path[neighbor] = max(longest_path[neighbor], longest_path[current] + 1) return max(longest_path)"},{"question":"def longest_contiguous_subsequence_length(n: int, sequence: List[int]) -> int: Returns the length of the longest contiguous subsequence where all elements are contiguous in value. Parameters: n (int): The number of elements in the sequence. sequence (list of int): The sequence of distinct positive integers. Returns: int: The length of the longest subsequence with contiguous values.","solution":"def longest_contiguous_subsequence_length(n, sequence): Returns the length of the longest contiguous subsequence where all elements are contiguous in value. Parameters: n (int): The number of elements in the sequence. sequence (list of int): The sequence of distinct positive integers. Returns: int: The length of the longest subsequence with contiguous values. if not sequence or n == 0: return 0 sequence_set = set(sequence) longest_length = 0 for num in sequence: if num - 1 not in sequence_set: # Start of a new subsequence current_num = num current_length = 1 while current_num + 1 in sequence_set: current_num += 1 current_length += 1 longest_length = max(longest_length, current_length) return longest_length"},{"question":"def process_operations(n, q, heights, operations): Process the operations on the buildings heights and queries. >>> process_operations(5, 5, [1, 2, 3, 4, 5], [[1, 2, 4, 10], [2, 3], [1, 1, 3, 5], [2, 1], [2, 5]]) '13n6n5' >>> process_operations(3, 2, [1, 1, 1], [[1, 1, 1, 10], [2, 1]]) '11' >>> process_operations(4, 4, [2, 2, 2, 2], [[1, 1, 2, 3], [1, 3, 4, 5], [2, 2], [2, 4]]) '5n7' >>> process_operations(300000, 6, [1] * 300000, [[1, 1, 300000, 1], [1, 1, 300000, 1], [1, 1, 300000, 1], [2, 1], [2, 2], [2, 3]]) '4n4n4'","solution":"def process_operations(n, q, heights, operations): result = [] deltas = [0] * (n + 1) for op in operations: if op[0] == 1: l, r, v = op[1], op[2], op[3] deltas[l-1] += v if r < n: deltas[r] -= v elif op[0] == 2: i = op[1] - 1 result.append(str(heights[i] + sum(deltas[:i+1]))) return \\"n\\".join(result) def parse_input(input_str): lines = input_str.strip().split(\\"n\\") n, q = map(int, lines[0].split()) heights = list(map(int, lines[1].split())) operations = [list(map(int, line.split())) for line in lines[2:]] return n, q, heights, operations def main(input_str): n, q, heights, operations = parse_input(input_str) return process_operations(n, q, heights, operations)"},{"question":"def calculate_trapped_water(heights): Calculate how many units of water can be trapped after the rain given the heights of walls. Args: heights (List[int]): List of non-negative integers representing the heights of the walls. Returns: int: Total units of water that can be trapped. >>> calculate_trapped_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> calculate_trapped_water([4, 2, 0, 3, 2, 5]) 9 # Implement the function here def process_test_cases(t, test_cases): Process multiple test cases to calculate water trapped for each. Args: t (int): Number of test cases. test_cases (List[Tuple[int, List[int]]]): List of tuples where each tuple represents a test case. Returns: List[int]: List of results for each test case. >>> process_test_cases(2, [(6, [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]), (5, [4, 2, 0, 3, 2, 5])]) [6, 9] >>> process_test_cases(3, [(3, [1, 0, 1]), (4, [3, 0, 2, 0, 4]), (4, [1, 1, 1, 1])]) [1, 7, 0] # Implement the function here","solution":"def calculate_trapped_water(heights): n = len(heights) if n == 0: return 0 left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i-1], heights[i]) right_max[n-1] = heights[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped def process_test_cases(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] heights = test_cases[i][1] results.append(calculate_trapped_water(heights)) return results"},{"question":"def check_permutation_and_generate(A: List[int], B: List[int]) -> Union[str, Tuple[str, List[int]]]: Checks if there exists a permutation of array A such that the sum of the permutation and B is constant for every element. If such a permutation exists, returns ('YES', P) where P is the permutation. Otherwise, returns 'NO'. >>> check_permutation_and_generate([1, 2, 3], [4, 5, 6]) ('YES', [1, 2, 3]) # One of the possible outputs >>> check_permutation_and_generate([1, 2, 3], [1, 1, 1]) 'NO'","solution":"def check_permutation_and_generate(A, B): Checks if there exists a permutation of array A such that the sum of the permutation and B is constant for every element. If such a permutation exists, returns ('YES', P) where P is the permutation. Otherwise, returns 'NO'. # Sort A and B A_sorted = sorted(A) B_sorted = sorted(B) # Calculate the target sum C using the smallest elements C = A_sorted[0] + B_sorted[-1] # Create a dictionary to count occurrences in B from collections import Counter B_counter = Counter(B) P = [] # For every element in sorted A for a in A_sorted: b_needed = C - a if B_counter[b_needed] > 0: P.append(a) B_counter[b_needed] -= 1 else: return \\"NO\\" return \\"YES\\", P"},{"question":"def max_distance_in_k_days(n: int, k: int, distances: List[int]) -> int: Returns the maximum distance covered in any consecutive k days. Parameters: - n (int): The number of days. - k (int): The number of consecutive days. - distances (list of int): List of distances run each day. Returns: - int: The maximum distance covered in any consecutive k days. >>> max_distance_in_k_days(7, 3, [1, 2, 3, 4, 5, 6, 7]) 18 >>> max_distance_in_k_days(5, 1, [2, 3, 1, 4, 6]) 6","solution":"def max_distance_in_k_days(n, k, distances): Returns the maximum distance covered in any consecutive k days. Parameters: - n (int): The number of days. - k (int): The number of consecutive days. - distances (list of int): List of distances run each day. Returns: - int: The maximum distance covered in any consecutive k days. max_sum = current_sum = sum(distances[:k]) for i in range(k, n): current_sum = current_sum - distances[i - k] + distances[i] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def longest_balanced_segment(n: int, A: List[int]) -> int: Find the length of the longest balanced segment in the array. Args: n: The number of elements in the array. A: A list of integers. Returns: The length of the longest balanced segment, or -1 if no such segment exists. Example: >>> longest_balanced_segment(6, [1, -1, 2, -2, 3, -3]) 6 >>> longest_balanced_segment(5, [1, 2, 3, 4, 5]) -1","solution":"def longest_balanced_segment(n, A): # Dictionary to store the first occurrence of each prefix sum prefix_sums = {0: -1} prefix_sum = 0 max_length = -1 for i in range(n): prefix_sum += A[i] if prefix_sum in prefix_sums: max_length = max(max_length, i - prefix_sums[prefix_sum]) else: prefix_sums[prefix_sum] = i return max_length"},{"question":"def min_operations_to_balance(s: str) -> int: Determine the minimum number of operations needed to make the string of parentheses balanced. Parameters: s (str): The input string consisting of parentheses. Returns: int: The minimum number of insertions needed to balance the string. >>> min_operations_to_balance(\\"))((\\") 4 >>> min_operations_to_balance(\\"()\\") 0 >>> min_operations_to_balance(\\"(((\\") 3 >>> min_operations_to_balance(\\")))\\") 3 >>> min_operations_to_balance(\\"(()))(\\") 2 >>> min_operations_to_balance(\\"\\") 0 >>> min_operations_to_balance(\\"()()()()()()\\") 0 >>> min_operations_to_balance(\\")()()()()()(\\") 2","solution":"def min_operations_to_balance(s): Determine the minimum number of operations needed to make the string of parentheses balanced. Parameters: s (str): The input string consisting of parentheses. Returns: int: The minimum number of insertions needed to balance the string. open_needed, close_needed = 0, 0 for char in s: if char == '(': close_needed += 1 else: # char == ')' if close_needed > 0: close_needed -= 1 else: open_needed += 1 return open_needed + close_needed"},{"question":"def zigzag_sequence(n: int) -> List[int]: Generates the lexicographically smallest zigzag sequence of length n. :param n: Integer value representing the length of the zigzag sequence (1 <= n <= 1000) :return: List containing the lexicographically smallest zigzag sequence >>> zigzag_sequence(5) [1, 2, 5, 4, 3] >>> zigzag_sequence(6) [1, 2, 3, 6, 5, 4]","solution":"def zigzag_sequence(n): Generates the lexicographically smallest zigzag sequence of length n. :param n: Integer value representing the length of the zigzag sequence (1 <= n <= 1000) :return: List containing the lexicographically smallest zigzag sequence if n == 1: return [1] half = (n + 1) // 2 first_half = list(range(1, half + 1)) # strictly increasing part second_half = list(range(n, half, -1)) # strictly decreasing part return first_half + second_half"},{"question":"def can_convert(s: str, t: str) -> str: Determine if string s can be converted to string t by swapping characters. s: str - the original string t: str - the target string Returns: 'YES' if s can be converted to t, otherwise 'NO' >>> can_convert(\\"abcd\\", \\"dcba\\") == \\"YES\\" >>> can_convert(\\"abcde\\", \\"edcba\\") == \\"YES\\" >>> can_convert(\\"abc\\", \\"def\\") == \\"NO\\"","solution":"def can_convert(s, t): Determine if string s can be converted to string t by swapping characters. s: str - the original string t: str - the target string Returns: 'YES' if s can be converted to t, otherwise 'NO' # If the sorted versions of both strings are equal, # it means we can rearrange s to become t. if sorted(s) == sorted(t): return \\"YES\\" else: return \\"NO\\""},{"question":"def allocate_tasks(m: int, n: int, capacity: List[int], tasks: List[int]) -> str: Determine the optimal way to allocate tasks to stations over a period of days. Return \\"YES\\" followed by the schedule if possible, otherwise return \\"NO\\". >>> allocate_tasks(4, 3, [5, 8, 6, 7], [12, 10, 14]) 'YESn5 5 0 2n5 2 3 0n2 6 4 2' >>> allocate_tasks(4, 3, [1, 1, 1, 1], [5, 7, 8]) 'NO'","solution":"def allocate_tasks(m, n, capacity, tasks): allocatable_schedule = [] for day in range(n): total_task = tasks[day] day_schedule = [0] * m for i in range(m): if total_task == 0: break allocate_here = min(capacity[i], total_task) day_schedule[i] = allocate_here total_task -= allocate_here if total_task > 0: return \\"NO\\" allocatable_schedule.append(day_schedule) result = \\"YESn\\" for schedule in allocatable_schedule: result += \\" \\".join(map(str, schedule)) + \\"n\\" return result.strip() # Read Input input_lines = [ '4 3', '5 8 6 7', '12 10 14' ] m, n = map(int, input_lines[0].split()) capacity = list(map(int, input_lines[1].split())) tasks = list(map(int, input_lines[2].split())) # Output Result print(allocate_tasks(m, n, capacity, tasks))"},{"question":"import math def total_travel_distance(n: int, checkpoints: List[Tuple[int, int]]) -> float: Calculate the total travel distance to go through all checkpoints in sequence. Parameters: n: int -> the number of checkpoints checkpoints: List[Tuple[int, int]] -> list of tuples where each tuple contains the coordinates (x, y) of a checkpoint Returns: float -> total travel distance Example: >>> total_travel_distance(3, [(0, 0), (1, 1), (2, 2)]) 2.828427 >>> total_travel_distance(2, [(0, 0), (3, 4)]) 5.0 def test_example(): assert abs(total_travel_distance(3, [(0, 0), (1, 1), (2, 2)]) - 2.828427) < 1e-6 def test_two_points(): assert abs(total_travel_distance(2, [(0, 0), (3, 4)]) - 5.0) < 1e-6 def test_horizontal_line(): assert abs(total_travel_distance(5, [(0, 0), (1, 0), (2, 0), (3, 0), (4, 0)]) - 4.0) < 1e-6 def test_vertical_line(): assert abs(total_travel_distance(3, [(0, 0), (0, 2), (0, 5)]) - 5.0) < 1e-6 def test_diagonal_line(): assert abs(total_travel_distance(3, [(0, 0), (3, 3), (6, 6)]) - (math.sqrt(18) + math.sqrt(18))) < 1e-6 def test_large_coordinates(): assert abs(total_travel_distance(2, [(10000, 10000), (-10000, -10000)]) - (2 * math.sqrt(200000000))) < 1e-6","solution":"import math def total_travel_distance(n, checkpoints): Returns the total travel distance to go through all checkpoints in sequence. Parameters: n : int Number of checkpoints. checkpoints : list of tuples List of tuples where each tuple contains the coordinates (x, y) of a checkpoint. Returns: float Total travel distance. total_distance = 0.0 for i in range(1, n): x1, y1 = checkpoints[i-1] x2, y2 = checkpoints[i] total_distance += math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2) return total_distance"},{"question":"def bacteria_colony(m: int, n: int, k: int, initial_state: List[List[int]]) -> List[List[int]]: A colony of bacteria grows in a rectangular grid with dimensions m  n. Each cell in the grid can either be empty (denoted by 0) or contain a bacterium (denoted by 1). Over time, the bacteria spread to adjacent cells according to the following rules: 1. A bacterium in a cell will die if it has fewer than two adjacent bacteria (underpopulation) or more than three adjacent bacteria (overpopulation). 2. A bacterium in a cell survives to the next generation if it has exactly two or three adjacent bacteria. 3. An empty cell becomes populated with a bacterium if it has exactly three adjacent bacteria (reproduction). You are given the initial state of the grid and are asked to compute the state of the colony after k generations. Args: - m: Number of rows in the grid. - n: Number of columns in the grid. - k: Number of generations. - initial_state: Initial state of the grid. Returns: - The state of the grid after k generations. >>> bacteria_colony(4, 5, 1, [ ... [0, 1, 0, 0, 0], ... [0, 0, 1, 0, 0], ... [1, 1, 1, 0, 0], ... [0, 0, 0, 0, 0] ... ]) # doctest: +NORMALIZE_WHITESPACE [ [0, 0, 0, 0, 0], [1, 0, 1, 0, 0], [0, 1, 1, 0, 0], [0, 1, 0, 0, 0] ] >>> bacteria_colony(3, 3, 1, [ ... [0, 0, 0], ... [0, 1, 1], ... [0, 1, 1] ... ]) # doctest: +NORMALIZE_WHITESPACE [ [0, 0, 0], [0, 1, 1], [0, 1, 1] ] >>> bacteria_colony(3, 3, 1, [ ... [1, 1, 1], ... [1, 0, 1], ... [1, 1, 1] ... ]) # doctest: +NORMALIZE_WHITESPACE [ [1, 0, 1], [0, 0, 0], [1, 0, 1] ] >>> bacteria_colony(2, 2, 0, [ ... [1, 0], ... [0, 1] ... ]) # doctest: +NORMALIZE_WHITESPACE [ [1, 0], [0, 1] ]","solution":"def get_next_state(grid): Given the current state of the grid, compute the state for the next generation. m, n = len(grid), len(grid[0]) next_grid = [[0] * n for _ in range(m)] def count_adjacent_bacteria(x, y): directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] count = 0 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n: count += grid[nx][ny] return count for i in range(m): for j in range(n): adjacent_count = count_adjacent_bacteria(i, j) if grid[i][j] == 1: if 2 <= adjacent_count <= 3: next_grid[i][j] = 1 else: next_grid[i][j] = 0 else: if adjacent_count == 3: next_grid[i][j] = 1 return next_grid def bacteria_colony(m, n, k, initial_state): current_state = initial_state for _ in range(k): current_state = get_next_state(current_state) return current_state def print_grid(grid): for row in grid: print(\\" \\".join(map(str, row))) # Example usage if __name__ == \\"__main__\\": m, n, k = 4, 5, 1 initial_state = [ [0, 1, 0, 0, 0], [0, 0, 1, 0, 0], [1, 1, 1, 0, 0], [0, 0, 0, 0, 0] ] result = bacteria_colony(m, n, k, initial_state) print_grid(result)"},{"question":"def can_group_into_pairs(n: int, array: List[int]) -> bool: Given an array of integers, check if it can be grouped into pairs of equal integers. >>> can_group_into_pairs(6, [1, 2, 2, 3, 3, 1]) True >>> can_group_into_pairs(5, [1, 2, 2, 3, 1]) False >>> can_group_into_pairs(1, [1]) False >>> can_group_into_pairs(4, [4, 4, 4, 4]) True >>> can_group_into_pairs(8, [3, 3, 1, 1, 2, 2, 4, 4]) True >>> can_group_into_pairs(7, [3, 3, 1, 1, 2, 2, 4]) False","solution":"def can_group_into_pairs(n, array): This function returns True if the array can be grouped into pairs of equal integers, otherwise False. from collections import Counter # Count each element's occurrences counts = Counter(array) # Check if all counts are even for count in counts.values(): if count % 2 != 0: return False return True"},{"question":"def find_best_viewing_block(n: int, p: int, heights: List[int], explosions: List[int]) -> int: Determines the best block for watching the fireworks to maximize the viewing experience. Parameters: n (int): Number of blocks p (int): Penalty factor for the height heights (list of int): Heights of the blocks explosions (list of int): Number of explosions visible from each block Returns: int: Index of the block that maximizes the viewing experience (1-based index) Examples: >>> find_best_viewing_block(5, 2, [10, 30, 20, 40, 50], [100, 200, 150, 80, 60]) 2 >>> find_best_viewing_block(1, 0, [10], [100]) 1","solution":"def find_best_viewing_block(n, p, heights, explosions): Determines the best block for watching the fireworks to maximize the viewing experience. Parameters: n (int): Number of blocks p (int): Penalty factor for the height heights (list of int): Heights of the blocks explosions (list of int): Number of explosions visible from each block Returns: int: Index of the block that maximizes the viewing experience (1-based index) max_quality = float('-inf') best_block_index = -1 for i in range(n): current_quality = explosions[i] - p * heights[i] if current_quality > max_quality: max_quality = current_quality best_block_index = i elif current_quality == max_quality: best_block_index = min(best_block_index, i) return best_block_index + 1"},{"question":"def min_books_to_remove(n: int, heights: List[int]) -> int: Returns the minimum number of books to remove to have the heights in a non-decreasing order. >>> min_books_to_remove(5, [4, 3, 2, 3, 4]) == 2 >>> min_books_to_remove(4, [5, 5, 5, 5]) == 0 >>> min_books_to_remove(5, [1, 2, 3, 4, 5]) == 0 >>> min_books_to_remove(4, [4, 3, 2, 1]) == 3 >>> min_books_to_remove(7, [1, 5, 3, 4, 6, 4, 7]) == 2 >>> min_books_to_remove(1, [4]) == 0","solution":"def min_books_to_remove(n, heights): Returns the minimum number of books to remove to have the heights in a non-decreasing order. if n == 0: return 0 import bisect lis = [] for height in heights: pos = bisect.bisect_right(lis, height) if pos < len(lis): lis[pos] = height else: lis.append(height) length_of_lis = len(lis) return n - length_of_lis # Example usage if __name__ == \\"__main__\\": n = 5 heights = [4, 3, 2, 3, 4] print(min_books_to_remove(n, heights)) # Output: 2"},{"question":"def shifted_fibonacci(a1: int, a2: int, k: int, m: int) -> int: Given the first two terms a1, a2 of the shifted fibonacci sequence and constant k, this function returns the m-th term of the sequence. >>> shifted_fibonacci(2, 3, 1, 5) 17 >>> shifted_fibonacci(2, 3, -1, 4) 6 >>> shifted_fibonacci(2, 3, 0, 5) 13","solution":"def shifted_fibonacci(a1, a2, k, m): Given the first two terms a1, a2 of the shifted fibonacci sequence and constant k, this function returns the m-th term of the sequence. if m == 1: return a1 elif m == 2: return a2 terms = [a1, a2] for i in range(2, m): next_term = terms[-1] + terms[-2] + k terms.append(next_term) return terms[m - 1]"},{"question":"def game_result(n: int, m: int) -> Tuple[int, int]: Returns the number of 'A's and 'B's on an n x m grid when Alice and Bob play optimally. >>> game_result(4, 4) (8, 8) >>> game_result(2, 3) (3, 3)","solution":"def game_result(n, m): Returns the number of 'A's and 'B's on an n x m grid when Alice and Bob play optimally. # When Alice and Bob both play optimally, they can fill the grid in a checkerboard pattern. max_as = (n * m + 1) // 2 # Maximum number of 'A's max_bs = (n * m) // 2 # Maximum number of 'B's return max_as, max_bs"},{"question":"def is_balanced_parentheses(s: str) -> str: Determines if a string of parentheses is balanced. Args: s: A string consisting of characters '(' and ')' Returns: 'YES' if the string is balanced, 'NO' otherwise >>> is_balanced_parentheses(\\"()\\") == 'YES' >>> is_balanced_parentheses(\\"(())\\") == 'YES' >>> is_balanced_parentheses(\\"(()\\") == 'NO' >>> is_balanced_parentheses(\\"))\\") == 'NO' >>> is_balanced_parentheses(\\"\\") == 'YES' from solution import is_balanced_parentheses def test_balanced_parentheses(): assert is_balanced_parentheses(\\"()\\") == 'YES' assert is_balanced_parentheses(\\"(())\\") == 'YES' assert is_balanced_parentheses(\\"(()(()))\\") == 'YES' assert is_balanced_parentheses(\\"()()\\") == 'YES' def test_unbalanced_parentheses(): assert is_balanced_parentheses(\\"(()\\") == 'NO' assert is_balanced_parentheses(\\"())\\") == 'NO' assert is_balanced_parentheses(\\"(()()(())\\") == 'NO' def test_empty_string(): assert is_balanced_parentheses(\\"\\") == 'YES' def test_only_opening_parentheses(): assert is_balanced_parentheses(\\"((((\\") == 'NO' def test_only_closing_parentheses(): assert is_balanced_parentheses(\\"))))\\") == 'NO' def test_large_balanced_string(): assert is_balanced_parentheses(\\"()\\" * (10**5)) == 'YES' def test_large_unbalanced_string(): assert is_balanced_parentheses(\\"()(\\" * (10**5)) == 'NO'","solution":"def is_balanced_parentheses(s): Determines if a string of parentheses is balanced. Args: s: A string consisting of characters '(' and ')' Returns: 'YES' if the string is balanced, 'NO' otherwise stack = [] for char in s: if char == '(': stack.append(char) elif char == ')': if not stack: return 'NO' stack.pop() return 'YES' if not stack else 'NO'"},{"question":"from typing import List, Tuple class RMQ: def __init__(self, array: List[int]): self.array = array self.n = len(array) self.sparse_table = self.build_sparse_table() def build_sparse_table(self) -> List[List[int]]: from math import log2, floor n = self.n max_log = floor(log2(n)) + 1 sparse_table = [[0] * max_log for _ in range(n)] for i in range(n): sparse_table[i][0] = self.array[i] j = 1 while (1 << j) <= n: i = 0 while (i + (1 << j) - 1) < n: sparse_table[i][j] = max(sparse_table[i][j-1], sparse_table[i + (1 << (j-1))][j-1]) i += 1 j += 1 return sparse_table def query(self, l: int, r: int) -> int: from math import log2, floor l -= 1 r -= 1 length = r - l + 1 log = floor(log2(length)) return max(self.sparse_table[l][log], self.sparse_table[r - (1 << log) + 1][log]) def process_queries(n: int, q: int, array: List[int], queries: List[Tuple[int, int]]) -> List[int]: Process multiple queries to find the maximum value in specified subarrays. Args: n: The number of elements in the array. q: The number of queries. array: List of integers representing the elements of the array. queries: List of tuples where each tuple contains two integers (l, r) representing the range of the query. Returns: A list of integers where each integer is the maximum value for the corresponding query. Examples: >>> process_queries(5, 3, [1, 2, 3, 4, 5], [(1, 3), (2, 4), (1, 5)]) [3, 4, 5] >>> process_queries(5, 3, [5, 4, 3, 2, 1], [(1, 3), (2, 4), (1, 5)]) [5, 4, 5]","solution":"class RMQ: def __init__(self, array): self.array = array self.n = len(array) self.sparse_table = self.build_sparse_table() def build_sparse_table(self): from math import log2, floor n = self.n max_log = floor(log2(n)) + 1 sparse_table = [[0] * max_log for _ in range(n)] for i in range(n): sparse_table[i][0] = self.array[i] j = 1 while (1 << j) <= n: i = 0 while (i + (1 << j) - 1) < n: sparse_table[i][j] = max(sparse_table[i][j-1], sparse_table[i + (1 << (j-1))][j-1]) i += 1 j += 1 return sparse_table def query(self, l, r): from math import log2, floor l -= 1 r -= 1 length = r - l + 1 log = floor(log2(length)) return max(self.sparse_table[l][log], self.sparse_table[r - (1 << log) + 1][log]) def process_queries(n, q, array, queries): results = [] rmq = RMQ(array) for query in queries: l, r = query results.append(rmq.query(l, r)) return results"},{"question":"def min_time_to_destination(n: int, m: int, sx: int, sy: int, dx: int, dy: int, obstacles: List[Tuple[int, int]]) -> int: Find the minimum time to reach the destination in a grid avoiding obstacles. Args: n (int): number of rows in the grid m (int): number of columns in the grid sx (int): starting row index sy (int): starting column index dx (int): destination row index dy (int): destination column index obstacles (List[Tuple[int, int]]): list of obstacle coordinates Returns: int: the minimum time needed to reach the destination, or -1 if it's impossible >>> min_time_to_destination(5, 4, 0, 0, 4, 3, [(1, 0), (2, 2), (3, 3)]) 7 >>> min_time_to_destination(5, 4, 0, 0, 4, 3, []) 7 >>> min_time_to_destination(5, 4, 0, 0, 4, 3, [(1, 0), (1, 1), (1, 2), (1, 3), (2, 2), (3, 3)]) -1 >>> min_time_to_destination(5, 4, 0, 0, 0, 0, []) 0 >>> min_time_to_destination(1, 1, 0, 0, 0, 0, []) 0","solution":"from collections import deque def min_time_to_destination(n, m, sx, sy, dx, dy, obstacles): Find the minimum time to reach destination in a grid avoiding obstacles. directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # up, down, left, right grid = [[0 for _ in range(m)] for _ in range(n)] # Mark obstacles on the grid for ox, oy in obstacles: grid[ox][oy] = -1 # BFS setup queue = deque([(sx, sy, 0)]) # (current x, current y, current time) visited = set((sx, sy)) while queue: x, y, time = queue.popleft() # Check if we've reached the destination if (x, y) == (dx, dy): return time # Explore all four directions for direction in directions: new_x, new_y = x + direction[0], y + direction[1] # Check if the new position is inside the grid and is not an obstacle or visited if 0 <= new_x < n and 0 <= new_y < m and grid[new_x][new_y] != -1 and (new_x, new_y) not in visited: visited.add((new_x, new_y)) queue.append((new_x, new_y, time + 1)) # If we've exhausted all possibilities, return -1 return -1"},{"question":"def is_palindrome(s: str) -> str: Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. A palindrome reads the same backward as forward ignoring spaces, punctuation, and capitalization. >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") == \\"YES\\" >>> is_palindrome(\\"race a car\\") == \\"NO\\" >>> is_palindrome(\\"\\") == \\"YES\\" >>> is_palindrome(\\"a\\") == \\"YES\\" >>> is_palindrome(\\"A\\") == \\"YES\\" >>> is_palindrome(\\"12321\\") == \\"YES\\" >>> is_palindrome(\\"12345\\") == \\"NO\\" >>> is_palindrome(\\"Madam, In Eden, I'm Adam\\") == \\"YES\\" >>> is_palindrome(\\"No 'x' in Nixon\\") == \\"YES\\" >>> is_palindrome(\\"!!!@@@...\\") == \\"YES\\"","solution":"def is_palindrome(s): Returns \\"YES\\" if the string s is a palindrome, considering only alphanumeric characters and ignoring cases. Otherwise, returns \\"NO\\". # Remove non-alphanumeric characters and convert to lower case cleaned_s = ''.join(char.lower() for char in s if char.isalnum()) # Check if the cleaned string is the same forward and backward if cleaned_s == cleaned_s[::-1]: return \\"YES\\" return \\"NO\\""},{"question":"from typing import List, Tuple def largest_connected_component(n: int, m: int, edges: List[Tuple[int, int]]) -> Tuple[int, List[int]]: Given an undirected graph with n nodes and m edges, find all the nodes that are part of the largest connected component. The output should consist of two elements: - The size of the largest connected component. - The nodes of the largest connected component in any order. >>> largest_connected_component(6, 5, [(1, 2), (2, 3), (1, 3), (4, 5), (4, 6)]) (3, [1, 2, 3]) >>> largest_connected_component(8, 7, [(1, 2), (2, 3), (3, 4), (4, 5), (6, 7), (7, 8), (6, 8)]) (5, [1, 2, 3, 4, 5])","solution":"def largest_connected_component(n, m, edges): from collections import defaultdict, deque # Create an adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) def bfs(start): queue = deque([start]) visited = set([start]) component = [] while queue: node = queue.popleft() component.append(node) for neighbor in graph[node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) return component visited_global = set() largest_component = [] for node in range(1, n+1): if node not in visited_global: component = bfs(node) visited_global.update(component) if len(component) > len(largest_component): largest_component = component print(len(largest_component)) print(\\" \\".join(map(str, largest_component))) return len(largest_component), sorted(largest_component)"},{"question":"def max_subarray_sum_not_exceeding_k(n: int, k: int, arr: List[int]) -> int: Returns the maximum possible sum of a subarray that does not exceed k. n: int - number of elements in the array k: int - the maximum allowed sum arr: list - the array of integers >>> max_subarray_sum_not_exceeding_k(5, 10, [1, 2, 3, 4, 5]) 10 >>> max_subarray_sum_not_exceeding_k(1, 1, [1]) 1 >>> max_subarray_sum_not_exceeding_k(4, 10, [2, 2, 2, 2]) 8 >>> max_subarray_sum_not_exceeding_k(3, 5, [3, 3, 3]) 3 >>> max_subarray_sum_not_exceeding_k(4, 1000000000, [1000000000, 1000000000, 1000000000, 1000000000]) 1000000000 >>> max_subarray_sum_not_exceeding_k(3, 9, [2, 3, 4]) 9 >>> max_subarray_sum_not_exceeding_k(0, 10, []) 0","solution":"def max_subarray_sum_not_exceeding_k(n, k, arr): Returns the maximum possible sum of a subarray that does not exceed k. n: int - number of elements in the array k: int - the maximum allowed sum arr: list - the array of integers max_sum = 0 current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum > k and start <= end: current_sum -= arr[start] start += 1 if current_sum <= k: max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def can_form_pairs(n, card_values): Determines if it is possible to form pairs of cards such that the sum of the values of the cards in each pair equals zero. Parameters: n (int): Number of cards each player initially has (that is, half of the total cards) card_values (list of int): List of 2n integers representing the card values Returns: str: \\"YES\\" if it is possible to form the required pairs, otherwise \\"NO\\" Examples: >>> can_form_pairs(4, [1, 2, -1, -2, 3, -3, 4, -4]) 'YES' >>> can_form_pairs(3, [1, 2, 3, -1, -2, -4]) 'NO'","solution":"def can_form_pairs(n, card_values): Determines if it is possible to form pairs of cards such that the sum of the values of the cards in each pair equals zero. Parameters: n (int): Number of cards each player initially has (that is, half of the total cards) card_values (list of int): List of 2n integers representing the card values Returns: str: \\"YES\\" if it is possible to form the required pairs, otherwise \\"NO\\" from collections import Counter card_counts = Counter(card_values) for card in card_counts: if card_counts[card] != card_counts[-card]: return \\"NO\\" return \\"YES\\""},{"question":"def robot_returns_to_origin(moves: str) -> str: Determines if the robot returns to the origin after executing the moves. :param moves: A string consisting of characters 'U', 'D', 'L', 'R' :return: \\"YES\\" if robot returns to origin, otherwise \\"NO\\" >>> robot_returns_to_origin(\\"UD\\") \\"YES\\" >>> robot_returns_to_origin(\\"LL\\") \\"NO\\" >>> robot_returns_to_origin(\\"UDLR\\") \\"YES\\" >>> robot_returns_to_origin(\\"UUDDLLRR\\") \\"YES\\"","solution":"def robot_returns_to_origin(moves): Determines if the robot returns to the origin after executing the moves. :param moves: A string consisting of characters 'U', 'D', 'L', 'R' :return: \\"YES\\" if robot returns to origin, otherwise \\"NO\\" u_count = moves.count('U') d_count = moves.count('D') l_count = moves.count('L') r_count = moves.count('R') if u_count == d_count and l_count == r_count: return \\"YES\\" else: return \\"NO\\""},{"question":"from typing import List def min_moves(n: int, sx: int, sy: int, tx: int, ty: int, grid: List[List[int]]) -> int: Determines the minimum number of moves required for a drone to travel from the starting point (sx, sy) to the target point (tx, ty) on an n x n grid. Returns -1 if no such path exists. Args: n (int): The size of the grid. sx (int): The starting x coordinate. sy (int): The starting y coordinate. tx (int): The target x coordinate. ty (int): The target y coordinate. grid (List[List[int]]): The n x n grid where 0 represents a navigable block and 1 represents a blocked block. Returns: int: The minimum number of moves required or -1 if no path exists. # Implementation goes here import unittest class TestMinMoves(unittest.TestCase): def test_example_case(self): n = 5 sx, sy, tx, ty = 1, 1, 5, 5 grid = [ [0, 0, 1, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 0, 0], [1, 1, 0, 1, 1], [0, 0, 0, 0, 0] ] self.assertEqual(min_moves(n, sx, sy, tx, ty, grid), 8) def test_no_path(self): n = 5 sx, sy, tx, ty = 1, 1, 5, 5 grid = [ [0, 0, 1, 0, 0], [0, 1, 1, 1, 0], [0, 1, 0, 0, 0], [1, 1, 0, 1, 1], [0, 0, 0, 1, 0] ] self.assertEqual(min_moves(n, sx, sy, tx, ty, grid), -1) def test_start_or_end_blocked(self): n = 5 sx, sy, tx, ty = 1, 1, 5, 5 grid = [ [1, 0, 1, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 0, 0], [1, 1, 0, 1, 1], [0, 0, 0, 0, 0] ] self.assertEqual(min_moves(n, sx, sy, tx, ty, grid), -1) # Start is blocked grid = [ [0, 0, 1, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 0, 0], [1, 1, 0, 1, 1], [0, 0, 0, 1, 1] ] self.assertEqual(min_moves(n, sx, sy, tx, ty, grid), -1) # End is blocked def test_no_moves_needed(self): n = 5 sx, sy, tx, ty = 1, 1, 1, 1 grid = [ [0, 0, 1, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 0, 0], [1, 1, 0, 1, 1], [0, 0, 0, 0, 0] ] self.assertEqual(min_moves(n, sx, sy, tx, ty, grid), 0) # Already at the target def test_large_grid(self): n = 1000 sx, sy, tx, ty = 1, 1, 1000, 1000 grid = [[0]*n for _ in range(n)] self.assertEqual(min_moves(n, sx, sy, tx, ty, grid), 1998) # Clear path in an empty large grid if __name__ == \\"__main__\\": unittest.main()","solution":"from collections import deque def min_moves(n, sx, sy, tx, ty, grid): Determines the minimum number of moves required for a drone to travel from start point (sx, sy) to target point (tx, ty) on an n x n grid. Returns -1 if no such path exists. # Convert to 0-based indexing for processing sx, sy, tx, ty = sx - 1, sy - 1, tx - 1, ty - 1 if grid[sx][sy] == 1 or grid[tx][ty] == 1: return -1 # Directions: up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Queue for BFS queue = deque([(sx, sy, 0)]) # (x, y, steps) visited = [[False] * n for _ in range(n)] visited[sx][sy] = True while queue: x, y, steps = queue.popleft() if (x, y) == (tx, ty): return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] == 0: queue.append((nx, ny, steps + 1)) visited[nx][ny] = True return -1"},{"question":"def maxProfit(prices: List[int]) -> int: Determines the maximum profit from buying and selling stock over a period of days. :param prices: A list of integers representing the stock prices on sequential days. :return: An integer representing the maximum profit achievable. >>> maxProfit([7, 1, 5, 3, 6, 4]) == 5 >>> maxProfit([7, 6, 5, 4, 3, 2, 1]) == 0 >>> maxProfit([1, 2, 3, 4, 5, 6]) == 5 >>> maxProfit([]) == 0 >>> maxProfit([5]) == 0 >>> maxProfit([5, 5, 5, 5, 5]) == 0 >>> maxProfit([3, 2, 6, 1, 4]) == 4 >>> maxProfit([5, 4, 3, 1, 6, 7, 8]) == 7","solution":"from typing import List def maxProfit(prices: List[int]) -> int: Determines the maximum profit from buying and selling stock over a period of days. :param prices: A list of integers representing the stock prices on sequential days. :return: An integer representing the maximum profit achievable. if not prices: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"from typing import List def find_subarray(nums: List[int], threshold: int) -> List[int]: Find a subarray (contiguous elements) such that the sum of the integers in the subarray is divisible by the threshold value. >>> find_subarray([10, 5, 3, -2, 6, -1], 5) [10, 5, -2] >>> find_subarray([1, 2, 3], 10) [] >>> find_subarray([10], 10) [10] >>> find_subarray([1, 2, 3, 4], 10) [1, 2, 3, 4] >>> find_subarray([1, 3, 9, 4, 2], 6) [3, 9]","solution":"from typing import List def find_subarray(nums: List[int], threshold: int) -> List[int]: Find a subarray (contiguous elements) such that the sum of the integers in the subarray is divisible by the threshold value. # Iterate through all possible subarrays n = len(nums) for i in range(n): current_sum = 0 for j in range(i, n): current_sum += nums[j] if current_sum % threshold == 0: return nums[i:j+1] return []"},{"question":"from typing import List, Tuple from collections import deque def get_farthest_node(start: int, adjacency_list: List[List[int]]) -> Tuple[int, int]: Perform BFS and return the farthest node and its distance from the start node. pass def tree_diameter(n: int, edges: List[Tuple[int, int]]) -> int: Given the number of nodes and the list of edges for a tree, return its diameter. >>> tree_diameter(6, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6)]) == 4 >>> tree_diameter(2, [(1, 2)]) == 1 >>> tree_diameter(7, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)]) == 4 >>> tree_diameter(5, [(1, 2), (2, 3), (3, 4), (4, 5)]) == 4 >>> tree_diameter(5, [(1, 2), (1, 3), (1, 4), (1, 5)]) == 2 pass","solution":"from collections import deque def get_farthest_node(start, adjacency_list): Perform BFS and return the farthest node and its distance from the start node. n = len(adjacency_list) visited = [False] * (n + 1) queue = deque([(start, 0)]) visited[start] = True farthest_node = start max_distance = 0 while queue: node, distance = queue.popleft() if distance > max_distance: farthest_node = node max_distance = distance for neighbor in adjacency_list[node]: if not visited[neighbor]: visited[neighbor] = True queue.append((neighbor, distance + 1)) return farthest_node, max_distance def tree_diameter(n, edges): Given the number of nodes and the list of edges for a tree, return its diameter. # Create adjacency list adjacency_list = [[] for _ in range(n + 1)] for u, v in edges: adjacency_list[u].append(v) adjacency_list[v].append(u) # Step 1: Find any farthest node from an arbitrary start node (1 in this case) farthest_node, _ = get_farthest_node(1, adjacency_list) # Step 2: Find the farthest node from the node found in step 1 and its distance _, diameter = get_farthest_node(farthest_node, adjacency_list) return diameter"},{"question":"def max_pairs(n: int) -> int: Returns the maximum number of pairs that can be formed such that the sum of numbers on their name tags is the same for each pair. >>> max_pairs(6) 3 >>> max_pairs(5) 2 >>> max_pairs(1) 0 >>> max_pairs(100000) 50000 def test_even_number_of_people(): assert max_pairs(6) == 3 assert max_pairs(8) == 4 assert max_pairs(10) == 5 def test_odd_number_of_people(): assert max_pairs(5) == 2 assert max_pairs(7) == 3 assert max_pairs(9) == 4 def test_small_number_of_people(): assert max_pairs(1) == 0 assert max_pairs(2) == 1 assert max_pairs(3) == 1 def test_large_number_of_people(): assert max_pairs(100000) == 50000 assert max_pairs(200000) == 100000","solution":"def max_pairs(n): Returns the maximum number of pairs that can be formed such that the sum of numbers on their name tags is the same for each pair. return n // 2"},{"question":"def generate_leaderboard(n: int, results: List[str]) -> List[str]: Generate a leaderboard based on the given results. >>> generate_leaderboard(5, [\\"alice 1 250\\", \\"bob 2 300\\", \\"alice 2 150\\", \\"charlie 1 300\\", \\"bob 1 100\\"]) [\\"alice 400\\", \\"bob 400\\", \\"charlie 300\\"] >>> generate_leaderboard(3, [\\"zara 2 500\\", \\"anna 1 100\\", \\"anna 2 200\\"]) [\\"zara 500\\", \\"anna 300\\"] >>> generate_leaderboard(4, [\\"dan 1 100\\", \\"bill 1 200\\", \\"steve 1 100\\", \\"mark 1 200\\"]) [\\"bill 200\\", \\"mark 200\\", \\"dan 100\\", \\"steve 100\\"] >>> generate_leaderboard(1, [\\"john 1 100\\"]) [\\"john 100\\"] >>> generate_leaderboard(4, [\\"alice 1 100\\", \\"bob 2 100\\", \\"alice 2 150\\", \\"bob 1 150\\"]) [\\"alice 250\\", \\"bob 250\\"]","solution":"def generate_leaderboard(n, results): from collections import defaultdict scores = defaultdict(int) for result in results: name, problem_number, score = result.split() score = int(score) scores[name] += score leaderboard = sorted(scores.items(), key=lambda item: (-item[1], item[0])) return [f\\"{name} {total_score}\\" for name, total_score in leaderboard]"},{"question":"def maximum_sum_subgrid(n: int, m: int, grid: List[List[int]]) -> int: Find the maximum sum of any subgrid within the grid. >>> maximum_sum_subgrid(3, 3, [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == 45 >>> maximum_sum_subgrid(2, 3, [ ... [1, -2, 3], ... [-4, 5, -6] ... ]) == 5","solution":"def maximum_sum_subgrid(n, m, grid): def kadane(arr): max_ending_here = max_so_far = arr[0] for x in arr[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far max_sum = float('-inf') for left in range(m): temp = [0] * n for right in range(left, m): for i in range(n): temp[i] += grid[i][right] max_sum = max(max_sum, kadane(temp)) return max_sum # Example usage: n = 3 m = 3 grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] print(maximum_sum_subgrid(n, m, grid))"},{"question":"def longest_palindrome_subsequence_length(s: str, queries: List[Tuple[int, int]]) -> List[int]: For a given string, process a series of queries to find the length of the longest palindrome that can be formed by any subsequence of the specified substring. Args: s (str): The string in which substrings are taken. queries (List[Tuple[int, int]]): A list of queries where each query is a tuple (l, r) representing the start and end indices (inclusive) of the substring. Returns: List[int]: A list of integers where each integer is the length of the longest palindrome that can be formed from the characters in the specified substring. Example: >>> longest_palindrome_subsequence_length(\\"abacaba\\", [(1, 7), (2, 5), (3, 3)]) [7, 3, 1] >>> longest_palindrome_subsequence_length(\\"abcdefgh\\", [(1, 1), (2, 2), (8, 8)]) [1, 1, 1]","solution":"def longest_palindrome_subsequence_length(s, queries): def longest_palindrome_length(sub): count = {} for char in sub: count[char] = count.get(char, 0) + 1 length = 0 odd_found = False for cnt in count.values(): length += (cnt // 2) * 2 if cnt % 2 == 1: odd_found = True return length + 1 if odd_found else length results = [] for l, r in queries: substring = s[l-1:r] results.append(longest_palindrome_length(substring)) return results"},{"question":"def find_single_element(arr: List[int]) -> int: Finds the single non-duplicate number in the array using bit manipulation. >>> find_single_element([1, 2, 2, 1, 3]) == 3 >>> find_single_element([4, 3, 2, 4, 2]) == 3 >>> find_single_element([7]) == 7 >>> find_single_element([1000000000, -1000000000, -1000000000, 1000000000, 123456789]) == 123456789 >>> find_single_element([-1, 1, -1, -2, 2, 2, 1]) == -2","solution":"def find_single_element(arr): Finds the single non-duplicate element in the array. unique_element = 0 for num in arr: unique_element ^= num return unique_element"},{"question":"def find_min_lambda(n: int, edges: List[Tuple[int, int, int]]) -> int: Function to find the smallest value of lambda such that there exists a subset of edges E' that forms a tree, and lambda is the maximum weight of an edge in the subset. :param n: Number of nodes :param edges: List of tuples (u, v, w) representing undirected edges :return: The minimum value of lambda if a tree can be formed, else -1 pass # Unit tests def test_single_node(): assert find_min_lambda(1, []) == 0 def test_no_edges(): assert find_min_lambda(2, []) == -1 def test_simple_tree(): edges = [(1, 2, 1), (2, 3, 2), (3, 4, 3)] assert find_min_lambda(4, edges) == 3 def test_min_lambda(): edges = [(1, 2, 1), (1, 3, 1), (2, 3, 2), (2, 4, 2), (3, 4, 3)] assert find_min_lambda(4, edges) == 2 def test_no_possible_tree(): edges = [(1, 2, 1), (2, 3, 2)] assert find_min_lambda(4, edges) == -1 def test_large_weights(): edges = [(1, 2, 1000000), (2, 3, 999999), (3, 4, 999998), (4, 5, 999997), (5, 6, 999996)] assert find_min_lambda(6, edges) == 1000000","solution":"def find_min_lambda(n, edges): Function to find the smallest value of lambda such that there exists a subset of edges E' that forms a tree, and lambda is the maximum weight of an edge in the subset. :param n: Number of nodes :param edges: List of tuples (u, v, w) representing undirected edges :return: The minimum value of lambda if a tree can be formed, else -1 if n == 1: return 0 # A single node is a trivial tree with lambda = 0 # Edge case: if there are less than n-1 edges, it's impossible to form a tree if len(edges) < n - 1: return -1 # Helper function for Kruskal's algorithm to form MST def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 # Sort edges by their weight edges = sorted(edges, key=lambda item: item[2]) # Kruskal's algorithm to find MST parent = [] rank = [] for node in range(n): parent.append(node) rank.append(0) mst = [] i = e = 0 while e < n - 1 and i < len(edges): u, v, w = edges[i] i += 1 x = find(parent, u - 1) y = find(parent, v - 1) if x != y: e += 1 mst.append((u, v, w)) union(parent, rank, x, y) # If we don't have exactly n-1 edges in MST, it means we can't connect all nodes if len(mst) != n - 1: return -1 # The lambda value is the weight of the heaviest edge in the MST max_weight_in_mst = max(mst, key=lambda item: item[2])[2] return max_weight_in_mst"},{"question":"def longest_balanced_subsequence(s: str) -> int: Returns the length of the longest contiguous subsequence in the DNA string such that it contains equal numbers of 'A's and 'T's, and equal numbers of 'C's and 'G's. >>> longest_balanced_subsequence(\\"ATCGTACG\\") 8 >>> longest_balanced_subsequence(\\"ATCGACTG\\") 8 >>> longest_balanced_subsequence(\\"ATCGTCAG\\") 8 >>> longest_balanced_subsequence(\\"AAAA\\") 0 >>> longest_balanced_subsequence(\\"ATCGATCG\\") 8","solution":"def longest_balanced_subsequence(s): Returns the length of the longest contiguous subsequence in the DNA string such that it contains equal numbers of 'A's and 'T's, and equal numbers of 'C's and 'G's. n = len(s) # Convert characters to the difference in counts diff_map = {'A': 1, 'T': -1, 'C': 2, 'G': -2} prefix_sum = [0] * (n + 1) for i in range(1, n + 1): prefix_sum[i] = prefix_sum[i - 1] + diff_map[s[i - 1]] seen = {} max_length = 0 for i in range(n + 1): if prefix_sum[i] in seen: max_length = max(max_length, i - seen[prefix_sum[i]]) else: seen[prefix_sum[i]] = i return max_length"},{"question":"from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_root_to_leaf_sum(root: Optional[TreeNode]) -> int: Returns the maximum sum of values from the root to any leaf in the binary tree. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> max_root_to_leaf_sum(root) 8 >>> root = TreeNode(10) >>> root.left = TreeNode(5) >>> root.right = TreeNode(15) >>> root.right.left = TreeNode(10) >>> root.right.right = TreeNode(20) >>> max_root_to_leaf_sum(root) 45","solution":"from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_root_to_leaf_sum(root: Optional[TreeNode]) -> int: Returns the maximum sum of values from the root to any leaf in the binary tree. if not root: return 0 def dfs(node): if not node: return 0 if not node.left and not node.right: return node.val if not node.left: return node.val + dfs(node.right) if not node.right: return node.val + dfs(node.left) return node.val + max(dfs(node.left), dfs(node.right)) return dfs(root)"},{"question":"from typing import List, Tuple def precompute_even_prefix_sums(arr: List[int]) -> List[int]: Precompute the prefix sums of even numbers in the given array. ... def query_even_sum(even_prefix_sums: List[int], l: int, r: int) -> int: Query the sum of even numbers in the segment of the array from index l to index r, inclusive. ... def process_queries(n: int, arr: List[int], queries: List[Tuple[int, int]]) -> List[int]: Process a list of queries to find the sum of even numbers in segments of the array. ... # Unit tests def test_precompute_even_prefix_sums(): arr = [1, 2, 3, 4, 5, 6] expected = [0, 0, 2, 2, 6, 6, 12] assert precompute_even_prefix_sums(arr) == expected def test_query_even_sum(): arr = [1, 2, 3, 4, 5, 6] even_prefix_sums = precompute_even_prefix_sums(arr) assert query_even_sum(even_prefix_sums, 1, 3) == 2 assert query_even_sum(even_prefix_sums, 2, 5) == 6 assert query_even_sum(even_prefix_sums, 1, 6) == 12 def test_process_queries(): n = 6 arr = [1, 2, 3, 4, 5, 6] queries = [(1, 3), (2, 5), (1, 6)] expected = [2, 6, 12] assert process_queries(n, arr, queries) == expected def test_edge_cases(): n = 1 arr = [2] queries = [(1, 1)] expected = [2] assert process_queries(n, arr, queries) == expected n = 10 arr = [1] * 10 queries = [(1, 10)] expected = [0] assert process_queries(n, arr, queries) == expected n = 10 arr = [2] * 10 queries = [(1, 10), (1, 5), (6, 10)] expected = [20, 10, 10] assert process_queries(n, arr, queries) == expected","solution":"def precompute_even_prefix_sums(arr): n = len(arr) even_prefix_sums = [0] * (n + 1) # initialize prefix sum array with an extra zero at the beginning for i in range(1, n + 1): even_prefix_sums[i] = even_prefix_sums[i - 1] + (arr[i - 1] if arr[i - 1] % 2 == 0 else 0) return even_prefix_sums def query_even_sum(even_prefix_sums, l, r): return even_prefix_sums[r] - even_prefix_sums[l - 1] def process_queries(n, arr, queries): even_prefix_sums = precompute_even_prefix_sums(arr) results = [] for l, r in queries: results.append(query_even_sum(even_prefix_sums, l, r)) return results"},{"question":"def min_battery_usage(grid: List[List[int]]) -> int: Compute the minimal battery usage needed for the drone to travel from the top-left corner to the bottom-right corner of the grid. >>> min_battery_usage([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 7 >>> min_battery_usage([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 21 >>> min_battery_usage([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) 5 >>> min_battery_usage([[5]]) 5 >>> min_battery_usage([ ... [1, 3], ... [2, 2] ... ]) 5","solution":"def min_battery_usage(grid): n = len(grid) dp = [[0] * n for _ in range(n)] dp[0][0] = grid[0][0] # Initialize the first row for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Initialize the first column for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the dp array for i in range(1, n): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[n-1][n-1] # Example Usage n = 3 grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] print(min_battery_usage(grid)) # Output: 7"},{"question":"def distribute_prizes(customers): Returns the list of customer IDs in the order they will receive the prizes. :param customers: List of tuples, each containing the ID and points of a customer :return: List of customer IDs in the order they receive the prizes >>> distribute_prizes([(1, 100), (2, 300), (3, 300), (4, 200), (5, 100)]) [2,3,4,1,5] >>> distribute_prizes([(1, 100)]) [1] >>> distribute_prizes([(1, 0), (2, 0), (3, 0)]) [1,2,3] >>> distribute_prizes([(1, 100), (2, 100), (3, 100)]) [1,2,3] >>> distribute_prizes([(1, 50), (2, 200), (3, 200), (4, 150), (5, 50)]) [2,3,4,1,5]","solution":"def distribute_prizes(customers): Returns the list of customer IDs in the order they will receive the prizes. :param customers: List of tuples, each containing the ID and points of a customer :return: List of customer IDs in the order they receive the prizes prize_order = [] while customers: # Find the customer with max points max_points = max(customers, key=lambda x: (x[1], -x[0])) prize_order.append(max_points[0]) customers.remove(max_points) return prize_order def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) customers = [(int(data[i*2+1]), int(data[i*2+2])) for i in range(n)] result = distribute_prizes(customers) for customer_id in result: print(customer_id) if __name__ == \\"__main__\\": main()"},{"question":"def count_pairs_with_sum(arr: List[int], target: int) -> int: Given an array of integers and a desired target sum, find the number of distinct pairs of elements in the array that add up to the target sum. A pair (a, b) is considered the same as (b, a) and should only be counted once. >>> count_pairs_with_sum([1, 5, 3, 3, 2], 6) 2 >>> count_pairs_with_sum([2, 2, 2, 3], 4) 1","solution":"def count_pairs_with_sum(arr, target): Returns the number of distinct pairs in the array that add up to the target sum. seen = set() pairs = set() for number in arr: complement = target - number if complement in seen: pairs.add((min(number, complement), max(number, complement))) seen.add(number) return len(pairs)"},{"question":"def max_subarray_sums(n: int, q: int, array: List[int], queries: List[int]) -> List[int]: Returns the maximum subarray sums for each query length. :param n: Length of the array :param q: Number of queries :param array: List of integers representing the array :param queries: List of integers representing the length of subarrays to consider :return: List of integers with the maximum subarray sum for each query # Example test case from solution import max_subarray_sums def test_example_case(): assert max_subarray_sums(5, 3, [1, 2, 3, 4, 5], [2, 3, 5]) == [9, 12, 15] def test_single_element_array(): assert max_subarray_sums(1, 1, [1], [1]) == [1] def test_all_elements_same(): assert max_subarray_sums(4, 2, [2, 2, 2, 2], [2, 3]) == [4, 6] def test_decreasing_elements(): assert max_subarray_sums(4, 2, [4, 3, 2, 1], [1, 2]) == [4, 7] def test_mixed_positive_negative(): assert max_subarray_sums(5, 3, [1, -1, 3, -2, 5], [2, 3, 4]) == [3, 6, 5] def test_large_values(): assert max_subarray_sums(3, 2, [1000000, 1000000, 1000000], [1, 2]) == [1000000, 2000000]","solution":"def max_subarray_sums(n, q, array, queries): Returns the maximum subarray sums for each query length. :param n: Length of the array :param q: Number of queries :param array: List of integers representing the array :param queries: List of integers representing the length of subarrays to consider :return: List of integers with the maximum subarray sum for each query result = [] def max_sum_of_subarray(length): # Use sliding window technique to find the max sum of subarray of given length max_sum = curr_sum = sum(array[:length]) for i in range(length, n): curr_sum += array[i] - array[i - length] max_sum = max(max_sum, curr_sum) return max_sum for k in queries: result.append(max_sum_of_subarray(k)) return result"},{"question":"def max_projects_within_deadline(n, m, d, projects): Calculate the maximum number of projects that can be completed within a given deadline. :param n: number of projects :param m: total number of tasks across all projects :param d: deadline in units of time :param projects: List of projects where each project is represented by a list of task durations :return: Maximum number of projects that can be completed within the deadline pass from solution import max_projects_within_deadline def test_example_case(): n = 3 m = 8 d = 10 projects = [ [2, 2, 2], [1, 3], [1, 1, 2] ] assert max_projects_within_deadline(n, m, d, projects) == 2 def test_single_project_fits(): n = 1 m = 3 d = 6 projects = [ [1, 2, 3] ] assert max_projects_within_deadline(n, m, d, projects) == 1 def test_no_project_fits(): n = 2 m = 4 d = 3 projects = [ [2, 2], [1, 3] ] assert max_projects_within_deadline(n, m, d, projects) == 0 def test_all_projects_fit_individually(): n = 3 m = 6 d = 15 projects = [ [2, 2, 2], [1, 3], [2, 1] ] assert max_projects_within_deadline(n, m, d, projects) == 3 def test_large_number_of_projects_and_tasks(): n = 100 m = 1000 d = 1000000 projects = [ [i for i in range(1, 11)] for _ in range(n) ] assert max_projects_within_deadline(n, m, d, projects) == 100 def test_some_projects_fitting(): n = 3 m = 6 d = 6 projects = [ [1, 2, 3], [2, 2, 1], [1, 5] ] assert max_projects_within_deadline(n, m, d, projects) == 1","solution":"def max_projects_within_deadline(n, m, d, projects): Calculate the maximum number of projects that can be completed within a given deadline. :param n: number of projects :param m: total number of tasks across all projects :param d: deadline in units of time :param projects: List of projects where each project is represented by a list of task durations :return: Maximum number of projects that can be completed within the deadline # Calculate the total time required for each project project_times = [sum(project) for project in projects] # Sort the projects by their total required time in ascending order project_times.sort() total_time_used = 0 completed_projects = 0 # Iterate over the sorted project times and count how many can be completed within the deadline for time in project_times: if total_time_used + time <= d: total_time_used += time completed_projects += 1 else: break return completed_projects"},{"question":"def max_recipes(n: int, k: int, initial_stock: List[int], recipes: List[List[int]]) -> int: Determines the maximum number of recipes that can be successfully prepared without running out of any ingredient at any point. >>> max_recipes(3, 3, [5, 5, 5], [[2, 0, 3], [1, 2, 1], [3, 1, 0]]) 2 >>> max_recipes(4, 2, [10, 8], [[3, 2], [5, 3], [2, 5], [1, 1]]) 3 >>> max_recipes(1, 1, [1], [[1]]) 1 >>> max_recipes(1, 1, [1], [[2]]) 0","solution":"def max_recipes(n, k, initial_stock, recipes): Determines the maximum number of recipes that can be successfully prepared without running out of any ingredient at any point. # Sort the recipes by the total amount of ingredients required, ascending recipes.sort(key=sum) count = 0 for recipe in recipes: if all(initial_stock[i] >= recipe[i] for i in range(k)): count += 1 for i in range(k): initial_stock[i] -= recipe[i] else: break return count"},{"question":"def can_partition(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determines if it's possible to partition each array in test_cases into two subsets with equal sums. Parameters: t (int): Number of test cases. test_cases (list): List of tuples, each containing an integer n and a list of n integers. Returns: list: List of strings \\"YES\\" or \\"NO\\" for each test case. pass # Unit tests import pytest def test_example(): t = 3 test_cases = [ (4, [1, 5, 11, 5]), (4, [1, 2, 3, 5]), (1, [100]) ] expected = [\\"YES\\", \\"NO\\", \\"NO\\"] assert can_partition(t, test_cases) == expected def test_single_element_odd(): t = 1 test_cases = [ (1, [1]) ] expected = [\\"NO\\"] assert can_partition(t, test_cases) == expected def test_single_element_even(): t = 1 test_cases = [ (1, [2]) ] expected = [\\"NO\\"] assert can_partition(t, test_cases) == expected def test_simple_even_partition(): t = 1 test_cases = [ (2, [3, 3]) ] expected = [\\"YES\\"] assert can_partition(t, test_cases) == expected def test_simple_odd_partition(): t = 1 test_cases = [ (2, [1, 3]) ] expected = [\\"NO\\"] assert can_partition(t, test_cases) == expected def test_large_case(): t = 1 test_cases = [ (10, [1, 1, 1, 1, 1, 1, 1, 1, 1, 9]) ] expected = [\\"YES\\"] assert can_partition(t, test_cases) == expected def test_no_partition(): t = 1 test_cases = [ (5, [1, 2, 5, 10, 20]) ] expected = [\\"NO\\"] assert can_partition(t, test_cases) == expected","solution":"def can_partition(t, test_cases): Determines if it's possible to partition each array in test_cases into two subsets with equal sums. Parameters: t (int): Number of test cases. test_cases (list): List of tuples, each containing an int n and a list of n integers. Returns: list: List of strings \\"YES\\" or \\"NO\\" for each test case. results = [] for case in test_cases: n, arr = case total_sum = sum(arr) # If the total sum is odd, we cannot partition it into two equal subsets if total_sum % 2 != 0: results.append(\\"NO\\") continue target = total_sum // 2 dp = [False] * (target + 1) dp[0] = True for num in arr: for i in range(target, num - 1, -1): dp[i] = dp[i] or dp[i - num] if dp[target]: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"from typing import List, Tuple def can_split_array_with_gcd(n: int, g: int, arr: List[int]) -> str: Determine whether you can split the array into exactly two non-empty subarrays such that the greatest common divisor (GCD) of elements of both subarrays is equal to \`g\`. >>> can_split_array_with_gcd(6, 2, [4, 2, 2, 4, 6, 8]) 'YES' >>> can_split_array_with_gcd(6, 3, [4, 2, 2, 4, 6, 8]) 'NO'","solution":"from math import gcd from functools import reduce def can_split_array_with_gcd(n, g, arr): def gcd_array(array): return reduce(gcd, array) # Check if the overall GCD of the array is divisible by g. # If the GCD of the entire array is not divisible by g, it's impossible to split. overall_gcd = gcd_array(arr) if overall_gcd % g != 0: return \\"NO\\" # Iterate and simulate splitting the array to see if conditions hold for i in range(1, n): left_gcd = gcd_array(arr[:i]) right_gcd = gcd_array(arr[i:]) if left_gcd == g and right_gcd == g: return \\"YES\\" return \\"NO\\""},{"question":"def organize_competition(n: int, complexities: List[int]) -> List[int]: Given the complexity levels of the problems, arrange them in such an order that the maximum difference between the complexity levels of any two consecutive problems is minimized. Args: n (int): The number of coding problems. complexities (list of int): The complexity levels of the coding problems. Returns: list of int: Arranged complexity levels. Example: >>> organize_competition(5, [4, 2, 9, 3, 7]) [2, 3, 4, 7, 9] >>> organize_competition(3, [30, 20, 10]) [10, 20, 30] pass from typing import List def test_organized_competition_with_positive_numbers(): assert organize_competition(5, [4, 2, 9, 3, 7]) == [2, 3, 4, 7, 9] def test_organized_competition_with_mixed_positive_numbers(): assert organize_competition(5, [10, 5, 15, 20, 25]) == [5, 10, 15, 20, 25] def test_organized_competition_with_larger_range(): assert organize_competition(4, [100, 50, 200, 150]) == [50, 100, 150, 200] def test_organized_competition_minimal_input(): assert organize_competition(2, [1, 1000000000]) == [1, 1000000000] def test_organized_competition_descending(): assert organize_competition(3, [30, 20, 10]) == [10, 20, 30]","solution":"def organize_competition(n, complexities): Given the complexity levels of the problems, arrange them in such an order that the maximum difference between the complexity levels of any two consecutive problems is minimized. Args: n (int): The number of coding problems. complexities (list of int): The complexity levels of the coding problems. Returns: list of int: Arranged complexity levels. return sorted(complexities)"},{"question":"from typing import List, Tuple from itertools import permutations def find_shortest_route(n: int, m: int, paths: List[Tuple[int, int, int]]) -> int: Given the number of checkpoints and paths, return the shortest possible route that visits all checkpoints exactly once and returns to the start. Args: n (int): The number of checkpoints. m (int): The number of paths. paths (List[Tuple[int, int, int]]): A list of tuples where each tuple contains three integers, u, v, and w indicating there is a path between checkpoint u and checkpoint v with distance w. Returns: int: The shortest possible distance to cover all checkpoints and return to the start. Example: >>> find_shortest_route(4, 6, [(1, 2, 10), (1, 3, 15), (1, 4, 20), (2, 3, 35), (2, 4, 25), (3, 4, 30)]) 80 >>> find_shortest_route(2, 1, [(1, 2, 5)]) 10 >>> find_shortest_route(3, 3, [(1, 2, 10), (2, 3, 20), (1, 3, 15)]) 45 pass def test_example_case(): n = 4 m = 6 paths = [ (1, 2, 10), (1, 3, 15), (1, 4, 20), (2, 3, 35), (2, 4, 25), (3, 4, 30) ] assert find_shortest_route(n, m, paths) == 80 def test_small_case(): n = 2 m = 1 path = [(1, 2, 5)] assert find_shortest_route(n, m, path) == 10 def test_case_with_three_nodes(): n = 3 m = 3 paths = [ (1, 2, 10), (2, 3, 20), (1, 3, 15) ] assert find_shortest_route(n, m, paths) == 45 def test_case_with_five_nodes(): n = 5 m = 7 paths = [ (1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 5, 4), (5, 1, 5), (1, 3, 10), (2, 4, 20) ] assert find_shortest_route(n, m, paths) == 15","solution":"from itertools import permutations def find_shortest_route(n, m, paths): # Create a distance matrix initialized with a large number dist = [[float('inf')] * n for _ in range(n)] # Populate the distance matrix with given paths for u, v, w in paths: dist[u-1][v-1] = w dist[v-1][u-1] = w # Check all permutations of nodes except the starting point (0-indexed) nodes = list(range(1, n)) min_route = float('inf') for perm in permutations(nodes): # Calculate the route distance including return to start current_dist = dist[0][perm[0]] for i in range(len(perm) - 1): current_dist += dist[perm[i]][perm[i+1]] current_dist += dist[perm[-1]][0] # Update minimum route distance if current_dist < min_route: min_route = current_dist return min_route"},{"question":"from typing import List, Tuple def find_max_data_volume_pair(n: int, m: int, links: List[Tuple[int, int, int]]) -> Tuple[int, int]: Find the pair of computers that exchanged the maximum volume of data. Args: n (int): The number of computers. m (int): The number of direct communication links. links (List[Tuple[int, int, int]]): A list of tuples representing the links between computers and data volume. Returns: Tuple[int, int]: The pair of computers that exchanged the maximum volume of data. Example: >>> find_max_data_volume_pair(5, 6, [(1, 2, 30), (2, 3, 50), (3, 1, 40), (4, 1, 60), (4, 3, 10), (5, 2, 90)]) (2, 5) pass # Test cases to validate the solution def test_example_case(): n = 5 m = 6 links = [ (1, 2, 30), (2, 3, 50), (3, 1, 40), (4, 1, 60), (4, 3, 10), (5, 2, 90) ] assert find_max_data_volume_pair(n, m, links) in [(2, 5), (5, 2)] def test_all_equal_volumes(): n = 4 m = 4 links = [ (1, 2, 50), (2, 3, 50), (3, 4, 50), (4, 1, 50) ] result = find_max_data_volume_pair(n, m, links) assert result in [(1, 2), (2, 1), (2, 3), (3, 2), (3, 4), (4, 3), (4, 1), (1, 4)] def test_smallest_case(): n = 2 m = 1 links = [ (1, 2, 10) ] assert find_max_data_volume_pair(n, m, links) in [(1, 2), (2, 1)] def test_multiple_max_cases(): n = 4 m = 5 links = [ (1, 2, 100), (1, 3, 90), (2, 3, 100), (3, 4, 80), (4, 1, 100) ] assert find_max_data_volume_pair(n, m, links) in [(1, 2), (2, 1), (2, 3), (3, 2), (4, 1), (1, 4)]","solution":"def find_max_data_volume_pair(n, m, links): max_volume = -1 pair = (-1, -1) for u, v, w in links: if w > max_volume: max_volume = w pair = (u, v) return pair"},{"question":"def largest_square_subgrid(n: int, m: int, grid: List[List[str]]) -> int: Compute the side length of the largest square sub-grid without any obstacles. Args: - n (int): Number of rows in the grid. - m (int): Number of columns in the grid. - grid (List[List[str]]): 2D grid of characters representing the grid. Returns: - int: Side length of the largest square sub-grid without any obstacles. >>> n, m = 5, 6 >>> grid = [ ... [\\".\\", \\".\\", \\".\\", \\"#\\", \\".\\", \\".\\"], ... [\\".\\", \\".\\", \\".\\", \\"#\\", \\".\\", \\".\\"], ... [\\".\\", \\".\\", \\".\\", \\".\\", \\".\\", \\".\\"], ... [\\".\\", \\"#\\", \\"#\\", \\".\\", \\".\\", \\".\\"], ... [\\".\\", \\"#\\", \\"#\\", \\".\\", \\".\\", \\".\\"] ... ] >>> largest_square_subgrid(n, m, grid) 3 if __name__ == \\"__main__\\": # Example usage: n, m = 5, 6 grid = [ \\". . . # . .\\", \\". . . # . .\\", \\". . . . . .\\", \\". # # . . .\\", \\". # # . . .\\" ] grid = [line.split() for line in grid] print(largest_square_subgrid(n, m, grid)) # Output: 3","solution":"def largest_square_subgrid(n, m, grid): dp = [[0] * (m + 1) for _ in range(n + 1)] max_side = 0 for i in range(1, n + 1): for j in range(1, m + 1): if grid[i-1][j-1] == '.': dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side # Example usage: if __name__ == \\"__main__\\": n, m = 5, 6 grid = [ \\". . . # . .\\", \\". . . # . .\\", \\". . . . . .\\", \\". # # . . .\\", \\". # # . . .\\" ] grid = [line.split() for line in grid] print(largest_square_subgrid(n, m, grid)) # Output: 3"},{"question":"def group_into_minimized_pairs(arr: List[int]) -> List[List[int]]: Groups integers into pairs such that the absolute difference between elements of each pair is minimized. If the array has an odd number of integers, the last single integer is left unpaired. >>> group_into_minimized_pairs([3, 8, 15, 17, 9, 1]) [[1, 3], [8, 9], [15, 17]] >>> group_into_minimized_pairs([5, 1, 6, 2, 8]) [[1, 2], [5, 6], [8]] >>> group_into_minimized_pairs([10, 2, 14, -1, 4, 7]) [[-1, 2], [4, 7], [10, 14]]","solution":"def group_into_minimized_pairs(arr): Groups integers into pairs such that the absolute difference between elements of each pair is minimized. If the array has an odd number of integers, the last single integer is left unpaired. Parameters: arr (list): A list of integers. Returns: list: A list containing pairs of integers as sublists, with the last unpaired integer as a single-element list if applicable. if not arr: return [] arr.sort() result = [] i = 0 n = len(arr) while i < n - 1: result.append([arr[i], arr[i + 1]]) i += 2 if n % 2 != 0: result.append([arr[-1]]) return result"},{"question":"from typing import List def count_distinct_encoded_strings(N: int) -> int: Takes a number N and returns the number of distinct strings that can be generated by permuting and encoding its digits. >>> count_distinct_encoded_strings(123) == 6 >>> count_distinct_encoded_strings(1) == 1 >>> count_distinct_encoded_strings(0) == 1 >>> count_distinct_encoded_strings(11) == 1 >>> count_distinct_encoded_strings(121) == 3 >>> count_distinct_encoded_strings(122) == 3 >>> count_distinct_encoded_strings(1024) == 24 pass","solution":"from itertools import permutations def count_distinct_encoded_strings(N): Takes a number N and returns the number of distinct strings that can be generated by permuting and encoding its digits. # Create mapping from digits to corresponding characters mapping = {'0': 'j', '1': 'a', '2': 'b', '3': 'c', '4': 'd', '5': 'e', '6': 'f', '7': 'g', '8': 'h', '9': 'i'} # Convert the number to string to get digits digits = str(N) # Generate all unique permutations of the digits unique_permutations = set(permutations(digits)) # Encode each permutation using the mapping encoded_strings = set() for perm in unique_permutations: encoded_string = ''.join(mapping[digit] for digit in perm) encoded_strings.add(encoded_string) return len(encoded_strings)"},{"question":"import heapq from typing import List def min_cost_to_combine_ropes(n: int, ropes: List[int]) -> int: Minimize the cost to connect all ropes into one single rope. >>> min_cost_to_combine_ropes(1, [4]) 0 >>> min_cost_to_combine_ropes(3, [2, 3, 4]) 14 >>> min_cost_to_combine_ropes(4, [1, 2, 3, 4]) 19","solution":"import heapq def min_cost_to_combine_ropes(n, ropes): if n == 1: return 0 heapq.heapify(ropes) total_cost = 0 while len(ropes) > 1: first = heapq.heappop(ropes) second = heapq.heappop(ropes) cost = first + second total_cost += cost heapq.heappush(ropes, cost) return total_cost"},{"question":"def min_elements_to_disappear(arr): Find the minimum number of elements that need to disappear to make both the product and sum of the remaining elements even. >>> min_elements_to_disappear([2, 3, 5, 4, 6]) 1 >>> min_elements_to_disappear([1, 3, 5, 7, 9]) -1 >>> min_elements_to_disappear([2, 4, 6, 8, 10]) 0 >>> min_elements_to_disappear([5]) -1 >>> min_elements_to_disappear([2]) 0 >>> min_elements_to_disappear([1, 2, 3, 4, 6]) 1 >>> min_elements_to_disappear([1, 1, 1, 1, 1]) -1","solution":"def min_elements_to_disappear(arr): n = len(arr) odd_count = sum(1 for x in arr if x % 2 != 0) if odd_count == n: # All elements are odd, can't have even sum or even product return -1 if odd_count == 0: # All elements are even, the sum will be even and so will the product return 0 # Count of even numbers is n - odd_count # Check the smallest odd number of odd_count to be removed # Since, sum of mixed odd + even, only one remaining odd to be removed to make even sum for i in range(n): if arr[i] % 2 != 0: # Find any odd number and remove it return 1 return -1 # Just an edge case, function should not reach this point"},{"question":"from collections import deque from typing import List def can_reach_and_return(n: int, m: int, grid: List[List[str]]) -> str: Determine if it is possible to reach the bottom-right corner and return to the top-left corner according to the rules. >>> can_reach_and_return(3, 3, [['.', '.', '.'], ['.', '#', '.'], ['.', '.', '.']]) 'YES' >>> can_reach_and_return(3, 3, [['.', '.', '.'], ['#', '#', '#'], ['.', '.', '.']]) 'NO' >>> can_reach_and_return(3, 3, [['.', '.', '.'], ['.', '2', '.'], ['.', '.', '.']]) 'YES'","solution":"from collections import deque def is_valid(x, y, n, m, grid, visited): return 0 <= x < n and 0 <= y < m and grid[x][y] != '#' and visited[x][y] != 1 def bfs(n, m, grid, start, end): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(start, 0)]) visited = [[0] * m for _ in range(n)] visited[start[0]][start[1]] = 1 step_counts = {} while queue: (x, y), steps = queue.popleft() if (x, y) == end: return True, steps for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny, n, m, grid, visited): if grid[nx][ny].isdigit(): trap_limit = int(grid[nx][ny]) if (nx, ny) not in step_counts: step_counts[(nx, ny)] = 0 if step_counts[(nx, ny)] < trap_limit: step_counts[(nx, ny)] += 1 queue.append(((nx, ny), steps + 1)) visited[nx][ny] = 1 else: visited[nx][ny] = 1 else: queue.append(((nx, ny), steps + 1)) visited[nx][ny] = 1 return False, -1 def can_reach_and_return(n, m, grid): start = (0, 0) end = (n - 1, m - 1) reachable_to_end, forward_steps = bfs(n, m, grid, start, end) if not reachable_to_end: return \\"NO\\" reachable_to_start, return_steps = bfs(n, m, grid, end, start) if not reachable_to_start: return \\"NO\\" return \\"YES\\" # Let's define our main function to get the input and call the function def main(): input_str = input().strip() n, m = map(int, input_str.split()) grid = [input().strip().split() for _ in range(n)] result = can_reach_and_return(n, m, grid) print(result)"},{"question":"def encode_string(n: int, s: str) -> str: Encodes the given string by replacing each continuous segment of the same character with a single instance of that character followed by the length of the segment. >>> encode_string(9, \\"aaabbcaaa\\") 'a3b2c1a3' >>> encode_string(6, \\"abbbbb\\") 'a1b5' >>> encode_string(1, \\"a\\") 'a1' >>> encode_string(4, \\"abcd\\") 'a1b1c1d1' >>> encode_string(5, \\"aaaaa\\") 'a5' >>> encode_string(0, \\"\\") '' >>> encode_string(10, \\"aabbbccccd\\") 'a2b3c4d1'","solution":"def encode_string(n, s): if n == 0: return \\"\\" encoded_string = \\"\\" count = 1 for i in range(1, n): if s[i] == s[i - 1]: count += 1 else: encoded_string += s[i - 1] + str(count) count = 1 # Don't forget to add the last segment encoded_string += s[n - 1] + str(count) return encoded_string"},{"question":"def max_contiguous_subarrays(nums: List[int]) -> int: Returns the maximum number of contiguous subarrays such that each subarray contains distinct elements. >>> max_contiguous_subarrays([1, 2, 3, 1, 2]) 2 >>> max_contiguous_subarrays([1]) 1 >>> max_contiguous_subarrays([1, 2, 3, 4, 5]) 1 >>> max_contiguous_subarrays([1, 1, 1, 1, 1]) 5 >>> max_contiguous_subarrays([1, 2, 1, 2, 1]) 3 >>> max_contiguous_subarrays([1, 2, 3, 4, 1, 2, 3, 4, 5, 6, 7, 8]) 2","solution":"def max_contiguous_subarrays(nums): Returns the maximum number of contiguous subarrays such that each subarray contains distinct elements. seen = set() count = 0 for num in nums: if num in seen: count += 1 seen = set() seen.add(num) return count + 1 if seen else count # Example usage: # nums = [1, 2, 3, 1, 2] # print(max_contiguous_subarrays(nums)) # Output: 2"},{"question":"from typing import Dict def parse_formula(formula: str) -> Dict[str, int]: Parse a chemical formula and return the total number of each element in the compound. >>> parse_formula(\\"H2O\\") {\\"H\\": 2, \\"O\\": 1} >>> parse_formula(\\"C6H12O6\\") {\\"C\\": 6, \\"H\\": 12, \\"O\\": 6} >>> parse_formula(\\"Mg(OH)2\\") {\\"Mg\\": 1, \\"O\\": 2, \\"H\\": 2} >>> parse_formula(\\"K4(ON(SO3)2)2\\") {\\"K\\": 4, \\"O\\": 14, \\"N\\": 2, \\"S\\": 4} >>> parse_formula(\\"Ca(OH)2(H2O)4\\") {\\"Ca\\": 1, \\"O\\": 6, \\"H\\": 10}","solution":"import re from collections import defaultdict def parse_formula(formula): def parse_segment(segment, multiplier): elements = defaultdict(int) i = 0 while i < len(segment): if segment[i].isupper(): # Find the full element symbol (could be one letter or two letters if the second is lowercase) j = i + 1 while j < len(segment) and segment[j].islower(): j += 1 element = segment[i:j] # Find the number of atoms, if any num_start = j while j < len(segment) and segment[j].isdigit(): j += 1 num_atoms = int(segment[num_start:j]) if num_start != j else 1 elements[element] += num_atoms * multiplier i = j elif segment[i] == '(': # Find the matching closing parenthesis start = i count = 1 i += 1 while i < len(segment): if segment[i] == '(': count += 1 elif segment[i] == ')': count -= 1 if count == 0: break i += 1 end = i # Find the multiplier for the group i += 1 num_start = i while i < len(segment) and segment[i].isdigit(): i += 1 group_multiplier = int(segment[num_start:i]) if num_start != i else 1 # Parse the segment inside the parentheses inner_elements = parse_segment(segment[start + 1:end], group_multiplier * multiplier) for elem, quant in inner_elements.items(): elements[elem] += quant else: i += 1 return elements all_elements = parse_segment(formula, 1) return dict(all_elements)"},{"question":"from typing import List def minimum_points_to_pass(n: int, grades: List[int]) -> int: Calculate the minimum number of points needed to bring every student's grade to at least 50. Parameters: n (int): The number of students grades (List[int]): List of grades of the students Returns: int: Minimum number of total points that need to be added to make every student's grade at least 50.  Examples: >>> minimum_points_to_pass(3, [40, 45, 50]) 15 >>> minimum_points_to_pass(3, [40, 35, 55]) 25","solution":"def minimum_points_to_pass(n, grades): Calculate the minimum number of points needed to bring every student's grade to at least 50. Parameters: n (int): The number of students grades (List[int]): List of grades of the students Returns: int: Minimum number of total points that need to be added to make every student's grade at least 50. total_points_needed = 0 for grade in grades: if grade < 50: total_points_needed += 50 - grade return total_points_needed # Example of how to call the function # n = 3 # grades = [40, 45, 50] # output = minimum_points_to_pass(n, grades) # print(output) # Should print 15"},{"question":"def rearrange_string(s: str) -> str: Returns a reordered string with all the alphabetic characters at the beginning followed by all the digits while maintaining their original relative order. >>> rearrange_string(\\"a1b2c3\\") 'abc123' >>> rearrange_string(\\"Z9Y8X7\\") 'ZYX987' >>> rearrange_string(\\"abcdef\\") 'abcdef' >>> rearrange_string(\\"ABCdef\\") 'ABCdef' >>> rearrange_string(\\"12345\\") '12345' >>> rearrange_string(\\"98765\\") '98765' >>> rearrange_string(\\"a1b2c3d4e5\\") 'abcde12345' >>> rearrange_string(\\"a\\") 'a' >>> rearrange_string(\\"1\\") '1' >>> rearrange_string(\\"aA1B2cC3\\") 'aABcC123' >>> rearrange_string(\\"a1\\" * 50000) 'a' * 50000 + '1' * 50000","solution":"def rearrange_string(s): Returns a reordered string with all the alphabetic characters at the beginning followed by all the digits while maintaining their original relative order. alphabetics = [] digits = [] for char in s: if char.isalpha(): alphabetics.append(char) else: digits.append(char) return ''.join(alphabetics + digits)"},{"question":"def max_cake_boxes(cake_counts: List[int]) -> int: Returns the maximum number of complete cake boxes that can be created. Each cake box should contain exactly one of each type of cake. >>> max_cake_boxes([3, 1, 2]) == 1 >>> max_cake_boxes([6, 2, 2, 5]) == 2","solution":"from typing import List def max_cake_boxes(cake_counts: List[int]) -> int: Returns the maximum number of complete cake boxes that can be created. Each cake box should contain exactly one of each type of cake. return min(cake_counts) # The limiting factor is the type of cake that has the fewest cakes"},{"question":"def process_queries(n: int, q: int, array: List[int], queries: List[List[int]]) -> List[int]: Emma's task is to answer a series of queries about the sum of elements within specified subarrays and update operations on the array. Args: n (int): Number of elements in the array. q (int): Number of queries. array (List[int]): Initial values of the array. queries (List[List[int]]): List of queries where each query is in one of the following formats: - [1, l, r]: Calculate and output the sum of elements from index l to r (inclusive). - [2, i, x]: Update the value of element at index i to x. Returns: List[int]: The results of the sum queries. Example: >>> process_queries(5, 3, [1, 2, 3, 4, 5], [[1, 1, 3], [2, 2, 10], [1, 2, 5]]) [6, 22] >>> process_queries(4, 2, [4, 4, 4, 4], [[2, 4, 7], [1, 1, 4]]) [19]","solution":"def process_queries(n, q, array, queries): result = [] for query in queries: query_type = query[0] if query_type == 1: l, r = query[1], query[2] result.append(sum(array[l-1:r])) elif query_type == 2: i, x = query[1], query[2] array[i-1] = x return result"},{"question":"def maximum_bravery(n: int, bravery_indices: List[int], duels: List[Tuple[int, int]]) -> int: Returns the maximum bravery among all duels. Parameters: n (int): Number of duels. bravery_indices (list of int): Bravery indices of the individuals. duels (list of tuple): Each tuple contains two integers a and b representing a duel between individuals a and b. Returns: int: Maximum bravery among all duels. >>> maximum_bravery(4, [5, 1, 3, 4], [(1, 2), (1, 3), (2, 4), (3, 4)]) 3 >>> maximum_bravery(3, [1, 2, 3], [(1, 2), (1, 3), (2, 3)]) 2 >>> maximum_bravery(1, [10], [(1, 1)]) 10 import unittest class TestMaximumBravery(unittest.TestCase): def test_maximum_bravery(self): self.assertEqual(maximum_bravery(4, [5, 1, 3, 4], [(1, 2), (1, 3), (2, 4), (3, 4)]), 3) self.assertEqual(maximum_bravery(3, [1, 2, 3], [(1, 2), (1, 3), (2, 3)]), 2) self.assertEqual(maximum_bravery(1, [10], [(1, 1)]), 10) def test_maximum_bravery_single_duel(self): self.assertEqual(maximum_bravery(1, [5, 3], [(1, 2)]), 3) def test_maximum_bravery_all_equal(self): self.assertEqual(maximum_bravery(3, [5, 5, 5], [(1, 2), (2, 3), (1, 3)]), 5) if __name__ == '__main__': unittest.main()","solution":"def maximum_bravery(n, bravery_indices, duels): Returns the maximum bravery among all duels. Parameters: n (int): Number of duels. bravery_indices (list of int): Bravery indices of the individuals. duels (list of tuple): Each tuple contains two integers a and b representing a duel between individuals a and b. Returns: int: Maximum bravery among all duels. max_bravery = 0 for a, b in duels: current_bravery = min(bravery_indices[a-1], bravery_indices[b-1]) if current_bravery > max_bravery: max_bravery = current_bravery return max_bravery"},{"question":"def count_subsequences(banner: str, pattern: str) -> int: Returns the number of times the pattern appears as a subsequence in the banner. >>> count_subsequences(\\"abc\\", \\"abc\\") 1 >>> count_subsequences(\\"abcdef\\", \\"gh\\") 0 >>> count_subsequences(\\"ababc\\", \\"abc\\") 3 >>> count_subsequences(\\"aaaaa\\", \\"a\\") 5 >>> count_subsequences(\\"abc\\", \\"abcd\\") 0 >>> count_subsequences(\\"abbc\\", \\"abc\\") 2 >>> count_subsequences(\\"anystring\\", \\"\\") 1 >>> count_subsequences(\\"\\", \\"any\\") 0 >>> count_subsequences(\\"abcdefghijklmnopqrstuvwxyz\\", \\"ace\\") 1 >>> count_subsequences(\\"axbxc\\", \\"abc\\") 1","solution":"def count_subsequences(banner, pattern): Returns the number of times the pattern appears as a subsequence in the banner. m = len(banner) n = len(pattern) # Create a 2D dp array with (m+1) x (n+1) filled with zeros dp = [[0] * (n + 1) for _ in range(m + 1)] # Every string includes the empty subsequence for i in range(m + 1): dp[i][0] = 1 # Fill the dp array for i in range(1, m + 1): for j in range(1, n + 1): if banner[i - 1] == pattern[j - 1]: dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j] else: dp[i][j] = dp[i - 1][j] return dp[m][n]"},{"question":"def min_changes_to_palindrome(n: int) -> int: Given a positive integer n, returns the minimum number of change operations required to make the integer palindrome. A change operation involves changing one digit to any other digit. >>> min_changes_to_palindrome(12321) == 0 >>> min_changes_to_palindrome(12345) == 2 >>> min_changes_to_palindrome(10011) == 1 >>> min_changes_to_palindrome(5) == 0 >>> min_changes_to_palindrome(123456789) == 4","solution":"def min_changes_to_palindrome(n): Returns the minimum number of change operations required to make the integer n palindrome. s = str(n) length = len(s) changes = 0 for i in range(length // 2): if s[i] != s[length - 1 - i]: changes += 1 return changes"},{"question":"def min_elements_after_operations(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the minimum number of elements that can remain in the array after performing the operations optimally. >>> min_elements_after_operations([(5, [1, 1, 1, 1, 1])]) [1] >>> min_elements_after_operations([(4, [2, 1, 3, 4])]) [3] >>> min_elements_after_operations([(3, [10, 20, 30])]) [3] >>> min_elements_after_operations([(5, [1, 1, 1, 1, 1]), (4, [2, 1, 3, 4]), (3, [10, 20, 30])]) [1, 3, 3]","solution":"def min_elements_after_operations(test_cases): results = [] for n, arr in test_cases: # It is optimal to sum all elements into one if we can replace adjacent elements if n == 1: results.append(1) else: # Each operation reduces the array size by 1, hence we can perform n-1 operations results.append(1) return results # Example of how to use the function: # test_cases = [(5, [1, 1, 1, 1, 1]), (4, [2, 1, 3, 4]), (3, [10, 20, 30])] # print(min_elements_after_operations(test_cases)) # This would output [1, 3, 3]"},{"question":"def max_games_on_shelf(n: int, W: int, game_weights: List[int]) -> int: Determines the maximum number of games Lara can place on the shelf without exceeding the weight limit. :param n: Number of games :param W: Weight limit of the shelf :param game_weights: List of weights of the games :return: Maximum number of games that can be placed on the shelf def test_max_games_on_shelf_example(): assert max_games_on_shelf(4, 10, [2, 3, 4, 5]) == 3 def test_max_games_on_shelf_single_game(): assert max_games_on_shelf(1, 5, [3]) == 1 def test_max_games_on_shelf_single_game_over_limit(): assert max_games_on_shelf(1, 1, [2]) == 0 def test_max_games_on_shelf_all_games_fit_exactly(): assert max_games_on_shelf(3, 6, [1, 2, 3]) == 3 def test_max_games_on_shelf_some_games_over_limit(): assert max_games_on_shelf(5, 15, [5, 5, 5, 5, 5]) == 3 def test_max_games_on_shelf_large_input(): assert max_games_on_shelf(6, 9, [8, 1, 7, 2, 6, 3]) == 3","solution":"def max_games_on_shelf(n, W, game_weights): Determines the maximum number of games Lara can place on the shelf without exceeding the weight limit. :param n: Number of games :param W: Weight limit of the shelf :param game_weights: List of weights of the games :return: Maximum number of games that can be placed on the shelf game_weights.sort() total_weight = 0 num_games = 0 for weight in game_weights: if total_weight + weight <= W: total_weight += weight num_games += 1 else: break return num_games"},{"question":"def count_squares_in_chessboard(n: int) -> int: Returns the total number of squares that can fit into an n x n chessboard. >>> count_squares_in_chessboard(1) 1 >>> count_squares_in_chessboard(2) 5 >>> count_squares_in_chessboard(3) 14 >>> count_squares_in_chessboard(4) 30 >>> count_squares_in_chessboard(10) 385 >>> count_squares_in_chessboard(1000) 333833500","solution":"def count_squares_in_chessboard(n): Returns the total number of squares that can fit into an n x n chessboard. total_squares = 0 for size in range(1, n + 1): squares_of_size = (n - size + 1) ** 2 total_squares += squares_of_size return total_squares"},{"question":"def rearrange_min_abs_diff(arr: List[int]) -> List[int]: Given an array of integers, rearrange it such that the absolute difference between any two consecutive elements is minimized. Parameters: arr (list): List of integers Returns: list: Rearranged list of integers >>> rearrange_min_abs_diff([6, 2, 5, 1]) [1, 2, 5, 6] >>> rearrange_min_abs_diff([10, 2, 3, 12, 7]) [2, 3, 7, 10, 12]","solution":"def rearrange_min_abs_diff(arr): Given an array of integers, rearrange it such that the absolute difference between any two consecutive elements is minimized. Parameters: arr (list): List of integers Returns: list: Rearranged list of integers arr.sort() return arr"},{"question":"def max_eggs_value(n: int, egg_values: List[int]) -> int: Help Mr. Hunter maximize the total value of eggs he can collect without picking from two consecutive nests. >>> max_eggs_value(1, [10]) 10 >>> max_eggs_value(2, [5, 10]) 10 >>> max_eggs_value(4, [1, 2, 9, 4]) 10 >>> max_eggs_value(5, [2, 7, 9, 3, 1]) 12 >>> max_eggs_value(4, [5, 5, 5, 5]) 10 >>> max_eggs_value(6, [5, 1, 1, 5, 1, 10]) 20","solution":"def max_eggs_value(n, egg_values): if n == 1: return egg_values[0] dp = [0] * n dp[0] = egg_values[0] dp[1] = max(egg_values[0], egg_values[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + egg_values[i]) return dp[n-1]"},{"question":"def calculate_total_uptime(n: int, logs: List[List[Tuple[int, int]]]) -> List[int]: Calculate the total uptime for each server given their logs. Each server's log might contain overlapping intervals which need to be merged. Parameters: n (int): Number of servers. logs (list of list of tuples): Each server's uptime logs represented as (start, end) tuples. Returns: list: Total uptime in minutes for each server. pass def test_single_server_no_overlap(): n = 1 logs = [ [(0, 60), (120, 180), (300, 360)] ] assert calculate_total_uptime(n, logs) == [180] def test_single_server_with_overlap(): n = 1 logs = [ [(0, 60), (50, 120), (110, 170)] ] assert calculate_total_uptime(n, logs) == [170] def test_multiple_servers_no_overlap(): n = 2 logs = [ [(0, 60), (120, 180)], [(300, 600), (700, 800)] ] assert calculate_total_uptime(n, logs) == [120, 400] def test_multiple_servers_with_overlap(): n = 2 logs = [ [(0, 60), (50, 120), (110, 170)], [(300, 600), (590, 690)] ] assert calculate_total_uptime(n, logs) == [170, 390] def test_example_case(): n = 3 logs = [ [(0, 60), (120, 180), (150, 210)], [(300, 600), (590, 690)], [(720, 780), (780, 840)] ] assert calculate_total_uptime(n, logs) == [150, 390, 120] def test_no_logs(): n = 3 logs = [ [], [], [] ] assert calculate_total_uptime(n, logs) == [0, 0, 0] def test_single_event(): n = 1 logs = [ [(0, 1440)] ] assert calculate_total_uptime(n, logs) == [1440]","solution":"def calculate_total_uptime(n, logs): Calculate the total uptime for each server given their logs. Each server's log might contain overlapping intervals which need to be merged. Parameters: n (int): Number of servers. logs (list of list of tuples): Each server's uptime logs represented as (start, end) tuples. Returns: list: Total uptime in minutes for each server. total_uptime = [] for server_logs in logs: # Sort intervals by start time merged_intervals = [] for start, end in sorted(server_logs): if merged_intervals and merged_intervals[-1][1] >= start: merged_intervals[-1][1] = max(merged_intervals[-1][1], end) else: merged_intervals.append([start, end]) # Calculate total uptime from merged intervals uptime = sum(end - start for start, end in merged_intervals) total_uptime.append(uptime) return total_uptime"},{"question":"def hiking_trail(n: int, m: int, k: int, grid_lines: List[str]) -> Union[int, List[Tuple[int, int]]]: Petya is organizing a hiking event and wants to create a unique hiking path for the participants. The hiking trail is represented as a grid of size \`n x m\`. Each cell of the grid can be either land or water. The trail can only be built on land, and hikers can move between adjacent cells (left, right, up, down). Petya needs to make sure that the trail forms a continuous path (i.e., an unbroken sequence of land cells) and includes a specified number of land cells. Given the grid and the desired number of land cells \`k\`, help Petya determine if it's possible to create such a continuous hiking trail and if so, find one of the possible trails. Parameters: n (int): Number of rows in the grid m (int): Number of columns in the grid k (int): Number of land cells required to form the trail grid_lines (List[str]): List of strings representing the grid layout Returns: Union[int, List[Tuple[int, int]]]: -1 if it's impossible to create such a trail, otherwise a list of coordinates of land cells forming the trail >>> hiking_trail(5, 5, 8, [\\".#...\\", \\"...#.\\", \\"...\\", \\".#..#\\", \\".....\\"]) != -1 True >>> hiking_trail(3, 3, 5, [\\"#\\", \\"#.#\\", \\"#\\"]) == -1 True","solution":"def find_continuous_trail(grid, n, m, k): def is_valid(x, y): return 0 <= x < n and 0 <= y < m and grid[x][y] == '.' and (x, y) not in visited def dfs(x, y): if len(path) == k: return True visited.add((x, y)) path.append((x, y)) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if is_valid(nx, ny): if dfs(nx, ny): return True if len(path) == k: return True visited.remove((x, y)) path.pop() return False visited = set() path = [] for i in range(n): for j in range(m): if grid[i][j] == '.': if dfs(i, j): return path else: return -1 return -1 def hiking_trail(n, m, k, grid_lines): grid = [list(line) for line in grid_lines] result = find_continuous_trail(grid, n, m, k) if result == -1: return -1 else: return result"},{"question":"def min_conference_rooms(presentations): Determines the minimum number of conference rooms required to schedule all presentations without any overlaps in the same room. :param presentations: List of tuples where each tuple contains the start and end time of a presentation (start, end). :return: Integer representing the minimum number of conference rooms required. >>> min_conference_rooms([(1, 5), (2, 6), (8, 9)]) 2 >>> min_conference_rooms([(1, 3), (4, 6), (7, 9)]) 1 >>> min_conference_rooms([(1, 5), (2, 6), (3, 7)]) 3 >>> min_conference_rooms([(1, 10), (2, 3), (4, 5), (6, 7)]) 2 >>> min_conference_rooms([(1, 2)]) 1 >>> min_conference_rooms([]) 0 >>> min_conference_rooms([(i, i + 1) for i in range(100000)]) 1","solution":"def min_conference_rooms(presentations): Determines the minimum number of conference rooms required to schedule all presentations without any overlaps in the same room. :param presentations: List of tuples where each tuple contains the start and end time of a presentation (start, end). :return: Integer representing the minimum number of conference rooms required. if not presentations: return 0 # Create two lists for start times and end times starts = sorted([s for s, e in presentations]) ends = sorted([e for s, e in presentations]) start_pointer, end_pointer = 0, 0 used_rooms = 0 max_rooms = 0 # Iterate through the start times while start_pointer < len(presentations): # If there is a meeting that starts before the last meeting ends, # allocate a new room if starts[start_pointer] < ends[end_pointer]: used_rooms += 1 start_pointer += 1 else: # If the current meeting starts after the earliest ended meeting, # free up a room used_rooms -= 1 end_pointer += 1 # Update the maximum number of rooms required max_rooms = max(max_rooms, used_rooms) return max_rooms # Example usage # presentations = [(1, 5), (2, 6), (8, 9)] # print(min_conference_rooms(presentations)) #=> 2"},{"question":"def count_pairs_with_distance_three(n: int, edges: List[Tuple[int, int, int]]) -> int: Count the number of pairs of vertices (u, v) such that the distance between u and v is exactly 3 in a tree. Args: n: An integer, the number of vertices in the tree. edges: A list of tuples, where each tuple contains three integers u, v, and w representing an edge between vertices u and v with weight w. Returns: An integer, the number of pairs (u, v) having the distance of exactly 3. Example: >>> count_pairs_with_distance_three(6, [(1, 2, 1), (1, 3, 2), (2, 4, 2), (2, 5, 1), (3, 6, 1)]) 4 >>> count_pairs_with_distance_three(3, [(1, 2, 1), (2, 3, 1)]) 0","solution":"def count_pairs_with_distance_three(n, edges): from collections import defaultdict, deque # Create adjacency list adj = defaultdict(list) for u, v, w in edges: adj[u].append((v, w)) adj[v].append((u, w)) def bfs(start): dist = [-1] * (n + 1) queue = deque([(start, 0)]) dist[start] = 0 while queue: node, d = queue.popleft() for neighbor, weight in adj[node]: if dist[neighbor] == -1: dist[neighbor] = d + weight queue.append((neighbor, dist[neighbor])) return dist count = 0 # Use BFS from each node to count pairs with distance exactly 3 for i in range(1, n + 1): distances = bfs(i) count += distances.count(3) # Each pair (u, v) will be counted twice so we divide by 2 return count // 2"},{"question":"def largest_common_divisor(n: int, numbers: List[int]) -> int: Find the largest integer that can divide all numbers in the list. If no such integer exists, return -1. >>> largest_common_divisor(3, [12, 15, 18]) 3 >>> largest_common_divisor(3, [7, 11, 13]) -1 >>> largest_common_divisor(3, [8, 12, 16]) 4 >>> largest_common_divisor(3, [5, 10, 15]) 5 >>> largest_common_divisor(3, [5, 7, 11]) -1 >>> largest_common_divisor(3, [1000000000, 2000000000, 3000000000]) 1000000000","solution":"from math import gcd from functools import reduce def largest_common_divisor(n, numbers): def find_gcd(lst): return reduce(gcd, lst) result = find_gcd(numbers) return result if result > 1 else -1"},{"question":"def is_match(w: str, p: str) -> bool: Determines if the pattern p matches the entire string w. The pattern character '*' can match zero or more of any characters. >>> is_match(\\"abcd\\", \\"a*d\\") True >>> is_match(\\"abcde\\", \\"a*c?e\\") False","solution":"def is_match(w: str, p: str) -> bool: Determines if the pattern p matches the entire string w. The pattern character '*' can match zero or more of any characters. m, n = len(w), len(p) # dp[i][j] will be True if p[0..j-1] matches w[0..i-1] dp = [[False] * (n + 1) for _ in range(m + 1)] # Empty pattern matches empty string dp[0][0] = True # Handles patterns like '*', '**', '**', etc. that can match an empty string for j in range(1, n + 1): if p[j-1] == '*': dp[0][j] = dp[0][j-1] for i in range(1, m + 1): for j in range(1, n + 1): if p[j-1] == '*': # '*' can match zero characters (dp[i][j-1]) or one more character in w (dp[i-1][j]) dp[i][j] = dp[i][j-1] or dp[i-1][j] elif p[j-1] == w[i-1]: dp[i][j] = dp[i-1][j-1] # Match this character and move diagonally else: dp[i][j] = False return dp[m][n]"},{"question":"def check_submatrix_sum(n, m, k, matrix): Determines if there exists a 2x2 submatrix within the given n x m matrix that has a sum of elements equal to k. Args: n (int): Number of rows in the matrix. m (int): Number of columns in the matrix. k (int): The required sum of elements of the 2x2 submatrix. matrix (list of list of int): The n x m matrix. Returns: str: \\"YES\\" if such a submatrix exists, otherwise \\"NO\\". import pytest from solution import check_submatrix_sum def test_check_submatrix_sum_exists(): matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 1, 2, 3] ] assert check_submatrix_sum(3, 4, 14, matrix) == \\"YES\\" def test_check_submatrix_sum_not_exists(): matrix = [ [1, 8, 3, 4], [5, 6, 7, 8], [9, 1, 2, 3] ] assert check_submatrix_sum(3, 4, 30, matrix) == \\"NO\\" def test_check_submatrix_sum_single_submatrix(): matrix = [ [1, 1], [1, 1] ] assert check_submatrix_sum(2, 2, 4, matrix) == \\"YES\\" def test_check_submatrix_sum_larger_matrix(): matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] assert check_submatrix_sum(4, 4, 34, matrix) == \\"YES\\" def test_check_submatrix_sum_edge_case_not_exist(): matrix = [ [1, 2], [3, 4] ] assert check_submatrix_sum(2, 2, 20, matrix) == \\"NO\\"","solution":"def check_submatrix_sum(n, m, k, matrix): Determines if there exists a 2x2 submatrix within the given n x m matrix that has a sum of elements equal to k. Args: n (int): Number of rows in the matrix. m (int): Number of columns in the matrix. k (int): The required sum of elements of the 2x2 submatrix. matrix (list of list of int): The n x m matrix. Returns: str: \\"YES\\" if such a submatrix exists, otherwise \\"NO\\". for i in range(n - 1): for j in range(m - 1): submatrix_sum = ( matrix[i][j] + matrix[i][j + 1] + matrix[i + 1][j] + matrix[i + 1][j + 1] ) if submatrix_sum == k: return \\"YES\\" return \\"NO\\""},{"question":"def permuta_maximizer(n: int) -> int: Given a positive integer, rearranges its digits to form the largest possible integer. Args: n (int): A positive integer (1  n  10^18) Returns: int: The largest possible integer obtained by rearranging the digits of n. >>> permuta_maximizer(2134) 4321 >>> permuta_maximizer(987654321) 987654321 >>> permuta_maximizer(120) 210","solution":"def permuta_maximizer(n): Given a positive integer, rearranges its digits to form the largest possible integer. Args: n (int): A positive integer (1  n  10^18) Returns: int: The largest possible integer obtained by rearranging the digits of n. digits = list(str(n)) digits.sort(reverse=True) return int(\\"\\".join(digits))"},{"question":"from typing import List, Tuple def count_unique_sums_of_leaves(n: int, leaves: List[int], edges: List[Tuple[int, int]]) -> int: Monica has a tree in her backyard, and each autumn she collects the leaves that fall. The tree has n branches, and each branch can either be a leaf or have child branches attached. Each autumn, Monica writes down the number of leaves that fall from each branch. Monica wants to know how many different sums of leaves she can get by selecting a subtree of the tree. A subtree of the tree rooted at branch x is a branch x and all its descendants in the tree. Given the tree structure and the number of leaves falling from each branch, help Monica find the number of different sums of leaves she can collect by selecting a subtree. Parameters: n (int): the number of branches in the tree. leaves (List[int]): the number of leaves on each branch. edges (List[Tuple[int, int]]): indicating that branch u is directly connected to branch v. Returns: int: the number of different sums of leaves she can collect by selecting a subtree. Example: >>> count_unique_sums_of_leaves(6, [4, 2, 3, 1, 1, 5], [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6)]) 5 pass def test_example(): n = 6 leaves = [4, 2, 3, 1, 1, 5] edges = [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6)] assert count_unique_sums_of_leaves(n, leaves, edges) == 5 def test_single_node(): n = 1 leaves = [4] edges = [] assert count_unique_sums_of_leaves(n, leaves, edges) == 1 def test_straight_line(): n = 3 leaves = [1, 2, 3] edges = [(1, 2), (2, 3)] assert count_unique_sums_of_leaves(n, leaves, edges) == 3 def test_binary_tree(): n = 7 leaves = [1, 2, 3, 4, 5, 6, 7] edges = [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)] assert count_unique_sums_of_leaves(n, leaves, edges) == 7 def test_complex_tree(): n = 5 leaves = [4, 0, 2, 1, 3] edges = [(1, 2), (1, 3), (3, 4), (3, 5)] assert count_unique_sums_of_leaves(n, leaves, edges) == 5","solution":"def count_unique_sums_of_leaves(n, leaves, edges): def dfs(node, parent): subtree_sum = leaves[node] for neighbor in adj[node]: if neighbor != parent: subtree_sum += dfs(neighbor, node) unique_sums.add(subtree_sum) return subtree_sum # Build adjacency list adj = {i: [] for i in range(n)} for u, v in edges: adj[u - 1].append(v - 1) adj[v - 1].append(u - 1) unique_sums = set() dfs(0, -1) return len(unique_sums)"},{"question":"def min_operations(source: str, target: str) -> int: Determine the minimum number of operations required to convert the source string into the target string. >>> min_operations(\\"kitten\\", \\"sitting\\") 3 >>> min_operations(\\"intention\\", \\"execution\\") 5 >>> min_operations(\\"abc\\", \\"abc\\") 0 >>> min_operations(\\"\\", \\"abc\\") 3 >>> min_operations(\\"abc\\", \\"\\") 3 >>> min_operations(\\"abcd\\", \\"abcde\\") 1 >>> min_operations(\\"abcde\\", \\"abcd\\") 1 >>> min_operations(\\"abc\\", \\"adc\\") 1","solution":"def min_operations(source, target): Returns the minimum number of operations required to convert source string into target string. m = len(source) n = len(target) # Create a DP table to store results of subproblems dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill dp[][] bottom up for i in range(m + 1): for j in range(n + 1): # If source is empty, the only option is to insert all characters of target if i == 0: dp[i][j] = j # Minimum operations = j # If target is empty, the only option is to remove all characters of source elif j == 0: dp[i][j] = i # Minimum operations = i # If last characters are the same, ignore the last char and recur for remaining string elif source[i-1] == target[j-1]: dp[i][j] = dp[i-1][j-1] # If last character is different, consider all possibilities and find the minimum else: dp[i][j] = 1 + min(dp[i][j-1], # Insert dp[i-1][j], # Remove dp[i-1][j-1]) # Replace return dp[m][n]"},{"question":"def min_swaps_to_sort(arr: List[int]) -> int: Determine the minimum number of swaps needed to sort the given array. Parameters: arr (list): A list of unique integers. Returns: int: The minimum number of swaps required. pass # Example usage: if __name__ == \\"__main__\\": n = int(input()) arr = list(map(int, input().split())) print(min_swaps_to_sort(arr)) # Unit tests def test_min_swaps_to_sort_example(): assert min_swaps_to_sort([5, 4, 3, 2, 1]) == 2 def test_min_swaps_to_sort_sorted_array(): assert min_swaps_to_sort([1, 2, 3, 4, 5]) == 0 def test_min_swaps_to_sort_two_element_array(): assert min_swaps_to_sort([2, 1]) == 1 def test_min_swaps_to_sort_random_order(): assert min_swaps_to_sort([4, 3, 1, 2, 5]) == 3 def test_min_swaps_to_sort_another_case(): assert min_swaps_to_sort([1, 5, 4, 3, 2]) == 2","solution":"def min_swaps_to_sort(arr): Determine the minimum number of swaps needed to sort the given array. Parameters: arr (list): A list of unique integers. Returns: int: The minimum number of swaps required. n = len(arr) # Create a list of tuples where each tuple is (number, index) indexed_array = list(enumerate(arr)) # Sort the tuple list based on the number value indexed_array.sort(key=lambda x: x[1]) visited = [False] * n swaps = 0 for i in range(n): # If already visited or already in correct place if visited[i] or indexed_array[i][0] == i: continue # Find out the size of the cycle cycle_size = 0 x = i while not visited[x]: visited[x] = True x = indexed_array[x][0] cycle_size += 1 # Add the number of swaps for this cycle if cycle_size > 0: swaps += (cycle_size - 1) return swaps # Example usage: if __name__ == \\"__main__\\": n = int(input()) arr = list(map(int, input().split())) print(min_swaps_to_sort(arr))"},{"question":"def minimum_adventurers_to_cross(n: int, bridge_limits: List[int], adventurer_weights: List[int]) -> int: Determines the minimum number of adventurers required to cross all the bridges. Parameters: - n (int): The number of bridges. - bridge_limits (list of int): The weight limits of the bridges. - adventurer_weights (list of int): The weights of the adventurers. Returns: - int: The minimum number of adventurers required to cross all the bridges. pass # Unit Tests def test_all_adventurers_can_cross(): assert minimum_adventurers_to_cross(3, [5, 9, 2], [4, 8, 1]) == 3 def test_some_adventurers_can_cross(): assert minimum_adventurers_to_cross(2, [10, 15], [9, 14]) == 2 def test_no_adventurers_can_cross(): assert minimum_adventurers_to_cross(3, [5, 6, 7], [10, 11, 12]) == 0 def test_mixed_cases(): assert minimum_adventurers_to_cross(4, [4, 8, 5, 9], [2, 5, 8, 10]) == 3 def test_single_bridge_and_adventurer(): assert minimum_adventurers_to_cross(1, [3], [2]) == 1 assert minimum_adventurers_to_cross(1, [3], [4]) == 0","solution":"def minimum_adventurers_to_cross(n, bridge_limits, adventurer_weights): Determines the minimum number of adventurers required to cross all the bridges. Parameters: - n (int): The number of bridges. - bridge_limits (list of int): The weight limits of the bridges. - adventurer_weights (list of int): The weights of the adventurers. Returns: - int: The minimum number of adventurers required to cross all the bridges. bridge_limits.sort() adventurer_weights.sort() adventurers_needed = 0 j = 0 # Pointer for adventurer weights for i in range(n): while j < n and adventurer_weights[j] > bridge_limits[i]: j += 1 if j == n: break adventurers_needed += 1 j += 1 return adventurers_needed"},{"question":"def distribute_items(n: int, k: int, weights: List[int]) -> int: Determine the minimum possible maximum weight limit required for containers such that all items can be distributed into k containers without exceeding the weight limit. :param n: The number of items. :param k: The number of containers. :param weights: A list of integers representing the weights of the items. :return: An integer representing the minimum possible maximum weight limit. >>> distribute_items(5, 3, [1, 2, 3, 4, 5]) 6 >>> distribute_items(4, 4, [1, 2, 3, 4]) 4 >>> distribute_items(4, 2, [4, 4, 4, 4]) 8 >>> distribute_items(6, 3, [10, 20, 30, 40, 50, 60]) 90 >>> distribute_items(5, 1, [1, 2, 3, 4, 5]) 15 >>> distribute_items(4, 2, [5, 5, 5, 5]) 10 >>> distribute_items(5, 5, [1, 2, 3, 4, 5]) 5","solution":"def distribute_items(n, k, weights): def canDistribute(mid): current_sum = 0 required_containers = 1 for weight in weights: if current_sum + weight > mid: required_containers += 1 current_sum = weight if required_containers > k: return False else: current_sum += weight return True low = max(weights) high = sum(weights) while low < high: mid = (low + high) // 2 if canDistribute(mid): high = mid else: low = mid + 1 return low"},{"question":"from itertools import combinations def find_minimum_balance(n: int, fi: List[int]) -> int: Finds the minimum possible balance of Lola's spice blend. Parameters: n (int): the number of spices (always even) fi (List[int]): list of flavor intensities of the spices Returns: int: the minimum possible balance Examples: >>> find_minimum_balance(4, [10, 20, 30, 40]) 0 >>> find_minimum_balance(6, [1, 2, 3, 4, 5, 6]) 1","solution":"from itertools import combinations def find_minimum_balance(n, fi): Finds the minimum possible balance of Lola's spice blend. total_sum = sum(fi) half_n = n // 2 min_balance = float('inf') for combo in combinations(fi, half_n): selected_sum = sum(combo) unselected_sum = total_sum - selected_sum balance = abs(selected_sum - unselected_sum) if balance < min_balance: min_balance = balance return min_balance"},{"question":"from typing import List, Tuple def perform_swaps(grid: List[List[int]], operations: List[Tuple[int, int, int, int]]) -> List[List[int]]: Perform the given swap operations on the grid and return the final state of the grid. :param grid: List of lists representing the initial state of the grid. :param operations: List of tuples representing swap operations. :return: List of lists representing the final state of the grid after all operations. for x1, y1, x2, y2 in operations: # Convert to 0-based indices x1 -= 1 y1 -= 1 x2 -= 1 y2 -= 1 # Perform the swap grid[x1][y1], grid[x2][y2] = grid[x2][y2], grid[x1][y1] return grid def read_input_and_process_operations(m: int, n: int, k: int, grid: List[List[int]], operations: List[Tuple[int, int, int, int]]) -> List[List[int]]: Read the input dimensions, initial grid, and operations, then process the operations to compute the final grid state. >>> m, n, k = 3, 3, 2 >>> grid = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> operations = [ ... (1, 1, 3, 3), ... (2, 2, 3, 1) ... ] >>> read_input_and_process_operations(m, n, k, grid, operations) [[9, 2, 3], [4, 7, 6], [5, 8, 1]] return perform_swaps(grid, operations) def test_sample_case(): m, n, k = 3, 3, 2 grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] operations = [ (1, 1, 3, 3), (2, 2, 3, 1) ] expected_output = [ [9, 2, 3], [4, 7, 6], [5, 8, 1] ] assert read_input_and_process_operations(m, n, k, grid, operations) == expected_output def test_no_operations(): m, n, k = 2, 2, 0 grid = [ [1, 2], [3, 4] ] operations = [] expected_output = [ [1, 2], [3, 4] ] assert read_input_and_process_operations(m, n, k, grid, operations) == expected_output def test_single_swap(): m, n, k = 2, 2, 1 grid = [ [1, 2], [3, 4] ] operations = [ (1, 1, 2, 2) ] expected_output = [ [4, 2], [3, 1] ] assert read_input_and_process_operations(m, n, k, grid, operations) == expected_output def test_multiple_swaps(): m, n, k = 2, 2, 2 grid = [ [1, 2], [3, 4] ] operations = [ (1, 1, 2, 2), (1, 2, 2, 1) ] expected_output = [ [4, 3], [2, 1] ] assert read_input_and_process_operations(m, n, k, grid, operations) == expected_output","solution":"def perform_swaps(grid, operations): Perform the given swap operations on the grid and return the final state of the grid. :param grid: List of lists representing the initial state of the grid. :param operations: List of tuples representing swap operations. :return: List of lists representing the final state of the grid after all operations. for x1, y1, x2, y2 in operations: # Convert to 0-based indices x1 -= 1 y1 -= 1 x2 -= 1 y2 -= 1 # Perform the swap grid[x1][y1], grid[x2][y2] = grid[x2][y2], grid[x1][y1] return grid def read_input_and_process_operations(m, n, k, grid, operations): return perform_swaps(grid, operations)"},{"question":"def sum_at_depth(h: int, d: int) -> int: Calculates the sum of all nodes' values at a given depth in a perfect binary tree of height \`h\`. Args: h (int): The height of the perfect binary tree (1  h  20). d (int): The depth at which the sum of nodes' values needs to be calculated (0  d  h-1). Returns: int: The sum of all nodes' values at depth \`d\`. Examples: >>> sum_at_depth(3, 2) 22 >>> sum_at_depth(3, 0) 1","solution":"def sum_at_depth(h, d): Returns the sum of all node values at depth \`d\` in a perfect binary tree of height \`h\`. if d == 0: return 1 start = 2**d end = 2**(d+1) - 1 return sum(range(start, end + 1))"},{"question":"def min_swaps_to_sort(arr: List[int]) -> int: Returns the minimum number of swaps required to sort the array in non-decreasing order. Args: arr (list): The list of integers to sort. Returns: int: The minimum number of swaps. >>> min_swaps_to_sort([4, 3, 2, 1]) 6 >>> min_swaps_to_sort([1, 2, 3, 4]) 0 >>> min_swaps_to_sort([1]) 0","solution":"def count_inversions(arr): Counts the number of inversions in the array using a modified merge sort. Args: arr (list): The list of integers to count inversions in. Returns: int: The number of inversions needed to sort the array. def merge_count_split_inv(arr, temp_arr, left, mid, right): i = left # Starting index for left subarray j = mid + 1 # Starting index for right subarray k = left # Starting index to be sorted inv_count = 0 while i <= mid and j <= right: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: temp_arr[k] = arr[j] inv_count += (mid-i + 1) # Number of inversions j += 1 k += 1 while i <= mid: temp_arr[k] = arr[i] i += 1 k += 1 while j <= right: temp_arr[k] = arr[j] j += 1 k += 1 for i in range(left, right + 1): arr[i] = temp_arr[i] return inv_count def merge_sort_and_count(arr, temp_arr, left, right): inv_count = 0 if left < right: mid = (left + right)//2 inv_count += merge_sort_and_count(arr, temp_arr, left, mid) inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right) inv_count += merge_count_split_inv(arr, temp_arr, left, mid, right) return inv_count n = len(arr) temp_arr = [0]*n return merge_sort_and_count(arr, temp_arr, 0, n-1) def min_swaps_to_sort(arr): Returns the minimum number of swaps required to sort the array in non-decreasing order. Args: arr (list): The list of integers to sort. Returns: int: The minimum number of swaps. return count_inversions(arr)"},{"question":"def find_pair(A: List[int], x: int) -> bool: Determine whether there exist two distinct indices i and j such that A[i] + A[j] = x. Args: A: List[int] - List of integers x: int - Target sum Returns: bool - True if such indices exist, False otherwise Examples: >>> find_pair([1, 2, 3, 4, 5], 9) True >>> find_pair([1, 2, 3, 4, 5], 10) False >>> find_pair([-1, -2, -3, -4, -5], -8) True >>> find_pair([-3, 1, 4, -2, 6], 4) True >>> find_pair([], 1) False >>> find_pair([1], 2) False >>> find_pair([0, 2, 4, 6], 6) True >>> find_pair([0, 2, 4, 6], 8) True >>> find_pair([2, 2], 4) True >>> find_pair([1, 2, 3, 3], 6) True >>> find_pair([1, 2, 3, 3], 7) False","solution":"def find_pair(A, x): Returns True if there exist two distinct indices i and j such that A[i] + A[j] = x, False otherwise. Args: A: List[int] - List of integers x: int - Target sum Returns: bool - True if such indices exist, False otherwise seen = set() for number in A: if x - number in seen: return True seen.add(number) return False"},{"question":"def min_rotations_to_open_padlock(n: int, initial_sequence: str, secret_sequence: str) -> int: Determine the minimum total rotations required to match the initial sequence to the secret sequence. >>> min_rotations_to_open_padlock(4, \\"1234\\", \\"4321\\") 8 >>> min_rotations_to_open_padlock(1, \\"0\\", \\"0\\") 0 >>> min_rotations_to_open_padlock(1, \\"0\\", \\"9\\") 1 >>> min_rotations_to_open_padlock(1, \\"5\\", \\"0\\") 5 >>> min_rotations_to_open_padlock(1, \\"5\\", \\"5\\") 0 >>> min_rotations_to_open_padlock(2, \\"00\\", \\"99\\") 2 >>> min_rotations_to_open_padlock(3, \\"123\\", \\"321\\") 4","solution":"def min_rotations_to_open_padlock(n, initial_sequence, secret_sequence): total_rotations = 0 for i in range(n): initial_digit = int(initial_sequence[i]) secret_digit = int(secret_sequence[i]) # Compute direct rotation difference forward_rotation = abs(secret_digit - initial_digit) backward_rotation = 10 - forward_rotation total_rotations += min(forward_rotation, backward_rotation) return total_rotations"},{"question":"def min_transformations(t: int, test_cases: List[str]) -> List[int]: Determine the minimum number of transformations required to make a string beautiful, or -1 if it is impossible. >>> min_transformations(2, [\\"aabb\\", \\"xyz\\"]) [2, 0] >>> min_transformations(1, [\\"a\\"]) [0] >>> min_transformations(1, [\\"aaaa\\"]) [2] >>> min_transformations(4, [\\"a\\", \\"abc\\", \\"aabb\\", \\"abacb\\"]) [0, 0, 2, 0] >>> min_transformations(1, [\\"a\\"*100]) [50]","solution":"def min_transformations(t, test_cases): results = [] for s in test_cases: n = len(s) if n == 1: results.append(0) continue # count transformations required transformations = 0 i = 0 while i < n - 1: if s[i] == s[i + 1]: transformations += 1 i += 2 # skip the next character since it forms a pair already else: i += 1 results.append(transformations) return results"},{"question":"def can_fulfill_orders(n: int, m: int, skill_levels: List[int], orders: List[Tuple[int, int]]) -> str: Determine if it is possible to fulfill all the orders under the given conditions. Parameters: n (int): The number of workers. m (int): The number of orders. skill_levels (List[int]): The skill levels of the workers. orders (List[Tuple[int, int]]): The orders where each order contains complexity and quantity. Returns: str: \\"YES\\" if all orders can be fulfilled, otherwise \\"NO\\". >>> can_fulfill_orders(3, 2, [5, 3, 1], [(1, 2), (3, 1)]) \\"YES\\" >>> can_fulfill_orders(2, 2, [2, 1], [(3, 1), (1, 2)]) \\"NO\\" >>> can_fulfill_orders(1, 1, [1], [(2, 1)]) \\"NO\\" >>> can_fulfill_orders(3, 3, [3, 2, 1], [(3, 1), (2, 1), (1, 1)]) \\"YES\\" >>> can_fulfill_orders(1, 2, [5], [(3, 1), (2, 1)]) \\"YES\\"","solution":"def can_fulfill_orders(n, m, skill_levels, orders): Determine if it is possible to fulfill all the orders under the given conditions. # Sort the skill levels in descending order skill_levels.sort(reverse=True) # Sort the orders by complexity in ascending order orders.sort(key=lambda x: x[0]) for complexity, quantity in orders: fulfilled = False for i in range(n): if skill_levels[i] >= complexity: if quantity > 0: quantity -= 1 if quantity == 0: fulfilled = True break if not fulfilled: return \\"NO\\" return \\"YES\\""},{"question":"def count_special_nodes(t: int, test_cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[int]: Determine the number of special nodes in the graph for multiple test cases. A special node is a node that is connected to exactly one other node. Args: t (int): The number of test cases. test_cases (List[Tuple[int, int, List[Tuple[int, int]]]]): A list of test cases, each containing: - n (int): The number of nodes in the graph. - m (int): The number of edges in the graph. - edges (List[Tuple[int, int]]): A list of edges, each connecting two nodes u and v. Returns: List[int]: A list containing the number of special nodes in each test case. >>> count_special_nodes(1, [(4, 2, [(1, 2), (3, 4)])]) == [4] >>> count_special_nodes(1, [(5, 3, [(1, 2), (2, 3), (4, 5)])]) == [4] >>> count_special_nodes(3, [(5, 3, [(1, 2), (2, 3), (4, 5)]), (4, 2, [(1, 2), (3, 4)]), (3, 1, [(1, 2)])]) == [4, 4, 2] >>> count_special_nodes(1, [(5, 0, [])]) == [0] >>> count_special_nodes(1, [(6, 2, [(1, 2), (3, 4)])]) == [4]","solution":"def count_special_nodes(t, test_cases): results = [] for case in test_cases: n, m, edges = case degree = [0] * (n + 1) for u, v in edges: degree[u] += 1 degree[v] += 1 special_count = sum(1 for d in degree if d == 1) results.append(special_count) return results"},{"question":"def max_tower_height(n: int, d: int, heights: List[int]) -> int: Determine the maximum possible height of the tower David can build such that the difference between heights of any two adjacent blocks does not exceed d. Parameters: n (int): Number of blocks d (int): Maximum allowed height difference between adjacent blocks heights (list): List of integers representing the height of each block Returns: int: The maximum possible height of the tower >>> max_tower_height(5, 3, [1, 2, 3, 4, 5]) 15 >>> max_tower_height(5, 1, [7, 10, 3, 4, 5]) 12 >>> max_tower_height(4, 5, [2, 8, 3, 7]) 20 >>> max_tower_height(3, 0, [5, 5, 5]) 15 >>> max_tower_height(1, 10, [12]) 12","solution":"def max_tower_height(n, d, heights): Determine the maximum possible height of the tower David can build such that the difference between heights of any two adjacent blocks does not exceed d. Parameters: n (int): Number of blocks d (int): Maximum allowed height difference between adjacent blocks heights (list): List of integers representing the height of each block Returns: int: The maximum possible height of the tower heights.sort() max_height = 0 current_height = heights[0] for i in range(n): if i == 0 or heights[i] - heights[i-1] <= d: max_height += heights[i] else: break return max_height"},{"question":"def min_types_fence_panels(n, L, lengths): Finds the minimum number of different types of panels required to exactly build a fence of length L. :param n: int - number of different types of panels :param L: int - desired length of the fence :param lengths: list of int - lengths of the different types of panels :return: int - minimum number of different types of panels required or -1 if not possible Examples: >>> min_types_fence_panels(3, 8, [3, 5, 4]) 2 >>> min_types_fence_panels(3, 10, [1, 2, 3]) -1 >>> min_types_fence_panels(1, 5, [5]) 1 >>> min_types_fence_panels(1, 5, [10]) -1 >>> min_types_fence_panels(4, 15, [1, 2, 10, 5]) 2 >>> min_types_fence_panels(4, 9, [2, 3, 4, 5]) 2 >>> min_types_fence_panels(3, 1000000000, [333333333, 666666667, 1000000000]) 1 >>> min_types_fence_panels(3, 999999997, [333333333, 666666667, 1000000000]) -1","solution":"def min_types_fence_panels(n, L, lengths): Finds the minimum number of different types of panels required to exactly build a fence of length L :param n: int - number of different types of panels :param L: int - desired length of the fence :param lengths: list of int - lengths of the different types of panels :return: int - minimum number of different types of panels required or -1 if not possible from itertools import combinations # Finding all combinations of lengths to check their sums for i in range(1, n + 1): for comb in combinations(lengths, i): if sum(comb) == L: return i return -1"},{"question":"def is_possible_magic_square_swap(n: int, m: int, grid: List[List[int]]) -> str: Determine if it's possible to convert the grid into a magic square using exactly one swap of two distinct elements. >>> is_possible_magic_square_swap(2, 2, [[2, 7], [6, 1]]) 'NO' >>> is_possible_magic_square_swap(3, 3, [[8, 1, 6], [3, 5, 7], [4, 9, 2]]) 'YES'","solution":"def is_possible_magic_square_swap(n, m, grid): def is_magic_square(grid): sum_diag1 = sum([grid[i][i] for i in range(n)]) sum_diag2 = sum([grid[i][n - 1 - i] for i in range(n)]) if sum_diag1 != sum_diag2: return False for i in range(n): if sum(grid[i]) != sum_diag1: return False for i in range(m): if sum([grid[j][i] for j in range(n)]) != sum_diag1: return False return True if is_magic_square(grid): return \\"YES\\" flat_grid = [grid[i][j] for i in range(n) for j in range(m)] for i in range(n * m): for j in range(i + 1, n * m): flat_grid[i], flat_grid[j] = flat_grid[j], flat_grid[i] new_grid = [flat_grid[k * m: (k + 1) * m] for k in range(n)] if is_magic_square(new_grid): return \\"YES\\" flat_grid[i], flat_grid[j] = flat_grid[j], flat_grid[i] return \\"NO\\""},{"question":"def max_non_overlapping_events(events: List[Tuple[int, int]]) -> int: Determines the maximum number of non-overlapping events that can be scheduled in a day. Parameters: events (list of tuples): A list where each tuple contains the start and end time of an event. Returns: int: The maximum number of non-overlapping events. Example: >>> max_non_overlapping_events([(1, 4), (2, 3), (3, 5), (7, 9), (6, 8)]) 3 >>> max_non_overlapping_events([(0, 1)]) 1 >>> max_non_overlapping_events([(1, 4), (2, 5), (3, 6)]) 1 >>> max_non_overlapping_events([(1, 2), (3, 4), (5, 6)]) 3 >>> max_non_overlapping_events([(1, 4), (4, 5), (5, 6), (2, 3)]) 3 >>> max_non_overlapping_events([(0, 1), (5, 6), (10, 11), (15, 16)]) 4 >>> max_non_overlapping_events([(6, 8), (1, 4), (3, 5), (7, 9), (2, 3)]) 3 >>> max_non_overlapping_events([(i, i + 1) for i in range(0, 1000, 2)]) 500","solution":"def max_non_overlapping_events(events): Determines the maximum number of non-overlapping events that can be scheduled in a day. Parameters: events (list of tuples): A list where each tuple contains the start and end time of an event. Returns: int: The maximum number of non-overlapping events. # Sort the events by their end time events.sort(key=lambda x: x[1]) max_events = 0 last_end_time = 0 for event in events: start, end = event if start >= last_end_time: max_events += 1 last_end_time = end return max_events"},{"question":"def maximum_swap(num_str: str) -> str: Given a string of digits representing a sequence of integers, find the maximum possible integer that can be obtained by swapping at most one pair of digits. If the maximum possible integer that can be obtained is the same as the given integer, then a swap is not required. Args: num_str (str): A string consisting of digits ('0' - '9') without any leading zeros. Returns: str: The maximum possible integer as a string. >>> maximum_swap(\\"2736\\") \\"7236\\" >>> maximum_swap(\\"9973\\") \\"9973\\" >>> maximum_swap(\\"1234\\") \\"4231\\"","solution":"def maximum_swap(num_str): Returns the maximum possible integer that can be obtained by swapping at most one pair of digits from the original string. If no swap is needed, returns the original string. num_list = list(num_str) n = len(num_list) last = {int(x): i for i, x in enumerate(num_list)} for i in range(n): for d in range(9, int(num_list[i]), -1): if last.get(d, -1) > i: num_list[i], num_list[last[d]] = num_list[last[d]], num_list[i] return ''.join(num_list) return num_str"},{"question":"def is_possible(n, m, denominations): Determines if it's possible to provide exact change for amount m using at least two different denominations. Parameters: n (int): Number of different denominations. m (int): Total amount. denominations (list of int): Values of each denomination. Returns: str: \\"Possible\\" if it's possible, otherwise \\"Impossible\\". pass from solution import is_possible def test_case_1(): assert is_possible(3, 11, [1, 2, 5]) == \\"Possible\\" def test_case_2(): assert is_possible(2, 7, [2, 4]) == \\"Impossible\\" def test_case_3(): assert is_possible(2, 16, [3, 6]) == \\"Impossible\\" def test_case_4(): assert is_possible(4, 100, [1, 10, 25, 50]) == \\"Possible\\" def test_case_5(): assert is_possible(2, 8, [1, 3]) == \\"Possible\\" def test_case_6(): assert is_possible(1, 5, [5]) == \\"Impossible\\" def test_case_7(): assert is_possible(3, 15, [5, 3, 7]) == \\"Possible\\" def test_case_8(): assert is_possible(3, 8, [3, 4, 5]) == \\"Possible\\" def test_case_9(): assert is_possible(2, 9, [4, 5]) == \\"Possible\\" def test_case_10(): assert is_possible(2, 20, [3, 11]) == \\"Possible\\"","solution":"def is_possible(n, m, denominations): Determines if it's possible to provide exact change for amount m using at least two different denominations. Parameters: n (int): Number of different denominations. m (int): Total amount. denominations (list of int): Values of each denomination. Returns: str: \\"Possible\\" if it's possible, otherwise \\"Impossible\\". def can_make_amount_with_two_denominations(m, denominations): # Check all pairs of denominations to see if their combination can make up the amount m for i in range(n): for j in range(i + 1, n): for k in range(m // denominations[i] + 1): if (m - k * denominations[i]) % denominations[j] == 0: return True return False if n < 2: return \\"Impossible\\" if can_make_amount_with_two_denominations(m, denominations): return \\"Possible\\" return \\"Impossible\\""},{"question":"def longest_subsequence_with_max_height(heights: List[int], maxHeight: int) -> int: Determine the length of the longest subsequence of consecutive boxes such that the sum of their heights does not exceed the given maxHeight. Parameters: heights (List[int]): An array of integers where each integer represents the height of a box. maxHeight (int): The maximum allowable height for the conveyor belt. Returns: int: The length of the longest subsequence of consecutive boxes which can be repeated and does not exceed the given height limit. >>> longest_subsequence_with_max_height([1, 2, 3, 4, 5, 6, 7, 8], 15) 5 >>> longest_subsequence_with_max_height([5, 1, 3, 8, 2], 10) 3 >>> longest_subsequence_with_max_height([3, 1, 4, 1, 5], 6) 3 >>> longest_subsequence_with_max_height([1, 1, 1, 1, 1], 2) 2 >>> longest_subsequence_with_max_height([2, 3, 1, 2, 4, 3], 5) 2","solution":"def longest_subsequence_with_max_height(heights, maxHeight): start = 0 current_sum = 0 max_length = 0 for end in range(len(heights)): current_sum += heights[end] while current_sum > maxHeight: current_sum -= heights[start] start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"def compare_versions(version1: str, version2: str) -> int: Compares two version strings. Returns 1 if version1 is greater than version2, Returns -1 if version1 is less than version2, Returns 0 if they are equal. Args: version1: str version2: str Returns: int >>> compare_versions(\\"1.0\\", \\"1.0.0\\") 0 >>> compare_versions(\\"1.0.2\\", \\"1.0.10\\") -1 >>> compare_versions(\\"2.0\\", \\"1.9.9\\") 1 # Unit tests def test_equal_versions(): assert compare_versions(\\"1.0\\", \\"1.0.0\\") == 0 assert compare_versions(\\"1.0.0\\", \\"1.0.0\\") == 0 assert compare_versions(\\"1\\", \\"1.0.0.0\\") == 0 def test_version1_greater(): assert compare_versions(\\"1.0.1\\", \\"1.0.0\\") == 1 assert compare_versions(\\"2.0\\", \\"1.9.9\\") == 1 assert compare_versions(\\"2.0.1\\", \\"2.0.0\\") == 1 def test_version2_greater(): assert compare_versions(\\"1.0.0\\", \\"1.0.1\\") == -1 assert compare_versions(\\"1.9.9\\", \\"2.0\\") == -1 assert compare_versions(\\"2.0.0\\", \\"2.0.1\\") == -1 def test_complex_cases(): assert compare_versions(\\"1.0.10\\", \\"1.0.2\\") == 1 assert compare_versions(\\"1.2.3.4\\", \\"1.2.3\\") == 1 assert compare_versions(\\"1.2.3\\", \\"1.2.3.4\\") == -1","solution":"def compare_versions(version1, version2): Compares two version strings. Returns 1 if version1 is greater than version2, Returns -1 if version1 is less than version2, Returns 0 if they are equal. # Split the version strings by '.' levels1 = version1.split('.') levels2 = version2.split('.') # Determine the max length of both levels max_length = max(len(levels1), len(levels2)) # Pad the shorter version levels with '0' to make them of equal length for i in range(max_length): level1 = int(levels1[i]) if i < len(levels1) else 0 level2 = int(levels2[i]) if i < len(levels2) else 0 if level1 > level2: return 1 elif level1 < level2: return -1 # If all levels are equal return 0"},{"question":"def minimal_communication_paths(n: int, relationships: List[Tuple[int, int]]) -> int: Determine the minimal number of communication paths needed to send a message from the CEO to all employees in a hierarchical structure. Args: n: an integer, the number of employees in the company. relationships: a list of tuples, where each tuple contains two integers u and v representing a direct reporting relationship where u is a direct manager of v. Returns: An integer, the minimal number of paths required to spread the message to all employees. >>> minimal_communication_paths(1, []) 0 >>> minimal_communication_paths(6, [(1, 2), (1, 3), (2, 4), (3, 5), (3, 6)]) 5 from typing import List, Tuple def test_single_employee(): assert minimal_communication_paths(1, []) == 0 def test_example_case(): assert minimal_communication_paths(6, [(1, 2), (1, 3), (2, 4), (3, 5), (3, 6)]) == 5 def test_two_employees(): assert minimal_communication_paths(2, [(1, 2)]) == 1 def test_another_case(): assert minimal_communication_paths(4, [(1, 2), (1, 3), (2, 4)]) == 3","solution":"def minimal_communication_paths(n, relationships): if n == 1: return 0 # Create the adjacency list from collections import defaultdict managers = defaultdict(list) for u, v in relationships: managers[u].append(v) # The number of paths needed is equivalent to the number of edges return n - 1"},{"question":"def min_moves_to_palindrome(s: str) -> int: Calculate the minimum number of moves needed to transform the given string into a palindrome. >>> min_moves_to_palindrome(\\"abac\\") 1 >>> min_moves_to_palindrome(\\"aabb\\") 2 >>> min_moves_to_palindrome(\\"racecar\\") 0 >>> min_moves_to_palindrome(\\"abcd\\") 3 >>> min_moves_to_palindrome(\\"aaaa\\") 0 >>> min_moves_to_palindrome(\\"a\\") 0 def solve(test_cases: List[str]) -> List[int]: Calculate the minimum number of moves needed for each string in the list to transform it into a palindrome. >>> solve([\\"abac\\", \\"aabb\\"]) [1, 2] >>> solve([\\"racecar\\"]) [0] >>> solve([\\"abcd\\"]) [3] >>> solve([\\"aaaa\\"]) [0] >>> solve([\\"abcdefghijklmnopqrstuvwxyz\\"]) [25]","solution":"def min_moves_to_palindrome(s): n = len(s) # Create a DP table to store the length of the longest palindromic subsequence dp = [[0] * n for _ in range(n)] # Fill the dp table for i in range(n): dp[i][i] = 1 for cl in range(2, n + 1): for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j] and cl == 2: dp[i][j] = 2 elif s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) # The length of the longest palindromic subsequence lps = dp[0][n - 1] # The minimum number of deletions to make the string a palindrome return n - lps def solve(test_cases): results = [] for s in test_cases: results.append(min_moves_to_palindrome(s)) return results"},{"question":"def rotate_list(n: int, k: int, nums: List[int]) -> List[int]: Returns the list after performing k circular right rotations. >>> rotate_list(5, 2, [1, 2, 3, 4, 5]) [4, 5, 1, 2, 3] >>> rotate_list(5, 0, [1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> rotate_list(5, 1, [1, 2, 3, 4, 5]) [5, 1, 2, 3, 4] >>> rotate_list(5, 10, [1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> rotate_list(5, 11, [1, 2, 3, 4, 5]) [5, 1, 2, 3, 4]","solution":"def rotate_list(n, k, nums): Returns the list after performing k circular right rotations. k = k % n # Only need to consider the remainder of k divided by n return nums[-k:] + nums[:-k]"},{"question":"def max_difference_with_removal(heights): Returns the maximum possible difference in heights after removing at most one person. >>> max_difference_with_removal([10, 3, 8, 6, 7]) 7 >>> max_difference_with_removal([1, 2, 3, 4, 5]) 4 >>> max_difference_with_removal([15, 7, 9, 12]) 8 >>> max_difference_with_removal([1, 100]) 0 >>> max_difference_with_removal([100, 200, 300, 400, 500]) 400 >>> max_difference_with_removal([5, 10, 15, 20, 25]) 20","solution":"def max_difference_with_removal(heights): Returns the maximum possible difference in heights after removing at most one person. n = len(heights) if n <= 2: return 0 # If there are only two people, removing one leaves no difference sorted_heights = sorted(heights) # Case 1: Remove the smallest height (max diff is between second smallest and largest) max_diff_remove_min = sorted_heights[-1] - sorted_heights[1] # Case 2: Remove the largest height (max diff is between smallest and second largest) max_diff_remove_max = sorted_heights[-2] - sorted_heights[0] # Case 3: Remove none (original max diff) max_diff_no_removal = sorted_heights[-1] - sorted_heights[0] return max(max_diff_remove_min, max_diff_remove_max, max_diff_no_removal)"},{"question":"def can_pair_monsters(n: int, strengths: List[int]) -> bool: Determines if it's possible to pair the strengths such that each pair sums up to the same value. Arguments: n : int : the number of monsters (always even) strengths : list[int] : list of strength values of the monsters Returns: bool : True if such a pairing is possible, False otherwise Example: >>> can_pair_monsters(4, [1, 2, 3, 4]) True >>> can_pair_monsters(6, [1, 1, 1, 1, 1, 5]) False >>> can_pair_monsters(4, [3, 3, 3, 3]) True","solution":"def can_pair_monsters(n, strengths): Determines if it's possible to pair the strengths such that each pair sums up to the same value. Arguments: n : int : the number of monsters (always even) strengths : list[int] : list of strength values of the monsters Returns: bool : True if such a pairing is possible, False otherwise strengths.sort() # Calculate the expected sum of each pair expected_sum = strengths[0] + strengths[-1] # Check all pairs to see if they sum to the expected_sum for i in range(n // 2): if strengths[i] + strengths[n - 1 - i] != expected_sum: return False return True"},{"question":"from typing import List, Tuple def longest_path_length(n: int, edges: List[Tuple[int, int]]) -> int: Calculate the length of the longest path in a tree. Parameters: n (int): The number of nodes in the tree. edges (List[Tuple[int, int]]): The tree edges represented as tuples of endpoints. Returns: int: The length of the longest path in the tree. Example: >>> longest_path_length(5, [(1, 2), (1, 3), (3, 4), (3, 5)]) 3 >>> longest_path_length(2, [(1, 2)]) 1 pass def test_sample_case(): n = 5 edges = [(1, 2), (1, 3), (3, 4), (3, 5)] assert longest_path_length(n, edges) == 3 def test_small_tree(): n = 2 edges = [(1, 2)] assert longest_path_length(n, edges) == 1 def test_line_tree(): n = 4 edges = [(1, 2), (2, 3), (3, 4)] assert longest_path_length(n, edges) == 3 def test_star_tree(): n = 4 edges = [(1, 2), (1, 3), (1, 4)] assert longest_path_length(n, edges) == 2 def test_unbalanced_tree(): n = 6 edges = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)] assert longest_path_length(n, edges) == 5","solution":"from collections import defaultdict, deque def longest_path_length(n, edges): def bfs(start_node): visited = [-1] * n queue = deque([start_node]) visited[start_node] = 0 farthest_node = start_node max_distance = 0 while queue: node = queue.popleft() current_distance = visited[node] for neighbor in graph[node]: if visited[neighbor] == -1: visited[neighbor] = current_distance + 1 queue.append(neighbor) if visited[neighbor] > max_distance: max_distance = visited[neighbor] farthest_node = neighbor return farthest_node, max_distance graph = defaultdict(list) for u, v in edges: graph[u-1].append(v-1) graph[v-1].append(u-1) first_far_node, _ = bfs(0) second_far_node, diameter = bfs(first_far_node) return diameter"},{"question":"def maximum_subgrid_sum(grid: List[List[int]]) -> int: Ahmed has a rectangular grid of size n x m (n rows and m columns) filled with non-negative integers. He wants to find the largest possible sum of numbers when he selects a sub-grid (a contiguous subarray from the grid). The sub-grid must consist of at least one element. Args: grid: List of List of non-negative integers representing the grid. Returns: int: The maximum sum of any sub-grid within the grid. Examples: >>> maximum_subgrid_sum([[5]]) 5 >>> maximum_subgrid_sum([[-5]]) -5 >>> maximum_subgrid_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 45 >>> maximum_subgrid_sum([[-1, -2, -3], [-4, -5, -6], [-7, -8, -9]]) -1 >>> maximum_subgrid_sum([[1, 2, -1], [-3, 4, 2], [1, -2, 1]]) 7 >>> grid = [[10**9, -10**9], [-10**9, 10**9]] >>> maximum_subgrid_sum(grid) 10**9 >>> grid = [[-10**9, -10**9], [-10**9, -10**9]] >>> maximum_subgrid_sum(grid) -10**9","solution":"def maximum_subgrid_sum(grid): def kadane(arr): max_sum = curr_sum = arr[0] for num in arr[1:]: curr_sum = max(num, curr_sum + num) max_sum = max(max_sum, curr_sum) return max_sum n = len(grid) m = len(grid[0]) max_sum = float('-inf') for left in range(m): temp = [0] * n for right in range(left, m): for i in range(n): temp[i] += grid[i][right] max_sum = max(max_sum, kadane(temp)) return max_sum"},{"question":"def find_participant_positions(n: int, d: List[int]) -> List[int]: Finds the positions of the parade participants on the street. Parameters: n (int): The number of participants. d (list of int): The distances between consecutive participants. Returns: list of int: The positions of the participants on the street. >>> find_participant_positions(3, [2, 3]) [0, 2, 5] >>> find_participant_positions(2, [1]) [0, 1] >>> find_participant_positions(4, [3, 3, 3]) [0, 3, 6, 9] >>> find_participant_positions(5, [1, 2, 3, 4]) [0, 1, 3, 6, 10] >>> find_participant_positions(3, [100, 100]) [0, 100, 200] >>> find_participant_positions(4, [4, 3, 2]) [0, 4, 7, 9]","solution":"def find_participant_positions(n, d): Finds the positions of the parade participants on the street. Parameters: n (int): The number of participants. d (list of int): The distances between consecutive participants. Returns: list of int: The positions of the participants on the street. positions = [0] * n for i in range(1, n): positions[i] = positions[i - 1] + d[i - 1] return positions"},{"question":"def min_elevator_stops(n, k): Calculates the minimum number of elevator stops Erin must wait for before she reaches or surpasses her grandmother's floor. The elevator stops at every second floor it passes. Args: n (int): The number of floors in the building. k (int): The floor number where Erins grandmother lives. Returns: int: The minimum number of elevator stops. Examples: >>> min_elevator_stops(10, 7) 3 >>> min_elevator_stops(12, 9) 4 >>> min_elevator_stops(15, 15) 7 >>> min_elevator_stops(5, 2) 1 >>> min_elevator_stops(2, 2) 1 >>> min_elevator_stops(1000000, 500000) 250000 >>> min_elevator_stops(1000000, 999999) 499999","solution":"def min_elevator_stops(n, k): Returns the minimum number of elevator stops before Erin reaches or surpasses her grandmother's floor. The elevator stops at every second floor it passes. # Starting from the first floor. current_floor = 1 stops_count = 0 while current_floor < k: # Move the floor up by 2 for every stop current_floor += 2 stops_count += 1 return stops_count"},{"question":"from collections import Counter def can_rearrange_string(s: str) -> str: Determines if a given string can be rearranged such that no two adjacent characters are the same. Parameters: s (str): Input string consisting of lowercase English letters. Returns: str: \\"YES\\" if rearrangement is possible, \\"NO\\" otherwise. >>> can_rearrange_string(\\"aab\\") \\"YES\\" >>> can_rearrange_string(\\"aaab\\") \\"NO\\" >>> can_rearrange_string(\\"aaaa\\") \\"NO\\" >>> can_rearrange_string(\\"abcdef\\") \\"YES\\" >>> can_rearrange_string(\\"aaabc\\") \\"YES\\" >>> can_rearrange_string(\\"aaaabc\\") \\"NO\\" >>> can_rearrange_string(\\"a\\") \\"YES\\" >>> can_rearrange_string(\\"ab\\") \\"YES\\" >>> can_rearrange_string(\\"aa\\") \\"NO\\"","solution":"from collections import Counter def can_rearrange_string(s): Determines if a given string can be rearranged such that no two adjacent characters are the same. Parameters: s (str): Input string consisting of lowercase English letters. Returns: str: \\"YES\\" if rearrangement is possible, \\"NO\\" otherwise. char_count = Counter(s) max_freq = max(char_count.values()) # To avoid adjacent characters being the same, the max frequency # character count should not be more than (length of string + 1) // 2 if max_freq > (len(s) + 1) // 2: return \\"NO\\" return \\"YES\\""},{"question":"def four_sum(nums: List[int], target: int) -> List[List[int]]: Implement a function that takes a list of integers and a target sum, and returns all unique quadruplets [a, b, c, d] such that a + b + c + d = target. >>> sorted(four_sum([1, 0, -1, 0, -2, 2], 0)) == sorted([[-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]]) >>> four_sum([1, 2, 3, 4], 50) == [] >>> four_sum([2, 2, 2, 2, 2], 8) == [[2, 2, 2, 2]] >>> sorted(four_sum([-3, -1, 0, 2, 4, 5], 2)) == sorted([[-3, -1, 2, 4]]) >>> sorted(four_sum([1, 0, -1, 0, -2, 2, -1, -4], -1)) == sorted([[-4, 0, 1, 2], [-2, -1, 0, 2], [-2, 0, 0, 1], [-1, -1, 0, 1]])","solution":"from typing import List def four_sum(nums: List[int], target: int) -> List[List[int]]: nums.sort() res = [] length = len(nums) for i in range(length - 3): if i > 0 and nums[i] == nums[i - 1]: continue for j in range(i + 1, length - 2): if j > i + 1 and nums[j] == nums[j - 1]: continue left, right = j + 1, length - 1 while left < right: total = nums[i] + nums[j] + nums[left] + nums[right] if total == target: res.append([nums[i], nums[j], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif total < target: left += 1 else: right -= 1 return res"},{"question":"def min_operations_to_palindrome(s: str) -> int: Returns the minimum number of operations required to make the string \`s\` palindromic. >>> min_operations_to_palindrome(\\"abc\\") 1 >>> min_operations_to_palindrome(\\"abca\\") 1 >>> min_operations_to_palindrome(\\"abcd\\") 2 pass def solve_palindrome_operations(test_cases: List[str]) -> List[int]: Solves multiple test cases and returns the results as a list. >>> solve_palindrome_operations([\\"abc\\", \\"abca\\", \\"abcd\\"]) [1, 1, 2] >>> solve_palindrome_operations([\\"a\\", \\"aa\\", \\"ab\\", \\"racecar\\", \\"hello\\", \\"world\\"]) [0, 0, 1, 0, 2, 2] pass","solution":"def min_operations_to_palindrome(s): Returns the minimum number of operations required to make the string \`s\` palindromic. n = len(s) operations = 0 for i in range(n // 2): if s[i] != s[n - i - 1]: operations += 1 return operations def solve_palindrome_operations(test_cases): Solves multiple test cases and returns the results as a list. results = [] for s in test_cases: results.append(min_operations_to_palindrome(s)) return results"},{"question":"def filter_restaurants(r0: int, d0: int, restaurants: List[Tuple[int, int]]) -> int: Filters the restaurants based on the rating threshold and maximum distance. Parameters: r0 (int): The rating threshold. d0 (int): The maximum distance. restaurants (list of tuple): Each tuple contains the rating and distance of a restaurant. Returns: int: The number of restaurants meeting the criteria. pass # Test cases def test_filter_restaurants_example(): r0, d0 = 4, 10 restaurants = [ (5, 8), (3, 12), (4, 7), (2, 5), (5, 10) ] assert filter_restaurants(r0, d0, restaurants) == 3 def test_filter_restaurants_no_match(): r0, d0 = 5, 5 restaurants = [ (4, 5), (3, 2), (2, 1), (1, 3) ] assert filter_restaurants(r0, d0, restaurants) == 0 def test_filter_restaurants_all_match(): r0, d0 = 3, 15 restaurants = [ (5, 12), (4, 10), (3, 5) ] assert filter_restaurants(r0, d0, restaurants) == 3 def test_filter_restaurants_some_match(): r0, d0 = 3, 10 restaurants = [ (5, 15), (4, 8), (3, 9), (2, 7), (5, 10) ] assert filter_restaurants(r0, d0, restaurants) == 3 def test_filter_restaurants_exact_match(): r0, d0 = 4, 10 restaurants = [ (4, 10) ] assert filter_restaurants(r0, d0, restaurants) == 1","solution":"def filter_restaurants(r0, d0, restaurants): Filters the restaurants based on the rating threshold and maximum distance. Parameters: r0 (int): The rating threshold. d0 (int): The maximum distance. restaurants (list of tuple): Each tuple contains the rating and distance of a restaurant. Returns: int: The number of restaurants meeting the criteria. count = 0 for r, d in restaurants: if r >= r0 and d <= d0: count += 1 return count"},{"question":"from typing import List def get_combinations_string(n: int, budget: int, costs: List[int]) -> List[str]: You are given an array of integers representing the costs of different items in a shop. You have a certain budget and you want to buy a combination of these items such that the total cost is exactly equal to your budget. You can only buy each item once. Write a function that returns all the distinct combinations of items that sum up to the given budget. The first line contains two integers n (1 <= n <= 20)  the number of items, and B (1 <= B <= 1000)  your budget. The second line contains n integers c_i (1 <= c_i <= 100)  the costs of the items. >>> get_combinations_string(4, 7, [2, 3, 6, 7]) ['7'] >>> get_combinations_string(5, 8, [2, 4, 1, 7, 6]) ['1 7', '2 6'] >>> get_combinations_string(3, 15, [2, 3, 4]) ['No solution'] >>> get_combinations_string(4, 5, [2, 2, 3, 3]) ['2 3'] >>> get_combinations_string(5, 10, [2, 2, 2, 2, 2]) ['2 2 2 2 2']","solution":"from itertools import combinations def find_combinations(costs, budget): Finds all distinct combinations of items that sum up to the given budget. costs.sort() result = [] n = len(costs) def backtrack(start, current_combo, current_sum): if current_sum == budget: result.append(current_combo[:]) return if current_sum > budget: return for i in range(start, n): if i > start and costs[i] == costs[i-1]: continue current_combo.append(costs[i]) backtrack(i + 1, current_combo, current_sum + costs[i]) current_combo.pop() backtrack(0, [], 0) return result def get_combinations_string(n, budget, costs): combinations = find_combinations(costs, budget) if not combinations: return [\\"No solution\\"] sorted_combinations = sorted(combinations, key=lambda x: (len(x), x)) combination_strings = [' '.join(map(str, combo)) for combo in sorted_combinations] return combination_strings"},{"question":"def min_breaks_to_divide_chocolate(R: int, C: int) -> int: Returns the minimum number of breaks required to divide a R x C chocolate bar into 1x1 pieces. Args: R (int): Number of rows in the chocolate bar. C (int): Number of columns in the chocolate bar. Returns: int: Minimum number of breaks needed. >>> min_breaks_to_divide_chocolate(3, 5) 14 >>> min_breaks_to_divide_chocolate(1, 10) 9 >>> min_breaks_to_divide_chocolate(10, 1) 9 >>> min_breaks_to_divide_chocolate(4, 4) 15 >>> min_breaks_to_divide_chocolate(1, 1) 0 >>> min_breaks_to_divide_chocolate(1000, 1000) 999999","solution":"def min_breaks_to_divide_chocolate(R, C): Returns the minimum number of breaks required to divide a R x C chocolate bar into 1x1 pieces. return R * C - 1 # Example function call # number_of_breaks = min_breaks_to_divide_chocolate(3, 5) # print(number_of_breaks) # Output should be 14"},{"question":"def rotate_matrix_90_clockwise(matrix: List[List[int]]) -> List[List[int]]: Rotates the given n x n matrix 90 degrees clockwise. Args: matrix (list of list of int): A 2D list representing the n x n matrix. Returns: list of list of int: The rotated 2D matrix. Examples: >>> rotate_matrix_90_clockwise([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix_90_clockwise([ ... [1, 2], ... [3, 4] ... ]) [[3, 1], [4, 2]]","solution":"def rotate_matrix_90_clockwise(matrix): Rotates the given n x n matrix 90 degrees clockwise. Args: matrix (list of list of int): A 2D list representing the n x n matrix. Returns: list of list of int: The rotated 2D matrix. n = len(matrix) rotated_matrix = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated_matrix[j][n - 1 - i] = matrix[i][j] return rotated_matrix"},{"question":"def find_min_guards(n: int, m: int, corridors: List[Tuple[int, int]]) -> int: Finds the minimum number of guards needed to ensure every room is watched. Parameters: n (int): Number of rooms. m (int): Number of corridors. corridors (list of tuple): List of corridors represented as tuples (u, v). Returns: int: Minimum number of guards needed. >>> find_min_guards(5, 4, [(1, 2), (1, 3), (1, 4), (1, 5)]) == 1 >>> find_min_guards(1, 0, []) == 1 >>> find_min_guards(5, 0, []) == 5 >>> find_min_guards(6, 3, [(1, 2), (3, 4), (5, 6)]) == 3 >>> find_min_guards(6, 4, [(1, 2), (2, 3), (4, 5), (5, 6)]) == 2 >>> find_min_guards(4, 3, [(1, 2), (2, 3), (3, 4)]) == 1","solution":"def find_min_guards(n, m, corridors): Finds the minimum number of guards needed to ensure every room is watched. Parameters: n (int): Number of rooms. m (int): Number of corridors. corridors (list of tuple): List of corridors represented as tuples (u, v). Returns: int: Minimum number of guards needed. from collections import defaultdict, deque def bfs(start): queue = deque([start]) visited[start] = current_component while queue: node = queue.popleft() for neighbor in graph[node]: if visited[neighbor] == -1: visited[neighbor] = current_component queue.append(neighbor) # Build adjacency list of graph graph = defaultdict(list) for u, v in corridors: graph[u].append(v) graph[v].append(u) visited = [-1] * (n + 1) current_component = 0 # Find connected components for room in range(1, n + 1): if visited[room] == -1: bfs(room) current_component += 1 # The number of guards needed is equal to the number of connected components return current_component # Example usage: n = 5 m = 4 corridors = [(1, 2), (1, 3), (1, 4), (1, 5)] print(find_min_guards(n, m, corridors)) # Output: 1"},{"question":"from typing import List, Dict def min_operations_to_modify(arr1: List[int], arr2: List[int]) -> int: Determine the minimum number of operations required to make arr1 less than or equal to arr2 for all indices. >>> min_operations_to_modify([3, 2, 5], [5, 4, 6]) == 5 >>> min_operations_to_modify([1, 2, 3], [3, 2, 1]) == -1 >>> min_operations_to_modify([10, 20, 30, 40], [15, 25, 35, 45]) == 20 pass def process_test_cases(t: int, test_cases: List[Dict[str, List[int]]]) -> List[int]: Process multiple test cases and return the results for each case. >>> process_test_cases(3, [{'n': 3, 'arr1': [3, 2, 5], 'arr2': [5, 4, 6]}, {'n': 3, 'arr1': [1, 2, 3], 'arr2': [3, 2, 1]}, {'n': 4, 'arr1': [10, 20, 30, 40], 'arr2': [15, 25, 35, 45]}]) == [5, -1, 20] pass","solution":"def min_operations_to_modify(arr1, arr2): total_operations = 0 for a, b in zip(arr1, arr2): if a > b: return -1 total_operations += b - a return total_operations def process_test_cases(t, test_cases): results = [] for i in range(t): n = test_cases[i]['n'] arr1 = test_cases[i]['arr1'] arr2 = test_cases[i]['arr2'] result = min_operations_to_modify(arr1, arr2) results.append(result) return results"},{"question":"def max_possible_area(heights, widths): Returns the maximum possible area of a rectangle that can be formed by choosing one element from heights and another element from widths. >>> max_possible_area([1, 2, 3, 4], [10, 20, 30]) 120 >>> max_possible_area([5], [100]) 500 >>> max_possible_area([50, 50, 50], [30, 30, 30]) 1500 >>> max_possible_area([4, 7, 9, 3, 5], [2, 6, 8, 1, 7]) 72 >>> max_possible_area([100, 150, 200], [300, 400, 500]) 100000","solution":"def max_possible_area(heights, widths): Returns the maximum possible area of a rectangle that can be formed by choosing one element from heights and another element from widths. max_height = max(heights) max_width = max(widths) return max_height * max_width"},{"question":"def minimum_travel_weight(n: int, edges: List[Tuple[int, int, int]]) -> int: Calculate the minimum possible total weight of the path taken by the traveler who wants to visit every node exactly once starting from node 1. Parameters: n (int): The number of nodes in the tree. edges (List[Tuple[int, int, int]]): The list of edges where each edge is represented by a tuple (u, v, w) indicating an edge between nodes u and v with weight w. Returns: int: The minimum possible total weight of the path. >>> minimum_travel_weight(4, [(1, 2, 3), (1, 3, 4), (3, 4, 2)]) 9 >>> minimum_travel_weight(2, [(1, 2, 1)]) 1 >>> minimum_travel_weight(6, [(1, 2, 3), (1, 3, 2), (2, 4, 4), (2, 5, 1), (3, 6, 5)]) 15 >>> minimum_travel_weight(5, [(1, 2, 3), (2, 3, 4), (3, 4, 2), (4, 5, 1)]) 10 >>> minimum_travel_weight(3, [(1, 2, 1), (2, 3, 2)]) 3","solution":"def minimum_travel_weight(n, edges): Given \`n\` nodes and \`n-1\` edges of a tree, calculate the minimum possible total weight of the path taken by the traveler who wants to visit every node exactly once starting from node 1. from collections import defaultdict, deque # Construct the adjacency list for the tree tree = defaultdict(list) for u, v, w in edges: tree[u].append((v, w)) tree[v].append((u, w)) # Use Breadth First Search (BFS) to find the sum of all edge weights from the root (node 1) def bfs_minimum_travel_weight(start): visited = [False] * (n + 1) queue = deque([(start, 0)]) total_weight = 0 while queue: node, weight = queue.popleft() if not visited[node]: visited[node] = True total_weight += weight for neighbor, edge_weight in tree[node]: if not visited[neighbor]: queue.append((neighbor, edge_weight)) return total_weight return bfs_minimum_travel_weight(1)"},{"question":"def max_sub_grid_sum(grid): Find the maximum sum of any sub-grid (contiguous sub-array) in a given grid. >>> max_sub_grid_sum([ ... [1, 2, -1], ... [-3, 4, 2], ... [-1, -2, 1] ... ]) 7 >>> max_sub_grid_sum([ ... [-1, -2], ... [-3, -4] ... ]) -1","solution":"def max_sub_grid_sum(grid): def kadane_1d(arr): max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) max_global = max(max_global, max_current) return max_global n = len(grid) m = len(grid[0]) max_sum = float('-inf') for left in range(m): temp = [0] * n for right in range(left, m): for i in range(n): temp[i] += grid[i][right] current_kadane_sum = kadane_1d(temp) max_sum = max(max_sum, current_kadane_sum) return max_sum"},{"question":"def minimum_time_to_pick_edible_mushrooms(n: int, mushrooms: str) -> int: Returns the minimum time required to pick all edible mushrooms without picking any poisonous ones. Parameters: n (int): Number of mushrooms mushrooms (str): String of length n consisting of characters 'E', 'P', and 'U' Returns: int: Minimum time in seconds >>> minimum_time_to_pick_edible_mushrooms(7, 'UEUEPPE') 2 >>> minimum_time_to_pick_edible_mushrooms(5, 'EEEEE') 0 >>> minimum_time_to_pick_edible_mushrooms(5, 'PPPPP') 0 >>> minimum_time_to_pick_edible_mushrooms(5, 'UUUUU') 5 >>> minimum_time_to_pick_edible_mushrooms(6, 'UEUEUE') 3 >>> minimum_time_to_pick_edible_mushrooms(6, 'EUEUEU') 3","solution":"def minimum_time_to_pick_edible_mushrooms(n, mushrooms): Returns the minimum time required to pick all edible mushrooms without picking any poisonous ones. Parameters: n (int): Number of mushrooms mushrooms (str): String of length n consisting of characters 'E', 'P', and 'U' Returns: int: Minimum time in seconds time = 0 for mushroom in mushrooms: if mushroom == 'U': time += 1 return time"},{"question":"def shortest_total_travel_times(trains: List[List[int]]) -> List[int]: Returns the minimum total travel time for each train's route. Parameters: trains (list of list of int): Nested list where each sublist represents travel times of segments of a train's route. Returns: list of int: List of minimum total travel times for each train. >>> shortest_total_travel_times([[10, 20, 30, 40]]) == [100] >>> shortest_total_travel_times([[10, 20, 30, 40], [15, 25], [14, 23, 42]]) == [100, 40, 79] >>> shortest_total_travel_times([[10]]) == [10] >>> shortest_total_travel_times([[5, 5, 5, 5], [1, 2, 3, 4], [10, 20, 10]]) == [20, 10, 40] >>> segments = [1 for _ in range(100)] >>> shortest_total_travel_times([segments]) == [100] >>> shortest_total_travel_times([[], [1, 2, 3]]) == [0, 6] pass","solution":"def shortest_total_travel_times(trains): Returns the minimum total travel time for each train's route. Parameters: trains (list of list of int): Nested list where each sublist represents travel times of segments of a train's route. Returns: list of int: List of minimum total travel times for each train. results = [] for train in trains: # Sum the travel times for the current train's route total_travel_time = sum(train) results.append(total_travel_time) return results"},{"question":"def game_result(test_cases: List[Tuple[int, List[int], List[int]]]) -> List[str]: Determine if Alice can guarantee a win in the given game scenarios. Parameters: test_cases (List[Tuple[int, List[int], List[int]]]): A list of test cases, each containing: - n (int): The length of the sequences. - initial (List[int]): The initial sequence of integers. - desired (List[int]): The desired sequence of integers. Returns: List[str]: A list of strings where each string is either \\"Alice wins\\" or \\"Bob wins\\" based on whether Alice can guarantee a win or not. >>> game_result([(3, [1, 2, 3], [2, 2, 2]), (4, [0, 1, 2, 3], [1, 2, 2, 4]), (2, [1, 0], [0, 2])]) ['Alice wins', 'Bob wins', 'Bob wins'] >>> game_result([(1, [10], [0]), (2, [5, 5], [5, 4]), (5, [10, 10, 10, 10, 10], [9, 9, 9, 9, 9])]) ['Alice wins', 'Alice wins', 'Alice wins'] >>> game_result([(1, [0], [1]), (3, [1, 1, 1], [1, 1, 2]), (4, [0, 1, 1, 1], [1, 1, 1, 1])]) ['Bob wins', 'Bob wins', 'Bob wins'] >>> game_result([(3, [1, 3, 2], [2, 2, 2]), (4, [2, 2, 2, 1], [1, 1, 1, 3]), (1, [1], [0])]) ['Alice wins', 'Alice wins', 'Alice wins']","solution":"def game_result(test_cases): results = [] for n, initial, desired in test_cases: if sum(initial) < sum(desired): results.append(\\"Bob wins\\") else: results.append(\\"Alice wins\\") return results"},{"question":"def determine_winner(n: int, sequence: List[int]) -> str: Determines the winner of the game between Egor and Timur. Args: n (int): The length of the sequence. sequence (list of int): The sequence of integers. Returns: str: \\"Egor\\" if Egor wins, and \\"Timur\\" if Timur wins. pass def test_egor_wins(): assert determine_winner(4, [1, -1, 2, -2]) == \\"Egor\\" def test_timur_wins(): assert determine_winner(3, [-1, -1, -1]) == \\"Timur\\" def test_mixed_sequence(): assert determine_winner(5, [0, -1, 2, 0, -2]) == \\"Egor\\" def test_all_zeros(): assert determine_winner(4, [0, 0, 0, 0]) == \\"Timur\\" def test_single_positive(): assert determine_winner(1, [1]) == \\"Egor\\" def test_single_negative(): assert determine_winner(1, [-1]) == \\"Timur\\"","solution":"def determine_winner(n, sequence): Determines the winner of the game between Egor and Timur. Args: n (int): The length of the sequence. sequence (list of int): The sequence of integers. Returns: str: \\"Egor\\" if Egor wins, and \\"Timur\\" if Timur wins. # Check if there is any positive number in the sequence for num in sequence: if num > 0: return \\"Egor\\" return \\"Timur\\""},{"question":"def max_friends_meeting(n: int, schedules: List[List[int]]) -> int: Determine the maximum number of friends that can be scheduled for a meeting at the same time. >>> max_friends_meeting(3, [[2, 1, 5, 10, 14], [3, 2, 6, 8, 12, 13, 15], [1, 6, 9]]) == 2 >>> max_friends_meeting(3, [[1, 1, 2], [1, 3, 4], [1, 5, 6]]) == 1 >>> max_friends_meeting(3, [[1, 1, 10], [1, 1, 10], [1, 1, 10]]) == 3 >>> max_friends_meeting(4, [[2, 1, 5, 6, 10], [2, 2, 6, 7, 11], [1, 12, 15], [1, 14, 16]]) == 2 >>> max_friends_meeting(1, [[2, 0, 500, 500, 1000]]) == 1 >>> max_friends_meeting(2, [[1, 1, 2], [1, 3, 4]]) == 1","solution":"def max_friends_meeting(n, schedules): # Initialize an array to count overlapping intervals timeline = [0] * 1001 for schedule in schedules: num_intervals = schedule[0] intervals = schedule[1:] for i in range(num_intervals): start, end = intervals[2*i], intervals[2*i+1] timeline[start] += 1 timeline[end] -= 1 # To find maximum overlap, accumulate the timeline values max_friends = 0 current_friends = 0 for i in range(1001): current_friends += timeline[i] if current_friends > max_friends: max_friends = current_friends return max_friends"},{"question":"def min_adjacent_asterisks(n: int, s: str) -> int: Returns the minimum number of adjacent '*' characters after any number of rotations. >>> min_adjacent_asterisks(5, \\".|.|.\\") == 0 >>> min_adjacent_asterisks(3, \\".*.\\") == 1 >>> min_adjacent_asterisks(4, \\"**..\\") == 1 >>> min_adjacent_asterisks(5, \\".*..*\\") == 1 >>> min_adjacent_asterisks(5, \\"*****\\") == 5 >>> min_adjacent_asterisks(6, \\"*..*..\\") == 1","solution":"def min_adjacent_asterisks(n, s): Returns the minimum number of adjacent '*' characters after any number of rotations. if '*' not in s: return 0 # Check for the minimum adjacent asterisks in any rotation min_adj = float('inf') # Loop through all rotations for i in range(n): rotated_string = s[i:] + s[:i] max_asterisks = 0 current_asterisks = 0 for char in rotated_string: if char == '*': current_asterisks += 1 max_asterisks = max(max_asterisks, current_asterisks) else: current_asterisks = 0 min_adj = min(min_adj, max_asterisks) return min_adj"},{"question":"import re from collections import Counter from typing import List, Tuple def unique_words_count(text: str) -> Tuple[int, List[Tuple[str, int]]]: Identify all unique words in a document and count their occurrences. A word is defined as a sequence of alphabetic characters and should be case-insensitive. >>> unique_words_count(\\"Hello, world! Hello-world. HELLO?\\") (2, [('hello', 3), ('world', 2)]) >>> unique_words_count(\\"This is a test. This is only a test!\\") (5, [('a', 2), ('is', 2), ('only', 1), ('test', 2), ('this', 2)]) >>> unique_words_count(\\"Python, Python! programming - python?\\") (2, [('programming', 1), ('python', 3)]) >>> unique_words_count(\\"\\") (0, []) >>> unique_words_count(\\"Unicorn\\") (1, [('unicorn', 1)]) >>> unique_words_count(\\"repeat repeat repeat\\") (1, [('repeat', 3)])","solution":"import re from collections import Counter def unique_words_count(text): Identify all unique words in a document and count their occurrences. A word is defined as a sequence of alphabetic characters and should be case-insensitive. # Using regex to extract words and converting to lowercase words = re.findall(r'[a-zA-Z]+', text.lower()) # Count the frequency of each word word_count = Counter(words) # Sorting the words alphabetically sorted_word_count = sorted(word_count.items()) # Print the number of unique words print(len(sorted_word_count)) # Print each word with its frequency for word, count in sorted_word_count: print(f\\"{word} {count}\\") # Return the data for unit testing purposes return len(sorted_word_count), sorted_word_count"},{"question":"def minimum_max_difference(denominations): Sergey wants to minimize the maximum difference between the denominations of any two adjacent coins in the row. >>> minimum_max_difference([1, 3, 6, 10]) 2 >>> minimum_max_difference([4, 8, 1, 3, 12, 20]) 1 >>> minimum_max_difference([10, 2, 8, 6]) 2 >>> minimum_max_difference([5, 15, 25, 20]) 5 >>> minimum_max_difference([100, 200, 150, 10]) 50 pass","solution":"def minimum_max_difference(denominations): denominations.sort() min_max_diff = float('inf') for i in range(1, len(denominations)): max_diff = denominations[i] - denominations[i - 1] min_max_diff = min(min_max_diff, max_diff) return min_max_diff # Input reading and function calling left for test modules"},{"question":"class Library: def __init__(self): self.collection = {} self.operation_stack = [] def add(self, isbn, genre): Add a new book with the given ISBN and genre to the collection pass def remove(self, isbn): Remove the book with the given ISBN from the collection pass def query(self, genre): Return a list of ISBNs of books of the specified genre pass def undo(self): Revert the last operation (either add or remove) pass def process_operations(q, operations): Process a list of operations on the library collection. Args: q (int): The number of operations. operations (List[str]): A list of operations to perform. Returns: List[str]: The results of the query operations. >>> process_operations(6, [\\"add 9780306406157 fiction\\", \\"add 9781451673319 fiction\\", \\"query fiction\\", \\"remove 9781451673319\\", \\"query fiction\\", \\"undo\\"]) [\\"9780306406157 9781451673319\\", \\"9780306406157\\"] library = Library() results = [] for operation in operations: parts = operation.split() action = parts[0] if action == 'add': isbn, genre = parts[1], parts[2] library.add(isbn, genre) elif action == 'remove': isbn = parts[1] library.remove(isbn) elif action == 'query': genre = parts[1] results.append(\\" \\".join(library.query(genre))) elif action == 'undo': library.undo() return results","solution":"class Library: def __init__(self): self.collection = {} self.operation_stack = [] def add(self, isbn, genre): if genre not in self.collection: self.collection[genre] = [] if isbn not in self.collection[genre]: self.collection[genre].append(isbn) self.operation_stack.append(('add', isbn, genre)) def remove(self, isbn): for genre, books in self.collection.items(): if isbn in books: books.remove(isbn) self.operation_stack.append(('remove', isbn, genre)) break def query(self, genre): if genre in self.collection: return self.collection[genre] return [] def undo(self): if not self.operation_stack: return last_operation = self.operation_stack.pop() action, isbn, genre = last_operation if action == 'add': self.collection[genre].remove(isbn) if not self.collection[genre]: del self.collection[genre] elif action == 'remove': if genre not in self.collection: self.collection[genre] = [] self.collection[genre].append(isbn) def process_operations(q, operations): library = Library() results = [] for operation in operations: parts = operation.split() action = parts[0] if action == 'add': isbn, genre = parts[1], parts[2] library.add(isbn, genre) elif action == 'remove': isbn = parts[1] library.remove(isbn) elif action == 'query': genre = parts[1] results.append(\\" \\".join(library.query(genre))) elif action == 'undo': library.undo() return results"},{"question":"def can_make_string_empty(s: str) -> str: Determine if it's possible to make the string empty by removing consecutive equal letters. >>> can_make_string_empty(\\"abba\\") \\"YES\\" >>> can_make_string_empty(\\"abcdef\\") \\"NO\\" >>> can_make_string_empty(\\"aabbcc\\") \\"YES\\" def process_test_cases(t: int, test_cases: List[str]) -> List[str]: Process multiple test cases to determine if each string can be made empty. >>> process_test_cases(3, [\\"abba\\", \\"abcdef\\", \\"aabbcc\\"]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> process_test_cases(1, [\\"a\\"]) [\\"NO\\"] >>> process_test_cases(5, [\\"abcdef\\", \\"abbaabba\\", \\"abccba\\", \\"aabbcc\\", \\"abcabc\\"]) [\\"NO\\", \\"YES\\", \\"YES\\", \\"YES\\", \\"NO\\"]","solution":"def can_make_string_empty(s): stack = [] for char in s: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return \\"YES\\" if not stack else \\"NO\\" def process_test_cases(t, test_cases): results = [] for s in test_cases: results.append(can_make_string_empty(s)) return results"},{"question":"def min_moves_to_reach_station(n: int, k: int) -> int: Determines the minimum number of moves required to reach the final station n starting from station 1 when you can move at most k stations ahead in one move. >>> min_moves_to_reach_station(10, 3) 3 >>> min_moves_to_reach_station(10, 2) 5","solution":"def min_moves_to_reach_station(n, k): Determines the minimum number of moves required to reach the final station n starting from station 1 when you can move at most k stations ahead in one move. # To reach station n, calculate the maximum jumps possible for each step return (n - 1 + k - 1) // k"},{"question":"def min_possible_difference(t: int, test_cases: List[List[int]]) -> List[int]: Determine the minimum possible difference between the maximum and minimum element of an array after performing the increment operation any number of times. Parameters: t (int): number of test cases test_cases (list of lists): each element is a list where the first element is the size of the array 'n' and the remaining elements are the integers of the array. Returns: list: list of integers representing the minimum possible difference for each test case >>> min_possible_difference(2, [[3, 1, 2, 3], [4, 10, 20, 30, 40]]) [0, 30] >>> min_possible_difference(1, [[1, 42]]) [0] >>> min_possible_difference(1, [[4, 5, 5, 5, 5]]) [0] >>> min_possible_difference(1, [[3, 1000000000, 999999999, 1000000001]]) [2] >>> min_possible_difference(1, [[5, 1, 994, 500, 750, 10000]]) [9999] >>> min_possible_difference(1, [[5, -10, -20, -30, -40, 50]]) [90]","solution":"def min_possible_difference(t, test_cases): Determine the minimum possible difference between the maximum and minimum element of an array after performing the increment operation any number of times. Parameters: t (int): number of test cases test_cases (list of lists): each element is a list where the first element is the size of the array 'n' and the remaining elements are the integers of the array. Returns: list: list of integers representing the minimum possible difference for each test case results = [] for case in test_cases: n = case[0] array = case[1:] min_value = min(array) max_value = max(array) results.append(max_value - min_value) return results"},{"question":"def answer_queries(n: int, q: int, treasure_values: List[int], queries: List[Tuple[int, int, int, int]]) -> List[str]: Answer queries about the total treasure value in specific segments of ships. Parameters: n (int): Number of ships. q (int): Number of queries. treasure_values (List[int]): List of treasure values for each ship. queries (List[Tuple[int, int, int, int]]): List of queries in the form (l, r, L, R). Returns: List[str]: List of \\"YES\\" or \\"NO\\" answers for each query. >>> answer_queries(5, 3, [100, 200, 300, 400, 500], [(1, 3, 500, 700), (2, 5, 900, 1500), (1, 5, 2000, 2500)]) ['YES', 'YES', 'NO'] >>> answer_queries(1, 1, [1000], [(1, 1, 900, 1100)]) ['YES']","solution":"def answer_queries(n, q, treasure_values, queries): # Compute prefix sums for treasure_values prefix_sums = [0] * (n + 1) for i in range(1, n + 1): prefix_sums[i] = prefix_sums[i - 1] + treasure_values[i - 1] results = [] for l, r, L, R in queries: # Calculate the sum of the segment from l to r segment_sum = prefix_sums[r] - prefix_sums[l - 1] # Check if the segment sum is within the range [L, R] if L <= segment_sum <= R: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def check_subsequence_with_sum(n: int, t: int, times: List[int]) -> str: Returns 'YES' if there exists a contiguous subsequence with a total playing time of exactly t minutes, otherwise returns 'NO'. >>> check_subsequence_with_sum(8, 15, [1, 2, 3, 4, 5, 6, 7, 8]) 'YES' >>> check_subsequence_with_sum(5, 21, [1, 2, 3, 4, 5]) 'NO' >>> check_subsequence_with_sum(8, 20, [1, 2, 3, 4, 5, 6, 7, 8]) 'YES' >>> check_subsequence_with_sum(1, 3, [3]) 'YES' >>> check_subsequence_with_sum(3, 100000, [50000, 50000, 50000]) 'YES' >>> check_subsequence_with_sum(7, 12, [1, 2, 3, 4, 5, 1, 0]) 'YES'","solution":"def check_subsequence_with_sum(n, t, times): Returns 'YES' if there exists a contiguous subsequence with a total playing time of exactly t minutes, otherwise returns 'NO'. # Initialize pointers for the sliding window and the current sum left = 0 current_sum = 0 for right in range(n): # Add the current element to the current_sum current_sum += times[right] # While current_sum exceeds t, move the left pointer to the right to decrease the sum while current_sum > t and left <= right: current_sum -= times[left] left += 1 # Check if we've found the exact sum if current_sum == t: return \\"YES\\" # If no such subsequence is found, return \\"NO\\" return \\"NO\\""},{"question":"def count_distinct_in_geometric_progression(a: int, r: int, n: int) -> int: Given an initial term a, a common ratio r, and a sequence length n, determine the number of distinct integers in the geometric progression modulo 10^9 + 7. >>> count_distinct_in_geometric_progression(2, 3, 4) 4 >>> count_distinct_in_geometric_progression(5, 1, 1) 1","solution":"def count_distinct_in_geometric_progression(a, r, n): MOD = 1000000007 terms = set() for i in range(n): term = (a * pow(r, i, MOD)) % MOD terms.add(term) return len(terms)"},{"question":"def max_subset_sum_no_consecutive(cards): Determine the maximum sum of a subset of card values such that no two selected cards have consecutive indices. Args: cards (List[int]): List of integers representing the values of the cards. Returns: int: Maximum possible sum of a subset of card values with no consecutive indices. Examples: >>> max_subset_sum_no_consecutive([3, 2, 5, 10, 7]) 15 >>> max_subset_sum_no_consecutive([2, 10, 2]) 10 >>> max_subset_sum_no_consecutive([1, 100, 1, 1, 100]) 200 >>> max_subset_sum_no_consecutive([10]) 10 >>> max_subset_sum_no_consecutive([5, 15]) 15 >>> max_subset_sum_no_consecutive([-1, -2, -3, -4]) -1 >>> max_subset_sum_no_consecutive([3, -2, 5, -1, 7, -8, 10]) 25 >>> max_subset_sum_no_consecutive([1, 1000, 1, 1, 1000, 1]) 2000","solution":"def max_subset_sum_no_consecutive(cards): Determine the maximum sum of a subset of card values such that no two selected cards have consecutive indices. n = len(cards) if n == 0: return 0 if n == 1: return cards[0] # dp[i] will be the maximum sum we can get from the first i cards without selecting consecutive cards dp = [0] * n dp[0] = cards[0] dp[1] = max(cards[0], cards[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + cards[i]) return dp[-1]"},{"question":"def smallest_lexicographical_array(n: int, d: int, a: List[int]) -> List[int]: Perform at most d swaps on the array to make it as lexicographically small as possible. Arguments: n -- the length of the array d -- the maximum number of swaps allowed a -- the array which needs to be modified Returns: The lexicographically smallest array that can be obtained by performing at most d swaps. >>> smallest_lexicographical_array(4, 1, [4, 3, 2, 1]) [1, 3, 2, 4] >>> smallest_lexicographical_array(4, 2, [4, 3, 2, 1]) [1, 2, 3, 4] >>> smallest_lexicographical_array(5, 1, [5, 1, 2, 3, 4]) [1, 5, 2, 3, 4] >>> smallest_lexicographical_array(3, 0, [3, 2, 1]) [3, 2, 1] >>> smallest_lexicographical_array(4, 10, [4, 3, 2, 1]) [1, 2, 3, 4] >>> smallest_lexicographical_array(5, 3, [5, 4, 3, 2, 1]) [1, 2, 3, 4, 5]","solution":"def smallest_lexicographical_array(n, d, a): swaps = 0 for i in range(n): if swaps >= d: break min_index = i for j in range(i + 1, n): if a[j] < a[min_index]: min_index = j if min_index != i: a[i], a[min_index] = a[min_index], a[i] swaps += 1 return a"},{"question":"def sort_competitors(competitors: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Sorts a list of tuples containing competitor ID and score. The list is sorted first by score in descending order, then by ID in ascending order. Args: competitors (list of tuples): A list where each tuple contains two integers: the competitor's ID and their score. Returns: list of tuples: The sorted list of competitors. >>> sort_competitors([(126, 400), (123, 450), (125, 500), (127, 450), (124, 450)]) [(125, 500), (123, 450), (124, 450), (127, 450), (126, 400)] >>> sort_competitors([(123, 450), (124, 450), (125, 450), (126, 450), (127, 450)]) [(123, 450), (124, 450), (125, 450), (126, 450), (127, 450)]","solution":"def sort_competitors(competitors): Sorts a list of tuples containing competitor ID and score. The list is sorted first by score in descending order, then by ID in ascending order. Args: competitors (list of tuples): A list where each tuple contains two integers: the competitor's ID and their score. Returns: list of tuples: The sorted list of competitors. return sorted(competitors, key=lambda x: (-x[1], x[0]))"},{"question":"def arrange_books(f: int, n: int, fiction_books: List[str], non_fiction_books: List[str]) -> str: Arrange the books such that no two fiction books are next to each other or return \\"IMPOSSIBLE\\". Args: f (int): Number of fiction books. n (int): Number of non-fiction books. fiction_books (list): List of fiction book titles. non_fiction_books (list): List of non-fiction book titles. Returns: str: A single line with titles arranged as required or \\"IMPOSSIBLE\\". >>> arrange_books(3, 4, [\\"TheGreatGatsby\\", \\"MobyDick\\", \\"WarAndPeace\\"], [\\"A_Brief_History_of_Time\\", \\"Sapiens\\", \\"TheSelfishGene\\", \\"GunsGermsAndSteel\\"]) \\"A_Brief_History_of_Time TheGreatGatsby Sapiens MobyDick TheSelfishGene WarAndPeace GunsGermsAndSteel\\" >>> arrange_books(4, 2, [\\"F1\\", \\"F2\\", \\"F3\\", \\"F4\\"], [\\"N1\\", \\"N2\\"]) \\"IMPOSSIBLE\\" >>> arrange_books(2, 2, [\\"F1\\", \\"F2\\"], [\\"N1\\", \\"N2\\"]) \\"F1 N1 F2 N2\\" >>> arrange_books(0, 3, [], [\\"N1\\", \\"N2\\", \\"N3\\"]) \\"N1 N2 N3\\" >>> arrange_books(1, 0, [\\"F1\\"], []) \\"F1\\" >>> arrange_books(0, 0, [], []) \\"\\"","solution":"def arrange_books(f, n, fiction_books, non_fiction_books): Arrange the books such that no two fiction books are next to each other or return \\"IMPOSSIBLE\\". Args: f (int): Number of fiction books. n (int): Number of non-fiction books. fiction_books (list): List of fiction book titles. non_fiction_books (list): List of non-fiction book titles. Returns: str: A single line with titles arranged as required or \\"IMPOSSIBLE\\". if f > n + 1: return \\"IMPOSSIBLE\\" arrangement = [] fiction_index, non_fiction_index = 0, 0 while fiction_index < f or non_fiction_index < n: if fiction_index < f: arrangement.append(fiction_books[fiction_index]) fiction_index += 1 if non_fiction_index < n: arrangement.append(non_fiction_books[non_fiction_index]) non_fiction_index += 1 # Check if arrangement has no two fiction books next to each other for i in range(1, len(arrangement)): if arrangement[i-1] in fiction_books and arrangement[i] in fiction_books: return \\"IMPOSSIBLE\\" return \\" \\".join(arrangement)"},{"question":"def find_connected_components(n: int, edges: List[Tuple[int, int]]) -> int: Returns the number of connected components in an undirected graph. :param n: Number of vertices. :param edges: List of edges, each edge is a tuple (u, v) which represents an undirected edge connecting u and v. :return: Number of connected components in the graph. >>> find_connected_components(5, [(1, 2), (2, 3), (4, 5)]) == 2 >>> find_connected_components(7, [(1, 2), (2, 3), (4, 5), (6, 7)]) == 3 >>> find_connected_components(3, []) == 3 >>> find_connected_components(1, []) == 1 >>> find_connected_components(4, [(1, 2), (2, 3), (1, 3), (3, 4), (1, 4)]) == 1 >>> find_connected_components(6, [(1, 2), (3, 4)]) == 4 >>> find_connected_components(4, [(1, 1), (2, 2)]) == 4 >>> n = 1000 >>> edges = [(i, i + 1) for i in range(1, 1000)] >>> find_connected_components(n, edges) == 1","solution":"def find_connected_components(n, edges): Returns the number of connected components in an undirected graph. :param n: Number of vertices. :param edges: List of edges, each edge is a tuple (u, v) which represents an undirected edge connecting u and v. :return: Number of connected components in the graph. from collections import defaultdict, deque def bfs(node): queue = deque([node]) while queue: current = queue.popleft() for neighbor in graph[current]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = set() components_count = 0 for vertex in range(1, n + 1): if vertex not in visited: components_count += 1 visited.add(vertex) bfs(vertex) return components_count"},{"question":"def count_special_vertices(n: int, m: int, k: int, edges: List[Tuple[int, int]]) -> int: You are given an undirected graph with n vertices and m edges. A vertex is called special if it has exactly k neighbors. You need to find the number of special vertices in the graph. Args: n (int): number of vertices m (int): number of edges k (int): number of neighbors that makes a vertex special edges (List[Tuple[int, int]]): list of edges where each edge is represented by a tuple (u, v) Returns: int: number of special vertices Example: >>> count_special_vertices(5, 4, 2, [(1, 2), (2, 3), (3, 4), (4, 5)]) 3","solution":"def count_special_vertices(n, m, k, edges): from collections import defaultdict # Create adjacency list adjacency_list = defaultdict(int) for u, v in edges: adjacency_list[u] += 1 adjacency_list[v] += 1 # Count the special vertices special_count = 0 for vertex in range(1, n + 1): if adjacency_list[vertex] == k: special_count += 1 return special_count"},{"question":"def minimize_max_difference(n: int, k: int, weights: List[int]) -> int: Partition an array into k contiguous subarrays such that the minimized maximum difference between the total weights of the largest and smallest subarrays. >>> minimize_max_difference(7, 3, [5, 1, 2, 6, 4, 3, 8]) 3 >>> minimize_max_difference(5, 1, [3, 1, 4, 1, 5]) 14 >>> minimize_max_difference(5, 3, [2, 2, 2, 2, 2]) 4 >>> minimize_max_difference(5, 2, [1000, 1000, 1000, 1000, 1000]) 3000 >>> minimize_max_difference(5, 5, [2, 4, 1, 7, 3]) 7 >>> minimize_max_difference(5, 3, [1, 2, 3, 4, 5]) 6 pass","solution":"def minimize_max_difference(n, k, weights): def canPartition(mid): partitions = 1 current_sum = 0 for weight in weights: if current_sum + weight > mid: partitions += 1 current_sum = weight if partitions > k: return False else: current_sum += weight return True low, high = max(weights), sum(weights) while low < high: mid = (low + high) // 2 if canPartition(mid): high = mid else: low = mid + 1 return low"},{"question":"def rearrange_cucumbers(n: int, cucumbers: List[int]) -> str: Jake is a passionate vegetable gardener with a special talent for cultivating cucumbers. He aims to optimize his harvest by arranging his cucumbers in an ideal sequence. Jake has a collection of cucumbers with varying lengths and he believes that an alternating sequence of long and short cucumbers yields the best harvest. Given an array of integers representing the lengths of cucumbers in his garden, help Jake find a way to rearrange the cucumbers to form such an alternating sequence. An alternating sequence is defined where the lengths of cucumbers at even indices are strictly greater than the lengths of cucumbers at odd indices. If there are multiple ways to achieve it, any valid arrangement is acceptable. If it's impossible to create such a sequence, output \\"NO\\". The first line of input contains an integer n (1  n  1000)  the number of cucumbers Jake has. The second line contains n integers a1, a2, ..., an (1  ai  1000)  the lengths of the cucumbers. If it is possible to rearrange the cucumbers into an alternating sequence, output \\"YES\\" on the first line. On the second line, output the new arrangement of cucumbers as n space-separated integers. If it is not possible, output \\"NO\\". Example: >>> rearrange_cucumbers(5, [1, 3, 2, 4, 5]) 'YESn5 1 4 2 3' >>> rearrange_cucumbers(3, [1, 1, 1]) 'NO'","solution":"def rearrange_cucumbers(n, cucumbers): cucumbers.sort() left, right = 0, n - 1 result = [] while left <= right: if left != right: result.append(cucumbers[right]) result.append(cucumbers[left]) else: result.append(cucumbers[right]) left += 1 right -= 1 for i in range(1, n, 2): if result[i] >= result[i-1]: return \\"NO\\" return \\"YESn\\" + \\" \\".join(map(str, result))"},{"question":"from typing import List def gcd(a: int, b: int) -> int: Helper function to compute the greatest common divisor of a and b. while b: a, b = b, a % b return a def longest_subsequence_with_common_divisor(n: int, activity_levels: List[int]) -> int: Returns the length of the longest subsequence where any two consecutive activity levels have a common divisor greater than 1. >>> longest_subsequence_with_common_divisor(6, [10, 20, 14, 25, 30, 49]) 4 >>> longest_subsequence_with_common_divisor(5, [2, 3, 5, 7, 11]) 1 def test_gcd_basic(): assert gcd(10, 20) == 10 assert gcd(14, 25) == 1 assert gcd(49, 30) == 1 assert gcd(25, 30) == 5 def test_single_record(): assert longest_subsequence_with_common_divisor(1, [10]) == 1 assert longest_subsequence_with_common_divisor(1, [25]) == 1 def test_example_case(): assert longest_subsequence_with_common_divisor(6, [10, 20, 14, 25, 30, 49]) == 4 def test_all_coprime(): assert longest_subsequence_with_common_divisor(5, [2, 3, 5, 7, 11]) == 1 def test_all_same_number(): assert longest_subsequence_with_common_divisor(4, [8, 8, 8, 8]) == 4 def test_mixed_numbers(): assert longest_subsequence_with_common_divisor(7, [6, 12, 8, 15, 10, 20, 9]) == 5","solution":"def gcd(a, b): Helper function to compute the greatest common divisor of a and b. while b: a, b = b, a % b return a def longest_subsequence_with_common_divisor(n, activity_levels): Returns the length of the longest subsequence where any two consecutive activity levels have a common divisor greater than 1. if n == 1: return 1 dp = [1] * n # dp[i] will store the length of the longest valid subsequence ending with activity_levels[i] for i in range(1, n): for j in range(i): if gcd(activity_levels[i], activity_levels[j]) > 1: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def find_segments_and_longest(n: int, heights: List[int]) -> Tuple[int, List[int]]: Determine the number of segments and identify the longest segment. Each segment is strictly increasing or strictly decreasing. Args: n (int): The number of days recorded. heights (List[int]): The heights of the plant over \`n\` days. Returns: Tuple[int, List[int]]: A tuple where the first element is the number of segments, and the second element is the longest segment. >>> find_segments_and_longest(7, [1, 2, 1, 3, 4, 3, 2]) (4, [1, 3, 4]) >>> find_segments_and_longest(1, [1]) (1, [1])","solution":"def find_segments_and_longest(n, heights): if n == 1: return 1, heights segments = [] start = 0 for i in range(1, n): if (heights[i] > heights[i-1] and (i == n-1 or heights[i+1] <= heights[i])) or (heights[i] < heights[i-1] and (i == n-1 or heights[i+1] >= heights[i])): segments.append(heights[start:i+1]) start = i if start < n - 1: segments.append(heights[start:n]) longest_segment = max(segments, key=len) return len(segments), longest_segment # Example usage: n = 7 heights = [1, 2, 1, 3, 4, 3, 2] num_segments, longest_segment = find_segments_and_longest(n, heights) print(num_segments) # Output: 4 print(longest_segment) # Output: [1, 3, 4]"},{"question":"from typing import List def partitionArray(arr: List[int], k: int) -> int: Partition the array into k contiguous subarrays such that the maximum sum of the subarrays is minimized. >>> partitionArray([1, 2, 3, 4, 5], 2) 9 >>> partitionArray([7, 2, 5, 10, 8], 2) 18 >>> partitionArray([1, 1, 1, 1, 1], 5) 1 >>> partitionArray([1, 2, 3, 4, 5], 1) 15 >>> partitionArray([5, 3, 2], 3) 5 >>> partitionArray([1], 1) 1 >>> partitionArray([2, 3, 1, 2, 4, 3], 3) 6 pass","solution":"from typing import List def partitionArray(arr: List[int], k: int) -> int: def canPartition(max_sum): current_sum = 0 parts = 1 for num in arr: if current_sum + num > max_sum: parts += 1 current_sum = num if parts > k: return False else: current_sum += num return True left, right = max(arr), sum(arr) while left < right: mid = (left + right) // 2 if canPartition(mid): right = mid else: left = mid + 1 return left"},{"question":"def process_commands(N, M, initial_statuses, commands): Process a sequence of commands to update or query the status of a collection of objects. Args: N (int): The number of objects. M (int): The number of commands. initial_statuses (List[int]): A list of integers representing the initial status of each object (1 for \\"active\\", 0 for \\"inactive\\"). commands (List[str]): A list of strings representing the commands to process. Returns: List[int]: A list of integers where each integer is the result of a QUERY command. >>> process_commands(5, 4, [1, 0, 1, 0, 1], [\\"QUERY\\", \\"UPDATE 2 1\\", \\"QUERY\\", \\"UPDATE 5 0\\"]) [3, 4] >>> process_commands(3, 3, [0, 0, 0], [\\"UPDATE 1 1\\", \\"UPDATE 2 1\\", \\"QUERY\\"]) [2] from collections import List def test_single_query(): N, M = 5, 1 initial_statuses = [1, 0, 1, 0, 1] commands = [\\"QUERY\\"] assert process_commands(N, M, initial_statuses, commands) == [3] def test_update_and_query(): N, M = 5, 2 initial_statuses = [1, 0, 1, 0, 1] commands = [\\"UPDATE 2 1\\", \\"QUERY\\"] assert process_commands(N, M, initial_statuses, commands) == [4] def test_multiple_queries_and_updates(): N, M = 5, 4 initial_statuses = [1, 0, 1, 0, 1] commands = [\\"QUERY\\", \\"UPDATE 2 1\\", \\"QUERY\\", \\"UPDATE 5 0\\"] assert process_commands(N, M, initial_statuses, commands) == [3, 4] def test_all_update_to_active(): N, M = 3, 3 initial_statuses = [0, 0, 0] commands = [\\"UPDATE 1 1\\", \\"UPDATE 2 1\\", \\"QUERY\\"] assert process_commands(N, M, initial_statuses, commands) == [2] def test_alternating_updates(): N, M = 4, 4 initial_statuses = [1, 1, 1, 1] commands = [\\"UPDATE 1 0\\", \\"QUERY\\", \\"UPDATE 1 1\\", \\"QUERY\\"] assert process_commands(N, M, initial_statuses, commands) == [3, 4]","solution":"def process_commands(N, M, initial_statuses, commands): statuses = initial_statuses[:] active_count = sum(statuses) results = [] for command in commands: parts = command.split() if parts[0] == \\"QUERY\\": results.append(active_count) elif parts[0] == \\"UPDATE\\": idx = int(parts[1]) - 1 new_status = int(parts[2]) if statuses[idx] != new_status: if new_status == 1: active_count += 1 else: active_count -= 1 statuses[idx] = new_status return results"},{"question":"def max_books(n: int, W: int, weights: List[int]) -> int: Returns the maximum number of books that can be placed on the shelf without exceeding the weight limit. >>> max_books(5, 10, [2, 3, 4, 5, 9]) == 3 >>> max_books(5, 7, [1, 2, 3, 4, 5]) == 3 >>> max_books(1, 1, [1]) == 1 >>> max_books(1, 1, [2]) == 0 >>> max_books(4, 10, [1, 2, 3, 4]) == 4 >>> max_books(5, 10, [9, 5, 4, 3, 2]) == 3 >>> max_books(6, 15, [5, 3, 4, 2, 6, 7]) == 4","solution":"def max_books(n, W, weights): Returns the maximum number of books that can be placed on the shelf without exceeding the weight limit. weights.sort() current_weight = 0 count = 0 for weight in weights: if current_weight + weight <= W: current_weight += weight count += 1 else: break return count"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree(level_order_values): Builds a binary tree from the given level order traversal values. if not level_order_values or level_order_values[0] == -1: return None iterator = iter(level_order_values) root = TreeNode(next(iterator)) queue = [root] while queue: node = queue.pop(0) try: left_val = next(iterator) if left_val != -1: node.left = TreeNode(left_val) queue.append(node.left) right_val = next(iterator) if right_val != -1: node.right = TreeNode(right_val) queue.append(node.right) except StopIteration: break return root def pre_order_traversal(root): Performs a pre-order traversal on the binary tree. if root is None: return [] result = [] stack = [root] while stack: node = stack.pop() if node is not None: result.append(node.val) if node.right is not None: stack.append(node.right) if node.left is not None: stack.append(node.left) return result def pre_order_from_level_order(level_order_values): Given a list of level order traversal values, returns the pre-order traversal of the binary tree. >>> pre_order_from_level_order([1, 2, 3, 4, 5, -1, -1, -1, -1, 6, 7]) [1, 2, 4, 5, 6, 7, 3] >>> pre_order_from_level_order([1]) [1] >>> pre_order_from_level_order([-1]) [] root = build_tree(level_order_values) return pre_order_traversal(root)","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree(level_order_values): if not level_order_values or level_order_values[0] == -1: return None iterator = iter(level_order_values) root = TreeNode(next(iterator)) queue = [root] while queue: node = queue.pop(0) try: left_val = next(iterator) if left_val != -1: node.left = TreeNode(left_val) queue.append(node.left) right_val = next(iterator) if right_val != -1: node.right = TreeNode(right_val) queue.append(node.right) except StopIteration: break return root def pre_order_traversal(root): if root is None: return [] result = [] stack = [root] while stack: node = stack.pop() if node is not None: result.append(node.val) if node.right is not None: stack.append(node.right) if node.left is not None: stack.append(node.left) return result def pre_order_from_level_order(level_order_values): root = build_tree(level_order_values) return pre_order_traversal(root)"},{"question":"def count_paths(n, m, k, obstacles): Calculate the number of distinct paths from the top-left corner to the bottom-right corner in a grid. The paths should avoid obstacles and only move right or down. :param n: int - number of rows in the grid. :param m: int - number of columns in the grid. :param k: int - number of obstacles in the grid. :param obstacles: list of tuples - positions of the obstacles where each tuple contains two integers (x, y). :return: int - number of distinct paths. >>> count_paths(3, 3, 0, []) == 6 >>> count_paths(3, 3, 1, [(2, 2)]) == 2","solution":"def count_paths(n, m, k, obstacles): # Initialize the DP table with zeros dp = [[0] * m for _ in range(n)] # If the starting point has an obstacle, return 0 if (1, 1) in obstacles: return 0 # Starting point (1, 1) setting to 1 dp[0][0] = 1 for i in range(n): for j in range(m): # If there's an obstacle, skip this cell if (i + 1, j + 1) in obstacles: dp[i][j] = 0 else: # Add ways from the top cell if within bounds if i > 0: dp[i][j] += dp[i - 1][j] # Add ways from the left cell if within bounds if j > 0: dp[i][j] += dp[i][j - 1] # Bottom right corner value return dp[n - 1][m - 1]"},{"question":"def can_be_balanced_expression(s: str) -> str: Determines if a string can be transformed into a balanced expression. Args: s (str): The input string consisting of '(', ')', and lowercase alphabet letters. Returns: str: \\"YES\\" if it can be transformed into a balanced expression, \\"NO\\" otherwise. Examples: >>> can_be_balanced_expression(\\"a(bc)d\\") \\"YES\\" >>> can_be_balanced_expression(\\"ab(c)d)\\") \\"NO\\" >>> can_be_balanced_expression(\\"(a(b)c)\\") \\"YES\\" >>> can_be_balanced_expression(\\"((ab)c\\") \\"NO\\" >>> can_be_balanced_expression(\\"abc\\") \\"YES\\" >>> can_be_balanced_expression(\\"\\") \\"YES\\" >>> can_be_balanced_expression(\\"(()\\") \\"NO\\" >>> can_be_balanced_expression(\\"())\\") \\"NO\\" def process_test_cases(t: int, cases: List[str]) -> List[str]: Process multiple test cases to determine if each string can be transformed into a balanced expression. Args: t (int): The number of test cases. cases (List[str]): List of strings to be checked. Returns: List[str]: List of results (\\"YES\\" or \\"NO\\") for each test case. Examples: >>> process_test_cases(4, [\\"ab(c)d)\\", \\"(a(b)c)\\", \\"((ab)c\\", \\"a(bc)d\\"]) [\\"NO\\", \\"YES\\", \\"NO\\", \\"YES\\"]","solution":"def can_be_balanced_expression(s): Determines if a string can be transformed into a balanced expression. stack = [] for char in s: if char == '(': stack.append(char) elif char == ')': if stack and stack[-1] == '(': stack.pop() else: return \\"NO\\" return \\"YES\\" if not stack else \\"NO\\" def process_test_cases(t, cases): results = [] for i in range(t): results.append(can_be_balanced_expression(cases[i])) return results"},{"question":"def count_primes_in_range(A: int, B: int) -> int: Returns the number of prime numbers in the closed interval [A, B]. >>> count_primes_in_range(1, 10) == 4 # Primes: 2, 3, 5, 7 >>> count_primes_in_range(10, 20) == 4 # Primes: 11, 13, 17, 19 >>> count_primes_in_range(2, 2) == 1 # Primes: 2 >>> count_primes_in_range(24, 28) == 0 # Primes: None in this range >>> count_primes_in_range(10, 30) == 6 # Primes: 11, 13, 17, 19, 23, 29 >>> count_primes_in_range(17, 19) == 2 # Primes: 17, 19 >>> count_primes_in_range(8, 8) == 0 # Primes: None >>> count_primes_in_range(99991, 100000) == 1 # Primes: 99991","solution":"def count_primes_in_range(A, B): Returns the number of prime numbers in the closed interval [A, B]. # Sieve of Eratosthenes for prime number generation up to 10^5 max_limit = 100000 is_prime = [True] * (max_limit + 1) is_prime[0] = is_prime[1] = False # 0 and 1 are not prime numbers p = 2 while p * p <= max_limit: if is_prime[p]: for i in range(p * p, max_limit + 1, p): is_prime[i] = False p += 1 # Counting the number of primes in the range [A, B] prime_count = 0 for number in range(A, B + 1): if is_prime[number]: prime_count += 1 return prime_count"},{"question":"def min_removals_to_make_arithmetic_seq(nums): Given a sequence of integers, determine the minimum number of elements that need to be removed to convert the given sequence into an arithmetic sequence. An arithmetic sequence is a sequence of numbers where the difference between any two consecutive terms is constant. Args: nums (List[int]): A list of integers Returns: int: The minimum number of elements to remove to make the sequence an arithmetic sequence Example: >>> min_removals_to_make_arithmetic_seq([3, 1, 4, 1, 5]) 2 >>> min_removals_to_make_arithmetic_seq([2, 2, 2]) 0","solution":"def min_removals_to_make_arithmetic_seq(nums): Returns the minimum number of elements to remove to make the sequence an arithmetic sequence. n = len(nums) if n <= 2: return 0 min_removals = float('inf') for i in range(n): for j in range(i + 1, n): diff = nums[j] - nums[i] count = 0 current = nums[i] for k in range(n): if nums[k] != current: count += 1 else: current += diff min_removals = min(min_removals, count) return min_removals"},{"question":"from typing import Set, Tuple def min_moves_to_reach_goal(h: int, w: int, sx: int, sy: int, gx: int, gy: int, obstacles: Set[Tuple[int, int]]) -> int: Determine the minimum number of moves required for a robot to reach its goal on a grid, considering obstacles. Return -1 if the goal is unreachable. >>> min_moves_to_reach_goal(5, 5, 1, 1, 5, 5, {(2, 2), (3, 3), (2, 4)}) 8 >>> min_moves_to_reach_goal(3, 3, 1, 1, 3, 3, set()) 4 >>> min_moves_to_reach_goal(3, 3, 1, 1, 3, 3, {(2, 2), (2, 3), (3, 2)}) -1 >>> min_moves_to_reach_goal(1, 1, 1, 1, 1, 1, set()) 0 >>> min_moves_to_reach_goal(1000, 1000, 1, 1, 1000, 1000, set()) != -1 import pytest def test_min_moves_to_reach_goal_example(): h, w = 5, 5 sx, sy = 1, 1 gx, gy = 5, 5 obstacles = {(2, 2), (3, 3), (2, 4)} assert min_moves_to_reach_goal(h, w, sx, sy, gx, gy, obstacles) == 8 def test_min_moves_to_reach_goal_no_obstacles(): h, w = 3, 3 sx, sy = 1, 1 gx, gy = 3, 3 obstacles = set() assert min_moves_to_reach_goal(h, w, sx, sy, gx, gy, obstacles) == 4 def test_min_moves_to_reach_goal_blocked_path(): h, w = 3, 3 sx, sy = 1, 1 gx, gy = 3, 3 obstacles = {(2, 2), (2, 3), (3, 2)} assert min_moves_to_reach_goal(h, w, sx, sy, gx, gy, obstacles) == -1 def test_min_moves_to_reach_goal_start_is_goal(): h, w = 1, 1 sx, sy = 1, 1 gx, gy = 1, 1 obstacles = set() assert min_moves_to_reach_goal(h, w, sx, sy, gx, gy, obstacles) == 0 def test_min_moves_to_reach_goal_large_grid(): h, w = 1000, 1000 sx, sy = 1, 1 gx, gy = 1000, 1000 obstacles = set() assert min_moves_to_reach_goal(h, w, sx, sy, gx, gy, obstacles) != -1 if __name__ == '__main__': pytest.main()","solution":"from collections import deque def min_moves_to_reach_goal(h, w, sx, sy, gx, gy, obstacles): def is_valid(x, y, h, w, obstacles, visited): return 1 <= x <= h and 1 <= y <= w and (x, y) not in obstacles and (x, y) not in visited directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(sx, sy, 0)]) visited = set() visited.add((sx, sy)) while queue: x, y, moves = queue.popleft() if (x, y) == (gx, gy): return moves for d in directions: nx, ny = x + d[0], y + d[1] if is_valid(nx, ny, h, w, obstacles, visited): visited.add((nx, ny)) queue.append((nx, ny, moves + 1)) return -1"},{"question":"from datetime import datetime, timedelta from typing import List, Tuple def total_unique_days(intervals: List[Tuple[str, str]]) -> int: Calculate the total number of unique days covered by the date intervals. Args: intervals (list of tuples): List of (start_date, end_date) tuples where dates are in \\"YYYY-MM-DD\\" format. Returns: int: Total number of unique days covered by the intervals. # Your code goes here def read_intervals_from_file(filename: str) -> List[Tuple[str, str]]: Read intervals from a file and return them as a list of tuples. Args: filename (str): The name of the file containing the intervals. Returns: list of tuples: List of (start_date, end_date) tuples. # Your code goes here # Example usage Example Input File: 3 2023-01-01 2023-01-10 2023-01-05 2023-01-15 2023-01-20 2023-01-25 intervals = read_intervals_from_file('input.txt') result = total_unique_days(intervals) print(result) # Expected output: 20 import pytest from solution import total_unique_days def test_single_interval(): intervals = [(\\"2023-01-01\\", \\"2023-01-10\\")] assert total_unique_days(intervals) == 10 def test_non_overlapping_intervals(): intervals = [(\\"2023-01-01\\", \\"2023-01-10\\"), (\\"2023-01-20\\", \\"2023-01-25\\")] assert total_unique_days(intervals) == 16 def test_overlapping_intervals(): intervals = [(\\"2023-01-01\\", \\"2023-01-10\\"), (\\"2023-01-05\\", \\"2023-01-15\\")] assert total_unique_days(intervals) == 15 def test_continuous_intervals(): intervals = [(\\"2023-01-01\\", \\"2023-01-10\\"), (\\"2023-01-11\\", \\"2023-01-20\\")] assert total_unique_days(intervals) == 20 def test_fully_contained_interval(): intervals = [(\\"2023-01-01\\", \\"2023-01-10\\"), (\\"2023-01-02\\", \\"2023-01-05\\")] assert total_unique_days(intervals) == 10 def test_large_dates(): intervals = [(\\"2023-01-01\\", \\"2023-12-31\\")] assert total_unique_days(intervals) == 365 def test_empty_intervals(): intervals = [] assert total_unique_days(intervals) == 0 def test_single_day_intervals(): intervals = [(\\"2023-01-01\\", \\"2023-01-01\\"), (\\"2023-01-01\\", \\"2023-01-01\\")] assert total_unique_days(intervals) == 1 if __name__ == \\"__main__\\": pytest.main()","solution":"from datetime import datetime, timedelta def total_unique_days(intervals): Calculate the total number of unique days covered by the date intervals. Args: intervals (list of tuples): List of (start_date, end_date) tuples where dates are in \\"YYYY-MM-DD\\" format. Returns: int: Total number of unique days covered by the intervals. unique_days = set() for start_date, end_date in intervals: start_dt = datetime.strptime(start_date, '%Y-%m-%d') end_dt = datetime.strptime(end_date, '%Y-%m-%d') current_dt = start_dt while current_dt <= end_dt: unique_days.add(current_dt) current_dt += timedelta(days=1) return len(unique_days) def read_intervals_from_file(filename): Read intervals from a file and return them as a list of tuples. Args: filename (str): The name of the file containing the intervals. Returns: list of tuples: List of (start_date, end_date) tuples. intervals = [] with open(filename, 'r') as file: n = int(file.readline().strip()) for _ in range(n): line = file.readline().strip() start_date, end_date = line.split() intervals.append((start_date, end_date)) return intervals"},{"question":"def min_sprinklers_needed(garden: List[List[int]]) -> int: Determine the minimum number of sprinklers needed to water all the flowers in the given garden grid. >>> min_sprinklers_needed([ ... [0, 1, 0], ... [1, 0, 1], ... [0, 0, 0] ... ]) 3 >>> min_sprinklers_needed([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) 0 >>> min_sprinklers_needed([[0, 1, 0]]) 1 >>> min_sprinklers_needed([ ... [0], ... [1], ... [0] ... ]) 1 >>> min_sprinklers_needed([ ... [1, 1], ... [1, 1] ... ]) 2 >>> min_sprinklers_needed([ ... [0, 0, 0, 1], ... [1, 0, 0, 0], ... [0, 0, 1, 0], ... [0, 1, 0, 1] ... ]) 4 # Implement your solution here","solution":"def min_sprinklers_needed(garden): n = len(garden) m = len(garden[0]) if n > 0 else 0 rows_to_water = [False] * n cols_to_water = [False] * m for i in range(n): for j in range(m): if garden[i][j] == 1: rows_to_water[i] = True cols_to_water[j] = True row_counts = sum(1 for i in range(n) if rows_to_water[i]) col_counts = sum(1 for j in range(m) if cols_to_water[j]) return max(row_counts, col_counts)"},{"question":"def count_even_sum_pairs(n: int, array: List[int]) -> int: Returns the number of pairs of indices (i, j) such that 1  i < j  n and the sum of array[i] and array[j] is an even number. >>> count_even_sum_pairs(5, [1, 2, 3, 4, 5]) # Expected: 4 >>> count_even_sum_pairs(4, [2, 4, 6, 8]) # Expected: 6","solution":"def count_even_sum_pairs(n, array): Returns the number of pairs of indices (i, j) such that 1  i < j  n and the sum of array[i] and array[j] is an even number. even_count = 0 odd_count = 0 for number in array: if number % 2 == 0: even_count += 1 else: odd_count += 1 # The number of ways to pick 2 elements from even_count elements even_pairs = (even_count * (even_count - 1)) // 2 # The number of ways to pick 2 elements from odd_count elements odd_pairs = (odd_count * (odd_count - 1)) // 2 # The valid pairs are the sum of even_pairs and odd_pairs return even_pairs + odd_pairs"},{"question":"def max_sum_subarray(n: int, k: int, a: List[int], b: List[int]) -> int: Determine the maximum sum of any subarray of length k from either array a or array b. >>> max_sum_subarray(5, 3, [1, 5, 2, 3, 6], [2, 4, 1, 8, 5]) 14 >>> max_sum_subarray(4, 2, [3, 3, 3, 3], [3, 3, 3, 3]) 6 >>> max_sum_subarray(4, 4, [1, 2, 3, 4], [4, 3, 2, 1]) 10 >>> max_sum_subarray(1, 1, [7], [5]) 7 >>> max_sum_subarray(3, 1, [1, 3, 2], [5, 4, 6]) 6 >>> max_sum_subarray(4, 2, [1000, 2000, 3000, 4000], [4000, 3000, 2000, 1000]) 7000","solution":"def max_sum_subarray(n, k, a, b): def max_k_subarray_sum(arr, k): current_sum = sum(arr[:k]) max_sum = current_sum for i in range(k, len(arr)): current_sum = current_sum - arr[i - k] + arr[i] max_sum = max(max_sum, current_sum) return max_sum max_sum_a = max_k_subarray_sum(a, k) max_sum_b = max_k_subarray_sum(b, k) return max(max_sum_a, max_sum_b)"},{"question":"def min_swaps_to_avoid_consecutive(s: str) -> int: Returns the minimum number of swaps required to rearrange the tubes so that no two consecutive tubes have the same color. >>> min_swaps_to_avoid_consecutive(\\"abcabc\\") 0 >>> min_swaps_to_avoid_consecutive(\\"aabc\\") 1 >>> min_swaps_to_avoid_consecutive(\\"aaabbb\\") 2","solution":"def min_swaps_to_avoid_consecutive(s): Returns the minimum number of swaps required to rearrange the tubes so that no two consecutive tubes have the same color. swaps = 0 i = 0 while i < len(s) - 1: if s[i] == s[i + 1]: swaps += 1 i += 2 else: i += 1 return swaps"},{"question":"def max_sequence_length_after_removal(n: int, sequence: List[int]) -> int: Given the length of the sequence n and the sequence of integers, this function returns the maximum length of the sequence after performing the operation of removing two adjacent elements with an even sum exactly once. >>> max_sequence_length_after_removal(4, [1, 3, 2, 8]) 2 >>> max_sequence_length_after_removal(4, [1, 2, 3, 4]) 4 >>> max_sequence_length_after_removal(2, [2, 2]) 0 >>> max_sequence_length_after_removal(5, [1, 2, 4, 6, 9]) 3 >>> max_sequence_length_after_removal(6, [11, 15, 9, 3, 7, 21]) 4 def process_test_cases(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Process multiple test cases for the max_sequence_length_after_removal function. >>> process_test_cases([(4, [1, 3, 2, 8]), (4, [1, 2, 3, 4]), (2, [2, 2]), (5, [1, 2, 4, 6, 9]), (6, [11, 15, 9, 3, 7, 21])]) [2, 4, 0, 3, 4]","solution":"def max_sequence_length_after_removal(n, sequence): Given the length of sequence n and the sequence of integers, this function returns the maximum length of the sequence after performing the operation of removing two adjacent elements with an even sum exactly once. for i in range(n - 1): if (sequence[i] + sequence[i + 1]) % 2 == 0: return n - 2 return n def process_test_cases(test_cases): results = [] for n, sequence in test_cases: result = max_sequence_length_after_removal(n, sequence) results.append(result) return results"},{"question":"def max_equal_days(n: int, packets: List[int]) -> int: Returns the maximum number of days Tom can distribute exactly the same number of packets. Args: n (int): The number of days the event lasts. packets (list): The number of packets available on each day. Returns: int: The maximum number of days with the same number of packets. def test_example_case(): assert max_equal_days(6, [5, 3, 9, 3, 3, 7]) == 3 def test_all_same_packets(): assert max_equal_days(5, [5, 5, 5, 5, 5]) == 5 def test_all_different_packets(): assert max_equal_days(4, [1, 2, 3, 4]) == 1 def test_mixed_packets(): assert max_equal_days(7, [2, 2, 3, 2, 4, 4, 4]) == 3 def test_single_day(): assert max_equal_days(1, [10]) == 1","solution":"def max_equal_days(n, packets): Returns the maximum number of days Tom can distribute exactly the same number of packets. Args: n (int): The number of days the event lasts. packets (list): The number of packets available on each day. Returns: int: The maximum number of days with the same number of packets. from collections import Counter packet_counts = Counter(packets) max_days = max(packet_counts.values()) return max_days"},{"question":"def can_be_palindrome_with_one_insert(s: str) -> str: Determines whether the string can be turned into a palindrome by adding at most one character. >>> can_be_palindrome_with_one_insert(\\"abca\\") \\"YES\\" >>> can_be_palindrome_with_one_insert(\\"abc\\") \\"NO\\"","solution":"def can_be_palindrome_with_one_insert(s): Determines whether the string can be turned into a palindrome by adding at most one character. Parameters: s (str): The input string Returns: str: \\"YES\\" if it's possible to turn the string into a palindrome by adding at most one character, otherwise \\"NO\\" def is_palindrome(s): return s == s[::-1] n = len(s) for i in range(n + 1): for ch in 'abcdefghijklmnopqrstuvwxyz': new_s = s[:i] + ch + s[i:] if is_palindrome(new_s): return \\"YES\\" return \\"NO\\" # Example usage: # print(can_be_palindrome_with_one_insert(\\"abca\\")) # Output: \\"YES\\" # print(can_be_palindrome_with_one_insert(\\"abc\\")) # Output: \\"NO\\""},{"question":"def minimum_transport_fee(N: int, edge_connections: List[Tuple[int, int, int]], queries: List[Tuple[int, int]]) -> List[int]: Given the city's tree structure and the lengths of the roads, for each query, determine the minimum transport fee to travel between two specified districts. >>> minimum_transport_fee(5, [(1, 2, 3), (1, 3, 2), (3, 4, 4), (3, 5, 1)], [(4, 5), (1, 4), (2, 5)]) [1, 2, 1] >>> minimum_transport_fee(5, [(1, 2, 3), (1, 3, 2), (3, 4, 4), (3, 5, 1)], [(2, 4)]) [2] >>> minimum_transport_fee(4, [(1, 2, 1000000000), (2, 3, 900000000), (2, 4, 800000000)], [(3, 4)]) [800000000] >>> minimum_transport_fee(2, [(1, 2, 10)], [(1, 2)]) [10]","solution":"from collections import defaultdict, deque import sys input = sys.stdin.read sys.setrecursionlimit(200000) def find_LCA_and_minimum_edge(parent, lca_matrix, min_edge_matrix, depth, u, v): if depth[u] < depth[v]: u, v = v, u diff = depth[u] - depth[v] min_edge = float('inf') for i in range(17): if (diff >> i) & 1: min_edge = min(min_edge, min_edge_matrix[u][i]) u = lca_matrix[u][i] if u == v: return min_edge for i in range(16, -1, -1): if lca_matrix[u][i] != lca_matrix[v][i]: min_edge = min(min_edge, min_edge_matrix[u][i], min_edge_matrix[v][i]) u = lca_matrix[u][i] v = lca_matrix[v][i] return min(min_edge, min_edge_matrix[u][0], min_edge_matrix[v][0]) def preprocess_lca(N, edge_connections): tree = defaultdict(list) for u, v, w in edge_connections: tree[u].append((v, w)) tree[v].append((u, w)) parent = [-1] * (N + 1) depth = [-1] * (N + 1) min_edge = [[float('inf')] * 18 for _ in range(N + 1)] lca_matrix = [[-1] * 18 for _ in range(N + 1)] def dfs(u, d): stack = [(u, d, -1, float('inf'))] while stack: u, d, p, w = stack.pop() parent[u] = p depth[u] = d min_edge[u][0] = w lca_matrix[u][0] = p for v, weight in tree[u]: if v != p: stack.append((v, d + 1, u, weight)) dfs(1, 0) for j in range(1, 18): for i in range(1, N + 1): if lca_matrix[i][j - 1] != -1: lca_matrix[i][j] = lca_matrix[lca_matrix[i][j - 1]][j - 1] min_edge[i][j] = min(min_edge[i][j - 1], min_edge[lca_matrix[i][j - 1]][j - 1]) return parent, lca_matrix, min_edge, depth def minimum_transport_fee(N, edge_connections, queries): parent, lca_matrix, min_edge, depth = preprocess_lca(N, edge_connections) result = [] for a, b in queries: result.append(find_LCA_and_minimum_edge(parent, lca_matrix, min_edge, depth, a, b)) return result"},{"question":"def smallest_subarray_with_sum_at_least_s(N: int, S: int, A: List[int]) -> int: Returns the length of the smallest subarray with a sum of at least S. If no such subarray exists, returns 0. :param N: int: Length of the array. :param S: int: Required subarray sum. :param A: List[int]: List of integers representing the array. :return: int: Length of the smallest subarray with a sum of at least S or 0 if no such subarray exists. >>> smallest_subarray_with_sum_at_least_s(10, 15, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 2 >>> smallest_subarray_with_sum_at_least_s(5, 11, [1, 2, 3, 4, 5]) 3 >>> smallest_subarray_with_sum_at_least_s(5, 15, [1, 2, 3, 4, 5]) 5 >>> smallest_subarray_with_sum_at_least_s(9, 20, [1, 2, 3, 4, 5, 6, 7, 8, 9]) 3 >>> smallest_subarray_with_sum_at_least_s(5, 100, [1, 2, 3, 4, 5]) 0 >>> smallest_subarray_with_sum_at_least_s(5, 4, [4, 3, 2, 1, 5]) 1","solution":"def smallest_subarray_with_sum_at_least_s(N, S, A): Returns the length of the smallest subarray with a sum of at least S. If no such subarray exists, returns 0. :param N: int: Length of the array. :param S: int: Required subarray sum. :param A: list: List of integers representing the array. :return: int: Length of the smallest subarray with a sum of at least S or 0 if no such subarray exists. min_length = float('inf') current_sum = 0 left = 0 for right in range(N): current_sum += A[right] while current_sum >= S: min_length = min(min_length, right - left + 1) current_sum -= A[left] left += 1 return min_length if min_length != float('inf') else 0"},{"question":"import heapq from typing import List, Tuple, Union def dijkstra(n: int, edges: List[Tuple[int, int, int]], s: int, t: int) -> Union[str, Tuple[str, int, List[int]]]: Find the shortest path in an undirected graph with given edges and weights. Args: n : int : number of nodes edges : List[Tuple[int, int, int]] : list of edges where each edge is represented by a tuple (u, v, w) s : int : starting node t : int : ending node Returns: Union[str, Tuple[str, int, List[int]]] : \\"NO\\" if no path exists, else a tuple (\\"YES\\", length of shortest path, list of nodes in the path) Test cases: >>> dijkstra(3, [(1, 2, 10)], 1, 3) 'NO' >>> dijkstra(1, [], 1, 1) ('YES', 0, [1]) >>> dijkstra(3, [(1, 2, 1), (2, 3, 1)], 1, 3) ('YES', 2, [1, 2, 3]) >>> dijkstra(5, [(1, 2, 2), (1, 3, 3), (2, 3, 2), (2, 4, 4), (3, 4, 1), (4, 5, 1)], 1, 5) ('YES', 5, [1, 2, 3, 4, 5]) >>> dijkstra(4, [(1, 2, 1), (2, 3, 1), (1, 3, 5), (3, 4, 1)], 1, 4) ('YES', 3, [1, 2, 3, 4])","solution":"import heapq def dijkstra(n, edges, s, t): graph = {i: [] for i in range(1, n + 1)} for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) dist = {i: float('inf') for i in range(1, n + 1)} dist[s] = 0 prev = {i: None for i in range(1, n + 1)} priority_queue = [(0, s)] while priority_queue: d, node = heapq.heappop(priority_queue) if d > dist[node]: continue for neighbor, weight in graph[node]: alt = dist[node] + weight if alt < dist[neighbor]: dist[neighbor] = alt prev[neighbor] = node heapq.heappush(priority_queue, (alt, neighbor)) if dist[t] == float('inf'): return \\"NO\\" path = [] current = t while current: path.append(current) current = prev[current] path.reverse() return (\\"YES\\", dist[t], path) # Example usage n = 5 m = 6 edges = [ (1, 2, 2), (1, 3, 3), (2, 3, 2), (2, 4, 4), (3, 4, 1), (4, 5, 1) ] s = 1 t = 5 print(dijkstra(n, edges, s, t)) # Output: (\\"YES\\", 5, [1, 2, 3, 4, 5])"},{"question":"def unique_paths(n: int, m: int) -> int: Returns the number of unique paths in a n x m grid from top-left to bottom-right. >>> unique_paths(3, 4) 10 >>> unique_paths(1, 1) 1 >>> unique_paths(2, 2) 2 >>> unique_paths(3, 3) 6 >>> unique_paths(4, 4) 20 >>> unique_paths(7, 3) 28","solution":"def unique_paths(n, m): Returns the number of unique paths in a n x m grid from top-left to bottom-right. # Create a 2D list to store the number of paths to each cell dp = [[1] * m for _ in range(n)] # Iterate over the grid starting from cell (1, 1) for i in range(1, n): for j in range(1, m): dp[i][j] = dp[i - 1][j] + dp[i][j - 1] # The bottom-right corner will have the number of unique paths return dp[-1][-1]"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring where all characters are unique. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"a\\") 1 >>> length_of_longest_substring(\\"abcdefgh\\") 8 >>> length_of_longest_substring(\\"abababab\\") 2 >>> length_of_longest_substring(\\"aababcabcd\\") 4 >>> length_of_longest_substring(\\"a\\" * 500 + \\"b\\" * 500) 2","solution":"def length_of_longest_substring(s): Returns the length of the longest substring where all characters are unique. char_set = set() left = 0 max_length = 0 for right in range(len(s)): while s[right] in char_set: char_set.remove(s[left]) left += 1 char_set.add(s[right]) max_length = max(max_length, right - left + 1) return max_length"},{"question":"def smallest_subarray_length(nums: List[int], target: int) -> int: Given an array of integers, returns the length of the smallest contiguous subarray for which the sum is equal to or greater than the target integer. If no such subarray exists, return 0. >>> smallest_subarray_length([2, 4, 3, 1, 1, 5, 6], 7) == 2 # subarray [4, 3] >>> smallest_subarray_length([12, 1, 3, 4, 5, 6], 11) == 1 # subarray [12] >>> smallest_subarray_length([1, 1, 1, 1, 1, 1], 10) == 0 # no subarray meets the target >>> smallest_subarray_length([1, 2, 3, 4, 5], 15) == 5 # whole array needed","solution":"def smallest_subarray_length(nums, target): Returns the length of the smallest contiguous subarray where the sum is equal to or greater than the target. If no such subarray exists, returns 0. n = len(nums) min_len = float('inf') current_sum = 0 start = 0 for end in range(n): current_sum += nums[end] while current_sum >= target: min_len = min(min_len, end - start + 1) current_sum -= nums[start] start += 1 return min_len if min_len != float('inf') else 0"},{"question":"def maximize_priority(m: int, n: int, slots: List[int], presentations: List[Tuple[int, int, int]]) -> int: Schedules the presentations into the available slots aiming to maximize the total priority. Parameters: m (int): The number of available time slots. n (int): The number of presentations. slots (list of int): A list of available time slots. presentations (list of tuples): A list of presentations, each defined by a tuple (priority, duration, start_hour). Returns: int: The maximum total priority that can be achieved by scheduling the presentations optimally.","solution":"def maximize_priority(m, n, slots, presentations): Schedules the presentations into the available slots aiming to maximize the total priority. Parameters: m (int): The number of available time slots. n (int): The number of presentations. slots (list of int): A list of available time slots. presentations (list of tuples): A list of presentations, each defined by a tuple (priority, duration, start_hour). Returns: int: The maximum total priority that can be achieved by scheduling the presentations optimally. slots.sort() presentations.sort(reverse=True, key=lambda x: x[0]) scheduled_slots = set() total_priority = 0 for priority, duration, start_hour in presentations: for slot in slots: if slot not in scheduled_slots and slot == start_hour: scheduled_slots.add(slot) total_priority += priority break return total_priority # Example usage: # m, n = 5, 3 # slots = [9, 12, 14, 16, 18] # presentations = [(500, 1, 9), (300, 2, 12), (200, 1, 14)] # print(maximize_priority(m, n, slots, presentations)) # Output: 1000"},{"question":"def minimum_distance(n: int, workstations: str) -> int: Finds the minimum distance between two empty workstations for placing a keyboard and a mouse. Args: n (int): number of workstations. workstations (str): string representing occupied (1) and empty (0) workstations. Returns: int: minimum possible distance or -1 if placement is not possible. >>> minimum_distance(7, \\"0100010\\") 1 >>> minimum_distance(5, \\"11111\\") -1 >>> minimum_distance(6, \\"000000\\") 1 >>> minimum_distance(1, \\"0\\") -1 >>> minimum_distance(2, \\"00\\") 1 >>> minimum_distance(3, \\"010\\") 2 >>> minimum_distance(8, \\"00101001\\") 1 >>> minimum_distance(7, \\"0011000\\") 1","solution":"def minimum_distance(n, workstations): Finds the minimum distance between two empty workstations for placing a keyboard and a mouse. Args: n (int): number of workstations. workstations (str): string representing occupied (1) and empty (0) workstations. Returns: int: minimum possible distance or -1 if placement is not possible. empty_positions = [i for i, char in enumerate(workstations) if char == '0'] if len(empty_positions) < 2: return -1 min_distance = float('inf') for i in range(1, len(empty_positions)): distance = empty_positions[i] - empty_positions[i - 1] if distance < min_distance: min_distance = distance return min_distance"},{"question":"def minimized_max_gift_bags(n: int, m: int) -> int: Determine the minimized maximum number of children that can receive the same type of gift bag. Parameters: n (int): The number of children. m (int): The number of different types of gift bags. Returns: int: The minimized maximum number of children that can receive the same type of gift bag. >>> minimized_max_gift_bags(7, 3) 3 >>> minimized_max_gift_bags(1, 1) 1 >>> minimized_max_gift_bags(10, 5) 2 >>> minimized_max_gift_bags(9, 3) 3 >>> minimized_max_gift_bags(12, 4) 3 >>> minimized_max_gift_bags(100, 10) 10 >>> minimized_max_gift_bags(50, 7) 8 >>> minimized_max_gift_bags(1000000000, 10) 100000000","solution":"def minimized_max_gift_bags(n, m): Determine the minimized maximum number of children that can receive the same type of gift bag. Parameters: n (int): The number of children. m (int): The number of different types of gift bags. Returns: int: The minimized maximum number of children that can receive the same type of gift bag. return (n + m - 1) // m"},{"question":"from typing import List def shortest_path_in_grid(m: int, n: int, grid: List[List[int]]) -> int: Find the shortest path from the top-left corner to the bottom-right corner of a grid avoiding obstacles. Returns the minimum number of steps required to reach the bottom-right corner or -1 if it is impossible. >>> shortest_path_in_grid(3, 3, [ [0, 0, 0], [1, 1, 0], [0, 0, 0] ]) 4 >>> shortest_path_in_grid(3, 3, [ [0, 1, 0], [1, 1, 0], [0, 0, 0] ]) -1 >>> shortest_path_in_grid(1, 1, [ [0] ]) 0 >>> shortest_path_in_grid(2, 2, [ [0, 0], [0, 0] ]) 2 >>> shortest_path_in_grid(2, 2, [ [0, 1], [0, 0] ]) 2 >>> shortest_path_in_grid(2, 2, [ [1, 1], [1, 0] ]) -1","solution":"from collections import deque def shortest_path_in_grid(m, n, grid): Find the shortest path from the top-left corner to the bottom-right corner of a grid avoiding obstacles. Returns the minimum number of steps required to reach the bottom-right corner or -1 if it is impossible. if grid[0][0] == 1 or grid[m-1][n-1] == 1: return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] visited = [[False] * n for _ in range(m)] queue = deque([(0, 0, 0)]) # (row, col, steps) visited[0][0] = True while queue: r, c, steps = queue.popleft() if r == m - 1 and c == n - 1: return steps for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < m and 0 <= nc < n and not visited[nr][nc] and grid[nr][nc] == 0: visited[nr][nc] = True queue.append((nr, nc, steps + 1)) return -1"},{"question":"def shortest_distance(L, positions, queries): Computes the shortest distance on a circular track between checkpoints \`a\` and \`b\` for each query. Parameters: - L: length of the circular track - positions: list of positions of checkpoints on the track - queries: list of tuples, where each tuple contains two integers (a, b) representing the start and end checkpoints Returns: - List of shortest distances for each query pass # Test Cases def test_shortest_distance_example(): L = 100 positions = [10, 20, 30, 60, 80] queries = [(1, 3), (3, 5), (1, 5)] expected = [20, 50, 30] assert shortest_distance(L, positions, queries) == expected def test_shortest_distance_single_checkpoint(): L = 50 positions = [0, 25] queries = [(1, 2), (2, 1)] expected = [25, 25] assert shortest_distance(L, positions, queries) == expected def test_shortest_distance_full_circle(): L = 100 positions = [0, 50] queries = [(1, 2), (2, 1)] expected = [50, 50] assert shortest_distance(L, positions, queries) == expected def test_shortest_distance_large_L(): L = 1000000000 positions = [1, 500000000, 999999999] queries = [(1, 2), (2, 3), (3, 1)] expected = [499999999, 499999999, 2] assert shortest_distance(L, positions, queries) == expected def test_shortest_distance_non_trivial(): L = 120 positions = [10, 30, 50, 70, 90] queries = [(1, 5), (2, 4)] expected = [40, 40] assert shortest_distance(L, positions, queries) == expected","solution":"def shortest_distance(L, positions, queries): Computes the shortest distance on a circular track between checkpoints \`a\` and \`b\` for each query. Parameters: - L: length of the circular track - positions: list of positions of checkpoints on the track - queries: list of tuples, where each tuple contains two integers (a, b) representing the start and end checkpoints Returns: - List of shortest distances for each query def distance(a, b): d1 = abs(positions[b-1] - positions[a-1]) d2 = L - d1 return min(d1, d2) result = [] for a, b in queries: result.append(distance(a, b)) return result"},{"question":"def max_simultaneous_events(n, events): Determines the maximum number of events happening simultaneously at any point in time. :param n: Integer, number of events :param events: List of tuples, where each tuple contains the start time and end time of an event :return: Integer, maximum number of events happening simultaneously pass import pytest def test_example_1(): n = 3 events = [(1, 4), (2, 5), (6, 8)] assert max_simultaneous_events(n, events) == 2 def test_example_2(): n = 4 events = [(1, 10), (2, 6), (5, 8), (9, 12)] assert max_simultaneous_events(n, events) == 3 def test_no_overlap(): n = 3 events = [(1, 2), (3, 4), (5, 6)] assert max_simultaneous_events(n, events) == 1 def test_all_same_time(): n = 4 events = [(1, 4), (1, 4), (1, 4), (1, 4)] assert max_simultaneous_events(n, events) == 4 def test_partial_overlap(): n = 3 events = [(1, 3), (2, 4), (3, 5)] assert max_simultaneous_events(n, events) == 2 def test_single_event(): n = 1 events = [(1, 2)] assert max_simultaneous_events(n, events) == 1","solution":"def max_simultaneous_events(n, events): Determines the maximum number of events happening simultaneously at any point in time. :param n: Integer, number of events :param events: List of tuples, where each tuple contains the start time and end time of an event :return: Integer, maximum number of events happening simultaneously events_dict = {} for start, end in events: if start in events_dict: events_dict[start] += 1 else: events_dict[start] = 1 if end in events_dict: events_dict[end] -= 1 else: events_dict[end] = -1 max_events = 0 ongoing_events = 0 for time in sorted(events_dict): ongoing_events += events_dict[time] max_events = max(max_events, ongoing_events) return max_events"},{"question":"def garden_operations(n: int, m: int, k: int, operations: List[Tuple[int, ...]]) -> List[str]: Perform operations on a garden represented as a 1-dimensional array and check for contiguous segments. Args: n : int : length of the garden array m : int : number of operations k : int : length of the contiguous segment of flowers to check operations : List[Tuple[int, ...]] : list of operations to perform on the garden Returns: List[str] : results of the check operations >>> garden_operations(8, 5, 3, [(1, 3), (1, 4), (2, ), (1, 5), (2, )]) [\\"NO\\", \\"YES\\"] >>> garden_operations(5, 3, 2, [(2, ), (1, 1), (2, )]) [\\"NO\\", \\"NO\\"]","solution":"def garden_operations(n, m, k, operations): garden = [0] * n results = [] for operation in operations: if operation[0] == 1: # plant flower i = operation[1] - 1 if garden[i] == 0: garden[i] = 1 elif operation[0] == 2: # check for sub-segment of length k with only flowers found = False for i in range(n - k + 1): if all(garden[i:i + k]): found = True break results.append(\\"YES\\" if found else \\"NO\\") return results # Example usage: n = 8 m = 5 k = 3 operations = [ (1, 3), (1, 4), (2, ), (1, 5), (2, ) ] print(garden_operations(n, m, k, operations))"},{"question":"def count_weight_increase_periods(n: int, weights: List[int]) -> int: Returns the number of periods of weight increase in the given list of weights. >>> count_weight_increase_periods(6, [1, 2, 2, 3, 4, 1]) == 2 >>> count_weight_increase_periods(1, [5]) == 0 >>> count_weight_increase_periods(5, [1, 2, 3, 4, 5]) == 1 >>> count_weight_increase_periods(5, [5, 4, 3, 2, 1]) == 0 >>> count_weight_increase_periods(7, [1, 3, 2, 1, 4, 3, 5]) == 3 >>> count_weight_increase_periods(6, [1, 2, 1, 2, 1, 2]) == 3","solution":"def count_weight_increase_periods(n, weights): Returns the number of periods of weight increase in the given list of weights. if n == 1: return 0 periods = 0 in_period = False for i in range(1, n): if weights[i] > weights[i - 1]: if not in_period: in_period = True periods += 1 else: in_period = False return periods"},{"question":"def count_distinct_peaks(n: int, heights: List[int]) -> int: Returns the number of distinct peak heights Mike has climbed. Args: n (int): The number of peaks Mike has climbed. heights (list of int): The heights of the peaks in the order Mike climbed them. Returns: int: The number of distinct peak heights. Examples: >>> count_distinct_peaks(7, [1000, 2000, 3000, 1000, 1500, 2000, 3000]) 4 >>> count_distinct_peaks(5, [3000, 3000, 3000, 3000, 3000]) 1 >>> count_distinct_peaks(5, [1000, 2000, 3000, 4000, 5000]) 5 >>> count_distinct_peaks(1, [1000]) 1 >>> count_distinct_peaks(2, [1000, 2000]) 2 >>> count_distinct_peaks(4, [1000000000, 1000000000, 999999999, 999999998]) 3 >>> count_distinct_peaks(1, [1]) 1 >>> count_distinct_peaks(6, [1, 2, 1, 2, 1, 2]) 2","solution":"def count_distinct_peaks(n, heights): Returns the number of distinct peak heights Mike has climbed. Args: n (int): The number of peaks Mike has climbed. heights (list of int): The heights of the peaks in the order Mike climbed them. Returns: int: The number of distinct peak heights. return len(set(heights))"},{"question":"def rearrange_queue(heights: List[int]) -> List[int]: Rearranges the queue so that no person is unhappy if someone taller is in front of them. This can be achieved by sorting the list of heights. :param heights: List of integers representing heights. :return: List of integers representing rearranged heights. return sorted(heights)","solution":"def rearrange_queue(heights): Rearranges the queue so that no person is unhappy if someone taller is in front of them. This can be achieved by sorting the list of heights. :param heights: List of integers representing heights. :return: List of integers representing rearranged heights. return sorted(heights)"},{"question":"def find_winner(n: int, array: List[int]) -> str: Determines the winner of the game with the given array. Alice starts first, and both play optimally. :param n: int, the length of the array :param array: list, the array of integers :return: str, \\"Alice\\" or \\"Bob\\" >>> find_winner(3, [1, 2, 3]) \\"Alice\\" >>> find_winner(4, [1, 2, 1, 1]) \\"Bob\\" from solution import find_winner def test_odd_length_array(): assert find_winner(3, [1, 2, 3]) == \\"Alice\\" assert find_winner(5, [4, 5, 6, 7, 8]) == \\"Alice\\" def test_even_length_array(): assert find_winner(4, [1, 2, 1, 1]) == \\"Bob\\" assert find_winner(6, [10, 20, 30, 40, 50, 60]) == \\"Bob\\" def test_min_length_array(): assert find_winner(1, [5]) == \\"Alice\\" assert find_winner(2, [5, 6]) == \\"Bob\\" def test_large_length_array(): assert find_winner(200001, [i for i in range(1, 200002)]) == \\"Alice\\" assert find_winner(200000, [i for i in range(1, 200001)]) == \\"Bob\\"","solution":"def find_winner(n, array): Determines the winner of the game with given array. Alice starts first, and both play optimally. :param n: int, the length of the array :param array: list, the array of integers :return: str, \\"Alice\\" or \\"Bob\\" # If n is odd, Alice can always win by removing the entire array first. # If n is even, Bob will win assuming optimal play from both sides. if n % 2 == 1: return \\"Alice\\" else: return \\"Bob\\""},{"question":"def can_buy_fruits(n: int, m: int, b: int, prices: List[int]) -> str: Determine if it is possible to buy at least m units of each of the n types of fruits within the budget b. :param n: int - number of types of fruits :param m: int - minimum units of each fruit to buy :param b: int - total budget in rubles :param prices: list - list of integers representing the price of each type of fruit :return: str - \\"Possible\\" if the friends can buy at least m units of each fruit within their budget, otherwise \\"Impossible\\" >>> can_buy_fruits(4, 10, 1500, [12, 15, 25, 10]) 'Possible' >>> can_buy_fruits(4, 10, 500, [12, 15, 25, 10]) 'Impossible' >>> can_buy_fruits(3, 5, 375, [25, 25, 25]) 'Possible' >>> can_buy_fruits(1, 50, 500, [10]) 'Possible' >>> can_buy_fruits(1, 100, 500, [10]) 'Impossible'","solution":"def can_buy_fruits(n, m, b, prices): Determine if it is possible to buy at least m units of each of the n types of fruits within the budget b. :param n: int - number of types of fruits :param m: int - minimum units of each fruit to buy :param b: int - total budget in rubles :param prices: list - list of integers representing the price of each type of fruit :return: str - \\"Possible\\" if the friends can buy at least m units of each fruit within their budget, otherwise \\"Impossible\\" total_cost = sum(price * m for price in prices) if total_cost <= b: return \\"Possible\\" else: return \\"Impossible\\" # Example usage n, m, b = 4, 10, 500 prices = [12, 15, 25, 10] print(can_buy_fruits(n, m, b, prices)) # Output: \\"Impossible\\""},{"question":"from typing import List, Tuple def order_frequencies(n: int, customer_ids: List[int]) -> List[Tuple[int, int]]: Returns the frequency of orders for each customer ID in ascending order of customer IDs. Parameters: n (int): the number of orders customer_ids (List[int]): a list of customer IDs Returns: List[Tuple[int, int]]: a list of tuples, each containing a customer ID and the number of orders. Example: >>> order_frequencies(6, [1, 2, 2, 3, 3, 3]) [(1, 1), (2, 2), (3, 3)] >>> order_frequencies(1, [7]) [(7, 1)] >>> order_frequencies(5, [5, 3, 9, 2, 4]) [(2, 1), (3, 1), (4, 1), (5, 1), (9, 1)] >>> order_frequencies(10, [3, 3, 3, 2, 2, 1, 1, 1, 1, 4]) [(1, 4), (2, 2), (3, 3), (4, 1)] >>> order_frequencies(3, [100000, 99999, 99999]) [(99999, 2), (100000, 1)]","solution":"from collections import defaultdict def order_frequencies(n, customer_ids): Returns the frequency of orders for each customer ID in ascending order of customer IDs. Parameters: n (int): the number of orders customer_ids (list of int): a list of customer IDs Returns: list of tuples: a list of tuples, each containing a customer ID and the number of orders freq_dict = defaultdict(int) for cid in customer_ids: freq_dict[cid] += 1 sorted_freq = sorted(freq_dict.items()) return sorted_freq"},{"question":"from typing import List, Tuple def process_graph_queries(n: int, m: int, q: int, vertex_values: List[int], edges: List[Tuple[int, int]], queries: List[str]) -> List[int]: Process a series of queries on an undirected graph with vertex values. Parameters: n (int): The number of vertices. m (int): The number of edges. q (int): The number of queries. vertex_values (List[int]): The initial values of the vertices. edges (List[Tuple[int, int]]): The edges of the graph. queries (List[str]): The list of queries to process. Returns: List[int]: The result of each type 2 query processed. Example: n, m, q = 4, 4, 3 vertex_values = [1, 2, 3, 4] edges = [(1, 2), (1, 3), (2, 3), (3, 4)] queries = [\\"2 1\\", \\"1 2 5\\", \\"2 1\\"] process_graph_queries(n, m, q, vertex_values, edges, queries) pass def test_example_case(): n, m, q = 4, 4, 3 vertex_values = [1, 2, 3, 4] edges = [(1, 2), (1, 3), (2, 3), (3, 4)] queries = [\\"2 1\\", \\"1 2 5\\", \\"2 1\\"] assert process_graph_queries(n, m, q, vertex_values, edges, queries) == [10, 15] def test_add_value_query(): n, m, q = 4, 4, 4 vertex_values = [1, 2, 3, 4] edges = [(1, 2), (1, 3), (2, 3), (3, 4)] queries = [\\"2 1\\", \\"1 2 3\\", \\"2 1\\"] result = process_graph_queries(n, m, q, vertex_values, edges, queries) assert result == [10, 13] def test_disconnected_graph(): n, m, q = 4, 2, 3 vertex_values = [1, 2, 3, 4] edges = [(1, 2), (3, 4)] queries = [\\"2 1\\", \\"2 3\\", \\"1 3 5\\", \\"2 3\\"] result = process_graph_queries(n, m, q, vertex_values, edges, queries) assert result == [3, 7, 12] def test_single_node_graph(): n, m, q = 1, 0, 2 vertex_values = [10] edges = [] queries = [\\"2 1\\", \\"1 1 5\\", \\"2 1\\"] result = process_graph_queries(n, m, q, vertex_values, edges, queries) assert result == [10, 15]","solution":"def process_graph_queries(n, m, q, vertex_values, edges, queries): from collections import defaultdict, deque # Create the adjacency list for the graph adjacency_list = defaultdict(list) for u, v in edges: adjacency_list[u].append(v) adjacency_list[v].append(u) # Function to perform BFS to find all connected vertices def bfs(start): visited = set() queue = deque([start]) visited.add(start) while queue: node = queue.popleft() for neighbor in adjacency_list[node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) return visited results = [] for query in queries: parts = query.split() if parts[0] == \\"1\\": # Add a specified value to a specific vertex u = int(parts[1]) v = int(parts[2]) vertex_values[u - 1] += v elif parts[0] == \\"2\\": # Compute the sum of the values of all connected vertices u = int(parts[1]) connected_vertices = bfs(u) sum_values = sum(vertex_values[v - 1] for v in connected_vertices) results.append(sum_values) return results"},{"question":"def max_rectangle_area(forest: List[List[str]]) -> int: Given a 2D grid representing a forest, returns the area of the largest rectangular empty plot (containing only '0's). >>> forest1 = [ ... ['0', '0', '1', '0', '1'], ... ['0', '0', '0', '1', '0'], ... ['1', '0', '0', '0', '1'], ... ['1', '0', '0', '0', '0'] ... ] >>> max_rectangle_area(forest1) 6 >>> forest2 = [ ... ['0', '1'], ... ['0', '0'] ... ] >>> max_rectangle_area(forest2) 2","solution":"def max_rectangle_area(forest): Given a 2D grid representing a forest, returns the area of the largest rectangular empty plot (containing only '0's). def largest_histogram_area(heights): stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area if not forest: return 0 n = len(forest) m = len(forest[0]) height = [0] * m max_area = 0 for row in forest: for col in range(m): height[col] = height[col] + 1 if row[col] == '0' else 0 max_area = max(max_area, largest_histogram_area(height)) return max_area"},{"question":"def generate_special_array(n, d): Generates a Special Array of length n with a constant addition factor d. Args: n (int): The length of the array. d (int): The constant addition factor. Returns: list: The generated Special Array. pass # Test Cases def test_generate_special_array_example(): assert generate_special_array(5, 3) == [3, 3, 4, 6, 9] def test_generate_special_array_single_element(): assert generate_special_array(1, 5) == [5] def test_generate_special_array_multiple_elements_with_min_d(): assert generate_special_array(3, 1) == [1, 1, 2] def test_generate_special_array_with_high_values(): assert generate_special_array(5, 1000) == [1000, 1000, 1001, 1003, 1006] def test_generate_special_array_edge_case(): assert generate_special_array(1000, 1000) == [1000] + list(1000 + sum(range(i)) for i in range(1, 1000))","solution":"def generate_special_array(n, d): Generates a Special Array of length n with a constant addition factor d. Args: n (int): The length of the array. d (int): The constant addition factor. Returns: list: The generated Special Array. special_array = [] for i in range(n): if i == 0: special_array.append(d) else: special_array.append(special_array[-1] + (i - 1)) return special_array"},{"question":"from typing import List def max_candies(grid: List[List[int]]) -> int: Calculates the maximum number of candies the robot can collect. Parameters: grid (list of list of int): A 2D list representing the grid. Returns: int: The maximum number of candies the robot can collect. def test_max_candies_example(): grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert max_candies(grid) == 29 def test_max_candies_single_cell(): grid = [[5]] assert max_candies(grid) == 5 def test_max_candies_single_row(): grid = [[1, 2, 3, 4, 5]] assert max_candies(grid) == 15 def test_max_candies_single_column(): grid = [[1], [2], [3], [4], [5]] assert max_candies(grid) == 15 def test_max_candies_small_grid(): grid = [ [2, 3], [1, 5] ] assert max_candies(grid) == 10 def test_max_candies_large_grid(): grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] assert max_candies(grid) == 12","solution":"def max_candies(grid): Calculates the maximum number of candies the robot can collect. Parameters: grid (list of list of int): A 2D list representing the grid. Returns: int: The maximum number of candies the robot can collect. n = len(grid) m = len(grid[0]) # Initialize a dp array with same dimensions as grid dp = [[0]*m for _ in range(n)] # Base case: start at the top-left corner dp[0][0] = grid[0][0] # Fill the first row for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, n): for j in range(1, m): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The value in the bottom-right corner is the answer return dp[n-1][m-1]"},{"question":"def find_critical_connections(n: int, m: int, connections: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Finds all critical connections in the network represented as an undirected graph. Args: n (int): The number of routers. m (int): The number of direct connections between routers. connections (List[Tuple[int, int]]): List of connections where each connection is represented by a tuple (u, v). Returns: List[Tuple[int, int]]: A list of critical connections sorted lexicographically. Example: >>> find_critical_connections(4, 4, [(1, 2), (1, 3), (3, 4), (1, 4)]) [(1, 2)] >>> find_critical_connections(3, 3, [(1, 2), (2, 3), (1, 3)]) [] pass def process_input(n: int, m: int, input_connections: List[str]) -> str: Processes the input and returns the output as a formatted string. Args: n (int): The number of routers. m (int): The number of direct connections between routers. input_connections (List[str]): List of connections as strings in the format \`u v\`. Returns: str: The number of critical connections followed by each critical connection in a new line. Example: >>> process_input(4, 4, [\\"1 2\\", \\"1 3\\", \\"3 4\\", \\"1 4\\"]) '1n1 2' >>> process_input(3, 3, [\\"1 2\\", \\"2 3\\", \\"1 3\\"]) '0' pass","solution":"def find_critical_connections(n, m, connections): from collections import defaultdict def dfs(node, parent, discovery_time, low_time, graph, time, critical_connections): discovery_time[node] = low_time[node] = time[0] time[0] += 1 for neighbor in graph[node]: if neighbor == parent: continue if discovery_time[neighbor] == -1: dfs(neighbor, node, discovery_time, low_time, graph, time, critical_connections) low_time[node] = min(low_time[node], low_time[neighbor]) if low_time[neighbor] > discovery_time[node]: critical_connections.append((min(node, neighbor), max(node, neighbor))) else: low_time[node] = min(low_time[node], discovery_time[neighbor]) graph = defaultdict(list) for u, v in connections: graph[u].append(v) graph[v].append(u) discovery_time = [-1] * (n + 1) low_time = [-1] * (n + 1) time = [0] critical_connections = [] for i in range(1, n + 1): if discovery_time[i] == -1: dfs(i, -1, discovery_time, low_time, graph, time, critical_connections) critical_connections.sort() return critical_connections def process_input(n, m, input_connections): connections = [tuple(map(int, connection.split())) for connection in input_connections] result = find_critical_connections(n, m, connections) output = f\\"{len(result)}n\\" for connection in result: output += f\\"{connection[0]} {connection[1]}n\\" return output.strip() # Example usage: # Input n, m = 4, 4 connections = [\\"1 2\\", \\"1 3\\", \\"3 4\\", \\"1 4\\"] # Execute print(process_input(n, m, connections))"},{"question":"from typing import List, Tuple, Union def correct_observations(n: int, observations: List[Tuple[int, int]]) -> Union[str, List[Tuple[int, int]]]: Corrects the observations by summing the counts for each species and removing species with non-positive sums. Args: n (int): The number of observations. observations (list of tuples): Each tuple contains (id, count). Returns: list of tuples: Each tuple contains (id, count) with positive count sorted by id or \\"NO SPECIES LEFT\\" if all counts are non-positive. >>> correct_observations(5, [(3, 10), (1, -5), (3, -5), (2, 3), (1, 10)]) [(1, 5), (2, 3), (3, 5)] >>> correct_observations(5, [(3, -10), (1, -5), (3, -5), (2, -3), (1, -10)]) \\"NO SPECIES LEFT\\" >>> correct_observations(5, [(3, 10), (1, 5), (3, 5), (2, 3), (1, 10)]) [(1, 15), (2, 3), (3, 15)] >>> correct_observations(5, [(3, 10), (1, -5), (3, -10), (2, 3), (1, 10)]) [(1, 5), (2, 3)] >>> correct_observations(3, [(3, 0), (4, 0), (4, 2)]) [(4, 2)] >>> correct_observations(2, [(1, 10**9), (1, -10**9 + 1)]) [(1, 1)]","solution":"def correct_observations(n, observations): Corrects the observations by summing the counts for each species and removing species with non-positive sums. Args: n (int): The number of observations. observations (list of tuples): Each tuple contains (id, count). Returns: list of tuples: Each tuple contains (id, count) with positive count sorted by id. species_counts = {} for obs_id, count in observations: if obs_id in species_counts: species_counts[obs_id] += count else: species_counts[obs_id] = count corrected_list = [(species_id, count) for species_id, count in species_counts.items() if count > 0] if not corrected_list: return \\"NO SPECIES LEFT\\" return sorted(corrected_list, key=lambda x: x[0])"},{"question":"def has_met_water_goal(n: int, g: int, drink_logs: List[int]) -> str: Determines if the daily water intake goal is met based on the logs. :param n: int - Number of drink logs :param g: int - Daily water intake goal in milliliters :param drink_logs: list of int - Amount of water in milliliters logged in each drink :return: str - \\"YES\\" if total amount of water logged meets or exceeds the goal, otherwise \\"NO\\" >>> has_met_water_goal(5, 2000, [500, 300, 400, 100, 800]) \\"YES\\" >>> has_met_water_goal(3, 3000, [1000, 500, 1000]) \\"NO\\"","solution":"def has_met_water_goal(n, g, drink_logs): Determines if the daily water intake goal is met based on the logs. :param n: int - Number of drink logs :param g: int - Daily water intake goal in milliliters :param drink_logs: list of int - Amount of water in milliliters logged in each drink :return: str - \\"YES\\" if total amount of water logged meets or exceeds the goal, otherwise \\"NO\\" total_water_intake = sum(drink_logs) return \\"YES\\" if total_water_intake >= g else \\"NO\\""},{"question":"from typing import List def groupAnagrams(strs: List[str]) -> List[List[str]]: Group strings that are anagrams of each other. Args: strs: A list of strings Returns: A list of lists, where each list contains strings that are anagrams of each other Examples: >>> groupAnagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']] >>> groupAnagrams([\\"apple\\"]) [['apple']] >>> groupAnagrams([\\"abc\\", \\"def\\", \\"ghi\\"]) [['abc'], ['def'], ['ghi']] >>> groupAnagrams([\\"aabb\\", \\"bbaa\\", \\"abab\\", \\"baba\\", \\"xyz\\"]) [['aabb', 'bbaa', 'abab', 'baba'], ['xyz']] >>> groupAnagrams([\\"a\\", \\"a\\", \\"b\\", \\"b\\", \\"c\\"]) [['a', 'a'], ['b', 'b'], ['c']]","solution":"from collections import defaultdict def groupAnagrams(strs): Group strings that are anagrams of each other. Args: strs: A list of strings Returns: A list of lists, where each list contains strings that are anagrams of each other anagrams = defaultdict(list) for s in strs: sorted_str = ''.join(sorted(s)) anagrams[sorted_str].append(s) return list(anagrams.values())"},{"question":"def determine_winner(n: int, A: List[int]) -> str: Determine who will win the game if both players start with the array A. >>> determine_winner(5, [3, 1, 4, 2, 5]) == \\"Anna\\" >>> determine_winner(4, [1, 2, 3, 4]) == \\"Bob\\"","solution":"def determine_winner(n, A): A.sort() # If the array length is odd, Anna will win because she picks first and there will be odd number of picks # If the array length is even, Bob will win because they play optimally and there will be even number of picks if n % 2 == 1: return \\"Anna\\" else: return \\"Bob\\""},{"question":"from typing import List from collections import defaultdict def count_pairs_with_sum(a: List[int], k: int) -> int: This function takes an array of integers \`a\` and an integer \`k\`, and returns the number of pairs (i, j) (i < j) such that a[i] + a[j] == k. >>> count_pairs_with_sum([1, 2, 3, 4], 5) 2 >>> count_pairs_with_sum([1, 1, 1, 1], 3) 0 >>> count_pairs_with_sum([5, 5, 5, 5], 10) 6 >>> count_pairs_with_sum([1, -2, 3, 4, -1], 2) 2 >>> count_pairs_with_sum([-1, -1, 2, -2, 1], 0) 3","solution":"def count_pairs_with_sum(a, k): This function takes an array of integers \`a\` and an integer \`k\`, and returns the number of pairs (i, j) (i < j) such that a[i] + a[j] == k. from collections import defaultdict count = 0 freq = defaultdict(int) for num in a: count += freq[k - num] freq[num] += 1 return count"},{"question":"def min_refills(n: int, k: int, gifts: List[int]) -> int: Determines the minimum number of refills required for Santa's sled. Parameters: n (int): Number of children. k (int): Maximum capacity of the sled. gifts (list): List of integers representing the number of gifts each child should receive. Returns: int: Minimum number of refills needed. >>> min_refills(5, 10, [2, 3, 5, 3, 1]) 2 >>> min_refills(1, 1, [1]) 1","solution":"def min_refills(n, k, gifts): Determines the minimum number of refills required for Santa's sled. Parameters: n (int): Number of children. k (int): Maximum capacity of the sled. gifts (list): List of integers representing the number of gifts each child should receive. Returns: int: Minimum number of refills needed. total_gifts = sum(gifts) refills_needed = (total_gifts + k - 1) // k return refills_needed"},{"question":"def maximize_total_beauty(n: int, beauty_factors: List[int]) -> int: Returns the maximum total beauty John can achieve by grouping plants of the same type together. Parameters: n (int): the number of plants in the store. beauty_factors (List[int]): the list of the beauty factors of the plants. Returns: int: Maximum total beauty. # Unit Tests if __name__ == \\"__main__\\": assert maximize_total_beauty(1, [1]) == 1 assert maximize_total_beauty(1, [100]) == 100 assert maximize_total_beauty(5, [1, 1, 1, 1, 1]) == 5 assert maximize_total_beauty(3, [5, 5, 5]) == 15 assert maximize_total_beauty(5, [3, 1, 4, 1, 2]) == 11 assert maximize_total_beauty(6, [2, 2, 3, 3, 3, 1]) == 14 assert maximize_total_beauty(7, [1, 2, 3, 4, 5, 5, 5]) == 25 assert maximize_total_beauty(100000, [1000] * 100000) == 100000000 assert maximize_total_beauty(100000, list(range(1, 100001))) == 5000050000","solution":"def maximize_total_beauty(n, beauty_factors): Returns the maximum total beauty John can achieve by grouping plants of the same type together. Parameters: n (int): the number of plants in the store. beauty_factors (List[int]): the list of the beauty factors of the plants. Returns: int: Maximum total beauty. from collections import Counter # Count the occurrence of each beauty factor beauty_counts = Counter(beauty_factors) # Calculate total beauty total_beauty = sum(beauty_factor * count for beauty_factor, count in beauty_counts.items()) return total_beauty"},{"question":"def sequence_operations(operations: List[str]) -> List[str]: Process several operations on a sequence of integers and return results for Query operations. >>> sequence_operations([\\"Add 5\\", \\"Add 10\\", \\"Query 5\\", \\"Remove\\", \\"Query 10\\", \\"Stop\\"]) [\\"YES\\", \\"NO\\"] >>> sequence_operations([\\"Add 1\\", \\"Remove\\", \\"Query 1\\", \\"Stop\\"]) [\\"NO\\"] >>> sequence_operations([\\"Query 1\\", \\"Stop\\"]) [\\"NO\\"]","solution":"def sequence_operations(operations): sequence = [] results = [] for operation in operations: if operation.startswith(\\"Add\\"): _, x = operation.split() sequence.append(int(x)) elif operation.startswith(\\"Remove\\"): if sequence: sequence.pop() elif operation.startswith(\\"Query\\"): _, y = operation.split() results.append(\\"YES\\" if int(y) in sequence else \\"NO\\") elif operation == \\"Stop\\": break return results"},{"question":"def log_query_system(logs: List[str], queries: List[str]) -> List[str]: This function answers multiple substring queries on a given list of log strings. Args: logs (list of str): The list of log strings. queries (list of str): The list of substring queries. Returns: list of str: The result for each query. >>> logs = [\\"hello world\\", \\"the quick brown fox\\", \\"jumps over the lazy dog\\"] >>> queries = [\\"quick\\", \\"lazy\\"] >>> print(log_query_system(logs, queries)) [\\"2\\", \\"3\\"] >>> logs = [\\"hello\\", \\"world\\", \\"test\\"] >>> queries = [\\"abc\\", \\"def\\"] >>> print(log_query_system(logs, queries)) [\\"No Match\\", \\"No Match\\"]","solution":"def log_query_system(logs, queries): This function answers multiple substring queries on a given list of log strings. Args: logs (list of str): The list of log strings. queries (list of str): The list of substring queries. Returns: list of str: The result for each query. results = [] for query in queries: found = False for i, log in enumerate(logs): if query in log: results.append(str(i + 1)) found = True break if not found: results.append(\\"No Match\\") return results"},{"question":"def is_perfect_sequence(positions): Determines whether it is possible to rearrange the fish to form a perfect sequence. Args: positions (list): List of non-negative integers representing initial positions of fish. Returns: str: \\"YES\\" if it's possible to rearrange to form a perfect sequence, otherwise \\"NO\\". >>> is_perfect_sequence([1, 7, 5, 3]) == \\"YES\\" >>> is_perfect_sequence([2, 4, 8]) == \\"NO\\"","solution":"def is_perfect_sequence(positions): Determines whether it is possible to rearrange the fish to form a perfect sequence. Args: positions (list): List of non-negative integers representing initial positions of fish. Returns: str: \\"YES\\" if it's possible to rearrange to form a perfect sequence, otherwise \\"NO\\". positions.sort() n = len(positions) # Find the differences between consecutive elements differences = [positions[i+1] - positions[i] for i in range(n-1)] # Check if all differences are the same if all(diff == differences[0] for diff in differences): return \\"YES\\" else: return \\"NO\\""},{"question":"def max_length_to_remove_to_make_valid(s: str) -> int: Returns the maximum length of a substring that can be removed to make the provided string of parentheses a valid sequence of parentheses. >>> max_length_to_remove_to_make_valid(\\"()()()\\") == 0 >>> max_length_to_remove_to_make_valid(\\"))((())(\\") == 4 >>> max_length_to_remove_to_make_valid(\\")()(\\") == 2 >>> max_length_to_remove_to_make_valid(\\"((((((\\") == 6 >>> max_length_to_remove_to_make_valid(\\")))))\\") == 5 >>> max_length_to_remove_to_make_valid(\\"))))((((\\") == 8 >>> max_length_to_remove_to_make_valid(\\"(())\\") == 0 >>> max_length_to_remove_to_make_valid(\\"(\\") == 1 >>> max_length_to_remove_to_make_valid(\\")\\") == 1 >>> max_length_to_remove_to_make_valid(\\"((())))(())(\\") == 2","solution":"def max_length_to_remove_to_make_valid(s): Returns the maximum length of a substring that can be removed to make the provided string of parentheses a valid sequence of parentheses. left_count, right_count = 0, 0 n = len(s) # Step through the string and determine the counts of unbalanced left and right parentheses for char in s: if char == '(': left_count += 1 elif char == ')': if left_count > 0: left_count -= 1 else: right_count += 1 # Removed substring includes unbalanced left and right parentheses return left_count + right_count"},{"question":"def max_fusion_value(n: int, elements: List[Tuple[int, int]]) -> int: Determine the maximum value that can be achieved by fusing elements. :param n: Number of elements :param elements: A list of tuples where each tuple contains an identifier and its value :return: Maximum value achievable by fusing elements according to the rules >>> max_fusion_value(1, [(1, 100)]) 100 >>> max_fusion_value(5, [(1, 10), (2, 20), (3, 30), (4, 40), (5, 50)]) 150 >>> max_fusion_value(5, [(1, 10), (2, 20), (4, 30), (3, 40), (5, 50)]) 150 >>> max_fusion_value(3, [(1, 10), (3, 20), (5, 30)]) 30 >>> max_fusion_value(6, [(1, 10), (3, 20), (2, 30), (5, 40), (8, 50), (9, 60)]) 110","solution":"def max_fusion_value(n, elements): Determine the maximum value that can be achieved by fusing elements. :param n: Number of elements :param elements: A list of tuples where each tuple contains an identifier and its value :return: Maximum value achievable by fusing elements according to the rules # Sort elements based on their identifiers elements.sort(key=lambda x: x[0]) max_value = 0 current_value = elements[0][1] last_id = elements[0][0] for i in range(1, n): current_id, value = elements[i] if current_id == last_id + 1: current_value += value else: max_value = max(max_value, current_value) current_value = value last_id = current_id max_value = max(max_value, current_value) return max_value"},{"question":"def lexicographically_smallest_string(s: str, k: int) -> str: Returns the lexicographically smallest string that can be obtained by flipping at most k bits in the input binary string s. >>> lexicographically_smallest_string(\\"1101\\", 2) \\"0001\\" >>> lexicographically_smallest_string(\\"1010001\\", 1) \\"0010001\\" >>> lexicographically_smallest_string(\\"1101\\", 0) \\"1101\\" >>> lexicographically_smallest_string(\\"0000\\", 2) \\"0000\\" >>> lexicographically_smallest_string(\\"1111\\", 4) \\"0000\\" # Implementation here","solution":"def lexicographically_smallest_string(s, k): Returns the lexicographically smallest string that can be obtained by flipping at most k bits in the input binary string s. s = list(s) # Convert the string to a list for easier manipulation for i in range(len(s)): if k == 0: break if s[i] == '1': s[i] = '0' k -= 1 return ''.join(s)"},{"question":"def can_form_by_deleting_one_substring(s: str, t: str) -> str: Determine if \`t\` can be formed by deleting exactly one substring from \`s\`. >>> can_form_by_deleting_one_substring(\\"abcde\\", \\"acde\\") \\"YES\\" >>> can_form_by_deleting_one_substring(\\"abcde\\", \\"abde\\") \\"YES\\" >>> can_form_by_deleting_one_substring(\\"abcde\\", \\"abcdef\\") \\"NO\\"","solution":"def can_form_by_deleting_one_substring(s, t): Returns \\"YES\\" if string t can be formed by deleting exactly one substring from s. Otherwise, returns \\"NO\\". if len(t) + 1 != len(s): return \\"NO\\" for i in range(len(s)): if s[:i] + s[i+1:] == t: return \\"YES\\" return \\"NO\\""},{"question":"def min_repaints(n: int, c: int, colors: List[int]) -> int: Returns the minimum number of repaints required such that no two adjacent houses have the same color. >>> min_repaints(5, 3, [1, 1, 3, 3, 2]) 2 >>> min_repaints(5, 3, [1, 2, 3, 1, 2]) 0 >>> min_repaints(4, 3, [1, 1, 1, 1]) 2 >>> min_repaints(6, 2, [1, 2, 1, 2, 1, 2]) 0 >>> min_repaints(1, 1, [1]) 0 >>> min_repaints(6, 3, [1, 1, 2, 2, 3, 3]) 3","solution":"def min_repaints(n, c, colors): Returns the minimum number of repaints required such that no two adjacent houses have the same color. repaints = 0 for i in range(1, n): if colors[i] == colors[i - 1]: # Find a replacement color that is different from both the previous and the next (if applicable) house for color in range(1, c + 1): if color != colors[i - 1] and (i == n - 1 or color != colors[i + 1]): colors[i] = color repaints += 1 break return repaints"},{"question":"def min_direction_changes(n: int, soldiers: str) -> int: Returns the minimum number of soldiers that need to change their direction so that all soldiers face the same direction. >>> min_direction_changes(5, \\"FBBFB\\") 2 >>> min_direction_changes(3, \\"FFF\\") 0 >>> min_direction_changes(3, \\"BBB\\") 0 >>> min_direction_changes(6, \\"FBFBFB\\") 3 >>> min_direction_changes(1, \\"F\\") 0 >>> min_direction_changes(1, \\"B\\") 0 >>> min_direction_changes(4, \\"FFFB\\") 1 >>> min_direction_changes(4, \\"BBBF\\") 1","solution":"def min_direction_changes(n, soldiers): Returns the minimum number of soldiers that need to change their direction so that all soldiers face the same direction. Parameters: n (int): The number of soldiers soldiers (str): A string of length n with 'F' (forward) and 'B' (backward) indicating the direction each soldier is facing Returns: int: Minimum number of direction changes required to make all soldiers face the same way forward_count = soldiers.count('F') backward_count = n - forward_count # total - forward = backward # The minimum changes required will be the minimum of all facing forward or all facing backward return min(forward_count, backward_count) # Example usage # Example input: (5, \\"FBBFB\\") # Expected output: 2 print(min_direction_changes(5, \\"FBBFB\\"))"},{"question":"from typing import List def max_magical_pairs(n: int, d: int, h: List[int]) -> int: In a faraway land, there are n magical plants growing in a row. Each plant has a unique height denoted by an integer array h of size n. Magic is only present when the heights of two consecutive plants are co-prime. Two numbers are co-prime if their greatest common divisor (GCD) is 1. You need to transform this row of plants to maximize the magic. You are allowed to perform the following operation at most once on each plant: - Decrease the height of a plant by a positive integer no greater than d. Find the maximum number of magical pairs (consecutive co-prime plants) that can be obtained after applying the operations optimally. >>> max_magical_pairs(5, 2, [2, 4, 6, 8, 10]) 4 >>> max_magical_pairs(4, 1, [6, 9, 14, 15]) 3 pass","solution":"from math import gcd def max_magical_pairs(n, d, h): max_pairs = 0 # Helper function to check if two numbers are co-prime def are_coprime(a, b): return gcd(a, b) == 1 # Iterate over each plant to determine the max pairs for i in range(n - 1): if are_coprime(h[i], h[i + 1]): max_pairs += 1 else: # Try decreasing the current plant or the next plant coprime_found = False for dec in range(1, d + 1): if are_coprime(h[i] - dec, h[i + 1]): coprime_found = True break if are_coprime(h[i], h[i + 1] - dec): coprime_found = True break if coprime_found: max_pairs += 1 return max_pairs"},{"question":"def max_contiguous_sum(n: int, sweetness_levels: List[int]) -> int: Returns the maximum possible sum of contiguous candies Polycarp can obtain. >>> max_contiguous_sum(5, [-1, 2, 3, -2, 5]) 8 >>> max_contiguous_sum(4, [-1, -2, -3, -4]) -1 >>> max_contiguous_sum(1, [5]) 5 >>> max_contiguous_sum(1, [-5]) -5 >>> max_contiguous_sum(5, [1, 2, 3, 4, 5]) 15 >>> max_contiguous_sum(5, [-1, -2, -3, -4, -5]) -1 >>> max_contiguous_sum(7, [2, -1, 2, 3, 4, -5, 2]) 10 >>> max_contiguous_sum(6, [-1, 3, 4, -2, -1, 6]) 10 >>> max_contiguous_sum(10, [1, -1, 1, -1, 1, -1, 1, -1, 1, -1]) 1 >>> max_contiguous_sum(10, [-1, 1, -1, 1, -1, 1, -1, 1, -1, 1]) 1","solution":"def max_contiguous_sum(n, sweetness_levels): Returns the maximum possible sum of contiguous candies Polycarp can obtain. # This problem is a variant of the maximum subarray sum problem. # We can solve it using Kadane's Algorithm. # Initialize the maximum sum and the current sum max_sum = sweetness_levels[0] current_sum = sweetness_levels[0] for i in range(1, n): current_sum = max(sweetness_levels[i], current_sum + sweetness_levels[i]) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def max_gold(n: int, gold: List[int]) -> int: Returns the maximum sum of gold collected from any contiguous subarray. Parameters: n (int): the number of villages gold (List[int]): the amount of gold in each village Returns: int: the maximum amount of gold that can be collected in one operation Example: >>> max_gold(5, [1, -2, 3, 4, -1]) 7","solution":"def max_gold(n, gold): Returns the maximum sum of gold collected from any contiguous subarray. max_current = max_global = gold[0] for i in range(1, n): max_current = max(gold[i], max_current + gold[i]) if max_current > max_global: max_global = max_current return max_global"},{"question":"def min_removals_to_uniform_binary_string(n: int, binary_string: str) -> int: Returns the minimum number of characters to be removed to make the binary string consist of only '0's or only '1's. Parameters: n (int): Length of the binary string (1  n  2 * 10^5). binary_string (str): The binary string consisting of '0's and '1's. Returns: int: Minimum number of characters to be removed. # Test cases from solution import min_removals_to_uniform_binary_string def test_case_1(): assert min_removals_to_uniform_binary_string(5, '11010') == 2 def test_already_uniform(): assert min_removals_to_uniform_binary_string(4, '1111') == 0 assert min_removals_to_uniform_binary_string(3, '000') == 0 def test_case_completely_different(): assert min_removals_to_uniform_binary_string(2, '10') == 1 def test_large_size(): assert min_removals_to_uniform_binary_string(6, '101010') == 3 assert min_removals_to_uniform_binary_string(7, '1110000') == 3 def test_alternating_characters(): assert min_removals_to_uniform_binary_string(6, '010101') == 3 assert min_removals_to_uniform_binary_string(4, '1010') == 2","solution":"def min_removals_to_uniform_binary_string(n, binary_string): Returns the minimum number of characters to be removed to make the binary string consist of only '0's or only '1's. Parameters: n (int): Length of the binary string (1  n  2 * 10^5). binary_string (str): The binary string consisting of '0's and '1's. Returns: int: Minimum number of characters to be removed. count_0 = binary_string.count('0') count_1 = n - count_0 # Since the string consists only of '0's and '1's, count_1 can be derived # Either remove all '0's or all '1's, take the minimum of these two options return min(count_0, count_1)"},{"question":"def maximum_valid_matchups(n: int, m: int, t: int, interests: List[Tuple[int, int]]) -> int: Returns the maximum number of valid match-ups in a single round. Args: n: int, number of participants m: int, number of categories t: int, number of interest pairs interests: list of tuple[pi, ci], each tuple represents the participant pi's interest in category ci Returns: int, maximum number of valid match-ups pass # Example test cases: def test_example_case(): n = 5 m = 3 t = 6 interests = [(1, 1), (2, 1), (3, 2), (4, 2), (5, 3), (1, 3)] assert maximum_valid_matchups(n, m, t, interests) == 2 def test_no_overlap_case(): n = 4 m = 4 t = 4 interests = [(1, 1), (2, 2), (3, 3), (4, 4)] assert maximum_valid_matchups(n, m, t, interests) == 2 def test_all_overlap_case(): n = 4 m = 1 t = 4 interests = [(1, 1), (2, 1), (3, 1), (4, 1)] assert maximum_valid_matchups(n, m, t, interests) == 0 def test_large_case(): n = 10 m = 10 t = 15 interests = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6), (7, 7), (8, 8), (9, 9), (10, 10), (1, 2), (3, 4), (5, 6), (7, 8), (9, 10)] assert maximum_valid_matchups(n, m, t, interests) == 5","solution":"from collections import defaultdict def maximum_valid_matchups(n, m, t, interests): Returns the maximum number of valid match-ups in a single round. Args: n: int, number of participants m: int, number of categories t: int, number of interest pairs interests: list of tuple[pi, ci], each tuple represents the participant pi's interest in category ci Returns: int, maximum number of valid match-ups category_count = defaultdict(int) participant_interests = defaultdict(list) for pi, ci in interests: participant_interests[pi].append(ci) for cat in category_count: category_count[cat] = len(participant_interests[pi]) overlap_graph = defaultdict(set) for i in range(1, n + 1): for j in range(i + 1, n + 1): shared_cat = set(participant_interests[i]) & set(participant_interests[j]) if not shared_cat: overlap_graph[i].add(j) overlap_graph[j].add(i) max_matchups = 0 visited = set() for node in overlap_graph: if node not in visited: current_size = 1 stack = [node] visited.add(node) while stack: participant = stack.pop() for neighbor in overlap_graph[participant]: if neighbor not in visited: visited.add(neighbor) stack.append(neighbor) current_size += 1 max_matchups += current_size // 2 return max_matchups"},{"question":"def max_sweetness_min_bitterness(syrups): Returns the maximum sweetness and the corresponding minimum bitterness of the combination. :param syrups: List of tuples containing sweetness and bitterness levels of syrups :returns: Tuple of two integers, maximum sweetness and minimum bitterness >>> max_sweetness_min_bitterness([(3, 2), (5, 6), (9, 1), (4, 3), (8, 7)]) (9, 1)","solution":"def max_sweetness_min_bitterness(syrups): Returns the maximum sweetness and the corresponding minimum bitterness of the combination. :param syrups: List of tuples containing sweetness and bitterness levels of syrups :returns: Tuple of two integers, maximum sweetness and minimum bitterness max_sweet = 0 min_bitter = float('inf') for syrup in syrups: s, b = syrup if s > max_sweet or (s == max_sweet and b < min_bitter): max_sweet = s min_bitter = b return (max_sweet, min_bitter) # Example usage n = 5 syrups = [ (3, 2), (5, 6), (9, 1), (4, 3), (8, 7) ] print(max_sweetness_min_bitterness(syrups)) # Output: (9, 1)"},{"question":"class SmartLight: def __init__(self, initial_state: List[int]): Initialize the SmartLight system with a given initial state. Args: initial_state (List[int]): The initial state of the lights. def toggle(self, l: int, r: int): Toggle the lights in the range from l to r. Args: l (int): The starting index (1-based). r (int): The ending index (1-based). def turn_on(self, x: int): Turn on the light at position x if it is off. Args: x (int): The position of the light (1-based). def turn_off(self, x: int): Turn off the light at position x if it is on. Args: x (int): The position of the light (1-based). def count_on(self) -> int: Return the count of lights that are currently on. Returns: int: The number of lights that are on. # Unit tests to validate the solution def test_initial_state(): sm = SmartLight([0, 1, 0, 0, 1]) assert sm.lights == [0, 1, 0, 0, 1] def test_toggle(): sm = SmartLight([0, 1, 0, 0, 1]) sm.toggle(1, 3) assert sm.lights == [1, 0, 1, 0, 1] def test_turn_on(): sm = SmartLight([0, 1, 0, 0, 1]) sm.turn_on(3) assert sm.lights == [0, 1, 1, 0, 1] def test_turn_off(): sm = SmartLight([0, 1, 0, 0, 1]) sm.turn_off(2) assert sm.lights == [0, 0, 0, 0, 1] def test_count_on(): sm = SmartLight([0, 1, 0, 0, 1]) assert sm.count_on() == 2 sm.toggle(1, 3) assert sm.count_on() == 3 sm.turn_off(2) assert sm.count_on() == 3 sm.turn_on(4) assert sm.count_on() == 4","solution":"class SmartLight: def __init__(self, initial_state): self.lights = initial_state def toggle(self, l, r): # Toggle the lights in the range [l-1, r-1] (converting from 1-based to 0-based index) for i in range(l-1, r): self.lights[i] = 1 - self.lights[i] def turn_on(self, x): # Turn on the light at position x-1 (converting from 1-based to 0-based index) self.lights[x-1] = 1 def turn_off(self, x): # Turn off the light at position x-1 (converting from 1-based to 0-based index) self.lights[x-1] = 0 def count_on(self): # Return the count of lights that are currently on return sum(self.lights)"},{"question":"def sort_people_by_height(people): Sorts people by height in descending order. If heights are the same, maintain the original relative order. Args: people (list of tuple): Each tuple contains a name (str) and a height (int). Returns: list: A list of names sorted by height in descending order. pass # Example usage: # people = [(\\"Alice\\", 170), (\\"Bob\\", 180), (\\"Charlie\\", 170), (\\"David\\", 175)] # print(sort_people_by_height(people)) # Output: [\\"Bob\\", \\"David\\", \\"Alice\\", \\"Charlie\\"]","solution":"def sort_people_by_height(people): Sorts people by height in descending order. If heights are the same, maintain the original relative order. Args: people (list of tuple): Each tuple contains a name (str) and a height (int). Returns: list: A list of names sorted by height in descending order. return [name for name, height in sorted(people, key=lambda x: -x[1])]"},{"question":"def form_teams(n: int, player_data: List[Tuple[str, int]]) -> List[Tuple[str, str]]: Forms teams by pairing players such that the absolute difference in their strengths is minimized. :param n: Integer representing the number of players. :param player_data: List of tuples containing player names and their strengths. :return: List of tuples representing the pairs of players. >>> form_teams(6, [(\\"Alice\\", 100), (\\"Bob\\", 200), (\\"Charlie\\", 150), (\\"Denise\\", 300), (\\"Eve\\", 50), (\\"Frank\\", 250)]) [(\\"Eve\\", \\"Alice\\"), (\\"Charlie\\", \\"Bob\\"), (\\"Frank\\", \\"Denise\\")] >>> form_teams(4, [(\\"Alice\\", 100), (\\"Bob\\", 100), (\\"Charlie\\", 100), (\\"Denise\\", 100)]) [(\\"Alice\\", \\"Bob\\"), (\\"Charlie\\", \\"Denise\\")] >>> form_teams(4, [(\\"Alice\\", 100), (\\"Bob\\", 300), (\\"Charlie\\", 200), (\\"Denise\\", 400)]) [(\\"Alice\\", \\"Charlie\\"), (\\"Bob\\", \\"Denise\\")] >>> form_teams(4, [(\\"Alice\\", 400), (\\"Bob\\", 300), (\\"Charlie\\", 200), (\\"Denise\\", 100)]) [(\\"Denise\\", \\"Charlie\\"), (\\"Bob\\", \\"Alice\\")] >>> form_teams(4, [(\\"John\\", 123456789), (\\"Jane\\", 987654321), (\\"Jim\\", 1000000000), (\\"Jill\\", 543210123)]) [(\\"John\\", \\"Jill\\"), (\\"Jane\\", \\"Jim\\")]","solution":"def form_teams(n, player_data): Forms teams by pairing players such that the absolute difference in their strengths is minimized. :param n: Integer representing the number of players. :param player_data: List of tuples containing player names and their strengths. :return: List of tuples representing the pairs of players. # Sort the players based on their strengths sorted_players = sorted(player_data, key=lambda x: x[1]) # Initialize the list for results result_teams = [] # Form teams by pairing adjacent players for i in range(0, n, 2): player1 = sorted_players[i] player2 = sorted_players[i + 1] result_teams.append((player1[0], player2[0])) return result_teams # Example to run if __name__ == \\"__main__\\": n = 6 player_data = [(\\"Alice\\", 100), (\\"Bob\\", 200), (\\"Charlie\\", 150), (\\"Denise\\", 300), (\\"Eve\\", 50), (\\"Frank\\", 250)] result = form_teams(n, player_data) for team in result: print(f\\"{team[0]} {team[1]}\\")"},{"question":"def circular_shift(n: int, m: int, sequence: List[int], queries: List[int]) -> List[List[int]]: Perform the given number of circular shifts for each query. Parameters: n (int): Number of elements in the sequence. m (int): Number of queries. sequence (list of int): The initial sequence of numbers. queries (list of int): The number of circular shifts for each query. Returns: list of list of int: The sequence after each query's circular shifts. >>> circular_shift(4, 3, [1, 2, 3, 4], [1, 2, 3]) [[4, 1, 2, 3], [3, 4, 1, 2], [2, 3, 4, 1]] >>> circular_shift(5, 2, [5, 6, 7, 8, 9], [4, 1]) [[6, 7, 8, 9, 5], [9, 5, 6, 7, 8]]","solution":"def circular_shift(n, m, sequence, queries): Perform the given number of circular shifts for each query. Parameters: n (int): Number of elements in the sequence. m (int): Number of queries. sequence (list of int): The initial sequence of numbers. queries (list of int): The number of circular shifts for each query. Returns: list of list of int: The sequence after each query's circular shifts. results = [] for k in queries: k = k % n # To handle cases where k > n results.append(sequence[-k:] + sequence[:-k]) return results"},{"question":"def longest_palindromic_subsequence(n: int, pearls: List[int]) -> int: Given a number of pearls and their beauty values, find the length of the longest palindromic subsequence that can be formed. Parameters: n (int): The number of pearls. pearls (List[int]): The beauty values of the pearls. Returns: int: The length of the longest palindromic subsequence. >>> longest_palindromic_subsequence(7, [1, 2, 3, 4, 3, 2, 1]) 7 >>> longest_palindromic_subsequence(6, [1, 3, 5, 1, 5, 3]) 5 >>>","solution":"def longest_palindromic_subsequence(n, pearls): # Create a 2D array to store the length of the longest palindromic subsequence # dp[i][j] will store the length of the longest palindromic subsequence in pearls[i..j] dp = [[0]*n for _ in range(n)] # Strings of length 1 are palindromes of length 1 for i in range(n): dp[i][i] = 1 # Build the table # The bottom-up manner for cl in range(2, n+1): for i in range(n-cl+1): j = i + cl - 1 if pearls[i] == pearls[j] and cl == 2: dp[i][j] = 2 elif pearls[i] == pearls[j]: dp[i][j] = dp[i+1][j-1] + 2 else: dp[i][j] = max(dp[i][j-1], dp[i+1][j]) # Length of longest palindromic subseq return dp[0][n-1]"},{"question":"def min_games_to_win_tournament(skills): Given a list of skill levels of students, determine the minimum number of games each student needs to play to determine the ultimate winner starting from that student. >>> min_games_to_win_tournament([1, 2, 3, 4, 5]) [4, 3, 2, 1, 0] >>> min_games_to_win_tournament([5, 4, 3, 2, 1]) [4, 3, 2, 1, 0] >>> min_games_to_win_tournament([3, 3, 3, 3]) [3, 2, 1, 0] >>> min_games_to_win_tournament([3, 1, 4, 2, 5]) [4, 3, 2, 1, 0] >>> min_games_to_win_tournament([1, 2]) [1, 0]","solution":"def min_games_to_win_tournament(skills): Given a list of skill levels of students, determine the minimum number of games each student needs to play to determine the ultimate winner starting from that student. n = len(skills) # Since each student can only play against their adjacent student, # in the worst case the strongest student will be the ultimate winner. results = [n - i - 1 for i in range(n)] return results"},{"question":"def group_books_by_genre(n: int, books: List[Any]) -> List[str]: Group the books by their genres and print the genres along with the books belonging to them in a sorted order. Args: n (int): The number of books books (List[Any]): List of book details (id, title, genre) Returns: List[str]: Ordered list of books grouped by genres Example: >>> group_books_by_genre(4, [100, \\"The Great Gatsby\\", 2, 200, \\"Moby Dick\\", 1, 150, \\"Crime and Punishment\\", 2, 175, \\"War and Peace\\", 1]) [\\"1\\", \\"200 Moby Dick\\", \\"175 War and Peace\\", \\"2\\", \\"100 The Great Gatsby\\", \\"150 Crime and Punishment\\"]","solution":"def group_books_by_genre(n, books): genres = {i: [] for i in range(1, 6)} for i in range(n): book_id = books[i*3] title = books[i*3 + 1] genre = int(books[i*3 + 2]) genres[genre].append((int(book_id), title)) output = [] for genre in range(1, 6): if genres[genre]: output.append(str(genre)) books_sorted = sorted(genres[genre], key=lambda x: x[0]) for book in books_sorted: output.append(f\\"{book[0]} {book[1]}\\") return output"},{"question":"def longest_subsequence_with_diff(arr: List[int], k: int) -> int: Given an array of n integers, find the length of the longest subsequence such that the difference between the maximum and minimum element in the subsequence does not exceed k. >>> longest_subsequence_with_diff([1, 5, 2, 7, 2, 4, 6], 3) == 4 >>> longest_subsequence_with_diff([1, 3, 3, 0, 5], 2) == 3 >>> longest_subsequence_with_diff([10], 5) == 1 >>> longest_subsequence_with_diff([2, 2, 2, 2], 0) == 4 >>> longest_subsequence_with_diff([1, 5, 2, 7, 2, 4, 6], 10) == 7 >>> longest_subsequence_with_diff([1, 2, 3, 4, 5], 0) == 1","solution":"def longest_subsequence_with_diff(arr, k): Returns the length of the longest subsequence such that the difference between the maximum and minimum element in the subsequence does not exceed k. arr.sort() n = len(arr) left = 0 max_len = 0 for right in range(n): while arr[right] - arr[left] > k: left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"def tallest_stack(n: int, heights: List[int]) -> int: Determines the height of the tallest stack of boxes that can be formed. Args: n : int : the number of boxes heights : list of int : the heights of the boxes Returns: int : height of the tallest stack that can be formed >>> tallest_stack(1, [5]) 1 >>> tallest_stack(5, [5, 4, 3, 2, 1]) 5 >>> tallest_stack(5, [1, 2, 3, 4, 5]) 1 >>> tallest_stack(5, [4, 5, 2, 3, 1]) 3 >>> tallest_stack(5, [3, 3, 3, 3, 3]) 5 >>> tallest_stack(0, []) 0 >>> tallest_stack(7, [5, 1, 5, 1, 5, 1, 5]) 4","solution":"def tallest_stack(n, heights): Determines the height of the tallest stack of boxes that can be formed. Args: n : int : the number of boxes heights : list of int : the heights of the boxes Returns: int : height of the tallest stack that can be formed if n == 0: return 0 # Initialize an array to store the maximum height at each position dp = [1] * n # Each box alone is a stack of height 1 # Compute the optimal stack using a dynamic programming approach for i in range(1, n): for j in range(i): if heights[j] >= heights[i]: dp[i] = max(dp[i], dp[j] + 1) # Return the maximum value from the dp array which represents the tallest stack return max(dp)"},{"question":"def min_operations_to_all_a(t: int, strings: list) -> list: Find the minimum number of operations required to transform each string into a string where all characters are 'a'. >>> min_operations_to_all_a(1, [\\"bcd\\"]) [1] >>> min_operations_to_all_a(1, [\\"abac\\"]) [2] >>> min_operations_to_all_a(1, [\\"zzz\\"]) [1]","solution":"def min_operations_to_all_a(t, strings): results = [] for s in strings: count = 0 n = len(s) i = 0 while i < n: if s[i] != 'a': count += 1 while i < n and s[i] != 'a': i += 1 i += 1 results.append(count) return results # Read number of test cases (assuming file input or hardcoded input) # Below is a sample input format for the function t = 3 strings = [\\"bcd\\", \\"abac\\", \\"zzz\\"] print(min_operations_to_all_a(t, strings)) # Output [1, 2, 1]"},{"question":"def min_abs_difference(weights): Given a list of weights, return the minimum possible absolute difference between the sums of two groups. def process_input(input_str): Process the input string and return the list of weights. # Example test cases test_cases = [ (\\"4n2 7 4 1\\", 0), (\\"2n1 2\\", 1), (\\"4n1 2 3 4\\", 0), (\\"3n10 20 15\\", 5), (\\"1n5\\", 5), (\\"3n1000 2000 3000\\", 0), (\\"5n1 3 5 9 11\\", 1), (\\"5n4 4 4 4 4\\", 4), ]","solution":"def min_abs_difference(weights): Given a list of weights, returns the minimum possible absolute difference between the sums of two groups. total_sum = sum(weights) n = len(weights) # Finding subsets up to sum // 2 to minimize difference subset_sums = [False] * (total_sum // 2 + 1) subset_sums[0] = True # Zero is always reachable for weight in weights: for j in range(total_sum // 2, weight - 1, -1): if subset_sums[j - weight]: subset_sums[j] = True for i in range(total_sum // 2, -1, -1): if subset_sums[i]: return total_sum - 2 * i return total_sum # Function to process input def process_input(input_str): input_lines = input_str.strip().split() n = int(input_lines[0]) weights = list(map(int, input_lines[1:1+n])) return weights"},{"question":"def process_logs(n: int, logs: List[str]) -> List[int]: This function processes log entries to update and query tree measurements (height and diameter) in a forest. Multiple logs can contain commands to either update the height or diameter of a tree, or query the current height or diameter of a tree. Initially, the height and diameter of all trees are set to zero. The first line of the input contains a single integer n (1  n  100,000)  the number of log entries. Each of the following n lines contains a log entry in one of the formats described below: UpdateHeight tree_id new_height: updates the height of the tree with the given tree_id to new_height. UpdateDiameter tree_id new_diameter: updates the diameter of the tree with the given tree_id to new_diameter. QueryHeight tree_id: returns the current height of the tree with the given tree_id. QueryDiameter tree_id: returns the current diameter of the tree with the given tree_id. Args: n (int): The number of log entries. logs (List[str]): The list of log entries. Returns: List[int]: Results of all the queries. Example Usage: >>> process_logs(7, [\\"UpdateHeight 1 15\\", \\"UpdateDiameter 1 3\\", \\"QueryHeight 1\\", \\"QueryDiameter 1\\", \\"UpdateHeight 2 25\\", \\"QueryHeight 2\\", \\"QueryDiameter 2\\"]) [15, 3, 25, 0] from typing import List def test_basic_operations(): logs = [ \\"UpdateHeight 1 15\\", \\"UpdateDiameter 1 3\\", \\"QueryHeight 1\\", \\"QueryDiameter 1\\", \\"UpdateHeight 2 25\\", \\"QueryHeight 2\\", \\"QueryDiameter 2\\" ] assert process_logs(7, logs) == [15, 3, 25, 0] def test_only_updates(): logs = [ \\"UpdateHeight 1 10\\", \\"UpdateDiameter 1 5\\", \\"UpdateHeight 2 20\\", \\"UpdateDiameter 2 10\\" ] assert process_logs(4, logs) == [] def test_mixed_updates_and_queries(): logs = [ \\"UpdateHeight 3 30\\", \\"UpdateDiameter 3 12\\", \\"UpdateHeight 1 5\\", \\"QueryHeight 3\\", \\"QueryDiameter 3\\", \\"QueryHeight 1\\", \\"QueryDiameter 1\\" ] assert process_logs(7, logs) == [30, 12, 5, 0] def test_initial_values(): logs = [ \\"QueryHeight 1\\", \\"QueryDiameter 1\\", \\"QueryHeight 2\\", \\"QueryDiameter 2\\" ] assert process_logs(4, logs) == [0, 0, 0, 0] def test_multiple_queries_same_tree(): logs = [ \\"UpdateHeight 1 10\\", \\"QueryHeight 1\\", \\"QueryHeight 1\\", \\"UpdateHeight 1 20\\", \\"QueryHeight 1\\" ] assert process_logs(5, logs) == [10, 10, 20]","solution":"def process_logs(n, logs): # Initialize tree properties dictionaries height_dict = {} diameter_dict = {} result = [] for log in logs: components = log.split() command = components[0] tree_id = int(components[1]) if command == \\"UpdateHeight\\": new_height = int(components[2]) height_dict[tree_id] = new_height elif command == \\"UpdateDiameter\\": new_diameter = int(components[2]) diameter_dict[tree_id] = new_diameter elif command == \\"QueryHeight\\": # Query height height = height_dict.get(tree_id, 0) result.append(height) elif command == \\"QueryDiameter\\": # Query diameter diameter = diameter_dict.get(tree_id, 0) result.append(diameter) return result"},{"question":"from typing import List def rearrange_string(s: str) -> str: Rearranges the input string such that no two adjacent characters are the same. Returns the rearranged string, or \\"Not Possible\\" if no valid rearrangement exists. >>> rearrange_string(\\"aaabc\\") in [\\"abaca\\", \\"acaba\\", \\"bacba\\", \\"bacab\\"] True >>> rearrange_string(\\"aaabb\\") == \\"ababa\\" True >>> rearrange_string(\\"aa\\") == \\"Not Possible\\" True >>> rearrange_string(\\"a\\") == \\"a\\" True >>> rearrange_string(\\"ab\\") == \\"ab\\" True","solution":"from heapq import heappop, heappush from collections import Counter def rearrange_string(s): Rearranges the input string such that no two adjacent characters are the same. Returns the rearranged string, or \\"Not Possible\\" if no valid rearrangement exists. count = Counter(s) max_heap = [] for char, cnt in count.items(): heappush(max_heap, (-cnt, char)) prev_char, prev_cnt = None, 0 result = [] while max_heap: cnt, char = heappop(max_heap) result.append(char) if prev_char and prev_cnt < 0: heappush(max_heap, (prev_cnt, prev_char)) prev_char, prev_cnt = char, cnt + 1 # since cnt is negative rearranged = ''.join(result) if len(rearranged) != len(s): return \\"Not Possible\\" return rearranged"},{"question":"def min_removals_to_forest(n: int, m: int, edges: List[Tuple[int, int]]) -> int: Determine the minimum number of nodes to remove to make the graph a forest. >>> min_removals_to_forest(6, 6, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (3, 6)]) 1 >>> min_removals_to_forest(5, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (1, 5)]) 1 >>> min_removals_to_forest(4, 0, []) 0 >>> min_removals_to_forest(3, 3, [(1, 2), (2, 3), (3, 1)]) 1 >>> min_removals_to_forest(5, 4, [(1, 2), (1, 3), (4, 5), (5, 4)]) 1 >>> min_removals_to_forest(4, 3, [(1, 2), (2, 3), (3, 4)]) 0 >>> min_removals_to_forest(5, 2, [(1, 3), (4, 5)]) 0 pass","solution":"def min_removals_to_forest(n, m, edges): Determine the minimum number of nodes to remove to make the graph a forest. from collections import defaultdict # Helper function to perform DFS and detect cycles def has_cycle(v, visited, parent): visited[v] = True for neighbor in graph[v]: if not visited[neighbor]: if has_cycle(neighbor, visited, v): return True elif parent != neighbor: return True return False # Creating the adjacency list of the graph graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = [False] * (n + 1) cycles_count = 0 # Iterate over all nodes to handle disconnected components for node in range(1, n + 1): if not visited[node]: # If we find a cycle, increment the cycle count if has_cycle(node, visited, -1): cycles_count += 1 return cycles_count"},{"question":"from typing import List def shortest_path(grid: List[str], n: int, m: int) -> int: Find the shortest path from the top-left corner (1, 1) to the bottom-right corner (n, m) in a grid with blocked cells. The function should return the minimum number of steps required to get from the top-left corner to the bottom-right corner or \\"Impossible\\" if it is not possible. Parameters: grid (List[str]): A list of strings representing the grid. n (int): Number of rows in the grid. m (int): Number of columns in the grid. Returns: int: The minimum number of steps required to reach the destination, or \\"Impossible\\" if it cannot be reached. Example: >>> grid = [ >>> \\".....\\", >>> \\".#.\\", >>> \\"..#..\\", >>> \\".#.\\", >>> \\".....\\" >>> ] >>> shortest_path(grid, 5, 5) 8 >>> grid = [ >>> \\".\\", >>> \\"#\\", >>> \\".\\" >>> ] >>> shortest_path(grid, 3, 3) \\"Impossible\\"","solution":"from collections import deque def shortest_path(grid, n, m): Find the shortest path from the top-left corner (1, 1) to the bottom-right corner (n, m) in a grid with blocked cells. grid: List of strings representing the grid. n: Number of rows in the grid. m: Number of columns in the grid. if grid[0][0] == '#' or grid[n-1][m-1] == '#': return \\"Impossible\\" directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] visited = [[False] * m for _ in range(n)] queue = deque([(0, 0, 0)]) # (row, column, steps) visited[0][0] = True while queue: x, y, steps = queue.popleft() if x == n - 1 and y == m - 1: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and grid[nx][ny] == '.': visited[nx][ny] = True queue.append((nx, ny, steps + 1)) return \\"Impossible\\""},{"question":"from typing import List def min_swaps_to_even_sums(matrix: List[List[int]]) -> int: Determine the minimum number of swaps needed between the elements in the matrix such that the sum of every row and every column is even. >>> min_swaps_to_even_sums([ ... [1, 0, 1, 0], ... [1, 1, 0, 1], ... [0, 1, 0, 0] ... ]) == 2 >>> min_swaps_to_even_sums([ ... [0, 0, 0, 0], ... [0, 0, 0, 0], ... [0, 0, 0, 0] ... ]) == 0 >>> min_swaps_to_even_sums([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) == -1 >>> min_swaps_to_even_sums([ ... [1, 1], ... [1, 1] ... ]) == 0 >>> min_swaps_to_even_sums([[0]]) == 0 >>> min_swaps_to_even_sums([[1]]) == -1","solution":"def min_swaps_to_even_sums(matrix): n = len(matrix) m = len(matrix[0]) row_sums = [sum(row) for row in matrix] col_sums = [sum(matrix[i][j] for i in range(n)) for j in range(m)] odd_rows = sum(1 for r in row_sums if r % 2 != 0) odd_cols = sum(1 for c in col_sums if c % 2 != 0) # For the sums to be even, number of odd rows and odd columns must both be even if (odd_rows % 2 != 0) or (odd_cols % 2 != 0): return -1 # The minimum number of swaps needed to correct all odd rows and columns return (odd_rows + odd_cols) // 2"},{"question":"def longest_unique_subsegment_length(n: int, a: List[int]) -> int: Returns the length of the longest subsegment containing only distinct elements. :param n: int - the number of elements in the array :param a: list of int - the elements of the array :return: int - the length of the longest subsegment with distinct elements >>> longest_unique_subsegment_length(5, [1, 2, 3, 2, 1]) 3 >>> longest_unique_subsegment_length(1, [1]) 1 >>> longest_unique_subsegment_length(5, [1, 2, 3, 4, 5]) 5 >>> longest_unique_subsegment_length(5, [1, 1, 1, 1, 1]) 1 >>> longest_unique_subsegment_length(5, [1, 1000000000, 1, 1000000000, 1]) 2 >>> longest_unique_subsegment_length(200000, [i % 1000 for i in range(200000)]) 1000 >>> longest_unique_subsegment_length(0, []) 0 >>> longest_unique_subsegment_length(5, [1, 1, 2, 3, 1]) 3 >>> longest_unique_subsegment_length(5, [1, 1, 1, 2, 3]) 3","solution":"def longest_unique_subsegment_length(n, a): Returns the length of the longest subsegment containing only distinct elements. :param n: int - the number of elements in the array :param a: list of int - the elements of the array :return: int - the length of the longest subsegment with distinct elements if n == 0: return 0 unique_elements = set() left = 0 max_length = 0 for right in range(n): while a[right] in unique_elements: unique_elements.remove(a[left]) left += 1 unique_elements.add(a[right]) max_length = max(max_length, right - left + 1) return max_length"},{"question":"from typing import List, Tuple def is_non_decreasing_subarray(a: List[int], x: int, y: int) -> str: Check if the subarray a[x..y] is non-decreasing. x and y are 1-based indexes. >>> is_non_decreasing_subarray([3, 4, 5, 5, 6, 7, 8], 1, 4) == \\"YES\\" >>> is_non_decreasing_subarray([3, 4, 5, 5, 6, 7, 8], 3, 6) == \\"YES\\" >>> is_non_decreasing_subarray([3, 4, 5, 5, 6, 7, 8], 2, 5) == \\"YES\\" >>> is_non_decreasing_subarray([5, 4, 3, 2, 1], 1, 3) == \\"NO\\" >>> is_non_decreasing_subarray([1, 2, 3, 4, 5], 1, 5) == \\"YES\\" >>> is_non_decreasing_subarray([1], 1, 1) == \\"YES\\" pass def process_queries(n: int, q: int, a: List[int], queries: List[Tuple[int, int]]) -> List[str]: Process a list of queries for non-decreasing subarrays. n: length of the array q: number of queries a: list of integers representing the array queries: list of tuples, each containing indices (x, y) >>> process_queries(7, 3, [3, 4, 5, 5, 6, 7, 8], [(1, 4), (3, 6), (2, 5)]) == [\\"YES\\", \\"YES\\", \\"YES\\"] >>> process_queries(5, 2, [5, 4, 3, 2, 1], [(1, 3), (2, 5)]) == [\\"NO\\", \\"NO\\"] >>> process_queries(5, 2, [1, 2, 3, 4, 5], [(1, 2), (1, 5)]) == [\\"YES\\", \\"YES\\"] >>> process_queries(1, 1, [1], [(1, 1)]) == [\\"YES\\"] pass","solution":"def is_non_decreasing_subarray(a, x, y): Check if the subarray a[x..y] is non-decreasing. x and y are 1-based indexes. for i in range(x-1, y-1): if a[i] > a[i+1]: return \\"NO\\" return \\"YES\\" def process_queries(n, q, a, queries): Process a list of queries for non-decreasing subarrays. n: length of the array q: number of queries a: list of integers representing the array queries: list of tuples, each containing indices (x, y) results = [] for x, y in queries: results.append(is_non_decreasing_subarray(a, x, y)) return results"},{"question":"def max_practice_sum(n, a, b): Calculate the maximum possible sum Kevin can gather starting from any index. The function takes: - n: an integer representing the number of elements in the arrays - a: a list of integers of length n representing the elements of array a - b: a list of integers of length n representing the elements of array b It returns an integer which is the maximum sum Kevin can gather. Test cases: >>> max_practice_sum(5, [3, 2, 5, 1, 7], [1, 1, 3, 1, 2]) 10 >>> max_practice_sum(3, [1, 2, 3], [1, 1, 1]) 6 >>> max_practice_sum(1, [1], [1]) 1 >>> max_practice_sum(2, [1, 10], [2, 1]) 10 >>> max_practice_sum(4, [8, 7, 3, 5], [1, 1, 1, 1]) 23 >>> max_practice_sum(4, [8, 6, 7, 5], [4, 4, 4, 1]) 8","solution":"def max_practice_sum(n, a, b): max_sum = 0 def get_sum(start_index): visited = set() current_sum = 0 index = start_index while index < n and index not in visited: visited.add(index) current_sum += a[index] index += b[index] return current_sum for i in range(n): max_sum = max(max_sum, get_sum(i)) return max_sum"},{"question":"from typing import List def fibonacci_flower(test_cases: List[int]) -> List[int]: Calculate the number of petals the Fibonacci Flower will have after a given number of days. >>> fibonacci_flower([0]) == [0] >>> fibonacci_flower([1]) == [1] >>> fibonacci_flower([5]) == [5]","solution":"def fibonacci(n): fib_sequence = [0, 1] for i in range(2, n + 1): fib_sequence.append(fib_sequence[-1] + fib_sequence[-2]) return fib_sequence[n] def fibonacci_flower(test_cases): results = [] for days in test_cases: results.append(fibonacci(days)) return results"},{"question":"def find_clusters(n: int, m: int, emails: List[Tuple[int, int]]) -> int: Identifies and counts the number of communication clusters given a list of email communications. Args: n (int): The number of employees in the company. m (int): The number of emails sent. emails (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers representing an email sent from one employee to another. Returns: int: The number of communication clusters in the company. Examples: >>> find_clusters(5, 4, [(1, 2), (2, 3), (4, 5), (3, 1)]) 2 >>> find_clusters(1, 0, []) 1 >>> find_clusters(3, 0, []) 3 >>> find_clusters(3, 3, [(1, 2), (2, 3), (1, 3)]) 1 >>> find_clusters(5, 2, [(1, 2), (4, 5)]) 3 >>> find_clusters(5, 4, [(1, 2), (2, 3), (4, 5), (3, 1)]) 2 >>> find_clusters(6, 3, [(1, 2), (2, 3), (5, 6)]) 3 >>> find_clusters(7, 6, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7)]) 1","solution":"def find_clusters(n, m, emails): from collections import defaultdict, deque # Build the graph using adjacency list graph = defaultdict(list) for a, b in emails: graph[a].append(b) graph[b].append(a) def bfs(start, visited): queue = deque([start]) while queue: node = queue.popleft() for neighbor in graph[node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) visited = set() clusters_count = 0 for employee in range(1, n + 1): if employee not in visited: clusters_count += 1 visited.add(employee) bfs(employee, visited) return clusters_count # Example to demonstrate the function print(find_clusters(5, 4, [(1, 2), (2, 3), (4, 5), (3, 1)])) # Output should be 2"},{"question":"def contains_cycle(grid: List[List[str]]) -> str: Check if the given grid contains a cycle. >>> contains_cycle([[\\"a\\", \\"a\\", \\"a\\", \\"a\\"], [\\"a\\", \\"b\\", \\"c\\", \\"a\\"], [\\"a\\", \\"a\\", \\"a\\", \\"a\\"]]) \\"Yes\\" >>> contains_cycle([[\\"a\\", \\"b\\", \\"c\\"], [\\"d\\", \\"e\\", \\"f\\"], [\\"g\\", \\"h\\", \\"i\\"]]) \\"No\\"","solution":"def contains_cycle(grid): def dfs(x, y, parent_x, parent_y): if visited[x][y]: return True visited[x][y] = True for direction in directions: nx, ny = x + direction[0], y + direction[1] if 0 <= nx < m and 0 <= ny < n and (nx, ny) != (parent_x, parent_y) and grid[nx][ny] == grid[x][y]: if dfs(nx, ny, x, y): return True return False m = len(grid) n = len(grid[0]) visited = [[False] * n for _ in range(m)] directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] for i in range(m): for j in range(n): if not visited[i][j]: if dfs(i, j, -1, -1): return \\"Yes\\" return \\"No\\""},{"question":"def length_of_lis(heights): Returns the length of the longest strictly increasing subsequence. >>> length_of_lis([5, 2, 8, 6, 3, 6]) 3 >>> length_of_lis([1, 2, 3, 4, 5]) 5 def process_test_cases(t, test_cases): Processes multiple test cases to find the length of longest strictly increasing subsequence for each. >>> process_test_cases(2, [(6, [5, 2, 8, 6, 3, 6]), (5, [1, 2, 3, 4, 5])]) [3, 5] >>> process_test_cases(3, [(4, [4, 10, 4, 3, 8, 9]), (3, [6, 2, 5, 1, 7]), (0, [])]) [3, 3, 0]","solution":"def length_of_lis(heights): Returns the length of the longest strictly increasing subsequence. if not heights: return 0 dp = [1] * len(heights) for i in range(1, len(heights)): for j in range(i): if heights[i] > heights[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) def process_test_cases(t, test_cases): results = [] for case in test_cases: n, heights = case result = length_of_lis(heights) results.append(result) return results"},{"question":"def min_additional_channels(n: int, m: int, channels: List[Tuple[int, int]]) -> int: Determines the minimum number of additional channels needed to ensure that all buildings can communicate with each other either directly or indirectly. :param n: int - number of buildings :param m: int - number of existing direct communication channels :param channels: list of tuples - each tuple represents a direct communication channel between two buildings :return: int - minimum number of additional channels required >>> min_additional_channels(5, 2, [(1, 2), (3, 4)]) 2 >>> min_additional_channels(4, 0, []) 3 >>> min_additional_channels(6, 3, [(1, 2), (2, 3), (4, 5)]) 2 >>> min_additional_channels(3, 3, [(1, 2), (2, 3), (1, 3)]) 0 >>> min_additional_channels(3, 1, [(1, 2)]) 1 >>> min_additional_channels(1, 0, []) 0 >>> min_additional_channels(2, 1, [(1, 2)]) 0","solution":"def min_additional_channels(n, m, channels): Determines the minimum number of additional channels needed to ensure that all buildings can communicate with each other either directly or indirectly. :param n: int - number of buildings :param m: int - number of existing direct communication channels :param channels: list of tuples - each tuple represents a direct communication channel between two buildings :return: int - minimum number of additional channels required from collections import defaultdict, deque # Create an adjacency list for the graph graph = defaultdict(list) for u, v in channels: graph[u].append(v) graph[v].append(u) # Function to perform BFS and mark all reachable nodes def bfs(start, visited): queue = deque([start]) visited[start] = True while queue: node = queue.popleft() for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) # Track visited nodes and count connected components visited = [False] * (n + 1) components = 0 for i in range(1, n + 1): if not visited[i]: bfs(i, visited) components += 1 # Number of additional channels needed is (number of components - 1) return components - 1"},{"question":"from typing import List def longest_increasing_subsequence(arr: List[int]) -> int: This function returns the length of the longest increasing subsequence. >>> longest_increasing_subsequence([3, 10, 2, 1, 20, 4, 6, 10, 30, 5]) 5 >>> longest_increasing_subsequence([1, 2, 3, 4, 5]) 5 >>> longest_increasing_subsequence([5, 4, 3, 2, 1]) 1 >>> longest_increasing_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80]) 6 >>> longest_increasing_subsequence([2, 2, 2, 2, 2]) 1 >>> longest_increasing_subsequence([]) 0 >>> longest_increasing_subsequence([7]) 1","solution":"import bisect def longest_increasing_subsequence(arr): This function returns the length of the longest increasing subsequence. if not arr: return 0 lis = [] for num in arr: pos = bisect.bisect_left(lis, num) if pos == len(lis): lis.append(num) else: lis[pos] = num return len(lis)"},{"question":"def min_operations_to_equalize_energy_levels(n: int, energy_levels: List[int]) -> int: Returns the minimum number of operations needed to make all energy levels equal. >>> min_operations_to_equalize_energy_levels(1, [5]) 0 >>> min_operations_to_equalize_energy_levels(4, [2, 2, 2, 2]) 0 >>> min_operations_to_equalize_energy_levels(4, [1, 2, 3, 4]) 4 >>> min_operations_to_equalize_energy_levels(4, [4, 3, 2, 1]) 4 >>> min_operations_to_equalize_energy_levels(4, [5, 2, 1, 3]) 5 >>> min_operations_to_equalize_energy_levels(6, [10, 20, 30, 40, 50, 60]) 90","solution":"def min_operations_to_equalize_energy_levels(n, energy_levels): Returns the minimum number of operations needed to make all energy levels equal. # Sorting the array energy_levels.sort() # The optimal target energy level is the median median = energy_levels[n // 2] # Calculate number of operations to align all elements to the median operations = sum(abs(energy_level - median) for energy_level in energy_levels) return operations"},{"question":"def min_total_cost_to_connect_towns(n: int, m: int, roads: List[Tuple[int, int, int]]) -> int: Returns the minimum cost to connect all towns ensuring every town is reachable from the capital. If it is not possible to connect all towns, return -1. :param n: Number of towns :param m: Number of roads :param roads: List of tuples (u, v, w) where u and v are towns and w is the cost of the road :return: Minimum total cost or -1 if it's not possible to connect all towns Tests: >>> min_total_cost_to_connect_towns(4, 5, [(1, 2, 5), (1, 3, 10), (4, 1, 3), (2, 3, 15), (3, 4, 20)]) == 18 >>> min_total_cost_to_connect_towns(3, 1, [(1, 2, 5)]) == -1 >>> min_total_cost_to_connect_towns(1, 0, []) == 0 >>> min_total_cost_to_connect_towns(4, 2, [(1, 2, 5), (3, 4, 8)]) == -1 >>> min_total_cost_to_connect_towns(4, 6, [(1, 2, 2), (1, 3, 4), (1, 4, 3), (2, 3, 1), (2, 4, 5), (3, 4, 6)]) == 6","solution":"def min_total_cost_to_connect_towns(n, m, roads): Returns the minimum cost to connect all towns ensuring every town is reachable from the capital. Uses Kruskal's algorithm to generate Minimum Spanning Tree (MST). :param n: Number of towns :param m: Number of roads :param roads: List of tuples (u, v, w) where u and v are towns and w is the cost of the road :return: Minimum total cost or -1 if it's not possible to connect all towns # Define a union-find data structure parent = list(range(n+1)) rank = [0] * (n+1) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 # Sort roads by cost roads.sort(key=lambda x: x[2]) total_cost = 0 edges_used = 0 for u, v, w in roads: if find(u) != find(v): union(u, v) total_cost += w edges_used += 1 if edges_used == n - 1: break # Check if all towns are connected root = find(1) for i in range(2, n+1): if find(i) != root: return -1 return total_cost"},{"question":"def can_rearrange_arrays(n, A, B): Determines if it's possible to rearrange elements of array B such that every element in array B is greater than or equal to the corresponding element in array A. Parameters: n (int): Number of elements in A and B. A (list of int): List of integers representing array A. B (list of int): List of integers representing array B. Returns: str: \\"YES\\" if it's possible to rearrange B as per the condition, else \\"NO\\". >>> can_rearrange_arrays(3, [2, 3, 4], [3, 4, 5]) \\"YES\\" >>> can_rearrange_arrays(3, [2, 3, 4], [1, 4, 5]) \\"NO\\" from can_rearrange_arrays import can_rearrange_arrays def test_example1(): assert can_rearrange_arrays(3, [2, 3, 4], [3, 4, 5]) == \\"YES\\" def test_example2(): assert can_rearrange_arrays(3, [2, 3, 4], [1, 4, 5]) == \\"NO\\" def test_all_equal(): assert can_rearrange_arrays(3, [2, 2, 2], [2, 2, 2]) == \\"YES\\" def test_case_with_large_numbers(): assert can_rearrange_arrays(3, [1000000000, 999999999, 999999998], [1000000000, 1000000000, 999999999]) == \\"YES\\" def test_case_unsorted_input(): assert can_rearrange_arrays(5, [3, 1, 4, 1, 5], [5, 4, 3, 2, 1]) == \\"YES\\" def test_case_unsorted_and_impossible(): assert can_rearrange_arrays(4, [4, 1, 3, 2], [1, 2, 2, 3]) == \\"NO\\"","solution":"def can_rearrange_arrays(n, A, B): Determines if it's possible to rearrange elements of array B such that every element in array B is greater than or equal to the corresponding element in array A. Parameters: n (int): Number of elements in A and B. A (list of int): List of integers representing array A. B (list of int): List of integers representing array B. Returns: str: \\"YES\\" if it's possible to rearrange B as per the condition, else \\"NO\\". A.sort() B.sort() for i in range(n): if B[i] < A[i]: return \\"NO\\" return \\"YES\\""},{"question":"def determine_winner(q: int, queries: List[Tuple[int, int]]) -> List[str]: Determine which player has a winning strategy in an infinite grid game. Each tuple in the queries list represents the starting cell coordinates (x, y). Return a list of strings where \\"First\\" means the first player has a winning strategy and \\"Second\\" means the second player has a winning strategy. >>> determine_winner(3, [(1, 1), (2, 2), (3, 1)]) ['Second', 'First', 'Second'] >>> determine_winner(1, [(1, 2)]) ['Second']","solution":"def determine_winner(q, queries): results = [] for x, y in queries: if x == y: results.append(\\"First\\") else: results.append(\\"Second\\") return results"},{"question":"def shuffle_cards(n: int, m: int) -> List[int]: Returns the sequence of cards in the deck after performing m moves. Parameters: n (int): The number of cards in the deck. m (int): The number of moves. Returns: List[int]: The sequence of cards after m moves. Examples: >>> shuffle_cards(5, 2) [3, 4, 5, 1, 2] >>> shuffle_cards(5, 0) [1, 2, 3, 4, 5] >>> shuffle_cards(5, 1) [2, 3, 4, 5, 1] >>> shuffle_cards(5, 5) [1, 2, 3, 4, 5] >>> shuffle_cards(5, 7) [3, 4, 5, 1, 2] >>> shuffle_cards(100000, 3)[:5] [4, 5, 6, 7, 8] >>> shuffle_cards(100000, 100003)[:5] [4, 5, 6, 7, 8] >>> shuffle_cards(1, 100000) [1]","solution":"def shuffle_cards(n, m): Returns the sequence of cards in the deck after performing m moves. moves = m % n deck = list(range(1, n + 1)) return deck[moves:] + deck[:moves] # Example usage: # n, m = 5, 2 # print(shuffle_cards(n, m)) # Output: [3, 4, 5, 1, 2]"},{"question":"def smallest_common_number(t: int, test_cases: List[Tuple[int, List[int], int, List[int]]]) -> List[int]: Find the smallest number that is present in both sets for each test case. If there is no common number, return -1. Args: t: Number of test cases test_cases: A list of tuples where each tuple contains: - An integer n (size of the first set) - A list of n distinct non-negative integers (elements of the first set) - An integer m (size of the second set) - A list of m distinct non-negative integers (elements of the second set) Returns: A list of integers where each integer is the smallest common number for the corresponding test case, or -1 if no common number exists. Example: >>> smallest_common_number(2, [(3, [1, 2, 3], 4, [3, 4, 5, 6]), (5, [7, 8, 9, 10, 11], 3, [12, 13, 14])]) [3, -1] >>> smallest_common_number(1, [(3, [1, 5, 7], 3, [9, 5, 11])]) [5]","solution":"def smallest_common_number(t, test_cases): results = [] for i in range(t): _, set1, _, set2 = test_cases[i] common_numbers = sorted(set(set1).intersection(set(set2))) if common_numbers: results.append(min(common_numbers)) else: results.append(-1) return results # Example usage: # test_cases = [(3, [1, 2, 3], 4, [3, 4, 5, 6]), (5, [7, 8, 9, 10, 11], 3, [12, 13, 14])] # print(smallest_common_number(2, test_cases)) # Output: [3, -1]"},{"question":"def min_operations_to_transform(a: str, b: str) -> int: Returns the minimum number of operations required to transform string \`a\` into string \`b\`. Each operation allows changing one character in string \`a\` to any other character in order to make \`a\` equal to string \`b\`. Strings must be of the same length. >>> min_operations_to_transform('abc', 'abc') 0 >>> min_operations_to_transform('abc', 'def') 3 assert len(a) == len(b), \\"Strings must be of the same length\\"","solution":"def min_operations_to_transform(a, b): Returns the minimum number of operations required to transform string \`a\` into string \`b\`. assert len(a) == len(b), \\"Strings must be of the same length\\" return sum(1 for i in range(len(a)) if a[i] != b[i])"},{"question":"def max_activity_spike(n: int, posts: List[int]) -> int: Given an array of n integers where each integer represents the number of posts a user made, returns the maximum sum of any contiguous subarray of the given array. >>> max_activity_spike(5, [1, -2, 3, 10, -4]) 13 >>> max_activity_spike(4, [1, 2, 3, 4]) 10 >>> max_activity_spike(3, [-1, -2, -3]) -1 >>> max_activity_spike(6, [2, -1, 2, 3, 4, -5]) 10 >>> max_activity_spike(1, [7]) 7 >>> max_activity_spike(1, [-3]) -3 >>> max_activity_spike(8, [1, 2, -1, 2, -1, 2, -1, 2]) 6","solution":"def max_activity_spike(n, posts): Given an array of n integers where each integer represents the number of posts a user made, returns the maximum sum of any contiguous subarray of the given array. max_current = max_global = posts[0] for i in range(1, n): max_current = max(posts[i], max_current + posts[i]) if max_current > max_global: max_global = max_current return max_global"},{"question":"def minimize_processing_time(n: int, processing_times: List[int]) -> int: Given the number of items and their respective processing times, calculates the minimal total processing time. >>> minimize_processing_time(1, [5]) 5 >>> minimize_processing_time(3, [4, 4, 4]) 12 >>> minimize_processing_time(4, [1, 2, 3, 4]) 10 >>> minimize_processing_time(6, [1, 2, 2, 5, 2]) 12 >>> minimize_processing_time(2, [1000000, 1000000]) 2000000 pass","solution":"def minimize_processing_time(n, processing_times): Given the number of items and their respective processing times, calculates the minimal total processing time. return sum(processing_times)"},{"question":"def min_modifications_to_equalize(arr): Returns the minimum number of modifications required to make all elements of the array equal. >>> min_modifications_to_equalize([1]) 0 >>> min_modifications_to_equalize([1, 1, 1]) 0 >>> min_modifications_to_equalize([1, 2, 3]) 2 >>> min_modifications_to_equalize([1, 4, 5, 7, 8]) 10 >>> min_modifications_to_equalize([5, 10, 20]) 15 >>> min_modifications_to_equalize([10, 10, 10, 10, 10]) 0 >>> min_modifications_to_equalize([1, 100000]) 99999 >>> min_modifications_to_equalize([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 25 >>> min_modifications_to_equalize([100000] * 100000) 0","solution":"def min_modifications_to_equalize(arr): Returns the minimum number of modifications required to make all elements of the array equal. # Sort the array to find the median arr.sort() # Median is the best candidate to minimize the modifications median = arr[len(arr) // 2] return sum(abs(x - median) for x in arr)"},{"question":"from collections import defaultdict, deque from typing import List, Tuple def find_maximum_width(edges: List[Tuple[int, int]]) -> int: Find the maximum width of the binary tree given its edges. >>> find_maximum_width([(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)]) 4 >>> find_maximum_width([]) 0 >>> find_maximum_width([(1, 2), (1, 3)]) 2 >>> find_maximum_width([(1, 2), (2, 3), (3, 4), (4, 5)]) 1 >>> find_maximum_width([(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7), (4, 8), (4, 9), (5, 10), (5, 11), (6, 12), (6, 13), (7, 14), (7, 15)]) 8","solution":"from collections import defaultdict, deque def find_maximum_width(edges): if not edges: return 0 adjacency_list = defaultdict(list) children = set() for parent, child in edges: adjacency_list[parent].append(child) children.add(child) # Find the root (minimum value of node that is not a child) all_nodes = set(adjacency_list.keys()).union(children) root = min(all_nodes - children) # Perform BFS to calculate the width of each level queue = deque([(root, 0)]) level_count = defaultdict(int) while queue: node, level = queue.popleft() level_count[level] += 1 for child in adjacency_list[node]: queue.append((child, level + 1)) # Calculate the maximum width max_width = max(level_count.values()) return max_width"},{"question":"from collections import defaultdict, Counter def best_selling_products(transactions): Analyze sales data to determine the best-selling product for each category. Args: transactions: List of tuples, where each tuple contains a category and a product sold in that category. Returns: A list of strings, where each string contains the category name and the best-selling product in that category. Example: >>> parse_input(\\"7nElectronics LaptopnFurniture SofanElectronics PhonenElectronics LaptopnFurniture TablenElectronics LaptopnFurniture Sofa\\") ... [('Electronics', 'Laptop'), ('Furniture', 'Sofa'), ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Furniture', 'Table'), ('Electronics', 'Laptop'), ('Furniture', 'Sofa')] >>> best_selling_products([('Electronics', 'Laptop'), ('Furniture', 'Sofa'), ('Electronics', 'Phone'), ('Electronics', 'Laptop'), ('Furniture', 'Table'), ('Electronics', 'Laptop'), ('Furniture', 'Sofa')]) ... [\\"Electronics Laptop\\", \\"Furniture Sofa\\"] >>> parse_input(\\"5nBooks BookAnBooks BookBnBooks BookAnBooks BookBnBooks BookC\\") ... [('Books', 'BookA'), ('Books', 'BookB'), ('Books', 'BookA'), ('Books', 'BookB'), ('Books', 'BookC')] >>> best_selling_products([('Books', 'BookA'), ('Books', 'BookB'), ('Books', 'BookA'), ('Books', 'BookB'), ('Books', 'BookC')]) ... [\\"Books BookA\\"] pass def parse_input(input_data): Parse input string to extract transaction information. Args: input_data: Multi-line string where first line indicates number of transactions and each subsequent line contains a category and product sold. Returns: A list of tuples where each tuple contains a category and a product sold in that category. pass","solution":"from collections import defaultdict, Counter def best_selling_products(transactions): category_counter = defaultdict(Counter) for category, product in transactions: category_counter[category][product] += 1 result = [] for category in sorted(category_counter.keys()): best_product = min( category_counter[category].keys(), key=lambda product: (-category_counter[category][product], product) ) result.append(f\\"{category} {best_product}\\") return result def parse_input(input_data): lines = input_data.strip().split(\\"n\\") n = int(lines[0]) transactions = [line.split() for line in lines[1:n+1]] return transactions"},{"question":"def is_connected(grid: List[str]) -> str: Determines if the grid is connected, meaning any cell with '#' can be reached from any other cell with '#'. >>> is_connected([\\"#\\",\\".#.\\",\\"#\\"]) \\"YES\\" >>> is_connected([\\"#.#\\",\\".#.\\",\\"#\\"]) \\"NO\\"","solution":"def is_connected(grid): Determines if the grid is connected, meaning any cell with '#' can be reached from any other cell with '#'. n = len(grid) visited = [[False] * n for _ in range(n)] # Find the first cell containing '#' def find_start(): for i in range(n): for j in range(n): if grid[i][j] == '#': return (i, j) return None # Depth-First Search (DFS) to mark connected components def dfs(x, y): stack = [(x, y)] while stack: cx, cy = stack.pop() for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = cx + dx, cy + dy if 0 <= nx < n and 0 <= ny < n and grid[nx][ny] == '#' and not visited[nx][ny]: visited[nx][ny] = True stack.append((nx, ny)) start = find_start() if not start: return \\"YES\\" # If there are no '#' in the grid sx, sy = start visited[sx][sy] = True dfs(sx, sy) for i in range(n): for j in range(n): if grid[i][j] == '#' and not visited[i][j]: return \\"NO\\" return \\"YES\\""},{"question":"def is_beautiful(s: str) -> str: Returns \\"YES\\" if the string can be permuted to a palindrome, otherwise \\"NO\\". >>> is_beautiful('aabb') \\"YES\\" >>> is_beautiful('abcd') \\"NO\\" >>> is_beautiful('aa') \\"YES\\" >>> is_beautiful('abc') \\"NO\\"","solution":"def is_beautiful(s): Returns \\"YES\\" if the string can be permuted to a palindrome, otherwise \\"NO\\". # Count the occurrences of each character in the string char_count = {} for char in s: char_count[char] = char_count.get(char, 0) + 1 # Count how many characters have an odd number of appearances odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can be permuted to a palindrome if it has at most one character with an odd count return \\"YES\\" if odd_count <= 1 else \\"NO\\""},{"question":"def best_discounted_prices(discounts, customer_queries): Calculate the best possible final price for each customer's intended purchase amount on their shopping day. Parameters: discounts (list of tuples): List containing discounts details as (start day, end day, minimum price, discount percentage). customer_queries (list of tuples): List containing customer queries as (day, intended purchase amount). Returns: list of floats: List containing the best possible final prices for each customer's query. Example: >>> best_discounted_prices([(1, 5, 100, 10), (2, 7, 150, 20), (4, 8, 200, 25)], [(3, 180), (5, 99), (7, 210)]) [144.0, 99.0, 157.5] >>> best_discounted_prices([(1, 3, 50, 5)], [(2, 60)]) [57.0] from solution import best_discounted_prices def test_best_discounted_prices_no_discount(): discounts = [(1, 5, 100, 10)] customer_queries = [(6, 120)] assert best_discounted_prices(discounts, customer_queries) == [120] def test_best_discounted_prices_single_discount(): discounts = [(1, 5, 100, 10)] customer_queries = [(5, 150)] assert best_discounted_prices(discounts, customer_queries) == [135.0] def test_best_discounted_prices_multiple_discounts_same_day(): discounts = [(1, 5, 100, 10), (1, 5, 200, 20)] customer_queries = [(4, 250)] assert best_discounted_prices(discounts, customer_queries) == [200.0] def test_best_discounted_prices_multiple_queries(): discounts = [(1, 5, 100, 10), (2, 7, 150, 20), (4, 8, 200, 25)] customer_queries = [(3, 180), (5, 99), (7, 210)] expected = [144.0, 99.0, 157.5] assert best_discounted_prices(discounts, customer_queries) == expected def test_best_discounted_prices_edge_cases(): discounts = [] customer_queries = [(3, 150)] assert best_discounted_prices(discounts, customer_queries) == [150.0] discounts = [(1, 5, 100, 10)] customer_queries = [] assert best_discounted_prices(discounts, customer_queries) == []","solution":"def best_discounted_prices(discounts, customer_queries): Calculate the best possible final price for each customer's intended purchase amount on their shopping day. Parameters: discounts (list of tuples): List containing discounts details as (start day, end day, minimum price, discount percentage). customer_queries (list of tuples): List containing customer queries as (day, intended purchase amount). Returns: list of floats: List containing the best possible final prices for each customer's query. final_prices = [] for day, amount in customer_queries: best_price = amount for s, e, p, d in discounts: if s <= day <= e and amount >= p: discounted_price = amount * (1 - d / 100) if discounted_price < best_price: best_price = discounted_price final_prices.append(best_price) return final_prices # Example Usage n, m = 3, 3 discounts = [(1, 5, 100, 10), (2, 7, 150, 20), (4, 8, 200, 25)] customer_queries = [(3, 180), (5, 99), (7, 210)] print(best_discounted_prices(discounts, customer_queries))"},{"question":"def max_sliding_window(buildings, k): Returns a list of the maximum heights within each sliding window of size k. >>> max_sliding_window([1, 3, 1, 2, 0, 5, 2, 6], 3) [3, 3, 2, 5, 5, 6] >>> max_sliding_window([7, 7, 7, 7, 7], 2) [7, 7, 7, 7] >>> max_sliding_window([2, 4, 6, 3, 5], 1) [2, 4, 6, 3, 5]","solution":"from collections import deque def max_sliding_window(buildings, k): Returns a list of the maximum heights within each sliding window of size k. n = len(buildings) if n * k == 0: return [] if k == 1: return buildings deq = deque() result = [] for i in range(n): # Remove elements not in the sliding window if deq and deq[0] == i - k: deq.popleft() # Remove elements smaller than the current from the deque while deq and buildings[deq[-1]] < buildings[i]: deq.pop() deq.append(i) # Append result from the start of the sliding window if i >= k - 1: result.append(buildings[deq[0]]) return result"},{"question":"def apply_operations(n: int, q: int, arr: List[int], operations: List[str]) -> int: Applies a series of add and subtract operations on the array and returns the maximum possible value. Parameters: n (int): Size of the array q (int): Number of operations arr (list): Initial array of nonnegative integers operations (list): List of operations with the format ['Add l r x'] or ['Subtract l r y'] Returns: int: Maximum possible value in the array after all operations Examples: >>> apply_operations(5, 3, [1, 2, 3, 4, 5], [\\"Add 2 4 10\\", \\"Subtract 3 5 2\\", \\"Add 1 3 5\\"]) 17 >>> apply_operations(3, 1, [0, 0, 0], [\\"Add 1 3 5\\"]) 5 >>> apply_operations(3, 1, [10, 10, 10], [\\"Subtract 1 3 5\\"]) 5 >>> apply_operations(4, 2, [1, 2, 3, 4], [\\"Add 1 2 3\\", \\"Subtract 2 3 2\\"]) 4 >>> apply_operations(3, 0, [1, 2, 3], []) 3","solution":"def apply_operations(n, q, arr, operations): Applies a series of add and subtract operations on the array and returns the maximum possible value. Parameters: n (int): Size of the array q (int): Number of operations arr (list): Initial array of nonnegative integers operations (list): List of operations with the format ['Add l r x'] or ['Subtract l r y'] Returns: int: Maximum possible value in the array after all operations # We initialize a difference array with the same length as arr + 1 for easier calculations diff = [0] * (n + 1) # Process the operations for operation in operations: parts = operation.split() type_op, l, r, value = parts[0], int(parts[1]), int(parts[2]), int(parts[3]) # Adjusting for 0-based index l -= 1 r -= 1 if type_op == 'Add': diff[l] += value if r + 1 < n: diff[r + 1] -= value elif type_op == 'Subtract': diff[l] -= value if r + 1 < n: diff[r + 1] += value # Calculate the final values of the array using the difference array max_val = arr[0] + diff[0] current_val = arr[0] + diff[0] for i in range(1, n): current_val = arr[i] + diff[i] + diff[i-1] diff[i] += diff[i-1] # Continuously sum the differences if current_val > max_val: max_val = current_val return max_val"},{"question":"def process_queries(n, q, array, queries): Preprocesses the array to quickly answer range sum queries. Args: n (int): The number of elements in the array. q (int): The number of queries. array (List[int]): The list of integers. queries (List[Tuple[int, int]]): The list of queries, where each query is a tuple (l, r). Returns: List[int]: A list of the sums of elements for each query. Examples: >>> process_queries(5, 1, [1, 2, 3, 4, 5], [(1, 3)]) [6] >>> process_queries(5, 3, [1, 2, 3, 4, 5], [(1, 3), (2, 4), (1, 5)]) [6, 9, 15] >>> process_queries(5, 2, [1, 2, 3, 4, 5], [(1, 1), (5, 5)]) [1, 5] >>> process_queries(5, 1, [1, 2, 3, 4, 5], [(1, 5)]) [15] from solution import process_queries def test_single_query(): assert process_queries(5, 1, [1, 2, 3, 4, 5], [(1, 3)]) == [6] def test_multiple_queries(): assert process_queries(5, 3, [1, 2, 3, 4, 5], [(1, 3), (2, 4), (1, 5)]) == [6, 9, 15] def test_single_element_query(): assert process_queries(5, 2, [1, 2, 3, 4, 5], [(1, 1), (5, 5)]) == [1, 5] def test_full_array_query(): assert process_queries(5, 1, [1, 2, 3, 4, 5], [(1, 5)]) == [15] def test_large_array(): n = 300000 q = 1 array = [1] * n queries = [(1, n)] assert process_queries(n, q, array, queries) == [300000]","solution":"def process_queries(n, q, array, queries): # Precompute prefix sums prefix_sums = [0] * (n + 1) for i in range(1, n + 1): prefix_sums[i] = prefix_sums[i - 1] + array[i - 1] results = [] for l, r in queries: sum_subarray = prefix_sums[r] - prefix_sums[l - 1] results.append(sum_subarray) return results"},{"question":"def can_sort_rows(n: int, m: int, grid: List[List[int]]) -> str: Determine if it is possible to sort each row of the grid in non-decreasing order using the operations described. Example: >>> can_sort_rows(3, 4, [ >>> [4, 3, 2, 1], >>> [4, 3, 2, 1], >>> [4, 3, 2, 1] >>> ]) \\"NO\\" >>> can_sort_rows(2, 2, [ >>> [1, 2], >>> [3, 4] >>> ]) \\"YES\\"","solution":"def can_sort_rows(n, m, grid): for row in grid: if row != sorted(row): return \\"NO\\" return \\"YES\\" def main(): import sys input = sys.stdin.read data = input().split() n, m = int(data[0]), int(data[1]) grid = [] index = 2 for i in range(n): row = [int(data[index + j]) for j in range(m)] grid.append(row) index += m print(can_sort_rows(n, m, grid)) if __name__ == \\"__main__\\": main()"},{"question":"def final_brightness(n, m, initial_brightness, operations): Computes the final brightness of each photo after applying all the operations. Parameters: n (int): Number of photos. m (int): Number of operations. initial_brightness (list of int): Initial brightness of each photo. operations (list of (int, int)): List of operations to apply (t, x). Returns: list of int: Final brightness of each photo. pass # Example usage initial_brightness = [10, 20, 15] operations = [(1, 5), (2, 3), (1, 10), (2, 2)] print(final_brightness(3, 4, initial_brightness, operations)) # Output: [20, 30, 25] # Unit tests def test_increase_only(): assert final_brightness(3, 2, [10, 20, 15], [(1, 5), (1, 10)]) == [25, 35, 30] def test_decrease_only(): assert final_brightness(3, 2, [10, 20, 15], [(2, 5), (2, 3)]) == [2, 12, 7] def test_mixed_operations(): assert final_brightness(3, 4, [10, 20, 15], [(1, 5), (2, 3), (1, 10), (2, 2)]) == [20, 30, 25] def test_no_operations(): assert final_brightness(3, 0, [10, 20, 15], []) == [10, 20, 15] def test_single_photo_many_operations(): assert final_brightness(1, 3, [100], [(1, 50), (2, 30), (1, 20)]) == [140] def test_large_values(): assert final_brightness(2, 2, [1000000000, 999999999], [(1, 1), (2, 2)]) == [999999999, 999999998]","solution":"def final_brightness(n, m, initial_brightness, operations): Computes the final brightness of each photo after applying all the operations. Parameters: n (int): Number of photos. m (int): Number of operations. initial_brightness (list of int): Initial brightness of each photo. operations (list of (int, int)): List of operations to apply (t, x). Returns: list of int: Final brightness of each photo. # Initialize the result with initial brightness values brightness = initial_brightness[:] # Apply each operation in sequence for t, x in operations: if t == 1: brightness = [b + x for b in brightness] elif t == 2: brightness = [b - x for b in brightness] return brightness"},{"question":"def well_spaced_sentence(s: str) -> str: Transforms the input string s into a well-spaced sentence, i.e., exactly one space between each word and no leading or trailing spaces. Parameters: s (str): The input string containing words separated by spaces. Returns: str: The transformed well-spaced sentence. >>> well_spaced_sentence(\\" hello world this is an example \\") \\"hello world this is an example\\" >>> well_spaced_sentence(\\"singleword\\") \\"singleword\\" >>> well_spaced_sentence(\\" leading and trailing spaces \\") \\"leading and trailing spaces\\" >>> well_spaced_sentence(\\"multiple spaces between words\\") \\"multiple spaces between words\\" >>> well_spaced_sentence(\\"\\") \\"\\" >>> well_spaced_sentence(\\" \\") \\"\\" >>> well_spaced_sentence(\\" with leading spaces but also text \\") \\"with leading spaces but also text\\"","solution":"def well_spaced_sentence(s: str) -> str: Transforms the input string s into a well-spaced sentence, i.e., exactly one space between each word and no leading or trailing spaces. Parameters: s (str): The input string containing words separated by spaces. Returns: str: The transformed well-spaced sentence. # Split the string by spaces to get the words words = s.split() # Join the words with a single space return ' '.join(words)"},{"question":"def count_zero_sum_subarrays(arr): Count the number of subarrays with sum equal to zero. Parameters: arr (list of int): The input array. Returns: int: The number of subarrays with sum zero. >>> count_zero_sum_subarrays([1, -1, 2, -2, 3]) 3 >>> count_zero_sum_subarrays([1, 2, 3, 4]) 0 >>> count_zero_sum_subarrays([0, 0, 0]) 6 >>> count_zero_sum_subarrays([0]) 1 >>> count_zero_sum_subarrays([5]) 0 >>> count_zero_sum_subarrays([10**9, -10**9, 10**9, -10**9, 10**9, -10**9]) 9 >>> count_zero_sum_subarrays([4, -3, -2, 1, 1, 5]) 2 >>> count_zero_sum_subarrays([3, -3, 3, -3]) 4","solution":"def count_zero_sum_subarrays(arr): Counts the number of subarrays with sum equal to zero. Parameters: arr (list of int): The input array. Returns: int: The number of subarrays with sum zero. sum_counts = {} sum_counts[0] = 1 current_sum = 0 zero_sum_count = 0 for num in arr: current_sum += num if current_sum in sum_counts: zero_sum_count += sum_counts[current_sum] sum_counts[current_sum] += 1 else: sum_counts[current_sum] = 1 return zero_sum_count"},{"question":"def analyze_feedback(n: int, m: int, feedback: List[List[int]]) -> Tuple[List[float], Tuple[int, int]]: Finds the average rating for each aspect and determines which aspect received the highest and lowest average score. Parameters: n : int : the number of feedback forms m : int : the number of aspects rated in each form feedback : List[List[int]] : the feedback ratings for each aspect Returns: Tuple[List[float], Tuple[int, int]] : a tuple containing: - the average ratings (rounded to two decimal places) of the aspects - two space-separated integers representing: - the 1-based index of the aspect with the highest average rating - the 1-based index of the aspect with the lowest average rating Example: >>> analyze_feedback(3, 4, [ ... [8, 6, 7, 5], ... [9, 7, 6, 8], ... [7, 8, 5, 7] ... ]) ([8.0, 7.0, 6.0, 6.67], (1, 3)) >>> analyze_feedback(1, 4, [ ... [1, 2, 3, 4] ... ]) ([1.0, 2.0, 3.0, 4.0], (4, 1))","solution":"def analyze_feedback(n, m, feedback): Returns the average rating of each aspect and the indices of the highest and lowest average rating aspects. # Calculate the total and average ratings for each aspect total_ratings = [0] * m for form in feedback: for j in range(m): total_ratings[j] += form[j] average_ratings = [round(total / n, 2) for total in total_ratings] # Determine the indices of the highest and lowest average ratings highest_index = average_ratings.index(max(average_ratings)) + 1 lowest_index = average_ratings.index(min(average_ratings)) + 1 return average_ratings, (highest_index, lowest_index)"},{"question":"def max_non_overlapping_groups(n: int, time_intervals: List[Tuple[int, int]]) -> int: Determine the maximum number of non-overlapping groups that can be accommodated. Parameters: n (int): Number of groups. time_intervals (List[Tuple[int, int]]): List of tuples with start and end times for each group. Returns: int: Maximum number of non-overlapping groups. >>> max_non_overlapping_groups(5, [(1, 4), (2, 6), (8, 9), (3, 5), (5, 7)]) 3 >>> max_non_overlapping_groups(1, [(1, 2)]) 1 >>> max_non_overlapping_groups(3, [(1, 2), (3, 4), (5, 6)]) 3 >>> max_non_overlapping_groups(3, [(1, 4), (2, 5), (3, 6)]) 1 >>> max_non_overlapping_groups(4, [(1, 3), (2, 4), (5, 6), (4, 5)]) 3 >>> max_non_overlapping_groups(6, [(1, 4), (2, 5), (3, 6), (7, 8), (8, 10), (10, 12)]) 4","solution":"def max_non_overlapping_groups(n, time_intervals): Returns the maximum number of non-overlapping groups that can be accommodated. Parameters: n (int): Number of groups. time_intervals (List[Tuple[int, int]]): List of tuples with start and end times for each group. Returns: int: Maximum number of non-overlapping groups. # Sort intervals based on their finish times sorted_intervals = sorted(time_intervals, key=lambda x: x[1]) # Initialize the count of non-overlapping groups count = 0 last_finish_time = 0 for start, finish in sorted_intervals: if start >= last_finish_time: count += 1 last_finish_time = finish return count"},{"question":"def min_insertions_to_make_valid_parentheses(s: str) -> int: Returns the minimum number of characters to be inserted to make the string a valid parentheses sequence. >>> min_insertions_to_make_valid_parentheses(\\"()))(\\") 2 >>> min_insertions_to_make_valid_parentheses(\\"(()))(\\") 2 >>> min_insertions_to_make_valid_parentheses(\\"((())(()\\") 2","solution":"def min_insertions_to_make_valid_parentheses(s): Returns the minimum number of characters to be inserted to make the string a valid parentheses sequence. open_count = 0 close_needed = 0 for char in s: if char == '(': open_count += 1 else: if open_count > 0: open_count -= 1 else: close_needed += 1 return open_count + close_needed"},{"question":"def largest_subtree_after_removal(n: int, edges: List[Tuple[int, int, int]]) -> int: In the kingdom of Graphland, determine the smallest size of the larger subtree after removing exactly one edge from the tree with n nodes. Args: n (int): The number of nodes in the tree. edges (List[Tuple[int, int, int]]): List of edges where each edge is represented by a tuple (u, v, w). Returns: int: The size of the larger subtree after removing the optimal edge. Example: >>> largest_subtree_after_removal(5, [(1, 2, 3), (1, 3, 4), (1, 4, 5), (4, 5, 6)]) 3 >>> largest_subtree_after_removal(5, [(1, 2, 1), (2, 3, 1), (2, 4, 1), (4, 5, 1)]) 3 pass def test_largest_subtree_after_removal_case_1(): edges = [(1, 2, 3), (1, 3, 4), (1, 4, 5), (4, 5, 6)] assert largest_subtree_after_removal(5, edges) == 3 def test_largest_subtree_after_removal_case_2(): edges = [(1, 2, 1), (2, 3, 1), (2, 4, 1), (4, 5, 1)] assert largest_subtree_after_removal(5, edges) == 3 def test_largest_subtree_after_removal_single_edge(): edges = [(1, 2, 1)] assert largest_subtree_after_removal(2, edges) == 1 def test_largest_subtree_after_removal_balanced_tree(): edges = [ (1, 2, 1), (1, 3, 1), (2, 4, 1), (2, 5, 1), (3, 6, 1), (3, 7, 1) ] assert largest_subtree_after_removal(7, edges) == 4 def test_largest_subtree_after_removal_linear_tree(): edges = [(1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 5, 1)] assert largest_subtree_after_removal(5, edges) == 3","solution":"def largest_subtree_after_removal(n, edges): from collections import defaultdict graph = defaultdict(list) for u, v, w in edges: graph[u].append(v) graph[v].append(u) sizes = [0] * (n + 1) def dfs(node, parent): sizes[node] = 1 for neighbor in graph[node]: if neighbor != parent: sizes[node] += dfs(neighbor, node) return sizes[node] dfs(1, -1) min_larger_part = n total_size = sizes[1] def find_optimal(node, parent): nonlocal min_larger_part for neighbor in graph[node]: if neighbor != parent: subtree_size = sizes[neighbor] larger_part = max(subtree_size, total_size - subtree_size) min_larger_part = min(min_larger_part, larger_part) find_optimal(neighbor, node) find_optimal(1, -1) return min_larger_part"},{"question":"def count_pairs_with_sum(n: int, numbers: List[int], target: int) -> int: Returns the number of pairs of integers in the list that sum up to the target integer. :param n: integer, the number of integers in the list :param numbers: list of integers :param target: integer, the target sum :return: integer, the number of pairs that sum up to the target pass # Example usage: # if __name__ == \\"__main__\\": # n = 5 # numbers = [1, 2, 3, 4, 5] # target = 5 # print(count_pairs_with_sum(n, numbers, target)) # Output: 2 # Unit Tests from typing import List def test_example_case(): assert count_pairs_with_sum(5, [1, 2, 3, 4, 5], 5) == 2 def test_no_pairs(): assert count_pairs_with_sum(3, [1, 2, 3], 10) == 0 def test_all_pairs(): assert count_pairs_with_sum(4, [1, 4, 2, 3], 5) == 2 def test_negative_numbers(): assert count_pairs_with_sum(5, [-1, -2, -3, -4, -5], -5) == 2 def test_multiple_same_numbers(): assert count_pairs_with_sum(4, [1, 1, 1, 1], 2) == 6","solution":"def count_pairs_with_sum(n, numbers, target): Returns the number of pairs of integers in the list that sum up to the target integer. :param n: integer, the number of integers in the list :param numbers: list of integers :param target: integer, the target sum :return: integer, the number of pairs that sum up to the target count = 0 for i in range(n): for j in range(i + 1, n): if numbers[i] + numbers[j] == target: count += 1 return count # Example usage # if __name__ == \\"__main__\\": # n = 5 # numbers = [1, 2, 3, 4, 5] # target = 5 # print(count_pairs_with_sum(n, numbers, target)) # Output: 2"},{"question":"def unique_paths_with_obstacles(n: int, m: int, grid: List[str]) -> int: Determine the number of unique paths for a robot to move from the top-left corner to the bottom-right corner of a grid with obstacles. :param n: Number of rows in the grid. :param m: Number of columns in the grid. :param grid: A list of strings representing the grid, where '.' is an empty cell and '#' is an obstacle. :return: The number of unique paths modulo 1,000,000,007. >>> unique_paths_with_obstacles(3, 3, [\\"...\\", \\".#.\\", \\"...\\"]) 2 >>> unique_paths_with_obstacles(2, 2, [\\"..\\", \\"..\\"]) 2 >>> unique_paths_with_obstacles(2, 2, [\\"..\\", \\"\\"]) 0 >>> unique_paths_with_obstacles(3, 3, [\\"...\\", \\"...\\", \\"..#\\"]) 0 >>> unique_paths_with_obstacles(3, 3, [\\"...\\", \\"...\\", \\"...\\"]) 6","solution":"def unique_paths_with_obstacles(n, m, grid): MOD = 1000000007 if grid[0][0] == '#' or grid[n-1][m-1] == '#': return 0 dp = [[0] * m for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(m): if grid[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] dp[i][j] %= MOD return dp[n-1][m-1]"},{"question":"def max_height_to_cut_trees(heights: List[int], m: int) -> int: Given a list of tree heights and a required amount of wood, this function returns the maximum height at which trees should be cut to collect at least the required amount of wood. >>> max_height_to_cut_trees([20, 15, 10, 17], 7) == 15 >>> max_height_to_cut_trees([4, 4, 4, 4], 4) == 3 >>> max_height_to_cut_trees([10, 7, 5, 20], 0) == 20 >>> max_height_to_cut_trees([1, 1, 1, 1, 1], 1) == 0 >>> max_height_to_cut_trees([1000000000, 1000000000, 1000000000, 1000000000], 2000000000) == 500000000","solution":"def max_height_to_cut_trees(heights, m): Given a list of tree heights and a required amount of wood, this function returns the maximum height at which trees should be cut to collect at least the required amount of wood. :param heights: List[int] - list of tree heights :param m: int - required amount of wood :return: int - maximum height at which to cut trees def wood_collected(cut_height): return sum(max(height - cut_height, 0) for height in heights) low, high = 0, max(heights) answer = 0 while low <= high: mid = (low + high) // 2 if wood_collected(mid) >= m: answer = mid low = mid + 1 else: high = mid - 1 return answer"},{"question":"from typing import List, Union def reorganize_sequence(n: int, a: List[int]) -> Union[List[int], str]: Determine if it is possible to reorder the sequence such that no two adjacent elements are equal. If such reordering is possible, return any valid sequence, otherwise return \\"Not Possible\\". >>> reorganize_sequence(6, [1, 1, 2, 2, 3, 3]) [1, 2, 1, 3, 2, 3] >>> reorganize_sequence(5, [1, 1, 1, 1, 1]) \\"Not Possible\\"","solution":"from collections import Counter import heapq def reorganize_sequence(n, a): Reorganizes sequence such that no two adjacent elements are equal if possible, otherwise returns 'Not Possible'. if n == 1: return a if a[0] < 2 else \\"Not Possible\\" counter = Counter(a) max_heap = [(-count, value) for value, count in counter.items()] heapq.heapify(max_heap) prev_count, prev_value = 0, None result = [] while max_heap: count, value = heapq.heappop(max_heap) count = -count result.append(value) if prev_count > 0: heapq.heappush(max_heap, (-prev_count, prev_value)) prev_count = count - 1 prev_value = value if len(result) != n: return \\"Not Possible\\" return result"},{"question":"def calculate_strip_lengths(k: int, folds: List[str]) -> Tuple[int, int]: Calculate the total length of the strip when fully unfolded and the length of the visible part after all the folds. >>> calculate_strip_lengths(3, ['U', 'D', 'U']) (8, 2) >>> calculate_strip_lengths(2, ['D', 'D']) (4, 1) >>> calculate_strip_lengths(1, ['U']) (2, 1) >>> calculate_strip_lengths(4, ['U', 'U', 'U', 'U']) (16, 1) >>> calculate_strip_lengths(5, ['D', 'D', 'U', 'D', 'U']) (32, 1)","solution":"def calculate_strip_lengths(k, folds): Calculate the total length of the strip when fully unfolded and the length of the visible part after all the folds. # Total length after k folds total_length = 2 ** k # Length of the visible part visible_length = 1 # Initially visible length after first fold for i in range(1, k): visible_length = (visible_length + 1) // 2 return total_length, visible_length"},{"question":"from typing import List, Tuple def rearrange_string(s: str, k: int) -> str: Rearrange the string 's' such that no two identical characters are adjacent. If possible, return the rearranged string, otherwise return \\"NO\\". :param s: The input string consisting of lowercase English letters. :param k: The maximum number of distinct characters allowed. :return: A valid rearranged string with no identical adjacent characters or \\"NO\\" if impossible. def process_test_cases(t: int, test_cases: List[Tuple[str, int]]) -> List[str]: Process multiple test cases and returns the results for each case. :param t: The number of test cases. :param test_cases: A list of tuples where each tuple contains a string and an integer k. :return: A list of results for each test case. from solution import process_test_cases def test_example_cases(): test_cases = [ ((\\"aabbcc\\", 2), \\"abcabc\\"), ((\\"aaab\\", 2), \\"NO\\"), ((\\"aabbcc\\", 3), \\"abcabc\\") ] for (s, k), expected in test_cases: result = process_test_cases(1, [(s, k)]) assert result[0] == expected def test_additional_cases(): # Test case with k=1 where the string should just be returned as is result = process_test_cases(1, [(\\"abcdef\\", 1)]) assert result == [\\"abcdef\\"] # Test case where there are not enough distinct characters to avoid repetition result = process_test_cases(1, [(\\"aaaa\\", 2)]) assert result == [\\"NO\\"] # Test cases with sufficiently long spaces between similar characters result = process_test_cases(1, [(\\"aabbccddeeff\\", 3)]) assert result == [\\"abcdefabcdef\\"] # Test case with string length 1 result = process_test_cases(1, [(\\"a\\", 2)]) assert result == [\\"a\\"] def test_edge_cases(): # Test edge case with maximum string length where rearrangement is still possible result = process_test_cases(1, [(\\"a\\"*500 + \\"b\\"*500, 2)]) assert result != [\\"NO\\"] # It should produce a valid rearrangement # Test edge case with maximum k result = process_test_cases(1, [(\\"abcdefghijklmnopqrstuvwxyz\\", 26)]) assert result != [\\"NO\\"] # It should be already ordered and valid","solution":"import heapq from collections import Counter, deque def rearrange_string(s, k): Rearrange the string 's' such that no two identical characters are adjacent. If possible, return the rearranged string, otherwise return \\"NO\\". if k == 1: return s letter_counts = Counter(s) max_heap = [(-count, letter) for letter, count in letter_counts.items()] heapq.heapify(max_heap) result = [] wait_queue = deque() while max_heap: count, letter = heapq.heappop(max_heap) result.append(letter) wait_queue.append((letter, count + 1)) if len(wait_queue) < k: continue front_letter, front_count = wait_queue.popleft() if front_count < 0: heapq.heappush(max_heap, (front_count, front_letter)) return ''.join(result) if len(result) == len(s) else \\"NO\\" def process_test_cases(t, test_cases): results = [] for s, k in test_cases: result = rearrange_string(s, k) results.append(result) return results # Sample usage: # Reading input (this part should be handled externally while using the function) input = [ (3, [ (\\"aabbcc\\", 2), (\\"aaab\\", 2), (\\"aabbcc\\", 3) ]) ] t, test_cases = input[0] print(process_test_cases(t, test_cases))"},{"question":"def min_moves_to_treasure(n: int, m: int, locations: List[Tuple[int, int]]) -> int: Determines the minimum number of moves required for the drone to reach the hidden treasure from the starting position (1, 1) on an n x n grid. Parameters: n - size of the grid (n x n) m - number of possible treasure locations locations - list of tuples representing coordinates of the m treasure locations Returns: Integer representing the minimum number of moves required. >>> min_moves_to_treasure(3, 2, [(3, 3), (2, 2)]) == 1 >>> min_moves_to_treasure(5, 1, [(4, 5)]) == 2","solution":"def min_moves_to_treasure(n, m, locations): Returns the minimum number of moves required for the drone to reach the hidden treasure from the starting position (1, 1) on an n x n grid. Parameters: n - size of the grid (n x n) m - number of possible treasure locations locations - list of tuples representing coordinates of the m treasure locations Returns: Integer representing the minimum number of moves required. min_moves = float('inf') for x, y in locations: dx, dy = abs(x - 1), abs(y - 1) if dx == dy or dx == 0 or dy == 0: min_moves = min(min_moves, 1) else: min_moves = min(min_moves, 2) return min_moves"},{"question":"def can_redistribute_jars(n: int, t: int, candies: List[int]) -> str: Determines if it's possible to make the number of candies in all jars equal by distributing candies within subarrays. :param n: Number of jars :param t: Size of subarray to choose :param candies: List of the number of candies in each jar :return: \\"YES\\" if redistribution is possible, otherwise \\"NO\\" >>> can_redistribute_jars(4, 2, [2, 4, 4, 2]) \\"YES\\" >>> can_redistribute_jars(4, 1, [2, 4, 4, 2]) \\"NO\\" >>> can_redistribute_jars(3, 3, [1, 2, 3]) \\"YES\\" >>> can_redistribute_jars(4, 2, [1, 1, 1, 1]) \\"YES\\" >>> can_redistribute_jars(5, 3, [1, 2, 1, 2, 2]) \\"NO\\" >>> can_redistribute_jars(5, 5, [5, 0, 5, 0, 0]) \\"YES\\"","solution":"def can_redistribute_jars(n, t, candies): Determines if it's possible to make the number of candies in all jars equal by distributing candies within subarrays. :param n: Number of jars :param t: Size of subarray to choose :param candies: List of the number of candies in each jar :return: \\"YES\\" if redistribution is possible, otherwise \\"NO\\" total_candies = sum(candies) # If the total number of candies is not divisible by n, it's impossible to redistribute equally if total_candies % n != 0: return \\"NO\\" target_candies = total_candies // n # Special case, if t == 1, we can only operate within single jar, which means redistribution is impossible if t == 1: return \\"YES\\" if len(set(candies)) == 1 else \\"NO\\" return \\"YES\\""},{"question":"def min_operations_to_make_beautiful(n: int, b: List[int]) -> int: This function returns the minimum number of operations needed to make the array beautiful. Example Usage: >>> min_operations_to_make_beautiful(5, [4, 7, 9, 1, 2]) 2 >>> min_operations_to_make_beautiful(4, [2, 4, 6, 8]) 0 >>> min_operations_to_make_beautiful(4, [1, 3, 5, 7]) 0 >>> min_operations_to_make_beautiful(6, [1, 2, 3, 4, 5, 10]) 3 >>> min_operations_to_make_beautiful(1, [2]) 0 >>> min_operations_to_make_beautiful(1, [1]) 0 >>> min_operations_to_make_beautiful(3, [1000000000, 999999999, 500000000]) 1","solution":"def min_operations_to_make_beautiful(n, b): This function returns the minimum number of operations needed to make the array beautiful. odd_count = sum(1 for x in b if x % 2 != 0) even_count = n - odd_count return min(odd_count, even_count) # Example usage print(min_operations_to_make_beautiful(5, [4, 7, 9, 1, 2])) # Output: 2"},{"question":"def total_temperature_adjustments(operations: List[str], max_compartments: int) -> int: Manage compartments to store ingredients and track the temperature adjustments. >>> total_temperature_adjustments([ '+ 1 20 30', 'adjust 1 25', '+ 2 50 40', '- 1', '+ 3 -10 0', 'adjust 3 -5', 'adjust 3 0' ], 3) 3 >>> total_temperature_adjustments([], 1) 0 >>> total_temperature_adjustments([ '+ 1 0 10', 'adjust 1 5', 'adjust 1 10' ], 1) 2 >>> total_temperature_adjustments([ '+ 1 0 10', '+ 2 20 10', 'adjust 1 5', 'adjust 1 10', 'adjust 2 15', 'adjust 2 10' ], 2) 4 >>> total_temperature_adjustments([ '+ 1 0 10', '+ 2 20 10', 'adjust 1 5', 'adjust 1 10', '- 2', 'adjust 2 15', 'adjust 2 10' ], 2) 2 pass","solution":"def total_temperature_adjustments(operations, max_compartments): compartments = {} adjustments = 0 for op in operations: parts = op.split() action = parts[0] if action == '+': id = int(parts[1]) if len(compartments) < max_compartments: initial_temp = int(parts[2]) target_temp = int(parts[3]) compartments[id] = {'initial_temp': initial_temp, 'current_temp': initial_temp, 'target_temp': target_temp, 'adjustments': 0} elif action == '-': id = int(parts[1]) if id in compartments: del compartments[id] elif action == 'adjust': id = int(parts[1]) if id in compartments: new_temp = int(parts[2]) compartments[id]['current_temp'] = new_temp compartments[id]['adjustments'] += 1 for id in compartments: comp = compartments[id] if comp['current_temp'] != comp['target_temp']: comp['adjustments'] += 1 for id in compartments: adjustments += compartments[id]['adjustments'] return adjustments n = 7 m = 3 operations = [ '+ 1 20 30', 'adjust 1 25', '+ 2 50 40', '- 1', '+ 3 -10 0', 'adjust 3 -5', 'adjust 3 0' ] print(total_temperature_adjustments(operations, m)) # Expected output: 3"},{"question":"def get_certified_participants(session_data: List[str], checkin_data: List[str]) -> List[str]: Determine which participants have attended all sessions and should receive a certificate. Args: session_data: List of strings where each string contains a session ID and the session's start and end time. checkin_data: List of strings where each string contains a session ID and a participant's email address. Returns: List of email addresses of participants who attended all sessions, in lexicographical order. >>> get_certified_participants([ ... \\"1 09:00-10:00\\", ... \\"2 10:30-11:30\\", ... \\"3 12:00-13:00\\" ... ], [ ... \\"1 john@example.com\\", ... \\"2 john@example.com\\", ... \\"3 john@example.com\\", ... \\"1 jane@example.com\\", ... \\"2 jane@example.com\\" ... ]) [\\"john@example.com\\"] >>> get_certified_participants([ ... \\"1 09:00-10:00\\", ... \\"2 10:30-11:30\\" ... ], []) [] >>> get_certified_participants([ ... \\"1 09:00-10:00\\", ... \\"2 10:30-11:30\\" ... ], [ ... \\"1 john@example.com\\", ... \\"2 john@example.com\\", ... \\"1 alice@example.com\\", ... \\"2 alice@example.com\\" ... ]) [\\"alice@example.com\\", \\"john@example.com\\"] >>> get_certified_participants([ ... \\"1 09:00-10:00\\", ... \\"2 10:30-11:30\\", ... \\"3 12:00-13:00\\" ... ], [ ... \\"1 john@example.com\\", ... \\"2 john@example.com\\", ... \\"1 alice@example.com\\", ... \\"2 alice@example.com\\", ... \\"3 alice@example.com\\", ... ]) [\\"alice@example.com\\"] >>> get_certified_participants([ ... \\"1 09:00-10:00\\", ... \\"2 10:30-11:30\\", ... \\"3 12:00-13:00\\" ... ], [ ... \\"1 john@example.com\\", ... \\"2 john@example.com\\", ... \\"3 john@example.com\\", ... \\"1 alice@example.com\\", ... \\"2 alice@example.com\\", ... \\"3 alice@example.com\\", ... \\"1 bob@example.com\\", ... \\"2 bob@example.com\\" ... ]) [\\"alice@example.com\\", \\"john@example.com\\"] pass","solution":"def get_certified_participants(session_data, checkin_data): sessions = {} checkins_by_email = {} # Read session data for session in session_data: session_id, time_period = session.split() sessions[session_id] = time_period # Read check-in data for checkin in checkin_data: session_id, email = checkin.split() if email not in checkins_by_email: checkins_by_email[email] = set() checkins_by_email[email].add(session_id) # Determine certified participants all_sessions_set = set(sessions.keys()) certified_participants = [ email for email, checked_sessions in checkins_by_email.items() if checked_sessions == all_sessions_set ] return sorted(certified_participants)"},{"question":"def max_increasing_subarray_length(n: int, arr: List[int]) -> int: Given an array of positive integers, find the maximum length of a subarray that contains elements in increasing order. :param n: int, the length of the array :param arr: list of int, the elements of the array :return: int, the maximum length of an increasing subarray pass def process_test_cases(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Processes multiple test cases for finding the maximum length of an increasing subarray. :param test_cases: list of tuples, each containing (n, arr) :return: list of int, results for each test case pass # Test cases def test_max_increasing_subarray_length(): assert max_increasing_subarray_length(6, [1, 2, 1, 2, 3, 4]) == 4 assert max_increasing_subarray_length(5, [5, 4, 3, 2, 1]) == 1 assert max_increasing_subarray_length(8, [1, 3, 5, 2, 4, 6, 7, 8]) == 5 assert max_increasing_subarray_length(1, [1]) == 1 assert max_increasing_subarray_length(3, [1, 2, 3]) == 3 def test_process_test_cases(): test_cases = [ (6, [1, 2, 1, 2, 3, 4]), (5, [5, 4, 3, 2, 1]), (8, [1, 3, 5, 2, 4, 6, 7, 8]) ] assert process_test_cases(test_cases) == [4, 1, 5] test_cases = [ (1, [1]), (3, [1, 2, 3]), (4, [4, 3, 2, 1]) ] assert process_test_cases(test_cases) == [1, 3, 1]","solution":"def max_increasing_subarray_length(n, arr): Given an array of positive integers, find the maximum length of a subarray that contains elements in increasing order. :param n: int, the length of the array :param arr: list of int, the elements of the array :return: int, the maximum length of an increasing subarray if n == 0: return 0 max_length = 1 current_length = 1 for i in range(1, n): if arr[i] > arr[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length def process_test_cases(test_cases): Processes multiple test cases for finding the maximum length of an increasing subarray. :param test_cases: list of tuples, each containing (n, arr) :return: list of int, results for each test case results = [] for n, arr in test_cases: results.append(max_increasing_subarray_length(n, arr)) return results"},{"question":"def min_operations_to_equalize_towers(n: int, towers: List[int]) -> int: Calculate the minimum number of operations required to make all tower heights equal. Parameters: n (int): The number of towers. towers (list of int): List of integers representing the heights of the towers. Returns: int: The minimum number of operations required to make all tower heights equal. >>> min_operations_to_equalize_towers(4, [1, 2, 3, 4]) 4 >>> min_operations_to_equalize_towers(3, [1, 1, 1]) 0 >>> min_operations_to_equalize_towers(5, [3, 7, 5, 6, 4]) 6","solution":"def min_operations_to_equalize_towers(n, towers): Calculate the minimum number of operations required to make all tower heights equal. Parameters: n (int): The number of towers. towers (list of int): List of integers representing the heights of the towers. Returns: int: The minimum number of operations required to make all tower heights equal. # Calculate the mean height (round it down) target_height = int(sum(towers) / n) # Calculate the number of operations to make all towers equal to the target height operations = sum(abs(h - target_height) for h in towers) return operations"},{"question":"def minimum_cost_to_equal_elements(arr): Determines the minimum cost to make all elements in the array equal and the value to which all elements should be changed. >>> minimum_cost_to_equal_elements([1, 3, 2]) (2, 2) >>> minimum_cost_to_equal_elements([5, 5, 5, 5]) (0, 5) >>> minimum_cost_to_equal_elements([10]) (0, 10) >>> minimum_cost_to_equal_elements([1000000000, 1000000000, 1000000000]) (0, 1000000000) >>> minimum_cost_to_equal_elements([1, 2, 3, 4, 5]) (6, 3) >>> minimum_cost_to_equal_elements([1, 2, 3, 4]) (4, 3)","solution":"def minimum_cost_to_equal_elements(arr): Determines the minimum cost to make all elements in the array equal and the value to which all elements should be changed. arr.sort() n = len(arr) median = arr[n // 2] # Using median minimizes the total cost in linear distance # Calculate the total cost to convert all elements to the median value total_cost = sum(abs(x - median) for x in arr) return total_cost, median"},{"question":"def find_peak_hour(n: int, timestamps: List[str]) -> str: Finds the hour during which the security code was entered the most number of times. :param n: Number of entries in the log. :param timestamps: List of n timestamps in the format \\"hh:mm:ss\\". :return: The hour \\"hh\\" during which the code was most likely entered the most number of times. pass # Example usage: n = 6 timestamps = [ \\"15:22:45\\", \\"15:35:50\\", \\"16:01:12\\", \\"16:15:22\\", \\"17:00:01\\", \\"17:45:30\\" ] print(find_peak_hour(n, timestamps)) # Expected Output: 16 from solution import find_peak_hour def test_single_entry(): assert find_peak_hour(1, [\\"12:45:56\\"]) == \\"12\\" def test_multiple_entries_single_peak(): assert find_peak_hour(3, [\\"09:15:23\\", \\"09:45:12\\", \\"10:05:45\\"]) == \\"09\\" def test_multiple_entries_multiple_peaks(): assert find_peak_hour(5, [\\"08:00:00\\", \\"09:15:23\\", \\"09:45:12\\", \\"10:05:45\\", \\"09:55:00\\"]) == \\"09\\" def test_entries_with_same_peak_hour(): assert find_peak_hour(7, [\\"05:12:45\\", \\"05:32:30\\", \\"05:59:59\\", \\"06:00:00\\", \\"06:01:01\\", \\"06:02:02\\", \\"06:03:03\\"]) == \\"06\\" def test_entries_peaks_tied(): assert find_peak_hour(6, [\\"14:01:22\\", \\"15:14:45\\", \\"14:23:10\\", \\"15:30:00\\", \\"16:00:20\\", \\"15:45:50\\"]) == \\"15\\"","solution":"def find_peak_hour(n, timestamps): Finds the hour during which the security code was entered the most number of times. :param n: Number of entries in the log. :param timestamps: List of n timestamps in the format \\"hh:mm:ss\\". :return: The hour \\"hh\\" during which the code was most likely entered the most number of times. hours_count = {} for timestamp in timestamps: hour = timestamp[:2] if hour in hours_count: hours_count[hour] += 1 else: hours_count[hour] = 1 max_entries = max(hours_count.values()) peak_hours = [hour for hour, count in hours_count.items() if count == max_entries] return min(peak_hours) # Example usage: n = 6 timestamps = [ \\"15:22:45\\", \\"15:35:50\\", \\"16:01:12\\", \\"16:15:22\\", \\"17:00:01\\", \\"17:45:30\\" ] print(find_peak_hour(n, timestamps)) # Output: 16"},{"question":"from typing import List, Tuple def shortest_path(n: int, m: int, blocked_positions: List[Tuple[int, int]]) -> int: Returns the length of the shortest path from (1, 1) to (n, m) or -1 if no such path exists. def solve_maze(t: int, test_cases: List[Tuple[int, int, int, List[Tuple[int, int]]]]) -> List[int]: Solves multiple test cases and returns the results. results = [] # Test cases using pytest def test_shortest_path(): assert shortest_path(3, 3, [(2,2)]) == 4 assert shortest_path(3, 3, [(1,2), (2,1)]) == -1 assert shortest_path(3, 3, []) == 4 assert shortest_path(1, 1, []) == 0 assert shortest_path(2, 2, [(1,1)]) == -1 assert shortest_path(2, 2, [(1,2), (2,2)]) == -1 def test_solve_maze(): test_cases_input = [ (3, 3, 1, [(2, 2)]), (3, 3, 2, [(1, 2), (2, 1)]), (1, 1, 0, []) ] expected_output = [4, -1, 0] assert solve_maze(3, test_cases_input) == expected_output","solution":"from collections import deque def shortest_path(n, m, blocked_positions): Returns the length of the shortest path from (1, 1) to (n, m) or -1 if no such path exists. grid = [[0] * m for _ in range(n)] for x, y in blocked_positions: grid[x - 1][y - 1] = 1 if grid[0][0] == 1 or grid[n-1][m-1] == 1: return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) visited = set((0, 0)) while queue: x, y, distance = queue.popleft() if x == n - 1 and y == m - 1: return distance for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] == 0: visited.add((nx, ny)) queue.append((nx, ny, distance + 1)) return -1 def solve_maze(t, test_cases): Solves multiple test cases and returns the results. results = [] for n, m, k, blocked_positions in test_cases: results.append(shortest_path(n, m, blocked_positions)) return results"},{"question":"def min_left_rotations_to_sort(arr: List[int]) -> int: Given an array of integers \`a\` where the array is initially sorted but has since been rotated an unknown number of times, find the minimum number of left rotations needed to return the array to its original sorted order. >>> min_left_rotations_to_sort([3, 4, 5, 1, 2]) 3 >>> min_left_rotations_to_sort([4, 5, 6, 1, 2, 3]) 3 >>> min_left_rotations_to_sort([1, 2, 3, 4]) 0 pass def test_sorted_array(): assert min_left_rotations_to_sort([1, 2, 3, 4]) == 0 def test_rotated_once(): assert min_left_rotations_to_sort([4, 1, 2, 3]) == 1 def test_rotated_twice(): assert min_left_rotations_to_sort([3, 4, 1, 2]) == 2 def test_rotated_thrice(): assert min_left_rotations_to_sort([2, 3, 4, 1]) == 3 def test_rotated_four_times(): assert min_left_rotations_to_sort([1, 2, 3, 4]) == 0 def test_rotated_five_times(): assert min_left_rotations_to_sort([4, 5, 6, 1, 2, 3]) == 3","solution":"def min_left_rotations_to_sort(arr): This function returns the minimum number of left rotations needed to return a rotated sorted array to its original sorted order. n = len(arr) # iterate through the array to determine the point where the array becomes unsorted for i in range(n - 1): if arr[i] > arr[i + 1]: return i + 1 # if the array is already sorted, 0 rotations are needed return 0"},{"question":"def handle_operations(n: int, q: int, fruits: List[int], operations: List[Tuple[int, ...]]) -> List[int]: Handle operations to add a certain number of fruits to a specific tree or query the number of fruits present on a specific tree. Args: n (int): Number of trees. q (int): Number of operations. fruits (List[int]): Initial number of fruits on each tree. operations (List[Tuple[int, ...]]): List of operations. Returns: List[int]: Results of the query operations. Example: >>> handle_operations(5, 3, [10, 20, 30, 40, 50], [(2, 3), (1, 2, 5), (2, 2)]) [30, 25] >>> handle_operations(5, 4, [1, 2, 3, 4, 5], [(1, 1, 10), (2, 1), (2, 5), (1, 5, 5)]) [11, 5] Test Cases: >>> handle_operations(3, 2, [100, 200, 300], [(2, 2), (1, 3, 50)]) [200] >>> handle_operations(4, 3, [15, 30, 45, 60], [(1, 4, 10), (2, 4), (2, 1)]) [70, 15]","solution":"def handle_operations(n, q, fruits, operations): result = [] for operation in operations: if operation[0] == 1: # Add operation x, y = operation[1] - 1, operation[2] fruits[x] += y elif operation[0] == 2: # Query operation x = operation[1] - 1 result.append(fruits[x]) return result"},{"question":"def maximum_cakes(n: int, m: int, participants: List[List[int]]) -> int: Determine the maximum number of cakes that can be baked such that each participant bakes exactly one cake from their favorites. Args: n (int): The number of cakes. m (int): The number of participants. participants (List[List[int]]): Each participant's favorite cakes. Returns: int: The maximum number of cakes that can be baked. >>> maximum_cakes(5, 3, [[1, 2], [1, 3, 4], [4, 5]]) 3 >>> maximum_cakes(4, 3, [[1, 2], [2, 3], [3, 4]]) 3 >>> maximum_cakes(5, 2, [[1, 2, 3, 4, 5], [1, 2, 3, 4, 5]]) 2 >>> maximum_cakes(1, 1, [[1]]) 1 >>> maximum_cakes(2, 2, [[1], [2]]) 2 >>> maximum_cakes(3, 3, [[1], [1, 2], [2, 3]]) 3 >>> maximum_cakes(3, 3, [[1], [1], [1]]) 1 >>> maximum_cakes(5, 5, [[1], [2], [3], [4], [5]]) 5","solution":"def maximum_cakes(n, m, participants): from collections import defaultdict import queue def bpm(u, matchR, seen): for v in graph[u]: if not seen[v]: seen[v] = True if matchR[v] == -1 or bpm(matchR[v], matchR, seen): matchR[v] = u return True return False graph = defaultdict(list) for i in range(m): for cake in participants[i]: graph[i].append(cake - 1) matchR = [-1] * n result = 0 for i in range(m): seen = [False] * n if bpm(i, matchR, seen): result += 1 return result"},{"question":"def is_special_customer(N: int, X: int, discounts: List[int]) -> str: Determine if there exist three non-overlapping flash sales such that their combined discount percentage is greater than X. :param N: Number of flash sales :param X: Target discount percentage :param discounts: List of discount percentages in each flash sale :return: \\"Special\\" if there exist three non-overlapping flash sales with combined discount > X, else \\"Not Special\\" >>> is_special_customer(5, 30, [5, 10, 15, 20, 25]) \\"Special\\" >>> is_special_customer(4, 50, [8, 12, 15, 10]) \\"Not Special\\" >>> is_special_customer(3, 20, [5, 10, 15]) \\"Special\\" >>> is_special_customer(6, 100, [5, 5, 5, 5, 5, 5]) \\"Not Special\\" >>> is_special_customer(6, 15, [1, 2, 3, 4, 5, 6]) \\"Not Special\\" >>> is_special_customer(6, 10, [1, 2, 3, 4, 5, 6]) \\"Special\\" from itertools import combinations for comb in combinations(discounts, 3): if sum(comb) > X: return \\"Special\\" return \\"Not Special\\"","solution":"def is_special_customer(N, X, discounts): Determine if there exist three non-overlapping flash sales such that their combined discount percentage is greater than X. from itertools import combinations for comb in combinations(discounts, 3): if sum(comb) > X: return \\"Special\\" return \\"Not Special\\" # Example usage: N, X = 5, 30 discounts = [5, 10, 15, 20, 25] print(is_special_customer(N, X, discounts)) # Output: Special N, X = 4, 50 discounts = [8, 12, 15, 10] print(is_special_customer(N, X, discounts)) # Output: Not Special"},{"question":"def is_valid_bijective_cipher(n: int, plaintext: str, ciphertext: str) -> str: Determine if the given plaintext and ciphertext strings form a valid bijective substitution cipher. Args: n : int : length of the strings plaintext : str : string of length n consisting of lowercase English letters (source text) ciphertext : str : string of length n consisting of lowercase English letters (substituted text) Returns: str : \\"YES\\" if they form a valid bijective substitution cipher, otherwise \\"NO\\". pass def test_valid_bijective_cipher_case1(): assert is_valid_bijective_cipher(6, \\"ababab\\", \\"cdcdcd\\") == \\"YES\\" def test_valid_bijective_cipher_case2(): assert is_valid_bijective_cipher(6, \\"abcdef\\", \\"ghijkl\\") == \\"YES\\" def test_invalid_bijective_cipher_case1(): assert is_valid_bijective_cipher(6, \\"aaaaaa\\", \\"abcdef\\") == \\"NO\\" def test_invalid_bijective_cipher_case2(): assert is_valid_bijective_cipher(5, \\"abcde\\", \\"aaaaa\\") == \\"NO\\" def test_invalid_bijective_cipher_case3(): assert is_valid_bijective_cipher(6, \\"abcabc\\", \\"abcdef\\") == \\"NO\\" def test_invalid_different_lengths(): assert is_valid_bijective_cipher(3, \\"abc\\", \\"abcd\\") == \\"NO\\" def test_valid_single_character(): assert is_valid_bijective_cipher(1, \\"a\\", \\"b\\") == \\"YES\\"","solution":"def is_valid_bijective_cipher(n, plaintext, ciphertext): Determine if the given plaintext and ciphertext strings form a valid bijective substitution cipher. Args: n : int : length of the strings plaintext : str : string of length n consisting of lowercase English letters (source text) ciphertext : str : string of length n consisting of lowercase English letters (substituted text) Returns: str : \\"YES\\" if they form a valid bijective substitution cipher, otherwise \\"NO\\". if n != len(plaintext) or n != len(ciphertext): return \\"NO\\" # Create the mapping dictionaries plain_to_cipher = {} cipher_to_plain = {} for p, c in zip(plaintext, ciphertext): if p in plain_to_cipher: # If 'p' is already mapped but not to 'c', then not bijective if plain_to_cipher[p] != c: return \\"NO\\" else: plain_to_cipher[p] = c if c in cipher_to_plain: # If 'c' is already mapped but not to 'p', then not bijective if cipher_to_plain[c] != p: return \\"NO\\" else: cipher_to_plain[c] = p # If all characters are bijectively mapped return \\"YES\\""},{"question":"def min_max_difference(n: int, scores: List[int]) -> int: Divides the students into groups such that the sum of scores in each group is as equal as possible, and returns the maximum difference between the sum of scores of any two groups. >>> min_max_difference(5, [1, 2, 3, 4, 5]) 1 >>> min_max_difference(1, [5]) 5 >>> min_max_difference(2, [10, 10]) 0 >>> min_max_difference(2, [12, 7]) 5 >>> min_max_difference(3, [1, 2, 3]) 0 >>> min_max_difference(4, [5, 5, 5, 5]) 0 >>> min_max_difference(3, [100, 200, 300]) 0 >>> min_max_difference(6, [10, 20, 30, 40, 50, 60]) 10","solution":"def min_max_difference(n, scores): total = sum(scores) dp = [0] * (total // 2 + 1) for score in scores: for j in range(total // 2, score - 1, -1): dp[j] = max(dp[j], dp[j - score] + score) return total - 2 * dp[total // 2] # Example usage: # n = 5 # scores = [1, 2, 3, 4, 5] # print(min_max_difference(n, scores)) # Should output 1"},{"question":"def merge_two_bsts(bst1, bst2): Merges two BSTs represented by their in-order traversals. Args: - bst1: List[int], in-order traversal of the first BST. - bst2: List[int], in-order traversal of the second BST. Returns: - List[int], in-order traversal of the merged BST. pass def solve(test_cases): Solves the problem for all test cases. Args: - test_cases: List[Tuple[int, int, List[int], List[int]]], where each element contains: - n: int, size of the first BST. - m: int, size of the second BST. - bst1: List[int], in-order traversal of the first BST. - bst2: List[int], in-order traversal of the second BST. Returns: - List[List[int]], each sublist is the in-order traversal of the merged BST for each test case. pass import pytest from solution import merge_two_bsts, solve def test_merge_two_bsts(): assert merge_two_bsts([1, 3, 5], [2, 4, 6]) == [1, 2, 3, 4, 5, 6] assert merge_two_bsts([1, 2], [3, 4, 5]) == [1, 2, 3, 4, 5] assert merge_two_bsts([1, 3], []) == [1, 3] assert merge_two_bsts([], [2, 4, 6]) == [2, 4, 6] def test_solve(): test_cases = [ (3, 3, [1, 3, 5], [2, 4, 6]), (2, 0, [1, 3], []), ] expected = [ [1, 2, 3, 4, 5, 6], [1, 3], ] assert solve(test_cases) == expected test_cases = [ (1, 1, [2], [1]), ] expected = [ [1, 2] ] assert solve(test_cases) == expected test_cases = [ (0, 0, [], []), ] expected = [ [] ] assert solve(test_cases) == expected def test_large_scale_merge(): bst1 = list(range(1, 100001)) bst2 = list(range(100001, 200001)) expected = list(range(1, 200001)) assert merge_two_bsts(bst1, bst2) == expected bst1 = list(range(1, 500001)) bst2 = list(range(500001, 1000001)) expected = list(range(1, 1000001)) assert merge_two_bsts(bst1, bst2) == expected if __name__ == \\"__main__\\": pytest.main()","solution":"def merge_two_bsts(bst1, bst2): Merges two BSTs represented by their in-order traversals. Args: - bst1: List[int], in-order traversal of the first BST. - bst2: List[int], in-order traversal of the second BST. Returns: - List[int], in-order traversal of the merged BST. merged = sorted(bst1 + bst2) return merged def solve(test_cases): Solves the problem for all test cases. Args: - test_cases: List[Tuple[int, int, List[int], List[int]]], where each element contains: - n: int, size of the first BST. - m: int, size of the second BST. - bst1: List[int], in-order traversal of the first BST. - bst2: List[int], in-order traversal of the second BST. Returns: - List[List[int]], each sublist is the in-order traversal of the merged BST for each test case. results = [] for n, m, bst1, bst2 in test_cases: merged_bst = merge_two_bsts(bst1, bst2) results.append(merged_bst) return results"},{"question":"def min_steps_to_reach_end(m: int, n: int) -> int: Calculate the minimum number of steps required for the robot to travel from bottom-left corner (m, 1) to top-right corner (1, n) of an m x n grid. This includes using the teleportation feature which counts as 1 step. Parameters: m (int): Number of rows in the grid. n (int): Number of columns in the grid. Returns: int: Minimum number of steps required. >>> min_steps_to_reach_end(3, 3) 1 >>> min_steps_to_reach_end(2, 2) 1 >>> min_steps_to_reach_end(1, 1) 1 >>> min_steps_to_reach_end(5, 7) 1 >>> min_steps_to_reach_end(1000, 1) 1 >>> min_steps_to_reach_end(1, 1000) 1","solution":"def min_steps_to_reach_end(m, n): Calculate the minimum number of steps required for the robot to travel from bottom-left corner (m, 1) to top-right corner (1, n) of an m x n grid. This includes using the teleportation feature which counts as 1 step. Parameters: m (int): Number of rows in the grid. n (int): Number of columns in the grid. Returns: int: Minimum number of steps required. # The robot can teleport directly to the end in one step. return 1"},{"question":"def minimum_swaps_for_increasing_order(n: int, heights: List[int]) -> int: Given an array of n integers representing the heights of people standing in a queue from left to right, find the minimum number of swaps required to make the heights of the people strictly increasing from left to right. If it is impossible to rearrange the queue to achieve strictly increasing order, return -1. Otherwise, return the minimum number of swaps required. >>> minimum_swaps_for_increasing_order(5, [1, 2, 3, 4, 5]) 0 >>> minimum_swaps_for_increasing_order(5, [1, 3, 2, 4, 5]) 1 >>> minimum_swaps_for_increasing_order(5, [5, 3, 8, 6, 2]) 2 >>> minimum_swaps_for_increasing_order(3, [3, 3, 3]) -1 >>> minimum_swaps_for_increasing_order(5, [5, 4, 3, 2, 1]) -1","solution":"def minimum_swaps_for_increasing_order(n, heights): if n < 3 or n > 10**5: return -1 # Identify misplacements (indexes where the heights are not in increasing order). misplaces = [] for i in range(1, n): if heights[i - 1] >= heights[i]: misplaces.append(i - 1) misplaces.append(i) misplaces = list(set(misplaces)) # If no misplaces were found, the array is already increasing. if not misplaces: return 0 # More than one misplaced element is an indication that more than two swaps might be needed. if len(misplaces) > 4: return -1 # Try to swap the elements directly for i in misplaces: for j in misplaces: if abs(i - j) == 1: new_heights = heights[:] new_heights[i], new_heights[j] = new_heights[j], new_heights[i] if all(new_heights[k] < new_heights[k + 1] for k in range(n-1)): return 1 return -1"},{"question":"def star_array_lengths(s: str) -> str: Determines the lengths of the longest contiguous subarrays of 0's and 1's. Parameters: s (str): A string of '0's and '1's. Returns: str: A space-separated string of lengths of contiguous subarrays. >>> star_array_lengths(\\"110001111000001\\") '2 3 4 5 1' >>> star_array_lengths(\\"0\\") '1' >>> star_array_lengths(\\"1\\") '1' >>> star_array_lengths(\\"0000\\") '4' >>> star_array_lengths(\\"1111\\") '4' >>> star_array_lengths(\\"01010101\\") '1 1 1 1 1 1 1 1' >>> star_array_lengths(\\"001100111000\\") '2 2 2 3 3' >>> star_array_lengths(\\"\\") ''","solution":"def star_array_lengths(s): Determines the lengths of the longest contiguous subarrays of 0's and 1's. Parameters: s (str): A string of '0's and '1's. Returns: str: A space-separated string of lengths of contiguous subarrays. if not s: return \\"\\" lengths = [] n = len(s) count = 1 for i in range(1, n): if s[i] == s[i - 1]: count += 1 else: lengths.append(str(count)) count = 1 lengths.append(str(count)) return \\" \\".join(lengths)"},{"question":"def calculate_wins(n, ratings): Calculate the number of matches each contestant wins based on their skill ratings. Parameters: n (int): Number of contestants ratings (list): List of integers representing the skill ratings of the contestants Returns: list: List of integers where the i-th integer is the number of matches won by the i-th contestant >>> calculate_wins(4, [4, 7, 9, 3]) [1, 2, 3, 0] >>> calculate_wins(3, [5, 5, 5]) [0, 0, 0] >>> calculate_wins(5, [1, 2, 3, 4, 5]) [0, 1, 2, 3, 4] >>> calculate_wins(5, [5, 4, 3, 2, 1]) [4, 3, 2, 1, 0] >>> calculate_wins(2, [2, 1]) [1, 0]","solution":"def calculate_wins(n, ratings): Calculate the number of matches each contestant wins based on their skill ratings. Parameters: n (int): Number of contestants ratings (list): List of integers representing the skill ratings of the contestants Returns: list: List of integers where the i-th integer is the number of matches won by the i-th contestant wins = [0] * n for i in range(n): for j in range(n): if i != j and ratings[i] > ratings[j]: wins[i] += 1 return wins"},{"question":"def max_subarray_sum(n: int, arr: List[int]) -> int: Returns the maximum sum of the subarrays that contain at least one element. >>> max_subarray_sum(9, [-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum(5, [-3, -1, -2, -4, -5]) -1 >>> max_subarray_sum(5, [1, 2, 3, 4, 5]) 15 >>> max_subarray_sum(1, [5]) 5 >>> max_subarray_sum(1, [-5]) -5 >>> max_subarray_sum(5, [0, -1, 2, -3, 4]) 4 >>> max_subarray_sum(1000, [i for i in range(1, 1001)]) 500500","solution":"def max_subarray_sum(n, arr): Returns the maximum sum of the subarrays that contain at least one element. if n == 0: return 0 current_sum = max_sum = arr[0] for num in arr[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def min_new_roads(n: int, m: int, roads: List[Tuple[int, int]]) -> int: Determine the minimum number of new roads needed to connect all regions in a kingdom. Args: n (int): Number of regions. m (int): Number of roads already built. roads (List[Tuple[int, int]]): List of tuples representing the roads. Returns: int: Minimum number of new roads needed to connect all regions. Example: >>> min_new_roads(6, 3, [(1, 2), (2, 3), (4, 5)]) 2 >>> min_new_roads(5, 0, []) 4","solution":"def min_new_roads(n, m, roads): from collections import defaultdict, deque def bfs(start, visited, adjacency_list): queue = deque([start]) visited[start] = True while queue: current = queue.popleft() for neighbor in adjacency_list[current]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) if n == 1: return 0 adjacency_list = defaultdict(list) for u, v in roads: adjacency_list[u].append(v) adjacency_list[v].append(u) visited = [False] * (n + 1) components = 0 for region in range(1, n + 1): if not visited[region]: bfs(region, visited, adjacency_list) components += 1 return components - 1"},{"question":"def min_operations_to_transform(str1: str, str2: str) -> int: Determine the minimum number of operations required to transform str1 into str2. Operations allowed are insertions, deletions, and replacements. >>> min_operations_to_transform(\\"kitten\\", \\"sitting\\") 3 >>> min_operations_to_transform(\\"flaw\\", \\"lawn\\") 2 >>> min_operations_to_transform(\\"intention\\", \\"execution\\") 5 >>> min_operations_to_transform(\\"same\\", \\"same\\") 0 >>> min_operations_to_transform(\\"\\", \\"abc\\") 3 >>> min_operations_to_transform(\\"abc\\", \\"\\") 3 >>> min_operations_to_transform(\\"\\", \\"\\") 0 >>> min_operations_to_transform(\\"a\\", \\"ab\\") 1 >>> min_operations_to_transform(\\"a\\", \\"b\\") 1","solution":"def min_operations_to_transform(str1: str, str2: str) -> int: Returns the minimum number of operations required to transform str1 into str2. Operations allowed are insertions, deletions, and replacements. m, n = len(str1), len(str2) # Create a DP table to store the minimal operations required to reach each position dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill the first row and column for i in range(m + 1): dp[i][0] = i for j in range(n + 1): dp[0][j] = j # Fill the rest of the DP table for i in range(1, m + 1): for j in range(1, n + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = min( dp[i - 1][j], # Deletion dp[i][j - 1], # Insertion dp[i - 1][j - 1] # Replacement ) + 1 return dp[m][n]"},{"question":"def warehouse_operations(n, quantities, m, operations): Perform a series of operations on an array of product quantities and return the results of max queries. >>> warehouse_operations(5, [1, 3, 5, 7, 9], 6, [\\"update 1 2\\", \\"max\\", \\"update 4 -3\\", \\"max\\", \\"update 3 10\\", \\"max\\"]) [9, 9, 15] >>> warehouse_operations(3, [10, 20, 30], 4, [\\"update 2 -5\\", \\"max\\", \\"update 1 10\\", \\"max\\"]) [30, 30]","solution":"def warehouse_operations(n, quantities, m, operations): Perform a series of operations on an array of product quantities and return the results of max queries. :param n: Number of product lines. :param quantities: List of initial quantities of the products. :param m: Number of operations. :param operations: List of operations to be performed. :return: List of results for each 'max' operation. results = [] for operation in operations: if operation.startswith('update'): _, i, x = operation.split() i = int(i) - 1 # Convert to zero-based index x = int(x) quantities[i] += x elif operation == 'max': results.append(max(quantities)) return results"},{"question":"def largest_square_submatrix(n: int, m: int, matrix: List[str]) -> int: Determines the size of the largest square submatrix where all letters are the same. n: number of rows m: number of columns matrix: list of strings representing the matrix Returns an integer representing the size of the largest square submatrix. >>> largest_square_submatrix(4, 5, [\\"aabbb\\", \\"aabbb\\", \\"aabbb\\", \\"ccccc\\"]) == 3 >>> largest_square_submatrix(3, 3, [\\"abc\\", \\"def\\", \\"ghi\\"]) == 1 >>> largest_square_submatrix(1, 5, [\\"aaaaa\\"]) == 1 >>> largest_square_submatrix(5, 1, [\\"a\\", \\"a\\", \\"a\\", \\"a\\", \\"a\\"]) == 1 >>> largest_square_submatrix(2, 2, [\\"aa\\", \\"aa\\"]) == 2 >>> largest_square_submatrix(4, 5, [\\"ababa\\", \\"babab\\", \\"ababa\\", \\"babab\\"]) == 1","solution":"def largest_square_submatrix(n, m, matrix): Determines the size of the largest square submatrix where all letters are the same. n: number of rows m: number of columns matrix: list of strings representing the matrix Returns an integer representing the size of the largest square submatrix. if n == 0 or m == 0: return 0 max_size = 1 dp = [[1] * m for _ in range(n)] for i in range(1, n): for j in range(1, m): if matrix[i][j] == matrix[i-1][j] == matrix[i][j-1] == matrix[i-1][j-1]: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_size = max(max_size, dp[i][j]) return max_size"},{"question":"from typing import List, Tuple def generate_ranking(n: int, k: int, contestants: List[Tuple[int, str]]) -> List[str]: Given the number of contestants and the number of required top positions, generate a ranking list that ensures at least one contestant from each region in the top k positions. Args: n (int): The number of contestants. k (int): The required number of top positions. contestants (List[Tuple[int, str]]): A list of tuples, each containing a contestant's score and region. Returns: List[str]: The list of contestants' regions in the final ranking order or \\"Impossible\\" if the ranking cannot be achieved. >>> generate_ranking(5, 3, [(500, 'North'), (700, 'East'), (600, 'West'), (800, 'North'), (400, 'South')]) ['East', 'North', 'West', 'South', 'North'] >>> generate_ranking(4, 5, [(500, 'East'), (600, 'West'), (700, 'North'), (400, 'South')]) 'Impossible'","solution":"def generate_ranking(n, k, contestants): from collections import defaultdict # Dictionary to track the best contestant from each region region_best = defaultdict(lambda: float('-inf')) all_contestants = [] # Parse the input contestants details for score, region in contestants: all_contestants.append((score, region)) region_best[region] = max(region_best[region], score) # Initial filter to have at least one contestant from each region top_regions = sorted(region_best.items(), key=lambda x: -x[1]) if len(top_regions) < k: return \\"Impossible\\" # Select top k regions with their best scores selected_regions = [region for _, region in top_regions[:k]] # Final sorting of all contestants by score in descending order sorted_contestants = sorted(all_contestants, key=lambda x: -x[0]) final_ranking = [] region_included = set() for score, region in sorted_contestants: if len(final_ranking) < k: if region not in region_included: final_ranking.append((score, region)) region_included.add(region) else: final_ranking.append((score, region)) # Check if we included k different regions in the top k positions if len(region_included) >= k: final_list = [region for _, region in final_ranking] return final_list else: return \\"Impossible\\""},{"question":"def count_palindromic_substrings(s: str) -> int: Returns the number of palindromic substrings in the given string \`s\`. >>> count_palindromic_substrings(\\"abc\\") 3 >>> count_palindromic_substrings(\\"aaa\\") 6 >>> count_palindromic_substrings(\\"aba\\") 4 >>> count_palindromic_substrings(\\"abba\\") 6 >>> count_palindromic_substrings(\\"racecar\\") 10 >>> count_palindromic_substrings(\\"abcdefgh\\") 8 >>> count_palindromic_substrings(\\"\\") 0","solution":"def count_palindromic_substrings(s): Returns the number of palindromic substrings in the given string \`s\`. n = len(s) count = 0 def expand_around_center(left, right): nonlocal count while left >= 0 and right < n and s[left] == s[right]: count += 1 left -= 1 right += 1 for i in range(n): # Odd length palindromes expand_around_center(i, i) # Even length palindromes expand_around_center(i, i + 1) return count"},{"question":"def is_valid_guess(n: int, a: List[int], m: int, b: List[int]) -> str: Returns 'YES' if the sequence b is a valid guess for sequence a, otherwise returns 'NO'. >>> is_valid_guess(5, [2, 3, 3, 5, 7], 3, [3, 5, 7]) \\"YES\\" >>> is_valid_guess(5, [1, 2, 3, 6, 6], 3, [2, 6, 6]) \\"YES\\" >>> is_valid_guess(5, [4, 12, 7, 9, 11], 2, [3, 7]) \\"NO\\"","solution":"def is_valid_guess(n, a, m, b): Returns 'YES' if the sequence b is a valid guess for sequence a, otherwise returns 'NO'. j = 0 # pointer for sequence a for i in range(m): while j < n and a[j] != b[i]: j += 1 if j == n: return \\"NO\\" j += 1 return \\"YES\\""},{"question":"def subarray_sum_exists(arr, target): Determines if there exists a subarray with a sum equal to the target. Parameters: arr (list of int): The input array. target (int): The target sum. Returns: str: \\"YES\\" if such a subarray exists, otherwise \\"NO\\". >>> subarray_sum_exists([1, 2, 3, 4, 5], 9) \\"YES\\" >>> subarray_sum_exists([10, -2, 3, -1, 10], 50) \\"NO\\" >>> subarray_sum_exists([1], 1) \\"YES\\" >>> subarray_sum_exists([1], -1) \\"NO\\" >>> subarray_sum_exists([3, 3, 3], 3) \\"YES\\" >>> subarray_sum_exists([], 0) \\"NO\\" >>> subarray_sum_exists([1000000000, -1000000000, 1000000000], 1000000000) \\"YES\\"","solution":"def subarray_sum_exists(arr, target): Determines if there exists a subarray with a sum equal to the target. Parameters: arr (list of int): The input array. target (int): The target sum. Returns: str: \\"YES\\" if such a subarray exists, otherwise \\"NO\\". n = len(arr) prefix_sum_map = {} current_sum = 0 for i in range(n): current_sum += arr[i] # Check if the current prefix sum equals the target if current_sum == target: return \\"YES\\" # Check if there is a prefix sum such that current_sum - prefix_sum = target if (current_sum - target) in prefix_sum_map: return \\"YES\\" # Save the current prefix sum and its index prefix_sum_map[current_sum] = i return \\"NO\\""},{"question":"from typing import List, Tuple def max_final_element(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: You are given an array a of n integers. You need to select exactly two distinct elements from the array and remove them. After that, you will replace these two elements with their sum. This operation can be repeated as many times as desired until only one element remains in the array. Your task is to determine the maximum possible value of the final remaining element in the array after performing the operations optimally. Args: t (int): the number of test cases. test_cases (List[Tuple[int, List[int]]]): each test case contains an integer n and a list of n integers. Returns: List[int]: the maximum possible value of the final remaining element for each test case. Examples: >>> max_final_element(3, [(4, [1, 2, 2, 3]), (3, [5, 5, 5]), (5, [1, 1, 1, 1, 1])]) [8, 15, 5]","solution":"def max_final_element(t, test_cases): results = [] for i in range(t): n, arr = test_cases[i] results.append(sum(arr)) return results # Example usage for the function t = 3 test_cases = [ (4, [1, 2, 2, 3]), (3, [5, 5, 5]), (5, [1, 1, 1, 1, 1]) ] print(max_final_element(t, test_cases)) # Expected output: [8, 15, 5]"},{"question":"def find_valid_combination(n, m, constraints): Determine if it is possible to set the dials to values that satisfy all the constraints. Args: n: int - The number of dials. m: int - The number of constraints. constraints: List[Tuple[int, int, int]] - The list of constraints where the sum of the values on the dials a and b must be equal to s. Returns: - If there exists a valid combination, return it as a space-separated sequence of integers from 1 to 10. - If no valid combination exists, return \\"Impossible\\". >>> find_valid_combination(3, 0, []) [1, 1, 1] >>> find_valid_combination(3, 1, [(1, 2, 3)]) [1, 2, 1] >>> find_valid_combination(3, 1, [(1, 2, 21)]) \\"Impossible\\" >>> find_valid_combination(3, 2, [(1, 2, 4), (2, 3, 5)]) [1, 3, 2] >>> find_valid_combination(3, 3, [(1, 2, 4), (2, 3, 5), (1, 3, 10)]) \\"Impossible\\"","solution":"def find_valid_combination(n, m, constraints): from itertools import product dials = range(1, 11) # Iterate through all possible combinations of dial settings for combination in product(dials, repeat=n): valid = True for a, b, s in constraints: if combination[a-1] + combination[b-1] != s: valid = False break if valid: return combination return \\"Impossible\\""},{"question":"def min_operations_to_non_decreasing(n, sequence): Computes the minimum number of operations needed to make the sequence non-decreasing. Parameters: n (int): the number of elements in the sequence. sequence (list): a list of integers representing the sequence. Returns: int: the minimum number of operations. Examples: >>> min_operations_to_non_decreasing(5, [4, 2, 5, 3, 5]) 4 >>> min_operations_to_non_decreasing(4, [1, 2, 3, 4]) 0 >>> min_operations_to_non_decreasing(3, [10, 1, 10]) 9","solution":"def min_operations_to_non_decreasing(n, sequence): Computes the minimum number of operations needed to make the sequence non-decreasing. Parameters: n (int): the number of elements in the sequence. sequence (list): a list of integers representing the sequence. Returns: int: the minimum number of operations. operations = 0 for i in range(1, n): if sequence[i] < sequence[i - 1]: operations += sequence[i - 1] - sequence[i] sequence[i] = sequence[i - 1] return operations"},{"question":"def largest_square_subgrid(m: int, n: int, grid: List[List[int]]) -> int: Returns the size of the largest square sub-grid that contains only '1's. >>> largest_square_subgrid(4, 5, [ ... [1, 1, 0, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 1, 1, 0, 0], ... [0, 1, 1, 1, 1] ... ]) 2 >>> largest_square_subgrid(3, 3, [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) 0 >>> largest_square_subgrid(1, 1, [ ... [1] ... ]) 1 >>> largest_square_subgrid(1, 1, [ ... [0] ... ]) 0 >>> largest_square_subgrid(4, 4, [ ... [1, 0, 1, 1], ... [1, 1, 1, 1], ... [1, 1, 0, 0], ... [1, 1, 1, 1] ... ]) 2","solution":"def largest_square_subgrid(m, n, grid): Returns the size of the largest square sub-grid that contains only '1's. Parameters: m (int): The number of rows in the grid. n (int): The number of columns in the grid. grid (List[List[int]]): The grid itself with 0s and 1s. if not grid or m == 0 or n == 0: return 0 # Create a dp array with the same dimensions as grid dp = [[0] * n for _ in range(m)] max_square_len = 0 for i in range(m): for j in range(n): if grid[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 # Base case: edges of the grid else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_square_len = max(max_square_len, dp[i][j]) return max_square_len"},{"question":"from typing import List def find_min_index(n: int, a: List[int], x: int) -> int: Determine the smallest index of an element in a sorted array that is greater than or equal to a given value x. If no such element exists, return -1. >>> find_min_index(5, [1, 2, 4, 5, 6], 3) 2 >>> find_min_index(4, [1, 2, 3, 4], 10) -1 >>> find_min_index(6, [1, 3, 3, 3, 5, 6], 3) 1 >>> find_min_index(6, [1, 3, 3, 3, 5, 6], 4) 4 >>> find_min_index(6, [1, 2, 2, 2, 2, 2], 3) -1 >>> find_min_index(1, [1], 1) 0 >>> find_min_index(1, [1], 2) -1 pass def process_test_cases(test_cases: List[tuple]) -> List[int]: Process a list of test cases to determine the smallest index of an element that is greater than or equal to given values. >>> test_cases = [ ... (5, 3, [1, 2, 4, 5, 6]), ... (4, 10, [1, 2, 3, 4]), ... (6, 3, [1, 3, 3, 3, 5, 6]), ... (6, 4, [1, 3, 3, 3, 5, 6]), ... (6, 3, [1, 2, 2, 2, 2, 2]), ... (1, 1, [1]), ... (1, 2, [1]), ... ] >>> expected_results = [2, -1, 1, 4, -1, 0, -1] >>> process_test_cases(test_cases) [2, -1, 1, 4, -1, 0, -1] pass","solution":"from typing import List def find_min_index(n: int, a: List[int], x: int) -> int: left, right = 0, n - 1 result = -1 while left <= right: mid = (left + right) // 2 if a[mid] >= x: result = mid right = mid - 1 else: left = mid + 1 return result def process_test_cases(test_cases: List[tuple]) -> List[int]: results = [] for n, x, arr in test_cases: results.append(find_min_index(n, arr, x)) return results"},{"question":"def longest_subsequence_length(n: int, a: List[int]) -> int: Finds the length of the longest subsequence such that all elements are distinct and the difference between each consecutive element is either 0 or 1. >>> longest_subsequence_length(7, [1, 2, 2, 3, 4, 5, 3]) 5 >>> longest_subsequence_length(1, [1]) 1 >>> longest_subsequence_length(5, [5, 5, 5, 5, 5]) 1 >>> longest_subsequence_length(10, [1, 2, 3, 4, 3, 2, 1, 5, 6, 7]) 7 >>> longest_subsequence_length(4, [1000000000, 999999999, 999999998, 999999997]) 4 >>> longest_subsequence_length(8, [8, 1, 7, 5, 6, 2, 4, 3]) 8 >>> longest_subsequence_length(5, [10, 30, 20, 40, 50]) 1 >>> longest_subsequence_length(4, [4, 3, 2, 1]) 4","solution":"def longest_subsequence_length(n, a): Finds the length of the longest subsequence such that all elements are distinct and the difference between each consecutive element is either 0 or 1. a_sorted = sorted(set(a)) max_length = 1 current_length = 1 for i in range(1, len(a_sorted)): if a_sorted[i] == a_sorted[i-1] + 1: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 max_length = max(max_length, current_length) return max_length"},{"question":"from typing import List def is_valid_password(password: str) -> str: Check if a password is valid based on predefined criteria. >>> is_valid_password(\\"aB1\\") 'Valid' >>> is_valid_password(\\"abcdefgh\\") 'Invalid' >>> is_valid_password(\\"ABCDEFGH\\") 'Invalid' >>> is_valid_password(\\"12345678\\") 'Invalid' >>> is_valid_password(\\"aB3defGh\\") 'Valid' >>> is_valid_password(\\"aB1\\") 'Invalid' >>> is_valid_password(\\"\\") 'Invalid' >>> is_valid_password(\\"aB1\\" + \\"a\\" * 97) 'Valid' >>> is_valid_password(\\"aB1\\" + \\"a\\" * 98) 'Invalid' # Your code here def validate_passwords(passwords: List[str]) -> List[str]: Given a list of passwords, determine which are valid. >>> validate_passwords([\\"aB1\\", \\"abcdefgh\\", \\"ABCDEFGH\\", \\"12345678\\", \\"aB3defGh\\"]) ['Valid', 'Invalid', 'Invalid', 'Invalid', 'Valid'] >>> validate_passwords([\\"aB1\\", \\"validPASS1\\", \\"NoDigitsHere\\", \\"1234567890\\", \\"validPass1\\"]) ['Invalid', 'Valid', 'Invalid', 'Invalid', 'Valid'] >>> validate_passwords([\\"aB1\\", \\"A1a\\", \\"1Aa\\", \\"short\\", \\"LONGUPPERCASE123\\"]) ['Valid', 'Valid', 'Valid', 'Invalid', 'Invalid'] # Your code here","solution":"def is_valid_password(password): Check if a password is valid based on predefined criteria. if len(password) < 1 or len(password) > 100: return \\"Invalid\\" has_upper = False has_lower = False has_digit = False for char in password: if char.isupper(): has_upper = True elif char.islower(): has_lower = True elif char.isdigit(): has_digit = True elif not char.isalnum(): return \\"Invalid\\" if has_upper and has_lower and has_digit: return \\"Valid\\" return \\"Invalid\\" def validate_passwords(passwords): Given a list of passwords, determine which are valid. results = [] for password in passwords: results.append(is_valid_password(password)) return results"},{"question":"def can_partition_into_two_subsequences(n: int, sequence: List[int]) -> str: Determines whether it's possible to partition the sequence into two non-empty subsequences such that the sum of the elements in the first subsequence is greater than the sum of the elements in the second subsequence. >>> can_partition_into_two_subsequences(5, [3, 1, 4, 2, 2]) == \\"YES\\" >>> can_partition_into_two_subsequences(3, [10, 1, 1]) == \\"YES\\" >>> can_partition_into_two_subsequences(4, [2, 2, 2, 2]) == \\"NO\\"","solution":"def can_partition_into_two_subsequences(n, sequence): Determines whether it's possible to partition the sequence into two non-empty subsequences such that the sum of the elements in the first subsequence is greater than the sum of the elements in the second subsequence. total_sum = sum(sequence) max_element = max(sequence) # If the largest element is strictly more than half the total sum, # it guarantees a partition. if max_element > total_sum - max_element: return \\"YES\\" # Otherwise, partition is always possible if there are at least two distinct elements return \\"YES\\" if len(set(sequence)) > 1 else \\"NO\\""},{"question":"def sieve_of_eratosthenes(limit): Generate a list of prime numbers up to the given limit using the Sieve of Eratosthenes algorithm. >>> sieve_of_eratosthenes(10) [2, 3, 5, 7] >>> sieve_of_eratosthenes(20) [2, 3, 5, 7, 11, 13, 17, 19] pass def distinct_prime_factors_sum(number, primes): Calculate the sum of distinct prime factors for a given number. >>> primes = sieve_of_eratosthenes(100) >>> distinct_prime_factors_sum(18, primes) 5 >>> distinct_prime_factors_sum(13, primes) 13 pass def smallest_integer_with_smallest_sdpfs(numbers): Find the smallest integer with the smallest Sum of Distinct Prime Factors (SDPF). >>> smallest_integer_with_smallest_sdpfs([18]) 18 >>> smallest_integer_with_smallest_sdpfs([2, 3, 5, 7, 11]) 2 >>> smallest_integer_with_smallest_sdpfs([10, 14, 21, 22]) 10 >>> smallest_integer_with_smallest_sdpfs([6, 15, 35, 77]) 6 pass","solution":"def sieve_of_eratosthenes(limit): primes = [] is_prime = [True] * (limit + 1) is_prime[0] = is_prime[1] = False for num in range(2, limit + 1): if is_prime[num]: primes.append(num) for multiple in range(num * num, limit + 1, num): is_prime[multiple] = False return primes def distinct_prime_factors_sum(number, primes): original_number = number sum_factors = 0 for prime in primes: if prime * prime > number: break if number % prime == 0: sum_factors += prime while number % prime == 0: number //= prime if number > 1: sum_factors += number return sum_factors def smallest_integer_with_smallest_sdpfs(numbers): limit = max(numbers) primes = sieve_of_eratosthenes(limit) min_sdpfs = float('inf') result = None for number in numbers: sdpfs = distinct_prime_factors_sum(number, primes) if (sdpfs < min_sdpfs) or (sdpfs == min_sdpfs and number < result): min_sdpfs = sdpfs result = number return result"},{"question":"def can_redistribute_books(n: int, k: int, books: List[int]) -> bool: Determines if it's possible to redistribute books so that no compartment exceeds the threshold k :param n: The number of compartments :param k: The maximum allowed number of books per compartment :param books: A list of integers representing the number of books in each compartment :return: True if it is possible to redistribute the books, otherwise False >>> can_redistribute_books(5, 5, [3, 8, 6, 2, 4]) True >>> can_redistribute_books(3, 2, [3, 1, 5]) False def solution(): import sys input = sys.stdin.read data = input().strip().split() n = int(data[0]) k = int(data[1]) books = list(map(int, data[2:])) if can_redistribute_books(n, k, books): print(\\"YES\\") else: print(\\"NO\\") def test_can_redistribute_books_yes(): assert can_redistribute_books(5, 5, [3, 8, 6, 2, 4]) == True assert can_redistribute_books(4, 4, [4, 4, 4, 4]) == True assert can_redistribute_books(3, 10, [3, 3, 3]) == True def test_can_redistribute_books_no(): assert can_redistribute_books(3, 2, [3, 1, 5]) == False assert can_redistribute_books(2, 1, [2, 2]) == False assert can_redistribute_books(4, 3, [4, 4, 4, 4]) == False def test_edge_cases(): assert can_redistribute_books(1, 1, [0]) == True assert can_redistribute_books(1, 1, [1]) == True assert can_redistribute_books(1, 1000000000, [1000000000]) == True assert can_redistribute_books(1000, 1000000000, [1000000000]*1000) == True from unittest.mock import patch import io def test_solution_yes(): with patch('sys.stdin.read', return_value='5 5n3 8 6 2 4n'): with patch('sys.stdout', new=io.StringIO()) as fake_stdout: solution() assert fake_stdout.getvalue().strip() == 'YES' def test_solution_no(): with patch('sys.stdin.read', return_value='3 2n3 1 5n'): with patch('sys.stdout', new=io.StringIO()) as fake_stdout: solution() assert fake_stdout.getvalue().strip() == 'NO'","solution":"def can_redistribute_books(n, k, books): Determines if it's possible to redistribute books so that no compartment exceeds the threshold k total_books = sum(books) max_possible_books_in_compartment = (total_books + n - 1) // n return max_possible_books_in_compartment <= k def solution(): import sys input = sys.stdin.read data = input().strip().split() n = int(data[0]) k = int(data[1]) books = list(map(int, data[2:])) if can_redistribute_books(n, k, books): print(\\"YES\\") else: print(\\"NO\\")"},{"question":"def decrypt_message(encrypted_message: str) -> str: Decrypts a message where each word has been reversed while keeping the order of words intact. >>> decrypt_message(\\"olleh\\") == \\"hello\\" >>> decrypt_message(\\"olleh dlrow\\") == \\"hello world\\" >>> decrypt_message(\\"dlrow olleh\\") == \\"world hello\\" >>> decrypt_message(\\"siht si a tset\\") == \\"this is a test\\" >>> decrypt_message(\\"a b c d\\") == \\"a b c d\\" >>> decrypt_message(\\"eman si yM\\") == \\"name is My\\" >>> decrypt_message(\\"a\\") == \\"a\\" >>> decrypt_message(\\"palindrome emordnilap\\") == \\"emordnilap palindrome\\"","solution":"def decrypt_message(encrypted_message): Decrypts a message where each word has been reversed while keeping the order of words intact. words = encrypted_message.split() decrypted_words = [word[::-1] for word in words] return ' '.join(decrypted_words) # Example usage # encrypted = \\"olleh dlrow\\" # print(decrypt_message(encrypted)) # Output: \\"hello world\\""},{"question":"def calculate_car(ratings): Calculate the Critical Average Rating (CAR) for a list of ratings. Args: ratings (list): List of integers representing the ratings. Returns: float: The CAR value rounded to two decimal places. pass def process_products(products): Process multiple products to find their CAR values. Args: products (list): List of tuples where each tuple contains the number of ratings and a list of ratings for a product. Returns: list: List of CAR values rounded to two decimal places for each product. pass def test_calculate_car_with_various_ratings(): assert calculate_car([1, 2, 3, 4, 5]) == 3.00 assert calculate_car([2, 3, 3, 3, 4, 5]) == 3.25 def test_calculate_car_with_same_ratings(): assert calculate_car([4, 4, 4, 4, 4]) == 4.00 def test_calculate_car_with_three_ratings(): assert calculate_car([3, 4, 5]) == 4.00 def test_process_products(): products = [ (5, [1, 2, 3, 4, 5]), (4, [4, 4, 4, 4]) ] assert process_products(products) == [3.00, 4.00] def test_process_products_with_various_ratings(): products = [ (3, [3, 4, 5]), (6, [2, 2, 3, 4, 4, 5]) ] assert process_products(products) == [4.00, 3.25]","solution":"def calculate_car(ratings): Calculate the Critical Average Rating (CAR) for a list of ratings. Args: ratings (list): List of integers representing the ratings. Returns: float: The CAR value rounded to two decimal places. # Sort the ratings to find the highest and lowest easily sorted_ratings = sorted(ratings) # If all ratings are the same, return their average if sorted_ratings[0] == sorted_ratings[-1]: return round(sum(ratings) / len(ratings), 2) # Remove the highest and lowest rating trimmed_ratings = sorted_ratings[1:-1] # Calculate the average of the remaining ratings car = sum(trimmed_ratings) / len(trimmed_ratings) return round(car, 2) def process_products(products): Process multiple products to find their CAR values. Args: products (list): List of tuples where each tuple contains the number of ratings and a list of ratings for a product. Returns: list: List of CAR values rounded to two decimal places for each product. car_values = [] for product in products: m, ratings = product[0], product[1] car = calculate_car(ratings) car_values.append(car) return car_values"},{"question":"from typing import List, Tuple def minimum_cost_to_bipartite(n: int, m: int, costs: List[int], edges: List[Tuple[int, int]]) -> int: You are given a connected undirected graph with \`n\` vertices and \`m\` edges. Each vertex has an initial cost associated with it. Your task is to remove the minimum number of vertices so that the remaining graph becomes a bipartite graph, i.e., it is possible to color the vertices in two colors such that no two adjacent vertices share the same color. The function should return the minimum possible sum of the costs of the removed vertices. If the graph is already bipartite, return 0. >>> minimum_cost_to_bipartite(4, 4, [1, 2, 3, 4], [(1, 2), (2, 3), (3, 4), (4, 1)]) 0 >>> minimum_cost_to_bipartite(5, 6, [1, 2, 3, 4, 5], [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1), (1, 3)]) 1 >>> minimum_cost_to_bipartite(3, 3, [10, 20, 30], [(1, 2), (2, 3), (3, 1)]) 10","solution":"def minimum_cost_to_bipartite(n, m, costs, edges): from collections import deque # Graph adjacency list graph = [[] for _ in range(n)] for u, v in edges: graph[u-1].append(v-1) graph[v-1].append(u-1) color = [-1] * n # -1 denotes uncolored def is_bipartite_and_get_costs(start): queue = deque([start]) color[start] = 0 cost_color0, cost_color1 = 0, 0 while queue: node = queue.popleft() if color[node] == 0: cost_color0 += costs[node] else: cost_color1 += costs[node] for neighbor in graph[node]: if color[neighbor] == -1: color[neighbor] = 1 - color[node] queue.append(neighbor) elif color[neighbor] == color[node]: return False, min(cost_color0, cost_color1) return True, 0 min_cost_to_remove = 0 for i in range(n): if color[i] == -1: bipartite, cost = is_bipartite_and_get_costs(i) if not bipartite: min_cost_to_remove += cost return min_cost_to_remove # The function expects inputs as follows: # n: number of vertices # m: number of edges # costs: list of costs associated with each vertex # edges: list of edges where each edge is a tuple (u, v) representing an edge between vertex u and vertex v"},{"question":"def min_light_posts(n: int, m: int, grid: List[str]) -> Union[int, str]: Returns the minimum number of light posts required to connect all houses to a market by light, or \\"impossible\\" if it is not possible. >>> min_light_posts(4, 4, ['H...', '....', '....', 'M..H']) == 3 >>> min_light_posts(4, 4, ['....', '....', '....', 'M..M']) == 0 >>> min_light_posts(4, 4, ['H...', 'H...', '....', 'H..H']) == \\"impossible\\" >>> min_light_posts(3, 3, ['H.M', '..H', 'M.H']) == 1 >>> min_light_posts(5, 5, ['H....', '.....', '.....', '.....', 'M...H']) == 4 pass","solution":"from collections import deque def min_light_posts(n, m, grid): Returns the minimum number of light posts required to connect all houses to a market by light, or \\"impossible\\" if it is not possible. houses = [(i, j) for i in range(n) for j in range(m) if grid[i][j] == 'H'] markets = [(i, j) for i in range(n) for j in range(m) if grid[i][j] == 'M'] if not houses or not markets: return 0 if not houses else \\"impossible\\" directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] def bfs(source, target): queue = deque([(source[0], source[1], 0)]) visited = set() visited.add((source[0], source[1])) while queue: x, y, steps = queue.popleft() if (x, y) == target: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] != 'H': queue.append((nx, ny, steps + 1)) visited.add((nx, ny)) return float('inf') min_posts_required = float('inf') for house in houses: nearest_market_distance = float('inf') for market in markets: distance = bfs(house, market) nearest_market_distance = min(nearest_market_distance, distance) if nearest_market_distance == float('inf'): return \\"impossible\\" min_posts_required = min(min_posts_required, nearest_market_distance) return min_posts_required # Input example # n, m = 4, 4 # grid = [ # \\"H...\\", # \\"....\\", # \\"....\\", # \\"M..H\\" # ] # # Output example # print(min_light_posts(n, m, grid)) # Output: 3"},{"question":"class LunarExploration: def __init__(self, n): Initializes an n x n matrix with all values set to 0. self.n = n self.matrix = [[0] * n for _ in range(n)] def update(self, x, y, z): Updates the altitude of the section at coordinates (x, y) to z. def query(self, x1, y1, x2, y2): Returns the minimum altitude in the submatrix from (x1, y1) to (x2, y2) inclusive. def process_queries(n, m, queries): Process multiple queries and return results for 'query' type queries. >>> process_queries(3, 5, [\\"u 1 2 5\\", \\"u 2 3 7\\", \\"q 1 1 2 3\\", \\"u 3 3 2\\", \\"q 1 1 3 3\\"]) [0, 0] >>> process_queries(1, 2, [\\"u 1 1 10\\", \\"q 1 1 1 1\\"]) [10]","solution":"class LunarExploration: def __init__(self, n): Initializes an n x n matrix with all values set to 0. self.n = n self.matrix = [[0] * n for _ in range(n)] def update(self, x, y, z): Updates the altitude of the section at coordinates (x, y) to z. self.matrix[x-1][y-1] = z def query(self, x1, y1, x2, y2): Returns the minimum altitude in the submatrix from (x1, y1) to (x2, y2) inclusive. min_altitude = float('inf') for i in range(x1-1, x2): for j in range(y1-1, y2): min_altitude = min(min_altitude, self.matrix[i][j]) return min_altitude def process_queries(n, m, queries): Process multiple queries and return results for 'query' type queries. lunar = LunarExploration(n) results = [] for query in queries: parts = query.split() if parts[0] == 'u': _, x, y, z = parts lunar.update(int(x), int(y), int(z)) elif parts[0] == 'q': _, x1, y1, x2, y2 = parts result = lunar.query(int(x1), int(y1), int(x2), int(y2)) results.append(result) return results"},{"question":"def arrange_balls(n: int, d: int, weights: List[int]) -> Union[List[int], str]: Arrange the weights of n juggling balls in such a way that the absolute difference between the weights of any two adjacent balls is at least d. If it is possible to arrange the balls, return a list of weights in the desired order. If it is impossible, return \\"Impossible\\". >>> arrange_balls(5, 2, [5, 3, 7, 10, 1]) [1, 3, 5, 7, 10] >>> arrange_balls(3, 4, [1, 2, 3]) \\"Impossible\\" >>> arrange_balls(1, 2, [1]) [1] >>> arrange_balls(4, 1, [1, 2, 3, 4]) [1, 2, 3, 4] >>> arrange_balls(3, 3, [1, 4, 7]) [1, 4, 7] >>> result = arrange_balls(4, 1, [4, 3, 2, 1]) >>> result in [[1, 2, 3, 4], [4, 3, 2, 1]] True pass","solution":"def arrange_balls(n, d, weights): Arrange the weights of n juggling balls in such a way that the absolute difference between the weights of any two adjacent balls is at least d. # Sort weights to make it easier to find a suitable sequence weights.sort() # Check if the sorted sequence meets the requirement for i in range(1, n): if abs(weights[i] - weights[i-1]) < d: return \\"Impossible\\" return weights"},{"question":"def find_minimum_buses(n: int, p: int, preferences: List[List[int]]) -> int: Determine the least number of buses required to accommodate everybody under the given constraints. Args: n : int : number of people p : int : maximum bus capacity preferences : List[List[int]] : list of friend preferences Returns: int: minimum number of buses required >>> find_minimum_buses(5, 3, [[2, 3], [4], [], [1], [2]]) 2 >>> find_minimum_buses(4, 2, [[2], [3], [4], []]) 2 >>> find_minimum_buses(7, 3, [[2, 3], [4], [5], [6], [7], [1], [2]]) 3 pass # Unit Test def test_find_minimum_buses(): assert find_minimum_buses(5, 3, [[2, 3], [4], [], [1], [2]]) == 2 assert find_minimum_buses(4, 2, [[2], [3], [4], []]) == 2 assert find_minimum_buses(7, 3, [[2, 3], [4], [5], [6], [7], [1], [2]]) == 3 assert find_minimum_buses(5, 5, [[2, 3], [4], [], [1], [2]]) == 1 assert find_minimum_buses(1, 1, [[]]) == 1 assert find_minimum_buses(6, 3, [[2, 3], [4, 5], [6], [1], [1], [1]]) == 2 test_find_minimum_buses()","solution":"def find_minimum_buses(n, p, preferences): from collections import deque, defaultdict adj_list = defaultdict(set) for i, friends in enumerate(preferences): for friend in friends: adj_list[i].add(friend - 1) adj_list[friend - 1].add(i) visited = [False] * n buses = 0 def bfs(start): queue = deque([start]) count = 0 while queue: node = queue.popleft() if visited[node]: continue visited[node] = True count += 1 for neighbor in adj_list[node]: if not visited[neighbor]: queue.append(neighbor) return count for person in range(n): if not visited[person]: group_size = bfs(person) buses += (group_size + p - 1) // p return buses"},{"question":"def roman_to_int(s: str) -> int: Convert a roman numeral string to an integer. :param s: str - Roman numeral string :return: int - Corresponding integer value Examples: >>> roman_to_int('III') 3 >>> roman_to_int('IV') 4 >>> roman_to_int('IX') 9 >>> roman_to_int('LVIII') 58 >>> roman_to_int('MCMXCIV') 1994","solution":"def roman_to_int(s): Convert a roman numeral string to an integer. :param s: str - Roman numeral string :return: int - Corresponding integer value # Dictionary mapping Roman numerals to their integer equivalents roman_numerals = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 } total = 0 prev_value = 0 # Traverse the string from right to left for char in reversed(s): value = roman_numerals[char] if value < prev_value: total -= value else: total += value prev_value = value return total"},{"question":"from typing import List def can_be_palindrome_with_removal(s: str) -> bool: Determines if the string can be made a palindrome by removing at most one character. >>> can_be_palindrome_with_removal(\\"abca\\") True >>> can_be_palindrome_with_removal(\\"racecar\\") True >>> can_be_palindrome_with_removal(\\"abcdefg\\") False >>> can_be_palindrome_with_removal(\\"deified\\") True pass def process_test_cases(test_cases: List[str]) -> List[str]: Processes multiple test cases to determine if each can be a palindrome after at most one removal. >>> test_cases = [\\"abca\\", \\"racecar\\", \\"abcdefg\\", \\"deified\\"] >>> process_test_cases(test_cases) [\\"YES\\", \\"YES\\", \\"NO\\", \\"YES\\"] pass","solution":"def can_be_palindrome_with_removal(s): Determines if the string can be made a palindrome by removing at most one character. def is_palindrome_range(s, left, right): while left < right: if s[left] != s[right]: return False left += 1 right -= 1 return True left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: return is_palindrome_range(s, left + 1, right) or is_palindrome_range(s, left, right - 1) left += 1 right -= 1 return True def process_test_cases(test_cases): result = [] for s in test_cases: if can_be_palindrome_with_removal(s): result.append(\\"YES\\") else: result.append(\\"NO\\") return result"},{"question":"def count_palindromic_substrings(s: str) -> int: Returns the number of contiguous palindromic substrings in the string s. >>> count_palindromic_substrings(\\"abba\\") 6 >>> count_palindromic_substrings(\\"racecar\\") 10","solution":"def count_palindromic_substrings(s): Returns the number of contiguous palindromic substrings in the string s. n = len(s) count = 0 dp = [[False]*n for _ in range(n)] for length in range(1, n+1): # length of substring for i in range(n-length+1): j = i + length - 1 if length == 1: dp[i][j] = True elif length == 2: dp[i][j] = (s[i] == s[j]) else: dp[i][j] = (s[i] == s[j] and dp[i+1][j-1]) if dp[i][j]: count += 1 return count"},{"question":"def days_to_max_height(n: int, heights: List[int]) -> int: Function to determine the number of days required to grow all plants to their respective maximum heights. Args: n (int): Number of plants in the garden heights (List[int]): List of maximum heights for each plant Returns: int: Number of days required for all plants to reach their maximum heights Example: >>> days_to_max_height(4, [3, 4, 2, 1]) 4 >>> days_to_max_height(3, [3, 3, 3]) 3 >>> days_to_max_height(1, [5]) 5 >>> days_to_max_height(3, [1, 1, 1]) 1 from solution import days_to_max_height def test_all_plants_have_same_height(): assert days_to_max_height(3, [3, 3, 3]) == 3 def test_different_heights(): assert days_to_max_height(4, [3, 4, 2, 1]) == 4 def test_single_plant(): assert days_to_max_height(1, [5]) == 5 def test_plants_with_minimum_height(): assert days_to_max_height(3, [1, 1, 1]) == 1 def test_max_limit(): n = 100000 heights = [1000000] * n assert days_to_max_height(n, heights) == 1000000 def test_large_numbers(): assert days_to_max_height(5, [500000, 600000, 700000, 800000, 900000]) == 900000","solution":"def days_to_max_height(n, heights): Function to determine the number of days required to grow all plants to their respective maximum heights. :param n: Number of plants :param heights: List of maximum heights for each plant :return: Number of days required for all plants to reach their maximum heights return max(heights)"},{"question":"def find_minimum_questions(n: int, questions: List[List[str]], interest_tags: List[str]) -> List[int]: Determine the minimum set of questions that cover all the user's interest tags. >>> n = 3 >>> questions = [[\\"python\\", \\"algorithms\\"], [\\"python\\", \\"databases\\"], [\\"algorithms\\", \\"databases\\"]] >>> interest_tags = [\\"python\\", \\"algorithms\\", \\"databases\\"] >>> find_minimum_questions(n, questions, interest_tags) [0, 1]","solution":"def find_minimum_questions(n, questions, interest_tags): from itertools import combinations # Convert interest_tags to a set for quicker lookup interest_tags_set = set(interest_tags) # Create a list of questions with their indices indexed_questions = [(i, set(tags)) for i, tags in enumerate(questions)] # Iterate over combinations of questions starting from size 1 to n for size in range(1, n + 1): for comb in combinations(indexed_questions, size): combined_tags = set() indices = [] for idx, tags in comb: combined_tags.update(tags) indices.append(idx) if interest_tags_set.issubset(combined_tags): return indices return [] # Example usage: # n = 4 # questions = [[\\"python\\", \\"algorithms\\"], [\\"python\\", \\"databases\\"], [\\"algorithms\\", \\"databases\\"], [\\"python\\", \\"algorithms\\", \\"databases\\"]] # interest_tags = [\\"python\\", \\"algorithms\\", \\"databases\\"] # print(find_minimum_questions(n, questions, interest_tags)) # Output could be [0, 1] or [1, 2] or any valid combination"},{"question":"from typing import List def maxCherries(grid: List[List[int]]) -> int: Given a grid of size n x n with some cells containing cherries, find the maximum number of cherries you can collect by following a path from the top-left corner (0, 0) to the bottom-right corner (n-1, n-1) and then back to the top-left corner. You can move either right or down during the first trip to the bottom-right corner and either left or up during the trip back to the top-left corner. Along the way, you should collect cherries from the cells. If you pass through a cell containing cherries, the cherries are collected and the cell becomes empty. >>> grid = [ ... [0, 1, -1], ... [1, 0, -1], ... [1, 1, 1] ... ] >>> maxCherries(grid) 5 >>> grid = [ ... [0, 0], ... [0, 0] ... ] >>> maxCherries(grid) 0 >>> grid = [ ... [0, 0], ... [1, 0] ... ] >>> maxCherries(grid) 1 >>> grid = [ ... [0, 1, -1, 0], ... [1, -1, 1, 1], ... [1, 1, -1, 1], ... [1, 1, 1, 1] ... ] >>> maxCherries(grid) 7 >>> grid = [ ... [-1, 1], ... [1, -1] ... ] >>> maxCherries(grid) 0","solution":"def maxCherries(grid): n = len(grid) memo = [[[-1 for _ in range(n)] for _ in range(n)] for _ in range(n)] def dp(r1, c1, r2): c2 = r1 + c1 - r2 if r1 >= n or r2 >= n or c1 >= n or c2 >= n or grid[r1][c1] == -1 or grid[r2][c2] == -1: return float('-inf') elif r1 == n-1 and c1 == n-1: return grid[r1][c1] elif memo[r1][c1][r2] != -1: return memo[r1][c1][r2] else: res = grid[r1][c1] if r1 != r2: # Avoid counting cherries twice if r1 == r2 and c1 == c2 res += grid[r2][c2] res += max( dp(r1+1, c1, r2+1), # Down, Down dp(r1+1, c1, r2), # Down, Right dp(r1, c1+1, r2+1), # Right, Down dp(r1, c1+1, r2) # Right, Right ) memo[r1][c1][r2] = res return res return max(0, dp(0, 0, 0))"},{"question":"from typing import List, Tuple from sympy import isprime def prime_subset(n: int) -> str: Determines if there exists a subset of the first N natural numbers such that the sum of the subset is a prime number. >>> prime_subset(5) 'YESn1 2 3 4 5' >>> prime_subset(10) 'YESn2 3 5' >>> prime_subset(1) 'NO'","solution":"from sympy import isprime def find_prime_subset(n): # Use the sum of the first n natural numbers formula total_sum = n * (n + 1) // 2 # Check if the sum is prime if isprime(total_sum): return (\\"YES\\", list(range(1, n + 1))) # Try to find subsets by excluding one number for i in range(1, n + 1): subset_sum = total_sum - i if isprime(subset_sum): return (\\"YES\\", [x for x in range(1, n + 1) if x != i]) # If no prime sum subset is found return (\\"NO\\", []) def prime_subset(n): status, subset = find_prime_subset(n) if status == \\"YES\\": return \\"YESn\\" + ' '.join(map(str, subset)) else: return \\"NO\\""},{"question":"def min_subarray_len(n: int, x: int, arr: List[int]) -> int: Returns the length of the minimum contiguous subarray with a sum >= x. If no such subarray exists, returns -1. >>> min_subarray_len(5, 11, [1, 2, 3, 4, 5]) 3 >>> min_subarray_len(3, 10, [1, 2, 3]) -1 >>> min_subarray_len(5, 1, [1, 2, 3, 4, 5]) 1 >>> min_subarray_len(3, 6, [2, 4, 1]) 2 >>> min_subarray_len(3, 10**9, [10**9, 10**8, 10**7]) 1 >>> min_subarray_len(7, 15, [1, 2, 3, 4, 10, 5, 6]) 2","solution":"def min_subarray_len(n, x, arr): Returns the length of the minimum contiguous subarray with a sum >= x. If no such subarray exists, returns -1. start = 0 current_sum = 0 min_length = float('inf') for end in range(n): current_sum += arr[end] while current_sum >= x: min_length = min(min_length, end - start + 1) current_sum -= arr[start] start += 1 return min_length if min_length != float('inf') else -1"},{"question":"def maximal_road_grid(n: int, m: int) -> (int, list): Returns the maximum number of roads that can be placed and one possible configuration. Args: n (int): number of rows m (int): number of columns Returns: (int, list of str): maximum number of roads and one possible configuration >>> maximal_road_grid(3, 3) (5, [\\"R.R\\", \\".R.\\", \\"R.R\\"]) >>> maximal_road_grid(2, 2) (2, [\\"R.\\", \\".R\\"]) >>> maximal_road_grid(1, 1) (1, [\\"R\\"]) >>> maximal_road_grid(4, 4) (8, [\\"R.R.\\", \\".R.R\\", \\"R.R.\\", \\".R.R\\"]) >>> maximal_road_grid(1, 5) (3, [\\"R.R.R\\"])","solution":"def maximal_road_grid(n, m): Returns the maximum number of roads that can be placed and one possible configuration. Args: n (int): number of rows m (int): number of columns Returns: (int, list of str): maximum number of roads and one possible configuration grid = [] road_count = 0 for i in range(n): row = [] for j in range(m): if (i + j) % 2 == 0: row.append(\\"R\\") road_count += 1 else: row.append(\\".\\") grid.append(\\"\\".join(row)) return road_count, grid # Example usage: n, m = 3, 3 road_count, grid = maximal_road_grid(n, m) print(road_count) print(\\"n\\".join(grid))"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def hasPathSum(root: TreeNode, targetSum: int) -> bool: Determine whether there exists a root-to-leaf path in the tree such that the sum of the values equals targetSum. Args: root (TreeNode): The root of the binary tree. targetSum (int): The target sum to check for the path. Returns: bool: True if there exists a path from root to leaf with sum equal to targetSum, False otherwise. >>> root = TreeNode(5) ... root.left = TreeNode(4) ... root.right = TreeNode(8) ... root.left.left = TreeNode(11) ... root.left.left.left = TreeNode(7) ... root.left.left.right = TreeNode(2) ... root.right.left = TreeNode(13) ... root.right.right = TreeNode(4) ... root.right.right.right = TreeNode(1) ... hasPathSum(root, 22) True >>> root = TreeNode(1) ... root.left = TreeNode(2) ... root.right = TreeNode(3) ... hasPathSum(root, 5) False >>> hasPathSum(None, 0) False pass","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def hasPathSum(root: TreeNode, targetSum: int) -> bool: if not root: return False if not root.left and not root.right: return root.val == targetSum targetSum -= root.val return hasPathSum(root.left, targetSum) or hasPathSum(root.right, targetSum)"},{"question":"def count_unique_strings(n: int, m: int) -> int: Generate the total number of unique strings of length n using the first m lowercase English alphabet letters, modulo 10^9 + 7. >>> count_unique_strings(3, 2) 8 >>> count_unique_strings(10**5, 1) 1 >>> count_unique_strings(10**5, 26) # Result for large inputs can be very large, ensure the implementation handles the modulo correctly.","solution":"def count_unique_strings(n, m): MOD = 10**9 + 7 return pow(m, n, MOD)"},{"question":"def generate_perfect_square_sequence(n: int) -> List[int]: Generates a sequence of length n where each element is a non-negative integer that is a perfect square and consecutive elements have minimal differences, in non-decreasing order. >>> generate_perfect_square_sequence(1) [0] >>> generate_perfect_square_sequence(5) [0, 1, 4, 9, 16] >>> generate_perfect_square_sequence(10) [0, 1, 4, 9, 16, 25, 36, 49, 64, 81] >>> generate_perfect_square_sequence(0) [] >>> generate_perfect_square_sequence(2) [0, 1]","solution":"def generate_perfect_square_sequence(n): Generates a sequence of length n where each element is a non-negative integer that is a perfect square and consecutive elements have minimal differences, in non-decreasing order. sequence = [i * i for i in range(n)] return sequence"},{"question":"def smallest_subarray_with_sum(arr, n, s): Determines the smallest subarray with a sum at least s. Parameters: arr (list): The list of integers. n (int): The number of elements in arr. s (int): The target sum. Returns: int: The length of the smallest subarray with a sum of at least s, or -1 if no such subarray exists. >>> smallest_subarray_with_sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10, 15) == 2 >>> smallest_subarray_with_sum([1, 1, 1, 1, 1], 5, 6) == -1 >>> smallest_subarray_with_sum([3, 1, 4, 2, 2], 5, 8) == 3 >>> smallest_subarray_with_sum([10], 1, 10) == 1 >>> smallest_subarray_with_sum([1, 2, 3, 4, 5], 5, 15) == 5 >>> smallest_subarray_with_sum([10000, 10000, 10000], 3, 20000) == 2 >>> smallest_subarray_with_sum([10, 5, 10, 2, 1], 5, 15) == 2 # Your code here","solution":"def smallest_subarray_with_sum(arr, n, s): Determines the smallest subarray with a sum at least s. Parameters: arr (list): The list of integers. n (int): The number of elements in arr. s (int): The target sum. Returns: int: The length of the smallest subarray with a sum of at least s, or -1 if no such subarray exists. min_length = float('inf') current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum >= s: min_length = min(min_length, end - start + 1) current_sum -= arr[start] start += 1 return min_length if min_length != float('inf') else -1"},{"question":"def decompose_number(n: int) -> List[int]: Decomposes the number n such that the difference between the maximum and minimum numbers in the resulting sequence is minimized. Each number in the sequence is between 1 and m (inclusive), where m is the floor of the square root of n. Parameters: n (int): The integer to decompose. Returns: list: The sequence of integers. import pytest from solution import decompose_number def test_decompose_example(): assert decompose_number(23) == [6, 6, 6, 5] def test_decompose_small_number(): assert decompose_number(1) == [1] def test_decompose_prime_number(): assert decompose_number(29) == [6, 6, 6, 6, 5] def test_decompose_large_number(): assert decompose_number(1000000) == [1000] * 1000 def test_decompose_even_split(): assert decompose_number(25) == [5, 5, 5, 5, 5] def test_decompose_power_of_two(): assert decompose_number(16) == [4, 4, 4, 4]","solution":"import math def decompose_number(n): Decomposes the number n such that the difference between the maximum and minimum numbers in the resulting sequence is minimized. Each number in the sequence is between 1 and m (inclusive), where m is the floor of the square root of n. Parameters: n (int): The integer to decompose. Returns: list: The sequence of integers. m = math.floor(math.sqrt(n)) quotient = n // m remainder = n % m result = [quotient + 1] * remainder + [quotient] * (m - remainder) return result"},{"question":"from typing import List, Tuple def max_sum_path(n: int, values: List[int], edges: List[Tuple[int, int]]) -> int: Find the maximum sum of values along any path in the tree. >>> max_sum_path(5, [3, 2, 1, 10, 1], [(1, 2), (1, 3), (3, 4), (3, 5)]) 16 >>> max_sum_path(1, [5], []) 5 >>> max_sum_path(2, [1, 2], [(1, 2)]) 3 >>> max_sum_path(4, [1, 2, 3, 4], [(1, 2), (2, 3), (3, 4)]) 10 >>> max_sum_path(4, [10, 1, 1, 1], [(1, 2), (1, 3), (1, 4)]) 12 pass","solution":"from collections import defaultdict import sys sys.setrecursionlimit(300000) def max_sum_path(n, values, edges): tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) def dfs(node, parent): max_single_path, max_top_path = values[node - 1], values[node - 1] for neighbor in tree[node]: if neighbor == parent: continue subpath_max_single, subpath_max_top = dfs(neighbor, node) max_top_path = max(max_top_path, max_single_path + subpath_max_single, subpath_max_top) max_single_path = max(max_single_path, values[node - 1] + subpath_max_single) return max_single_path, max_top_path overall_max_sum = -float('inf') for start_node in range(1, n + 1): overall_max_sum = max(overall_max_sum, dfs(start_node, -1)[1]) return overall_max_sum # Function to handle the input format and call the main function def main(): import sys input = sys.stdin.read data = input().strip().split() n = int(data[0]) values = list(map(int, data[1:n+1])) edges = [tuple(map(int, data[i:i + 2])) for i in range(n + 1, len(data), 2)] print(max_sum_path(n, values, edges))"},{"question":"from collections import deque from typing import List def shortest_path_maze(n: int, m: int, maze: List[str]) -> int: Determine the length of the shortest path in a maze from the top-left corner to the bottom-right corner. >>> shortest_path_maze(5, 5, [\\".....\\", \\".#.\\", \\".#.\\", \\".#.\\", \\".....\\"]) 8 >>> shortest_path_maze(3, 3, [\\".#.\\", \\".#.\\", \\".#.\\"]) -1","solution":"from collections import deque def shortest_path_maze(n, m, maze): def neighbors(x, y): for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and maze[nx][ny] == '.': yield nx, ny start = (0, 0) end = (n - 1, m - 1) queue = deque([(start, 0)]) # (position, distance) visited = set([start]) while queue: (x, y), dist = queue.popleft() if (x, y) == end: return dist for nx, ny in neighbors(x, y): if (nx, ny) not in visited: visited.add((nx, ny)) queue.append(((nx, ny), dist + 1)) return -1"},{"question":"def find_event_timestamp(n: int, m: int, logs: List[Tuple[int, int]]) -> int: Determine the first event that reaches the given number of unique participants. Args: n (int): The number of log entries. m (int): The number of unique participants needed to reach the event. logs (List[Tuple[int, int]]): A list of log entries, each with a user ID and a timestamp. Returns: int: The timestamp of the log entry when the number of unique participants first reaches m, or -1 if the number of unique participants never reaches m. Examples: >>> find_event_timestamp(7, 3, [(1, 100), (2, 200), (3, 300), (1, 400), (4, 500), (2, 600), (5, 700)]) 300 >>> find_event_timestamp(5, 6, [(1, 100), (2, 200), (3, 300), (1, 400), (4, 500)]) -1","solution":"def find_event_timestamp(n, m, logs): unique_participants = set() for user_id, timestamp in logs: unique_participants.add(user_id) if len(unique_participants) >= m: return timestamp return -1"},{"question":"def max_participants_at_any_checkpoint(n: int, intervals: List[Tuple[int, int]]) -> int: Determines the maximum number of participants present at any checkpoint at the same time. >>> max_participants_at_any_checkpoint(5, [(1, 5), (2, 6), (3, 7), (4, 8), (5, 9)]) 4 >>> max_participants_at_any_checkpoint(4, [(1, 3), (2, 5), (4, 6), (7, 9)]) 2 from typing import List, Tuple def test_example_1(): n = 5 intervals = [(1, 5), (2, 6), (3, 7), (4, 8), (5, 9)] assert max_participants_at_any_checkpoint(n, intervals) == 4 def test_example_2(): n = 4 intervals = [(1, 3), (2, 5), (4, 6), (7, 9)] assert max_participants_at_any_checkpoint(n, intervals) == 2 def test_single_participant(): n = 1 intervals = [(1, 2)] assert max_participants_at_any_checkpoint(n, intervals) == 1 def test_all_overlapping(): n = 3 intervals = [(1, 5), (2, 6), (3, 7)] assert max_participants_at_any_checkpoint(n, intervals) == 3 def test_no_overlap(): n = 3 intervals = [(1, 2), (3, 4), (5, 6)] assert max_participants_at_any_checkpoint(n, intervals) == 1 def test_large_ranges(): n = 2 intervals = [(1, 100000), (50000, 100000)] assert max_participants_at_any_checkpoint(n, intervals) == 2 def test_varied_intervals(): n = 6 intervals = [(1, 4), (2, 5), (1, 6), (3, 7), (6, 9), (5, 10)] assert max_participants_at_any_checkpoint(n, intervals) == 4","solution":"def max_participants_at_any_checkpoint(n, intervals): Determines the maximum number of participants present at any checkpoint at the same time. Args: n: int - The number of participants. intervals: List[Tuple[int, int]] - List of tuples where each tuple contains start and end times (si, ei) for each participant. Returns: int - The maximum number of participants present at any checkpoint at the same time. checkpoints = [0] * 100001 for start, end in intervals: checkpoints[start] += 1 checkpoints[end] -= 1 max_participants = 0 current_participants = 0 for checkpoint in checkpoints: current_participants += checkpoint if current_participants > max_participants: max_participants = current_participants return max_participants # Example usage: # participants = 5 # intervals = [(1, 5), (2, 6), (3, 7), (4, 8), (5, 9)] # result = max_participants_at_any_checkpoint(participants, intervals) # print(result) # Should return 4"},{"question":"def minimum_removals_to_lucky_line(t, test_cases): Given a number of test cases of student heights, determine the minimum number of students that need to be removed to ensure the heights never decrease between two consecutive students. Parameters: t (int): The number of test cases. test_cases (list of tuples): Each tuple contains n (the number of students) and a list of n integers representing the heights. Returns: List of integers representing the minimum number of removals for each test case. >>> minimum_removals_to_lucky_line(1, [(5, [1, 2, 3, 4, 5])]) [0] >>> minimum_removals_to_lucky_line(1, [(5, [5, 4, 3, 2, 1])]) [4]","solution":"def minimum_removals_to_lucky_line(t, test_cases): Given a number of test cases of student heights, determine the minimum number of students that need to be removed to ensure the heights never decrease between two consecutive students. Parameters: t (int): The number of test cases. test_cases (list of tuples): Each tuple contains n (the number of students) and a list of n integers representing the heights. Returns: List of integers representing the minimum number of removals for each test case. results = [] for case in test_cases: n, heights = case # Initialize the dp array where dp[i] is the length of the longest increasing subsequence # ending at index i dp = [1] * n for i in range(1, n): for j in range(i): if heights[i] >= heights[j]: dp[i] = max(dp[i], dp[j] + 1) longest_increasing_subsequence_length = max(dp) min_removals = n - longest_increasing_subsequence_length results.append(min_removals) return results"},{"question":"def max_min_alarm_volume(n: int, volumes: List[int]) -> int: Calculate the maximum possible minimum total alarm volume. Args: n (int): Number of rows in the grid. volumes (List[int]): Volumes of the alarms in each row. Returns: int: The maximum possible minimum total alarm volume. >>> max_min_alarm_volume(5, [3, 1, 4, 1, 5]) 2 >>> max_min_alarm_volume(1, [7]) 7 >>> max_min_alarm_volume(3, [4, 4, 4]) 4 >>> max_min_alarm_volume(4, [0, 0, 0, 5]) 1 >>> max_min_alarm_volume(5, [1, 1, 1, 1, 1]) 1 >>> max_min_alarm_volume(2, [10000, 20000]) 10000 >>> max_min_alarm_volume(3, [10000, 10000, 10000]) 10000","solution":"def max_min_alarm_volume(n, volumes): def can_distribute(min_vol): return sum(vol // min_vol for vol in volumes) >= n low, high = 1, max(volumes) while low <= high: mid = (low + high) // 2 if can_distribute(mid): low = mid + 1 else: high = mid - 1 return high"},{"question":"def find_shortest_route(n: int, roads: List[Tuple[int, int, int]]) -> int: Finds the shortest possible route that allows the group to visit each city exactly once and return to the starting city. Args: n (int): The number of cities. roads (List[Tuple[int, int, int]]): The list of tuples where each tuple contains three integers a, b, and c representing a direct road between city a and city b with length c. Returns: int: The length of the shortest possible route, or -1 if no such route exists. >>> find_shortest_route(1, []) 0 >>> find_shortest_route(4, [(1, 2, 10), (1, 3, 15), (1, 4, 20), (2, 3, 35), (2, 4, 25), (3, 4, 30)]) 80 >>> find_shortest_route(4, [(1, 2, 10), (1, 3, 15), (3, 4, 30)]) -1 >>> find_shortest_route(4, [(1, 2, 1), (1, 3, 1), (1, 4, 1), (2, 3, 1), (2, 4, 1), (3, 4, 1)]) 4 >>> find_shortest_route(4, [(1, 2, 1000000000), (1, 3, 1000000000), (1, 4, 1000000000), (2, 3, 1000000000), (2, 4, 1000000000), (3, 4, 1000000000)]) 4000000000","solution":"import itertools def find_shortest_route(n, roads): if n == 1: return 0 # Initialize the distance table with inf except the diagonal (self-loops) dist = [[float('inf')] * n for _ in range(n)] for i in range(n): dist[i][i] = 0 # Populate distance table for (a, b, c) in roads: dist[a-1][b-1] = c dist[b-1][a-1] = c # Generate all permutations of cities and find the shortest route cities = range(1, n) shortest_route = float('inf') for perm in itertools.permutations(cities): current_length = 0 current_path = [0] + list(perm) for i in range(len(current_path) - 1): current_length += dist[current_path[i]][current_path[i+1]] current_length += dist[current_path[-1]][0] # Return to start city shortest_route = min(shortest_route, current_length) return shortest_route if shortest_route < float('inf') else -1"},{"question":"def plot_size_and_count(m: int, n: int) -> (int, int): Determines the size \`k\` of the largest possible square plot and the number of such plots that fit within the m x n field. Args: m : int : the length of the field n : int : the width of the field Returns: (int, int) : a tuple containing the size \`k\` and the number of square plots Examples: >>> plot_size_and_count(8, 6) (2, 12) >>> plot_size_and_count(15, 10) (5, 6)","solution":"def plot_size_and_count(m, n): Determines the size \`k\` of the largest possible square plot and the number of such plots that fit within the m x n field. Args: m : int : the length of the field n : int : the width of the field Returns: (int, int) : a tuple containing the size \`k\` and the number of square plots from math import gcd k = gcd(m, n) num_plots = (m // k) * (n // k) return k, num_plots"},{"question":"from typing import List, Tuple, Union def minimum_fabric_length(outfit: str, fabric_inventory: List[Tuple[str, int]]) -> Union[int, str]: Determine if a specific outfit can be made given the fabric inventory. The function returns \\"Impossible\\" if the outfit can't be made, or the minimum total length of fabric used to create the outfit. >>> minimum_fabric_length(\\"ABCA\\", [(\\"A\\", 3), (\\"B\\", 2), (\\"C\\", 4), (\\"B\\", 1), (\\"A\\", 2)]) == 10 >>> minimum_fabric_length(\\"AA\\", [(\\"A\\", 1), (\\"A\\", 2)]) == 3 >>> minimum_fabric_length(\\"ABC\\", [(\\"A\\", 1), (\\"B\\", 2), (\\"C\\", 1)]) == 4 >>> minimum_fabric_length(\\"AAB\\", [(\\"A\\", 1), (\\"A\\", 1), (\\"B\\", 1), (\\"C\\", 2)]) == 3 >>> minimum_fabric_length(\\"AAB\\", [(\\"A\\", 1), (\\"A\\", 1), (\\"C\\", 2)]) == \\"Impossible\\" >>> minimum_fabric_length(\\"AAA\\", [(\\"A\\", 1), (\\"A\\", 1)]) == \\"Impossible\\" >>> minimum_fabric_length(\\"A\\", []) == \\"Impossible\\" >>> minimum_fabric_length(\\"AB\\", []) == \\"Impossible\\" >>> minimum_fabric_length(\\"\\", [(\\"A\\", 1), (\\"B\\", 2), (\\"C\\", 3)]) == 0","solution":"def minimum_fabric_length(outfit, fabric_inventory): from collections import defaultdict import heapq # Parse the fabric inventory into a dictionary fabric_dict = defaultdict(list) for fabric, length in fabric_inventory: fabric_dict[fabric].append(length) # Create a min-heap for each fabric type to optimize length usage for fabric in fabric_dict: heapq.heapify(fabric_dict[fabric]) total_length = 0 for fabric in outfit: if fabric_dict[fabric]: min_length = heapq.heappop(fabric_dict[fabric]) total_length += min_length else: return \\"Impossible\\" return total_length"},{"question":"def can_partition(arr: List[int], x: int, y: int) -> str: Determine if an array can be partitioned into two non-empty subarrays such that the sum of the elements in the first subarray is divisible by x and the sum of the elements in the second subarray is divisible by y. >>> can_partition([2, 4, 1, 3, 6], 3, 6) == \\"NO\\" >>> can_partition([6, 12, 9, 15], 6, 9) == \\"YES\\" # Unit Tests def test_simple_cases(): assert can_partition([2, 4, 1, 3, 6], 3, 6) == \\"NO\\" assert can_partition([6, 12, 9, 15], 6, 9) == \\"YES\\" def test_small_array(): assert can_partition([1, 2], 1, 1) == \\"YES\\" assert can_partition([1, 1], 2, 2) == \\"NO\\" def test_large_elements(): assert can_partition([1000000000, 1000000000, 1000000000], 1000000000, 1000000000) == \\"YES\\" assert can_partition([1000000000, 1], 1000000000, 1000000000) == \\"NO\\" def test_zero_conditions(): assert can_partition([3, 6, 9, 12], 0, 9) == \\"YES\\" assert can_partition([3, 6, 9, 12], 9, 0) == \\"YES\\" assert can_partition([3, 6, 9, 12], 0, 0) == \\"YES\\" def test_edge_cases(): assert can_partition([10**9]*100000, 10**9, 10**9) == \\"YES\\" assert can_partition([1, 2, 3, 4], 5, 6) == \\"NO\\"","solution":"def can_partition(arr, x, y): n = len(arr) if n < 2: return \\"NO\\" total_sum = sum(arr) prefix_sum = 0 for i in range(n - 1): # To ensure each subarray is non-empty, we iterate till n-1 prefix_sum += arr[i] suffix_sum = total_sum - prefix_sum if (x == 0 or prefix_sum % x == 0) and (y == 0 or suffix_sum % y == 0): return \\"YES\\" return \\"NO\\""},{"question":"def num_distinct_islands(grid: List[List[int]]) -> int: Find the number of distinct islands in the grid. >>> grid1 = [ ... \\"11000\\", ... \\"11000\\", ... \\"00100\\", ... \\"00011\\" ... ] >>> num_distinct_islands(grid1) 3 >>> grid2 = [ ... \\"11110\\", ... \\"11010\\", ... \\"11000\\", ... \\"00000\\" ... ] >>> num_distinct_islands(grid2) 1 >>> grid3 = [ ... \\"1100\\", ... \\"1000\\", ... \\"0001\\", ... \\"0111\\" ... ] >>> num_distinct_islands(grid3) 2","solution":"def num_distinct_islands(grid): from collections import deque def bfs(r, c, origin): q = deque([(r, c)]) island = [] directions = [(0,1), (1,0), (0,-1), (-1,0)] while q: x, y = q.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and grid[nx][ny] == '1' and (nx, ny) not in visited: visited.add((nx, ny)) q.append((nx, ny)) island.append((nx - origin[0], ny - origin[1])) return tuple(island) visited = set() distinct_islands = set() for r in range(len(grid)): for c in range(len(grid[0])): if grid[r][c] == '1' and (r, c) not in visited: visited.add((r, c)) island_shape = bfs(r, c, (r, c)) distinct_islands.add(island_shape) return len(distinct_islands)"},{"question":"def is_valid_parentheses(s): Function to check if the parentheses in the string are valid. >>> is_valid_parentheses(\\"()\\") == \\"YES\\" >>> is_valid_parentheses(\\"()[]{}\\") == \\"YES\\" >>> is_valid_parentheses(\\"(]\\") == \\"NO\\" >>> is_valid_parentheses(\\"([)]\\") == \\"NO\\" >>> is_valid_parentheses(\\"\\") == \\"YES\\" >>> is_valid_parentheses(\\"{[]}\\") == \\"YES\\" >>> is_valid_parentheses(\\"[(])\\") == \\"NO\\" >>> is_valid_parentheses(\\"[\\") == \\"NO\\" >>> is_valid_parentheses(\\"]\\") == \\"NO\\" # Your code here def process_test_cases(t, test_cases): Process multiple test cases to check if the parentheses in each string are valid. >>> process_test_cases(4, [\\"()\\", \\"()[]{}\\", \\"(]\\", \\"([)]\\"]) == [\\"YES\\", \\"YES\\", \\"NO\\", \\"NO\\"] >>> process_test_cases(5, [\\"\\", \\"{[]}\\", \\"[(])\\", \\"[\\", \\"]\\"]) == [\\"YES\\", \\"YES\\", \\"NO\\", \\"NO\\", \\"NO\\"] # Your code here","solution":"def is_valid_parentheses(s): Function to check if the parentheses in the string are valid. stack = [] mapping = {')': '(', '}': '{', ']': '['} for char in s: if char in mapping: top_element = stack.pop() if stack else '#' if mapping[char] != top_element: return \\"NO\\" else: stack.append(char) return \\"YES\\" if not stack else \\"NO\\" def process_test_cases(t, test_cases): results = [] for case in test_cases: results.append(is_valid_parentheses(case)) return results"},{"question":"def can_handle_operations(n, m, operations): Determines if the system can handle all operations without exceeding upload or download limits. Parameters: n (int): The number of users. m (int): The maximum capacity for uploads and downloads per time unit. operations (list of tuples): A list of tuples where each tuple (u, d) represents upload and download operation by each user. Returns: str: \\"YES\\" if the system can handle all operations, otherwise \\"NO\\". from solution import can_handle_operations def test_can_handle_operations_case1(): assert can_handle_operations(3, 5000, [(1000, 2000), (2000, 1500), (1500, 1000)]) == \\"YES\\" def test_can_handle_operations_case2(): assert can_handle_operations(2, 3000, [(2500, 1000), (600, 2500)]) == \\"NO\\" def test_can_handle_operations_case3(): assert can_handle_operations(4, 10000, [(3000, 2000), (2000, 3000), (1500, 1500), (2000, 1500)]) == \\"YES\\" def test_can_handle_operations_case4(): assert can_handle_operations(1, 2000, [(1000, 3000)]) == \\"NO\\" def test_can_handle_operations_case5(): assert can_handle_operations(5, 6000, [(1000, 1000), (1000, 1500), (1500, 1000), (1000, 1500), (500, 1000)]) == \\"YES\\"","solution":"def can_handle_operations(n, m, operations): Determines if the system can handle all operations without exceeding upload or download limits. Parameters: n (int): The number of users. m (int): The maximum capacity for uploads and downloads per time unit. operations (list of tuples): A list of tuples where each tuple (u, d) represents upload and download operation by each user. Returns: str: \\"YES\\" if the system can handle all operations, otherwise \\"NO\\". total_upload = sum(op[0] for op in operations) total_download = sum(op[1] for op in operations) if total_upload <= m and total_download <= m: return \\"YES\\" else: return \\"NO\\""},{"question":"def max_non_overlapping_performances(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]: Determine the maximum number of non-overlapping performances that can be included in the festival program. >>> max_non_overlapping_performances(2, [(3, [(1, 3), (2, 5), (4, 6)]), (4, [(1, 2), (2, 3), (3, 4), (4, 5)])]) [2, 4] >>> max_non_overlapping_performances(1, [(3, [(1, 2), (3, 4), (5, 6)])]) [3] def parse_input(input_str: str) -> Tuple[int, List[Tuple[int, List[Tuple[int, int]]]]]: Parse the input string and return the number of test cases and the list of test cases. >>> parse_input(\\"2n3n1 3n2 5n4 6n4n1 2n2 3n3 4n4 5\\") (2, [(3, [(1, 3), (2, 5), (4, 6)]), (4, [(1, 2), (2, 3), (3, 4), (4, 5)])])","solution":"def max_non_overlapping_performances(t, test_cases): results = [] for case in test_cases: n, performances = case performances.sort(key=lambda x: x[1]) # Sort by end time count = 0 last_end_time = 0 for start, end in performances: if start >= last_end_time: count += 1 last_end_time = end results.append(count) return results def parse_input(input_str): lines = input_str.split('n') t = int(lines[0]) test_cases = [] index = 1 for _ in range(t): n = int(lines[index]) index += 1 performances = [] for _ in range(n): s, e = map(int, lines[index].split()) performances.append((s, e)) index += 1 test_cases.append((n, performances)) return t, test_cases"},{"question":"def final_value(arr): Returns the final value after performing the operations on the array until no more operations can be performed. >>> final_value([2, 3, 4]) 24 >>> final_value([1, 2, 3, 4]) 24","solution":"def final_value(arr): Returns the final value after performing the operations on the array until no more operations can be performed. product = 1 for num in arr: product *= num return product"},{"question":"def minimal_rounds(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determines the minimal number of rounds required so that only one player remains in the tournament for each test case. Parameters: t (int): The number of test cases. test_cases (list of tuples): List of tuples, where each tuple contains an integer n and a list of integers representing the skill levels of the players. Returns: list of int: A list containing the minimal number of rounds required for each test case. Example: >>> minimal_rounds(2, [(3, [1, 2, 3]), (5, [1, 1, 1, 1, 1])]) [2, 4] >>> minimal_rounds(1, [(4, [5, 5, 5, 5])]) [3]","solution":"def minimal_rounds(t, test_cases): Determines the minimal number of rounds required so that only one player remains in the tournament for each test case. Parameters: t (int): The number of test cases. test_cases (list of tuples): List of tuples, where each tuple contains an integer n and a list of integers representing the skill levels of the players. Returns: list of int: A list containing the minimal number of rounds required for each test case. results = [] for n, skill_levels in test_cases: # The number of rounds needed to get from n players to 1 player is n - 1 results.append(n - 1) return results"},{"question":"def max_distinct_characters(n: int, s: str) -> int: Determines the maximum number of distinct characters across all substrings when the string \`s\` is split into non-empty contiguous substrings such that each substring contains unique characters. Parameters: n (int): The length of the string s. s (str): A string of lowercase English letters. Returns: int: The maximum number of distinct characters. from solution import max_distinct_characters def test_example_case(): assert max_distinct_characters(4, \\"abac\\") == 3 def test_single_character(): assert max_distinct_characters(1, \\"a\\") == 1 def test_all_unique_characters(): assert max_distinct_characters(5, \\"abcde\\") == 5 def test_all_identical_characters(): assert max_distinct_characters(4, \\"aaaa\\") == 1 def test_mixed_characters(): assert max_distinct_characters(7, \\"aabcdea\\") == 5 def test_empty_string(): assert max_distinct_characters(0, \\"\\") == 0","solution":"def max_distinct_characters(n, s): Determines the maximum number of distinct characters across all substrings when the string \`s\` is split into non-empty contiguous substrings such that each substring contains unique characters. Parameters: n (int): The length of the string s. s (str): A string of lowercase English letters. Returns: int: The maximum number of distinct characters. if n == 0: return 0 unique_characters = set() substring_chars = set() for ch in s: if ch in substring_chars: unique_characters.update(substring_chars) substring_chars = set() substring_chars.add(ch) unique_characters.update(substring_chars) return len(unique_characters)"},{"question":"def process_queries(n: int, a: List[int], queries: List[List[int]]) -> List[int]: Perform a series of range sum queries and element updates on a sequence of integers. The function takes in the number of integers n, the sequence a of n integers, and a list of queries. Each query is either a range sum query or an update element query. The function returns the results of the range sum queries. >>> process_queries(5, [1, 2, 3, 4, 5], [[1, 2, 4], [2, 3, 10], [1, 2, 4], [2, 5, 20], [1, 1, 5]]) [9, 16, 37] >>> process_queries(1, [100], [[1, 1, 1], [2, 1, 200], [1, 1, 1]]) [100, 200] pass # Sample Test def test_example(): n = 5 a = [1, 2, 3, 4, 5] queries = [ [1, 2, 4], [2, 3, 10], [1, 2, 4], [2, 5, 20], [1, 1, 5] ] expected_output = [9, 16, 37] assert process_queries(n, a, queries) == expected_output def test_single_element(): n = 1 a = [100] queries = [ [1, 1, 1], # sum of the only element [2, 1, 200], # update the only element [1, 1, 1] # sum of the updated element ] expected_output = [100, 200] assert process_queries(n, a, queries) == expected_output def test_large_range_sum(): n = 6 a = [1, 2, 3, 4, 5, 6] queries = [ [1, 1, 6], # sum of all elements [2, 4, 10], # update index 4 [1, 1, 6] # sum of all elements after update ] expected_output = [21, 27] assert process_queries(n, a, queries) == expected_output def test_multiple_updates(): n = 4 a = [1, 1, 1, 1] queries = [ [2, 2, 2], # update index 2 to 2 [2, 3, 3], # update index 3 to 3 [1, 1, 4] # sum of all elements ] expected_output = [7] assert process_queries(n, a, queries) == expected_output","solution":"class SegmentTree: def __init__(self, data): self.n = len(data) self.tree = [0] * (2 * self.n) self.build(data) def build(self, data): # Insert leaf nodes in the tree array for i in range(self.n): self.tree[self.n + i] = data[i] # Build the tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1] def update(self, index, value): # Set value at position index pos = index + self.n self.tree[pos] = value while pos > 1: pos //= 2 self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1] def range_sum(self, left, right): # Get sum of elements in the range [left, right) left += self.n right += self.n sum_ = 0 while left < right: if left % 2: sum_ += self.tree[left] left += 1 if right % 2: right -= 1 sum_ += self.tree[right] left //= 2 right //= 2 return sum_ def process_queries(n, a, queries): seg_tree = SegmentTree(a) results = [] for query in queries: if query[0] == 1: l, r = query[1] - 1, query[2] result = seg_tree.range_sum(l, r) results.append(result) elif query[0] == 2: p, x = query[1] - 1, query[2] seg_tree.update(p, x) return results"},{"question":"def can_allocate_projects(m: int, n: int, p: int, projects: List[Tuple[int, int]]) -> str: Given the number of months, number of employees, number of projects, and the start and end months of each project, determine if it is possible to assign all the projects such that no employee works on multiple projects simultaneously. >>> can_allocate_projects(6, 3, 4, [(1, 3), (2, 4), (3, 6), (5, 6)]) 'Yes' >>> can_allocate_projects(6, 2, 4, [(1, 3), (2, 4), (3, 6), (5, 6)]) 'No' >>> can_allocate_projects(4, 1, 4, [(1, 1), (1, 1), (1, 1), (1, 1)]) 'No' >>> can_allocate_projects(6, 3, 3, [(1, 2), (2, 3), (3, 4)]) 'Yes' >>> can_allocate_projects(100, 20, 20, [(i, i+4) for i in range(1, 21)]) 'Yes'","solution":"def can_allocate_projects(m, n, p, projects): # Dictionary to keep track of the end month for each employee employee_end_month = [-1] * n # Sort projects by their end month projects.sort(key=lambda x: x[1]) for project in projects: start, end = project allocated = False for i in range(n): # Check if employee i is available for the current project if employee_end_month[i] < start: employee_end_month[i] = end allocated = True break # If no employee could take the project, return \\"No\\" if not allocated: return \\"No\\" return \\"Yes\\""},{"question":"def count_inversions(arr): Function to count the number of inversions in the array. # Unit Tests def test_no_inversions(): assert count_inversions([1, 2, 3, 4, 5]) == 0 def test_all_reversed(): assert count_inversions([5, 4, 3, 2, 1]) == 10 def test_some_inversions(): assert count_inversions([2, 3, 8, 6, 1]) == 5 def test_single_element(): assert count_inversions([1]) == 0 def test_empty_array(): assert count_inversions([]) == 0 def test_duplicates(): assert count_inversions([1, 3, 2, 3, 1]) == 4","solution":"def count_inversions(arr): Function to count the number of inversions in the array. if not arr: return 0 n = len(arr) temp_arr = [0]*n return _merge_sort(arr, temp_arr, 0, n-1) def _merge_sort(arr, temp_arr, left, right): Utility function to perform mergesort and count inversions. inv_count = 0 if left < right: mid = (left + right)//2 inv_count += _merge_sort(arr, temp_arr, left, mid) inv_count += _merge_sort(arr, temp_arr, mid+1, right) inv_count += _merge(arr, temp_arr, left, mid, right) return inv_count def _merge(arr, temp_arr, left, mid, right): Utility function to merge two halves and count inversions. i = left # Starting index for left subarray j = mid + 1 # Starting index for right subarray k = left # Starting index to be sorted inv_count = 0 while i <= mid and j <= right: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: temp_arr[k] = arr[j] inv_count += (mid-i + 1) j += 1 k += 1 while i <= mid: temp_arr[k] = arr[i] i += 1 k += 1 while j <= right: temp_arr[k] = arr[j] j += 1 k += 1 for i in range(left, right + 1): arr[i] = temp_arr[i] return inv_count"},{"question":"def min_seats_required(n: int) -> int: Calculates the minimum number of seats required such that no two students are sitting next to each other. :param n: int: The number of students :return: int: The minimum number of seats required pass # Example usage print(min_seats_required(1)) # Output: 1 print(min_seats_required(5)) # Output: 9 print(min_seats_required(3)) # Output: 5","solution":"def min_seats_required(n): Returns the minimum number of seats required to seat all students such that there is at least one empty seat between any two students. :param n: int: The number of students :return: int: The minimum number of seats required # Since there needs to be at least one empty seat between any two students, # the minimum number of seats required is 2 * n - 1. return 2 * n - 1 # Example usage print(min_seats_required(1)) # Output: 1 print(min_seats_required(5)) # Output: 9 print(min_seats_required(3)) # Output: 5"},{"question":"from typing import List, Tuple def compute_max_photos(H: int, W: int, n: int, photos: List[Tuple[int, int]]) -> int: Determine the maximum possible number of photos that can fit inside a grid of size H x W. Args: H (int): The height of the grid. W (int): The width of the grid. n (int): The number of photos. photos (List[Tuple[int, int]]): A list of tuples representing the height and width of the photos. Returns: int: The maximum number of photos that can be placed inside the grid. Examples: >>> compute_max_photos(5, 5, 3, [(1, 2), (2, 2), (3, 3)]) 3 >>> compute_max_photos(10, 10, 1, [(10, 10)]) 1 >>> compute_max_photos(2, 2, 3, [(3, 3), (4, 4), (5, 5)]) 0 >>> compute_max_photos(3, 3, 4, [(1, 1), (1, 1), (1, 1), (1, 1)]) 4 >>> compute_max_photos(6, 6, 4, [(2, 2), (2, 2), (3, 3), (1, 1)]) 4 pass","solution":"def compute_max_photos(H, W, n, photos): grid = [[0] * W for _ in range(H)] def can_place_photo(h, w, i, j): if i + h > H or j + w > W: return False for x in range(i, i + h): for y in range(j, j + w): if grid[x][y] != 0: return False return True def place_photo(h, w, i, j): for x in range(i, i + h): for y in range(j, j + w): grid[x][y] = 1 photos_sorted = sorted(photos, key=lambda x: (x[0] * x[1]), reverse=True) placed_count = 0 for h, w in photos_sorted: placed = False for i in range(H): if placed: break for j in range(W): if can_place_photo(h, w, i, j): place_photo(h, w, i, j) placed_count += 1 placed = True break return placed_count def main(): import sys input = sys.stdin.read data = input().split() H = int(data[0]) W = int(data[1]) n = int(data[2]) photos = [] index = 3 for _ in range(n): h = int(data[index]) w = int(data[index + 1]) photos.append((h, w)) index += 2 max_photos = compute_max_photos(H, W, n, photos) print(max_photos)"},{"question":"from typing import List, Tuple def can_place_trees(t: int, cases: List[Tuple[int, int, int]]) -> List[Tuple[str, List[List[str]]]]: Determines if it is possible to place exactly k trees in the garden under the given constraints and if yes, provide one possible arrangement. :param t: Number of test cases :param cases: List of tuples, each containing (n, m, k) :return: List of tuples for each test case. Each tuple contains: - \\"YES\\"/\\"NO\\" indicating if the arrangement is possible. - A list of lists representing the garden grid if arrangement is possible. Example: >>> can_place_trees(3, [(3, 3, 4), (4, 4, 16), (5, 5, 13)]) [('YES', [['T', '.', 'T'], ['.', 'T', '.'], ['T', '.', 'T']]), ('NO', []), ('YES', [['T', '.', 'T', '.', 'T'], ['.', 'T', '.', 'T', '.'], ['T', '.', 'T', '.', 'T'], ['.', 'T', '.', 'T', '.'], ['T', '.', 'T', '.', 'T']])] def test_case_1(): result = can_place_trees(3, [(3, 3, 4), (4, 4, 16), (5, 5, 13)]) assert result[0][0] == \\"YES\\" assert result[1][0] == \\"NO\\" assert result[2][0] == \\"YES\\" # Further checks on grid structure can be added def test_case_2(): result = can_place_trees(1, [(2, 2, 2)]) assert result == [(\\"YES\\", [['T', '.'], ['.', 'T']])] def test_case_3(): result = can_place_trees(1, [(1, 1, 1)]) assert result == [(\\"YES\\", [['T']])] def test_case_4(): result = can_place_trees(1, [(1, 1, 0)]) assert result == [(\\"YES\\", [['.']])] def test_case_5(): result = can_place_trees(1, [(5, 5, 13)]) assert result[0][0] == \\"YES\\" # Check for grid validity grid = result[0][1] tree_count = sum(row.count('T') for row in grid) assert tree_count == 13 for i in range(5): for j in range(5): if grid[i][j] == 'T': # check neighbors if i > 0: assert grid[i - 1][j] != 'T' if i < 4: assert grid[i + 1][j] != 'T' if j > 0: assert grid[i][j - 1] != 'T' if j < 4: assert grid[i][j + 1] != 'T'","solution":"def can_place_trees(t, cases): results = [] for n, m, k in cases: # For the condition, we will use a checkerboard pattern max_trees = (n * m + 1) // 2 if k > max_trees: results.append((\\"NO\\", [])) else: grid = [['.' for _ in range(m)] for _ in range(n)] count = 0 for i in range(n): for j in range(m): if (i + j) % 2 == 0 and count < k: grid[i][j] = 'T' count += 1 results.append((\\"YES\\", grid)) return results"},{"question":"def find_min_max(n: int, q: int, a: List[int], queries: List[Tuple[int, int]]) -> List[Tuple[int, int]]: For each query, finds the minimum and maximum elements in the specified subarray. Parameters: n (int): The length of the array. q (int): The number of queries. a (list): The array of integers. queries (list): List of tuples where each tuple contains two integers L and R. Returns: list: A list of tuples, each containing the minimum and maximum elements for each query. Examples: >>> find_min_max(5, 3, [1, 3, -2, 8, 5], [(1, 3), (2, 4), (1, 5)]) [(-2, 3), (-2, 8), (-2, 8)] >>> find_min_max(5, 3, [1, 3, -2, 8, 5], [(1, 1), (3, 3), (5, 5)]) [(1, 1), (-2, -2), (5, 5)]","solution":"def find_min_max(n, q, a, queries): For each query, finds the minimum and maximum elements in the specified subarray. Parameters: n (int): The length of the array. q (int): The number of queries. a (list): The array of integers. queries (list): List of tuples where each tuple contains two integers L and R. Returns: list: A list of tuples, each containing the minimum and maximum elements for each query. results = [] for L, R in queries: subarray = a[L-1:R] min_val = min(subarray) max_val = max(subarray) results.append((min_val, max_val)) return results"},{"question":"from typing import List def max_problems_solved(m: int, n: int, difficulties: List[int], skills: List[int]) -> int: Determine the maximum number of problems that can be solved by any single participant. Args: m (int): The number of participants. n (int): The number of problems. difficulties (List[int]): The difficulty levels of the problems. skills (List[int]): The skill levels of the participants. Returns: int: The maximum number of problems that can be solved by any single participant. Examples: >>> max_problems_solved(3, 5, [4, 8, 2, 6, 7], [5, 10, 3]) 5 >>> max_problems_solved(1, 1, [3], [5]) 1 >>> max_problems_solved(1, 1, [3], [1]) 0 >>> max_problems_solved(3, 5, [4, 8, 2, 6, 7], [5, 5, 5]) 2 >>> max_problems_solved(3, 2, [3, 12], [15, 10, 5]) 2 >>> max_problems_solved(3, 2, [3, 12], [2, 2, 1]) 0 >>> max_problems_solved(4, 5, [1, 2, 3, 4, 5], [5, 5, 5, 5]) 5 >>> max_problems_solved(4, 5, [10, 20, 30, 40, 50], [1, 2, 3, 4]) 0 pass","solution":"def max_problems_solved(m, n, difficulties, skills): maximum_problems = 0 for skill in skills: count = sum(1 for difficulty in difficulties if skill >= difficulty) maximum_problems = max(maximum_problems, count) return maximum_problems"},{"question":"def is_path_possible(n: int, m: int, grid: List[str]) -> str: Determines if there is a path from the top-left cell (1, 1) to the bottom-right cell (n, m) in a grid where walls are represented by '#' and free spaces by '.'. Args: n (int): The number of rows in the grid. m (int): The number of columns in the grid. grid (List[str]): The grid itself as a list of strings. Returns: str: \\"YES\\" if a path exists, \\"NO\\" otherwise. >>> is_path_possible(5, 5, [\\".....\\", \\".#.#.\\", \\".#.#.\\", \\".#.#.\\", \\".....\\"]) 'YES' >>> is_path_possible(5, 5, [\\".#...\\", \\".#.#.\\", \\".#.#.\\", \\"#..\\", \\".....\\"]) 'NO'","solution":"def is_path_possible(n, m, grid): from collections import deque # Directions for moving in the grid: Up, Down, Left, Right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # BFS Initialization queue = deque([(0, 0)]) visited = set() visited.add((0, 0)) while queue: x, y = queue.popleft() # Check if we have reached the bottom-right if (x, y) == (n - 1, m - 1): return \\"YES\\" # Explore neighbors for dx, dy in directions: nx, ny = x + dx, y + dy # Check boundaries and wall if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] == \\".\\": visited.add((nx, ny)) queue.append((nx, ny)) return \\"NO\\""},{"question":"def max_crystals_collected(m: int, n: int, grid: List[List[int]]) -> int: In a magical land, there are enchantress sisters Tessa and Elara. They found a magical garden represented as a grid of size m  n, with each cell containing a certain number of magic crystals. Tessa and Elara want to walk from the top-left corner to the bottom-right corner of the garden in such a way that they collect the maximum number of crystals. They can only move either down or right at any point in time. Given the grid, this function will help Tessa and Elara determine the maximum number of magic crystals they can collect on their way to the bottom-right corner. >>> max_crystals_collected(3, 3, [[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 12 >>> max_crystals_collected(2, 2, [[1, 2], [1, 1]]) 4 >>> max_crystals_collected(3, 4, [[1, 3, 1, 2], [1, 5, 1, 1], [4, 2, 1, 3]]) 15 >>> max_crystals_collected(4, 4, [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]) 73 >>> max_crystals_collected(1, 1, [[8]]) 8 >>> max_crystals_collected(1, 5, [[1, 2, 3, 4, 5]]) 15 >>> max_crystals_collected(5, 1, [[1], [2], [3], [4], [5]]) 15","solution":"def max_crystals_collected(m, n, grid): # Create a 2D list to store the maximum crystals collected up to each cell dp = [[0]*n for _ in range(m)] # Initialize the starting point dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column (can only come from above) for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the remaining cells for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The bottom-right cell contains the maximum crystals collected return dp[m-1][n-1]"}]`),S={name:"App",components:{PoemCard:j},data(){return{searchQuery:"",visibleCount:4,poemsData:E,isLoading:!1}},computed:{filteredPoems(){const n=this.searchQuery.trim().toLowerCase();return n?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(n)||e.solution&&e.solution.toLowerCase().includes(n)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(n=>setTimeout(n,1e3)),this.visibleCount+=4,this.isLoading=!1}}},A={class:"search-container"},z={class:"card-container"},D={key:0,class:"empty-state"},Y=["disabled"],P={key:0},O={key:1};function C(n,e,u,c,r,a){const f=h("PoemCard");return s(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"prompts chat")])],-1)),t("div",A,[e[3]||(e[3]=t("span",{class:"search-icon"},"",-1)),g(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>r.searchQuery=o),placeholder:"Search..."},null,512),[[b,r.searchQuery]]),r.searchQuery?(s(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>r.searchQuery="")},"  ")):l("",!0)]),t("div",z,[(s(!0),i(y,null,x(a.displayedPoems,(o,p)=>(s(),v(f,{key:p,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(s(),i("div",D,' No results found for "'+_(r.searchQuery)+'". ',1)):l("",!0)]),a.hasMorePoems?(s(),i("button",{key:0,class:"load-more-button",disabled:r.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[r.isLoading?(s(),i("span",O,"Loading...")):(s(),i("span",P,"See more"))],8,Y)):l("",!0)])}const I=d(S,[["render",C],["__scopeId","data-v-1175a18e"]]),M=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"guide/40.md","filePath":"guide/40.md"}'),F={name:"guide/40.md"},G=Object.assign(F,{setup(n){return(e,u)=>(s(),i("div",null,[w(I)]))}});export{M as __pageData,G as default};
